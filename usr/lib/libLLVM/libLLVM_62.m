uint64_t sub_1CD65AC68(uint64_t result, __int16 a2, __int16 a3)
{
  *(_WORD *)(result + 8) |= a3;
  *(_WORD *)(result + 10) |= a2;
  return result;
}

uint64_t sub_1CD65AC84(uint64_t result, __int16 a2, __int16 a3)
{
  *(_WORD *)(result + 8) &= a3;
  *(_WORD *)(result + 10) &= a2;
  return result;
}

void sub_1CD65ACA4()
{
}

uint64_t sub_1CD65ACB8(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_1CD65ACC0(uint64_t a1)
{
  return a1 + 32;
}

void sub_1CD65ACC8(char *a1@<X8>)
{
  a1[23] = 20;
  strcpy(a1, "AAValueConstantRange");
}

void *sub_1CD65ACF4()
{
  return &llvm::AAValueConstantRange::ID;
}

BOOL sub_1CD65AD00(uint64_t a1)
{
  return *(_DWORD *)(a1 + 8) && !llvm::ConstantRange::isFullSet((const void **)(a1 + 16));
}

BOOL sub_1CD65AD30(uint64_t a1)
{
  return sub_1CC8DD0F0(a1 + 16, (const void **)(a1 + 48));
}

uint64_t sub_1CD65AD40(uint64_t a1)
{
  return 0;
}

uint64_t sub_1CD65AD64(uint64_t a1)
{
  return 0;
}

void *sub_1CD65AD88(void *a1)
{
  *a1 = &unk_1F26245C0;
  uint64_t v2 = (uint64_t)(a1 + 2);
  sub_1CC05EB8C((uint64_t)(a1 + 6));
  sub_1CC05EB8C(v2);
  return a1;
}

void sub_1CD65ADDC(void *a1)
{
  *a1 = &unk_1F26245C0;
  uint64_t v1 = (uint64_t)(a1 + 2);
  sub_1CC05EB8C((uint64_t)(a1 + 6));
  sub_1CC05EB8C(v1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD65AE50(uint64_t a1, llvm::ConstantRange *a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = a1 + 16;
  llvm::ConstantRange::intersectWith(a1 + 16, a2, 0, (uint64_t)v6);
  sub_1CC149928(v4, (uint64_t)v6);
  sub_1CC05EB8C((uint64_t)v6);
  v3 += 48;
  llvm::ConstantRange::intersectWith(v3, a2, 0, (uint64_t)v6);
  sub_1CC149928(v3, (uint64_t)v6);
  return sub_1CC05EB8C((uint64_t)v6);
}

uint64_t sub_1CD65AED8(uint64_t a1, unsigned int *a2)
{
  uint64_t v3 = a1 + 16;
  llvm::ConstantRange::unionWith(a1 + 16, a2, 0, (uint64_t)v5);
  llvm::ConstantRange::intersectWith((uint64_t)v5, (llvm::ConstantRange *)(a1 + 48), 0, (uint64_t)v6);
  sub_1CC149928(v3, (uint64_t)v6);
  sub_1CC05EB8C((uint64_t)v6);
  return sub_1CC05EB8C((uint64_t)v5);
}

BOOL sub_1CD65AF44(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 16;
  sub_1CC067C7C((uint64_t)v11, a1 + 16);
  sub_1CD65AFF8((uint64_t)&v8, a1, a2);
  v8 = &unk_1F26245C0;
  sub_1CC05EB8C((uint64_t)&v10);
  sub_1CC05EB8C((uint64_t)&v9);
  sub_1CC067C7C((uint64_t)v7, v4);
  BOOL v5 = sub_1CC8DD0F0((uint64_t)v11, v7);
  sub_1CC05EB8C((uint64_t)v7);
  sub_1CC05EB8C((uint64_t)v11);
  return v5;
}

uint64_t sub_1CD65AFF8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1CC067C7C((uint64_t)v6, a3 + 16);
  sub_1CD65AED8(a2, v6);
  sub_1CC05EB8C((uint64_t)v6);
  *(void *)a1 = &unk_1F26245C0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  sub_1CC067C7C(a1 + 16, a2 + 16);
  return sub_1CC067C7C(a1 + 48, a2 + 48);
}

uint64_t sub_1CD65B080(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1CC067C7C((uint64_t)v7, a3 + 48);
  sub_1CD65B134(a2, v7);
  sub_1CC05EB8C((uint64_t)v7);
  sub_1CC067C7C((uint64_t)v7, a3 + 16);
  sub_1CD65AED8(a2, v7);
  sub_1CC05EB8C((uint64_t)v7);
  *(void *)a1 = &unk_1F26245C0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  sub_1CC067C7C(a1 + 16, a2 + 16);
  return sub_1CC067C7C(a1 + 48, a2 + 48);
}

uint64_t sub_1CD65B134(uint64_t a1, unsigned int *a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = (unsigned int *)(a1 + 48);
  llvm::ConstantRange::unionWith(a1 + 48, a2, 0, (uint64_t)v5);
  sub_1CC149928((uint64_t)v3, (uint64_t)v5);
  sub_1CC05EB8C((uint64_t)v5);
  v2 += 16;
  llvm::ConstantRange::unionWith(v2, v3, 0, (uint64_t)v5);
  sub_1CC149928(v2, (uint64_t)v5);
  return sub_1CC05EB8C((uint64_t)v5);
}

uint64_t sub_1CD65B1B0(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 80))
  {
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
    sub_1CC8DD3CC(a1 + 16, (const void **)(a2 + 16));
    sub_1CC8DD3CC(a1 + 48, (const void **)(a2 + 48));
  }
  else
  {
    *(void *)a1 = &unk_1F26245C0;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
    sub_1CC067C7C(a1 + 16, a2 + 16);
    sub_1CC067C7C(a1 + 48, a2 + 48);
    *(unsigned char *)(a1 + 80) = 1;
  }
  return a1;
}

uint64_t sub_1CD65B248(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_1CD65B250(uint64_t a1)
{
  return a1 + 32;
}

double sub_1CD65B258@<D0>(uint64_t a1@<X8>)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)a1 = v2;
  *(_OWORD *)(a1 + 8) = xmmword_1CD91A400;
  strcpy(v2, "AAPotentialConstantValues");
  return *(double *)"alConstantValues";
}

void *sub_1CD65B2AC()
{
  return &llvm::AAPotentialConstantValues::ID;
}

uint64_t sub_1CD65B2B8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 17);
}

BOOL sub_1CD65B2C0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 17) == *(unsigned __int8 *)(a1 + 16);
}

uint64_t sub_1CD65B2D4(uint64_t a1)
{
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a1 + 17);
  return 1;
}

uint64_t sub_1CD65B2E4(uint64_t a1)
{
  *(unsigned char *)(a1 + 17) = *(unsigned char *)(a1 + 16);
  return 0;
}

uint64_t sub_1CD65B2F4(uint64_t a1)
{
  *(void *)a1 = &unk_1F2624AC0;
  sub_1CD480C18((char **)(a1 + 160));
  sub_1CD65B3B4(a1 + 24);
  return a1;
}

void sub_1CD65B344(uint64_t a1)
{
  *(void *)a1 = &unk_1F2624AC0;
  sub_1CD480C18((char **)(a1 + 160));
  sub_1CD65B3B4(a1 + 24);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD65B3B4(uint64_t a1)
{
  if ((*(unsigned char *)a1 & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
  }
  return a1;
}

uint64_t sub_1CD65B3F0(uint64_t result)
{
  if (*(unsigned char *)result)
  {
    uint64_t v2 = result + 8;
    uint64_t v1 = 8;
  }
  else
  {
    uint64_t v1 = *(unsigned int *)(result + 16);
    if (!v1) {
      return result;
    }
    uint64_t v2 = *(void *)(result + 8);
  }
  uint64_t v3 = 16 * v1;
  uint64_t v4 = (_DWORD *)(v2 + 8);
  do
  {
    if (*v4 >= 0x41u)
    {
      result = *((void *)v4 - 1);
      if (result) {
        result = MEMORY[0x1D25D9CB0](result, 0x1000C8000313F17);
      }
    }
    v4 += 4;
    v3 -= 16;
  }
  while (v3);
  return result;
}

llvm::APInt *sub_1CD65B468(uint64_t a1, llvm *a2)
{
  result = (llvm::APInt *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (result)
  {
    result = sub_1CD65B52C(a1 + 24, a2);
    unsigned int v5 = *(_DWORD *)(a1 + 168);
    if (v5 >= llvm::PotentialValuesState<llvm::APInt>::MaxPotentialValues)
    {
      v8 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 40);
      return (llvm::APInt *)v8(a1);
    }
    else
    {
      if (v5) {
        BOOL v6 = 1;
      }
      else {
        BOOL v6 = *(unsigned char *)(a1 + 304) == 0;
      }
      char v7 = !v6;
      *(unsigned char *)(a1 + 304) = v7;
    }
  }
  return result;
}

llvm::APInt *sub_1CD65B52C(uint64_t a1, llvm *this)
{
  result = (llvm::APInt *)sub_1CD65B598((uint64_t)v5, a1, this);
  if (v5[16])
  {
    return sub_1CC8E15CC(a1 + 136, this);
  }
  return result;
}

uint64_t sub_1CD65B598(uint64_t a1, uint64_t a2, llvm *this)
{
  uint64_t v14 = 0;
  uint64_t result = sub_1CD65B6BC(a2, this, &v14);
  uint64_t v7 = v14;
  if (result)
  {
    uint64_t v8 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v9 = 8;
    }
    else
    {
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a2 + 16);
    }
    char v10 = 0;
    uint64_t v11 = v8 + 16 * v9;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD65B650((_DWORD *)a2, v14, this);
    uint64_t v7 = result;
    uint64_t v12 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v13 = 8;
    }
    else
    {
      uint64_t v12 = *(void *)(a2 + 8);
      uint64_t v13 = *(unsigned int *)(a2 + 16);
    }
    uint64_t v11 = v12 + 16 * v13;
    char v10 = 1;
  }
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

const llvm::APInt *sub_1CD65B650(_DWORD *a1, uint64_t a2, llvm *a3)
{
  uint64_t v4 = (const llvm::APInt *)sub_1CD65B7DC(a1, a3, a2);
  unsigned int v5 = v4;
  if (*((_DWORD *)v4 + 2) > 0x40u || *((_DWORD *)a3 + 2) > 0x40u)
  {
    llvm::APInt::assignSlowCase(v4, a3);
  }
  else
  {
    *(void *)uint64_t v4 = *(void *)a3;
    *((_DWORD *)v4 + 2) = *((_DWORD *)a3 + 2);
  }
  return v5;
}

uint64_t sub_1CD65B6BC(uint64_t a1, llvm *this, void *a3)
{
  uint64_t v5 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v6 = 8;
  }
  else
  {
    int v6 = *(_DWORD *)(a1 + 16);
    if (!v6)
    {
      uint64_t v13 = 0;
      uint64_t result = 0;
      goto LABEL_21;
    }
    uint64_t v5 = *(void *)(a1 + 8);
  }
  unsigned int v7 = llvm::hash_value(this, this);
  uint64_t v8 = 0;
  int v9 = v6 - 1;
  uint64_t v10 = *((unsigned int *)this + 2);
  for (int i = 1; ; ++i)
  {
    unsigned int v12 = v7 & v9;
    uint64_t v13 = v5 + 16 * (v7 & v9);
    int v14 = *(_DWORD *)(v13 + 8);
    if (v10 == v14)
    {
      v15 = *(const void **)this;
      if (v10 > 0x40)
      {
        if (!memcmp(v15, *(const void **)v13, ((unint64_t)(v10 + 63) >> 3) & 0x3FFFFFF8))
        {
LABEL_20:
          uint64_t result = 1;
          goto LABEL_21;
        }
      }
      else if (v15 == *(const void **)v13)
      {
        goto LABEL_20;
      }
    }
    if (v14)
    {
      BOOL v16 = 0;
      goto LABEL_13;
    }
    if (!*(void *)v13) {
      break;
    }
    BOOL v16 = *(void *)v13 == 1;
LABEL_13:
    if (v16 && v8 == 0) {
      uint64_t v8 = v5 + 16 * v12;
    }
    unsigned int v7 = v12 + i;
  }
  uint64_t result = 0;
  if (v8) {
    uint64_t v13 = v8;
  }
LABEL_21:
  *a3 = v13;
  return result;
}

uint64_t sub_1CD65B7DC(_DWORD *a1, llvm *a2, uint64_t a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 8;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
    goto LABEL_12;
  }
  if (v6 + ~v5 - a1[1] <= v6 >> 3)
  {
LABEL_12:
    sub_1CD65B8A4((uint64_t)a1, v6);
    uint64_t v8 = 0;
    sub_1CD65B6BC((uint64_t)a1, a2, &v8);
    a3 = v8;
  }
  *a1 += 2;
  if (*(_DWORD *)(a3 + 8) || *(void *)a3) {
    --a1[1];
  }
  return a3;
}

int *sub_1CD65B8A4(uint64_t a1, unsigned int a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a2 >= 9)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    unsigned int v6 = *(llvm **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 8)
    {
      uint64_t v14 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v14;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD65BA3C((int *)a1, v6, (llvm *)((char *)v6 + 16 * v7));
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = 0;
  int v9 = (llvm *)v15;
  do
  {
    uint64_t v10 = a1 + v8;
    int v11 = *(_DWORD *)(a1 + v8 + 16);
    if (v11 || *(void *)(v10 + 8) >= 2uLL)
    {
      *((_DWORD *)v9 + 2) = v11;
      *(void *)int v9 = *(void *)(v10 + 8);
      int v9 = (llvm *)((char *)v9 + 16);
      *(_DWORD *)(v10 + 16) = 0;
    }
    v8 += 16;
  }
  while (v8 != 128);
  if (a2 > 8)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v12 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v12;
  }
  return sub_1CD65BA3C((int *)a1, (llvm *)v15, v9);
}

int *sub_1CD65BA3C(int *result, llvm *this, llvm *a3)
{
  int v5 = result;
  int v6 = *result;
  *(void *)uint64_t result = *result & 1;
  if (v6)
  {
    uint64_t v8 = result + 2;
    int v9 = result + 34;
  }
  else
  {
    uint64_t v7 = result[4];
    if (!v7) {
      goto LABEL_16;
    }
    uint64_t v8 = (int *)*((void *)result + 1);
    int v9 = &v8[4 * v7];
  }
  do
  {
    v8[2] = 0;
    *(void *)uint64_t v8 = 0;
    v8 += 4;
  }
  while (v8 != v9);
LABEL_16:
  while (this != a3)
  {
    if (*((_DWORD *)this + 2) || *(void *)this >= 2uLL)
    {
      int v11 = 0;
      uint64_t result = (int *)sub_1CD65B6BC((uint64_t)v5, this, &v11);
      uint64_t v10 = v11;
      if (*((_DWORD *)v11 + 2) >= 0x41u)
      {
        uint64_t result = *v11;
        if (*v11) {
          uint64_t result = (int *)MEMORY[0x1D25D9CB0](result, 0x1000C8000313F17);
        }
      }
      *uint64_t v10 = *(int **)this;
      *((_DWORD *)v10 + 2) = *((_DWORD *)this + 2);
      *((_DWORD *)this + 2) = 0;
      *v5 += 2;
      if (*((_DWORD *)this + 2) >= 0x41u)
      {
        uint64_t result = *(int **)this;
        if (*(void *)this) {
          uint64_t result = (int *)MEMORY[0x1D25D9CB0](result, 0x1000C8000313F17);
        }
      }
    }
    this = (llvm *)((char *)this + 16);
  }
  return result;
}

uint64_t sub_1CD65BB64(uint64_t a1, uint64_t a2)
{
  int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (v4 != (*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2)) {
    return 0;
  }
  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1) & 1) == 0
    && !(*(unsigned int (**)(uint64_t))(*(void *)a2 + 16))(a2))
  {
    return 1;
  }
  if ((*(unsigned char *)(a1 + 304) != 0) != (*(unsigned char *)(a2 + 304) != 0)) {
    return 0;
  }
  int v6 = *(const void ***)(a2 + 160);
  unsigned int v7 = *(_DWORD *)(a2 + 168);

  return sub_1CD65C184((uint64_t *)(a1 + 160), v6, v7);
}

void *sub_1CD65BC98(void *a1, _DWORD *a2)
{
  uint64_t v4 = 0;
  *a1 = 1;
  uint64_t v5 = (uint64_t)(a1 + 17);
  do
  {
    int v6 = &a1[v4];
    *((_DWORD *)v6 + 4) = 0;
    v6[1] = 0;
    v4 += 2;
  }
  while (v4 != 16);
  sub_1CD65BD2C((uint64_t)a1, a2);
  a1[17] = a1 + 19;
  a1[18] = 0x800000000;
  if (a2[36]) {
    sub_1CD65BE9C(v5, (uint64_t)(a2 + 34));
  }
  return a1;
}

unsigned int *sub_1CD65BD2C(uint64_t a1, _DWORD *a2)
{
  sub_1CD65B3F0(a1);
  unsigned int v4 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
    unsigned int v4 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v4 | 1;
  if ((*(unsigned char *)a2 & 1) == 0 && a2[4] >= 9u)
  {
    *(_DWORD *)a1 = v4 & 0xFFFFFFFE;
    if (*a2) {
      uint64_t v5 = 8;
    }
    else {
      uint64_t v5 = a2[4];
    }
    *(void *)(a1 + 8) = operator new(16 * v5, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v5;
  }

  return sub_1CD65BDD4((unsigned int *)a1, a2);
}

unsigned int *sub_1CD65BDD4(unsigned int *result, _DWORD *a2)
{
  unint64_t v3 = result;
  uint64_t v4 = 0;
  unint64_t v5 = 0;
  unsigned int v6 = *a2 & 0xFFFFFFFE | *result & 1;
  llvm::APInt *result = v6;
  result[1] = a2[1];
  unsigned int v7 = result + 2;
  uint64_t v8 = a2 + 2;
  while ((v6 & 1) == 0)
  {
    if (v5 >= v3[4]) {
      return result;
    }
    int v9 = (void *)*v7;
LABEL_6:
    uint64_t v10 = v8;
    if ((*(unsigned char *)a2 & 1) == 0) {
      uint64_t v10 = (void *)*v8;
    }
    uint64_t result = (unsigned int *)&v9[v4];
    int v11 = (const llvm::APInt *)&v10[v4];
    unsigned int v12 = v10[v4 + 1];
    result[2] = v12;
    if (v12 > 0x40) {
      llvm::APInt::initSlowCase((llvm::APInt *)result, v11);
    }
    *(void *)uint64_t result = *(void *)v11;
    ++v5;
    unsigned int v6 = *v3;
    v4 += 2;
  }
  int v9 = v7;
  if (v5 < 8) {
    goto LABEL_6;
  }
  return result;
}

uint64_t sub_1CD65BE9C(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unint64_t v4 = *(unsigned int *)(a2 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    if (v5 >= v4)
    {
      if (v4)
      {
        sub_1CC8E1674(*(void *)a2, *(void *)a2 + 16 * v4, *(void ***)a1);
        v19 = v18;
        v20 = *(void ***)a1;
        uint64_t v5 = *(unsigned int *)(a1 + 8);
      }
      else
      {
        v20 = *(void ***)a1;
        v19 = *(void ***)a1;
      }
      for (int i = &v20[2 * v5]; i != v19; i -= 2)
      {
        if (*((_DWORD *)i - 2) >= 0x41u)
        {
          uint64_t v22 = (uint64_t)*(i - 2);
          if (v22) {
            MEMORY[0x1D25D9CB0](v22, 0x1000C8000313F17);
          }
        }
      }
      goto LABEL_18;
    }
    if (*(_DWORD *)(a1 + 12) >= v4)
    {
      if (v5)
      {
        sub_1CC8E1674(*(void *)a2, *(void *)a2 + 16 * v5, *(void ***)a1);
LABEL_12:
        uint64_t v9 = *(unsigned int *)(a2 + 8);
        if (v5 != v9)
        {
          uint64_t v10 = *(void *)a2;
          int v11 = *(void ***)a1;
          uint64_t v12 = 16 * v5;
          uint64_t v13 = 16 * v9;
          do
          {
            uint64_t v14 = (llvm::APInt *)&v11[(unint64_t)v12 / 8];
            v15 = (const llvm::APInt *)(v10 + v12);
            unsigned int v16 = *(_DWORD *)(v10 + v12 + 8);
            LODWORD(v11[(unint64_t)v12 / 8 + 1]) = v16;
            if (v16 > 0x40) {
              llvm::APInt::initSlowCase(v14, v15);
            }
            *(void *)uint64_t v14 = *(void *)v15;
            v11 += 2;
            v13 -= 16;
            v10 += 16;
          }
          while (v12 != v13);
        }
LABEL_18:
        *(_DWORD *)(a1 + 8) = v4;
        return a1;
      }
    }
    else
    {
      if (v5)
      {
        unsigned int v6 = *(void ***)a1;
        uint64_t v7 = 2 * v5;
        do
        {
          if (LODWORD(v6[v7 - 1]) >= 0x41)
          {
            uint64_t v8 = v6[v7 - 2];
            if (v8) {
              MEMORY[0x1D25D9CB0](v8, 0x1000C8000313F17);
            }
          }
          v7 -= 2;
        }
        while (v7 * 8);
      }
      *(_DWORD *)(a1 + 8) = 0;
      sub_1CBFC6948(a1, v4);
    }
    uint64_t v5 = 0;
    goto LABEL_12;
  }
  return a1;
}

uint64_t sub_1CD65C028(uint64_t a1, long long *a2, uint64_t a3, int a4)
{
  uint64_t v10 = &llvm::AAPotentialConstantValues::ID;
  long long v11 = *a2;
  uint64_t v12 = 0;
  if ((sub_1CD64CDF0((uint64_t *)(a1 + 32), (uint64_t)&v10, &v12) & 1) == 0) {
    return 0;
  }
  uint64_t v7 = v12[3];
  if (v7)
  {
    if (a3)
    {
      if (a4 != 2)
      {
        uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 40))(v12[3]);
        if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 16))(v8)) {
          llvm::Attributor::recordDependence(a1, v7, a3, a4);
        }
      }
    }
  }
  return v7;
}

uint64_t sub_1CD65C114(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = &llvm::AAPotentialConstantValues::ID;
  long long v6 = *(_OWORD *)(a2 + 16);
  sub_1CD64CF70((uint64_t *)(a1 + 32), (uint64_t)&v5)[3] = a2;
  if (*(_DWORD *)(a1 + 4368) <= 1u) {
    sub_1CD64B90C((unint64_t *)(a1 + 104), a2);
  }
  return a2;
}

uint64_t sub_1CD65C184(uint64_t *a1, const void **a2, unsigned int a3)
{
  if (*((_DWORD *)a1 + 2) != a3) {
    return 0;
  }
  if (a3)
  {
    uint64_t v4 = *a1;
    uint64_t v5 = 16 * a3;
    do
    {
      uint64_t v6 = *(unsigned int *)(v4 + 8);
      if (v6 > 0x40)
      {
        if (memcmp(*(const void **)v4, *a2, ((unint64_t)(v6 + 63) >> 3) & 0x3FFFFFF8)) {
          return 0;
        }
      }
      else if (*(const void **)v4 != *a2)
      {
        return 0;
      }
      v4 += 16;
      a2 += 2;
      v5 -= 16;
    }
    while (v5);
  }
  return 1;
}

uint64_t sub_1CD65C220(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    if ((result & 1) == 0) {
      goto LABEL_15;
    }
    uint64_t v5 = *(unsigned int *)(a2 + 168);
    if (v5)
    {
      uint64_t v6 = *(llvm **)(a2 + 160);
      uint64_t v7 = 16 * v5;
      do
      {
        uint64_t result = (uint64_t)sub_1CD65B52C(a1 + 24, v6);
        uint64_t v6 = (llvm *)((char *)v6 + 16);
        v7 -= 16;
      }
      while (v7);
    }
    char v8 = *(unsigned char *)(a1 + 304) | *(unsigned char *)(a2 + 304);
    *(unsigned char *)(a1 + 304) = v8;
    unsigned int v9 = *(_DWORD *)(a1 + 168);
    if (v9 < llvm::PotentialValuesState<llvm::APInt>::MaxPotentialValues)
    {
      if (v8) {
        BOOL v10 = v9 == 0;
      }
      else {
        BOOL v10 = 0;
      }
      char v11 = v10;
      *(unsigned char *)(a1 + 304) = v11;
    }
    else
    {
LABEL_15:
      uint64_t v12 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 40);
      return v12(a1);
    }
  }
  return result;
}

void *sub_1CD65C354(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(uint64_t, void, void))(*(void *)(a2 + 8) + 72))(a2 + 8, *(unsigned __int8 *)(a3 + 17), *(unsigned __int8 *)(a3 + 16));
  sub_1CD65C220(a2, a3);
  *(void *)a1 = &unk_1F2624AC0;
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  *(void *)(a1 + 8) = &unk_1F2620BB0;
  uint64_t result = sub_1CD65BC98((void *)(a1 + 24), (_DWORD *)(a2 + 24));
  *(unsigned char *)(a1 + 304) = *(unsigned char *)(a2 + 304);
  return result;
}

uint64_t sub_1CD65C418(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 312))
  {
    *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
    if (a2 != a1) {
      sub_1CD65BD2C(a1 + 24, (_DWORD *)(a2 + 24));
    }
    sub_1CD65BE9C(a1 + 160, a2 + 160);
    *(unsigned char *)(a1 + 304) = *(unsigned char *)(a2 + 304);
  }
  else
  {
    *(void *)a1 = &unk_1F2624AC0;
    *(void *)(a1 + 8) = &unk_1F26275E0;
    *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
    *(void *)(a1 + 8) = &unk_1F2620BB0;
    sub_1CD65BC98((void *)(a1 + 24), (_DWORD *)(a2 + 24));
    *(unsigned char *)(a1 + 304) = *(unsigned char *)(a2 + 304);
    *(unsigned char *)(a1 + 312) = 1;
  }
  return a1;
}

void sub_1CD65C4F8(char *a1@<X8>)
{
  a1[23] = 9;
  strcpy(a1, "AANoUndef");
}

void *sub_1CD65C51C()
{
  return &llvm::AANoUndef::ID;
}

unint64_t sub_1CD65C528(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  unint64_t result = llvm::Attribute::get(a2, 0x24u, 0);
  uint64_t v5 = *(unsigned int *)(a3 + 8);
  if (v5 >= *(_DWORD *)(a3 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)a3 + 8 * v5) = result;
  *(_DWORD *)(a3 + 8) = v5 + 1;
  return result;
}

unint64_t sub_1CD65C5A0(void *a1, uint64_t a2)
{
  uint64_t v4 = (llvm::IRPosition *)(a1 + 2);
  if (*(unsigned __int8 *)(sub_1CD6482F0((llvm::IRPosition *)(a1 + 2)) + 16) - 11 < 2
    || (unsigned int v10 = 36, llvm::IRPosition::hasAttr(v4, &v10, 1, 0, a2)))
  {
    uint64_t v5 = (*(uint64_t (**)(void *))(*a1 + 40))(a1);
    return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 32))(v5);
  }
  else
  {
    unsigned int v7 = sub_1CD647DEC(v4);
    if (v7 <= 6 && ((1 << v7) & 0x54) != 0)
    {
      char v8 = (llvm::GlobalValue *)sub_1CD6482A0(v4);
      if (!v8 || (unint64_t result = sub_1CD64EF44(a2, v8), (result & 1) == 0))
      {
        uint64_t v9 = (*(uint64_t (**)(void *))(*a1 + 40))(a1);
        return (*(uint64_t (**)(uint64_t))(*(void *)v9 + 40))(v9);
      }
    }
    else
    {
      return sub_1CD6482A0(v4);
    }
  }
  return result;
}

uint64_t sub_1CD65C700(uint64_t a1, uint64_t a2)
{
  v11[4] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (llvm::IRPosition *)(a1 + 16);
  if (*(unsigned __int8 *)(sub_1CD6482F0((llvm::IRPosition *)(a1 + 16)) + 16) - 11 < 2) {
    return 1;
  }
  uint64_t v9 = v11;
  uint64_t v10 = 0x400000000;
  unint64_t v7 = *(void *)v4 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~*(_DWORD *)v4 & 3) == 0) {
    unint64_t v7 = *(void *)(v7 + 24);
  }
  (*(void (**)(uint64_t, void, void **))(*(void *)a1 + 112))(a1, **(void **)v7, &v9);
  v8[0] = v9;
  v8[1] = v10;
  uint64_t v5 = llvm::IRAttributeManifest::manifestAttrs(a2, v4, (uint64_t)v8, 0);
  if (v9 != v11) {
    free(v9);
  }
  return v5;
}

uint64_t sub_1CD65C820(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_1CD65C828(uint64_t a1)
{
  return a1 + 32;
}

void sub_1CD65C830(char *a1@<X8>)
{
  a1[23] = 13;
  strcpy(a1, "AAPointerInfo");
}

void *sub_1CD65C858()
{
  return &llvm::AAPointerInfo::ID;
}

uint64_t sub_1CD65C864(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 41);
}

BOOL sub_1CD65C86C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 41) == *(unsigned __int8 *)(a1 + 40);
}

uint64_t sub_1CD65C880(uint64_t a1)
{
  *(unsigned char *)(a1 + 40) = *(unsigned char *)(a1 + 41);
  return 1;
}

uint64_t sub_1CD65C890(uint64_t a1)
{
  *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
  return 0;
}

void sub_1CD65C8A4(uint64_t a1)
{
  sub_1CD65C8DC(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD65C8DC(uint64_t a1)
{
  *(void *)a1 = &unk_1F2625358;
  uint64_t v2 = (uint64_t *)(a1 + 8);
  uint64_t v4 = sub_1CD65C9B4(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = (void *)(v5 + 24 * *(unsigned int *)(a1 + 24));
  if (v6 != v4)
  {
    unint64_t v7 = v3;
    do
    {
      sub_1CD65CA14(v4[2]);
      while (1)
      {
        v4 += 3;
        if (v4 == v7) {
          break;
        }
        uint64_t v8 = v4[1];
        if ((*v4 != 0x7FFFFFFFFFFFFFFFLL || v8 != 0x7FFFFFFFFFFFFFFFLL)
          && (*v4 != 0x8000000000000000 || v8 != 0x8000000000000000))
        {
          goto LABEL_15;
        }
      }
      uint64_t v4 = v7;
LABEL_15:
      ;
    }
    while (v4 != v6);
    uint64_t v5 = *v2;
  }
  MEMORY[0x1D25D9CD0](v5, 8);
  return a1;
}

void *sub_1CD65C9B4(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 8);
  unint64_t result = *(void **)a1;
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  uint64_t v5 = &result[3 * v4];
  if (!v2) {
    return v5;
  }
  if (v4)
  {
    uint64_t v6 = 24 * v4;
    while (1)
    {
      uint64_t v7 = result[1];
      if ((*result != 0x7FFFFFFFFFFFFFFFLL || v7 != 0x7FFFFFFFFFFFFFFFLL)
        && (*result != 0x8000000000000000 || v7 != 0x8000000000000000))
      {
        break;
      }
      result += 3;
      v6 -= 24;
      if (!v6) {
        return v5;
      }
    }
  }
  return result;
}

uint64_t sub_1CD65CA14(uint64_t a1)
{
  if (*(void *)a1 != a1 + 16) {
    free(*(void **)a1);
  }
  return a1;
}

__n128 sub_1CD65CA58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v15 = a11;
  v33[0] = a3;
  v33[1] = a4;
  if (a11)
  {
    unsigned int v16 = &a11;
  }
  else
  {
    unsigned int v16 = sub_1CD65CC84(a1 + 8, v33) + 2;
    uint64_t v15 = *v16;
    if (!*v16)
    {
      uint64_t v15 = sub_1CB906F34(*(uint64_t **)(a2 + 24), 232, 3);
      *(void *)uint64_t v15 = v15 + 16;
      *(void *)(v15 + 8) = 0x400000000;
      *(void *)(v15 + 208) = 0;
      *(void *)(v15 + 216) = 0;
      *(_DWORD *)(v15 + 224) = 0;
      *unsigned int v16 = v15;
    }
  }
  if (a10) {
    uint64_t v17 = a10;
  }
  else {
    uint64_t v17 = a5;
  }
  uint64_t v28 = a5;
  uint64_t v29 = v17;
  v30[0] = a6;
  v30[1] = a7;
  int v31 = a8;
  uint64_t v32 = a9;
  uint64_t v34 = v17;
  uint64_t v35 = 0;
  if (sub_1CBA0E618(v15 + 208, &v34, &v35)) {
    uint64_t v18 = v35;
  }
  else {
    uint64_t v18 = *(void *)(v15 + 208) + 16 * *(unsigned int *)(v15 + 224);
  }
  uint64_t v19 = *v16;
  if (v18 == *(void *)(v19 + 208) + 16 * *(unsigned int *)(v19 + 224))
  {
    int v24 = *(_DWORD *)(v19 + 8);
    uint64_t v35 = v29;
    *((_DWORD *)sub_1CC21C478(v19 + 208, &v35) + 2) = v24;
    unint64_t v25 = sub_1CD65D05C(v19, (unint64_t)&v28);
    uint64_t v26 = *(void *)v19 + 48 * *(unsigned int *)(v19 + 8);
    long long v27 = *(_OWORD *)(v25 + 16);
    __n128 result = *(__n128 *)(v25 + 32);
    *(_OWORD *)uint64_t v26 = *(_OWORD *)v25;
    *(_OWORD *)(v26 + 16) = v27;
    *(__n128 *)(v26 + 32) = result;
    ++*(_DWORD *)(v19 + 8);
  }
  else
  {
    uint64_t v20 = *(void *)v19 + 48 * *(unsigned int *)(v18 + 8);
    *(void *)(v20 + 16) = llvm::AA::combineOptionalValuesInAAValueLatice((unsigned __int8 *)(v20 + 16), (uint64_t)v30, *(llvm::Value **)(v20 + 40));
    *(void *)(v20 + 24) = v22;
    *(_DWORD *)(v20 + 32) |= v31;
  }
  return result;
}

void *sub_1CD65CC84(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD65CCF4(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD65CDE4(a1, a2, v7);
    *(_OWORD *)uint64_t v5 = *(_OWORD *)a2;
    v5[2] = 0;
  }
  return v5;
}

uint64_t sub_1CD65CCF4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (a2)
  {
    unint64_t v5 = ((37 * a4) | (unint64_t)(0x2500000000 * a3))
       + ~((unint64_t)(37 * a4) << 32);
    unint64_t v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    int v8 = a2 - 1;
    unsigned int v9 = (a2 - 1) & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27)));
    uint64_t v10 = (void *)(a1 + 24 * v9);
    uint64_t v11 = *v10;
    uint64_t v12 = v10[1];
    if (*v10 == a3 && v12 == a4)
    {
      uint64_t v14 = 1;
    }
    else
    {
      unsigned int v16 = 0;
      int v17 = 1;
      while (v11 != 0x7FFFFFFFFFFFFFFFLL || v12 != 0x7FFFFFFFFFFFFFFFLL)
      {
        if (v16) {
          BOOL v19 = 0;
        }
        else {
          BOOL v19 = v12 == 0x8000000000000000;
        }
        if (v19 && v11 == 0x8000000000000000) {
          unsigned int v16 = v10;
        }
        unsigned int v21 = v9 + v17++;
        unsigned int v9 = v21 & v8;
        uint64_t v10 = (void *)(a1 + 24 * (v21 & v8));
        uint64_t v11 = *v10;
        uint64_t v12 = v10[1];
        uint64_t v14 = 1;
        if (*v10 == a3 && v12 == a4) {
          goto LABEL_8;
        }
      }
      uint64_t v14 = 0;
      if (v16) {
        uint64_t v10 = v16;
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v14 = 0;
  }
LABEL_8:
  *a5 = v10;
  return v14;
}

void *sub_1CD65CDE4(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD65CEA0(a1, v6);
  unsigned int v9 = 0;
  sub_1CD65CCF4(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v9);
  a3 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != 0x7FFFFFFFFFFFFFFFLL || a3[1] != 0x7FFFFFFFFFFFFFFFLL) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_OWORD *sub_1CD65CEA0(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  char v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  __n128 result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD65CF7C(a1, v4, &v4[3 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 24 * v10;
    int64x2_t v12 = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
    do
    {
      _OWORD *result = v12;
      __n128 result = (_OWORD *)((char *)result + 24);
      v11 -= 24;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD65CF7C(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  char v4 = a2;
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(int64x2_t **)result;
    uint64_t v8 = 24 * v6;
    int64x2_t v9 = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
    do
    {
      *int v7 = v9;
      int v7 = (int64x2_t *)((char *)v7 + 24);
      v8 -= 24;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v10 = *v4;
      uint64_t v11 = v4[1];
      if ((*v4 != 0x7FFFFFFFFFFFFFFFLL || v11 != 0x7FFFFFFFFFFFFFFFLL)
        && (v10 != 0x8000000000000000 || v11 != 0x8000000000000000))
      {
        unsigned int v16 = 0;
        __n128 result = sub_1CD65CCF4(*(void *)v5, *(_DWORD *)(v5 + 16), v10, v11, &v16);
        uint64_t v14 = v16;
        *unsigned int v16 = *v4;
        uint64_t v15 = v4[2];
        v14[1] = v4[1];
        v14[2] = v15;
        ++*(_DWORD *)(v5 + 8);
      }
      v4 += 3;
    }
    while (v4 != a3);
  }
  return result;
}

unint64_t sub_1CD65D05C(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 48 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      sub_1CD65D0C8();
    }
    sub_1CD65D0C8();
  }
  return a2;
}

void sub_1CD65D0C8()
{
}

uint64_t sub_1CD65D174(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t, BOOL), uint64_t a5)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (result)
  {
    uint64_t v11 = sub_1CD65C9B4(a1 + 8);
    uint64_t v30 = *(void *)(a1 + 8) + 24 * *(unsigned int *)(a1 + 24);
    if ((uint64_t *)v30 == v11)
    {
      return 1;
    }
    else
    {
      uint64_t v13 = v11;
      uint64_t v14 = v12;
      BOOL v15 = a2 == 0xFFFFFFFF80000000;
      if (a3 == 0xFFFFFFFF80000000) {
        BOOL v15 = 1;
      }
      BOOL v31 = v15;
      while (1)
      {
        uint64_t v16 = *v13;
        uint64_t v17 = v13[1];
        if (v31
          || (v16 != 0xFFFFFFFF80000000 ? (BOOL v18 = v17 == 0xFFFFFFFF80000000) : (BOOL v18 = 1),
              v18 || (v17 + v16 > a2 ? (BOOL v19 = v16 < a2 + a3) : (BOOL v19 = 0), v19)))
        {
          BOOL v20 = a2 == v16 && a3 == v17;
          BOOL v21 = a2 != 0xFFFFFFFF80000000;
          if (!v20) {
            BOOL v21 = 0;
          }
          BOOL v22 = a3 != 0xFFFFFFFF80000000 && (unint64_t)v21;
          v23 = (uint64_t *)v13[2];
          uint64_t v24 = *((unsigned int *)v23 + 2);
          if (v24) {
            break;
          }
        }
LABEL_28:
        v13 += 3;
        if (v13 == v14)
        {
LABEL_39:
          uint64_t v13 = v14;
        }
        else
        {
          while (1)
          {
            uint64_t v27 = v13[1];
            if ((*v13 != 0x7FFFFFFFFFFFFFFFLL || v27 != 0x7FFFFFFFFFFFFFFFLL)
              && (*v13 != 0x8000000000000000 || v27 != 0x8000000000000000))
            {
              break;
            }
            v13 += 3;
            if (v13 == v14) {
              goto LABEL_39;
            }
          }
        }
        uint64_t result = 1;
        if (v13 == (uint64_t *)v30) {
          return result;
        }
      }
      uint64_t v25 = *v23;
      uint64_t v26 = 48 * v24;
      while ((a4(a5, v25, v22) & 1) != 0)
      {
        v25 += 48;
        v26 -= 48;
        if (!v26) {
          goto LABEL_28;
        }
      }
      return 0;
    }
  }
  return result;
}

uint64_t sub_1CD65D328(uint64_t a1, long long *a2, uint64_t a3, int a4, char a5)
{
  long long v9 = *a2;
  uint64_t v14 = &llvm::AAExecutionDomain::ID;
  long long v15 = v9;
  uint64_t v16 = 0;
  if ((sub_1CD64CDF0((uint64_t *)(a1 + 32), (uint64_t)&v14, &v16) & 1) == 0) {
    return 0;
  }
  uint64_t v10 = v16[3];
  if (v10)
  {
    if (a3)
    {
      if (a4 != 2)
      {
        uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 40))(v16[3]);
        if ((*(unsigned int (**)(uint64_t))(*(void *)v11 + 16))(v11)) {
          llvm::Attributor::recordDependence(a1, v10, a3, a4);
        }
      }
    }
    if ((a5 & 1) == 0)
    {
      uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 40))(v10);
      if (!(*(unsigned int (**)(uint64_t))(*(void *)v12 + 16))(v12)) {
        return 0;
      }
    }
  }
  return v10;
}

uint64_t sub_1CD65D474(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, BOOL), uint64_t a4)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (result)
  {
    long long v9 = sub_1CD65C9B4(a1 + 8);
    uint64_t v11 = *(void *)(a1 + 8) + 24 * *(unsigned int *)(a1 + 24);
    if ((uint64_t *)v11 != v9)
    {
      do
      {
        uint64_t v12 = (unsigned int *)v9[2];
        uint64_t v13 = v12[2];
        if (!v13) {
          goto LABEL_9;
        }
        uint64_t v14 = (void *)(*(void *)v12 + 8);
        uint64_t v15 = 48 * v13;
        do
        {
          if (*v14 == a2)
          {
            uint64_t v16 = v9[1];
            if (v16 == -1) {
              break;
            }
            uint64_t v20 = *v9;
            return sub_1CD65D174(a1, v20, v16, a3, a4);
          }
          v14 += 6;
          v15 -= 48;
        }
        while (v15);
LABEL_9:
        while (1)
        {
          v9 += 3;
          if (v9 == v10) {
            break;
          }
          uint64_t v17 = v9[1];
          if ((*v9 != 0x7FFFFFFFFFFFFFFFLL || v17 != 0x7FFFFFFFFFFFFFFFLL)
            && (*v9 != 0x8000000000000000 || v17 != 0x8000000000000000))
          {
            goto LABEL_20;
          }
        }
        long long v9 = v10;
LABEL_20:
        ;
      }
      while (v9 != (uint64_t *)v11);
    }
    return 1;
  }
  return result;
}

uint64_t sub_1CD65D5AC(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_1CD65D5B4(uint64_t a1)
{
  return a1 + 32;
}

void sub_1CD65D5BC(char *a1@<X8>)
{
  a1[23] = 15;
  strcpy(a1, "AAValueSimplify");
}

void *sub_1CD65D5E4()
{
  return &llvm::AAValueSimplify::ID;
}

uint64_t sub_1CD65D5F0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 25);
}

BOOL sub_1CD65D5F8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 25) == *(unsigned __int8 *)(a1 + 24);
}

uint64_t sub_1CD65D60C(uint64_t a1)
{
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a1 + 25);
  return 1;
}

uint64_t sub_1CD65D61C(uint64_t a1, uint64_t a2, llvm::Value *a3)
{
  uint64_t v7 = a2;
  unint64_t v4 = (llvm::Value **)sub_1CD65D6F8(a1 + 432, &v7);
  if (*v4)
  {
    uint64_t v5 = llvm::Value::stripPointerCasts(*v4);
    if (v5 == llvm::Value::stripPointerCasts(a3) || *v4 && *((unsigned __int8 *)*v4 + 16) - 11 < 2) {
      return 0;
    }
  }
  *unint64_t v4 = a3;
  return 1;
}

void sub_1CD65D6A8()
{
}

uint64_t sub_1CD65D6F8(uint64_t a1, uint64_t *a2)
{
  uint64_t v12 = *a2;
  int v13 = 0;
  sub_1CD65D7B8(a1, &v12, &v13, (uint64_t)&v10);
  uint64_t v4 = v10;
  if (v11)
  {
    uint64_t v5 = *a2;
    unsigned int v6 = *(_DWORD *)(a1 + 528);
    if (v6 >= *(_DWORD *)(a1 + 532)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v7 = (void *)(*(void *)(a1 + 520) + 16 * v6);
    *uint64_t v7 = v5;
    v7[1] = 0;
    unsigned int v8 = *(_DWORD *)(a1 + 528);
    *(_DWORD *)(a1 + 528) = v8 + 1;
    *(_DWORD *)(v4 + 8) = v8;
  }
  else
  {
    unsigned int v8 = *(_DWORD *)(v10 + 8);
  }
  return *(void *)(a1 + 520) + 16 * v8 + 8;
}

uint64_t sub_1CD65D7B8@<X0>(uint64_t a1@<X0>, void *a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v16 = 0;
  uint64_t result = sub_1CD65D880(a1, a2, &v16);
  long long v9 = v16;
  if (result)
  {
    uint64_t v10 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v11 = 32;
    }
    else
    {
      uint64_t v10 = *(void *)(a1 + 8);
      uint64_t v11 = *(unsigned int *)(a1 + 16);
    }
    char v12 = 0;
    uint64_t v13 = v10 + 16 * v11;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD65D930((_DWORD *)a1, (uint64_t)a2, a2, v16);
    long long v9 = (void *)result;
    *(void *)uint64_t result = *a2;
    *(_DWORD *)(result + 8) = *a3;
    uint64_t v14 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v15 = 32;
    }
    else
    {
      uint64_t v14 = *(void *)(a1 + 8);
      uint64_t v15 = *(unsigned int *)(a1 + 16);
    }
    uint64_t v13 = v14 + 16 * v15;
    char v12 = 1;
  }
  *(void *)a4 = v9;
  *(void *)(a4 + 8) = v13;
  *(unsigned char *)(a4 + 16) = v12;
  return result;
}

uint64_t sub_1CD65D880(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 32;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  uint64_t v7 = (void *)(v3 + 16 * v6);
  uint64_t v8 = *v7;
  if (*a2 == *v7)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 16 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    if (v10) {
      uint64_t v7 = v10;
    }
  }
LABEL_7:
  *a3 = v7;
  return result;
}

void *sub_1CD65D930(_DWORD *a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *a1 >> 1;
  if (*a1) {
    unsigned int v7 = 32;
  }
  else {
    unsigned int v7 = a1[4];
  }
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - a1[1] > v7 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD65D9F0((uint64_t)a1, v7);
  long long v9 = 0;
  sub_1CD65D880((uint64_t)a1, a3, &v9);
  a4 = v9;
LABEL_6:
  *a1 += 2;
  if (*a4 != -4096) {
    --a1[1];
  }
  return a4;
}

uint64_t sub_1CD65D9F0(uint64_t a1, unsigned int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 0x21)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 0x20)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD65DB88(a1, v6, v6 + 16 * v7);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = 0;
  long long v9 = v14;
  do
  {
    uint64_t v10 = *(void *)(a1 + v8 + 8);
    if ((v10 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *(void *)long long v9 = v10;
      *((_DWORD *)v9 + 2) = *(_DWORD *)(a1 + v8 + 16);
      v9 += 16;
    }
    v8 += 16;
  }
  while (v8 != 512);
  if (a2 > 0x20)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD65DB88(a1, (uint64_t)v14, (uint64_t)v9);
}

uint64_t sub_1CD65DB88(uint64_t result, uint64_t a2, uint64_t a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    long long v9 = (void *)(result + 520);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(void **)(result + 8);
    long long v9 = &v8[2 * v7];
  }
  do
  {
    void *v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CD65D880((uint64_t)v5, (void *)a2, &v11);
      uint64_t v10 = v11;
      *uint64_t v11 = *(void *)a2;
      *((_DWORD *)v10 + 2) = *(_DWORD *)(a2 + 8);
      *v5 += 2;
    }
    a2 += 16;
  }
  return result;
}

llvm::Value *sub_1CD65DC58(uint64_t a1)
{
  (*(void (**)(const void **__return_ptr))(*(void *)a1 + 112))(v8);
  uint64_t v2 = sub_1CC058CAC((uint64_t)v8);
  if (v2)
  {
    int v5 = (llvm::Type *)v2;
    int v6 = (llvm::ConstantInt ***)sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
    unint64_t v3 = llvm::ConstantInt::get(*v6, v5, v7);
  }
  else
  {
    unint64_t v3 = 0;
    llvm::ConstantRange::isEmptySet(v8);
  }
  sub_1CC05EB8C((uint64_t)v8);
  return v3;
}

llvm::Value *sub_1CD65DCFC(uint64_t a1)
{
  if (!(*(unsigned int (**)(void))(*(void *)(a1 + 32) + 16))()) {
    return 0;
  }
  int v2 = *(_DWORD *)(a1 + 200);
  if (v2)
  {
    if (v2 != 1) {
      return 0;
    }
    unint64_t v4 = (llvm::ConstantInt ***)sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
    return llvm::ConstantInt::get(*v4, *(llvm::Type **)(a1 + 192), v5);
  }
  else if (*(unsigned char *)(a1 + 336))
  {
    int v6 = (llvm::ConstantInt **)sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
    return (llvm::Value *)llvm::ConstantInt::get(*v6, 0, 0);
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1CD65DDA4(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_1CD65DDAC(uint64_t a1)
{
  return a1 + 32;
}

void sub_1CD65DDB4(char *a1@<X8>)
{
  a1[23] = 8;
  strcpy(a1, "AAIsDead");
}

void *sub_1CD65DDD8()
{
  return &llvm::AAIsDead::ID;
}

uint64_t sub_1CD65DDE4()
{
  return 0;
}

BOOL sub_1CD65DDEC(uint64_t a1)
{
  return *(unsigned char *)(a1 + 9) != 0;
}

BOOL sub_1CD65DDFC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 9) == *(unsigned __int8 *)(a1 + 8);
}

uint64_t sub_1CD65DE10(uint64_t a1)
{
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a1 + 9);
  return 1;
}

uint64_t sub_1CD65DE20(uint64_t a1)
{
  *(unsigned char *)(a1 + 9) = *(unsigned char *)(a1 + 8);
  return 0;
}

uint64_t sub_1CD65DE30(uint64_t result, char a2)
{
  *(unsigned char *)(result + 9) = *(unsigned char *)(result + 9) & a2 | *(unsigned char *)(result + 8);
  return result;
}

uint64_t sub_1CD65DE48(uint64_t result, char a2)
{
  *(unsigned char *)(result + 9) |= a2;
  *(unsigned char *)(result + 8) |= a2;
  return result;
}

uint64_t sub_1CD65DE64(uint64_t result, char a2, char a3)
{
  *(unsigned char *)(result + 8) |= a3;
  *(unsigned char *)(result + 9) |= a2;
  return result;
}

uint64_t sub_1CD65DE80(uint64_t result, char a2, char a3)
{
  *(unsigned char *)(result + 8) &= a3;
  *(unsigned char *)(result + 9) &= a2;
  return result;
}

uint64_t sub_1CD65DE9C()
{
  return 0;
}

BOOL sub_1CD65DEA4(uint64_t a1, uint64_t *a2)
{
  sub_1CD65DF34(a1, a2, (uint64_t)&v8);
  int v4 = v9;
  if (v9)
  {
    uint64_t v5 = *a2;
    unsigned int v6 = *(_DWORD *)(a1 + 80);
    if (v6 >= *(_DWORD *)(a1 + 84)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 72) + 8 * v6) = v5;
    ++*(_DWORD *)(a1 + 80);
  }
  return v4 != 0;
}

void *sub_1CD65DF34@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v14 = 0;
  uint64_t result = (void *)sub_1CD4AC5C0(a1, a2, &v14);
  uint64_t v7 = v14;
  if (result)
  {
    uint64_t v8 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v9 = 8;
    }
    else
    {
      uint64_t v8 = *(void *)(a1 + 8);
      uint64_t v9 = *(unsigned int *)(a1 + 16);
    }
    char v10 = 0;
    uint64_t v11 = v8 + 8 * v9;
  }
  else
  {
    uint64_t result = sub_1CD65DFF0((_DWORD *)a1, (uint64_t)a2, a2, v14);
    uint64_t v7 = result;
    void *result = *a2;
    uint64_t v12 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v13 = 8;
    }
    else
    {
      uint64_t v12 = *(void *)(a1 + 8);
      uint64_t v13 = *(unsigned int *)(a1 + 16);
    }
    uint64_t v11 = v12 + 8 * v13;
    char v10 = 1;
  }
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v11;
  *(unsigned char *)(a3 + 16) = v10;
  return result;
}

void *sub_1CD65DFF0(_DWORD *a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *a1 >> 1;
  if (*a1) {
    unsigned int v7 = 8;
  }
  else {
    unsigned int v7 = a1[4];
  }
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - a1[1] > v7 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD65E0B0((uint64_t)a1, v7);
  uint64_t v9 = 0;
  sub_1CD4AC5C0((uint64_t)a1, a3, &v9);
  a4 = v9;
LABEL_6:
  *a1 += 2;
  if (*a4 != -4096) {
    --a1[1];
  }
  return a4;
}

uint64_t sub_1CD65E0B0(uint64_t a1, unsigned int a2)
{
  v14[8] = *MEMORY[0x1E4F143B8];
  if (a2 >= 9)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    int v6 = *(void **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 8)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD65E22C(a1, v6, &v6[v7]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = v14;
  for (uint64_t i = 8; i != 72; i += 8)
  {
    uint64_t v10 = *(void *)(a1 + i);
    if ((v10 | 0x1000) != 0xFFFFFFFFFFFFF000) {
      *v8++ = v10;
    }
  }
  if (a2 > 8)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD65E22C(a1, v14, v8);
}

uint64_t sub_1CD65E22C(uint64_t result, void *a2, void *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 72);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[v7];
  }
  do
    *v8++ = -4096;
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v10 = 0;
      uint64_t result = sub_1CD4AC5C0((uint64_t)v5, a2, &v10);
      *uint64_t v10 = *a2;
      *v5 += 2;
    }
    ++a2;
  }
  return result;
}

llvm::raw_ostream *sub_1CD65E2F4(unsigned __int8 *a1, llvm::Value *a2)
{
  unint64_t v4 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
  int v5 = sub_1CB8E509C(v4, "Delete ");
  Name = llvm::Value::getName(a2);
  size_t v8 = v6;
  uint64_t v9 = (void *)*((void *)v5 + 4);
  if (v6 <= *((void *)v5 + 3) - (void)v9)
  {
    if (v6)
    {
      memcpy(v9, Name, v6);
      *((void *)v5 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v5, Name, v6);
  }
  uint64_t v10 = sub_1CB8E509C(v5, " : ");
  uint64_t v11 = llvm::raw_ostream::operator<<(v10, a1[5465]);
  uint64_t result = sub_1CB8E509C(v11, "\n");
  if (a1[5465])
  {
    uint64_t v13 = a2;
    return (llvm::raw_ostream *)sub_1CC8AEA28((uint64_t)(a1 + 4472), (uint64_t *)&v13);
  }
  return result;
}

void *sub_1CD65E3D0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 + 3576;
  v5[0] = 4;
  v5[1] = 0;
  uint64_t v6 = a2;
  if (a2 != -8192 && a2 != -4096 && a2) {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)v5);
  }
  uint64_t result = (void *)sub_1CD64A470(v2, v5);
  if (v6 != -8192 && v6 != -4096 && v6 != 0) {
    return llvm::ValueHandleBase::RemoveFromUseList(v5);
  }
  return result;
}

void *sub_1CD65E44C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 + 2784;
  v5[0] = 4;
  v5[1] = 0;
  uint64_t v6 = a2;
  if (a2 != -8192 && a2 != -4096 && a2) {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)v5);
  }
  uint64_t result = (void *)sub_1CD64A470(v2, v5);
  if (v6 != -8192 && v6 != -4096 && v6 != 0) {
    return llvm::ValueHandleBase::RemoveFromUseList(v5);
  }
  return result;
}

uint64_t sub_1CD65E4C8(uint64_t a1, unsigned int *a2)
{
  if ((*(unsigned char *)a1 & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
  }
  *(void *)a1 = 1;
  int64x2_t v4 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  *(int64x2_t *)(a1 + 8) = v4;
  *(int64x2_t *)(a1 + 24) = v4;
  *(int64x2_t *)(a1 + 40) = v4;
  *(int64x2_t *)(a1 + 56) = v4;
  sub_1CD65E534((unsigned int *)a1, a2);
  return a1;
}

unsigned int *sub_1CD65E534(unsigned int *result, unsigned int *a2)
{
  unsigned int v2 = *a2;
  *a2 = *result & 0xFFFFFFFE | *a2 & 1;
  unsigned int v3 = result[1];
  void *result = v2 & 0xFFFFFFFE | *result & 1;
  result[1] = a2[1];
  a2[1] = v3;
  unsigned int v4 = *a2;
  if ((*result & 1) == 0)
  {
    if ((v4 & 1) == 0)
    {
      uint64_t v5 = *((void *)result + 1);
      *((void *)result + 1) = *((void *)a2 + 1);
      *((void *)a2 + 1) = v5;
      LODWORD(v5) = result[4];
      result[4] = a2[4];
      a2[4] = v5;
      return result;
    }
    unsigned int v4 = *result;
    uint64_t v6 = result;
    uint64_t result = a2;
    goto LABEL_7;
  }
  if ((v4 & 1) == 0)
  {
    uint64_t v6 = a2;
LABEL_7:
    long long v12 = *(_OWORD *)(v6 + 2);
    *uint64_t v6 = v4 | 1;
    for (uint64_t i = 2; i != 18; i += 2)
      *(void *)&v6[i] = *(void *)&result[i];
    *result &= ~1u;
    *(_OWORD *)(result + 2) = v12;
    return result;
  }
  uint64_t v8 = 0;
  uint64_t v9 = (int *)(result + 2);
  uint64_t v10 = (int *)(a2 + 2);
  do
  {
    uint64_t v11 = *(void *)&v9[v8];
    *(void *)&v9[v8] = *(void *)&v10[v8];
    *(void *)&v10[v8] = v11;
    v8 += 2;
  }
  while (v8 != 16);
  return result;
}

void *sub_1CD65E620(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 + 4776;
  v5[0] = 4;
  v5[1] = 0;
  uint64_t v6 = a2;
  if (a2 != -8192 && a2 != -4096 && a2) {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)v5);
  }
  uint64_t result = (void *)sub_1CD65E6A0(v2, v5);
  if (v6 != -8192 && v6 != -4096 && v6 != 0) {
    return llvm::ValueHandleBase::RemoveFromUseList(v5);
  }
  return result;
}

BOOL sub_1CD65E6A0(uint64_t a1, uint64_t *a2)
{
  sub_1CD65E6FC(a1, a2, (uint64_t)&v6);
  int v4 = v7;
  if (v7) {
    sub_1CC0B4168((unsigned int *)(a1 + 200), (char *)a2);
  }
  return v4 != 0;
}

unint64_t sub_1CD65E6FC@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v14 = 0;
  unint64_t result = sub_1CD64E38C(a1, (uint64_t)a2, &v14);
  unsigned __int8 v7 = v14;
  if (result)
  {
    uint64_t v8 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      unsigned int v9 = 8;
    }
    else
    {
      uint64_t v8 = *(void *)(a1 + 8);
      unsigned int v9 = *(_DWORD *)(a1 + 16);
    }
    char v10 = 0;
    uint64_t v11 = v8 + 24 * v9;
  }
  else
  {
    unsigned __int8 v7 = (unint64_t *)sub_1CD65E7C4((_DWORD *)a1, (uint64_t)a2, (uint64_t)a2, (uint64_t)v14);
    unint64_t result = sub_1CBF62D84(v7, a2);
    uint64_t v12 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      unsigned int v13 = 8;
    }
    else
    {
      uint64_t v12 = *(void *)(a1 + 8);
      unsigned int v13 = *(_DWORD *)(a1 + 16);
    }
    uint64_t v11 = v12 + 24 * v13;
    char v10 = 1;
  }
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v11;
  *(unsigned char *)(a3 + 16) = v10;
  return result;
}

uint64_t sub_1CD65E7C4(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v6 = *a1 >> 1;
  if (*a1) {
    unsigned int v7 = 8;
  }
  else {
    unsigned int v7 = a1[4];
  }
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - a1[1] > v7 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD65E884((uint64_t)a1, v7);
  uint64_t v9 = 0;
  sub_1CD64E38C((uint64_t)a1, a3, &v9);
  a4 = v9;
LABEL_6:
  *a1 += 2;
  if (*(void *)(a4 + 16) != -4096) {
    --a1[1];
  }
  return a4;
}

void *sub_1CD65E884(uint64_t a1, unsigned int a2)
{
  v24[24] = *MEMORY[0x1E4F143B8];
  unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
  int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
  if ((v5 + 1) > 0x40) {
    unsigned int v6 = v5 + 1;
  }
  else {
    unsigned int v6 = 64;
  }
  if (a2 >= 9) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = a2;
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v8 = *(uint64_t **)(a1 + 8);
    unsigned int v9 = *(_DWORD *)(a1 + 16);
    if (v7 > 8)
    {
      *(void *)(a1 + 8) = operator new(24 * v7, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v7;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD65EAF8((int *)a1, v8, &v8[3 * v9]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v10 = 0;
  v22[0] = 4;
  v22[1] = 0;
  uint64_t v23 = -4096;
  v20[0] = 4;
  v20[1] = 0;
  uint64_t v11 = v24;
  uint64_t v21 = -8192;
  do
  {
    uint64_t v12 = (void *)(a1 + v10 + 8);
    uint64_t v13 = *(void *)(a1 + v10 + 24);
    if (v13 != v23 && v13 != v21)
    {
      *uint64_t v11 = 4;
      v11[1] = 0;
      v11[2] = v13;
      if (v13 != -8192 && v13 != -4096 && v13 != 0)
      {
        unint64_t v16 = *v12 & 0xFFFFFFFFFFFFFFF8;
        v11[1] = *(void *)v16;
        *(void *)unint64_t v16 = v11;
        *uint64_t v11 = v16 | 4;
        uint64_t v17 = (unint64_t *)v11[1];
        if (v17) {
          *uint64_t v17 = *v17 & 7 | (unint64_t)(v11 + 1);
        }
      }
      v11 += 3;
      uint64_t v13 = *(void *)(a1 + v10 + 24);
    }
    if (v13 != -8192 && v13 != -4096 && v13 != 0) {
      llvm::ValueHandleBase::RemoveFromUseList(v12);
    }
    v10 += 24;
  }
  while (v10 != 192);
  if (v7 > 8)
  {
    *(_DWORD *)a1 &= ~1u;
    *(void *)(a1 + 8) = operator new(24 * v7, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v7;
  }
  unint64_t result = (void *)sub_1CD65EAF8((int *)a1, v24, v11);
  if (v21 != -8192 && v21 != -4096 && v21) {
    unint64_t result = llvm::ValueHandleBase::RemoveFromUseList(v20);
  }
  if (v23 != -8192 && v23 != -4096 && v23) {
    return llvm::ValueHandleBase::RemoveFromUseList(v22);
  }
  return result;
}

unint64_t sub_1CD65EAF8(int *a1, uint64_t *a2, uint64_t *a3)
{
  unint64_t result = (unint64_t)sub_1CD64F2C4(a1);
  while (a2 != a3)
  {
    uint64_t v7 = a2[2];
    if ((v7 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      unsigned int v9 = 0;
      sub_1CD64E38C((uint64_t)a1, (uint64_t)a2, &v9);
      unint64_t result = sub_1CBF62D84(v9, a2);
      *a1 += 2;
      uint64_t v7 = a2[2];
    }
    if (v7 != -8192 && v7 != -4096 && v7 != 0) {
      unint64_t result = (unint64_t)llvm::ValueHandleBase::RemoveFromUseList(a2);
    }
    a2 += 3;
  }
  return result;
}

unint64_t sub_1CD65EBA4(void *a1, uint64_t a2)
{
  unint64_t v4 = (llvm::IRPosition *)(a1 + 2);
  if (*(unsigned __int8 *)(sub_1CD6482F0((llvm::IRPosition *)(a1 + 2)) + 16) - 11 < 2
    || (unsigned int v10 = 25, llvm::IRPosition::hasAttr(v4, &v10, 1, 0, a2)))
  {
    uint64_t v5 = (*(uint64_t (**)(void *))(*a1 + 40))(a1);
    return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 32))(v5);
  }
  else
  {
    unsigned int v7 = sub_1CD647DEC(v4);
    if (v7 <= 6 && ((1 << v7) & 0x54) != 0)
    {
      uint64_t v8 = (llvm::GlobalValue *)sub_1CD6482A0(v4);
      if (!v8 || (unint64_t result = sub_1CD64EF44(a2, v8), (result & 1) == 0))
      {
        uint64_t v9 = (*(uint64_t (**)(void *))(*a1 + 40))(a1);
        return (*(uint64_t (**)(uint64_t))(*(void *)v9 + 40))(v9);
      }
    }
    else
    {
      return sub_1CD6482A0(v4);
    }
  }
  return result;
}

void sub_1CD65ED04(char *a1@<X8>)
{
  a1[23] = 8;
  strcpy(a1, "AANoFree");
}

void *sub_1CD65ED28()
{
  return &llvm::AANoFree::ID;
}

uint64_t sub_1CD65ED34(uint64_t a1, uint64_t a2)
{
  v11[4] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = (llvm::IRPosition *)(a1 + 16);
  if (*(unsigned __int8 *)(sub_1CD6482F0((llvm::IRPosition *)(a1 + 16)) + 16) - 11 < 2) {
    return 1;
  }
  uint64_t v9 = v11;
  uint64_t v10 = 0x400000000;
  unint64_t v7 = *(void *)v4 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~*(_DWORD *)v4 & 3) == 0) {
    unint64_t v7 = *(void *)(v7 + 24);
  }
  (*(void (**)(uint64_t, void, void **))(*(void *)a1 + 112))(a1, **(void **)v7, &v9);
  v8[0] = v9;
  v8[1] = v10;
  uint64_t v5 = llvm::IRAttributeManifest::manifestAttrs(a2, v4, (uint64_t)v8, 0);
  if (v9 != v11) {
    free(v9);
  }
  return v5;
}

unint64_t sub_1CD65EE54(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  unint64_t result = llvm::Attribute::get(a2, 0x19u, 0);
  uint64_t v5 = *(unsigned int *)(a3 + 8);
  if (v5 >= *(_DWORD *)(a3 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)a3 + 8 * v5) = result;
  *(_DWORD *)(a3 + 8) = v5 + 1;
  return result;
}

void sub_1CD65EECC(char *a1@<X8>)
{
  a1[23] = 13;
  strcpy(a1, "AAHeapToStack");
}

void *sub_1CD65EEF4()
{
  return &llvm::AAHeapToStack::ID;
}

unint64_t *sub_1CD65EF00(uint64_t *a1, uint64_t *a2)
{
  unint64_t v7 = 0;
  char v4 = sub_1CD650C48(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD65EF78((uint64_t)a1, (uint64_t)a2, a2, v7);
    *(_OWORD *)uint64_t v5 = *(_OWORD *)a2;
    uint64_t v5[2] = (unint64_t)(v5 + 4);
    v5[3] = 0x100000000;
  }
  return v5;
}

unint64_t *sub_1CD65EF78(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD65F038(a1, v7);
  uint64_t v10 = 0;
  sub_1CD650C48((uint64_t *)a1, a3, &v10);
  a4 = v10;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != (void)llvm::IRPosition::EmptyKey || a4[1] != *((void *)&llvm::IRPosition::EmptyKey + 1)) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

_OWORD *sub_1CD65F038(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(char **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  unint64_t result = operator new((unint64_t)v8 << 6, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD65F10C((char **)a1, (uint64_t)v4, (uint64_t)&v4[64 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    long long v11 = llvm::IRPosition::EmptyKey;
    uint64_t v12 = v10 << 6;
    do
    {
      _OWORD *result = v11;
      result += 4;
      v12 -= 64;
    }
    while (v12);
  }
  return result;
}

char **sub_1CD65F10C(char **result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  unint64_t v5 = result;
  result[1] = 0;
  uint64_t v7 = *((void *)&llvm::IRPosition::EmptyKey + 1);
  uint64_t v6 = llvm::IRPosition::EmptyKey;
  uint64_t v8 = *((unsigned int *)result + 4);
  if (v8)
  {
    uint64_t v9 = *result;
    uint64_t v10 = &(*result)[64 * v8];
    do
    {
      *(void *)uint64_t v9 = v6;
      *((void *)v9 + 1) = v7;
      v9 += 64;
    }
    while (v9 != v10);
    uint64_t v7 = *((void *)&llvm::IRPosition::EmptyKey + 1);
    uint64_t v6 = llvm::IRPosition::EmptyKey;
  }
  if (a2 != a3)
  {
    long long v11 = llvm::IRPosition::TombstoneKey;
    do
    {
      uint64_t v12 = *(void *)(v4 + 8);
      if ((*(void *)v4 != v6 || v12 != v7) && (*(void *)v4 != (void)v11 || v12 != *((void *)&v11 + 1)))
      {
        uint64_t v17 = 0;
        sub_1CD650C48((uint64_t *)v5, (uint64_t *)v4, &v17);
        uint64_t v15 = v17;
        *(_OWORD *)uint64_t v17 = *(_OWORD *)v4;
        v15[3] = 0x100000000;
        v15[2] = (unint64_t)(v15 + 4);
        unint64_t v16 = (unsigned int *)(v15 + 2);
        if (*(_DWORD *)(v4 + 24)) {
          sub_1CC8F1F9C(v16, (unsigned int *)(v4 + 16));
        }
        ++*((_DWORD *)v5 + 2);
        unint64_t result = sub_1CD650EAC((char **)(v4 + 16));
      }
      v4 += 64;
    }
    while (v4 != a3);
  }
  return result;
}

double sub_1CD65F22C(char **a1, char **a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *((unsigned int *)a1 + 2);
  if (v5)
  {
    uint64_t v6 = 32 * v5;
    uint64_t v7 = v4 - 32;
    do
    {
      uint64_t v8 = *(char **)&v7[v6 + 24];
      if (&v7[v6] == v8)
      {
        (*(void (**)(char *))(*(void *)&v7[v6] + 32))(&v7[v6]);
      }
      else if (v8)
      {
        (*(void (**)(char *))(*(void *)v8 + 40))(v8);
      }
      v6 -= 32;
    }
    while (v6);
    uint64_t v4 = *a1;
  }
  if (v4 != (char *)(a1 + 2)) {
    free(v4);
  }
  *a1 = *a2;
  double result = *((double *)a2 + 1);
  *((double *)a1 + 1) = result;
  *a2 = (char *)(a2 + 2);
  a2[1] = 0;
  return result;
}

uint64_t sub_1CD65F304(uint64_t a1, uint64_t a2, llvm::Value *a3, char a4)
{
  uint64_t v9 = a2;
  uint64_t v6 = sub_1CD65F394(a1 + 1480, &v9);
  if (*(void *)v6)
  {
    uint64_t v7 = llvm::Value::stripPointerCasts(*(llvm::Value **)v6);
    if (v7 == llvm::Value::stripPointerCasts(a3) || *(unsigned __int8 *)(*(void *)v6 + 16) - 11 < 2) {
      return 0;
    }
  }
  *(void *)uint64_t v6 = a3;
  *(unsigned char *)(v6 + 8) = a4;
  return 1;
}

uint64_t sub_1CD65F394(uint64_t a1, uint64_t *a2)
{
  uint64_t v14 = *a2;
  int v15 = 0;
  sub_1CD65F458(a1, &v14, &v15, (uint64_t)&v12);
  uint64_t v4 = v12;
  if (v13)
  {
    v10[0] = *a2;
    v10[1] = 0;
    char v11 = 0;
    unint64_t v7 = sub_1CD41C4F0(a1 + 520, (unint64_t)v10, 1);
    uint64_t v8 = *(void *)(a1 + 520) + 24 * *(unsigned int *)(a1 + 528);
    long long v9 = *(_OWORD *)v7;
    *(void *)(v8 + 16) = *(void *)(v7 + 16);
    *(_OWORD *)uint64_t v8 = v9;
    unsigned int v5 = *(_DWORD *)(a1 + 528);
    *(_DWORD *)(a1 + 528) = v5 + 1;
    *(_DWORD *)(v4 + 8) = v5;
  }
  else
  {
    unsigned int v5 = *(_DWORD *)(v12 + 8);
  }
  return *(void *)(a1 + 520) + 24 * v5 + 8;
}

uint64_t sub_1CD65F458@<X0>(uint64_t a1@<X0>, void *a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v16 = 0;
  uint64_t result = sub_1CC87DBEC(a1, a2, &v16);
  long long v9 = v16;
  if (result)
  {
    uint64_t v10 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v11 = 32;
    }
    else
    {
      uint64_t v10 = *(void *)(a1 + 8);
      uint64_t v11 = *(unsigned int *)(a1 + 16);
    }
    char v14 = 0;
    uint64_t v15 = v10 + 16 * v11;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CC87DC94(a1, (uint64_t)a2, a2, v16);
    long long v9 = (void *)result;
    *(void *)uint64_t result = *a2;
    *(_DWORD *)(result + 8) = *a3;
    uint64_t v12 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v13 = 32;
    }
    else
    {
      uint64_t v12 = *(void *)(a1 + 8);
      uint64_t v13 = *(unsigned int *)(a1 + 16);
    }
    uint64_t v15 = v12 + 16 * v13;
    char v14 = 1;
  }
  *(void *)a4 = v9;
  *(void *)(a4 + 8) = v15;
  *(unsigned char *)(a4 + 16) = v14;
  return result;
}

void *sub_1CD65F520(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_1CD65F5A4((uint64_t)v7, a1, a2);
  if (v7[16])
  {
    uint64_t v5 = *a2;
    unsigned int v6 = *(_DWORD *)(a1 + 32);
    if (v6 >= *(_DWORD *)(a1 + 36)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 24) + 8 * v6) = v5;
    ++*(_DWORD *)(a1 + 32);
  }
  return result;
}

void *sub_1CD65F5A4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  char v14 = 0;
  uint64_t result = (void *)sub_1CD65F664(a2, *a3, &v14);
  unint64_t v7 = v14;
  if (result)
  {
    uint64_t v8 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v9 = 1;
    }
    else
    {
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a2 + 16);
    }
    char v10 = 0;
    uint64_t v11 = v8 + 8 * v9;
  }
  else
  {
    uint64_t result = sub_1CD65F710((_DWORD *)a2, a3, v14);
    unint64_t v7 = result;
    void *result = *a3;
    uint64_t v12 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v13 = 1;
    }
    else
    {
      uint64_t v12 = *(void *)(a2 + 8);
      uint64_t v13 = *(unsigned int *)(a2 + 16);
    }
    uint64_t v11 = v12 + 8 * v13;
    char v10 = 1;
  }
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1CD65F664(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 1;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      unint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  unint64_t v7 = (void *)(v3 + 8 * v6);
  uint64_t v8 = *v7;
  if (*v7 == a2)
  {
    uint64_t result = 1;
  }
  else
  {
    char v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        char v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      unint64_t v7 = (void *)(v3 + 8 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    if (v10) {
      unint64_t v7 = v10;
    }
  }
LABEL_7:
  *a3 = v7;
  return result;
}

void *sub_1CD65F710(_DWORD *a1, uint64_t *a2, void *a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 1;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD65F7D0((uint64_t)a1, v6);
  uint64_t v8 = 0;
  sub_1CD65F664((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096) {
    --a1[1];
  }
  return a3;
}

uint64_t sub_1CD65F7D0(uint64_t a1, unsigned int a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a2 >= 2)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  int v6 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    unint64_t v7 = *(uint64_t **)(a1 + 8);
    uint64_t v8 = *(unsigned int *)(a1 + 16);
    if (a2 > 1)
    {
      uint64_t v12 = a2;
      *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v12;
    }
    else
    {
      *(_DWORD *)a1 = v6 | 1;
    }
    sub_1CD65F93C(a1, v7, &v7[v8]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v9 = &v13;
  if ((*(void *)(a1 + 8) | 0x1000) != 0xFFFFFFFFFFFFF000)
  {
    uint64_t v13 = *(void *)(a1 + 8);
    uint64_t v9 = &v14;
  }
  if (a2 >= 2)
  {
    *(_DWORD *)a1 = v6 & 0xFFFFFFFE;
    uint64_t v10 = a2;
    *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v10;
  }
  return sub_1CD65F93C(a1, &v13, v9);
}

uint64_t sub_1CD65F93C(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 16);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[v7];
  }
  do
    *v8++ = -4096;
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    uint64_t v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      int v11 = 0;
      uint64_t result = sub_1CD65F664((uint64_t)v5, v10, &v11);
      *int v11 = *a2;
      *v5 += 2;
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD65FA00(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5 = sub_1CD4B25C4(a1, a3);
  v13[0] = 0;
  v13[1] = 0;
  int v14 = 0;
  sub_1CBFCB9AC((uint64_t)v13, v5);
  long long v6 = *(_OWORD *)(v5 + 40);
  long long v15 = *(_OWORD *)(v5 + 24);
  long long v16 = v6;
  v9[0] = 0;
  v9[1] = 0;
  int v10 = 0;
  sub_1CBFCB9AC((uint64_t)v9, a1 + 176);
  long long v11 = *(_OWORD *)(a1 + 200);
  long long v12 = *(_OWORD *)(a1 + 216);
  uint64_t v7 = sub_1CD648B2C(a1, a2, v13, v9);
  MEMORY[0x1D25D9CD0](v9[0], 8);
  MEMORY[0x1D25D9CD0](v13[0], 8);
  return v7;
}

void sub_1CD65FAB8(char *a1@<X8>)
{
  a1[23] = 14;
  strcpy(a1, "AAReachability");
}

void *sub_1CD65FAE0()
{
  return &llvm::AAReachability::ID;
}

void sub_1CD65FAEC(char *a1@<X8>)
{
  a1[23] = 19;
  strcpy(a1, "AAUndefinedBehavior");
}

void *sub_1CD65FB18()
{
  return &llvm::AAUndefinedBehavior::ID;
}

uint64_t sub_1CD65FB24()
{
  return 1;
}

void sub_1CD65FB2C(char *a1@<X8>)
{
  a1[23] = 22;
}

void *sub_1CD65FB50()
{
  return &llvm::AAFunctionReachability::ID;
}

uint64_t sub_1CD65FB5C(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  long long v12 = 0;
  uint64_t result = sub_1CBA0E618(a2, a3, &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CC21C538(a2, (uint64_t)a3, a3, v12);
    uint64_t v9 = (void *)result;
    *(void *)uint64_t result = *a3;
    *(_DWORD *)(result + 8) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

void sub_1CD65FBF8(char *a1@<X8>)
{
  a1[23] = 16;
  strcpy(a1, "AAMemoryBehavior");
}

void *sub_1CD65FC18()
{
  return &llvm::AAMemoryBehavior::ID;
}

uint64_t sub_1CD65FC24(uint64_t a1, uint64_t a2)
{
  v11[4] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = (llvm::IRPosition *)(a1 + 16);
  if (*(unsigned __int8 *)(sub_1CD6482F0((llvm::IRPosition *)(a1 + 16)) + 16) - 11 < 2) {
    return 1;
  }
  uint64_t v9 = v11;
  uint64_t v10 = 0x400000000;
  unint64_t v7 = *(void *)v4 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~*(_DWORD *)v4 & 3) == 0) {
    unint64_t v7 = *(void *)(v7 + 24);
  }
  (*(void (**)(uint64_t, void, void **))(*(void *)a1 + 112))(a1, **(void **)v7, &v9);
  v8[0] = v9;
  v8[1] = v10;
  uint64_t v5 = llvm::IRAttributeManifest::manifestAttrs(a2, v4, (uint64_t)v8, 0);
  if (v9 != v11) {
    free(v9);
  }
  return v5;
}

void sub_1CD65FD44(int **a1, _WORD *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCDDFE8, 0, 0);
  dword_1EBCDE068 = 0;
  qword_1EBCDE070 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCDE078 = 0;
  qword_1EBCDDFE8 = (uint64_t)&unk_1F2643F68;
  qword_1EBCDE080 = (uint64_t)&unk_1F2643D20;
  qword_1EBCDE088 = (uint64_t)&unk_1F25F7480;
  qword_1EBCDE0A0 = (uint64_t)&qword_1EBCDE088;
  llvm::cl::Option::setArgStr(v4, "max-heap-to-stack-size", 0x16uLL);
  uint64_t v5 = *a1;
  dword_1EBCDE068 = **a1;
  byte_1EBCDE07C = 1;
  dword_1EBCDE078 = *v5;
  word_1EBCDDFF2 = (32 * (*a2 & 3)) | word_1EBCDDFF2 & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCDDFE8);
}

void sub_1CD65FE64(_WORD *a1, long long *a2, _DWORD **a3, int **a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCDE0A8, 0, 0);
  byte_1EBCDE13C = 0;
  qword_1EBCDE128 = 0;
  unk_1EBCDE130 = &unk_1F25EA1B0;
  qword_1EBCDE0A8 = (uint64_t)&unk_1F26050E8;
  qword_1EBCDE140 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCDE148 = (uint64_t)&unk_1F2605150;
  qword_1EBCDE160 = (uint64_t)&qword_1EBCDE148;
  sub_1CD65FF64(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCDE0A8);
}

uint64_t sub_1CD65FF64(_WORD *a1, long long *a2, _DWORD **a3, int **a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCDE0A8, "attributor-max-potential-values", 0x1FuLL);
  word_1EBCDE0B2 = (32 * (*a1 & 3)) | word_1EBCDE0B2 & 0xFF9F;
  xmmword_1EBCDE0C8 = *a2;
  uint64_t result = sub_1CC0777B8((uint64_t)&qword_1EBCDE128, &qword_1EBCDE0A8, *a3);
  int v9 = **a4;
  *(_DWORD *)qword_1EBCDE128 = v9;
  byte_1EBCDE13C = 1;
  dword_1EBCDE138 = v9;
  return result;
}

void sub_1CD660008(_WORD *a1, long long *a2, int **a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCDE168, 0, 0);
  dword_1EBCDE1E8 = 0;
  qword_1EBCDE1F0 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCDE1F8 = 0;
  qword_1EBCDE168 = (uint64_t)&unk_1F2643F00;
  qword_1EBCDE200 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCDE208 = (uint64_t)&unk_1F25EA168;
  qword_1EBCDE220 = (uint64_t)&qword_1EBCDE208;
  llvm::cl::Option::setArgStr(v6, "attributor-max-interfering-accesses", 0x23uLL);
  word_1EBCDE172 = (32 * (*a1 & 3)) | word_1EBCDE172 & 0xFF9F;
  xmmword_1EBCDE188 = *a2;
  dword_1EBCDE1E8 = **a3;
  byte_1EBCDE1FC = 1;
  dword_1EBCDE1F8 = dword_1EBCDE1E8;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCDE168);
}

void sub_1CD660130(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  unint64_t v3 = (uint64_t *)(*(uint64_t (**)(void))(**(void **)v2 + 16))();
  uint64_t v5 = v4;
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)v2 + 24))();
  if (v3 != (uint64_t *)v6)
  {
    unint64_t v7 = (uint64_t *)v6;
    do
    {
      uint64_t v8 = (char *)sub_1CC8C5FA0(v5, *v3, 0, 0, 2) + 48;
      if (**(char ***)(a1 + 8) != v8) {
        sub_1CC8F87A8(a1, (unint64_t)v8);
      }
      ++v3;
    }
    while (v3 != v7);
  }
}

void sub_1CD660200(std::string *a1, uint64_t a2)
{
  uint64_t v3 = a2 - 48;
  if (!a2) {
    uint64_t v3 = 0;
  }
  uint64_t v4 = (llvm::Value *)sub_1CD648A0C((llvm::IRPosition *)(v3 + 16));
  Name = llvm::Value::getName(v4);
  if (Name)
  {
    std::string::__init(a1, Name, v6);
  }
  else
  {
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
  }
}

llvm::raw_ostream *sub_1CD660270(uint64_t a1, llvm::raw_ostream *a2, uint64_t a3)
{
  (*(void (**)(uint64_t))(*(void *)a3 + 16))(a3);
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a3 + 24))(a3);
  if (*(unsigned char *)(a1 + 16))
  {
    return sub_1CB8E509C(a2, "</tr><tr>");
  }
  return result;
}

void sub_1CD660324(llvm::raw_ostream **a1, unint64_t a2, uint64_t *a3, uint64_t a4)
{
  std::string::size_type v6 = sub_1CC8C5FA0(a4, *a3, 0, 0, 2);
  char v8 = 0;
  LOBYTE(__p) = 0;
  sub_1CD460084(a1, a2, (unint64_t)v6 + 48, (uint64_t)&__p);
  if (v8 < 0) {
    operator delete(__p);
  }
}

void llvm::createBarrierNoopPass(llvm *this)
{
}

char **llvm::BlockExtractorPass::run@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  v11[68] = *MEMORY[0x1E4F143B8];
  v7[1] = 0;
  v8[0] = v9;
  v8[1] = (char *)0x400000000;
  v9[576] = 0;
  v10[0] = (char *)v11;
  v10[1] = (char *)0x400000000;
  v7[0] = (char *)v8;
  sub_1CC8F96A0((uint64_t)v8, (uint64_t *)v7);
  sub_1CD63C448(v7);
  if (sub_1CC8F9B04((uint64_t)v8, a1))
  {
    int v4 = 0;
    *(void *)(a2 + 88) = 0;
    *(_OWORD *)(a2 + 72) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 24) = 0u;
    uint64_t v5 = a2 + 32;
  }
  else
  {
    *(void *)(a2 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
    uint64_t v5 = a2 + 32;
    int v4 = 1;
  }
  *(void *)a2 = v5;
  *(void *)(a2 + 8) = v5;
  *(_DWORD *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 20) = v4;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 48) = a2 + 80;
  *(void *)(a2 + 56) = a2 + 80;
  *(void *)(a2 + 64) = 2;
  *(_DWORD *)(a2 + 72) = 0;
  sub_1CD660F0C(v10);
  return sub_1CD63C448(v8);
}

void *sub_1CD6605A4(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 8);
  if (v3 >= *(_DWORD *)(a1 + 12))
  {
    sub_1CD660628();
  }
  uint64_t result = (void *)(*(void *)a1 + 144 * v3);
  void *result = result + 2;
  result[1] = 0x1000000000;
  if (*(_DWORD *)(a2 + 8)) {
    uint64_t result = (void *)sub_1CBB08064((uint64_t)result, a2);
  }
  ++*(_DWORD *)(a1 + 8);
  return result;
}

void sub_1CD660628()
{
}

unint64_t sub_1CD6606E4(uint64_t a1, unint64_t a2)
{
  unint64_t result = sub_1CD660768(a1, a2);
  uint64_t v4 = *(void *)a1 + 136 * *(unsigned int *)(a1 + 8);
  long long v5 = *(_OWORD *)result;
  *(void *)(v4 + 16) = *(void *)(result + 16);
  *(_OWORD *)uint64_t v4 = v5;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)unint64_t result = 0;
  *(void *)(v4 + 24) = v4 + 40;
  uint64_t v6 = v4 + 24;
  *(void *)(v6 + 8) = 0x400000000;
  if (*(_DWORD *)(result + 32)) {
    unint64_t result = sub_1CD660924(v6, result + 24);
  }
  ++*(_DWORD *)(a1 + 8);
  return result;
}

unint64_t sub_1CD660768(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 136 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      sub_1CD6607D4();
    }
    sub_1CD6607D4();
  }
  return a2;
}

void sub_1CD6607D4()
{
}

void sub_1CD660844(uint64_t *a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    uint64_t v4 = *a1;
    uint64_t v5 = *a1 + 136 * v2;
    uint64_t v6 = (void *)(a2 + 24);
    uint64_t v7 = v4 + 24;
    do
    {
      long long v8 = *(_OWORD *)(v7 - 24);
      *(v6 - 1) = *(void *)(v7 - 8);
      *(_OWORD *)(v6 - 3) = v8;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      *(void *)(v7 - 24) = 0;
      *uint64_t v6 = v6 + 2;
      v6[1] = 0x400000000;
      if (*(_DWORD *)(v7 + 8)) {
        uint64_t v6 = (void *)sub_1CD660924((uint64_t)v6, v7);
      }
      uint64_t v9 = v7 - 24;
      v6 += 17;
      v7 += 136;
    }
    while (v9 + 136 != v5);
    uint64_t v10 = *((unsigned int *)a1 + 2);
    if (v10)
    {
      uint64_t v11 = *a1;
      uint64_t v12 = 136 * v10;
      do
      {
        sub_1CC076978((void **)(v11 + v12 - 112));
        if (*(char *)(v11 + v12 - 113) < 0) {
          operator delete(*(void **)(v11 + v12 - 136));
        }
        v12 -= 136;
      }
      while (v12);
    }
  }
}

uint64_t sub_1CD660924(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(char **)a2;
    if (*(void *)a2 == a2 + 16)
    {
      unsigned int v5 = *(_DWORD *)(a2 + 8);
      uint64_t v6 = *(unsigned int *)(a1 + 8);
      if (v6 >= v5)
      {
        uint64_t v15 = *(void *)a1;
        if (v5)
        {
          sub_1CC22B004((long long *)v4, (long long *)&v4[24 * v5], v15);
          uint64_t v17 = v16;
          uint64_t v15 = *(void *)a1;
          LODWORD(v6) = *(_DWORD *)(a1 + 8);
        }
        else
        {
          uint64_t v17 = *(void *)a1;
        }
        for (uint64_t i = v15 + 24 * v6; i != v17; i -= 24)
        {
          if (*(char *)(i - 1) < 0) {
            operator delete(*(void **)(i - 24));
          }
        }
        *(_DWORD *)(a1 + 8) = v5;
        uint64_t v19 = *(unsigned int *)(a2 + 8);
        if (v19)
        {
          uint64_t v20 = *(char **)a2;
          uint64_t v21 = 24 * v19;
          do
          {
            if (v20[v21 - 1] < 0) {
              operator delete(*(void **)&v20[v21 - 24]);
            }
            v21 -= 24;
          }
          while (v21);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v5)
        {
          if (v6)
          {
            uint64_t v23 = *(void *)a1;
            uint64_t v24 = 24 * v6;
            do
            {
              if (*(char *)(v23 + v24 - 1) < 0) {
                operator delete(*(void **)(v23 + v24 - 24));
              }
              v24 -= 24;
            }
            while (v24);
          }
          *(_DWORD *)(a1 + 8) = 0;
          sub_1CD477D68();
        }
        if (v6) {
          sub_1CC22B004((long long *)v4, (long long *)&v4[24 * v6], *(void *)a1);
        }
        else {
          uint64_t v6 = 0;
        }
        uint64_t v7 = *(char **)a2;
        uint64_t v8 = *(unsigned int *)(a2 + 8);
        if (v6 != v8)
        {
          uint64_t v9 = *(void *)a1 + 24 * v6;
          uint64_t v10 = &v7[24 * v6];
          uint64_t v11 = 24 * v8 - 24 * v6;
          do
          {
            long long v12 = *(_OWORD *)v10;
            *(void *)(v9 + 16) = *((void *)v10 + 2);
            *(_OWORD *)uint64_t v9 = v12;
            v9 += 24;
            *((void *)v10 + 1) = 0;
            *((void *)v10 + 2) = 0;
            *(void *)uint64_t v10 = 0;
            v10 += 24;
            v11 -= 24;
          }
          while (v11);
          uint64_t v7 = *(char **)a2;
        }
        *(_DWORD *)(a1 + 8) = v5;
        uint64_t v13 = *(unsigned int *)(a2 + 8);
        if (v13)
        {
          uint64_t v14 = 24 * v13;
          do
          {
            if (v7[v14 - 1] < 0) {
              operator delete(*(void **)&v7[v14 - 24]);
            }
            v14 -= 24;
          }
          while (v14);
        }
      }
      *(_DWORD *)(a2 + 8) = 0;
    }
    else
    {
      sub_1CD660B04((char **)a1, (char **)a2);
    }
  }
  return a1;
}

double sub_1CD660B04(char **a1, char **a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *((unsigned int *)a1 + 2);
  if (v5)
  {
    uint64_t v6 = 24 * v5;
    do
    {
      if (v4[v6 - 1] < 0) {
        operator delete(*(void **)&v4[v6 - 24]);
      }
      v6 -= 24;
    }
    while (v6);
    uint64_t v4 = *a1;
  }
  if (v4 != (char *)(a1 + 2)) {
    free(v4);
  }
  *a1 = *a2;
  double result = *((double *)a2 + 1);
  *((double *)a1 + 1) = result;
  *a2 = (char *)(a2 + 2);
  a2[1] = 0;
  return result;
}

void sub_1CD660B90(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  unint64_t v6 = a3 - a2;
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  if (v7 + ((a3 - a2) >> 4) > (unint64_t)*(unsigned int *)(a1 + 12)) {
    sub_1CD477D68();
  }
  if (a2 != a3)
  {
    uint64_t v8 = (std::string *)(*(void *)a1 + 24 * v7);
    do
    {
      uint64_t v9 = *(const std::string::value_type **)v4;
      std::string::size_type v10 = *(void *)(v4 + 8);
      v4 += 16;
      std::string::__init(v8++, v9, v10);
    }
    while (v4 != a3);
    LODWORD(v7) = *(_DWORD *)(a1 + 8);
  }
  *(_DWORD *)(a1 + 8) = v7 + (v6 >> 4);
}

uint64_t sub_1CD660C28(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(unsigned int *)(a2 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    if (v5 >= v4)
    {
      if (v4)
      {
        uint64_t v9 = *(const std::string **)a2;
        std::string::size_type v10 = *(std::string **)a1;
        uint64_t v11 = 24 * v4;
        do
        {
          std::string::operator=(v10++, v9++);
          v11 -= 24;
        }
        while (v11);
        LODWORD(v5) = *(_DWORD *)(a1 + 8);
        long long v12 = *(std::string **)a1;
      }
      else
      {
        long long v12 = *(std::string **)a1;
        std::string::size_type v10 = *(std::string **)a1;
      }
      for (uint64_t i = &v12[v5]; i != v10; --i)
      {
        if (SHIBYTE(i[-1].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(i[-1].__r_.__value_.__l.__data_);
        }
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 12) < v4)
      {
        if (v5)
        {
          uint64_t v14 = *(std::string **)a1;
          uint64_t v15 = v5;
          do
          {
            if (SHIBYTE(v14[v15 - 1].__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v14[v15 - 1].__r_.__value_.__l.__data_);
            }
            --v15;
          }
          while (v15 * 24);
        }
        *(_DWORD *)(a1 + 8) = 0;
        sub_1CD477D68();
      }
      if (v5)
      {
        unint64_t v6 = *(const std::string **)a2;
        uint64_t v7 = *(std::string **)a1;
        uint64_t v8 = 24 * v5;
        do
        {
          std::string::operator=(v7++, v6++);
          v8 -= 24;
        }
        while (v8);
      }
      else
      {
        uint64_t v5 = 0;
      }
      uint64_t v16 = *(unsigned int *)(a2 + 8);
      if (v5 != v16)
      {
        BOOL v18 = *(const std::string **)a2;
        uint64_t v19 = *(void *)a1 + 24 * v5;
        uint64_t v20 = &v18[v5];
        uint64_t v21 = 24 * v16 - 24 * v5;
        do
        {
          if (SHIBYTE(v20->__r_.__value_.__r.__words[2]) < 0)
          {
            sub_1CB8BDF7C(v19, v20->__r_.__value_.__l.__data_, v20->__r_.__value_.__l.__size_);
          }
          else
          {
            long long v22 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
            *(void *)(v19 + 16) = *((void *)&v20->__r_.__value_.__l + 2);
            *(_OWORD *)uint64_t v19 = v22;
          }
          ++v20;
          v19 += 24;
          v21 -= 24;
        }
        while (v21);
      }
    }
    *(_DWORD *)(a1 + 8) = v4;
  }
  return a1;
}

uint64_t sub_1CD660DD8(llvm::GlobalValue *a1)
{
  uint64_t result = llvm::Function::dropAllReferences((uint64_t)a1);
  int v3 = *((_DWORD *)a1 + 8);
  *((_DWORD *)a1 + 8) = v3 & 0xFFFFFFF0;
  if ((v3 & 0x30) != 0)
  {
    uint64_t result = llvm::GlobalValue::hasExternalWeakLinkage(a1);
    if ((result & 1) == 0) {
      *((_DWORD *)a1 + 8) |= 0x4000u;
    }
  }
  return result;
}

void sub_1CD660E2C(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2 != a2)
  {
    int v3 = a2;
    if (v2 <= a2)
    {
      if (*(unsigned int *)(a1 + 12) < a2) {
        sub_1CD63C324();
      }
      if (v2 != a2)
      {
        uint64_t v8 = 9 * v2;
        uint64_t v9 = 144 * a2 - 144 * v2;
        uint64_t v10 = *(void *)a1 + 16 * v8 + 16;
        do
        {
          *(void *)(v10 - 16) = v10;
          *(void *)(v10 - 8) = 0x1000000000;
          v10 += 144;
          v9 -= 144;
        }
        while (v9);
      }
    }
    else
    {
      uint64_t v5 = 9 * v2;
      unint64_t v6 = (void **)(*(void *)a1 + 16 * v5 - 144);
      uint64_t v7 = 144 * a2 - 16 * v5;
      do
      {
        if (v6 + 2 != *v6) {
          free(*v6);
        }
        v6 -= 18;
        v7 += 144;
      }
      while (v7);
    }
    *(_DWORD *)(a1 + 8) = v3;
  }
}

char **sub_1CD660F0C(char **a1)
{
  unint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 136 * v3;
    do
    {
      sub_1CC076978((void **)&v2[v4 - 112]);
      if (v2[v4 - 113] < 0) {
        operator delete(*(void **)&v2[v4 - 136]);
      }
      v4 -= 136;
    }
    while (v4);
    unint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

void sub_1CD660F88(long long *a1, long long *a2, _WORD *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCDE300, 0, 0);
  qword_1EBCDE380 = 0;
  qword_1EBCDE388 = 0;
  qword_1EBCDE3A8 = 0;
  unk_1EBCDE3B0 = 0;
  byte_1EBCDE3B8 = 0;
  qword_1EBCDE3A0 = 0;
  unk_1EBCDE390 = 0;
  unk_1EBCDE398 = &unk_1F2643C20;
  qword_1EBCDE300 = (uint64_t)&unk_1F2643FD0;
  qword_1EBCDE3C0 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCDE3C8 = (uint64_t)&unk_1F25F6428;
  qword_1EBCDE3E0 = (uint64_t)&qword_1EBCDE3C8;
  llvm::cl::Option::setArgStr(v6, "extract-blocks-file", 0x13uLL);
  xmmword_1EBCDE330 = *a1;
  xmmword_1EBCDE320 = *a2;
  word_1EBCDE30A = (32 * (*a3 & 3)) | word_1EBCDE30A & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCDE300);
}

uint64_t sub_1CD6610AC(uint64_t a1, char *a2, _OWORD *a3, _WORD *a4)
{
  uint64_t v8 = sub_1CB883A14(a1, 0, 0);
  *(unsigned char *)(v8 + 128) = 0;
  *(void *)(v8 + 136) = &unk_1F25EDE58;
  *(void *)(v8 + 144) = 0;
  *(void *)uint64_t v8 = &unk_1F26440A0;
  *(void *)(v8 + 152) = &unk_1F2643CC0;
  *(void *)(v8 + 160) = &unk_1F25EDE78;
  *(void *)(v8 + 184) = v8 + 160;
  size_t v9 = strlen(a2);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)a2, v9);
  *(_OWORD *)(a1 + 32) = *a3;
  *(_WORD *)(a1 + 10) = (32 * (*a4 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

double llvm::CalledValuePropagationPass::run@<D0>(uint64_t *a1@<X1>, uint64_t a2@<X8>)
{
  sub_1CC8FA4CC(a1);
  *(void *)(a2 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a2 = a2 + 32;
  *(void *)(a2 + 8) = a2 + 32;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 48) = a2 + 80;
  *(void *)(a2 + 56) = a2 + 80;
  *(void *)(a2 + 64) = 2;
  *(_DWORD *)(a2 + 72) = 0;
  *(void *)&double result = 0x100000002;
  *(void *)(a2 + 16) = 0x100000002;
  return result;
}

void llvm::createCalledValuePropagationPass(llvm *this)
{
}

double llvm::ConstantMergePass::run@<D0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if (sub_1CC8FE808(a1))
  {
    int v3 = 0;
    *(void *)(a2 + 88) = 0;
    *(_OWORD *)(a2 + 72) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 24) = 0u;
    uint64_t v4 = a2 + 32;
  }
  else
  {
    *(void *)(a2 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
    uint64_t v4 = a2 + 32;
    int v3 = 1;
  }
  *(void *)a2 = v4;
  *(void *)(a2 + 8) = v4;
  *(_DWORD *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 20) = v3;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 48) = a2 + 80;
  *(void *)(a2 + 56) = a2 + 80;
  *(void *)&double result = 2;
  *(void *)(a2 + 64) = 2;
  *(_DWORD *)(a2 + 72) = 0;
  return result;
}

void llvm::createConstantMergePass(llvm *this)
{
}

void llvm::CrossDSOCFIPass::run(void **a1@<X1>, uint64_t a2@<X8>)
{
  sub_1CC8FF6C8((uint64_t)v6);
  if (sub_1CC8FF778((uint64_t)v6, a1))
  {
    int v4 = 0;
    *(void *)(a2 + 88) = 0;
    *(_OWORD *)(a2 + 72) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 24) = 0u;
    uint64_t v5 = a2 + 32;
  }
  else
  {
    *(void *)(a2 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
    uint64_t v5 = a2 + 32;
    int v4 = 1;
  }
  *(void *)a2 = v5;
  *(void *)(a2 + 8) = v5;
  *(_DWORD *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 20) = v4;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 48) = a2 + 80;
  *(void *)(a2 + 56) = a2 + 80;
  *(void *)(a2 + 64) = 2;
  *(_DWORD *)(a2 + 72) = 0;
  llvm::Pass::~Pass((llvm::Pass *)v6);
}

uint64_t sub_1CD6613C8(uint64_t a1, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v9[3] = *MEMORY[0x1E4F143B8];
  v9[0] = a3;
  v9[1] = a4;
  void v9[2] = a5;
  uint64_t v6 = (llvm::PointerType *)llvm::FunctionType::get(a2, (uint64_t)v9, 3, 0);
  llvm::Module::getOrInsertFunction(a1, "__cfi_check", (const char *)0xB, v6, 0);
  return v7;
}

llvm::PointerType *sub_1CD661480(uint64_t a1, unsigned __int8 *a2, const char *a3, uint64_t a4, uint64_t **a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13[2] = *MEMORY[0x1E4F143B8];
  v13[0] = a6;
  v13[1] = a7;
  uint64_t v11 = (llvm::PointerType *)llvm::FunctionType::get(a5, (uint64_t)v13, 2, 0);
  return llvm::Module::getOrInsertFunction(a1, a2, a3, v11, a4);
}

void llvm::createDeadArgEliminationPass(llvm *this)
{
}

char *sub_1CD661590(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8, const char **a9, llvm::BasicBlock *a10)
{
  int v16 = 0;
  if (a8)
  {
    uint64_t v17 = 48 * a8;
    BOOL v18 = (void *)(a7 + 32);
    do
    {
      v16 += (*v18 - *(v18 - 1)) >> 3;
      v18 += 6;
      v17 -= 48;
    }
    while (v17);
  }
  signed int v19 = a6 + v16 + 3;
  uint64_t v20 = llvm::User::operator new((llvm::User *)0x50, v19, 16 * (int)a8);
  uint64_t v21 = llvm::Instruction::Instruction((llvm::Instruction *)v20, **(llvm::Type ***)(a1 + 16), 5, (llvm::Use *)&v20[-32 * v19], v19, a10);
  *((void *)v21 + 8) = 0;
  llvm::InvokeInst::init((uint64_t)v21, a1, a2, a3, a4, a5, a6, v22, a7, a8, a9);
  return v20;
}

double llvm::EliminateAvailableExternallyPass::run@<D0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if (sub_1CC904F88(a1))
  {
    int v3 = 0;
    *(void *)(a2 + 88) = 0;
    *(_OWORD *)(a2 + 72) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 24) = 0u;
    uint64_t v4 = a2 + 32;
  }
  else
  {
    *(void *)(a2 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
    uint64_t v4 = a2 + 32;
    int v3 = 1;
  }
  *(void *)a2 = v4;
  *(void *)(a2 + 8) = v4;
  *(_DWORD *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 20) = v3;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 48) = a2 + 80;
  *(void *)(a2 + 56) = a2 + 80;
  *(void *)&double result = 2;
  *(void *)(a2 + 64) = 2;
  *(_DWORD *)(a2 + 72) = 0;
  return result;
}

void llvm::createEliminateAvailableExternallyPass(llvm *this)
{
}

double llvm::ForceFunctionAttrsPass::run@<D0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if (qword_1EBCDE590 == unk_1EBCDE598 && qword_1EBCDE668 == unk_1EBCDE670)
  {
    *(void *)(a2 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
    *(void *)a2 = a2 + 32;
    *(void *)(a2 + 8) = a2 + 32;
    *(_DWORD *)(a2 + 24) = 0;
    *(void *)(a2 + 48) = a2 + 80;
    *(void *)(a2 + 56) = a2 + 80;
    *(void *)(a2 + 64) = 2;
    *(_DWORD *)(a2 + 72) = 0;
    *(void *)&double result = 0x100000002;
    *(void *)(a2 + 16) = 0x100000002;
  }
  else
  {
    uint64_t v4 = a1 + 24;
    for (uint64_t i = *(void *)(a1 + 32); i != v4; uint64_t i = *(void *)(i + 8))
    {
      if (i) {
        unint64_t v6 = i - 56;
      }
      else {
        unint64_t v6 = 0;
      }
      sub_1CC9061A4(v6);
    }
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(void *)(a2 + 88) = 0;
    *(_OWORD *)(a2 + 72) = 0u;
    *(_OWORD *)(a2 + 24) = 0u;
    *(void *)a2 = a2 + 32;
    *(void *)(a2 + 8) = a2 + 32;
    *(void *)&double result = 2;
    *(void *)(a2 + 16) = 2;
    *(void *)(a2 + 48) = a2 + 80;
    *(void *)(a2 + 56) = a2 + 80;
    *(_DWORD *)(a2 + 64) = 2;
  }
  return result;
}

void llvm::createForceFunctionAttrsLegacyPass(llvm *this)
{
}

void sub_1CD661878(_WORD *a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCDE510, 1, 0);
  qword_1EBCDE590 = 0;
  unk_1EBCDE598 = 0;
  qword_1EBCDE5A0 = 0;
  unk_1EBCDE5A8 = 0;
  qword_1EBCDE510 = (uint64_t)&unk_1F260A070;
  qword_1EBCDE5B0 = 0;
  unk_1EBCDE5B8 = 0;
  qword_1EBCDE5C0 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCDE5C8 = (uint64_t)&unk_1F260AC78;
  qword_1EBCDE5E0 = (uint64_t)&qword_1EBCDE5C8;
  llvm::cl::Option::setArgStr(v4, "force-attribute", 0xFuLL);
  word_1EBCDE51A = (32 * (*a1 & 3)) | word_1EBCDE51A & 0xFF9F;
  xmmword_1EBCDE530 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCDE510);
}

void sub_1CD66196C(_WORD *a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCDE5E8, 1, 0);
  qword_1EBCDE668 = 0;
  unk_1EBCDE670 = 0;
  qword_1EBCDE678 = 0;
  unk_1EBCDE680 = 0;
  qword_1EBCDE5E8 = (uint64_t)&unk_1F260A070;
  qword_1EBCDE688 = 0;
  unk_1EBCDE690 = 0;
  qword_1EBCDE698 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCDE6A0 = (uint64_t)&unk_1F260AC78;
  qword_1EBCDE6B8 = (uint64_t)&qword_1EBCDE6A0;
  llvm::cl::Option::setArgStr(v4, "force-remove-attribute", 0x16uLL);
  word_1EBCDE5F2 = (32 * (*a1 & 3)) | word_1EBCDE5F2 & 0xFF9F;
  xmmword_1EBCDE608 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCDE5E8);
}

uint64_t llvm::computeFunctionBodyMemoryAccess(llvm *this, llvm::Function *a2, llvm::AAResults *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  memset(v11, 0, sizeof(v11));
  uint64_t v5 = 1;
  int64x2_t v6 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  int64x2_t v7 = v6;
  int64x2_t v8 = v6;
  int64x2_t v9 = v6;
  v10[0] = v11;
  v10[1] = (void *)0x800000000;
  uint64_t v3 = sub_1CC90686C((uint64_t)this, 1, (uint64_t)a2, (uint64_t)&v5);
  if (v10[0] != v11) {
    free(v10[0]);
  }
  if ((v5 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v6.i64[0], 8);
  }
  return v3;
}

void llvm::createPostOrderFunctionAttrsLegacyPass(llvm *this)
{
}

void llvm::createReversePostOrderFunctionAttrsPass(llvm *this)
{
}

void llvm::ReversePostOrderFunctionAttrsPass::run()
{
}

uint64_t *sub_1CD661C80(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (!a2) {
    return (uint64_t *)(a1 + 16 * a2);
  }
  LODWORD(v3) = (37 * a3) & (a2 - 1);
  uint64_t v4 = (uint64_t *)(a1 + 16 * v3);
  uint64_t v5 = *v4;
  if (*v4 != a3)
  {
    int v7 = 1;
    while (v5 != -1)
    {
      int v8 = v3 + v7++;
      uint64_t v3 = v8 & (a2 - 1);
      uint64_t v5 = *(void *)(a1 + 16 * v3);
      if (v5 == a3) {
        return (uint64_t *)(a1 + 16 * v3);
      }
    }
    return (uint64_t *)(a1 + 16 * a2);
  }
  return v4;
}

uint64_t llvm::ComputeCrossModuleImportForModule(void *__s2, size_t __n, uint64_t a3, uint64_t a4)
{
  v9[0] = 0;
  v9[1] = 0;
  int v10 = 0;
  llvm::ModuleSummaryIndex::collectDefinedFunctionsForModule(a3, __s2, __n, (uint64_t)v9);
  sub_1CC912D30((uint64_t)v9, a3, __s2, __n, a4, 0);
  return MEMORY[0x1D25D9CD0](v9[0], 8);
}

uint64_t llvm::ComputeCrossModuleImportForModuleFromIndex(uint64_t __s2, size_t __n, void *a3, uint64_t a4)
{
  uint64_t v4 = a3 + 1;
  uint64_t v5 = (void *)*a3;
  if ((void *)*a3 != a3 + 1)
  {
    int v8 = (const void *)__s2;
    do
    {
      int64x2_t v9 = (uint64_t *)v5[7];
      if (v9 != (uint64_t *)v5[8])
      {
        unint64_t v17 = v5[4];
        uint64_t v10 = *v9;
        uint64_t v11 = *(unsigned __int8 **)(v10 + 24);
        size_t v12 = *(void *)(v10 + 32);
        if (v12 != __n || __n && (__s2 = memcmp(*(const void **)(v10 + 24), v8, __n), __s2))
        {
          int v16 = sub_1CD66421C(a4, v11, v12);
          __s2 = (uint64_t)sub_1CC7C0480(*v16 + 8, &v17, &v17);
        }
      }
      uint64_t v13 = (void *)v5[1];
      if (v13)
      {
        do
        {
          uint64_t v14 = v13;
          uint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v14 = (void *)v5[2];
          BOOL v15 = *v14 == (void)v5;
          uint64_t v5 = v14;
        }
        while (!v15);
      }
      uint64_t v5 = v14;
    }
    while (v14 != v4);
  }
  return __s2;
}

uint64_t llvm::convertToDeclaration(llvm *this, llvm::GlobalValue *a2)
{
  if (*((unsigned char *)this + 16) == 3)
  {
    if ((*((unsigned char *)this + 34) & 0x40) != 0)
    {
      SectionImpl = llvm::GlobalObject::getSectionImpl(this);
      if (v8 == 12 && *(void *)SectionImpl == 0x7274702E6D766C6CLL && *((_DWORD *)SectionImpl + 2) == 1752462689) {
        llvm::report_fatal_error((llvm *)"can't convert llvm.ptrauth to declaration!", (const llvm::Twine *)1);
      }
    }
    llvm::GlobalVariable::setInitializer((uint64_t)this, 0);
    int v10 = *((_DWORD *)this + 8);
    *((_DWORD *)this + 8) = v10 & 0xFFFFFFF0;
    if ((v10 & 0x30) != 0 && (llvm::GlobalValue::hasExternalWeakLinkage(this) & 1) == 0) {
      *((_DWORD *)this + 8) |= 0x4000u;
    }
LABEL_14:
    llvm::Value::clearMetadata((uint64_t)this);
    uint64_t v11 = *((void *)this + 6);
    if (v11) {
      llvm::Comdat::removeUser(v11, (uint64_t)this);
    }
    *((void *)this + 6) = 0;
    int v12 = *((_DWORD *)this + 8);
    if ((v12 & 0xFu) - 7 < 2) {
      return 1;
    }
    if ((v12 & 0x30) != 0)
    {
      if (!llvm::GlobalValue::hasExternalWeakLinkage(this)) {
        return 1;
      }
      int v12 = *((_DWORD *)this + 8);
    }
    *((_DWORD *)this + 8) = v12 & 0xFFFFBFFF;
    return 1;
  }
  if (!*((unsigned char *)this + 16))
  {
    sub_1CD660DD8(this);
    goto LABEL_14;
  }
  uint64_t v3 = *((void *)this + 3);
  if (*(unsigned char *)(v3 + 8) == 14)
  {
    uint64_t AddressSpace = llvm::GlobalValue::getAddressSpace(this);
    __int16 v17 = 257;
    uint64_t v5 = *((void *)this + 5);
    int64x2_t v6 = (unint64_t *)llvm::User::operator new((llvm::User *)0x78);
    llvm::Function::Function(v6, v3, 0, AddressSpace, v16, v5);
  }
  else
  {
    int64x2_t v6 = llvm::User::operator new((llvm::User *)0x58, 1u);
    uint64_t v14 = *((void *)this + 5);
    BOOL v15 = (llvm::PointerType *)*((void *)this + 3);
    __int16 v17 = 257;
    llvm::GlobalVariable::GlobalVariable(v6, v14, v15, 0, 0, 0, v16, 0, (*((_DWORD *)this + 8) >> 10) & 7, (llvm::Type *)(((unint64_t)*(unsigned int *)(*(void *)this + 8) >> 8) | 0x100000000), 0);
  }
  llvm::Value::takeName((int32x2_t ****)v6, this);
  llvm::Value::replaceAllUsesWith(this, (llvm::Value *)v6);
  return 0;
}

uint64_t llvm::thinLTOFinalizeInModule(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3 = result;
  uint64_t v13 = a2;
  uint64_t v4 = result + 24;
  uint64_t v5 = *(void *)(result + 32);
  if (v5 != result + 24)
  {
    do
    {
      if (v5) {
        uint64_t v7 = v5 - 56;
      }
      else {
        uint64_t v7 = 0;
      }
      double result = sub_1CC9141BC((uint64_t)&v13, v7, a3);
      uint64_t v5 = *(void *)(v5 + 8);
    }
    while (v5 != v4);
  }
  for (uint64_t i = *(void *)(v3 + 16); i != v3 + 8; uint64_t i = *(void *)(i + 8))
  {
    if (i) {
      uint64_t v9 = i - 56;
    }
    else {
      uint64_t v9 = 0;
    }
    double result = sub_1CC9141BC((uint64_t)&v13, v9, 0);
  }
  uint64_t v10 = v3 + 40;
  for (uint64_t j = *(void *)(v3 + 48); j != v10; uint64_t j = *(void *)(j + 8))
  {
    if (j) {
      uint64_t v12 = j - 48;
    }
    else {
      uint64_t v12 = 0;
    }
    double result = sub_1CC9141BC((uint64_t)&v13, v12, 0);
  }
  return result;
}

uint64_t llvm::thinLTOInternalizeModule(llvm::Module *a1, uint64_t a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  v3[0] = &unk_1F2628368;
  v3[1] = a2;
  v3[2] = a1;
  uint64_t v4 = v3;
  sub_1CC9144B8(a1, v3, 0);
  uint64_t result = (uint64_t)v4;
  if (v4 == v3) {
    return (*(uint64_t (**)(void *))(v3[0] + 32))(v3);
  }
  if (v4) {
    return (*(uint64_t (**)(void))(*v4 + 40))();
  }
  return result;
}

void *llvm::FunctionImporter::importFunctions@<X0>(uint64_t a1@<X0>, llvm::Module *a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  llvm::IRMover::IRMover((llvm::IRMover *)v63, a2);
  v62[0] = 0;
  v62[1] = 0;
  v61 = v62;
  uint64_t v7 = *(unsigned int *)(a3 + 8);
  if (v7)
  {
    for (uint64_t i = *(uint64_t ***)a3; !*i || *i + 1 == 0; ++i)
      ;
  }
  else
  {
    uint64_t i = *(uint64_t ***)a3;
  }
  uint64_t v10 = *(void *)a3 + 8 * v7;
  if (i == (uint64_t **)v10) {
    goto LABEL_79;
  }
  uint64_t v11 = *i;
  do
  {
    uint64_t v12 = *v11;
    *(void *)&long long v70 = v11 + 6;
    *((void *)&v70 + 1) = v12;
    sub_1CC91641C((uint64_t)&v61, (uint64_t)&v70, &v70);
    do
    {
      uint64_t v13 = i[1];
      ++i;
      uint64_t v11 = v13;
      if (v13) {
        BOOL v14 = v11 + 1 == 0;
      }
      else {
        BOOL v14 = 1;
      }
    }
    while (v14);
  }
  while (i != (uint64_t **)v10);
  if (v61 == v62)
  {
LABEL_79:
    v49 = (void *)*((void *)a2 + 2);
    if (v49 == (void *)((char *)a2 + 8))
    {
LABEL_95:
      a4[8] &= ~1u;
      *a4 = 0;
      goto LABEL_96;
    }
    while (1)
    {
      if (v49) {
        v50 = v49 - 7;
      }
      else {
        v50 = 0;
      }
      if (v49 && *((unsigned char *)v50 + 16) == 3)
      {
        if ((*((_DWORD *)v50 + 5) & 0x7FFFFFF) != 0) {
          goto LABEL_88;
        }
      }
      else if (*((unsigned char *)v50 + 16) || (void *)v50[9] != v50 + 9 || (*((unsigned char *)v50 + 34) & 0x80) != 0)
      {
LABEL_88:
        if (llvm::AttributeSet::hasAttribute(v50 + 9, (uint64_t)"thinlto-internalize", 19)) {
          *((_DWORD *)v50 + 8) = v50[4] & 0xFFFFBFC0 | 0x4007;
        }
      }
      v49 = (void *)v49[1];
      if (v49 == (void *)((char *)a2 + 8)) {
        goto LABEL_95;
      }
    }
  }
  BOOL v15 = (unsigned __int8 *)v61[4];
  size_t v16 = (size_t)v61[5];
  int Key = llvm::StringMapImpl::FindKey((uint64_t *)a3, v15, v16);
  uint64_t v18 = *(void *)a3;
  if (Key == -1) {
    uint64_t v19 = *(unsigned int *)(a3 + 8);
  }
  else {
    uint64_t v19 = Key;
  }
  *(void *)&long long v70 = v15;
  *((void *)&v70 + 1) = v16;
  uint64_t v20 = *(void *)(a1 + 32);
  if (!v20) {
    sub_1CB920400();
  }
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v20 + 48))(&v68);
  uint64_t v21 = v68;
  uint64_t v68 = 0;
  if (v69)
  {
    a4[8] |= 1u;
    *(void *)a4 = v21;
    sub_1CC1CC83C((uint64_t)&v68);
    goto LABEL_96;
  }
  llvm::Module::materializeMetadata((llvm::Module *)v21, &v70);
  uint64_t v23 = v70;
  if ((void)v70)
  {
    a4[8] |= 1u;
    *(void *)a4 = v23;
    goto LABEL_26;
  }
  uint64_t v24 = (void *)(*(void *)(v18 + 8 * v19) + 8);
  v56[0] = 0;
  v56[1] = 0;
  int v57 = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  uint64_t v58 = 0;
  for (uint64_t j = *(void *)(v21 + 32); ; uint64_t j = *(void *)(j + 8))
  {
    if (j == v21 + 24)
    {
      for (uint64_t k = *(void *)(v21 + 16); ; uint64_t k = *(void *)(k + 8))
      {
        if (k == v21 + 8)
        {
          uint64_t v36 = *(void *)(v21 + 48);
          if (v36 == v21 + 40)
          {
LABEL_78:
            llvm::UpgradeDebugInfo((llvm **)v21, v22);
            llvm::Module::setPartialSampleProfileRatio((llvm::Module *)v21, *(const llvm::ModuleSummaryIndex **)a1);
            llvm::renameModuleForThinLTO(v21, *(void *)a1, *(unsigned char *)(a1 + 40), (uint64_t)v56);
          }
          while (1)
          {
            if (v36) {
              uint64_t v37 = v36 - 48;
            }
            else {
              uint64_t v37 = 0;
            }
            if ((*(unsigned char *)(v37 + 23) & 0x10) != 0)
            {
              v67[0] = 0;
              v67[0] = sub_1CD4AC784((llvm::GlobalValue *)v37);
              if (sub_1CC7C03C0(v24, v67))
              {
                llvm::GlobalValue::materialize((llvm::Module **)v37, &v70);
                unint64_t v35 = v70;
                if ((void)v70) {
                  goto LABEL_76;
                }
                AliaseeObject = (llvm::Module **)llvm::GlobalAlias::getAliaseeObject((llvm::GlobalAlias *)v37);
                llvm::GlobalValue::materialize(AliaseeObject, &v70);
                unint64_t v35 = v70;
                if ((void)v70) {
                  goto LABEL_76;
                }
                v39 = (llvm::Function *)llvm::GlobalAlias::getAliaseeObject((llvm::GlobalAlias *)v37);
                int v71 = 128;
                *(void *)&long long v70 = operator new(0x2000uLL, (std::align_val_t)8uLL);
                sub_1CC7AF4A4(&v70);
                v72[0] = 0;
                v72[24] = 0;
                v40 = llvm::CloneFunction(v39, (uint64_t)&v70);
                sub_1CC1966A4((llvm::GlobalValue *)v40, *(_DWORD *)(v37 + 32) & 0xF);
                sub_1CC196644((uint64_t)v40, (*(_DWORD *)(v37 + 32) >> 4) & 3);
                BitCast = llvm::ConstantExpr::getBitCast((llvm::detail::IEEEFloat *)v40, *(llvm::Constant **)v37, 0);
                llvm::Value::replaceAllUsesWith((llvm::Value *)v37, BitCast);
                llvm::Value::takeName((int32x2_t ****)v40, (llvm::Value *)v37);
                sub_1CC009354((uint64_t)v72);
                sub_1CC4D021C(&v70);
                MEMORY[0x1D25D9CD0](v70, 8);
                if (byte_1EBCDF2A8)
                {
                  uint64_t v42 = *(void *)a2;
                  char v43 = *(unsigned char *)(v21 + 215);
                  BOOL v44 = v43 < 0;
                  if (v43 >= 0) {
                    v45 = (unsigned __int8 *)(v21 + 192);
                  }
                  else {
                    v45 = *(unsigned __int8 **)(v21 + 192);
                  }
                  size_t v46 = v43 & 0x7F;
                  if (v44) {
                    size_t v47 = *(void *)(v21 + 200);
                  }
                  else {
                    size_t v47 = v46;
                  }
                  *(void *)&long long v70 = llvm::MDString::get(*(uint64_t **)a2, v45, v47);
                  Impl = llvm::MDTuple::getImpl(v42, &v70, 1, 0, 1);
                  llvm::Value::setMetadata((uint64_t)v40, "thinlto_src_module", 0x12uLL, Impl);
                }
                *(void *)&long long v70 = v40;
                sub_1CC9146E4(v56, &v70);
              }
            }
            uint64_t v36 = *(void *)(v36 + 8);
            if (v36 == v21 + 40) {
              goto LABEL_78;
            }
          }
        }
        if (k) {
          uint64_t v34 = (llvm::GlobalValue *)(k - 56);
        }
        else {
          uint64_t v34 = 0;
        }
        if ((*((unsigned char *)v34 + 23) & 0x10) != 0)
        {
          *(void *)&long long v70 = 0;
          *(void *)&long long v70 = sub_1CD4AC784(v34);
          if (sub_1CC7C03C0(v24, (unint64_t *)&v70))
          {
            llvm::GlobalValue::materialize((llvm::Module **)v34, v67);
            unint64_t v35 = v67[0];
            if (v67[0])
            {
LABEL_76:
              a4[8] |= 1u;
              *(void *)a4 = v35;
              goto LABEL_77;
            }
            v67[0] = (unint64_t)v34;
            sub_1CC9146E4(v56, v67);
          }
        }
      }
    }
    uint64_t v26 = j ? (llvm::GlobalValue *)(j - 56) : 0;
    if ((*((unsigned char *)v26 + 23) & 0x10) != 0)
    {
      *(void *)&long long v70 = 0;
      *(void *)&long long v70 = sub_1CD4AC784(v26);
      if (sub_1CC7C03C0(v24, (unint64_t *)&v70)) {
        break;
      }
    }
LABEL_35:
    ;
  }
  llvm::GlobalValue::materialize((llvm::Module **)v26, v67);
  unint64_t v27 = v67[0];
  if (!v67[0])
  {
    if (byte_1EBCDF2A8)
    {
      uint64_t v28 = *(void *)a2;
      char v29 = *(unsigned char *)(v21 + 215);
      if (v29 >= 0) {
        uint64_t v30 = (unsigned __int8 *)(v21 + 192);
      }
      else {
        uint64_t v30 = *(unsigned __int8 **)(v21 + 192);
      }
      if (v29 >= 0) {
        size_t v31 = v29 & 0x7F;
      }
      else {
        size_t v31 = *(void *)(v21 + 200);
      }
      v67[0] = (unint64_t)llvm::MDString::get(*(uint64_t **)a2, v30, v31);
      uint64_t v32 = llvm::MDTuple::getImpl(v28, v67, 1, 0, 1);
      llvm::Value::setMetadata((uint64_t)v26, "thinlto_src_module", 0x12uLL, v32);
    }
    v67[0] = (unint64_t)v26;
    sub_1CC9146E4(v56, v67);
    goto LABEL_35;
  }
  a4[8] |= 1u;
  *(void *)a4 = v27;
LABEL_77:
  sub_1CD456CB4(v56);
LABEL_26:
  if (v21)
  {
    llvm::Module::~Module((llvm::Module *)v21);
    MEMORY[0x1D25D9CE0]();
  }
  sub_1CC1CC83C((uint64_t)&v68);
LABEL_96:
  sub_1CB833A08((uint64_t)&v61, v62[0]);
  uint64_t v51 = v65;
  if (v66)
  {
    uint64_t v52 = 16 * v66;
    v53 = (unsigned __int8 **)(v65 + 8);
    do
    {
      if (((unint64_t)*(v53 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000 && *v53) {
        llvm::MetadataTracking::untrack((uint64_t)v53, *v53);
      }
      v53 += 2;
      v52 -= 16;
    }
    while (v52);
    uint64_t v51 = v65;
  }
  MEMORY[0x1D25D9CD0](v51, 8);
  return sub_1CC9159BC(v64);
}

double llvm::FunctionImportPass::run@<D0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if (sub_1CC914804(a1))
  {
    int v3 = 0;
    *(void *)(a2 + 88) = 0;
    *(_OWORD *)(a2 + 72) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 24) = 0u;
    uint64_t v4 = a2 + 32;
  }
  else
  {
    *(void *)(a2 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
    uint64_t v4 = a2 + 32;
    int v3 = 1;
  }
  *(void *)a2 = v4;
  *(void *)(a2 + 8) = v4;
  *(_DWORD *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 20) = v3;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 48) = a2 + 80;
  *(void *)(a2 + 56) = a2 + 80;
  *(void *)&double result = 2;
  *(void *)(a2 + 64) = 2;
  *(_DWORD *)(a2 + 72) = 0;
  return result;
}

void llvm::createFunctionImportPass(llvm *this)
{
}

llvm::raw_ostream *sub_1CD662C0C(llvm::raw_ostream *a1, void *a2)
{
  llvm::raw_ostream::operator<<(a1, *(void *)(*a2 & 0xFFFFFFFFFFFFFFF8));
  unint64_t v4 = *a2 & 0xFFFFFFFFFFFFFFF8;
  if (*a2) {
    llvm::Value::getName(*(llvm::Value **)(v4 + 8));
  }
  else {
    uint64_t v5 = *(void *)(v4 + 16);
  }
  if (v5)
  {
    int64x2_t v6 = sub_1CB8E509C(a1, " (");
    unint64_t v7 = *a2 & 0xFFFFFFFFFFFFFFF8;
    if (*a2)
    {
      Name = llvm::Value::getName(*(llvm::Value **)(v7 + 8));
      size_t v9 = v10;
    }
    else
    {
      Name = *(char **)(v7 + 8);
      size_t v9 = *(void *)(v7 + 16);
    }
    uint64_t v11 = (void *)*((void *)v6 + 4);
    if (v9 <= *((void *)v6 + 3) - (void)v11)
    {
      if (v9)
      {
        memcpy(v11, Name, v9);
        *((void *)v6 + 4) += v9;
      }
    }
    else
    {
      llvm::raw_ostream::write(v6, Name, v9);
    }
    sub_1CB8E509C(v6, ")");
  }
  return a1;
}

void *sub_1CD662CF4(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  unsigned int v8 = *(_DWORD *)(a2 + 16);
  if (!v8)
  {
    BOOL v14 = 0;
LABEL_6:
    double result = sub_1CD662DFC(a2, a3, v14);
    void *result = *a3;
    *((_DWORD *)result + 2) = *(_DWORD *)a4;
    result[2] = *(void *)(a4 + 8);
    uint64_t v15 = *(void *)(a4 + 16);
    *(void *)(a4 + 16) = 0;
    result[3] = v15;
    uint64_t v9 = *(void *)a2;
    unsigned int v8 = *(_DWORD *)(a2 + 16);
    char v13 = 1;
    goto LABEL_4;
  }
  uint64_t v9 = *(void *)a2;
  uint64_t v10 = (37 * *a3) & (v8 - 1);
  double result = (void *)(*(void *)a2 + 32 * v10);
  uint64_t v12 = *result;
  if (*a3 != *result)
  {
    size_t v16 = 0;
    int v17 = 1;
    while (v12 != -1)
    {
      if (v16) {
        BOOL v18 = 0;
      }
      else {
        BOOL v18 = v12 == -2;
      }
      if (v18) {
        size_t v16 = result;
      }
      int v19 = v10 + v17++;
      uint64_t v10 = v19 & (v8 - 1);
      double result = (void *)(v9 + 32 * v10);
      uint64_t v12 = *result;
      if (*a3 == *result) {
        goto LABEL_3;
      }
    }
    if (v16) {
      BOOL v14 = v16;
    }
    else {
      BOOL v14 = result;
    }
    goto LABEL_6;
  }
LABEL_3:
  char v13 = 0;
LABEL_4:
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v9 + 32 * v8;
  *(unsigned char *)(a1 + 16) = v13;
  return result;
}

void *sub_1CD662DFC(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    sub_1CD662F74(a1, 2 * v6);
    uint64_t v7 = *a2;
    int v9 = *(_DWORD *)(a1 + 16) - 1;
    uint64_t v10 = (37 * *a2) & v9;
    a3 = (void *)(*(void *)a1 + 32 * v10);
    uint64_t v11 = *a3;
    if (*a2 != *a3)
    {
      uint64_t v12 = 0;
      int v13 = 1;
      while (v11 != -1)
      {
        if (v12) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v11 == -2;
        }
        if (v14) {
          uint64_t v12 = a3;
        }
        int v15 = v10 + v13++;
        uint64_t v10 = v15 & v9;
        a3 = (void *)(*(void *)a1 + 32 * v10);
        uint64_t v11 = *a3;
        if (v7 == *a3) {
          goto LABEL_4;
        }
      }
      goto LABEL_20;
    }
  }
  else
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
    {
LABEL_3:
      uint64_t v7 = *a3;
      goto LABEL_4;
    }
    sub_1CD662F74(a1, v6);
    uint64_t v7 = *a2;
    int v16 = *(_DWORD *)(a1 + 16) - 1;
    uint64_t v17 = (37 * *a2) & v16;
    a3 = (void *)(*(void *)a1 + 32 * v17);
    uint64_t v18 = *a3;
    if (*a2 != *a3)
    {
      uint64_t v12 = 0;
      int v19 = 1;
      while (v18 != -1)
      {
        if (v12) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v18 == -2;
        }
        if (v20) {
          uint64_t v12 = a3;
        }
        int v21 = v17 + v19++;
        uint64_t v17 = v21 & v16;
        a3 = (void *)(*(void *)a1 + 32 * v17);
        uint64_t v18 = *a3;
        if (v7 == *a3) {
          goto LABEL_4;
        }
      }
LABEL_20:
      if (v12) {
        a3 = v12;
      }
      goto LABEL_3;
    }
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v7 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD662F74(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  unint64_t v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  double result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD663040(a1, v4, &v4[4 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      void *result = -1;
      result += 4;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD663040(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  unint64_t v4 = a2;
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 32 * v6;
    do
    {
      *int v7 = -1;
      v7 += 4;
      v8 -= 32;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v9 = *v4;
      if ((unint64_t)*v4 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        int v10 = *(_DWORD *)(v5 + 16) - 1;
        uint64_t v11 = v10 & (37 * v9);
        uint64_t v12 = *(void *)v5 + 32 * v11;
        uint64_t v13 = *(void *)v12;
        if (v9 != *(void *)v12)
        {
          uint64_t v15 = 0;
          int v16 = 1;
          while (v13 != -1)
          {
            if (v15) {
              BOOL v17 = 0;
            }
            else {
              BOOL v17 = v13 == -2;
            }
            if (v17) {
              uint64_t v15 = v12;
            }
            int v18 = v11 + v16++;
            uint64_t v11 = v18 & v10;
            uint64_t v12 = *(void *)v5 + 32 * v11;
            uint64_t v13 = *(void *)v12;
            if (v9 == *(void *)v12) {
              goto LABEL_9;
            }
          }
          if (v15) {
            uint64_t v12 = v15;
          }
        }
LABEL_9:
        *(void *)uint64_t v12 = v9;
        *(_DWORD *)(v12 + 8) = *((_DWORD *)v4 + 2);
        *(void *)(v12 + 16) = v4[2];
        uint64_t v14 = v4[3];
        v4[3] = 0;
        *(void *)(v12 + 24) = v14;
        ++*(_DWORD *)(v5 + 8);
        double result = v4[3];
        v4[3] = 0;
        if (result) {
          double result = MEMORY[0x1D25D9CE0](result, 0x1000C40669B30A5);
        }
      }
      v4 += 4;
    }
    while (v4 != a3);
  }
  return result;
}

size_t **sub_1CD663184(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  uint64_t v6 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  uint64_t i = (size_t **)(*(void *)a1 + 8 * v6);
  uint64_t v8 = *i;
  if (*i == (size_t *)-8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v8)
  {
    while (!v8 || v8 == (size_t *)-8)
    {
      uint64_t v9 = i[1];
      ++i;
      uint64_t v8 = v9;
    }
    return i;
  }
  int v10 = operator new(a3 + 33, (std::align_val_t)8uLL);
  uint64_t v11 = v10;
  uint64_t v12 = (char *)(v10 + 4);
  if (a3) {
    memcpy(v10 + 4, a2, a3);
  }
  v12[a3] = 0;
  *uint64_t v11 = a3;
  v11[1] = 0;
  v11[2] = 0;
  v11[3] = 0;
  *uint64_t i = v11;
  ++*(_DWORD *)(a1 + 12);
  for (uint64_t i = (size_t **)(*(void *)a1
                      + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v6));
        !*i || *i + 1 == 0;
  return i;
}

uint64_t sub_1CD663284(uint64_t result, uint64_t a2, float a3)
{
  unsigned int v3 = *(_DWORD *)(result + 8);
  if (v3 >= *(_DWORD *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unint64_t v4 = (void *)(*(void *)result + 16 * v3);
  *unint64_t v4 = a2;
  v4[1] = a3;
  ++*(_DWORD *)(result + 8);
  return result;
}

uint64_t *sub_1CD6632F8(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v4 = 32 * v2;
    uint64_t v5 = (uint64_t *)(v3 + 24);
    do
    {
      if ((unint64_t)*(v5 - 3) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        uint64_t v6 = *v5;
        *uint64_t v5 = 0;
        if (v6) {
          MEMORY[0x1D25D9CE0](v6, 0x1000C40669B30A5);
        }
      }
      v5 += 4;
      v4 -= 32;
    }
    while (v4);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

uint64_t sub_1CD66337C(uint64_t result)
{
  if (*(_DWORD *)(result + 16))
  {
    uint64_t v1 = result;
    Emptyint Key = (llvm::IRMover::StructTypeKeyInfo *)llvm::IRMover::StructTypeKeyInfo::getEmptyKey((llvm::IRMover::StructTypeKeyInfo *)result);
    double result = llvm::IRMover::StructTypeKeyInfo::getTombstoneKey(EmptyKey);
    uint64_t v4 = *(unsigned int *)(v1 + 16);
    if (v4)
    {
      uint64_t v5 = (const void **)result;
      uint64_t v6 = *(const void ****)v1;
      uint64_t v7 = 8 * v4;
      do
      {
        double result = llvm::IRMover::StructTypeKeyInfo::isEqual(*v6, (const void **)EmptyKey, v3);
        if ((result & 1) == 0) {
          double result = llvm::IRMover::StructTypeKeyInfo::isEqual(*v6, v5, v3);
        }
        ++v6;
        v7 -= 8;
      }
      while (v7);
    }
  }
  return result;
}

uint64_t sub_1CD6633FC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 12))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 8);
    if (v2)
    {
      uint64_t v3 = 0;
      uint64_t v4 = 8 * v2;
      do
      {
        uint64_t v5 = *(void *)(*(void *)a1 + v3);
        if (v5 != -8 && v5 != 0)
        {
          sub_1CD4CAAF4(v5 + 8);
          MEMORY[0x1D25D9CD0](v5, 8);
        }
        v3 += 8;
      }
      while (v4 != v3);
    }
  }
  free(*(void **)a1);
  return a1;
}

uint64_t sub_1CD663484(uint64_t a1)
{
  char v2 = *(unsigned char *)(a1 + 8);
  uint64_t v3 = *(void *)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
  }
  else if (v3)
  {
    uint64_t v4 = sub_1CD4AFAF4(v3);
    MEMORY[0x1D25D9CE0](v4, 0x10B0C4007EAB999);
  }
  return a1;
}

void sub_1CD663500(int **a1, _WORD *a2, long long *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCDE9E8, 0, 0);
  dword_1EBCDEA68 = 0;
  qword_1EBCDEA70 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCDEA78 = 0;
  qword_1EBCDE9E8 = (uint64_t)&unk_1F2643F00;
  qword_1EBCDEA80 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCDEA88 = (uint64_t)&unk_1F25EA168;
  qword_1EBCDEAA0 = (uint64_t)&qword_1EBCDEA88;
  sub_1CD663600(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCDE9E8);
}

__n128 sub_1CD663600(int **a1, _WORD *a2, long long *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCDE9E8, "import-instr-limit", 0x12uLL);
  dword_1EBCDEA68 = **a1;
  byte_1EBCDEA7C = 1;
  dword_1EBCDEA78 = dword_1EBCDEA68;
  word_1EBCDE9F2 = (32 * (*a2 & 3)) | word_1EBCDE9F2 & 0xFF9F;
  xmmword_1EBCDEA18 = *a3;
  __n128 result = *a4;
  xmmword_1EBCDEA08 = (__int128)*a4;
  return result;
}

void sub_1CD663698(int **a1, _WORD *a2, long long *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCDEAA8, 0, 0);
  dword_1EBCDEB28 = 0;
  qword_1EBCDEB30 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCDEB38 = 0;
  qword_1EBCDEAA8 = (uint64_t)&unk_1F2643F68;
  qword_1EBCDEB40 = (uint64_t)&unk_1F2643D20;
  qword_1EBCDEB48 = (uint64_t)&unk_1F25F7480;
  qword_1EBCDEB60 = (uint64_t)&qword_1EBCDEB48;
  sub_1CD663798(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCDEAA8);
}

__n128 sub_1CD663798(int **a1, _WORD *a2, long long *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCDEAA8, "import-cutoff", 0xDuLL);
  uint64_t v8 = *a1;
  dword_1EBCDEB28 = **a1;
  byte_1EBCDEB3C = 1;
  dword_1EBCDEB38 = *v8;
  word_1EBCDEAB2 = (32 * (*a2 & 3)) | word_1EBCDEAB2 & 0xFF9F;
  xmmword_1EBCDEAD8 = *a3;
  __n128 result = *a4;
  xmmword_1EBCDEAC8 = (__int128)*a4;
  return result;
}

void sub_1CD663834(double **a1, _WORD *a2, long long *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCDEC28, 0, 0);
  dword_1EBCDECA8 = 0;
  qword_1EBCDECB0 = (uint64_t)&unk_1F2605730;
  *(void *)&dword_1EBCDECB8 = 0;
  qword_1EBCDEC28 = (uint64_t)&unk_1F26056C8;
  qword_1EBCDECC0 = (uint64_t)&unk_1F2643E70;
  qword_1EBCDECC8 = (uint64_t)&unk_1F2605750;
  qword_1EBCDECE0 = (uint64_t)&qword_1EBCDECC8;
  sub_1CD663934(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCDEC28);
}

__n128 sub_1CD663934(double **a1, _WORD *a2, long long *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCDEC28, "import-instr-evolution-factor", 0x1DuLL);
  *(float *)&int v8 = **a1;
  dword_1EBCDECA8 = v8;
  byte_1EBCDECBC = 1;
  dword_1EBCDECB8 = v8;
  word_1EBCDEC32 = (32 * (*a2 & 3)) | word_1EBCDEC32 & 0xFF9F;
  xmmword_1EBCDEC58 = *a3;
  __n128 result = *a4;
  xmmword_1EBCDEC48 = (__int128)*a4;
  return result;
}

void sub_1CD6639D0(double **a1, _WORD *a2, long long *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCDECE8, 0, 0);
  dword_1EBCDED68 = 0;
  qword_1EBCDED70 = (uint64_t)&unk_1F2605730;
  *(void *)&dword_1EBCDED78 = 0;
  qword_1EBCDECE8 = (uint64_t)&unk_1F26056C8;
  qword_1EBCDED80 = (uint64_t)&unk_1F2643E70;
  qword_1EBCDED88 = (uint64_t)&unk_1F2605750;
  qword_1EBCDEDA0 = (uint64_t)&qword_1EBCDED88;
  sub_1CD663AD0(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCDECE8);
}

__n128 sub_1CD663AD0(double **a1, _WORD *a2, long long *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCDECE8, "import-hot-evolution-factor", 0x1BuLL);
  *(float *)&int v8 = **a1;
  dword_1EBCDED68 = v8;
  byte_1EBCDED7C = 1;
  dword_1EBCDED78 = v8;
  word_1EBCDECF2 = (32 * (*a2 & 3)) | word_1EBCDECF2 & 0xFF9F;
  xmmword_1EBCDED18 = *a3;
  __n128 result = *a4;
  xmmword_1EBCDED08 = (__int128)*a4;
  return result;
}

void sub_1CD663B6C(double **a1, _WORD *a2, long long *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCDEDA8, 0, 0);
  dword_1EBCDEE28 = 0;
  qword_1EBCDEE30 = (uint64_t)&unk_1F2605730;
  *(void *)&dword_1EBCDEE38 = 0;
  qword_1EBCDEDA8 = (uint64_t)&unk_1F26056C8;
  qword_1EBCDEE40 = (uint64_t)&unk_1F2643E70;
  qword_1EBCDEE48 = (uint64_t)&unk_1F2605750;
  qword_1EBCDEE60 = (uint64_t)&qword_1EBCDEE48;
  sub_1CD663C6C(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCDEDA8);
}

__n128 sub_1CD663C6C(double **a1, _WORD *a2, long long *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCDEDA8, "import-hot-multiplier", 0x15uLL);
  *(float *)&int v8 = **a1;
  dword_1EBCDEE28 = v8;
  byte_1EBCDEE3C = 1;
  dword_1EBCDEE38 = v8;
  word_1EBCDEDB2 = (32 * (*a2 & 3)) | word_1EBCDEDB2 & 0xFF9F;
  xmmword_1EBCDEDD8 = *a3;
  __n128 result = *a4;
  xmmword_1EBCDEDC8 = (__int128)*a4;
  return result;
}

void sub_1CD663D08(double **a1, _WORD *a2, long long *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCDEE68, 0, 0);
  dword_1EBCDEEE8 = 0;
  qword_1EBCDEEF0 = (uint64_t)&unk_1F2605730;
  *(void *)&dword_1EBCDEEF8 = 0;
  qword_1EBCDEE68 = (uint64_t)&unk_1F26056C8;
  qword_1EBCDEF00 = (uint64_t)&unk_1F2643E70;
  qword_1EBCDEF08 = (uint64_t)&unk_1F2605750;
  qword_1EBCDEF20 = (uint64_t)&qword_1EBCDEF08;
  sub_1CD663E08(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCDEE68);
}

__n128 sub_1CD663E08(double **a1, _WORD *a2, long long *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCDEE68, "import-critical-multiplier", 0x1AuLL);
  *(float *)&int v8 = **a1;
  dword_1EBCDEEE8 = v8;
  byte_1EBCDEEFC = 1;
  dword_1EBCDEEF8 = v8;
  word_1EBCDEE72 = (32 * (*a2 & 3)) | word_1EBCDEE72 & 0xFF9F;
  xmmword_1EBCDEE98 = *a3;
  __n128 result = *a4;
  xmmword_1EBCDEE88 = (__int128)*a4;
  return result;
}

void sub_1CD663EA4(int **a1, _WORD *a2, long long *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCDEF28, 0, 0);
  dword_1EBCDEFA8 = 0;
  qword_1EBCDEFB0 = (uint64_t)&unk_1F2605730;
  *(void *)&dword_1EBCDEFB8 = 0;
  qword_1EBCDEF28 = (uint64_t)&unk_1F26056C8;
  qword_1EBCDEFC0 = (uint64_t)&unk_1F2643E70;
  qword_1EBCDEFC8 = (uint64_t)&unk_1F2605750;
  qword_1EBCDEFE0 = (uint64_t)&qword_1EBCDEFC8;
  sub_1CD663FA4(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCDEF28);
}

__n128 sub_1CD663FA4(int **a1, _WORD *a2, long long *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCDEF28, "import-cold-multiplier", 0x16uLL);
  *(float *)&dword_1EBCDEFA8 = (float)**a1;
  byte_1EBCDEFBC = 1;
  dword_1EBCDEFB8 = dword_1EBCDEFA8;
  word_1EBCDEF32 = (32 * (*a2 & 3)) | word_1EBCDEF32 & 0xFF9F;
  xmmword_1EBCDEF58 = *a3;
  __n128 result = *a4;
  xmmword_1EBCDEF48 = (__int128)*a4;
  return result;
}

void sub_1CD664040(long long *a1)
{
  uint64_t v2 = sub_1CB883A14((uint64_t)qword_1EBCDF3A8, 0, 0);
  qword_1EBCDF428 = 0;
  qword_1EBCDF430 = 0;
  qword_1EBCDF450 = 0;
  unk_1EBCDF458 = 0;
  byte_1EBCDF460 = 0;
  qword_1EBCDF448 = 0;
  unk_1EBCDF438 = 0;
  unk_1EBCDF440 = &unk_1F2643C20;
  qword_1EBCDF3A8[0] = (uint64_t)&unk_1F2643FD0;
  qword_1EBCDF468 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCDF470 = (uint64_t)&unk_1F25F6428;
  qword_1EBCDF488 = (uint64_t)&qword_1EBCDF470;
  llvm::cl::Option::setArgStr(v2, "summary-file", 0xCuLL);
  xmmword_1EBCDF3C8 = *a1;

  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EBCDF3A8);
}

void sub_1CD664134(long long *a1)
{
  uint64_t v2 = sub_1CB883A14((uint64_t)qword_1EBCDF2E8, 0, 0);
  byte_1EBCDF368 = 0;
  qword_1EBCDF370 = (uint64_t)&unk_1F25EDE58;
  unk_1EBCDF378 = 0;
  qword_1EBCDF2E8[0] = (uint64_t)&unk_1F26440A0;
  qword_1EBCDF380 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCDF388 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCDF3A0 = (uint64_t)&qword_1EBCDF388;
  llvm::cl::Option::setArgStr(v2, "import-all-index", 0x10uLL);
  xmmword_1EBCDF308 = *a1;

  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EBCDF2E8);
}

uint64_t *sub_1CD66421C(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  uint64_t v6 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  uint64_t i = (uint64_t *)(*(void *)a1 + 8 * v6);
  uint64_t v8 = *i;
  if (*i == -8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v8)
  {
    while (!v8 || v8 == -8)
    {
      uint64_t v9 = i[1];
      ++i;
      uint64_t v8 = v9;
    }
    return i;
  }
  int v10 = (char *)operator new(a3 + 49, (std::align_val_t)8uLL);
  uint64_t v11 = v10;
  uint64_t v12 = v10 + 48;
  if (a3) {
    memcpy(v10 + 48, a2, a3);
  }
  v12[a3] = 0;
  *(void *)uint64_t v11 = a3;
  *(_OWORD *)(v11 + 8) = 0u;
  *(_OWORD *)(v11 + 24) = 0u;
  *((_DWORD *)v11 + 10) = 1065353216;
  *uint64_t i = (uint64_t)v11;
  ++*(_DWORD *)(a1 + 12);
  for (uint64_t i = (uint64_t *)(*(void *)a1
                      + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v6));
        !*i || *i == -8;
  return i;
}

void sub_1CD66432C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v13 = 0;
  char v8 = sub_1CD664444(*(void *)a2, *(_DWORD *)(a2 + 16), *a3, &v13);
  uint64_t v9 = v13;
  if (v8)
  {
    char v10 = 0;
  }
  else
  {
    sub_1CD6643BC(a2, v13, a3, a4);
    uint64_t v9 = v12;
    char v10 = 1;
  }
  unint64_t v11 = *(void *)a2 + ((unint64_t)*(unsigned int *)(a2 + 16) << 6);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
}

__n128 sub_1CD6643BC(uint64_t a1, void *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v6 = sub_1CD6644D8(a1, a3, a2);
  *uint64_t v6 = *a3;
  *(_OWORD *)(v6 + 1) = *(_OWORD *)a4;
  *((_DWORD *)v6 + 10) = 0;
  v6[3] = 0;
  v6[4] = 0;
  v6[3] = *(void *)(a4 + 16);
  *(void *)(a4 + 16) = 0;
  *((_DWORD *)v6 + 8) = *(_DWORD *)(a4 + 24);
  *(_DWORD *)(a4 + 24) = 0;
  int v7 = *((_DWORD *)v6 + 9);
  *((_DWORD *)v6 + 9) = *(_DWORD *)(a4 + 28);
  *(_DWORD *)(a4 + 28) = v7;
  int v8 = *((_DWORD *)v6 + 10);
  *((_DWORD *)v6 + 10) = *(_DWORD *)(a4 + 32);
  *(_DWORD *)(a4 + 32) = v8;
  __n128 result = *(__n128 *)(a4 + 40);
  *((__n128 *)v6 + 3) = result;
  return result;
}

uint64_t sub_1CD664444(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    uint64_t v4 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    uint64_t v5 = (void *)(a1 + (v4 << 6));
    uint64_t v6 = *v5;
    if (*v5 == a3)
    {
      uint64_t v7 = 1;
    }
    else
    {
      uint64_t v9 = 0;
      int v10 = 1;
      while (v6 != -4096)
      {
        if (v9) {
          BOOL v11 = 0;
        }
        else {
          BOOL v11 = v6 == -8192;
        }
        if (v11) {
          uint64_t v9 = v5;
        }
        int v12 = v4 + v10++;
        uint64_t v4 = v12 & (a2 - 1);
        uint64_t v5 = (void *)(a1 + (v4 << 6));
        uint64_t v6 = *v5;
        uint64_t v7 = 1;
        if (*v5 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v7 = 0;
      if (v9) {
        uint64_t v5 = v9;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v7 = 0;
  }
LABEL_4:
  *a4 = v5;
  return v7;
}

void *sub_1CD6644D8(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD66458C(a1, v6);
  int v8 = 0;
  sub_1CD664444(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD66458C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  __n128 result = operator new((unint64_t)v8 << 6, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD664658(a1, v4, v4 + (v3 << 6));
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = v10 << 6;
    do
    {
      void *result = -4096;
      result += 8;
      v11 -= 64;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD664658(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = v6 << 6;
    do
    {
      *int v7 = -4096;
      v7 += 8;
      v8 -= 64;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v13 = 0;
      sub_1CD664444(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v13);
      uint64_t v10 = v13;
      *uint64_t v13 = *(void *)a2;
      *(_OWORD *)(v10 + 1) = *(_OWORD *)(a2 + 8);
      *((_DWORD *)v10 + 10) = 0;
      v10[3] = 0;
      v10[4] = 0;
      v10[3] = *(void *)(a2 + 24);
      *(void *)(a2 + 24) = 0;
      *((_DWORD *)v10 + 8) = *(_DWORD *)(a2 + 32);
      *(_DWORD *)(a2 + 32) = 0;
      int v11 = *((_DWORD *)v10 + 9);
      *((_DWORD *)v10 + 9) = *(_DWORD *)(a2 + 36);
      *(_DWORD *)(a2 + 36) = v11;
      int v12 = *((_DWORD *)v10 + 10);
      *((_DWORD *)v10 + 10) = *(_DWORD *)(a2 + 40);
      *(_DWORD *)(a2 + 40) = v12;
      *((_OWORD *)v10 + 3) = *(_OWORD *)(a2 + 48);
      ++*(_DWORD *)(v5 + 8);
      __n128 result = MEMORY[0x1D25D9CD0](*(void *)(a2 + 24), 8);
    }
    a2 += 64;
  }
  return result;
}

uint64_t sub_1CD664764(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  int v16 = 0;
  uint64_t result = sub_1CD461A14(a2, *a3, &v16);
  uint64_t v9 = v16;
  if (result)
  {
    uint64_t v10 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v11 = 8;
    }
    else
    {
      uint64_t v10 = *(void *)(a2 + 8);
      uint64_t v11 = *(unsigned int *)(a2 + 16);
    }
    char v12 = 0;
    uint64_t v13 = v10 + 16 * v11;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD664830((_DWORD *)a2, a3, v16);
    uint64_t v9 = (void *)result;
    *(void *)uint64_t result = *a3;
    *(_DWORD *)(result + 8) = *a4;
    uint64_t v14 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v15 = 8;
    }
    else
    {
      uint64_t v14 = *(void *)(a2 + 8);
      uint64_t v15 = *(unsigned int *)(a2 + 16);
    }
    uint64_t v13 = v14 + 16 * v15;
    char v12 = 1;
  }
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v13;
  *(unsigned char *)(a1 + 16) = v12;
  return result;
}

void *sub_1CD664830(_DWORD *a1, uint64_t *a2, void *a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 8;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD6648F0((uint64_t)a1, v6);
  uint64_t v8 = 0;
  sub_1CD461A14((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096) {
    --a1[1];
  }
  return a3;
}

uint64_t sub_1CD6648F0(uint64_t a1, unsigned int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 9)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 8)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD664A7C(a1, v6, v6 + 16 * v7);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = 0;
  uint64_t v9 = v14;
  do
  {
    uint64_t v10 = *(void *)(a1 + v8 + 8);
    if ((v10 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *(void *)uint64_t v9 = v10;
      *((_DWORD *)v9 + 2) = *(_DWORD *)(a1 + v8 + 16);
      v9 += 16;
    }
    v8 += 16;
  }
  while (v8 != 128);
  if (a2 > 8)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD664A7C(a1, (uint64_t)v14, (uint64_t)v9);
}

uint64_t sub_1CD664A7C(uint64_t result, uint64_t a2, uint64_t a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 136);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[2 * v7];
  }
  do
  {
    void *v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    uint64_t v10 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      char v12 = 0;
      uint64_t result = sub_1CD461A14((uint64_t)v5, v10, &v12);
      uint64_t v11 = v12;
      *char v12 = *(void *)a2;
      *((_DWORD *)v11 + 2) = *(_DWORD *)(a2 + 8);
      *v5 += 2;
    }
    a2 += 16;
  }
  return result;
}

uint64_t sub_1CD664B48(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);
    return v2();
  }
  else
  {
    sub_1CB920400();
    return sub_1CD664B98();
  }
}

void *sub_1CD664B98(_DWORD *a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD461A14((uint64_t)a1, *a2, &v7);
  int v5 = v7;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CD664830(a1, a2, v7);
    *int v5 = *a2;
    *((_DWORD *)v5 + 2) = 0;
  }
  return v5;
}

void *sub_1CD664C00(void *result)
{
  int v1 = *(_DWORD *)result;
  if (*(_DWORD *)result > 1u || *((_DWORD *)result + 1))
  {
    if (v1)
    {
      unint64_t v3 = result + 1;
      char v4 = result + 17;
    }
    else
    {
      uint64_t v2 = *((unsigned int *)result + 4);
      if (((2 * v1) & 0xFFFFFFFC) < v2 && v2 >= 0x41) {
        return sub_1CD643230(result);
      }
      if (!v2)
      {
        int v5 = 0;
LABEL_11:
        *(_DWORD *)uint64_t result = v5;
        *((_DWORD *)result + 1) = 0;
        return result;
      }
      unint64_t v3 = (void *)result[1];
      char v4 = &v3[2 * v2];
    }
    do
    {
      *unint64_t v3 = -4096;
      v3 += 2;
    }
    while (v3 != v4);
    int v5 = *(_DWORD *)result & 1;
    goto LABEL_11;
  }
  return result;
}

uint64_t sub_1CD664C78(uint64_t result, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = (void *)result;
    unint64_t v3 = (unint64_t)a2 << 6;
    do
    {
      if ((*v2 | 0x1000) != 0xFFFFFFFFFFFFF000) {
        uint64_t result = MEMORY[0x1D25D9CD0](v2[3], 8);
      }
      v2 += 8;
      v3 -= 64;
    }
    while (v3);
  }
  return result;
}

void sub_1CD664CCC(char **a1, _WORD *a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCDF910, 0, 0);
  byte_1EBCDF990 = 0;
  qword_1EBCDF998 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCDF9A0 = 0;
  qword_1EBCDF910 = (uint64_t)&unk_1F26440A0;
  qword_1EBCDF9A8 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCDF9B0 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCDF9C8 = (uint64_t)&qword_1EBCDF9B0;
  sub_1CD664DBC(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCDF910);
}

__n128 sub_1CD664DBC(char **a1, _WORD *a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCDF910, "function-specialization-for-literal-constant", 0x2CuLL);
  int v6 = *a1;
  byte_1EBCDF990 = **a1;
  byte_1EBCDF9A1 = 1;
  byte_1EBCDF9A0 = *v6;
  word_1EBCDF91A = (32 * (*a2 & 3)) | word_1EBCDF91A & 0xFF9F;
  __n128 result = *a3;
  xmmword_1EBCDF930 = (__int128)*a3;
  return result;
}

uint64_t sub_1CD664E44(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t result = *(void *)(a1 + 32);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void sub_1CD664EA8(char *__p)
{
  uint64_t v2 = __p + 8;
  unint64_t v3 = (char *)*((void *)__p + 4);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }

  operator delete(__p);
}

uint64_t sub_1CD664F40(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1)
  {
    sub_1CB920400();
    llvm::createGlobalDCEPass(v4);
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);

  return v2();
}

void llvm::createGlobalDCEPass(llvm *this)
{
}

uint64_t sub_1CD664FCC(uint64_t result, unint64_t *a2)
{
  uint64_t v3 = result;
  if (*(void *)(result + 96))
  {
    uint64_t v12 = result + 80;
    unint64_t v13 = *a2;
    unint64_t v14 = a2[1];
LABEL_17:
    return sub_1CD50F484(v12, v13, v14, a2);
  }
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(result + 8);
  if (v5)
  {
    unint64_t v6 = *a2;
    unint64_t v7 = a2[1];
    uint64_t v8 = 16 * v5;
    uint64_t v9 = (void *)(v4 + 8);
    while (*(v9 - 1) != v6 || *v9 != v7)
    {
      v9 += 2;
      v8 -= 16;
      if (!v8) {
        goto LABEL_9;
      }
    }
    if (v8) {
      return result;
    }
LABEL_9:
    if (v5 <= 3) {
      goto LABEL_10;
    }
    do
    {
      sub_1CD50F484(v3 + 80, *(void *)(*(void *)v3 + 16 * v5 - 16), *(void *)(*(void *)v3 + 16 * v5 - 8), (_OWORD *)(*(void *)v3 + 16 * v5 - 16));
      LODWORD(v5) = *(_DWORD *)(v3 + 8) - 1;
      *(_DWORD *)(v3 + 8) = v5;
    }
    while (v5);
    unint64_t v13 = *a2;
    unint64_t v14 = a2[1];
    uint64_t v12 = v3 + 80;
    goto LABEL_17;
  }
  unint64_t v6 = *a2;
  unint64_t v7 = a2[1];
LABEL_10:
  if (v5 >= *(_DWORD *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v11 = (unint64_t *)(v4 + 16 * v5);
  *uint64_t v11 = v6;
  v11[1] = v7;
  ++*(_DWORD *)(result + 8);
  return result;
}

void llvm::GlobalDCEPass::ScanVTableLoad(llvm::GlobalDCEPass *this, llvm::Function *a2, llvm::Metadata *a3, uint64_t a4)
{
  uint64_t v25 = a3;
  unint64_t v7 = sub_1CD665D14((uint64_t)this + 392, (uint64_t *)&v25);
  uint64_t v9 = v7[13];
  if (v9) {
    uint64_t v10 = (llvm::Module **)v7[11];
  }
  else {
    uint64_t v10 = (llvm::Module **)v7[1];
  }
  uint64_t v11 = v7[1] + 16 * *((unsigned int *)v7 + 4);
  uint64_t v12 = (llvm::Module **)(v7 + 12);
  while (v9)
  {
    if (v10 == v12) {
      return;
    }
LABEL_7:
    unint64_t v13 = v10 + 4;
    if (!v9) {
      unint64_t v13 = v10;
    }
    unint64_t v14 = *v13;
    PointerAtOffset = llvm::getPointerAtOffset(*((llvm **)*v13 - 4), (unint64_t)v13[1] + a4, *((void *)a2 + 5), *v13, v8);
    if (PointerAtOffset
      && ((int v18 = llvm::Value::stripPointerCasts(PointerAtOffset), (v20 = (uint64_t)v18) != 0)
        ? (BOOL v21 = *((unsigned char *)v18 + 16) == 0)
        : (BOOL v21 = 0),
          v21 || (llvm::GlobalPtrAuthInfo::analyze((uint64_t ***)v18, v19), v22) && *(unsigned __int8 *)(v20 + 16) < 4u))
    {
      uint64_t v24 = a2;
      uint64_t v23 = sub_1CC92027C((uint64_t)this + 288, (uint64_t *)&v24);
      sub_1CB89694C((llvm::SmallPtrSetImplBase *)(v23 + 1), v20);
    }
    else
    {
      sub_1CD665254((uint64_t)this + 416, (uint64_t)v14);
    }
    if (v9)
    {
      int v16 = v10[1];
      BOOL v17 = v10;
      if (v16)
      {
        do
        {
          uint64_t v10 = (llvm::Module **)v16;
          int v16 = *(llvm::Module **)v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          uint64_t v10 = (llvm::Module **)v17[2];
          BOOL v21 = *v10 == (llvm::Module *)v17;
          BOOL v17 = v10;
        }
        while (!v21);
      }
    }
    else
    {
      v10 += 2;
    }
  }
  if (v10 != (llvm::Module **)v11) {
    goto LABEL_7;
  }
}

int32x2_t sub_1CD665254(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  if (sub_1CD665928(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v6))
  {
    uint64_t v4 = (void *)v6;
    uint64_t v5 = *(void **)(v6 + 16);
    if (v5 != *(void **)(v6 + 8)) {
      free(v5);
    }
    *uint64_t v4 = -8192;
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + 8) = result;
  }
  return result;
}

void llvm::GlobalDCEPass::ScanTypeCheckedLoadIntrinsics(llvm::GlobalDCEPass *this, llvm::Module *a2)
{
  Name = (unsigned __int8 *)llvm::Intrinsic::getName((llvm::Intrinsic *)0x129);
  uint64_t Function = llvm::Module::getFunction((uint64_t)a2, Name, v5);
  unint64_t v7 = (unsigned __int8 *)llvm::Intrinsic::getName((llvm::Intrinsic *)0x12A);
  uint64_t v9 = llvm::Module::getFunction((uint64_t)a2, v7, v8);
  sub_1CC91D9B0(this, Function);

  sub_1CC91D9B0(this, v9);
}

llvm::GlobalVariable *llvm::GlobalDCEPass::PropagateLivenessToConditionallyUsed(llvm::GlobalDCEPass *this, llvm::Module *a2)
{
  int32x2_t result = (llvm::GlobalVariable *)llvm::Module::getGlobalVariable((uint64_t)a2, "llvm.used", 9uLL, 0);
  if (result)
  {
    unint64_t v5 = result;
    v20[0] = "llvm.used.conditional";
    v23[0] = 259;
    int32x2_t result = (llvm::GlobalVariable *)llvm::Module::getNamedMetadata(a2, v20);
    if (result)
    {
      uint64_t v6 = (uint64_t)result;
      v20[0] = (const char *)v23;
      v20[1] = (const char *)v23;
      uint64_t v21 = 8;
      int v22 = 0;
      uint64_t v7 = *((void *)v5 - 4);
      int v8 = *(_DWORD *)(v7 + 20);
      if ((v8 & 0x40000000) != 0)
      {
        uint64_t v10 = *(llvm::Value ***)(v7 - 8);
        uint64_t v9 = v8 & 0x7FFFFFF;
      }
      else
      {
        uint64_t v9 = v8 & 0x7FFFFFF;
        uint64_t v10 = (llvm::Value **)(v7 - 32 * v9);
      }
      if (v9)
      {
        uint64_t v11 = 32 * v9;
        do
        {
          uint64_t v12 = *v10;
          v10 += 4;
          unint64_t v13 = llvm::Value::stripPointerCasts(v12);
          sub_1CB89694C((llvm::SmallPtrSetImplBase *)v20, (uint64_t)v13);
          v11 -= 32;
        }
        while (v11);
      }
      do
      {
        llvm::GlobalDCEPass::PropagateLivenessInGlobalValues(this);
        uint64_t v19 = *(unsigned int *)(*(void *)(v6 + 48) + 8);
        if (!v19) {
          break;
        }
        uint64_t v14 = 0;
        int v15 = HIDWORD(v21) - v22;
        uint64_t v16 = 8 * v19;
        do
        {
          uint64_t v17 = llvm::GlobalDCEPass::TargetFromConditionalUsedIfLive(this, *(llvm::MDNode **)(**(void **)(v6 + 48) + v14));
          if (v17)
          {
            uint64_t v18 = v17;
            sub_1CB89694C((llvm::SmallPtrSetImplBase *)v20, v17);
            llvm::GlobalDCEPass::MarkLive((uint64_t)this, v18, 0);
          }
          v14 += 8;
        }
        while (v16 != v14);
      }
      while (HIDWORD(v21) - v22 != v15);
      llvm::setUsedInitializer(v5, (uint64_t)v20);
    }
  }
  return result;
}

uint64_t sub_1CD6654F4(uint64_t result, void *a2, void *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    uint64_t v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *uint64_t v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      sub_1CB87DF68(v5, a2, &v11);
      uint64_t v9 = v11;
      *uint64_t v11 = *a2;
      uint64_t v10 = a2[1];
      a2[1] = 0;
      v9[1] = v10;
      ++*(_DWORD *)(v5 + 8);
      int32x2_t result = a2[1];
      a2[1] = 0;
      if (result) {
        int32x2_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
    }
    a2 += 2;
  }
  return result;
}

void sub_1CD6655E4()
{
}

void *sub_1CD6655FC(void *a1)
{
  *a1 = &unk_1F26284C8;
  uint64_t v2 = a1[1];
  if (v2)
  {
    sub_1CBF9BC38((_DWORD *)(v2 + 48));
    sub_1CC6168A0((_DWORD *)(v2 + 24));
  }
  return a1;
}

const char *sub_1CD665654()
{
  uint64_t v10 = "StringRef llvm::getTypeName() [DesiredTypeName = llvm::InnerAnalysisManagerProxy<FunctionAnalysisManager, Module>]";
  unint64_t v11 = 114;
  unint64_t v0 = llvm::StringRef::find((uint64_t *)&v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v11 >= v0) {
    unint64_t v1 = v0;
  }
  else {
    unint64_t v1 = v11;
  }
  uint64_t v2 = &v10[v1];
  unint64_t v3 = v11 - v1;
  if (v11 - v1 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v11 - v1;
  }
  int32x2_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

void sub_1CD66570C(_WORD *a1, char **a2, _WORD *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCDF9D0, 0, 0);
  byte_1EBCDFA50 = 0;
  qword_1EBCDFA58 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCDFA60 = 0;
  qword_1EBCDF9D0 = (uint64_t)&unk_1F26440A0;
  qword_1EBCDFA68 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCDFA70 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCDFA88 = (uint64_t)&qword_1EBCDFA70;
  sub_1CD66580C(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCDF9D0);
}

__n128 sub_1CD66580C(_WORD *a1, char **a2, _WORD *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCDF9D0, "enable-vfe", 0xAuLL);
  word_1EBCDF9DA = word_1EBCDF9DA & 0xFF9F | (32 * (*a1 & 3));
  uint64_t v8 = *a2;
  byte_1EBCDFA50 = **a2;
  byte_1EBCDFA61 = 1;
  byte_1EBCDFA60 = *v8;
  word_1EBCDF9DA = word_1EBCDF9DA & 0xFFF8 | *a3 & 7;
  __n128 result = *a4;
  xmmword_1EBCDF9F0 = (__int128)*a4;
  return result;
}

void *sub_1CD6658A4(uint64_t a1, uint64_t *a2)
{
  unint64_t v7 = 0;
  char v4 = sub_1CD665928(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD6659C4(a1, a2, v7);
    *uint64_t v5 = *a2;
    v5[1] = v5 + 5;
    uint64_t v5[2] = v5 + 5;
    v5[3] = 8;
    *((_DWORD *)v5 + 8) = 0;
  }
  return v5;
}

uint64_t sub_1CD665928(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    unint64_t v6 = (void *)(a1 + 104 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      while (v7 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          uint64_t v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        unint64_t v6 = (void *)(a1 + 104 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        unint64_t v6 = v10;
      }
    }
  }
  else
  {
    unint64_t v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

void *sub_1CD6659C4(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD665A78(a1, v6);
  uint64_t v8 = 0;
  sub_1CD665928(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD665A78(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  __n128 result = operator new(104 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD665B50(a1, v4, &v4[13 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  unsigned int v10 = *(_DWORD *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 104 * v10;
    do
    {
      void *result = -4096;
      result += 13;
      v11 -= 104;
    }
    while (v11);
  }
  return result;
}

void sub_1CD665B50(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  *(void *)(a1 + 8) = 0;
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 104 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 13;
      v8 -= 104;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      unsigned int v13 = 0;
      sub_1CD665928(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
      unsigned int v10 = v13;
      uint64_t v11 = v13 + 5;
      *unsigned int v13 = *a2;
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(v10 + 1), v11, 8, a2 + 1);
      ++*(_DWORD *)(a1 + 8);
      BOOL v12 = (void *)a2[2];
      if (v12 != (void *)a2[1]) {
        free(v12);
      }
    }
    a2 += 13;
  }
}

void *sub_1CD665C24(void *a1, void *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  uint64_t v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  __n128 result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      __n128 result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void *sub_1CD665D14(uint64_t a1, uint64_t *a2)
{
  uint64_t v8 = 0;
  char v4 = sub_1CD5144DC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  unint64_t v5 = v8;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CD665DB4(a1, a2, v8);
    uint64_t v7 = *a2;
    *(_OWORD *)(v5 + 9) = 0u;
    *(_OWORD *)(v5 + 7) = 0u;
    *(_OWORD *)(v5 + 5) = 0u;
    *(_OWORD *)(v5 + 3) = 0u;
    *unint64_t v5 = v7;
    v5[1] = v5 + 3;
    uint64_t v5[2] = 0x400000000;
    v5[13] = 0;
    v5[12] = 0;
    v5[11] = v5 + 12;
  }
  return v5;
}

void *sub_1CD665DB4(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD665E68(a1, v6);
  uint64_t v8 = 0;
  sub_1CD5144DC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD665E68(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  __n128 result = operator new(112 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD665F40(a1, v4, v4 + 112 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 112 * v10;
    do
    {
      void *result = -4096;
      result += 14;
      v11 -= 112;
    }
    while (v11);
  }
  return result;
}

void sub_1CD665F40(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 112 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 14;
      v8 -= 112;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      BOOL v12 = 0;
      sub_1CD5144DC(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v12);
      uint64_t v10 = v12;
      *BOOL v12 = *(void *)a2;
      sub_1CD66601C(v10 + 1, a2 + 8);
      ++*(_DWORD *)(a1 + 8);
      sub_1CB833A08(a2 + 88, *(void **)(a2 + 96));
      uint64_t v11 = *(void **)(a2 + 8);
      if ((void *)(a2 + 24) != v11) {
        free(v11);
      }
    }
    a2 += 112;
  }
}

void *sub_1CD66601C(void *result, uint64_t a2)
{
  void *result = result + 2;
  result[1] = 0x400000000;
  if (*(_DWORD *)(a2 + 8)) {
    __n128 result = (void *)sub_1CD49A6B8((uint64_t)result, a2);
  }
  result[10] = *(void *)(a2 + 80);
  unsigned int v3 = (void *)(a2 + 88);
  uint64_t v4 = *(void *)(a2 + 88);
  result[11] = v4;
  unint64_t v5 = result + 11;
  uint64_t v6 = *(void *)(a2 + 96);
  result[12] = v6;
  if (v6)
  {
    *(void *)(v4 + 16) = v5;
    *(void *)(a2 + 80) = v3;
    *unsigned int v3 = 0;
    *(void *)(a2 + 96) = 0;
  }
  else
  {
    result[10] = v5;
  }
  return result;
}

uint64_t sub_1CD66609C(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

void *sub_1CD6660A8(void *a1, long long *a2)
{
  uint64_t v4 = operator new(0x20uLL);
  long long v5 = *a2;
  v4[1] = *a2;
  unint64_t v6 = 0x9DDFEA08EB382D69 * (((8 * v5) + 8) ^ DWORD1(v5));
  *(void *)uint64_t v4 = 0;
  *((void *)v4 + 1) = 0x9DDFEA08EB382D69
                      * ((0x9DDFEA08EB382D69 * (DWORD1(v5) ^ (v6 >> 47) ^ v6)) ^ ((0x9DDFEA08EB382D69
                                                                                   * (DWORD1(v5) ^ (v6 >> 47) ^ v6)) >> 47));

  return sub_1CD666134(a1, v4);
}

void *sub_1CD666134(void *a1, void *a2)
{
  uint64_t v4 = a2 + 2;
  unint64_t v5 = a2[2];
  unint64_t v6 = HIDWORD(v5);
  unint64_t v7 = 0x9DDFEA08EB382D69 * (((8 * v5) + 8) ^ HIDWORD(v5));
  unint64_t v8 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
  a2[1] = v8;
  uint64_t v9 = sub_1CC9205B8((uint64_t)a1, v8, v4);
  sub_1CD6661B4(a1, a2, v9);
  return a2;
}

void *sub_1CD6661B4(void *result, void *a2, void *a3)
{
  int8x8_t v3 = (int8x8_t)result[1];
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }
  else
  {
    v4 &= *(void *)&v3 - 1;
  }
  if (!a3)
  {
    *a2 = result[2];
    result[2] = a2;
    *(void *)(*result + 8 * v4) = result + 2;
    if (!*a2) {
      goto LABEL_15;
    }
    unint64_t v6 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(void *)&v3) {
        v6 %= *(void *)&v3;
      }
    }
    else
    {
      v6 &= *(void *)&v3 - 1;
    }
LABEL_14:
    *(void *)(*result + 8 * v6) = a2;
    goto LABEL_15;
  }
  *a2 = *a3;
  *a3 = a2;
  if (*a2)
  {
    unint64_t v6 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(void *)&v3) {
        v6 %= *(void *)&v3;
      }
    }
    else
    {
      v6 &= *(void *)&v3 - 1;
    }
    if (v6 != v4) {
      goto LABEL_14;
    }
  }
LABEL_15:
  ++result[3];
  return result;
}

void sub_1CD66629C(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      sub_1CB833614();
    }
    unint64_t v4 = operator new(8 * a2);
    uint8x8_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    unint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      for (uint64_t i = (void *)*v7; *v7; uint64_t i = (void *)*v7)
      {
        unint64_t v11 = i[1];
        if (v9.u32[0] > 1uLL)
        {
          if (v11 >= a2) {
            v11 %= a2;
          }
        }
        else
        {
          v11 &= a2 - 1;
        }
        if (v11 == v8)
        {
          unint64_t v7 = i;
        }
        else
        {
          BOOL v12 = i;
          if (*(void *)(*(void *)a1 + 8 * v11))
          {
            do
            {
              unsigned int v13 = v12;
              BOOL v12 = (void *)*v12;
            }
            while (v12 && i[2] == v12[2]);
            *unint64_t v7 = v12;
            *unsigned int v13 = **(void **)(*(void *)a1 + 8 * v11);
            **(void **)(*(void *)a1 + 8 * v11) = i;
          }
          else
          {
            *(void *)(*(void *)a1 + 8 * v11) = v7;
            unint64_t v7 = i;
            unint64_t v8 = v11;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v14 = *(void **)a1;
    *(void *)a1 = 0;
    if (v14) {
      operator delete(v14);
    }
    *(void *)(a1 + 8) = 0;
  }
}

void sub_1CD666410(_DWORD *a1)
{
  int v2 = a1[2];
  sub_1CC91FE68((uint64_t)a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4 == a1[4])
  {
    *((void *)a1 + 1) = 0;
    if (v4)
    {
      uint8x8_t v5 = *(void **)a1;
      uint64_t v6 = 112 * v4;
      do
      {
        *uint8x8_t v5 = -4096;
        v5 += 14;
        v6 -= 112;
      }
      while (v6);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CC4E4ED4(a1, v4);
  }
}

void sub_1CD6664C4(_DWORD *a1)
{
  int v2 = a1[2];
  sub_1CC91FE00(a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    unsigned int v4 = v3;
  }
  else {
    unsigned int v4 = 0;
  }
  if (v4 == a1[4])
  {
    *((void *)a1 + 1) = 0;
    if (v4)
    {
      uint8x8_t v5 = *(void **)a1;
      uint64_t v6 = 104 * v4;
      do
      {
        *uint8x8_t v5 = -4096;
        v5 += 13;
        v6 -= 104;
      }
      while (v6);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CC91FCE0(a1, v4);
  }
}

void llvm::createGlobalOptimizerPass(llvm *this)
{
}

uint64_t sub_1CD6665B4(uint64_t a1)
{
  return (*(uint64_t (**)(void))a1)(*(void *)(a1 + 8));
}

uint64_t sub_1CD6665BC(uint64_t result, uint64_t a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t v5 = *(unsigned int *)(result + 8);
  if (*(void *)result + 16 * v5 == a2)
  {
    return sub_1CC92A578(result, a3, a4, a5);
  }
  else
  {
    uint64_t v7 = *(void *)result;
    uint8x8_t v9 = a3;
    if (a3 == a5)
    {
      unint64_t v10 = 0;
    }
    else
    {
      unint64_t v10 = 0;
      unint64_t v11 = a3;
      do
      {
        ++v10;
        BOOL v12 = v11 + 2;
        while (v12 != a4)
        {
          unint64_t v13 = *v12;
          v12 += 2;
          if (v13 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            unint64_t v11 = v12 - 2;
            goto LABEL_12;
          }
        }
        unint64_t v11 = a4;
LABEL_12:
        ;
      }
      while (v11 != a5);
    }
    uint64_t v14 = (a2 - *(void *)result) >> 4;
    if (v10 + v5 > *(unsigned int *)(result + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    int v15 = (char *)(v7 + 16 * v14);
    uint64_t v16 = (char *)(v7 + 16 * v5);
    unint64_t v17 = (v16 - v15) >> 4;
    if (v17 >= v10)
    {
      __n128 result = sub_1CD3E56A0(result, &v16[-16 * v10], (char *)(v7 + 16 * v5));
      if (&v16[-16 * v10] != v15)
      {
        uint64_t v23 = 16 * v5;
        uint64_t v24 = v7 - 16 * v10;
        uint64_t v25 = 16 * v10 + 16 * v14;
        do
        {
          uint64_t v26 = v7 + v23;
          uint64_t v27 = *(void *)(v24 + v23 - 8);
          *(void *)(v26 - 16) = *(void *)(v24 + v23 - 16);
          *(void *)(v26 - 8) = v27;
          v7 -= 16;
          v24 -= 16;
          v25 += 16;
        }
        while (v23 != v25);
      }
      while (v9 != a5)
      {
        unint64_t v28 = v9[1];
        *(void *)int v15 = *v9;
        *((void *)v15 + 1) = v28;
        char v29 = v9 + 2;
        while (v29 != a4)
        {
          unint64_t v30 = *v29;
          v29 += 2;
          if (v30 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            uint8x8_t v9 = v29 - 2;
            goto LABEL_43;
          }
        }
        uint8x8_t v9 = a4;
LABEL_43:
        v15 += 16;
      }
    }
    else
    {
      *(_DWORD *)(result + 8) = v5 + v10;
      if (v14 != v5)
      {
        __n128 result = (uint64_t)memcpy((void *)(v7 + 16 * (v5 + v10) - 16 * v17), (const void *)(v7 + 16 * v14), v16 - v15);
        do
        {
          unint64_t v18 = v9[1];
          *(void *)int v15 = *v9;
          *((void *)v15 + 1) = v18;
          v15 += 16;
          uint64_t v19 = v9 + 2;
          while (v19 != a4)
          {
            unint64_t v20 = *v19;
            v19 += 2;
            if (v20 <= 0xFFFFFFFFFFFFFFFDLL)
            {
              uint8x8_t v9 = v19 - 2;
              goto LABEL_23;
            }
          }
          uint8x8_t v9 = a4;
LABEL_23:
          --v17;
        }
        while (v17);
      }
      while (v9 != a5)
      {
        *(_OWORD *)uint64_t v16 = *(_OWORD *)v9;
        uint64_t v21 = v9 + 2;
        while (v21 != a4)
        {
          unint64_t v22 = *v21;
          v21 += 2;
          if (v22 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            uint8x8_t v9 = v21 - 2;
            goto LABEL_30;
          }
        }
        uint8x8_t v9 = a4;
LABEL_30:
        v16 += 16;
      }
    }
  }
  return result;
}

int *sub_1CD666828(uint64_t *a1, _DWORD *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = (37 * *a2) & (v3 - 1);
    __n128 result = (int *)(v2 + 32 * v4);
    int v6 = *result;
    if (*a2 == *result) {
      return result;
    }
    int v7 = 1;
    while (v6 != -1)
    {
      int v8 = v4 + v7++;
      uint64_t v4 = v8 & (v3 - 1);
      int v6 = *(_DWORD *)(v2 + 32 * v4);
      if (*a2 == v6) {
        return (int *)(v2 + 32 * v4);
      }
    }
  }
  return (int *)(v2 + 32 * v3);
}

void sub_1CD66689C(__n128 *a1, char **a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCDFAB0, 0, 0);
  byte_1EBCDFB30 = 0;
  qword_1EBCDFB38 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCDFB40 = 0;
  qword_1EBCDFAB0 = (uint64_t)&unk_1F26440A0;
  qword_1EBCDFB48 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCDFB50 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCDFB68 = (uint64_t)&qword_1EBCDFB50;
  sub_1CD66698C(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCDFAB0);
}

__n128 sub_1CD66698C(__n128 *a1, char **a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCDFAB0, "enable-coldcc-stress-test", 0x19uLL);
  __n128 result = *a1;
  xmmword_1EBCDFAD0 = (__int128)*a1;
  int v7 = *a2;
  byte_1EBCDFB30 = **a2;
  byte_1EBCDFB41 = 1;
  byte_1EBCDFB40 = *v7;
  word_1EBCDFABA = (32 * (*a3 & 3)) | word_1EBCDFABA & 0xFF9F;
  return result;
}

void sub_1CD666A14(_WORD *a1, int **a2, _WORD *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCDFB70, 0, 0);
  dword_1EBCDFBF0 = 0;
  qword_1EBCDFBF8 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCDFC00 = 0;
  qword_1EBCDFB70 = (uint64_t)&unk_1F2643F68;
  qword_1EBCDFC08 = (uint64_t)&unk_1F2643D20;
  qword_1EBCDFC10 = (uint64_t)&unk_1F25F7480;
  qword_1EBCDFC28 = (uint64_t)&qword_1EBCDFC10;
  sub_1CD666B14(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCDFB70);
}

__n128 sub_1CD666B14(_WORD *a1, int **a2, _WORD *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCDFB70, "coldcc-rel-freq", 0xFuLL);
  word_1EBCDFB7A = word_1EBCDFB7A & 0xFF9F | (32 * (*a1 & 3));
  int v8 = *a2;
  dword_1EBCDFBF0 = **a2;
  byte_1EBCDFC04 = 1;
  dword_1EBCDFC00 = *v8;
  word_1EBCDFB7A = word_1EBCDFB7A & 0xFFF8 | *a3 & 7;
  __n128 result = *a4;
  xmmword_1EBCDFB90 = (__int128)*a4;
  return result;
}

double llvm::GlobalSplitPass::run@<D0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if (sub_1CC92D980(a1))
  {
    int v3 = 0;
    *(void *)(a2 + 88) = 0;
    *(_OWORD *)(a2 + 72) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 24) = 0u;
    uint64_t v4 = a2 + 32;
  }
  else
  {
    *(void *)(a2 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
    uint64_t v4 = a2 + 32;
    int v3 = 1;
  }
  *(void *)a2 = v4;
  *(void *)(a2 + 8) = v4;
  *(_DWORD *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 20) = v3;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 48) = a2 + 80;
  *(void *)(a2 + 56) = a2 + 80;
  *(void *)&double result = 2;
  *(void *)(a2 + 64) = 2;
  *(_DWORD *)(a2 + 72) = 0;
  return result;
}

void llvm::HotColdSplittingPass::run()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::AnalysisManager<llvm::Module>::getResultImpl();
}

void llvm::createHotColdSplittingPass(llvm *this)
{
}

void sub_1CD666EEC(uint64_t a1, uint64_t a2)
{
  sub_1CD667198((uint64_t)&v3, a2);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)a1, (const void **)(a1 + 32), (const llvm::SmallPtrSetImplBase *)&v3);
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  a1 += 96;
  *(void *)(a1 + 16) = 0;
  sub_1CBF340A8((void *)a1, __p, v6, 0xAAAAAAAAAAAAAAABLL * ((v6 - (unsigned char *)__p) >> 3));
  if (__p)
  {
    int v6 = __p;
    operator delete(__p);
  }
  if (v4 != v3) {
    free(v4);
  }
}

void sub_1CD666F78(const void **a1)
{
  uint64_t v6 = 0;
  __p = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t v2 = (char *)v5 + 8;
  int v3 = (char *)v5 + 8;
  uint64_t v4 = 8;
  int v8 = 0;
  uint64_t v9 = 0;
  unint64_t v1 = llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)a1, a1 + 4, (const llvm::SmallPtrSetImplBase *)&v2);
  *((void *)v1 + 12) = 0;
  *((void *)v1 + 13) = 0;
  unint64_t v1 = (llvm::SmallPtrSetImplBase *)((char *)v1 + 96);
  *((void *)v1 + 2) = 0;
  sub_1CBF340A8(v1, __p, v8, 0xAAAAAAAAAAAAAAABLL * ((v8 - (unsigned char *)__p) >> 3));
  if (__p)
  {
    int v8 = __p;
    operator delete(__p);
  }
  if (v3 != v2) {
    free(v3);
  }
}

uint64_t sub_1CD667018(uint64_t result, void *a2)
{
  if ((void *)result != a2)
  {
    int v3 = a2 + 2;
    uint64_t v2 = *a2;
    if ((void *)*a2 == a2 + 2)
    {
      uint64_t v13 = result;
      uint64_t v5 = *((unsigned int *)a2 + 2);
      unint64_t v11 = a2 + 1;
      uint64_t v6 = *(unsigned int *)(result + 8);
      if (v6 >= *((_DWORD *)a2 + 2))
      {
        if (v5)
        {
          uint64_t v7 = v2 + 16 * v5;
          int v8 = *(_DWORD **)result;
          do
          {
            *(void *)int v8 = *(void *)v2;
            void v8[2] = *(_DWORD *)(v2 + 8);
            v2 += 16;
            v8 += 4;
          }
          while (v2 != v7);
        }
      }
      else
      {
        if (*(_DWORD *)(result + 12) < v5)
        {
          *(_DWORD *)(result + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v6)
        {
          uint64_t v9 = v2 + 16 * v6;
          unint64_t v10 = *(_DWORD **)result;
          do
          {
            *(void *)unint64_t v10 = *(void *)v2;
            void v10[2] = *(_DWORD *)(v2 + 8);
            v2 += 16;
            v10 += 4;
          }
          while (v2 != v9);
        }
        else
        {
          uint64_t v6 = 0;
        }
        if (v6 != v5) {
          memcpy((void *)(*(void *)result + 16 * v6), (const void *)(*a2 + 16 * v6), *a2 + 16 * v5 - (*a2 + 16 * v6));
        }
      }
      double result = v13;
      *(_DWORD *)(v13 + 8) = v5;
      uint64_t v4 = v11;
    }
    else
    {
      if (*(void *)result != result + 16)
      {
        BOOL v12 = a2;
        uint64_t v14 = result;
        free(*(void **)result);
        a2 = v12;
        double result = v14;
        uint64_t v2 = *v12;
      }
      *(void *)double result = v2;
      uint64_t v4 = a2 + 1;
      *(void *)(result + 8) = a2[1];
      *a2 = v3;
      *((_DWORD *)a2 + 3) = 0;
    }
    *uint64_t v4 = 0;
  }
  return result;
}

uint64_t sub_1CD667198(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(void *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 96) = 0;
  uint64_t v4 = (void **)(a1 + 96);
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  sub_1CB89694C((llvm::SmallPtrSetImplBase *)a1, a2);
  *(void *)&long long v9 = a2;
  BYTE8(v9) = 0;
  LOBYTE(v10) = 0;
  unint64_t v5 = *(void *)(a1 + 104);
  if (v5 < *(void *)(a1 + 112))
  {
    long long v8 = v9;
    *(void *)(v5 + 16) = v10;
    *(_OWORD *)unint64_t v5 = v8;
    uint64_t v6 = (char *)(v5 + 24);
  }
  else
  {
    uint64_t v6 = sub_1CBF56DE8(v4, (uint64_t)&v9);
  }
  *(void *)(a1 + 104) = v6;
  return a1;
}

void sub_1CD667238(int **a1, _WORD *a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCDFD10, 0, 0);
  dword_1EBCDFD90 = 0;
  qword_1EBCDFD98 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCDFDA0 = 0;
  qword_1EBCDFD10 = (uint64_t)&unk_1F2643F68;
  qword_1EBCDFDA8 = (uint64_t)&unk_1F2643D20;
  qword_1EBCDFDB0 = (uint64_t)&unk_1F25F7480;
  qword_1EBCDFDC8 = (uint64_t)&qword_1EBCDFDB0;
  sub_1CD667328(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCDFD10);
}

__n128 sub_1CD667328(int **a1, _WORD *a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCDFD10, "hotcoldsplit-threshold", 0x16uLL);
  uint64_t v6 = *a1;
  dword_1EBCDFD90 = **a1;
  byte_1EBCDFDA4 = 1;
  dword_1EBCDFDA0 = *v6;
  word_1EBCDFD1A = (32 * (*a2 & 3)) | word_1EBCDFD1A & 0xFF9F;
  __n128 result = *a3;
  xmmword_1EBCDFD30 = (__int128)*a3;
  return result;
}

void sub_1CD6673B0(const char **a1, _WORD *a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCDFF50, 0, 0);
  qword_1EBCDFFD0 = 0;
  unk_1EBCDFFD8 = 0;
  qword_1EBCDFFF8 = 0;
  unk_1EBCE0000 = 0;
  byte_1EBCE0008 = 0;
  qword_1EBCDFFF0 = 0;
  unk_1EBCDFFE0 = 0;
  unk_1EBCDFFE8 = &unk_1F2643C20;
  qword_1EBCDFF50 = (uint64_t)&unk_1F2643FD0;
  qword_1EBCE0010 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCE0018 = (uint64_t)&unk_1F25F6428;
  qword_1EBCE0030 = (uint64_t)&qword_1EBCE0018;
  sub_1CD6674AC(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCDFF50);
}

__n128 sub_1CD6674AC(const char **a1, _WORD *a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCDFF50, "hotcoldsplit-cold-section-name", 0x1EuLL);
  sub_1CD476D48(a1, (uint64_t)&qword_1EBCDFF50);
  word_1EBCDFF5A = (32 * (*a2 & 3)) | word_1EBCDFF5A & 0xFF9F;
  __n128 result = *a3;
  xmmword_1EBCDFF70 = (__int128)*a3;
  return result;
}

void sub_1CD667524(int **a1, _WORD *a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCDFE90, 0, 0);
  dword_1EBCDFF10 = 0;
  qword_1EBCDFF18 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCDFF20 = 0;
  qword_1EBCDFE90 = (uint64_t)&unk_1F2643F68;
  qword_1EBCDFF28 = (uint64_t)&unk_1F2643D20;
  qword_1EBCDFF30 = (uint64_t)&unk_1F25F7480;
  qword_1EBCDFF48 = (uint64_t)&qword_1EBCDFF30;
  sub_1CD667614(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCDFE90);
}

__n128 sub_1CD667614(int **a1, _WORD *a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCDFE90, "hotcoldsplit-max-params", 0x17uLL);
  uint64_t v6 = *a1;
  dword_1EBCDFF10 = **a1;
  byte_1EBCDFF24 = 1;
  dword_1EBCDFF20 = *v6;
  word_1EBCDFE9A = (32 * (*a2 & 3)) | word_1EBCDFE9A & 0xFF9F;
  __n128 result = *a3;
  xmmword_1EBCDFEB0 = (__int128)*a3;
  return result;
}

void llvm::OutlinableRegion::reattachCandidate(llvm::OutlinableRegion *this)
{
  uint64_t v1 = *((void *)this + 28);
  uint64_t v2 = *(void *)(v1 + 40);
  if (v2 == v1 + 40)
  {
    uint64_t v4 = 0;
  }
  else
  {
    if (v2) {
      int v3 = (unsigned __int8 *)(v2 - 24);
    }
    else {
      int v3 = 0;
    }
    if (v3[16] - 29 >= 0xB) {
      uint64_t v4 = 0;
    }
    else {
      uint64_t v4 = (llvm::Instruction *)v3;
    }
  }
  llvm::Instruction::eraseFromParent(v4);
}

unint64_t llvm::OutlinableRegion::getBenefit(llvm::OutlinableRegion *this, llvm::TargetTransformInfo *a2)
{
  uint64_t v2 = *(void *)(*(void *)this + 8);
  uint64_t v3 = *(void *)(*(void *)(*(void *)this + 16) + 8);
  if (v2 == v3) {
    return 0;
  }
  unint64_t v5 = 0;
  do
  {
    uint64_t v6 = *(void *)(v2 + 16);
    if (*(unsigned __int8 *)(v6 + 16) - 47 >= 6) {
      uint64_t v7 = sub_1CBFB51A8(a2, v6);
    }
    else {
      uint64_t v7 = 1;
    }
    if (__OFADD__(v5, v7)) {
      unint64_t v5 = ((uint64_t)(v5 + v7) >> 63) ^ 0x8000000000000000;
    }
    else {
      v5 += v7;
    }
    uint64_t v2 = *(void *)(v2 + 8);
  }
  while (v2 != v3);
  return v5;
}

uint64_t **OutlinableGroup::collectGVNStoreSets(uint64_t **this, llvm::Module *a2)
{
  uint64_t v3 = (uint64_t)this;
  uint64_t v4 = *this;
  unint64_t v5 = this[1];
  if (*this != v5)
  {
    do
    {
      uint64_t v6 = *v4++;
      uint64_t v7 = (const void *)*(unsigned int *)(v6 + 168);
      v10[0] = *(const void **)(v6 + 160);
      v10[1] = v7;
      this = (uint64_t **)sub_1CD66A728((uint64_t)v11, v3 + 120, v10);
    }
    while (v4 != v5);
  }
  if (*(_DWORD *)(v3 + 128) > 1u)
  {
    uint64_t v8 = **(void **)a2 + 1960;
    v11[0] = v8;
    long long v9 = *(uint64_t **)(v3 + 32);
    if ((unint64_t)v9 >= *(void *)(v3 + 40))
    {
      this = (uint64_t **)sub_1CBC13470((void **)(v3 + 24), v11);
    }
    else
    {
      *long long v9 = v8;
      this = (uint64_t **)(v9 + 1);
    }
    *(void *)(v3 + 32) = this;
  }
  return this;
}

uint64_t llvm::IROutliner::createFunction(llvm::IROutliner *this, llvm::Module *a2, OutlinableGroup *a3, unsigned int a4)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = (llvm::Type *)(**(void **)a2 + 1576);
  uint64_t v8 = *(void *)a3;
  uint64_t v9 = *((void *)a3 + 1);
  while (v8 != v9)
  {
    uint64_t v10 = **(llvm::Type ***)(*(void *)(*(void *)(*(void *)v8 + 208) + 24) + 16);
    if (*((unsigned char *)v7 + 8) == 7 && *((unsigned char *)v10 + 8) != 7
      || llvm::Type::isIntegerTy(v7, 1) && llvm::Type::isIntegerTy(v10, 16))
    {
      uint64_t v7 = v10;
    }
    v8 += 8;
  }
  unint64_t v11 = (llvm::PointerType *)llvm::FunctionType::get((uint64_t **)v7, *((void *)a3 + 3), (uint64_t)(*((void *)a3 + 4) - *((void *)a3 + 3)) >> 3, 0);
  *((void *)a3 + 6) = v11;
  std::to_string(&v40, a4);
  BOOL v12 = std::string::insert(&v40, 0, "outlined_ir_func_");
  std::string::size_type v13 = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  std::string::size_type v32 = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  __int16 v42 = 260;
  v41[0] = (const char *)__p;
  *((void *)a3 + 7) = llvm::Function::Create(v11, 7, v41, (unint64_t)a2);
  if (SHIBYTE(v32) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v40.__r_.__value_.__l.__data_);
  }
  uint64_t v14 = *((void *)a3 + 7);
  if (*((unsigned char *)a3 + 268))
  {
    llvm::Function::addParamAttr(v14, *((_DWORD *)a3 + 66), 63);
    uint64_t v14 = *((void *)a3 + 7);
  }
  llvm::Function::addFnAttr(v14, 42);
  llvm::Function::addFnAttr(*((void *)a3 + 7), 15);
  uint64_t v15 = *(void *)a3;
  uint64_t v16 = *((void *)a3 + 1);
  while (v15 != v16)
  {
    unint64_t v17 = *(llvm::Function **)(*(void *)(*(void *)(*(void *)v15 + 200) + 40) + 56);
    if (v17)
    {
      uint64_t Subprogram = llvm::Function::getSubprogram(v17);
      if (Subprogram)
      {
        uint64_t v19 = Subprogram;
        unint64_t v20 = (const llvm::GlobalValue *)*((void *)a3 + 7);
        llvm::DIBuilder::DIBuilder(v41, a2, 1, *(void *)(Subprogram - 8 * *(unsigned int *)(Subprogram + 8) + 40));
        if (*(unsigned char *)v19 != 15) {
          uint64_t v19 = *(void *)(v19 - 8 * *(unsigned int *)(v19 + 8));
        }
        memset(&v40, 0, 20);
        uint64_t v39 = 0;
        *(_OWORD *)v38 = 0u;
        LODWORD(__p[1]) = 0;
        char v34 = 0;
        uint64_t v35 = 0;
        uint64_t v37 = v38;
        int v36 = 0;
        __p[0] = &unk_1F2646F30;
        std::string::size_type v32 = 0;
        long long v33 = 0u;
        llvm::Mangler::getNameWithPrefix((llvm::Mangler *)&v40, (char **)__p, v20, 0);
        Name = (unsigned __int8 *)llvm::Value::getName(v20);
        size_t v23 = v22;
        char v24 = *((unsigned char *)v37 + 23);
        if (v24 >= 0) {
          uint64_t v25 = (unsigned __int8 *)v37;
        }
        else {
          uint64_t v25 = (unsigned __int8 *)*v37;
        }
        if (v24 >= 0) {
          uint64_t v26 = (void *)(v24 & 0x7F);
        }
        else {
          uint64_t v26 = v37[1];
        }
        TypeArray = llvm::DIBuilder::getOrCreateTypeArray((uint64_t)v41, 0, 0);
        llvm::DIBuilder::createSubroutineType((uint64_t)v41, (uint64_t)TypeArray, 0, 0);
        uint64_t Function = (llvm::DISubprogram *)llvm::DIBuilder::createFunction((uint64_t)v41, (unsigned char *)v19, Name, v23, v25, v26, (void *)v19, 0, v28, 0, 0x40u, 0x18u, 0, 0, 0, 0, "", 0);
        llvm::DIBuilder::finalizeSubprogram((llvm::DIBuilder *)v41, Function);
        llvm::Function::setSubprogram((uint64_t ***)v20, Function);
        llvm::DIBuilder::finalize((llvm::DIBuilder *)v41);
        llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)__p);
        if (SHIBYTE(v39) < 0) {
          operator delete(v38[0]);
        }
        MEMORY[0x1D25D9CD0](v40.__r_.__value_.__r.__words[0], 8);
        sub_1CC2DBB1C((uint64_t)v41);
        return *((void *)a3 + 7);
      }
    }
    v15 += 8;
  }
  return *((void *)a3 + 7);
}

uint64_t replaceCalledFunction(llvm::Module *a1, llvm::OutlinableRegion *a2)
{
  __p = 0;
  char v34 = 0;
  unint64_t v35 = 0;
  uint64_t v4 = *((void *)a2 + 32);
  uint64_t v5 = *((void *)a2 + 25);
  uint64_t v6 = *(void *)(v4 + 56);
  if (*((unsigned char *)a2 + 104)
    || (uint64_t v28 = *(void *)(v6 + 96),
        v28 != ((sub_1CBF5BBBC(*((void *)a2 + 25))
                             - (v5
                              + 32 * (unint64_t)-(*(_DWORD *)(v5 + 20) & 0x7FFFFFF))) >> 5)))
  {
    unsigned int v32 = 0;
    unint64_t v7 = *(void *)(v6 + 96);
    if (!v7)
    {
      BOOL v12 = 0;
      uint64_t v19 = 0;
LABEL_21:
      unint64_t v20 = *(uint64_t ***)(v6 + 24);
      uint64_t v21 = ((char *)v12 - (char *)v19) >> 3;
      __int16 v31 = 257;
      size_t v22 = (unsigned __int8 **)llvm::User::operator new((llvm::User *)0x50, (int)v21 + 1);
      sub_1CC93B7F0((llvm::Value *)v22, v20, (uint64_t **)v6, v19, v21, 0, 0, v30, v5);
      size_t v23 = (llvm::ValueAsMetadata *)*((void *)a2 + 25);
      uint64_t v24 = *((void *)a2 + 1);
      if (*(llvm::ValueAsMetadata **)(v24 + 16) == v23) {
        *(void *)(v24 + 16) = v22;
      }
      uint64_t v25 = *((void *)a2 + 2);
      if (*(llvm::ValueAsMetadata **)(v25 + 16) == v23) {
        *(void *)(v25 + 16) = v22;
      }
      uint64_t v26 = (unsigned __int8 *)*((void *)v23 + 6);
      char v29 = v26;
      if (v26) {
        llvm::MetadataTracking::track((uint64_t)&v29, v26, 2);
      }
      sub_1CB8F69CC(v22 + 6, &v29);
      if (v29) {
        llvm::MetadataTracking::untrack((uint64_t)&v29, v29);
      }
      llvm::Value::doRAUW(v23, (llvm::Value *)v22, (llvm::Value *)1);
      llvm::Instruction::eraseFromParent(v23);
    }
    uint64_t v8 = 0;
    while (v7 - 1 != v8 || *(_DWORD *)(v4 + 128) < 2u)
    {
      std::string::size_type v13 = sub_1CBA9CB98((uint64_t *)a2 + 7, &v32);
      if ((int *)(*((void *)a2 + 7) + 8 * *((unsigned int *)a2 + 18)) == v13)
      {
        uint64_t v14 = *((void *)a2 + 17);
        uint64_t v15 = *((unsigned int *)a2 + 38);
        unsigned int v16 = v32;
        unint64_t v17 = sub_1CD57516C(v14, *((_DWORD *)a2 + 38), v32);
        if ((int *)(v14 + 16 * v15) != v17)
        {
          uint64_t v10 = (const char *)*((void *)v17 + 1);
          v30[0] = v10;
LABEL_8:
          unint64_t v11 = v34;
          if ((unint64_t)v34 < v35) {
            goto LABEL_12;
          }
          goto LABEL_9;
        }
        if (*(_WORD *)(v6 + 18)) {
          llvm::Function::BuildLazyArguments((llvm::Function *)v6);
        }
        uint64_t v9 = (const char *)llvm::ConstantPointerNull::get(*(llvm::ConstantPointerNull **)(*(void *)(v6 + 88) + 40 * v16), v18);
LABEL_7:
        uint64_t v10 = v9;
        v30[0] = v9;
        goto LABEL_8;
      }
      v30[0] = 0;
      uint64_t v10 = *(const char **)(v5 - 32 * (*(_DWORD *)(v5 + 20) & 0x7FFFFFF) + 32 * v13[1]);
      v30[0] = v10;
      unint64_t v11 = v34;
      if ((unint64_t)v34 < v35)
      {
LABEL_12:
        *unint64_t v11 = v10;
        BOOL v12 = v11 + 1;
        goto LABEL_13;
      }
LABEL_9:
      BOOL v12 = (const char **)sub_1CBC13470(&__p, v30);
LABEL_13:
      char v34 = v12;
      uint64_t v8 = ++v32;
      unint64_t v7 = *(void *)(v6 + 96);
      if (v7 <= v32)
      {
        uint64_t v19 = (uint64_t *)__p;
        goto LABEL_21;
      }
    }
    uint64_t v9 = (const char *)llvm::ConstantInt::get((llvm::ConstantInt *)(**(void **)a1 + 1960), *((unsigned int *)a2 + 7), 0);
    goto LABEL_7;
  }
  sub_1CC1DDE04(v5, v6);
  return v5;
}

void replaceConstants(llvm::OutlinableRegion *a1)
{
  uint64_t v1 = *((void *)a1 + 17);
  uint64_t v2 = *((unsigned int *)a1 + 38);
  uint64_t v3 = (unsigned int *)(v1 + 16 * v2);
  if (*((_DWORD *)a1 + 36))
  {
    if (v2)
    {
      uint64_t v4 = 16 * v2;
      uint64_t v5 = (unsigned int *)*((void *)a1 + 17);
      while (*v5 >= 0xFFFFFFFE)
      {
        v5 += 4;
        v4 -= 16;
        if (!v4) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v5 = (unsigned int *)*((void *)a1 + 17);
    }
  }
  else
  {
LABEL_6:
    uint64_t v5 = (unsigned int *)(v1 + 16 * v2);
  }
  uint64_t v6 = (unsigned int *)(v1 + 16 * v2);
  if (v5 != v6)
  {
    uint64_t v7 = *((void *)a1 + 32);
    do
    {
      unsigned int v8 = *v5;
      uint64_t v9 = *(void *)(v7 + 56);
      uint64_t v10 = (llvm::Value *)*((void *)v5 + 1);
      if (*(_WORD *)(v9 + 18)) {
        llvm::Function::BuildLazyArguments(*(llvm::Function **)(v7 + 56));
      }
      unint64_t v11 = (llvm::Value *)(*(void *)(v9 + 88) + 40 * v8);
      uint64_t v14 = v9;
      llvm::Value::replaceUsesWithIf(v10, v11, (unsigned int (*)(uint64_t, uint64_t))sub_1CC93DB48, (uint64_t)&v14);
      BOOL v12 = v5 + 4;
      while (v12 != v3)
      {
        unsigned int v13 = *v12;
        v12 += 4;
        if (v13 <= 0xFFFFFFFD)
        {
          uint64_t v5 = v12 - 4;
          goto LABEL_16;
        }
      }
      uint64_t v5 = v3;
LABEL_16:
      ;
    }
    while (v5 != v6);
  }
}

uint64_t findDuplicateOutputBlock(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v29 = a2[1];
  if (*a2 == v29)
  {
LABEL_44:
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    return v27 | v26;
  }
  unsigned int v4 = 0;
LABEL_3:
  uint64_t v5 = *(unsigned int *)(v2 + 16);
  uint64_t v6 = *(void *)v2 + 16 * v5;
  if (*(_DWORD *)(v2 + 8))
  {
    if (*(_DWORD *)(v2 + 16))
    {
      uint64_t v7 = 16 * v5;
      unsigned int v8 = *(uint64_t **)v2;
      while ((*v8 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v8 += 2;
        v7 -= 16;
        if (!v7) {
          goto LABEL_8;
        }
      }
    }
    else
    {
      unsigned int v8 = *(uint64_t **)v2;
    }
  }
  else
  {
LABEL_8:
    unsigned int v8 = (uint64_t *)(*(void *)v2 + 16 * v5);
  }
  uint64_t v9 = *(void *)v2 + 16 * v5;
  if (v8 == (uint64_t *)v9) {
    goto LABEL_46;
  }
  char v10 = 0;
  do
  {
    uint64_t v11 = *v8;
    uint64_t v30 = 0;
    if (sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), v11, &v30)) {
      BOOL v12 = v30 == *(void *)a1 + 16 * *(unsigned int *)(a1 + 16);
    }
    else {
      BOOL v12 = 1;
    }
    if (v12) {
      goto LABEL_41;
    }
    uint64_t v13 = 0;
    uint64_t v14 = v8[1];
    uint64_t v15 = *(void *)(v30 + 8);
    uint64_t v16 = v14 + 40;
    uint64_t v17 = -2;
    uint64_t v18 = v14 + 40;
    do
    {
      uint64_t v19 = v13;
      uint64_t v18 = *(void *)(v18 + 8);
      ++v17;
      ++v13;
    }
    while (v18 != v16);
    uint64_t v20 = v15 + 40;
    do
    {
      uint64_t v20 = *(void *)(v20 + 8);
      --v19;
    }
    while (v20 != v15 + 40);
    if (v19)
    {
LABEL_41:
      ++v4;
      v2 += 24;
      if (v2 == v29) {
        goto LABEL_44;
      }
      goto LABEL_3;
    }
    uint64_t v21 = *(void *)(v14 + 48);
    if (v21 == v16) {
      goto LABEL_32;
    }
    uint64_t v22 = *(void *)(v15 + 48);
    while (1)
    {
      if (v21) {
        size_t v23 = (llvm::Instruction *)(v21 - 24);
      }
      else {
        size_t v23 = 0;
      }
      if (*((unsigned char *)v23 + 16) == 30) {
        goto LABEL_31;
      }
      uint64_t v24 = v22 ? (const llvm::Instruction *)(v22 - 24) : 0;
      if (!llvm::Instruction::isIdenticalTo(v23, v24)) {
        break;
      }
      uint64_t v22 = *(void *)(v22 + 8);
LABEL_31:
      uint64_t v21 = *(void *)(v21 + 8);
      if (v21 == v16) {
        goto LABEL_32;
      }
    }
    char v10 = 1;
LABEL_32:
    uint64_t v25 = v8 + 2;
    unsigned int v8 = (uint64_t *)v6;
    if (v25 != (uint64_t *)v6)
    {
      unsigned int v8 = v25;
      while ((*v8 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v8 += 2;
        if (v8 == (uint64_t *)v6)
        {
          unsigned int v8 = (uint64_t *)v6;
          break;
        }
      }
    }
  }
  while (v8 != (uint64_t *)v9);
  if (v10) {
    goto LABEL_41;
  }
LABEL_46:
  uint64_t v27 = v4;
  uint64_t v26 = 0x100000000;
  return v27 | v26;
}

uint64_t createSwitchStatement(uint64_t result, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v48 = result;
  if (*(_DWORD *)(a2 + 128) < 2u)
  {
    uint64_t v34 = *a4;
    if (a4[1] - *a4 != 24) {
      return result;
    }
    uint64_t v51 = 0;
    uint64_t v52 = 0;
    unsigned int v53 = 0;
    sub_1CBFCBCC4((uint64_t)&v51, v34);
    if (v52)
    {
      if (v53)
      {
        uint64_t v36 = 16 * v53;
        uint64_t v37 = v51;
        while ((*v37 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v37 += 2;
          v36 -= 16;
          if (!v36) {
            goto LABEL_53;
          }
        }
      }
      else
      {
        uint64_t v37 = v51;
      }
    }
    else
    {
LABEL_53:
      uint64_t v37 = &v51[2 * v53];
    }
    if (v37 != &v51[2 * v53])
    {
      uint64_t v38 = *v37;
      v54 = 0;
      sub_1CD40EA84(*(void *)a3, *(_DWORD *)(a3 + 16), v38, &v54);
      uint64_t v39 = v37[1];
      uint64_t v40 = *(void *)(v39 + 40);
      if (v40 == v39 + 40)
      {
        __int16 v42 = 0;
      }
      else
      {
        if (v40) {
          v41 = (unsigned __int8 *)(v40 - 24);
        }
        else {
          v41 = 0;
        }
        if (v41[16] - 29 >= 0xB) {
          __int16 v42 = 0;
        }
        else {
          __int16 v42 = (llvm::Instruction *)v41;
        }
      }
      llvm::Instruction::eraseFromParent(v42);
    }
    uint64_t v43 = v51;
  }
  else
  {
    uint64_t v6 = *(void *)(a2 + 56);
    uint64_t v51 = 0;
    uint64_t v52 = 0;
    unsigned int v53 = 0;
    v49 = "final_block";
    __int16 v50 = 259;
    sub_1CC936600(a2 + 72, (uint64_t)&v51, v6, (uint64_t)&v49);
    size_t v46 = a4;
    size_t v47 = v51;
    uint64_t v7 = &v51[2 * v53];
    if (v52)
    {
      if (v53)
      {
        uint64_t v8 = 16 * v53;
        uint64_t v9 = v51;
        while ((*v9 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v9 += 2;
          v8 -= 16;
          if (!v8) {
            goto LABEL_7;
          }
        }
      }
      else
      {
        uint64_t v9 = v51;
      }
    }
    else
    {
LABEL_7:
      uint64_t v9 = &v51[2 * v53];
    }
    v45 = &v51[2 * v53];
    if (v9 != v45)
    {
      uint64_t v44 = v6;
      do
      {
        uint64_t v10 = *v9;
        v54 = 0;
        if (sub_1CD40EA84(*(void *)(a2 + 72), *(_DWORD *)(a2 + 88), v10, &v54)) {
          uint64_t v11 = v54;
        }
        else {
          uint64_t v11 = (uint64_t *)(*(void *)(a2 + 72) + 16 * *(unsigned int *)(a2 + 88));
        }
        BOOL v12 = (llvm::BasicBlock *)v11[1];
        uint64_t v13 = (void *)*((void *)v12 + 5);
        if (v13 == (void *)((char *)v12 + 40))
        {
          uint64_t v15 = 0;
        }
        else
        {
          if (v13) {
            uint64_t v14 = v13 - 3;
          }
          else {
            uint64_t v14 = 0;
          }
          if (*((unsigned __int8 *)v14 + 16) - 29 >= 0xB) {
            uint64_t v15 = 0;
          }
          else {
            uint64_t v15 = v14;
          }
        }
        uint64_t v16 = (uint64_t *)v9[1];
        llvm::Instruction::moveBefore(v15, (uint64_t)v16, v16 + 5);
        uint64_t v17 = *(void *)(v6 + 96);
        if (*(_WORD *)(v6 + 18)) {
          llvm::Function::BuildLazyArguments((llvm::Function *)v6);
        }
        uint64_t v18 = (llvm::Value *)(*(void *)(v6 + 88) + 40 * (v17 - 1));
        unsigned int v19 = -1431655765 * ((unint64_t)(v46[1] - *v46) >> 3);
        uint64_t v20 = (llvm::SwitchInst *)llvm::User::operator new((llvm::User *)0x40);
        llvm::SwitchInst::SwitchInst(v20, v18, (llvm::BasicBlock *)v16, v19, v12);
        uint64_t v21 = *v46;
        uint64_t v22 = v46[1];
        if (*v46 != v22)
        {
          unsigned int v23 = 0;
          do
          {
            uint64_t v24 = *v11;
            v54 = 0;
            if (sub_1CD40EA84(*(void *)v21, *(_DWORD *)(v21 + 16), v24, &v54))
            {
              uint64_t v25 = (uint64_t)v54;
              uint64_t v26 = *(unsigned int *)(v21 + 16);
              uint64_t v27 = *(void *)v21;
            }
            else
            {
              uint64_t v27 = *(void *)v21;
              uint64_t v26 = *(unsigned int *)(v21 + 16);
              uint64_t v25 = *(void *)v21 + 16 * v26;
            }
            if (v25 != v27 + 16 * v26)
            {
              uint64_t v28 = *(llvm::BasicBlock **)(v25 + 8);
              uint64_t v29 = (llvm::ConstantInt *)llvm::ConstantInt::get((llvm::ConstantInt *)(**(void **)v48 + 1960), v23, 0);
              llvm::SwitchInst::addCase(v20, v29, v28);
              uint64_t v30 = (void *)*((void *)v28 + 5);
              if (v30 == (void *)((char *)v28 + 40))
              {
                uint64_t v32 = 0;
              }
              else
              {
                if (v30) {
                  uint64_t v31 = (uint64_t)(v30 - 3);
                }
                else {
                  uint64_t v31 = 0;
                }
                if (*(unsigned __int8 *)(v31 + 16) - 29 >= 0xB) {
                  uint64_t v32 = 0;
                }
                else {
                  uint64_t v32 = v31;
                }
              }
              llvm::Instruction::setSuccessor(v32, 0, (llvm::BasicBlock *)v16);
              ++v23;
            }
            v21 += 24;
          }
          while (v21 != v22);
        }
        long long v33 = v9 + 2;
        uint64_t v9 = v7;
        uint64_t v6 = v44;
        if (v33 != v7)
        {
          uint64_t v9 = v33;
          while ((*v9 | 0x1000) == 0xFFFFFFFFFFFFF000)
          {
            v9 += 2;
            if (v9 == v7)
            {
              uint64_t v9 = v7;
              break;
            }
          }
        }
      }
      while (v9 != v45);
    }
    uint64_t v43 = v47;
  }
  return MEMORY[0x1D25D9CD0](v43, 8);
}

uint64_t llvm::IROutliner::isCompatibleWithAlreadyOutlinedCode(llvm::IROutliner *this, unsigned int **a2)
{
  unsigned int v4 = *a2;
  unsigned int v5 = **a2;
  unsigned int v6 = v5 + (*a2)[1] - 1;
  unsigned int v20 = v5;
  uint64_t v7 = v4;
  if (v5 <= v6)
  {
    while ((int *)(*((void *)this + 1) + 4 * *((unsigned int *)this + 6)) == sub_1CD48C650((uint64_t *)this + 1, &v20))
    {
      if (++v20 > v6)
      {
        uint64_t v7 = *a2;
        goto LABEL_2;
      }
    }
    return 0;
  }
  else
  {
LABEL_2:
    uint64_t v8 = *(unsigned __int8 **)(*((void *)v7 + 2) + 16);
    if (v8[16] - 29 >= 0xB)
    {
      uint64_t NextNonDebugInstruction = llvm::Instruction::getNextNonDebugInstruction((llvm::Instruction *)v8, 0);
      if (*(void *)(*(void *)(*((void *)*a2 + 2) + 8) + 16) != NextNonDebugInstruction)
      {
        uint64_t v14 = NextNonDebugInstruction;
        uint64_t v15 = *(void *)(*((void *)*a2 + 1) + 152);
        uint64_t v16 = sub_1CB906F34((uint64_t *)this + 37, 160, 3);
        char v17 = sub_1CD6689A4((unsigned __int8 *)this + 392, v14);
        llvm::IRSimilarity::IRInstructionData::IRInstructionData(v16, v14, v17, v15);
        uint64_t v18 = *(uint64_t **)(*((void *)*a2 + 2) + 8);
        unint64_t v19 = *v18 & 0xFFFFFFFFFFFFFFF8;
        *(void *)uint64_t v16 = v19 | *(void *)v16 & 7;
        *(void *)(v16 + 8) = v18;
        *(void *)(v19 + 8) = v16;
        *uint64_t v18 = *v18 & 7 | v16;
      }
    }
    uint64_t v10 = *((void *)v4 + 1);
    uint64_t v11 = *(void *)(*((void *)v4 + 2) + 8);
    if (v10 == v11)
    {
      return 1;
    }
    else
    {
      BOOL v12 = (unsigned __int8 *)this + 392;
      while (1)
      {
        uint64_t result = sub_1CC93DC54(*(void *)(*(void *)(v10 + 8) + 16), *(llvm::Instruction **)(v10 + 16));
        if (!result) {
          break;
        }
        uint64_t result = sub_1CD6689A4(v12, *(void *)(v10 + 16));
        if (!result) {
          break;
        }
        uint64_t v10 = *(void *)(v10 + 8);
        if (v10 == v11) {
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1CD6689A4(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t result = 0;
  switch(*(unsigned char *)(a2 + 16))
  {
    case 0x1E:
    case 0x53:
      uint64_t result = *a1 != 0;
      break;
    case 0x28:
    case 0x29:
    case 0x2A:
    case 0x2B:
    case 0x2C:
    case 0x2D:
    case 0x2E:
    case 0x2F:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x36:
    case 0x37:
    case 0x38:
    case 0x39:
    case 0x3A:
    case 0x3C:
    case 0x3D:
    case 0x3E:
    case 0x3F:
    case 0x40:
    case 0x41:
    case 0x42:
    case 0x43:
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:
    case 0x48:
    case 0x49:
    case 0x4A:
    case 0x4B:
    case 0x4C:
    case 0x4D:
    case 0x4E:
    case 0x51:
    case 0x52:
    case 0x55:
    case 0x56:
    case 0x57:
    case 0x59:
    case 0x5A:
    case 0x5B:
    case 0x5C:
    case 0x5D:
      uint64_t result = 1;
      break;
    case 0x54:
      uint64_t result = sub_1CD66AB00((uint64_t)a1, a2);
      break;
    default:
      return result;
  }
  return result;
}

unint64_t llvm::IROutliner::findBenefitFromAllRegions(uint64_t a1, llvm::OutlinableRegion ***a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  if (*a2 == v3) {
    return 0;
  }
  unint64_t v5 = 0;
  do
  {
    unsigned int v6 = *v2++;
    uint64_t v7 = (llvm::TargetTransformInfo *)(*(uint64_t (**)(void, void))(a1 + 32))(*(void *)(a1 + 40), *(void *)(*((void *)v6 + 29) + 56));
    unint64_t Benefit = llvm::OutlinableRegion::getBenefit(v6, v7);
    if (__OFADD__(v5, Benefit)) {
      unint64_t v5 = ((uint64_t)(v5 + Benefit) >> 63) ^ 0x8000000000000000;
    }
    else {
      v5 += Benefit;
    }
  }
  while (v2 != v3);
  return v5;
}

unint64_t llvm::IROutliner::findCostOutputReloads(uint64_t a1, uint64_t **a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  if (*a2 == v3) {
    return 0;
  }
  unint64_t v5 = 0;
  do
  {
    uint64_t v6 = *v2;
    uint64_t v7 = (*(uint64_t (**)(void, void))(a1 + 32))(*(void *)(a1 + 40), *(void *)(*(void *)(*v2 + 232) + 56));
    uint64_t v8 = *(unsigned int *)(v6 + 168);
    if (v8)
    {
      uint64_t v9 = v7;
      uint64_t v10 = *(unsigned int **)(v6 + 160);
      uint64_t v11 = 4 * v8;
      do
      {
        unsigned int v12 = *v10++;
        sub_1CC938A30(*(void *)v6, *(void *)(v6 + 256), v12);
        uint64_t v13 = (*(uint64_t (**)(void))(**(void **)v9 + 888))();
        if (__OFADD__(v5, v13)) {
          unint64_t v5 = ((uint64_t)(v5 + v13) >> 63) ^ 0x8000000000000000;
        }
        else {
          v5 += v13;
        }
        v11 -= 4;
      }
      while (v11);
    }
    ++v2;
  }
  while (v2 != v3);
  return v5;
}

uint64_t llvm::IROutliner::updateOutputMapping(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(void *)(a5 - 32);
  unint64_t v10 = *(unsigned int *)(a2 + 24);
  uint64_t v11 = *(void *)(a2 + 200);
  uint64_t result = sub_1CBF5BBBC(v11);
  if (v10 < ((result - (v11 + 32 * (unint64_t)-(*(_DWORD *)(v11 + 20) & 0x7FFFFFF))) >> 5))
  {
    for (uint64_t i = 32 * v10; ; i += 32)
    {
      uint64_t v14 = *(void *)(a2 + 200);
      if (v9 == *(void *)(v14 - 32 * (*(_DWORD *)(v14 + 20) & 0x7FFFFFF) + i)) {
        break;
      }
      ++v10;
      uint64_t result = sub_1CBF5BBBC(*(void *)(a2 + 200));
      if (v10 >= ((result - (v14 + 32 * (unint64_t)-(*(_DWORD *)(v14 + 20) & 0x7FFFFFF))) >> 5)) {
        return result;
      }
    }
    uint64_t v15 = (v10 - *(_DWORD *)(a2 + 24));
    uint64_t v19 = *(void *)(a3 + 8 * v15);
    v18[0] = 0;
    if (!sub_1CBA0E618(a1 + 48, &v19, v18)
      || v18[0] == *(void *)(a1 + 48) + 16 * *(unsigned int *)(a1 + 64))
    {
      uint64_t v17 = *(void *)(a3 + 8 * v15);
    }
    else
    {
      uint64_t v19 = *(void *)(a3 + 8 * v15);
      v18[0] = 0;
      if (sub_1CBA0E618(a1 + 48, &v19, v18)) {
        uint64_t v16 = v18[0];
      }
      else {
        uint64_t v16 = *(void *)(a1 + 48) + 16 * *(unsigned int *)(a1 + 64);
      }
      uint64_t v17 = *(void *)(v16 + 8);
    }
    uint64_t v19 = a5;
    uint64_t v20 = v17;
    return sub_1CC27B388(a1 + 48, &v19, &v20, (uint64_t)v18);
  }
  return result;
}

uint64_t sub_1CD668D28(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result != a2)
  {
    v13[9] = v4;
    v13[10] = v5;
    uint64_t v9 = result;
    do
    {
      uint64_t v11 = *(void *)(*(void *)(v9 + 16) + 40);
      uint64_t v12 = 0;
      v13[0] = v11;
      uint64_t result = sub_1CBFFBBB4((uint64_t *)a3, v13, &v12);
      if (!result || v12 == *(void *)a3 + 8 * *(unsigned int *)(a3 + 16))
      {
        uint64_t result = sub_1CBB23C3C((_DWORD *)a3, &v11, (uint64_t)v13);
        unint64_t v10 = *(unsigned int *)(a4 + 8);
        if (v10 >= *(unsigned int *)(a4 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a4 + 8 * v10) = v11;
        ++*(_DWORD *)(a4 + 8);
      }
      uint64_t v9 = *(void *)(v9 + 8);
    }
    while (v9 != a2);
  }
  return result;
}

uint64_t sub_1CD668E1C(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 16);
    uint64_t v4 = &v3[v2];
    do
    {
      uint64_t v5 = *(void *)(a1 + 16);
      uint64_t v6 = *v3;
      if (*v3 == *(void *)(v5 + 8 * *(unsigned int *)(a1 + 24) - 8))
      {
        unint64_t v8 = *(void *)a1;
      }
      else
      {
        uint64_t v7 = (((unint64_t)v3 - v5) >> 10) & 0x1FFFFFF;
        if (v7 >= 0x1E) {
          LOBYTE(v7) = 30;
        }
        unint64_t v8 = v6 + (4096 << v7);
      }
      unint64_t v9 = (v6 + 7) & 0xFFFFFFFFFFFFFFF8;
      unint64_t v10 = v9 + 240;
      while (v10 <= v8)
      {
        uint64_t v11 = sub_1CD6110E0(v9);
        unint64_t v10 = v11 + 480;
        unint64_t v9 = v11 + 240;
      }
      ++v3;
    }
    while (v3 != v4);
  }
  uint64_t v12 = *(unsigned int *)(a1 + 72);
  if (v12)
  {
    uint64_t v13 = *(void **)(a1 + 64);
    uint64_t v14 = &v13[2 * v12];
    do
    {
      unint64_t v15 = (*v13 + 7) & 0xFFFFFFFFFFFFFFF8;
      unint64_t v16 = *v13 + v13[1];
      unint64_t v17 = v15 + 240;
      while (v17 <= v16)
      {
        uint64_t v18 = sub_1CD6110E0(v15);
        unint64_t v17 = v18 + 480;
        unint64_t v15 = v18 + 240;
      }
      v13 += 2;
    }
    while (v13 != v14);
  }

  return sub_1CBFFBB10(a1);
}

void llvm::IROutlinerPass::run()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::AnalysisManager<llvm::Module>::getResultImpl();
}

void llvm::createIROutlinerPass(llvm *this)
{
}

unsigned int *sub_1CD6692E8(unsigned int *result, unsigned int *a2, unint64_t a3, unsigned int *a4, uint64_t a5)
{
  if (a3 >= 2)
  {
    uint64_t v6 = (char *)result;
    if (a3 == 2)
    {
      unsigned int v7 = *(a2 - 1);
      unsigned int v8 = *result;
      if (v7 < *result)
      {
        int *result = v7;
        *(a2 - 1) = v8;
      }
    }
    else if ((uint64_t)a3 > 128)
    {
      uint64_t v18 = a4;
      unint64_t v19 = a3 >> 1;
      uint64_t v20 = &result[a3 >> 1];
      unint64_t v21 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        sub_1CD66951C(result, v20, v21, a4);
        uint64_t v22 = &v18[v19];
        uint64_t result = sub_1CD66951C((unsigned int *)&v6[4 * (a3 >> 1)], a2, a3 - (a3 >> 1), v22);
        unsigned int v23 = &v18[a3];
        uint64_t v24 = v22;
        while (v24 != v23)
        {
          uint64_t v25 = v24;
          unsigned int v26 = *v24;
          unsigned int v27 = *v18;
          BOOL v28 = *v24 < *v18;
          if (v26 >= *v18) {
            unsigned int v29 = *v18;
          }
          else {
            unsigned int v29 = v26;
          }
          v18 += v26 >= *v18;
          uint64_t v24 = &v25[v28];
          *(_DWORD *)uint64_t v6 = v29;
          v6 += 4;
          if (v18 == v22)
          {
            if (v24 != v23)
            {
              uint64_t v30 = 0;
              if (v26 < v27) {
                char v31 = 1;
              }
              else {
                char v31 = 2;
              }
              uint64_t v32 = &v25[v31 & 1];
              do
              {
                *(_DWORD *)&v6[v30 * 4] = v32[v30];
                ++v30;
              }
              while (&v32[v30] != v23);
            }
            return result;
          }
        }
        if (v18 != v22)
        {
          uint64_t v33 = 0;
          do
          {
            *(_DWORD *)&v6[v33 * 4] = v18[v33];
            ++v33;
          }
          while (&v18[v33] != v22);
        }
      }
      else
      {
        sub_1CD6692E8(result, v20, v21, a4, a5);
        sub_1CD6692E8(&v6[4 * (a3 >> 1)], a2, a3 - (a3 >> 1), v18, a5);
        return (unsigned int *)sub_1CC93AE50(v6, &v6[4 * (a3 >> 1)], (char *)a2, a3 >> 1, a3 - (a3 >> 1), v18, a5);
      }
    }
    else if (result != a2)
    {
      unint64_t v10 = result + 1;
      if (result + 1 != a2)
      {
        uint64_t v11 = 0;
        uint64_t v12 = result;
        do
        {
          unsigned int v13 = *v12;
          uint64_t v12 = v10;
          unsigned int v14 = *v10;
          if (v14 < v13)
          {
            uint64_t v15 = v11;
            while (1)
            {
              *(unsigned int *)((char *)result + v15 + 4) = v13;
              if (!v15) {
                break;
              }
              unsigned int v13 = *(unsigned int *)((char *)result + v15 - 4);
              v15 -= 4;
              if (v14 >= v13)
              {
                unint64_t v16 = (unsigned int *)((char *)result + v15 + 4);
                goto LABEL_16;
              }
            }
            unint64_t v16 = result;
LABEL_16:
            *unint64_t v16 = v14;
          }
          unint64_t v10 = v12 + 1;
          v11 += 4;
        }
        while (v12 + 1 != a2);
      }
    }
  }
  return result;
}

unsigned int *sub_1CD66951C(unsigned int *result, unsigned int *a2, unint64_t a3, unsigned int *a4)
{
  if (a3)
  {
    uint64_t v4 = a4;
    uint64_t v6 = result;
    if (a3 == 1)
    {
LABEL_9:
      *uint64_t v4 = *v6;
      return result;
    }
    if (a3 == 2)
    {
      unsigned int v9 = *(a2 - 1);
      unsigned int v8 = v9;
      BOOL v10 = v9 >= *result;
      if (v9 >= *result) {
        unsigned int v8 = *result;
      }
      *a4 = v8;
      uint64_t v4 = a4 + 1;
      if (v10) {
        uint64_t v6 = a2 - 1;
      }
      goto LABEL_9;
    }
    if ((uint64_t)a3 > 8)
    {
      uint64_t v20 = &result[a3 >> 1];
      sub_1CD6692E8(result, v20, a3 >> 1, a4, a3 >> 1);
      uint64_t result = (unsigned int *)sub_1CD6692E8(&v6[a3 >> 1], a2, a3 - (a3 >> 1), &v4[a3 >> 1], a3 - (a3 >> 1));
      unint64_t v21 = &v6[a3 >> 1];
      while (v21 != a2)
      {
        uint64_t v22 = v21;
        unsigned int v23 = *v21;
        unsigned int v24 = *v6;
        BOOL v25 = *v21 >= *v6;
        BOOL v26 = *v21 < *v6;
        if (v23 >= *v6) {
          unsigned int v27 = *v6;
        }
        else {
          unsigned int v27 = v23;
        }
        unint64_t v21 = &v22[v26];
        v6 += v25;
        *v4++ = v27;
        if (v6 == v20)
        {
          if (v21 != a2)
          {
            uint64_t v28 = 0;
            unsigned int v29 = &v22[v23 < v24];
            do
            {
              v4[v28] = v29[v28];
              ++v28;
            }
            while (&v29[v28] != a2);
          }
          return result;
        }
      }
      if (v6 != v20)
      {
        uint64_t v30 = 0;
        do
        {
          v4[v30] = v6[v30];
          ++v30;
        }
        while (&v6[v30] != v20);
      }
    }
    else if (result != a2)
    {
      uint64_t v11 = result + 1;
      *a4 = *result;
      if (result + 1 != a2)
      {
        uint64_t v12 = 0;
        unsigned int v13 = a4;
        unsigned int v14 = a4;
        do
        {
          unsigned int v16 = *v14++;
          unsigned int v15 = v16;
          if (*v11 >= v16)
          {
            *unsigned int v14 = *v11;
          }
          else
          {
            v13[1] = v15;
            unint64_t v17 = a4;
            if (v13 != a4)
            {
              uint64_t v18 = v12;
              while (1)
              {
                unint64_t v17 = (unsigned int *)((char *)a4 + v18);
                unsigned int v19 = *(unsigned int *)((char *)a4 + v18 - 4);
                if (*v11 >= v19) {
                  break;
                }
                *unint64_t v17 = v19;
                v18 -= 4;
                if (!v18)
                {
                  unint64_t v17 = a4;
                  break;
                }
              }
            }
            *unint64_t v17 = *v11;
          }
          ++v11;
          v12 += 4;
          unsigned int v13 = v14;
        }
        while (v11 != a2);
      }
    }
  }
  return result;
}

uint64_t *sub_1CD6696FC(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (!a2) {
    return (uint64_t *)(a1 + 16 * a2);
  }
  LODWORD(v3) = (a2 - 1) & a3;
  uint64_t v4 = (uint64_t *)(a1 + 16 * v3);
  uint64_t v5 = *v4;
  if (*v4 != a3)
  {
    int v7 = 1;
    while (v5 != -1)
    {
      int v8 = v3 + v7++;
      uint64_t v3 = v8 & (a2 - 1);
      uint64_t v5 = *(void *)(a1 + 16 * v3);
      if (v5 == a3) {
        return (uint64_t *)(a1 + 16 * v3);
      }
    }
    return (uint64_t *)(a1 + 16 * a2);
  }
  return v4;
}

uint64_t sub_1CD669758(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CD56AEFC(*(void *)a2, *(_DWORD *)(a2 + 16), *a3, &v12);
  unsigned int v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD6697EC(a2, v12, a3, a4);
    unsigned int v9 = (_DWORD *)result;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 40 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

_DWORD *sub_1CD6697EC(uint64_t a1, _DWORD *a2, int *a3, uint64_t a4)
{
  uint64_t v6 = sub_1CD669860(a1, a3, a2);
  *uint64_t v6 = *a3;
  *((void *)v6 + 1) = *(void *)a4;
  *((void *)v6 + 2) = v6 + 8;
  *((void *)v6 + 3) = 0x200000000;
  if (*(_DWORD *)(a4 + 16)) {
    sub_1CC0778D4((uint64_t)(v6 + 4), a4 + 8);
  }
  return v6;
}

_DWORD *sub_1CD669860(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD669914(a1, v6);
  int v8 = 0;
  sub_1CD56AEFC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD669914(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(40 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD6699EC(a1, v4, v4 + 40 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 40 * v10;
    do
    {
      _DWORD *result = -1;
      result += 10;
      v11 -= 40;
    }
    while (v11);
  }
  return result;
}

void sub_1CD6699EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(_DWORD **)a1;
    uint64_t v8 = 40 * v6;
    do
    {
      *int v7 = -1;
      v7 += 10;
      v8 -= 40;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      int v9 = *(_DWORD *)v4;
      if (*(_DWORD *)v4 <= 0xFFFFFFFD)
      {
        unsigned int v15 = 0;
        sub_1CD56AEFC(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v15);
        uint64_t v10 = v15;
        uint64_t v11 = v15;
        _DWORD *v15 = *(_DWORD *)v4;
        uint64_t v12 = *(void *)(v4 + 8);
        *((void *)v10 + 2) = v11 + 8;
        uint64_t v13 = (uint64_t)(v10 + 4);
        *(void *)(v13 - 8) = v12;
        *(void *)(v13 + 8) = 0x200000000;
        if (*(_DWORD *)(v4 + 24)) {
          sub_1CC0778D4(v13, v4 + 16);
        }
        ++*(_DWORD *)(a1 + 8);
        unsigned int v14 = *(void **)(v4 + 16);
        if ((void *)(v4 + 32) != v14) {
          free(v14);
        }
      }
      v4 += 40;
    }
    while (v4 != a3);
  }
}

void *sub_1CD669AE8(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  unsigned int v8 = *(_DWORD *)(a2 + 16);
  if (!v8)
  {
    unsigned int v14 = 0;
LABEL_6:
    uint64_t result = sub_1CD669BD0(a2, a3, v14);
    void *result = *a3;
    *((_DWORD *)result + 2) = *a4;
    uint64_t v9 = *(void *)a2;
    unsigned int v8 = *(_DWORD *)(a2 + 16);
    char v13 = 1;
    goto LABEL_4;
  }
  uint64_t v9 = *(void *)a2;
  unsigned int v10 = (v8 - 1) & *a3;
  uint64_t result = (void *)(*(void *)a2 + 16 * v10);
  uint64_t v12 = *result;
  if (*a3 != *result)
  {
    unsigned int v15 = 0;
    int v16 = 1;
    while (v12 != -1)
    {
      if (v15) {
        BOOL v17 = 0;
      }
      else {
        BOOL v17 = v12 == -2;
      }
      if (v17) {
        unsigned int v15 = result;
      }
      unsigned int v18 = v10 + v16++;
      unsigned int v10 = v18 & (v8 - 1);
      uint64_t result = (void *)(v9 + 16 * v10);
      uint64_t v12 = *result;
      if (*a3 == *result) {
        goto LABEL_3;
      }
    }
    if (v15) {
      unsigned int v14 = v15;
    }
    else {
      unsigned int v14 = result;
    }
    goto LABEL_6;
  }
LABEL_3:
  char v13 = 0;
LABEL_4:
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v9 + 16 * v8;
  *(unsigned char *)(a1 + 16) = v13;
  return result;
}

void *sub_1CD669BD0(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    sub_1CD669D38(a1, 2 * v6);
    uint64_t v7 = *a2;
    int v9 = *(_DWORD *)(a1 + 16) - 1;
    unsigned int v10 = v9 & *a2;
    a3 = (void *)(*(void *)a1 + 16 * v10);
    uint64_t v11 = *a3;
    if (*a2 != *a3)
    {
      uint64_t v12 = 0;
      int v13 = 1;
      while (v11 != -1)
      {
        if (v12) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v11 == -2;
        }
        if (v14) {
          uint64_t v12 = a3;
        }
        unsigned int v15 = v10 + v13++;
        unsigned int v10 = v15 & v9;
        a3 = (void *)(*(void *)a1 + 16 * v10);
        uint64_t v11 = *a3;
        if (v7 == *a3) {
          goto LABEL_4;
        }
      }
      goto LABEL_20;
    }
  }
  else
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
    {
LABEL_3:
      uint64_t v7 = *a3;
      goto LABEL_4;
    }
    sub_1CD669D38(a1, v6);
    uint64_t v7 = *a2;
    int v16 = *(_DWORD *)(a1 + 16) - 1;
    unsigned int v17 = v16 & *a2;
    a3 = (void *)(*(void *)a1 + 16 * v17);
    uint64_t v18 = *a3;
    if (*a2 != *a3)
    {
      uint64_t v12 = 0;
      int v19 = 1;
      while (v18 != -1)
      {
        if (v12) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v18 == -2;
        }
        if (v20) {
          uint64_t v12 = a3;
        }
        unsigned int v21 = v17 + v19++;
        unsigned int v17 = v21 & v16;
        a3 = (void *)(*(void *)a1 + 16 * v17);
        uint64_t v18 = *a3;
        if (v7 == *a3) {
          goto LABEL_4;
        }
      }
LABEL_20:
      if (v12) {
        a3 = v12;
      }
      goto LABEL_3;
    }
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v7 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD669D38(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD669E04(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -1;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD669E04(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  *(void *)(result + 8) = 0;
  uint64_t v3 = *(void **)result;
  uint64_t v4 = *(unsigned int *)(result + 16);
  if (v4)
  {
    uint64_t v5 = 16 * v4;
    unint64_t v6 = *(void **)result;
    do
    {
      *unint64_t v6 = -1;
      v6 += 2;
      v5 -= 16;
    }
    while (v5);
  }
  for (; a2 != a3; a2 += 2)
  {
    uint64_t v7 = *a2;
    if ((unint64_t)*a2 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      int v8 = *(_DWORD *)(result + 16) - 1;
      int v9 = v8 & v7;
      uint64_t v10 = &v3[2 * (v8 & v7)];
      uint64_t v11 = *v10;
      if (v7 != *v10)
      {
        uint64_t v12 = 0;
        int v13 = 1;
        while (v11 != -1)
        {
          if (v12) {
            BOOL v14 = 0;
          }
          else {
            BOOL v14 = v11 == -2;
          }
          if (v14) {
            uint64_t v12 = v10;
          }
          int v15 = v9 + v13++;
          int v9 = v15 & v8;
          uint64_t v10 = &v3[2 * (v15 & v8)];
          uint64_t v11 = *v10;
          if (v7 == *v10) {
            goto LABEL_7;
          }
        }
        if (v12) {
          uint64_t v10 = v12;
        }
      }
LABEL_7:
      *uint64_t v10 = v7;
      *((_DWORD *)v10 + 2) = *((_DWORD *)a2 + 2);
      ++*(_DWORD *)(result + 8);
    }
  }
  return result;
}

unsigned int *sub_1CD669ED0(unsigned int *result, unsigned int *a2, unint64_t a3, unsigned int *a4, uint64_t a5)
{
  if (a3 >= 2)
  {
    unint64_t v6 = result;
    if (a3 == 2)
    {
      unsigned int v7 = *(a2 - 1);
      unsigned int v8 = *result;
      if (v7 < *result)
      {
        void *result = v7;
        *(a2 - 1) = v8;
      }
    }
    else if ((uint64_t)a3 > 128)
    {
      int v19 = a4;
      unint64_t v20 = a3 >> 1;
      unsigned int v21 = &result[a3 >> 1];
      unint64_t v22 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        sub_1CD66A100(result, v21, v22, a4);
        unsigned int v23 = &v19[v20];
        uint64_t result = sub_1CD66A100(&v6[a3 >> 1], a2, a3 - (a3 >> 1), v23);
        unsigned int v24 = &v19[a3];
        BOOL v25 = v23;
        while (v25 != v24)
        {
          BOOL v26 = v25;
          unsigned int v27 = *v25;
          unsigned int v28 = *v19;
          BOOL v29 = *v25 < *v19;
          if (v27 >= *v19) {
            unsigned int v30 = *v19;
          }
          else {
            unsigned int v30 = v27;
          }
          v19 += v27 >= *v19;
          BOOL v25 = &v26[v29];
          *v6++ = v30;
          if (v19 == v23)
          {
            if (v25 != v24)
            {
              uint64_t v31 = 0;
              if (v27 < v28) {
                char v32 = 1;
              }
              else {
                char v32 = 2;
              }
              uint64_t v33 = &v26[v32 & 1];
              do
              {
                v6[v31] = v33[v31];
                ++v31;
              }
              while (&v33[v31] != v24);
            }
            return result;
          }
        }
        if (v19 != v23)
        {
          uint64_t v34 = 0;
          do
          {
            v6[v34] = v19[v34];
            ++v34;
          }
          while (&v19[v34] != v23);
        }
      }
      else
      {
        sub_1CD669ED0(result, v21, v22, a4, a5);
        sub_1CD669ED0(&v6[a3 >> 1], a2, a3 - (a3 >> 1), v19, a5);
        return sub_1CC93B370(v6, &v6[a3 >> 1], a2, a3 >> 1, a3 - (a3 >> 1), v19, a5);
      }
    }
    else if (result != a2)
    {
      uint64_t v10 = result + 1;
      if (result + 1 != a2)
      {
        uint64_t v11 = 4;
        uint64_t v12 = result;
        do
        {
          unsigned int v14 = *v12;
          unsigned int v13 = v12[1];
          uint64_t v12 = v10;
          if (v13 < v14)
          {
            uint64_t v15 = v11;
            while (1)
            {
              *(unsigned int *)((char *)result + v15) = v14;
              uint64_t v16 = v15 - 4;
              if (v15 == 4) {
                break;
              }
              unsigned int v14 = *(unsigned int *)((char *)result + v15 - 8);
              v15 -= 4;
              if (v13 >= v14)
              {
                unsigned int v17 = (unsigned int *)((char *)result + v16);
                goto LABEL_16;
              }
            }
            unsigned int v17 = result;
LABEL_16:
            *unsigned int v17 = v13;
          }
          uint64_t v10 = v12 + 1;
          v11 += 4;
        }
        while (v12 + 1 != a2);
      }
    }
  }
  return result;
}

unsigned int *sub_1CD66A100(unsigned int *result, unsigned int *a2, unint64_t a3, unsigned int *a4)
{
  if (a3)
  {
    uint64_t v4 = a4;
    unint64_t v6 = result;
    if (a3 == 1)
    {
LABEL_9:
      *uint64_t v4 = *v6;
      return result;
    }
    if (a3 == 2)
    {
      unsigned int v9 = *(a2 - 1);
      unsigned int v8 = v9;
      BOOL v10 = v9 >= *result;
      if (v9 >= *result) {
        unsigned int v8 = *result;
      }
      *a4 = v8;
      uint64_t v4 = a4 + 1;
      if (v10) {
        unint64_t v6 = a2 - 1;
      }
      goto LABEL_9;
    }
    if ((uint64_t)a3 > 8)
    {
      unint64_t v20 = &result[a3 >> 1];
      sub_1CD669ED0(result, v20, a3 >> 1, a4, a3 >> 1);
      uint64_t result = (unsigned int *)sub_1CD669ED0(&v6[a3 >> 1], a2, a3 - (a3 >> 1), &v4[a3 >> 1], a3 - (a3 >> 1));
      unsigned int v21 = &v6[a3 >> 1];
      while (v21 != a2)
      {
        unint64_t v22 = v21;
        unsigned int v23 = *v21;
        unsigned int v24 = *v6;
        BOOL v25 = *v21 >= *v6;
        BOOL v26 = *v21 < *v6;
        if (v23 >= *v6) {
          unsigned int v27 = *v6;
        }
        else {
          unsigned int v27 = v23;
        }
        unsigned int v21 = &v22[v26];
        v6 += v25;
        *v4++ = v27;
        if (v6 == v20)
        {
          if (v21 != a2)
          {
            uint64_t v28 = 0;
            BOOL v29 = &v22[v23 < v24];
            do
            {
              v4[v28] = v29[v28];
              ++v28;
            }
            while (&v29[v28] != a2);
          }
          return result;
        }
      }
      if (v6 != v20)
      {
        uint64_t v30 = 0;
        do
        {
          v4[v30] = v6[v30];
          ++v30;
        }
        while (&v6[v30] != v20);
      }
    }
    else if (result != a2)
    {
      uint64_t v11 = result + 1;
      *a4 = *result;
      if (result + 1 != a2)
      {
        uint64_t v12 = 0;
        unsigned int v13 = a4;
        unsigned int v14 = a4;
        do
        {
          unsigned int v16 = *v14++;
          unsigned int v15 = v16;
          if (*v11 >= v16)
          {
            *unsigned int v14 = *v11;
          }
          else
          {
            v13[1] = v15;
            unsigned int v17 = a4;
            if (v13 != a4)
            {
              uint64_t v18 = v12;
              while (1)
              {
                unsigned int v17 = (unsigned int *)((char *)a4 + v18);
                unsigned int v19 = *(unsigned int *)((char *)a4 + v18 - 4);
                if (*v11 >= v19) {
                  break;
                }
                *unsigned int v17 = v19;
                v18 -= 4;
                if (!v18)
                {
                  unsigned int v17 = a4;
                  break;
                }
              }
            }
            *unsigned int v17 = *v11;
          }
          ++v11;
          v12 += 4;
          unsigned int v13 = v14;
        }
        while (v11 != a2);
      }
    }
  }
  return result;
}

uint64_t *sub_1CD66A2E0(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    *(void *)(v4 - 24) = 0;
    *(void *)(v4 - 16) = 0;
    v4 -= 24;
    *(_DWORD *)(v4 + 16) = 0;
    uint64_t v5 = *(void *)(v2 - 24);
    v2 -= 24;
    *(void *)uint64_t v4 = v5;
    *(void *)uint64_t v2 = 0;
    *(_DWORD *)(v4 + 8) = *(_DWORD *)(v2 + 8);
    *(_DWORD *)(v2 + 8) = 0;
    int v6 = *(_DWORD *)(v4 + 12);
    *(_DWORD *)(v4 + 12) = *(_DWORD *)(v2 + 12);
    *(_DWORD *)(v2 + 12) = v6;
    int v7 = *(_DWORD *)(v4 + 16);
    *(_DWORD *)(v4 + 16) = *(_DWORD *)(v2 + 16);
    *(_DWORD *)(v2 + 16) = v7;
  }
  a2[1] = v4;
  uint64_t v8 = *result;
  void *result = v4;
  a2[1] = v8;
  uint64_t v9 = result[1];
  result[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = result[2];
  result[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1CD66A370(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CC93D528((uint64_t *)a2, a3, &v10);
  int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CC93D5C4(a2, (uint64_t)a3, a3, v10);
    int v7 = (void *)result;
    *(void *)uint64_t result = *a3;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a2 + 8 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v9;
  *(unsigned char *)(a1 + 16) = v8;
  return result;
}

uint64_t sub_1CD66A400(uint64_t result, void *a2, void *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v9 = 0;
      uint64_t result = sub_1CC93D528((uint64_t *)v5, a2, &v9);
      *uint64_t v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

double sub_1CD66A4A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0xFFFFFFFF00000000;
  *(_WORD *)(a1 + 104) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = a1 + 176;
  *(void *)(a1 + 168) = 0x400000000;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 192) = 0;
  *(_WORD *)(a1 + 216) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(void *)(a1 + 256) = a3;
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a2 + 16) + 16) + 40);
  *(void *)(a1 + 232) = *(void *)(*(void *)(*(void *)(a2 + 8) + 16) + 40);
  *(void *)(a1 + 240) = v4;
  return result;
}

uint64_t sub_1CD66A528(uint64_t a1)
{
  uint64_t v2 = a1 + 296;
  sub_1CD48B324(a1 + 296);
  sub_1CBFFBA64(v2);
  sub_1CD66A5A0(a1 + 200);
  sub_1CBFFBA64(a1 + 200);
  sub_1CD668E1C(a1 + 104);
  sub_1CBFFBA64(a1 + 104);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 48), 8);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 4);
  return a1;
}

uint64_t sub_1CD66A5A0(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 16);
    uint64_t v4 = &v3[v2];
    do
    {
      uint64_t v5 = *(void *)(a1 + 16);
      uint64_t v6 = *v3;
      if (*v3 == *(void *)(v5 + 8 * *(unsigned int *)(a1 + 24) - 8))
      {
        unint64_t v8 = *(void *)a1;
      }
      else
      {
        uint64_t v7 = (((unint64_t)v3 - v5) >> 10) & 0x1FFFFFF;
        if (v7 >= 0x1E) {
          LOBYTE(v7) = 30;
        }
        unint64_t v8 = v6 + (4096 << v7);
      }
      uint64_t v9 = (void *)((v6 + 7) & 0xFFFFFFFFFFFFFFF8);
      uint64_t v10 = v9 + 33;
      while ((unint64_t)v10 <= v8)
      {
        uint64_t v11 = sub_1CD66A6B4(v9);
        uint64_t v10 = v11 + 66;
        uint64_t v9 = v11 + 33;
      }
      ++v3;
    }
    while (v3 != v4);
  }
  uint64_t v12 = *(unsigned int *)(a1 + 72);
  if (v12)
  {
    unsigned int v13 = *(void **)(a1 + 64);
    unsigned int v14 = &v13[2 * v12];
    do
    {
      unsigned int v15 = (void *)((*v13 + 7) & 0xFFFFFFFFFFFFFFF8);
      unint64_t v16 = *v13 + v13[1];
      unsigned int v17 = v15 + 33;
      while ((unint64_t)v17 <= v16)
      {
        uint64_t v18 = sub_1CD66A6B4(v15);
        unsigned int v17 = v18 + 66;
        unsigned int v15 = v18 + 33;
      }
      v13 += 2;
    }
    while (v13 != v14);
  }

  return sub_1CBFFBB10(a1);
}

void *sub_1CD66A6B4(void *a1)
{
  uint64_t v2 = (void *)a1[20];
  if (v2 != a1 + 22) {
    free(v2);
  }
  MEMORY[0x1D25D9CD0](a1[17], 8);
  MEMORY[0x1D25D9CD0](a1[14], 8);
  MEMORY[0x1D25D9CD0](a1[10], 8);
  MEMORY[0x1D25D9CD0](a1[7], 4);
  MEMORY[0x1D25D9CD0](a1[4], 4);
  return a1;
}

uint64_t sub_1CD66A728(uint64_t a1, uint64_t a2, const void **a3)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD66A7B4(*(void *)a2, *(_DWORD *)(a2 + 16), a3, &v10);
  uint64_t v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD66A8C8(a2, a3, v10);
    uint64_t v7 = (const void **)result;
    *(_OWORD *)uint64_t result = *(_OWORD *)a3;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v9;
  *(unsigned char *)(a1 + 16) = v8;
  return result;
}

uint64_t sub_1CD66A7B4(uint64_t a1, int a2, const void **a3, const void ***a4)
{
  if (a2)
  {
    uint64_t v7 = 0;
    int v8 = a2 - 1;
    unsigned int v9 = (a2 - 1) & sub_1CC13A6B8(*a3, (uint64_t)*a3 + 4 * (void)a3[1]);
    for (int i = 1; ; ++i)
    {
      uint64_t v11 = (const void **)(a1 + 16 * v9);
      uint64_t v12 = *v11;
      if (*v11 == (const void *)-2)
      {
        if (*a3 == (const void *)-2) {
          goto LABEL_15;
        }
      }
      else if (v12 == (const void *)-1)
      {
        if (*a3 == (const void *)-1) {
          goto LABEL_15;
        }
      }
      else
      {
        unsigned int v13 = a3[1];
        if (v13 == v11[1] && !memcmp(*a3, *v11, 4 * (void)v13))
        {
LABEL_15:
          uint64_t result = 1;
          goto LABEL_16;
        }
      }
      if (v12 == (const void *)-1) {
        break;
      }
      if (v7) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v12 == (const void *)-2;
      }
      if (v15) {
        uint64_t v7 = (const void **)(a1 + 16 * v9);
      }
      unsigned int v16 = v9 + i;
      unsigned int v9 = v16 & v8;
    }
    uint64_t result = 0;
    if (v7) {
      uint64_t v11 = v7;
    }
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t result = 0;
  }
LABEL_16:
  *a4 = v11;
  return result;
}

const void **sub_1CD66A8C8(uint64_t a1, const void **a2, const void **a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD66A97C(a1, v6);
  int v8 = 0;
  sub_1CD66A7B4(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != (const void *)-1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_OWORD *sub_1CD66A97C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(const void ***)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD66AA4C(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *result++ = xmmword_1CFAC4A20;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD66AA4C(uint64_t result, const void **a2, const void **a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(_OWORD **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *v7++ = xmmword_1CFAC4A20;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((unint64_t)*a2 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      unsigned int v9 = 0;
      uint64_t result = sub_1CD66A7B4(*(void *)v5, *(_DWORD *)(v5 + 16), a2, &v9);
      *(_OWORD *)unsigned int v9 = *(_OWORD *)a2;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 2;
  }
  return result;
}

uint64_t sub_1CD66AB00(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 - 32);
  if (v2
    && !*(unsigned char *)(v2 + 16)
    && *(void *)(v2 + 24) == *(void *)(a2 + 72)
    && (*(_DWORD *)(v2 + 36) - 56) < 3)
  {
    return 1;
  }
  else
  {
    return sub_1CC93DB7C(a1, a2);
  }
}

uint64_t sub_1CD66AB3C(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  sub_1CD46A1B4(a1 + 24, (uint64_t)a2 + 24);
  sub_1CD46A1B4(a1 + 48, (uint64_t)(a2 + 3));
  sub_1CD66ABA0(a1 + 72, (uint64_t)a2 + 72);
  sub_1CD66ABA0(a1 + 96, (uint64_t)(a2 + 6));
  return a1;
}

uint64_t sub_1CD66ABA0(uint64_t a1, uint64_t a2)
{
  MEMORY[0x1D25D9CD0](*(void *)a1, 4);
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)a1 = *(void *)a2;
  *(void *)a2 = 0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = 0;
  int v4 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = v4;
  int v5 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v5;
  return a1;
}

void sub_1CD66AC14(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    int v4 = v1;
    if (v3 != v1)
    {
      do
        uint64_t v3 = sub_1CD48A868(v3 - 15);
      while (v3 != v1);
      int v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void *sub_1CD66AC74(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if (a2 >= 0xF0F0F0F0F0F0F1) {
      abort();
    }
    uint64_t v3 = 17 * a2;
    uint64_t v4 = 272 * a2;
    int v5 = operator new(272 * a2);
    *a1 = v5;
    uint64_t v6 = &v5[v3];
    a1[2] = v6;
    do
    {
      v5[15] = 0u;
      v5[16] = 0u;
      v5[13] = 0u;
      v5[14] = 0u;
      v5[11] = 0u;
      v5[12] = 0u;
      v5[9] = 0u;
      v5[10] = 0u;
      v5[7] = 0u;
      v5[8] = 0u;
      v5[5] = 0u;
      v5[6] = 0u;
      v5[3] = 0u;
      _OWORD v5[4] = 0u;
      v5[1] = 0u;
      uint64_t v5[2] = 0u;
      *int v5 = 0u;
      sub_1CD66AD1C((uint64_t)v5);
      int v5 = (_OWORD *)(v7 + 272);
      v4 -= 272;
    }
    while (v4);
    a1[1] = v6;
  }
  return a1;
}

double sub_1CD66AD1C(uint64_t a1)
{
  *(unsigned char *)(a1 + 144) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(unsigned char *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(void *)(a1 + 164) = 0;
  *(void *)(a1 + 148) = 0;
  *(void *)(a1 + 156) = 0;
  double result = NAN;
  *(void *)(a1 + 176) = 0xFFFFFFFD00000000;
  *(void *)(a1 + 232) = 0;
  *(_DWORD *)(a1 + 240) = 0;
  *(void *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 256) = 0;
  *(unsigned char *)(a1 + 264) = 0;
  *(unsigned char *)(a1 + 268) = 0;
  *(_DWORD *)(a1 + 200) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 224) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  return result;
}

uint64_t sub_1CD66AD8C(uint64_t a1)
{
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 208), 8);
  sub_1CD66AE14((uint64_t *)(a1 + 184));
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 152), 4);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 120), 8);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 96), 8);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 72), 8);
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t *sub_1CD66AE14(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v4 = 40 * v2;
    int v5 = (void *)(v3 + 32);
    do
    {
      if (*((_DWORD *)v5 - 8) <= 0xFFFFFFFD)
      {
        uint64_t v6 = (void *)*(v5 - 2);
        if (v5 != v6) {
          free(v6);
        }
      }
      v5 += 5;
      v4 -= 40;
    }
    while (v4);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

uint64_t sub_1CD66AE8C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);
    return v2();
  }
  else
  {
    sub_1CB920400();
    return sub_1CD66AEDC();
  }
}

uint64_t sub_1CD66AEDC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (!v1)
  {
    sub_1CB920400();
    llvm::InferFunctionAttrsPass::run();
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);

  return v2();
}

void llvm::InferFunctionAttrsPass::run()
{
}

void llvm::createInferFunctionAttrsLegacyPass(llvm *this)
{
}

void llvm::createFunctionInliningPass(llvm *this, int a2, int a3)
{
  llvm::getInlineParams(this, a2, (uint64_t)&v4);
  if (a3)
  {
    int v5 = 0;
    if (!v6) {
      char v6 = 1;
    }
  }
  operator new();
}

double llvm::LegacyInlinerBase::LegacyInlinerBase(llvm::LegacyInlinerBase *this, char *a2)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = a2;
  *((_DWORD *)this + 6) = 3;
  *(void *)this = &unk_1F2628B90;
  *((unsigned char *)this + 28) = 1;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0x1000000000;
  double result = 0.0;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  return result;
}

double llvm::LegacyInlinerBase::LegacyInlinerBase(llvm::LegacyInlinerBase *this, char *a2, char a3)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = a2;
  *((_DWORD *)this + 6) = 3;
  *(void *)this = &unk_1F2628B90;
  *((unsigned char *)this + 28) = a3;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0x1000000000;
  double result = 0.0;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  return result;
}

void llvm::LegacyInlinerBase::getAnalysisUsage(llvm::LegacyInlinerBase *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::addRequiredID(a2, llvm::AssumptionCacheTracker::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::ProfileSummaryInfoWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::TargetLibraryInfoWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::TargetTransformInfoWrapperPass::ID);
  llvm::getAAResultsAnalysisUsage(a2, v4);

  llvm::CallGraphSCCPass::getAnalysisUsage(this, a2);
}

uint64_t llvm::LegacyInlinerBase::runOnSCC(uint64_t a1, uint64_t a2)
{
  if (llvm::CallGraphSCCPass::skipSCC(a1, a2)) {
    return 0;
  }

  return llvm::LegacyInlinerBase::inlineCalls(a1, a2);
}

void llvm::ModuleInlinerWrapperPass::ModuleInlinerWrapperPass(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  long long v5 = *(_OWORD *)(a2 + 16);
  long long v6 = *(_OWORD *)(a2 + 48);
  int v7 = *(_DWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v6;
  *(_OWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 64) = v7;
  *(_DWORD *)(a1 + 68) = a4;
  *(_DWORD *)(a1 + 72) = a5;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(void *)(a1 + 144) = 0;
  if (a3) {
    sub_1CD66B36C();
  }
  sub_1CD66B36C();
}

void sub_1CD66B36C()
{
}

void llvm::ModuleInlinerWrapperPass::run()
{
}

void sub_1CD66B728()
{
}

void sub_1CD66B7E4()
{
}

void sub_1CD66B878()
{
}

llvm::raw_ostream *llvm::InlinerPass::printPipeline(uint64_t a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, char *, uint64_t), uint64_t a4)
{
  double result = sub_1CD66B980(a2, a3, a4);
  if (*(unsigned char *)(a1 + 8))
  {
    return sub_1CB8E509C(a2, "<only-mandatory>");
  }
  return result;
}

llvm::raw_ostream *sub_1CD66B980(llvm::raw_ostream *a1, uint64_t (*a2)(uint64_t, char *, uint64_t), uint64_t a3)
{
  long long v6 = sub_1CC94713C();
  unsigned int v9 = (const void *)a2(a3, v6, v7);
  size_t v10 = v8;
  double result = (llvm::raw_ostream *)*((void *)a1 + 4);
  if (v8 <= *((void *)a1 + 3) - (void)result)
  {
    if (v8)
    {
      double result = (llvm::raw_ostream *)memcpy(result, v9, v8);
      *((void *)a1 + 4) += v10;
    }
  }
  else
  {
    return llvm::raw_ostream::write(a1, (const char *)v9, v8);
  }
  return result;
}

void llvm::ModuleInlinerWrapperPass::printPipeline(uint64_t a1, llvm::raw_ostream *a2)
{
  if (*(void *)(a1 + 104) != *(void *)(a1 + 112)) {
    llvm::PassManager<llvm::Module,llvm::AnalysisManager<llvm::Module>>::printPipeline();
  }
  sub_1CB8E509C(a2, "cgscc(");
  if (*(_DWORD *)(a1 + 72))
  {
    long long v4 = sub_1CB8E509C(a2, "devirt<");
    long long v5 = llvm::raw_ostream::operator<<(v4, *(unsigned int *)(a1 + 72));
    sub_1CB8E509C(v5, ">(");
  }
  llvm::PassManager<llvm::LazyCallGraph::SCC,llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>,llvm::LazyCallGraph&,llvm::CGSCCUpdateResult &>::printPipeline();
}

void *sub_1CD66BB18(void *a1)
{
  *a1 = &unk_1F2628C48;
  uint64_t v2 = a1 + 71;
  uint64_t v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1F2628CB0;
  long long v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }

  return sub_1CB87DD48(a1);
}

void *sub_1CD66BC00(void *a1)
{
  *a1 = &unk_1F2628CB0;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD66BC54(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  int v12 = 0;
  uint64_t v8 = sub_1CD42FA04(a1 + 152, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD66BCE8(v11);
}

uint64_t sub_1CD66BCE8(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 160) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD66BD00(void *a1)
{
  sub_1CD66BB18(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD66BD38(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t sub_1CD66BD44(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

llvm::raw_ostream *sub_1CD66BD54(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    int v3 = *((_DWORD *)result + 32);
LABEL_3:
    long long v4 = &unk_1F2628D00;
    char v6 = 1;
    int v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 148))
  {
    int v3 = *((_DWORD *)result + 32);
    if (*((_DWORD *)result + 36) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD66BDD8(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void *sub_1CD66BDEC(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 152), a2);
}

void sub_1CD66BDF4(void *a1)
{
  *a1 = &unk_1F2628CB0;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD66BE68(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD66BE70(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1CD66BE84(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1CD66BE98(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1CD66BEAC(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

void *sub_1CD66BED8(void *a1)
{
  *a1 = &unk_1F2628D40;
  uint64_t v2 = a1 + 71;
  int v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1F2628DA8;
  long long v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }

  return sub_1CB87DD48(a1);
}

void *sub_1CD66BFC0(void *a1)
{
  *a1 = &unk_1F2628DA8;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD66C014(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  int v12 = 0;
  uint64_t v8 = sub_1CD42FA04(a1 + 152, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD66C0A8(v11);
}

uint64_t sub_1CD66C0A8(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 160) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD66C0C0(void *a1)
{
  sub_1CD66BED8(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD66C0F8(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t sub_1CD66C104(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

llvm::raw_ostream *sub_1CD66C114(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    int v3 = *((_DWORD *)result + 32);
LABEL_3:
    long long v4 = &unk_1F2628DF8;
    char v6 = 1;
    int v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 148))
  {
    int v3 = *((_DWORD *)result + 32);
    if (*((_DWORD *)result + 36) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD66C198(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void *sub_1CD66C1AC(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 152), a2);
}

void sub_1CD66C1B4(void *a1)
{
  *a1 = &unk_1F2628DA8;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD66C228(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD66C230(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1CD66C244(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1CD66C258(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1CD66C26C(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

void *sub_1CD66C298(void *a1)
{
  *a1 = &unk_1F2628E38;
  uint64_t v2 = a1 + 71;
  int v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1F2628EA0;
  long long v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }

  return sub_1CB87DD48(a1);
}

void *sub_1CD66C380(void *a1)
{
  *a1 = &unk_1F2628EA0;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD66C3D4(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  int v12 = 0;
  uint64_t v8 = sub_1CD42FA04(a1 + 152, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD66C468(v11);
}

uint64_t sub_1CD66C468(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 160) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD66C480(void *a1)
{
  sub_1CD66C298(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD66C4B8(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t sub_1CD66C4C4(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

llvm::raw_ostream *sub_1CD66C4D4(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    int v3 = *((_DWORD *)result + 32);
LABEL_3:
    long long v4 = &unk_1F2628EF0;
    char v6 = 1;
    int v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 148))
  {
    int v3 = *((_DWORD *)result + 32);
    if (*((_DWORD *)result + 36) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD66C558(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void *sub_1CD66C56C(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 152), a2);
}

void sub_1CD66C574(void *a1)
{
  *a1 = &unk_1F2628EA0;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD66C5E8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD66C5F0(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1CD66C604(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1CD66C618(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1CD66C62C(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

uint64_t sub_1CD66C658(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    uint64_t v7 = *(void **)result;
    uint64_t v8 = 32 * v6;
    do
    {
      *uint64_t v7 = -4096;
      v7 += 4;
      v8 -= 32;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      double result = sub_1CC94600C(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      size_t v10 = v11;
      *uint64_t v11 = *(void *)a2;
      v10[1] = 0;
      void v10[2] = 0;
      v10[3] = 0;
      *(_OWORD *)(v10 + 1) = *(_OWORD *)(a2 + 8);
      v10[3] = *(void *)(a2 + 24);
      *(void *)(a2 + 8) = 0;
      *(void *)(a2 + 16) = 0;
      *(void *)(a2 + 24) = 0;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 32;
  }
  return result;
}

void sub_1CD66C71C(char **a1, _WORD *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCE01E8, 0, 0);
  byte_1EBCE0268 = 0;
  qword_1EBCE0270 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCE0278 = 0;
  qword_1EBCE01E8 = (uint64_t)&unk_1F26440A0;
  qword_1EBCE0280 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCE0288 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCE02A0 = (uint64_t)&qword_1EBCE0288;
  llvm::cl::Option::setArgStr(v4, "disable-inlined-alloca-merging", 0x1EuLL);
  uint64_t v5 = *a1;
  byte_1EBCE0268 = **a1;
  byte_1EBCE0279 = 1;
  byte_1EBCE0278 = *v5;
  word_1EBCE01F2 = (32 * (*a2 & 3)) | word_1EBCE01F2 & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE01E8);
}

void sub_1CD66C83C(int **a1, _WORD *a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE02A8, 0, 0);
  dword_1EBCE0328 = 0;
  qword_1EBCE0330 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCE0338 = 0;
  qword_1EBCE02A8 = (uint64_t)&unk_1F2643F68;
  qword_1EBCE0340 = (uint64_t)&unk_1F2643D20;
  qword_1EBCE0348 = (uint64_t)&unk_1F25F7480;
  qword_1EBCE0360 = (uint64_t)&qword_1EBCE0348;
  sub_1CD66C92C(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE02A8);
}

__n128 sub_1CD66C92C(int **a1, _WORD *a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE02A8, "intra-scc-cost-multiplier", 0x19uLL);
  uint64_t v6 = *a1;
  dword_1EBCE0328 = **a1;
  byte_1EBCE033C = 1;
  dword_1EBCE0338 = *v6;
  word_1EBCE02B2 = (32 * (*a2 & 3)) | word_1EBCE02B2 & 0xFF9F;
  __n128 result = *a3;
  xmmword_1EBCE02C8 = (__int128)*a3;
  return result;
}

llvm::cl::Option *sub_1CD66C9B4(llvm::cl::Option *a1, char *a2, const char **a3, _OWORD *a4, __n128 *a5, _WORD *a6)
{
  uint64_t v12 = sub_1CB883A14((uint64_t)a1, 0, 0);
  *(void *)(v12 + 128) = 0;
  *(void *)(v12 + 136) = 0;
  *(void *)(v12 + 168) = 0;
  *(void *)(v12 + 176) = 0;
  *(unsigned char *)(v12 + 184) = 0;
  *(void *)(v12 + 160) = 0;
  *(void *)(v12 + 144) = 0;
  *(void *)(v12 + 152) = &unk_1F2643C20;
  *(void *)uint64_t v12 = &unk_1F2643FD0;
  *(void *)(v12 + 192) = &unk_1F2643EA0;
  *(void *)(v12 + 200) = &unk_1F25F6428;
  *(void *)(v12 + 224) = v12 + 200;
  sub_1CD66CAB8(v12, a2, a3, a4, a5, a6);
  llvm::cl::Option::addArgument(a1);
  return a1;
}

__n128 sub_1CD66CAB8(uint64_t a1, char *__s, const char **a3, _OWORD *a4, __n128 *a5, _WORD *a6)
{
  size_t v12 = strlen(__s);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)__s, v12);
  sub_1CBAD7D28(a3, a1);
  *(_OWORD *)(a1 + 48) = *a4;
  __n128 result = *a5;
  *(__n128 *)(a1 + 32) = *a5;
  *(_WORD *)(a1 + 10) = (32 * (*a6 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  return result;
}

void sub_1CD66CB48(int **a1, uint64_t *a2, __n128 *a3, _WORD *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE05D0, 0, 0);
  dword_1EBCE0650 = 0;
  qword_1EBCE0658 = (uint64_t)&unk_1F2628D00;
  *(void *)&dword_1EBCE0660 = 0;
  qword_1EBCE05D0 = (uint64_t)&unk_1F2628C48;
  qword_1EBCE0668 = (uint64_t)&unk_1F2628CB0;
  unk_1EBCE0670 = &qword_1EBCE05D0;
  qword_1EBCE0678 = (uint64_t)&unk_1EBCE0688;
  qword_1EBCE0680 = 0x800000000;
  qword_1EBCE0808 = (uint64_t)&unk_1F2628F30;
  qword_1EBCE0820 = (uint64_t)&qword_1EBCE0808;
  sub_1CD66CC5C(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE05D0);
}

__n128 sub_1CD66CC5C(int **a1, uint64_t *a2, __n128 *a3, _WORD *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE05D0, "cgscc-inline-replay-scope", 0x19uLL);
  uint64_t v8 = *a1;
  dword_1EBCE0650 = **a1;
  byte_1EBCE0664 = 1;
  dword_1EBCE0660 = *v8;
  sub_1CC94616C(a2, (uint64_t)&qword_1EBCE05D0);
  __n128 result = *a3;
  xmmword_1EBCE05F0 = (__int128)*a3;
  word_1EBCE05DA = (32 * (*a4 & 3)) | word_1EBCE05DA & 0xFF9F;
  return result;
}

void sub_1CD66CD00()
{
}

void *sub_1CD66CD14()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1F2628F30;
  return result;
}

void sub_1CD66CD4C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2628F30;
}

void sub_1CD66CD78(uint64_t a1, unsigned __int8 *a2, size_t a3, int *a4, uint64_t a5, uint64_t a6)
{
  int v9 = *a4;
  v14[0] = a2;
  v14[1] = a3;
  v14[2] = a5;
  v14[3] = a6;
  v14[4] = &unk_1F2628D00;
  char v16 = 1;
  int v15 = v9;
  unint64_t v10 = sub_1CD66CE7C(a1 + 16, (unint64_t)v14, 1);
  uint64_t v11 = *(void *)(a1 + 16) + 48 * *(unsigned int *)(a1 + 24);
  long long v12 = *(_OWORD *)(v10 + 16);
  *(_OWORD *)uint64_t v11 = *(_OWORD *)v10;
  *(_OWORD *)(v11 + 16) = v12;
  *(void *)(v11 + 32) = &unk_1F2628D20;
  char v13 = *(unsigned char *)(v10 + 44);
  *(_DWORD *)(v11 + 40) = *(_DWORD *)(v10 + 40);
  *(unsigned char *)(v11 + 44) = v13;
  *(void *)(v11 + 32) = &unk_1F2628D00;
  ++*(_DWORD *)(a1 + 24);
  llvm::cl::AddLiteralOption(*(void *)(a1 + 8), a2, a3);
}

unint64_t sub_1CD66CE7C(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3 + a3 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    unint64_t v5 = *(void *)a1 + 48 * v3;
    if (*(void *)a1 > a2 || v5 <= a2) {
      sub_1CD66CEF4();
    }
    sub_1CD66CEF4();
  }
  return a2;
}

void sub_1CD66CEF4()
{
}

void sub_1CD66CFD8(int **a1, uint64_t *a2, __n128 *a3, _WORD *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE0828, 0, 0);
  dword_1EBCE08A8 = 0;
  qword_1EBCE08B0 = (uint64_t)&unk_1F2628DF8;
  *(void *)&dword_1EBCE08B8 = 0;
  qword_1EBCE0828 = (uint64_t)&unk_1F2628D40;
  qword_1EBCE08C0 = (uint64_t)&unk_1F2628DA8;
  unk_1EBCE08C8 = &qword_1EBCE0828;
  qword_1EBCE08D0 = (uint64_t)&unk_1EBCE08E0;
  qword_1EBCE08D8 = 0x800000000;
  qword_1EBCE0A60 = (uint64_t)&unk_1F2628F78;
  qword_1EBCE0A78 = (uint64_t)&qword_1EBCE0A60;
  sub_1CD66D0EC(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE0828);
}

__n128 sub_1CD66D0EC(int **a1, uint64_t *a2, __n128 *a3, _WORD *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE0828, "cgscc-inline-replay-fallback", 0x1CuLL);
  uint64_t v8 = *a1;
  dword_1EBCE08A8 = **a1;
  byte_1EBCE08BC = 1;
  dword_1EBCE08B8 = *v8;
  sub_1CC9461C8(a2, (uint64_t)&qword_1EBCE0828);
  __n128 result = *a3;
  xmmword_1EBCE0848 = (__int128)*a3;
  word_1EBCE0832 = (32 * (*a4 & 3)) | word_1EBCE0832 & 0xFF9F;
  return result;
}

void sub_1CD66D190()
{
}

void *sub_1CD66D1A4()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1F2628F78;
  return result;
}

void sub_1CD66D1DC(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2628F78;
}

void sub_1CD66D208()
{
}

void sub_1CD66D2EC(int **a1, uint64_t *a2, __n128 *a3, _WORD *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE0A80, 0, 0);
  dword_1EBCE0B00 = 0;
  qword_1EBCE0B08 = (uint64_t)&unk_1F2628EF0;
  *(void *)&dword_1EBCE0B10 = 0;
  qword_1EBCE0A80 = (uint64_t)&unk_1F2628E38;
  qword_1EBCE0B18 = (uint64_t)&unk_1F2628EA0;
  unk_1EBCE0B20 = &qword_1EBCE0A80;
  qword_1EBCE0B28 = (uint64_t)&unk_1EBCE0B38;
  qword_1EBCE0B30 = 0x800000000;
  qword_1EBCE0CB8 = (uint64_t)&unk_1F2628FC0;
  qword_1EBCE0CD0 = (uint64_t)&qword_1EBCE0CB8;
  sub_1CD66D400(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE0A80);
}

__n128 sub_1CD66D400(int **a1, uint64_t *a2, __n128 *a3, _WORD *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE0A80, "cgscc-inline-replay-format", 0x1AuLL);
  uint64_t v8 = *a1;
  dword_1EBCE0B00 = **a1;
  byte_1EBCE0B14 = 1;
  dword_1EBCE0B10 = *v8;
  sub_1CC9463A0(a2, (uint64_t)&qword_1EBCE0A80);
  __n128 result = *a3;
  xmmword_1EBCE0AA0 = (__int128)*a3;
  word_1EBCE0A8A = (32 * (*a4 & 3)) | word_1EBCE0A8A & 0xFF9F;
  return result;
}

void sub_1CD66D4A4()
{
}

void *sub_1CD66D4B8()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1F2628FC0;
  return result;
}

void sub_1CD66D4F0(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2628FC0;
}

void sub_1CD66D51C()
{
}

uint64_t sub_1CD66D600(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a2 < *a1;
  }
}

void sub_1CD66D620(void *a1)
{
  sub_1CD66D900(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD66D658(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

void *sub_1CD66D660(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v12 = v3;
  uint64_t v4 = *(void *)(v3 - 32);
  if (!v4 || *(unsigned char *)(v4 + 16) || *(void *)(v4 + 24) != *(void *)(v3 + 72)) {
    uint64_t v4 = 0;
  }
  int v5 = *((_DWORD *)a2 + 2);
  unsigned int InstructionCount = llvm::Function::getInstructionCount((llvm::Function *)v4);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (v7 >= *(_DWORD *)(a1 + 20)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v8 = (void *)(*(void *)(a1 + 8) + 16 * v7);
  void *v8 = v3;
  v8[1] = InstructionCount;
  uint64_t v9 = (*(_DWORD *)(a1 + 16) + 1);
  *(_DWORD *)(a1 + 16) = v9;
  uint64_t v10 = *(void *)(a1 + 8);
  char v13 = sub_1CD66D960;
  sub_1CC9469EC(v10, v10 + 16 * v9, (uint64_t (**)(uint64_t, uint64_t))&v13, v9);
  __n128 result = sub_1CD3CDD24((uint64_t *)(a1 + 280), &v12);
  *((_DWORD *)result + 2) = v5;
  return result;
}

uint64_t sub_1CD66D73C(uint64_t a1)
{
  sub_1CD66D974(a1);
  uint64_t v6 = **(void **)(a1 + 8);
  sub_1CD3CDD24((uint64_t *)(a1 + 280), &v6);
  uint64_t v2 = v6;
  unsigned int v7 = 0;
  if (sub_1CD3C8538((uint64_t *)(a1 + 280), &v6, &v7))
  {
    *(void *)unsigned int v7 = -8192;
    *(int32x2_t *)(a1 + 288) = vadd_s32(*(int32x2_t *)(a1 + 288), (int32x2_t)0x1FFFFFFFFLL);
  }
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  unsigned int v7 = sub_1CD66D960;
  sub_1CC946AA8(v3, v3 + 16 * v4, (uint64_t (**)(uint64_t, uint64_t))&v7, v4);
  --*(_DWORD *)(a1 + 16);
  return v2;
}

uint64_t sub_1CD66D804(uint64_t a1)
{
  sub_1CD66D974(a1);
  uint64_t v3 = **(void **)(a1 + 8);
  uint64_t v4 = 0;
  if (sub_1CD3C8538((uint64_t *)(a1 + 280), &v3, &v4)) {
    return v4;
  }
  else {
    return *(void *)(a1 + 280) + 16 * *(unsigned int *)(a1 + 296);
  }
}

uint64_t sub_1CD66D864(uint64_t a1, unsigned int (*a2)(uint64_t, uint64_t, void), uint64_t a3)
{
  uint64_t result = (uint64_t)sub_1CD66DA88(a1 + 8, a2, a3);
  uint64_t v5 = *(void *)(a1 + 8);
  *(_DWORD *)(a1 + 16) = (unint64_t)(result - v5) >> 4;
  uint64_t v10 = sub_1CD66D960;
  if (((result - v5) & 0xFFFFFFFF0uLL) >= 0x11)
  {
    uint64_t v6 = ((unint64_t)(result - v5) >> 4);
    unint64_t v7 = ~((unint64_t)(v6 - 2) >> 1);
    uint64_t v8 = (long long *)(v5 + 16 * ((unint64_t)(v6 - 2) >> 1));
    do
      uint64_t result = sub_1CC946C00(v5, (unsigned int (**)(uint64_t, uint64_t))&v10, v6, v8--);
    while (!__CFADD__(v7++, 1));
  }
  return result;
}

void *sub_1CD66D900(void *a1)
{
  *a1 = &unk_1F2629098;
  MEMORY[0x1D25D9CD0](a1[35], 8);
  uint64_t v2 = (void *)a1[1];
  if (v2 != a1 + 3) {
    free(v2);
  }
  return a1;
}

BOOL sub_1CD66D960(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 8) < *(_DWORD *)(a1 + 8);
}

uint64_t sub_1CD66D974(uint64_t a1)
{
  uint64_t v2 = (uint64_t **)(a1 + 8);
  while (1)
  {
    uint64_t v3 = **v2;
    int v4 = *((_DWORD *)*v2 + 2);
    uint64_t v5 = *(void *)(v3 - 32);
    if (!v5 || *(unsigned char *)(v5 + 16) || *(void *)(v5 + 24) != *(void *)(v3 + 72)) {
      uint64_t v5 = 0;
    }
    uint64_t result = llvm::Function::getInstructionCount((llvm::Function *)v5);
    if (v4 >= (int)result) {
      break;
    }
    unsigned int v7 = result;
    uint64_t v8 = *(void *)(a1 + 8);
    uint64_t v9 = *(unsigned int *)(a1 + 16);
    int v15 = sub_1CD66D960;
    sub_1CC946AA8(v8, v8 + 16 * v9, (uint64_t (**)(uint64_t, uint64_t))&v15, v9);
    unsigned int v10 = *(_DWORD *)(a1 + 20);
    unsigned int v11 = *(_DWORD *)(a1 + 16) - 1;
    *(_DWORD *)(a1 + 16) = v11;
    if (v11 >= v10) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v12 = (void *)(*(void *)(a1 + 8) + 16 * v11);
    *uint64_t v12 = v3;
    v12[1] = v7;
    uint64_t v13 = (*(_DWORD *)(a1 + 16) + 1);
    *(_DWORD *)(a1 + 16) = v13;
    uint64_t v14 = *(void *)(a1 + 8);
    int v15 = sub_1CD66D960;
    sub_1CC9469EC(v14, v14 + 16 * v13, (uint64_t (**)(uint64_t, uint64_t))&v15, v13);
  }
  return result;
}

void *sub_1CD66DA88(uint64_t a1, unsigned int (*a2)(uint64_t, uint64_t, void), uint64_t a3)
{
  uint64_t v3 = *(void **)a1;
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  if (v4)
  {
    unsigned int v7 = &v3[2 * v4];
    uint64_t v8 = 16 * v4 - 16;
    uint64_t v9 = *(void **)a1;
    while (1)
    {
      uint64_t v10 = *v9;
      v9 += 2;
      if (a2(a3, v10, 0)) {
        break;
      }
      v8 -= 16;
      uint64_t v3 = v9;
      if (v8 == -16) {
        return v7;
      }
    }
    if (v8)
    {
      uint64_t v12 = v3 + 2;
      do
      {
        if ((((uint64_t (*)(uint64_t, void, void))a2)(a3, *v12, 0) & 1) == 0)
        {
          *uint64_t v3 = *v12;
          *((_DWORD *)v3 + 2) = *((_DWORD *)v12 + 2);
          v3 += 2;
        }
        v12 += 2;
        v8 -= 16;
      }
      while (v8);
    }
  }
  return v3;
}

void *sub_1CD66DB44(void *a1)
{
  *a1 = &unk_1F26290E0;
  uint64_t v2 = (void *)a1[1];
  if (v2 != a1 + 3) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD66DB98(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v4 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v5 = 4;
  }
  else
  {
    int v5 = *(_DWORD *)(a1 + 16);
    if (!v5)
    {
      uint64_t v12 = 0;
      uint64_t result = 0;
      goto LABEL_11;
    }
    uint64_t v4 = *(void *)(a1 + 8);
  }
  unint64_t v6 = ((a3 >> 4) ^ (a3 >> 9) | ((unint64_t)((a2 >> 4) ^ (a2 >> 9)) << 32))
     + ~((unint64_t)((a3 >> 4) ^ (a3 >> 9)) << 32);
  unint64_t v7 = (v6 ^ (v6 >> 22)) + ~((v6 ^ (v6 >> 22)) << 13);
  unint64_t v8 = (9 * (v7 ^ (v7 >> 8))) ^ ((9 * (v7 ^ (v7 >> 8))) >> 15);
  int v9 = ((v8 + ~(v8 << 27)) >> 31) ^ (v8 + ~(v8 << 27));
  int v10 = v5 - 1;
  unsigned int v11 = (v5 - 1) & v9;
  uint64_t v12 = (void *)(v4 + 16 * v11);
  uint64_t v13 = *v12;
  uint64_t v14 = v12[1];
  if (*v12 == a2 && v14 == a3)
  {
    uint64_t result = 1;
  }
  else
  {
    char v16 = 0;
    int v17 = 1;
    uint64_t result = 1;
    while (v13 != -4096 || v14 != -4096)
    {
      if (v16) {
        BOOL v19 = 0;
      }
      else {
        BOOL v19 = v14 == -8192;
      }
      if (v19 && v13 == -8192) {
        char v16 = v12;
      }
      unsigned int v21 = v11 + v17++;
      unsigned int v11 = v21 & v10;
      uint64_t v12 = (void *)(v4 + 16 * (v21 & v10));
      uint64_t v13 = *v12;
      uint64_t v14 = v12[1];
      if (*v12 == a2 && v14 == a3) {
        goto LABEL_11;
      }
    }
    uint64_t result = 0;
    if (v16) {
      uint64_t v12 = v16;
    }
  }
LABEL_11:
  *a4 = v12;
  return result;
}

void *sub_1CD66DC98(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v14 = 0;
  uint64_t result = (void *)sub_1CD66DB98(a2, *a3, a3[1], &v14);
  unint64_t v7 = v14;
  if (result)
  {
    uint64_t v8 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v9 = 4;
    }
    else
    {
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a2 + 16);
    }
    char v10 = 0;
    uint64_t v11 = v8 + 16 * v9;
  }
  else
  {
    uint64_t result = sub_1CD66DD60((_DWORD *)a2, a3, v14);
    unint64_t v7 = result;
    void *result = *a3;
    result[1] = a3[1];
    uint64_t v12 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v13 = 4;
    }
    else
    {
      uint64_t v12 = *(void *)(a2 + 8);
      uint64_t v13 = *(unsigned int *)(a2 + 16);
    }
    uint64_t v11 = v12 + 16 * v13;
    char v10 = 1;
  }
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

void *sub_1CD66DD60(_DWORD *a1, uint64_t *a2, void *a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 4;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
    goto LABEL_11;
  }
  if (v6 + ~v5 - a1[1] <= v6 >> 3)
  {
LABEL_11:
    sub_1CD66DE2C((uint64_t)a1, v6);
    uint64_t v8 = 0;
    sub_1CD66DB98((uint64_t)a1, *a2, a2[1], &v8);
    a3 = v8;
  }
  *a1 += 2;
  if (*a3 != -4096 || a3[1] != -4096) {
    --a1[1];
  }
  return a3;
}

void sub_1CD66DE2C(uint64_t a1, unsigned int a2)
{
  v14[8] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    unsigned int v6 = *(uint64_t **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD66DFCC(a1, v6, &v6[2 * v7]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = 0;
  uint64_t v9 = v14;
  do
  {
    uint64_t v11 = *(void *)(a1 + v8 + 8);
    uint64_t v10 = *(void *)(a1 + v8 + 16);
    if ((v11 != -4096 || v10 != -4096) && (v11 != -8192 || v10 != -8192))
    {
      *(_OWORD *)uint64_t v9 = *(_OWORD *)(a1 + v8 + 8);
      v9 += 2;
    }
    v8 += 16;
  }
  while (v8 != 64);
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v12 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v12;
  }
  sub_1CD66DFCC(a1, v14, v9);
}

void sub_1CD66DFCC(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v6 = *(_DWORD *)a1;
  *(void *)a1 = *(_DWORD *)a1 & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(a1 + 8);
    size_t v9 = 64;
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (!v7) {
      goto LABEL_6;
    }
    uint64_t v8 = *(void **)(a1 + 8);
    size_t v9 = 16 * v7;
  }
  memset_pattern16(v8, &unk_1CFAC3070, v9);
LABEL_6:
  while (a2 != a3)
  {
    uint64_t v10 = *a2;
    uint64_t v11 = a2[1];
    if ((*a2 != -4096 || v11 != -4096) && (v10 != -8192 || v11 != -8192))
    {
      uint64_t v13 = 0;
      sub_1CD66DB98(a1, v10, v11, &v13);
      uint64_t v12 = v13;
      *uint64_t v13 = *a2;
      v12[1] = a2[1];
      *(_DWORD *)a1 += 2;
    }
    a2 += 2;
  }
}

void *sub_1CD66E0A4(void *a1)
{
  uint64_t v2 = a1[1];
  *a1 = &unk_1F2629128;
  a1[1] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_1CD66E110(void *a1)
{
  uint64_t v1 = a1[1];
  *a1 = &unk_1F2629128;
  a1[1] = 0;
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x1D25D9CE0);
}

llvm::raw_ostream *sub_1CD66E1A4(uint64_t a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, char *, uint64_t), uint64_t a4)
{
  uint64_t result = sub_1CD66B980(a2, a3, a4);
  if (*(unsigned char *)(a1 + 16))
  {
    return sub_1CB8E509C(a2, "<only-mandatory>");
  }
  return result;
}

uint64_t sub_1CD66E208(uint64_t a1)
{
  *(void *)a1 = &unk_1F2629168;
  unint64_t v3 = (void **)(a1 + 8);
  sub_1CC947208(&v3);
  return a1;
}

uint64_t sub_1CD66E260(uint64_t a1)
{
  *(void *)a1 = &unk_1F2629168;
  unint64_t v3 = (void **)(a1 + 8);
  sub_1CC947208(&v3);
  return MEMORY[0x1D25D9CE0](a1, 0xA1C4030951706);
}

void sub_1CD66E2CC()
{
}

char *sub_1CD66E2D8()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::PassManager<LazyCallGraph::SCC, CGSCCAnalysis"
                    "Manager, LazyCallGraph &, CGSCCUpdateResult &>]";
  v10[1] = 147;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x93) {
    uint64_t v1 = 147;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_10[v1];
  unint64_t v3 = 147 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

void *sub_1CD66E394(void *a1)
{
  uint64_t v2 = a1[1];
  *a1 = &unk_1F26291A8;
  a1[1] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_1CD66E400(void *a1)
{
  uint64_t v2 = a1[1];
  *a1 = &unk_1F26291A8;
  a1[1] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD66E48C()
{
}

llvm::raw_ostream *sub_1CD66E494(uint64_t a1, llvm::raw_ostream *a2, uint64_t a3, uint64_t a4)
{
  sub_1CB8E509C(a2, "cgscc(");
  (*(void (**)(void, llvm::raw_ostream *, uint64_t, uint64_t))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), a2, a3, a4);

  return sub_1CB8E509C(a2, ")");
}

uint64_t sub_1CD66E52C()
{
  return 1;
}

char *sub_1CD66E534()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::ModuleToPostOrderCGSCCPassAdaptor]";
  v10[1] = 89;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x59) {
    uint64_t v1 = 89;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_11[v1];
  unint64_t v3 = 89 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

void *sub_1CD66E5F0(void *a1)
{
  uint64_t v2 = a1[1];
  *a1 = &unk_1F26291E8;
  a1[1] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_1CD66E65C(void *a1)
{
  uint64_t v2 = a1[1];
  *a1 = &unk_1F26291E8;
  a1[1] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

llvm::raw_ostream *sub_1CD66E6E8(uint64_t a1, llvm::raw_ostream *a2, uint64_t a3, uint64_t a4)
{
  return sub_1CD66E6F0((int *)(a1 + 8), a2, a3, a4);
}

llvm::raw_ostream *sub_1CD66E6F0(int *a1, llvm::raw_ostream *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = sub_1CB8E509C(a2, "devirt<");
  size_t v9 = llvm::raw_ostream::operator<<(v8, a1[2]);
  sub_1CB8E509C(v9, ">(");
  (*(void (**)(void, llvm::raw_ostream *, uint64_t, uint64_t))(**(void **)a1 + 24))(*(void *)a1, a2, a3, a4);

  return sub_1CB8E509C(a2, ")");
}

llvm::GlobalAlias *llvm::InternalizePass::checkComdat(llvm::GlobalAlias *result, llvm::GlobalAlias *this, uint64_t a3)
{
  int v3 = *((unsigned __int8 *)this + 16);
  if (v3 != 2)
  {
    uint64_t v4 = a3;
    unint64_t v6 = result;
    uint64_t result = this;
    if (v3 != 1 || (result = (llvm::GlobalAlias *)llvm::GlobalAlias::getAliaseeObject(this), uint64_t v4 = a3, result))
    {
      uint64_t v10 = *((void *)result + 6);
      if (v10)
      {
        sub_1CD66E848((uint64_t)v9, v4, &v10);
        uint64_t v7 = v9[0];
        ++*(void *)(v9[0] + 8);
        uint64_t result = (llvm::GlobalAlias *)llvm::InternalizePass::shouldPreserveGV(v6, this);
        if (result) {
          *(unsigned char *)(v7 + 16) = 1;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1CD66E848(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD45B528(*(void *)a2, *(_DWORD *)(a2 + 16), *a3, &v10);
  uint64_t v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD4CB5C0(a2, a3, v10);
    uint64_t v7 = (void *)result;
    *(void *)uint64_t result = *a3;
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a2 + 24 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v9;
  *(unsigned char *)(a1 + 16) = v8;
  return result;
}

llvm::InternalizePass *llvm::InternalizePass::InternalizePass(llvm::InternalizePass *this)
{
  *(unsigned char *)this = 0;
  sub_1CC94820C((llvm::StringMapImpl *)&v5);
  uint64_t v2 = operator new(0x28uLL);
  uint64_t v3 = v5;
  *uint64_t v2 = &unk_1F26292C8;
  v2[1] = v3;
  *((_OWORD *)v2 + 1) = v6;
  uint64_t v5 = 0;
  *(void *)&long long v6 = 0;
  DWORD2(v6) = 0;
  *((void *)this + 4) = v2;
  sub_1CC0D7CD8((uint64_t)&v5);
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0x800000000;
  return this;
}

void llvm::createInternalizePass(llvm *this)
{
}

void llvm::createInternalizePass()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1CD66EBBC(long long *a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCE0DC0, 0, 0);
  qword_1EBCE0E40 = 0;
  qword_1EBCE0E48 = 0;
  qword_1EBCE0E68 = 0;
  unk_1EBCE0E70 = 0;
  byte_1EBCE0E78 = 0;
  qword_1EBCE0E60 = 0;
  unk_1EBCE0E50 = 0;
  unk_1EBCE0E58 = &unk_1F2643C20;
  qword_1EBCE0DC0 = (uint64_t)&unk_1F2643FD0;
  qword_1EBCE0E80 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCE0E88 = (uint64_t)&unk_1F25F6428;
  qword_1EBCE0EA0 = (uint64_t)&qword_1EBCE0E88;
  llvm::cl::Option::setArgStr(v4, "internalize-public-api-file", 0x1BuLL);
  xmmword_1EBCE0DF0 = *a1;
  xmmword_1EBCE0DE0 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE0DC0);
}

void sub_1CD66ECC4(long long *a1, long long *a2, _WORD *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCE0CE8, 1, 0);
  qword_1EBCE0D68 = 0;
  unk_1EBCE0D70 = 0;
  qword_1EBCE0D78 = 0;
  unk_1EBCE0D80 = 0;
  qword_1EBCE0CE8 = (uint64_t)&unk_1F260A070;
  qword_1EBCE0D88 = 0;
  unk_1EBCE0D90 = 0;
  qword_1EBCE0D98 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCE0DA0 = (uint64_t)&unk_1F260AC78;
  qword_1EBCE0DB8 = (uint64_t)&qword_1EBCE0DA0;
  llvm::cl::Option::setArgStr(v6, "internalize-public-api-list", 0x1BuLL);
  xmmword_1EBCE0D18 = *a1;
  xmmword_1EBCE0D08 = *a2;
  word_1EBCE0CF2 |= (*a3 & 0x1F) << 9;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE0CE8);
}

llvm::StringMapImpl *sub_1CD66EDC0(llvm::StringMapImpl *this, uint64_t *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0x800000000;
  if (*((_DWORD *)a2 + 3))
  {
    llvm::StringMapImpl::init(this, *((_DWORD *)a2 + 2));
    uint64_t v4 = *(void *)this;
    uint64_t v5 = *((unsigned int *)this + 2);
    uint64_t v6 = *a2;
    *(void *)((char *)this + 12) = *(uint64_t *)((char *)a2 + 12);
    if (v5)
    {
      uint64_t v7 = 0;
      uint64_t v8 = v4 + 8 * v5 + 8;
      uint64_t v9 = v6 + 8 * v5 + 8;
      do
      {
        uint64_t v10 = *(size_t **)(*a2 + 8 * v7);
        if (v10) {
          BOOL v11 = v10 + 1 == 0;
        }
        else {
          BOOL v11 = 1;
        }
        if (v11)
        {
          *(void *)(*(void *)this + 8 * v7) = v10;
        }
        else
        {
          size_t v12 = *v10;
          uint64_t v13 = operator new(*v10 + 9, (std::align_val_t)8uLL);
          uint64_t v14 = v13;
          int v15 = (char *)(v13 + 1);
          if (v12) {
            memcpy(v13 + 1, v10 + 1, v12);
          }
          v15[v12] = 0;
          *uint64_t v14 = v12;
          *(void *)(*(void *)this + 8 * v7) = v14;
          *(_DWORD *)(v8 + 4 * v7) = *(_DWORD *)(v9 + 4 * v7);
        }
        ++v7;
      }
      while (v5 != v7);
    }
  }
  return this;
}

void llvm::createLoopExtractorPass(llvm *this)
{
}

void llvm::createSingleLoopExtractorPass(llvm *this)
{
}

void llvm::LoopExtractorPass::run()
{
}

llvm::raw_ostream *llvm::LoopExtractorPass::printPipeline(_DWORD *a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, const char *, uint64_t), uint64_t a4)
{
  sub_1CD66F0F0(a2, a3, a4);
  sub_1CB8E509C(a2, "<");
  if (*a1 == 1) {
    sub_1CB8E509C(a2, "single");
  }

  return sub_1CB8E509C(a2, ">");
}

llvm::raw_ostream *sub_1CD66F0F0(llvm::raw_ostream *a1, uint64_t (*a2)(uint64_t, const char *, uint64_t), uint64_t a3)
{
  uint64_t v6 = sub_1CD66F19C();
  uint64_t v9 = (const void *)a2(a3, v6, v7);
  size_t v10 = v8;
  uint64_t result = (llvm::raw_ostream *)*((void *)a1 + 4);
  if (v8 <= *((void *)a1 + 3) - (void)result)
  {
    if (v8)
    {
      uint64_t result = (llvm::raw_ostream *)memcpy(result, v9, v8);
      *((void *)a1 + 4) += v10;
    }
  }
  else
  {
    return llvm::raw_ostream::write(a1, (const char *)v9, v8);
  }
  return result;
}

const char *sub_1CD66F19C()
{
  size_t v10 = "StringRef llvm::getTypeName() [DesiredTypeName = llvm::LoopExtractorPass]";
  unint64_t v11 = 73;
  unint64_t v0 = llvm::StringRef::find((uint64_t *)&v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v11 >= v0) {
    unint64_t v1 = v0;
  }
  else {
    unint64_t v1 = v11;
  }
  uint64_t v2 = &v10[v1];
  unint64_t v3 = v11 - v1;
  if (v11 - v1 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v11 - v1;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

uint64_t **llvm::lowertypetests::BitSetBuilder::build@<X0>(uint64_t **this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v3 = this[18];
  uint64_t v4 = this[19];
  if (v3 > v4)
  {
    unint64_t v3 = 0;
    this[18] = 0;
  }
  uint64_t v5 = *this;
  uint64_t v6 = *((unsigned int *)this + 2);
  uint64_t v7 = 8 * v6;
  unint64_t v8 = 0;
  if (v6)
  {
    uint64_t v9 = 8 * v6;
    size_t v10 = *this;
    do
    {
      uint64_t v11 = *v10 - (void)this[18];
      *v10++ = v11;
      v8 |= v11;
      v9 -= 8;
    }
    while (v9);
    unint64_t v3 = this[18];
    uint64_t v4 = this[19];
  }
  *(void *)(a2 + 8) = 0;
  *(void *)a2 = a2 + 8;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = v3;
  char v12 = __clz(__rbit64(v8));
  *(_DWORD *)(a2 + 40) = v12 & 0x3F;
  *(void *)(a2 + 32) = ((unint64_t)((char *)v4 - (char *)v3) >> v12) + 1;
  if (v6)
  {
    do
    {
      unint64_t v13 = *v5++;
      unint64_t v14 = v13 >> *(_DWORD *)(a2 + 40);
      this = sub_1CD3CFB98((uint64_t **)a2, &v14, (uint64_t **)&v14);
      v7 -= 8;
    }
    while (v7);
  }
  return this;
}

void llvm::lowertypetests::ByteArrayBuilder::allocate(unint64_t *a1, void *a2, int a3, unint64_t *a4, unsigned char *a5)
{
  unsigned int v9 = 0;
  for (uint64_t i = 4; i != 11; ++i)
  {
    if (a1[i] < a1[v9 + 3]) {
      unsigned int v9 = i - 3;
    }
  }
  uint64_t v11 = &a1[v9];
  unint64_t v12 = v11[3];
  *a4 = v12;
  unint64_t v13 = (v12 + a3);
  void v11[3] = v13;
  unint64_t v14 = a1[1] - *a1;
  if (v13 > v14) {
    sub_1CD674784(a1, v13 - v14);
  }
  *a5 = 1 << v9;
  int v17 = (void *)*a2;
  char v16 = a2 + 1;
  int v15 = v17;
  if (v17 != v16)
  {
    do
    {
      *(unsigned char *)(*a1 + *a4 + v15[4]) |= *a5;
      uint64_t v18 = (void *)v15[1];
      if (v18)
      {
        do
        {
          BOOL v19 = v18;
          uint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          BOOL v19 = (void *)v15[2];
          BOOL v20 = *v19 == (void)v15;
          int v15 = v19;
        }
        while (!v20);
      }
      int v15 = v19;
    }
    while (v19 != v16);
  }
}

uint64_t llvm::lowertypetests::isJumpTableCanonical(llvm::lowertypetests *this, llvm::Function *a2)
{
  int v2 = *((_DWORD *)this + 8);
  if ((v2 & 0xF) == 1) {
    return 0;
  }
  if (!*((unsigned char *)this + 16))
  {
    if ((v2 & 0x800000) != 0 || *((llvm::lowertypetests **)this + 9) != (llvm::lowertypetests *)((char *)this + 72)) {
      goto LABEL_6;
    }
    return 0;
  }
  if (*((unsigned char *)this + 16) == 3 && (*((_DWORD *)this + 5) & 0x7FFFFFF) == 0) {
    return 0;
  }
LABEL_6:
  uint64_t ModuleFlag = llvm::Module::getModuleFlag(*((llvm::Module **)this + 5), "CFI Canonical Jump Tables", 0x19uLL);
  if (!ModuleFlag) {
    return 1;
  }
  uint64_t v6 = *(void *)(ModuleFlag + 128);
  if (!v6) {
    return 1;
  }
  uint64_t v7 = (void *)(v6 + 24);
  if (*(_DWORD *)(v6 + 32) >= 0x41u) {
    uint64_t v7 = (void *)*v7;
  }
  if (*v7) {
    return 1;
  }

  return llvm::Function::hasFnAttribute((uint64_t)this, "cfi-canonical-jump-table", 0x18uLL);
}

void llvm::createLowerTypeTestsPass(llvm *this, llvm::ModuleSummaryIndex *a2, const llvm::ModuleSummaryIndex *a3)
{
}

double llvm::LowerTypeTestsPass::run@<D0>(uint64_t a1@<X0>, llvm::IntegerType **a2@<X1>, uint64_t a3@<X8>)
{
  if (*(unsigned char *)a1)
  {
    if (sub_1CC94A46C(a2))
    {
LABEL_3:
      *(_OWORD *)(a3 + 40) = 0u;
      *(_OWORD *)(a3 + 56) = 0u;
      *(void *)(a3 + 88) = 0;
      *(_OWORD *)(a3 + 72) = 0u;
      *(_OWORD *)(a3 + 24) = 0u;
      *(void *)a3 = a3 + 32;
      *(void *)(a3 + 8) = a3 + 32;
      *(void *)&double result = 2;
      *(void *)(a3 + 16) = 2;
      *(void *)(a3 + 48) = a3 + 80;
      *(void *)(a3 + 56) = a3 + 80;
      *(_DWORD *)(a3 + 64) = 2;
      return result;
    }
  }
  else
  {
    sub_1CC94AAC8(v6, a2, *(llvm::IntegerType ***)(a1 + 8), *(llvm::IntegerType ***)(a1 + 16), *(unsigned char *)(a1 + 24));
    char v5 = sub_1CC94ABE8((llvm::Constant **)v6);
    sub_1CC9508E4((uint64_t)v6);
    if (v5) {
      goto LABEL_3;
    }
  }
  *(void *)(a3 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a3 = a3 + 32;
  *(void *)(a3 + 8) = a3 + 32;
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 48) = a3 + 80;
  *(void *)(a3 + 56) = a3 + 80;
  *(void *)(a3 + 64) = 2;
  *(_DWORD *)(a3 + 72) = 0;
  *(void *)&double result = 0x100000002;
  *(void *)(a3 + 16) = 0x100000002;
  return result;
}

void *sub_1CD66F6F0(void *a1)
{
  *a1 = &unk_1F2629450;
  int v2 = a1 + 71;
  unint64_t v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1F26294B8;
  uint64_t v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }

  return sub_1CB87DD48(a1);
}

void *sub_1CD66F7D8(void *a1)
{
  *a1 = &unk_1F26294B8;
  int v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD66F82C(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  int v12 = 0;
  uint64_t v8 = sub_1CD42FA04(a1 + 152, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD66F8C0(v11);
}

uint64_t sub_1CD66F8C0(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 160) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD66F8D8(void *a1)
{
  sub_1CD66F6F0(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD66F910(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t sub_1CD66F91C(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

llvm::raw_ostream *sub_1CD66F92C(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    int v3 = *((_DWORD *)result + 32);
LABEL_3:
    uint64_t v4 = &unk_1F2629508;
    char v6 = 1;
    int v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 148))
  {
    int v3 = *((_DWORD *)result + 32);
    if (*((_DWORD *)result + 36) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD66F9B0(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void *sub_1CD66F9C8(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 152), a2);
}

void sub_1CD66F9D0(void *a1)
{
  *a1 = &unk_1F26294B8;
  int v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD66FA44(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD66FA4C(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1CD66FA60(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1CD66FA74(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1CD66FA88(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

llvm *sub_1CD66FAB4@<X0>(uint64_t a1@<X0>, std::error_code a2@<X2:X1>, uint64_t a3@<X8>)
{
  if (*(unsigned char *)(a1 + 16))
  {
    double result = *(llvm **)a1;
    if (*(void *)a1)
    {
      *(void *)&a2.__val_ = *(void *)(a1 + 8);
      llvm::errorCodeToError(result, a2, &v6);
      *(unsigned char *)(a3 + 8) |= 1u;
      double result = v6;
      goto LABEL_4;
    }
  }
  else
  {
    std::system_category();
    double result = *(llvm **)a1;
  }
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(void *)a1 = 0;
LABEL_4:
  *(void *)a3 = result;
  return result;
}

llvm::yaml::Output *sub_1CD66FB2C(llvm::yaml::Output *a1, uint64_t a2)
{
  if (llvm::yaml::Output::preflightDocument(a1, 0))
  {
    (*(void (**)(llvm::yaml::Output *))(*(void *)a1 + 104))(a1);
    sub_1CC950C98(a1, a2);
    (*(void (**)(llvm::yaml::Output *))(*(void *)a1 + 112))(a1);
    llvm::yaml::Output::postflightDocument(a1);
  }
  llvm::yaml::Output::endDocuments(a1);
  return a1;
}

void sub_1CD66FBD8()
{
}

_DWORD *sub_1CD66FBEC(uint64_t a1)
{
  double result = operator new(0x10uLL);
  *(void *)double result = &unk_1F26295E8;
  result[2] = *(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1CD66FC38(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1F26295E8;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(result + 8);
  return result;
}

uint64_t sub_1CD66FC68(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t sub_1CD66FC70(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    int v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);
    return v2();
  }
  else
  {
    sub_1CB920400();
    return sub_1CD66FCC0();
  }
}

uint64_t sub_1CD66FCC0(llvm::yaml::IO *a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v8 = 0;
  char v7 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if (result)
  {
    sub_1CD66FD80(a1, a3);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  return result;
}

uint64_t sub_1CD66FD80(llvm::yaml::IO *a1, void *a2)
{
  int v4 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1);
  (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 104))(a1);
  if (v4)
  {
    sub_1CC950F90(a1, a2);
    int v5 = *(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 112);
    return v5(a1);
  }
  else
  {
    (*(void (**)(std::string::value_type ***__return_ptr, llvm::yaml::IO *))(*(void *)a1 + 136))(&v11, a1);
    char v7 = v11;
    uint64_t v8 = v12;
    if (v11 != v12)
    {
      do
      {
        uint64_t v9 = *v7;
        std::string::size_type v10 = (std::string::size_type)v7[1];
        v7 += 2;
        sub_1CD66FEE8(a1, v9, v10, (uint64_t)a2);
      }
      while (v7 != v8);
      char v7 = v11;
    }
    if (v7)
    {
      int v12 = v7;
      operator delete(v7);
    }
    return (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 112))(a1);
  }
}

void sub_1CD66FEE8(llvm::yaml::IO *a1, std::string::value_type *__s, std::string::size_type __sz, uint64_t a4)
{
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  if (__s)
  {
    std::string::__init(&v35, __s, __sz);
    if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v8 = &v35;
    }
    else {
      uint64_t v8 = (std::string *)v35.__r_.__value_.__r.__words[0];
    }
  }
  else
  {
    memset(&v35, 0, sizeof(v35));
    uint64_t v8 = &v35;
  }
  sub_1CD670438(a1, (uint64_t)v8, &v38, 1);
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v35.__r_.__value_.__l.__data_);
  }
  v35.__r_.__value_.__r.__words[0] = 0;
  if (llvm::getAsUnsignedInteger((unsigned __int8 *)__s, __sz, 0, (unint64_t *)&v35))
  {
    v35.__r_.__value_.__r.__words[0] = (std::string::size_type)"key not an integer";
    __int16 v36 = 259;
    (*(void (**)(llvm::yaml::IO *, std::string *))(*(void *)a1 + 248))(a1, &v35);
  }
  else
  {
    unint64_t v37 = v35.__r_.__value_.__r.__words[0];
    uint64_t v11 = (void *)(a4 + 8);
    std::string::size_type v10 = *(void **)(a4 + 8);
    if (v10)
    {
      int v12 = *(void **)(a4 + 8);
      do
      {
        std::string::size_type v13 = v12[4];
        if (v35.__r_.__value_.__r.__words[0] >= v13)
        {
          if (v13 >= v35.__r_.__value_.__r.__words[0]) {
            goto LABEL_18;
          }
          ++v12;
        }
        int v12 = (void *)*v12;
      }
      while (v12);
    }
    v35.__r_.__value_.__s.__data_[0] = 0;
    sub_1CD671110((uint64_t **)a4, &v37, (uint64_t *)&v37, &v35);
    std::string::size_type v10 = *(void **)(a4 + 8);
LABEL_18:
    if (v10)
    {
      do
      {
        if (v10[4] >= v37) {
          unint64_t v14 = v10;
        }
        else {
          unint64_t v14 = v10 + 1;
        }
        std::string::size_type v10 = (void *)*v14;
      }
      while (*v14);
    }
    uint64_t v15 = v38;
    if (v38 != v39)
    {
      memset(&v35, 0, sizeof(v35));
      char v16 = *(unint64_t **)(v38 + 16);
      int v17 = *(unint64_t **)(v38 + 24);
      while (1)
      {
        if (v16 == v17)
        {
          v9.i32[0] = *(_DWORD *)(v15 + 8);
          int8x8_t v29 = vbic_s8((int8x8_t)0x200010000800040, (int8x8_t)vceqz_s16((int16x4_t)*(_OWORD *)&vmovl_u8(v9)));
          __int16 v34 = v29.i16[0] | v29.i16[2] | ((v29.i32[0] | v29.i32[1]) >> 16) | *(_WORD *)v15 & 0xF | (16 * (*(_WORD *)(v15 + 4) & 3));
          int v33 = 0;
          __int16 v32 = 0;
          int v31 = 0;
          v30[0] = 0;
          v30[1] = 0;
          sub_1CC951E28();
        }
        uint64_t v18 = (void *)*v11;
        if (*v11)
        {
          unint64_t v19 = *v16;
          BOOL v20 = (void *)*v11;
          do
          {
            unint64_t v21 = v20[4];
            if (v19 >= v21)
            {
              if (v21 >= v19) {
                goto LABEL_33;
              }
              ++v20;
            }
            BOOL v20 = (void *)*v20;
          }
          while (v20);
        }
        LOBYTE(v30[0]) = 0;
        sub_1CD671110((uint64_t **)a4, v16, (uint64_t *)v16, v30);
        uint64_t v18 = *(void **)(a4 + 8);
LABEL_33:
        if (!v18) {
          goto LABEL_44;
        }
        unint64_t v22 = *v16;
        unsigned int v23 = (void *)(a4 + 8);
        do
        {
          unint64_t v24 = v18[4];
          BOOL v25 = v24 >= v22;
          if (v24 >= v22) {
            BOOL v26 = v18;
          }
          else {
            BOOL v26 = v18 + 1;
          }
          if (v25) {
            unsigned int v23 = v18;
          }
          uint64_t v18 = (void *)*v26;
        }
        while (*v26);
        if (v23 == v11 || v22 < v23[4]) {
LABEL_44:
        }
          unsigned int v23 = (void *)(a4 + 8);
        v30[0] = (unint64_t)(v23 + 4) & 0xFFFFFFFFFFFFFFF8;
        std::string::size_type size = v35.__r_.__value_.__l.__size_;
        if (v35.__r_.__value_.__l.__size_ >= v35.__r_.__value_.__r.__words[2])
        {
          uint64_t v28 = sub_1CC1533E4(&v35.__r_.__value_.__l.__data_, v30);
        }
        else
        {
          *(void *)v35.__r_.__value_.__l.__size_ = (unint64_t)(v23 + 4) & 0xFFFFFFFFFFFFFFF8;
          uint64_t v28 = (char *)(size + 8);
        }
        v35.__r_.__value_.__l.__size_ = (std::string::size_type)v28;
        ++v16;
      }
    }
  }
  v35.__r_.__value_.__r.__words[0] = (std::string::size_type)&v38;
  sub_1CC951DA4((void ***)&v35);
}

__n128 sub_1CD6702D8(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
  *(void *)a1 = v2;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 16) = *((_OWORD *)a2 + 1);
  *(void *)(a1 + 32) = a2[4];
  a2[2] = 0;
  a2[3] = 0;
  a2[4] = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 5);
  *(void *)(a1 + 56) = a2[7];
  a2[5] = 0;
  a2[6] = 0;
  a2[7] = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 64) = *((_OWORD *)a2 + 4);
  *(void *)(a1 + 80) = a2[10];
  a2[8] = 0;
  a2[9] = 0;
  a2[10] = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 11);
  *(void *)(a1 + 104) = a2[13];
  a2[11] = 0;
  a2[12] = 0;
  a2[13] = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 112) = *((_OWORD *)a2 + 7);
  *(void *)(a1 + 128) = a2[16];
  a2[14] = 0;
  a2[15] = 0;
  a2[16] = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  __n128 result = *(__n128 *)(a2 + 17);
  *(__n128 *)(a1 + 136) = result;
  *(void *)(a1 + 152) = a2[19];
  a2[17] = 0;
  a2[18] = 0;
  a2[19] = 0;
  return result;
}

uint64_t sub_1CD6703AC(uint64_t a1)
{
  char v7 = (void **)(a1 + 136);
  sub_1CC0C4BCC(&v7);
  char v7 = (void **)(a1 + 112);
  sub_1CC0C4BCC(&v7);
  uint64_t v2 = *(void **)(a1 + 88);
  if (v2)
  {
    *(void *)(a1 + 96) = v2;
    operator delete(v2);
  }
  int v3 = *(void **)(a1 + 64);
  if (v3)
  {
    *(void *)(a1 + 72) = v3;
    operator delete(v3);
  }
  int v4 = *(void **)(a1 + 40);
  if (v4)
  {
    *(void *)(a1 + 48) = v4;
    operator delete(v4);
  }
  int v5 = *(void **)(a1 + 16);
  if (v5)
  {
    *(void *)(a1 + 24) = v5;
    operator delete(v5);
  }
  return a1;
}

uint64_t sub_1CD670438(llvm::yaml::IO *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v8 = 0;
  char v7 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if (result)
  {
    sub_1CD6704F8(a1, a3);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  return result;
}

uint64_t sub_1CD6704F8(llvm::yaml::IO *a1, uint64_t *a2)
{
  unsigned int v4 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 24))(a1);
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    unsigned int v4 = -858993459 * ((unint64_t)(a2[1] - *a2) >> 5);
  }
  if (v4)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    uint64_t v7 = v4;
    do
    {
      uint64_t v11 = 0;
      if ((*(unsigned int (**)(llvm::yaml::IO *, unint64_t, uint64_t *))(*(void *)a1 + 32))(a1, v6, &v11))
      {
        uint64_t v8 = *a2;
        if (0xCCCCCCCCCCCCCCCDLL * ((a2[1] - *a2) >> 5) <= v6)
        {
          sub_1CD670EBC(a2, v6 + 1);
          uint64_t v8 = *a2;
        }
        uint64_t v9 = v8 + v5;
        (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 104))(a1);
        sub_1CC951594(a1, v9);
        (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 112))(a1);
        (*(void (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 40))(a1, v11);
      }
      ++v6;
      v5 += 160;
    }
    while (v7 != v6);
  }
  return (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 48))(a1);
}

uint64_t sub_1CD6706EC(llvm::yaml::IO *a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v8 = 0;
  char v7 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if (result)
  {
    sub_1CD6707AC(a1, a3);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  return result;
}

uint64_t sub_1CD6707AC(llvm::yaml::IO *a1, void *a2)
{
  unsigned int v4 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 64))(a1);
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    uint64_t v5 = ((a2[1] - *a2) >> 3);
  }
  else {
    uint64_t v5 = v4;
  }
  if (v5)
  {
    for (unint64_t i = 0; i != v5; ++i)
    {
      uint64_t v9 = 0;
      if ((*(unsigned int (**)(llvm::yaml::IO *, unint64_t, uint64_t *))(*(void *)a1 + 72))(a1, i, &v9))
      {
        char v7 = (unint64_t *)sub_1CD67091C((uint64_t)a1, (uint64_t)a2, i);
        sub_1CD561CFC(a1, v7);
        (*(void (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 80))(a1, v9);
      }
    }
  }
  return (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 88))(a1);
}

char *sub_1CD67091C(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unsigned int v4 = *(char **)a2;
  unint64_t v5 = (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3;
  if (v5 <= a3)
  {
    if (a3 + 1 > v5)
    {
      sub_1CD4F51C4((char **)a2, a3 + 1 - v5);
      unsigned int v4 = *(char **)a2;
    }
    else if (a3 + 1 < v5)
    {
      *(void *)(a2 + 8) = &v4[8 * a3 + 8];
    }
  }
  return &v4[8 * a3];
}

uint64_t sub_1CD670984(llvm::yaml::IO *a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v8 = 0;
  char v7 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if (result)
  {
    sub_1CC951874(a1, a3);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  return result;
}

char *sub_1CD670A40(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unsigned int v4 = *(char **)a2;
  unint64_t v5 = (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4;
  if (v5 <= a3)
  {
    if (a3 + 1 > v5)
    {
      sub_1CD670AA8((char **)a2, a3 + 1 - v5);
      unsigned int v4 = *(char **)a2;
    }
    else if (a3 + 1 < v5)
    {
      *(void *)(a2 + 8) = &v4[16 * a3 + 16];
    }
  }
  return &v4[16 * a3];
}

void sub_1CD670AA8(char **a1, unint64_t a2)
{
  unint64_t v5 = a1[1];
  unsigned int v4 = a1[2];
  if (a2 <= (v4 - v5) >> 4)
  {
    if (a2)
    {
      bzero(a1[1], 16 * a2);
      v5 += 16 * a2;
    }
    a1[1] = v5;
  }
  else
  {
    unint64_t v6 = *a1;
    uint64_t v7 = v5 - *a1;
    unint64_t v8 = a2 + (v7 >> 4);
    if (v8 >> 60) {
      abort();
    }
    uint64_t v9 = v4 - v6;
    if (v9 >> 3 > v8) {
      unint64_t v8 = v9 >> 3;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 >> 60) {
        sub_1CB833614();
      }
      uint64_t v11 = (char *)operator new(16 * v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    int v12 = &v11[16 * (v7 >> 4)];
    std::string::size_type v13 = &v11[16 * v10];
    bzero(v12, 16 * a2);
    if (v5 != v6)
    {
      do
      {
        *((_OWORD *)v12 - 1) = *((_OWORD *)v5 - 1);
        v12 -= 16;
        v5 -= 16;
      }
      while (v5 != v6);
      unint64_t v5 = *a1;
    }
    *a1 = v12;
    a1[1] = &v11[16 * a2 + v7];
    a1[2] = v13;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

uint64_t sub_1CD670BE8(llvm::yaml::IO *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v8 = 0;
  char v7 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if (result)
  {
    sub_1CC951A94(a1, a3);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  return result;
}

void sub_1CD670CA4(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1CD670D44(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 40 * a2;
    while (v3 != v7)
    {
      uint64_t v8 = *(void **)(v3 - 24);
      if (v8)
      {
        *(void *)(v3 - 16) = v8;
        operator delete(v8);
      }
      v3 -= 40;
    }
    a1[1] = v7;
  }
}

char *sub_1CD670D44(uint64_t *a1, unint64_t a2)
{
  unint64_t v4 = a1 + 2;
  uint64_t v5 = a1[2];
  uint64_t result = (char *)a1[1];
  if (0xCCCCCCCCCCCCCCCDLL * ((v5 - (uint64_t)result) >> 3) < a2)
  {
    unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&result[-*a1] >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x666666666666666) {
      abort();
    }
    unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x333333333333333) {
      unint64_t v11 = 0x666666666666666;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v18 = v4;
    if (v11)
    {
      if (v11 > 0x666666666666666) {
        sub_1CB833614();
      }
      int v12 = (char *)operator new(40 * v11);
    }
    else
    {
      int v12 = 0;
    }
    unint64_t v14 = v12;
    uint64_t v15 = &v12[40 * v8];
    int v17 = &v12[40 * v11];
    uint64_t v13 = 5 * a2;
    bzero(v15, 40 * ((8 * v13 - 40) / 0x28uLL) + 40);
    char v16 = &v15[8 * v13];
    sub_1CD4AE5F0(a1, &v14);
    return (char *)sub_1CD4AE684((uint64_t)&v14);
  }
  else
  {
    if (a2)
    {
      uint64_t v7 = &result[40 * a2];
      bzero(result, 40 * ((40 * a2 - 40) / 0x28) + 40);
      uint64_t result = v7;
    }
    a1[1] = (uint64_t)result;
  }
  return result;
}

void sub_1CD670EBC(void *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((v3 - *a1) >> 5);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1CD670F48((uint64_t)a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 160 * a2;
    while (v3 != v7)
      uint64_t v3 = sub_1CD6703AC(v3 - 160);
    a1[1] = v7;
  }
}

void sub_1CD670F48(uint64_t a1, unint64_t a2)
{
  BOOL v5 = *(uint64_t **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  if (0xCCCCCCCCCCCCCCCDLL * ((v4 - (uint64_t)v5) >> 5) >= a2)
  {
    if (a2)
    {
      bzero(*(void **)(a1 + 8), 160 * ((160 * a2 - 160) / 0xA0) + 160);
      v5 += 20 * a2;
    }
    *(void *)(a1 + 8) = v5;
  }
  else
  {
    unint64_t v6 = *(uint64_t **)a1;
    unint64_t v7 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v5 - *(void *)a1) >> 5);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0x199999999999999) {
      abort();
    }
    unint64_t v9 = 0xCCCCCCCCCCCCCCCDLL * ((v4 - (uint64_t)v6) >> 5);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0xCCCCCCCCCCCCCCLL) {
      unint64_t v10 = 0x199999999999999;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0x199999999999999) {
        sub_1CB833614();
      }
      unint64_t v11 = (char *)operator new(160 * v10);
    }
    else
    {
      unint64_t v11 = 0;
    }
    int v12 = &v11[160 * v7];
    uint64_t v13 = &v11[160 * v10];
    uint64_t v14 = 5 * a2;
    bzero(v12, 160 * ((32 * v14 - 160) / 0xA0uLL) + 160);
    uint64_t v15 = &v12[32 * v14];
    if (v5 == v6)
    {
      *(void *)a1 = v12;
      *(void *)(a1 + 8) = v15;
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      do
      {
        v12 -= 160;
        v5 -= 20;
        sub_1CD6702D8((uint64_t)v12, v5);
      }
      while (v5 != v6);
      BOOL v5 = *(uint64_t **)a1;
      uint64_t v16 = *(void *)(a1 + 8);
      *(void *)a1 = v12;
      *(void *)(a1 + 8) = v15;
      *(void *)(a1 + 16) = v13;
      while ((uint64_t *)v16 != v5)
        uint64_t v16 = sub_1CD6703AC(v16 - 160);
    }
    if (v5)
    {
      operator delete(v5);
    }
  }
}

uint64_t *sub_1CD671110(uint64_t **a1, unint64_t *a2, uint64_t *a3, unsigned char *a4)
{
  unint64_t v8 = a1 + 1;
  unint64_t v7 = a1[1];
  if (v7)
  {
    unint64_t v9 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v10 = (uint64_t **)v7;
        unint64_t v11 = v7[4];
        if (v9 >= v11) {
          break;
        }
        unint64_t v7 = *v10;
        unint64_t v8 = v10;
        if (!*v10) {
          goto LABEL_10;
        }
      }
      if (v11 >= v9) {
        return (uint64_t *)v10;
      }
      unint64_t v7 = v10[1];
      if (!v7)
      {
        unint64_t v8 = v10 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    unint64_t v10 = a1 + 1;
LABEL_10:
    int v12 = (uint64_t *)operator new(0x50uLL);
    uint64_t v13 = v12;
    v12[4] = *a3;
    if (*a4)
    {
      uint64_t v14 = 0;
    }
    else
    {
      v12[6] = 0;
      uint64_t v14 = "";
    }
    v12[5] = (uint64_t)v14;
    *int v12 = 0;
    v12[1] = 0;
    v12[8] = 0;
    v12[9] = 0;
    v12[7] = 0;
    v12[2] = (uint64_t)v10;
    void *v8 = v12;
    uint64_t v15 = (uint64_t *)**a1;
    uint64_t v16 = v12;
    if (v15)
    {
      *a1 = v15;
      uint64_t v16 = *v8;
    }
    sub_1CB8358B8(a1[1], v16);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v13;
}

uint64_t sub_1CD67121C(llvm::yaml::IO *a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v8 = 0;
  char v7 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if (result)
  {
    sub_1CD6712DC(a1, a3);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  return result;
}

uint64_t sub_1CD6712DC(llvm::yaml::IO *a1, void *a2)
{
  int v4 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1);
  (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 104))(a1);
  if (v4)
  {
    sub_1CD671444((uint64_t)a1, a2);
    unint64_t v10 = *(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 112);
    return v10(a1);
  }
  else
  {
    (*(void (**)(std::string::value_type ***__return_ptr, llvm::yaml::IO *))(*(void *)a1 + 136))(&v11, a1);
    BOOL v5 = v11;
    unint64_t v6 = v12;
    if (v11 != v12)
    {
      do
      {
        char v7 = *v5;
        std::string::size_type v8 = (std::string::size_type)v5[1];
        v5 += 2;
        sub_1CD6714E0(a1, v7, v8, (uint64_t)a2);
      }
      while (v5 != v6);
      BOOL v5 = v11;
    }
    if (v5)
    {
      int v12 = v5;
      operator delete(v5);
    }
    return (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 112))(a1);
  }
}

uint64_t sub_1CD671444(uint64_t result, void *a2)
{
  uint64_t v2 = a2 + 1;
  uint64_t v3 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    int v4 = (llvm::yaml::IO *)result;
    do
    {
      BOOL v5 = v3 + 5;
      if (*((char *)v3 + 63) < 0) {
        BOOL v5 = (void *)*v5;
      }
      uint64_t result = sub_1CC952078(v4, (uint64_t)v5, (uint64_t)(v3 + 8), 1);
      unint64_t v6 = (void *)v3[1];
      if (v6)
      {
        do
        {
          char v7 = v6;
          unint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          char v7 = (void *)v3[2];
          BOOL v8 = *v7 == (void)v3;
          uint64_t v3 = v7;
        }
        while (!v8);
      }
      uint64_t v3 = v7;
    }
    while (v7 != v2);
  }
  return result;
}

void sub_1CD6714E0(llvm::yaml::IO *a1, std::string::value_type *__s, std::string::size_type __sz, uint64_t a4)
{
  v22[10] = *(char **)MEMORY[0x1E4F143B8];
  *(_DWORD *)unint64_t v11 = 5;
  memset(&v11[4], 0, 21);
  v14[0] = 0;
  v14[1] = 0;
  uint64_t v12 = 0;
  uint64_t v13 = v14;
  if (__s)
  {
    std::string::__init(&v20, __s, __sz);
    if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      BOOL v8 = &v20;
    }
    else {
      BOOL v8 = (std::string *)v20.__r_.__value_.__r.__words[0];
    }
  }
  else
  {
    memset(&v20, 0, sizeof(v20));
    BOOL v8 = &v20;
  }
  sub_1CC952078(a1, (uint64_t)v8, (uint64_t)v11, 1);
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v20.__r_.__value_.__l.__data_);
  }
  *(_OWORD *)&v20.__r_.__value_.__l.__data_ = xmmword_1CFAC4320;
  v20.__r_.__value_.__r.__words[2] = 0;
  llvm::MD5::update((int *)&v20, (int *)__s, __sz);
  llvm::MD5::final((int *)&v20, (int *)&__p);
  std::string::size_type v9 = __p.__r_.__value_.__r.__words[0];
  std::string::__init(&v10, __s, __sz);
  std::string __p = v10;
  memset(&v10, 0, sizeof(v10));
  long long v16 = *(_OWORD *)v11;
  long long v17 = *(_OWORD *)&v11[16];
  uint64_t v18 = v12;
  sub_1CC19DF38((uint64_t)v19, &v13);
  v20.__r_.__value_.__r.__words[0] = v9;
  sub_1CC19DEC4((uint64_t)&v20.__r_.__value_.__l.__size_, (long long *)&__p);
  sub_1CD4F2A40(a4, (uint64_t)&v20);
  sub_1CD4AFC3C((uint64_t)v22, v22[1]);
  if (v21 < 0) {
    operator delete((void *)v20.__r_.__value_.__l.__size_);
  }
  sub_1CD4AFC3C((uint64_t)v19, v19[1]);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
  sub_1CD4AFC3C((uint64_t)&v13, v14[0]);
}

uint64_t sub_1CD6716DC(llvm::yaml::IO *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = 0;
  char v7 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if (result)
  {
    (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 104))(a1);
    sub_1CD6717D4(a1, a3);
    (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 112))(a1);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  return result;
}

uint64_t sub_1CD6717D4(llvm::yaml::IO *a1, uint64_t a2)
{
  return sub_1CD563C30(a1, (uint64_t)"InlineBits", (unint64_t *)(a2 + 32), 0);
}

uint64_t sub_1CD6718A4(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v8 = 0;
  char v7 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 160))(a1);
    sub_1CD67199C(a1, a3);
    (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  return result;
}

uint64_t sub_1CD67199C(uint64_t a1, _DWORD *a2)
{
  unsigned int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 5) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "Unknown", v5)) {
    *a2 = 5;
  }
  unsigned int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v6;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "Unsat", v7)) {
    *a2 = 0;
  }
  unsigned int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 1) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "ByteArray", v9)) {
    *a2 = 1;
  }
  unsigned int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 2) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "Inline", v11)) {
    *a2 = 2;
  }
  unsigned int v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 3) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "Single", v13)) {
    *a2 = 3;
  }
  unsigned int v14 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 4) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "AllOnes", v15);
  if (result) {
    *a2 = 4;
  }
  return result;
}

uint64_t sub_1CD671C58(llvm::yaml::IO *a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4)
{
  uint64_t v8 = 0;
  char v7 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if (result)
  {
    sub_1CD671D18(a1, a3);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  return result;
}

void sub_1CD671D18(llvm::yaml::IO *a1, unsigned __int8 *a2)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1))
  {
    unint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    LODWORD(v16) = 0;
    char v20 = 0;
    uint64_t v21 = 0;
    unsigned int v23 = &v24;
    int v22 = 0;
    uint64_t v15 = (const char *)&unk_1F2646F30;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t Context = llvm::yaml::IO::getContext(a1);
    llvm::yaml::ScalarTraits<unsigned char,void>::output(a2, Context, (llvm::raw_ostream *)&v15);
    uint64_t v5 = v23;
    char v6 = *((unsigned char *)v23 + 23);
    BOOL v7 = v6 < 0;
    if (v6 < 0) {
      uint64_t v5 = *v23;
    }
    uint64_t v8 = (void *)(v6 & 0x7F);
    if (v7) {
      uint64_t v8 = v23[1];
    }
    v14[0] = v5;
    v14[1] = v8;
    (*(void (**)(llvm::yaml::IO *, void *, void))(*(void *)a1 + 216))(a1, v14, 0);
    llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v15);
    if (SHIBYTE(v26) < 0) {
      operator delete(v24);
    }
  }
  else
  {
    unint64_t v24 = 0;
    uint64_t v25 = 0;
    (*(void (**)(llvm::yaml::IO *, void **, void))(*(void *)a1 + 216))(a1, &v24, 0);
    uint64_t v9 = (unsigned __int8 *)v24;
    uint64_t v10 = v25;
    uint64_t v11 = llvm::yaml::IO::getContext(a1);
    unsigned int v12 = llvm::yaml::ScalarTraits<unsigned char,void>::input(v9, v10, v11, a2);
    if (v13)
    {
      LOWORD(v19) = 261;
      uint64_t v15 = v12;
      uint64_t v16 = v13;
      (*(void (**)(llvm::yaml::IO *, const char **))(*(void *)a1 + 248))(a1, &v15);
    }
  }
}

uint64_t sub_1CD671ED4(llvm::yaml::IO *a1, uint64_t a2, uint64_t **a3, uint64_t a4)
{
  uint64_t v8 = 0;
  char v7 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if (result)
  {
    sub_1CD671F94(a1, a3);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  return result;
}

uint64_t sub_1CD671F94(llvm::yaml::IO *a1, uint64_t **a2)
{
  int v4 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1);
  (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 104))(a1);
  if (v4)
  {
    sub_1CD6720FC(a1, a2);
    uint64_t v10 = *(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 112);
    return v10(a1);
  }
  else
  {
    (*(void (**)(std::string::value_type ***__return_ptr, llvm::yaml::IO *))(*(void *)a1 + 136))(&v11, a1);
    uint64_t v5 = v11;
    char v6 = v12;
    if (v11 != v12)
    {
      do
      {
        char v7 = *v5;
        std::string::size_type v8 = (std::string::size_type)v5[1];
        v5 += 2;
        sub_1CD672254(a1, v7, v8, a2);
      }
      while (v5 != v6);
      uint64_t v5 = v11;
    }
    if (v5)
    {
      unsigned int v12 = v5;
      operator delete(v5);
    }
    return (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 112))(a1);
  }
}

void sub_1CD6720FC(llvm::yaml::IO *a1, void *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a2 + 1;
  uint64_t v3 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      unint64_t v5 = v3[4];
      char v6 = (char *)&v15;
      if (v5)
      {
        do
        {
          *--char v6 = (v5 % 0xA) | 0x30;
          BOOL v7 = v5 > 9;
          v5 /= 0xAuLL;
        }
        while (v7);
      }
      else
      {
        char v14 = 48;
        char v6 = &v14;
      }
      sub_1CC028D80(__p, v6, (char *)&v15, (char *)&v15 - v6);
      if (v13 >= 0) {
        std::string::size_type v8 = __p;
      }
      else {
        std::string::size_type v8 = (void **)__p[0];
      }
      sub_1CD672384(a1, (uint64_t)v8, (uint64_t)(v3 + 5), 1);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
      uint64_t v9 = (void *)v3[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)v3[2];
          BOOL v11 = *v10 == (void)v3;
          uint64_t v3 = v10;
        }
        while (!v11);
      }
      uint64_t v3 = v10;
    }
    while (v10 != v2);
  }
}

void sub_1CD672254(llvm::yaml::IO *a1, std::string::value_type *a2, std::string::size_type a3, uint64_t **a4)
{
  __p.__r_.__value_.__r.__words[0] = 0;
  if (llvm::getAsUnsignedInteger((unsigned __int8 *)a2, a3, 0, (unint64_t *)&__p))
  {
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"key not an integer";
    __int16 v11 = 259;
    (*(void (**)(llvm::yaml::IO *, std::string *))(*(void *)a1 + 248))(a1, &__p);
  }
  else
  {
    std::string::size_type v12 = __p.__r_.__value_.__r.__words[0];
    if (a2)
    {
      std::string::__init(&__p, a2, a3);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
    }
    else
    {
      memset(&__p, 0, sizeof(__p));
      p_p = &__p;
    }
    char v13 = &v12;
    uint64_t v9 = sub_1CD4F4FFC(a4, &v12, (uint64_t)&std::piecewise_construct, &v13);
    sub_1CD672384(a1, (uint64_t)p_p, (uint64_t)(v9 + 40), 1);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

uint64_t sub_1CD672384(llvm::yaml::IO *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = 0;
  char v7 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if (result)
  {
    (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 104))(a1);
    sub_1CD67247C(a1, a3);
    (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 112))(a1);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  return result;
}

uint64_t sub_1CD67247C(llvm::yaml::IO *a1, uint64_t a2)
{
  return sub_1CD6729DC(a1, (uint64_t)"ResByArg", (void *)(a2 + 32), 0);
}

uint64_t sub_1CD6724F8(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v8 = 0;
  char v7 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 160))(a1);
    sub_1CD6725F0(a1, a3);
    (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  return result;
}

uint64_t sub_1CD6725F0(uint64_t a1, _DWORD *a2)
{
  unsigned int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = v4;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "Indir", v5)) {
    *a2 = 0;
  }
  unsigned int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 1) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "SingleImpl", v7)) {
    *a2 = 1;
  }
  unsigned int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 2) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "BranchFunnel", v9);
  if (result) {
    *a2 = 2;
  }
  return result;
}

uint64_t sub_1CD67275C(llvm::yaml::IO *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = 0;
  char v7 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if (result)
  {
    sub_1CD67281C(a1, a3);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  return result;
}

void sub_1CD67281C(llvm::yaml::IO *a1, uint64_t a2)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1))
  {
    unint64_t v24 = 0;
    std::string::size_type v25 = 0;
    uint64_t v26 = 0;
    LODWORD(v16) = 0;
    char v20 = 0;
    uint64_t v21 = 0;
    unsigned int v23 = &v24;
    int v22 = 0;
    uint64_t v15 = &unk_1F2646F30;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    int Context = llvm::yaml::IO::getContext(a1);
    llvm::yaml::ScalarTraits<std::string,void>::output(a2, Context, (llvm::raw_ostream *)&v15);
    char v10 = *((unsigned char *)v23 + 23);
    if (v10 >= 0) {
      __int16 v11 = (char *)v23;
    }
    else {
      __int16 v11 = (char *)*v23;
    }
    if (v10 >= 0) {
      uint64_t v12 = v10 & 0x7F;
    }
    else {
      uint64_t v12 = (uint64_t)v23[1];
    }
    v14[0] = v11;
    v14[1] = v12;
    uint64_t mustQuote = llvm::yaml::ScalarTraits<FlowStringRef,void>::mustQuote(v11, v12);
    (*(void (**)(llvm::yaml::IO *, void *, uint64_t))(*(void *)a1 + 216))(a1, v14, mustQuote);
    llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v15);
    if (SHIBYTE(v26) < 0) {
      operator delete(v24);
    }
  }
  else
  {
    unint64_t v24 = 0;
    std::string::size_type v25 = 0;
    (*(void (**)(llvm::yaml::IO *, void **, uint64_t))(*(void *)a1 + 216))(a1, &v24, 1);
    unsigned int v4 = (std::string::value_type *)v24;
    std::string::size_type v5 = v25;
    uint64_t v6 = llvm::yaml::IO::getContext(a1);
    uint64_t v7 = llvm::yaml::ScalarTraits<std::string,void>::input(v4, v5, v6, a2);
    if (v8)
    {
      LOWORD(v19) = 261;
      uint64_t v15 = (void *)v7;
      uint64_t v16 = v8;
      (*(void (**)(llvm::yaml::IO *, void **))(*(void *)a1 + 248))(a1, &v15);
    }
  }
}

uint64_t sub_1CD6729DC(llvm::yaml::IO *a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v8 = 0;
  char v7 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if (result)
  {
    sub_1CD672A9C(a1, a3);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  return result;
}

uint64_t sub_1CD672A9C(llvm::yaml::IO *a1, void *a2)
{
  int v4 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1);
  (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 104))(a1);
  if (v4)
  {
    sub_1CD672C04(a1, a2);
    char v10 = *(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 112);
    return v10(a1);
  }
  else
  {
    (*(void (**)(char ***__return_ptr, llvm::yaml::IO *))(*(void *)a1 + 136))(&v11, a1);
    std::string::size_type v5 = v11;
    uint64_t v6 = v12;
    if (v11 != v12)
    {
      do
      {
        char v7 = *v5;
        size_t v8 = (size_t)v5[1];
        v5 += 2;
        sub_1CC9521E4(a1, v7, v8, (uint64_t)a2);
      }
      while (v5 != v6);
      std::string::size_type v5 = v11;
    }
    if (v5)
    {
      uint64_t v12 = v5;
      operator delete(v5);
    }
    return (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 112))(a1);
  }
}

void sub_1CD672C04(llvm::yaml::IO *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (void *)*a2;
  uint64_t v16 = a2 + 1;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      memset(&v19, 0, sizeof(v19));
      int v4 = (unint64_t *)v2[4];
      uint64_t v3 = (unint64_t *)v2[5];
      if (v4 == v3)
      {
        std::string::size_type v5 = &v19;
      }
      else
      {
        do
        {
          unint64_t v6 = *v4;
          std::string::size_type size = *((unsigned char *)&v19.__r_.__value_.__s + 23) & 0x7F;
          if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type size = v19.__r_.__value_.__l.__size_;
          }
          if (size) {
            std::string::push_back(&v19, 44);
          }
          size_t v8 = (char *)&v21;
          if (v6)
          {
            do
            {
              *--size_t v8 = (v6 % 0xA) | 0x30;
              BOOL v9 = v6 > 9;
              v6 /= 0xAuLL;
            }
            while (v9);
          }
          else
          {
            char v20 = 48;
            size_t v8 = &v20;
          }
          sub_1CC028D80(__p, v8, (char *)&v21, (char *)&v21 - v8);
          if (v18 >= 0) {
            char v10 = __p;
          }
          else {
            char v10 = (void **)__p[0];
          }
          if (v18 >= 0) {
            std::string::size_type v11 = v18 & 0x7F;
          }
          else {
            std::string::size_type v11 = (std::string::size_type)__p[1];
          }
          std::string::append(&v19, (const std::string::value_type *)v10, v11);
          if (v18 < 0) {
            operator delete(__p[0]);
          }
          ++v4;
        }
        while (v4 != v3);
        if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v5 = &v19;
        }
        else {
          std::string::size_type v5 = (std::string *)v19.__r_.__value_.__r.__words[0];
        }
      }
      sub_1CD672DEC(a1, (uint64_t)v5, (uint64_t)(v2 + 7), 1);
      if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v19.__r_.__value_.__l.__data_);
      }
      uint64_t v12 = (void *)v2[1];
      if (v12)
      {
        do
        {
          char v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          char v13 = (void *)v2[2];
          BOOL v14 = *v13 == (void)v2;
          uint64_t v2 = v13;
        }
        while (!v14);
      }
      uint64_t v2 = v13;
    }
    while (v13 != v16);
  }
}

uint64_t sub_1CD672DEC(llvm::yaml::IO *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = 0;
  char v7 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if (result)
  {
    (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 104))(a1);
    sub_1CD672EE4(a1, a3);
    (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 112))(a1);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  return result;
}

uint64_t sub_1CD672EE4(llvm::yaml::IO *a1, uint64_t a2)
{
  return sub_1CD3EDEB8(a1, (uint64_t)"Bit", (unsigned int *)(a2 + 20), 0);
}

uint64_t sub_1CD672F7C(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v8 = 0;
  char v7 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 160))(a1);
    sub_1CD673074(a1, a3);
    (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  return result;
}

uint64_t sub_1CD673074(uint64_t a1, _DWORD *a2)
{
  unsigned int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = v4;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "Indir", v5)) {
    *a2 = 0;
  }
  unsigned int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 1) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "UniformRetVal", v7)) {
    *a2 = 1;
  }
  unsigned int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 2) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "UniqueRetVal", v9)) {
    *a2 = 2;
  }
  unsigned int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 3) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "VirtualConstProp", v11);
  if (result) {
    *a2 = 3;
  }
  return result;
}

void *sub_1CD673250(void *a1, void *a2, void *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2 == a3)
  {
    unint64_t v4 = 0;
  }
  else
  {
    unint64_t v4 = 0;
    uint64_t v5 = a2;
    do
    {
      unsigned int v6 = (void *)v5[1];
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          unsigned int v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (void *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          uint64_t v5 = v7;
        }
        while (!v8);
      }
      ++v4;
      uint64_t v5 = v7;
    }
    while (v7 != a3);
  }
  sub_1CC95255C((uint64_t)a1, a2, a3, v4);
  return a1;
}

uint64_t sub_1CD6732D8(llvm::yaml::IO *a1, uint64_t a2, int64x2_t *a3, uint64_t a4)
{
  uint64_t v8 = 0;
  char v7 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if (result)
  {
    sub_1CD673398(a1, a3);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  return result;
}

uint64_t sub_1CD673398(llvm::yaml::IO *a1, int64x2_t *a2)
{
  int v4 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 24))(a1);
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    int v4 = -1431655765 * ((unint64_t)(a2->i64[1] - a2->i64[0]) >> 3);
  }
  if (v4)
  {
    uint64_t v5 = 0;
    for (unint64_t i = 0; i != v4; ++i)
    {
      uint64_t v9 = 0;
      if ((*(unsigned int (**)(llvm::yaml::IO *, unint64_t, uint64_t *))(*(void *)a1 + 32))(a1, i, &v9))
      {
        uint64_t v7 = a2->i64[0];
        if (0xAAAAAAAAAAAAAAABLL * ((a2->i64[1] - a2->i64[0]) >> 3) <= i)
        {
          sub_1CD673544(a2, i + 1);
          uint64_t v7 = a2->i64[0];
        }
        sub_1CD67281C(a1, v7 + v5);
        (*(void (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 40))(a1, v9);
      }
      v5 += 24;
    }
  }
  return (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 48))(a1);
}

void sub_1CD673544(int64x2_t *a1, unint64_t a2)
{
  uint64_t v3 = a1->i64[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - a1->i64[0]) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1CD6735E4(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = a1->i64[0] + 24 * a2;
    while (v3 != v7)
    {
      if (*(char *)(v3 - 1) < 0) {
        operator delete(*(void **)(v3 - 24));
      }
      v3 -= 24;
    }
    a1->i64[1] = v7;
  }
}

void sub_1CD6735E4(int64x2_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[1].i64[0];
  unint64_t v5 = a1->u64[1];
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - v5) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v16 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero((void *)a1->i64[1], v16);
      v5 += v16;
    }
    a1->i64[1] = v5;
  }
  else
  {
    uint64_t v6 = a1->i64[0];
    uint64_t v7 = v5 - a1->i64[0];
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (v7 >> 3) + a2;
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    if (0x5555555555555556 * ((v4 - v6) >> 3) > v8) {
      unint64_t v8 = 0x5555555555555556 * ((v4 - v6) >> 3);
    }
    if (0xAAAAAAAAAAAAAAABLL * ((v4 - v6) >> 3) >= 0x555555555555555) {
      unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v9 = v8;
    }
    char v20 = a1 + 1;
    if (v9)
    {
      if (v9 > 0xAAAAAAAAAAAAAAALL) {
        sub_1CB833614();
      }
      unsigned int v10 = (char *)operator new(24 * v9);
    }
    else
    {
      unsigned int v10 = 0;
    }
    uint64_t v11 = &v10[8 * (v7 >> 3)];
    uint64_t v12 = &v10[24 * v9];
    size_t v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v11, v13);
    if (v5 == v6)
    {
      int64x2_t v15 = vdupq_n_s64(v5);
    }
    else
    {
      do
      {
        long long v14 = *(_OWORD *)(v5 - 24);
        *((void *)v11 - 1) = *(void *)(v5 - 8);
        *(_OWORD *)(v11 - 24) = v14;
        v11 -= 24;
        *(void *)(v5 - 16) = 0;
        *(void *)(v5 - 8) = 0;
        *(void *)(v5 - 24) = 0;
        v5 -= 24;
      }
      while (v5 != v6);
      int64x2_t v15 = *a1;
      uint64_t v4 = a1[1].i64[0];
    }
    a1->i64[0] = (uint64_t)v11;
    a1->i64[1] = (uint64_t)&v10[v7 + v13];
    int64x2_t v18 = v15;
    a1[1].i64[0] = (uint64_t)v12;
    uint64_t v19 = v4;
    uint64_t v17 = v15.i64[0];
    sub_1CBF4EE0C((uint64_t)&v17);
  }
}

uint64_t sub_1CD6737AC(uint64_t a1)
{
  uint64_t v2 = a1 + 24;
  uint64_t v3 = *(void *)(a1 + 48);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_1CD673844(uint64_t a1, int *a2, size_t a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  long long v18 = xmmword_1CFAC4320;
  uint64_t v5 = a1 + 56;
  uint64_t v19 = 0;
  llvm::MD5::update((int *)&v18, a2, a3);
  llvm::MD5::final((int *)&v18, (int *)&v17);
  *(void *)&long long v18 = v17;
  uint64_t v6 = sub_1CD4F29A8(v5, (unint64_t *)&v18);
  if (v6 == v7) {
    return 0;
  }
  unint64_t v8 = v6;
  unint64_t v9 = v7;
  while (1)
  {
    char v10 = *((unsigned char *)v8 + 63);
    if (v10 >= 0) {
      uint64_t v11 = v8 + 5;
    }
    else {
      uint64_t v11 = (const void *)v8[5];
    }
    uint64_t v12 = v8[6];
    if (v10 >= 0) {
      uint64_t v12 = v10 & 0x7F;
    }
    if (v12 == a3 && (!a3 || !memcmp(v11, a2, a3))) {
      break;
    }
    size_t v13 = (void *)v8[1];
    if (v13)
    {
      do
      {
        long long v14 = v13;
        size_t v13 = (void *)*v13;
      }
      while (v13);
    }
    else
    {
      do
      {
        long long v14 = (void *)v8[2];
        BOOL v15 = *v14 == (void)v8;
        unint64_t v8 = v14;
      }
      while (!v15);
    }
    unint64_t v8 = v14;
    if (v14 == v9) {
      return 0;
    }
  }
  return v8 + 8;
}

uint64_t sub_1CD673974(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

void *sub_1CD673980(uint64_t a1, uint64_t *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    unint64_t v9 = 0;
LABEL_5:
    uint64_t v6 = sub_1CD673A40(a1, (uint64_t)a2, a2, v9);
    *uint64_t v6 = *a2;
    v6[1] = 0;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = (37 * *a2) & (v3 - 1);
  uint64_t v6 = (void *)(*(void *)a1 + 16 * v5);
  uint64_t v7 = *v6;
  if (*a2 != *v6)
  {
    char v10 = 0;
    int v11 = 1;
    while (v7 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        char v10 = v6;
      }
      unsigned int v13 = v5 + v11++;
      unsigned int v5 = v13 & v4;
      uint64_t v6 = (void *)(*(void *)a1 + 16 * (v13 & v4));
      uint64_t v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      unint64_t v9 = v10;
    }
    else {
      unint64_t v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

void *sub_1CD673A40(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    sub_1CD673BB8(a1, 2 * v7);
    uint64_t v8 = *a3;
    int v10 = *(_DWORD *)(a1 + 16) - 1;
    unsigned int v11 = (37 * *a3) & v10;
    a4 = (void *)(*(void *)a1 + 16 * v11);
    uint64_t v12 = *a4;
    if (*a3 != *a4)
    {
      unsigned int v13 = 0;
      int v14 = 1;
      while (v12 != -1)
      {
        if (v13) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v12 == -2;
        }
        if (v15) {
          unsigned int v13 = a4;
        }
        unsigned int v16 = v11 + v14++;
        unsigned int v11 = v16 & v10;
        a4 = (void *)(*(void *)a1 + 16 * v11);
        uint64_t v12 = *a4;
        if (v8 == *a4) {
          goto LABEL_4;
        }
      }
      goto LABEL_20;
    }
  }
  else
  {
    if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
    {
LABEL_3:
      uint64_t v8 = *a4;
      goto LABEL_4;
    }
    sub_1CD673BB8(a1, v7);
    uint64_t v8 = *a3;
    int v17 = *(_DWORD *)(a1 + 16) - 1;
    unsigned int v18 = (37 * *a3) & v17;
    a4 = (void *)(*(void *)a1 + 16 * v18);
    uint64_t v19 = *a4;
    if (*a3 != *a4)
    {
      unsigned int v13 = 0;
      int v20 = 1;
      while (v19 != -1)
      {
        if (v13) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v19 == -2;
        }
        if (v21) {
          unsigned int v13 = a4;
        }
        unsigned int v22 = v18 + v20++;
        unsigned int v18 = v22 & v17;
        a4 = (void *)(*(void *)a1 + 16 * v18);
        uint64_t v19 = *a4;
        if (v8 == *a4) {
          goto LABEL_4;
        }
      }
LABEL_20:
      if (v13) {
        a4 = v13;
      }
      goto LABEL_3;
    }
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD673BB8(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD673C84((void *)a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -1;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

void *sub_1CD673C84(void *result, uint64_t *a2, uint64_t *a3)
{
  int v4 = a2;
  unint64_t v5 = result;
  result[1] = 0;
  uint64_t v6 = *((unsigned int *)result + 4);
  if (v6)
  {
    int v7 = (void *)*result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -1;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v9 = *v4;
      if ((unint64_t)*v4 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        int v10 = *((_DWORD *)v5 + 4) - 1;
        unsigned int v11 = v10 & (37 * v9);
        uint64_t v12 = (void *)(*v5 + 16 * v11);
        uint64_t v13 = *v12;
        if (v9 != *v12)
        {
          int v14 = 0;
          int v15 = 1;
          while (v13 != -1)
          {
            if (v14) {
              BOOL v16 = 0;
            }
            else {
              BOOL v16 = v13 == -2;
            }
            if (v16) {
              int v14 = v12;
            }
            unsigned int v17 = v11 + v15++;
            unsigned int v11 = v17 & v10;
            uint64_t v12 = (void *)(*v5 + 16 * (v17 & v10));
            uint64_t v13 = *v12;
            if (v9 == *v12) {
              goto LABEL_7;
            }
          }
          if (v14) {
            uint64_t v12 = v14;
          }
        }
LABEL_7:
        *uint64_t v12 = v9;
        v12[1] = v4[1];
        v4[1] = 0;
        ++*((_DWORD *)v5 + 2);
        uint64_t result = sub_1CC957084(v4 + 1);
      }
      v4 += 2;
    }
    while (v4 != a3);
  }
  return result;
}

uint64_t *sub_1CD673D98(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v4 = 16 * v2;
    unint64_t v5 = (void *)(v3 + 8);
    do
    {
      if (*(v5 - 1) <= 0xFFFFFFFFFFFFFFFDLL) {
        unint64_t v5 = sub_1CC957084(v5);
      }
      v5 += 2;
      v4 -= 16;
    }
    while (v4);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

void *sub_1CD673DF8(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v3 = 3 * a2;
    uint64_t v4 = 24 * a2;
    unint64_t v5 = (char *)operator new(24 * a2);
    *a1 = v5;
    uint64_t v6 = &v5[8 * v3];
    a1[2] = v6;
    int v7 = v5 + 8;
    do
    {
      *int v7 = 0;
      v7[1] = 0;
      *(v7 - 1) = v7;
      v7 += 3;
      v4 -= 24;
    }
    while (v4);
    a1[1] = v6;
  }
  return a1;
}

uint64_t *sub_1CD673E80(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  void *result = *(void *)a2;
  *(void *)a2 = v2;
  uint64_t v5 = result[1];
  uint64_t v4 = result[2];
  uint64_t v3 = result + 1;
  *(_OWORD *)(result + 1) = *(_OWORD *)(a2 + 8);
  *(void *)(a2 + 8) = v5;
  *(void *)(a2 + 16) = v4;
  if (result[2]) {
    uint64_t result = (uint64_t *)(*v3 + 16);
  }
  void *result = (uint64_t)v3;
  uint64_t v6 = (void *)(*(void *)(a2 + 8) + 16);
  if (!v4) {
    uint64_t v6 = (void *)a2;
  }
  *uint64_t v6 = a2 + 8;
  return result;
}

void sub_1CD673ED8(uint64_t a1, void *a2)
{
  uint64_t v4 = (void *)(a1 + 8);
  sub_1CB833A08(a1, *(void **)(a1 + 8));
  *(void *)a1 = *a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = a2[1];
  *uint64_t v4 = v6;
  uint64_t v7 = a2[2];
  *(void *)(a1 + 16) = v7;
  if (v7)
  {
    *(void *)(v6 + 16) = v4;
    *a2 = v5;
    *uint64_t v5 = 0;
    a2[2] = 0;
  }
  else
  {
    *(void *)a1 = v4;
  }
}

void *sub_1CD673F44(void *a1, unint64_t a2)
{
  uint64_t v4 = operator new(0x18uLL);
  a1[1] = v4 + 3;
  a1[2] = v4 + 3;
  v4[1] = 0;
  v4[2] = 0;
  *uint64_t v4 = 0;
  *a1 = v4;
  sub_1CD673F94(a1 + 3, a2);
  return a1;
}

void *sub_1CD673F94(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if (a2 >> 61) {
      abort();
    }
    size_t v4 = 8 * a2;
    uint64_t v5 = (char *)operator new(8 * a2);
    *a1 = v5;
    uint64_t v6 = &v5[8 * a2];
    a1[2] = v6;
    bzero(v5, v4);
    a1[1] = v6;
  }
  return a1;
}

uint64_t sub_1CD674000(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 144) > a2) {
    *(void *)(result + 144) = a2;
  }
  if (*(void *)(result + 152) < a2) {
    *(void *)(result + 152) = a2;
  }
  unsigned int v2 = *(_DWORD *)(result + 8);
  if (v2 >= *(_DWORD *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)result + 8 * v2) = a2;
  ++*(_DWORD *)(result + 8);
  return result;
}

void sub_1CD674080(uint64_t a1, void *a2, void *a3)
{
  if (*(void *)(a1 + 16))
  {
    uint64_t v6 = *(uint64_t **)a1;
    uint64_t v7 = *(void *)(a1 + 8);
    *(void *)a1 = a1 + 8;
    *(void *)(v7 + 16) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 8) = 0;
    uint64_t v8 = v6[1] ? (uint64_t *)v6[1] : v6;
    if (v8)
    {
      uint64_t v12 = sub_1CD4F3428((uint64_t)v8);
      if (a2 != a3)
      {
        int v14 = a2;
        do
        {
          int v15 = v8;
          uint64_t v8 = v12;
          v15[4] = v14[4];
          sub_1CD6741E0((uint64_t **)a1, v15);
          if (v12) {
            uint64_t v12 = sub_1CD4F3428((uint64_t)v12);
          }
          BOOL v16 = (void *)v14[1];
          if (v16)
          {
            do
            {
              a2 = v16;
              BOOL v16 = (void *)*v16;
            }
            while (v16);
          }
          else
          {
            do
            {
              a2 = (void *)v14[2];
              BOOL v11 = *a2 == (void)v14;
              int v14 = a2;
            }
            while (!v11);
          }
          if (!v8) {
            break;
          }
          int v14 = a2;
        }
        while (a2 != a3);
      }
      sub_1CB833A08(a1, v8);
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          uint64_t v12 = (uint64_t *)v12[2];
        }
        while (v12);
        sub_1CB833A08(a1, v13);
      }
    }
  }
  if (a2 != a3)
  {
    do
    {
      sub_1CD5E5034((uint64_t **)a1, a2 + 4);
      uint64_t v9 = (void *)a2[1];
      if (v9)
      {
        do
        {
          int v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v10 = (void *)a2[2];
          BOOL v11 = *v10 == (void)a2;
          a2 = v10;
        }
        while (!v11);
      }
      a2 = v10;
    }
    while (v10 != a3);
  }
}

uint64_t *sub_1CD6741E0(uint64_t **a1, uint64_t *a2)
{
  uint64_t v3 = a1 + 1;
  size_t v4 = a1[1];
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v3 = (uint64_t **)v4;
        if (a2[4] >= (unint64_t)v4[4]) {
          break;
        }
        size_t v4 = (uint64_t *)*v4;
        uint64_t v5 = v3;
        if (!*v3) {
          goto LABEL_8;
        }
      }
      size_t v4 = (uint64_t *)v4[1];
    }
    while (v4);
    uint64_t v5 = v3 + 1;
  }
  else
  {
    uint64_t v5 = a1 + 1;
  }
LABEL_8:
  *a2 = 0;
  a2[1] = 0;
  a2[2] = (uint64_t)v3;
  *uint64_t v5 = a2;
  uint64_t v6 = (uint64_t *)**a1;
  if (v6)
  {
    *a1 = v6;
    a2 = *v5;
  }
  uint64_t result = sub_1CB8358B8(a1[1], a2);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

void sub_1CD674278(long long *a1, uint64_t *a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE1220, 0, 0);
  dword_1EBCE12A0 = 0;
  qword_1EBCE12A8 = (uint64_t)&unk_1F2629508;
  unk_1EBCE12B0 = 0;
  qword_1EBCE1220 = (uint64_t)&unk_1F2629450;
  qword_1EBCE12B8 = (uint64_t)&unk_1F26294B8;
  unk_1EBCE12C0 = &qword_1EBCE1220;
  qword_1EBCE12C8 = (uint64_t)&unk_1EBCE12D8;
  qword_1EBCE12D0 = 0x800000000;
  qword_1EBCE1458 = (uint64_t)&unk_1F2629670;
  qword_1EBCE1470 = (uint64_t)&qword_1EBCE1458;
  sub_1CD67437C(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE1220);
}

void sub_1CD67437C(long long *a1, uint64_t *a2, _WORD *a3)
{
  xmmword_1EBCE1240 = *a1;
  sub_1CC95C734(a2, (uint64_t)&qword_1EBCE1220);
  word_1EBCE122A = (32 * (*a3 & 3)) | word_1EBCE122A & 0xFF9F;
}

void sub_1CD6743F8()
{
}

void *sub_1CD67440C()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1F2629670;
  return result;
}

void sub_1CD674444(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2629670;
}

void sub_1CD674470()
{
}

void sub_1CD674554(long long *a1, _WORD *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCE1050, 0, 0);
  qword_1EBCE10D0 = 0;
  qword_1EBCE10D8 = 0;
  qword_1EBCE10F8 = 0;
  unk_1EBCE1100 = 0;
  byte_1EBCE1108 = 0;
  qword_1EBCE10F0 = 0;
  unk_1EBCE10E0 = 0;
  unk_1EBCE10E8 = &unk_1F2643C20;
  qword_1EBCE1050 = (uint64_t)&unk_1F2643FD0;
  qword_1EBCE1110 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCE1118 = (uint64_t)&unk_1F25F6428;
  qword_1EBCE1130 = (uint64_t)&qword_1EBCE1118;
  llvm::cl::Option::setArgStr(v4, "lowertypetests-read-summary", 0x1BuLL);
  xmmword_1EBCE1070 = *a1;
  word_1EBCE105A = (32 * (*a2 & 3)) | word_1EBCE105A & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE1050);
}

void sub_1CD67466C(long long *a1, _WORD *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCE1138, 0, 0);
  qword_1EBCE11B8 = 0;
  qword_1EBCE11C0 = 0;
  qword_1EBCE11E0 = 0;
  unk_1EBCE11E8 = 0;
  byte_1EBCE11F0 = 0;
  qword_1EBCE11D8 = 0;
  unk_1EBCE11C8 = 0;
  unk_1EBCE11D0 = &unk_1F2643C20;
  qword_1EBCE1138 = (uint64_t)&unk_1F2643FD0;
  qword_1EBCE11F8 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCE1200 = (uint64_t)&unk_1F25F6428;
  qword_1EBCE1218 = (uint64_t)&qword_1EBCE1200;
  llvm::cl::Option::setArgStr(v4, "lowertypetests-write-summary", 0x1CuLL);
  xmmword_1EBCE1158 = *a1;
  word_1EBCE1142 = (32 * (*a2 & 3)) | word_1EBCE1142 & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE1138);
}

void sub_1CD674784(unint64_t *a1, size_t a2)
{
  uint64_t v5 = (char *)a1[1];
  uint64_t v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }
    a1[1] = (unint64_t)v5;
  }
  else
  {
    unint64_t v6 = *a1;
    uint64_t v7 = &v5[-*a1];
    unint64_t v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0) {
      abort();
    }
    unint64_t v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10) {
      unint64_t v11 = (unint64_t)operator new(v10);
    }
    else {
      unint64_t v11 = 0;
    }
    uint64_t v12 = &v7[v11];
    uint64_t v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      unint64_t v11 = (unint64_t)v12;
    }
    else
    {
      int v14 = &v5[~v6];
      do
      {
        char v15 = *--v5;
        (v14--)[v11] = v15;
      }
      while (v5 != (char *)v6);
      uint64_t v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void llvm::createMergeFunctionsPass(llvm *this)
{
}

void *llvm::MergeFunctionsPass::run@<X0>(llvm::Function *a1@<X1>, uint64_t a2@<X8>)
{
  sub_1CC95CD34((uint64_t)v8);
  if (sub_1CC95CDA0((uint64_t)v8, a1, v4))
  {
    int v5 = 0;
    *(void *)(a2 + 88) = 0;
    *(_OWORD *)(a2 + 72) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 24) = 0u;
    uint64_t v6 = a2 + 32;
  }
  else
  {
    *(void *)(a2 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
    uint64_t v6 = a2 + 32;
    int v5 = 1;
  }
  *(void *)a2 = v6;
  *(void *)(a2 + 8) = v6;
  *(_DWORD *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 20) = v5;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 48) = a2 + 80;
  *(void *)(a2 + 56) = a2 + 80;
  *(void *)(a2 + 64) = 2;
  *(_DWORD *)(a2 + 72) = 0;
  return sub_1CC95DAFC(v8);
}

void *sub_1CD6749A0(void *result)
{
  result[1] = 0;
  v10[0] = 2;
  v10[1] = 0;
  uint64_t v11 = -4096;
  uint64_t v12 = 0;
  uint64_t v1 = *((unsigned int *)result + 4);
  if (v1)
  {
    unsigned int v2 = result;
    uint64_t result = v10;
    uint64_t v3 = *v2;
    uint64_t v4 = 48 * v1;
    int v5 = (void *)(*v2 + 16);
    do
    {
      uint64_t v6 = v10[0] & 6;
      *(v5 - 1) = v6;
      *int v5 = 0;
      uint64_t v7 = v11;
      v5[1] = v11;
      if (v7 != -8192 && v7 != -4096 && v7 != 0)
      {
        unint64_t v9 = v10[0] & 0xFFFFFFFFFFFFFFF8;
        *int v5 = *(void *)(v10[0] & 0xFFFFFFFFFFFFFFF8);
        *(void *)unint64_t v9 = v5 - 1;
        *(v5 - 1) = v9 | v6;
        if (*v5) {
          *(void *)*int v5 = *(void *)*v5 & 7 | (v3 + 16);
        }
      }
      *(v5 - 2) = &unk_1F2629758;
      uint64_t v5[2] = v12;
      v5 += 6;
      v3 += 48;
      v4 -= 48;
    }
    while (v4);
    if (v11 != -8192 && v11 != -4096)
    {
      if (v11) {
        return llvm::ValueHandleBase::RemoveFromUseList(v10);
      }
    }
  }
  return result;
}

void *sub_1CD674ACC(uint64_t a1)
{
  sub_1CC008720(v6, (void *)(a1 + 8));
  uint64_t v2 = *(void *)(a1 + 32);
  int v5 = &unk_1F2629758;
  uint64_t v8 = v2;
  uint64_t result = (void *)sub_1CD674BD4(v2, (uint64_t)&v5);
  if (v7 != -8192 && v7 != -4096 && v7 != 0) {
    return llvm::ValueHandleBase::RemoveFromUseList(v6);
  }
  return result;
}

void *sub_1CD674B5C(uint64_t a1)
{
  uint64_t result = sub_1CC008720(&v4, (void *)(a1 + 8));
  uint64_t v6 = *(void *)(a1 + 32);
  if (v5 != -8192 && v5 != -4096 && v5 != 0) {
    return llvm::ValueHandleBase::RemoveFromUseList(result);
  }
  return result;
}

uint64_t sub_1CD674BD4(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0;
  uint64_t v3 = sub_1CD5323B4((uint64_t *)a1, a2, (uint64_t *)&v8);
  if (v3)
  {
    uint64_t v4 = v8;
    v9[0] = 2;
    v9[1] = 0;
    uint64_t v10 = -8192;
    unint64_t v11 = 0;
    uint64_t v8 = (unint64_t *)&unk_1F2629758;
    sub_1CBF62D84(v4 + 1, v9);
    uint64_t v5 = v10;
    v4[4] = v11;
    if (v5 != -8192 && v5 != -4096 && v5 != 0) {
      llvm::ValueHandleBase::RemoveFromUseList(v9);
    }
    *(int32x2_t *)(a1 + 8) = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
  }
  return v3;
}

void *sub_1CD674CA0(void *result)
{
  uint64_t v1 = *((unsigned int *)result + 4);
  if (v1)
  {
    uint64_t v11 = 2;
    uint64_t v12 = 0;
    uint64_t v13 = -4096;
    uint64_t v14 = 0;
    uint64_t v9 = 0;
    uint64_t v10 = &unk_1F2629758;
    uint64_t v6 = 2;
    uint64_t v7 = 0;
    uint64_t v8 = -8192;
    uint64_t v2 = 48 * v1;
    uint64_t v3 = (uint64_t *)(*result + 24);
    do
    {
      uint64_t v4 = *v3;
      if (*v3 != -8192 && v4 != -4096 && v4 != 0) {
        uint64_t result = llvm::ValueHandleBase::RemoveFromUseList(v3 - 2);
      }
      v3 += 6;
      v2 -= 48;
    }
    while (v2);
  }
  return result;
}

void sub_1CD674DB4(__n128 *a1, __n128 *a2, unint64_t a3, __n128 *a4, uint64_t a5, __n128 a6)
{
  if (a3 >= 2)
  {
    uint64_t v7 = a1;
    if (a3 == 2)
    {
      unint64_t v8 = a2[-1].n128_u64[0];
      unint64_t v9 = a1->n128_u64[0];
      if (v8 < a1->n128_u64[0])
      {
        unint64_t v10 = a1->n128_u64[1];
        unint64_t v11 = a2[-1].n128_u64[1];
        a1->n128_u64[0] = v8;
        a1->n128_u64[1] = v11;
        a2[-1].n128_u64[0] = v9;
        a2[-1].n128_u64[1] = v10;
      }
    }
    else if ((uint64_t)a3 > 0)
    {
      std::string::size_type v25 = (char *)a4;
      unint64_t v26 = a3 >> 1;
      unsigned int v27 = &a1[a3 >> 1];
      unint64_t v28 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        __n128 v29 = sub_1CD674FF4(a1, v27, v28, a4, a6);
        uint64_t v30 = (__n128 *)&v25[16 * v26];
        sub_1CD674FF4(&v7[a3 >> 1], a2, a3 - (a3 >> 1), v30, v29);
        int v31 = &v25[16 * a3];
        __int16 v32 = v30;
        while (v32 != (__n128 *)v31)
        {
          unint64_t v33 = v32->n128_u64[0];
          if (v32->n128_u64[0] < *(void *)v25)
          {
            __int16 v34 = v32;
          }
          else
          {
            unint64_t v33 = *(void *)v25;
            __int16 v34 = (__n128 *)v25;
          }
          unint64_t v35 = v34->n128_u64[1];
          if (v32->n128_u64[0] < *(void *)v25) {
            ++v32;
          }
          else {
            v25 += 16;
          }
          v7->n128_u64[0] = v33;
          v7->n128_u64[1] = v35;
          ++v7;
          if (v25 == (char *)v30)
          {
            if (v32 != (__n128 *)v31)
            {
              uint64_t v36 = 0;
              do
              {
                unint64_t v37 = &v7[v36];
                unint64_t v39 = v32[v36].n128_u64[1];
                uint64_t v38 = (uint64_t)&v32[v36 + 1];
                v37->n128_u64[0] = v32[v36].n128_u64[0];
                v37->n128_u64[1] = v39;
                ++v36;
              }
              while ((char *)v38 != v31);
            }
            return;
          }
        }
        if (v25 != (char *)v30)
        {
          unint64_t v40 = 0;
          do
          {
            v41 = &v7[v40 / 0x10];
            unint64_t v43 = *(void *)&v25[v40 + 8];
            uint64_t v42 = (uint64_t)&v25[v40 + 16];
            v41->n128_u64[0] = *(void *)&v25[v40];
            v41->n128_u64[1] = v43;
            v40 += 16;
          }
          while ((__n128 *)v42 != v30);
        }
      }
      else
      {
        sub_1CD674DB4(a1, v27, v28, a4, a5);
        sub_1CD674DB4(&v7[a3 >> 1], a2, a3 - (a3 >> 1), v25, a5);
        sub_1CC95DD48((char *)v7, (char *)&v7[a3 >> 1], (char *)a2, a3 >> 1, a3 - (a3 >> 1), v25, a5);
      }
    }
    else if (a1 != a2)
    {
      uint64_t v13 = a1 + 1;
      if (&a1[1] != a2)
      {
        uint64_t v14 = 0;
        char v15 = a1;
        do
        {
          BOOL v16 = v13;
          unint64_t v17 = v13->n128_u64[0];
          unint64_t v18 = v15->n128_u64[0];
          if (v17 < v15->n128_u64[0])
          {
            unint64_t v19 = v15[1].n128_u64[1];
            uint64_t v20 = v14;
            while (1)
            {
              BOOL v21 = (char *)a1 + v20;
              uint64_t v22 = *(uint64_t *)((char *)&a1->n128_i64[1] + v20);
              *((void *)v21 + 2) = v18;
              *((void *)v21 + 3) = v22;
              if (!v20) {
                break;
              }
              unint64_t v18 = *((void *)v21 - 2);
              v20 -= 16;
              if (v17 >= v18)
              {
                unsigned int v23 = (__n128 *)((char *)a1 + v20 + 16);
                goto LABEL_16;
              }
            }
            unsigned int v23 = a1;
LABEL_16:
            v23->n128_u64[0] = v17;
            v23->n128_u64[1] = v19;
          }
          uint64_t v13 = v16 + 1;
          v14 += 16;
          char v15 = v16;
        }
        while (&v16[1] != a2);
      }
    }
  }
}

__n128 sub_1CD674FF4(__n128 *a1, __n128 *a2, unint64_t a3, __n128 *a4, __n128 result)
{
  if (a3)
  {
    uint64_t v5 = a4;
    unint64_t v8 = a1;
    if (a3 == 2)
    {
      unint64_t v9 = a2 - 1;
      if (a2[-1].n128_u64[0] >= a1->n128_u64[0])
      {
        *a4 = *a1;
        uint64_t result = *v9;
      }
      else
      {
        *a4 = *v9;
        uint64_t result = *a1;
      }
      a4[1] = result;
    }
    else if (a3 == 1)
    {
      uint64_t result = *a1;
      *a4 = *a1;
    }
    else if ((uint64_t)a3 > 8)
    {
      BOOL v21 = &a1[a3 >> 1];
      sub_1CD674DB4(a1, v21, a3 >> 1, a4, a3 >> 1);
      sub_1CD674DB4(&v8[a3 >> 1], a2, a3 - (a3 >> 1), &v5[a3 >> 1], a3 - (a3 >> 1));
      uint64_t v22 = &v8[a3 >> 1];
      while (v22 != a2)
      {
        if (v22->n128_u64[0] >= v8->n128_u64[0])
        {
          __n128 v24 = *v8++;
          uint64_t result = v24;
        }
        else
        {
          __n128 v23 = *v22++;
          uint64_t result = v23;
        }
        *v5++ = result;
        if (v8 == v21)
        {
          if (v22 != a2)
          {
            uint64_t v25 = 0;
            do
            {
              uint64_t result = v22[v25];
              v5[v25++] = result;
            }
            while (&v22[v25] != a2);
          }
          return result;
        }
      }
      if (v8 != v21)
      {
        uint64_t v26 = 0;
        do
        {
          uint64_t result = v8[v26];
          v5[v26++] = result;
        }
        while (&v8[v26] != v21);
      }
    }
    else if (a1 != a2)
    {
      uint64_t result = *a1;
      *a4 = *a1;
      unint64_t v10 = a1 + 1;
      if (&a1[1] != a2)
      {
        uint64_t v11 = 0;
        uint64_t v12 = a4;
        uint64_t v13 = a4;
        do
        {
          uint64_t v14 = v10;
          unint64_t v15 = v13->n128_u64[0];
          ++v13;
          if (v10->n128_u64[0] >= v15)
          {
            uint64_t result = *v10;
            *uint64_t v13 = *v10;
          }
          else
          {
            uint64_t result = *v12;
            *uint64_t v13 = *v12;
            BOOL v16 = a4;
            if (v12 != a4)
            {
              uint64_t v17 = v11;
              while (1)
              {
                BOOL v16 = (__n128 *)((char *)a4 + v17);
                unint64_t v18 = *(unint64_t *)((char *)a4[-1].n128_u64 + v17);
                if (v14->n128_u64[0] >= v18) {
                  break;
                }
                uint64_t v19 = v16[-1].n128_i64[1];
                v16->n128_u64[0] = v18;
                v16->n128_u64[1] = v19;
                v17 -= 16;
                if (!v17)
                {
                  BOOL v16 = a4;
                  break;
                }
              }
            }
            unint64_t v20 = v8[1].n128_u64[1];
            v16->n128_u64[0] = v14->n128_u64[0];
            v16->n128_u64[1] = v20;
          }
          unint64_t v10 = v14 + 1;
          v11 += 16;
          uint64_t v12 = v13;
          unint64_t v8 = v14;
        }
        while (&v14[1] != a2);
      }
    }
  }
  return result;
}

uint64_t sub_1CD6751F8(uint64_t a1)
{
  return a1;
}

uint64_t sub_1CD675234(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = (llvm::ValueHandleBase *)a1[1];
  if ((unint64_t)v3 >= a1[2])
  {
    uint64_t result = sub_1CC95F8DC(a1, a2);
  }
  else
  {
    *(void *)uint64_t v3 = 6;
    *((void *)v3 + 1) = 0;
    *((void *)v3 + 2) = a2;
    if (a2 != -8192 && a2 != -4096 && a2) {
      llvm::ValueHandleBase::AddToUseList(v3);
    }
    uint64_t result = (uint64_t)v3 + 24;
  }
  a1[1] = result;
  return result;
}

int32x2_t sub_1CD67529C(int32x2_t *a1, uint64_t a2)
{
  v7[0] = 2;
  v7[1] = 0;
  uint64_t v8 = -8192;
  uint64_t v9 = 0;
  sub_1CBF62D84((unint64_t *)(a2 + 8), v7);
  uint64_t v4 = v8;
  *(void *)(a2 + 32) = v9;
  if (v4 != -8192 && v4 != -4096 && v4 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList(v7);
  }
  int32x2_t result = vadd_s32(a1[1], (int32x2_t)0x1FFFFFFFFLL);
  a1[1] = result;
  return result;
}

void **sub_1CD675348(void **result)
{
  uint64_t v1 = result;
  int v2 = *((_DWORD *)result + 2);
  if (v2 || *((_DWORD *)result + 3))
  {
    uint64_t v3 = *((unsigned int *)result + 4);
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      return sub_1CD6754B4(result);
    }
    else
    {
      v12[0] = 2;
      v12[1] = 0;
      uint64_t v13 = -4096;
      uint64_t v14 = 0;
      uint64_t v10 = 0;
      uint64_t v11 = &unk_1F2629758;
      v8[0] = 2;
      v8[1] = 0;
      uint64_t v9 = -8192;
      if (v3)
      {
        uint64_t v4 = 48 * v3;
        uint64_t v5 = (char *)*result + 32;
        do
        {
          int32x2_t result = (void **)sub_1CBF62D84(v5 - 3, v12);
          *uint64_t v5 = v14;
          v5 += 6;
          v4 -= 48;
        }
        while (v4);
        uint64_t v6 = v9;
        v1[1] = 0;
        if (v6 != -8192 && v6 != -4096 && v6 != 0) {
          int32x2_t result = (void **)llvm::ValueHandleBase::RemoveFromUseList(v8);
        }
      }
      else
      {
        result[1] = 0;
      }
      if (v13 != -8192 && v13 != -4096)
      {
        if (v13) {
          return (void **)llvm::ValueHandleBase::RemoveFromUseList(v12);
        }
      }
    }
  }
  return result;
}

void **sub_1CD6754B4(void *a1)
{
  int v2 = *((_DWORD *)a1 + 2);
  sub_1CD674CA0(a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    int v4 = v3;
  }
  else {
    int v4 = 0;
  }
  if (v4 == *((_DWORD *)a1 + 4))
  {
    return (void **)sub_1CD6749A0(a1);
  }
  else
  {
    MEMORY[0x1D25D9CD0](*a1, 8);
    return sub_1CC95DCB0((void **)a1, v4);
  }
}

uint64_t llvm::ModuleInlinerPass::getAdvisor(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result) {
    llvm::AnalysisManager<llvm::Module>::getCachedResultImpl();
  }
  return result;
}

uint64_t llvm::AAExecutionDomain::createForPosition(llvm::AAExecutionDomain *this, uint64_t **a2, llvm::Attributor *a3)
{
  if (sub_1CD647DEC(this) != 4) {
    return 0;
  }
  uint64_t result = sub_1CB906F34(a2[3], 336, 3);
  *(_OWORD *)(result + 16) = *(_OWORD *)this;
  *(_WORD *)(result + 40) = 256;
  *(void *)uint64_t result = &unk_1F2629780;
  *(void *)(result + 8) = 0;
  *(void *)(result + 32) = &unk_1F2629810;
  *(void *)(result + 48) = 1;
  uint64_t v6 = 56;
  int64x2_t v7 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  do
  {
    *(int64x2_t *)(result + v6) = v7;
    v6 += 16;
  }
  while (v6 != 184);
  *(void *)(result + 184) = result + 200;
  *(void *)(result + 192) = 0x1000000000;
  *(void *)(result + 328) = 0;
  return result;
}

uint64_t llvm::omp::getDeviceKernels@<X0>(llvm::omp *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = llvm::Module::getOrInsertNamedMetadata(this, "nvvm.annotations", 0x10uLL);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 24) = 0;
  if (result)
  {
    uint64_t v5 = (llvm::NamedMDNode *)result;
    uint64_t result = llvm::NamedMDNode::getNumOperands((llvm::NamedMDNode *)result);
    if (result)
    {
      int v6 = result;
      for (unsigned int i = 0; i != v6; ++i)
      {
        uint64_t result = llvm::NamedMDNode::getOperand(v5, i);
        uint64_t v8 = *(unsigned int *)(result + 8);
        if (v8 >= 2)
        {
          uint64_t v9 = (uint64_t *)(result - 8 * v8);
          uint64_t v10 = v9[1];
          if (!*(unsigned char *)v10)
          {
            uint64_t v11 = *(void *)(v10 + 8);
            if (*(void *)v11 == 6)
            {
              int v12 = *(_DWORD *)(v11 + 24);
              int v13 = *(unsigned __int16 *)(v11 + 28);
              if (v12 == 1852990827 && v13 == 27749)
              {
                uint64_t v17 = 0;
                uint64_t v15 = *v9;
                if (v15)
                {
                  if (*(unsigned char *)v15 == 1)
                  {
                    uint64_t v16 = *(void *)(v15 + 128);
                    if (!*(unsigned char *)(v16 + 16))
                    {
                      uint64_t v17 = v16;
                      uint64_t result = sub_1CC8B0F60((void *)a2, &v17);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void llvm::OpenMPOptCGSCCPass::run(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  MEMORY[0x1F4188790](a1, a2, a3, a4);
  uint64_t v5 = v4;
  uint64_t v7 = v6;
  v15[16] = *MEMORY[0x1E4F143B8];
  if (llvm::Module::getModuleFlag(*(llvm::Module **)(*(void *)(**(void **)(v4 + 8) + 8) + 40), "openmp", 6uLL)
    && !byte_1EBCE1818)
  {
    int v13 = v15;
    uint64_t v14 = 0x1000000000;
    uint64_t v8 = *(unsigned int *)(v5 + 16);
    if (v8)
    {
      unsigned int v9 = 0;
      uint64_t v10 = *(void *)(v5 + 8);
      uint64_t v11 = 8 * v8;
      do
      {
        if (v9 >= HIDWORD(v14)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        v13[v9] = *(void *)(*(void *)v10 + 8);
        unsigned int v9 = v14 + 1;
        LODWORD(v14) = v14 + 1;
        v10 += 8;
        v11 -= 8;
      }
      while (v11);
      if (v9)
      {
        llvm::omp::getDeviceKernels(*(llvm::omp **)(*(void *)(**(void **)(v5 + 8) + 8) + 40), (uint64_t)v12);
        llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::getResultImpl();
      }
    }
    *(void *)(v7 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
    *(void *)uint64_t v7 = v7 + 32;
    *(void *)(v7 + 8) = v7 + 32;
    *(_DWORD *)(v7 + 24) = 0;
    *(void *)(v7 + 48) = v7 + 80;
    *(void *)(v7 + 56) = v7 + 80;
    *(void *)(v7 + 64) = 2;
    *(_DWORD *)(v7 + 72) = 0;
    *(void *)(v7 + 16) = 0x100000002;
    if (v13 != v15) {
      free(v13);
    }
  }
  else
  {
    *(void *)(v7 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
    *(void *)uint64_t v7 = v7 + 32;
    *(void *)(v7 + 8) = v7 + 32;
    *(_DWORD *)(v7 + 24) = 0;
    *(void *)(v7 + 48) = v7 + 80;
    *(void *)(v7 + 56) = v7 + 80;
    *(void *)(v7 + 64) = 2;
    *(_DWORD *)(v7 + 72) = 0;
    *(void *)(v7 + 16) = 0x100000002;
  }
}

void llvm::createOpenMPOptCGSCCLegacyPass(llvm *this)
{
}

void sub_1CD675D20(char *a1@<X8>)
{
  a1[23] = 17;
  strcpy(a1, "AAExecutionDomain");
}

void *sub_1CD675D44()
{
  return &llvm::AAExecutionDomain::ID;
}

uint64_t sub_1CD675D50(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = &llvm::AAExecutionDomain::ID;
  long long v6 = *(_OWORD *)(a2 + 16);
  sub_1CD64CF70((uint64_t *)(a1 + 32), (uint64_t)&v5)[3] = a2;
  if (*(_DWORD *)(a1 + 4368) <= 1u) {
    sub_1CD64B90C((unint64_t *)(a1 + 104), a2);
  }
  return a2;
}

uint64_t sub_1CD675DC0(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  if (sub_1CD5297D8(a1, a2, &v6)) {
    return v6;
  }
  uint64_t v4 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    uint64_t v5 = 16;
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 16);
  }
  return v4 + 8 * v5;
}

double sub_1CD675E20(uint64_t a1, uint64_t *a2)
{
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x800000000;
  *(void *)(a1 + 336) = a2;
  uint64_t v2 = *a2;
  *(void *)(a1 + 344) = a1 + 360;
  *(void *)(a1 + 352) = 0x200000000;
  *(void *)(a1 + 408) = v2;
  *(void *)(a1 + 416) = a1 + 464;
  *(void *)(a1 + 424) = a1 + 472;
  *(void *)(a1 + 432) = 0;
  *(_DWORD *)(a1 + 440) = 0;
  *(_WORD *)(a1 + 444) = 512;
  *(unsigned char *)(a1 + 446) = 7;
  double result = 0.0;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(void *)(a1 + 464) = &unk_1F2616E88;
  *(void *)(a1 + 472) = &unk_1F2617008;
  *(_DWORD *)(a1 + 496) = 0;
  *(_OWORD *)(a1 + 480) = 0u;
  *(_DWORD *)(a1 + 500) = 16;
  *(_DWORD *)(a1 + 528) = 0;
  *(_OWORD *)(a1 + 512) = 0u;
  *(void *)(a1 + 536) = a1 + 552;
  *(void *)(a1 + 544) = 0x1000000000;
  *(void *)(a1 + 1976) = 0;
  *(_OWORD *)(a1 + 1960) = 0u;
  *(void *)(a1 + 1984) = 0x1000000000;
  *(void *)(a1 + 1992) = 0;
  *(void *)(a1 + 2000) = 0;
  *(void *)(a1 + 2008) = a1 + 2024;
  *(void *)(a1 + 2016) = 0x400000000;
  *(void *)(a1 + 2056) = a1 + 2072;
  *(void *)(a1 + 2064) = 0;
  *(void *)(a1 + 2072) = 0;
  *(void *)(a1 + 2080) = 1;
  *(_OWORD *)(a1 + 2088) = 0u;
  *(_OWORD *)(a1 + 2104) = 0u;
  *(_OWORD *)(a1 + 2120) = 0u;
  *(_OWORD *)(a1 + 2136) = 0u;
  *(_OWORD *)(a1 + 2152) = 0u;
  *(_OWORD *)(a1 + 2168) = 0u;
  *(_OWORD *)(a1 + 2184) = 0u;
  *(_OWORD *)(a1 + 2200) = 0u;
  *(_OWORD *)(a1 + 2216) = 0u;
  *(_OWORD *)(a1 + 2232) = 0u;
  *(_OWORD *)(a1 + 2248) = 0u;
  *(_OWORD *)(a1 + 2264) = 0u;
  *(_OWORD *)(a1 + 2280) = 0u;
  *(_OWORD *)(a1 + 2296) = 0u;
  *(_OWORD *)(a1 + 2312) = 0u;
  *(_OWORD *)(a1 + 2328) = 0u;
  *(_OWORD *)(a1 + 2344) = 0u;
  *(_OWORD *)(a1 + 2360) = 0u;
  *(_OWORD *)(a1 + 2376) = 0u;
  *(_OWORD *)(a1 + 2392) = 0u;
  *(_OWORD *)(a1 + 2408) = 0u;
  return result;
}

void *sub_1CD675F64(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD45B528(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD675FD4(a1, a2, v7);
    *uint64_t v5 = *a2;
    v5[1] = 0;
    uint64_t v5[2] = 0;
  }
  return v5;
}

void *sub_1CD675FD4(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD676088(a1, v6);
  uint64_t v8 = 0;
  sub_1CD45B528(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD676088(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  double result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD676160(a1, v4, v4 + 24 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 24 * v10;
    do
    {
      void *result = -4096;
      result += 3;
      v11 -= 24;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD676160(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 24 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 3;
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      double result = sub_1CD45B528(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      uint64_t v10 = v11;
      *uint64_t v11 = *(void *)a2;
      *(_OWORD *)(v10 + 1) = *(_OWORD *)(a2 + 8);
      *(void *)(a2 + 8) = 0;
      *(void *)(a2 + 16) = 0;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 24;
  }
  return result;
}

void sub_1CD676220(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2629870;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1CD676240(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2629870;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD676294(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2 != (void *)(a1 + 40)) {
    free(v2);
  }
}

void *sub_1CD6762B4(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }
  MEMORY[0x1D25D9CD0](*a1, 1);
  return a1;
}

uint64_t sub_1CD6762F4(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    sub_1CC9860BC(a1, a2);
    sub_1CC986134((void *)(a1 + 24), *(char **)(a2 + 24), *(char **)(a2 + 32), *(void *)(a2 + 32) - *(void *)(a2 + 24));
  }
  return a1;
}

unsigned __int8 *sub_1CD67633C(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  if (!v6)
  {
    uint64_t v14 = 0;
LABEL_6:
    double result = sub_1CD676420(a2, a3, v14);
    unsigned __int8 *result = *a3;
    uint64_t v7 = *(void *)a2;
    unsigned int v6 = *(_DWORD *)(a2 + 16);
    char v13 = 1;
    goto LABEL_4;
  }
  uint64_t v7 = *(void *)a2;
  int v8 = *a3;
  uint64_t v9 = v6 - 1;
  uint64_t v10 = (37 * v8) & v9;
  double result = (unsigned __int8 *)(*(void *)a2 + v10);
  int v12 = *result;
  if (v8 != v12)
  {
    uint64_t v15 = 0;
    int v16 = 1;
    while (v12 != 255)
    {
      if (v15) {
        BOOL v17 = 0;
      }
      else {
        BOOL v17 = v12 == 254;
      }
      if (v17) {
        uint64_t v15 = result;
      }
      uint64_t v18 = (v10 + v16++);
      LODWORD(v10) = v18 & v9;
      double result = (unsigned __int8 *)(v7 + (v18 & v9));
      int v12 = *result;
      if (v8 == v12) {
        goto LABEL_3;
      }
    }
    if (v15) {
      uint64_t v14 = v15;
    }
    else {
      uint64_t v14 = result;
    }
    goto LABEL_6;
  }
LABEL_3:
  char v13 = 0;
LABEL_4:
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v7 + v6;
  *(unsigned char *)(a1 + 16) = v13;
  return result;
}

unsigned __int8 *sub_1CD676420(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_3;
    }
    sub_1CD6765A8(a1, v6);
    int v17 = *(_DWORD *)(a1 + 16);
    if (v17)
    {
      int v18 = *a2;
      uint64_t v19 = (v17 - 1);
      uint64_t v20 = (37 * v18) & v19;
      a3 = (unsigned __int8 *)(*(void *)a1 + v20);
      int v21 = *a3;
      if (v18 == v21) {
        goto LABEL_3;
      }
      char v13 = 0;
      int v22 = 1;
      while (v21 != 255)
      {
        if (v13) {
          BOOL v23 = 0;
        }
        else {
          BOOL v23 = v21 == 254;
        }
        if (v23) {
          char v13 = a3;
        }
        uint64_t v24 = (v20 + v22++);
        LODWORD(v20) = v24 & v19;
        a3 = (unsigned __int8 *)(*(void *)a1 + (v24 & v19));
        int v21 = *a3;
        if (v18 == v21) {
          goto LABEL_3;
        }
      }
      goto LABEL_21;
    }
LABEL_24:
    a3 = 0;
    goto LABEL_3;
  }
  sub_1CD6765A8(a1, 2 * v6);
  int v8 = *(_DWORD *)(a1 + 16);
  if (!v8) {
    goto LABEL_24;
  }
  int v9 = *a2;
  uint64_t v10 = (v8 - 1);
  uint64_t v11 = (37 * v9) & v10;
  a3 = (unsigned __int8 *)(*(void *)a1 + v11);
  int v12 = *a3;
  if (v9 == v12) {
    goto LABEL_3;
  }
  char v13 = 0;
  int v14 = 1;
  while (v12 != 255)
  {
    if (v13) {
      BOOL v15 = 0;
    }
    else {
      BOOL v15 = v12 == 254;
    }
    if (v15) {
      char v13 = a3;
    }
    uint64_t v16 = (v11 + v14++);
    LODWORD(v11) = v16 & v10;
    a3 = (unsigned __int8 *)(*(void *)a1 + (v16 & v10));
    int v12 = *a3;
    if (v9 == v12) {
      goto LABEL_3;
    }
  }
LABEL_21:
  if (v13) {
    a3 = v13;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != 255) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD6765A8(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(unsigned __int8 **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    size_t v8 = (v7 + 1);
  }
  else {
    size_t v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  double result = operator new(v8, (std::align_val_t)1uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD676680((void *)a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  size_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    return memset(result, 255, v10);
  }
  return result;
}

void *sub_1CD676680(void *result, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unint64_t v5 = result;
  result[1] = 0;
  size_t v6 = *((unsigned int *)result + 4);
  if (v6) {
    double result = memset((void *)*result, 255, v6);
  }
  for (; a2 != a3; ++a2)
  {
    unsigned int v7 = *a2;
    if (v7 <= 0xFD)
    {
      uint64_t v8 = (*((_DWORD *)v5 + 4) - 1);
      uint64_t v9 = v8 & (37 * v7);
      size_t v10 = (unsigned char *)(*v5 + v9);
      int v11 = *v10;
      if (v7 != v11)
      {
        int v12 = 0;
        int v13 = 1;
        while (v11 != 255)
        {
          if (v12) {
            BOOL v14 = 0;
          }
          else {
            BOOL v14 = v11 == 254;
          }
          if (v14) {
            int v12 = v10;
          }
          uint64_t v15 = (v9 + v13++);
          LODWORD(v9) = v15 & v8;
          size_t v10 = (unsigned char *)(*v5 + (v15 & v8));
          int v11 = *v10;
          if (v7 == v11) {
            goto LABEL_6;
          }
        }
        if (v12) {
          size_t v10 = v12;
        }
      }
LABEL_6:
      *size_t v10 = v7;
      ++*((_DWORD *)v5 + 2);
    }
  }
  return result;
}

uint64_t sub_1CD67676C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v12 = 0;
  uint64_t result = sub_1CBFFD518((uint64_t *)a2, a3, &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CC01F6A4(a2, (uint64_t)a3, a3, v12);
    uint64_t v9 = (void *)result;
    *(void *)uint64_t result = *a3;
    *(void *)(result + 8) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

void sub_1CD676808(unsigned int *a1)
{
  unsigned int v2 = a1[2];
  if (!v2 && !a1[3]) {
    return;
  }
  uint64_t v3 = a1[4];
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_13:
      *((void *)a1 + 1) = 0;
      return;
    }
    uint64_t v4 = *(void **)a1;
    uint64_t v5 = 24 * v3;
    while (1)
    {
      if (*v4 == -8192) {
        goto LABEL_11;
      }
      if (*v4 != -4096) {
        break;
      }
LABEL_12:
      v4 += 3;
      v5 -= 24;
      if (!v5) {
        goto LABEL_13;
      }
    }
    size_t v6 = (std::__shared_weak_count *)v4[2];
    if (v6)
    {
      if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
LABEL_11:
    *uint64_t v4 = -4096;
    goto LABEL_12;
  }

  sub_1CD67690C(a1);
}

void sub_1CD67690C(unsigned int *a1)
{
  unsigned int v2 = a1[2];
  sub_1CD6769C0(a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4 == a1[4])
  {
    *((void *)a1 + 1) = 0;
    if (v4)
    {
      uint64_t v5 = *(void **)a1;
      uint64_t v6 = 24 * v4;
      do
      {
        *uint64_t v5 = -4096;
        v5 += 3;
        v6 -= 24;
      }
      while (v6);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CBC04E60(a1, v4);
  }
}

void sub_1CD6769C0(unsigned int *a1)
{
  uint64_t v1 = a1[4];
  if (v1)
  {
    uint64_t v2 = 24 * v1;
    int v3 = (std::__shared_weak_count **)(*(void *)a1 + 16);
    do
    {
      if (((unint64_t)*(v3 - 2) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v4 = *v3;
        if (*v3)
        {
          if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
            std::__shared_weak_count::__release_weak(v4);
          }
        }
      }
      v3 += 3;
      v2 -= 24;
    }
    while (v2);
  }
}

void sub_1CD676A68(uint64_t a1, unint64_t a2)
{
  if (*(unsigned int *)(a1 + 12) < a2)
  {
    *(_DWORD *)(a1 + 8) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unint64_t v4 = *(unsigned int *)(a1 + 8);
  if (v4 >= a2) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = *(unsigned int *)(a1 + 8);
  }
  if (v5) {
    bzero(*(void **)a1, 8 * v5);
  }
  if (a2 > v4) {
    bzero((void *)(*(void *)a1 + 8 * v4), 8 * (a2 - v4));
  }
  *(_DWORD *)(a1 + 8) = a2;
}

void sub_1CD676AFC(uint64_t a1)
{
  int v2 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 <= 1u && !*(_DWORD *)(a1 + 4)) {
    return;
  }
  if (v2)
  {
    unint64_t v5 = (void *)(a1 + 8);
    uint64_t v6 = (void *)(a1 + 296);
    while (1)
    {
LABEL_9:
      if (*v5 == -8192) {
        goto LABEL_13;
      }
      if (*v5 != -4096) {
        break;
      }
LABEL_14:
      v5 += 9;
      if (v5 == v6)
      {
        unsigned int v4 = *(_DWORD *)a1 & 1;
        goto LABEL_16;
      }
    }
    unsigned int v7 = (void *)v5[2];
    if (v7 != (void *)v5[1]) {
      free(v7);
    }
LABEL_13:
    *unint64_t v5 = -4096;
    goto LABEL_14;
  }
  unsigned int v3 = (2 * v2) & 0xFFFFFFFC;
  unsigned int v4 = *(_DWORD *)(a1 + 16);
  if (v3 < v4 && v4 >= 0x41)
  {
    sub_1CD676DD4(a1);
  }
  else
  {
    if (v4)
    {
      unint64_t v5 = *(void **)(a1 + 8);
      uint64_t v6 = &v5[9 * v4];
      goto LABEL_9;
    }
LABEL_16:
    *(_DWORD *)a1 = v4;
    *(_DWORD *)(a1 + 4) = 0;
  }
}

int *sub_1CD676BDC(int *a1)
{
  int v2 = *a1;
  if (*a1 > 1)
  {
    if (v2)
    {
      uint64_t result = a1 + 2;
      unsigned int v7 = a1 + 74;
LABEL_10:
      while ((*(void *)result | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        result += 18;
        if (result == v7) {
          return v7;
        }
      }
    }
    else
    {
      uint64_t result = (int *)*((void *)a1 + 1);
      unsigned int v6 = a1[4];
      if (v6)
      {
        unsigned int v7 = &result[18 * v6];
        goto LABEL_10;
      }
    }
  }
  else
  {
    if (v2)
    {
      unsigned int v3 = a1 + 2;
      unsigned int v4 = 4;
    }
    else
    {
      unsigned int v3 = (int *)*((void *)a1 + 1);
      unsigned int v4 = a1[4];
    }
    return &v3[18 * v4];
  }
  return result;
}

void *sub_1CD676C5C(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = sub_1CD677330(a1, a2);
  uint64_t result = (void *)(*(void *)a1 + 48 * *(unsigned int *)(a1 + 8));
  void *result = result + 2;
  result[1] = 0x400000000;
  if (*(_DWORD *)(v3 + 8)) {
    uint64_t result = (void *)llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=((uint64_t)result, v3);
  }
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1CD676CC4(uint64_t result, void *a2)
{
  *(void *)(result + 8) = a2[1];
  unint64_t v2 = *(unsigned int *)(result + 16);
  if (v2)
  {
    uint64_t v3 = 0;
    for (unint64_t i = 0; i < v2; ++i)
    {
      *(void *)(*(void *)result + v3) = *(void *)(*a2 + v3);
      if ((*(void *)(*(void *)result + v3) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v5 = *(void *)result + v3;
        uint64_t v6 = *a2 + v3;
        uint64_t v8 = *(void *)(v6 + 8);
        uint64_t v7 = *(void *)(v6 + 16);
        *(void *)(v5 + 8) = v8;
        *(void *)(v5 + 16) = v7;
        if (v7)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
          unint64_t v2 = *(unsigned int *)(result + 16);
        }
      }
      v3 += 24;
    }
  }
  return result;
}

void *sub_1CD676D44(void *a1, unsigned int a2)
{
  if (a2 <= 4)
  {
    *a1 = 1;
  }
  else
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v3 = a2;
    uint64_t result = operator new(72 * a2, (std::align_val_t)8uLL);
    a1[1] = result;
    a1[2] = v3;
    int v5 = *(_DWORD *)a1;
    *a1 = *(_DWORD *)a1 & 1;
    if ((v5 & 1) == 0)
    {
      uint64_t v6 = &result[9 * v3];
      goto LABEL_6;
    }
  }
  uint64_t result = a1 + 1;
  uint64_t v6 = a1 + 37;
  do
  {
LABEL_6:
    void *result = -4096;
    result += 9;
  }
  while (result != v6);
  return result;
}

void sub_1CD676DD4(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)a1;
  sub_1CD676EB8(a1);
  unsigned int v3 = __clz((v2 >> 1) - 1);
  if (v3 - 28 >= 3) {
    int v4 = 1 << (33 - v3);
  }
  else {
    int v4 = 64;
  }
  if (v2 >= 2) {
    unsigned int v5 = v4;
  }
  else {
    unsigned int v5 = 0;
  }
  if ((*(_DWORD *)a1 & 1) != 0 && v5 < 5)
  {
    uint64_t v6 = (void *)(a1 + 296);
    *(void *)a1 = 1;
    uint64_t v7 = (void *)(a1 + 8);
    do
    {
LABEL_10:
      *uint64_t v7 = -4096;
      v7 += 9;
    }
    while (v7 != v6);
    return;
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    if (v5 == *(_DWORD *)(a1 + 16))
    {
      *(void *)a1 = 0;
      if (!v5) {
        return;
      }
      uint64_t v7 = *(void **)(a1 + 8);
      uint64_t v6 = &v7[9 * v5];
      goto LABEL_10;
    }
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
  }

  sub_1CD676D44((void *)a1, v5);
}

void sub_1CD676EB8(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = a1 + 8;
    uint64_t v1 = 4;
  }
  else
  {
    uint64_t v1 = *(unsigned int *)(a1 + 16);
    if (!v1) {
      return;
    }
    uint64_t v2 = *(void *)(a1 + 8);
  }
  uint64_t v3 = 72 * v1;
  int v4 = (void **)(v2 + 16);
  do
  {
    if (((unint64_t)*(v4 - 2) | 0x1000) != 0xFFFFFFFFFFFFF000 && *v4 != *(v4 - 1)) {
      free(*v4);
    }
    v4 += 9;
    v3 -= 72;
  }
  while (v3);
}

void *sub_1CD676F34(_DWORD *a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD5449C0((uint64_t)a1, *a2, &v7);
  unsigned int v5 = v7;
  if ((v4 & 1) == 0)
  {
    unsigned int v5 = sub_1CD676FB0(a1, a2, v7);
    *unsigned int v5 = *a2;
    v5[1] = v5 + 5;
    uint64_t v5[2] = v5 + 5;
    v5[3] = 4;
    *((_DWORD *)v5 + 8) = 0;
  }
  return v5;
}

void *sub_1CD676FB0(_DWORD *a1, uint64_t *a2, void *a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 4;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD677070((uint64_t)a1, v6);
  uint64_t v8 = 0;
  sub_1CD5449C0((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096) {
    --a1[1];
  }
  return a3;
}

void sub_1CD677070(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = a2;
  v14[36] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v4 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v5 = v4 | (v4 >> 2) | ((v4 | (v4 >> 2)) >> 4);
    int v6 = ((v5 | (v5 >> 8)) >> 16) | v5 | (v5 >> 8);
    if ((v6 + 1) > 0x40) {
      unsigned int v2 = v6 + 1;
    }
    else {
      unsigned int v2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v7 = *(uint64_t **)(a1 + 8);
    unsigned int v8 = *(_DWORD *)(a1 + 16);
    if (v2 > 4)
    {
      *(void *)(a1 + 8) = operator new(72 * v2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v2;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD677248(a1, v7, &v7[9 * v8]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v9 = 0;
  char v10 = v14;
  do
  {
    uint64_t v11 = a1 + v9;
    uint64_t v12 = *(void *)(a1 + v9 + 8);
    if ((v12 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *char v10 = v12;
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(v10 + 1), v10 + 5, 4, (uint64_t *)(v11 + 16));
      v10 += 9;
      int v13 = *(void **)(v11 + 24);
      if (v13 != *(void **)(v11 + 16)) {
        free(v13);
      }
    }
    v9 += 72;
  }
  while (v9 != 288);
  if (v2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    *(void *)(a1 + 8) = operator new(72 * v2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v2;
  }
  sub_1CD677248(a1, v14, v10);
}

void sub_1CD677248(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v6 = *(_DWORD *)a1;
  *(void *)a1 = *(_DWORD *)a1 & 1;
  if (v6)
  {
    unsigned int v8 = (void *)(a1 + 8);
    uint64_t v9 = (void *)(a1 + 296);
  }
  else
  {
    unsigned int v7 = *(_DWORD *)(a1 + 16);
    if (!v7) {
      goto LABEL_11;
    }
    unsigned int v8 = *(void **)(a1 + 8);
    uint64_t v9 = &v8[9 * v7];
  }
  do
  {
    void *v8 = -4096;
    v8 += 9;
  }
  while (v8 != v9);
LABEL_11:
  while (a2 != a3)
  {
    uint64_t v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      BOOL v14 = 0;
      sub_1CD5449C0(a1, v10, &v14);
      uint64_t v11 = v14;
      uint64_t v12 = v14 + 5;
      *BOOL v14 = *a2;
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(v11 + 1), v12, 4, a2 + 1);
      *(_DWORD *)a1 += 2;
      int v13 = (void *)a2[2];
      if (v13 != (void *)a2[1]) {
        free(v13);
      }
    }
    a2 += 9;
  }
}

unint64_t sub_1CD677330(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 48 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      sub_1CD67739C();
    }
    sub_1CD67739C();
  }
  return a2;
}

void sub_1CD67739C()
{
}

uint64_t sub_1CD67740C(uint64_t a1)
{
  if ((*(unsigned char *)a1 & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
  }
  return a1;
}

void *sub_1CD677448(uint64_t a1, uint64_t *a2)
{
  unsigned int v7 = 0;
  char v4 = sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  unint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CD6774B4(a1, a2, v7);
    *unint64_t v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD6774B4(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD677568(a1, v6);
  unsigned int v8 = 0;
  sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD677568(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD677634(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

void sub_1CD677634(uint64_t a1, void *a2, void *a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v5 = *(unsigned int *)(a1 + 16);
  if (v5)
  {
    unint64_t v6 = *(void **)a1;
    uint64_t v7 = 16 * v5;
    do
    {
      *unint64_t v6 = -4096;
      v6 += 2;
      v7 -= 16;
    }
    while (v7);
  }
  if (a2 != a3)
  {
    unsigned int v8 = a2 + 1;
    do
    {
      uint64_t v9 = *(v8 - 1);
      if ((v9 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        BOOL v14 = 0;
        sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v14);
        uint64_t v11 = v14;
        *BOOL v14 = *(v8 - 1);
        uint64_t v12 = *v8;
        uint64_t *v8 = 0;
        v11[1] = v12;
        ++*(_DWORD *)(a1 + 8);
        uint64_t v13 = *v8;
        uint64_t *v8 = 0;
        if (v13) {
          sub_1CC0CC1D8((uint64_t)v8, v13);
        }
      }
      uint64_t v10 = v8 + 1;
      v8 += 2;
    }
    while (v10 != a3);
  }
}

void sub_1CD67770C(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = 16 * a2;
    uint64_t v3 = (uint64_t *)(a1 + 8);
    do
    {
      if ((*(v3 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v4 = *v3;
        *uint64_t v3 = 0;
        if (v4) {
          sub_1CC0CC1D8((uint64_t)v3, v4);
        }
      }
      v3 += 2;
      v2 -= 16;
    }
    while (v2);
  }
}

void sub_1CD677770(_WORD *a1, __n128 *a2, _WORD *a3, char **a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE1798, 0, 0);
  byte_1EBCE1818 = 0;
  qword_1EBCE1820 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCE1828 = 0;
  qword_1EBCE1798 = (uint64_t)&unk_1F26440A0;
  qword_1EBCE1830 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCE1838 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCE1850 = (uint64_t)&qword_1EBCE1838;
  sub_1CD677870(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE1798);
}

__n128 sub_1CD677870(_WORD *a1, __n128 *a2, _WORD *a3, char **a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE1798, "openmp-opt-disable", 0x12uLL);
  word_1EBCE17A2 = word_1EBCE17A2 & 0xFFF8 | *a1 & 7;
  __n128 result = *a2;
  xmmword_1EBCE17B8 = (__int128)*a2;
  word_1EBCE17A2 = (32 * (*a3 & 3)) | word_1EBCE17A2 & 0xFF9F;
  uint64_t v9 = *a4;
  byte_1EBCE1818 = **a4;
  byte_1EBCE1829 = 1;
  byte_1EBCE1828 = *v9;
  return result;
}

void sub_1CD677910(_WORD *a1, __n128 *a2, _WORD *a3, char **a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE1858, 0, 0);
  byte_1EBCE18D8 = 0;
  qword_1EBCE18E0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCE18E8 = 0;
  qword_1EBCE1858 = (uint64_t)&unk_1F26440A0;
  qword_1EBCE18F0 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCE18F8 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCE1910 = (uint64_t)&qword_1EBCE18F8;
  sub_1CD677A10(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE1858);
}

__n128 sub_1CD677A10(_WORD *a1, __n128 *a2, _WORD *a3, char **a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE1858, "openmp-opt-enable-merging", 0x19uLL);
  word_1EBCE1862 = word_1EBCE1862 & 0xFFF8 | *a1 & 7;
  __n128 result = *a2;
  xmmword_1EBCE1878 = (__int128)*a2;
  word_1EBCE1862 = (32 * (*a3 & 3)) | word_1EBCE1862 & 0xFF9F;
  uint64_t v9 = *a4;
  byte_1EBCE18D8 = **a4;
  byte_1EBCE18E9 = 1;
  byte_1EBCE18E8 = *v9;
  return result;
}

llvm::cl::Option *sub_1CD677AB0(llvm::cl::Option *a1, char *a2, _WORD *a3, __n128 *a4, _WORD *a5, unsigned char **a6)
{
  uint64_t v12 = sub_1CB883A14((uint64_t)a1, 0, 0);
  *(unsigned char *)(v12 + 128) = 0;
  *(void *)(v12 + 136) = &unk_1F25EDE58;
  *(void *)(v12 + 144) = 0;
  *(void *)uint64_t v12 = &unk_1F26440A0;
  *(void *)(v12 + 152) = &unk_1F2643CC0;
  *(void *)(v12 + 160) = &unk_1F25EDE78;
  *(void *)(v12 + 184) = v12 + 160;
  sub_1CD677BA8(v12, a2, a3, a4, a5, a6);
  llvm::cl::Option::addArgument(a1);
  return a1;
}

__n128 sub_1CD677BA8(uint64_t a1, char *__s, _WORD *a3, __n128 *a4, _WORD *a5, unsigned char **a6)
{
  size_t v12 = strlen(__s);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)__s, v12);
  __int16 v13 = *(_WORD *)(a1 + 10) & 0xFFF8 | *a3 & 7;
  *(_WORD *)(a1 + 10) = v13;
  __n128 result = *a4;
  *(__n128 *)(a1 + 32) = *a4;
  *(_WORD *)(a1 + 10) = (32 * (*a5 & 3)) | v13 & 0xFF9F;
  uint64_t v15 = *a6;
  *(unsigned char *)(a1 + 128) = **a6;
  *(unsigned char *)(a1 + 145) = 1;
  *(unsigned char *)(a1 + 144) = *v15;
  return result;
}

void sub_1CD677C4C(_WORD *a1, __n128 *a2, _WORD *a3, char **a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE1E58, 0, 0);
  byte_1EBCE1ED8 = 0;
  qword_1EBCE1EE0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCE1EE8 = 0;
  qword_1EBCE1E58 = (uint64_t)&unk_1F26440A0;
  qword_1EBCE1EF0 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCE1EF8 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCE1F10 = (uint64_t)&qword_1EBCE1EF8;
  sub_1CD677D4C(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE1E58);
}

__n128 sub_1CD677D4C(_WORD *a1, __n128 *a2, _WORD *a3, char **a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE1E58, "openmp-opt-disable-state-machine-rewrite", 0x28uLL);
  word_1EBCE1E62 = word_1EBCE1E62 & 0xFFF8 | *a1 & 7;
  __n128 result = *a2;
  xmmword_1EBCE1E78 = (__int128)*a2;
  word_1EBCE1E62 = (32 * (*a3 & 3)) | word_1EBCE1E62 & 0xFF9F;
  uint64_t v9 = *a4;
  byte_1EBCE1ED8 = **a4;
  byte_1EBCE1EE9 = 1;
  byte_1EBCE1EE8 = *v9;
  return result;
}

void sub_1CD677DEC(_WORD *a1, __n128 *a2, _WORD *a3, char **a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE1F18, 0, 0);
  byte_1EBCE1F98 = 0;
  qword_1EBCE1FA0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCE1FA8 = 0;
  qword_1EBCE1F18 = (uint64_t)&unk_1F26440A0;
  qword_1EBCE1FB0 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCE1FB8 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCE1FD0 = (uint64_t)&qword_1EBCE1FB8;
  sub_1CD677EEC(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE1F18);
}

__n128 sub_1CD677EEC(_WORD *a1, __n128 *a2, _WORD *a3, char **a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE1F18, "openmp-opt-disable-barrier-elimination", 0x26uLL);
  word_1EBCE1F22 = word_1EBCE1F22 & 0xFFF8 | *a1 & 7;
  __n128 result = *a2;
  xmmword_1EBCE1F38 = (__int128)*a2;
  word_1EBCE1F22 = (32 * (*a3 & 3)) | word_1EBCE1F22 & 0xFF9F;
  uint64_t v9 = *a4;
  byte_1EBCE1F98 = **a4;
  byte_1EBCE1FA9 = 1;
  byte_1EBCE1FA8 = *v9;
  return result;
}

void sub_1CD677F8C(_WORD *a1, __n128 *a2, _WORD *a3, char **a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE1FD8, 0, 0);
  byte_1EBCE2058 = 0;
  qword_1EBCE2060 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCE2068 = 0;
  qword_1EBCE1FD8 = (uint64_t)&unk_1F26440A0;
  qword_1EBCE2070 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCE2078 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCE2090 = (uint64_t)&qword_1EBCE2078;
  sub_1CD67808C(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE1FD8);
}

__n128 sub_1CD67808C(_WORD *a1, __n128 *a2, _WORD *a3, char **a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE1FD8, "openmp-opt-print-module-after", 0x1DuLL);
  word_1EBCE1FE2 = word_1EBCE1FE2 & 0xFFF8 | *a1 & 7;
  __n128 result = *a2;
  xmmword_1EBCE1FF8 = (__int128)*a2;
  word_1EBCE1FE2 = (32 * (*a3 & 3)) | word_1EBCE1FE2 & 0xFF9F;
  uint64_t v9 = *a4;
  byte_1EBCE2058 = **a4;
  byte_1EBCE2069 = 1;
  byte_1EBCE2068 = *v9;
  return result;
}

void sub_1CD67812C(_WORD *a1, __n128 *a2, _WORD *a3, char **a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE2158, 0, 0);
  byte_1EBCE21D8 = 0;
  qword_1EBCE21E0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCE21E8 = 0;
  qword_1EBCE2158 = (uint64_t)&unk_1F26440A0;
  qword_1EBCE21F0 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCE21F8 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCE2210 = (uint64_t)&qword_1EBCE21F8;
  sub_1CD67822C(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE2158);
}

__n128 sub_1CD67822C(_WORD *a1, __n128 *a2, _WORD *a3, char **a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE2158, "openmp-opt-inline-device", 0x18uLL);
  word_1EBCE2162 = word_1EBCE2162 & 0xFFF8 | *a1 & 7;
  __n128 result = *a2;
  xmmword_1EBCE2178 = (__int128)*a2;
  word_1EBCE2162 = (32 * (*a3 & 3)) | word_1EBCE2162 & 0xFF9F;
  uint64_t v9 = *a4;
  byte_1EBCE21D8 = **a4;
  byte_1EBCE21E9 = 1;
  byte_1EBCE21E8 = *v9;
  return result;
}

void sub_1CD6782CC(_WORD *a1, __n128 *a2, int **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE2398, 0, 0);
  dword_1EBCE2418 = 0;
  qword_1EBCE2420 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCE2428 = 0;
  qword_1EBCE2398 = (uint64_t)&unk_1F2643F00;
  qword_1EBCE2430 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCE2438 = (uint64_t)&unk_1F25EA168;
  qword_1EBCE2450 = (uint64_t)&qword_1EBCE2438;
  sub_1CD6783BC(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE2398);
}

__n128 sub_1CD6783BC(_WORD *a1, __n128 *a2, int **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE2398, "openmp-opt-shared-limit", 0x17uLL);
  word_1EBCE23A2 = (32 * (*a1 & 3)) | word_1EBCE23A2 & 0xFF9F;
  __n128 result = *a2;
  xmmword_1EBCE23B8 = (__int128)*a2;
  uint64_t v7 = *a3;
  dword_1EBCE2418 = **a3;
  byte_1EBCE242C = 1;
  dword_1EBCE2428 = *v7;
  return result;
}

void llvm::createPartialInliningPass(llvm *this)
{
}

void llvm::PartialInlinerPass::run()
{
}

uint64_t sub_1CD6785D0(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    uint64_t v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *uint64_t v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v10 = 0;
      __n128 result = sub_1CC9A2D50((uint64_t *)v5, (void *)a2, &v10);
      uint64_t v9 = v10;
      *uint64_t v10 = *(void *)a2;
      *((unsigned char *)v9 + 8) = *(unsigned char *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

void *sub_1CD678680(uint64_t *a1, void *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CC9A2D50(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CC9A2DEC(a1, a2, v7);
    *uint64_t v5 = *a2;
    *((unsigned char *)v5 + 8) = 0;
  }
  return v5;
}

void sub_1CD6786E0(char **a1, _WORD *a2, _WORD *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE2768, 0, 0);
  byte_1EBCE27E8 = 0;
  qword_1EBCE27F0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCE27F8 = 0;
  qword_1EBCE2768 = (uint64_t)&unk_1F26440A0;
  qword_1EBCE2800 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCE2808 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCE2820 = (uint64_t)&qword_1EBCE2808;
  sub_1CD6787E0(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE2768);
}

__n128 sub_1CD6787E0(char **a1, _WORD *a2, _WORD *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE2768, "skip-partial-inlining-cost-analysis", 0x23uLL);
  uint64_t v8 = *a1;
  byte_1EBCE27E8 = **a1;
  byte_1EBCE27F9 = 1;
  byte_1EBCE27F8 = *v8;
  word_1EBCE2772 = word_1EBCE2772 & 0xFFF8 | *a2 & 7;
  word_1EBCE2772 = (32 * (*a3 & 3)) | word_1EBCE2772 & 0xFF9F;
  __n128 result = *a4;
  xmmword_1EBCE2788 = (__int128)*a4;
  return result;
}

void sub_1CD678880(double **a1, _WORD *a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE2828, 0, 0);
  dword_1EBCE28A8 = 0;
  qword_1EBCE28B0 = (uint64_t)&unk_1F2605730;
  *(void *)&dword_1EBCE28B8 = 0;
  qword_1EBCE2828 = (uint64_t)&unk_1F26056C8;
  qword_1EBCE28C0 = (uint64_t)&unk_1F2643E70;
  qword_1EBCE28C8 = (uint64_t)&unk_1F2605750;
  qword_1EBCE28E0 = (uint64_t)&qword_1EBCE28C8;
  sub_1CD678970(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE2828);
}

__n128 sub_1CD678970(double **a1, _WORD *a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE2828, "min-region-size-ratio", 0x15uLL);
  *(float *)&int v6 = **a1;
  dword_1EBCE28A8 = v6;
  byte_1EBCE28BC = 1;
  dword_1EBCE28B8 = v6;
  word_1EBCE2832 = (32 * (*a2 & 3)) | word_1EBCE2832 & 0xFF9F;
  __n128 result = *a3;
  xmmword_1EBCE2848 = (__int128)*a3;
  return result;
}

void sub_1CD6789F8(double **a1, _WORD *a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE29A8, 0, 0);
  dword_1EBCE2A28 = 0;
  qword_1EBCE2A30 = (uint64_t)&unk_1F2605730;
  *(void *)&dword_1EBCE2A38 = 0;
  qword_1EBCE29A8 = (uint64_t)&unk_1F26056C8;
  qword_1EBCE2A40 = (uint64_t)&unk_1F2643E70;
  qword_1EBCE2A48 = (uint64_t)&unk_1F2605750;
  qword_1EBCE2A60 = (uint64_t)&qword_1EBCE2A48;
  sub_1CD678AE8(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE29A8);
}

__n128 sub_1CD678AE8(double **a1, _WORD *a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE29A8, "cold-branch-ratio", 0x11uLL);
  *(float *)&int v6 = **a1;
  dword_1EBCE2A28 = v6;
  byte_1EBCE2A3C = 1;
  dword_1EBCE2A38 = v6;
  word_1EBCE29B2 = (32 * (*a2 & 3)) | word_1EBCE29B2 & 0xFF9F;
  __n128 result = *a3;
  xmmword_1EBCE29C8 = (__int128)*a3;
  return result;
}

void sub_1CD678B70(int **a1, _WORD *a2, _WORD *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE2B28, 0, 0);
  dword_1EBCE2BA8 = 0;
  qword_1EBCE2BB0 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCE2BB8 = 0;
  qword_1EBCE2B28 = (uint64_t)&unk_1F2643F68;
  qword_1EBCE2BC0 = (uint64_t)&unk_1F2643D20;
  qword_1EBCE2BC8 = (uint64_t)&unk_1F25F7480;
  qword_1EBCE2BE0 = (uint64_t)&qword_1EBCE2BC8;
  sub_1CD678C70(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE2B28);
}

__n128 sub_1CD678C70(int **a1, _WORD *a2, _WORD *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE2B28, "max-partial-inlining", 0x14uLL);
  uint64_t v8 = *a1;
  dword_1EBCE2BA8 = **a1;
  byte_1EBCE2BBC = 1;
  dword_1EBCE2BB8 = *v8;
  word_1EBCE2B32 = word_1EBCE2B32 & 0xFF9F | (32 * (*a2 & 3));
  word_1EBCE2B32 = word_1EBCE2B32 & 0xFFF8 | *a3 & 7;
  __n128 result = *a4;
  xmmword_1EBCE2B48 = (__int128)*a4;
  return result;
}

void sub_1CD678D08(int **a1, _WORD *a2, _WORD *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE2BE8, 0, 0);
  dword_1EBCE2C68 = 0;
  qword_1EBCE2C70 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCE2C78 = 0;
  qword_1EBCE2BE8 = (uint64_t)&unk_1F2643F68;
  qword_1EBCE2C80 = (uint64_t)&unk_1F2643D20;
  qword_1EBCE2C88 = (uint64_t)&unk_1F25F7480;
  qword_1EBCE2CA0 = (uint64_t)&qword_1EBCE2C88;
  sub_1CD678E08(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE2BE8);
}

__n128 sub_1CD678E08(int **a1, _WORD *a2, _WORD *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE2BE8, "outline-region-freq-percent", 0x1BuLL);
  uint64_t v8 = *a1;
  dword_1EBCE2C68 = **a1;
  byte_1EBCE2C7C = 1;
  dword_1EBCE2C78 = *v8;
  word_1EBCE2BF2 = word_1EBCE2BF2 & 0xFF9F | (32 * (*a2 & 3));
  word_1EBCE2BF2 = word_1EBCE2BF2 & 0xFFF8 | *a3 & 7;
  __n128 result = *a4;
  xmmword_1EBCE2C08 = (__int128)*a4;
  return result;
}

llvm::PassManagerBuilder *llvm::PassManagerBuilder::PassManagerBuilder(llvm::PassManagerBuilder *this)
{
  uint64_t v2 = (char *)this + 96;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  uint64_t v3 = (char *)this + 120;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_DWORD *)this = 2;
  *((unsigned char *)this + 40) = 0;
  *((unsigned char *)this + 42) = 0;
  *(void *)((char *)this + 12) = 0;
  *(void *)((char *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0;
  *(_WORD *)((char *)this + 43) = 257;
  *((unsigned char *)this + 45) = byte_1EBCE2EC8;
  *((unsigned char *)this + 46) = byte_1EBD07B98;
  int v4 = dword_1EBD0B6B8;
  *((_DWORD *)this + 15) = dword_1EBD0B5F8;
  *((_DWORD *)this + 16) = v4;
  *((unsigned char *)this + 47) = 0;
  *((unsigned char *)this + 48) = byte_1EBD0B778;
  *((_WORD *)this + 34) = 0;
  *((unsigned char *)this + 70) = 0;
  *((unsigned char *)this + 53) = 0;
  *(_DWORD *)((char *)this + 49) = 0;
  MEMORY[0x1D25D9630]((char *)this + 72, "");
  MEMORY[0x1D25D9630](v2, "");
  MEMORY[0x1D25D9630](v3, "");
  *((unsigned char *)this + 54) = byte_1EBCE2F88;
  *((unsigned char *)this + 55) = byte_1EBCE3048;
  *((unsigned char *)this + 56) = 0;
  *((unsigned char *)this + 41) = 1;
  return this;
}

uint64_t llvm::PassManagerBuilder::addExtension(uint64_t a1, int a2, void *a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (uint64_t *)(a1 + 144);
  int v6 = a2;
  int v4 = (void *)a3[3];
  if (v4)
  {
    if (v4 == a3)
    {
      uint64_t v8 = v7;
      (*(void (**)(void *, void *))(*a3 + 24))(a3, v7);
    }
    else
    {
      uint64_t v8 = (void *)a3[3];
      a3[3] = 0;
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  sub_1CC9A3C7C(v3, (uint64_t)&v6);
  uint64_t result = (uint64_t)v8;
  if (v8 == v7) {
    return (*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (*(uint64_t (**)(void *))(*v8 + 40))(v8);
  }
  return result;
}

void llvm::PassManagerBuilder::addExtensionsToPM(uint64_t a1, int a2, uint64_t a3)
{
  if (atomic_load((unint64_t *)qword_1EBCE2D70))
  {
    if (!atomic_load_explicit(qword_1EBCE2D70, memory_order_acquire)) {
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCE2D70, (void *(*)(void))sub_1CD67CFF0, (void (*)(void *))sub_1CD67D030);
    }
    if (*(_DWORD *)(qword_1EBCE2D70[0] + 8))
    {
      if (!atomic_load_explicit(qword_1EBCE2D70, memory_order_acquire)) {
        llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EBCE2D70, (void *(*)(void))sub_1CD67CFF0, (void (*)(void *))sub_1CD67D030);
      }
      uint64_t v7 = *(unsigned int *)(qword_1EBCE2D70[0] + 8);
      if (v7)
      {
        uint64_t v8 = 48 * v7;
        uint64_t v9 = (void *)(*(void *)qword_1EBCE2D70[0] + 32);
        do
        {
          if (*((_DWORD *)v9 - 8) == a2)
          {
            if (!*v9)
            {
LABEL_20:
              sub_1CB920400();
              llvm::PassManagerBuilder::addInitialAliasAnalysisPasses(v15, v16);
              return;
            }
            (*(void (**)(void, uint64_t, uint64_t))(*(void *)*v9 + 48))(*v9, a1, a3);
          }
          v9 += 6;
          v8 -= 48;
        }
        while (v8);
      }
    }
  }
  uint64_t v10 = -858993459 * ((*(void *)(a1 + 152) - *(void *)(a1 + 144)) >> 3);
  if (v10)
  {
    uint64_t v11 = 0;
    uint64_t v12 = 40 * v10;
    do
    {
      uint64_t v13 = *(void *)(a1 + 144);
      if (*(_DWORD *)(v13 + v11) == a2)
      {
        uint64_t v14 = *(void *)(v13 + v11 + 32);
        if (!v14) {
          goto LABEL_20;
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v14 + 48))(v14, a1, a3);
      }
      v11 += 40;
    }
    while (v12 != v11);
  }
}

void llvm::PassManagerBuilder::addInitialAliasAnalysisPasses(llvm::PassManagerBuilder *this, llvm::legacy::PassManagerBase *a2)
{
  if (dword_1EBCE3348 != 1)
  {
    if (dword_1EBCE3348 != 2)
    {
      if (dword_1EBCE3348 == 3) {
        llvm::createCFLSteensAAWrapperPass(this);
      }
      llvm::createTypeBasedAAWrapperPass(this);
    }
    llvm::createCFLAndersAAWrapperPass(this);
  }
  llvm::createCFLSteensAAWrapperPass(this);
}

void llvm::PassManagerBuilder::populateFunctionPassManager(llvm::PassManagerBuilder *this, llvm::legacy::FunctionPassManager *a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  llvm::PassManagerBuilder::addExtensionsToPM((uint64_t)this, 0, (uint64_t)a2);
  if (*((void *)this + 1)) {
    operator new();
  }
  if (byte_1EBD08618)
  {
    if (!*(_DWORD *)this) {
      llvm::createLowerMatrixIntrinsicsMinimalPass(v4);
    }
LABEL_7:
    llvm::PassManagerBuilder::addInitialAliasAnalysisPasses(v4, a2);
  }
  if (*(_DWORD *)this) {
    goto LABEL_7;
  }
}

void llvm::PassManagerBuilder::addFunctionSimplificationPasses(llvm::PassManagerBuilder *this, llvm::legacy::PassManagerBase *a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  llvm::createSROAPass(this);
}

void llvm::PassManagerBuilder::addVectorPasses(llvm::PassManagerBuilder *this, llvm::legacy::PassManagerBase *a2)
{
  llvm::createLoopVectorizePass((llvm *)(*((unsigned char *)this + 44) == 0));
}

void llvm::PassManagerBuilder::populateModulePassManager(llvm::PassManagerBuilder *this, llvm::legacy::PassManagerBase *a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  llvm::createAnnotation2MetadataLegacyPass(this);
}

void *sub_1CD67BDB8(void *a1)
{
  *a1 = &unk_1F262A588;
  uint64_t v2 = a1 + 71;
  uint64_t v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1F262A5F0;
  int v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }

  return sub_1CB87DD48(a1);
}

void *sub_1CD67BEA0(void *a1)
{
  *a1 = &unk_1F262A5F0;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD67BEF4(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  int v12 = 0;
  uint64_t v8 = sub_1CD42FA04(a1 + 152, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD67BF88(v11);
}

uint64_t sub_1CD67BF88(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 160) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD67BFA0(void *a1)
{
  sub_1CD67BDB8(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD67BFD8(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t sub_1CD67BFE4(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

llvm::raw_ostream *sub_1CD67BFF4(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    int v3 = *((_DWORD *)result + 32);
LABEL_3:
    int v4 = &unk_1F262A640;
    char v6 = 1;
    int v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 148))
  {
    int v3 = *((_DWORD *)result + 32);
    if (*((_DWORD *)result + 36) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD67C078(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void *sub_1CD67C08C(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 152), a2);
}

void sub_1CD67C094(void *a1)
{
  *a1 = &unk_1F262A5F0;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD67C108(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD67C110(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1CD67C124(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1CD67C138(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1CD67C14C(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

void sub_1CD67C178(char **a1, _WORD *a2, _WORD *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&llvm::RunPartialInlining, 0, 0);
  byte_1EBD07A18 = 0;
  qword_1EBD07A20 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBD07A28 = 0;
  llvm::RunPartialInlining = (uint64_t)&unk_1F26440A0;
  qword_1EBD07A30 = (uint64_t)&unk_1F2643CC0;
  qword_1EBD07A38 = (uint64_t)&unk_1F25EDE78;
  qword_1EBD07A50 = (uint64_t)&qword_1EBD07A38;
  sub_1CD67C278(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&llvm::RunPartialInlining);
}

__n128 sub_1CD67C278(char **a1, _WORD *a2, _WORD *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&llvm::RunPartialInlining, "enable-partial-inlining", 0x17uLL);
  uint64_t v8 = *a1;
  byte_1EBD07A18 = **a1;
  byte_1EBD07A29 = 1;
  byte_1EBD07A28 = *v8;
  word_1EBD079A2 = word_1EBD079A2 & 0xFF9F | (32 * (*a2 & 3));
  word_1EBD079A2 = word_1EBD079A2 & 0xFFF8 | *a3 & 7;
  __n128 result = *a4;
  xmmword_1EBD079B8 = (__int128)*a4;
  return result;
}

void sub_1CD67C310(int **a1, _WORD *a2, long long *a3, uint64_t *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE32C8, 0, 0);
  dword_1EBCE3348 = 0;
  qword_1EBCE3350 = (uint64_t)&unk_1F2614F70;
  *(void *)&dword_1EBCE3358 = 0;
  qword_1EBCE32C8 = (uint64_t)&unk_1F2614EB8;
  qword_1EBCE3360 = (uint64_t)&unk_1F2614F20;
  unk_1EBCE3368 = &qword_1EBCE32C8;
  qword_1EBCE3370 = (uint64_t)&unk_1EBCE3380;
  qword_1EBCE3378 = 0x800000000;
  qword_1EBCE3500 = (uint64_t)&unk_1F26151C0;
  qword_1EBCE3518 = (uint64_t)&qword_1EBCE3500;
  sub_1CD67C424(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE32C8);
}

void sub_1CD67C424(int **a1, _WORD *a2, long long *a3, uint64_t *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE32C8, "use-cfl-aa", 0xAuLL);
  uint64_t v8 = *a1;
  dword_1EBCE3348 = **a1;
  byte_1EBCE335C = 1;
  dword_1EBCE3358 = *v8;
  word_1EBCE32D2 = (32 * (*a2 & 3)) | word_1EBCE32D2 & 0xFF9F;
  xmmword_1EBCE32E8 = *a3;

  sub_1CC4B024C(a4, (uint64_t)&qword_1EBCE32C8);
}

void sub_1CD67C4D0(__n128 *a1, char **a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&llvm::EnableDFAJumpThreading, 0, 0);
  byte_1EBD07E98 = 0;
  qword_1EBD07EA0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBD07EA8 = 0;
  llvm::EnableDFAJumpThreading = (uint64_t)&unk_1F26440A0;
  qword_1EBD07EB0 = (uint64_t)&unk_1F2643CC0;
  qword_1EBD07EB8 = (uint64_t)&unk_1F25EDE78;
  qword_1EBD07ED0 = (uint64_t)&qword_1EBD07EB8;
  sub_1CD67C5C0(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&llvm::EnableDFAJumpThreading);
}

__n128 sub_1CD67C5C0(__n128 *a1, char **a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&llvm::EnableDFAJumpThreading, "enable-dfa-jump-thread", 0x16uLL);
  __n128 result = *a1;
  xmmword_1EBD07E38 = (__int128)*a1;
  uint64_t v7 = *a2;
  byte_1EBD07E98 = **a2;
  byte_1EBD07EA9 = 1;
  byte_1EBD07EA8 = *v7;
  word_1EBD07E22 = (32 * (*a3 & 3)) | word_1EBD07E22 & 0xFF9F;
  return result;
}

void sub_1CD67C648(char **a1, _WORD *a2, long long *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&llvm::EnableHotColdSplit, 0, 0);
  byte_1EBD07F58 = 0;
  qword_1EBD07F60 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBD07F68 = 0;
  llvm::EnableHotColdSplit = (uint64_t)&unk_1F26440A0;
  qword_1EBD07F70 = (uint64_t)&unk_1F2643CC0;
  qword_1EBD07F78 = (uint64_t)&unk_1F25EDE78;
  qword_1EBD07F90 = (uint64_t)&qword_1EBD07F78;
  llvm::cl::Option::setArgStr(v6, "hot-cold-split", 0xEuLL);
  uint64_t v7 = *a1;
  byte_1EBD07F58 = **a1;
  byte_1EBD07F69 = 1;
  byte_1EBD07F68 = *v7;
  word_1EBD07EE2 = word_1EBD07EE2 & 0xFFF8 | *a2 & 7;
  xmmword_1EBD07EF8 = *a3;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&llvm::EnableHotColdSplit);
}

void sub_1CD67C76C(_WORD *a1, int **a2, _WORD *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&llvm::PreInlineThreshold, 0, 0);
  dword_1EBD08198 = 0;
  qword_1EBD081A0 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBD081A8 = 0;
  llvm::PreInlineThreshold = (uint64_t)&unk_1F2643F68;
  qword_1EBD081B0 = (uint64_t)&unk_1F2643D20;
  qword_1EBD081B8 = (uint64_t)&unk_1F25F7480;
  qword_1EBD081D0 = (uint64_t)&qword_1EBD081B8;
  sub_1CD67C86C(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&llvm::PreInlineThreshold);
}

__n128 sub_1CD67C86C(_WORD *a1, int **a2, _WORD *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&llvm::PreInlineThreshold, "preinline-threshold", 0x13uLL);
  word_1EBD08122 = word_1EBD08122 & 0xFF9F | (32 * (*a1 & 3));
  uint64_t v8 = *a2;
  dword_1EBD08198 = **a2;
  byte_1EBD081AC = 1;
  dword_1EBD081A8 = *v8;
  word_1EBD08122 = word_1EBD08122 & 0xFFF8 | *a3 & 7;
  __n128 result = *a4;
  xmmword_1EBD08138 = (__int128)*a4;
  return result;
}

void sub_1CD67C904(char **a1, _WORD *a2, long long *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&llvm::EnableGVNHoist, 0, 0);
  byte_1EBD08258 = 0;
  qword_1EBD08260 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBD08268 = 0;
  llvm::EnableGVNHoist = (uint64_t)&unk_1F26440A0;
  qword_1EBD08270 = (uint64_t)&unk_1F2643CC0;
  qword_1EBD08278 = (uint64_t)&unk_1F25EDE78;
  qword_1EBD08290 = (uint64_t)&qword_1EBD08278;
  llvm::cl::Option::setArgStr(v6, "enable-gvn-hoist", 0x10uLL);
  uint64_t v7 = *a1;
  byte_1EBD08258 = **a1;
  byte_1EBD08269 = 1;
  byte_1EBD08268 = *v7;
  word_1EBD081E2 = word_1EBD081E2 & 0xFFF8 | *a2 & 7;
  xmmword_1EBD081F8 = *a3;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&llvm::EnableGVNHoist);
}

void sub_1CD67CA28(char **a1, _WORD *a2, long long *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&llvm::EnableGVNSink, 0, 0);
  byte_1EBD08318 = 0;
  qword_1EBD08320 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBD08328 = 0;
  llvm::EnableGVNSinuint64_t k = (uint64_t)&unk_1F26440A0;
  qword_1EBD08330 = (uint64_t)&unk_1F2643CC0;
  qword_1EBD08338 = (uint64_t)&unk_1F25EDE78;
  qword_1EBD08350 = (uint64_t)&qword_1EBD08338;
  llvm::cl::Option::setArgStr(v6, "enable-gvn-sink", 0xFuLL);
  uint64_t v7 = *a1;
  byte_1EBD08318 = **a1;
  byte_1EBD08329 = 1;
  byte_1EBD08328 = *v7;
  word_1EBD082A2 = word_1EBD082A2 & 0xFFF8 | *a2 & 7;
  xmmword_1EBD082B8 = *a3;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&llvm::EnableGVNSink);
}

void sub_1CD67CB4C(_WORD *a1, int **a2, long long *a3, uint64_t a4)
{
  sub_1CB883A14((uint64_t)&llvm::AttributorRun, 0, 0);
  dword_1EBD08858 = 0;
  qword_1EBD08860 = (uint64_t)&unk_1F262A640;
  *(void *)&dword_1EBD08868 = 0;
  llvm::AttributorRun = (uint64_t)&unk_1F262A588;
  qword_1EBD08870 = (uint64_t)&unk_1F262A5F0;
  qword_1EBD08878 = (uint64_t)&llvm::AttributorRun;
  qword_1EBD08880 = (uint64_t)&unk_1EBD08890;
  qword_1EBD08888 = 0x800000000;
  qword_1EBD08A10 = (uint64_t)&unk_1F262A680;
  qword_1EBD08A28 = (uint64_t)&qword_1EBD08A10;
  sub_1CD67CC60(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&llvm::AttributorRun);
}

void sub_1CD67CC60(_WORD *a1, int **a2, long long *a3, uint64_t a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&llvm::AttributorRun, "attributor-enable", 0x11uLL);
  word_1EBD087E2 = (32 * (*a1 & 3)) | word_1EBD087E2 & 0xFF9F;
  uint64_t v8 = *a2;
  dword_1EBD08858 = **a2;
  byte_1EBD0886C = 1;
  dword_1EBD08868 = *v8;
  xmmword_1EBD087F8 = *a3;
  uint64_t v9 = *(void *)a4;
  unsigned int v10 = *(_DWORD *)(a4 + 8);

  sub_1CC9A4C74(v9, v10);
}

void sub_1CD67CD10()
{
}

void *sub_1CD67CD24()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1F262A680;
  return result;
}

void sub_1CD67CD5C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F262A680;
}

void sub_1CD67CD88(unsigned __int8 *a1, size_t a2, int a3, uint64_t a4, uint64_t a5)
{
  v11[0] = a1;
  v11[1] = a2;
  v11[2] = a4;
  void v11[3] = a5;
  _OWORD v11[4] = &unk_1F262A640;
  char v13 = 1;
  int v12 = a3;
  unint64_t v7 = sub_1CD67CE7C((unint64_t)v11);
  uint64_t v8 = qword_1EBD08880 + 48 * qword_1EBD08888;
  long long v9 = *(_OWORD *)(v7 + 16);
  *(_OWORD *)uint64_t v8 = *(_OWORD *)v7;
  *(_OWORD *)(v8 + 16) = v9;
  *(void *)(v8 + 32) = &unk_1F262A660;
  char v10 = *(unsigned char *)(v7 + 44);
  *(_DWORD *)(v8 + 40) = *(_DWORD *)(v7 + 40);
  *(unsigned char *)(v8 + 44) = v10;
  *(void *)(v8 + 32) = &unk_1F262A640;
  LODWORD(qword_1EBD08888) = qword_1EBD08888 + 1;
  llvm::cl::AddLiteralOption(qword_1EBD08878, a1, a2);
}

unint64_t sub_1CD67CE7C(unint64_t result)
{
  if (qword_1EBD08888 >= HIDWORD(qword_1EBD08888))
  {
    if (qword_1EBD08880 > result || qword_1EBD08880 + 48 * (unint64_t)qword_1EBD08888 <= result) {
      sub_1CD67CEF8();
    }
    sub_1CD67CEF8();
  }
  return result;
}

void sub_1CD67CEF8()
{
}

void sub_1CD67CFF0()
{
}

char **sub_1CD67D030(char **result)
{
  if (result)
  {
    sub_1CD67D070(result);
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

char **sub_1CD67D070(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 48 * v3;
    int v5 = v2 - 40;
    do
    {
      uint64_t v6 = *(char **)&v5[v4 + 24];
      if (&v5[v4] == v6)
      {
        (*(void (**)(char *))(*(void *)&v5[v4] + 32))(&v5[v4]);
      }
      else if (v6)
      {
        (*(void (**)(char *))(*(void *)v6 + 40))(v6);
      }
      v4 -= 48;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

uint64_t *sub_1CD67D134(uint64_t *result, void *a2)
{
  uint64_t v3 = result;
  uint64_t v5 = *result;
  uint64_t v4 = result[1];
  uint64_t v6 = a2[1];
  if (v4 != *result)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = v6 + v7;
      uint64_t v9 = v4 + v7;
      *(_DWORD *)(v6 + v7 - 40) = *(_DWORD *)(v4 + v7 - 40);
      uint64_t v10 = *(void *)(v4 + v7 - 8);
      if (v10)
      {
        if (v9 - 32 == v10)
        {
          *(void *)(v8 - 8) = v8 - 32;
          __n128 result = (uint64_t *)(*(uint64_t (**)(void))(**(void **)(v9 - 8) + 24))(*(void *)(v9 - 8));
        }
        else
        {
          *(void *)(v8 - 8) = v10;
          *(void *)(v9 - 8) = 0;
        }
      }
      else
      {
        *(void *)(v8 - 8) = 0;
      }
      v7 -= 40;
    }
    while (v4 + v7 != v5);
    v6 += v7;
  }
  a2[1] = v6;
  uint64_t v11 = *v3;
  *uint64_t v3 = v6;
  a2[1] = v11;
  uint64_t v12 = v3[1];
  v3[1] = a2[2];
  a2[2] = v12;
  uint64_t v13 = v3[2];
  v3[2] = a2[3];
  a2[3] = v13;
  *a2 = a2[1];
  return result;
}

void llvm::createPruneEHPass(llvm *this)
{
}

void *llvm::ContextTrieNode::getChildContext(void *a1, unsigned int *a2, std::string::value_type *__s, std::string::size_type __sz)
{
  if (__sz)
  {
    unint64_t v6 = llvm::sampleprof::FunctionSamples::getCallSiteHash(__s, __sz, a2);
    uint64_t v9 = (void *)a1[1];
    uint64_t v8 = a1 + 1;
    uint64_t v7 = v9;
    if (!v9) {
      goto LABEL_16;
    }
    uint64_t v10 = v8;
    do
    {
      unint64_t v11 = v7[4];
      BOOL v12 = v11 >= v6;
      if (v11 >= v6) {
        uint64_t v13 = v7;
      }
      else {
        uint64_t v13 = v7 + 1;
      }
      if (v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = (void *)*v13;
    }
    while (*v13);
    if (v10 == v8 || v6 < v10[4]) {
LABEL_16:
    }
      uint64_t v10 = v8;
    if (v10 == v8) {
      return 0;
    }
    else {
      return v10 + 5;
    }
  }
  else
  {
    return llvm::ContextTrieNode::getHottestChildContext(a1, a2);
  }
}

void *llvm::ContextTrieNode::getHottestChildContext(void *a1, _DWORD *a2)
{
  uint64_t v4 = (void *)*a1;
  uint64_t v2 = a1 + 1;
  uint64_t v3 = v4;
  if (v4 == v2) {
    return 0;
  }
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  do
  {
    if (*((_DWORD *)v3 + 26) == *a2 && *((_DWORD *)v3 + 27) == a2[1])
    {
      uint64_t v7 = v3[11];
      if (v7)
      {
        unint64_t v8 = *(void *)(v7 + 56);
        if (v8 > v6)
        {
          unint64_t v6 = v8;
          uint64_t v5 = v3 + 5;
        }
      }
    }
    uint64_t v9 = (void *)v3[1];
    if (v9)
    {
      do
      {
        uint64_t v10 = v9;
        uint64_t v9 = (void *)*v9;
      }
      while (v9);
    }
    else
    {
      do
      {
        uint64_t v10 = (void *)v3[2];
        BOOL v11 = *v10 == (void)v3;
        uint64_t v3 = v10;
      }
      while (!v11);
    }
    uint64_t v3 = v10;
  }
  while (v10 != v2);
  return v5;
}

uint64_t llvm::ContextTrieNode::getFunctionSamples(llvm::ContextTrieNode *this)
{
  return *((void *)this + 6);
}

uint64_t llvm::ContextTrieNode::getCallSiteLoc(llvm::ContextTrieNode *this)
{
  return *((void *)this + 8);
}

uint64_t **llvm::ContextTrieNode::getOrCreateChildContext(uint64_t a1, unsigned int *a2, std::string::value_type *__s, std::string::size_type __sz, int a5)
{
  uint64_t v10 = (uint64_t *)llvm::sampleprof::FunctionSamples::getCallSiteHash(__s, __sz, a2);
  unint64_t v11 = (unint64_t)v10;
  int v31 = v10;
  BOOL v12 = *(void **)(a1 + 8);
  if (v12)
  {
    uint64_t v13 = (void *)(a1 + 8);
    do
    {
      unint64_t v14 = v12[4];
      BOOL v15 = v14 >= (unint64_t)v10;
      if (v14 >= (unint64_t)v10) {
        uint64_t v16 = v12;
      }
      else {
        uint64_t v16 = v12 + 1;
      }
      if (v15) {
        uint64_t v13 = v12;
      }
      BOOL v12 = (void *)*v16;
    }
    while (*v16);
    if (v13 != (void *)(a1 + 8) && (unint64_t)v10 >= v13[4]) {
      return (uint64_t **)(v13 + 5);
    }
  }
  if (!a5) {
    return 0;
  }
  uint64_t v18 = *(void *)a2;
  uint64_t v25 = &v26;
  uint64_t v26 = 0;
  unsigned int v27 = 0;
  *(void *)&long long v28 = a1;
  *((void *)&v28 + 1) = __s;
  long long v29 = __sz;
  LOBYTE(v30) = 0;
  BYTE4(v30) = 0;
  *((void *)&v30 + 1) = v18;
  uint64_t v19 = sub_1CD67E990((uint64_t **)a1, (unint64_t)v10, &v31);
  uint64_t v20 = (uint64_t *)(v19 + 6);
  sub_1CD67E3C0((uint64_t)(v19 + 5), v19[6]);
  int v21 = v26;
  v19[5] = (uint64_t *)&v26;
  v19[6] = v21;
  int v22 = v27;
  v19[7] = v27;
  if (v22)
  {
    v21[2] = (uint64_t)v20;
    uint64_t v25 = &v26;
    uint64_t v26 = 0;
    unsigned int v27 = 0;
    int v21 = 0;
  }
  else
  {
    v19[5] = v20;
  }
  long long v24 = v29;
  long long v23 = v30;
  *((_OWORD *)v19 + 4) = v28;
  *((_OWORD *)v19 + 5) = v24;
  *((_OWORD *)v19 + 6) = v23;
  sub_1CD67E3C0((uint64_t)&v25, v21);
  return sub_1CD67E990((uint64_t **)a1, v11, &v31) + 5;
}

uint64_t llvm::SampleContextTracker::SampleContextTracker(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0x2000000000;
  *(void *)a1 = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = a1 + 48;
  uint64_t v4 = (uint64_t **)(a1 + 40);
  *(void *)(a1 + 56) = 0;
  *(unsigned char *)(a1 + 100) = 0;
  *(void *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(unsigned char *)(a1 + 96) = 0;
  uint64_t v5 = *(uint64_t **)(a2 + 16);
  if (v5)
  {
    while (1)
    {
      BOOL v12 = v5 + 7;
      uint64_t v6 = v5[4];
      uint64_t v7 = v5[5];
      if (v7 == 1) {
        break;
      }
      uint64_t v10 = sub_1CD67EB0C(a1, (unsigned __int8 *)v5[2], v5[3]);
      sub_1CD67EC08((uint64_t)(*v10 + 1), (uint64_t *)&v12, (uint64_t *)&v12);
      uint64_t v13 = 0;
      Childint Context = v4;
      if (v7) {
        goto LABEL_4;
      }
LABEL_6:
      ChildContext[6] = v5 + 7;
      uint64_t v5 = (uint64_t *)*v5;
      if (!v5) {
        return a1;
      }
    }
    uint64_t v13 = 0;
LABEL_4:
    uint64_t v8 = v6 + 24 * v7;
    Childint Context = v4;
    do
    {
      Childint Context = llvm::ContextTrieNode::getOrCreateChildContext((uint64_t)ChildContext, (unsigned int *)&v13, *(std::string::value_type **)v6, *(void *)(v6 + 8), 1);
      uint64_t v13 = *(void *)(v6 + 16);
      v6 += 24;
    }
    while (v6 != v8);
    goto LABEL_6;
  }
  return a1;
}

uint64_t llvm::SampleContextTracker::getCalleeContextSamplesFor(llvm::SampleContextTracker *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4 = *(const llvm::DILocation **)(a2 + 48);
  if (!v4) {
    return 0;
  }
  uint64_t v8 = (int *)sub_1CC3BEC98(a3, a4, (uint64_t)"selected", 8);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v14 = 0;
  uint64_t v10 = sub_1CC9A70C4(v8, v9, llvm::sampleprof::FunctionSamples::UseMD5, (uint64_t)__p);
  CalleeContextFor = llvm::SampleContextTracker::getCalleeContextFor(a1, v4, (std::string::value_type *)v10, v11);
  if (CalleeContextFor) {
    uint64_t v5 = CalleeContextFor[6];
  }
  else {
    uint64_t v5 = 0;
  }
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  return v5;
}

void *llvm::SampleContextTracker::getCalleeContextFor(llvm::SampleContextTracker *a1, const llvm::DILocation *a2, std::string::value_type *a3, std::string::size_type a4)
{
  __n128 result = llvm::SampleContextTracker::getContextFor(a1, a2);
  if (result)
  {
    uint64_t v8 = result;
    unint64_t v9 = llvm::sampleprof::FunctionSamples::getCallSiteIdentifier(a2, 0);
    return llvm::ContextTrieNode::getChildContext(v8, (unsigned int *)&v9, a3, a4);
  }
  return result;
}

void *llvm::SampleContextTracker::getContextFor(llvm::SampleContextTracker *this, const llvm::DILocation *a2)
{
  uint64_t v2 = a2;
  v45[30] = *MEMORY[0x1E4F143B8];
  unint64_t v43 = v45;
  uint64_t v44 = 0xA00000000;
  unsigned int v4 = *((_DWORD *)a2 + 2);
  if (v4 != 2) {
    goto LABEL_14;
  }
  uint64_t v5 = (llvm::sampleprof::FunctionSamples *)*((void *)a2 - 1);
  if (!v5)
  {
    unsigned int v4 = 2;
    goto LABEL_14;
  }
  do
  {
    uint64_t v6 = v5;
    uint64_t Subprogram = llvm::DILocalScope::getSubprogram(*((void *)v2 - 2));
    uint64_t v8 = *(llvm::MDString **)(Subprogram - 8 * *(unsigned int *)(Subprogram + 8) + 24);
    if (!v8 || (uint64_t String = llvm::MDString::getString(v8), !v10))
    {
      uint64_t v11 = llvm::DILocalScope::getSubprogram(*((void *)v2 - *((unsigned int *)v2 + 2)));
      BOOL v12 = *(llvm::MDString **)(v11 - 8 * *(unsigned int *)(v11 + 8) + 16);
      if (!v12)
      {
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        goto LABEL_10;
      }
      uint64_t String = llvm::MDString::getString(v12);
    }
    uint64_t v13 = (unint64_t *)String;
    uint64_t v14 = v10;
LABEL_10:
    unint64_t v40 = llvm::sampleprof::FunctionSamples::getCallSiteIdentifier(v6, 0);
    v41 = v13;
    uint64_t v42 = v14;
    unint64_t v15 = sub_1CD41C4F0((uint64_t)&v43, (unint64_t)&v40, 1);
    uint64_t v16 = (char *)v43 + 24 * v44;
    long long v17 = *(_OWORD *)v15;
    *((void *)v16 + 2) = *(void *)(v15 + 16);
    *(_OWORD *)uint64_t v16 = v17;
    LODWORD(v44) = v44 + 1;
    unsigned int v4 = *((_DWORD *)v6 + 2);
    if (v4 != 2) {
      goto LABEL_13;
    }
    uint64_t v5 = (llvm::sampleprof::FunctionSamples *)*((void *)v6 - 1);
    uint64_t v2 = v6;
  }
  while (v5);
  unsigned int v4 = 2;
LABEL_13:
  uint64_t v2 = v6;
LABEL_14:
  uint64_t v18 = llvm::DILocalScope::getSubprogram(*((void *)v2 - v4));
  uint64_t v19 = *(llvm::MDString **)(v18 - 8 * *(unsigned int *)(v18 + 8) + 24);
  if (!v19 || (uint64_t v20 = (llvm::MDString *)llvm::MDString::getString(v19), !v21))
  {
    uint64_t v22 = llvm::DILocalScope::getSubprogram(*((void *)v2 - *((unsigned int *)v2 + 2)));
    uint64_t v20 = *(llvm::MDString **)(v22 - 8 * *(unsigned int *)(v22 + 8) + 16);
    if (v20) {
      uint64_t v20 = (llvm::MDString *)llvm::MDString::getString(v20);
    }
    else {
      uint64_t v21 = 0;
    }
  }
  unint64_t v40 = 0;
  v41 = (unint64_t *)v20;
  uint64_t v42 = v21;
  unint64_t v23 = sub_1CD41C4F0((uint64_t)&v43, (unint64_t)&v40, 1);
  long long v24 = (char *)v43 + 24 * v44;
  long long v25 = *(_OWORD *)v23;
  *((void *)v24 + 2) = *(void *)(v23 + 16);
  *(_OWORD *)long long v24 = v25;
  uint64_t v26 = (v44 + 1);
  LODWORD(v44) = v44 + 1;
  unint64_t v40 = (unint64_t)&v40;
  v41 = &v40;
  uint64_t v42 = 0;
  if (llvm::sampleprof::FunctionSamples::UseMD5)
  {
    if (v26)
    {
      uint64_t v27 = 24 * v26;
      long long v28 = (size_t *)((char *)v43 + 16);
      long long v29 = &v40;
      do
      {
        long long v30 = operator new(0x28uLL);
        v30[3] = 0;
        v30[4] = 0;
        void v30[2] = 0;
        *long long v30 = v29;
        v30[1] = &v40;
        v29[1] = (unint64_t)v30;
        unint64_t v40 = (unint64_t)v30;
        ++v42;
        sub_1CC9A70C4((int *)*(v28 - 1), *v28, llvm::sampleprof::FunctionSamples::UseMD5, (uint64_t)(v30 + 2));
        long long v29 = (unint64_t *)v40;
        char v31 = *(unsigned char *)(v40 + 39);
        BOOL v32 = v31 < 0;
        if (v31 >= 0) {
          unint64_t v33 = v40 + 16;
        }
        else {
          unint64_t v33 = *(void *)(v40 + 16);
        }
        size_t v34 = v31 & 0x7F;
        if (v32) {
          size_t v34 = *(void *)(v40 + 24);
        }
        *(v28 - 1) = v33;
        *long long v28 = v34;
        v28 += 3;
        v27 -= 24;
      }
      while (v27);
      LODWORD(v26) = v44;
      goto LABEL_29;
    }
    int v37 = 0;
    unint64_t v35 = (void *)((char *)this + 40);
  }
  else
  {
LABEL_29:
    unint64_t v35 = (void *)((char *)this + 40);
    if ((int)v26 < 1)
    {
      int v37 = v26;
    }
    else
    {
      unint64_t v36 = v26;
      do
      {
        int v37 = v36 - 1;
        Childint Context = llvm::ContextTrieNode::getChildContext(v35, (unsigned int *)v43 + 6 * (v36 - 1), *((std::string::value_type **)v43 + 3 * (v36 - 1) + 1), *((void *)v43 + 3 * (v36 - 1) + 2));
        unint64_t v35 = ChildContext;
        if (v36 < 2) {
          break;
        }
        --v36;
      }
      while (ChildContext);
    }
  }
  sub_1CC9A755C((char *)&v40);
  if (v43 != v45) {
    free(v43);
  }
  if (v37 >= 1) {
    return 0;
  }
  else {
    return v35;
  }
}

void *llvm::SampleContextTracker::getContextSamplesFor(llvm::SampleContextTracker *this, const llvm::DILocation *a2)
{
  __n128 result = llvm::SampleContextTracker::getContextFor(this, a2);
  if (result)
  {
    uint64_t v4 = (uint64_t)result;
    __n128 result = (void *)result[6];
    if (result)
    {
      if (*(llvm::SampleContextTracker **)(v4 + 24) != (llvm::SampleContextTracker *)((char *)this + 40)) {
        *((_DWORD *)result + 12) |= 4u;
      }
    }
  }
  return result;
}

void *llvm::SampleContextTracker::getContextFor(uint64_t a1, uint64_t a2)
{
  __n128 result = (void *)(a1 + 40);
  uint64_t v6 = 0;
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    uint64_t v4 = *(void *)(a2 + 16);
    uint64_t v5 = v4 + 24 * v3;
    do
    {
      __n128 result = llvm::ContextTrieNode::getChildContext(result, (unsigned int *)&v6, *(std::string::value_type **)v4, *(void *)(v4 + 8));
      uint64_t v6 = *(void *)(v4 + 16);
      v4 += 24;
    }
    while (v4 != v5);
  }
  return result;
}

uint64_t llvm::SampleContextTracker::getBaseSamplesFor(uint64_t **this, const llvm::Function *a2, int a3)
{
  uint64_t v6 = (int *)sub_1CD553864(a2);

  return llvm::SampleContextTracker::getBaseSamplesFor(this, v6, v5, a3);
}

uint64_t llvm::SampleContextTracker::getBaseSamplesFor(uint64_t **a1, int *a2, size_t a3, int a4)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v21 = 0;
  uint64_t v6 = sub_1CC9A70C4(a2, a3, llvm::sampleprof::FunctionSamples::UseMD5, (uint64_t)__p);
  size_t v8 = v7;
  uint64_t v22 = 0;
  Childint Context = (llvm::ContextTrieNode *)llvm::ContextTrieNode::getChildContext(a1 + 5, (unsigned int *)&v22, (std::string::value_type *)v6, v7);
  if (a4)
  {
    BOOL v12 = sub_1CD67EB0C((uint64_t)a1, (unsigned __int8 *)v6, v8);
    uint64_t v13 = (void *)(*v12)[1];
    uint64_t v14 = (uint64_t)(*v12 + 2);
    if (v13 != (void *)v14)
    {
      do
      {
        uint64_t v15 = v13[4];
        if ((*(unsigned char *)(v15 + 48) & 0xC) == 0)
        {
          ContextFor = (llvm::ContextTrieNode *)llvm::SampleContextTracker::getContextFor((uint64_t)a1, v15 + 16);
          if (ContextFor != ChildContext) {
            Childint Context = (llvm::ContextTrieNode *)llvm::SampleContextTracker::promoteMergeContextSamplesTree((llvm::SampleContextTracker *)a1, ContextFor, a1 + 5, *(_DWORD *)(*((void *)ContextFor + 6) + 40) - 1);
          }
        }
        uint64_t v16 = (void *)v13[1];
        if (v16)
        {
          do
          {
            long long v17 = v16;
            uint64_t v16 = (void *)*v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            long long v17 = (void *)v13[2];
            BOOL v18 = *v17 == (void)v13;
            uint64_t v13 = v17;
          }
          while (!v18);
        }
        uint64_t v13 = v17;
      }
      while (v17 != (void *)v14);
    }
  }
  if (ChildContext) {
    uint64_t v10 = *((void *)ChildContext + 6);
  }
  else {
    uint64_t v10 = 0;
  }
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[0]);
  }
  return v10;
}

void llvm::SampleContextTracker::markContextSamplesInlined(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 48) |= 4u;
}

uint64_t llvm::SampleContextTracker::getRootContext(llvm::SampleContextTracker *this)
{
  return (uint64_t)this + 40;
}

uint64_t **llvm::SampleContextTracker::promoteMergeContextSamplesTree(llvm::SampleContextTracker *this, llvm::ContextTrieNode *a2, uint64_t **a3, unsigned int a4)
{
  uint64_t v8 = *((void *)a2 + 8);
  uint64_t v20 = v8;
  uint64_t v21 = 0;
  unint64_t v9 = (llvm::SampleContextTracker *)((char *)this + 40);
  if ((uint64_t **)((char *)this + 40) != a3) {
    uint64_t v21 = v8;
  }
  uint64_t v10 = *((void *)a2 + 3);
  Childint Context = (llvm::SampleContextTracker *)llvm::ContextTrieNode::getChildContext(a3, (unsigned int *)&v21, *((std::string::value_type **)a2 + 4), *((void *)a2 + 5));
  if (ChildContext)
  {
    BOOL v12 = (uint64_t **)ChildContext;
    llvm::SampleContextTracker::mergeContextNode(ChildContext, a2, ChildContext, a4);
    uint64_t v14 = (char *)a2 + 8;
    uint64_t v15 = *(char **)a2;
    if (*(llvm::ContextTrieNode **)a2 != (llvm::ContextTrieNode *)((char *)a2 + 8))
    {
      do
      {
        llvm::SampleContextTracker::promoteMergeContextSamplesTree(this, (llvm::ContextTrieNode *)(v15 + 40), (llvm::ContextTrieNode *)v12, a4);
        uint64_t v16 = (char *)*((void *)v15 + 1);
        if (v16)
        {
          do
          {
            long long v17 = v16;
            uint64_t v16 = *(char **)v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            long long v17 = (char *)*((void *)v15 + 2);
            BOOL v18 = *(void *)v17 == (void)v15;
            uint64_t v15 = v17;
          }
          while (!v18);
        }
        uint64_t v15 = v17;
      }
      while (v17 != v14);
    }
    sub_1CD67E3C0((uint64_t)a2, *((void **)a2 + 1));
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = v14;
  }
  else
  {
    BOOL v12 = llvm::ContextTrieNode::moveToChildContext(a3, (unsigned int *)&v21, (uint64_t)a2, a4, 0);
  }
  if (v9 == (llvm::ContextTrieNode *)a3)
  {
    unint64_t v19 = llvm::sampleprof::FunctionSamples::getCallSiteHash((std::string::value_type *)v12[4], (std::string::size_type)v12[5], (unsigned int *)&v20);
    sub_1CD67EA7C(v10, v19);
  }
  return v12;
}

uint64_t llvm::SampleContextTracker::getFuncNameFor(llvm::SampleContextTracker *this, llvm::ContextTrieNode *a2)
{
  if (!llvm::sampleprof::FunctionSamples::UseMD5) {
    return *((void *)a2 + 4);
  }
  uint64_t v2 = *((void *)this + 4);
  uint64_t v3 = (const char *)*((void *)a2 + 4);
  std::string::size_type v4 = strlen(v3);
  std::string::__init(&__str, v3, v4);
  unint64_t v5 = std::stoull(&__str, 0, 10);
  int v6 = *(_DWORD *)(v2 + 16);
  if (v6)
  {
    int v7 = v6 - 1;
    unsigned int v8 = v7 & (37 * v5);
    unint64_t v9 = (uint64_t *)(*(void *)v2 + 24 * v8);
    uint64_t v10 = *v9;
    if (v5 == *v9)
    {
LABEL_4:
      uint64_t v11 = v9[1];
      goto LABEL_5;
    }
    int v13 = 1;
    while (v10 != -1)
    {
      unsigned int v14 = v8 + v13++;
      unsigned int v8 = v14 & v7;
      unint64_t v9 = (uint64_t *)(*(void *)v2 + 24 * v8);
      uint64_t v10 = *v9;
      if (v5 == *v9) {
        goto LABEL_4;
      }
    }
  }
  uint64_t v11 = 0;
LABEL_5:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  return v11;
}

uint64_t llvm::SampleContextTracker::mergeContextNode(llvm::SampleContextTracker *this, llvm::ContextTrieNode *a2, llvm::ContextTrieNode *a3, unsigned int a4)
{
  uint64_t v4 = *((void *)a2 + 6);
  uint64_t v5 = *((void *)a3 + 6);
  if (v4) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if (v4)
    {
      *((void *)a3 + 6) = v4;
      *(_DWORD *)(v4 + 48) |= 2u;
      uint64_t v7 = *(void *)(v4 + 40) - a4;
      *(void *)(v4 + 32) += 24 * a4;
      *(void *)(v4 + 40) = v7;
      *((void *)a2 + 6) = 0;
    }
  }
  else
  {
    uint64_t result = sub_1CD67DFD0(*((void *)a3 + 6), *((void *)a2 + 6), 1uLL);
    *(_DWORD *)(v5 + 48) |= 2u;
    *(_DWORD *)(v4 + 48) |= 8u;
    if ((*(unsigned char *)(v4 + 52) & 2) != 0) {
      *(_DWORD *)(v5 + 52) |= 2u;
    }
  }
  return result;
}

uint64_t sub_1CD67DFD0(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (!*(void *)a1) {
    *(void *)a1 = *(void *)a2;
  }
  if (!*(void *)(a1 + 24))
  {
    long long v6 = *(_OWORD *)(a2 + 16);
    long long v7 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + 48) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 16) = v6;
    *(_OWORD *)(a1 + 32) = v7;
  }
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(a2 + 8);
  if (v8)
  {
    if (v8 != v9) {
      return 14;
    }
  }
  else
  {
    *(void *)(a1 + 8) = v9;
  }
  LODWORD(v10) = sub_1CC9A75E0(a1, *(void *)(a2 + 56), a3);
  unsigned int v11 = sub_1CC9A7664(a1, *(void *)(a2 + 64), a3);
  if (v11) {
    BOOL v12 = v10 == 0;
  }
  else {
    BOOL v12 = 0;
  }
  if (v12) {
    uint64_t v10 = v11;
  }
  else {
    uint64_t v10 = v10;
  }
  int v13 = *(void **)(a2 + 72);
  if (v13 != (void *)(a2 + 80))
  {
    do
    {
      BOOL v32 = v13 + 4;
      unsigned int v14 = sub_1CD67E6E4(a1 + 72, (unsigned int *)v13 + 8, (uint64_t)&std::piecewise_construct, &v32);
      unsigned int v15 = llvm::sampleprof::SampleRecord::merge((uint64_t *)v14 + 5, (uint64_t)(v13 + 5), a3);
      if (v15) {
        BOOL v16 = v10 == 0;
      }
      else {
        BOOL v16 = 0;
      }
      if (v16) {
        uint64_t v10 = v15;
      }
      else {
        uint64_t v10 = v10;
      }
      long long v17 = (void *)v13[1];
      if (v17)
      {
        do
        {
          BOOL v18 = v17;
          long long v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          BOOL v18 = (void *)v13[2];
          BOOL v12 = *v18 == (void)v13;
          int v13 = v18;
        }
        while (!v12);
      }
      int v13 = v18;
    }
    while (v18 != (void *)(a2 + 80));
  }
  unint64_t v19 = *(void **)(a2 + 96);
  if (v19 != (void *)(a2 + 104))
  {
    uint64_t v20 = a1 + 96;
    do
    {
      BOOL v32 = v19 + 4;
      uint64_t v21 = sub_1CD67E818(v20, (unsigned int *)v19 + 8, (uint64_t)&std::piecewise_construct, &v32);
      uint64_t v22 = (void *)v19[5];
      if (v22 != v19 + 6)
      {
        uint64_t v23 = (uint64_t)(v21 + 5);
        do
        {
          BOOL v32 = v22 + 4;
          long long v24 = sub_1CD67E8D4(v23, (uint64_t)(v22 + 4), (uint64_t)&std::piecewise_construct, (long long **)&v32);
          unsigned int v25 = sub_1CD67DFD0(v24 + 7, v22 + 7, a3);
          if (v25) {
            BOOL v26 = v10 == 0;
          }
          else {
            BOOL v26 = 0;
          }
          if (v26) {
            uint64_t v10 = v25;
          }
          else {
            uint64_t v10 = v10;
          }
          uint64_t v27 = (void *)v22[1];
          if (v27)
          {
            do
            {
              long long v28 = v27;
              uint64_t v27 = (void *)*v27;
            }
            while (v27);
          }
          else
          {
            do
            {
              long long v28 = (void *)v22[2];
              BOOL v12 = *v28 == (void)v22;
              uint64_t v22 = v28;
            }
            while (!v12);
          }
          uint64_t v22 = v28;
        }
        while (v28 != v19 + 6);
      }
      long long v29 = (void *)v19[1];
      if (v29)
      {
        do
        {
          long long v30 = v29;
          long long v29 = (void *)*v29;
        }
        while (v29);
      }
      else
      {
        do
        {
          long long v30 = (void *)v19[2];
          BOOL v12 = *v30 == (void)v19;
          unint64_t v19 = v30;
        }
        while (!v12);
      }
      unint64_t v19 = v30;
    }
    while (v30 != (void *)(a2 + 104));
  }
  return v10;
}

void sub_1CD67E220(uint64_t a1, void *a2, void *a3)
{
  if (*(void *)(a1 + 16))
  {
    long long v6 = *(uint64_t **)a1;
    uint64_t v7 = *(void *)(a1 + 8);
    *(void *)a1 = a1 + 8;
    *(void *)(v7 + 16) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 8) = 0;
    uint64_t v8 = v6[1] ? v6[1] : (uint64_t)v6;
    if (v8)
    {
      BOOL v12 = sub_1CD4F3428(v8);
      if (a2 == a3)
      {
        int v13 = (void *)v8;
      }
      else
      {
        unsigned int v15 = a2;
        do
        {
          int v13 = v12;
          *(void *)(v8 + 32) = v15[4];
          if ((void *)v8 != v15) {
            sub_1CD67E220(v8 + 40, v15[5], v15 + 6);
          }
          long long v16 = *((_OWORD *)v15 + 4);
          long long v17 = *((_OWORD *)v15 + 6);
          *(_OWORD *)(v8 + 80) = *((_OWORD *)v15 + 5);
          *(_OWORD *)(v8 + 96) = v17;
          *(_OWORD *)(v8 + 64) = v16;
          sub_1CD6741E0((uint64_t **)a1, (uint64_t *)v8);
          if (v12) {
            BOOL v12 = sub_1CD4F3428((uint64_t)v12);
          }
          else {
            BOOL v12 = 0;
          }
          BOOL v18 = (void *)v15[1];
          if (v18)
          {
            do
            {
              a2 = v18;
              BOOL v18 = (void *)*v18;
            }
            while (v18);
          }
          else
          {
            do
            {
              a2 = (void *)v15[2];
              BOOL v11 = *a2 == (void)v15;
              unsigned int v15 = a2;
            }
            while (!v11);
          }
          if (!v13) {
            break;
          }
          unsigned int v15 = a2;
          uint64_t v8 = (uint64_t)v13;
        }
        while (a2 != a3);
      }
      sub_1CD67E3C0(a1, v13);
      if (v12)
      {
        do
        {
          unsigned int v14 = v12;
          BOOL v12 = (void *)v12[2];
        }
        while (v12);
        sub_1CD67E3C0(a1, v14);
      }
    }
  }
  if (a2 != a3)
  {
    do
    {
      sub_1CD67E420((uint64_t **)a1, a2 + 4);
      uint64_t v9 = (void *)a2[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)a2[2];
          BOOL v11 = *v10 == (void)a2;
          a2 = v10;
        }
        while (!v11);
      }
      a2 = v10;
    }
    while (v10 != a3);
  }
}

void sub_1CD67E3C0(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1CD67E3C0(a1, *a2);
    sub_1CD67E3C0(a1, a2[1]);
    sub_1CD67E3C0(a2 + 5, a2[6]);
    operator delete(a2);
  }
}

uint64_t *sub_1CD67E420(uint64_t **a1, uint64_t *a2)
{
  uint64_t v4 = (uint64_t *)operator new(0x70uLL);
  v4[4] = *a2;
  sub_1CD67E4E8((uint64_t)(v4 + 5), (uint64_t)(a2 + 1));
  uint64_t v5 = a1 + 1;
  long long v6 = a1[1];
  if (v6)
  {
    do
    {
      while (1)
      {
        uint64_t v5 = (uint64_t **)v6;
        if (v4[4] >= (unint64_t)v6[4]) {
          break;
        }
        long long v6 = (uint64_t *)*v6;
        uint64_t v7 = v5;
        if (!*v5) {
          goto LABEL_8;
        }
      }
      long long v6 = (uint64_t *)v6[1];
    }
    while (v6);
    uint64_t v7 = v5 + 1;
  }
  else
  {
    uint64_t v7 = a1 + 1;
  }
LABEL_8:
  *uint64_t v4 = 0;
  v4[1] = 0;
  v4[2] = (uint64_t)v5;
  *uint64_t v7 = v4;
  uint64_t v8 = (uint64_t *)**a1;
  if (v8)
  {
    *a1 = v8;
    uint64_t v4 = *v7;
  }
  uint64_t result = sub_1CB8358B8(a1[1], v4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t sub_1CD67E4E8(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v4 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  uint64_t v5 = (void *)(a2 + 8);
  long long v6 = *(void **)a2;
  if (*(void *)a2 != a2 + 8)
  {
    do
    {
      sub_1CD67E5A8((void **)a1, v4, v6[4], (uint64_t)(v6 + 4));
      uint64_t v7 = (void *)v6[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (void *)v6[2];
          BOOL v9 = *v8 == (void)v6;
          long long v6 = v8;
        }
        while (!v9);
      }
      long long v6 = v8;
    }
    while (v8 != v5);
  }
  long long v10 = *(_OWORD *)(a2 + 24);
  long long v11 = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v11;
  *(_OWORD *)(a1 + 24) = v10;
  return a1;
}

void *sub_1CD67E5A8(void **a1, void *a2, unint64_t a3, uint64_t a4)
{
  uint64_t result = sub_1CD4CA0D8(a1, a2, &v17, &v16, a3);
  if (!*result)
  {
    uint64_t v7 = result;
    uint64_t v8 = operator new(0x70uLL);
    BOOL v9 = *(void **)(a4 + 8);
    v8[4] = *(void *)a4;
    v8[6] = 0;
    v8[5] = v8 + 6;
    v8[7] = 0;
    if (v9 != (void *)(a4 + 16))
    {
      do
      {
        sub_1CD67E5A8(v8 + 5, v8 + 6, v9[4], v9 + 4);
        long long v10 = (void *)v9[1];
        if (v10)
        {
          do
          {
            long long v11 = v10;
            long long v10 = (void *)*v10;
          }
          while (v10);
        }
        else
        {
          do
          {
            long long v11 = (void *)v9[2];
            BOOL v12 = *v11 == (void)v9;
            BOOL v9 = v11;
          }
          while (!v12);
        }
        BOOL v9 = v11;
      }
      while (v11 != (void *)(a4 + 16));
    }
    long long v13 = *(_OWORD *)(a4 + 48);
    *((_OWORD *)v8 + 4) = *(_OWORD *)(a4 + 32);
    *((_OWORD *)v8 + 5) = v13;
    *((_OWORD *)v8 + 6) = *(_OWORD *)(a4 + 64);
    uint64_t v14 = v17;
    void *v8 = 0;
    v8[1] = 0;
    void v8[2] = v14;
    *uint64_t v7 = v8;
    unsigned int v15 = (void *)**a1;
    if (v15)
    {
      *a1 = v15;
      uint64_t v8 = (void *)*v7;
    }
    uint64_t result = sub_1CB8358B8(a1[1], v8);
    a1[2] = (void *)((char *)a1[2] + 1);
  }
  return result;
}

char *sub_1CD67E6E4(uint64_t a1, unsigned int *a2, uint64_t a3, void **a4)
{
  long long v6 = sub_1CD67E7AC(a1, &v13, a2);
  uint64_t v7 = (char *)*v6;
  if (!*v6)
  {
    BOOL v9 = v6;
    uint64_t v7 = (char *)operator new(0x50uLL);
    *((void *)v7 + 4) = **a4;
    *(_OWORD *)(v7 + 56) = 0u;
    *((void *)v7 + 9) = 0;
    *(_OWORD *)(v7 + 40) = 0u;
    *((_DWORD *)v7 + 17) = 16;
    uint64_t v10 = v13;
    *(void *)uint64_t v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = v10;
    *BOOL v9 = (uint64_t)v7;
    uint64_t v11 = **(void **)a1;
    BOOL v12 = (uint64_t *)v7;
    if (v11)
    {
      *(void *)a1 = v11;
      BOOL v12 = (uint64_t *)*v9;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v12);
    ++*(void *)(a1 + 16);
  }
  return v7;
}

uint64_t *sub_1CD67E7AC(uint64_t a1, void *a2, unsigned int *a3)
{
  uint64_t v5 = *(uint64_t **)(a1 + 8);
  uint64_t result = (uint64_t *)(a1 + 8);
  uint64_t v4 = v5;
  if (v5)
  {
    unsigned int v6 = *a3;
    unsigned int v7 = a3[1];
    while (1)
    {
      while (1)
      {
        uint64_t v8 = v4;
        unsigned int v9 = *((_DWORD *)v4 + 8);
        if (v6 >= v9) {
          break;
        }
LABEL_4:
        uint64_t v4 = (uint64_t *)*v8;
        uint64_t result = v8;
        if (!*v8) {
          goto LABEL_14;
        }
      }
      if (v6 == v9)
      {
        unsigned int v10 = *((_DWORD *)v8 + 9);
        if (v7 < v10) {
          goto LABEL_4;
        }
        if (v10 >= v7) {
          goto LABEL_14;
        }
      }
      else if (v9 >= v6)
      {
        goto LABEL_14;
      }
      uint64_t result = v8 + 1;
      uint64_t v4 = (uint64_t *)v8[1];
      if (!v4) {
        goto LABEL_14;
      }
    }
  }
  uint64_t v8 = result;
LABEL_14:
  *a2 = v8;
  return result;
}

uint64_t *sub_1CD67E818(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t **a4)
{
  unsigned int v6 = sub_1CD67E7AC(a1, &v14, a2);
  unsigned int v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    unsigned int v9 = v6;
    unsigned int v7 = (uint64_t *)operator new(0x40uLL);
    uint64_t v10 = **a4;
    v7[7] = 0;
    v7[6] = 0;
    v7[4] = v10;
    v7[5] = (uint64_t)(v7 + 6);
    uint64_t v11 = v14;
    *unsigned int v7 = 0;
    v7[1] = 0;
    uint64_t v7[2] = v11;
    *unsigned int v9 = (uint64_t)v7;
    uint64_t v12 = **(void **)a1;
    uint64_t v13 = v7;
    if (v12)
    {
      *(void *)a1 = v12;
      uint64_t v13 = (uint64_t *)*v9;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v13);
    ++*(void *)(a1 + 16);
  }
  return v7;
}

uint64_t *sub_1CD67E8D4(uint64_t a1, uint64_t a2, uint64_t a3, long long **a4)
{
  unsigned int v6 = (uint64_t **)sub_1CD4AF8D4(a1, &v13, a2);
  unsigned int v7 = *v6;
  if (!*v6)
  {
    unsigned int v9 = v6;
    unsigned int v7 = (uint64_t *)operator new(0xB0uLL);
    uint64_t v14 = *a4;
    sub_1CC9A76E8((uint64_t)(v7 + 4), &v14);
    uint64_t v10 = v13;
    *unsigned int v7 = 0;
    v7[1] = 0;
    uint64_t v7[2] = v10;
    *unsigned int v9 = v7;
    uint64_t v11 = **(void **)a1;
    uint64_t v12 = v7;
    if (v11)
    {
      *(void *)a1 = v11;
      uint64_t v12 = *v9;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v12);
    ++*(void *)(a1 + 16);
  }
  return v7;
}

uint64_t **sub_1CD67E990(uint64_t **a1, unint64_t a2, uint64_t **a3)
{
  unsigned int v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        unsigned int v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        unsigned int v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    unsigned int v7 = a1 + 1;
LABEL_9:
    unsigned int v9 = (uint64_t *)v7;
    unsigned int v7 = (uint64_t **)operator new(0x70uLL);
    uint64_t v10 = *a3;
    v7[7] = 0;
    v7[6] = 0;
    v7[4] = v10;
    v7[5] = (uint64_t *)(v7 + 6);
    *((unsigned char *)v7 + 100) = 0;
    v7[13] = 0;
    *unsigned int v7 = 0;
    v7[1] = 0;
    *((_OWORD *)v7 + 4) = 0u;
    *((_OWORD *)v7 + 5) = 0u;
    *((unsigned char *)v7 + 96) = 0;
    uint64_t v7[2] = v9;
    *unsigned int v6 = (uint64_t *)v7;
    uint64_t v11 = (uint64_t *)**a1;
    uint64_t v12 = (uint64_t *)v7;
    if (v11)
    {
      *a1 = v11;
      uint64_t v12 = *v6;
    }
    sub_1CB8358B8(a1[1], v12);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void sub_1CD67EA7C(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (uint64_t *)(a1 + 8);
    do
    {
      unint64_t v4 = v2[4];
      BOOL v5 = v4 >= a2;
      if (v4 >= a2) {
        unsigned int v6 = v2;
      }
      else {
        unsigned int v6 = v2 + 1;
      }
      if (v5) {
        uint64_t v3 = v2;
      }
      uint64_t v2 = (void *)*v6;
    }
    while (*v6);
    if (v3 != (uint64_t *)(a1 + 8) && v3[4] <= a2)
    {
      sub_1CD491B50((uint64_t **)a1, v3);
      sub_1CD67E3C0((uint64_t)(v3 + 5), (void *)v3[6]);
      operator delete(v3);
    }
  }
}

size_t **sub_1CD67EB0C(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  uint64_t v6 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  unint64_t i = (size_t **)(*(void *)a1 + 8 * v6);
  unint64_t v8 = *i;
  if (*i == (size_t *)-8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v8)
  {
    while (!v8 || v8 == (size_t *)-8)
    {
      unsigned int v9 = i[1];
      ++i;
      unint64_t v8 = v9;
    }
    return i;
  }
  buffer = llvm::allocate_buffer(a3 + 33, (std::align_val_t)8uLL);
  uint64_t v12 = buffer;
  uint64_t v13 = (char *)(buffer + 4);
  if (a3) {
    memcpy(buffer + 4, a2, a3);
  }
  v13[a3] = 0;
  v12[3] = 0;
  uint64_t v12[2] = 0;
  *uint64_t v12 = a3;
  v12[1] = (size_t)(v12 + 2);
  *unint64_t i = v12;
  ++*(_DWORD *)(a1 + 12);
  for (unint64_t i = (size_t **)(*(void *)a1
                      + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v6));
        !*i || *i + 1 == 0;
  return i;
}

uint64_t **sub_1CD67EC08(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t result = (uint64_t **)sub_1CD67ECA8(a1, &v11, a2);
  if (!*result)
  {
    uint64_t v6 = result;
    unsigned int v7 = (uint64_t *)operator new(0x28uLL);
    v7[4] = *a3;
    uint64_t v8 = v11;
    *unsigned int v7 = 0;
    v7[1] = 0;
    uint64_t v7[2] = v8;
    *uint64_t v6 = v7;
    uint64_t v9 = **(void **)a1;
    if (v9)
    {
      *(void *)a1 = v9;
      uint64_t v10 = *v6;
    }
    else
    {
      uint64_t v10 = v7;
    }
    uint64_t result = (uint64_t **)sub_1CB8358B8(*(uint64_t **)(a1 + 8), v10);
    ++*(void *)(a1 + 16);
  }
  return result;
}

void *sub_1CD67ECA8(uint64_t a1, void *a2, uint64_t *a3)
{
  BOOL v5 = (void *)(a1 + 8);
  unint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v7 = v4;
        uint64_t v8 = *a3;
        uint64_t v9 = v4[4];
        unint64_t v10 = *(void *)(*a3 + 56);
        unint64_t v11 = *(void *)(v9 + 56);
        if (v10 != v11) {
          break;
        }
        if (sub_1CD67ED6C(v8 + 16, v9 + 16)) {
          goto LABEL_4;
        }
        uint64_t v9 = v7[4];
        uint64_t v8 = *a3;
        unint64_t v11 = *(void *)(v9 + 56);
        unint64_t v10 = *(void *)(*a3 + 56);
LABEL_8:
        if (v11 == v10)
        {
          if (!sub_1CD67ED6C(v9 + 16, v8 + 16)) {
            goto LABEL_15;
          }
        }
        else if (v11 <= v10)
        {
          goto LABEL_15;
        }
        BOOL v5 = v7 + 1;
        unint64_t v4 = (void *)v7[1];
        if (!v4) {
          goto LABEL_15;
        }
      }
      if (v10 <= v11) {
        goto LABEL_8;
      }
LABEL_4:
      unint64_t v4 = (void *)*v7;
      BOOL v5 = v7;
      if (!*v7) {
        goto LABEL_15;
      }
    }
  }
  unsigned int v7 = (void *)(a1 + 8);
LABEL_15:
  *a2 = v7;
  return v5;
}

BOOL sub_1CD67ED6C(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 32);
  unsigned int v3 = *(_DWORD *)(a2 + 32);
  BOOL v4 = v2 >= v3;
  if (v2 != v3) {
    return !v4;
  }
  if (!v2)
  {
    unint64_t v17 = *(void *)(a2 + 8);
    unint64_t v18 = *(void *)(a1 + 8);
    if (v17 >= v18) {
      size_t v19 = *(void *)(a1 + 8);
    }
    else {
      size_t v19 = *(void *)(a2 + 8);
    }
    if (v19 && (int v20 = memcmp(*(const void **)a1, *(const void **)a2, v19)) != 0)
    {
      int v21 = (v20 >> 31) | 1;
    }
    else
    {
      if (v18 < v17) {
        int v21 = -1;
      }
      else {
        int v21 = 1;
      }
      if (v18 == v17) {
        int v21 = 0;
      }
    }
    return v21 == -1;
  }
  unint64_t v5 = *(void *)(a1 + 24);
  unint64_t v6 = *(void *)(a2 + 24);
  if (v6 >= v5) {
    uint64_t v7 = *(void *)(a1 + 24);
  }
  else {
    uint64_t v7 = *(void *)(a2 + 24);
  }
  if (!v7)
  {
LABEL_17:
    BOOL v4 = v5 >= v6;
    return !v4;
  }
  uint64_t v8 = (_DWORD *)(*(void *)(a1 + 16) + 16);
  uint64_t v9 = (_DWORD *)(*(void *)(a2 + 16) + 16);
  while (1)
  {
    unint64_t v10 = *((void *)v9 - 1);
    unint64_t v11 = *((void *)v8 - 1);
    size_t v12 = v10 >= v11 ? *((void *)v8 - 1) : *((void *)v9 - 1);
    if (v12)
    {
      unsigned int v13 = memcmp(*((const void **)v8 - 2), *((const void **)v9 - 2), v12);
      if (v13) {
        return v13 >> 31;
      }
    }
    BOOL v4 = v11 >= v10;
    if (v11 != v10) {
      return !v4;
    }
    BOOL v4 = *v8 >= *v9;
    if (*v8 != *v9) {
      return !v4;
    }
    unsigned int v14 = v8[1];
    unsigned int v15 = v9[1];
    BOOL v4 = v14 >= v15;
    if (v14 != v15) {
      return !v4;
    }
    v8 += 6;
    v9 += 6;
    if (!--v7) {
      goto LABEL_17;
    }
  }
}

void llvm::createSampleProfileLoaderPass()
{
}

void llvm::SampleProfileLoaderPass::run()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::AnalysisManager<llvm::Module>::getResultImpl();
}

uint64_t sub_1CD67F340(uint64_t a1, long long *a2, long long *a3, uint64_t *a4)
{
  *(void *)a1 = &unk_1F262A910;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_DWORD *)(a1 + 24) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_DWORD *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = a1 + 112;
  *(void *)(a1 + 88) = a1 + 112;
  *(void *)(a1 + 96) = 32;
  *(_DWORD *)(a1 + 104) = 0;
  *(void *)(a1 + 368) = a1 + 384;
  *(void *)(a1 + 376) = 0x2000000000;
  *(_OWORD *)(a1 + 904) = 0u;
  *(void *)(a1 + 896) = a1 + 904;
  uint64_t v7 = (_OWORD *)(a1 + 920);
  uint64_t v8 = a1 + 944;
  uint64_t v9 = (_OWORD *)(a1 + 1016);
  *(void *)(a1 + 1040) = 0;
  *(unsigned char *)(a1 + 1048) = 0;
  uint64_t v10 = a1 + 1072;
  *(_DWORD *)(a1 + 936) = 0;
  *uint64_t v7 = 0u;
  *(_OWORD *)(a1 + 944) = 0u;
  *(_OWORD *)(a1 + 960) = 0u;
  *(_OWORD *)(v8 + 28) = 0u;
  *(_DWORD *)(a1 + 1008) = 0;
  *(_OWORD *)(a1 + 992) = 0u;
  *(_DWORD *)(a1 + 1032) = 0;
  *uint64_t v9 = 0u;
  *(_OWORD *)(a1 + 1056) = 0u;
  if (*((char *)a2 + 23) < 0)
  {
    sub_1CB8BDF7C(v10, *(const void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v11 = *a2;
    *(void *)(v10 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v10 = v11;
  }
  size_t v12 = (_OWORD *)(a1 + 1096);
  if (*((char *)a3 + 23) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v12, *(const void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v13 = *a3;
    *(void *)(a1 + 1112) = *((void *)a3 + 2);
    *size_t v12 = v13;
  }
  uint64_t v14 = *a4;
  *(void *)(a1 + 1120) = *a4;
  if (v14) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v14 + 8), 1u, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 1128) = 0u;
  return a1;
}

void sub_1CD67F494(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t sub_1CD67F4A4(uint64_t a1, uint64_t a2)
{
  unint64_t v6 = *(llvm::sampleprof::FunctionSamples **)(a2 + 48);
  if (!v6) {
    return *(void *)(a1 + 1064);
  }
  sub_1CD5563B4(a1 + 8, &v6, (uint64_t)&v4);
  if (!v5) {
    return *(void *)(v4 + 8);
  }
  uint64_t result = llvm::sampleprof::FunctionSamples::findFunctionSamples(*(void *)(a1 + 1064), v6, *(void *)(*(void *)(a1 + 1056) + 112));
  *(void *)(v4 + 8) = result;
  return result;
}

void sub_1CD67F528(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = (*(uint64_t (**)(void *, uint64_t))(*a2 + 8))(a2, a3);
  if (v6 && (uint64_t v8 = *(void *)(a3 + 48)) != 0)
  {
    uint64_t v10 = (const std::error_category *)v6;
    unsigned int Offset = llvm::sampleprof::FunctionSamples::getOffset(*(llvm::sampleprof::FunctionSamples **)(a3 + 48), v7);
    unsigned int v17 = Offset;
    if (byte_1EBD064B8)
    {
      uint64_t v14 = *(void *)(v8 - 8 * *(unsigned int *)(v8 + 8));
      if (*(unsigned char *)v14 == 19) {
        unsigned int v12 = *(_DWORD *)(v14 + 24);
      }
      else {
        unsigned int v12 = 0;
      }
    }
    else
    {
      unsigned int v12 = sub_1CD495F94(v8);
    }
    unsigned int v16 = v12;
    sub_1CD555FF8(v10, Offset, v12, a1);
    if ((*(unsigned char *)(a1 + 16) & 1) == 0
      && llvm::sampleprofutil::SampleCoverageTracker::markSamplesUsed((llvm::sampleprofutil::SampleCoverageTracker *)(a2 + 127), (const llvm::sampleprof::FunctionSamples *)v10, Offset, v12, *(void *)a1))
    {
      long long v13 = (uint64_t ***)a2[142];
      v15[0] = a3;
      v15[1] = a1;
      v15[2] = &v17;
      v15[3] = &v16;
      sub_1CC9AE208(v13, (uint64_t)v15);
    }
  }
  else
  {
    uint64_t v9 = std::system_category();
    *(unsigned char *)(a1 + 16) |= 1u;
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = v9;
  }
}

uint64_t *sub_1CD67F668(uint64_t a1, unsigned int a2, unsigned int a3)
{
  char v5 = *(uint64_t **)(a1 + 8);
  unsigned int v3 = (uint64_t *)(a1 + 8);
  uint64_t v4 = v5;
  if (!v5) {
    return v3;
  }
  uint64_t v6 = v3;
  do
  {
    unsigned int v7 = *((_DWORD *)v4 + 8);
    if (v7 >= a2)
    {
      if (v7 == a2)
      {
        if (*((_DWORD *)v4 + 9) < a3) {
          ++v4;
        }
        else {
          uint64_t v6 = v4;
        }
      }
      else
      {
        uint64_t v6 = v4;
      }
    }
    else
    {
      ++v4;
    }
    uint64_t v4 = (uint64_t *)*v4;
  }
  while (v4);
  if (v6 == v3) {
    return v3;
  }
  unsigned int v8 = *((_DWORD *)v6 + 8);
  if (v8 > a2 || v8 == a2 && *((_DWORD *)v6 + 9) > a3) {
    return v3;
  }
  return v6;
}

uint64_t sub_1CD67F6F0(uint64_t result)
{
  if (*(_DWORD *)(result + 12))
  {
    uint64_t v1 = result;
    uint64_t v2 = *(unsigned int *)(result + 8);
    if (v2)
    {
      uint64_t v3 = 0;
      uint64_t v4 = 8 * v2;
      do
      {
        uint64_t v5 = *(void *)v1;
        uint64_t result = *(void *)(*(void *)v1 + v3);
        if (result != -8 && result != 0) {
          uint64_t result = MEMORY[0x1D25D9CD0]();
        }
        *(void *)(v5 + v3) = 0;
        v3 += 8;
      }
      while (v4 != v3);
    }
    *(_DWORD *)(v1 + 12) = 0;
    *(_DWORD *)(v1 + 16) = 0;
  }
  return result;
}

uint64_t sub_1CD67F760(uint64_t a1)
{
  return a1;
}

uint64_t sub_1CD67F798(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 12))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 8);
    if (v2)
    {
      uint64_t v3 = 0;
      uint64_t v4 = 8 * v2;
      do
      {
        uint64_t v5 = *(void *)(*(void *)a1 + v3);
        if (v5 != -8 && v5 != 0)
        {
          sub_1CD40B1BC(*(void **)(v5 + 16));
          MEMORY[0x1D25D9CD0](v5, 8);
        }
        v3 += 8;
      }
      while (v4 != v3);
    }
  }
  free(*(void **)a1);
  return a1;
}

void sub_1CD67F820(uint64_t a1)
{
  sub_1CD3C7F68((_DWORD *)(a1 + 32));
  sub_1CD553F7C((_DWORD *)(a1 + 56));
  sub_1CBFF3560((llvm::SmallPtrSetImplBase *)(a1 + 80));
  *(_DWORD *)(a1 + 376) = 0;
  sub_1CD40B1BC(*(void **)(a1 + 904));
  *(void *)(a1 + 896) = a1 + 904;
  *(void *)(a1 + 912) = 0;
  *(void *)(a1 + 904) = 0;
  sub_1CD3C7F68((_DWORD *)(a1 + 920));
  uint64_t v2 = *(void *)(a1 + 944);
  *(void *)(a1 + 944) = 0;
  if (v2) {
    sub_1CBF8FF20(a1 + 944, v2);
  }
  uint64_t v3 = *(void *)(a1 + 952);
  *(void *)(a1 + 952) = 0;
  if (v3) {
    sub_1CBF8FFEC(a1 + 952, v3);
  }
  uint64_t v4 = *(void *)(a1 + 960);
  *(void *)(a1 + 960) = 0;
  if (v4) {
    llvm::LoopInfoBase<llvm::BasicBlock,llvm::Loop>::~LoopInfoBase();
  }
  sub_1CD553FD0((_DWORD *)(a1 + 968));
  sub_1CD553FD0((_DWORD *)(a1 + 992));
  sub_1CD5541B0((_DWORD *)(a1 + 1016));
  *(void *)(a1 + 1040) = 0;
}

uint64_t sub_1CD67F8E4(uint64_t a1, uint64_t a2, void *a3, _OWORD *a4)
{
  unsigned int v12 = 0;
  uint64_t result = sub_1CD4F89F8((uint64_t *)a2, a3, &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD4F8A9C(a2, (uint64_t)a3, a3, v12);
    uint64_t v9 = (void *)result;
    *(void *)uint64_t result = *a3;
    *(_OWORD *)(result + 8) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 24 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

size_t **sub_1CD67F984(uint64_t a1, unsigned __int8 *a2, size_t a3, size_t *a4)
{
  uint64_t v8 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  unint64_t i = (size_t **)(*(void *)a1 + 8 * v8);
  char v10 = *i;
  if (*i == (size_t *)-8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v10)
  {
    while (!v10 || v10 == (size_t *)-8)
    {
      uint64_t v11 = i[1];
      ++i;
      char v10 = v11;
    }
    return i;
  }
  unsigned int v12 = operator new(a3 + 17, (std::align_val_t)8uLL);
  long long v13 = v12;
  uint64_t v14 = (char *)(v12 + 2);
  if (a3) {
    memcpy(v12 + 2, a2, a3);
  }
  v14[a3] = 0;
  size_t v15 = *a4;
  *long long v13 = a3;
  v13[1] = v15;
  *unint64_t i = v13;
  ++*(_DWORD *)(a1 + 12);
  for (unint64_t i = (size_t **)(*(void *)a1
                      + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v8));
        !*i || *i + 1 == 0;
  return i;
}

void sub_1CD67FA88(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  uint64_t v6 = a1 + 40;
  int Key = llvm::StringMapImpl::FindKey((uint64_t *)(a1 + 40), a2, a3);
  if (Key == -1 || Key == (unint64_t)*(unsigned int *)(a1 + 48))
  {
    *(void *)&long long v14 = a2;
    *((void *)&v14 + 1) = a3;
    size_t v15 = 0;
    size_t v16 = 0;
    uint64_t v8 = *sub_1CD67FF38(v6, a2, a3);
    *(_OWORD *)(v8 + 1) = v14;
    uint64_t v9 = v8 + 4;
    sub_1CD40B1BC((void *)v8[4]);
    v8[3] = (size_t)&v15;
    char v10 = v15;
    v8[4] = (size_t)v15;
    size_t v11 = v16;
    v8[5] = v16;
    if (v11)
    {
      unsigned int v12 = 0;
      void v10[2] = v9;
      size_t v15 = 0;
      size_t v16 = 0;
    }
    else
    {
      v8[3] = (size_t)v9;
      unsigned int v12 = v15;
    }
    sub_1CD40B1BC(v12);
    long long v13 = sub_1CD67FF38(v6, a2, a3);
    sub_1CD680660(a1 + 16, a1, (uint64_t)(*v13 + 1), 0);
  }
}

BOOL sub_1CD67FB9C(void *a1)
{
  if (!llvm::sampleprof::FunctionSamples::ProfileIsCSFlat || (uint64_t v2 = a1[8]) == 0)
  {
    if (a1[11])
    {
      uint64_t v4 = a1[9];
      if (!a1[14]
        || (uint64_t v5 = a1[12], v6 = *(_DWORD *)(v4 + 32), v7 = *(_DWORD *)(v5 + 32), v6 < v7)
        || v6 == v7 && *(_DWORD *)(v4 + 36) < *(_DWORD *)(v5 + 36))
      {
        uint64_t v2 = *(void *)(v4 + 40);
LABEL_8:
        if (v2) {
          return v2;
        }
        return a1[7] != 0;
      }
    }
    else
    {
      if (!a1[14]) {
        return a1[7] != 0;
      }
      uint64_t v5 = a1[12];
    }
    uint64_t v8 = *(void **)(v5 + 40);
    uint64_t v9 = (void *)(v5 + 48);
    if (v8 == (void *)(v5 + 48)) {
      return a1[7] != 0;
    }
    uint64_t v2 = 0;
    do
    {
      uint64_t v10 = sub_1CD67FB9C(v8 + 7);
      size_t v11 = (void *)v8[1];
      if (v11)
      {
        do
        {
          unsigned int v12 = v11;
          size_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          unsigned int v12 = (void *)v8[2];
          BOOL v13 = *v12 == (void)v8;
          uint64_t v8 = v12;
        }
        while (!v13);
      }
      v2 += v10;
      uint64_t v8 = v12;
    }
    while (v12 != v9);
    goto LABEL_8;
  }
  return v2;
}

llvm::StringMapImpl *sub_1CD67FCA4(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  unsigned int v6 = sub_1CD67F668(a2 + 72, a3, a4);
  if ((uint64_t *)(a2 + 80) == v6)
  {
    uint64_t result = (llvm::StringMapImpl *)std::system_category();
    *(unsigned char *)(a1 + 32) |= 1u;
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = result;
  }
  else
  {
    *(unsigned char *)(a1 + 32) &= ~1u;
    return sub_1CD67FE2C((llvm::StringMapImpl *)a1, v6 + 6);
  }
  return result;
}

uint64_t *sub_1CD67FD28(uint64_t a1, unsigned __int8 *a2, size_t a3, unsigned __int8 *__s1, size_t __n, unint64_t a6)
{
  uint64_t v10 = a1 + 40;
  uint64_t result = (uint64_t *)llvm::StringMapImpl::FindKey((uint64_t *)(a1 + 40), __s1, __n);
  if (result != -1)
  {
    uint64_t v12 = (int)result;
    if ((int)result != (unint64_t)*(unsigned int *)(a1 + 48))
    {
      uint64_t v13 = *(void *)(a1 + 40);
      long long v14 = sub_1CD67FF38(v10, a2, a3);
      uint64_t v15 = *(void *)(v13 + 8 * v12) + 8;
      v19[0] = *v14 + 1;
      v19[1] = v15;
      v19[2] = a6;
      size_t v16 = *sub_1CD67FF38(v10, a2, a3);
      unsigned int v17 = (uint64_t **)(v16 + 3);
      uint64_t result = sub_1CD680038((uint64_t)(v16 + 3), v15);
      if (v16 + 4 != (size_t *)result)
      {
        unint64_t v18 = result;
        if (result[6] >= a6) {
          return result;
        }
        sub_1CD491B50(v17, result);
        operator delete(v18);
      }
      return (uint64_t *)sub_1CD68011C((uint64_t)v17, v15, (uint64_t)v19);
    }
  }
  return result;
}

llvm::StringMapImpl *sub_1CD67FE2C(llvm::StringMapImpl *this, uint64_t *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0x1000000000;
  if (*((_DWORD *)a2 + 3))
  {
    llvm::StringMapImpl::init(this, *((_DWORD *)a2 + 2));
    uint64_t v4 = *(void *)this;
    uint64_t v5 = *((unsigned int *)this + 2);
    uint64_t v6 = *a2;
    *(void *)((char *)this + 12) = *(uint64_t *)((char *)a2 + 12);
    if (v5)
    {
      uint64_t v7 = 0;
      uint64_t v8 = v4 + 8 * v5 + 8;
      uint64_t v9 = v6 + 8 * v5 + 8;
      do
      {
        uint64_t v10 = *(size_t **)(*a2 + 8 * v7);
        if (v10) {
          BOOL v11 = v10 + 1 == 0;
        }
        else {
          BOOL v11 = 1;
        }
        if (v11)
        {
          *(void *)(*(void *)this + 8 * v7) = v10;
        }
        else
        {
          size_t v12 = *v10;
          uint64_t v13 = operator new(*v10 + 17, (std::align_val_t)8uLL);
          long long v14 = v13;
          uint64_t v15 = (char *)(v13 + 2);
          if (v12) {
            memcpy(v13 + 2, v10 + 2, v12);
          }
          v15[v12] = 0;
          size_t v16 = v10[1];
          *long long v14 = v12;
          v14[1] = v16;
          *(void *)(*(void *)this + 8 * v7) = v14;
          *(_DWORD *)(v8 + 4 * v7) = *(_DWORD *)(v9 + 4 * v7);
        }
        ++v7;
      }
      while (v5 != v7);
    }
  }
  return this;
}

size_t **sub_1CD67FF38(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  uint64_t v6 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  unint64_t i = (size_t **)(*(void *)a1 + 8 * v6);
  uint64_t v8 = *i;
  if (*i == (size_t *)-8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v8)
  {
    while (!v8 || v8 == (size_t *)-8)
    {
      uint64_t v9 = i[1];
      ++i;
      uint64_t v8 = v9;
    }
    return i;
  }
  BOOL v11 = operator new(a3 + 49, (std::align_val_t)8uLL);
  size_t v12 = v11;
  uint64_t v13 = (char *)(v11 + 6);
  if (a3) {
    memcpy(v11 + 6, a2, a3);
  }
  v13[a3] = 0;
  *size_t v12 = a3;
  v12[1] = 0;
  v12[5] = 0;
  v12[4] = 0;
  uint64_t v12[2] = 0;
  v12[3] = (size_t)(v12 + 4);
  *unint64_t i = v12;
  ++*(_DWORD *)(a1 + 12);
  for (unint64_t i = (size_t **)(*(void *)a1
                      + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v6));
        !*i || *i + 1 == 0;
  return i;
}

void *sub_1CD680038(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = (void *)(a1 + 8);
  do
  {
    BOOL v6 = sub_1CD6800B8(v3[5], a2);
    uint64_t v7 = v3 + 1;
    if (!v6)
    {
      uint64_t v7 = v3;
      uint64_t v5 = v3;
    }
    uint64_t v3 = (void *)*v7;
  }
  while (*v7);
  if (v5 == v2 || sub_1CD6800B8(a2, v5[5])) {
    return v2;
  }
  return v5;
}

BOOL sub_1CD6800B8(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 8);
  unint64_t v3 = *(void *)(a2 + 8);
  if (v3 >= v2) {
    size_t v4 = *(void *)(a1 + 8);
  }
  else {
    size_t v4 = *(void *)(a2 + 8);
  }
  if (v4 && (int v5 = memcmp(*(const void **)a1, *(const void **)a2, v4)) != 0)
  {
    int v6 = (v5 >> 31) | 1;
  }
  else
  {
    if (v2 < v3) {
      int v6 = -1;
    }
    else {
      int v6 = 1;
    }
    if (v2 == v3) {
      int v6 = 0;
    }
  }
  return v6 == -1;
}

uint64_t **sub_1CD68011C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (uint64_t **)sub_1CD6801C4(a1, &v11, a2);
  if (!*result)
  {
    int v6 = result;
    uint64_t v7 = operator new(0x38uLL);
    uint64_t v7[2] = *(_OWORD *)a3;
    *((void *)v7 + 6) = *(void *)(a3 + 16);
    uint64_t v8 = v11;
    *(void *)uint64_t v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = v8;
    *int v6 = (uint64_t *)v7;
    uint64_t v9 = **(void **)a1;
    if (v9)
    {
      *(void *)a1 = v9;
      uint64_t v10 = *v6;
    }
    else
    {
      uint64_t v10 = (uint64_t *)v7;
    }
    uint64_t result = (uint64_t **)sub_1CB8358B8(*(uint64_t **)(a1 + 8), v10);
    ++*(void *)(a1 + 16);
  }
  return result;
}

void *sub_1CD6801C4(uint64_t a1, void *a2, uint64_t a3)
{
  int v5 = (void *)(a1 + 8);
  size_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v7 = v4;
        uint64_t v8 = v4[5];
        if (!sub_1CD6800B8(a3, v8)) {
          break;
        }
        size_t v4 = (void *)*v7;
        int v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (!sub_1CD6800B8(v8, a3)) {
        break;
      }
      int v5 = v7 + 1;
      size_t v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    uint64_t v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t sub_1CD680258(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 12))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 8);
    if (v2)
    {
      uint64_t v3 = 0;
      uint64_t v4 = 8 * v2;
      do
      {
        uint64_t v5 = *(void *)(*(void *)a1 + v3);
        if (v5 != -8 && v5 != 0)
        {
          sub_1CD40B1BC(*(void **)(v5 + 32));
          MEMORY[0x1D25D9CD0](v5, 8);
        }
        v3 += 8;
      }
      while (v4 != v3);
    }
  }
  free(*(void **)a1);
  return a1;
}

void sub_1CD6802E0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (unsigned __int8 *)sub_1CD68056C((uint64_t *)a2, *(char **)(a2 + 16));
  sub_1CD67FA88(a1, v4, v5);
  int v6 = *(void **)(a2 + 72);
  if (v6 != (void *)(a2 + 80))
  {
    do
    {
      uint64_t v7 = *((unsigned int *)v6 + 14);
      if (v7)
      {
        for (unint64_t i = (uint64_t *)v6[6]; ; ++i)
        {
          BOOL v9 = !*i || *i == -8;
          if (!v9) {
            break;
          }
        }
      }
      else
      {
        unint64_t i = (uint64_t *)v6[6];
      }
      uint64_t v10 = v6[6] + 8 * v7;
      if (i != (uint64_t *)v10)
      {
        uint64_t v11 = *i;
        do
        {
          sub_1CD67FA88(a1, (unsigned __int8 *)(v11 + 16), *(void *)v11);
          size_t v12 = (unsigned __int8 *)sub_1CD68056C((uint64_t *)a2, *(char **)(a2 + 16));
          sub_1CD67FD28(a1, v12, v13, (unsigned __int8 *)(v11 + 16), *(void *)v11, *(void *)(v11 + 8));
          do
          {
            uint64_t v14 = i[1];
            ++i;
            uint64_t v11 = v14;
            if (v14) {
              BOOL v15 = v11 == -8;
            }
            else {
              BOOL v15 = 1;
            }
          }
          while (v15);
        }
        while (i != (uint64_t *)v10);
      }
      size_t v16 = (void *)v6[1];
      if (v16)
      {
        do
        {
          unsigned int v17 = v16;
          size_t v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          unsigned int v17 = (void *)v6[2];
          BOOL v9 = *v17 == (void)v6;
          int v6 = v17;
        }
        while (!v9);
      }
      int v6 = v17;
    }
    while (v17 != (void *)(a2 + 80));
  }
  unint64_t v18 = *(void **)(a2 + 96);
  if (v18 != (void *)(a2 + 104))
  {
    do
    {
      size_t v19 = (void *)v18[5];
      if (v19 != v18 + 6)
      {
        do
        {
          char v20 = *((unsigned char *)v19 + 55);
          int v21 = v20;
          if (v20 >= 0) {
            uint64_t v22 = (unsigned __int8 *)(v19 + 4);
          }
          else {
            uint64_t v22 = (unsigned __int8 *)v19[4];
          }
          size_t v23 = v20 & 0x7F;
          if (v21 >= 0) {
            size_t v24 = v23;
          }
          else {
            size_t v24 = v19[5];
          }
          sub_1CD67FA88(a1, v22, v24);
          unsigned int v25 = (unsigned __int8 *)sub_1CD68056C((uint64_t *)a2, *(char **)(a2 + 16));
          size_t v27 = v26;
          char v28 = *((unsigned char *)v19 + 55);
          BOOL v29 = v28 < 0;
          if (v28 >= 0) {
            long long v30 = (unsigned __int8 *)(v19 + 4);
          }
          else {
            long long v30 = (unsigned __int8 *)v19[4];
          }
          size_t v31 = v28 & 0x7F;
          if (v29) {
            size_t v32 = v19[5];
          }
          else {
            size_t v32 = v31;
          }
          unint64_t v33 = sub_1CD67FB9C(v19 + 7);
          sub_1CD67FD28(a1, v25, v27, v30, v32, v33);
          sub_1CD6802E0(a1, v19 + 7);
          size_t v34 = (void *)v19[1];
          if (v34)
          {
            do
            {
              unint64_t v35 = v34;
              size_t v34 = (void *)*v34;
            }
            while (v34);
          }
          else
          {
            do
            {
              unint64_t v35 = (void *)v19[2];
              BOOL v9 = *v35 == (void)v19;
              size_t v19 = v35;
            }
            while (!v9);
          }
          size_t v19 = v35;
        }
        while (v35 != v18 + 6);
      }
      unint64_t v36 = (void *)v18[1];
      if (v36)
      {
        do
        {
          int v37 = v36;
          unint64_t v36 = (void *)*v36;
        }
        while (v36);
      }
      else
      {
        do
        {
          int v37 = (void *)v18[2];
          BOOL v9 = *v37 == (void)v18;
          unint64_t v18 = v37;
        }
        while (!v9);
      }
      unint64_t v18 = v37;
    }
    while (v37 != (void *)(a2 + 104));
  }
}

const std::string::value_type *sub_1CD68056C(uint64_t *a1, char *__s)
{
  uint64_t v2 = __s;
  if (!llvm::sampleprof::FunctionSamples::UseMD5) {
    return v2;
  }
  uint64_t v3 = *a1;
  std::string::size_type v4 = strlen(__s);
  std::string::__init(&__str, v2, v4);
  unint64_t v5 = std::stoull(&__str, 0, 10);
  int v6 = *(_DWORD *)(v3 + 16);
  if (v6)
  {
    int v7 = v6 - 1;
    unsigned int v8 = v7 & (37 * v5);
    BOOL v9 = (uint64_t *)(*(void *)v3 + 24 * v8);
    uint64_t v10 = *v9;
    if (v5 == *v9)
    {
LABEL_4:
      uint64_t v2 = (const std::string::value_type *)v9[1];
      goto LABEL_5;
    }
    int v12 = 1;
    while (v10 != -1)
    {
      unsigned int v13 = v8 + v12++;
      unsigned int v8 = v13 & v7;
      BOOL v9 = (uint64_t *)(*(void *)v3 + 24 * v8);
      uint64_t v10 = *v9;
      if (v5 == *v9) {
        goto LABEL_4;
      }
    }
  }
  uint64_t v2 = 0;
LABEL_5:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  return v2;
}

void sub_1CD680660(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unsigned int v8 = operator new(0x38uLL);
  v8[4] = a2;
  v8[5] = a3;
  v8[6] = a4;
  BOOL v9 = sub_1CD6801C4(a1, &v12, a3);
  if (*v9)
  {
    operator delete(v8);
  }
  else
  {
    uint64_t v10 = v12;
    void *v8 = 0;
    v8[1] = 0;
    void v8[2] = v10;
    *BOOL v9 = v8;
    uint64_t v11 = **(void **)a1;
    if (v11)
    {
      *(void *)a1 = v11;
      unsigned int v8 = (void *)*v9;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v8);
    ++*(void *)(a1 + 16);
  }
}

char *sub_1CD68073C(int *a1, uint64_t a2)
{
  uint64_t v13 = a2;
  int v4 = *a1 + 1;
  *a1 = v4;
  *((_DWORD *)sub_1CD40EB18((uint64_t)(a1 + 2), &v13) + 2) = v4;
  unint64_t v5 = (uint64_t *)*((void *)a1 + 5);
  if ((unint64_t)v5 >= *((void *)a1 + 6))
  {
    int v6 = sub_1CBF63C18((void **)a1 + 4, a2);
  }
  else
  {
    *unint64_t v5 = a2;
    int v6 = v5 + 1;
  }
  *((void *)a1 + 5) = v6;
  uint64_t v7 = *(void *)(a2 + 16);
  int v8 = *a1;
  *(void *)&long long v11 = a2;
  *((void *)&v11 + 1) = v7;
  LODWORD(v12) = v8;
  unint64_t v9 = *((void *)a1 + 11);
  if (v9 >= *((void *)a1 + 12))
  {
    uint64_t result = sub_1CC9AEA78((void **)a1 + 10, (uint64_t)&v11);
  }
  else
  {
    *(_OWORD *)unint64_t v9 = v11;
    *(void *)(v9 + 16) = v12;
    uint64_t result = (char *)(v9 + 24);
  }
  *((void *)a1 + 11) = result;
  return result;
}

void *sub_1CD6807F4(void *result)
{
  uint64_t v1 = (void **)(result + 7);
  result[8] = result[7];
  if (result[10] != result[11])
  {
    uint64_t v2 = result;
    uint64_t v3 = (uint64_t)(result + 1);
    while (1)
    {
      sub_1CD680904((uint64_t)v2);
      uint64_t v5 = v2[10];
      uint64_t v4 = v2[11];
      uint64_t v6 = *(void *)(v4 - 24);
      uint64_t v10 = v6;
      unsigned int v7 = *(_DWORD *)(v4 - 8);
      v2[11] = v4 - 24;
      if (v5 != v4 - 24 && *(_DWORD *)(v4 - 32) > v7) {
        *(_DWORD *)(v4 - 32) = v7;
      }
      uint64_t result = sub_1CD40EB18(v3, &v10);
      if (v7 == *((_DWORD *)result + 2)) {
        break;
      }
      if (v2[10] == v2[11]) {
        return result;
      }
    }
    uint64_t result = (void *)v2[8];
    do
    {
      uint64_t v8 = *(void *)(v2[5] - 8);
      if ((unint64_t)result >= v2[9])
      {
        unint64_t v9 = sub_1CBF63C18(v1, v8);
      }
      else
      {
        char *result = v8;
        unint64_t v9 = result + 1;
      }
      v2[8] = v9;
      v2[5] -= 8;
      *((_DWORD *)sub_1CD40EB18(v3, v9 - 1) + 2) = -1;
      uint64_t result = (void *)v2[8];
    }
    while (*(result - 1) != v6);
  }
  return result;
}

uint64_t sub_1CD680904(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 88);
  uint64_t v4 = *(void **)(v1 - 16);
  uint64_t v2 = (void *)(v1 - 16);
  uint64_t v3 = v4;
  if (v4 != (void *)(*(v2 - 1) + 24))
  {
    uint64_t v5 = result;
    do
    {
      uint64_t v6 = (void *)v3[1];
      unsigned int v7 = v3;
      if (v6)
      {
        do
        {
          uint64_t v8 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v8 = (void *)v7[2];
          BOOL v10 = *v8 == (void)v7;
          unsigned int v7 = v8;
        }
        while (!v10);
      }
      *uint64_t v2 = v8;
      uint64_t v9 = v3[5];
      uint64_t v14 = 0;
      uint64_t result = sub_1CD40EA84(*(void *)(v5 + 8), *(_DWORD *)(v5 + 24), v9, &v14);
      if (result) {
        BOOL v10 = v14 == *(void *)(v5 + 8) + 16 * *(unsigned int *)(v5 + 24);
      }
      else {
        BOOL v10 = 1;
      }
      if (v10)
      {
        uint64_t result = (uint64_t)sub_1CD68073C((int *)v5, v9);
        uint64_t v12 = *(void *)(v5 + 88);
      }
      else
      {
        unsigned int v11 = *(_DWORD *)(v14 + 8);
        uint64_t v12 = *(void *)(v5 + 88);
        if (*(_DWORD *)(v12 - 8) > v11) {
          *(_DWORD *)(v12 - 8) = v11;
        }
      }
      uint64_t v13 = *(void **)(v12 - 16);
      uint64_t v2 = (void *)(v12 - 16);
      uint64_t v3 = v13;
    }
    while (v13 != (void *)(*(v2 - 1) + 24));
  }
  return result;
}

void *sub_1CD6809F4(void *result)
{
  if (result[3])
  {
    uint64_t v1 = result;
    uint64_t result = (void *)result[2];
    if (result)
    {
      do
      {
        uint64_t v2 = (void *)*result;
        operator delete(result);
        uint64_t result = v2;
      }
      while (v2);
    }
    v1[2] = 0;
    uint64_t v3 = v1[1];
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(*v1 + 8 * i) = 0;
    }
    v1[3] = 0;
  }
  return result;
}

uint64_t *sub_1CD680A5C(uint64_t **a1, uint64_t a2)
{
  uint64_t v4 = (uint64_t *)operator new(0x28uLL);
  uint64_t v5 = v4;
  v4[4] = a2;
  uint64_t v6 = a1 + 1;
  unsigned int v7 = a1[1];
  if (v7)
  {
    do
    {
      while (1)
      {
        uint64_t v6 = (uint64_t **)v7;
        if (*(void *)(a2 + 16) <= *(void *)(v7[4] + 16)) {
          break;
        }
        unsigned int v7 = (uint64_t *)*v7;
        uint64_t v8 = v6;
        if (!*v6) {
          goto LABEL_8;
        }
      }
      unsigned int v7 = (uint64_t *)v7[1];
    }
    while (v7);
    uint64_t v8 = v6 + 1;
  }
  else
  {
    uint64_t v8 = a1 + 1;
  }
LABEL_8:
  *uint64_t v4 = 0;
  v4[1] = 0;
  v4[2] = (uint64_t)v6;
  void *v8 = v4;
  uint64_t v9 = (uint64_t *)**a1;
  if (v9)
  {
    *a1 = v9;
    uint64_t v5 = *v8;
  }
  uint64_t result = sub_1CB8358B8(a1[1], v5);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *sub_1CD680B0C(uint64_t *a1)
{
  uint64_t v1 = a1;
  if ((uint64_t *)*a1 != a1)
  {
    uint64_t v3 = sub_1CD680B0C();
    *uint64_t v1 = v3;
    return (uint64_t *)v3;
  }
  return v1;
}

void *sub_1CD680B4C(uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (!a2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * (((8 * a3) + 8) ^ HIDWORD(a3));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(a3) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= a2) {
      unint64_t v7 = v5 % a2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (a2 - 1);
  }
  uint64_t v8 = *(void **)(a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  uint64_t result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v5 == v10)
      {
        if (result[2] == a3) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= a2) {
            v10 %= a2;
          }
        }
        else
        {
          v10 &= a2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t sub_1CD680C2C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }

  return sub_1CD4CAAF4(a1);
}

uint64_t sub_1CD680C70(void *a1, llvm::Function *a2, uint64_t a3)
{
  int v6 = *(_DWORD *)(a3 + 8);
  unsigned int v7 = sub_1CD681D50((void *(***)(unint64_t *__return_ptr, void, uint64_t))a1, (uint64_t)a2);
  if (v6) {
    uint64_t v8 = 1;
  }
  else {
    uint64_t v8 = v7;
  }
  if (v8 == 1)
  {
    sub_1CD681E34((uint64_t)a1, a2, a3);
    sub_1CD681EB8((uint64_t)a1, (uint64_t)a2);
    sub_1CD68212C(a1, a2, a3);
  }
  return v8;
}

const llvm::sampleprof::FunctionSamples **sub_1CD680CEC(const llvm::sampleprof::FunctionSamples **result, uint64_t **a2)
{
  unint64_t v3 = result;
  if (dword_1EBD0C958)
  {
    int v4 = llvm::sampleprofutil::SampleCoverageTracker::countUsedRecords((llvm::sampleprofutil::SampleCoverageTracker *)(result + 127), result[133], result[141]);
    unsigned int v5 = llvm::sampleprofutil::SampleCoverageTracker::countBodyRecords((llvm::sampleprofutil::SampleCoverageTracker *)(v3 + 127), v3[133], v3[141]);
    uint64_t result = (const llvm::sampleprof::FunctionSamples **)llvm::sampleprofutil::SampleCoverageTracker::computeCoverage((llvm::sampleprofutil::SampleCoverageTracker *)(v3 + 127), v4, v5);
    if (result < dword_1EBD0C958)
    {
      int v6 = (int)result;
      uint64_t v7 = **a2;
      uint64_t Subprogram = llvm::Function::getSubprogram((llvm::Function *)a2);
      uint64_t v9 = sub_1CC3BE9E0(Subprogram);
      uint64_t v11 = v10;
      int v12 = sub_1CD552F00((llvm::Function *)a2);
      __int16 v33 = 264;
      LODWORD(v32[0]) = v4;
      v30[0] = (uint64_t)" of ";
      __int16 v31 = 259;
      sub_1CB8F1E58(v32, v30, (uint64_t)v34);
      __int16 v29 = 264;
      LODWORD(v28[0]) = v5;
      sub_1CB8F1E58(v34, v28, (uint64_t)v35);
      v26[0] = (uint64_t)" available profile records (";
      __int16 v27 = 259;
      sub_1CB8F1E58(v35, v26, (uint64_t)v36);
      __int16 v25 = 264;
      LODWORD(v24[0]) = v6;
      sub_1CB8F1E58(v36, v24, (uint64_t)v37);
      v22[0] = (uint64_t)"%) were applied";
      __int16 v23 = 259;
      sub_1CB8F1E58(v37, v22, (uint64_t)v38);
      int v40 = 8;
      char v41 = 1;
      unint64_t v39 = &unk_1F2616770;
      uint64_t v42 = v9;
      uint64_t v43 = v11;
      int v44 = v12;
      v45 = v38;
      uint64_t result = (const llvm::sampleprof::FunctionSamples **)llvm::LLVMContext::diagnose(v7, (const llvm::DiagnosticInfo *)&v39);
    }
  }
  if (dword_1EBD0CA18)
  {
    int v21 = v3[130];
    uint64_t v20 = llvm::sampleprofutil::SampleCoverageTracker::countBodySamples((llvm::sampleprofutil::SampleCoverageTracker *)(v3 + 127), v3[133], v3[141]);
    uint64_t result = (const llvm::sampleprof::FunctionSamples **)llvm::sampleprofutil::SampleCoverageTracker::computeCoverage((llvm::sampleprofutil::SampleCoverageTracker *)(v3 + 127), (int)v21, v20);
    if (result < dword_1EBD0CA18)
    {
      int v13 = (int)result;
      uint64_t v14 = **a2;
      uint64_t v15 = llvm::Function::getSubprogram((llvm::Function *)a2);
      size_t v16 = sub_1CC3BE9E0(v15);
      uint64_t v18 = v17;
      int v19 = sub_1CD552F00((llvm::Function *)a2);
      __int16 v33 = 268;
      v32[0] = (uint64_t)&v21;
      v30[0] = (uint64_t)" of ";
      __int16 v31 = 259;
      sub_1CB8F1E58(v32, v30, (uint64_t)v34);
      __int16 v29 = 268;
      v28[0] = (uint64_t)&v20;
      sub_1CB8F1E58(v34, v28, (uint64_t)v35);
      v26[0] = (uint64_t)" available profile samples (";
      __int16 v27 = 259;
      sub_1CB8F1E58(v35, v26, (uint64_t)v36);
      __int16 v25 = 264;
      LODWORD(v24[0]) = v13;
      sub_1CB8F1E58(v36, v24, (uint64_t)v37);
      v22[0] = (uint64_t)"%) were applied";
      __int16 v23 = 259;
      sub_1CB8F1E58(v37, v22, (uint64_t)v38);
      int v40 = 8;
      char v41 = 1;
      unint64_t v39 = &unk_1F2616770;
      uint64_t v42 = v16;
      uint64_t v43 = v18;
      int v44 = v19;
      v45 = v38;
      return (const llvm::sampleprof::FunctionSamples **)llvm::LLVMContext::diagnose(v14, (const llvm::DiagnosticInfo *)&v39);
    }
  }
  return result;
}

unint64_t sub_1CD681020(char *__src, size_t __n)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (llvm::sampleprof::FunctionSamples::UseMD5)
  {
    std::string::size_type v3 = strlen(__src);
    std::string::__init(&__str, __src, v3);
    unint64_t v4 = std::stoull(&__str, 0, 10);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    *(_OWORD *)&__str.__r_.__value_.__l.__data_ = xmmword_1CFAC4320;
    __str.__r_.__value_.__r.__words[2] = 0;
    llvm::MD5::update((int *)&__str, (int *)__src, __n);
    llvm::MD5::final((int *)&__str, v6);
    return *(void *)v6;
  }
  return v4;
}

uint64_t sub_1CD6810F8(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (*(void *)(result + 56) <= a4) {
    return result;
  }
  uint64_t v7 = result;
  uint64_t v8 = (unsigned __int8 *)sub_1CD68056C((uint64_t *)result, *(char **)(result + 16));
  uint64_t result = llvm::StringMapImpl::FindKey((uint64_t *)a3, v8, v9);
  BOOL v10 = result == -1 || (int)result == (unint64_t)*(unsigned int *)(a3 + 8);
  if (v10) {
    goto LABEL_14;
  }
  uint64_t v11 = *(void *)(*(void *)(*(void *)a3 + 8 * (int)result) + 8);
  if (!v11) {
    goto LABEL_14;
  }
  if (*(unsigned char *)(v11 + 16))
  {
    if (*(unsigned char *)(v11 + 16) == 3 && (*(_DWORD *)(v11 + 20) & 0x7FFFFFF) == 0)
    {
LABEL_14:
      unint64_t v33 = sub_1CD681020(*(char **)(v7 + 16), *(void *)(v7 + 24));
      uint64_t result = (uint64_t)sub_1CD4ADCD0(a2, (uint64_t *)&v33, (uint64_t)v34);
    }
  }
  else if (*(void *)(v11 + 72) == v11 + 72 && (*(unsigned char *)(v11 + 34) & 0x80) == 0)
  {
    goto LABEL_14;
  }
  int v12 = *(void **)(v7 + 72);
  if (v12 != (void *)(v7 + 80))
  {
    while (1)
    {
      uint64_t v13 = *((unsigned int *)v12 + 14);
      if (v13)
      {
        for (uint64_t i = (uint64_t *)v12[6]; !*i || *i == -8; ++i)
          ;
      }
      else
      {
        uint64_t i = (uint64_t *)v12[6];
      }
      uint64_t v16 = v12[6] + 8 * v13;
      if (i != (uint64_t *)v16) {
        break;
      }
LABEL_46:
      size_t v24 = (void *)v12[1];
      if (v24)
      {
        do
        {
          __int16 v25 = v24;
          size_t v24 = (void *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          __int16 v25 = (void *)v12[2];
          BOOL v10 = *v25 == (void)v12;
          int v12 = v25;
        }
        while (!v10);
      }
      int v12 = v25;
      if (v25 == (void *)(v7 + 80)) {
        goto LABEL_52;
      }
    }
    uint64_t v17 = *i;
    while (1)
    {
      if (*(void *)(v17 + 8) > a4)
      {
        uint64_t v20 = (unsigned __int8 *)sub_1CD68056C((uint64_t *)v7, (char *)(v17 + 16));
        uint64_t result = llvm::StringMapImpl::FindKey((uint64_t *)a3, v20, v21);
        BOOL v22 = result == -1 || (int)result == (unint64_t)*(unsigned int *)(a3 + 8);
        if (v22 || (uint64_t v23 = *(void *)(*(void *)(*(void *)a3 + 8 * (int)result) + 8)) == 0)
        {
LABEL_42:
          unint64_t v33 = sub_1CD681020((char *)(v17 + 16), *(void *)v17);
          uint64_t result = (uint64_t)sub_1CD4ADCD0(a2, (uint64_t *)&v33, (uint64_t)v34);
          goto LABEL_28;
        }
        if (*(unsigned char *)(v23 + 16))
        {
          if (*(unsigned char *)(v23 + 16) == 3 && (*(_DWORD *)(v23 + 20) & 0x7FFFFFF) == 0) {
            goto LABEL_42;
          }
        }
        else if (*(void *)(v23 + 72) == v23 + 72 && (*(unsigned char *)(v23 + 34) & 0x80) == 0)
        {
          goto LABEL_42;
        }
      }
      do
      {
LABEL_28:
        uint64_t v18 = i[1];
        ++i;
        uint64_t v17 = v18;
        if (v18) {
          BOOL v19 = v17 == -8;
        }
        else {
          BOOL v19 = 1;
        }
      }
      while (v19);
      if (i == (uint64_t *)v16) {
        goto LABEL_46;
      }
    }
  }
LABEL_52:
  size_t v26 = *(void **)(v7 + 96);
  __int16 v27 = (void *)(v7 + 104);
  if (v26 != v27)
  {
    do
    {
      char v28 = (void *)v26[5];
      if (v28 != v26 + 6)
      {
        do
        {
          uint64_t result = sub_1CD6810F8(v28 + 7, a2, a3, a4);
          __int16 v29 = (void *)v28[1];
          if (v29)
          {
            do
            {
              long long v30 = v29;
              __int16 v29 = (void *)*v29;
            }
            while (v29);
          }
          else
          {
            do
            {
              long long v30 = (void *)v28[2];
              BOOL v10 = *v30 == (void)v28;
              char v28 = v30;
            }
            while (!v10);
          }
          char v28 = v30;
        }
        while (v30 != v26 + 6);
      }
      __int16 v31 = (void *)v26[1];
      if (v31)
      {
        do
        {
          size_t v32 = v31;
          __int16 v31 = (void *)*v31;
        }
        while (v31);
      }
      else
      {
        do
        {
          size_t v32 = (void *)v26[2];
          BOOL v10 = *v32 == (void)v26;
          size_t v26 = v32;
        }
        while (!v10);
      }
      size_t v26 = v32;
    }
    while (v32 != v27);
  }
  return result;
}

void *sub_1CD6813F8(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  unsigned int v8 = *(_DWORD *)(a2 + 16);
  if (!v8)
  {
    uint64_t v14 = 0;
LABEL_6:
    uint64_t result = sub_1CD5EF768(a2, (uint64_t)a3, a3, v14);
    void *result = *a3;
    result[1] = *a4;
    uint64_t v9 = *(void *)a2;
    unsigned int v8 = *(_DWORD *)(a2 + 16);
    char v13 = 1;
    goto LABEL_4;
  }
  uint64_t v9 = *(void *)a2;
  unsigned int v10 = (37 * *a3) & (v8 - 1);
  uint64_t result = (void *)(*(void *)a2 + 16 * v10);
  uint64_t v12 = *result;
  if (*a3 != *result)
  {
    uint64_t v15 = 0;
    int v16 = 1;
    while (v12 != -1)
    {
      if (v15) {
        BOOL v17 = 0;
      }
      else {
        BOOL v17 = v12 == -2;
      }
      if (v17) {
        uint64_t v15 = result;
      }
      unsigned int v18 = v10 + v16++;
      unsigned int v10 = v18 & (v8 - 1);
      uint64_t result = (void *)(v9 + 16 * v10);
      uint64_t v12 = *result;
      if (*a3 == *result) {
        goto LABEL_3;
      }
    }
    if (v15) {
      uint64_t v14 = v15;
    }
    else {
      uint64_t v14 = result;
    }
    goto LABEL_6;
  }
LABEL_3:
  char v13 = 0;
LABEL_4:
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v9 + 16 * v8;
  *(unsigned char *)(a1 + 16) = v13;
  return result;
}

void *sub_1CD6814EC(uint64_t a1, uint64_t *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    uint64_t v9 = 0;
LABEL_5:
    int v6 = sub_1CD5EF768(a1, (uint64_t)a2, a2, v9);
    *int v6 = *a2;
    v6[1] = 0;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = (37 * *a2) & (v3 - 1);
  int v6 = (void *)(*(void *)a1 + 16 * v5);
  uint64_t v7 = *v6;
  if (*a2 != *v6)
  {
    unsigned int v10 = 0;
    int v11 = 1;
    while (v7 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        unsigned int v10 = v6;
      }
      unsigned int v13 = v5 + v11++;
      unsigned int v5 = v13 & v4;
      int v6 = (void *)(*(void *)a1 + 16 * (v13 & v4));
      uint64_t v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      uint64_t v9 = v10;
    }
    else {
      uint64_t v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

char *sub_1CD6815AC(void *a1, llvm::Value *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  memset(&__p, 0, sizeof(__p));
  p_p = (int *)sub_1CD553864(a2);
  size_t size = v4;
  char v6 = (*(uint64_t (**)(void *))(*a1 + 72))(a1);
  if (size && (v6 & 1) != 0)
  {
    *(_OWORD *)&v19.__r_.__value_.__l.__data_ = xmmword_1CFAC4320;
    v19.__r_.__value_.__r.__words[2] = 0;
    llvm::MD5::update((int *)&v19, p_p, size);
    llvm::MD5::final((int *)&v19, (int *)__val);
    std::to_string(&v19, __val[0]);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v19;
    if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = (int *)&__p;
    }
    else {
      p_p = (int *)v19.__r_.__value_.__r.__words[0];
    }
    if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t size = *((unsigned char *)&v19.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      size_t size = v19.__r_.__value_.__l.__size_;
    }
  }
  v19.__r_.__value_.__r.__words[0] = (std::string::size_type)p_p;
  *(_OWORD *)&v19.__r_.__value_.__r.__words[1] = size;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v7 = (char *)sub_1CD681854(a1 + 1, (uint64_t)&v19);
  if (!v7)
  {
    std::string::size_type v9 = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v9 = __p.__r_.__value_.__l.__size_;
    }
    if (v9)
    {
      unsigned int v10 = sub_1CC619C24((uint64_t)(a1 + 8), (uint64_t)&__p, (uint64_t)&__p);
      uint64_t v13 = v10[2];
      int v11 = v10 + 2;
      BOOL v12 = (int *)v13;
      char v14 = *((unsigned char *)v11 + 23);
      int v15 = v14;
      if (v14 >= 0) {
        p_p = (int *)v11;
      }
      else {
        p_p = v12;
      }
      size_t v16 = v14 & 0x7F;
      if (v15 >= 0) {
        size_t size = v16;
      }
      else {
        size_t size = v11[1];
      }
    }
    v19.__r_.__value_.__r.__words[0] = (std::string::size_type)p_p;
    *(_OWORD *)&v19.__r_.__value_.__r.__words[1] = size;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    __val[0] = (unint64_t)&v19;
    uint64_t v7 = sub_1CC9B3AE0((uint64_t)(a1 + 1), (uint64_t)&v19, (uint64_t)&std::piecewise_construct, (long long **)__val);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v7 + 56;
}

uint64_t sub_1CD68178C(uint64_t result)
{
  *(_DWORD *)(result + 48) |= 2u;
  uint64_t v1 = *(void **)(result + 96);
  uint64_t v2 = (void *)(result + 104);
  if (v1 != (void *)(result + 104))
  {
    do
    {
      int v3 = (void *)v1[5];
      if (v3 != v1 + 6)
      {
        do
        {
          uint64_t result = sub_1CD68178C(v3 + 7);
          size_t v4 = (void *)v3[1];
          if (v4)
          {
            do
            {
              unsigned int v5 = v4;
              size_t v4 = (void *)*v4;
            }
            while (v4);
          }
          else
          {
            do
            {
              unsigned int v5 = (void *)v3[2];
              BOOL v6 = *v5 == (void)v3;
              int v3 = v5;
            }
            while (!v6);
          }
          int v3 = v5;
        }
        while (v5 != v1 + 6);
      }
      uint64_t v7 = (void *)v1[1];
      if (v7)
      {
        do
        {
          unsigned int v8 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          unsigned int v8 = (void *)v1[2];
          BOOL v6 = *v8 == (void)v1;
          uint64_t v1 = v8;
        }
        while (!v6);
      }
      uint64_t v1 = v8;
    }
    while (v8 != v2);
  }
  return result;
}

void *sub_1CD681854(void *a1, uint64_t a2)
{
  unint64_t v4 = sub_1CD681950(a2);
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v5 - 1) & v4;
  }
  unsigned int v10 = *(void **)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  int v11 = (void *)*v10;
  if (*v10)
  {
    do
    {
      unint64_t v12 = v11[1];
      if (v12 == v6)
      {
        if (sub_1CD681C28((uint64_t)(v11 + 2), a2)) {
          return v11;
        }
      }
      else
      {
        if (v8 > 1)
        {
          if (v12 >= *(void *)&v5) {
            v12 %= *(void *)&v5;
          }
        }
        else
        {
          v12 &= *(void *)&v5 - 1;
        }
        if (v12 != v9) {
          return 0;
        }
      }
      int v11 = (void *)*v11;
    }
    while (v11);
  }
  return v11;
}

unint64_t sub_1CD681950(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 32)) {
    return sub_1CD681978(*(void *)(a1 + 16), *(void *)(a1 + 16) + 24 * *(void *)(a1 + 24));
  }
  else {
    return llvm::hash_value(*(void **)a1, *(void *)(a1 + 8));
  }
}

unint64_t sub_1CD681978(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = sub_1CBF65470();
  if (a1 == a2)
  {
    unint64_t v7 = 0;
    return sub_1CBAE06B8(v14, v7, v4);
  }
  else
  {
    for (unint64_t i = 0; ; ++i)
    {
      unint64_t v6 = sub_1CD681AF4(a1, (int *)(a1 + 16), (int *)(a1 + 20));
      if (i > 7) {
        break;
      }
      unint64_t v7 = i * 8 + 8;
      v14[i] = v6;
      a1 += 24;
      if (a1 == a2) {
        return sub_1CBAE06B8(v14, v7, v4);
      }
    }
    sub_1CBFFCE40(v14, v4, v13);
    unint64_t v9 = 64;
LABEL_9:
    if (a1 != a2)
    {
      unint64_t v10 = 0;
      do
      {
        unint64_t v11 = sub_1CD681AF4(a1, (int *)(a1 + 16), (int *)(a1 + 20));
        if (v10 > 7)
        {
          sub_1CBFFCF68(v13, v14);
          v9 += 64;
          goto LABEL_9;
        }
        uint64_t v12 = v10 * 8 + 8;
        v14[v10] = v11;
        a1 += 24;
        ++v10;
      }
      while (a1 != a2);
      if ((v12 & 0x7FFFFFFFFFFFFFB8) != 0) {
        sub_1CBFFD29C(v14, (unsigned char *)v14 + v12, &v15);
      }
      sub_1CBFFCF68(v13, v14);
      v9 += v12;
    }
    return sub_1CBFFD150(v13, v9);
  }
}

unint64_t sub_1CD681AF4(uint64_t a1, int *a2, int *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  uint64_t v10 = sub_1CBF65470();
  return sub_1CD681BA0((char *)v7, 0, v7, (char *)v8, a1, a2, a3);
}

unint64_t sub_1CD681BA0(char *a1, uint64_t a2, void *a3, char *a4, uint64_t a5, int *a6, int *a7)
{
  uint64_t v15 = a2;
  unint64_t v12 = llvm::hash_value(*(void **)a5, *(void *)(a5 + 8));
  uint64_t v13 = sub_1CBFFCBA0(a1, &v15, a3, (unint64_t)a4, v12);
  return sub_1CC36B194(a1, v15, v13, a4, a6, a7);
}

BOOL sub_1CD681C28(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 32) != *(_DWORD *)(a2 + 32)) {
    return 0;
  }
  size_t v4 = *(void *)(a1 + 8);
  if (v4 != *(void *)(a2 + 8) || v4 && memcmp(*(const void **)a1, *(const void **)a2, v4)) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 24);
  if (v5 != *(void *)(a2 + 24)) {
    return 0;
  }
  if (!v5) {
    return 1;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = *(void *)(a2 + 16);
  uint64_t v8 = 24 * v5 - 24;
  do
  {
    BOOL result = sub_1CD681CE4(v6, v7);
    if (!result) {
      break;
    }
    v6 += 24;
    v7 += 24;
    uint64_t v10 = v8;
    v8 -= 24;
  }
  while (v10);
  return result;
}

BOOL sub_1CD681CE4(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16)) {
    return 0;
  }
  if (*(_DWORD *)(a1 + 20) != *(_DWORD *)(a2 + 20)) {
    return 0;
  }
  size_t v2 = *(void *)(a1 + 8);
  if (v2 != *(void *)(a2 + 8)) {
    return 0;
  }
  if (v2) {
    return memcmp(*(const void **)a1, *(const void **)a2, v2) == 0;
  }
  return 1;
}

uint64_t sub_1CD681D50(void *(***a1)(unint64_t *__return_ptr, void, uint64_t), uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a2 + 72;
  uint64_t v3 = *(void *)(a2 + 80);
  if (v3 == a2 + 72)
  {
    char v5 = 0;
  }
  else
  {
    char v5 = 0;
    do
    {
      if (v3) {
        uint64_t v6 = v3 - 24;
      }
      else {
        uint64_t v6 = 0;
      }
      sub_1CD682214((uint64_t)&v10, a1, v6);
      if ((v11 & 1) == 0)
      {
        uint64_t v7 = v10;
        uint64_t v9 = v6;
        sub_1CD45F378((uint64_t)(a1 + 4), &v9)[1] = v7;
        sub_1CB89694C((llvm::SmallPtrSetImplBase *)(a1 + 10), v6);
        char v5 = 1;
      }
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != v2);
  }
  return v5 & 1;
}

void sub_1CD681E34(uint64_t a1, llvm::Function *a2, uint64_t a3)
{
  llvm::Function::setEntryCount(a2, *(void *)(*(void *)(a1 + 1064) + 64) + 1, 0, a3);
  if (!byte_1EBD0CB98) {
    sub_1CD682328();
  }

  sub_1CC9B4208(a1, (uint64_t)a2);
}

void sub_1CD681EB8(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (byte_1EBD0CB98)
  {
    uint64_t v4 = a2 + 72;
    v22[0] = 0;
    v22[1] = 0;
    int v23 = 0;
    for (uint64_t i = *(void *)(a2 + 80); i != v4; uint64_t i = *(void *)(i + 8))
    {
      if (i) {
        uint64_t v6 = i - 24;
      }
      else {
        uint64_t v6 = 0;
      }
      sub_1CD682214((uint64_t)v24, (void *(***)(unint64_t *__return_ptr, void, uint64_t))a1, v6);
      if ((v25 & 1) == 0)
      {
        uint64_t v7 = v24[0];
        uint64_t v21 = v6;
        sub_1CD45F378((uint64_t)v22, &v21)[1] = v7;
      }
    }
    v24[0] = a2;
    v24[1] = a1 + 992;
    __int16 v25 = v22;
    sub_1CC9B47C4(v24, (_DWORD *)(a1 + 32), (_DWORD *)(a1 + 56));
    MEMORY[0x1D25D9CD0](v22[0], 8);
  }
  else
  {
    uint64_t v8 = a2 + 72;
    uint64_t v9 = *(void *)(a2 + 80);
    if (v9 != a2 + 72)
    {
      do
      {
        uint64_t v16 = v9 - 24;
        if (!v9) {
          uint64_t v16 = 0;
        }
        uint64_t v21 = v16;
        v22[0] = 0;
        BOOL v17 = *(uint64_t **)(a1 + 960);
        v24[0] = v16;
        if (sub_1CB834D78(v17, v24, v22))
        {
          uint64_t v18 = *(void *)(v22[0] + 8);
          if (v18)
          {
            v24[0] = **(void **)(v18 + 32);
            if (v24[0])
            {
              unint64_t v19 = sub_1CD45F378(a1 + 32, &v21)[1];
              if (v19 > sub_1CD45F378(a1 + 32, v24)[1])
              {
                uint64_t v20 = sub_1CD45F378(a1 + 32, &v21)[1];
                sub_1CD45F378(a1 + 32, v24)[1] = v20;
              }
            }
          }
        }
        uint64_t v9 = *(void *)(v9 + 8);
      }
      while (v9 != v8);
    }
    int v10 = 3;
    do
    {
      unsigned int v11 = v10;
      if (v10 - 3 >= dword_1EBD0C898) {
        break;
      }
      char v12 = sub_1CD682800(a1, a2, 0);
      int v10 = v11 + 1;
    }
    while ((v12 & 1) != 0);
    *(_DWORD *)(a1 + 376) = 0;
    sub_1CD40B1BC(*(void **)(a1 + 904));
    *(void *)(a1 + 896) = a1 + 904;
    *(void *)(a1 + 912) = 0;
    *(void *)(a1 + 904) = 0;
    while (1)
    {
      unsigned int v13 = v11;
      unsigned int v14 = dword_1EBD0C898;
      if (v11 - 2 >= dword_1EBD0C898) {
        break;
      }
      ++v11;
      if ((sub_1CD682800(a1, a2, 0) & 1) == 0)
      {
        unsigned int v14 = dword_1EBD0C898;
        break;
      }
    }
    if (v13 - 1 < v14)
    {
      do
      {
        if (!sub_1CD682800(a1, a2, 1)) {
          break;
        }
      }
      while (v13++ < dword_1EBD0C898);
    }
  }
}

void *sub_1CD68212C(void *result, llvm::Function *a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (byte_1EBD0CB98)
  {
    char v5 = result;
    uint64_t v6 = *((void *)a2 + 10);
    if (v6) {
      uint64_t v7 = v6 - 24;
    }
    else {
      uint64_t v7 = 0;
    }
    uint64_t v10 = v7;
    sub_1CD682214((uint64_t)v11, (void *(***)(unint64_t *__return_ptr, void, uint64_t))result, v7);
    uint64_t v8 = (uint64_t)(v5 + 4);
    BOOL result = sub_1CD45F378(v8, &v10);
    if (result[1] && (byte_1EBD0CC58 || (v11[16] & 1) != 0))
    {
      uint64_t v9 = sub_1CD45F378(v8, &v10);
      return (void *)llvm::Function::setEntryCount(a2, v9[1], 0, a3);
    }
  }
  return result;
}

const std::error_category *sub_1CD682214(uint64_t a1, void *(***a2)(unint64_t *__return_ptr, void, uint64_t), uint64_t a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a3 + 40;
  uint64_t v5 = *(void *)(a3 + 48);
  if (v5 == a3 + 40) {
    goto LABEL_13;
  }
  char v7 = 0;
  unint64_t v8 = 0;
  do
  {
    if (v5) {
      uint64_t v9 = v5 - 24;
    }
    else {
      uint64_t v9 = 0;
    }
    BOOL result = (const std::error_category *)(**a2)(&v12, a2, v9);
    unint64_t v11 = v12;
    if (v8 > v12) {
      unint64_t v11 = v8;
    }
    if ((v13 & 1) == 0) {
      unint64_t v8 = v11;
    }
    v7 |= (v13 & 1) == 0;
    uint64_t v5 = *(void *)(v5 + 8);
  }
  while (v5 != v4);
  if ((v7 & 1) == 0)
  {
LABEL_13:
    BOOL result = std::system_category();
    unint64_t v8 = 0;
    *(unsigned char *)(a1 + 16) |= 1u;
    *(void *)(a1 + 8) = result;
  }
  else
  {
    *(unsigned char *)(a1 + 16) &= ~1u;
  }
  *(void *)a1 = v8;
  return result;
}

void sub_1CD682328()
{
}

void sub_1CD6824AC(uint64_t a1, uint64_t a2)
{
  v16[8] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = v16;
  uint64_t v15 = 0x800000000;
  uint64_t v2 = a2 + 72;
  uint64_t v3 = *(void *)(a2 + 80);
  if (v3 != a2 + 72)
  {
    uint64_t v6 = a1 + 920;
    do
    {
      if (v3) {
        uint64_t v7 = v3 - 24;
      }
      else {
        uint64_t v7 = 0;
      }
      uint64_t v12 = v7;
      uint64_t v13 = 0;
      if ((sub_1CD40EA84(*(void *)(a1 + 920), *(_DWORD *)(a1 + 936), v7, &v13) & 1) == 0)
      {
        uint64_t v8 = v12;
        sub_1CD467E2C(v6, &v12)[1] = v8;
        LODWORD(v15) = 0;
        llvm::DominatorTreeBase<llvm::BasicBlock,false>::getDescendants();
      }
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != v2);
    for (uint64_t i = *(void *)(a2 + 80); i != v2; uint64_t i = *(void *)(i + 8))
    {
      if (i) {
        uint64_t v10 = i - 24;
      }
      else {
        uint64_t v10 = 0;
      }
      uint64_t v13 = v10;
      uint64_t v12 = sub_1CD467E2C(v6, &v13)[1];
      if (v10 != v12)
      {
        uint64_t v11 = sub_1CD45F378(a1 + 32, &v12)[1];
        sub_1CD45F378(a1 + 32, &v13)[1] = v11;
      }
    }
  }
  if (v14 != v16) {
    free(v14);
  }
}

void *sub_1CD682638(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = a2;
  uint64_t v11 = sub_1CD467E2C(a1 + 920, &v12)[1];
  uint64_t v10 = v11;
  uint64_t v6 = sub_1CD45F378(a1 + 32, &v11)[1];
  if (a4) {
    llvm::DominatorTreeBase<llvm::BasicBlock,true>::dominates();
  }
  uint64_t v7 = *(void *)(*(void *)(v10 + 56) + 80);
  if (v7) {
    uint64_t v8 = v7 - 24;
  }
  else {
    uint64_t v8 = 0;
  }
  if (v10 == v8) {
    uint64_t v6 = *(void *)(*(void *)(a1 + 1064) + 64) + 1;
  }
  BOOL result = sub_1CD45F378(a1 + 32, &v11);
  result[1] = v6;
  return result;
}

uint64_t sub_1CD682800(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a2 + 80);
  uint64_t v80 = a2 + 72;
  if (v3 != a2 + 72)
  {
    int v4 = a3;
    char v77 = 0;
    uint64_t v6 = a1 + 992;
    uint64_t v81 = a1 + 968;
    uint64_t v7 = (llvm::SmallPtrSetImplBase *)(a1 + 80);
    uint64_t v74 = a1 + 32;
    uint64_t v78 = a1 + 920;
    uint64_t v79 = a1 + 80;
    uint64_t v76 = a1 + 992;
    while (1)
    {
      if (v3) {
        uint64_t v8 = v3 - 24;
      }
      else {
        uint64_t v8 = 0;
      }
      v92[0] = v8;
      uint64_t v91 = sub_1CD467E2C(v78, v92)[1];
      char v9 = 1;
      uint64_t v82 = v91;
      do
      {
        unsigned int v90 = 0;
        int64x2_t v89 = 0uLL;
        int64x2_t v88 = 0uLL;
        uint64_t v86 = 0;
        uint64_t v87 = 0;
        char v83 = v9;
        unint64_t v84 = v8;
        if ((v9 & 1) == 0)
        {
          int v10 = *((_DWORD *)sub_1CD554E30(v6, v92) + 4);
          uint64_t v20 = sub_1CD554E30(v6, v92);
          uint64_t v21 = *((unsigned int *)v20 + 4);
          if (v21)
          {
            unint64_t v15 = 0;
            uint64_t v22 = (unint64_t *)v20[1];
            uint64_t v23 = 8 * v21;
            do
            {
              unint64_t v24 = *v22++;
              v15 += sub_1CD5559F4(a1, v84, v24, &v90, (unint64_t *)&v89);
              v23 -= 8;
            }
            while (v23);
          }
          else
          {
            unint64_t v15 = 0;
          }
          if (v10 != 1)
          {
            uint64_t v14 = 0;
            goto LABEL_24;
          }
          size_t v47 = v92;
          uint64_t v14 = 0;
          size_t v46 = (uint64_t *)sub_1CD554E30(v6, v92)[1];
          goto LABEL_46;
        }
        int v10 = *((_DWORD *)sub_1CD554E30(v81, v92) + 4);
        uint64_t v11 = sub_1CD554E30(v81, v92);
        uint64_t v12 = *((unsigned int *)v11 + 4);
        if (v12)
        {
          uint64_t v13 = 0;
          uint64_t v14 = 0;
          unint64_t v15 = 0;
          uint64_t v16 = (unint64_t *)v11[1];
          uint64_t v17 = 8 * v12;
          do
          {
            unint64_t v19 = *v16++;
            unint64_t v18 = v19;
            v15 += sub_1CD5559F4(a1, v19, v84, &v90, (unint64_t *)&v89);
            if (v19 == v84)
            {
              uint64_t v13 = v18;
              uint64_t v14 = v18;
            }
            v17 -= 8;
          }
          while (v17);
          v88.i64[0] = v14;
          v88.i64[1] = v13;
          int v4 = a3;
          uint64_t v6 = v76;
          uint64_t v7 = (llvm::SmallPtrSetImplBase *)v79;
        }
        else
        {
          uint64_t v14 = 0;
          unint64_t v15 = 0;
        }
        if (v10 == 1)
        {
          size_t v46 = v92;
          size_t v47 = (uint64_t *)sub_1CD554E30(v81, v92)[1];
LABEL_46:
          uint64_t v37 = *v46;
          uint64_t v86 = *v47;
          uint64_t v87 = v37;
          int v10 = 1;
          uint64_t v7 = (llvm::SmallPtrSetImplBase *)v79;
        }
LABEL_24:
        unsigned int v25 = v90;
        if (v90 <= 1)
        {
          uint64_t v38 = sub_1CD45F378(v74, &v91);
          if (v25 == 1)
          {
            uint64_t v26 = v82;
            uint64_t v48 = sub_1CB896AE8((uint64_t)v7, v82);
            uint64_t v49 = *(void *)(a1 + 88);
            if (v49 == *(void *)(a1 + 80)) {
              uint64_t v50 = 100;
            }
            else {
              uint64_t v50 = 96;
            }
            if (v48 != (void *)(v49 + 8 * *(unsigned int *)(a1 + v50)))
            {
              unint64_t v63 = v38[1];
              BOOL v43 = v63 >= v15;
              unint64_t v64 = v63 - v15;
              if (v43) {
                unint64_t v65 = v64;
              }
              else {
                unint64_t v65 = 0;
              }
              sub_1CD553BAC(a1 + 56, v89.i64)[2] = v65;
              uint64_t v7 = (llvm::SmallPtrSetImplBase *)v79;
              if (v83) {
                unsigned int v66 = &v89;
              }
              else {
                unsigned int v66 = (int64x2_t *)&v89.u64[1];
              }
              v85.i64[0] = sub_1CD467E2C(v78, v66->i64)[1];
              v67 = sub_1CB896AE8(v79, v85.i64[0]);
              uint64_t v68 = *(void *)(a1 + 88);
              uint64_t v69 = 96;
              if (v68 == *(void *)(a1 + 80)) {
                uint64_t v69 = 100;
              }
              if (v67 != (void *)(v68 + 8 * *(unsigned int *)(a1 + v69)))
              {
                unint64_t v70 = sub_1CD553BAC(a1 + 56, v89.i64)[2];
                if (v70 > sub_1CD45F378(v74, v85.i64)[1])
                {
                  uint64_t v71 = sub_1CD45F378(v74, v85.i64)[1];
                  sub_1CD553BAC(a1 + 56, v89.i64)[2] = v71;
                }
              }
              sub_1CD555A70(a1 + 368, &v89);
              char v77 = 1;
            }
          }
          else
          {
            if (v25) {
              goto LABEL_68;
            }
            unint64_t v39 = sub_1CB896AE8((uint64_t)v7, v82);
            uint64_t v40 = *(void *)(a1 + 88);
            if (v40 == *(void *)(a1 + 80)) {
              uint64_t v41 = 100;
            }
            else {
              uint64_t v41 = 96;
            }
            if (v39 == (void *)(v40 + 8 * *(unsigned int *)(a1 + v41)))
            {
              if (v15 > v38[1])
              {
                v38[1] = v15;
                char v77 = 1;
              }
LABEL_68:
              uint64_t v26 = v82;
              goto LABEL_34;
            }
            if (v10 != 1) {
              goto LABEL_68;
            }
            unint64_t v72 = sub_1CD553BAC(a1 + 56, &v86)[2];
            uint64_t v26 = v82;
            if (v72 < sub_1CD45F378(v74, &v91)[1])
            {
              uint64_t v73 = sub_1CD45F378(v74, &v91)[1];
              sub_1CD553BAC(a1 + 56, &v86)[2] = v73;
              char v77 = 1;
            }
          }
        }
        else
        {
          uint64_t v26 = v82;
          __int16 v27 = sub_1CB896AE8((uint64_t)v7, v82);
          uint64_t v28 = *(void *)(a1 + 88);
          if (v28 == *(void *)(a1 + 80)) {
            uint64_t v29 = 100;
          }
          else {
            uint64_t v29 = 96;
          }
          if (v27 == (void *)(v28 + 8 * *(unsigned int *)(a1 + v29)) || sub_1CD45F378(v74, &v91)[1])
          {
            if (v14)
            {
              long long v30 = sub_1CB896AE8((uint64_t)v7, v82);
              uint64_t v31 = *(void *)(a1 + 88);
              uint64_t v32 = v31 == *(void *)(a1 + 80) ? 100 : 96;
              if (v30 != (void *)(v31 + 8 * *(unsigned int *)(a1 + v32)))
              {
                unint64_t v42 = sub_1CD45F378(v74, v92)[1];
                BOOL v43 = v42 >= v15;
                unint64_t v44 = v42 - v15;
                if (v43) {
                  unint64_t v45 = v44;
                }
                else {
                  unint64_t v45 = 0;
                }
                sub_1CD553BAC(a1 + 56, v88.i64)[2] = v45;
                uint64_t v26 = v82;
                sub_1CD555A70(a1 + 368, &v88);
                char v77 = 1;
              }
            }
          }
          else
          {
            if (v83)
            {
              uint64_t v52 = sub_1CD554E30(v81, v92);
              uint64_t v53 = *((unsigned int *)v52 + 4);
              if (!v53) {
                goto LABEL_34;
              }
              v54 = (uint64_t *)v52[1];
              uint64_t v55 = v92[0];
              uint64_t v56 = 8 * v53;
              do
              {
                uint64_t v57 = *v54++;
                v85.i64[0] = v57;
                v85.i64[1] = v55;
                sub_1CD553BAC(a1 + 56, v85.i64)[2] = 0;
                sub_1CD555A70(a1 + 368, &v85);
                v56 -= 8;
              }
              while (v56);
            }
            else
            {
              uint64_t v58 = sub_1CD554E30(v6, v92);
              uint64_t v59 = *((unsigned int *)v58 + 4);
              if (!v59) {
                goto LABEL_34;
              }
              uint64_t v60 = (uint64_t *)v58[1];
              uint64_t v55 = v92[0];
              uint64_t v61 = 8 * v59;
              do
              {
                uint64_t v62 = *v60++;
                v85.i64[0] = v55;
                v85.i64[1] = v62;
                sub_1CD553BAC(a1 + 56, v85.i64)[2] = 0;
                sub_1CD555A70(a1 + 368, &v85);
                v61 -= 8;
              }
              while (v61);
            }
            unint64_t v84 = v55;
          }
        }
LABEL_34:
        if (v4)
        {
          unint64_t v33 = sub_1CB896AE8((uint64_t)v7, v26);
          uint64_t v34 = *(void *)(a1 + 88);
          if (v34 == *(void *)(a1 + 80)) {
            uint64_t v35 = 100;
          }
          else {
            uint64_t v35 = 96;
          }
          BOOL v36 = v33 != (void *)(v34 + 8 * *(unsigned int *)(a1 + v35)) || v15 == 0;
          uint64_t v8 = v84;
          if (!v36)
          {
            sub_1CD45F378(v74, &v91)[1] = v15;
            sub_1CB89694C(v7, v26);
            char v77 = 1;
          }
        }
        else
        {
          uint64_t v8 = v84;
        }
        char v9 = 0;
      }
      while ((v83 & 1) != 0);
      uint64_t v3 = *(void *)(v3 + 8);
      if (v3 == v80) {
        return v77 & 1;
      }
    }
  }
  char v77 = 0;
  return v77 & 1;
}

void *sub_1CD682E60(void *result, int a2)
{
  if (a2)
  {
    unint64_t v2 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    unint64_t v3 = v2 | (v2 >> 2) | ((v2 | (v2 >> 2)) >> 4);
    unsigned int v4 = ((v3 | (v3 >> 8)) >> 16) | v3 | (v3 >> 8);
    if (*((_DWORD *)result + 4) <= v4) {
      return sub_1CD45F498((uint64_t)result, v4 + 1);
    }
  }
  return result;
}

uint64_t sub_1CD682EAC(uint64_t result, uint64_t a2, unsigned char *a3, unsigned char *a4)
{
  if (a3 != a4)
  {
    v20[9] = v4;
    v20[10] = v5;
    uint64_t v8 = (uint64_t *)result;
    char v9 = a3 + 24;
    do
    {
      int v10 = v9 - 24;
      uint64_t v11 = *v8;
      v20[0] = *(void *)(*v8 + 8 * *((void *)v9 - 3));
      uint64_t v12 = *(void *)(v20[0] + 40);
      if (v12 == v20[0] + 40)
      {
        uint64_t v13 = 0;
      }
      else
      {
        if (v12) {
          uint64_t v14 = v12 - 24;
        }
        else {
          uint64_t v14 = 0;
        }
        if (*(unsigned __int8 *)(v14 + 16) - 29 >= 0xB) {
          uint64_t v13 = 0;
        }
        else {
          uint64_t v13 = v14;
        }
      }
      uint64_t v15 = *(void *)(v11 + 8 * *((void *)v9 - 2));
      if (*((_DWORD *)sub_1CD554E30(a2, v20) + 4) == 2)
      {
        unint64_t v19 = sub_1CD554E30(a2, v20);
        if (*(void *)(v19[1] + 8 * *((unsigned int *)v19 + 4) - 8) == v15 && *(unsigned char *)(v13 + 16) == 33) {
          *char v9 = 1;
        }
      }
      uint64_t v16 = *(void *)(v15 + 40);
      if (v16 == v15 + 40)
      {
        unint64_t v18 = 0;
      }
      else
      {
        if (v16) {
          uint64_t v17 = (llvm::Instruction *)(v16 - 24);
        }
        else {
          uint64_t v17 = 0;
        }
        if (*((unsigned __int8 *)v17 + 16) - 29 >= 0xB) {
          unint64_t v18 = 0;
        }
        else {
          unint64_t v18 = v17;
        }
      }
      BOOL result = llvm::Instruction::getNumSuccessors(v18);
      if (!result && *((unsigned char *)v18 + 16) == 35) {
        *char v9 = 1;
      }
      v9 += 32;
    }
    while (v10 + 32 != a4);
  }
  return result;
}

void sub_1CD683008(void *a1, uint64_t a2, llvm::SmallPtrSetImplBase *a3)
{
  if (a2) {
    uint64_t v4 = a2 - 24;
  }
  else {
    uint64_t v4 = 0;
  }
  sub_1CD48200C(&v6, v4, a3);
  uint64_t v5 = __p;
  *a1 = v6;
  a1[2] = 0;
  a1[3] = 0;
  a1[1] = 0;
  sub_1CBFE1720(a1 + 1, v5, v8, (v8 - v5) >> 5);
  if (__p)
  {
    uint64_t v8 = __p;
    operator delete(__p);
  }
}

_OWORD *sub_1CD683078(uint64_t a1)
{
  unint64_t v2 = (void **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  while (2)
  {
    uint64_t v4 = *(void *)(v3 - 32);
    if (!*(unsigned char *)(v3 - 8))
    {
      uint64_t v15 = *(void *)(v4 + 40);
      if (v15 == v4 + 40)
      {
        uint64_t v16 = 0;
      }
      else
      {
        if (v15) {
          uint64_t v16 = v15 - 24;
        }
        else {
          uint64_t v16 = 0;
        }
        if (*(unsigned __int8 *)(v16 + 16) - 29 >= 0xB) {
          uint64_t v16 = 0;
        }
      }
      *(void *)(v3 - 24) = v16;
      *(void *)(v3 - 16) = 0;
      *(unsigned char *)(v3 - 8) = 1;
    }
    uint64_t v5 = (void *)(v4 + 40);
    while (1)
    {
      uint64_t v6 = (void *)*v5;
      if ((void *)*v5 == v5
        || (v6 ? (uint64_t v7 = (unsigned __int8 *)(v6 - 3)) : (uint64_t v7 = 0), v7[16] - 29 > 0xA))
      {
        BOOL result = 0;
      }
      else
      {
        BOOL result = (_OWORD *)llvm::Instruction::getNumSuccessors((llvm::Instruction *)v7);
      }
      int v9 = *(_DWORD *)(v3 - 16);
      if (v9 == result) {
        break;
      }
      int v10 = *(llvm::Instruction **)(v3 - 24);
      unsigned int v11 = *(_DWORD *)(v3 - 16);
      *(_DWORD *)(v3 - 16) = v9 + 1;
      uint64_t Successor = llvm::Instruction::getSuccessor(v10, v11);
      sub_1CB89694C(*(llvm::SmallPtrSetImplBase **)a1, Successor);
      if (v13)
      {
        *(void *)&long long v19 = Successor;
        BYTE8(v19) = 0;
        BYTE8(v20) = 0;
        uint64_t v17 = *(_OWORD **)(a1 + 16);
        if ((unint64_t)v17 >= *(void *)(a1 + 24))
        {
          BOOL result = sub_1CBF9AC5C(v2, &v19);
        }
        else
        {
          long long v18 = v20;
          *uint64_t v17 = v19;
          v17[1] = v18;
          BOOL result = v17 + 2;
        }
        *(void *)(a1 + 16) = result;
        return result;
      }
    }
    uint64_t v14 = *(void *)(a1 + 8);
    uint64_t v3 = *(void *)(a1 + 16) - 32;
    *(void *)(a1 + 16) = v3;
    if (v14 != v3) {
      continue;
    }
    break;
  }
  return result;
}

size_t **sub_1CD6831CC(size_t **result, uint64_t *a2, int a3, float a4)
{
  uint64_t v5 = (uint64_t)result;
  _OWORD *result = 0;
  result[1] = 0;
  result[2] = (size_t *)0x1000000000;
  uint64_t i = a2;
  if (a3)
  {
    for (uint64_t i = a2; !*i || *i == -8; ++i)
      ;
  }
  uint64_t v8 = &a2[a3];
  if (i != v8)
  {
    uint64_t v9 = *i;
    do
    {
      unint64_t v10 = (unint64_t)(float)((float)*(unint64_t *)(v9 + 8) * a4);
      BOOL result = sub_1CD5CF708(v5, (unsigned __int8 *)(v9 + 16), *(void *)v9);
      (*result)[1] = v10;
      do
      {
        uint64_t v11 = i[1];
        ++i;
        uint64_t v9 = v11;
        if (v11) {
          BOOL v12 = v9 == -8;
        }
        else {
          BOOL v12 = 1;
        }
      }
      while (v12);
    }
    while (i != v8);
  }
  return result;
}

uint64_t *sub_1CD68327C@<X0>(uint64_t *result@<X0>, void *a2@<X8>)
{
  a2[2] = 0;
  a2[1] = 0;
  *a2 = a2 + 1;
  uint64_t v3 = *((unsigned int *)result + 2);
  if (v3)
  {
    for (uint64_t i = (uint64_t **)*result; !*i || *i + 1 == 0; ++i)
      ;
  }
  else
  {
    uint64_t i = (uint64_t **)*result;
  }
  uint64_t v6 = *result + 8 * v3;
  if (i != (uint64_t **)v6)
  {
    uint64_t v7 = *i;
    do
    {
      uint64_t v8 = *v7;
      *(void *)&long long v11 = v7 + 2;
      *((void *)&v11 + 1) = v8;
      BOOL result = sub_1CD683324((uint64_t)a2, &v11, v7 + 1);
      do
      {
        uint64_t v9 = i[1];
        ++i;
        uint64_t v7 = v9;
        if (v9) {
          BOOL v10 = v7 + 1 == 0;
        }
        else {
          BOOL v10 = 1;
        }
      }
      while (v10);
    }
    while (i != (uint64_t **)v6);
  }
  return result;
}

uint64_t *sub_1CD683324(uint64_t a1, _OWORD *a2, void *a3)
{
  uint64_t v6 = operator new(0x38uLL);
  *((_OWORD *)v6 + 2) = *a2;
  v6[6] = *a3;
  uint64_t v7 = (uint64_t **)sub_1CD6833E8(a1, &v13, (uint64_t)(v6 + 4));
  uint64_t v8 = *v7;
  if (*v7)
  {
    operator delete(v6);
    return v8;
  }
  else
  {
    uint64_t v10 = v13;
    *uint64_t v6 = 0;
    v6[1] = 0;
    void v6[2] = v10;
    *uint64_t v7 = v6;
    uint64_t v11 = **(void **)a1;
    BOOL v12 = v6;
    if (v11)
    {
      *(void *)a1 = v11;
      BOOL v12 = *v7;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v12);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

void *sub_1CD6833E8(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 16;
    do
    {
      while (1)
      {
        uint64_t v8 = v4;
        uint64_t v9 = (uint64_t)(v4 + 4);
        if (!sub_1CD683488(v7, a3, (uint64_t)(v4 + 4))) {
          break;
        }
        uint64_t v4 = (void *)*v8;
        uint64_t v5 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (!sub_1CD683488(v7, v9, a3)) {
        break;
      }
      uint64_t v5 = v8 + 1;
      uint64_t v4 = (void *)v8[1];
    }
    while (v4);
  }
  else
  {
    uint64_t v8 = (void *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

BOOL sub_1CD683488(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a2 + 16);
  unint64_t v4 = *(void *)(a3 + 16);
  if (v3 != v4) {
    return v3 > v4;
  }
  unint64_t v5 = *(void *)(a2 + 8);
  unint64_t v6 = *(void *)(a3 + 8);
  if (v6 >= v5) {
    size_t v7 = *(void *)(a2 + 8);
  }
  else {
    size_t v7 = *(void *)(a3 + 8);
  }
  if (v7 && (int v8 = memcmp(*(const void **)a2, *(const void **)a3, v7)) != 0)
  {
    int v9 = (v8 >> 31) | 1;
  }
  else
  {
    if (v5 < v6) {
      int v9 = -1;
    }
    else {
      int v9 = 1;
    }
    if (v5 == v6) {
      int v9 = 0;
    }
  }
  return v9 == -1;
}

_DWORD *sub_1CD68350C(_DWORD *result)
{
  if (*((void *)result + 1))
  {
    uint64_t v1 = result[4];
    if (v1 > 4 * result[2] && v1 >= 0x41)
    {
      return sub_1CD683560(result);
    }
    else
    {
      if (v1)
      {
        unint64_t v2 = *(void **)result;
        uint64_t v3 = 24 * v1;
        do
        {
          *unint64_t v2 = -1;
          v2 += 3;
          v3 -= 24;
        }
        while (v3);
      }
      *((void *)result + 1) = 0;
    }
  }
  return result;
}

_DWORD *sub_1CD683560(_DWORD *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[4];
  int v3 = result[2];
  int v4 = 1 << (33 - __clz(v3 - 1));
  if (v4 <= 64) {
    int v4 = 64;
  }
  if (v3) {
    int v5 = v4;
  }
  else {
    int v5 = 0;
  }
  if (v5 == v2)
  {
    *((void *)result + 1) = 0;
    if (v2)
    {
      unint64_t v6 = *(void **)result;
      uint64_t v7 = 24 * v2;
      do
      {
        *unint64_t v6 = -1;
        v6 += 3;
        v7 -= 24;
      }
      while (v7);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)result, 8);
    return sub_1CC9AE5D8(v1, v5);
  }
  return result;
}

uint64_t sub_1CD683610(uint64_t a1)
{
  *(void *)a1 = &unk_1F262A910;
  uint64_t v2 = *(atomic_uint **)(a1 + 1120);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }
  if (*(char *)(a1 + 1119) < 0) {
    operator delete(*(void **)(a1 + 1096));
  }
  if (*(char *)(a1 + 1095) < 0) {
    operator delete(*(void **)(a1 + 1072));
  }
  uint64_t v3 = *(void *)(a1 + 1056);
  *(void *)(a1 + 1056) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  sub_1CD555E34((uint64_t *)(a1 + 1016));
  sub_1CD554148(a1 + 992);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 992), 8);
  sub_1CD554148(a1 + 968);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 968), 8);
  uint64_t v4 = *(void *)(a1 + 960);
  *(void *)(a1 + 960) = 0;
  if (v4) {
    llvm::LoopInfoBase<llvm::BasicBlock,llvm::Loop>::~LoopInfoBase();
  }
  uint64_t v5 = *(void *)(a1 + 952);
  *(void *)(a1 + 952) = 0;
  if (v5) {
    sub_1CBF8FFEC(a1 + 952, v5);
  }
  uint64_t v6 = *(void *)(a1 + 944);
  *(void *)(a1 + 944) = 0;
  if (v6) {
    sub_1CBF8FF20(a1 + 944, v6);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 920), 8);
  sub_1CD40B1BC(*(void **)(a1 + 904));
  uint64_t v7 = *(void **)(a1 + 368);
  if (v7 != (void *)(a1 + 384)) {
    free(v7);
  }
  int v8 = *(void **)(a1 + 88);
  if (v8 != *(void **)(a1 + 80)) {
    free(v8);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 56), 8);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 32), 8);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
  return a1;
}

void sub_1CD6837B8(const char **a1, long long *a2, __n128 *a3, _WORD *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE4168, 0, 0);
  qword_1EBCE41E8 = 0;
  qword_1EBCE41F0 = 0;
  qword_1EBCE4210 = 0;
  unk_1EBCE4218 = 0;
  byte_1EBCE4220 = 0;
  qword_1EBCE4208 = 0;
  unk_1EBCE41F8 = 0;
  unk_1EBCE4200 = &unk_1F2643C20;
  qword_1EBCE4168 = (uint64_t)&unk_1F2643FD0;
  qword_1EBCE4228 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCE4230 = (uint64_t)&unk_1F25F6428;
  qword_1EBCE4248 = (uint64_t)&qword_1EBCE4230;
  sub_1CD6838C4(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE4168);
}

__n128 sub_1CD6838C4(const char **a1, long long *a2, __n128 *a3, _WORD *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE4168, "sample-profile-remapping-file", 0x1DuLL);
  sub_1CBAD7D28(a1, (uint64_t)&qword_1EBCE4168);
  xmmword_1EBCE4198 = *a2;
  __n128 result = *a3;
  xmmword_1EBCE4188 = (__int128)*a3;
  word_1EBCE4172 = (32 * (*a4 & 3)) | word_1EBCE4172 & 0xFF9F;
  return result;
}

llvm::cl::Option *sub_1CD683950(llvm::cl::Option *a1, char *a2, _WORD *a3, _WORD *a4, unsigned char **a5, __n128 *a6)
{
  uint64_t v12 = sub_1CB883A14((uint64_t)a1, 0, 0);
  *(unsigned char *)(v12 + 128) = 0;
  *(void *)(v12 + 136) = &unk_1F25EDE58;
  *(void *)(v12 + 144) = 0;
  *(void *)uint64_t v12 = &unk_1F26440A0;
  *(void *)(v12 + 152) = &unk_1F2643CC0;
  *(void *)(v12 + 160) = &unk_1F25EDE78;
  *(void *)(v12 + 184) = v12 + 160;
  sub_1CD683A48(v12, a2, a3, a4, a5, a6);
  llvm::cl::Option::addArgument(a1);
  return a1;
}

__n128 sub_1CD683A48(uint64_t a1, char *__s, _WORD *a3, _WORD *a4, unsigned char **a5, __n128 *a6)
{
  size_t v12 = strlen(__s);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)__s, v12);
  __int16 v13 = *(_WORD *)(a1 + 10) & 0xFF9F | (32 * (*a3 & 3));
  *(_WORD *)(a1 + 10) = v13;
  *(_WORD *)(a1 + 10) = v13 & 0xFFF8 | *a4 & 7;
  uint64_t v14 = *a5;
  *(unsigned char *)(a1 + 128) = **a5;
  *(unsigned char *)(a1 + 145) = 1;
  *(unsigned char *)(a1 + 144) = *v14;
  __n128 result = *a6;
  *(__n128 *)(a1 + 32) = *a6;
  return result;
}

void sub_1CD683AE4(_WORD *a1, int **a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&ProfileInlineGrowthLimit, 0, 0);
  dword_1EBD08B70 = 0;
  qword_1EBD08B78 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBD08B80 = 0;
  ProfileInlineGrowthLimit = (uint64_t)&unk_1F2643F68;
  qword_1EBD08B88 = (uint64_t)&unk_1F2643D20;
  qword_1EBD08B90 = (uint64_t)&unk_1F25F7480;
  qword_1EBD08BA8 = (uint64_t)&qword_1EBD08B90;
  sub_1CD683BD4(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&ProfileInlineGrowthLimit);
}

__n128 sub_1CD683BD4(_WORD *a1, int **a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&ProfileInlineGrowthLimit, "sample-profile-inline-growth-limit", 0x22uLL);
  word_1EBD08AFA = (32 * (*a1 & 3)) | word_1EBD08AFA & 0xFF9F;
  uint64_t v6 = *a2;
  dword_1EBD08B70 = **a2;
  byte_1EBD08B84 = 1;
  dword_1EBD08B80 = *v6;
  __n128 result = *a3;
  xmmword_1EBD08B10 = (__int128)*a3;
  return result;
}

void sub_1CD683C5C(_WORD *a1, int **a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&SampleHotCallSiteThreshold, 0, 0);
  dword_1EBD08DB0 = 0;
  qword_1EBD08DB8 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBD08DC0 = 0;
  SampleHotCallSiteThreshold = (uint64_t)&unk_1F2643F68;
  qword_1EBD08DC8 = (uint64_t)&unk_1F2643D20;
  qword_1EBD08DD0 = (uint64_t)&unk_1F25F7480;
  qword_1EBD08DE8 = (uint64_t)&qword_1EBD08DD0;
  sub_1CD683D4C(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&SampleHotCallSiteThreshold);
}

__n128 sub_1CD683D4C(_WORD *a1, int **a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&SampleHotCallSiteThreshold, "sample-profile-hot-inline-threshold", 0x23uLL);
  word_1EBD08D3A = (32 * (*a1 & 3)) | word_1EBD08D3A & 0xFF9F;
  uint64_t v6 = *a2;
  dword_1EBD08DB0 = **a2;
  byte_1EBD08DC4 = 1;
  dword_1EBD08DC0 = *v6;
  __n128 result = *a3;
  xmmword_1EBD08D50 = (__int128)*a3;
  return result;
}

void sub_1CD683DD4(_WORD *a1, int **a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&SampleColdCallSiteThreshold, 0, 0);
  dword_1EBD08E70 = 0;
  qword_1EBD08E78 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBD08E80 = 0;
  SampleColdCallSiteThreshold = (uint64_t)&unk_1F2643F68;
  qword_1EBD08E88 = (uint64_t)&unk_1F2643D20;
  qword_1EBD08E90 = (uint64_t)&unk_1F25F7480;
  qword_1EBD08EA8 = (uint64_t)&qword_1EBD08E90;
  sub_1CD683EC4(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&SampleColdCallSiteThreshold);
}

__n128 sub_1CD683EC4(_WORD *a1, int **a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&SampleColdCallSiteThreshold, "sample-profile-cold-inline-threshold", 0x24uLL);
  word_1EBD08DFA = (32 * (*a1 & 3)) | word_1EBD08DFA & 0xFF9F;
  uint64_t v6 = *a2;
  dword_1EBD08E70 = **a2;
  byte_1EBD08E84 = 1;
  dword_1EBD08E80 = *v6;
  __n128 result = *a3;
  xmmword_1EBD08E10 = (__int128)*a3;
  return result;
}

void sub_1CD683F4C(_WORD *a1, int **a2, long long *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCE3C00, 0, 0);
  dword_1EBCE3C80 = 0;
  qword_1EBCE3C88 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCE3C90 = 0;
  qword_1EBCE3C00 = (uint64_t)&unk_1F2643F00;
  qword_1EBCE3C98 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCE3CA0 = (uint64_t)&unk_1F25EA168;
  qword_1EBCE3CB8 = (uint64_t)&qword_1EBCE3CA0;
  llvm::cl::Option::setArgStr(v6, "sample-profile-icp-relative-hotness-skip", 0x28uLL);
  word_1EBCE3C0A = (32 * (*a1 & 3)) | word_1EBCE3C0A & 0xFF9F;
  dword_1EBCE3C80 = **a2;
  byte_1EBCE3C94 = 1;
  dword_1EBCE3C90 = dword_1EBCE3C80;
  xmmword_1EBCE3C20 = *a3;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE3C00);
}

void sub_1CD684074(_WORD *a1, _WORD *a2, char **a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE3CC0, 0, 0);
  byte_1EBCE3D40 = 0;
  qword_1EBCE3D48 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCE3D50 = 0;
  qword_1EBCE3CC0 = (uint64_t)&unk_1F26440A0;
  qword_1EBCE3D58 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCE3D60 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCE3D78 = (uint64_t)&qword_1EBCE3D60;
  sub_1CD684174(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE3CC0);
}

__n128 sub_1CD684174(_WORD *a1, _WORD *a2, char **a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE3CC0, "sample-profile-prioritized-inline", 0x21uLL);
  word_1EBCE3CCA = word_1EBCE3CCA & 0xFF9F | (32 * (*a1 & 3));
  word_1EBCE3CCA = word_1EBCE3CCA & 0xFFF8 | *a2 & 7;
  int v8 = *a3;
  byte_1EBCE3D40 = **a3;
  byte_1EBCE3D51 = 1;
  byte_1EBCE3D50 = *v8;
  __n128 result = *a4;
  xmmword_1EBCE3CE0 = (__int128)*a4;
  return result;
}

void sub_1CD68420C(_WORD *a1, _WORD *a2, char **a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE3D80, 0, 0);
  byte_1EBCE3E00 = 0;
  qword_1EBCE3E08 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCE3E10 = 0;
  qword_1EBCE3D80 = (uint64_t)&unk_1F26440A0;
  qword_1EBCE3E18 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCE3E20 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCE3E38 = (uint64_t)&qword_1EBCE3E20;
  sub_1CD68430C(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE3D80);
}

__n128 sub_1CD68430C(_WORD *a1, _WORD *a2, char **a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE3D80, "sample-profile-use-preinliner", 0x1DuLL);
  word_1EBCE3D8A = word_1EBCE3D8A & 0xFF9F | (32 * (*a1 & 3));
  word_1EBCE3D8A = word_1EBCE3D8A & 0xFFF8 | *a2 & 7;
  int v8 = *a3;
  byte_1EBCE3E00 = **a3;
  byte_1EBCE3E11 = 1;
  byte_1EBCE3E10 = *v8;
  __n128 result = *a4;
  xmmword_1EBCE3DA0 = (__int128)*a4;
  return result;
}

void sub_1CD6843A4(const char **a1, long long *a2, __n128 *a3, _WORD *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE4250, 0, 0);
  qword_1EBCE42D0 = 0;
  qword_1EBCE42D8 = 0;
  qword_1EBCE42F8 = 0;
  unk_1EBCE4300 = 0;
  byte_1EBCE4308 = 0;
  qword_1EBCE42F0 = 0;
  unk_1EBCE42E0 = 0;
  unk_1EBCE42E8 = &unk_1F2643C20;
  qword_1EBCE4250 = (uint64_t)&unk_1F2643FD0;
  qword_1EBCE4310 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCE4318 = (uint64_t)&unk_1F25F6428;
  qword_1EBCE4330 = (uint64_t)&qword_1EBCE4318;
  sub_1CD6844B0(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE4250);
}

__n128 sub_1CD6844B0(const char **a1, long long *a2, __n128 *a3, _WORD *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE4250, "sample-profile-inline-replay", 0x1CuLL);
  sub_1CBAD7D28(a1, (uint64_t)&qword_1EBCE4250);
  xmmword_1EBCE4280 = *a2;
  __n128 result = *a3;
  xmmword_1EBCE4270 = (__int128)*a3;
  word_1EBCE425A = (32 * (*a4 & 3)) | word_1EBCE425A & 0xFF9F;
  return result;
}

void sub_1CD68453C(int **a1, uint64_t *a2, __n128 *a3, _WORD *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE4338, 0, 0);
  dword_1EBCE43B8 = 0;
  qword_1EBCE43C0 = (uint64_t)&unk_1F2628D00;
  *(void *)&dword_1EBCE43C8 = 0;
  qword_1EBCE4338 = (uint64_t)&unk_1F2628C48;
  qword_1EBCE43D0 = (uint64_t)&unk_1F2628CB0;
  unk_1EBCE43D8 = &qword_1EBCE4338;
  qword_1EBCE43E0 = (uint64_t)&unk_1EBCE43F0;
  qword_1EBCE43E8 = 0x800000000;
  qword_1EBCE4570 = (uint64_t)&unk_1F2628F30;
  qword_1EBCE4588 = (uint64_t)&qword_1EBCE4570;
  sub_1CD684650(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE4338);
}

__n128 sub_1CD684650(int **a1, uint64_t *a2, __n128 *a3, _WORD *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE4338, "sample-profile-inline-replay-scope", 0x22uLL);
  int v8 = *a1;
  dword_1EBCE43B8 = **a1;
  byte_1EBCE43CC = 1;
  dword_1EBCE43C8 = *v8;
  sub_1CC94616C(a2, (uint64_t)&qword_1EBCE4338);
  __n128 result = *a3;
  xmmword_1EBCE4358 = (__int128)*a3;
  word_1EBCE4342 = (32 * (*a4 & 3)) | word_1EBCE4342 & 0xFF9F;
  return result;
}

void sub_1CD6846F0(int **a1, uint64_t *a2, __n128 *a3, _WORD *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE4590, 0, 0);
  dword_1EBCE4610 = 0;
  qword_1EBCE4618 = (uint64_t)&unk_1F2628DF8;
  *(void *)&dword_1EBCE4620 = 0;
  qword_1EBCE4590 = (uint64_t)&unk_1F2628D40;
  qword_1EBCE4628 = (uint64_t)&unk_1F2628DA8;
  unk_1EBCE4630 = &qword_1EBCE4590;
  qword_1EBCE4638 = (uint64_t)&unk_1EBCE4648;
  qword_1EBCE4640 = 0x800000000;
  qword_1EBCE47C8 = (uint64_t)&unk_1F2628F78;
  qword_1EBCE47E0 = (uint64_t)&qword_1EBCE47C8;
  sub_1CD684804(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE4590);
}

__n128 sub_1CD684804(int **a1, uint64_t *a2, __n128 *a3, _WORD *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE4590, "sample-profile-inline-replay-fallback", 0x25uLL);
  int v8 = *a1;
  dword_1EBCE4610 = **a1;
  byte_1EBCE4624 = 1;
  dword_1EBCE4620 = *v8;
  sub_1CC9461C8(a2, (uint64_t)&qword_1EBCE4590);
  __n128 result = *a3;
  xmmword_1EBCE45B0 = (__int128)*a3;
  word_1EBCE459A = (32 * (*a4 & 3)) | word_1EBCE459A & 0xFF9F;
  return result;
}

void sub_1CD6848A4(int **a1, uint64_t *a2, __n128 *a3, _WORD *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE47E8, 0, 0);
  dword_1EBCE4868 = 0;
  qword_1EBCE4870 = (uint64_t)&unk_1F2628EF0;
  *(void *)&dword_1EBCE4878 = 0;
  qword_1EBCE47E8 = (uint64_t)&unk_1F2628E38;
  qword_1EBCE4880 = (uint64_t)&unk_1F2628EA0;
  unk_1EBCE4888 = &qword_1EBCE47E8;
  qword_1EBCE4890 = (uint64_t)&unk_1EBCE48A0;
  qword_1EBCE4898 = 0x800000000;
  qword_1EBCE4A20 = (uint64_t)&unk_1F2628FC0;
  qword_1EBCE4A38 = (uint64_t)&qword_1EBCE4A20;
  sub_1CD6849B8(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE47E8);
}

__n128 sub_1CD6849B8(int **a1, uint64_t *a2, __n128 *a3, _WORD *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE47E8, "sample-profile-inline-replay-format", 0x23uLL);
  int v8 = *a1;
  dword_1EBCE4868 = **a1;
  byte_1EBCE487C = 1;
  dword_1EBCE4878 = *v8;
  sub_1CC9463A0(a2, (uint64_t)&qword_1EBCE47E8);
  __n128 result = *a3;
  xmmword_1EBCE4808 = (__int128)*a3;
  word_1EBCE47F2 = (32 * (*a4 & 3)) | word_1EBCE47F2 & 0xFF9F;
  return result;
}

BOOL llvm::PseudoProbeVerifier::shouldVerifyFunction(llvm::PseudoProbeVerifier *this, const llvm::Function *a2)
{
  if (llvm::GlobalValue::isDeclaration(a2) || (*((_DWORD *)a2 + 8) & 0xF) == 1) {
    return 0;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCE4A40, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EBCE4A40))
  {
    uint64_t v7 = qword_1EBCE4C70;
    uint64_t v8 = qword_1EBCE4C78;
    xmmword_1EBCE4A48 = 0u;
    *(_OWORD *)algn_1EBCE4A58 = 0u;
    for (dword_1EBCE4A68 = 1065353216; v7 != v8; v7 += 24)
      sub_1CC619C24((uint64_t)&xmmword_1EBCE4A48, v7, v7);
    __cxa_atexit((void (*)(void *))sub_1CC619C20, &xmmword_1EBCE4A48, &dword_1CB82C000);
    __cxa_guard_release(&qword_1EBCE4A40);
  }
  if (!qword_1EBCE4A60) {
    return 1;
  }
  Name = llvm::Value::getName(a2);
  if (Name) {
    std::string::__init(&v9, Name, v6);
  }
  else {
    memset(&v9, 0, sizeof(v9));
  }
  BOOL v3 = sub_1CC619FE0(&xmmword_1EBCE4A48, (uint64_t)&v9) != 0;
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
  return v3;
}

uint64_t llvm::PseudoProbeVerifier::registerCallbacks(uint64_t result, uint64_t a2)
{
  if (byte_1EBCE4AF0)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 440);
    if (v2 >= *(_DWORD *)(a2 + 444)) {
      llvm::SmallVectorBase<unsigned int>::mallocForGrow();
    }
    BOOL v3 = (void *)(*(void *)(a2 + 432) + 32 * v2);
    *BOOL v3 = result;
    void v3[3] = (char *)off_1EC7DFA50 + 2;
    *(_DWORD *)(a2 + 440) = v2 + 1;
  }
  return result;
}

void llvm::PseudoProbeVerifier::runAfterPass(llvm::PseudoProbeVerifier *a1, const std::string::value_type *a2, std::string::size_type a3, uint64_t *a4)
{
  if (a2) {
    std::string::__init(&v29, a2, a3);
  }
  else {
    memset(&v29, 0, sizeof(v29));
  }
  std::string::size_type v6 = std::string::insert(&v29, 0, "\n*** Pseudo Probe Verification After ");
  std::string::size_type v7 = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v30.__r_.__value_.__r.__words[2] = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  uint64_t v8 = std::string::append(&v30, " ***\n");
  std::string::size_type v9 = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  uint64_t v32 = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v30.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v29.__r_.__value_.__l.__data_);
  }
  uint64_t v10 = llvm::dbgs((llvm *)v8);
  if (v32 >= 0) {
    uint64_t v11 = __p;
  }
  else {
    uint64_t v11 = (void **)__p[0];
  }
  if (v32 >= 0) {
    size_t v12 = HIBYTE(v32) & 0x7F;
  }
  else {
    size_t v12 = (size_t)__p[1];
  }
  llvm::raw_ostream::write(v10, (const char *)v11, v12);
  __int16 v13 = (void *)(*(uint64_t (**)(void))(*(void *)*a4 + 24))();
  uint64_t v14 = *a4;
  if (v13 == &llvm::Any::TypeId<llvm::Module const*>::Id)
  {
    (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
    uint64_t v24 = *(void *)(*a4 + 8);
    uint64_t v25 = v24 + 24;
    for (uint64_t i = *(void *)(v24 + 32); i != v25; uint64_t i = *(void *)(i + 8))
    {
      if (i) {
        __int16 v27 = (const llvm::Function *)(i - 56);
      }
      else {
        __int16 v27 = 0;
      }
      llvm::PseudoProbeVerifier::runAfterPass(a1, v27);
    }
    goto LABEL_19;
  }
  uint64_t v15 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v14 + 24))(v14);
  uint64_t v16 = *a4;
  if (v15 == &llvm::Any::TypeId<llvm::Function const*>::Id)
  {
    (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
    uint64_t v28 = (const llvm::Function **)(*a4 + 8);
LABEL_31:
    llvm::PseudoProbeVerifier::runAfterPass(a1, *v28);
    goto LABEL_19;
  }
  uint64_t v17 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v16 + 24))(v16);
  uint64_t v18 = *a4;
  if (v17 != &llvm::Any::TypeId<llvm::LazyCallGraph::SCC const*>::Id)
  {
    (*(void (**)(uint64_t))(*(void *)v18 + 24))(v18);
    (*(void (**)(void))(*(void *)*a4 + 24))();
    uint64_t v28 = (const llvm::Function **)(**(void **)(*(void *)(*a4 + 8) + 32) + 56);
    goto LABEL_31;
  }
  (*(void (**)(uint64_t))(*(void *)v18 + 24))(v18);
  uint64_t v19 = *(void *)(*a4 + 8);
  uint64_t v20 = *(unsigned int *)(v19 + 16);
  if (v20)
  {
    uint64_t v21 = *(uint64_t **)(v19 + 8);
    uint64_t v22 = 8 * v20;
    do
    {
      uint64_t v23 = *v21++;
      llvm::PseudoProbeVerifier::runAfterPass(a1, *(const llvm::Function **)(v23 + 8));
      v22 -= 8;
    }
    while (v22);
  }
LABEL_19:
  if (SHIBYTE(v32) < 0) {
    operator delete(__p[0]);
  }
}

void llvm::PseudoProbeVerifier::runAfterPass(llvm::PseudoProbeVerifier *this, const llvm::Function *a2)
{
  shouldVerifyuint64_t Function = llvm::PseudoProbeVerifier::shouldVerifyFunction(this, a2);
  if (shouldVerifyFunction)
  {
    *(_OWORD *)uint64_t v10 = 0u;
    *(_OWORD *)std::string __p = 0u;
    int v12 = 1065353216;
    for (uint64_t i = (void *)*((void *)a2 + 10); i != (void *)((char *)a2 + 72); uint64_t i = (void *)i[1])
    {
      if (i) {
        uint64_t v6 = (uint64_t)(i - 3);
      }
      else {
        uint64_t v6 = 0;
      }
      llvm::PseudoProbeVerifier::collectProbeFactors(shouldVerifyFunction, v6, (uint64_t)v10);
    }
    llvm::PseudoProbeVerifier::verifyProbeFactors((uint64_t)this, a2, (uint64_t)v10);
    std::string::size_type v7 = __p[0];
    if (__p[0])
    {
      do
      {
        uint64_t v8 = (void *)*v7;
        operator delete(v7);
        std::string::size_type v7 = v8;
      }
      while (v8);
    }
    std::string::size_type v9 = v10[0];
    v10[0] = 0;
    if (v9) {
      operator delete(v9);
    }
  }
}

void llvm::PseudoProbeVerifier::collectProbeFactors(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a2 + 40;
  uint64_t v4 = *(void *)(a2 + 48);
  if (v4 != a2 + 40)
  {
    do
    {
      if (v4) {
        uint64_t v6 = (uint64_t *)(v4 - 24);
      }
      else {
        uint64_t v6 = 0;
      }
      llvm::extractProbe((llvm *)v6, (uint64_t)v11);
      if (v12)
      {
        uint64_t v7 = sub_1CC9B65D0(v6[6]);
        float v8 = *(float *)&v11[3];
        *(void *)&long long v10 = v11[0];
        *((void *)&v10 + 1) = v7;
        std::string::size_type v9 = (float *)sub_1CC9B7ED4(a3, v11[0], v7, &v10);
        v9[8] = v8 + v9[8];
      }
      uint64_t v4 = *(void *)(v4 + 8);
    }
    while (v4 != v3);
  }
}

uint64_t *llvm::PseudoProbeVerifier::verifyProbeFactors(uint64_t a1, llvm::Value *this, uint64_t a3)
{
  Name = (unsigned __int8 *)llvm::Value::getName(this);
  __n128 result = sub_1CD685ED4(a1, Name, v7);
  std::string::size_type v9 = *(float **)(a3 + 16);
  if (v9)
  {
    char v10 = 0;
    uint64_t v11 = (void *)(*result + 8);
    do
    {
      uint64_t v12 = *((void *)v9 + 2);
      float v13 = v9[8];
      uint64_t v14 = *((void *)v9 + 3);
      if (sub_1CD685FD8(v11, v12, v14))
      {
        uint64_t v15 = (float *)sub_1CC9B7ED4((uint64_t)v11, v12, v14, (_OWORD *)v9 + 1);
        float v16 = v15[8];
        if (vabds_f32(v13, v16) > 0.02)
        {
          if ((v10 & 1) == 0)
          {
            uint64_t v17 = llvm::dbgs((llvm *)v15);
            uint64_t v18 = sub_1CB8E509C(v17, "Function ");
            uint64_t v20 = llvm::Value::getName(this);
            size_t v21 = v19;
            uint64_t v22 = (void *)*((void *)v18 + 4);
            if (v19 <= *((void *)v18 + 3) - (void)v22)
            {
              if (v19)
              {
                memcpy(v22, v20, v19);
                *((void *)v18 + 4) += v21;
              }
            }
            else
            {
              llvm::raw_ostream::write(v18, v20, v19);
            }
            uint64_t v15 = (float *)sub_1CB8E509C(v18, ":\n");
          }
          uint64_t v23 = llvm::dbgs((llvm *)v15);
          uint64_t v24 = sub_1CB8E509C(v23, "Probe ");
          uint64_t v25 = llvm::raw_ostream::operator<<(v24, *((void *)v9 + 2));
          uint64_t v26 = sub_1CB8E509C(v25, "\tprevious factor ");
          v32[0] = &unk_1F2618090;
          v32[1] = "%0.2f";
          v32[2] = LODWORD(v16);
          __int16 v27 = llvm::raw_ostream::operator<<(v26, (uint64_t)v32);
          uint64_t v28 = sub_1CB8E509C(v27, "\tcurrent factor ");
          v31[0] = &unk_1F2618090;
          v31[1] = "%0.2f";
          v31[2] = LODWORD(v13);
          std::string v29 = llvm::raw_ostream::operator<<(v28, (uint64_t)v31);
          sub_1CB8E509C(v29, "\n");
          char v10 = 1;
        }
      }
      int v30 = *((_DWORD *)v9 + 8);
      __n128 result = sub_1CC9B7ED4((uint64_t)v11, *((void *)v9 + 2), *((void *)v9 + 3), (_OWORD *)v9 + 1);
      *((_DWORD *)result + 8) = v30;
      std::string::size_type v9 = *(float **)v9;
    }
    while (v9);
  }
  return result;
}

llvm::PseudoProbeManager *llvm::PseudoProbeManager::PseudoProbeManager(llvm::PseudoProbeManager *this, const llvm::Module *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  v20[0] = "llvm.pseudo_probe_desc";
  __int16 v21 = 259;
  NamedMetadata = (llvm::NamedMDNode *)llvm::Module::getNamedMetadata(a2, v20);
  if (NamedMetadata)
  {
    uint64_t v4 = NamedMetadata;
    int NumOperands = llvm::NamedMDNode::getNumOperands(NamedMetadata);
    if (NumOperands)
    {
      int v6 = NumOperands;
      for (unsigned int i = 0; i != v6; ++i)
      {
        uint64_t Operand = llvm::NamedMDNode::getOperand(v4, i);
        std::string::size_type v9 = (void *)(Operand - 8 * *(unsigned int *)(Operand + 8));
        if (*(unsigned char *)(*(void *)(*v9 + 128) + 16) == 16) {
          uint64_t v10 = *(void *)(*v9 + 128);
        }
        else {
          uint64_t v10 = 0;
        }
        uint64_t v11 = (uint64_t *)(v10 + 24);
        if (*(_DWORD *)(v10 + 32) >= 0x41u) {
          uint64_t v11 = (uint64_t *)*v11;
        }
        uint64_t v12 = *v11;
        uint64_t v19 = v12;
        uint64_t v13 = *(void *)(v9[1] + 128);
        if (*(unsigned char *)(v13 + 16) == 16) {
          uint64_t v14 = v13;
        }
        else {
          uint64_t v14 = 0;
        }
        uint64_t v15 = (void *)(v14 + 24);
        if (*(_DWORD *)(v14 + 32) >= 0x41u) {
          uint64_t v15 = (void *)*v15;
        }
        float v16 = (void *)*v15;
        *(void *)&long long v18 = v12;
        *((void *)&v18 + 1) = v16;
        sub_1CD68546C((uint64_t)v20, (uint64_t)this, &v19, &v18);
      }
    }
  }
  return this;
}

uint64_t sub_1CD68546C(uint64_t a1, uint64_t a2, uint64_t *a3, _OWORD *a4)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CD686098(*(void *)a2, *(_DWORD *)(a2 + 16), *a3, &v12);
  std::string::size_type v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD686134(a2, a3, v12);
    std::string::size_type v9 = (void *)result;
    *(void *)uint64_t result = *a3;
    *(_OWORD *)(result + 8) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 24 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t *llvm::PseudoProbeManager::getDesc(llvm::PseudoProbeManager *this, const llvm::Function *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (int *)sub_1CD553864(a2);
  long long v14 = xmmword_1CFAC4320;
  uint64_t v15 = 0;
  llvm::MD5::update((int *)&v14, v3, v4);
  llvm::MD5::final((int *)&v14, v13);
  uint64_t v5 = *(void *)this;
  unsigned int v6 = *((_DWORD *)this + 4);
  if (v6)
  {
    unsigned int v7 = (v6 - 1) & (37 * v13[0]);
    float v8 = (uint64_t *)(v5 + 24 * v7);
    uint64_t v9 = *v8;
    if (*(void *)v13 == *v8) {
      goto LABEL_3;
    }
    int v11 = 1;
    while (v9 != -1)
    {
      unsigned int v12 = v7 + v11++;
      unsigned int v7 = v12 & (v6 - 1);
      float v8 = (uint64_t *)(v5 + 24 * v7);
      uint64_t v9 = *v8;
      if (*(void *)v13 == *v8) {
        goto LABEL_3;
      }
    }
  }
  float v8 = (uint64_t *)(v5 + 24 * v6);
LABEL_3:
  if (v8 == (uint64_t *)(v5 + 24 * v6)) {
    return 0;
  }
  else {
    return v8 + 1;
  }
}

BOOL llvm::PseudoProbeManager::moduleIsProbed(llvm::PseudoProbeManager *this, const llvm::Module *a2)
{
  uint64_t v3 = "llvm.pseudo_probe_desc";
  __int16 v4 = 259;
  return llvm::Module::getNamedMetadata(a2, &v3) != 0;
}

uint64_t *llvm::PseudoProbeManager::profileIsValid(llvm::PseudoProbeManager *this, const llvm::Function *a2, const llvm::sampleprof::FunctionSamples *a3)
{
  uint64_t result = llvm::PseudoProbeManager::getDesc(this, a2);
  if (result) {
    return (uint64_t *)(result[1] == *((void *)a3 + 1));
  }
  return result;
}

uint64_t llvm::SampleProfileProber::SampleProfileProber(uint64_t a1, uint64_t a2, long long *a3)
{
  *(void *)a1 = a2;
  uint64_t v4 = a1 + 8;
  if (*((char *)a3 + 23) < 0)
  {
    sub_1CB8BDF7C(v4, *(const void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v5 = *a3;
    *(void *)(v4 + 16) = *((void *)a3 + 2);
    *(_OWORD *)uint64_t v4 = v5;
  }
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_DWORD *)(a1 + 72) = 1065353216;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_DWORD *)(a1 + 112) = 1065353216;
  sub_1CD6809F4((void *)(a1 + 40));
  sub_1CD6809F4((void *)(a1 + 80));
  *(_DWORD *)(a1 + 120) = 0;
  llvm::SampleProfileProber::computeProbeIdForBlocks((_DWORD *)a1);
  llvm::SampleProfileProber::computeProbeIdForCallsites((llvm::SampleProfileProber *)a1);
  llvm::SampleProfileProber::computeCFGHash((llvm::SampleProfileProber *)a1);
  return a1;
}

_DWORD *llvm::SampleProfileProber::computeProbeIdForBlocks(_DWORD *this)
{
  uint64_t v1 = *(void *)this + 72;
  uint64_t v2 = *(void *)(*(void *)this + 80);
  if (v2 != v1)
  {
    uint64_t v3 = this;
    uint64_t v4 = (uint64_t)(this + 10);
    do
    {
      if (v2) {
        unint64_t v5 = v2 - 24;
      }
      else {
        unint64_t v5 = 0;
      }
      int v6 = v3[30] + 1;
      v3[30] = v6;
      unint64_t v7 = v5;
      this = sub_1CC151E74(v4, v5, &v7);
      this[6] = v6;
      uint64_t v2 = *(void *)(v2 + 8);
    }
    while (v2 != v1);
  }
  return this;
}

void llvm::SampleProfileProber::computeCFGHash(llvm::SampleProfileProber *this)
{
  uint64_t v20 = 0;
  __int16 v21 = 0;
  unint64_t v22 = 0;
  unsigned int v19 = -1;
  uint64_t v2 = *(void *)this + 72;
  uint64_t v3 = *(void *)(*(void *)this + 80);
  if (v3 == v2)
  {
    uint64_t v17 = 0;
    LODWORD(v4) = 0;
    long long v18 = 0;
  }
  else
  {
    uint64_t v4 = 0;
    do
    {
      if (v3) {
        uint64_t v5 = v3 - 24;
      }
      else {
        uint64_t v5 = 0;
      }
      uint64_t v6 = *(void *)(v5 + 40);
      if (v6 == v5 + 40)
      {
        float v8 = 0;
      }
      else
      {
        if (v6) {
          unint64_t v7 = (unsigned __int8 *)(v6 - 24);
        }
        else {
          unint64_t v7 = 0;
        }
        if (v7[16] - 29 >= 0xB) {
          float v8 = 0;
        }
        else {
          float v8 = (llvm::Instruction *)v7;
        }
      }
      int NumSuccessors = llvm::Instruction::getNumSuccessors(v8);
      if (NumSuccessors)
      {
        int v10 = NumSuccessors;
        for (unsigned int i = 0; i != v10; ++i)
        {
          unint64_t Successor = llvm::Instruction::getSuccessor(v8, i);
          uint64_t v13 = sub_1CD4CAC44((void *)this + 5, Successor);
          if (v13) {
            unsigned int v14 = *((_DWORD *)v13 + 6);
          }
          else {
            unsigned int v14 = 0;
          }
          for (int j = 0; j != 32; j += 8)
          {
            unsigned int v16 = v14 >> j;
            if ((unint64_t)v4 >= v22) {
              uint64_t v4 = (unsigned char *)sub_1CC9B80DC((void **)&v20, v16);
            }
            else {
              *v4++ = v16;
            }
            __int16 v21 = v4;
          }
        }
      }
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != v2);
    uint64_t v17 = v20;
    long long v18 = v4;
  }
  llvm::JamCRC::update(&v19, v17, v18 - v17);
  *((void *)this + 4) = (((unint64_t)(v4 - v17) << 32) | (*((void *)this + 13) << 48)) & 0xFFFFFFF00000000 | v19;
  if (v17) {
    operator delete(v17);
  }
}

void llvm::SampleProfileProbePass::run(llvm *this@<X1>, llvm::TargetMachine **a2@<X0>, uint64_t a3@<X8>)
{
  llvm::getUniqueModuleId(this, (uint64_t)&v10);
  llvm::Module::getOrInsertNamedMetadata(this, "llvm.pseudo_probe_desc", 0x16uLL);
  uint64_t v6 = (char *)this + 24;
  for (uint64_t i = *((void *)this + 4); (char *)i != v6; uint64_t i = *(void *)(i + 8))
  {
    if (i) {
      uint64_t v8 = i - 56;
    }
    else {
      uint64_t v8 = 0;
    }
    if (i && *(unsigned char *)(v8 + 16) == 3)
    {
      if ((*(_DWORD *)(v8 + 20) & 0x7FFFFFF) == 0) {
        continue;
      }
LABEL_14:
      llvm::SampleProfileProber::SampleProfileProber((uint64_t)v9, v8, &v10);
      llvm::SampleProfileProber::instrumentOneFunc((llvm::SampleProfileProber *)v9, (llvm::Function *)v8, *a2);
      sub_1CD685D9C((uint64_t)v9);
      continue;
    }
    if (*(unsigned char *)(v8 + 16) || *(void *)(v8 + 72) != v8 + 72 || (*(unsigned char *)(v8 + 34) & 0x80) != 0) {
      goto LABEL_14;
    }
  }
  *(_OWORD *)(a3 + 40) = 0u;
  *(_OWORD *)(a3 + 56) = 0u;
  *(void *)(a3 + 88) = 0;
  *(_OWORD *)(a3 + 72) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(void *)a3 = a3 + 32;
  *(void *)(a3 + 8) = a3 + 32;
  *(void *)(a3 + 16) = 2;
  *(void *)(a3 + 48) = a3 + 80;
  *(void *)(a3 + 56) = a3 + 80;
  *(_DWORD *)(a3 + 64) = 2;
  if (v11 < 0) {
    operator delete((void *)v10);
  }
}

void llvm::PseudoProbeUpdatePass::runOnFunction()
{
}

double llvm::PseudoProbeUpdatePass::run@<D0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if (byte_1EBCE4BB0)
  {
    for (uint64_t i = *(void *)(a1 + 32); i != a1 + 24; uint64_t i = *(void *)(i + 8))
    {
      if (i) {
        uint64_t v3 = i - 56;
      }
      else {
        uint64_t v3 = 0;
      }
      if (i && *(unsigned char *)(v3 + 16) == 3)
      {
        if ((*(_DWORD *)(v3 + 20) & 0x7FFFFFF) != 0) {
          goto LABEL_15;
        }
      }
      else if (*(unsigned char *)(v3 + 16) || *(void *)(v3 + 72) != v3 + 72 || (*(unsigned char *)(v3 + 34) & 0x80) != 0)
      {
LABEL_15:
        llvm::AnalysisManager<llvm::Module>::getResultImpl();
      }
    }
  }
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(void *)(a2 + 88) = 0;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(void *)a2 = a2 + 32;
  *(void *)(a2 + 8) = a2 + 32;
  *(void *)&double result = 2;
  *(void *)(a2 + 16) = 2;
  *(void *)(a2 + 48) = a2 + 80;
  *(void *)(a2 + 56) = a2 + 80;
  *(_DWORD *)(a2 + 64) = 2;
  return result;
}

uint64_t sub_1CD685D9C(uint64_t a1)
{
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1CD685DE0(_WORD *a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCE4BF0, 1, 0);
  qword_1EBCE4C70 = 0;
  qword_1EBCE4C78 = 0;
  qword_1EBCE4C80 = 0;
  unk_1EBCE4C88 = 0;
  qword_1EBCE4BF0 = (uint64_t)&unk_1F260A070;
  qword_1EBCE4C90 = 0;
  unk_1EBCE4C98 = 0;
  qword_1EBCE4CA0 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCE4CA8 = (uint64_t)&unk_1F260AC78;
  qword_1EBCE4CC0 = (uint64_t)&qword_1EBCE4CA8;
  llvm::cl::Option::setArgStr(v4, "verify-pseudo-probe-funcs", 0x19uLL);
  word_1EBCE4BFA = (32 * (*a1 & 3)) | word_1EBCE4BFA & 0xFF9F;
  xmmword_1EBCE4C10 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE4BF0);
}

uint64_t *sub_1CD685ED4(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  uint64_t v6 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  uint64_t i = (uint64_t *)(*(void *)a1 + 8 * v6);
  uint64_t v8 = *i;
  if (*i == -8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v8)
  {
    while (!v8 || v8 == -8)
    {
      uint64_t v9 = i[1];
      ++i;
      uint64_t v8 = v9;
    }
    return i;
  }
  char v11 = (char *)operator new(a3 + 49, (std::align_val_t)8uLL);
  unsigned int v12 = v11;
  uint64_t v13 = v11 + 48;
  if (a3) {
    memcpy(v11 + 48, a2, a3);
  }
  v13[a3] = 0;
  *(void *)unsigned int v12 = a3;
  *(_OWORD *)(v12 + 8) = 0u;
  *(_OWORD *)(v12 + 24) = 0u;
  *((_DWORD *)v12 + 10) = 1065353216;
  *uint64_t i = (uint64_t)v12;
  ++*(_DWORD *)(a1 + 12);
  for (uint64_t i = (uint64_t *)(*(void *)a1
                      + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v6));
        !*i || *i == -8;
  return i;
}

void *sub_1CD685FD8(void *a1, uint64_t a2, uint64_t a3)
{
  int8x8_t v3 = (int8x8_t)a1[1];
  if (!*(void *)&v3) {
    return 0;
  }
  unint64_t v4 = a3 - a2 + 32 * a2;
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = a3 - a2 + 32 * a2;
    if (v4 >= *(void *)&v3) {
      uint64_t v6 = v4 % *(void *)&v3;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v3 - 1) & v4;
  }
  unint64_t v7 = *(void **)(*a1 + 8 * v6);
  if (!v7) {
    return 0;
  }
  double result = (void *)*v7;
  if (*v7)
  {
    do
    {
      unint64_t v9 = result[1];
      if (v4 == v9)
      {
        if (result[2] == a2 && result[3] == a3) {
          return result;
        }
      }
      else
      {
        if (v5.u32[0] > 1uLL)
        {
          if (v9 >= *(void *)&v3) {
            v9 %= *(void *)&v3;
          }
        }
        else
        {
          v9 &= *(void *)&v3 - 1;
        }
        if (v9 != v6) {
          return 0;
        }
      }
      double result = (void *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t sub_1CD686098(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = (37 * a3) & (a2 - 1);
    uint64_t v6 = (void *)(a1 + 24 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      long long v10 = 0;
      int v11 = 1;
      while (v7 != -1)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -2;
        }
        if (v12) {
          long long v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        uint64_t v6 = (void *)(a1 + 24 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        uint64_t v6 = v10;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

void *sub_1CD686134(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD6861E8(a1, v6);
  uint64_t v8 = 0;
  sub_1CD686098(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD6861E8(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  double result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD6862C0(a1, v4, v4 + 24 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 24 * v10;
    do
    {
      void *result = -1;
      result += 3;
      v11 -= 24;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD6862C0(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 24 * v6;
    do
    {
      *int v7 = -1;
      v7 += 3;
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if (*(void *)a2 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v11 = 0;
      double result = sub_1CD686098(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      uint64_t v10 = v11;
      *uint64_t v11 = *(void *)a2;
      *(_OWORD *)(v10 + 1) = *(_OWORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 24;
  }
  return result;
}

void llvm::IPSCCPPass::run()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::AnalysisManager<llvm::Module>::getResultImpl();
}

void llvm::createIPSCCPPass(llvm *this)
{
}

void llvm::FunctionSpecializationPass::run()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::AnalysisManager<llvm::Module>::getResultImpl();
}

void llvm::createFunctionSpecializationPass(llvm *this)
{
}

double llvm::StripDeadPrototypesPass::run@<D0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if (sub_1CC9B96AC(a1))
  {
    int v3 = 0;
    *(void *)(a2 + 88) = 0;
    *(_OWORD *)(a2 + 72) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 24) = 0u;
    uint64_t v4 = a2 + 32;
  }
  else
  {
    *(void *)(a2 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
    uint64_t v4 = a2 + 32;
    int v3 = 1;
  }
  *(void *)a2 = v4;
  *(void *)(a2 + 8) = v4;
  *(_DWORD *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 20) = v3;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 48) = a2 + 80;
  *(void *)(a2 + 56) = a2 + 80;
  *(void *)&double result = 2;
  *(void *)(a2 + 64) = 2;
  *(_DWORD *)(a2 + 72) = 0;
  return result;
}

void llvm::createStripDeadPrototypesPass(llvm *this)
{
}

void llvm::createStripSymbolsPass(llvm *this)
{
}

void llvm::createStripNonDebugSymbolsPass(llvm *this)
{
}

void llvm::createStripDeadDebugInfoPass(llvm *this)
{
}

double llvm::StripSymbolsPass::run@<D0>(llvm *this@<X1>, unsigned char *a2@<X0>, uint64_t a3@<X8>)
{
  llvm::StripDebugInfo(this, this);
  sub_1CC9BA180(this, 0, *a2 == 0);
  *(void *)(a3 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a3 = a3 + 32;
  *(void *)(a3 + 8) = a3 + 32;
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 48) = a3 + 80;
  *(void *)(a3 + 56) = a3 + 80;
  *(void *)(a3 + 64) = 2;
  *(_DWORD *)(a3 + 72) = 0;
  *(void *)&double result = 0x100000002;
  *(void *)(a3 + 16) = 0x100000002;
  return result;
}

double llvm::StripNonDebugSymbolsPass::run@<D0>(unsigned char *a1@<X0>, const llvm::Module *a2@<X1>, uint64_t a3@<X8>)
{
  sub_1CC9BA180(a2, 1, *a1 == 0);
  *(void *)(a3 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a3 = a3 + 32;
  *(void *)(a3 + 8) = a3 + 32;
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 48) = a3 + 80;
  *(void *)(a3 + 56) = a3 + 80;
  *(void *)(a3 + 64) = 2;
  *(_DWORD *)(a3 + 72) = 0;
  *(void *)&double result = 0x100000002;
  *(void *)(a3 + 16) = 0x100000002;
  return result;
}

double llvm::StripDebugDeclarePass::run@<D0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  sub_1CC9BACA0(*(uint64_t **)(a1 + 112));
  *(void *)(a2 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a2 = a2 + 32;
  *(void *)(a2 + 8) = a2 + 32;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 48) = a2 + 80;
  *(void *)(a2 + 56) = a2 + 80;
  *(void *)(a2 + 64) = 2;
  *(_DWORD *)(a2 + 72) = 0;
  *(void *)&double result = 0x100000002;
  *(void *)(a2 + 16) = 0x100000002;
  return result;
}

double llvm::StripDeadDebugInfoPass::run@<D0>(llvm::Module *a1@<X1>, uint64_t a2@<X8>)
{
  sub_1CC9BB0E0(a1);
  *(void *)(a2 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a2 = a2 + 32;
  *(void *)(a2 + 8) = a2 + 32;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 48) = a2 + 80;
  *(void *)(a2 + 56) = a2 + 80;
  *(void *)(a2 + 64) = 2;
  *(_DWORD *)(a2 + 72) = 0;
  *(void *)&double result = 0x100000002;
  *(void *)(a2 + 16) = 0x100000002;
  return result;
}

void llvm::createWriteThinLTOBitcodePass(llvm *this, llvm::raw_ostream *a2, llvm::raw_ostream *a3)
{
}

void llvm::ThinLTOBitcodeWriterPass::run()
{
}

uint64_t sub_1CD686DBC@<X0>(uint64_t a1@<X0>, void *a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  BOOL v12 = 0;
  uint64_t result = sub_1CD3C8538((uint64_t *)a1, a2, &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD4F83B4(a1, (uint64_t)a2, a2, v12);
    uint64_t v9 = (void *)result;
    *(void *)uint64_t result = *a2;
    *(void *)(result + 8) = *a3;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a1 + 16 * *(unsigned int *)(a1 + 16);
  *(void *)a4 = v9;
  *(void *)(a4 + 8) = v11;
  *(unsigned char *)(a4 + 16) = v10;
  return result;
}

unsigned char *llvm::wholeprogramdevirt::setBeforeReturnValues(unsigned char *result, uint64_t a2, unint64_t a3, int a4, void *a5, unint64_t *a6)
{
  uint64_t v6 = ((a4 + 7) >> 3) + ((a3 + 7) >> 3);
  if (a4 == 1) {
    uint64_t v6 = (a3 >> 3) + 1;
  }
  *a5 = -v6;
  *a6 = a3 & 7;
  if (a2)
  {
    uint64_t v9 = (uint64_t)result;
    uint64_t v10 = 32 * a2;
    unsigned int v11 = ((a4 + 7) >> 3);
    do
    {
      if (a4 == 1) {
        uint64_t result = sub_1CD686EFC(**(void **)(v9 + 8), *(void *)(*(void *)(v9 + 8) + 8), *(void *)(v9 + 16), a3);
      }
      else {
        uint64_t result = sub_1CD686F64(v9, a3, v11);
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
  }
  return result;
}

unsigned char *sub_1CD686EFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v4 = a4;
  uint64_t result = (unsigned char *)sub_1CD68786C((unint64_t *)(a1 + 16), (unint64_t)(a4 - 8 * a2) >> 3, 1u);
  int v8 = 1 << (v4 & 7);
  if (a3) {
    *result |= v8;
  }
  *v7 |= v8;
  return result;
}

unsigned char *sub_1CD686F64(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v4 = *(unsigned __int8 *)(a1 + 24);
  unint64_t v5 = *(void *)(a1 + 16);
  uint64_t result = (unsigned char *)sub_1CD68786C((unint64_t *)(**(void **)(a1 + 8) + 16), (unint64_t)(a2 - 8 * *(void *)(*(void *)(a1 + 8) + 8)) >> 3, a3);
  if (v4)
  {
    if (a3)
    {
      uint64_t v8 = 0;
      do
      {
        *result++ = v5 >> v8;
        *v7++ = -1;
        v8 += 8;
      }
      while (8 * a3 != v8);
    }
  }
  else if (a3)
  {
    uint64_t v9 = 0;
    uint64_t v10 = a3 - 1;
    do
    {
      result[v10] = v5 >> v9;
      v7[v10--] = -1;
      v9 += 8;
    }
    while (v10 != -1);
  }
  return result;
}

unsigned char *llvm::wholeprogramdevirt::setAfterReturnValues(unsigned char *result, uint64_t a2, unint64_t a3, int a4, unint64_t *a5, unint64_t *a6)
{
  unint64_t v6 = a3 + 7;
  if (a4 == 1) {
    unint64_t v6 = a3;
  }
  *a5 = v6 >> 3;
  *a6 = a3 & 7;
  if (a2)
  {
    uint64_t v9 = (uint64_t)result;
    uint64_t v10 = 32 * a2;
    unsigned int v11 = ((a4 + 7) >> 3);
    do
    {
      if (a4 == 1) {
        uint64_t result = sub_1CD6870A4(**(void **)(v9 + 8), *(void *)(*(void *)(v9 + 8) + 8), *(void *)(v9 + 16), a3);
      }
      else {
        uint64_t result = sub_1CD687118(v9, a3, v11);
      }
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
  }
  return result;
}

unsigned char *sub_1CD6870A4(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  char v4 = a4;
  uint64_t result = (unsigned char *)sub_1CD68786C((unint64_t *)(a1 + 64), (a2 + (a4 >> 3) - *(void *)(a1 + 8)) & 0x1FFFFFFFFFFFFFFFLL, 1u);
  int v8 = 1 << (v4 & 7);
  if (a3) {
    *result |= v8;
  }
  *v7 |= v8;
  return result;
}

unsigned char *sub_1CD687118(uint64_t a1, unint64_t a2, unsigned int a3)
{
  int v4 = *(unsigned __int8 *)(a1 + 24);
  unint64_t v5 = *(void *)(a1 + 16);
  uint64_t result = (unsigned char *)sub_1CD68786C((unint64_t *)(**(void **)(a1 + 8) + 64), (*(void *)(*(void *)(a1 + 8) + 8) - *(void *)(**(void **)(a1 + 8) + 8) + (a2 >> 3)) & 0x1FFFFFFFFFFFFFFFLL, a3);
  if (v4)
  {
    if (a3)
    {
      uint64_t v8 = 0;
      uint64_t v9 = a3 - 1;
      do
      {
        result[v9] = v5 >> v8;
        v7[v9--] = -1;
        v8 += 8;
      }
      while (v9 != -1);
    }
  }
  else if (a3)
  {
    uint64_t v10 = 0;
    do
    {
      *result++ = v5 >> v10;
      *v7++ = -1;
      v10 += 8;
    }
    while (8 * a3 != v10);
  }
  return result;
}

void llvm::WholeProgramDevirtPass::run()
{
}

void sub_1CD687350(unsigned char *a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>, std::string *a4@<X8>)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  unsigned int v13 = v15;
  long long v14 = xmmword_1CD96DBF0;
  sub_1CC22C75C(&v13, a1, &a1[a2]);
  sub_1CC22C75C(&v13, ".llvm.", "");
  unint64_t v6 = a3[1] | ((unint64_t)*a3 << 32);
  if (v6)
  {
    int v7 = (char *)&v17;
    do
    {
      *--int v7 = (v6 % 0xA) | 0x30;
      BOOL v8 = v6 > 9;
      v6 /= 0xAuLL;
    }
    while (v8);
  }
  else
  {
    int v7 = &v16;
    char v16 = 48;
  }
  sub_1CC028D80(__p, v7, (char *)&v17, (char *)&v17 - v7);
  if (v12 >= 0) {
    uint64_t v9 = __p;
  }
  else {
    uint64_t v9 = (void **)__p[0];
  }
  uint64_t v10 = (unsigned char *)(v12 & 0x7F);
  if (v12 < 0) {
    uint64_t v10 = __p[1];
  }
  sub_1CC22C75C(&v13, v9, &v10[(void)v9]);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  std::string::__init(a4, (const std::string::value_type *)v13, v14);
  if (v13 != v15) {
    free(v13);
  }
}

void *sub_1CD6874A8(void *a1)
{
  *a1 = &unk_1F262B1D0;
  uint64_t v2 = a1 + 71;
  int v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1F262B238;
  int v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }

  return sub_1CB87DD48(a1);
}

void *sub_1CD687590(void *a1)
{
  *a1 = &unk_1F262B238;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD6875E4(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  int v12 = 0;
  uint64_t v8 = sub_1CD42FA04(a1 + 152, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD687678(v11);
}

uint64_t sub_1CD687678(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 160) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD687690(void *a1)
{
  sub_1CD6874A8(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD6876C8(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t sub_1CD6876D4(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

llvm::raw_ostream *sub_1CD6876E4(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    int v3 = *((_DWORD *)result + 32);
LABEL_3:
    int v4 = &unk_1F262B288;
    char v6 = 1;
    int v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 148))
  {
    int v3 = *((_DWORD *)result + 32);
    if (*((_DWORD *)result + 36) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD687768(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void *sub_1CD687780(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 152), a2);
}

void sub_1CD687788(void *a1)
{
  *a1 = &unk_1F262B238;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD6877FC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD687804(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1CD687818(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1CD68782C(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1CD687840(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

uint64_t sub_1CD68786C(unint64_t *a1, uint64_t a2, unsigned int a3)
{
  unint64_t v5 = a1[1] - *a1;
  unint64_t v6 = a2 + a3;
  if (v6 > v5)
  {
    sub_1CD674784(a1, v6 - v5);
    unint64_t v8 = a1[3];
    unint64_t v9 = a1[4] - v8;
    if (v6 > v9)
    {
      sub_1CD674784(a1 + 3, v6 - v9);
    }
    else if (v6 < v9)
    {
      a1[4] = v8 + v6;
    }
  }
  return *a1 + a2;
}

uint64_t *sub_1CD6878F0(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v4 + v5;
      uint64_t v7 = v2 + v5;
      *(void *)(v6 - 96) = 0;
      *(void *)(v6 - 88) = 0;
      *(void *)(v6 - 80) = 0;
      *(_OWORD *)(v6 - 96) = *(_OWORD *)(v2 + v5 - 96);
      *(void *)(v6 - 80) = *(void *)(v2 + v5 - 80);
      *(void *)(v7 - 88) = 0;
      *(void *)(v7 - 80) = 0;
      *(void *)(v7 - 96) = 0;
      long long v8 = *(_OWORD *)(v2 + v5 - 40);
      long long v9 = *(_OWORD *)(v2 + v5 - 24);
      uint64_t v10 = *(void *)(v2 + v5 - 8);
      *(_OWORD *)(v6 - 56) = *(_OWORD *)(v2 + v5 - 56);
      *(void *)(v6 - 8) = v10;
      *(_OWORD *)(v6 - 24) = v9;
      *(_OWORD *)(v6 - 40) = v8;
      *(_OWORD *)(v6 - 72) = *(_OWORD *)(v2 + v5 - 72);
      v5 -= 96;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  uint64_t v11 = *result;
  unsigned char *result = v4;
  a2[1] = v11;
  uint64_t v12 = result[1];
  result[1] = a2[2];
  a2[2] = v12;
  uint64_t v13 = result[2];
  result[2] = a2[3];
  a2[3] = v13;
  *a2 = a2[1];
  return result;
}

char *sub_1CD6879A4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 104);
  if (!v2) {
    operator new();
  }
  uint64_t v3 = *(uint64_t **)(v2 + 8);
  if ((unint64_t)v3 >= *(void *)(v2 + 16))
  {
    uint64_t result = sub_1CC9C7F0C((char **)v2, a2);
  }
  else
  {
    *uint64_t v3 = a2;
    uint64_t result = (char *)(v3 + 1);
  }
  *(void *)(v2 + 8) = result;
  return result;
}

unint64_t *sub_1CD687A5C(unint64_t *result, unint64_t a2)
{
  unint64_t v2 = result[2];
  unint64_t v3 = *result;
  if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v2 - *result) >> 4) < a2)
  {
    if (a2 >= 0x24924924924924ALL) {
      abort();
    }
    uint64_t v4 = (int64x2_t *)result;
    uint64_t v5 = result[1];
    uint64_t v15 = result + 2;
    uint64_t v6 = 112 * a2;
    uint64_t v7 = (char *)operator new(112 * a2);
    long long v8 = &v7[v6];
    long long v9 = &v7[v5 - v3];
    if (v5 == v3)
    {
      int64x2_t v10 = vdupq_n_s64(v3);
      uint64_t v11 = &v7[v5 - v3];
    }
    else
    {
      uint64_t v11 = &v7[v5 - v3];
      do
      {
        v5 -= 112;
        sub_1CD687B58((uint64_t)(v11 - 112), v5);
      }
      while (v5 != v3);
      int64x2_t v10 = *v4;
      unint64_t v2 = v4[1].u64[0];
    }
    v4->i64[0] = (uint64_t)v11;
    v4->i64[1] = (uint64_t)v9;
    int64x2_t v13 = v10;
    v4[1].i64[0] = (uint64_t)v8;
    unint64_t v14 = v2;
    uint64_t v12 = v10.i64[0];
    return (unint64_t *)sub_1CD687BE4((uint64_t)&v12);
  }
  return result;
}

__n128 sub_1CD687B58(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  __n128 result = *(__n128 *)(a2 + 88);
  *(__n128 *)(a1 + 88) = result;
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  return result;
}

uint64_t sub_1CD687BE4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 112;
    sub_1CD468254(i - 48);
    sub_1CD468254(i - 96);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t **sub_1CD687C48(uint64_t a1, unint64_t a2, unint64_t a3, _OWORD *a4)
{
  __n128 result = (uint64_t **)sub_1CD687CEC(a1, &v12, a2, a3);
  if (!*result)
  {
    uint64_t v7 = result;
    long long v8 = operator new(0x30uLL);
    void v8[2] = *a4;
    uint64_t v9 = v12;
    *(void *)long long v8 = 0;
    *((void *)v8 + 1) = 0;
    *((void *)v8 + 2) = v9;
    *uint64_t v7 = (uint64_t *)v8;
    uint64_t v10 = **(void **)a1;
    if (v10)
    {
      *(void *)a1 = v10;
      uint64_t v11 = *v7;
    }
    else
    {
      uint64_t v11 = (uint64_t *)v8;
    }
    __n128 result = (uint64_t **)sub_1CB8358B8(*(uint64_t **)(a1 + 8), v11);
    ++*(void *)(a1 + 16);
  }
  return result;
}

void *sub_1CD687CEC(uint64_t a1, void *a2, unint64_t a3, unint64_t a4)
{
  uint64_t v6 = *(void **)(a1 + 8);
  __n128 result = (void *)(a1 + 8);
  uint64_t v5 = v6;
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = v5;
        unint64_t v8 = v5[4];
        if (v8 <= a3) {
          break;
        }
LABEL_3:
        uint64_t v5 = (void *)*v7;
        __n128 result = v7;
        if (!*v7) {
          goto LABEL_13;
        }
      }
      if (v8 == a3)
      {
        unint64_t v10 = v7[5];
        BOOL v9 = v10 >= a4;
        if (v10 > a4) {
          goto LABEL_3;
        }
      }
      else
      {
        BOOL v9 = v8 >= a3;
      }
      if (!v9)
      {
        __n128 result = v7 + 1;
        uint64_t v5 = (void *)v7[1];
        if (v5) {
          continue;
        }
      }
      goto LABEL_13;
    }
  }
  uint64_t v7 = result;
LABEL_13:
  *a2 = v7;
  return result;
}

void *sub_1CD687D4C(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  uint64_t v5 = *(void **)(a1 + 8);
  __n128 result = (void *)(a1 + 8);
  uint64_t v4 = v5;
  if (v5)
  {
    uint64_t v6 = result;
    do
    {
      if (a2 == a3)
      {
LABEL_12:
        uint64_t v6 = v4;
      }
      else
      {
        uint64_t v7 = (unint64_t *)v4[4];
        unint64_t v8 = a2 + 1;
        while (v7 != (unint64_t *)v4[5])
        {
          unint64_t v9 = *v7;
          unint64_t v10 = *(v8 - 1);
          if (*v7 < v10) {
            break;
          }
          ++v7;
          if (v10 < v9 || v8++ == a3) {
            goto LABEL_12;
          }
        }
        ++v4;
      }
      uint64_t v4 = (void *)*v4;
    }
    while (v4);
    if (v6 != result)
    {
      uint64_t v13 = v6[4];
      uint64_t v12 = v6[5];
      if (v13 == v12)
      {
        return v6;
      }
      else
      {
        for (uint64_t i = v13 + 8; a2 != a3; i += 8)
        {
          unint64_t v15 = *a2;
          unint64_t v16 = *(void *)(i - 8);
          if (*a2 < v16) {
            break;
          }
          ++a2;
          if (v16 < v15 || i == v12) {
            return v6;
          }
        }
      }
    }
  }
  return result;
}

void *sub_1CD687DFC(uint64_t a1, uint64_t *a2)
{
  unint64_t v8 = 0;
  char v4 = sub_1CD41F538(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  uint64_t v5 = v8;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD687E74(a1, a2, v8);
    uint64_t v7 = *a2;
    v5[3] = 0;
    uint64_t v5[2] = 0;
    *uint64_t v5 = v7;
    v5[1] = v5 + 2;
  }
  return v5;
}

void *sub_1CD687E74(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD687F28(a1, v6);
  unint64_t v8 = 0;
  sub_1CD41F538(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD687F28(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  __n128 result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD687FF4(a1, v4, &v4[4 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      void *result = -4096;
      result += 4;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

void sub_1CD687FF4(uint64_t a1, void *a2, void *a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v5 = *(unsigned int *)(a1 + 16);
  if (v5)
  {
    unint64_t v6 = *(void **)a1;
    uint64_t v7 = 32 * v5;
    do
    {
      *unint64_t v6 = -4096;
      v6 += 4;
      v7 -= 32;
    }
    while (v7);
  }
  if (a2 != a3)
  {
    unsigned int v8 = a2 + 2;
    do
    {
      uint64_t v9 = *(v8 - 2);
      if ((v9 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unint64_t v16 = 0;
        sub_1CD41F538(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v16);
        uint64_t v11 = v16;
        *unint64_t v16 = *(v8 - 2);
        v11[1] = *(v8 - 1);
        uint64_t v12 = (void *)*v8;
        v11[2] = *v8;
        uint64_t v13 = v11 + 2;
        uint64_t v14 = v8[1];
        void v11[3] = v14;
        if (v14)
        {
          unint64_t v15 = 0;
          uint64_t v12[2] = v13;
          *(v8 - 1) = v8;
          void *v8 = 0;
          v8[1] = 0;
        }
        else
        {
          v11[1] = v13;
          unint64_t v15 = (void *)*v8;
        }
        ++*(_DWORD *)(a1 + 8);
        sub_1CD40B1BC(v15);
      }
      uint64_t v10 = v8 + 2;
      v8 += 4;
    }
    while (v10 != a3);
  }
}

_OWORD *sub_1CD6880EC(uint64_t a1, uint64_t a2, _OWORD **a3)
{
  uint64_t v5 = (void **)sub_1CD4AF8D4(a1, &v14, a2);
  unint64_t v6 = *v5;
  if (!*v5)
  {
    unsigned int v8 = v5;
    unint64_t v6 = operator new(0x40uLL);
    uint64_t v9 = *a3;
    uint64_t v10 = *((void *)*a3 + 2);
    void v6[2] = **a3;
    *((void *)v6 + 6) = v10;
    *uint64_t v9 = 0;
    v9[1] = 0;
    uint64_t v9[2] = 0;
    *((void *)v6 + 7) = 0;
    uint64_t v11 = v14;
    *(void *)unint64_t v6 = 0;
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = v11;
    void *v8 = v6;
    uint64_t v12 = **(void **)a1;
    uint64_t v13 = (uint64_t *)v6;
    if (v12)
    {
      *(void *)a1 = v12;
      uint64_t v13 = (uint64_t *)*v8;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v13);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

uint64_t *sub_1CD6881A8(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v4 = 32 * v2;
    uint64_t v5 = (void **)(v3 + 16);
    do
    {
      if (((unint64_t)*(v5 - 2) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        sub_1CD40B1BC(*v5);
      }
      v5 += 4;
      v4 -= 32;
    }
    while (v4);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

void sub_1CD688220(long long *a1, uint64_t *a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE52E0, 0, 0);
  dword_1EBCE5360 = 0;
  qword_1EBCE5368 = (uint64_t)&unk_1F2629508;
  unk_1EBCE5370 = 0;
  qword_1EBCE52E0 = (uint64_t)&unk_1F2629450;
  qword_1EBCE5378 = (uint64_t)&unk_1F26294B8;
  unk_1EBCE5380 = &qword_1EBCE52E0;
  qword_1EBCE5388 = (uint64_t)&unk_1EBCE5398;
  qword_1EBCE5390 = 0x800000000;
  qword_1EBCE5518 = (uint64_t)&unk_1F2629670;
  qword_1EBCE5530 = (uint64_t)&qword_1EBCE5518;
  sub_1CD688324(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE52E0);
}

void sub_1CD688324(long long *a1, uint64_t *a2, _WORD *a3)
{
  xmmword_1EBCE5300 = *a1;
  sub_1CC95C734(a2, (uint64_t)&qword_1EBCE52E0);
  word_1EBCE52EA = (32 * (*a3 & 3)) | word_1EBCE52EA & 0xFF9F;
}

void sub_1CD68839C(long long *a1, _WORD *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCE5110, 0, 0);
  qword_1EBCE5190 = 0;
  qword_1EBCE5198 = 0;
  qword_1EBCE51B8 = 0;
  unk_1EBCE51C0 = 0;
  byte_1EBCE51C8 = 0;
  qword_1EBCE51B0 = 0;
  unk_1EBCE51A0 = 0;
  unk_1EBCE51A8 = &unk_1F2643C20;
  qword_1EBCE5110 = (uint64_t)&unk_1F2643FD0;
  qword_1EBCE51D0 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCE51D8 = (uint64_t)&unk_1F25F6428;
  qword_1EBCE51F0 = (uint64_t)&qword_1EBCE51D8;
  llvm::cl::Option::setArgStr(v4, "wholeprogramdevirt-read-summary", 0x1FuLL);
  xmmword_1EBCE5130 = *a1;
  word_1EBCE511A = (32 * (*a2 & 3)) | word_1EBCE511A & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE5110);
}

uint64_t sub_1CD6884B4(uint64_t a1, char *a2, _OWORD *a3, _WORD *a4)
{
  uint64_t v8 = sub_1CB883A14(a1, 0, 0);
  *(void *)(v8 + 128) = 0;
  *(void *)(v8 + 136) = 0;
  *(void *)(v8 + 168) = 0;
  *(void *)(v8 + 176) = 0;
  *(unsigned char *)(v8 + 184) = 0;
  *(void *)(v8 + 160) = 0;
  *(void *)(v8 + 144) = 0;
  *(void *)(v8 + 152) = &unk_1F2643C20;
  *(void *)uint64_t v8 = &unk_1F2643FD0;
  *(void *)(v8 + 192) = &unk_1F2643EA0;
  *(void *)(v8 + 200) = &unk_1F25F6428;
  *(void *)(v8 + 224) = v8 + 200;
  size_t v9 = strlen(a2);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)a2, v9);
  *(_OWORD *)(a1 + 32) = *a3;
  *(_WORD *)(a1 + 10) = (32 * (*a4 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void sub_1CD6885C8(_WORD *a1, int **a2, _WORD *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE4EB8, 0, 0);
  dword_1EBCE4F38 = 0;
  qword_1EBCE4F40 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCE4F48 = 0;
  qword_1EBCE4EB8 = (uint64_t)&unk_1F2643F00;
  qword_1EBCE4F50 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCE4F58 = (uint64_t)&unk_1F25EA168;
  qword_1EBCE4F70 = (uint64_t)&qword_1EBCE4F58;
  sub_1CD6886C8(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE4EB8);
}

__n128 sub_1CD6886C8(_WORD *a1, int **a2, _WORD *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE4EB8, "wholeprogramdevirt-branch-funnel-threshold", 0x2AuLL);
  word_1EBCE4EC2 = word_1EBCE4EC2 & 0xFF9F | (32 * (*a1 & 3));
  dword_1EBCE4F38 = **a2;
  byte_1EBCE4F4C = 1;
  dword_1EBCE4F48 = dword_1EBCE4F38;
  word_1EBCE4EC2 = word_1EBCE4EC2 & 0xFFF8 | *a3 & 7;
  __n128 result = *a4;
  xmmword_1EBCE4ED8 = (__int128)*a4;
  return result;
}

void sub_1CD68875C(_WORD *a1, char **a2, _WORD *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE4F78, 0, 0);
  byte_1EBCE4FF8 = 0;
  qword_1EBCE5000 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCE5008 = 0;
  qword_1EBCE4F78 = (uint64_t)&unk_1F26440A0;
  qword_1EBCE5010 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCE5018 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCE5030 = (uint64_t)&qword_1EBCE5018;
  sub_1CD68885C(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE4F78);
}

__n128 sub_1CD68885C(_WORD *a1, char **a2, _WORD *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE4F78, "wholeprogramdevirt-print-index-based", 0x24uLL);
  word_1EBCE4F82 = word_1EBCE4F82 & 0xFF9F | (32 * (*a1 & 3));
  uint64_t v8 = *a2;
  byte_1EBCE4FF8 = **a2;
  byte_1EBCE5009 = 1;
  byte_1EBCE5008 = *v8;
  word_1EBCE4F82 = word_1EBCE4F82 & 0xFFF8 | *a3 & 7;
  __n128 result = *a4;
  xmmword_1EBCE4F98 = (__int128)*a4;
  return result;
}

void sub_1CD6888F4(__n128 *a1, _WORD *a2, _WORD *a3, _WORD *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE5038, 1, 0);
  qword_1EBCE50B8 = 0;
  unk_1EBCE50C0 = 0;
  qword_1EBCE50C8 = 0;
  unk_1EBCE50D0 = 0;
  qword_1EBCE5038 = (uint64_t)&unk_1F260A070;
  qword_1EBCE50D8 = 0;
  unk_1EBCE50E0 = 0;
  qword_1EBCE50E8 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCE50F0 = (uint64_t)&unk_1F260AC78;
  qword_1EBCE5108 = (uint64_t)&qword_1EBCE50F0;
  sub_1CD6889DC(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE5038);
}

__n128 sub_1CD6889DC(__n128 *a1, _WORD *a2, _WORD *a3, _WORD *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE5038, "wholeprogramdevirt-skip", 0x17uLL);
  __n128 result = *a1;
  xmmword_1EBCE5058 = (__int128)*a1;
  word_1EBCE5042 = word_1EBCE5042 & 0xFF9F | (32 * (*a2 & 3));
  word_1EBCE5042 = word_1EBCE5042 & 0xFFF8 | *a3 & 7;
  word_1EBCE5042 |= (*a4 & 0x1F) << 9;
  return result;
}

void sub_1CD688A68(_WORD *a1, _WORD *a2, long long *a3, uint64_t a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE5538, 0, 0);
  dword_1EBCE55B8 = 0;
  qword_1EBCE55C0 = (uint64_t)&unk_1F262B288;
  unk_1EBCE55C8 = 0;
  qword_1EBCE5538 = (uint64_t)&unk_1F262B1D0;
  qword_1EBCE55D0 = (uint64_t)&unk_1F262B238;
  qword_1EBCE55D8 = (uint64_t)&qword_1EBCE5538;
  qword_1EBCE55E0 = (uint64_t)&unk_1EBCE55F0;
  qword_1EBCE55E8 = 0x800000000;
  qword_1EBCE5770 = (uint64_t)&unk_1F262B3A8;
  qword_1EBCE5788 = (uint64_t)&qword_1EBCE5770;
  sub_1CD688B7C(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE5538);
}

void sub_1CD688B7C(_WORD *a1, _WORD *a2, long long *a3, uint64_t a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE5538, "wholeprogramdevirt-check", 0x18uLL);
  word_1EBCE5542 = word_1EBCE5542 & 0xFF9F | (32 * (*a1 & 3));
  word_1EBCE5542 = word_1EBCE5542 & 0xFFF8 | *a2 & 7;
  xmmword_1EBCE5558 = *a3;
  uint64_t v8 = *(void *)a4;
  unsigned int v9 = *(_DWORD *)(a4 + 8);

  sub_1CD688C8C(v8, v9);
}

void sub_1CD688C14()
{
}

void *sub_1CD688C28()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1F262B3A8;
  return result;
}

void sub_1CD688C60(uint64_t a1, void *a2)
{
  *a2 = &unk_1F262B3A8;
}

void sub_1CD688C8C(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = a1;
    uint64_t v3 = a1 + 40 * a2;
    do
    {
      sub_1CD688CD8(*(unsigned __int8 **)v2, *(void *)(v2 + 8), *(_DWORD *)(v2 + 16), *(void *)(v2 + 24), *(void *)(v2 + 32));
      v2 += 40;
    }
    while (v2 != v3);
  }
}

void sub_1CD688CD8(unsigned __int8 *a1, size_t a2, int a3, uint64_t a4, uint64_t a5)
{
  v11[0] = a1;
  v11[1] = a2;
  v11[2] = a4;
  void v11[3] = a5;
  _DWORD v11[4] = &unk_1F262B288;
  char v13 = 1;
  int v12 = a3;
  unint64_t v7 = sub_1CD688DCC((unint64_t)v11);
  uint64_t v8 = qword_1EBCE55E0 + 48 * qword_1EBCE55E8;
  long long v9 = *(_OWORD *)(v7 + 16);
  *(_OWORD *)uint64_t v8 = *(_OWORD *)v7;
  *(_OWORD *)(v8 + 16) = v9;
  *(void *)(v8 + 32) = &unk_1F262B2A8;
  char v10 = *(unsigned char *)(v7 + 44);
  *(_DWORD *)(v8 + 40) = *(_DWORD *)(v7 + 40);
  *(unsigned char *)(v8 + 44) = v10;
  *(void *)(v8 + 32) = &unk_1F262B288;
  LODWORD(qword_1EBCE55E8) = qword_1EBCE55E8 + 1;
  llvm::cl::AddLiteralOption(qword_1EBCE55D8, a1, a2);
}

unint64_t sub_1CD688DCC(unint64_t result)
{
  if (qword_1EBCE55E8 >= HIDWORD(qword_1EBCE55E8))
  {
    if (qword_1EBCE55E0 > result || qword_1EBCE55E0 + 48 * (unint64_t)qword_1EBCE55E8 <= result) {
      sub_1CD688E48();
    }
    sub_1CD688E48();
  }
  return result;
}

void sub_1CD688E48()
{
}

void llvm::getLazyIRFileModule(const std::string::value_type *a1@<X0>, std::string::size_type a2@<X1>, uint64_t a3@<X2>, char **a4@<X8>)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  LOWORD(v22.__r_.__value_.__r.__words[2]) = 261;
  uint64_t v20 = a1;
  std::string::size_type v21 = a2;
  llvm::MemoryBuffer::getFileOrSTDIN((llvm::MemoryBuffer *)&v20, 0, 1, (uint64_t)&v32);
  if ((v33 & 1) == 0)
  {
    std::system_category();
    uint64_t v8 = *(const llvm::MemoryBuffer **)&v32.__val_;
    goto LABEL_3;
  }
  uint64_t v8 = *(const llvm::MemoryBuffer **)&v32.__val_;
  std::error_code v19 = v32;
  if (!v32.__val_)
  {
LABEL_3:
    *(void *)&v32.__val_ = 0;
    unint64_t v15 = v8;
    llvm::getLazyIRModule(&v15, a3, a4);
    long long v9 = v15;
    unint64_t v15 = 0;
    if (v9) {
      (*(void (**)(const llvm::MemoryBuffer *))(*(void *)v9 + 8))(v9);
    }
    goto LABEL_5;
  }
  std::error_code::message(&v16, &v19);
  uint64_t v11 = std::string::insert(&v16, 0, "Could not open input file: ");
  std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  uint64_t v18 = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (v18 >= 0) {
    char v13 = __p;
  }
  else {
    char v13 = (void **)__p[0];
  }
  if (v18 >= 0) {
    std::string::size_type v14 = HIBYTE(v18) & 0x7F;
  }
  else {
    std::string::size_type v14 = (std::string::size_type)__p[1];
  }
  uint64_t v20 = 0;
  std::string::size_type v21 = 0;
  std::string::__init(&v22, a1, a2);
  uint64_t v23 = -1;
  int v24 = 0;
  std::string::__init(&v25, (const std::string::value_type *)v13, v14);
  long long v27 = 0u;
  long long v28 = 0u;
  long long v26 = 0u;
  std::string v29 = &v31;
  uint64_t v30 = 0x400000000;
  sub_1CD4D7434(a3, (uint64_t)&v20);
  sub_1CC192528((uint64_t)&v20);
  if (SHIBYTE(v18) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v16.__r_.__value_.__l.__data_);
  }
  *a4 = 0;
LABEL_5:
  if ((v33 & 1) == 0)
  {
    uint64_t v10 = *(void *)&v32.__val_;
    *(void *)&v32.__val_ = 0;
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
  }
}

void llvm::parseIRFile(const std::string::value_type *a1@<X0>, std::string::size_type a2@<X1>, uint64_t a3@<X2>, char **a4@<X8>)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  LOWORD(v26.__r_.__value_.__r.__words[2]) = 261;
  int v24 = a1;
  std::string::size_type v25 = a2;
  llvm::MemoryBuffer::getFileOrSTDIN((llvm::MemoryBuffer *)&v24, (const llvm::Twine *)1, 1, (uint64_t)&v36);
  if ((v37 & 1) == 0)
  {
    std::system_category();
    uint64_t v8 = *(void **)&v36.__val_;
LABEL_3:
    long long v9 = (unsigned __int8 *)v8[1];
    uint64_t v10 = (unsigned __int8 *)(v8[2] - (void)v9);
    uint64_t v11 = (unsigned __int8 *)(*(uint64_t (**)(void *))(*v8 + 16))(v8);
    v19[0] = v9;
    v19[1] = v10;
    v19[2] = v11;
    void v19[3] = v12;
    llvm::parseIR(v19, a3, v13, a4);
    goto LABEL_4;
  }
  uint64_t v8 = *(void **)&v36.__val_;
  std::error_code v23 = v36;
  if (!v36.__val_) {
    goto LABEL_3;
  }
  std::error_code::message(&v20, &v23);
  unint64_t v15 = std::string::insert(&v20, 0, "Could not open input file: ");
  std::string::size_type v16 = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  uint64_t v22 = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  if (v22 >= 0) {
    uint64_t v17 = __p;
  }
  else {
    uint64_t v17 = (void **)__p[0];
  }
  if (v22 >= 0) {
    std::string::size_type v18 = HIBYTE(v22) & 0x7F;
  }
  else {
    std::string::size_type v18 = (std::string::size_type)__p[1];
  }
  int v24 = 0;
  std::string::size_type v25 = 0;
  std::string::__init(&v26, a1, a2);
  uint64_t v27 = -1;
  int v28 = 0;
  std::string::__init(&v29, (const std::string::value_type *)v17, v18);
  long long v31 = 0u;
  long long v32 = 0u;
  long long v30 = 0u;
  char v33 = &v35;
  uint64_t v34 = 0x400000000;
  sub_1CD4D7434(a3, (uint64_t)&v24);
  sub_1CC192528((uint64_t)&v24);
  if (SHIBYTE(v22) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v20.__r_.__value_.__l.__data_);
  }
  *a4 = 0;
LABEL_4:
  if ((v37 & 1) == 0)
  {
    uint64_t v14 = *(void *)&v36.__val_;
    *(void *)&v36.__val_ = 0;
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    }
  }
}

void llvm::initializeAGXInstCombinePass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCE5798, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC9D0458;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCE5798, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createAGXInstCombinePass(llvm *this)
{
}

llvm::Value *sub_1CD689458(uint64_t a1, llvm::GEPOperator *this)
{
  return sub_1CD4A7084(*(void *)(a1 + 24), *(void *)(a1 + 80), this, 0);
}

llvm::Value *sub_1CD689470(llvm::ConstantExpr *a1, llvm::Constant *a2, llvm::Type *a3)
{
  int v3 = (int)a3;
  int v5 = (int)a1;
  v20[16] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)a2;
  unint64_t v7 = *(llvm::ConstantFP **)(*(void *)a2 + 24);
  BinOpIdentity = llvm::ConstantExpr::getBinOpIdentity(a1, v7, a3, 0);
  if (!BinOpIdentity)
  {
    if (v3)
    {
      if ((v5 & 0xFFFFFFFE) == 0x16) {
        NullValue = (const llvm::detail::DoubleAPFloat *)llvm::ConstantInt::get(v7, 1uLL, 0);
      }
      else {
        NullValue = llvm::ConstantFP::get((llvm::ConstantFP **)v7, v8, 1.0);
      }
    }
    else
    {
      NullValue = llvm::Constant::getNullValue(v7, v8, v9);
    }
    BinOpIdentity = NullValue;
  }
  unint64_t v11 = *(unsigned int *)(v6 + 32);
  std::string::size_type v18 = v20;
  uint64_t v19 = 0x1000000000;
  sub_1CBFC6B20((uint64_t)&v18, v11, 0);
  if (v11)
  {
    for (uint64_t i = 0; i != (llvm::Type *)v11; uint64_t i = (llvm::Type *)((char *)i + 1))
    {
      AggregateElement = (const llvm::detail::DoubleAPFloat *)llvm::Constant::getAggregateElement(a2, i);
      if (*((unsigned __int8 *)AggregateElement + 16) - 11 >= 2) {
        uint64_t v14 = AggregateElement;
      }
      else {
        uint64_t v14 = BinOpIdentity;
      }
      *((void *)v18 + i) = v14;
    }
  }
  unint64_t v15 = llvm::ConstantVector::get((llvm::FixedVectorType ***)v18, (llvm::Type *)v19);
  if (v18 != v20) {
    free(v18);
  }
  return v15;
}

llvm::StoreInst *sub_1CD6895C8(uint64_t a1, llvm::Instruction *a2)
{
  int v3 = **(llvm::ConstantInt ***)a2;
  uint64_t v4 = operator new(0x80uLL);
  v4[21] = v4[21] & 0x38000000 | 2;
  int v5 = (llvm::StoreInst *)(v4 + 16);
  *(void *)uint64_t v4 = 0;
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = v4 + 16;
  *((void *)v4 + 4) = 0;
  *((void *)v4 + 5) = 0;
  *((void *)v4 + 6) = 0;
  *((void *)v4 + 7) = v4 + 16;
  True = (llvm::Type **)llvm::ConstantInt::getTrue(v3, v6, v7);
  Int1PtrTy = (llvm::UndefValue *)llvm::Type::getInt1PtrTy(v3, 0);
  unint64_t v11 = llvm::UndefValue::get(Int1PtrTy, v10);

  return llvm::StoreInst::StoreInst(v5, True, v11, 0, a2);
}

llvm::AnalysisUsage *llvm::InstructionCombiningPass::getAnalysisUsage(llvm::InstructionCombiningPass *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::setPreservesCFG(a2);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::AAResultsWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::AssumptionCacheTracker::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::TargetLibraryInfoWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::TargetTransformInfoWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::DominatorTreeWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::OptimizationRemarkEmitterWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)llvm::AAResultsWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)llvm::BasicAAWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::ProfileSummaryInfoWrapperPass::ID);

  return llvm::LazyBlockFrequencyInfoPass::getLazyBFIAnalysisUsage(a2, v3);
}

llvm::InstructionCombiningPass *llvm::InstructionCombiningPass::InstructionCombiningPass(llvm::InstructionCombiningPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::InstructionCombiningPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F262B4D8;
  *((void *)this + 4) = (char *)this + 48;
  *((void *)this + 5) = 0x10000000000;
  *((_OWORD *)this + 131) = 0u;
  *((_DWORD *)this + 528) = 0;
  *((void *)this + 265) = 1;
  uint64_t v2 = 2128;
  int64x2_t v3 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  do
  {
    *(int64x2_t *)((char *)this + v2) = v3;
    v2 += 16;
  }
  while (v2 != 2256);
  *((void *)this + 282) = (char *)this + 2272;
  *((void *)this + 283) = 0x1000000000;
  *((_DWORD *)this + 600) = 1000;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCE57A0, memory_order_acquire) != -1)
  {
    v7[0] = sub_1CC9E6CE4;
    v7[1] = &PassRegistry;
    uint64_t v6 = v7;
    std::__call_once(&qword_1EBCE57A0, &v6, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void sub_1CD6898C4(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F262B4D8;
  sub_1CC9E8C24((uint64_t)a1 + 32);

  llvm::Pass::~Pass(a1);
}

void sub_1CD689918(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F262B4D8;
  sub_1CC9E8C24((uint64_t)a1 + 32);
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD689980(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char **a5, llvm::BasicBlock *a6)
{
  std::string::size_type v12 = operator new(0xB0uLL);
  uint64_t v13 = 0;
  uint64_t v14 = (llvm::Instruction *)(v12 + 24);
  v12[29] = v12[29] & 0x38000000 | 3;
  do
  {
    unint64_t v15 = &v12[v13];
    void *v15 = 0;
    v15[1] = 0;
    v15[2] = 0;
    v15[3] = v14;
    v13 += 8;
  }
  while (v13 != 24);
  std::string::size_type v16 = llvm::Instruction::Instruction(v14, **(llvm::Type ***)(a1 + 16), 5, (llvm::Use *)v12, 3, a6);
  *((void *)v12 + 20) = 0;
  llvm::InvokeInst::init((uint64_t)v16, a1, a2, a3, a4, 0, 0, v17, 0, 0, a5);
}

uint64_t sub_1CD689A54(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a2 && *(unsigned char *)(a2 + 16) == 81)
  {
    uint64_t v5 = *(void *)(a2 - 64);
    if ((*(void *)(a1 + 8) == v5 || *(void *)(a1 + 16) == v5)
      && (uint64_t v6 = *(unsigned __int8 **)(a2 - 32)) != 0
      && v6[16] <= 0x14u
      && ((llvm::Constant::isNullValue(*(llvm::Constant **)(a2 - 32)) & 1) != 0
       || (sub_1CC03F414((uint64_t)&v7, (llvm::Constant *)v6) & 1) != 0))
    {
      **(_DWORD **)a1 = *(_WORD *)(a2 + 18) & 0x3F;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void llvm::callDefaultCtor<llvm::InstructionCombiningPass>()
{
}

void sub_1CD689B40(int **a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)qword_1EBCE5878, 0, 0);
  dword_1EBCE58F8 = 0;
  qword_1EBCE5900 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCE5908 = 0;
  qword_1EBCE5878[0] = (uint64_t)&unk_1F2643F00;
  qword_1EBCE5910 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCE5918 = (uint64_t)&unk_1F25EA168;
  qword_1EBCE5930 = (uint64_t)&qword_1EBCE5918;
  llvm::cl::Option::setArgStr(v4, "instcombine-max-sink-users", 0x1AuLL);
  dword_1EBCE58F8 = **a1;
  byte_1EBCE590C = 1;
  dword_1EBCE5908 = dword_1EBCE58F8;
  xmmword_1EBCE5898 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EBCE5878);
}

void sub_1CD689C4C(long long *a1, int **a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)qword_1EBD090F0, 0, 0);
  dword_1EBD09170 = 0;
  qword_1EBD09178 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBD09180 = 0;
  qword_1EBD090F0[0] = (uint64_t)&unk_1F2643F00;
  qword_1EBD09188 = (uint64_t)&unk_1F2643DB0;
  qword_1EBD09190 = (uint64_t)&unk_1F25EA168;
  qword_1EBD091A8 = (uint64_t)&qword_1EBD09190;
  llvm::cl::Option::setArgStr(v4, "instcombine-max-iterations", 0x1AuLL);
  xmmword_1EBD09110 = *a1;
  uint64_t v5 = *a2;
  dword_1EBD09170 = **a2;
  byte_1EBD09184 = 1;
  dword_1EBD09180 = *v5;

  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EBD090F0);
}

void sub_1CD689D5C(__n128 *a1, int **a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE5938, 0, 0);
  dword_1EBCE59B8 = 0;
  qword_1EBCE59C0 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCE59C8 = 0;
  qword_1EBCE5938 = (uint64_t)&unk_1F2643F00;
  qword_1EBCE59D0 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCE59D8 = (uint64_t)&unk_1F25EA168;
  qword_1EBCE59F0 = (uint64_t)&qword_1EBCE59D8;
  sub_1CD689E4C(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE5938);
}

__n128 sub_1CD689E4C(__n128 *a1, int **a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE5938, "instcombine-infinite-loop-threshold", 0x23uLL);
  __n128 result = *a1;
  xmmword_1EBCE5958 = (__int128)*a1;
  char v7 = *a2;
  dword_1EBCE59B8 = **a2;
  byte_1EBCE59CC = 1;
  dword_1EBCE59C8 = *v7;
  word_1EBCE5942 = (32 * (*a3 & 3)) | word_1EBCE5942 & 0xFF9F;
  return result;
}

void sub_1CD689ED4(int **a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)qword_1EBCE59F8, 0, 0);
  dword_1EBCE5A78 = 0;
  qword_1EBCE5A80 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCE5A88 = 0;
  qword_1EBCE59F8[0] = (uint64_t)&unk_1F2643F00;
  qword_1EBCE5A90 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCE5A98 = (uint64_t)&unk_1F25EA168;
  qword_1EBCE5AB0 = (uint64_t)&qword_1EBCE5A98;
  llvm::cl::Option::setArgStr(v4, "instcombine-maxarray-size", 0x19uLL);
  dword_1EBCE5A78 = **a1;
  byte_1EBCE5A8C = 1;
  dword_1EBCE5A88 = dword_1EBCE5A78;
  xmmword_1EBCE5A18 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EBCE59F8);
}

void sub_1CD689FE0(_WORD *a1, unsigned __int8 **a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCE5AB8, 0, 0);
  dword_1EBCE5B38 = 0;
  qword_1EBCE5B40 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCE5B48 = 0;
  qword_1EBCE5AB8 = (uint64_t)&unk_1F2643F00;
  qword_1EBCE5B50 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCE5B58 = (uint64_t)&unk_1F25EA168;
  qword_1EBCE5B70 = (uint64_t)&qword_1EBCE5B58;
  llvm::cl::Option::setArgStr(v4, "instcombine-lower-dbg-declare", 0x1DuLL);
  word_1EBCE5AC2 = (32 * (*a1 & 3)) | word_1EBCE5AC2 & 0xFF9F;
  dword_1EBCE5B38 = **a2;
  byte_1EBCE5B4C = 1;
  dword_1EBCE5B48 = dword_1EBCE5B38;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE5AB8);
}

uint64_t sub_1CD68A0FC(uint64_t result, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t), unint64_t a4, uint64_t *a5, uint64_t a6)
{
  if (a4 >= 2)
  {
    uint64_t v8 = (uint64_t *)result;
    if (a4 == 2)
    {
      __n128 result = (*a3)(*(a2 - 1), *(void *)result);
      if (result)
      {
        uint64_t v9 = *v8;
        uint64_t *v8 = *(a2 - 1);
        *(a2 - 1) = v9;
      }
    }
    else if ((uint64_t)a4 > 128)
    {
      std::string v20 = (char *)a5;
      unint64_t v21 = a4 >> 1;
      uint64_t v22 = (uint64_t *)(result + 8 * (a4 >> 1));
      unint64_t v23 = a4 >> 1;
      if ((uint64_t)a4 <= a6)
      {
        sub_1CD68A35C((uint64_t *)result, v22, a3, v23, a5);
        int v24 = (uint64_t *)&v20[8 * v21];
        __n128 result = (uint64_t)sub_1CD68A35C(&v8[a4 >> 1], a2, a3, a4 - (a4 >> 1), v24);
        std::string::size_type v25 = &v20[8 * a4];
        std::string v26 = v24;
        while (v26 != (uint64_t *)v25)
        {
          __n128 result = (*a3)(*v26, *(void *)v20);
          if (result) {
            uint64_t v27 = (char *)v26;
          }
          else {
            uint64_t v27 = v20;
          }
          v20 += 8 * (result ^ 1);
          v26 += result;
          *v8++ = *(void *)v27;
          if (v20 == (char *)v24)
          {
            if (v26 != (uint64_t *)v25)
            {
              uint64_t v28 = 0;
              do
              {
                v8[v28] = v26[v28];
                ++v28;
              }
              while (&v26[v28] != (uint64_t *)v25);
            }
            return result;
          }
        }
        if (v20 != (char *)v24)
        {
          uint64_t v29 = 0;
          do
          {
            v8[v29] = *(void *)&v20[v29 * 8];
            ++v29;
          }
          while (&v20[v29 * 8] != (char *)v24);
        }
      }
      else
      {
        sub_1CD68A0FC(result, v22, a3, v23, a5, a6);
        sub_1CD68A0FC(&v8[a4 >> 1], a2, a3, a4 - (a4 >> 1), v20, a6);
        return sub_1CC9E91A8((uint64_t)v8, &v8[a4 >> 1], a2, (unsigned int (**)(void, void))a3, a4 >> 1, a4 - (a4 >> 1), v20, a6);
      }
    }
    else if ((uint64_t *)result != a2)
    {
      unint64_t v11 = (uint64_t *)(result + 8);
      if ((uint64_t *)(result + 8) != a2)
      {
        uint64_t v12 = 0;
        uint64_t v13 = (uint64_t *)result;
        do
        {
          uint64_t v15 = *v13;
          uint64_t v14 = v13[1];
          uint64_t v13 = v11;
          __n128 result = (*a3)(v14, v15);
          if (result)
          {
            uint64_t v16 = *v13;
            uint64_t v17 = v12;
            while (1)
            {
              *(uint64_t *)((char *)v8 + v17 + 8) = *(uint64_t *)((char *)v8 + v17);
              if (!v17) {
                break;
              }
              __n128 result = (*a3)(v16, *(uint64_t *)((char *)v8 + v17 - 8));
              v17 -= 8;
              if ((result & 1) == 0)
              {
                std::string::size_type v18 = (uint64_t *)((char *)v8 + v17 + 8);
                goto LABEL_16;
              }
            }
            std::string::size_type v18 = v8;
LABEL_16:
            *std::string::size_type v18 = v16;
          }
          unint64_t v11 = v13 + 1;
          v12 += 8;
        }
        while (v13 + 1 != a2);
      }
    }
  }
  return result;
}

uint64_t *sub_1CD68A35C(uint64_t *result, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t), unint64_t a4, uint64_t *a5)
{
  if (a4)
  {
    uint64_t v5 = a5;
    uint64_t v9 = result;
    if (a4 == 2)
    {
      __n128 result = (uint64_t *)(*a3)(*(a2 - 1), *result);
      if (result)
      {
        *uint64_t v5 = *(a2 - 1);
        uint64_t v10 = *v9;
      }
      else
      {
        *uint64_t v5 = *v9;
        uint64_t v10 = *(a2 - 1);
      }
      v5[1] = v10;
    }
    else if (a4 == 1)
    {
      *a5 = *result;
    }
    else if ((uint64_t)a4 > 8)
    {
      unint64_t v11 = &result[a4 >> 1];
      sub_1CD68A0FC(result, v11, a3, a4 >> 1, a5, a4 >> 1);
      __n128 result = (uint64_t *)sub_1CD68A0FC(&v9[a4 >> 1], a2, a3, a4 - (a4 >> 1), &v5[a4 >> 1], a4 - (a4 >> 1));
      uint64_t v12 = &v9[a4 >> 1];
      while (v12 != a2)
      {
        __n128 result = (uint64_t *)(*a3)(*v12, *v9);
        if (result) {
          uint64_t v13 = v12;
        }
        else {
          uint64_t v13 = v9;
        }
        v12 += result;
        v9 += result ^ 1;
        *v5++ = *v13;
        if (v9 == v11)
        {
          if (v12 != a2)
          {
            uint64_t v14 = 0;
            do
            {
              v5[v14] = v12[v14];
              ++v14;
            }
            while (&v12[v14] != a2);
          }
          return result;
        }
      }
      if (v9 != v11)
      {
        uint64_t v15 = 0;
        do
        {
          v5[v15] = v9[v15];
          ++v15;
        }
        while (&v9[v15] != v11);
      }
    }
    else
    {
      return sub_1CC9E96B4(result, a2, a5, a3);
    }
  }
  return result;
}

BOOL sub_1CD68A508(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 16) == 85
    && ((int v2 = *(_DWORD *)(a2 + 20), (v2 & 0x40000000) != 0)
      ? (int64x2_t v3 = *(void **)(a2 - 8))
      : (int64x2_t v3 = (void *)(a2 - 32 * (v2 & 0x7FFFFFF))),
        *v3 == a1))
  {
    return *(unsigned __int8 *)(v3[4] + 16) < 0x15u;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1CD68A554(void *a1, uint64_t a2)
{
  unsigned int v3 = *(unsigned __int8 *)(a2 + 16);
  unsigned int v4 = v3 - 28;
  BOOL v6 = v3 < 0x1C && v3 != 5 || a2 == 0;
  int v7 = v6;
  if (!v6)
  {
    if (v3 <= 0x1B) {
      unsigned int v4 = *(unsigned __int16 *)(a2 + 18);
    }
    if (v4 == 39)
    {
      int v9 = *(_DWORD *)(a2 + 20);
      if ((v9 & 0x40000000) != 0) {
        uint64_t v10 = *(void **)(a2 - 8);
      }
      else {
        uint64_t v10 = (void *)(a2 - 32 * (v9 & 0x7FFFFFF));
      }
      BOOL v2 = *a1 == *v10;
    }
    else
    {
      BOOL v2 = 0;
    }
  }
  return (v7 ^ 1) & v2;
}

uint64_t sub_1CD68A5C0(uint64_t a1, uint64_t a2)
{
  if ((sub_1CC9FAAFC(a1, a2) & 1) != 0
    || (sub_1CC9FAC1C(a1 + 16, a2) & 1) != 0
    || (sub_1CC9FAD3C(a1 + 32, a2) & 1) != 0)
  {
    return 1;
  }

  return sub_1CC9FAE5C(a1 + 48, a2);
}

llvm::Instruction *sub_1CD68A634(uint64_t a1, llvm::Value *a2, llvm::APInt *this, llvm::Type *a4, int a5, int a6)
{
  uint64_t v10 = *(llvm::ConstantInt ***)a2;
  if (a6) {
    int v11 = 36;
  }
  else {
    int v11 = 35;
  }
  if (!a5)
  {
    unsigned int v23 = *((_DWORD *)this + 2);
    if (v23 > 0x40)
    {
      if (llvm::APInt::countLeadingZerosSlowCase(this) != v23) {
        goto LABEL_6;
      }
    }
    else if (*(void *)this)
    {
      goto LABEL_6;
    }
LABEL_13:
    uint64_t v24 = *(void *)(a1 + 24);
    unint64_t v21 = llvm::ConstantInt::get(v10, a4, this);
    __int16 v30 = 257;
    uint64_t v18 = v24;
    __int16 v19 = v11;
    std::string v20 = a2;
    return sub_1CB845F20(v18, v19, v20, (uint64_t)v21, (uint64_t)&Name);
  }
  if (sub_1CB8C0D18((uint64_t)this))
  {
    LOWORD(v11) = llvm::ICmpInst::getSignedPredicate(v11);
    goto LABEL_13;
  }
LABEL_6:
  uint64_t v12 = *(void *)(a1 + 24);
  uint64_t v13 = llvm::ConstantInt::get(v10, this, this);
  __int16 v30 = 773;
  Name = llvm::Value::getName(a2);
  uint64_t v28 = v14;
  uint64_t v29 = ".off";
  uint64_t v15 = sub_1CB84494C(v12, (uint64_t)a2, (uint64_t)v13, (uint64_t)&Name, 0, 0);
  unsigned int v26 = *((_DWORD *)a4 + 2);
  if (v26 > 0x40) {
    operator new[]();
  }
  std::string::size_type v25 = *(char **)a4;
  llvm::APInt::operator-=((uint64_t)&v25, (unint64_t **)this);
  LODWORD(v28) = v26;
  Name = v25;
  unsigned int v26 = 0;
  uint64_t v17 = llvm::ConstantInt::get(v10, (llvm::Type *)&Name, v16);
  if (v28 >= 0x41 && Name) {
    MEMORY[0x1D25D9CB0](Name, 0x1000C8000313F17);
  }
  if (v26 >= 0x41 && v25) {
    MEMORY[0x1D25D9CB0](v25, 0x1000C8000313F17);
  }
  uint64_t v18 = *(void *)(a1 + 24);
  __int16 v30 = 257;
  __int16 v19 = v11;
  std::string v20 = v15;
  unint64_t v21 = v17;
  return sub_1CB845F20(v18, v19, v20, (uint64_t)v21, (uint64_t)&Name);
}

llvm::Instruction *sub_1CD68A854(uint64_t *a1, llvm::Value *a2, uint64_t a3)
{
  BOOL v6 = operator new(0x60uLL);
  v6[13] = v6[13] & 0x38000000 | 1;
  int v7 = (llvm::Instruction *)(v6 + 8);
  *(void *)BOOL v6 = 0;
  *((void *)v6 + 1) = 0;
  *((void *)v6 + 2) = 0;
  *((void *)v6 + 3) = v6 + 8;
  __int16 v10 = 257;
  llvm::FreezeInst::FreezeInst((llvm::FreezeInst *)(v6 + 8), a2, &v9, 0);
  return sub_1CB844E0C(a1, v7, a3);
}

int8x8_t *sub_1CD68A8DC(int8x8_t ***a1, llvm::Constant *this)
{
  if (this && *((unsigned char *)this + 16) == 16)
  {
    unsigned int v3 = (int8x8_t *)((char *)this + 24);
    uint64_t v4 = *((unsigned int *)this + 8);
    if (v4 > 0x40)
    {
      int v6 = 0;
      unint64_t v7 = (unint64_t)(v4 + 63) >> 6;
      uint64_t v8 = (int8x8_t *)*v3;
      do
      {
        int8x8_t v9 = *v8++;
        uint8x8_t v10 = (uint8x8_t)vcnt_s8(v9);
        v10.i16[0] = vaddlv_u8(v10);
        v6 += v10.i32[0];
        --v7;
      }
      while (v7);
      if (v6 == 1) {
        goto LABEL_9;
      }
    }
    else
    {
      uint8x8_t v5 = (uint8x8_t)vcnt_s8(*v3);
      v5.i16[0] = vaddlv_u8(v5);
      if (v5.u32[0] == 1) {
        goto LABEL_9;
      }
    }
  }
  if ((*(_DWORD *)(*(void *)this + 8) & 0xFE) == 0x12)
  {
    __n128 result = (int8x8_t *)llvm::Constant::getSplatValue(this, 0);
    if (!result) {
      return result;
    }
    if (result[2].i8[0] == 16)
    {
      unsigned int v3 = result + 3;
      uint64_t v12 = result[4].u32[0];
      if (v12 > 0x40)
      {
        int v14 = 0;
        unint64_t v15 = (unint64_t)(v12 + 63) >> 6;
        uint64_t v16 = (int8x8_t *)*v3;
        do
        {
          int8x8_t v17 = *v16++;
          uint8x8_t v18 = (uint8x8_t)vcnt_s8(v17);
          v18.i16[0] = vaddlv_u8(v18);
          v14 += v18.i32[0];
          --v15;
        }
        while (v15);
        if (v14 != 1) {
          return 0;
        }
      }
      else
      {
        uint8x8_t v13 = (uint8x8_t)vcnt_s8(*v3);
        v13.i16[0] = vaddlv_u8(v13);
        if (v13.u32[0] != 1) {
          return 0;
        }
      }
LABEL_9:
      **a1 = v3;
      return (int8x8_t *)1;
    }
  }
  return 0;
}

BOOL sub_1CD68AA10@<W0>(uint64_t a1@<X0>, uint64_t a2@<X1>, BOOL a3@<W8>)
{
  if (!a2) {
    return 0;
  }
  BOOL result = sub_1CCA137A8((void **)(a1 + 8), *(void *)(a2 - 64), a3);
  if (result)
  {
    int v6 = *(unsigned __int8 **)(a2 - 32);
    if (v6
      && v6[16] <= 0x14u
      && ((llvm::Constant::isNullValue(*(llvm::Constant **)(a2 - 32)) & 1) != 0
       || (sub_1CC03F414((uint64_t)&v7, (llvm::Constant *)v6) & 1) != 0))
    {
      **(_DWORD **)a1 = *(_WORD *)(a2 + 18) & 0x3F;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1CD68AAB4@<X0>(void *a1@<X0>, uint64_t a2@<X1>, BOOL a3@<W8>)
{
  unsigned int v3 = *(unsigned __int8 *)(a2 + 16);
  unsigned int v4 = v3 - 28;
  BOOL v6 = v3 < 0x1C && v3 != 5 || a2 == 0;
  int v7 = v6;
  if (!v6)
  {
    if (v3 <= 0x1B) {
      unsigned int v4 = *(unsigned __int16 *)(a2 + 18);
    }
    if (v4 == 39)
    {
      int v9 = *(_DWORD *)(a2 + 20);
      if ((v9 & 0x40000000) != 0) {
        uint8x8_t v10 = *(uint64_t **)(a2 - 8);
      }
      else {
        uint8x8_t v10 = (uint64_t *)(a2 - 32 * (v9 & 0x7FFFFFF));
      }
      a3 = sub_1CCA15FD0(a1, *v10, (BOOL)v10);
    }
    else
    {
      a3 = 0;
    }
  }
  return (v7 ^ 1) & a3;
}

uint64_t sub_1CD68AB34(uint64_t a1, uint64_t a2, llvm::APInt *a3)
{
  uint64_t v3 = a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  uint8x8_t v5 = (llvm::APInt *)(a1 + 16);
  BOOL v6 = (const llvm::APInt *)(a2 + 16);
  LODWORD(v3) = *(_DWORD *)(v3 + 24);
  *(_DWORD *)(a1 + 24) = v3;
  if (v3 > 0x40) {
    llvm::APInt::initSlowCase(v5, v6);
  }
  *(void *)uint8x8_t v5 = *(void *)v6;
  int v7 = (llvm::APInt *)(a1 + 32);
  unsigned int v8 = *((_DWORD *)a3 + 2);
  *(_DWORD *)(a1 + 40) = v8;
  if (v8 > 0x40) {
    llvm::APInt::initSlowCase(v7, a3);
  }
  *(void *)int v7 = *(void *)a3;
  return a1;
}

uint64_t sub_1CD68ABB8(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 40) >= 0x41u)
  {
    uint64_t v2 = *(void *)(a1 + 32);
    if (v2) {
      MEMORY[0x1D25D9CB0](v2, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 24) >= 0x41u)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
    }
  }
  return a1;
}

uint64_t sub_1CD68AC2C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W8>)
{
  unsigned int v3 = *(unsigned __int8 *)(a2 + 16);
  unsigned int v4 = v3 - 28;
  BOOL v6 = v3 < 0x1C && v3 != 5 || a2 == 0;
  int v7 = v6;
  if (!v6)
  {
    if (v3 <= 0x1B) {
      unsigned int v4 = *(unsigned __int16 *)(a2 + 18);
    }
    if (v4 == 39)
    {
      int v9 = *(_DWORD *)(a2 + 20);
      if ((v9 & 0x40000000) != 0) {
        uint8x8_t v10 = *(uint64_t **)(a2 - 8);
      }
      else {
        uint8x8_t v10 = (uint64_t *)(a2 - 32 * (v9 & 0x7FFFFFF));
      }
      a3 = sub_1CCA15DB0(a1, 28, *v10);
    }
    else
    {
      a3 = 0;
    }
  }
  return (v7 ^ 1) & a3;
}

uint64_t sub_1CD68ACB0(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(unsigned __int8 *)(a2 + 16);
  unsigned int v4 = v3 - 28;
  BOOL v6 = v3 < 0x1C && v3 != 5 || a2 == 0;
  int v7 = v6;
  if (!v6)
  {
    if (v3 <= 0x1B) {
      unsigned int v4 = *(unsigned __int16 *)(a2 + 18);
    }
    if (v4 == 40)
    {
      int v9 = *(_DWORD *)(a2 + 20);
      if ((v9 & 0x40000000) != 0) {
        uint8x8_t v10 = *(void **)(a2 - 8);
      }
      else {
        uint8x8_t v10 = (void *)(a2 - 32 * (v9 & 0x7FFFFFF));
      }
      BOOL v2 = *v10 == a1;
    }
    else
    {
      BOOL v2 = 0;
    }
  }
  return (v7 ^ 1) & v2;
}

llvm::Value *sub_1CD68AD18(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF);
  uint64_t v5 = *(void *)v4;
  uint64_t v6 = *(void *)(v4 + 32);
  int v7 = (unint64_t *)(v6 + 24);
  if (*(_DWORD *)(v6 + 32) >= 0x41u) {
    int v7 = (unint64_t *)*v7;
  }
  unint64_t v8 = *v7;
  __int16 v9 = __clz(v8) ^ 0x3F;
  if (v8) {
    __int16 v10 = v9;
  }
  else {
    __int16 v10 = 0;
  }
  if (llvm::maskIsAllOneOrUndef(*(llvm **)(v4 + 64), (llvm::Value *)a2))
  {
    int v11 = *(uint64_t **)(a1 + 24);
    uint64_t v12 = *(llvm::Type **)a2;
    v22[0] = "unmaskedload";
    __int16 v23 = 259;
    uint8x8_t v13 = sub_1CC241384(v11, v12, v5, v10 | 0x100u, 0, (uint64_t)v22);
    llvm::Instruction::copyMetadata((uint64_t)v13, a2, 0, 0);
  }
  else
  {
    uint8x8_t v13 = 0;
    if (llvm::isDereferenceablePointer(v5, *(void *)a2, *(void *)(*(void *)(*(void *)(a2 + 40) + 56) + 40) + 272, (uint64_t *)a2, 0, 0))
    {
      unint64_t v15 = *(uint64_t **)(a1 + 24);
      uint64_t v16 = *(llvm::Type **)a2;
      v22[0] = "unmaskedload";
      __int16 v23 = 259;
      int8x8_t v17 = sub_1CC241384(v15, v16, v5, v10 | 0x100u, 0, (uint64_t)v22);
      llvm::Instruction::copyMetadata((uint64_t)v17, a2, 0, 0);
      uint8x8_t v18 = *(llvm::IRBuilderBase **)(a1 + 24);
      uint64_t v19 = a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF);
      std::string v20 = *(llvm::Value **)(v19 + 64);
      unint64_t v21 = *(llvm::Value **)(v19 + 96);
      __int16 v23 = 257;
      return llvm::IRBuilderBase::CreateSelect(v18, v20, v17, v21, (const llvm::Twine *)v22, 0);
    }
  }
  return v13;
}

uint64_t sub_1CD68AE90(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  v3[0] = &unk_1F262B5C0;
  uint64_t v4 = v3;
  sub_1CCA18094(a2, a1, (uint64_t)v3);
  if (v4 == v3)
  {
    (*(void (**)(void *))(v3[0] + 32))(v3);
  }
  else if (v4)
  {
    (*(void (**)(void))(*v4 + 40))();
  }
  return 0;
}

llvm::Value *sub_1CD68AF7C(void *a1, llvm::Instruction *this)
{
  v19[2] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = 0;
  unint64_t v15 = 0;
  unsigned int v2 = *(_DWORD *)(*((void *)this - 4) + 36) - 262;
  uint64_t v4 = 1 << (*(unsigned char *)(*((void *)this - 4) + 36) - 6);
  if ((v4 & 0x6000000600000) != 0) {
    unsigned int v5 = 15;
  }
  else {
    unsigned int v5 = 17;
  }
  if ((v4 & 0xC000000003) != 0) {
    uint64_t v6 = 13;
  }
  else {
    uint64_t v6 = v5;
  }
  unsigned int v7 = (v2 < 0x17) & (0x610003u >> v2);
  unint64_t v8 = (char *)this - 32 * (*((_DWORD *)this + 5) & 0x7FFFFFF);
  if (!sub_1CCA667D0(a1, v6, v7, *(unsigned __int8 **)v8, *((void *)v8 + 4), (unsigned __int8 **)this, (uint64_t *)&v15, &v14))return 0; {
  uint64_t v11 = v14;
  }
  uint64_t v10 = (uint64_t)v15;
  v19[0] = llvm::UndefValue::get(*v15, v9);
  v19[1] = v11;
  uint64_t v12 = llvm::ConstantStruct::get(*(llvm::PoisonValue **)this, (llvm::Type *)v19, 2);
  int v18 = 0;
  __int16 v17 = 257;
  return sub_1CC19A834(v12, v10, &v18, 1, &v16, 0);
}

__n128 sub_1CD68B0B4(uint64_t a1, __n128 *a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 8);
  if (v4 >= *(_DWORD *)(a1 + 12))
  {
    sub_1CD68B3A4();
  }
  uint64_t v5 = *(void *)a1 + 48 * v4;
  *(void *)uint64_t v5 = 0x68747561727470;
  *(unsigned char *)(v5 + 23) = 7;
  *(void *)(v5 + 32) = 0;
  *(void *)(v5 + 40) = 0;
  uint64_t v6 = operator new(0x10uLL);
  *(void *)(v5 + 24) = v6;
  *(void *)(v5 + 32) = v6;
  *(void *)(v5 + 40) = v6 + 1;
  __n128 result = *a2;
  *uint64_t v6 = *a2;
  *(void *)(v5 + 32) = v6 + 1;
  ++*(_DWORD *)(a1 + 8);
  return result;
}

void sub_1CD68B16C(int **a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)qword_1EBCE5B78, 0, 0);
  dword_1EBCE5BF8 = 0;
  qword_1EBCE5C00 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCE5C08 = 0;
  qword_1EBCE5B78[0] = (uint64_t)&unk_1F2643F00;
  qword_1EBCE5C10 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCE5C18 = (uint64_t)&unk_1F25EA168;
  qword_1EBCE5C30 = (uint64_t)&qword_1EBCE5C18;
  llvm::cl::Option::setArgStr(v4, "instcombine-guard-widening-window", 0x21uLL);
  dword_1EBCE5BF8 = **a1;
  byte_1EBCE5C0C = 1;
  dword_1EBCE5C08 = dword_1EBCE5BF8;
  xmmword_1EBCE5B98 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EBCE5B78);
}

uint64_t sub_1CD68B278(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a2 + 16);
  unsigned int v3 = v2 - 28;
  BOOL v5 = v2 < 0x1C && v2 != 5 || a2 == 0;
  int v6 = v5;
  if (!v5)
  {
    if (v2 <= 0x1B) {
      unsigned int v3 = *(unsigned __int16 *)(a2 + 18);
    }
    if (v3 == 38)
    {
      int v8 = *(_DWORD *)(a2 + 20);
      if ((v8 & 0x40000000) != 0) {
        __int16 v9 = *(uint64_t **)(a2 - 8);
      }
      else {
        __int16 v9 = (uint64_t *)(a2 - 32 * (v8 & 0x7FFFFFF));
      }
      LODWORD(a1) = sub_1CC045310(a1, *v9);
    }
    else
    {
      LODWORD(a1) = 0;
    }
  }
  return (v6 ^ 1) & a1;
}

uint64_t sub_1CD68B2F8(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a2)
  {
    unsigned int v5 = *(unsigned __int8 *)(a2 + 16);
    if (v5 >= 0x1C && v5 - 83 >= 0xFFFFFFFE)
    {
      uint64_t result = sub_1CCA38BC8((void **)(a1 + 8), *(void *)(a2 - 64), v5);
      if (result)
      {
        unsigned int v7 = *(unsigned __int8 **)(a2 - 32);
        if (v7
          && v7[16] <= 0x14u
          && ((llvm::Constant::isNullValue(*(llvm::Constant **)(a2 - 32)) & 1) != 0
           || (sub_1CC03F414((uint64_t)&v8, (llvm::Constant *)v7) & 1) != 0))
        {
          **(_DWORD **)a1 = *(_WORD *)(a2 + 18) & 0x3F;
          return 1;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

void sub_1CD68B3A4()
{
}

llvm::Instruction *sub_1CD68B480(uint64_t a1, uint64_t *a2, uint64_t a3, llvm::Instruction *a4, uint64_t a5)
{
  if (*(unsigned char *)(a1 + 100)) {
    return (llvm::Instruction *)llvm::IRBuilderBase::CreateConstrainedFPBinOp(a1, 95, a2, a3, a4, a5, 0, 0, 0);
  }
  uint64_t result = sub_1CC581220(a1, 24, (uint64_t)a2, a3, a5);
  if (!result)
  {
    __int16 v16 = 257;
    uint64_t v11 = (uint64_t ***)llvm::BinaryOperator::Create(24, a2, a3, &v15, 0);
    uint64_t v12 = v11;
    char v13 = *((unsigned char *)a4 + 17) & 0xFE;
    uint64_t v14 = *(llvm::MDNode **)(a1 + 88);
    if (v14) {
      llvm::Value::setMetadata(v11, 3, v14);
    }
    *((unsigned char *)v12 + 17) |= v13;
    return sub_1CB844E0C((uint64_t *)a1, (llvm::Instruction *)v12, a5);
  }
  return result;
}

uint64_t sub_1CD68B574(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  unint64_t v5 = a3;
  uint64_t v6 = *(void *)result;
  uint64_t v7 = *(unsigned int *)(result + 8);
  if (*(void *)result + 4 * v7 == a2)
  {
    return sub_1CC458150(result, a3, a4);
  }
  else
  {
    uint64_t v8 = (a2 - v6) >> 2;
    if (v7 + a3 > *(unsigned int *)(result + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    __int16 v9 = (int *)(v6 + 4 * v8);
    uint64_t v10 = (int *)(v6 + 4 * v7);
    unint64_t v11 = v10 - v9;
    unint64_t v12 = v11 - a3;
    if (v11 >= a3)
    {
      unint64_t v15 = (char *)&v10[-a3];
      uint64_t result = sub_1CD462190(result, v15, (char *)(v6 + 4 * v7));
      if (v15 != (char *)v9) {
        uint64_t result = (uint64_t)memmove(&v9[v5], v9, (char *)&v10[-v5] - (char *)v9);
      }
      for (; v5; --v5)
        *v9++ = a4;
    }
    else
    {
      *(_DWORD *)(result + 8) = v7 + a3;
      if (v8 != v7)
      {
        uint64_t result = (uint64_t)memcpy((void *)(v6 + 4 * (v7 + a3) - 4 * v11), v9, (char *)v10 - (char *)v9);
        uint64_t v13 = v10 - v9;
        do
        {
          *v9++ = a4;
          --v13;
        }
        while (v13);
      }
      if (v5 != v11)
      {
        do
          *v10++ = a4;
        while (!__CFADD__(v12++, 1));
      }
    }
  }
  return result;
}

llvm::Value *sub_1CD68B6C8(llvm::ConstantInt ***a1, uint64_t a2, int a3)
{
  unsigned int v5 = a3 & 0xFFFFFFFE;
  if ((a3 & 0xFFFFFFFE) == 0x22)
  {
    uint64_t v13 = operator new(0x80uLL);
    v13[21] = v13[21] & 0x38000000 | 2;
    uint64_t v7 = (llvm::Value *)(v13 + 16);
    *(void *)uint64_t v13 = 0;
    *((void *)v13 + 1) = 0;
    *((void *)v13 + 2) = 0;
    *((void *)v13 + 3) = v13 + 16;
    *((void *)v13 + 4) = 0;
    *((void *)v13 + 5) = 0;
    *((void *)v13 + 6) = 0;
    *((void *)v13 + 7) = v13 + 16;
    uint64_t v14 = *a1;
    unsigned int v38 = *(_DWORD *)(a2 + 8);
    if (v38 > 0x40) {
      operator new[]();
    }
    char v37 = *(unint64_t **)a2;
    sub_1CBA14940((uint64_t)&v37);
    llvm::APInt::operator++((uint64_t)&v37);
    unsigned int v40 = v38;
    __src = v37;
    unsigned int v38 = 0;
    __int16 v16 = llvm::ConstantInt::get(v14, (llvm::Type *)&__src, v15);
    __int16 v43 = 257;
    sub_1CB90C994(*a1);
    llvm::CmpInst::CmpInst(v7, v17, 53, 36, (uint64_t)a1, (uint64_t)v16, &v41, 0, 0);
    if (v40 >= 0x41 && __src) {
      MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
    }
    if (v38 >= 0x41)
    {
      int v18 = v37;
      if (v37) {
        goto LABEL_32;
      }
    }
    return v7;
  }
  if (v5 == 36)
  {
    uint64_t v19 = *a1;
    uint64_t v20 = sub_1CB8F1EEC((uint64_t)&v44, *(_DWORD *)(a2 + 8), -1);
    llvm::APInt::operator-=(v20, (unint64_t **)a2);
    unsigned int v42 = v45;
    uint64_t v41 = v44;
    unsigned int v45 = 0;
    uint64_t v22 = llvm::ConstantInt::get(v19, (llvm::Type *)&v41, v21);
    if (v42 >= 0x41 && v41) {
      MEMORY[0x1D25D9CB0](v41, 0x1000C8000313F17);
    }
    if (v45 >= 0x41 && v44) {
      MEMORY[0x1D25D9CB0](v44, 0x1000C8000313F17);
    }
    __int16 v23 = operator new(0x80uLL);
    v23[21] = v23[21] & 0x38000000 | 2;
    uint64_t v7 = (llvm::Value *)(v23 + 16);
    *(void *)__int16 v23 = 0;
    *((void *)v23 + 1) = 0;
    *((void *)v23 + 2) = 0;
    *((void *)v23 + 3) = v23 + 16;
    *((void *)v23 + 4) = 0;
    *((void *)v23 + 5) = 0;
    *((void *)v23 + 6) = 0;
    *((void *)v23 + 7) = v23 + 16;
    __int16 v43 = 257;
    sub_1CB90C994(*a1);
    llvm::CmpInst::CmpInst(v7, v24, 53, 34, (uint64_t)a1, (uint64_t)v22, &v41, 0, 0);
    return v7;
  }
  sub_1CBFD9168(*(unsigned int *)(a2 + 8), (llvm::APInt *)&__src);
  uint64_t v6 = operator new(0x80uLL);
  v6[21] = v6[21] & 0x38000000 | 2;
  uint64_t v7 = (llvm::Value *)(v6 + 16);
  *(void *)uint64_t v6 = 0;
  *((void *)v6 + 1) = 0;
  *((void *)v6 + 2) = 0;
  *((void *)v6 + 3) = v6 + 16;
  *((void *)v6 + 4) = 0;
  *((void *)v6 + 5) = 0;
  *((void *)v6 + 6) = 0;
  *((void *)v6 + 7) = v6 + 16;
  uint64_t v8 = *a1;
  if (v5 != 40)
  {
    unsigned int v30 = *(_DWORD *)(a2 + 8);
    if (v30 > 0x40) {
      operator new[]();
    }
    uint64_t v29 = *(unint64_t **)a2;
    llvm::APInt::operator-=((uint64_t)&v29, 1uLL);
    unsigned int v32 = v30;
    long long v31 = v29;
    unsigned int v30 = 0;
    sub_1CBA14940((uint64_t)&v31);
    llvm::APInt::operator++((uint64_t)&v31);
    llvm::APInt::operator+=((uint64_t)&v31, (uint64_t **)&__src);
    unsigned int v36 = v32;
    uint64_t v35 = v31;
    unsigned int v32 = 0;
    uint64_t v10 = llvm::ConstantInt::get(v8, (llvm::Type *)&v35, v9);
    __int16 v43 = 257;
    sub_1CB90C994(*a1);
    llvm::CmpInst::CmpInst(v7, v11, 53, 40, (uint64_t)a1, (uint64_t)v10, &v41, 0, 0);
    if (v36 >= 0x41 && v35) {
      MEMORY[0x1D25D9CB0](v35, 0x1000C8000313F17);
    }
    if (v32 >= 0x41 && v31) {
      MEMORY[0x1D25D9CB0](v31, 0x1000C8000313F17);
    }
    if (v30 < 0x41) {
      goto LABEL_8;
    }
    std::string::size_type v25 = v29;
    if (!v29) {
      goto LABEL_8;
    }
LABEL_39:
    MEMORY[0x1D25D9CB0](v25, 0x1000C8000313F17);
    goto LABEL_8;
  }
  unsigned int v34 = v40;
  if (v40 > 0x40) {
    operator new[]();
  }
  char v33 = (unint64_t *)__src;
  llvm::APInt::operator-=((uint64_t)&v33, (unint64_t **)a2);
  unsigned int v36 = v34;
  uint64_t v35 = v33;
  unsigned int v34 = 0;
  uint64_t v27 = llvm::ConstantInt::get(v8, (llvm::Type *)&v35, v26);
  __int16 v43 = 257;
  sub_1CB90C994(*a1);
  llvm::CmpInst::CmpInst(v7, v28, 53, 38, (uint64_t)a1, (uint64_t)v27, &v41, 0, 0);
  if (v36 >= 0x41 && v35) {
    MEMORY[0x1D25D9CB0](v35, 0x1000C8000313F17);
  }
  if (v34 >= 0x41)
  {
    std::string::size_type v25 = v33;
    if (v33) {
      goto LABEL_39;
    }
  }
LABEL_8:
  if (v40 >= 0x41)
  {
    int v18 = __src;
    if (__src) {
LABEL_32:
    }
      MEMORY[0x1D25D9CB0](v18, 0x1000C8000313F17);
  }
  return v7;
}

llvm::Value *sub_1CD68BC1C(uint64_t a1, uint64_t a2, llvm::ConstantInt **a3, llvm::APInt *this, llvm::APInt *a5)
{
  unsigned int v7 = *((_DWORD *)a5 + 2);
  if (v7 > 0x40)
  {
    uint64_t v19 = a1;
    uint64_t v20 = a5;
    unint64_t v21 = this;
    int v22 = llvm::APInt::countLeadingZerosSlowCase(a5);
    this = v21;
    a5 = v20;
    int v23 = v22;
    a1 = v19;
    if (v23 == v7) {
      return 0;
    }
  }
  else if (!*(void *)a5)
  {
    return 0;
  }
  uint64_t v8 = *(void *)(a2 - 64);
  int v9 = *(unsigned __int8 *)(v8 + 16);
  if (v9 != 55 && (v9 != 5 || *(_WORD *)(v8 + 18) != 27))
  {
    int v10 = 0;
    goto LABEL_6;
  }
  if (!v7) {
    return 0;
  }
  uint64_t v24 = this;
  std::string::size_type v25 = a5;
  uint64_t v26 = a1;
  if (v7 <= 0x40)
  {
    uint64_t result = 0;
    uint64_t v27 = *(void *)a5;
    if (*(void *)a5 == 0xFFFFFFFFFFFFFFFFLL >> -(char)v7) {
      return result;
    }
    goto LABEL_38;
  }
  if (llvm::APInt::countTrailingOnesSlowCase(a5) == v7) {
    return 0;
  }
  uint64_t v27 = *(void *)v25;
LABEL_38:
  char v37 = (llvm::APInt *)(v27 + 8 * ((v7 - 1) >> 6));
  if (v7 < 0x41) {
    char v37 = v25;
  }
  uint64_t v38 = *(void *)v37 >> (v7 - 1);
  unsigned int v39 = *((_DWORD *)v24 + 2);
  if (v39 >= 0x41) {
    unsigned int v40 = (llvm::APInt *)(*(void *)v24 + 8 * ((v39 - 1) >> 6));
  }
  else {
    unsigned int v40 = v24;
  }
  if (((v38 ^ (*(void *)v40 >> (v39 - 1))) & 1) != 0
    || (int)llvm::APInt::compareSigned(v25, v24) > 0)
  {
    return 0;
  }
  a1 = v26;
  a5 = v25;
  int v10 = 1;
  this = v24;
LABEL_6:
  uint64_t v11 = *((unsigned int *)this + 2);
  if (v11 > 0x40)
  {
    uint64_t v65 = a1;
    unsigned int v66 = a5;
    v67 = this;
    int v28 = llvm::APInt::countLeadingZerosSlowCase(this);
    a5 = v66;
    if (v28 == v11) {
      goto LABEL_8;
    }
    unint64_t v12 = *(void *)v67;
    unsigned int v29 = v11;
    unint64_t v30 = v11 + 63;
    unint64_t v31 = *(void *)v66;
    if (!memcmp(*(const void **)v67, *(const void **)v66, (v30 >> 3) & 0x3FFFFFF8)) {
      goto LABEL_32;
    }
    if (!v10) {
      goto LABEL_34;
    }
LABEL_23:
    unsigned int v32 = v29 - 1;
    char v33 = v67;
    if (v29 >= 0x41) {
      char v33 = (llvm::APInt *)(v12 + 8 * (v32 >> 6));
    }
    if ((*(void *)v33 >> v32))
    {
      if (v29 > 0x40)
      {
        int v35 = llvm::APInt::countLeadingOnesSlowCase(v67);
      }
      else
      {
        int v34 = __clz(~(v12 << -(char)v29));
        if (v29) {
          int v35 = v34;
        }
        else {
          int v35 = 0;
        }
      }
      if (v7 > 0x40)
      {
        int v56 = llvm::APInt::countLeadingOnesSlowCase(v66);
      }
      else
      {
        int v55 = __clz(~(v31 << -(char)v7));
        if (v7) {
          int v56 = v55;
        }
        else {
          int v56 = 0;
        }
      }
      int v42 = v35 - v56;
      if (v42 <= 0)
      {
LABEL_87:
        uint64_t v57 = (llvm::Value *)llvm::ConstantInt::get(*(llvm::ConstantInt **)a2, (*(_WORD *)(a2 + 18) & 0x3F) == 33, 0);
        return (llvm::Value *)sub_1CC9D3C84(v65, (llvm::ValueAsMetadata *)a2, v57);
      }
    }
    else
    {
LABEL_34:
      if (v29 > 0x40) {
        int v36 = llvm::APInt::countLeadingZerosSlowCase(v67);
      }
      else {
        int v36 = v29 + __clz(v12) - 64;
      }
      if (v7 > 0x40) {
        int v41 = llvm::APInt::countLeadingZerosSlowCase(v66);
      }
      else {
        int v41 = v7 + __clz(v31) - 64;
      }
      int v42 = v36 - v41;
      if (v42 <= 0) {
        goto LABEL_87;
      }
      if (!v10) {
        goto LABEL_68;
      }
    }
    unsigned int v69 = v7;
    if (v7 > 0x40) {
      operator new[]();
    }
    uint64_t v68 = (const void *)v31;
    sub_1CCA784F0((unsigned int *)&v68, v42);
    uint64_t v43 = *((unsigned int *)v67 + 2);
    unint64_t v44 = v68;
    if (v43 > 0x40) {
      BOOL v45 = memcmp(*(const void **)v67, v68, ((unint64_t)(v43 + 63) >> 3) & 0x3FFFFFF8) == 0;
    }
    else {
      BOOL v45 = *(void *)v67 == (void)v68;
    }
    int v46 = v45;
    if (v69 >= 0x41 && v44) {
      MEMORY[0x1D25D9CB0](v44, 0x1000C8000313F17);
    }
    if (v46)
    {
      unsigned int v47 = *((_DWORD *)v67 + 2);
      if (v47)
      {
        if (v47 > 0x40)
        {
          if (llvm::APInt::countTrailingOnesSlowCase(v67) != v47) {
            goto LABEL_78;
          }
        }
        else if (*(void *)v67 != 0xFFFFFFFFFFFFFFFFLL >> -(char)v47)
        {
          goto LABEL_78;
        }
      }
      uint64_t v58 = *((unsigned int *)v66 + 2);
      if (v58 > 0x40)
      {
        int v60 = 0;
        unint64_t v61 = (unint64_t)(v58 + 63) >> 6;
        uint64_t v62 = *(int8x8_t **)v66;
        do
        {
          int8x8_t v63 = *v62++;
          uint8x8_t v64 = (uint8x8_t)vcnt_s8(v63);
          v64.i16[0] = vaddlv_u8(v64);
          v60 += v64.i32[0];
          --v61;
        }
        while (v61);
        if (v60 != 1) {
          goto LABEL_96;
        }
      }
      else
      {
        uint8x8_t v59 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v66);
        v59.i16[0] = vaddlv_u8(v59);
        if (v59.u32[0] != 1)
        {
LABEL_96:
          uint64_t v52 = llvm::ConstantInt::get(*a3, v42, 0);
          __int16 v53 = *(_WORD *)(a2 + 18);
          int v54 = 35;
          return sub_1CCA4D608(v53, v54, a3, (uint64_t)v52);
        }
      }
LABEL_78:
      uint64_t v52 = llvm::ConstantInt::get(*a3, v42, 0);
      __int16 v53 = *(_WORD *)(a2 + 18);
      int v54 = 32;
      return sub_1CCA4D608(v53, v54, a3, (uint64_t)v52);
    }
LABEL_68:
    sub_1CB8F02F4((uint64_t)v66, v42, (uint64_t)&v68);
    uint64_t v48 = *((unsigned int *)v67 + 2);
    uint64_t v49 = v68;
    if (v48 > 0x40) {
      BOOL v50 = memcmp(*(const void **)v67, v68, ((unint64_t)(v48 + 63) >> 3) & 0x3FFFFFF8) == 0;
    }
    else {
      BOOL v50 = *(void *)v67 == (void)v68;
    }
    int v51 = v50;
    if (v69 >= 0x41 && v49) {
      MEMORY[0x1D25D9CB0](v49, 0x1000C8000313F17);
    }
    if (!v51) {
      goto LABEL_87;
    }
    goto LABEL_78;
  }
  unint64_t v12 = *(void *)this;
  if (!*(void *)this)
  {
LABEL_8:
    uint64_t v13 = *a3;
    if (v7 > 0x40) {
      int v14 = llvm::APInt::countLeadingZerosSlowCase(a5);
    }
    else {
      int v14 = v7 + __clz(*(void *)a5) - 64;
    }
    NullValue = llvm::ConstantInt::get(v13, v7 + ~v14, 0);
    __int16 v16 = *(_WORD *)(a2 + 18);
    int v17 = 34;
    goto LABEL_11;
  }
  unsigned int v29 = *((_DWORD *)this + 2);
  unsigned int v66 = a5;
  v67 = this;
  uint64_t v65 = a1;
  unint64_t v31 = *(void *)a5;
  if (v12 != *(void *)a5) {
    goto LABEL_23;
  }
LABEL_32:
  NullValue = llvm::Constant::getNullValue(*a3, (llvm::Type *)a2, (const llvm::APFloat *)a3);
  __int16 v16 = *(_WORD *)(a2 + 18);
  int v17 = 32;
LABEL_11:

  return sub_1CCA4D608(v16, v17, a3, (uint64_t)NullValue);
}

BOOL sub_1CD68C1E0(uint64_t a1, uint64_t a2)
{
  if (sub_1CCA78A3C(a1, a2) & 1) != 0 || sub_1CCA78C74(a1 + 3, a2, v4) || (sub_1CCA7921C(a1 + 8, a2)) {
    return 1;
  }

  return sub_1CCA78DC8(a1 + 16, 26, a2);
}

uint64_t sub_1CD68C258(uint64_t a1, uint64_t a2)
{
  if (sub_1CCA79460(a1, a2)) {
    return 1;
  }
  uint64_t result = 0;
  if (a2)
  {
    unsigned int v5 = *(unsigned __int8 *)(a2 + 16);
    if (v5 >= 0x1C && v5 - 53 <= 1)
    {
      **(void **)(a1 + 24) = a2;
      return 1;
    }
  }
  return result;
}

uint64_t sub_1CD68C2B0(uint64_t result, void *a2, uint64_t a3)
{
  unsigned int v3 = a2;
  uint64_t v5 = *a2;
  char v4 = (const llvm::APInt *)(a2 + 1);
  *(void *)uint64_t result = v5;
  LODWORD(v3) = *((_DWORD *)v3 + 4);
  *(_DWORD *)(result + 16) = v3;
  if (v3 > 0x40) {
    llvm::APInt::initSlowCase((llvm::APInt *)(result + 8), v4);
  }
  *(void *)(result + 8) = *(void *)v4;
  *(_OWORD *)(result + 24) = *(_OWORD *)a3;
  uint64_t v6 = (const llvm::APInt *)(a3 + 16);
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  *(_DWORD *)(result + 48) = v7;
  if (v7 > 0x40) {
    llvm::APInt::initSlowCase((llvm::APInt *)(result + 40), v6);
  }
  *(void *)(result + 40) = *(void *)v6;
  return result;
}

uint64_t sub_1CD68C344(uint64_t result)
{
  if (*(_DWORD *)(result + 48) >= 0x41u)
  {
    uint64_t v1 = *(void *)(result + 40);
    if (v1)
    {
      uint64_t v3 = result;
      MEMORY[0x1D25D9CB0](v1, 0x1000C8000313F17);
      uint64_t result = v3;
    }
  }
  if (*(_DWORD *)(result + 16) >= 0x41u)
  {
    uint64_t v2 = *(void *)(result + 8);
    if (v2)
    {
      uint64_t v4 = result;
      MEMORY[0x1D25D9CB0](v2, 0x1000C8000313F17);
      return v4;
    }
  }
  return result;
}

uint64_t sub_1CD68C3D0(void **a1, llvm::Constant *this)
{
  if (this)
  {
    if (*((unsigned char *)this + 16) == 16)
    {
      uint64_t v4 = (char *)this + 24;
      if (sub_1CCA78F70((llvm::Constant *)((char *)this + 24))) {
        goto LABEL_4;
      }
    }
  }
  if ((*(_DWORD *)(*(void *)this + 8) & 0xFE) != 0x12) {
    return 0;
  }
  uint64_t result = (uint64_t)llvm::Constant::getSplatValue(this, 0);
  if (!result) {
    return result;
  }
  if (*(unsigned char *)(result + 16) != 16) {
    return 0;
  }
  uint64_t v4 = (char *)(result + 24);
  uint64_t result = sub_1CCA78F70((llvm::APInt *)(result + 24));
  if (result)
  {
LABEL_4:
    **a1 = v4;
    return 1;
  }
  return result;
}

uint64_t sub_1CD68C474@<X0>(void *a1@<X0>, uint64_t a2@<X1>, BOOL a3@<W8>)
{
  unsigned int v3 = *(unsigned __int8 *)(a2 + 16);
  unsigned int v4 = v3 - 28;
  BOOL v6 = v3 < 0x1C && v3 != 5 || a2 == 0;
  int v7 = v6;
  if (!v6)
  {
    if (v3 <= 0x1B) {
      unsigned int v4 = *(unsigned __int16 *)(a2 + 18);
    }
    if (v4 == 38)
    {
      int v9 = *(_DWORD *)(a2 + 20);
      if ((v9 & 0x40000000) != 0) {
        int v10 = *(uint64_t **)(a2 - 8);
      }
      else {
        int v10 = (uint64_t *)(a2 - 32 * (v9 & 0x7FFFFFF));
      }
      a3 = sub_1CCA7A240(a1, *v10, (BOOL)v10);
    }
    else
    {
      a3 = 0;
    }
  }
  return (v7 ^ 1) & a3;
}

uint64_t sub_1CD68C4F4(uint64_t a1, uint64_t *a2)
{
  uint64_t v13 = *a2;
  int v14 = 0;
  sub_1CD5D55BC(a1, &v13, &v14, (uint64_t)&v11);
  uint64_t v4 = v11;
  if (v12)
  {
    long long v10 = (unint64_t)*a2;
    uint64_t v5 = *(_OWORD **)(a1 + 32);
    if ((unint64_t)v5 >= *(void *)(a1 + 40))
    {
      BOOL v6 = sub_1CC00319C((void **)(a1 + 24), &v10);
    }
    else
    {
      *uint64_t v5 = v10;
      BOOL v6 = v5 + 1;
    }
    *(void *)(a1 + 32) = v6;
    uint64_t v8 = *(void *)(a1 + 24);
    unsigned int v7 = (((unint64_t)v6 - v8) >> 4) - 1;
    *(_DWORD *)(v4 + 8) = v7;
  }
  else
  {
    unsigned int v7 = *(_DWORD *)(v11 + 8);
    uint64_t v8 = *(void *)(a1 + 24);
  }
  return v8 + 16 * v7 + 8;
}

uint64_t sub_1CD68C5B0(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = a2;
  if (sub_1CBFFBC50((uint64_t *)a1, &v8, &v7))
  {
    uint64_t v3 = v7;
    uint64_t v4 = *(void *)a1;
    uint64_t v5 = *(unsigned int *)(a1 + 16);
  }
  else
  {
    uint64_t v4 = *(void *)a1;
    uint64_t v5 = *(unsigned int *)(a1 + 16);
    uint64_t v3 = *(void *)a1 + 16 * v5;
  }
  if (v3 == v4 + 16 * v5) {
    return 0;
  }
  else {
    return *(void *)(*(void *)(a1 + 24) + 16 * *(unsigned int *)(v3 + 8) + 8);
  }
}

void sub_1CD68C62C(char **a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCE5C40, 0, 0);
  byte_1EBCE5CC0 = 0;
  qword_1EBCE5CC8 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCE5CD0 = 0;
  qword_1EBCE5C40 = (uint64_t)&unk_1F26440A0;
  qword_1EBCE5CD8 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCE5CE0 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCE5CF8 = (uint64_t)&qword_1EBCE5CE0;
  llvm::cl::Option::setArgStr(v4, "instcombine-negator-enabled", 0x1BuLL);
  uint64_t v5 = *a1;
  byte_1EBCE5CC0 = **a1;
  byte_1EBCE5CD1 = 1;
  byte_1EBCE5CD0 = *v5;
  xmmword_1EBCE5C60 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE5C40);
}

void sub_1CD68C73C(int **a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCE5D00, 0, 0);
  dword_1EBCE5D80 = 0;
  qword_1EBCE5D88 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCE5D90 = 0;
  qword_1EBCE5D00 = (uint64_t)&unk_1F2643F00;
  qword_1EBCE5D98 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCE5DA0 = (uint64_t)&unk_1F25EA168;
  qword_1EBCE5DB8 = (uint64_t)&qword_1EBCE5DA0;
  llvm::cl::Option::setArgStr(v4, "instcombine-negator-max-depth", 0x1DuLL);
  uint64_t v5 = *a1;
  dword_1EBCE5D80 = **a1;
  byte_1EBCE5D94 = 1;
  dword_1EBCE5D90 = *v5;
  xmmword_1EBCE5D20 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE5D00);
}

void sub_1CD68C84C(int **a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCE5DC0, 0, 0);
  dword_1EBCE5E40 = 0;
  qword_1EBCE5E48 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCE5E50 = 0;
  qword_1EBCE5DC0 = (uint64_t)&unk_1F2643F00;
  qword_1EBCE5E58 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCE5E60 = (uint64_t)&unk_1F25EA168;
  qword_1EBCE5E78 = (uint64_t)&qword_1EBCE5E60;
  llvm::cl::Option::setArgStr(v4, "instcombine-max-num-phis", 0x18uLL);
  dword_1EBCE5E40 = **a1;
  byte_1EBCE5E54 = 1;
  dword_1EBCE5E50 = dword_1EBCE5E40;
  xmmword_1EBCE5DE0 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE5DC0);
}

void *sub_1CD68C958(_DWORD *a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD4C64C4((uint64_t)a1, *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD68C9BC(a1, a2, v7);
    *uint64_t v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD68C9BC(_DWORD *a1, uint64_t *a2, void *a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 4;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD68CA7C((uint64_t)a1, v6);
  uint64_t v8 = 0;
  sub_1CD4C64C4((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096) {
    --a1[1];
  }
  return a3;
}

uint64_t sub_1CD68CA7C(uint64_t a1, unsigned int a2)
{
  void v14[8] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    unsigned int v6 = *(uint64_t **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD4C67C0(a1, v6, &v6[2 * v7]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = 0;
  int v9 = v14;
  do
  {
    uint64_t v10 = *(void *)(a1 + v8 + 8);
    if ((v10 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *int v9 = v10;
      v9[1] = *(void *)(a1 + v8 + 16);
      v9 += 2;
    }
    v8 += 16;
  }
  while (v8 != 64);
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD4C67C0(a1, v14, v9);
}

uint64_t sub_1CD68CC08(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a2 && *(unsigned char *)(a2 + 16) == 81)
  {
    if (*(void *)(a1 + 8) == *(void *)(a2 - 64))
    {
      int v5 = *(unsigned __int8 **)(a2 - 32);
      uint64_t result = sub_1CC9F89B4((int)a1 + 16, (llvm::Constant *)v5);
      if (result)
      {
        uint64_t result = 0;
        if (v5)
        {
          if (v5[16] <= 0x14u)
          {
            **(void **)(a1 + 24) = v5;
            **(_DWORD **)a1 = *(_WORD *)(a2 + 18) & 0x3F;
            return 1;
          }
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1CD68CCA4(unsigned __int8 *a1)
{
  if (sub_1CC04BFB8((uint64_t)a1)) {
    return 1;
  }
  uint64_t result = 0;
  if (a1 && a1[16] <= 0x14u)
  {
    if ((llvm::Constant::isNullValue((llvm::Constant *)a1) & 1) == 0) {
      return sub_1CC03F414((uint64_t)&v3, (llvm::Constant *)a1);
    }
    return 1;
  }
  return result;
}

uint64_t sub_1CD68CD08@<X0>(void **a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W8>)
{
  unsigned int v3 = *(unsigned __int8 *)(a2 + 16);
  unsigned int v4 = v3 - 28;
  BOOL v6 = v3 < 0x1C && v3 != 5 || a2 == 0;
  int v7 = v6;
  if (!v6)
  {
    if (v3 <= 0x1B) {
      unsigned int v4 = *(unsigned __int16 *)(a2 + 18);
    }
    if (v4 == 39)
    {
      int v9 = *(_DWORD *)(a2 + 20);
      if ((v9 & 0x40000000) != 0) {
        uint64_t v10 = *(uint64_t **)(a2 - 8);
      }
      else {
        uint64_t v10 = (uint64_t *)(a2 - 32 * (v9 & 0x7FFFFFF));
      }
      a3 = sub_1CCAB3228(a1, *v10, (uint64_t)v10);
    }
    else
    {
      a3 = 0;
    }
  }
  return (v7 ^ 1) & a3;
}

uint64_t sub_1CD68CD88@<X0>(void **a1@<X0>, uint64_t a2@<X1>, BOOL a3@<W8>)
{
  unsigned int v3 = *(unsigned __int8 *)(a2 + 16);
  unsigned int v4 = v3 - 28;
  BOOL v6 = v3 < 0x1C && v3 != 5 || a2 == 0;
  int v7 = v6;
  if (!v6)
  {
    if (v3 <= 0x1B) {
      unsigned int v4 = *(unsigned __int16 *)(a2 + 18);
    }
    if (v4 == 39)
    {
      int v9 = *(_DWORD *)(a2 + 20);
      if ((v9 & 0x40000000) != 0) {
        uint64_t v10 = *(uint64_t **)(a2 - 8);
      }
      else {
        uint64_t v10 = (uint64_t *)(a2 - 32 * (v9 & 0x7FFFFFF));
      }
      a3 = sub_1CCAB331C(a1, *v10, (BOOL)v10);
    }
    else
    {
      a3 = 0;
    }
  }
  return (v7 ^ 1) & a3;
}

uint64_t sub_1CD68CE08(void **a1, uint64_t a2)
{
  unsigned int v3 = *(unsigned __int8 *)(a2 + 16);
  unsigned int v4 = v3 - 28;
  BOOL v6 = v3 < 0x1C && v3 != 5 || a2 == 0;
  int v7 = v6;
  if (!v6)
  {
    if (v3 <= 0x1B) {
      unsigned int v4 = *(unsigned __int16 *)(a2 + 18);
    }
    if (v4 == 39)
    {
      int v9 = *(_DWORD *)(a2 + 20);
      if ((v9 & 0x40000000) != 0) {
        uint64_t v10 = *(void **)(a2 - 8);
      }
      else {
        uint64_t v10 = (void *)(a2 - 32 * (v9 & 0x7FFFFFF));
      }
      BOOL v2 = **a1 == *v10;
    }
    else
    {
      BOOL v2 = 0;
    }
  }
  return (v7 ^ 1) & v2;
}

uint64_t sub_1CD68CE78@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, BOOL a3@<W8>)
{
  unsigned int v3 = *(unsigned __int8 *)(a2 + 16);
  unsigned int v4 = v3 - 28;
  BOOL v6 = v3 < 0x1C && v3 != 5 || a2 == 0;
  int v7 = v6;
  if (!v6)
  {
    if (v3 <= 0x1B) {
      unsigned int v4 = *(unsigned __int16 *)(a2 + 18);
    }
    if (v4 == 39)
    {
      int v9 = *(_DWORD *)(a2 + 20);
      if ((v9 & 0x40000000) != 0) {
        uint64_t v10 = *(uint64_t **)(a2 - 8);
      }
      else {
        uint64_t v10 = (uint64_t *)(a2 - 32 * (v9 & 0x7FFFFFF));
      }
      a3 = sub_1CCAB3418(a1, *v10, (BOOL)v10);
    }
    else
    {
      a3 = 0;
    }
  }
  return (v7 ^ 1) & a3;
}

void sub_1CD68CEFC()
{
}

uint64_t sub_1CD68CF10(uint64_t a1, unsigned int a2)
{
  void v14[8] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    BOOL v6 = *(uint64_t **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD68D09C(a1, v6, &v6[2 * v7]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = 0;
  int v9 = v14;
  do
  {
    uint64_t v10 = *(void *)(a1 + v8 + 8);
    if ((v10 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *int v9 = v10;
      v9[1] = *(void *)(a1 + v8 + 16);
      v9 += 2;
    }
    v8 += 16;
  }
  while (v8 != 64);
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD68D09C(a1, v14, v9);
}

uint64_t sub_1CD68D09C(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    int v9 = (void *)(result + 72);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(void **)(result + 8);
    int v9 = &v8[2 * v7];
  }
  do
  {
    void *v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    uint64_t v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      char v12 = 0;
      uint64_t result = sub_1CC056A94((uint64_t)v5, v10, &v12);
      uint64_t v11 = v12;
      *char v12 = *a2;
      v11[1] = a2[1];
      *v5 += 2;
    }
    a2 += 2;
  }
  return result;
}

void *sub_1CD68D160(_DWORD *a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CC056A94((uint64_t)a1, *a2, &v7);
  int v5 = v7;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CCACAF04(a1, a2, v7);
    *int v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

uint64_t sub_1CD68D1C0(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    uint64_t v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *uint64_t v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CCACB19C(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      uint64_t v10 = v11;
      *uint64_t v11 = *a2;
      v10[1] = a2[1];
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 2;
  }
  return result;
}

void *llvm::LocationMetadata::parse(void *this, llvm::MDNode *a2)
{
  BOOL v2 = this;
  unint64_t v3 = (void *)((char *)a2 - 8 * *((unsigned int *)a2 + 2));
  char v4 = *(uint64_t **)(*v3 + 8);
  uint64_t v5 = *v4;
  *this = v4 + 3;
  this[1] = v5;
  uint64_t v6 = *(void *)(v3[1] + 128);
  uint64_t v7 = (void *)(v6 + 24);
  unsigned int v8 = *(_DWORD *)(v6 + 32);
  if (v8 < 0x41) {
    goto LABEL_2;
  }
  this = (void *)llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)(v6 + 24));
  if (v8 - this <= 0x40)
  {
    uint64_t v7 = (void *)*v7;
LABEL_2:
    int v9 = *(_DWORD *)v7;
    goto LABEL_3;
  }
  int v9 = -1;
LABEL_3:
  *((_DWORD *)v2 + 4) = v9;
  uint64_t v10 = *(void *)(v3[2] + 128);
  uint64_t v11 = (void *)(v10 + 24);
  unsigned int v12 = *(_DWORD *)(v10 + 32);
  if (v12 >= 0x41)
  {
    this = (void *)llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)(v10 + 24));
    if (v12 - this > 0x40)
    {
      int v13 = -1;
      goto LABEL_5;
    }
    uint64_t v11 = (void *)*v11;
  }
  int v13 = *(_DWORD *)v11;
LABEL_5:
  *((_DWORD *)v2 + 5) = v13;
  return this;
}

llvm::GlobalsMetadata *llvm::GlobalsMetadata::GlobalsMetadata(llvm::GlobalsMetadata *this, llvm::Module *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  v33[0] = "llvm.asan.globals";
  __int16 v34 = 259;
  uint64_t NamedMetadata = llvm::Module::getNamedMetadata(a2, v33);
  if (NamedMetadata)
  {
    uint64_t v4 = NamedMetadata;
    uint64_t v5 = *(unsigned int *)(*(void *)(NamedMetadata + 48) + 8);
    if (v5)
    {
      uint64_t v6 = 0;
      uint64_t v7 = 8 * v5;
      do
      {
        uint64_t v8 = *(void *)(**(void **)(v4 + 48) + v6);
        uint64_t v9 = *(void *)(v8 - 8 * *(unsigned int *)(v8 + 8));
        if (v9)
        {
          uint64_t v10 = *(llvm::Value **)(v9 + 128);
          if (v10)
          {
            uint64_t v11 = llvm::Value::stripPointerCasts(v10);
            unsigned int v12 = *((unsigned char *)v11 + 16) == 3 ? (const char *)v11 : 0;
            v33[0] = v12;
            if (v12)
            {
              int v13 = sub_1CD690254((uint64_t)this, (uint64_t *)v33);
              int v14 = v13;
              uint64_t v15 = *(unsigned int *)(v8 + 8);
              __int16 v16 = *(llvm::MDNode **)(v8 - 8 * v15 + 8);
              if (v16)
              {
                llvm::LocationMetadata::parse(v13 + 1, v16);
                uint64_t v15 = *(unsigned int *)(v8 + 8);
              }
              uint64_t v17 = -v15;
              uint64_t v18 = *(void *)(v8 - 8 * v15 + 16);
              if (v18)
              {
                uint64_t v19 = *(uint64_t **)(v18 + 8);
                uint64_t v20 = *v19;
                v14[4] = v19 + 3;
                void v14[5] = v20;
                uint64_t v17 = -v15;
              }
              uint64_t v21 = v8 + 8 * v17;
              uint64_t v22 = *(void *)(*(void *)(v21 + 24) + 128);
              int v23 = (llvm::APInt *)(v22 + 24);
              unsigned int v24 = *(_DWORD *)(v22 + 32);
              if (v24 > 0x40) {
                BOOL v25 = llvm::APInt::countLeadingZerosSlowCase(v23) == v24 - 1;
              }
              else {
                BOOL v25 = *(void *)v23 == 1;
              }
              char v26 = v25;
              *((unsigned char *)v14 + 48) |= v26;
              uint64_t v27 = *(void *)(*(void *)(v21 + 32) + 128);
              int v28 = (llvm::APInt *)(v27 + 24);
              unsigned int v29 = *(_DWORD *)(v27 + 32);
              if (v29 > 0x40) {
                BOOL v30 = llvm::APInt::countLeadingZerosSlowCase(v28) == v29 - 1;
              }
              else {
                BOOL v30 = *(void *)v28 == 1;
              }
              char v31 = v30;
              *((unsigned char *)v14 + 49) |= v31;
            }
          }
        }
        v6 += 8;
      }
      while (v7 != v6);
    }
  }
  return this;
}

llvm::GlobalsMetadata *llvm::ASanGlobalsMetadataAnalysis::run@<X0>(llvm::Module *a1@<X1>, llvm::GlobalsMetadata *a2@<X8>)
{
  return llvm::GlobalsMetadata::GlobalsMetadata(a2, a1);
}

llvm::raw_ostream *llvm::ModuleAddressSanitizerPass::printPipeline(unsigned char *a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, char *, uint64_t), uint64_t a4)
{
  sub_1CD68D570(a2, a3, a4);
  sub_1CB8E509C(a2, "<");
  if (*a1) {
    sub_1CB8E509C(a2, "kernel");
  }

  return sub_1CB8E509C(a2, ">");
}

llvm::raw_ostream *sub_1CD68D570(llvm::raw_ostream *a1, uint64_t (*a2)(uint64_t, char *, uint64_t), uint64_t a3)
{
  uint64_t v6 = sub_1CD690528();
  uint64_t v9 = (const void *)a2(a3, v6, v7);
  size_t v10 = v8;
  uint64_t result = (llvm::raw_ostream *)*((void *)a1 + 4);
  if (v8 <= *((void *)a1 + 3) - (void)result)
  {
    if (v8)
    {
      uint64_t result = (llvm::raw_ostream *)memcpy(result, v9, v8);
      *((void *)a1 + 4) += v10;
    }
  }
  else
  {
    return llvm::raw_ostream::write(a1, (const char *)v9, v8);
  }
  return result;
}

void llvm::ModuleAddressSanitizerPass::run()
{
}

void llvm::createAddressSanitizerFunctionPass()
{
}

void llvm::createModuleAddressSanitizerLegacyPassPass()
{
}

void *sub_1CD68D8C4(void *a1)
{
  *a1 = &unk_1F262B718;
  BOOL v2 = a1 + 71;
  unint64_t v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1F262B780;
  uint64_t v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }

  return sub_1CB87DD48(a1);
}

void *sub_1CD68D9AC(void *a1)
{
  *a1 = &unk_1F262B780;
  BOOL v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD68DA00(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  int v12 = 0;
  uint64_t v8 = sub_1CD42FA04(a1 + 152, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD68DA94(v11);
}

uint64_t sub_1CD68DA94(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 160) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD68DAAC(void *a1)
{
  sub_1CD68D8C4(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD68DAE4(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t sub_1CD68DAF0(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

llvm::raw_ostream *sub_1CD68DB00(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    int v3 = *((_DWORD *)result + 32);
LABEL_3:
    uint64_t v4 = &unk_1F262B7D0;
    char v6 = 1;
    int v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 148))
  {
    int v3 = *((_DWORD *)result + 32);
    if (*((_DWORD *)result + 36) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD68DB84(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void *sub_1CD68DB98(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 152), a2);
}

void sub_1CD68DBA0(void *a1)
{
  *a1 = &unk_1F262B780;
  BOOL v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD68DC14(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD68DC1C(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1CD68DC30(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1CD68DC44(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1CD68DC58(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

void *sub_1CD68DC84(void *a1)
{
  *a1 = &unk_1F262B810;
  BOOL v2 = a1 + 71;
  int v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1F262B878;
  uint64_t v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }

  return sub_1CB87DD48(a1);
}

void *sub_1CD68DD6C(void *a1)
{
  *a1 = &unk_1F262B878;
  BOOL v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD68DDC0(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  int v12 = 0;
  uint64_t v8 = sub_1CD42FA04(a1 + 152, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD68DE54(v11);
}

uint64_t sub_1CD68DE54(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 160) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD68DE6C(void *a1)
{
  sub_1CD68DC84(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD68DEA4(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t sub_1CD68DEB0(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

llvm::raw_ostream *sub_1CD68DEC0(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    int v3 = *((_DWORD *)result + 32);
LABEL_3:
    uint64_t v4 = &unk_1F262B8C8;
    char v6 = 1;
    int v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 148))
  {
    int v3 = *((_DWORD *)result + 32);
    if (*((_DWORD *)result + 36) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD68DF44(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void *sub_1CD68DF58(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 152), a2);
}

void sub_1CD68DF60(void *a1)
{
  *a1 = &unk_1F262B878;
  BOOL v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD68DFD4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD68DFDC(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1CD68DFF0(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1CD68E004(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1CD68E018(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

llvm::PointerType *sub_1CD68E044(uint64_t a1, unsigned __int8 *a2, const char *a3, uint64_t a4, uint64_t **a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v14[3] = *MEMORY[0x1E4F143B8];
  v14[0] = a6;
  v14[1] = a7;
  void v14[2] = a8;
  int v12 = (llvm::PointerType *)llvm::FunctionType::get(a5, (uint64_t)v14, 3, 0);
  return llvm::Module::getOrInsertFunction(a1, a2, a3, v12, a4);
}

void *sub_1CD68E11C(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  int v5 = v7;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CD68E18C(a1, a2, v7);
    *int v5 = *a2;
    *((unsigned char *)v5 + 8) = 0;
  }
  return v5;
}

void *sub_1CD68E18C(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD68E240(a1, v6);
  uint64_t v8 = 0;
  sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD68E240(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD68E30C(a1, v4, v4 + 16 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD68E30C(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CD40EA84(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      uint64_t v10 = v11;
      *uint64_t v11 = *(void *)a2;
      *((unsigned char *)v10 + 8) = *(unsigned char *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

uint64_t sub_1CD68E3C4(uint64_t a1, uint64_t *a2, unsigned int *a3, char *a4, uint64_t *a5, unsigned __int8 *a6)
{
  unsigned int v7 = *(_DWORD *)(a1 + 8);
  if (v7 >= *(_DWORD *)(a1 + 12))
  {
    return sub_1CD68E554(a1, a2, a3, a4, a5, a6);
  }
  else
  {
    sub_1CD68E5E8(*(void *)a1 + 48 * v7, *a2, *a3, *a4, *a5, *a6 | 0x100, 0);
    unsigned int v8 = *(_DWORD *)(a1 + 8) + 1;
    *(_DWORD *)(a1 + 8) = v8;
    return *(void *)a1 + 48 * v8 - 48;
  }
}

uint64_t sub_1CD68E454(uint64_t a1, uint64_t *a2, unsigned int *a3, char *a4, uint64_t *a5)
{
  unsigned int v6 = *(_DWORD *)(a1 + 8);
  if (v6 >= *(_DWORD *)(a1 + 12))
  {
    return sub_1CD68E69C(a1, a2, a3, a4, a5);
  }
  else
  {
    sub_1CD68E5E8(*(void *)a1 + 48 * v6, *a2, *a3, *a4, *a5, 0, 0);
    unsigned int v7 = *(_DWORD *)(a1 + 8) + 1;
    *(_DWORD *)(a1 + 8) = v7;
    return *(void *)a1 + 48 * v7 - 48;
  }
}

uint64_t sub_1CD68E4E0(uint64_t a1, uint64_t a2, unsigned int a3, char a4, uint64_t a5, __int16 a6, uint64_t a7)
{
  unsigned int v8 = *(_DWORD *)(a1 + 8);
  if (v8 >= *(_DWORD *)(a1 + 12))
  {
    return sub_1CD68E72C(a1, a2, a3, a4, a5, a6, a7);
  }
  else
  {
    uint64_t result = sub_1CD68E5E8(*(void *)a1 + 48 * v8, a2, a3, a4 != 0, a5, a6, a7);
    ++*(_DWORD *)(a1 + 8);
  }
  return result;
}

uint64_t sub_1CD68E554(uint64_t a1, uint64_t *a2, unsigned int *a3, char *a4, uint64_t *a5, unsigned __int8 *a6)
{
  sub_1CD68E5E8((uint64_t)v12, *a2, *a3, *a4, *a5, *a6 | 0x100, 0);
  unsigned int v7 = (_OWORD *)sub_1CD58643C(a1, (unint64_t)v12, 1);
  unsigned int v8 = (_OWORD *)(*(void *)a1 + 48 * *(unsigned int *)(a1 + 8));
  long long v10 = v7[1];
  long long v9 = v7[2];
  _OWORD *v8 = *v7;
  v8[1] = v10;
  void v8[2] = v9;
  LODWORD(v8) = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v8;
  return *(void *)a1 + 48 * v8 - 48;
}

uint64_t sub_1CD68E5E8(uint64_t a1, uint64_t a2, unsigned int a3, char a4, uint64_t a5, __int16 a6, uint64_t a7)
{
  *(unsigned char *)(a1 + 8) = a4;
  *(void *)(a1 + 16) = a5;
  *(_WORD *)(a1 + 32) = a6;
  *(void *)(a1 + 40) = a7;
  unint64_t v11 = (sub_1CB83544C(*(void *)(*(void *)(*(void *)(a2 + 40) + 56) + 40) + 272, a5) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v10 == 1)
  {
    unint64_t v15 = v11;
    unint64_t v11 = v15;
  }
  *(void *)(a1 + 24) = v11;
  int v12 = *(_DWORD *)(a2 + 20);
  if ((v12 & 0x40000000) != 0) {
    uint64_t v13 = *(void *)(a2 - 8);
  }
  else {
    uint64_t v13 = a2 - 32 * (v12 & 0x7FFFFFF);
  }
  *(void *)a1 = v13 + 32 * a3;
  return a1;
}

uint64_t sub_1CD68E69C(uint64_t a1, uint64_t *a2, unsigned int *a3, char *a4, uint64_t *a5)
{
  sub_1CD68E5E8((uint64_t)v11, *a2, *a3, *a4, *a5, 0, 0);
  unsigned int v6 = (_OWORD *)sub_1CD58643C(a1, (unint64_t)v11, 1);
  unsigned int v7 = (_OWORD *)(*(void *)a1 + 48 * *(unsigned int *)(a1 + 8));
  long long v9 = v6[1];
  long long v8 = v6[2];
  *unsigned int v7 = *v6;
  v7[1] = v9;
  void v7[2] = v8;
  LODWORD(v7) = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v7;
  return *(void *)a1 + 48 * v7 - 48;
}

uint64_t sub_1CD68E72C(uint64_t a1, uint64_t a2, unsigned int a3, char a4, uint64_t a5, __int16 a6, uint64_t a7)
{
  sub_1CD68E5E8((uint64_t)v13, a2, a3, a4 != 0, a5, a6, a7);
  long long v8 = (_OWORD *)sub_1CD58643C(a1, (unint64_t)v13, 1);
  long long v9 = (_OWORD *)(*(void *)a1 + 48 * *(unsigned int *)(a1 + 8));
  long long v11 = v8[1];
  long long v10 = v8[2];
  *long long v9 = *v8;
  v9[1] = v11;
  uint64_t v9[2] = v10;
  LODWORD(v9) = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v9;
  return *(void *)a1 + 48 * v9 - 48;
}

unint64_t sub_1CD68E7B0(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 56 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  return a2;
}

void *sub_1CD68E82C(void *result, size_t __len, int __c)
{
  unint64_t v4 = result;
  uint64_t v5 = result[1];
  if (v5 + __len > result[2]) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  if (__len)
  {
    uint64_t result = memset((void *)(*result + v5), __c, __len);
    uint64_t v5 = v4[1];
  }
  v4[1] = v5 + __len;
  return result;
}

void sub_1CD68E8A8(_WORD *a1, char **a2, _WORD *a3, __n128 *a4, _WORD *a5)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE6270, 0, 0);
  byte_1EBCE62F0 = 0;
  qword_1EBCE62F8 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCE6300 = 0;
  qword_1EBCE6270 = (uint64_t)&unk_1F26440A0;
  qword_1EBCE6308 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCE6310 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCE6328 = (uint64_t)&qword_1EBCE6310;
  sub_1CD68E9B0(a1, a2, a3, a4, a5);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE6270);
}

__n128 sub_1CD68E9B0(_WORD *a1, char **a2, _WORD *a3, __n128 *a4, _WORD *a5)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE6270, "asan-use-stack-safety", 0x15uLL);
  __int16 v10 = word_1EBCE627A;
  word_1EBCE627A = word_1EBCE627A & 0xFF9F | (32 * (*a1 & 3));
  long long v11 = *a2;
  byte_1EBCE62F0 = **a2;
  byte_1EBCE6301 = 1;
  byte_1EBCE6300 = *v11;
  word_1EBCE627A = v10 & 0xFF9F | (32 * (*a3 & 3));
  __n128 result = *a4;
  xmmword_1EBCE6290 = (__int128)*a4;
  word_1EBCE627A = word_1EBCE627A & 0xFFF8 | *a5 & 7;
  return result;
}

void sub_1CD68EA5C(int **a1, __n128 *a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE67B0, 0, 0);
  dword_1EBCE6830 = 0;
  qword_1EBCE6838 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCE6840 = 0;
  qword_1EBCE67B0 = (uint64_t)&unk_1F2643F68;
  qword_1EBCE6848 = (uint64_t)&unk_1F2643D20;
  qword_1EBCE6850 = (uint64_t)&unk_1F25F7480;
  qword_1EBCE6868 = (uint64_t)&qword_1EBCE6850;
  sub_1CD68EB4C(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE67B0);
}

__n128 sub_1CD68EB4C(int **a1, __n128 *a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE67B0, "asan-max-ins-per-bb", 0x13uLL);
  unsigned int v6 = *a1;
  dword_1EBCE6830 = **a1;
  byte_1EBCE6844 = 1;
  dword_1EBCE6840 = *v6;
  __n128 result = *a2;
  xmmword_1EBCE67D0 = (__int128)*a2;
  word_1EBCE67BA = (32 * (*a3 & 3)) | word_1EBCE67BA & 0xFF9F;
  return result;
}

void sub_1CD68EBD4(__n128 *a1, _WORD *a2, char **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE6870, 0, 0);
  byte_1EBCE68F0 = 0;
  qword_1EBCE68F8 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCE6900 = 0;
  qword_1EBCE6870 = (uint64_t)&unk_1F26440A0;
  qword_1EBCE6908 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCE6910 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCE6928 = (uint64_t)&qword_1EBCE6910;
  sub_1CD68ECC4(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE6870);
}

__n128 sub_1CD68ECC4(__n128 *a1, _WORD *a2, char **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE6870, "asan-stack", 0xAuLL);
  __n128 result = *a1;
  xmmword_1EBCE6890 = (__int128)*a1;
  word_1EBCE687A = (32 * (*a2 & 3)) | word_1EBCE687A & 0xFF9F;
  unsigned int v7 = *a3;
  byte_1EBCE68F0 = **a3;
  byte_1EBCE6901 = 1;
  byte_1EBCE6900 = *v7;
  return result;
}

void sub_1CD68ED4C(long long *a1, uint64_t a2, _WORD *a3, int **a4)
{
  sub_1CB883A14((uint64_t)&qword_1EA61D540, 0, 0);
  dword_1EA61D5C0 = 0;
  qword_1EA61D5C8 = (uint64_t)&unk_1F262B7D0;
  *(void *)&dword_1EA61D5D0 = 0;
  qword_1EA61D540 = (uint64_t)&unk_1F262B718;
  qword_1EA61D5D8 = (uint64_t)&unk_1F262B780;
  qword_1EA61D5E0 = (uint64_t)&qword_1EA61D540;
  qword_1EA61D5E8 = (uint64_t)&unk_1EA61D5F8;
  qword_1EA61D5F0 = 0x800000000;
  qword_1EA61D778 = (uint64_t)&unk_1F262BAE8;
  qword_1EA61D790 = (uint64_t)&qword_1EA61D778;
  sub_1CD68EE60(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EA61D540);
}

void sub_1CD68EE60(long long *a1, uint64_t a2, _WORD *a3, int **a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EA61D540, "asan-use-after-return", 0x15uLL);
  xmmword_1EA61D560 = *a1;
  sub_1CD68EF7C(*(void *)a2, *(_DWORD *)(a2 + 8));
  word_1EA61D54A = (32 * (*a3 & 3)) | word_1EA61D54A & 0xFF9F;
  long long v8 = *a4;
  dword_1EA61D5C0 = **a4;
  byte_1EA61D5D4 = 1;
  dword_1EA61D5D0 = *v8;
}

void sub_1CD68EF04()
{
}

void *sub_1CD68EF18()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1F262BAE8;
  return result;
}

void sub_1CD68EF50(uint64_t a1, void *a2)
{
  *a2 = &unk_1F262BAE8;
}

void sub_1CD68EF7C(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = a1;
    uint64_t v3 = a1 + 40 * a2;
    do
    {
      sub_1CD68EFC8(*(unsigned __int8 **)v2, *(void *)(v2 + 8), *(_DWORD *)(v2 + 16), *(void *)(v2 + 24), *(void *)(v2 + 32));
      v2 += 40;
    }
    while (v2 != v3);
  }
}

void sub_1CD68EFC8(unsigned __int8 *a1, size_t a2, int a3, uint64_t a4, uint64_t a5)
{
  v11[0] = a1;
  v11[1] = a2;
  v11[2] = a4;
  void v11[3] = a5;
  _DWORD v11[4] = &unk_1F262B7D0;
  char v13 = 1;
  int v12 = a3;
  unint64_t v7 = sub_1CD68F0BC((unint64_t)v11);
  uint64_t v8 = qword_1EA61D5E8 + 48 * qword_1EA61D5F0;
  long long v9 = *(_OWORD *)(v7 + 16);
  *(_OWORD *)uint64_t v8 = *(_OWORD *)v7;
  *(_OWORD *)(v8 + 16) = v9;
  *(void *)(v8 + 32) = &unk_1F262B7F0;
  char v10 = *(unsigned char *)(v7 + 44);
  *(_DWORD *)(v8 + 40) = *(_DWORD *)(v7 + 40);
  *(unsigned char *)(v8 + 44) = v10;
  *(void *)(v8 + 32) = &unk_1F262B7D0;
  LODWORD(qword_1EA61D5F0) = qword_1EA61D5F0 + 1;
  llvm::cl::AddLiteralOption(qword_1EA61D5E0, a1, a2);
}

unint64_t sub_1CD68F0BC(unint64_t result)
{
  if (qword_1EA61D5F0 >= HIDWORD(qword_1EA61D5F0))
  {
    if (qword_1EA61D5E8 > result || qword_1EA61D5E8 + 48 * (unint64_t)qword_1EA61D5F0 <= result) {
      sub_1CD68F138();
    }
    sub_1CD68F138();
  }
  return result;
}

void sub_1CD68F138()
{
}

void sub_1CD68F230(long long *a1, _WORD *a2, const char **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EA61D370, 0, 0);
  xmmword_1EA61D3F0 = 0uLL;
  qword_1EA61D418 = 0;
  unk_1EA61D420 = 0;
  byte_1EA61D428 = 0;
  qword_1EA61D410 = 0;
  unk_1EA61D400 = 0;
  unk_1EA61D408 = &unk_1F2643C20;
  qword_1EA61D370 = (uint64_t)&unk_1F2643FD0;
  qword_1EA61D430 = (uint64_t)&unk_1F2643EA0;
  qword_1EA61D438 = (uint64_t)&unk_1F25F6428;
  qword_1EA61D450 = (uint64_t)&qword_1EA61D438;
  sub_1CD68F32C(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EA61D370);
}

void sub_1CD68F32C(long long *a1, _WORD *a2, const char **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EA61D370, "asan-memory-access-callback-prefix", 0x22uLL);
  xmmword_1EA61D390 = *a1;
  word_1EA61D37A = (32 * (*a2 & 3)) | word_1EA61D37A & 0xFF9F;
  unsigned int v6 = *a3;

  sub_1CD68F3AC(v6);
}

void sub_1CD68F3AC(const char *a1)
{
  std::string::size_type v2 = strlen(a1);
  std::string::__init(&__str, a1, v2);
  std::string::operator=((std::string *)&xmmword_1EA61D3F0, &__str);
  byte_1EA61D428 = 1;
  std::string::operator=((std::string *)&qword_1EA61D410, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_1CD68F424(long long *a1, _WORD *a2, int **a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EA61D2A8, 0, 0);
  xmmword_1EA61D328 = 0u;
  *(_OWORD *)&qword_1EA61D338 = 0u;
  *((void *)&xmmword_1EA61D328 + 1) = &unk_1F261F710;
  qword_1EA61D2A8 = (uint64_t)&unk_1F261F6A8;
  qword_1EA61D348 = (uint64_t)&unk_1F2643E10;
  qword_1EA61D350 = (uint64_t)&unk_1F261F7D0;
  qword_1EA61D368 = (uint64_t)&qword_1EA61D350;
  llvm::cl::Option::setArgStr(v6, "asan-mapping-offset", 0x13uLL);
  xmmword_1EA61D2C8 = *a1;
  word_1EA61D2B2 = (32 * (*a2 & 3)) | word_1EA61D2B2 & 0xFF9F;
  *(void *)&xmmword_1EA61D328 = **a3;
  byte_1EA61D340 = 1;
  qword_1EA61D338 = xmmword_1EA61D328;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EA61D2A8);
}

void sub_1CD68F550(__n128 *a1, _WORD *a2, char **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EA61C768, 0, 0);
  byte_1EA61C7E8 = 0;
  qword_1EA61C7F0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EA61C7F8 = 0;
  qword_1EA61C768 = (uint64_t)&unk_1F26440A0;
  qword_1EA61C800 = (uint64_t)&unk_1F2643CC0;
  qword_1EA61C808 = (uint64_t)&unk_1F25EDE78;
  qword_1EA61C820 = (uint64_t)&qword_1EA61C808;
  sub_1CD68F640(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EA61C768);
}

__n128 sub_1CD68F640(__n128 *a1, _WORD *a2, char **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EA61C768, "asan-opt", 8uLL);
  __n128 result = *a1;
  xmmword_1EA61C788 = (__int128)*a1;
  word_1EA61C772 = (32 * (*a2 & 3)) | word_1EA61C772 & 0xFF9F;
  unint64_t v7 = *a3;
  byte_1EA61C7E8 = **a3;
  byte_1EA61C7F9 = 1;
  byte_1EA61C7F8 = *v7;
  return result;
}

void sub_1CD68F6C8(__n128 *a1, _WORD *a2, char **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EA61C8E8, 0, 0);
  byte_1EA61C968 = 0;
  qword_1EA61C970 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EA61C978 = 0;
  qword_1EA61C8E8 = (uint64_t)&unk_1F26440A0;
  qword_1EA61C980 = (uint64_t)&unk_1F2643CC0;
  qword_1EA61C988 = (uint64_t)&unk_1F25EDE78;
  qword_1EA61C9A0 = (uint64_t)&qword_1EA61C988;
  sub_1CD68F7B8(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EA61C8E8);
}

__n128 sub_1CD68F7B8(__n128 *a1, _WORD *a2, char **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EA61C8E8, "asan-opt-same-temp", 0x12uLL);
  __n128 result = *a1;
  xmmword_1EA61C908 = (__int128)*a1;
  word_1EA61C8F2 = (32 * (*a2 & 3)) | word_1EA61C8F2 & 0xFF9F;
  unint64_t v7 = *a3;
  byte_1EA61C968 = **a3;
  byte_1EA61C979 = 1;
  byte_1EA61C978 = *v7;
  return result;
}

void sub_1CD68F840(long long *a1, _WORD *a2, int **a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EA61CBE8, 0, 0);
  dword_1EA61CC68 = 0;
  qword_1EA61CC70 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EA61CC78 = 0;
  qword_1EA61CBE8 = (uint64_t)&unk_1F2643F00;
  qword_1EA61CC80 = (uint64_t)&unk_1F2643DB0;
  qword_1EA61CC88 = (uint64_t)&unk_1F25EA168;
  qword_1EA61CCA0 = (uint64_t)&qword_1EA61CC88;
  llvm::cl::Option::setArgStr(v6, "asan-force-experiment", 0x15uLL);
  xmmword_1EA61CC08 = *a1;
  word_1EA61CBF2 = (32 * (*a2 & 3)) | word_1EA61CBF2 & 0xFF9F;
  dword_1EA61CC68 = **a3;
  byte_1EA61CC7C = 1;
  dword_1EA61CC78 = dword_1EA61CC68;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EA61CBE8);
}

void sub_1CD68F968(long long *a1, uint64_t a2, int **a3, _WORD *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EA61D798, 0, 0);
  dword_1EA61D818 = 0;
  qword_1EA61D820 = (uint64_t)&unk_1F262B8C8;
  *(void *)&dword_1EA61D828 = 0;
  qword_1EA61D798 = (uint64_t)&unk_1F262B810;
  qword_1EA61D830 = (uint64_t)&unk_1F262B878;
  qword_1EA61D838 = (uint64_t)&qword_1EA61D798;
  qword_1EA61D840 = (uint64_t)&unk_1EA61D850;
  qword_1EA61D848 = 0x800000000;
  qword_1EA61D9D0 = (uint64_t)&unk_1F262BB30;
  qword_1EA61D9E8 = (uint64_t)&qword_1EA61D9D0;
  sub_1CD68FA7C(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EA61D798);
}

void sub_1CD68FA7C(long long *a1, uint64_t a2, int **a3, _WORD *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EA61D798, "asan-destructor-kind", 0x14uLL);
  xmmword_1EA61D7B8 = *a1;
  sub_1CD68FB98(*(void *)a2, *(_DWORD *)(a2 + 8));
  uint64_t v8 = *a3;
  dword_1EA61D818 = **a3;
  byte_1EA61D82C = 1;
  dword_1EA61D828 = *v8;
  word_1EA61D7A2 = (32 * (*a4 & 3)) | word_1EA61D7A2 & 0xFF9F;
}

void sub_1CD68FB20()
{
}

void *sub_1CD68FB34()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1F262BB30;
  return result;
}

void sub_1CD68FB6C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F262BB30;
}

void sub_1CD68FB98(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = a1;
    uint64_t v3 = a1 + 40 * a2;
    do
    {
      sub_1CD68FBE4(*(unsigned __int8 **)v2, *(void *)(v2 + 8), *(_DWORD *)(v2 + 16), *(void *)(v2 + 24), *(void *)(v2 + 32));
      v2 += 40;
    }
    while (v2 != v3);
  }
}

void sub_1CD68FBE4(unsigned __int8 *a1, size_t a2, int a3, uint64_t a4, uint64_t a5)
{
  v11[0] = a1;
  v11[1] = a2;
  v11[2] = a4;
  void v11[3] = a5;
  _DWORD v11[4] = &unk_1F262B8C8;
  char v13 = 1;
  int v12 = a3;
  unint64_t v7 = sub_1CD68FCD8((unint64_t)v11);
  uint64_t v8 = qword_1EA61D840 + 48 * qword_1EA61D848;
  long long v9 = *(_OWORD *)(v7 + 16);
  *(_OWORD *)uint64_t v8 = *(_OWORD *)v7;
  *(_OWORD *)(v8 + 16) = v9;
  *(void *)(v8 + 32) = &unk_1F262B8E8;
  char v10 = *(unsigned char *)(v7 + 44);
  *(_DWORD *)(v8 + 40) = *(_DWORD *)(v7 + 40);
  *(unsigned char *)(v8 + 44) = v10;
  *(void *)(v8 + 32) = &unk_1F262B8C8;
  LODWORD(qword_1EA61D848) = qword_1EA61D848 + 1;
  llvm::cl::AddLiteralOption(qword_1EA61D838, a1, a2);
}

unint64_t sub_1CD68FCD8(unint64_t result)
{
  if (qword_1EA61D848 >= HIDWORD(qword_1EA61D848))
  {
    if (qword_1EA61D840 > result || qword_1EA61D840 + 48 * (unint64_t)qword_1EA61D848 <= result) {
      sub_1CD68FD54();
    }
    sub_1CD68FD54();
  }
  return result;
}

void sub_1CD68FD54()
{
}

void sub_1CD68FE4C(__n128 *a1, _WORD *a2, int **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EA61CFA8, 0, 0);
  dword_1EA61D028 = 0;
  qword_1EA61D030 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EA61D038 = 0;
  qword_1EA61CFA8 = (uint64_t)&unk_1F2643F68;
  qword_1EA61D040 = (uint64_t)&unk_1F2643D20;
  qword_1EA61D048 = (uint64_t)&unk_1F25F7480;
  qword_1EA61D060 = (uint64_t)&qword_1EA61D048;
  sub_1CD68FF3C(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EA61CFA8);
}

__n128 sub_1CD68FF3C(__n128 *a1, _WORD *a2, int **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EA61CFA8, "asan-debug", 0xAuLL);
  __n128 result = *a1;
  xmmword_1EA61CFC8 = (__int128)*a1;
  word_1EA61CFB2 = (32 * (*a2 & 3)) | word_1EA61CFB2 & 0xFF9F;
  unint64_t v7 = *a3;
  dword_1EA61D028 = **a3;
  byte_1EA61D03C = 1;
  dword_1EA61D038 = *v7;
  return result;
}

void sub_1CD68FFC4(__n128 *a1, _WORD *a2, int **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EA61D068, 0, 0);
  dword_1EA61D0E8 = 0;
  qword_1EA61D0F0 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EA61D0F8 = 0;
  qword_1EA61D068 = (uint64_t)&unk_1F2643F68;
  qword_1EA61D100 = (uint64_t)&unk_1F2643D20;
  qword_1EA61D108 = (uint64_t)&unk_1F25F7480;
  qword_1EA61D120 = (uint64_t)&qword_1EA61D108;
  sub_1CD6900B4(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EA61D068);
}

__n128 sub_1CD6900B4(__n128 *a1, _WORD *a2, int **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EA61D068, "asan-debug-stack", 0x10uLL);
  __n128 result = *a1;
  xmmword_1EA61D088 = (__int128)*a1;
  word_1EA61D072 = (32 * (*a2 & 3)) | word_1EA61D072 & 0xFF9F;
  unint64_t v7 = *a3;
  dword_1EA61D0E8 = **a3;
  byte_1EA61D0FC = 1;
  dword_1EA61D0F8 = *v7;
  return result;
}

void sub_1CD69013C(_WORD *a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EA61D458, 0, 0);
  qword_1EA61D4D8 = 0;
  qword_1EA61D4E0 = 0;
  qword_1EA61D500 = 0;
  unk_1EA61D508 = 0;
  byte_1EA61D510 = 0;
  qword_1EA61D4F8 = 0;
  unk_1EA61D4E8 = 0;
  unk_1EA61D4F0 = &unk_1F2643C20;
  qword_1EA61D458 = (uint64_t)&unk_1F2643FD0;
  qword_1EA61D518 = (uint64_t)&unk_1F2643EA0;
  qword_1EA61D520 = (uint64_t)&unk_1F25F6428;
  qword_1EA61D538 = (uint64_t)&qword_1EA61D520;
  llvm::cl::Option::setArgStr(v4, "asan-debug-func", 0xFuLL);
  word_1EA61D462 = (32 * (*a1 & 3)) | word_1EA61D462 & 0xFF9F;
  xmmword_1EA61D478 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EA61D458);
}

void *sub_1CD690254(uint64_t a1, uint64_t *a2)
{
  unint64_t v7 = 0;
  char v4 = sub_1CD4A7E9C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD6902D0(a1, a2, v7);
    *uint64_t v5 = *a2;
    *(_OWORD *)(v5 + 5) = 0u;
    *(_OWORD *)(v5 + 3) = 0u;
    *(_OWORD *)(v5 + 1) = 0u;
  }
  return v5;
}

void *sub_1CD6902D0(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD690384(a1, v6);
  uint64_t v8 = 0;
  sub_1CD4A7E9C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD690384(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  __n128 result = operator new(56 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD69045C(a1, v4, v4 + 56 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 56 * v10;
    do
    {
      void *result = -4096;
      result += 7;
      v11 -= 56;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD69045C(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 56 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 7;
      v8 -= 56;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      char v13 = 0;
      __n128 result = sub_1CD4A7E9C(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v13);
      uint64_t v10 = v13;
      *char v13 = *(void *)a2;
      long long v11 = *(_OWORD *)(a2 + 8);
      long long v12 = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(v10 + 5) = *(_OWORD *)(a2 + 40);
      *(_OWORD *)(v10 + 3) = v12;
      *(_OWORD *)(v10 + 1) = v11;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 56;
  }
  return result;
}

char *sub_1CD690528()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::ModuleAddressSanitizerPass]";
  v10[1] = 82;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x52) {
    uint64_t v1 = 82;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_14[v1];
  unint64_t v3 = 82 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  __n128 result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

void llvm::BoundsCheckingPass::run()
{
}

void llvm::createBoundsCheckingLegacyPass(llvm *this)
{
}

uint64_t sub_1CD6906F0(uint64_t a1, uint64_t **a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = **a2;
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x200000000;
  *(void *)(a1 + 64) = v5;
  *(void *)(a1 + 72) = a1 + 120;
  *(void *)(a1 + 80) = a1 + 136;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(_WORD *)(a1 + 100) = 512;
  *(unsigned char *)(a1 + 102) = 7;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  uint64_t v6 = *(void *)(a4 + 8);
  *(void *)(a1 + 120) = &unk_1F2602158;
  *(void *)(a1 + 128) = v6;
  *(void *)(a1 + 136) = &unk_1F2617008;
  sub_1CBF5385C(a1, (uint64_t)a2, a3);
  return a1;
}

void sub_1CD69079C(long long *a1)
{
  uint64_t v2 = sub_1CB883A14((uint64_t)qword_1EBCE6E70, 0, 0);
  byte_1EBCE6EF0 = 0;
  qword_1EBCE6EF8 = (uint64_t)&unk_1F25EDE58;
  unk_1EBCE6F00 = 0;
  qword_1EBCE6E70[0] = (uint64_t)&unk_1F26440A0;
  qword_1EBCE6F08 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCE6F10 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCE6F28 = (uint64_t)&qword_1EBCE6F10;
  llvm::cl::Option::setArgStr(v2, "bounds-checking-single-trap", 0x1BuLL);
  xmmword_1EBCE6E90 = *a1;

  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EBCE6E70);
}

void llvm::createCGProfileLegacyPass(llvm *this)
{
}

void llvm::CGProfilePass::run()
{
}

uint64_t sub_1CD690978(uint64_t *a1, unint64_t a2)
{
  sub_1CD5DF87C(a1);
  uint64_t v4 = (char *)a1[10];
  uint64_t v5 = (char *)a1[11];
  if (v5 != v4)
  {
    unint64_t v6 = (v5 - v4) >> 4;
    do
    {
      unint64_t v7 = v6 >> 1;
      uint64_t v8 = &v4[16 * (v6 >> 1)];
      unint64_t v10 = *(void *)v8;
      uint64_t v9 = v8 + 16;
      v6 += ~(v6 >> 1);
      if (v10 < a2) {
        uint64_t v4 = v9;
      }
      else {
        unint64_t v6 = v7;
      }
    }
    while (v6);
  }
  if (v4 == v5 || *(void *)v4 != a2) {
    return 0;
  }
  else {
    return *((void *)v4 + 1);
  }
}

uint64_t sub_1CD6909F8(uint64_t a1, long long *a2)
{
  long long v14 = *a2;
  v15[0] = 0;
  sub_1CD690AD4((uint64_t)&v12, a1, (uint64_t *)&v14, v15);
  uint64_t v4 = v12;
  if (v13)
  {
    long long v10 = *a2;
    uint64_t v11 = 0;
    unint64_t v5 = *(void *)(a1 + 32);
    if (v5 >= *(void *)(a1 + 40))
    {
      unint64_t v6 = sub_1CBF56DE8((void **)(a1 + 24), (uint64_t)&v10);
    }
    else
    {
      *(_OWORD *)unint64_t v5 = v10;
      *(void *)(v5 + 16) = v11;
      unint64_t v6 = (char *)(v5 + 24);
    }
    *(void *)(a1 + 32) = v6;
    uint64_t v8 = *(void *)(a1 + 24);
    unsigned int v7 = -1431655765 * ((unint64_t)&v6[-v8] >> 3) - 1;
    *(_DWORD *)(v4 + 16) = v7;
  }
  else
  {
    unsigned int v7 = *(_DWORD *)(v12 + 16);
    uint64_t v8 = *(void *)(a1 + 24);
  }
  return v8 + 24 * v7 + 16;
}

uint64_t sub_1CD690AD4(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CD553C1C(*(void *)a2, *(_DWORD *)(a2 + 16), *a3, a3[1], &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD57E8D4(a2, a3, v12);
    uint64_t v9 = (void *)result;
    *(_OWORD *)uint64_t result = *(_OWORD *)a3;
    *(_DWORD *)(result + 16) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 24 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

void llvm::createControlHeightReductionLegacyPass(llvm *this)
{
}

void llvm::ControlHeightReductionPass::run()
{
}

void *sub_1CD690D68(uint64_t a1, uint64_t *a2)
{
  unsigned int v7 = 0;
  char v4 = sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  unint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CD40EB88(a1, a2, v7);
    *unint64_t v5 = *a2;
    *((_DWORD *)v5 + 2) = -1;
  }
  return v5;
}

uint64_t sub_1CD690DDC@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  char v10 = 0;
  uint64_t result = sub_1CBFE4194((uint64_t *)a1, a2, &v10);
  unsigned int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD690E64(a1, (uint64_t)a2, a2, v10);
    unsigned int v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

void *sub_1CD690E64(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD690F18(a1, v7);
  uint64_t v9 = 0;
  sub_1CBFE4194((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD690F18(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD690FE4(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD690FE4(uint64_t result, void *a2, void *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v9 = 0;
      uint64_t result = sub_1CBFE4194((uint64_t *)v5, a2, &v9);
      *uint64_t v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD691094@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CBF5FB7C((uint64_t *)a1, a2, &v10);
  int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CBF5FC18(a1, (uint64_t)a2, a2, v10);
    int v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD69111C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CD4678E0((uint64_t *)a2, a3, &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD6911A8(a2, v12, a3, a4);
    uint64_t v9 = (void *)result;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 32 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

void *sub_1CD6911A8(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t result = sub_1CD691218(a1, (uint64_t)a3, a3, a2);
  void *result = *a3;
  result[1] = *a4;
  int v7 = a4 + 1;
  uint64_t v8 = a4[1];
  result[2] = v8;
  uint64_t v9 = result + 2;
  uint64_t v10 = a4[2];
  result[3] = v10;
  if (v10)
  {
    *(void *)(v8 + 16) = v9;
    *a4 = v7;
    *int v7 = 0;
    a4[2] = 0;
  }
  else
  {
    result[1] = v9;
  }
  return result;
}

void *sub_1CD691218(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD6912C8(a1, v7);
  uint64_t v9 = 0;
  sub_1CD4678E0((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD6912C8(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD691394(a1, v4, &v4[4 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      void *result = -4096;
      result += 4;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

void sub_1CD691394(uint64_t a1, void *a2, void *a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v5 = *(unsigned int *)(a1 + 16);
  if (v5)
  {
    unint64_t v6 = *(void **)a1;
    uint64_t v7 = 32 * v5;
    do
    {
      *unint64_t v6 = -4096;
      v6 += 4;
      v7 -= 32;
    }
    while (v7);
  }
  if (a2 != a3)
  {
    unsigned int v8 = a2 + 2;
    do
    {
      if ((*(v8 - 2) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unint64_t v15 = 0;
        sub_1CD4678E0((uint64_t *)a1, v8 - 2, &v15);
        uint64_t v10 = v15;
        void *v15 = *(v8 - 2);
        v10[1] = *(v8 - 1);
        uint64_t v11 = (void *)*v8;
        uint64_t v10[2] = *v8;
        uint64_t v12 = v10 + 2;
        uint64_t v13 = v8[1];
        v10[3] = v13;
        if (v13)
        {
          long long v14 = 0;
          v11[2] = v12;
          *(v8 - 1) = v8;
          void *v8 = 0;
          v8[1] = 0;
        }
        else
        {
          v10[1] = v12;
          long long v14 = (void *)*v8;
        }
        ++*(_DWORD *)(a1 + 8);
        sub_1CB833A08((uint64_t)(v8 - 1), v14);
      }
      uint64_t v9 = v8 + 2;
      v8 += 4;
    }
    while (v9 != a3);
  }
}

uint64_t *sub_1CD691490(void **a1, void *a2, unint64_t *a3, uint64_t *a4)
{
  unint64_t v6 = (uint64_t **)sub_1CD4F2C50(a1, a2, &v14, &v13, a3);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    uint64_t v9 = v6;
    uint64_t v7 = (uint64_t *)operator new(0x28uLL);
    _OWORD v7[4] = *a4;
    uint64_t v10 = v14;
    *uint64_t v7 = 0;
    v7[1] = 0;
    void v7[2] = v10;
    *uint64_t v9 = v7;
    uint64_t v11 = (void *)**a1;
    uint64_t v12 = v7;
    if (v11)
    {
      *a1 = v11;
      uint64_t v12 = *v9;
    }
    sub_1CB8358B8(a1[1], v12);
    a1[2] = (void *)((char *)a1[2] + 1);
  }
  return v7;
}

unint64_t sub_1CD691540(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 24 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      sub_1CD6915AC();
    }
    sub_1CD6915AC();
  }
  return a2;
}

void sub_1CD6915AC()
{
}

void *sub_1CD69161C(uint64_t a1, uint64_t *a2)
{
  unsigned int v8 = 0;
  char v4 = sub_1CD41F538(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  uint64_t v5 = v8;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD69168C(a1, a2, v8);
    uint64_t v7 = *a2;
    uint64_t v5[2] = 0;
    v5[3] = 0;
    *uint64_t v5 = v7;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD69168C(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD691740(a1, v6);
  unsigned int v8 = 0;
  sub_1CD41F538(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD691740(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD69180C(a1, v4, v4 + 32 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      void *result = -4096;
      result += 4;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD69180C(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 32 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 4;
      v8 -= 32;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v12 = 0;
      sub_1CD41F538(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v12);
      uint64_t v10 = v12;
      uint64_t v11 = *(void *)a2;
      *(_DWORD *)(v12 + 24) = 0;
      *(void *)(v10 + 8) = 0;
      *(void *)(v10 + 16) = 0;
      *(void *)uint64_t v10 = v11;
      *(void *)(v10 + 8) = *(void *)(a2 + 8);
      *(void *)(a2 + 8) = 0;
      *(_DWORD *)(v10 + 16) = *(_DWORD *)(a2 + 16);
      *(_DWORD *)(a2 + 16) = 0;
      LODWORD(v11) = *(_DWORD *)(v10 + 20);
      *(_DWORD *)(v10 + 20) = *(_DWORD *)(a2 + 20);
      *(_DWORD *)(a2 + 20) = v11;
      LODWORD(v11) = *(_DWORD *)(v10 + 24);
      *(_DWORD *)(v10 + 24) = *(_DWORD *)(a2 + 24);
      *(_DWORD *)(a2 + 24) = v11;
      ++*(_DWORD *)(v5 + 8);
      uint64_t result = MEMORY[0x1D25D9CD0](0, 8);
    }
    a2 += 32;
  }
  return result;
}

uint64_t sub_1CD691908(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = a2;
  if (sub_1CD4AC5C0(a1, &v7, &v6)) {
    return v6;
  }
  uint64_t v4 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    uint64_t v5 = 8;
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 16);
  }
  return v4 + 8 * v5;
}

void sub_1CD69196C(uint64_t **a1, _WORD *a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE7120, 0, 0);
  xmmword_1EBCE71A0 = 0u;
  *(_OWORD *)&qword_1EBCE71B0 = 0u;
  *((void *)&xmmword_1EBCE71A0 + 1) = &unk_1F2601200;
  qword_1EBCE7120 = (uint64_t)&unk_1F2601198;
  qword_1EBCE71C0 = (uint64_t)&unk_1F2643E40;
  qword_1EBCE71C8 = (uint64_t)&unk_1F2601220;
  qword_1EBCE71E0 = (uint64_t)&qword_1EBCE71C8;
  sub_1CD691A60(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE7120);
}

__n128 sub_1CD691A60(uint64_t **a1, _WORD *a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE7120, "chr-bias-threshold", 0x12uLL);
  uint64_t v6 = *a1;
  *(void *)&xmmword_1EBCE71A0 = **a1;
  byte_1EBCE71B8 = 1;
  qword_1EBCE71B0 = *v6;
  word_1EBCE712A = (32 * (*a2 & 3)) | word_1EBCE712A & 0xFF9F;
  __n128 result = *a3;
  xmmword_1EBCE7140 = (__int128)*a3;
  return result;
}

void sub_1CD691AE8(const char **a1, _WORD *a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE71E8, 0, 0);
  qword_1EBCE7268 = 0;
  qword_1EBCE7270 = 0;
  qword_1EBCE7290 = 0;
  unk_1EBCE7298 = 0;
  byte_1EBCE72A0 = 0;
  qword_1EBCE7288 = 0;
  unk_1EBCE7278 = 0;
  unk_1EBCE7280 = &unk_1F2643C20;
  qword_1EBCE71E8 = (uint64_t)&unk_1F2643FD0;
  qword_1EBCE72A8 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCE72B0 = (uint64_t)&unk_1F25F6428;
  qword_1EBCE72C8 = (uint64_t)&qword_1EBCE72B0;
  sub_1CD691BE4(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE71E8);
}

__n128 sub_1CD691BE4(const char **a1, _WORD *a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE71E8, "chr-module-list", 0xFuLL);
  sub_1CBAD7D28(a1, (uint64_t)&qword_1EBCE71E8);
  word_1EBCE71F2 = (32 * (*a2 & 3)) | word_1EBCE71F2 & 0xFF9F;
  __n128 result = *a3;
  xmmword_1EBCE7208 = (__int128)*a3;
  return result;
}

void sub_1CD691C5C(const char **a1, _WORD *a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE72D0, 0, 0);
  qword_1EBCE7350 = 0;
  qword_1EBCE7358 = 0;
  qword_1EBCE7378 = 0;
  unk_1EBCE7380 = 0;
  byte_1EBCE7388 = 0;
  qword_1EBCE7370 = 0;
  unk_1EBCE7360 = 0;
  unk_1EBCE7368 = &unk_1F2643C20;
  qword_1EBCE72D0 = (uint64_t)&unk_1F2643FD0;
  qword_1EBCE7390 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCE7398 = (uint64_t)&unk_1F25F6428;
  qword_1EBCE73B0 = (uint64_t)&qword_1EBCE7398;
  sub_1CD691D58(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE72D0);
}

__n128 sub_1CD691D58(const char **a1, _WORD *a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE72D0, "chr-function-list", 0x11uLL);
  sub_1CBAD7D28(a1, (uint64_t)&qword_1EBCE72D0);
  word_1EBCE72DA = (32 * (*a2 & 3)) | word_1EBCE72DA & 0xFF9F;
  __n128 result = *a3;
  xmmword_1EBCE72F0 = (__int128)*a3;
  return result;
}

llvm::Value *StripPointerGEPsAndCasts(llvm::Value *a1)
{
  uint64_t v1 = a1;
  if (*(unsigned char *)(*(void *)a1 + 8) != 15) {
    return v1;
  }
  uint64_t v12 = v16;
  uint64_t v13 = v16;
  uint64_t v14 = 4;
  int v15 = 0;
  sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v12, (uint64_t)a1);
  uint64_t v3 = v12;
  unsigned int v2 = v13;
  while (1)
  {
    unsigned int v4 = *((unsigned __int8 *)v1 + 16);
    if (v4 == 62)
    {
LABEL_6:
      int v6 = *((_DWORD *)v1 + 5);
      if ((v6 & 0x40000000) != 0) {
        uint64_t v7 = (llvm::Value **)*((void *)v1 - 1);
      }
      else {
        uint64_t v7 = (llvm::Value **)((char *)v1 - 32 * (v6 & 0x7FFFFFF));
      }
      goto LABEL_15;
    }
    if (v4 == 5)
    {
      unsigned int v5 = *((unsigned __int16 *)v1 + 9);
      if (v5 == 34) {
        goto LABEL_6;
      }
    }
    else
    {
      unsigned int v5 = v4 - 28;
      if (v4 < 0x1C) {
        goto LABEL_12;
      }
    }
    if (v5 == 49) {
      break;
    }
LABEL_12:
    if (v4 == 1)
    {
      uint64_t v7 = (llvm::Value **)((char *)v1 - 32);
LABEL_15:
      uint64_t v1 = *v7;
    }
LABEL_16:
    sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v12, (uint64_t)v1);
    uint64_t v3 = v12;
    unsigned int v2 = v13;
    if (!v10) {
      goto LABEL_20;
    }
  }
  int v8 = *((_DWORD *)v1 + 5);
  if ((v8 & 0x40000000) != 0) {
    uint64_t v9 = (llvm::Value **)*((void *)v1 - 1);
  }
  else {
    uint64_t v9 = (llvm::Value **)((char *)v1 - 32 * (v8 & 0x7FFFFFF));
  }
  uint64_t v1 = *v9;
  if (*(unsigned char *)(*(void *)*v9 + 8) == 15) {
    goto LABEL_16;
  }
LABEL_20:
  if (v2 != v3) {
    free(v2);
  }
  return v1;
}

void llvm::createDataFlowSanitizerLegacyPassPass()
{
}

void llvm::DataFlowSanitizerPass::run(uint64_t *a1)
{
  sub_1CCAEA070((uint64_t)&v1, a1);
}

void sub_1CD692038(uint64_t a1, void *a2, void *a3)
{
  if (*(void *)(a1 + 16))
  {
    int v6 = *(uint64_t **)a1;
    uint64_t v7 = *(void *)(a1 + 8);
    *(void *)a1 = a1 + 8;
    *(void *)(v7 + 16) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 8) = 0;
    int v8 = v6[1] ? (uint64_t *)v6[1] : v6;
    if (v8)
    {
      uint64_t v12 = sub_1CD4F3428((uint64_t)v8);
      if (a2 != a3)
      {
        uint64_t v14 = a2;
        do
        {
          int v15 = v8;
          int v8 = v12;
          _DWORD v15[4] = v14[4];
          sub_1CD6741E0((uint64_t **)a1, v15);
          if (v12) {
            uint64_t v12 = sub_1CD4F3428((uint64_t)v12);
          }
          __int16 v16 = (void *)v14[1];
          if (v16)
          {
            do
            {
              a2 = v16;
              __int16 v16 = (void *)*v16;
            }
            while (v16);
          }
          else
          {
            do
            {
              a2 = (void *)v14[2];
              BOOL v11 = *a2 == (void)v14;
              uint64_t v14 = a2;
            }
            while (!v11);
          }
          if (!v8) {
            break;
          }
          uint64_t v14 = a2;
        }
        while (a2 != a3);
      }
      sub_1CB833A08(a1, v8);
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          uint64_t v12 = (uint64_t *)v12[2];
        }
        while (v12);
        sub_1CB833A08(a1, v13);
      }
    }
  }
  if (a2 != a3)
  {
    do
    {
      sub_1CD692198((uint64_t **)a1, a2[4]);
      uint64_t v9 = (void *)a2[1];
      if (v9)
      {
        do
        {
          char v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          char v10 = (void *)a2[2];
          BOOL v11 = *v10 == (void)a2;
          a2 = v10;
        }
        while (!v11);
      }
      a2 = v10;
    }
    while (v10 != a3);
  }
}

uint64_t *sub_1CD692198(uint64_t **a1, unint64_t a2)
{
  unsigned int v4 = (uint64_t *)operator new(0x28uLL);
  unsigned int v5 = v4;
  v4[4] = a2;
  int v6 = a1 + 1;
  uint64_t v7 = a1[1];
  if (v7)
  {
    do
    {
      while (1)
      {
        int v6 = (uint64_t **)v7;
        if (v7[4] <= a2) {
          break;
        }
        uint64_t v7 = (uint64_t *)*v7;
        int v8 = v6;
        if (!*v6) {
          goto LABEL_8;
        }
      }
      uint64_t v7 = (uint64_t *)v7[1];
    }
    while (v7);
    int v8 = v6 + 1;
  }
  else
  {
    int v8 = a1 + 1;
  }
LABEL_8:
  *unsigned int v4 = 0;
  v4[1] = 0;
  void v4[2] = (uint64_t)v6;
  uint64_t *v8 = v4;
  uint64_t v9 = (uint64_t *)**a1;
  if (v9)
  {
    *a1 = v9;
    unsigned int v5 = *v8;
  }
  __n128 result = sub_1CB8358B8(a1[1], v5);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

void *sub_1CD692240(uint64_t *a1, uint64_t *a2)
{
  int v8 = 0;
  char v4 = sub_1CD4678E0(a1, a2, &v8);
  unsigned int v5 = v8;
  if ((v4 & 1) == 0)
  {
    unsigned int v5 = sub_1CD691218((uint64_t)a1, (uint64_t)a2, a2, v8);
    uint64_t v7 = *a2;
    v5[3] = 0;
    uint64_t v5[2] = 0;
    *unsigned int v5 = v7;
    v5[1] = v5 + 2;
  }
  return v5;
}

void sub_1CD6922B0(long long *a1, _WORD *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCE7C08, 1, 0);
  qword_1EBCE7C88 = 0;
  unk_1EBCE7C90 = 0;
  qword_1EBCE7C98 = 0;
  unk_1EBCE7CA0 = 0;
  qword_1EBCE7C08 = (uint64_t)&unk_1F260A070;
  qword_1EBCE7CA8 = 0;
  unk_1EBCE7CB0 = 0;
  qword_1EBCE7CB8 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCE7CC0 = (uint64_t)&unk_1F260AC78;
  qword_1EBCE7CD8 = (uint64_t)&qword_1EBCE7CC0;
  llvm::cl::Option::setArgStr(v4, "dfsan-abilist", 0xDuLL);
  xmmword_1EBCE7C28 = *a1;
  word_1EBCE7C12 = (32 * (*a2 & 3)) | word_1EBCE7C12 & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE7C08);
}

void sub_1CD6923A4(__n128 *a1, _WORD *a2, char **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE7548, 0, 0);
  byte_1EBCE75C8 = 0;
  qword_1EBCE75D0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCE75D8 = 0;
  qword_1EBCE7548 = (uint64_t)&unk_1F26440A0;
  qword_1EBCE75E0 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCE75E8 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCE7600 = (uint64_t)&qword_1EBCE75E8;
  sub_1CD692494(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE7548);
}

__n128 sub_1CD692494(__n128 *a1, _WORD *a2, char **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE7548, "dfsan-combine-pointer-labels-on-store", 0x25uLL);
  __n128 result = *a1;
  xmmword_1EBCE7568 = (__int128)*a1;
  word_1EBCE7552 = (32 * (*a2 & 3)) | word_1EBCE7552 & 0xFF9F;
  uint64_t v7 = *a3;
  byte_1EBCE75C8 = **a3;
  byte_1EBCE75D9 = 1;
  byte_1EBCE75D8 = *v7;
  return result;
}

void sub_1CD69251C(long long *a1, _WORD *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCE7CE0, 1, 0);
  qword_1EBCE7D60 = 0;
  unk_1EBCE7D68 = 0;
  qword_1EBCE7D70 = 0;
  unk_1EBCE7D78 = 0;
  qword_1EBCE7CE0 = (uint64_t)&unk_1F260A070;
  qword_1EBCE7D80 = 0;
  unk_1EBCE7D88 = 0;
  qword_1EBCE7D90 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCE7D98 = (uint64_t)&unk_1F260AC78;
  qword_1EBCE7DB0 = (uint64_t)&qword_1EBCE7D98;
  llvm::cl::Option::setArgStr(v4, "dfsan-combine-taint-lookup-table", 0x20uLL);
  xmmword_1EBCE7D00 = *a1;
  word_1EBCE7CEA = (32 * (*a2 & 3)) | word_1EBCE7CEA & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE7CE0);
}

void sub_1CD692610(__n128 *a1, _WORD *a2, int **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE79C8, 0, 0);
  dword_1EBCE7A48 = 0;
  qword_1EBCE7A50 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCE7A58 = 0;
  qword_1EBCE79C8 = (uint64_t)&unk_1F2643F68;
  qword_1EBCE7A60 = (uint64_t)&unk_1F2643D20;
  qword_1EBCE7A68 = (uint64_t)&unk_1F25F7480;
  qword_1EBCE7A80 = (uint64_t)&qword_1EBCE7A68;
  sub_1CD692700(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE79C8);
}

__n128 sub_1CD692700(__n128 *a1, _WORD *a2, int **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE79C8, "dfsan-instrument-with-call-threshold", 0x24uLL);
  __n128 result = *a1;
  xmmword_1EBCE79E8 = (__int128)*a1;
  word_1EBCE79D2 = (32 * (*a2 & 3)) | word_1EBCE79D2 & 0xFF9F;
  uint64_t v7 = *a3;
  dword_1EBCE7A48 = **a3;
  byte_1EBCE7A5C = 1;
  dword_1EBCE7A58 = *v7;
  return result;
}

void llvm::GCOVOptions::getDefault(uint64_t a1@<X8>)
{
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_WORD *)a1 = 257;
  *(unsigned char *)(a1 + 6) = 0;
  *(unsigned char *)(a1 + 7) = byte_1EBD09318;
  uint64_t v2 = qword_1EBD09238;
  if (byte_1EBD09247 >= 0) {
    uint64_t v2 = byte_1EBD09247 & 0x7F;
  }
  if (v2 != 4)
  {
    int v6 = "Invalid -default-gcov-version: ";
    __int16 v7 = 259;
    __int16 v5 = 260;
    uint64_t v4 = &qword_1EBD09230;
    sub_1CD3E3950((uint64_t *)&v6, (uint64_t *)&v4, (uint64_t)v8);
    llvm::report_fatal_error((llvm *)v8, (const llvm::Twine *)1);
  }
  if (byte_1EBD09247 >= 0) {
    uint64_t v3 = &qword_1EBD09230;
  }
  else {
    uint64_t v3 = (uint64_t *)qword_1EBD09230;
  }
  *(_DWORD *)(a1 + 2) = *(_DWORD *)v3;
}

void llvm::createGCOVProfilerPass()
{
}

void llvm::GCOVProfilerPass::run(uint64_t a1)
{
  v1[50] = *MEMORY[0x1E4F143B8];
  sub_1CCAFF7FC(v1, a1);
  llvm::AnalysisManager<llvm::Module>::getResultImpl();
}

uint64_t sub_1CD692A60(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void *sub_1CD692AA4(void *a1, uint64_t a2)
{
  *a1 = *(void *)a2;
  uint64_t v4 = (uint64_t)(a1 + 1);
  if (*(char *)(a2 + 31) < 0)
  {
    sub_1CB8BDF7C(v4, *(const void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 8);
    *(void *)(v4 + 16) = *(void *)(a2 + 24);
    *(_OWORD *)uint64_t v4 = v5;
  }
  int v6 = a1 + 4;
  if (*(char *)(a2 + 55) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v6, *(const void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 32);
    a1[6] = *(void *)(a2 + 48);
    *int v6 = v7;
  }
  return a1;
}

void sub_1CD692B28(void **a1)
{
  uint64_t v1 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = v1;
    if (v3 != v1)
    {
      do
        llvm::Regex::~Regex((llvm::Regex *)(v3 - 16));
      while (v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_1CD692B88(const char **a1, _WORD *a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBD091B0, 0, 0);
  qword_1EBD09230 = 0;
  qword_1EBD09238 = 0;
  qword_1EBD09258 = 0;
  unk_1EBD09260 = 0;
  byte_1EBD09268 = 0;
  qword_1EBD09250 = 0;
  unk_1EBD09240 = 0;
  unk_1EBD09248 = &unk_1F2643C20;
  qword_1EBD091B0 = (uint64_t)&unk_1F2643FD0;
  qword_1EBD09270 = (uint64_t)&unk_1F2643EA0;
  qword_1EBD09278 = (uint64_t)&unk_1F25F6428;
  qword_1EBD09290 = (uint64_t)&qword_1EBD09278;
  sub_1CD692C84(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBD091B0);
}

void sub_1CD692C84(const char **a1, _WORD *a2, _WORD *a3)
{
  word_1EBD091BA = word_1EBD091BA & 0xFF9F | (32 * (*a2 & 3));
  word_1EBD091BA = (8 * (*a3 & 3)) | word_1EBD091BA & 0xFFE7;
}

double llvm::MemProfilerPass::run@<D0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 40);
  int v11 = dword_1EBCE8220;
  int v12 = dword_1EBCE82E0;
  uint64_t v13 = -dword_1EBCE82E0;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  uint64_t v21 = 0;
  int v8 = *(llvm::IntegerType **)v4;
  unsigned int v9 = *(_DWORD *)(*(void *)(v4 + 504) + 4);
  uint64_t v10 = llvm::IntegerType::get(v8, (llvm::LLVMContext *)v9);
  if (sub_1CCB0CA38((uint64_t)&v8, (uint64_t ***)a1))
  {
    int v5 = 0;
    *(void *)(a2 + 88) = 0;
    *(_OWORD *)(a2 + 72) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(_OWORD *)(a2 + 40) = 0u;
    uint64_t v6 = a2 + 32;
    *(_OWORD *)(a2 + 24) = 0u;
  }
  else
  {
    *(void *)(a2 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
    uint64_t v6 = a2 + 32;
    int v5 = 1;
  }
  *(void *)a2 = v6;
  *(void *)(a2 + 8) = v6;
  *(_DWORD *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 20) = v5;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 48) = a2 + 80;
  *(void *)(a2 + 56) = a2 + 80;
  *(void *)&double result = 2;
  *(void *)(a2 + 64) = 2;
  *(_DWORD *)(a2 + 72) = 0;
  return result;
}

void llvm::ModuleMemProfilerPass::run(uint64_t a1, llvm::Module *a2)
{
  sub_1CCB0E0DC((uint64_t)__p, (uint64_t)a2);
  sub_1CCB0E184((uint64_t)__p, a2);
}

void llvm::createMemProfilerFunctionPass(llvm *this)
{
}

void llvm::createModuleMemProfilerLegacyPassPass(llvm *this)
{
}

void createProfileFileNameVar(llvm::Module *a1)
{
  uint64_t ModuleFlag = llvm::Module::getModuleFlag(a1, "MemProfProfileFilename", 0x16uLL);
  if (ModuleFlag && !*(unsigned char *)ModuleFlag)
  {
    uint64_t String = llvm::ConstantDataArray::getString(*(void *)a1, (char *)(*(void *)(ModuleFlag + 8) + 24), **(llvm::Type ***)(ModuleFlag + 8), 1);
    uint64_t v4 = operator new(0x78uLL);
    int v5 = (llvm::GlobalValue *)(v4 + 8);
    v4[13] = v4[13] & 0x38000000 | 1;
    *(void *)uint64_t v4 = 0;
    *((void *)v4 + 1) = 0;
    *((void *)v4 + 2) = 0;
    *((void *)v4 + 3) = v4 + 8;
    uint64_t v6 = *(llvm::PointerType **)String;
    __p[0] = "__memprof_profile_filename";
    __int16 v13 = 259;
    llvm::GlobalVariable::GlobalVariable((unint64_t *)v4 + 4, (uint64_t)a1, v6, 1, 4, (unint64_t)String, (const char **)__p, 0, 0, 0, 0);
    __int16 v10 = 260;
    unsigned int v9 = (char *)a1 + 216;
    llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)&v9);
    if (v14 > 9 || ((1 << v14) & 0x320) == 0)
    {
      int v7 = v4[16];
      v4[16] = v7 & 0xFFFFFFF0;
      if ((v7 & 0x30) != 0 && (llvm::GlobalValue::hasExternalWeakLinkage(v5) & 1) == 0) {
        v4[16] |= 0x4000u;
      }
      inserted = llvm::Module::getOrInsertComdat((uint64_t)a1, "__memprof_profile_filename", 0x1AuLL);
      llvm::GlobalObject::setComdat(v5, (llvm::Comdat *)inserted);
    }
    if (v12 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1CD693088(__n128 *a1, _WORD *a2, char **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE7DE0, 0, 0);
  byte_1EBCE7E60 = 0;
  qword_1EBCE7E68 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCE7E70 = 0;
  qword_1EBCE7DE0 = (uint64_t)&unk_1F26440A0;
  qword_1EBCE7E78 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCE7E80 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCE7E98 = (uint64_t)&qword_1EBCE7E80;
  sub_1CD693178(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE7DE0);
}

__n128 sub_1CD693178(__n128 *a1, _WORD *a2, char **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE7DE0, "memprof-guard-against-version-mismatch", 0x26uLL);
  __n128 result = *a1;
  xmmword_1EBCE7E00 = (__int128)*a1;
  word_1EBCE7DEA = (32 * (*a2 & 3)) | word_1EBCE7DEA & 0xFF9F;
  int v7 = *a3;
  byte_1EBCE7E60 = **a3;
  byte_1EBCE7E71 = 1;
  byte_1EBCE7E70 = *v7;
  return result;
}

void sub_1CD693200(long long *a1, _WORD *a2, const char **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE8620, 0, 0);
  qword_1EBCE86A0 = 0;
  qword_1EBCE86A8 = 0;
  qword_1EBCE86C8 = 0;
  unk_1EBCE86D0 = 0;
  byte_1EBCE86D8 = 0;
  qword_1EBCE86C0 = 0;
  unk_1EBCE86B0 = 0;
  unk_1EBCE86B8 = &unk_1F2643C20;
  qword_1EBCE8620 = (uint64_t)&unk_1F2643FD0;
  qword_1EBCE86E0 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCE86E8 = (uint64_t)&unk_1F25F6428;
  qword_1EBCE8700 = (uint64_t)&qword_1EBCE86E8;
  sub_1CD6932FC(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE8620);
}

void sub_1CD6932FC(long long *a1, _WORD *a2, const char **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE8620, "memprof-memory-access-callback-prefix", 0x25uLL);
  xmmword_1EBCE8640 = *a1;
  word_1EBCE862A = (32 * (*a2 & 3)) | word_1EBCE862A & 0xFF9F;
  uint64_t v6 = *a3;

  sub_1CD69337C(v6);
}

void sub_1CD69337C(const char *a1)
{
  std::string::size_type v2 = strlen(a1);
  std::string::__init(&__str, a1, v2);
  std::string::operator=((std::string *)&qword_1EBCE86A0, &__str);
  byte_1EBCE86D8 = 1;
  std::string::operator=((std::string *)&qword_1EBCE86C0, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_1CD6933F4(long long *a1, _WORD *a2, int **a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCE81A0, 0, 0);
  dword_1EBCE8220 = 0;
  qword_1EBCE8228 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCE8230 = 0;
  qword_1EBCE81A0 = (uint64_t)&unk_1F2643F68;
  qword_1EBCE8238 = (uint64_t)&unk_1F2643D20;
  qword_1EBCE8240 = (uint64_t)&unk_1F25F7480;
  qword_1EBCE8258 = (uint64_t)&qword_1EBCE8240;
  llvm::cl::Option::setArgStr(v6, "memprof-mapping-scale", 0x15uLL);
  xmmword_1EBCE81C0 = *a1;
  word_1EBCE81AA = (32 * (*a2 & 3)) | word_1EBCE81AA & 0xFF9F;
  dword_1EBCE8220 = **a3;
  byte_1EBCE8234 = 1;
  dword_1EBCE8230 = dword_1EBCE8220;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE81A0);
}

void sub_1CD69351C(long long *a1, _WORD *a2, int **a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCE8260, 0, 0);
  dword_1EBCE82E0 = 0;
  qword_1EBCE82E8 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCE82F0 = 0;
  qword_1EBCE8260 = (uint64_t)&unk_1F2643F68;
  qword_1EBCE82F8 = (uint64_t)&unk_1F2643D20;
  qword_1EBCE8300 = (uint64_t)&unk_1F25F7480;
  qword_1EBCE8318 = (uint64_t)&qword_1EBCE8300;
  llvm::cl::Option::setArgStr(v6, "memprof-mapping-granularity", 0x1BuLL);
  xmmword_1EBCE8280 = *a1;
  word_1EBCE826A = (32 * (*a2 & 3)) | word_1EBCE826A & 0xFF9F;
  dword_1EBCE82E0 = **a3;
  byte_1EBCE82F4 = 1;
  dword_1EBCE82F0 = dword_1EBCE82E0;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE8260);
}

void sub_1CD693644(__n128 *a1, _WORD *a2, int **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE83E0, 0, 0);
  dword_1EBCE8460 = 0;
  qword_1EBCE8468 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCE8470 = 0;
  qword_1EBCE83E0 = (uint64_t)&unk_1F2643F68;
  qword_1EBCE8478 = (uint64_t)&unk_1F2643D20;
  qword_1EBCE8480 = (uint64_t)&unk_1F25F7480;
  qword_1EBCE8498 = (uint64_t)&qword_1EBCE8480;
  sub_1CD693734(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE83E0);
}

__n128 sub_1CD693734(__n128 *a1, _WORD *a2, int **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE83E0, "memprof-debug", 0xDuLL);
  __n128 result = *a1;
  xmmword_1EBCE8400 = (__int128)*a1;
  word_1EBCE83EA = (32 * (*a2 & 3)) | word_1EBCE83EA & 0xFF9F;
  int v7 = *a3;
  dword_1EBCE8460 = **a3;
  byte_1EBCE8474 = 1;
  dword_1EBCE8470 = *v7;
  return result;
}

void llvm::MemorySanitizerPass::run(uint64_t a1, uint64_t a2)
{
  sub_1CCB0F6FC((uint64_t)v2, *(llvm::IntegerType ***)(a2 + 40), *(void *)a1, *(_DWORD *)(a1 + 8));
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

double llvm::ModuleMemorySanitizerPass::run@<D0>(unsigned char *a1@<X0>, llvm::Module *a2@<X1>, uint64_t a3@<X8>)
{
  if (*a1)
  {
    *(void *)(a3 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
    uint64_t v4 = a3 + 32;
    int v5 = 1;
  }
  else
  {
    void v7[3] = (uint64_t)a2;
    llvm::getOrCreateSanitizerCtorAndInitFunctions(a2, "msan.module_ctor", (const char *)0x10, "__msan_init", (const char *)0xB, 0, 0, v7);
    int v5 = 0;
    *(void *)(a3 + 88) = 0;
    *(_OWORD *)(a3 + 72) = 0u;
    *(_OWORD *)(a3 + 56) = 0u;
    *(_OWORD *)(a3 + 40) = 0u;
    uint64_t v4 = a3 + 32;
    *(_OWORD *)(a3 + 24) = 0u;
  }
  *(void *)a3 = v4;
  *(void *)(a3 + 8) = v4;
  *(_DWORD *)(a3 + 16) = 2;
  *(_DWORD *)(a3 + 20) = v5;
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 48) = a3 + 80;
  *(void *)(a3 + 56) = a3 + 80;
  *(void *)&double result = 2;
  *(void *)(a3 + 64) = 2;
  *(_DWORD *)(a3 + 72) = 0;
  return result;
}

llvm::raw_ostream *llvm::MemorySanitizerPass::printPipeline(uint64_t a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, char *, uint64_t), uint64_t a4)
{
  sub_1CD693AD0(a2, a3, a4);
  sub_1CB8E509C(a2, "<");
  if (*(unsigned char *)(a1 + 8)) {
    sub_1CB8E509C(a2, "recover;");
  }
  if (*(unsigned char *)a1) {
    sub_1CB8E509C(a2, "kernel;");
  }
  if (*(unsigned char *)(a1 + 9)) {
    sub_1CB8E509C(a2, "eager-checks;");
  }
  uint64_t v6 = sub_1CB8E509C(a2, "track-origins=");
  llvm::raw_ostream::operator<<(v6, *(int *)(a1 + 4));

  return sub_1CB8E509C(a2, ">");
}

llvm::raw_ostream *sub_1CD693AD0(llvm::raw_ostream *a1, uint64_t (*a2)(uint64_t, char *, uint64_t), uint64_t a3)
{
  uint64_t v6 = sub_1CD694D40();
  unsigned int v9 = (const void *)a2(a3, v6, v7);
  size_t v10 = v8;
  double result = (llvm::raw_ostream *)*((void *)a1 + 4);
  if (v8 <= *((void *)a1 + 3) - (void)result)
  {
    if (v8)
    {
      double result = (llvm::raw_ostream *)memcpy(result, v9, v8);
      *((void *)a1 + 4) += v10;
    }
  }
  else
  {
    return llvm::raw_ostream::write(a1, (const char *)v9, v8);
  }
  return result;
}

void llvm::createMemorySanitizerLegacyPassPass()
{
}

void *sub_1CD693BD0(void *result)
{
  result[1] = 0;
  v10[0] = 2;
  v10[1] = 0;
  uint64_t v11 = -4096;
  uint64_t v12 = 0;
  uint64_t v1 = *((unsigned int *)result + 4);
  if (v1)
  {
    std::string::size_type v2 = result;
    double result = v10;
    uint64_t v3 = *v2;
    uint64_t v4 = 48 * v1;
    int v5 = (void *)(*v2 + 16);
    do
    {
      uint64_t v6 = v10[0] & 6;
      *(v5 - 1) = v6;
      *int v5 = 0;
      uint64_t v7 = v11;
      v5[1] = v11;
      if (v7 != -8192 && v7 != -4096 && v7 != 0)
      {
        unint64_t v9 = v10[0] & 0xFFFFFFFFFFFFFFF8;
        *int v5 = *(void *)(v10[0] & 0xFFFFFFFFFFFFFFF8);
        *(void *)unint64_t v9 = v5 - 1;
        *(v5 - 1) = v9 | v6;
        if (*v5) {
          *(void *)*int v5 = *(void *)*v5 & 7 | (v3 + 16);
        }
      }
      *(v5 - 2) = &off_1F262C108;
      uint64_t v5[2] = v12;
      v5 += 6;
      v3 += 48;
      v4 -= 48;
    }
    while (v4);
    if (v11 != -8192 && v11 != -4096)
    {
      if (v11) {
        return llvm::ValueHandleBase::RemoveFromUseList(v10);
      }
    }
  }
  return result;
}

void sub_1CD693CF8(uint64_t a1)
{
  sub_1CC008720(v3, (void *)(a1 + 8));
  uint64_t v5 = *(void *)(a1 + 32);
  sub_1CD693E80(v5, v4);
  if (v4 != -8192 && v4 != -4096 && v4 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList(v3);
  }
}

void sub_1CD693D88(uint64_t a1, uint64_t a2)
{
  sub_1CC008720(v9, (void *)(a1 + 8));
  uint64_t v4 = *(int32x2_t **)(a1 + 32);
  void v8[2] = (uint64_t)&off_1F262C108;
  uint64_t v11 = v4;
  v7[0] = 0;
  if (sub_1CD45AE60((uint64_t)*v4, v4[2].i32[0], v10, v7)) {
    uint64_t v5 = v7[0];
  }
  else {
    uint64_t v5 = *(void *)v4 + 48 * v4[2].u32[0];
  }
  if (*(void *)v11 + 48 * v11[2].u32[0] != v5)
  {
    uint64_t v6 = *(void *)(v5 + 40);
    sub_1CD693F48(v11, v5);
    v8[0] = a2;
    v8[1] = v6;
    sub_1CD693FF4((uint64_t)v7, (uint64_t)v11, v8);
  }
  if (v10 != -8192 && v10 != -4096)
  {
    if (v10) {
      llvm::ValueHandleBase::RemoveFromUseList(v9);
    }
  }
}

int32x2_t sub_1CD693E80(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  if (sub_1CD45AE60(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v6))
  {
    uint64_t v4 = v6;
    v7[0] = 2;
    v7[1] = 0;
    uint64_t v8 = -8192;
    unint64_t v9 = 0;
    uint64_t v6 = &off_1F262C108;
    sub_1CBF62D84((unint64_t *)v4 + 1, v7);
    uint64_t v5 = v8;
    v4[4] = v9;
    if (v5 != -8192 && v5 != -4096)
    {
      if (v5) {
        llvm::ValueHandleBase::RemoveFromUseList(v7);
      }
    }
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + 8) = result;
  }
  return result;
}

int32x2_t sub_1CD693F48(int32x2_t *a1, uint64_t a2)
{
  v7[0] = 2;
  v7[1] = 0;
  uint64_t v8 = -8192;
  uint64_t v9 = 0;
  sub_1CBF62D84((unint64_t *)(a2 + 8), v7);
  uint64_t v4 = v8;
  *(void *)(a2 + 32) = v9;
  if (v4 != -8192 && v4 != -4096 && v4 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList(v7);
  }
  int32x2_t result = vadd_s32(a1[1], (int32x2_t)0x1FFFFFFFFLL);
  a1[1] = result;
  return result;
}

double sub_1CD693FF4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = *a3;
  uint64_t v7 = 2;
  v13[0] = 2;
  v13[1] = 0;
  uint64_t v14 = v6;
  if (v6 != -8192 && v6 != -4096 && v6 != 0)
  {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)v13);
    uint64_t v7 = v13[0];
    uint64_t v6 = v14;
  }
  uint64_t v15 = a2;
  unint64_t v17 = v7 & 6;
  long long v18 = 0;
  uint64_t v19 = v6;
  uint64_t v9 = a2;
  if (v6 != -8192)
  {
    BOOL v10 = v6 == -4096 || v6 == 0;
    uint64_t v9 = a2;
    if (!v10)
    {
      long long v18 = *(unint64_t **)(v7 & 0xFFFFFFFFFFFFFFF8);
      *(void *)(v7 & 0xFFFFFFFFFFFFFFF8) = &v17;
      unint64_t v17 = v7 & 0xFFFFFFFFFFFFFFFELL;
      if (v18) {
        *long long v18 = *v18 & 7 | (unint64_t)&v18;
      }
      uint64_t v9 = v15;
    }
  }
  long long v16 = &off_1F262C108;
  unint64_t v11 = a3[1];
  uint64_t v20 = v9;
  unint64_t v21 = v11;
  sub_1CD694184((uint64_t)&v22, a2, (uint64_t *)&v16, &v21);
  if (v19 != -8192 && v19 != -4096 && v19) {
    llvm::ValueHandleBase::RemoveFromUseList(&v17);
  }
  if (v14 != -8192 && v14 != -4096 && v14) {
    llvm::ValueHandleBase::RemoveFromUseList(v13);
  }
  double result = *(double *)&v22;
  *(_OWORD *)a1 = v22;
  *(unsigned char *)(a1 + 16) = v23;
  return result;
}

unint64_t sub_1CD694184(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t *a4)
{
  uint64_t v12 = 0;
  unint64_t result = sub_1CD45AE60(*(void *)a2, *(_DWORD *)(a2 + 16), a3[3], &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t v9 = (unint64_t *)sub_1CD69423C(a2, (uint64_t)a3, (uint64_t)v12);
    unint64_t result = sub_1CBF62D84(v9 + 1, a3 + 1);
    void v9[4] = a3[4];
    v9[5] = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 48 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1CD69423C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD6942F0(a1, v6);
  uint64_t v8 = 0;
  sub_1CD45AE60(*(void *)a1, *(_DWORD *)(a1 + 16), *(void *)(a2 + 24), &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*(void *)(a3 + 24) != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD6942F0(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  *(void *)a1 = operator new(48 * v8, (std::align_val_t)8uLL);
  if (v4)
  {
    sub_1CD6943B8(a1, v4, &v4[6 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }

  return sub_1CD693BD0((void *)a1);
}

void *sub_1CD6943B8(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  unint64_t result = sub_1CD693BD0((void *)a1);
  v15[0] = 2;
  v15[1] = 0;
  uint64_t v16 = -4096;
  uint64_t v17 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = &off_1F262C108;
  v11[0] = 2;
  v11[1] = 0;
  uint64_t v12 = -8192;
  if (a2 != a3)
  {
    do
    {
      uint64_t v7 = a2[3];
      if (v7 != v16 && v7 != v12)
      {
        uint64_t v18 = 0;
        sub_1CD45AE60(*(void *)a1, *(_DWORD *)(a1 + 16), v7, &v18);
        uint64_t v10 = v18;
        unint64_t result = (void *)sub_1CBF62D84((unint64_t *)(v18 + 8), a2 + 1);
        *(void *)(v10 + 32) = a2[4];
        *(void *)(v10 + 40) = a2[5];
        ++*(_DWORD *)(a1 + 8);
        uint64_t v7 = a2[3];
      }
      if (v7 != -8192 && v7 != -4096 && v7 != 0) {
        unint64_t result = llvm::ValueHandleBase::RemoveFromUseList(a2 + 1);
      }
      a2 += 6;
    }
    while (a2 != a3);
    if (v12 != -8192 && v12 != -4096 && v12) {
      unint64_t result = llvm::ValueHandleBase::RemoveFromUseList(v11);
    }
  }
  if (v16 != -8192 && v16 != -4096)
  {
    if (v16) {
      return llvm::ValueHandleBase::RemoveFromUseList(v15);
    }
  }
  return result;
}

unint64_t *sub_1CD694530(uint64_t a1, uint64_t a2)
{
  v7[0] = 2;
  v7[1] = 0;
  uint64_t v8 = a2;
  if (a2 != -8192 && a2 != -4096 && a2) {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)v7);
  }
  unint64_t v6 = &off_1F262C108;
  uint64_t v9 = a1;
  unsigned int v3 = sub_1CD6945E4(a1, (uint64_t *)&v6);
  if (v8 != -8192 && v8 != -4096 && v8 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList(v7);
  }
  return v3 + 5;
}

unint64_t *sub_1CD6945E4(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD45AE60(*(void *)a1, *(_DWORD *)(a1 + 16), a2[3], &v7);
  unint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = (unint64_t *)sub_1CD69423C(a1, (uint64_t)a2, (uint64_t)v7);
    sub_1CBF62D84(v5 + 1, a2 + 1);
    _OWORD v5[4] = a2[4];
    v5[5] = 0;
  }
  return v5;
}

llvm::PointerType *sub_1CD694668(uint64_t a1, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8[3] = *MEMORY[0x1E4F143B8];
  v8[0] = a3;
  v8[1] = a4;
  void v8[2] = a5;
  unint64_t v6 = (llvm::PointerType *)llvm::FunctionType::get(a2, (uint64_t)v8, 3, 0);
  return llvm::Module::getOrInsertFunction(a1, "__msan_set_origin", (const char *)0x11, v6, 0);
}

llvm::PointerType *sub_1CD694730(uint64_t a1, unsigned __int8 *a2, const char *a3, uint64_t **a4, uint64_t a5, uint64_t a6)
{
  void v11[2] = *MEMORY[0x1E4F143B8];
  v11[0] = a5;
  v11[1] = a6;
  uint64_t v9 = (llvm::PointerType *)llvm::FunctionType::get(a4, (uint64_t)v11, 2, 0);
  return llvm::Module::getOrInsertFunction(a1, a2, a3, v9, 0);
}

llvm::PointerType *sub_1CD6947F8(uint64_t a1, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8[3] = *MEMORY[0x1E4F143B8];
  v8[0] = a3;
  v8[1] = a4;
  void v8[2] = a5;
  unint64_t v6 = (llvm::PointerType *)llvm::FunctionType::get(a2, (uint64_t)v8, 3, 0);
  return llvm::Module::getOrInsertFunction(a1, "__msan_poison_alloca", (const char *)0x14, v6, 0);
}

llvm::PointerType *sub_1CD6948C0(uint64_t a1, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  void v9[4] = *MEMORY[0x1E4F143B8];
  v9[0] = a3;
  v9[1] = a4;
  void v9[2] = a5;
  void v9[3] = a6;
  uint64_t v7 = (llvm::PointerType *)llvm::FunctionType::get(a2, (uint64_t)v9, 4, 0);
  return llvm::Module::getOrInsertFunction(a1, "__msan_set_alloca_origin4", (const char *)0x19, v7, 0);
}

void *sub_1CD694988(void *result, unsigned int a2)
{
  if (a2)
  {
    uint64_t v11 = 2;
    uint64_t v12 = 0;
    uint64_t v13 = -4096;
    uint64_t v14 = 0;
    uint64_t v9 = 0;
    uint64_t v10 = &off_1F262C108;
    uint64_t v6 = 2;
    uint64_t v7 = 0;
    uint64_t v8 = -8192;
    uint64_t v2 = 48 * a2;
    unsigned int v3 = result + 3;
    do
    {
      uint64_t v4 = *v3;
      if (*v3 != -8192 && v4 != -4096 && v4 != 0) {
        unint64_t result = llvm::ValueHandleBase::RemoveFromUseList(v3 - 2);
      }
      v3 += 6;
      v2 -= 48;
    }
    while (v2);
  }
  return result;
}

void sub_1CD694A98(__n128 *a1, _WORD *a2, int **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE8980, 0, 0);
  dword_1EBCE8A00 = 0;
  qword_1EBCE8A08 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCE8A10 = 0;
  qword_1EBCE8980 = (uint64_t)&unk_1F2643F68;
  qword_1EBCE8A18 = (uint64_t)&unk_1F2643D20;
  qword_1EBCE8A20 = (uint64_t)&unk_1F25F7480;
  qword_1EBCE8A38 = (uint64_t)&qword_1EBCE8A20;
  sub_1CD694B88(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE8980);
}

__n128 sub_1CD694B88(__n128 *a1, _WORD *a2, int **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE8980, "msan-poison-stack-pattern", 0x19uLL);
  __n128 result = *a1;
  xmmword_1EBCE89A0 = (__int128)*a1;
  word_1EBCE898A = (32 * (*a2 & 3)) | word_1EBCE898A & 0xFF9F;
  uint64_t v7 = *a3;
  dword_1EBCE8A00 = **a3;
  byte_1EBCE8A14 = 1;
  dword_1EBCE8A10 = *v7;
  return result;
}

uint64_t sub_1CD694C10(uint64_t a1, char *a2, _OWORD *a3, _WORD *a4, int **a5)
{
  uint64_t v10 = sub_1CB883A14(a1, 0, 0);
  *(_OWORD *)(v10 + 128) = 0u;
  *(_OWORD *)(v10 + 144) = 0u;
  *(void *)(v10 + 136) = &unk_1F261F710;
  *(void *)uint64_t v10 = &unk_1F261F6A8;
  *(void *)(v10 + 160) = &unk_1F2643E10;
  *(void *)(v10 + 168) = &unk_1F261F7D0;
  *(void *)(v10 + 192) = v10 + 168;
  size_t v11 = strlen(a2);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)a2, v11);
  *(_OWORD *)(a1 + 32) = *a3;
  *(_WORD *)(a1 + 10) = (32 * (*a4 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  uint64_t v12 = **a5;
  *(void *)(a1 + 128) = v12;
  *(unsigned char *)(a1 + 152) = 1;
  *(void *)(a1 + 144) = v12;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

char *sub_1CD694D40()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::MemorySanitizerPass]";
  v10[1] = 75;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x4B) {
    uint64_t v1 = 75;
  }
  else {
    uint64_t v1 = v0;
  }
  uint64_t v2 = &aStringrefLlvmG_15[v1];
  unint64_t v3 = 75 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  __n128 result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

void sub_1CD694DFC(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = a1 + 72;
  std::string __p = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4 == a1 + 72)
  {
    uint64_t v12 = 0;
    size_t v11 = 0;
  }
  else
  {
    do
    {
      uint64_t v5 = v4 - 24;
      BOOL v6 = v4 == 0;
      uint64_t v4 = *(void *)(v4 + 8);
      if (v6) {
        uint64_t v5 = 0;
      }
      uint64_t v7 = v5 + 40;
      uint64_t v8 = *(void *)(v5 + 48);
      if (v8 != v7)
      {
        do
        {
          uint64_t v9 = *(void *)(v8 + 8);
          if (v8) {
            uint64_t v10 = (llvm::CallBase *)(v8 - 24);
          }
          else {
            uint64_t v10 = 0;
          }
          sub_1CD694ED0((uint64_t)&__p, v10);
          uint64_t v8 = v9;
        }
        while (v9 != v7);
      }
    }
    while (v4 != v3);
    size_t v11 = __p;
    uint64_t v12 = (uint64_t)v14;
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  sub_1CBFCBA2C(a2, v11, v12, (v12 - (uint64_t)v11) >> 3);
  if (__p)
  {
    uint64_t v14 = __p;
    operator delete(__p);
  }
}

uint64_t sub_1CD694ED0(uint64_t a1, llvm::CallBase *this)
{
  int v2 = *((unsigned __int8 *)this + 16);
  if ((v2 - 40) >= 0x2C)
  {
    unsigned int v3 = v2 - 33;
    BOOL v4 = v3 <= 0x3E && ((1 << v3) & 0x7FF000000000003ELL) == 0;
    uint64_t v5 = (1 << v3) & 0x8000000000041;
    if (v4 && v5 != 0) {
      return sub_1CD694F20(a1, this);
    }
  }
  return a1;
}

uint64_t sub_1CD694F20(uint64_t a1, llvm::CallBase *this)
{
  uint64_t result = llvm::CallBase::isIndirectCall(this);
  if (result)
  {
    BOOL v6 = this;
    uint64_t v5 = *(void **)(a1 + 8);
    if ((unint64_t)v5 >= *(void *)(a1 + 16))
    {
      uint64_t result = (uint64_t)sub_1CBC13470((void **)a1, &v6);
    }
    else
    {
      *uint64_t v5 = this;
      uint64_t result = (uint64_t)(v5 + 1);
    }
    *(void *)(a1 + 8) = result;
  }
  return result;
}

void sub_1CD694F80(char **a1, _WORD *a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE97E0, 0, 0);
  byte_1EBCE9860 = 0;
  qword_1EBCE9868 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCE9870 = 0;
  qword_1EBCE97E0 = (uint64_t)&unk_1F26440A0;
  qword_1EBCE9878 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCE9880 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCE9898 = (uint64_t)&qword_1EBCE9880;
  sub_1CD695070(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE97E0);
}

__n128 sub_1CD695070(char **a1, _WORD *a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE97E0, "icp-lto", 7uLL);
  BOOL v6 = *a1;
  byte_1EBCE9860 = **a1;
  byte_1EBCE9871 = 1;
  byte_1EBCE9870 = *v6;
  word_1EBCE97EA = (32 * (*a2 & 3)) | word_1EBCE97EA & 0xFF9F;
  __n128 result = *a3;
  xmmword_1EBCE9800 = (__int128)*a3;
  return result;
}

uint64_t llvm::createPrivateGlobalForString(uint64_t *a1, char *a2, llvm::Type *a3, int a4, const char *a5)
{
  char v8 = 1;
  uint64_t String = llvm::ConstantDataArray::getString(*a1, a2, a3, 1);
  uint64_t v10 = llvm::User::operator new((llvm::User *)0x58, 1u);
  uint64_t v11 = (uint64_t)v10;
  uint64_t v12 = *(llvm::PointerType **)String;
  char v16 = 1;
  if (*a5)
  {
    uint64_t v14 = a5;
    char v8 = 3;
  }
  char v15 = v8;
  llvm::GlobalVariable::GlobalVariable(v10, (uint64_t)a1, v12, 1, 8, (unint64_t)String, &v14, 0, 0, 0, 0);
  if (a4) {
    *(_DWORD *)(v11 + 32) = *(_DWORD *)(v11 + 32) & 0xFFFFFF3F | 0x80;
  }
  llvm::GlobalObject::setAlignment(v11, 256);
  return v11;
}

size_t *llvm::getOrCreateFunctionComdat(llvm *this, llvm::Function *a2, llvm::Triple *a3)
{
  unsigned int v3 = (size_t *)*((void *)this + 6);
  if (!v3)
  {
    uint64_t v7 = *((void *)this + 5);
    Name = (unsigned __int8 *)llvm::Value::getName(this);
    inserted = llvm::Module::getOrInsertComdat(v7, Name, v9);
    unsigned int v3 = inserted;
    int v11 = *((_DWORD *)a2 + 11);
    if (v11 == 3
      || v11 == 1
      && ((unsigned int v12 = *((_DWORD *)this + 8) & 0xF, v13 = v12 > 0xA, v14 = (1 << v12) & 0x63C, !v13)
        ? (BOOL v15 = v14 == 0)
        : (BOOL v15 = 1),
          v15))
    {
      *((_DWORD *)inserted + 2) = 3;
    }
    llvm::GlobalObject::setComdat(this, (llvm::Comdat *)inserted);
  }
  return v3;
}

double llvm::InstrOrderFilePass::run@<D0>(void *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v5 = 0;
  memset(v4, 0, sizeof(v4));
  sub_1CCB332E4((unint64_t **)v4, a1);
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(void *)(a2 + 88) = 0;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(void *)a2 = a2 + 32;
  *(void *)(a2 + 8) = a2 + 32;
  *(void *)&double result = 2;
  *(void *)(a2 + 16) = 2;
  *(void *)(a2 + 48) = a2 + 80;
  *(void *)(a2 + 56) = a2 + 80;
  *(_DWORD *)(a2 + 64) = 2;
  return result;
}

void llvm::createInstrOrderFilePass(llvm *this)
{
}

void sub_1CD695328(const char **a1, __n128 *a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCE9BA0, 0, 0);
  qword_1EBCE9C20 = 0;
  qword_1EBCE9C28 = 0;
  qword_1EBCE9C48 = 0;
  unk_1EBCE9C50 = 0;
  byte_1EBCE9C58 = 0;
  qword_1EBCE9C40 = 0;
  unk_1EBCE9C30 = 0;
  unk_1EBCE9C38 = &unk_1F2643C20;
  qword_1EBCE9BA0 = (uint64_t)&unk_1F2643FD0;
  qword_1EBCE9C60 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCE9C68 = (uint64_t)&unk_1F25F6428;
  qword_1EBCE9C80 = (uint64_t)&qword_1EBCE9C68;
  sub_1CD695424(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE9BA0);
}

__n128 sub_1CD695424(const char **a1, __n128 *a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCE9BA0, "orderfile-write-mapping", 0x17uLL);
  sub_1CBAD7D28(a1, (uint64_t)&qword_1EBCE9BA0);
  __n128 result = *a2;
  xmmword_1EBCE9BC0 = (__int128)*a2;
  word_1EBCE9BAA = (32 * (*a3 & 3)) | word_1EBCE9BAA & 0xFF9F;
  return result;
}

void llvm::InstrProfiling::run()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::AnalysisManager<llvm::Module>::getResultImpl();
}

void llvm::createInstrProfilingLegacyPass()
{
}

void llvm::InstrProfiling::lowerCover(llvm::InstrProfiling *a1, llvm::Value **a2)
{
  v7[17] = *(void **)MEMORY[0x1E4F143B8];
  CounterAddress = llvm::InstrProfiling::getCounterAddress(a1, a2);
  sub_1CC243A10((uint64_t)v7, (uint64_t **)a2, 0, 0, 0);
  Int8Ty = (llvm::ConstantInt *)llvm::Type::getInt8Ty((llvm::Type *)v7[8], v4);
  BOOL v6 = llvm::ConstantInt::get(Int8Ty, 0, 0);
  sub_1CC27BF8C((uint64_t *)v7, (uint64_t)v6, (uint64_t)CounterAddress, 0, 0);
  llvm::Instruction::eraseFromParent((llvm::Instruction *)a2);
}

void llvm::InstrProfiling::lowerValueProfileInst(uint64_t a1, uint64_t a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  BOOL v4 = llvm::Value::stripPointerCasts(*(llvm::Value **)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF)));
  v34[0] = 0;
  if (sub_1CD41F538(*(void *)(a1 + 120), *(_DWORD *)(a1 + 136), (uint64_t)v4, v34)) {
    uint64_t v5 = v34[0];
  }
  else {
    uint64_t v5 = (void *)(*(void *)(a1 + 120) + 32 * *(unsigned int *)(a1 + 136));
  }
  uint64_t v6 = a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF);
  uint64_t v7 = *(void *)(v6 + 96);
  char v8 = (void *)(v7 + 24);
  if (*(_DWORD *)(v7 + 32) >= 0x41u) {
    char v8 = (void *)*v8;
  }
  size_t v9 = (void *)*v8;
  uint64_t v10 = *(void *)(v6 + 128);
  int v11 = (void *)(v10 + 24);
  if (*(_DWORD *)(v10 + 32) >= 0x41u) {
    int v11 = (void *)*v11;
  }
  unsigned int v12 = (void *)*v11;
  if (v9)
  {
    uint64_t v13 = 2;
    do
    {
      LODWORD(v12) = v12 + *((_DWORD *)v5 + v13);
      unint64_t v14 = (v13++ - 1);
    }
    while ((unint64_t)v9 > v14);
  }
  uint64_t v15 = *((void *)v5 + 3);
  sub_1CC243A10((uint64_t)v34, (uint64_t **)a2, 0, 0, 0);
  uint64_t v16 = *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 96);
  uint64_t v17 = (void *)(v16 + 24);
  if (*(_DWORD *)(v16 + 32) >= 0x41u) {
    uint64_t v17 = (void *)*v17;
  }
  uint64_t v18 = (void *)*v17;
  uint64_t Function = llvm::Instruction::getFunction((llvm::Instruction *)a2);
  uint64_t v20 = *(void *)(a1 + 112);
  if (!v20) {
    sub_1CB920400();
  }
  unint64_t v21 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v20 + 48))(v20, Function);
  char v31 = &v33;
  *(void *)unsigned int v32 = 0x100000000;
  llvm::CallBase::getOperandBundlesAsDefs(a2, (uint64_t)&v31);
  v30[0] = *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 64);
  unint64_t v22 = llvm::PointerType::get((llvm::PointerType *)(*(void *)v35 + 1912), 0);
  __int16 v29 = 257;
  v30[1] = (uint64_t)sub_1CB84580C((uint64_t)v34, 49, v15, v22, (uint64_t)v28);
  void v30[2] = (uint64_t)llvm::ConstantInt::get((llvm::ConstantInt *)(*(void *)v35 + 1960), v12, 0);
  char v23 = (uint64_t **)sub_1CCB395E8(*(uint64_t ***)(a1 + 32), *v21, v18 == (void *)1);
  __int16 v29 = 257;
  uint64_t v25 = sub_1CC233B6C((uint64_t *)v34, v23, v24, v30, 3, (uint64_t)v31, v32[0], (uint64_t)v28, 0);
  char v26 = (llvm::Value *)v25;
  if (*(unsigned char *)(*v21 + 144))
  {
    signed int v27 = 67;
  }
  else
  {
    if (!*(unsigned char *)(*v21 + 146))
    {
LABEL_17:
      llvm::Value::replaceAllUsesWith((llvm::Value *)a2, v26);
      llvm::Instruction::eraseFromParent((llvm::Instruction *)a2);
    }
    signed int v27 = 48;
  }
  *(void *)(v25 + 64) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(v25 + 64), **(uint64_t ***)v25, 3, v27);
  goto LABEL_17;
}

_DWORD *sub_1CD695B54(_DWORD *result)
{
  if (*((void *)result + 1))
  {
    uint64_t v1 = result[4];
    if (v1 > 4 * result[2] && v1 >= 0x41)
    {
      return sub_1CD426218(result);
    }
    else
    {
      if (v1)
      {
        int v2 = *(void **)result;
        uint64_t v3 = 32 * v1;
        do
        {
          *int v2 = -4096;
          v2 += 4;
          v3 -= 32;
        }
        while (v3);
      }
      *((void *)result + 1) = 0;
    }
  }
  return result;
}

uint64_t llvm::InstrProfiling::emitRuntimeHook(llvm::InstrProfiling *this)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 19) == 9) {
    return 0;
  }
  uint64_t GlobalVariable = llvm::Module::getGlobalVariable(*((void *)this + 4), "__llvm_profile_runtime", 0x16uLL, 0);
  uint64_t result = 0;
  if (!GlobalVariable)
  {
    uint64_t v4 = ***((void ***)this + 4);
    uint64_t v5 = operator new(0x78uLL);
    v5[13] = v5[13] & 0x38000000 | 1;
    uint64_t v6 = v5 + 8;
    *(void *)uint64_t v5 = 0;
    *((void *)v5 + 1) = 0;
    *((void *)v5 + 2) = 0;
    *((void *)v5 + 3) = v5 + 8;
    uint64_t v7 = (llvm::PointerType *)(v4 + 1960);
    uint64_t v8 = *((void *)this + 4);
    __int16 v25 = 261;
    char v23 = "__llvm_profile_runtime";
    uint64_t v24 = 22;
    llvm::GlobalVariable::GlobalVariable((unint64_t *)v5 + 4, v8, v7, 0, 0, 0, (const char **)&v23, 0, 0, 0, 0);
    if (*((_DWORD *)this + 21) == 3)
    {
      char v23 = v6;
      size_t v9 = (void *)*((void *)this + 19);
      if ((unint64_t)v9 >= *((void *)this + 20))
      {
        uint64_t v10 = sub_1CBC13470((void **)this + 18, &v23);
      }
      else
      {
        *size_t v9 = v6;
        uint64_t v10 = v9 + 1;
      }
      *((void *)this + 19) = v10;
      return 1;
    }
    int v11 = (llvm::PointerType *)llvm::FunctionType::get((uint64_t **)v7, 0, 0, 0);
    __int16 v25 = 261;
    char v23 = "__llvm_profile_runtime_user";
    uint64_t v24 = 27;
    unint64_t v12 = *((void *)this + 4);
    uint64_t v13 = (char *)operator new(0x80uLL);
    unint64_t v14 = (uint64_t ***)(v13 + 8);
    *((_DWORD *)v13 + 7) = *((_DWORD *)v13 + 7) & 0x38000000 | 0x40000000;
    *(void *)uint64_t v13 = 0;
    llvm::Function::Function((unint64_t *)v13 + 1, v11, 5, (llvm::Type *)0xFFFFFFFFLL, (const char **)&v23, v12);
    *((void *)v13 + 15) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)v13 + 15, **((uint64_t ***)v13 + 1), -1, 27);
    *((void *)v13 + 15) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)v13 + 15, **((uint64_t ***)v13 + 1), -1, 43);
    if (*(unsigned char *)this) {
      *((void *)v13 + 15) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)v13 + 15, **v14, -1, 31);
    }
    int v15 = *((_DWORD *)v13 + 10);
    unsigned int v16 = v15 & 0xFFFFFFCF | 0x10;
    *((_DWORD *)v13 + 10) = v16;
    if ((v15 & 0xFu) - 7 >= 2)
    {
      if (llvm::GlobalValue::hasExternalWeakLinkage((llvm::GlobalValue *)v14)) {
        goto LABEL_12;
      }
      unsigned int v16 = *((_DWORD *)v13 + 10);
    }
    *((_DWORD *)v13 + 10) = v16 | 0x4000;
LABEL_12:
    unsigned int v17 = *((_DWORD *)this + 21);
    if (v17 > 9 || ((1 << v17) & 0x320) == 0)
    {
      uint64_t v18 = *((void *)this + 4);
      Name = (unsigned __int8 *)llvm::Value::getName((llvm::Value *)v14);
      inserted = llvm::Module::getOrInsertComdat(v18, Name, v20);
      llvm::GlobalObject::setComdat((llvm::GlobalObject *)v14, (llvm::Comdat *)inserted);
    }
    __int16 v22 = 257;
    operator new();
  }
  return result;
}

void *llvm::InstrProfiling::computeNumValueSiteCounts(uint64_t a1, uint64_t a2)
{
  unint64_t v14 = llvm::Value::stripPointerCasts(*(llvm::Value **)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF)));
  uint64_t v4 = a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF);
  uint64_t v5 = *(void *)(v4 + 96);
  uint64_t v6 = (void *)(v5 + 24);
  if (*(_DWORD *)(v5 + 32) >= 0x41u) {
    uint64_t v6 = (void *)*v6;
  }
  uint64_t v7 = (void *)*v6;
  uint64_t v8 = *(void *)(v4 + 128);
  size_t v9 = (void *)(v8 + 24);
  if (*(_DWORD *)(v8 + 32) >= 0x41u) {
    size_t v9 = (void *)*v9;
  }
  int v10 = *(_DWORD *)v9;
  uint64_t result = sub_1CD697878(a1 + 120, (uint64_t *)&v14);
  unint64_t v12 = (char *)result + 4 * (void)v7;
  if (*((_DWORD *)v12 + 2) <= (v10 + 1)) {
    int v13 = v10 + 1;
  }
  else {
    int v13 = *((_DWORD *)v12 + 2);
  }
  *((_DWORD *)v12 + 2) = v13;
  return result;
}

void llvm::InstrProfiling::lowerCoverageData(llvm::InstrProfiling *this, llvm::GlobalVariable *a2)
{
  uint64_t v3 = *((void *)a2 - 4);
  int v4 = *(_DWORD *)(v3 + 20);
  uint64_t v5 = v4 & 0x7FFFFFF;
  if ((v4 & 0x7FFFFFF) != 0)
  {
    uint64_t v7 = (void **)((char *)this + 192);
    uint64_t v8 = *((void *)a2 - 4);
    do
    {
      size_t v9 = *(llvm::Value **)(v8 - 32 * (*(_DWORD *)(v3 + 20) & 0x7FFFFFF));
      int v10 = llvm::Value::stripPointerCasts(v9);
      *((_DWORD *)v10 + 8) = *((_DWORD *)v10 + 8) & 0xFFFFBFC0 | 0x4008;
      int v11 = (llvm::Value **)*((void *)this + 25);
      if ((unint64_t)v11 >= *((void *)this + 26))
      {
        unint64_t v12 = sub_1CBF63C18(v7, (uint64_t)v10);
      }
      else
      {
        *int v11 = v10;
        unint64_t v12 = v11 + 1;
      }
      *((void *)this + 25) = v12;
      if (*((unsigned char *)v9 + 16) == 5) {
        sub_1CC0BCC78((uint64_t)v9);
      }
      v8 += 32;
      --v5;
    }
    while (v5);
  }

  llvm::GlobalVariable::eraseFromParent(a2);
}

void llvm::InstrProfiling::emitNameData(llvm::InstrProfiling *this)
{
  int v2 = (llvm **)*((void *)this + 24);
  uint64_t v3 = (llvm **)*((void *)this + 25);
  if (v2 != v3)
  {
    memset(&v23, 0, sizeof(v23));
    llvm::collectPGOFuncNameStrings(v2, (llvm::GlobalVariable *)(v3 - v2), &v23, &v22);
    if (v22)
    {
      uint64_t v18 = v22;
      uint64_t v22 = 0;
      sub_1CD4FB504(&v18, &v19);
      __int16 v21 = 260;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v19;
      llvm::report_fatal_error((llvm *)&__p, 0);
    }
    if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v4 = &v23;
    }
    else {
      int v4 = (std::string *)v23.__r_.__value_.__r.__words[0];
    }
    if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = *((unsigned char *)&v23.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type size = v23.__r_.__value_.__l.__size_;
    }
    uint64_t String = llvm::ConstantDataArray::getString(**((void **)this + 4), (char *)v4, (llvm::Type *)size, 0);
    uint64_t v7 = (char *)operator new(0x78uLL);
    uint64_t v8 = v7 + 32;
    *((_DWORD *)v7 + 13) = *((_DWORD *)v7 + 13) & 0x38000000 | 1;
    *(void *)uint64_t v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = 0;
    *((void *)v7 + 3) = v7 + 32;
    uint64_t v9 = *((void *)this + 4);
    int v10 = *(llvm::PointerType **)String;
    __int16 v21 = 261;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"__llvm_prf_nm";
    __p.__r_.__value_.__l.__size_ = 13;
    llvm::GlobalVariable::GlobalVariable((unint64_t *)v7 + 4, v9, v10, 1, 8, (unint64_t)String, (const char **)&__p.__r_.__value_.__l.__data_, 0, 0, 0, 0);
    std::string::size_type v11 = *((unsigned char *)&v23.__r_.__value_.__s + 23) & 0x7F;
    if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v11 = v23.__r_.__value_.__l.__size_;
    }
    *((void *)this + 27) = v8;
    *((void *)this + 28) = v11;
    llvm::getInstrProfSectionName(2u, *((_DWORD *)this + 21), 1, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t v13 = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      size_t v13 = __p.__r_.__value_.__l.__size_;
    }
    llvm::GlobalObject::setSection(v8, p_p, v13);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    *(_DWORD *)(*((void *)this + 27) + 32) = *(_DWORD *)(*((void *)this + 27) + 32) & 0xFFC0FFFF | 0x10000;
    std::string::size_type v14 = *((void *)this + 27);
    __p.__r_.__value_.__r.__words[0] = v14;
    int v15 = (std::string::size_type *)*((void *)this + 22);
    if ((unint64_t)v15 >= *((void *)this + 23))
    {
      unsigned int v16 = sub_1CBC13470((void **)this + 21, &__p);
    }
    else
    {
      std::string::size_type *v15 = v14;
      unsigned int v16 = v15 + 1;
    }
    *((void *)this + 22) = v16;
    unsigned int v17 = (llvm::GlobalVariable **)*((void *)this + 24);
    if (v17 != *((llvm::GlobalVariable ***)this + 25)) {
      llvm::GlobalVariable::eraseFromParent(*v17);
    }
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v23.__r_.__value_.__l.__data_);
    }
  }
}

void llvm::InstrProfiling::emitUses(llvm::InstrProfiling *this, const llvm::Module *a2)
{
  int v3 = *((_DWORD *)this + 21);
  BOOL v4 = v3 == 5 || v3 == 3;
  if (v4 || v3 == 1 && !sub_1CCB3A140(*((llvm **)this + 4), a2)) {
    llvm::appendToCompilerUsed(*((void **)this + 4), *((llvm::ConstantExpr ***)this + 18), (uint64_t)(*((void *)this + 19) - *((void *)this + 18)) >> 3);
  }
  else {
    llvm::appendToUsed(*((void **)this + 4), *((llvm::ConstantExpr ***)this + 18), (uint64_t)(*((void *)this + 19) - *((void *)this + 18)) >> 3);
  }
  uint64_t v5 = (void *)*((void *)this + 4);
  uint64_t v6 = (llvm::ConstantExpr **)*((void *)this + 21);
  uint64_t v7 = (uint64_t)(*((void *)this + 22) - (void)v6) >> 3;

  llvm::appendToUsed(v5, v6, v7);
}

uint64_t llvm::InstrProfiling::emitInitialization(llvm::InstrProfiling *this)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (!*((unsigned char *)this + 232))
  {
    int v2 = (uint64_t *)*((void *)this + 4);
    char v3 = *((unsigned char *)this + 31);
    if (v3 >= 0) {
      BOOL v4 = (char *)this + 8;
    }
    else {
      BOOL v4 = (char *)*((void *)this + 1);
    }
    if (v3 >= 0) {
      uint64_t v5 = (llvm::Type *)(v3 & 0x7F);
    }
    else {
      uint64_t v5 = (llvm::Type *)*((void *)this + 2);
    }
    llvm::createProfileFileNameVar(v2, v4, v5);
  }
  uint64_t result = llvm::Module::getFunction(*((void *)this + 4), "__llvm_profile_register_functions", 0x21uLL);
  if (result)
  {
    uint64_t v7 = (llvm::PointerType *)llvm::FunctionType::get((uint64_t **)(***((void ***)this + 4) + 1576), 0, 0, 0);
    __int16 v11 = 261;
    v10[0] = "__llvm_profile_init";
    v10[1] = (void *)19;
    unint64_t v8 = *((void *)this + 4);
    uint64_t v9 = operator new(0x80uLL);
    *((_DWORD *)v9 + 7) = *((_DWORD *)v9 + 7) & 0x38000000 | 0x40000000;
    *(void *)uint64_t v9 = 0;
    llvm::Function::Function((unint64_t *)v9 + 1, v7, 7, (llvm::Type *)0xFFFFFFFFLL, (const char **)v10, v8);
    *((_DWORD *)v9 + 10) = *((_DWORD *)v9 + 10) & 0xFFFFFF3F | 0x80;
    *((void *)v9 + 15) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)v9 + 15, **((uint64_t ***)v9 + 1), -1, 27);
    if (*(unsigned char *)this) {
      *((void *)v9 + 15) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)v9 + 15, **((uint64_t ***)v9 + 1), -1, 31);
    }
    operator new();
  }
  return result;
}

char *llvm::InstrProfiling::createRegionCounters(uint64_t a1, llvm::LLVMContext *a2, const char *a3, uint64_t a4, char a5)
{
  uint64_t v9 = ((void *)a2 - 4 * (*((_DWORD *)a2 + 5) & 0x7FFFFFF))[8];
  int v10 = (llvm::Type **)(v9 + 24);
  if (*(_DWORD *)(v9 + 32) >= 0x41u) {
    int v10 = (llvm::Type **)*v10;
  }
  __int16 v11 = *v10;
  uint64_t v12 = **(llvm::Type ***)(a1 + 32);
  if (*(_DWORD *)(*((void *)a2 - 4) + 36) == 159)
  {
    Int8Ty = (llvm::ArrayType *)llvm::Type::getInt8Ty(v12, a2);
    std::string::size_type v14 = llvm::ArrayType::get(Int8Ty, v11);
    AllOnesValue = llvm::Constant::getAllOnesValue(Int8Ty, v15, v16);
    if (v11)
    {
      if ((unint64_t)v11 >> 61) {
        abort();
      }
      uint64_t v18 = AllOnesValue;
      std::string v19 = (llvm::Type *)operator new(8 * (void)v11);
      size_t v20 = v19;
      uint64_t v21 = 0;
      uint64_t v22 = (char *)v19 + 8 * (void)v11;
      do
      {
        *(void *)((char *)v19 + v21) = v18;
        v21 += 8;
      }
      while (8 * (void)v11 != v21);
    }
    else
    {
      size_t v20 = 0;
      uint64_t v22 = 0;
    }
    char v31 = (char *)operator new(0x78uLL);
    __int16 v25 = v31 + 32;
    *((_DWORD *)v31 + 13) = *((_DWORD *)v31 + 13) & 0x38000000 | 1;
    *(void *)char v31 = 0;
    *((void *)v31 + 1) = 0;
    *((void *)v31 + 2) = 0;
    *((void *)v31 + 3) = v31 + 32;
    uint64_t v32 = *(void *)(a1 + 32);
    uint64_t v33 = llvm::ConstantArray::get(v14, v20, (v22 - (char *)v20) >> 3);
    __int16 v36 = 261;
    __int16 v34 = a3;
    uint64_t v35 = a4;
    llvm::GlobalVariable::GlobalVariable((unint64_t *)v31 + 4, v32, v14, 0, a5, (unint64_t)v33, &v34, 0, 0, 0, 0);
    *((_DWORD *)v31 + 16) = *((_DWORD *)v31 + 16) & 0xFFC0FFFF | 0x10000;
    if (v20) {
      operator delete(v20);
    }
  }
  else
  {
    std::string v23 = llvm::ArrayType::get((llvm::ArrayType *)(*(void *)v12 + 1984), *v10);
    uint64_t v24 = (char *)operator new(0x78uLL);
    __int16 v25 = v24 + 32;
    *((_DWORD *)v24 + 13) = *((_DWORD *)v24 + 13) & 0x38000000 | 1;
    *(void *)uint64_t v24 = 0;
    *((void *)v24 + 1) = 0;
    *((void *)v24 + 2) = 0;
    *((void *)v24 + 3) = v24 + 32;
    uint64_t v26 = *(void *)(a1 + 32);
    NullValue = llvm::Constant::getNullValue(v23, v27, v28);
    __int16 v36 = 261;
    __int16 v34 = a3;
    uint64_t v35 = a4;
    llvm::GlobalVariable::GlobalVariable((unint64_t *)v24 + 4, v26, v23, 0, a5, (unint64_t)NullValue, &v34, 0, 0, 0, 0);
    *((_DWORD *)v24 + 16) = *((_DWORD *)v24 + 16) & 0xFFC0FFFF | 0x40000;
  }
  return v25;
}

uint64_t sub_1CD696894(uint64_t a1)
{
  int v2 = *(void **)(a1 + 240);
  if (v2)
  {
    *(void *)(a1 + 248) = v2;
    operator delete(v2);
  }
  char v3 = *(void **)(a1 + 192);
  if (v3)
  {
    *(void *)(a1 + 200) = v3;
    operator delete(v3);
  }
  BOOL v4 = *(void **)(a1 + 168);
  if (v4)
  {
    *(void *)(a1 + 176) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 144);
  if (v5)
  {
    *(void *)(a1 + 152) = v5;
    operator delete(v5);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 120), 8);
  uint64_t v6 = *(void *)(a1 + 112);
  if (v6 == a1 + 88)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 88) + 32))(a1 + 88);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t sub_1CD696988(uint64_t a1, uint64_t a2, char a3)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  uint64_t v5 = a1 + 8;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_1CB8BDF7C(v5, *(const void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 8);
    *(void *)(v5 + 16) = *(void *)(a2 + 24);
    *(_OWORD *)uint64_t v5 = v6;
  }
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(void *)(a1 + 208) = 0;
  *(unsigned char *)(a1 + 232) = a3;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  return a1;
}

void *sub_1CD696A14(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD50E500(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD696A90(a1, a2, v7);
    *uint64_t v5 = *a2;
    v5[1] = v5 + 3;
    uint64_t v5[2] = 0x800000000;
  }
  return v5;
}

void *sub_1CD696A90(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD696B44(a1, v6);
  unint64_t v8 = 0;
  sub_1CD50E500(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD696B44(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(152 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD696C1C(a1, v4, v4 + 152 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  unsigned int v10 = *(_DWORD *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 152 * v10;
    do
    {
      void *result = -4096;
      result += 19;
      v11 -= 152;
    }
    while (v11);
  }
  return result;
}

void sub_1CD696C1C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 152 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 19;
      v8 -= 152;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v9 = *(void *)v4;
      if ((*(void *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        size_t v13 = 0;
        sub_1CD50E500(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        unsigned int v10 = v13;
        *size_t v13 = *(void *)v4;
        uint64_t v10[2] = 0x800000000;
        v10[1] = v10 + 3;
        uint64_t v11 = (uint64_t)(v10 + 1);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CD4BAB44(v11, v4 + 8);
        }
        ++*(_DWORD *)(a1 + 8);
        uint64_t v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12) {
          free(v12);
        }
      }
      v4 += 152;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1CD696D1C()
{
  return 1;
}

uint64_t sub_1CD696D24(uint64_t a1, char *a2, _WORD *a3, _OWORD *a4, unsigned char **a5)
{
  uint64_t v10 = sub_1CB883A14(a1, 0, 0);
  *(unsigned char *)(v10 + 128) = 0;
  *(void *)(v10 + 136) = &unk_1F25EDE58;
  *(void *)(v10 + 144) = 0;
  *(void *)uint64_t v10 = &unk_1F26440A0;
  *(void *)(v10 + 152) = &unk_1F2643CC0;
  *(void *)(v10 + 160) = &unk_1F25EDE78;
  *(void *)(v10 + 184) = v10 + 160;
  size_t v11 = strlen(a2);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)a2, v11);
  *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 10) & 0xFFF8 | *a3 & 7;
  *(_OWORD *)(a1 + 32) = *a4;
  uint64_t v12 = *a5;
  *(unsigned char *)(a1 + 128) = **a5;
  *(unsigned char *)(a1 + 145) = 1;
  *(unsigned char *)(a1 + 144) = *v12;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void sub_1CD696E4C(long long *a1, uint64_t **a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)qword_1EBCEA668, 0, 0);
  xmmword_1EBCEA6E8 = 0u;
  *(_OWORD *)&qword_1EBCEA6F8 = 0u;
  *((void *)&xmmword_1EBCEA6E8 + 1) = &unk_1F2601200;
  qword_1EBCEA668[0] = (uint64_t)&unk_1F2601198;
  qword_1EBCEA708 = (uint64_t)&unk_1F2643E40;
  qword_1EBCEA710 = (uint64_t)&unk_1F2601220;
  qword_1EBCEA728 = (uint64_t)&qword_1EBCEA710;
  llvm::cl::Option::setArgStr(v4, "vp-counters-per-site", 0x14uLL);
  xmmword_1EBCEA688 = *a1;
  unint64_t v5 = *a2;
  *(void *)&xmmword_1EBCEA6E8 = **a2;
  byte_1EBCEA700 = 1;
  qword_1EBCEA6F8 = *v5;

  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EBCEA668);
}

void sub_1CD696F60(_WORD *a1, long long *a2, char **a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCE9EE8, 0, 0);
  byte_1EBCE9F68 = 0;
  qword_1EBCE9F70 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCE9F78 = 0;
  qword_1EBCE9EE8 = (uint64_t)&unk_1F26440A0;
  qword_1EBCE9F80 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCE9F88 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCE9FA0 = (uint64_t)&qword_1EBCE9F88;
  llvm::cl::Option::setArgStr(v6, "instrprof-atomic-counter-update-all", 0x23uLL);
  word_1EBCE9EF2 = word_1EBCE9EF2 & 0xFFF8 | *a1 & 7;
  xmmword_1EBCE9F08 = *a2;
  int v7 = *a3;
  byte_1EBCE9F68 = **a3;
  byte_1EBCE9F79 = 1;
  byte_1EBCE9F78 = *v7;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE9EE8);
}

void sub_1CD697084(_WORD *a1, long long *a2, char **a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCE9FA8, 0, 0);
  byte_1EBCEA028 = 0;
  qword_1EBCEA030 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCEA038 = 0;
  qword_1EBCE9FA8 = (uint64_t)&unk_1F26440A0;
  qword_1EBCEA040 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCEA048 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCEA060 = (uint64_t)&qword_1EBCEA048;
  llvm::cl::Option::setArgStr(v6, "atomic-counter-update-promoted", 0x1EuLL);
  word_1EBCE9FB2 = word_1EBCE9FB2 & 0xFFF8 | *a1 & 7;
  xmmword_1EBCE9FC8 = *a2;
  int v7 = *a3;
  byte_1EBCEA028 = **a3;
  byte_1EBCEA039 = 1;
  byte_1EBCEA038 = *v7;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCE9FA8);
}

void sub_1CD6971A8(_WORD *a1, int **a2, long long *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCEA1E8, 0, 0);
  dword_1EBCEA268 = 0;
  qword_1EBCEA270 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCEA278 = 0;
  qword_1EBCEA1E8 = (uint64_t)&unk_1F2643F00;
  qword_1EBCEA280 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCEA288 = (uint64_t)&unk_1F25EA168;
  qword_1EBCEA2A0 = (uint64_t)&qword_1EBCEA288;
  word_1EBCEA1F2 = word_1EBCEA1F2 & 0xFFF8 | *a1 & 7;
  llvm::cl::Option::setArgStr(v6, "max-counter-promotions-per-loop", 0x1FuLL);
  dword_1EBCEA268 = **a2;
  byte_1EBCEA27C = 1;
  dword_1EBCEA278 = dword_1EBCEA268;
  xmmword_1EBCEA208 = *a3;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCEA1E8);
}

void sub_1CD6972C8(_WORD *a1, int **a2, long long *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCEA2A8, 0, 0);
  dword_1EBCEA328 = 0;
  qword_1EBCEA330 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCEA338 = 0;
  qword_1EBCEA2A8 = (uint64_t)&unk_1F2643F68;
  qword_1EBCEA340 = (uint64_t)&unk_1F2643D20;
  qword_1EBCEA348 = (uint64_t)&unk_1F25F7480;
  qword_1EBCEA360 = (uint64_t)&qword_1EBCEA348;
  word_1EBCEA2B2 = word_1EBCEA2B2 & 0xFFF8 | *a1 & 7;
  llvm::cl::Option::setArgStr(v6, "max-counter-promotions", 0x16uLL);
  int v7 = *a2;
  dword_1EBCEA328 = **a2;
  byte_1EBCEA33C = 1;
  dword_1EBCEA338 = *v7;
  xmmword_1EBCEA2C8 = *a3;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCEA2A8);
}

void sub_1CD6973EC(_WORD *a1, int **a2, long long *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCEA368, 0, 0);
  dword_1EBCEA3E8 = 0;
  qword_1EBCEA3F0 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCEA3F8 = 0;
  qword_1EBCEA368 = (uint64_t)&unk_1F2643F00;
  qword_1EBCEA400 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCEA408 = (uint64_t)&unk_1F25EA168;
  qword_1EBCEA420 = (uint64_t)&qword_1EBCEA408;
  word_1EBCEA372 = word_1EBCEA372 & 0xFFF8 | *a1 & 7;
  llvm::cl::Option::setArgStr(v6, "speculative-counter-promotion-max-exiting", 0x29uLL);
  dword_1EBCEA3E8 = **a2;
  byte_1EBCEA3FC = 1;
  dword_1EBCEA3F8 = dword_1EBCEA3E8;
  xmmword_1EBCEA388 = *a3;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCEA368);
}

void sub_1CD69750C(_WORD *a1, char **a2, long long *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCEA428, 0, 0);
  byte_1EBCEA4A8 = 0;
  qword_1EBCEA4B0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCEA4B8 = 0;
  qword_1EBCEA428 = (uint64_t)&unk_1F26440A0;
  qword_1EBCEA4C0 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCEA4C8 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCEA4E0 = (uint64_t)&qword_1EBCEA4C8;
  word_1EBCEA432 = word_1EBCEA432 & 0xFFF8 | *a1 & 7;
  llvm::cl::Option::setArgStr(v6, "speculative-counter-promotion-to-loop", 0x25uLL);
  int v7 = *a2;
  byte_1EBCEA4A8 = **a2;
  byte_1EBCEA4B9 = 1;
  byte_1EBCEA4B8 = *v7;
  xmmword_1EBCEA448 = *a3;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCEA428);
}

void sub_1CD697630(_WORD *a1, char **a2, long long *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCEA4E8, 0, 0);
  byte_1EBCEA568 = 0;
  qword_1EBCEA570 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCEA578 = 0;
  qword_1EBCEA4E8 = (uint64_t)&unk_1F26440A0;
  qword_1EBCEA580 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCEA588 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCEA5A0 = (uint64_t)&qword_1EBCEA588;
  word_1EBCEA4F2 = word_1EBCEA4F2 & 0xFFF8 | *a1 & 7;
  llvm::cl::Option::setArgStr(v6, "iterative-counter-promotion", 0x1BuLL);
  int v7 = *a2;
  byte_1EBCEA568 = **a2;
  byte_1EBCEA579 = 1;
  byte_1EBCEA578 = *v7;
  xmmword_1EBCEA508 = *a3;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCEA4E8);
}

void sub_1CD697754(_WORD *a1, char **a2, long long *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCEA5A8, 0, 0);
  byte_1EBCEA628 = 0;
  qword_1EBCEA630 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCEA638 = 0;
  qword_1EBCEA5A8 = (uint64_t)&unk_1F26440A0;
  qword_1EBCEA640 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCEA648 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCEA660 = (uint64_t)&qword_1EBCEA648;
  word_1EBCEA5B2 = word_1EBCEA5B2 & 0xFFF8 | *a1 & 7;
  llvm::cl::Option::setArgStr(v6, "skip-ret-exit-block", 0x13uLL);
  int v7 = *a2;
  byte_1EBCEA628 = **a2;
  byte_1EBCEA639 = 1;
  byte_1EBCEA638 = *v7;
  xmmword_1EBCEA5C8 = *a3;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCEA5A8);
}

void *sub_1CD697878(uint64_t a1, uint64_t *a2)
{
  uint64_t v8 = 0;
  char v4 = sub_1CD41F538(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  unint64_t v5 = v8;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CD6978E8(a1, a2, v8);
    uint64_t v7 = *a2;
    uint64_t v5[2] = 0;
    v5[3] = 0;
    *unint64_t v5 = v7;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD6978E8(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD69799C(a1, v6);
  uint64_t v8 = 0;
  sub_1CD41F538(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD69799C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD697A68(a1, v4, v4 + 32 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      void *result = -4096;
      result += 4;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD697A68(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 32 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 4;
      v8 -= 32;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v12 = 0;
      uint64_t result = sub_1CD41F538(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v12);
      uint64_t v10 = v12;
      *uint64_t v12 = *(void *)a2;
      long long v11 = *(_OWORD *)(a2 + 8);
      v10[3] = *(void *)(a2 + 24);
      *(_OWORD *)(v10 + 1) = v11;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 32;
  }
  return result;
}

double llvm::PGOInstrumentationGenCreateVar::run@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  char v5 = *(unsigned char *)(a1 + 23);
  BOOL v6 = v5 < 0;
  if (v5 >= 0) {
    int v7 = (char *)a1;
  }
  else {
    int v7 = *(char **)a1;
  }
  uint64_t v8 = (llvm::Type *)(v5 & 0x7F);
  if (v6) {
    uint64_t v9 = *(llvm::Type **)(a1 + 8);
  }
  else {
    uint64_t v9 = v8;
  }
  llvm::createProfileFileNameVar(a2, v7, v9);
  long long v11 = (llvm::ConstantExpr *)sub_1CCB3BAA4((uint64_t **)a2, 1);
  llvm::appendToCompilerUsed(a2, &v11, 1);
  *(void *)(a3 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a3 = a3 + 32;
  *(void *)(a3 + 8) = a3 + 32;
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 48) = a3 + 80;
  *(void *)(a3 + 56) = a3 + 80;
  *(void *)(a3 + 64) = 2;
  *(_DWORD *)(a3 + 72) = 0;
  *(void *)&double result = 0x100000002;
  *(void *)(a3 + 16) = 0x100000002;
  return result;
}

uint64_t llvm::PGOInstrumentationUse::PGOInstrumentationUse(uint64_t a1, long long *a2, long long *a3, char a4, void *a5)
{
  long long v6 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v6;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  long long v7 = *a3;
  *(void *)(a1 + 40) = *((void *)a3 + 2);
  *(_OWORD *)(a1 + 24) = v7;
  *((void *)a3 + 1) = 0;
  *((void *)a3 + 2) = 0;
  *(void *)a3 = 0;
  *(unsigned char *)(a1 + 48) = a4;
  *(void *)(a1 + 56) = *a5;
  *a5 = 0;
  if (byte_1EBCEB6DF >= 0) {
    uint64_t v8 = byte_1EBCEB6DF & 0x7F;
  }
  else {
    uint64_t v8 = qword_1EBCEB6D0;
  }
  if (v8)
  {
    if (byte_1EBCEB6DF >= 0) {
      uint64_t v9 = &qword_1EBCEB6C8;
    }
    else {
      uint64_t v9 = (uint64_t *)qword_1EBCEB6C8;
    }
    MEMORY[0x1D25D9640](a1, v9);
  }
  if (byte_1EBCEB7C7 >= 0) {
    uint64_t v10 = byte_1EBCEB7C7 & 0x7F;
  }
  else {
    uint64_t v10 = qword_1EBCEB7B8;
  }
  if (v10)
  {
    if (byte_1EBCEB7C7 >= 0) {
      long long v11 = &qword_1EBCEB7B0;
    }
    else {
      long long v11 = (uint64_t *)qword_1EBCEB7B0;
    }
    MEMORY[0x1D25D9640](a1 + 24, v11);
  }
  if (!*(void *)(a1 + 56))
  {
    llvm::vfs::getRealFileSystem(&v15);
    size_t v13 = v15;
    int v15 = *(atomic_uint **)(a1 + 56);
    std::string::size_type v14 = v15;
    *(void *)(a1 + 56) = v13;
    if (v14)
    {
      if (atomic_fetch_add(v14 + 2, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v14 + 8))(v14);
      }
    }
  }
  return a1;
}

void llvm::PGOInstrumentationUse::run()
{
}

__n128 sub_1CD697E94(uint64_t a1, long long *a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12)) {
    sub_1CD697FE8();
  }
  uint64_t v3 = *(void *)a1 + 48 * v2;
  long long v4 = *a2;
  *(void *)(v3 + 16) = *((void *)a2 + 2);
  *(_OWORD *)uint64_t v3 = v4;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  *(void *)(v3 + 24) = 0;
  *(void *)(v3 + 32) = 0;
  *(void *)(v3 + 40) = 0;
  __n128 result = *(__n128 *)((char *)a2 + 24);
  *(__n128 *)(v3 + 24) = result;
  *(void *)(v3 + 40) = *((void *)a2 + 5);
  *((void *)a2 + 3) = 0;
  *((void *)a2 + 4) = 0;
  *((void *)a2 + 5) = 0;
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1CD697EF8(uint64_t *a1, char *__s, uint64_t *a3)
{
  unsigned int v6 = *((_DWORD *)a1 + 2);
  if (v6 >= *((_DWORD *)a1 + 3))
  {
    sub_1CD6980B4();
  }
  uint64_t v7 = *a1 + 48 * v6;
  std::string::size_type v8 = strlen(__s);
  std::string::__init(&v15, __s, v8);
  uint64_t v9 = *a3;
  long long v10 = *(_OWORD *)&v15.__r_.__value_.__l.__data_;
  *(void *)(v7 + 16) = *((void *)&v15.__r_.__value_.__l + 2);
  *(_OWORD *)uint64_t v7 = v10;
  *(void *)(v7 + 32) = 0;
  *(void *)(v7 + 40) = 0;
  long long v11 = operator new(8uLL);
  *(void *)(v7 + 24) = v11;
  *(void *)(v7 + 40) = v11 + 1;
  *long long v11 = v9;
  *(void *)(v7 + 32) = v11 + 1;
  uint64_t v12 = *a1;
  unsigned int v13 = *((_DWORD *)a1 + 2) + 1;
  *((_DWORD *)a1 + 2) = v13;
  return v12 + 48 * v13 - 48;
}

void sub_1CD697FE8()
{
}

void sub_1CD6980B4()
{
  uint64_t v0 = 0;
  llvm::SmallVectorBase<unsigned int>::mallocForGrow();
}

uint64_t sub_1CD6981A8(uint64_t a1, __n128 *a2)
{
  sub_1CD46D2D8(a1, a2);
  unint64_t v4 = a2[1].n128_u64[1];
  a2[1].n128_u64[1] = 0;
  char v5 = *(void ***)(a1 + 24);
  *(void *)(a1 + 24) = v4;
  if (v5)
  {
    uint64_t v7 = sub_1CD698204(v5);
    MEMORY[0x1D25D9CE0](v7, 0x20C40A759441BLL);
  }
  return a1;
}

void **sub_1CD698204(void **a1)
{
  uint64_t v3 = a1 + 3;
  unsigned int v2 = a1[3];
  if (v2)
  {
    sub_1CCB49618(a1 + 3, v2);
    operator delete(*v3);
  }
  if (*a1)
  {
    sub_1CCB49618(a1, *a1);
    operator delete(*a1);
  }
  return a1;
}

uint64_t sub_1CD69825C(uint64_t a1)
{
  unsigned int v2 = *(void ***)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v2)
  {
    char v5 = sub_1CD698204(v2);
    MEMORY[0x1D25D9CE0](v5, 0x20C40A759441BLL);
  }
  uint64_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_1CD6982B8(const char **a1, _WORD *a2, long long *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCEB648, 0, 0);
  qword_1EBCEB6C8 = 0;
  qword_1EBCEB6D0 = 0;
  qword_1EBCEB6F0 = 0;
  unk_1EBCEB6F8 = 0;
  byte_1EBCEB700 = 0;
  qword_1EBCEB6E8 = 0;
  unk_1EBCEB6D8 = 0;
  unk_1EBCEB6E0 = &unk_1F2643C20;
  qword_1EBCEB648 = (uint64_t)&unk_1F2643FD0;
  qword_1EBCEB708 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCEB710 = (uint64_t)&unk_1F25F6428;
  qword_1EBCEB728 = (uint64_t)&qword_1EBCEB710;
  sub_1CD6983C4(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCEB648);
}

__n128 sub_1CD6983C4(const char **a1, _WORD *a2, long long *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCEB648, "pgo-test-profile-file", 0x15uLL);
  sub_1CBAD7D28(a1, (uint64_t)&qword_1EBCEB648);
  word_1EBCEB652 = (32 * (*a2 & 3)) | word_1EBCEB652 & 0xFF9F;
  xmmword_1EBCEB678 = *a3;
  __n128 result = *a4;
  xmmword_1EBCEB668 = (__int128)*a4;
  return result;
}

void sub_1CD698450(const char **a1, _WORD *a2, long long *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCEB730, 0, 0);
  qword_1EBCEB7B0 = 0;
  qword_1EBCEB7B8 = 0;
  qword_1EBCEB7D8 = 0;
  unk_1EBCEB7E0 = 0;
  byte_1EBCEB7E8 = 0;
  qword_1EBCEB7D0 = 0;
  unk_1EBCEB7C0 = 0;
  unk_1EBCEB7C8 = &unk_1F2643C20;
  qword_1EBCEB730 = (uint64_t)&unk_1F2643FD0;
  qword_1EBCEB7F0 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCEB7F8 = (uint64_t)&unk_1F25F6428;
  qword_1EBCEB810 = (uint64_t)&qword_1EBCEB7F8;
  sub_1CD69855C(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCEB730);
}

__n128 sub_1CD69855C(const char **a1, _WORD *a2, long long *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCEB730, "pgo-test-profile-remapping-file", 0x1FuLL);
  sub_1CBAD7D28(a1, (uint64_t)&qword_1EBCEB730);
  word_1EBCEB73A = (32 * (*a2 & 3)) | word_1EBCEB73A & 0xFF9F;
  xmmword_1EBCEB760 = *a3;
  __n128 result = *a4;
  xmmword_1EBCEB750 = (__int128)*a4;
  return result;
}

void sub_1CD6985E8(int **a1, _WORD *a2, _WORD *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCEAA48, 0, 0);
  dword_1EBCEAAC8 = 0;
  qword_1EBCEAAD0 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCEAAD8 = 0;
  qword_1EBCEAA48 = (uint64_t)&unk_1F2643F00;
  qword_1EBCEAAE0 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCEAAE8 = (uint64_t)&unk_1F25EA168;
  qword_1EBCEAB00 = (uint64_t)&qword_1EBCEAAE8;
  sub_1CD6986E8(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCEAA48);
}

__n128 sub_1CD6986E8(int **a1, _WORD *a2, _WORD *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCEAA48, "icp-max-annotations", 0x13uLL);
  dword_1EBCEAAC8 = **a1;
  byte_1EBCEAADC = 1;
  dword_1EBCEAAD8 = dword_1EBCEAAC8;
  word_1EBCEAA52 = word_1EBCEAA52 & 0xFF9F | (32 * (*a2 & 3));
  word_1EBCEAA52 = word_1EBCEAA52 & 0xFFF8 | *a3 & 7;
  __n128 result = *a4;
  xmmword_1EBCEAA68 = (__int128)*a4;
  return result;
}

void sub_1CD69877C(_WORD *a1, long long *a2, uint64_t *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCEA730, 0, 0);
  dword_1EBCEA7B0 = 0;
  qword_1EBCEA7B8 = (uint64_t)&unk_1F2601030;
  unk_1EBCEA7C0 = 0;
  qword_1EBCEA730 = (uint64_t)&unk_1F2600F78;
  qword_1EBCEA7C8 = (uint64_t)&unk_1F2600FE0;
  unk_1EBCEA7D0 = &qword_1EBCEA730;
  qword_1EBCEA7D8 = (uint64_t)&unk_1EBCEA7E8;
  qword_1EBCEA7E0 = 0x800000000;
  qword_1EBCEA968 = (uint64_t)&unk_1F2601120;
  qword_1EBCEA980 = (uint64_t)&qword_1EBCEA968;
  sub_1CD698880(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCEA730);
}

void sub_1CD698880(_WORD *a1, long long *a2, uint64_t *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCEA730, "pgo-view-raw-counts", 0x13uLL);
  word_1EBCEA73A = (32 * (*a1 & 3)) | word_1EBCEA73A & 0xFF9F;
  xmmword_1EBCEA750 = *a2;

  sub_1CBF7AB24(a3, (uint64_t)&qword_1EBCEA730);
}

void sub_1CD698904(_WORD *a1, _WORD *a2, int **a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCEB818, 0, 0);
  dword_1EBCEB898 = 0;
  qword_1EBCEB8A0 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCEB8A8 = 0;
  qword_1EBCEB818 = (uint64_t)&unk_1F2643F00;
  qword_1EBCEB8B0 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCEB8B8 = (uint64_t)&unk_1F25EA168;
  qword_1EBCEB8D0 = (uint64_t)&qword_1EBCEB8B8;
  sub_1CD698A04(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCEB818);
}

__n128 sub_1CD698A04(_WORD *a1, _WORD *a2, int **a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCEB818, "pgo-memop-count-threshold", 0x19uLL);
  word_1EBCEB822 = word_1EBCEB822 & 0xFF9F | (32 * (*a1 & 3));
  word_1EBCEB822 = word_1EBCEB822 & 0xFFF8 | *a2 & 7;
  dword_1EBCEB898 = **a3;
  byte_1EBCEB8AC = 1;
  dword_1EBCEB8A8 = dword_1EBCEB898;
  __n128 result = *a4;
  xmmword_1EBCEB838 = (__int128)*a4;
  return result;
}

double llvm::PoisonCheckingPass::run@<D0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v3 = a1 + 24;
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4 == a1 + 24)
  {
    *(void *)(a2 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
    *(void *)a2 = a2 + 32;
    *(void *)(a2 + 8) = a2 + 32;
    *(_DWORD *)(a2 + 24) = 0;
    *(void *)(a2 + 48) = a2 + 80;
    *(void *)(a2 + 56) = a2 + 80;
    *(void *)(a2 + 64) = 2;
    *(_DWORD *)(a2 + 72) = 0;
    *(void *)&double result = 0x100000002;
    *(void *)(a2 + 16) = 0x100000002;
  }
  else
  {
    do
    {
      if (v4) {
        char v5 = (uint64_t ***)(v4 - 56);
      }
      else {
        char v5 = 0;
      }
      sub_1CCB4CD90(v5);
      uint64_t v4 = *(void *)(v4 + 8);
    }
    while (v4 != v3);
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(void *)(a2 + 88) = 0;
    *(_OWORD *)(a2 + 72) = 0u;
    *(_OWORD *)(a2 + 24) = 0u;
    *(void *)a2 = a2 + 32;
    *(void *)(a2 + 8) = a2 + 32;
    *(void *)&double result = 2;
    *(void *)(a2 + 16) = 2;
    *(void *)(a2 + 48) = a2 + 80;
    *(void *)(a2 + 56) = a2 + 80;
    *(_DWORD *)(a2 + 64) = 2;
  }
  return result;
}

void sub_1CD698B68(char **a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)qword_1EBCEBC98, 0, 0);
  byte_1EBCEBD18 = 0;
  qword_1EBCEBD20 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCEBD28 = 0;
  qword_1EBCEBC98[0] = (uint64_t)&unk_1F26440A0;
  qword_1EBCEBD30 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCEBD38 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCEBD50 = (uint64_t)&qword_1EBCEBD38;
  llvm::cl::Option::setArgStr(v4, "poison-checking-function-local", 0x1EuLL);
  char v5 = *a1;
  byte_1EBCEBD18 = **a1;
  byte_1EBCEBD29 = 1;
  byte_1EBCEBD28 = *v5;
  xmmword_1EBCEBCB8 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EBCEBC98);
}

void llvm::ModuleSanitizerCoveragePass::run(uint64_t a1)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  sub_1CCB4E64C((uint64_t)v1, (int *)a1, *(void *)(a1 + 24), *(void *)(a1 + 32));
  llvm::AnalysisManager<llvm::Module>::getResultImpl();
}

void llvm::createModuleSanitizerCoverageLegacyPassPass()
{
}

void sub_1CD698E0C(__n128 *a1, _WORD *a2, int **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCEBD68, 0, 0);
  dword_1EBCEBDE8 = 0;
  qword_1EBCEBDF0 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCEBDF8 = 0;
  qword_1EBCEBD68 = (uint64_t)&unk_1F2643F68;
  qword_1EBCEBE00 = (uint64_t)&unk_1F2643D20;
  qword_1EBCEBE08 = (uint64_t)&unk_1F25F7480;
  qword_1EBCEBE20 = (uint64_t)&qword_1EBCEBE08;
  sub_1CD698EFC(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCEBD68);
}

__n128 sub_1CD698EFC(__n128 *a1, _WORD *a2, int **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCEBD68, "sanitizer-coverage-level", 0x18uLL);
  __n128 result = *a1;
  xmmword_1EBCEBD88 = (__int128)*a1;
  word_1EBCEBD72 = (32 * (*a2 & 3)) | word_1EBCEBD72 & 0xFF9F;
  uint64_t v7 = *a3;
  dword_1EBCEBDE8 = **a3;
  byte_1EBCEBDFC = 1;
  dword_1EBCEBDF8 = *v7;
  return result;
}

void sub_1CD698F84(__n128 *a1, _WORD *a2, char **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCEC068, 0, 0);
  byte_1EBCEC0E8 = 0;
  qword_1EBCEC0F0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCEC0F8 = 0;
  qword_1EBCEC068 = (uint64_t)&unk_1F26440A0;
  qword_1EBCEC100 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCEC108 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCEC120 = (uint64_t)&qword_1EBCEC108;
  sub_1CD699074(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCEC068);
}

__n128 sub_1CD699074(__n128 *a1, _WORD *a2, char **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCEC068, "sanitizer-coverage-inline-8bit-counters", 0x27uLL);
  __n128 result = *a1;
  xmmword_1EBCEC088 = (__int128)*a1;
  word_1EBCEC072 = (32 * (*a2 & 3)) | word_1EBCEC072 & 0xFF9F;
  uint64_t v7 = *a3;
  byte_1EBCEC0E8 = **a3;
  byte_1EBCEC0F9 = 1;
  byte_1EBCEC0F8 = *v7;
  return result;
}

void sub_1CD6990FC(__n128 *a1, _WORD *a2, char **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCEC728, 0, 0);
  byte_1EBCEC7A8 = 0;
  qword_1EBCEC7B0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCEC7B8 = 0;
  qword_1EBCEC728 = (uint64_t)&unk_1F26440A0;
  qword_1EBCEC7C0 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCEC7C8 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCEC7E0 = (uint64_t)&qword_1EBCEC7C8;
  sub_1CD6991EC(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCEC728);
}

__n128 sub_1CD6991EC(__n128 *a1, _WORD *a2, char **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCEC728, "sanitizer-coverage-gated-trace-callbacks", 0x28uLL);
  __n128 result = *a1;
  xmmword_1EBCEC748 = (__int128)*a1;
  word_1EBCEC732 = (32 * (*a2 & 3)) | word_1EBCEC732 & 0xFF9F;
  uint64_t v7 = *a3;
  byte_1EBCEC7A8 = **a3;
  byte_1EBCEC7B9 = 1;
  byte_1EBCEC7B8 = *v7;
  return result;
}

void llvm::createSoftPointerAuthPass(llvm *this)
{
}

void llvm::SoftPointerAuthPass::run(uint64_t **a1@<X1>, const llvm::APInt *a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  char v8 = 0;
  memset(v6, 0, 89);
  if (sub_1CCB58458((uint64_t ***)v6, a1, a2))
  {
    int v4 = 0;
    *(void *)(a3 + 88) = 0;
    *(_OWORD *)(a3 + 72) = 0u;
    *(_OWORD *)(a3 + 56) = 0u;
    *(_OWORD *)(a3 + 40) = 0u;
    uint64_t v5 = a3 + 32;
    *(_OWORD *)(a3 + 24) = 0u;
  }
  else
  {
    *(void *)(a3 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
    uint64_t v5 = a3 + 32;
    int v4 = 1;
  }
  *(void *)a3 = v5;
  *(void *)(a3 + 8) = v5;
  *(_DWORD *)(a3 + 16) = 2;
  *(_DWORD *)(a3 + 20) = v4;
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 48) = a3 + 80;
  *(void *)(a3 + 56) = a3 + 80;
  *(void *)(a3 + 64) = 2;
  *(_DWORD *)(a3 + 72) = 0;
  if (v8)
  {
    if (*(uint64_t **)&v6[88] != &v7) {
      free(*(void **)&v6[88]);
    }
  }
}

double sub_1CD6993AC(uint64_t a1, llvm::BasicBlock **a2)
{
  if (*(unsigned char *)(a1 + 136))
  {
    uint64_t v3 = *(void **)a1;
    if (*(void *)a1 != a1 + 16)
    {
      uint64_t v7 = a2;
      free(v3);
      a2 = v7;
    }
    *(unsigned char *)(a1 + 136) = 0;
  }
  int v4 = *a2;
  uint64_t Context = llvm::BasicBlock::getContext(*a2);
  *(void *)a1 = a1 + 16;
  *(void *)&double result = 0x200000000;
  *(void *)(a1 + 8) = 0x200000000;
  *(void *)(a1 + 64) = Context;
  *(void *)(a1 + 72) = a1 + 120;
  *(void *)(a1 + 80) = a1 + 128;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(_WORD *)(a1 + 100) = 512;
  *(unsigned char *)(a1 + 102) = 7;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = &unk_1F2616E88;
  *(void *)(a1 + 128) = &unk_1F2617008;
  *(void *)(a1 + 48) = v4;
  *(void *)(a1 + 56) = (char *)v4 + 40;
  *(unsigned char *)(a1 + 136) = 1;
  return result;
}

void llvm::ValueProfileCollector::get(uint64_t **a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v3 = *a1;
  if (a2)
  {
    if (a2 == 1)
    {
      uint64_t v6 = v3[1];
      uint64_t v5 = v3 + 1;
      uint64_t v5[2] = (uint64_t)a3;
      sub_1CD699594((char *)v5, v6);
      uint64_t v5[2] = 0;
    }
  }
  else
  {
    int v4 = *a1;
    sub_1CD699830(v4, (uint64_t)a3);
  }
}

char *sub_1CD699594(char *result, uint64_t a2)
{
  uint64_t v2 = a2 + 72;
  uint64_t v3 = *(void *)(a2 + 80);
  if (v3 != a2 + 72)
  {
    int v4 = result;
    do
    {
      uint64_t v5 = v3 - 24;
      BOOL v6 = v3 == 0;
      uint64_t v3 = *(void *)(v3 + 8);
      if (v6) {
        uint64_t v5 = 0;
      }
      uint64_t v7 = v5 + 40;
      uint64_t v8 = *(void *)(v5 + 48);
      if (v8 != v7)
      {
        do
        {
          uint64_t v9 = *(void *)(v8 + 8);
          if (v8) {
            uint64_t v10 = v8 - 24;
          }
          else {
            uint64_t v10 = 0;
          }
          if (*(unsigned char *)(v10 + 16) == 84) {
            double result = sub_1CD699634(v4, v10);
          }
          uint64_t v8 = v9;
        }
        while (v9 != v7);
      }
    }
    while (v3 != v2);
  }
  return result;
}

char *sub_1CD699634(char *result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 - 32);
  if (v2 && !*(unsigned char *)(v2 + 16) && *(void *)(v2 + 24) == *(void *)(a2 + 72))
  {
    int v3 = *(_DWORD *)(v2 + 36);
    if (v3 > 196)
    {
      if (v3 <= 312 && (v3 == 197 || v3 == 199)) {
        return sub_1CD6997B0(result, a2);
      }
    }
    else if (v3 == 194)
    {
      return sub_1CD6997B0(result, a2);
    }
  }
  return sub_1CD6996C8(result, a2);
}

char *sub_1CD6996C8(char *result, uint64_t a2)
{
  if (byte_1EBD09858)
  {
    uint64_t v3 = *(void *)(a2 - 32);
    if (v3)
    {
      if (!*(unsigned char *)(v3 + 16) && *(void *)(v3 + 24) == *(void *)(a2 + 72))
      {
        int v4 = result;
        int v9 = 0;
        double result = (char *)sub_1CC0A4DF4(*((uint64_t **)result + 1), a2, &v9);
        if (result)
        {
          if ((v9 == 321 || v9 == 168)
            && *(unsigned char *)(*(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 64) + 16) != 16)
          {
            uint64_t v5 = *((void *)v4 + 2);
            *(void *)&long long v7 = *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 64);
            *((void *)&v7 + 1) = a2;
            uint64_t v8 = a2;
            unint64_t v6 = *(void *)(v5 + 8);
            if (v6 >= *(void *)(v5 + 16))
            {
              double result = sub_1CBF99908((void **)v5, (uint64_t)&v7);
            }
            else
            {
              *(_OWORD *)unint64_t v6 = v7;
              *(void *)(v6 + 16) = v8;
              double result = (char *)(v6 + 24);
            }
            *(void *)(v5 + 8) = result;
          }
        }
      }
    }
  }
  return result;
}

char *sub_1CD6997B0(char *result, uint64_t a2)
{
  if (*(unsigned char *)(*(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 64) + 16) != 16)
  {
    uint64_t v2 = *((void *)result + 2);
    *(void *)&long long v4 = *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 64);
    *((void *)&v4 + 1) = a2;
    uint64_t v5 = a2;
    unint64_t v3 = *(void *)(v2 + 8);
    if (v3 >= *(void *)(v2 + 16))
    {
      double result = sub_1CBF99908((void **)v2, (uint64_t)&v4);
    }
    else
    {
      *(_OWORD *)unint64_t v3 = v4;
      *(void *)(v3 + 16) = v5;
      double result = (char *)(v3 + 24);
    }
    *(void *)(v2 + 8) = result;
  }
  return result;
}

void sub_1CD699830(uint64_t *a1, uint64_t a2)
{
  sub_1CD694DFC(*a1, &v10);
  unint64_t v3 = v10;
  long long v4 = v11;
  if (v10 != v11)
  {
    uint64_t v5 = *(char **)(a2 + 8);
    do
    {
      uint64_t v6 = *v3;
      *(void *)&long long v8 = *(void *)(*v3 - 32);
      *((void *)&v8 + 1) = v6;
      uint64_t v9 = v6;
      if ((unint64_t)v5 >= *(void *)(a2 + 16))
      {
        uint64_t v5 = sub_1CBF99908((void **)a2, (uint64_t)&v8);
      }
      else
      {
        long long v7 = v8;
        *((void *)v5 + 2) = v9;
        *(_OWORD *)uint64_t v5 = v7;
        v5 += 24;
      }
      *(void *)(a2 + 8) = v5;
      ++v3;
    }
    while (v3 != v4);
    unint64_t v3 = v10;
  }
  if (v3)
  {
    long long v11 = v3;
    operator delete(v3);
  }
}

void llvm::ThreadSanitizerPass::run()
{
  sub_1CCB5BAB4((uint64_t)v0);
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

double llvm::ModuleThreadSanitizerPass::run@<D0>(llvm::Module *a1@<X1>, uint64_t a2@<X8>)
{
  v4[3] = (uint64_t)a1;
  llvm::getOrCreateSanitizerCtorAndInitFunctions(a1, "tsan.module_ctor", (const char *)0x10, "__tsan_init", (const char *)0xB, 0, 0, v4);
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(void *)(a2 + 88) = 0;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(void *)a2 = a2 + 32;
  *(void *)(a2 + 8) = a2 + 32;
  *(void *)&double result = 2;
  *(void *)(a2 + 16) = 2;
  *(void *)(a2 + 48) = a2 + 80;
  *(void *)(a2 + 56) = a2 + 80;
  *(_DWORD *)(a2 + 64) = 2;
  return result;
}

void llvm::createThreadSanitizerLegacyPassPass(llvm *this)
{
}

llvm::PointerType *sub_1CD699A94(uint64_t a1, unsigned __int8 *a2, const char *a3, uint64_t a4, uint64_t **a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  v16[5] = *MEMORY[0x1E4F143B8];
  v16[0] = a6;
  v16[1] = a7;
  v16[2] = a8;
  v16[3] = a9;
  v16[4] = a10;
  std::string::size_type v14 = (llvm::PointerType *)llvm::FunctionType::get(a5, (uint64_t)v16, 5, 0);
  return llvm::Module::getOrInsertFunction(a1, a2, a3, v14, a4);
}

uint64_t sub_1CD699B74(unsigned __int8 *a1)
{
  if (llvm::Instruction::isAtomic((llvm::Instruction *)a1))
  {
    int v3 = a1[16];
    if (a1 && v3 == 60 || a1 && v3 == 61 || a1 && v3 == 63 || a1 && v3 == 64 || (int v4 = 1, a1) && v3 == 65)
    {
      unsigned __int8 v2 = a1[60];
      int v4 = 1;
    }
  }
  else
  {
    unsigned __int8 v2 = 0;
    int v4 = 0;
  }
  return v2 | (v4 << 8);
}

llvm::cl::Option *sub_1CD699C00(llvm::cl::Option *a1, char *a2, unsigned char **a3, __n128 *a4, _WORD *a5)
{
  uint64_t v10 = sub_1CB883A14((uint64_t)a1, 0, 0);
  *(unsigned char *)(v10 + 128) = 0;
  *(void *)(v10 + 136) = &unk_1F25EDE58;
  *(void *)(v10 + 144) = 0;
  *(void *)uint64_t v10 = &unk_1F26440A0;
  *(void *)(v10 + 152) = &unk_1F2643CC0;
  *(void *)(v10 + 160) = &unk_1F25EDE78;
  *(void *)(v10 + 184) = v10 + 160;
  sub_1CD699CF0(v10, a2, a3, a4, a5);
  llvm::cl::Option::addArgument(a1);
  return a1;
}

__n128 sub_1CD699CF0(uint64_t a1, char *__s, unsigned char **a3, __n128 *a4, _WORD *a5)
{
  size_t v10 = strlen(__s);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)__s, v10);
  long long v11 = *a3;
  *(unsigned char *)(a1 + 128) = **a3;
  *(unsigned char *)(a1 + 145) = 1;
  *(unsigned char *)(a1 + 144) = *v11;
  __n128 result = *a4;
  *(__n128 *)(a1 + 32) = *a4;
  *(_WORD *)(a1 + 10) = (32 * (*a5 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  return result;
}

void sub_1CD699D84(char **a1, __n128 *a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCEC988, 0, 0);
  byte_1EBCECA08 = 0;
  qword_1EBCECA10 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCECA18 = 0;
  qword_1EBCEC988 = (uint64_t)&unk_1F26440A0;
  qword_1EBCECA20 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCECA28 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCECA40 = (uint64_t)&qword_1EBCECA28;
  sub_1CD699E74(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCEC988);
}

__n128 sub_1CD699E74(char **a1, __n128 *a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCEC988, "tsan-handle-cxx-exceptions", 0x1AuLL);
  uint64_t v6 = *a1;
  byte_1EBCECA08 = **a1;
  byte_1EBCECA19 = 1;
  byte_1EBCECA18 = *v6;
  __n128 result = *a2;
  xmmword_1EBCEC9A8 = (__int128)*a2;
  word_1EBCEC992 = (32 * (*a3 & 3)) | word_1EBCEC992 & 0xFF9F;
  return result;
}

void sub_1CD699EFC(char **a1, __n128 *a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCECA48, 0, 0);
  byte_1EBCECAC8 = 0;
  qword_1EBCECAD0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCECAD8 = 0;
  qword_1EBCECA48 = (uint64_t)&unk_1F26440A0;
  qword_1EBCECAE0 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCECAE8 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCECB00 = (uint64_t)&qword_1EBCECAE8;
  sub_1CD699FEC(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCECA48);
}

__n128 sub_1CD699FEC(char **a1, __n128 *a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCECA48, "tsan-instrument-atomics", 0x17uLL);
  uint64_t v6 = *a1;
  byte_1EBCECAC8 = **a1;
  byte_1EBCECAD9 = 1;
  byte_1EBCECAD8 = *v6;
  __n128 result = *a2;
  xmmword_1EBCECA68 = (__int128)*a2;
  word_1EBCECA52 = (32 * (*a3 & 3)) | word_1EBCECA52 & 0xFF9F;
  return result;
}

void sub_1CD69A074(char **a1, __n128 *a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCECB08, 0, 0);
  byte_1EBCECB88 = 0;
  qword_1EBCECB90 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCECB98 = 0;
  qword_1EBCECB08 = (uint64_t)&unk_1F26440A0;
  qword_1EBCECBA0 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCECBA8 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCECBC0 = (uint64_t)&qword_1EBCECBA8;
  sub_1CD69A164(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCECB08);
}

__n128 sub_1CD69A164(char **a1, __n128 *a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCECB08, "tsan-instrument-memintrinsics", 0x1DuLL);
  uint64_t v6 = *a1;
  byte_1EBCECB88 = **a1;
  byte_1EBCECB99 = 1;
  byte_1EBCECB98 = *v6;
  __n128 result = *a2;
  xmmword_1EBCECB28 = (__int128)*a2;
  word_1EBCECB12 = (32 * (*a3 & 3)) | word_1EBCECB12 & 0xFF9F;
  return result;
}

void sub_1CD69A1EC(char **a1, __n128 *a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCECBC8, 0, 0);
  byte_1EBCECC48 = 0;
  qword_1EBCECC50 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCECC58 = 0;
  qword_1EBCECBC8 = (uint64_t)&unk_1F26440A0;
  qword_1EBCECC60 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCECC68 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCECC80 = (uint64_t)&qword_1EBCECC68;
  sub_1CD69A2DC(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCECBC8);
}

__n128 sub_1CD69A2DC(char **a1, __n128 *a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCECBC8, "tsan-distinguish-volatile", 0x19uLL);
  uint64_t v6 = *a1;
  byte_1EBCECC48 = **a1;
  byte_1EBCECC59 = 1;
  byte_1EBCECC58 = *v6;
  __n128 result = *a2;
  xmmword_1EBCECBE8 = (__int128)*a2;
  word_1EBCECBD2 = (32 * (*a3 & 3)) | word_1EBCECBD2 & 0xFF9F;
  return result;
}

void sub_1CD69A364(char **a1, __n128 *a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCECC88, 0, 0);
  byte_1EBCECD08 = 0;
  qword_1EBCECD10 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCECD18 = 0;
  qword_1EBCECC88 = (uint64_t)&unk_1F26440A0;
  qword_1EBCECD20 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCECD28 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCECD40 = (uint64_t)&qword_1EBCECD28;
  sub_1CD69A454(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCECC88);
}

__n128 sub_1CD69A454(char **a1, __n128 *a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCECC88, "tsan-instrument-read-before-write", 0x21uLL);
  uint64_t v6 = *a1;
  byte_1EBCECD08 = **a1;
  byte_1EBCECD19 = 1;
  byte_1EBCECD18 = *v6;
  __n128 result = *a2;
  xmmword_1EBCECCA8 = (__int128)*a2;
  word_1EBCECC92 = (32 * (*a3 & 3)) | word_1EBCECC92 & 0xFF9F;
  return result;
}

void llvm::createHWAddressSanitizerLegacyPassPass(llvm *this)
{
}

void llvm::HWAddressSanitizerPass::run(BOOL *a1, uint64_t **a2)
{
  __int16 v7 = 260;
  v6[0] = a2 + 27;
  llvm::Triple::Triple((llvm::Triple *)&v8, (const llvm::Twine *)v6);
  if ((v9 != 42 || byte_1EA61DC00 == 0) && byte_1EBCED3D8 != 0)
  {
    if (word_1EBCED420)
    {
      if (byte_1EBCED498) {
        goto LABEL_12;
      }
    }
    else if (!a1[2])
    {
LABEL_12:
      llvm::AnalysisManager<llvm::Module>::getResultImpl();
    }
  }
  sub_1CCB605CC((uint64_t)v6, a2, *a1, a1[1], 0);
  llvm::AnalysisManager<llvm::Module>::getResultImpl();
}

llvm::raw_ostream *llvm::HWAddressSanitizerPass::printPipeline(unsigned char *a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, char *, uint64_t), uint64_t a4)
{
  sub_1CD69A7DC(a2, a3, a4);
  sub_1CB8E509C(a2, "<");
  if (*a1) {
    sub_1CB8E509C(a2, "kernel;");
  }
  if (a1[1]) {
    sub_1CB8E509C(a2, "recover");
  }

  return sub_1CB8E509C(a2, ">");
}

llvm::raw_ostream *sub_1CD69A7DC(llvm::raw_ostream *a1, uint64_t (*a2)(uint64_t, char *, uint64_t), uint64_t a3)
{
  uint64_t v6 = sub_1CD69B974();
  int v9 = (const void *)a2(a3, v6, v7);
  size_t v10 = v8;
  __n128 result = (llvm::raw_ostream *)*((void *)a1 + 4);
  if (v8 <= *((void *)a1 + 3) - (void)result)
  {
    if (v8)
    {
      __n128 result = (llvm::raw_ostream *)memcpy(result, v9, v8);
      *((void *)a1 + 4) += v10;
    }
  }
  else
  {
    return llvm::raw_ostream::write(a1, (const char *)v9, v8);
  }
  return result;
}

uint64_t sub_1CD69A888(uint64_t a1, unint64_t *a2)
{
  uint64_t v13 = *a2;
  int v14 = 0;
  sub_1CD5092D4((uint64_t)&v11, a1, &v13, &v14);
  uint64_t v4 = v11;
  if (v12)
  {
    long long v8 = *a2;
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    sub_1CC4CE04C((uint64_t *)(a1 + 24), &v8);
    if (*((void *)&v8 + 1)) {
      operator delete(*((void **)&v8 + 1));
    }
    uint64_t v5 = *(void *)(a1 + 24);
    unsigned int v6 = ((unint64_t)(*(void *)(a1 + 32) - v5) >> 5) - 1;
    *(_DWORD *)(v4 + 8) = v6;
  }
  else
  {
    unsigned int v6 = *(_DWORD *)(v11 + 8);
    uint64_t v5 = *(void *)(a1 + 24);
  }
  return v5 + 32 * v6 + 8;
}

llvm::PointerType *sub_1CD69A93C(uint64_t a1, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  v13[8] = *MEMORY[0x1E4F143B8];
  v13[0] = a3;
  v13[1] = a4;
  void v13[2] = a5;
  void v13[3] = a6;
  int v13[4] = a7;
  v13[5] = a8;
  v13[6] = a9;
  unint64_t v13[7] = a10;
  uint64_t v11 = (llvm::PointerType *)llvm::FunctionType::get(a2, (uint64_t)v13, 8, 0);
  return llvm::Module::getOrInsertFunction(a1, "__hwasan_personality_wrapper", (const char *)0x1C, v11, 0);
}

uint64_t sub_1CD69AA10(uint64_t a1)
{
  unsigned __int8 v2 = *(void **)(a1 + 96);
  if (v2 != (void *)(a1 + 112)) {
    free(v2);
  }
  int v3 = *(void **)(a1 + 48);
  if (v3 != (void *)(a1 + 64)) {
    free(v3);
  }

  return sub_1CD69AA6C(a1);
}

uint64_t sub_1CD69AA6C(uint64_t a1)
{
  int v3 = (void **)(a1 + 24);
  sub_1CCB69584(&v3);
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);
  return a1;
}

void *sub_1CD69AAB4(void *a1)
{
  unsigned __int8 v2 = (void *)a1[9];
  if (v2 != a1 + 11) {
    free(v2);
  }
  int v3 = (void *)a1[5];
  if (v3 != a1 + 7) {
    free(v3);
  }
  uint64_t v4 = (void *)a1[1];
  if (v4 != a1 + 3) {
    free(v4);
  }
  return a1;
}

void sub_1CD69AB14(long long *a1, _WORD *a2, const char **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EA61DDD0, 0, 0);
  *(void *)byte_1EA61DE50 = 0;
  *(void *)&byte_1EA61DE50[8] = 0;
  qword_1EA61DE78 = 0;
  unk_1EA61DE80 = 0;
  byte_1EA61DE88 = 0;
  qword_1EA61DE70 = 0;
  *(void *)&byte_1EA61DE50[16] = 0;
  unk_1EA61DE68 = &unk_1F2643C20;
  qword_1EA61DDD0 = (uint64_t)&unk_1F2643FD0;
  qword_1EA61DE90 = (uint64_t)&unk_1F2643EA0;
  qword_1EA61DE98 = (uint64_t)&unk_1F25F6428;
  qword_1EA61DEB0 = (uint64_t)&qword_1EA61DE98;
  sub_1CD69AC10(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EA61DDD0);
}

void sub_1CD69AC10(long long *a1, _WORD *a2, const char **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EA61DDD0, "hwasan-memory-access-callback-prefix", 0x24uLL);
  xmmword_1EA61DDF0 = *a1;
  word_1EA61DDDA = (32 * (*a2 & 3)) | word_1EA61DDDA & 0xFF9F;
  unsigned int v6 = *a3;

  sub_1CD69AC90(v6);
}

void sub_1CD69AC90(const char *a1)
{
  std::string::size_type v2 = strlen(a1);
  std::string::__init(&__str, a1, v2);
  std::string::operator=((std::string *)byte_1EA61DE50, &__str);
  byte_1EA61DE88 = 1;
  std::string::operator=((std::string *)&qword_1EA61DE70, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_1CD69AD08(_WORD *a1, char **a2, _WORD *a3, __n128 *a4, _WORD *a5)
{
  sub_1CB883A14((uint64_t)&qword_1EBCED418, 0, 0);
  byte_1EBCED498 = 0;
  qword_1EBCED4A0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCED4A8 = 0;
  qword_1EBCED418 = (uint64_t)&unk_1F26440A0;
  qword_1EBCED4B0 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCED4B8 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCED4D0 = (uint64_t)&qword_1EBCED4B8;
  sub_1CD69AE10(a1, a2, a3, a4, a5);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCED418);
}

__n128 sub_1CD69AE10(_WORD *a1, char **a2, _WORD *a3, __n128 *a4, _WORD *a5)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCED418, "hwasan-use-stack-safety", 0x17uLL);
  __int16 v10 = word_1EBCED422;
  word_1EBCED422 = word_1EBCED422 & 0xFF9F | (32 * (*a1 & 3));
  uint64_t v11 = *a2;
  byte_1EBCED498 = **a2;
  byte_1EBCED4A9 = 1;
  byte_1EBCED4A8 = *v11;
  word_1EBCED422 = v10 & 0xFF9F | (32 * (*a3 & 3));
  __n128 result = *a4;
  xmmword_1EBCED438 = (__int128)*a4;
  word_1EBCED422 = word_1EBCED422 & 0xFFF8 | *a5 & 7;
  return result;
}

void sub_1CD69AEBC(_WORD *a1, int **a2, _WORD *a3, __n128 *a4, _WORD *a5)
{
  sub_1CB883A14((uint64_t)&qword_1EA61DC40, 0, 0);
  xmmword_1EA61DCC0 = 0u;
  *(_OWORD *)&qword_1EA61DCD0 = 0u;
  *((void *)&xmmword_1EA61DCC0 + 1) = &unk_1F2611D50;
  qword_1EA61DC40 = (uint64_t)&unk_1F2611CE8;
  qword_1EA61DCE0 = (uint64_t)&unk_1F2643DE0;
  qword_1EA61DCE8 = (uint64_t)&unk_1F2611DB8;
  qword_1EA61DD00 = (uint64_t)&qword_1EA61DCE8;
  sub_1CD69AFC8(a1, a2, a3, a4, a5);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EA61DC40);
}

__n128 sub_1CD69AFC8(_WORD *a1, int **a2, _WORD *a3, __n128 *a4, _WORD *a5)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EA61DC40, "hwasan-max-lifetimes-for-alloca", 0x1FuLL);
  __int16 v10 = word_1EA61DC4A;
  word_1EA61DC4A = word_1EA61DC4A & 0xFF9F | (32 * (*a1 & 3));
  *(void *)&xmmword_1EA61DCC0 = **a2;
  byte_1EA61DCD8 = 1;
  qword_1EA61DCD0 = xmmword_1EA61DCC0;
  word_1EA61DC4A = v10 & 0xFF9F | (32 * (*a3 & 3));
  __n128 result = *a4;
  xmmword_1EA61DC60 = (__int128)*a4;
  word_1EA61DC4A = word_1EA61DC4A & 0xFFF8 | *a5 & 7;
  return result;
}

void sub_1CD69B070(__n128 *a1, _WORD *a2, char **a3, _WORD *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCED718, 0, 0);
  byte_1EBCED798 = 0;
  qword_1EBCED7A0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCED7A8 = 0;
  qword_1EBCED718 = (uint64_t)&unk_1F26440A0;
  qword_1EBCED7B0 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCED7B8 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCED7D0 = (uint64_t)&qword_1EBCED7B8;
  sub_1CD69B170(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCED718);
}

__n128 sub_1CD69B170(__n128 *a1, _WORD *a2, char **a3, _WORD *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCED718, "hwasan-globals", 0xEuLL);
  __n128 result = *a1;
  xmmword_1EBCED738 = (__int128)*a1;
  word_1EBCED722 = word_1EBCED722 & 0xFF9F | (32 * (*a2 & 3));
  uint64_t v9 = *a3;
  byte_1EBCED798 = **a3;
  byte_1EBCED7A9 = 1;
  byte_1EBCED7A8 = *v9;
  word_1EBCED722 = word_1EBCED722 & 0xFFF8 | *a4 & 7;
  return result;
}

void sub_1CD69B208(__n128 *a1, _WORD *a2, char **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCED898, 0, 0);
  byte_1EBCED918 = 0;
  qword_1EBCED920 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCED928 = 0;
  qword_1EBCED898 = (uint64_t)&unk_1F26440A0;
  qword_1EBCED930 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCED938 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCED950 = (uint64_t)&qword_1EBCED938;
  sub_1CD69B2F8(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCED898);
}

__n128 sub_1CD69B2F8(__n128 *a1, _WORD *a2, char **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCED898, "hwasan-kernel", 0xDuLL);
  __n128 result = *a1;
  xmmword_1EBCED8B8 = (__int128)*a1;
  word_1EBCED8A2 = (32 * (*a2 & 3)) | word_1EBCED8A2 & 0xFF9F;
  uint64_t v7 = *a3;
  byte_1EBCED918 = **a3;
  byte_1EBCED929 = 1;
  byte_1EBCED928 = *v7;
  return result;
}

void sub_1CD69B380(long long *a1, _WORD *a2, int **a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EA61DD08, 0, 0);
  xmmword_1EA61DD88 = 0u;
  *(_OWORD *)&qword_1EA61DD98 = 0u;
  *((void *)&xmmword_1EA61DD88 + 1) = &unk_1F261F710;
  qword_1EA61DD08 = (uint64_t)&unk_1F261F6A8;
  qword_1EA61DDA8 = (uint64_t)&unk_1F2643E10;
  qword_1EA61DDB0 = (uint64_t)&unk_1F261F7D0;
  qword_1EA61DDC8 = (uint64_t)&qword_1EA61DDB0;
  llvm::cl::Option::setArgStr(v6, "hwasan-mapping-offset", 0x15uLL);
  xmmword_1EA61DD28 = *a1;
  word_1EA61DD12 = (32 * (*a2 & 3)) | word_1EA61DD12 & 0xFF9F;
  *(void *)&xmmword_1EA61DD88 = **a3;
  byte_1EA61DDA0 = 1;
  qword_1EA61DD98 = xmmword_1EA61DD88;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EA61DD08);
}

void sub_1CD69B4AC(__n128 *a1, _WORD *a2, char **a3, _WORD *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCEDC58, 0, 0);
  byte_1EBCEDCD8 = 0;
  qword_1EBCEDCE0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCEDCE8 = 0;
  qword_1EBCEDC58 = (uint64_t)&unk_1F26440A0;
  qword_1EBCEDCF0 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCEDCF8 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCEDD10 = (uint64_t)&qword_1EBCEDCF8;
  sub_1CD69B5AC(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCEDC58);
}

__n128 sub_1CD69B5AC(__n128 *a1, _WORD *a2, char **a3, _WORD *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCEDC58, "hwasan-instrument-landing-pads", 0x1EuLL);
  __n128 result = *a1;
  xmmword_1EBCEDC78 = (__int128)*a1;
  word_1EBCEDC62 = word_1EBCEDC62 & 0xFF9F | (32 * (*a2 & 3));
  uint64_t v9 = *a3;
  byte_1EBCEDCD8 = **a3;
  byte_1EBCEDCE9 = 1;
  byte_1EBCEDCE8 = *v9;
  word_1EBCEDC62 = word_1EBCEDC62 & 0xFFF8 | *a4 & 7;
  return result;
}

void sub_1CD69B644(__n128 *a1, _WORD *a2, char **a3, _WORD *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCEDD18, 0, 0);
  byte_1EBCEDD98 = 0;
  qword_1EBCEDDA0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCEDDA8 = 0;
  qword_1EBCEDD18 = (uint64_t)&unk_1F26440A0;
  qword_1EBCEDDB0 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCEDDB8 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCEDDD0 = (uint64_t)&qword_1EBCEDDB8;
  sub_1CD69B744(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCEDD18);
}

__n128 sub_1CD69B744(__n128 *a1, _WORD *a2, char **a3, _WORD *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCEDD18, "hwasan-use-short-granules", 0x19uLL);
  __n128 result = *a1;
  xmmword_1EBCEDD38 = (__int128)*a1;
  word_1EBCEDD22 = word_1EBCEDD22 & 0xFF9F | (32 * (*a2 & 3));
  uint64_t v9 = *a3;
  byte_1EBCEDD98 = **a3;
  byte_1EBCEDDA9 = 1;
  byte_1EBCEDDA8 = *v9;
  word_1EBCEDD22 = word_1EBCEDD22 & 0xFFF8 | *a4 & 7;
  return result;
}

void sub_1CD69B7DC(__n128 *a1, _WORD *a2, char **a3, _WORD *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EA61DA00, 0, 0);
  byte_1EA61DA80 = 0;
  qword_1EA61DA88 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EA61DA90 = 0;
  qword_1EA61DA00 = (uint64_t)&unk_1F26440A0;
  qword_1EA61DA98 = (uint64_t)&unk_1F2643CC0;
  qword_1EA61DAA0 = (uint64_t)&unk_1F25EDE78;
  qword_1EA61DAB8 = (uint64_t)&qword_1EA61DAA0;
  sub_1CD69B8DC(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EA61DA00);
}

__n128 sub_1CD69B8DC(__n128 *a1, _WORD *a2, char **a3, _WORD *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EA61DA00, "hwasan-instrument-personality-functions", 0x27uLL);
  __n128 result = *a1;
  xmmword_1EA61DA20 = (__int128)*a1;
  word_1EA61DA0A = word_1EA61DA0A & 0xFF9F | (32 * (*a2 & 3));
  uint64_t v9 = *a3;
  byte_1EA61DA80 = **a3;
  byte_1EA61DA91 = 1;
  byte_1EA61DA90 = *v9;
  word_1EA61DA0A = word_1EA61DA0A & 0xFFF8 | *a4 & 7;
  return result;
}

char *sub_1CD69B974()
{
  v10[0] = (uint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = llvm::HWAddressSanitizerPass]";
  v10[1] = 78;
  unint64_t v0 = llvm::StringRef::find(v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v0 >= 0x4E) {
    uint64_t v1 = 78;
  }
  else {
    uint64_t v1 = v0;
  }
  std::string::size_type v2 = &aStringrefLlvmG_16[v1];
  unint64_t v3 = 78 - v1;
  if (v3 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v3;
  }
  __n128 result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

void sub_1CD69BA30(unsigned __int8 *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, std::string *a4@<X8>)
{
  void v7[2] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = v7;
  long long v6 = xmmword_1CDB15990;
  sub_1CC223B30(a1, a2, a3, &v5);
  std::string::__init(a4, (const std::string::value_type *)v5, v6);
  if (v5 != v7) {
    free(v5);
  }
}

unint64_t sub_1CD69BAC0(uint64_t a1, _OWORD *a2)
{
  if (*(void *)(a1 + 64))
  {
    sub_1CD69C5D0(a1 + 48, (uint64_t)a2, a2);
    return ((unint64_t)v7 << 32) | 1;
  }
  else
  {
    uint64_t v4 = sub_1CD69C550((uint64_t *)a1, (uint64_t)a2);
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    if (v4 == *(void *)a1 + 16 * v5)
    {
      if (v5 > 1)
      {
        do
        {
          long long v8 = (_OWORD *)(*(void *)a1 + 16 * v5 - 16);
          sub_1CD69C5D0(a1 + 48, (uint64_t)v8, v8);
          LODWORD(v5) = *(_DWORD *)(a1 + 8) - 1;
          *(_DWORD *)(a1 + 8) = v5;
        }
        while (v5);
        sub_1CD69C5D0(a1 + 48, (uint64_t)a2, a2);
      }
      else
      {
        if (v5 >= *(_DWORD *)(a1 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(_OWORD *)(*(void *)a1 + 16 * v5) = *a2;
        ++*(_DWORD *)(a1 + 8);
      }
      return 0x100000001;
    }
    else
    {
      return 1;
    }
  }
}

void llvm::lto::setupLLVMOptimizationRemarks(uint64_t *a1@<X0>, const std::string::value_type *a2@<X1>, std::string::size_type a3@<X2>, uint64_t a4@<X5>, uint64_t a5@<X6>, int a6@<W7>, uint64_t a7@<X8>, uint64_t a8, uint64_t a9, int a10)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  std::string::__init(&v43, a2, a3);
  char v14 = HIBYTE(v43.__r_.__value_.__r.__words[2]);
  std::string::size_type size = v43.__r_.__value_.__l.__size_;
  uint64_t v16 = *((unsigned char *)&v43.__r_.__value_.__s + 23) & 0x7F;
  if ((v43.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v17 = *((unsigned char *)&v43.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    std::string::size_type v17 = v43.__r_.__value_.__l.__size_;
  }
  if (a10 != -1 && v17 != 0)
  {
    __int16 v38 = 260;
    char v37 = &v43;
    uint64_t v35 = ".thin.";
    __int16 v36 = 259;
    sub_1CB8F1E58((uint64_t *)&v37, (uint64_t *)&v35, (uint64_t)v39);
    if (a10)
    {
      unint64_t v20 = a10;
      std::string v19 = v47;
      do
      {
        *--std::string v19 = (v20 % 0xA) | 0x30;
        BOOL v21 = v20 > 9;
        v20 /= 0xAuLL;
      }
      while (v21);
    }
    else
    {
      std::string v19 = &v46;
      char v46 = 48;
    }
    sub_1CC028D80(__p, v19, v47, v47 - v19);
    __int16 v34 = 260;
    uint64_t v33 = __p;
    sub_1CB8F1E58(v39, (uint64_t *)&v33, (uint64_t)v40);
    __int16 v29 = ".";
    __int16 v30 = 259;
    sub_1CB8F1E58(v40, (uint64_t *)&v29, (uint64_t)v41);
    __int16 v28 = 261;
    v27[0] = a4;
    v27[1] = a5;
    sub_1CB8F1E58(v41, v27, (uint64_t)&v44);
    llvm::Twine::str((llvm::Twine *)&v44, &v42);
    if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v43.__r_.__value_.__l.__data_);
    }
    std::string v43 = v42;
    *((unsigned char *)&v42.__r_.__value_.__s + 23) = 0;
    v42.__r_.__value_.__s.__data_[0] = 0;
    if (v32 < 0) {
      operator delete(__p[0]);
    }
    char v14 = HIBYTE(v43.__r_.__value_.__r.__words[2]);
    std::string::size_type size = v43.__r_.__value_.__l.__size_;
    uint64_t v16 = *((unsigned char *)&v43.__r_.__value_.__s + 23) & 0x7F;
  }
  if (v14 >= 0) {
    uint64_t v22 = v16;
  }
  else {
    uint64_t v22 = size;
  }
  llvm::setupLLVMOptimizationRemarks(a1, v22, a4, a5, a6, (uint64_t)&v44, a8, a9);
  char v23 = v45;
  uint64_t v24 = v44;
  if (v45)
  {
    uint64_t v25 = 0;
    uint64_t v44 = 0;
    if (v24)
    {
      *(unsigned char *)(a7 + 8) |= 1u;
      goto LABEL_27;
    }
  }
  else if (v44)
  {
    *(unsigned char *)(v44 + 24) = 1;
    uint64_t v25 = v24;
  }
  else
  {
    uint64_t v25 = 0;
  }
  *(unsigned char *)(a7 + 8) = *(unsigned char *)(a7 + 8) & 0xFE | v23 & 1;
  uint64_t v44 = 0;
  uint64_t v24 = v25;
LABEL_27:
  *(void *)a7 = v24;
  sub_1CD69CB60((uint64_t)&v44);
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v43.__r_.__value_.__l.__data_);
  }
}

void *sub_1CD69BE88(void *result, uint64_t a2)
{
  std::string::size_type v2 = result + 1;
  unint64_t v3 = (void *)*result;
  if ((void *)*result != result + 1)
  {
    do
    {
      uint64_t v12 = v3[4];
      uint64_t v5 = (uint64_t *)v3[7];
      long long v6 = (uint64_t *)v3[8];
      while (v5 != v6)
      {
        uint64_t v7 = *v5++;
        long long v8 = sub_1CD69BF44(a2, *(unsigned __int8 **)(v7 + 24), *(void *)(v7 + 32));
        __n128 result = sub_1CD5D47AC(*v8 + 8, &v12);
        result[1] = v7;
      }
      uint64_t v9 = (void *)v3[1];
      if (v9)
      {
        do
        {
          __int16 v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          __int16 v10 = (void *)v3[2];
          BOOL v11 = *v10 == (void)v3;
          unint64_t v3 = v10;
        }
        while (!v11);
      }
      unint64_t v3 = v10;
    }
    while (v10 != v2);
  }
  return result;
}

uint64_t *sub_1CD69BF44(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  uint64_t v6 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  uint64_t i = (uint64_t *)(*(void *)a1 + 8 * v6);
  uint64_t v8 = *i;
  if (*i == -8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v8)
  {
    while (!v8 || v8 == -8)
    {
      uint64_t v9 = i[1];
      ++i;
      uint64_t v8 = v9;
    }
    return i;
  }
  __int16 v10 = (char *)operator new(a3 + 33, (std::align_val_t)8uLL);
  BOOL v11 = v10;
  uint64_t v12 = v10 + 32;
  if (a3) {
    memcpy(v10 + 32, a2, a3);
  }
  v12[a3] = 0;
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 2) = 0;
  *(void *)BOOL v11 = a3;
  *((_DWORD *)v11 + 6) = 0;
  *uint64_t i = (uint64_t)v11;
  ++*(_DWORD *)(a1 + 12);
  for (uint64_t i = (uint64_t *)(*(void *)a1
                      + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v6));
        !*i || *i == -8;
  return i;
}

uint64_t sub_1CD69C048(uint64_t a1)
{
  uint64_t v2 = a1 + 1120;
  uint64_t v3 = *(void *)(a1 + 1144);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 1112);
  if (v4 == a1 + 1088)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 1088) + 32))(a1 + 1088);
  }
  else if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 1080);
  if (v5 == a1 + 1056)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 1056) + 32))(a1 + 1056);
  }
  else if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 40))(v5);
  }
  uint64_t v6 = *(void *)(a1 + 1048);
  if (v6 == a1 + 1024)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 1024) + 32))(a1 + 1024);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 1016);
  if (v7 == a1 + 992)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 992) + 32))(a1 + 992);
  }
  else if (v7)
  {
    (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
  }
  uint64_t v8 = *(void *)(a1 + 984);
  if (v8 == a1 + 960)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 960) + 32))(a1 + 960);
  }
  else if (v8)
  {
    (*(void (**)(uint64_t))(*(void *)v8 + 40))(v8);
  }
  uint64_t v9 = *(void *)(a1 + 952);
  if (v9 == a1 + 928)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 928) + 32))(a1 + 928);
  }
  else if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 40))(v9);
  }
  uint64_t v10 = *(void *)(a1 + 896);
  *(void *)(a1 + 896) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t v11 = *(void *)(a1 + 880);
  if (v11 == a1 + 856)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 856) + 32))(a1 + 856);
  }
  else if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 40))(v11);
  }
  char v14 = (void **)(a1 + 816);
  sub_1CB8338B8(&v14);
  if (*(char *)(a1 + 815) < 0) {
    operator delete(*(void **)(a1 + 792));
  }
  if (*(char *)(a1 + 783) < 0) {
    operator delete(*(void **)(a1 + 760));
  }
  if (*(char *)(a1 + 735) < 0) {
    operator delete(*(void **)(a1 + 712));
  }
  if (*(char *)(a1 + 711) < 0) {
    operator delete(*(void **)(a1 + 688));
  }
  if (*(char *)(a1 + 687) < 0) {
    operator delete(*(void **)(a1 + 664));
  }
  if (*(char *)(a1 + 663) < 0) {
    operator delete(*(void **)(a1 + 640));
  }
  if (*(char *)(a1 + 639) < 0) {
    operator delete(*(void **)(a1 + 616));
  }
  if (*(char *)(a1 + 615) < 0) {
    operator delete(*(void **)(a1 + 592));
  }
  if (*(char *)(a1 + 591) < 0) {
    operator delete(*(void **)(a1 + 568));
  }
  if (*(char *)(a1 + 567) < 0) {
    operator delete(*(void **)(a1 + 544));
  }
  if (*(char *)(a1 + 543) < 0) {
    operator delete(*(void **)(a1 + 520));
  }
  if (*(char *)(a1 + 519) < 0) {
    operator delete(*(void **)(a1 + 496));
  }
  if (*(char *)(a1 + 495) < 0) {
    operator delete(*(void **)(a1 + 472));
  }
  if (*(char *)(a1 + 471) < 0) {
    operator delete(*(void **)(a1 + 448));
  }
  uint64_t v12 = *(void *)(a1 + 400);
  if (v12 == a1 + 376)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 376) + 32))(a1 + 376);
  }
  else if (v12)
  {
    (*(void (**)(uint64_t))(*(void *)v12 + 40))(v12);
  }
  char v14 = (void **)(a1 + 352);
  sub_1CB8338B8(&v14);
  char v14 = (void **)(a1 + 328);
  sub_1CB8338B8(&v14);
  sub_1CB906D7C(a1 + 24);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1CD69C550(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  uint64_t v4 = *a1 + 16 * v3;
  if (v3)
  {
    uint64_t v5 = *(const void **)a2;
    size_t v6 = *(void *)(a2 + 8);
    uint64_t v7 = 16 * v3;
    while (*(void *)(v2 + 8) != v6 || v6 && memcmp(*(const void **)v2, v5, v6))
    {
      v2 += 16;
      v7 -= 16;
      if (!v7) {
        return v4;
      }
    }
    return v2;
  }
  return v4;
}

_OWORD *sub_1CD69C5D0(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  uint64_t v5 = (void **)sub_1CC9164B8(a1, &v12, a2);
  size_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v8 = v5;
    size_t v6 = operator new(0x30uLL);
    void v6[2] = *a3;
    uint64_t v9 = v12;
    *(void *)size_t v6 = 0;
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = v9;
    uint64_t *v8 = v6;
    uint64_t v10 = **(void **)a1;
    uint64_t v11 = (uint64_t *)v6;
    if (v10)
    {
      *(void *)a1 = v10;
      uint64_t v11 = (uint64_t *)*v8;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v11);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

void sub_1CD69C67C(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = sub_1CD69C6DC((uint64_t)a1, a2);
  if (a1 + 1 != (uint64_t **)v3)
  {
    uint64_t v4 = v3;
    sub_1CD491B50(a1, v3);
    operator delete(v4);
  }
}

void *sub_1CD69C6DC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 16;
  size_t v6 = (void *)(a1 + 8);
  do
  {
    BOOL v7 = sub_1CC016A40(v5, (uint64_t)(v3 + 4), a2);
    uint64_t v8 = v3 + 1;
    if (!v7)
    {
      uint64_t v8 = v3;
      size_t v6 = v3;
    }
    uint64_t v3 = (void *)*v8;
  }
  while (*v8);
  if (v6 == v2 || sub_1CC016A40(v5, a2, (uint64_t)(v6 + 4))) {
    return v2;
  }
  return v6;
}

uint64_t sub_1CD69C76C@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CD69C804((uint64_t *)a1, a2, &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD69C918(a1, (uint64_t)a2, a2, v12);
    uint64_t v9 = (void *)result;
    *(_OWORD *)uint64_t result = *(_OWORD *)a2;
    *(_DWORD *)(result + 16) = *a3;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a1 + 24 * *(unsigned int *)(a1 + 16);
  *(void *)a4 = v9;
  *(void *)(a4 + 8) = v11;
  *(unsigned char *)(a4 + 16) = v10;
  return result;
}

uint64_t sub_1CD69C804(uint64_t *a1, const void **a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v6 = *a1;
    unsigned int HashValue = llvm::DenseMapInfo<llvm::StringRef,void>::getHashValue(*a2, (uint64_t)a2[1]);
    uint64_t v8 = 0;
    int v9 = v4 - 1;
    for (int i = 1; ; ++i)
    {
      unsigned int v11 = HashValue & v9;
      uint64_t v12 = v6 + 24 * (HashValue & v9);
      uint64_t v13 = *(const void **)v12;
      if (*(void *)v12 == -2)
      {
        if (*a2 == (const void *)-2) {
          goto LABEL_18;
        }
      }
      else if (v13 == (const void *)-1)
      {
        if (*a2 == (const void *)-1) {
          goto LABEL_18;
        }
      }
      else
      {
        size_t v14 = (size_t)a2[1];
        if (v14 == *(void *)(v12 + 8) && (!v14 || !memcmp(*a2, *(const void **)v12, v14)))
        {
LABEL_18:
          uint64_t result = 1;
          goto LABEL_19;
        }
      }
      if (v13 == (const void *)-1) {
        break;
      }
      if (v8) {
        BOOL v16 = 0;
      }
      else {
        BOOL v16 = v13 == (const void *)-2;
      }
      if (v16) {
        uint64_t v8 = v6 + 24 * v11;
      }
      unsigned int HashValue = i + v11;
    }
    uint64_t result = 0;
    if (v8) {
      uint64_t v12 = v8;
    }
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t result = 0;
  }
LABEL_19:
  *a3 = v12;
  return result;
}

void *sub_1CD69C918(uint64_t a1, uint64_t a2, const void **a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD69C9C8(a1, v7);
  int v9 = 0;
  sub_1CD69C804((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

_OWORD *sub_1CD69C9C8(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD69CAA4(a1, v4, v4 + 24 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 24 * v10;
    do
    {
      _OWORD *result = xmmword_1CFAC4A20;
      uint64_t result = (_OWORD *)((char *)result + 24);
      v11 -= 24;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD69CAA4(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(_OWORD **)result;
    uint64_t v8 = 24 * v6;
    do
    {
      *int v7 = xmmword_1CFAC4A20;
      int v7 = (_OWORD *)((char *)v7 + 24);
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if (*(void *)a2 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v10 = 0;
      uint64_t result = sub_1CD69C804((uint64_t *)v5, (const void **)a2, &v10);
      int v9 = v10;
      *uint64_t v10 = *(_OWORD *)a2;
      *((_DWORD *)v9 + 4) = *(_DWORD *)(a2 + 16);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 24;
  }
  return result;
}

uint64_t sub_1CD69CB60(uint64_t result)
{
  char v1 = *(unsigned char *)(result + 8);
  uint64_t v2 = *(llvm::ToolOutputFile::CleanupInstaller **)result;
  *(void *)uint64_t result = 0;
  if ((v1 & 1) == 0)
  {
    if (!v2) {
      return result;
    }
    uint64_t v3 = result;
    sub_1CBAD7E10(result, v2);
    return v3;
  }
  if (v2)
  {
    uint64_t v3 = result;
    (*(void (**)(llvm::ToolOutputFile::CleanupInstaller *))(*(void *)v2 + 8))(v2);
    return v3;
  }
  return result;
}

void sub_1CD69CBD4(unsigned char *a1@<X8>)
{
  *a1 = 0;
  a1[24] = 0;
}

uint64_t sub_1CD69CBE0(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 12))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 8);
    if (v2)
    {
      uint64_t v3 = 0;
      uint64_t v4 = 8 * v2;
      do
      {
        uint64_t v5 = *(void *)(*(void *)a1 + v3);
        if (v5 != -8 && v5 != 0) {
          sub_1CD69CC5C(v5);
        }
        v3 += 8;
      }
      while (v4 != v3);
    }
  }
  free(*(void **)a1);
  return a1;
}

void sub_1CD69CC5C(uint64_t a1)
{
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);

  JUMPOUT(0x1D25D9CD0);
}

void llvm::lto::Config::addSaveTemps(uint64_t a1, const void **a2, char a3)
{
  uint64_t v7[4] = *(void **)MEMORY[0x1E4F143B8];
  char v6 = a3;
  *(unsigned char *)(a1 + 848) = 0;
  LODWORD(v4) = 0;
  uint64_t v5 = std::system_category();
  sub_1CBAD7600("resolution.txt", a2, v7);
  operator new();
}

void llvm::lto::opt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = MEMORY[0x1F4188790](a1, a2, a3, a4);
  uint64_t v8 = v7;
  uint64_t v10 = v9;
  uint64_t v11 = v4;
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (dword_1EBCEDFD8 == 2)
  {
    memset(v29, 0, sizeof(v29));
    llvm::embedBitcodeInModule(v5, (llvm::LLVMContext *)v29, 1, 1, v6);
  }
  if (*(_DWORD *)(v11 + 432) >= 2u)
  {
    LOBYTE(v55[0]) = 1;
    byte_1EBD07AD8 = 1;
    if (!qword_1EBD07B10) {
      goto LABEL_65;
    }
    (*(void (**)(uint64_t, _DWORD *))(*(void *)qword_1EBD07B10 + 48))(qword_1EBD07B10, v55);
  }
  llvm::vfs::getRealFileSystem(&v54);
  LOBYTE(v52[0]) = 0;
  char v53 = 0;
  char v12 = *(unsigned char *)(v11 + 591);
  int v13 = v12;
  uint64_t v14 = v12 & 0x7F;
  if (v13 < 0) {
    uint64_t v14 = *(void *)(v11 + 576);
  }
  if (v14)
  {
    uint64_t v18 = (const void **)(v11 + 568);
    if (v13 < 0)
    {
      sub_1CB8BDF7C((uint64_t)v50, *v18, *(void *)(v11 + 576));
    }
    else
    {
      *(_OWORD *)BOOL v50 = *(_OWORD *)v18;
      uint64_t v51 = *(void *)(v11 + 584);
    }
    HIBYTE(v49) = 0;
    LOBYTE(v48[0]) = 0;
    if (*(char *)(v11 + 615) < 0)
    {
      sub_1CB8BDF7C((uint64_t)__p, *(const void **)(v11 + 592), *(void *)(v11 + 600));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(v11 + 592);
      uint64_t v47 = *(void *)(v11 + 608);
    }
    uint64_t v19 = v54;
    uint64_t v45 = v54;
    if (!v54)
    {
      int v20 = 3;
      int v21 = 0;
      char v22 = 1;
LABEL_25:
      sub_1CD69E71C((uint64_t)v55, (long long *)v50, (long long *)v48, (long long *)__p, &v45, v20, v21, v22);
      sub_1CD69E818((uint64_t)v52, (uint64_t)v55);
      sub_1CD69E9BC((uint64_t)v55);
LABEL_26:
      if (SHIBYTE(v47) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v49) < 0) {
        operator delete(v48[0]);
      }
      if (SHIBYTE(v51) < 0) {
        operator delete(v50[0]);
      }
LABEL_32:
      v43[0] = 0;
      char v44 = 0;
      if (v53)
      {
        sub_1CD69EB48((uint64_t)v43, v52);
        char v44 = 1;
      }
      sub_1CD69EA50(v10 + 600, (uint64_t)v43);
      if (v44)
      {
        sub_1CD69E9BC((uint64_t)v43);
        char v44 = 0;
      }
      llvm::AnalysisManager<llvm::Loop,llvm::LoopStandardAnalysisResults &>::AnalysisManager();
    }
    char v23 = (atomic_uint *)(v54 + 8);
    atomic_fetch_add_explicit((atomic_uint *volatile)(v54 + 8), 1u, memory_order_relaxed);
    int v24 = 3;
    int v25 = 0;
    char v26 = 1;
  }
  else
  {
    if (!*(unsigned char *)(v11 + 440))
    {
      char v15 = *(unsigned char *)(v11 + 567);
      int v16 = v15;
      uint64_t v17 = v15 & 0x7F;
      if (v16 < 0) {
        uint64_t v17 = *(void *)(v11 + 552);
      }
      if (!v17)
      {
        if (*(unsigned char *)(v11 + 888))
        {
          HIBYTE(v51) = 0;
          LOBYTE(v50[0]) = 0;
          HIBYTE(v49) = 0;
          LOBYTE(v48[0]) = 0;
          HIBYTE(v47) = 0;
          LOBYTE(__p[0]) = 0;
          uint64_t v45 = 0;
          sub_1CD69E71C((uint64_t)v55, (long long *)v50, (long long *)v48, (long long *)__p, &v45, 0, 0, 1);
          sub_1CD69E818((uint64_t)v52, (uint64_t)v55);
          sub_1CD69E9BC((uint64_t)v55);
        }
        goto LABEL_32;
      }
      signed int v27 = (const void **)(v11 + 544);
      if (v16 < 0)
      {
        sub_1CB8BDF7C((uint64_t)v50, *v27, *(void *)(v11 + 552));
      }
      else
      {
        *(_OWORD *)BOOL v50 = *(_OWORD *)v27;
        uint64_t v51 = *(void *)(v11 + 560);
      }
      HIBYTE(v49) = 0;
      LOBYTE(v48[0]) = 0;
      if (*(char *)(v11 + 615) < 0)
      {
        sub_1CB8BDF7C((uint64_t)__p, *(const void **)(v11 + 592), *(void *)(v11 + 600));
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)(v11 + 592);
        uint64_t v47 = *(void *)(v11 + 608);
      }
      __int16 v28 = (atomic_uint *)v54;
      uint64_t v45 = v54;
      if (v54)
      {
        atomic_fetch_add_explicit((atomic_uint *volatile)(v54 + 8), 1u, memory_order_relaxed);
        sub_1CD69E71C((uint64_t)v55, (long long *)v50, (long long *)v48, (long long *)__p, &v45, 2, 2, *(unsigned char *)(v11 + 888));
        sub_1CD69E818((uint64_t)v52, (uint64_t)v55);
        sub_1CD69E9BC((uint64_t)v55);
        if (atomic_fetch_add(v28 + 2, 0xFFFFFFFF) == 1) {
          (*(void (**)(atomic_uint *))(*(void *)v28 + 8))(v28);
        }
      }
      else
      {
        sub_1CD69E71C((uint64_t)v55, (long long *)v50, (long long *)v48, (long long *)__p, &v45, 2, 2, *(unsigned char *)(v11 + 888));
        sub_1CD69E818((uint64_t)v52, (uint64_t)v55);
        sub_1CD69E9BC((uint64_t)v55);
      }
      if (SHIBYTE(v47) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v49) < 0) {
        operator delete(v48[0]);
      }
      if (SHIBYTE(v51) < 0) {
        operator delete(v50[0]);
      }
      LOBYTE(v55[0]) = *(unsigned char *)(v11 + 441) ^ 1;
      byte_1EBD09798 = v55[0];
      if (qword_1EBD097D0)
      {
        (*(void (**)(uint64_t, _DWORD *))(*(void *)qword_1EBD097D0 + 48))(qword_1EBD097D0, v55);
        goto LABEL_32;
      }
LABEL_65:
      sub_1CB920400();
      __int16 v38 = "unable to parse AA pipeline description '";
      __int16 v39 = 259;
      __int16 v37 = 260;
      v36[0] = v8;
      sub_1CD3E3950((uint64_t *)&v38, v36, (uint64_t)v40);
      __int16 v34 = "': ";
      __int16 v35 = 259;
      sub_1CD3E3950(v40, (uint64_t *)&v34, (uint64_t)v41);
      uint64_t v30 = v42;
      uint64_t v42 = 0;
      sub_1CD4FB504(&v30, &v31);
      __int16 v33 = 260;
      char v32 = &v31;
      sub_1CD3E3950(v41, (uint64_t *)&v32, (uint64_t)v56);
      llvm::report_fatal_error((llvm *)v56, (const llvm::Twine *)1);
    }
    HIBYTE(v51) = 0;
    LOBYTE(v50[0]) = 0;
    if (*(char *)(v11 + 567) < 0)
    {
      sub_1CB8BDF7C((uint64_t)v48, *(const void **)(v11 + 544), *(void *)(v11 + 552));
    }
    else
    {
      *(_OWORD *)uint64_t v48 = *(_OWORD *)(v11 + 544);
      uint64_t v49 = *(void *)(v11 + 560);
    }
    if (*(char *)(v11 + 615) < 0)
    {
      sub_1CB8BDF7C((uint64_t)__p, *(const void **)(v11 + 592), *(void *)(v11 + 600));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)(v11 + 592);
      uint64_t v47 = *(void *)(v11 + 608);
    }
    uint64_t v19 = v54;
    uint64_t v45 = v54;
    if (!v54)
    {
      char v22 = *(unsigned char *)(v11 + 888);
      int v20 = 2;
      int v21 = 1;
      goto LABEL_25;
    }
    char v23 = (atomic_uint *)(v54 + 8);
    atomic_fetch_add_explicit((atomic_uint *volatile)(v54 + 8), 1u, memory_order_relaxed);
    char v26 = *(unsigned char *)(v11 + 888);
    int v24 = 2;
    int v25 = 1;
  }
  sub_1CD69E71C((uint64_t)v55, (long long *)v50, (long long *)v48, (long long *)__p, &v45, v24, v25, v26);
  sub_1CD69E818((uint64_t)v52, (uint64_t)v55);
  sub_1CD69E9BC((uint64_t)v55);
  if (atomic_fetch_add(v23, 0xFFFFFFFF) == 1) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  }
  goto LABEL_26;
}

llvm::raw_ostream *sub_1CD69E02C(llvm::raw_ostream *result)
{
  char v1 = (const char *)*((void *)result + 2);
  if (*((const char **)result + 4) != v1)
  {
    *((void *)result + 4) = v1;
    return (llvm::raw_ostream *)llvm::raw_ostream::flush_tied_then_write(result, v1);
  }
  return result;
}

llvm::BitcodeModule *llvm::lto::findThinLTOModule(llvm::BitcodeModule *this, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (byte_1EBCEDF18) {
    BOOL v3 = a2 == 1;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3)
  {
    if (a2)
    {
      uint64_t v4 = a2 << 6;
      while (1)
      {
        llvm::BitcodeModule::getLTOInfo(this, (uint64_t)&v9);
        int v5 = v10;
        BOOL v6 = (_BYTE)v9 == 0;
        if (v10)
        {
          uint64_t v7 = v9;
          uint64_t v9 = 0;
          if (v7) {
            (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
          }
        }
        if (((v5 | v6) & 1) == 0) {
          break;
        }
        this = (llvm::BitcodeModule *)((char *)this + 64);
        v4 -= 64;
        if (!v4) {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return this;
}

uint64_t llvm::lto::initImportList(uint64_t a1, void *a2, uint64_t a3)
{
  if (!byte_1EBCEDF18)
  {
    uint64_t v4 = a2 + 1;
    int v5 = (void *)*a2;
    if ((void *)*a2 != a2 + 1)
    {
      uint64_t v8 = (const void *)(a1 + 168);
      do
      {
        uint64_t v9 = v5[7];
        uint64_t v10 = v5[8];
        if (v9 != v10)
        {
          unint64_t v21 = v5[4];
          do
          {
            uint64_t v11 = *(unsigned __int8 **)(*(void *)v9 + 24);
            size_t v12 = *(void *)(*(void *)v9 + 32);
            char v13 = *(unsigned char *)(a1 + 191);
            BOOL v14 = v13 < 0;
            if (v13 >= 0) {
              char v15 = v8;
            }
            else {
              char v15 = *(const void **)(a1 + 168);
            }
            uint64_t v16 = v13 & 0x7F;
            if (v14) {
              uint64_t v16 = *(void *)(a1 + 176);
            }
            if (v12 != v16
              || v12 && memcmp(*(const void **)(*(void *)v9 + 24), v15, *(void *)(*(void *)v9 + 32)))
            {
              uint64_t v17 = sub_1CD66421C(a3, v11, v12);
              sub_1CC7C0480(*v17 + 8, &v21, &v21);
            }
            v9 += 8;
          }
          while (v9 != v10);
        }
        uint64_t v18 = (void *)v5[1];
        if (v18)
        {
          do
          {
            uint64_t v19 = v18;
            uint64_t v18 = (void *)*v18;
          }
          while (v18);
        }
        else
        {
          do
          {
            uint64_t v19 = (void *)v5[2];
            BOOL v20 = *v19 == (void)v5;
            int v5 = v19;
          }
          while (!v20);
        }
        int v5 = v19;
      }
      while (v19 != v4);
    }
  }
  return 1;
}

void *sub_1CD69E264(void *a1)
{
  *a1 = &unk_1F262C928;
  uint64_t v2 = a1 + 71;
  BOOL v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1F262C990;
  uint64_t v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }

  return sub_1CB87DD48(a1);
}

void *sub_1CD69E34C(void *a1)
{
  *a1 = &unk_1F262C990;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD69E3A0(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  int v12 = 0;
  uint64_t v8 = sub_1CD42FA04(a1 + 152, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD69E434(v11);
}

uint64_t sub_1CD69E434(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 160) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD69E44C(void *a1)
{
  sub_1CD69E264(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD69E484(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t sub_1CD69E490(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

llvm::raw_ostream *sub_1CD69E4A0(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    int v3 = *((_DWORD *)result + 32);
LABEL_3:
    uint64_t v4 = &unk_1F262C9E0;
    char v6 = 1;
    int v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 148))
  {
    int v3 = *((_DWORD *)result + 32);
    if (*((_DWORD *)result + 36) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD69E524(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void *sub_1CD69E538(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 152), a2);
}

void sub_1CD69E540(void *a1)
{
  *a1 = &unk_1F262C990;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD69E5B4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD69E5BC(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1CD69E5D0(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1CD69E5E4(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1CD69E5F8(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

llvm::raw_ostream *sub_1CD69E624(llvm::raw_ostream *a1, llvm::Twine *this)
{
  return a1;
}

void sub_1CD69E654()
{
}

uint64_t sub_1CD69E71C(uint64_t a1, long long *a2, long long *a3, long long *a4, uint64_t *a5, int a6, int a7, char a8)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1CB8BDF7C(a1, *(const void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v15 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v15;
  }
  uint64_t v16 = (_OWORD *)(a1 + 24);
  if (*((char *)a3 + 23) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v16, *(const void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v17 = *a3;
    *(void *)(a1 + 40) = *((void *)a3 + 2);
    *uint64_t v16 = v17;
  }
  uint64_t v18 = (_OWORD *)(a1 + 48);
  if (*((char *)a4 + 23) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v18, *(const void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v19 = *a4;
    *(void *)(a1 + 64) = *((void *)a4 + 2);
    *uint64_t v18 = v19;
  }
  *(_DWORD *)(a1 + 72) = a6;
  *(_DWORD *)(a1 + 76) = a7;
  if (a6 == 3) {
    char v20 = 1;
  }
  else {
    char v20 = a8;
  }
  *(unsigned char *)(a1 + 80) = v20;
  *(unsigned char *)(a1 + 81) = 0;
  uint64_t v21 = *a5;
  *(void *)(a1 + 88) = *a5;
  if (v21) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v21 + 8), 1u, memory_order_relaxed);
  }
  return a1;
}

uint64_t sub_1CD69E818(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)(result + 96)) {
    return sub_1CD69E8A8(result, (long long *)a2);
  }
  long long v2 = *(_OWORD *)a2;
  *(void *)(result + 16) = *(void *)(a2 + 16);
  *(_OWORD *)uint64_t result = v2;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  long long v3 = *(_OWORD *)(a2 + 24);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(result + 24) = v3;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 24) = 0;
  long long v4 = *(_OWORD *)(a2 + 48);
  *(void *)(result + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(result + 48) = v4;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 48) = 0;
  uint64_t v5 = *(void *)(a2 + 72);
  *(_WORD *)(result + 80) = *(_WORD *)(a2 + 80);
  *(void *)(result + 72) = v5;
  *(void *)(result + 88) = *(void *)(a2 + 88);
  *(void *)(a2 + 88) = 0;
  *(unsigned char *)(result + 96) = 1;
  return result;
}

uint64_t sub_1CD69E8A8(uint64_t a1, long long *a2)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((unsigned char *)a2 + 23) = 0;
  *(unsigned char *)a2 = 0;
  uint64_t v5 = (void **)(a1 + 24);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*v5);
  }
  long long v6 = *(long long *)((char *)a2 + 24);
  *(void *)(a1 + 40) = *((void *)a2 + 5);
  *(_OWORD *)uint64_t v5 = v6;
  *((unsigned char *)a2 + 47) = 0;
  *((unsigned char *)a2 + 24) = 0;
  uint64_t v7 = (void **)(a1 + 48);
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*v7);
  }
  long long v8 = a2[3];
  *(void *)(a1 + 64) = *((void *)a2 + 8);
  *(_OWORD *)uint64_t v7 = v8;
  *((unsigned char *)a2 + 71) = 0;
  *((unsigned char *)a2 + 48) = 0;
  uint64_t v9 = *((void *)a2 + 9);
  *(_WORD *)(a1 + 80) = *((_WORD *)a2 + 40);
  *(void *)(a1 + 72) = v9;
  uint64_t v10 = *((void *)a2 + 11);
  *((void *)a2 + 11) = 0;
  uint64_t v11 = *(atomic_uint **)(a1 + 88);
  *(void *)(a1 + 88) = v10;
  if (v11 && atomic_fetch_add(v11 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v11 + 8))(v11);
  }
  return a1;
}

uint64_t sub_1CD69E9BC(uint64_t a1)
{
  long long v2 = *(atomic_uint **)(a1 + 88);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1CD69EA50(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 96))
  {
    if (*(unsigned char *)(result + 96))
    {
      return sub_1CD69EA9C(result, a2);
    }
    else
    {
      uint64_t result = sub_1CD69EB48(result, (long long *)a2);
      *(unsigned char *)(result + 96) = 1;
    }
  }
  else if (*(unsigned char *)(result + 96))
  {
    uint64_t result = sub_1CD69E9BC(result);
    *(unsigned char *)(result + 96) = 0;
  }
  return result;
}

uint64_t sub_1CD69EA9C(uint64_t a1, uint64_t a2)
{
  std::string::operator=((std::string *)a1, (const std::string *)a2);
  std::string::operator=((std::string *)(a1 + 24), (const std::string *)(a2 + 24));
  std::string::operator=((std::string *)(a1 + 48), (const std::string *)(a2 + 48));
  uint64_t v4 = *(void *)(a2 + 72);
  *(_WORD *)(a1 + 80) = *(_WORD *)(a2 + 80);
  *(void *)(a1 + 72) = v4;
  uint64_t v5 = *(void *)(a2 + 88);
  if (v5) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v5 + 8), 1u, memory_order_relaxed);
  }
  long long v6 = *(atomic_uint **)(a1 + 88);
  *(void *)(a1 + 88) = v5;
  if (v6 && atomic_fetch_add(v6 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v6 + 8))(v6);
  }
  return a1;
}

uint64_t sub_1CD69EB48(uint64_t a1, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1CB8BDF7C(a1, *(const void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v4;
  }
  uint64_t v5 = (_OWORD *)(a1 + 24);
  if (*((char *)a2 + 47) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v5, *((const void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 24);
    *(void *)(a1 + 40) = *((void *)a2 + 5);
    *uint64_t v5 = v6;
  }
  uint64_t v7 = (_OWORD *)(a1 + 48);
  if (*((char *)a2 + 71) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v7, *((const void **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v8 = a2[3];
    *(void *)(a1 + 64) = *((void *)a2 + 8);
    *uint64_t v7 = v8;
  }
  uint64_t v9 = *((void *)a2 + 9);
  *(_WORD *)(a1 + 80) = *((_WORD *)a2 + 40);
  *(void *)(a1 + 72) = v9;
  uint64_t v10 = *((void *)a2 + 11);
  *(void *)(a1 + 88) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v10 + 8), 1u, memory_order_relaxed);
  }
  return a1;
}

uint64_t sub_1CD69EC18(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = a2 + 16;
    long long v3 = *(const void **)a2;
    if (*(void *)a2 == a2 + 16)
    {
      long long v6 = (_DWORD *)(a2 + 8);
      uint64_t v5 = *(unsigned int *)(a2 + 8);
      uint64_t v7 = *(unsigned int *)(a1 + 8);
      if (v7 >= v5)
      {
        if (v5) {
          memmove(*(void **)a1, *(const void **)a2, 8 * v5);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v5)
        {
          *(_DWORD *)(a1 + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v7)
        {
          uint64_t v15 = *(unsigned int *)(a1 + 8);
          uint64_t v16 = a2;
          memmove(*(void **)a1, v3, 8 * v7);
          uint64_t v8 = v15;
          a2 = v16;
        }
        else
        {
          uint64_t v8 = 0;
        }
        uint64_t v9 = *v6;
        if (v8 != v9) {
          memcpy((void *)(*(void *)a1 + 8 * v8), (const void *)(*(void *)a2 + 8 * v8), *(void *)a2 + 8 * v9 - (*(void *)a2 + 8 * v8));
        }
      }
      *(_DWORD *)(a1 + 8) = v5;
    }
    else
    {
      uint64_t v11 = a2;
      int v12 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v12);
        long long v3 = *(const void **)v11;
      }
      *(void *)a1 = v3;
      uint64_t v13 = v11;
      uint64_t v14 = *(void *)(v11 + 8);
      long long v6 = (_DWORD *)(v11 + 8);
      *(void *)(a1 + 8) = v14;
      *(void *)uint64_t v13 = v4;
      *(_DWORD *)(v13 + 12) = 0;
    }
    *long long v6 = 0;
  }
  return a1;
}

void *sub_1CD69ED50(void *a1)
{
  *a1 = &unk_1F262CA68;
  long long v2 = (void *)a1[1];
  if (v2 != a1 + 3) {
    free(v2);
  }
  return a1;
}

void sub_1CD69EDA4(void *a1)
{
  *a1 = &unk_1F262CA68;
  int v1 = (void *)a1[1];
  if (v1 != a1 + 3) {
    free(v1);
  }

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CD69EE24(void *a1)
{
  *a1 = &unk_1F262CA98;
  llvm::AAResults::~AAResults((llvm::AAResults *)(a1 + 1));
  return a1;
}

const char *sub_1CD69EE68()
{
  uint64_t v10 = "StringRef llvm::getTypeName() [DesiredTypeName = llvm::AAManager]";
  unint64_t v11 = 65;
  unint64_t v0 = llvm::StringRef::find((uint64_t *)&v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v11 >= v0) {
    unint64_t v1 = v0;
  }
  else {
    unint64_t v1 = v11;
  }
  long long v2 = &v10[v1];
  unint64_t v3 = v11 - v1;
  if (v11 - v1 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v11 - v1;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

void sub_1CD69EF24()
{
}

void sub_1CD69EF38()
{
}

llvm::raw_ostream *sub_1CD69EF40(uint64_t a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, const char *, uint64_t), uint64_t a4)
{
  return sub_1CD69EF54(a1 + 8, a2, a3, a4);
}

uint64_t sub_1CD69EF4C()
{
  return 1;
}

llvm::raw_ostream *sub_1CD69EF54(uint64_t a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, const char *, uint64_t), uint64_t a4)
{
  unint64_t v7 = sub_1CD69F000();
  uint64_t v10 = (const void *)a3(a4, v7, v8);
  size_t v11 = v9;
  uint64_t result = (llvm::raw_ostream *)*((void *)a2 + 4);
  if (v9 <= *((void *)a2 + 3) - (void)result)
  {
    if (v9)
    {
      uint64_t result = (llvm::raw_ostream *)memcpy(result, v10, v9);
      *((void *)a2 + 4) += v11;
    }
  }
  else
  {
    return llvm::raw_ostream::write(a2, (const char *)v10, v9);
  }
  return result;
}

const char *sub_1CD69F000()
{
  uint64_t v10 = "StringRef llvm::getTypeName() [DesiredTypeName = llvm::VerifierPass]";
  unint64_t v11 = 68;
  unint64_t v0 = llvm::StringRef::find((uint64_t *)&v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v11 >= v0) {
    unint64_t v1 = v0;
  }
  else {
    unint64_t v1 = v11;
  }
  long long v2 = &v10[v1];
  unint64_t v3 = v11 - v1;
  if (v11 - v1 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v11 - v1;
  }
  uint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

uint64_t sub_1CD69F0B8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 128))
  {
    sub_1CD69E9BC(a1 + 32);
    *(unsigned char *)(a1 + 128) = 0;
  }
  return a1;
}

void **sub_1CD69F1AC(void **result)
{
  unint64_t v1 = (void **)*result;
  uint64_t v2 = *((unsigned int *)result + 2);
  if (v2)
  {
    unint64_t v7 = result;
    uint64_t v3 = 32 * v2;
    uint64_t v4 = (char *)(v1 - 4);
    do
    {
      uint64_t v5 = *(char **)&v4[v3 + 24];
      if (&v4[v3] == v5)
      {
        (*(void (**)(char *))(*(void *)&v4[v3] + 32))(&v4[v3]);
      }
      else if (v5)
      {
        (*(void (**)(char *))(*(void *)v5 + 40))(v5);
      }
      v3 -= 32;
    }
    while (v3);
    uint64_t result = v7;
    unint64_t v1 = (void **)*v7;
  }
  if (v1 != result + 2)
  {
    unint64_t v6 = result;
    free(v1);
    return v6;
  }
  return result;
}

void **sub_1CD69F280(void **result)
{
  unint64_t v1 = (void **)*result;
  uint64_t v2 = *((unsigned int *)result + 2);
  if (v2)
  {
    unint64_t v7 = result;
    uint64_t v3 = 32 * v2;
    uint64_t v4 = (char *)(v1 - 4);
    do
    {
      uint64_t v5 = *(char **)&v4[v3 + 24];
      if (&v4[v3] == v5)
      {
        (*(void (**)(char *))(*(void *)&v4[v3] + 32))(&v4[v3]);
      }
      else if (v5)
      {
        (*(void (**)(char *))(*(void *)v5 + 40))(v5);
      }
      v3 -= 32;
    }
    while (v3);
    uint64_t result = v7;
    unint64_t v1 = (void **)*v7;
  }
  if (v1 != result + 2)
  {
    unint64_t v6 = result;
    free(v1);
    return v6;
  }
  return result;
}

void **sub_1CD69F354(void **result)
{
  unint64_t v1 = (void **)*result;
  uint64_t v2 = *((unsigned int *)result + 2);
  if (v2)
  {
    unint64_t v7 = result;
    uint64_t v3 = 32 * v2;
    uint64_t v4 = (char *)(v1 - 4);
    do
    {
      uint64_t v5 = *(char **)&v4[v3 + 24];
      if (&v4[v3] == v5)
      {
        (*(void (**)(char *))(*(void *)&v4[v3] + 32))(&v4[v3]);
      }
      else if (v5)
      {
        (*(void (**)(char *))(*(void *)v5 + 40))(v5);
      }
      v3 -= 32;
    }
    while (v3);
    uint64_t result = v7;
    unint64_t v1 = (void **)*v7;
  }
  if (v1 != result + 2)
  {
    unint64_t v6 = result;
    free(v1);
    return v6;
  }
  return result;
}

char **sub_1CD69F428(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 32 * v3;
    uint64_t v5 = v2 - 32;
    do
    {
      unint64_t v6 = *(char **)&v5[v4 + 24];
      if (&v5[v4] == v6)
      {
        (*(void (**)(char *))(*(void *)&v5[v4] + 32))(&v5[v4]);
      }
      else if (v6)
      {
        (*(void (**)(char *))(*(void *)v6 + 40))(v6);
      }
      v4 -= 32;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

void **sub_1CD69F4EC(void **result)
{
  unint64_t v1 = (void **)*result;
  uint64_t v2 = *((unsigned int *)result + 2);
  if (v2)
  {
    unint64_t v7 = result;
    uint64_t v3 = 32 * v2;
    uint64_t v4 = (char *)(v1 - 4);
    do
    {
      uint64_t v5 = *(char **)&v4[v3 + 24];
      if (&v4[v3] == v5)
      {
        (*(void (**)(char *))(*(void *)&v4[v3] + 32))(&v4[v3]);
      }
      else if (v5)
      {
        (*(void (**)(char *))(*(void *)v5 + 40))(v5);
      }
      v3 -= 32;
    }
    while (v3);
    uint64_t result = v7;
    unint64_t v1 = (void **)*v7;
  }
  if (v1 != result + 2)
  {
    unint64_t v6 = result;
    free(v1);
    return v6;
  }
  return result;
}

void **sub_1CD69F5C0(void **result)
{
  unint64_t v1 = (void **)*result;
  uint64_t v2 = *((unsigned int *)result + 2);
  if (v2)
  {
    unint64_t v7 = result;
    uint64_t v3 = 32 * v2;
    uint64_t v4 = (char *)(v1 - 4);
    do
    {
      uint64_t v5 = *(char **)&v4[v3 + 24];
      if (&v4[v3] == v5)
      {
        (*(void (**)(char *))(*(void *)&v4[v3] + 32))(&v4[v3]);
      }
      else if (v5)
      {
        (*(void (**)(char *))(*(void *)v5 + 40))(v5);
      }
      v3 -= 32;
    }
    while (v3);
    uint64_t result = v7;
    unint64_t v1 = (void **)*v7;
  }
  if (v1 != result + 2)
  {
    unint64_t v6 = result;
    free(v1);
    return v6;
  }
  return result;
}

void **sub_1CD69F694(void **result)
{
  unint64_t v1 = (void **)*result;
  uint64_t v2 = *((unsigned int *)result + 2);
  if (v2)
  {
    unint64_t v7 = result;
    uint64_t v3 = 32 * v2;
    uint64_t v4 = (char *)(v1 - 4);
    do
    {
      uint64_t v5 = *(char **)&v4[v3 + 24];
      if (&v4[v3] == v5)
      {
        (*(void (**)(char *))(*(void *)&v4[v3] + 32))(&v4[v3]);
      }
      else if (v5)
      {
        (*(void (**)(char *))(*(void *)v5 + 40))(v5);
      }
      v3 -= 32;
    }
    while (v3);
    uint64_t result = v7;
    unint64_t v1 = (void **)*v7;
  }
  if (v1 != result + 2)
  {
    unint64_t v6 = result;
    free(v1);
    return v6;
  }
  return result;
}

void **sub_1CD69F768(void **result)
{
  unint64_t v1 = (void **)*result;
  uint64_t v2 = *((unsigned int *)result + 2);
  if (v2)
  {
    unint64_t v7 = result;
    uint64_t v3 = 32 * v2;
    uint64_t v4 = (char *)(v1 - 4);
    do
    {
      uint64_t v5 = *(char **)&v4[v3 + 24];
      if (&v4[v3] == v5)
      {
        (*(void (**)(char *))(*(void *)&v4[v3] + 32))(&v4[v3]);
      }
      else if (v5)
      {
        (*(void (**)(char *))(*(void *)v5 + 40))(v5);
      }
      v3 -= 32;
    }
    while (v3);
    uint64_t result = v7;
    unint64_t v1 = (void **)*v7;
  }
  if (v1 != result + 2)
  {
    unint64_t v6 = result;
    free(v1);
    return v6;
  }
  return result;
}

char **sub_1CD69F83C(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 32 * v3;
    uint64_t v5 = v2 - 32;
    do
    {
      unint64_t v6 = *(char **)&v5[v4 + 24];
      if (&v5[v4] == v6)
      {
        (*(void (**)(char *))(*(void *)&v5[v4] + 32))(&v5[v4]);
      }
      else if (v6)
      {
        (*(void (**)(char *))(*(void *)v6 + 40))(v6);
      }
      v4 -= 32;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

char **sub_1CD69F900(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 32 * v3;
    uint64_t v5 = v2 - 32;
    do
    {
      unint64_t v6 = *(char **)&v5[v4 + 24];
      if (&v5[v4] == v6)
      {
        (*(void (**)(char *))(*(void *)&v5[v4] + 32))(&v5[v4]);
      }
      else if (v6)
      {
        (*(void (**)(char *))(*(void *)v6 + 40))(v6);
      }
      v4 -= 32;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

void **sub_1CD69F9C4(void **result)
{
  unint64_t v1 = (void **)*result;
  uint64_t v2 = *((unsigned int *)result + 2);
  if (v2)
  {
    unint64_t v7 = result;
    uint64_t v3 = 32 * v2;
    uint64_t v4 = (char *)(v1 - 4);
    do
    {
      uint64_t v5 = *(char **)&v4[v3 + 24];
      if (&v4[v3] == v5)
      {
        (*(void (**)(char *))(*(void *)&v4[v3] + 32))(&v4[v3]);
      }
      else if (v5)
      {
        (*(void (**)(char *))(*(void *)v5 + 40))(v5);
      }
      v3 -= 32;
    }
    while (v3);
    uint64_t result = v7;
    unint64_t v1 = (void **)*v7;
  }
  if (v1 != result + 2)
  {
    unint64_t v6 = result;
    free(v1);
    return v6;
  }
  return result;
}

void **sub_1CD69FA98(void **result)
{
  unint64_t v1 = (void **)*result;
  uint64_t v2 = *((unsigned int *)result + 2);
  if (v2)
  {
    unint64_t v7 = result;
    uint64_t v3 = 32 * v2;
    uint64_t v4 = (char *)(v1 - 4);
    do
    {
      uint64_t v5 = *(char **)&v4[v3 + 24];
      if (&v4[v3] == v5)
      {
        (*(void (**)(char *))(*(void *)&v4[v3] + 32))(&v4[v3]);
      }
      else if (v5)
      {
        (*(void (**)(char *))(*(void *)v5 + 40))(v5);
      }
      v3 -= 32;
    }
    while (v3);
    uint64_t result = v7;
    unint64_t v1 = (void **)*v7;
  }
  if (v1 != result + 2)
  {
    unint64_t v6 = result;
    free(v1);
    return v6;
  }
  return result;
}

void **sub_1CD69FB6C(void **result)
{
  unint64_t v1 = (void **)*result;
  uint64_t v2 = *((unsigned int *)result + 2);
  if (v2)
  {
    unint64_t v7 = result;
    uint64_t v3 = 32 * v2;
    uint64_t v4 = (char *)(v1 - 4);
    do
    {
      uint64_t v5 = *(char **)&v4[v3 + 24];
      if (&v4[v3] == v5)
      {
        (*(void (**)(char *))(*(void *)&v4[v3] + 32))(&v4[v3]);
      }
      else if (v5)
      {
        (*(void (**)(char *))(*(void *)v5 + 40))(v5);
      }
      v3 -= 32;
    }
    while (v3);
    uint64_t result = v7;
    unint64_t v1 = (void **)*v7;
  }
  if (v1 != result + 2)
  {
    unint64_t v6 = result;
    free(v1);
    return v6;
  }
  return result;
}

void sub_1CD69FC40(uint64_t a1)
{
  llvm::DotCfgChangeReporter::~DotCfgChangeReporter((llvm::DotCfgChangeReporter *)(a1 + 640));
  llvm::InLineChangePrinter::~InLineChangePrinter((llvm::InLineChangePrinter *)(a1 + 584));
  sub_1CD69FCB4(a1 + 552);
  llvm::IRChangedPrinter::~IRChangedPrinter((llvm::IRChangedPrinter *)(a1 + 504));
  uint64_t v2 = *(void **)(a1 + 360);
  if (v2 != (void *)(a1 + 376)) {
    free(v2);
  }
  sub_1CD69FD3C((llvm::TimePassesHandler *)(a1 + 128));

  llvm::PrintIRInstrumentation::~PrintIRInstrumentation((void **)a1);
}

uint64_t sub_1CD69FCB4(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 12))
  {
    uint64_t v3 = *(unsigned int *)(a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t v6 = *(void *)(*(void *)a1 + v4);
        if (v6 != -8 && v6 != 0)
        {
          sub_1CD4CAAF4(v6 + 8);
          MEMORY[0x1D25D9CD0](v6, 8);
        }
        v4 += 8;
      }
      while (v5 != v4);
    }
  }
  free(*(void **)a1);
  return a1;
}

void sub_1CD69FD3C(llvm::TimePassesHandler *a1)
{
  llvm::TimePassesHandler::print(a1);
  uint64_t v2 = (void *)*((void *)a1 + 16);
  if (v2 != (void *)((char *)a1 + 144)) {
    free(v2);
  }
  sub_1CD69FD94((uint64_t)a1 + 96);

  llvm::TimerGroup::~TimerGroup(a1);
}

uint64_t sub_1CD69FD94(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 12))
  {
    uint64_t v3 = *(unsigned int *)(a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t v6 = *(void *)(*(void *)a1 + v4);
        if (v6 != -8 && v6 != 0)
        {
          sub_1CD69FE1C((char **)(v6 + 8));
          MEMORY[0x1D25D9CD0](v6, 8);
        }
        v4 += 8;
      }
      while (v5 != v4);
    }
  }
  free(*(void **)a1);
  return a1;
}

char **sub_1CD69FE1C(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 8 * v3;
    uint64_t v5 = v2 - 8;
    do
    {
      uint64_t v6 = *(llvm::Timer **)&v5[v4];
      *(void *)&v5[v4] = 0;
      if (v6)
      {
        llvm::Timer::~Timer(v6);
        MEMORY[0x1D25D9CE0]();
      }
      v4 -= 8;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

char **sub_1CD69FE9C(char **a1)
{
  sub_1CCB7ABD0((uint64_t)(a1 + 162));
  uint64_t v2 = a1[144];
  uint64_t v3 = *((unsigned int *)a1 + 290);
  if (v3)
  {
    uint64_t v23 = 32 * v3;
    int v24 = v2 - 32;
    do
    {
      sub_1CD500E14(&v24[v23]);
      v23 -= 32;
    }
    while (v23);
    uint64_t v2 = a1[144];
  }
  if (v2 != (char *)(a1 + 146)) {
    free(v2);
  }
  uint64_t v4 = a1[126];
  uint64_t v5 = *((unsigned int *)a1 + 254);
  if (v5)
  {
    uint64_t v25 = 32 * v5;
    char v26 = v4 - 32;
    do
    {
      sub_1CD500E14(&v26[v25]);
      v25 -= 32;
    }
    while (v25);
    uint64_t v4 = a1[126];
  }
  if (v4 != (char *)(a1 + 128)) {
    free(v4);
  }
  uint64_t v6 = a1[108];
  uint64_t v7 = *((unsigned int *)a1 + 218);
  if (v7)
  {
    uint64_t v27 = 32 * v7;
    __int16 v28 = v6 - 32;
    do
    {
      sub_1CD500E14(&v28[v27]);
      v27 -= 32;
    }
    while (v27);
    uint64_t v6 = a1[108];
  }
  if (v6 != (char *)(a1 + 110)) {
    free(v6);
  }
  uint64_t v8 = a1[90];
  uint64_t v9 = *((unsigned int *)a1 + 182);
  if (v9)
  {
    uint64_t v29 = 32 * v9;
    uint64_t v30 = v8 - 32;
    do
    {
      sub_1CD500E14(&v30[v29]);
      v29 -= 32;
    }
    while (v29);
    uint64_t v8 = a1[90];
  }
  if (v8 != (char *)(a1 + 92)) {
    free(v8);
  }
  uint64_t v10 = a1[72];
  uint64_t v11 = *((unsigned int *)a1 + 146);
  if (v11)
  {
    uint64_t v31 = 32 * v11;
    char v32 = v10 - 32;
    do
    {
      sub_1CD500E14(&v32[v31]);
      v31 -= 32;
    }
    while (v31);
    uint64_t v10 = a1[72];
  }
  if (v10 != (char *)(a1 + 74)) {
    free(v10);
  }
  int v12 = a1[54];
  uint64_t v13 = *((unsigned int *)a1 + 110);
  if (v13)
  {
    uint64_t v33 = 32 * v13;
    __int16 v34 = v12 - 32;
    do
    {
      sub_1CD500E14(&v34[v33]);
      v33 -= 32;
    }
    while (v33);
    int v12 = a1[54];
  }
  if (v12 != (char *)(a1 + 56)) {
    free(v12);
  }
  uint64_t v14 = a1[36];
  uint64_t v15 = *((unsigned int *)a1 + 74);
  if (v15)
  {
    uint64_t v35 = 32 * v15;
    __int16 v36 = v14 - 32;
    do
    {
      sub_1CD500E14(&v36[v35]);
      v35 -= 32;
    }
    while (v35);
    uint64_t v14 = a1[36];
  }
  if (v14 != (char *)(a1 + 38)) {
    free(v14);
  }
  uint64_t v16 = a1[18];
  uint64_t v17 = *((unsigned int *)a1 + 38);
  if (v17)
  {
    uint64_t v37 = 32 * v17;
    __int16 v38 = v16 - 32;
    do
    {
      sub_1CD500E14(&v38[v37]);
      v37 -= 32;
    }
    while (v37);
    uint64_t v16 = a1[18];
  }
  if (v16 != (char *)(a1 + 20)) {
    free(v16);
  }
  uint64_t v18 = *a1;
  uint64_t v19 = *((unsigned int *)a1 + 2);
  if (v19)
  {
    uint64_t v20 = 32 * v19;
    uint64_t v21 = v18 - 32;
    do
    {
      sub_1CD58927C((llvm *)&v21[v20]);
      v20 -= 32;
    }
    while (v20);
    uint64_t v18 = *a1;
  }
  if (v18 != (char *)(a1 + 2)) {
    free(v18);
  }
  return a1;
}

uint64_t sub_1CD6A010C(uint64_t a1, int a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v3 = (37 * a3) & (a2 - 1);
    uint64_t v4 = *(void *)(a1 + 16 * v3);
    if (v4 == a3) {
      return *(void *)(a1 + 16 * v3 + 8);
    }
    int v6 = 1;
    while (v4 != -1)
    {
      int v7 = v3 + v6++;
      uint64_t v3 = v7 & (a2 - 1);
      uint64_t v4 = *(void *)(a1 + 16 * v3);
      if (v4 == a3) {
        return *(void *)(a1 + 16 * v3 + 8);
      }
    }
  }
  return 0;
}

void sub_1CD6A0170(int **a1, uint64_t a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)qword_1EBCEDF58, 0, 0);
  dword_1EBCEDFD8 = 0;
  qword_1EBCEDFE0 = (uint64_t)&unk_1F262C9E0;
  *(void *)&dword_1EBCEDFE8 = 0;
  qword_1EBCEDF58[0] = (uint64_t)&unk_1F262C928;
  qword_1EBCEDFF0 = (uint64_t)&unk_1F262C990;
  qword_1EBCEDFF8 = (uint64_t)qword_1EBCEDF58;
  qword_1EBCEE000 = (uint64_t)&unk_1EBCEE010;
  qword_1EBCEE008 = 0x800000000;
  qword_1EBCEE190 = (uint64_t)&unk_1F262CB48;
  qword_1EBCEE1A8 = (uint64_t)&qword_1EBCEE190;
  sub_1CD6A0274(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EBCEDF58);
}

__n128 sub_1CD6A0274(int **a1, uint64_t a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCEDF58, "lto-embed-bitcode", 0x11uLL);
  int v6 = *a1;
  dword_1EBCEDFD8 = **a1;
  byte_1EBCEDFEC = 1;
  dword_1EBCEDFE8 = *v6;
  sub_1CD6A036C(*(void *)a2, *(_DWORD *)(a2 + 8));
  __n128 result = *a3;
  xmmword_1EBCEDF78 = (__int128)*a3;
  return result;
}

void sub_1CD6A02F4()
{
}

void *sub_1CD6A0308()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1F262CB48;
  return result;
}

void sub_1CD6A0340(uint64_t a1, void *a2)
{
  *a2 = &unk_1F262CB48;
}

void sub_1CD6A036C(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = a1;
    uint64_t v3 = a1 + 40 * a2;
    do
    {
      sub_1CD6A03B8(*(unsigned __int8 **)v2, *(void *)(v2 + 8), *(_DWORD *)(v2 + 16), *(void *)(v2 + 24), *(void *)(v2 + 32));
      v2 += 40;
    }
    while (v2 != v3);
  }
}

void sub_1CD6A03B8(unsigned __int8 *a1, size_t a2, int a3, uint64_t a4, uint64_t a5)
{
  v11[0] = a1;
  v11[1] = a2;
  void v11[2] = a4;
  void v11[3] = a5;
  _DWORD v11[4] = &unk_1F262C9E0;
  char v13 = 1;
  int v12 = a3;
  unint64_t v7 = sub_1CD6A04AC((unint64_t)v11);
  uint64_t v8 = qword_1EBCEE000 + 48 * qword_1EBCEE008;
  long long v9 = *(_OWORD *)(v7 + 16);
  *(_OWORD *)uint64_t v8 = *(_OWORD *)v7;
  *(_OWORD *)(v8 + 16) = v9;
  *(void *)(v8 + 32) = &unk_1F262CA00;
  char v10 = *(unsigned char *)(v7 + 44);
  *(_DWORD *)(v8 + 40) = *(_DWORD *)(v7 + 40);
  *(unsigned char *)(v8 + 44) = v10;
  *(void *)(v8 + 32) = &unk_1F262C9E0;
  LODWORD(qword_1EBCEE008) = qword_1EBCEE008 + 1;
  llvm::cl::AddLiteralOption(qword_1EBCEDFF8, a1, a2);
}

unint64_t sub_1CD6A04AC(unint64_t result)
{
  if (qword_1EBCEE008 >= HIDWORD(qword_1EBCEE008))
  {
    if (qword_1EBCEE000 > result || qword_1EBCEE000 + 48 * (unint64_t)qword_1EBCEE008 <= result) {
      sub_1CD6A0528();
    }
    sub_1CD6A0528();
  }
  return result;
}

void sub_1CD6A0528()
{
}

uint64_t sub_1CD6A0620(uint64_t a1, const void **a2)
{
  uint64_t v4 = 0;
  if (!sub_1CD69C804((uint64_t *)a1, a2, &v4) || v4 == *(void *)a1 + 24 * *(unsigned int *)(a1 + 16)) {
    return *(void *)(a1 + 32);
  }
  else {
    return *(void *)(a1 + 24) + 80 * *(unsigned int *)(v4 + 16);
  }
}

llvm *sub_1CD6A068C(llvm *result, _DWORD *a2, uint64_t a3)
{
  uint64_t v4 = result;
  if (a3 == 4 && *a2 == 1869903201)
  {
    *((unsigned char *)result + 16) &= ~1u;
    *(unsigned char *)__n128 result = 0;
    *((unsigned char *)result + 8) = 0;
  }
  else
  {
    uint64_t v8 = 0;
    __n128 result = (llvm *)llvm::getAsSignedInteger((uint64_t)a2, a3, (llvm::StringRef *)0xA, (unint64_t *)&v8);
    if (result)
    {
      uint64_t v6 = llvm::inconvertibleErrorCode(result);
      uint64_t v8 = (uint64_t)a2;
      sub_1CD5E3960(v6, v7, (uint64_t)"Not an integer: %s", &v8);
    }
    uint64_t v5 = v8 & ~(v8 >> 63);
    *((unsigned char *)v4 + 16) &= ~1u;
    *(void *)uint64_t v4 = v5;
    *((unsigned char *)v4 + 8) = 1;
  }
  return result;
}

uint64_t sub_1CD6A075C(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  sub_1CD4546AC(a1 + 24);
  *(void *)(a1 + 400) = 0;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_DWORD *)(a1 + 408) = 1;
  *(unsigned char *)(a1 + 412) = 1;
  *(unsigned char *)(a1 + 416) = 0;
  *(unsigned char *)(a1 + 420) = 0;
  *(void *)(a1 + 424) = 0x100000002;
  *(void *)(a1 + 432) = 2;
  *(_WORD *)(a1 + 440) = 256;
  *(void *)(a1 + 744) = 0;
  *(_OWORD *)(a1 + 442) = 0u;
  *(_OWORD *)(a1 + 458) = 0u;
  *(_OWORD *)(a1 + 474) = 0u;
  *(_OWORD *)(a1 + 490) = 0u;
  *(_OWORD *)(a1 + 506) = 0u;
  *(_OWORD *)(a1 + 522) = 0u;
  *(_OWORD *)(a1 + 538) = 0u;
  *(_OWORD *)(a1 + 554) = 0u;
  *(_OWORD *)(a1 + 570) = 0u;
  *(_OWORD *)(a1 + 586) = 0u;
  *(_OWORD *)(a1 + 602) = 0u;
  *(_OWORD *)(a1 + 618) = 0u;
  *(_OWORD *)(a1 + 634) = 0u;
  *(_OWORD *)(a1 + 650) = 0u;
  *(_OWORD *)(a1 + 666) = 0u;
  *(_OWORD *)(a1 + 682) = 0u;
  *(_OWORD *)(a1 + 698) = 0u;
  *(_OWORD *)(a1 + 714) = 0u;
  *(void *)(a1 + 729) = 0;
  *(unsigned char *)(a1 + 752) = 1;
  *(void *)(a1 + 760) = 0;
  *(void *)(a1 + 776) = 0;
  *(void *)(a1 + 768) = 0;
  *(unsigned char *)(a1 + 784) = 0;
  *(_OWORD *)(a1 + 792) = 0u;
  *(_OWORD *)(a1 + 808) = 0u;
  *(_OWORD *)(a1 + 824) = 0u;
  *(unsigned char *)(a1 + 840) = 0;
  *(_DWORD *)(a1 + 844) = 500;
  *(unsigned char *)(a1 + 848) = 1;
  *(void *)(a1 + 880) = 0;
  *(unsigned char *)(a1 + 888) = 0;
  *(void *)(a1 + 896) = 0;
  llvm::PipelineTuningOptions::PipelineTuningOptions((llvm::PipelineTuningOptions *)(a1 + 904));
  *(void *)(a1 + 952) = 0;
  *(void *)(a1 + 984) = 0;
  *(void *)(a1 + 1016) = 0;
  *(void *)(a1 + 1048) = 0;
  *(void *)(a1 + 1080) = 0;
  *(void *)(a1 + 1112) = 0;
  *(void *)(a1 + 1144) = 0;
  return a1;
}

std::string *sub_1CD6A0868(std::string *this, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__r.__words[2] = 0;
  if (a2 != a3)
  {
    uint64_t v5 = this;
    std::string::size_type v6 = 0;
    uint64_t v7 = a2;
    do
    {
      if (*(char *)(v7 + 23) < 0) {
        uint64_t v8 = *(void *)(v7 + 8);
      }
      else {
        uint64_t v8 = *(unsigned __int8 *)(v7 + 23);
      }
      v6 += v8;
      v7 += 24;
    }
    while (v7 != a3);
    std::string::reserve(this, v6);
    char v9 = *(unsigned char *)(a2 + 23);
    BOOL v10 = v9 < 0;
    uint64_t v11 = v9 >= 0 ? (const std::string::value_type *)a2 : *(const std::string::value_type **)a2;
    uint64_t v12 = v9 & 0x7F;
    std::string::size_type v13 = v10 ? *(void *)(a2 + 8) : v12;
    this = std::string::append(v5, v11, v13);
    for (uint64_t i = a2 + 24; i != a3; i += 24)
    {
      std::string::append(v5, "", 0);
      char v15 = *(unsigned char *)(i + 23);
      BOOL v16 = v15 < 0;
      if (v15 >= 0) {
        uint64_t v17 = (const std::string::value_type *)i;
      }
      else {
        uint64_t v17 = *(const std::string::value_type **)i;
      }
      std::string::size_type v18 = v15 & 0x7F;
      if (v16) {
        std::string::size_type v19 = *(void *)(i + 8);
      }
      else {
        std::string::size_type v19 = v18;
      }
      this = std::string::append(v5, v17, v19);
    }
  }
  return this;
}

uint64_t llvm::LinkDiagnosticInfo::print(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 128))(a2, *(void *)(a1 + 16));
}

uint64_t llvm::IRMover::StructTypeKeyInfo::getEmptyKey(llvm::IRMover::StructTypeKeyInfo *this)
{
  return -4096;
}

uint64_t llvm::IRMover::StructTypeKeyInfo::getTombstoneKey(llvm::IRMover::StructTypeKeyInfo *this)
{
  return -8192;
}

BOOL llvm::IRMover::StructTypeKeyInfo::isEqual(const void **this, unint64_t a2, const llvm::StructType *a3)
{
  if ((a2 | 0x1000) == 0xFFFFFFFFFFFFF000) {
    return 0;
  }
  if (*((unsigned char *)this + 16) == ((*(_DWORD *)(a2 + 8) >> 9) & 1))
  {
    unint64_t v4 = *(unsigned int *)(a2 + 12);
    if (this[1] == (const void *)v4) {
      return memcmp(*this, *(const void **)(a2 + 16), 8 * v4) == 0;
    }
  }
  return 0;
}

BOOL llvm::IRMover::StructTypeKeyInfo::isEqual(const void **this, const void **a2, const llvm::StructType *a3)
{
  if (((unint64_t)a2 | 0x1000) == 0xFFFFFFFFFFFFF000) {
    return this == a2;
  }
  BOOL result = 0;
  if (((*((_DWORD *)a2 + 2) ^ *((_DWORD *)this + 2)) & 0x200) == 0)
  {
    uint64_t v5 = *((unsigned int *)this + 3);
    if (v5 == *((_DWORD *)a2 + 3)) {
      return memcmp(this[2], a2[2], 8 * v5) == 0;
    }
  }
  return result;
}

uint64_t llvm::IRMover::IdentifiedStructTypeSet::addNonOpaque(llvm::IRMover::IdentifiedStructTypeSet *this, llvm::StructType *a2)
{
  uint64_t v3 = a2;
  return sub_1CD6A1428((uint64_t)v4, (uint64_t)this + 24, (uint64_t *)&v3);
}

int32x2_t llvm::IRMover::IdentifiedStructTypeSet::switchToNonOpaque(int32x2_t *this, llvm::StructType *a2)
{
  uint64_t v5 = a2;
  sub_1CD6A1428((uint64_t)v6, (uint64_t)&this[3], (uint64_t *)&v5);
  v6[0] = 0;
  if (sub_1CCB99544((uint64_t)*this, this[2].i32[0], (uint64_t)a2, v6))
  {
    *(void *)v6[0] = -8192;
    int32x2_t result = vadd_s32(this[1], (int32x2_t)0x1FFFFFFFFLL);
    this[1] = result;
  }
  return result;
}

uint64_t llvm::IRMover::IdentifiedStructTypeSet::addOpaque(llvm::IRMover::IdentifiedStructTypeSet *this, llvm::StructType *a2)
{
  uint64_t v3 = a2;
  return sub_1CCB995CC((uint64_t)v4, (uint64_t)this, (uint64_t *)&v3);
}

uint64_t llvm::IRMover::IdentifiedStructTypeSet::findNonOpaque(uint64_t a1, const void *a2, const void *a3, char a4)
{
  v8[0] = a2;
  v8[1] = a3;
  char v9 = a4;
  BOOL v10 = 0;
  int v5 = sub_1CD6A1884(*(void *)(a1 + 24), *(_DWORD *)(a1 + 40), v8, &v10);
  uint64_t result = 0;
  if (v5) {
    BOOL v7 = v10 == (unint64_t *)(*(void *)(a1 + 24) + 8 * *(unsigned int *)(a1 + 40));
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7) {
    return *v10;
  }
  return result;
}

uint64_t llvm::IRMover::IdentifiedStructTypeSet::hasType(llvm::IRMover::IdentifiedStructTypeSet *this, const void **a2)
{
  if ((*((unsigned char *)a2 + 9) & 1) == 0) {
    return sub_1CD4C9788(*(void *)this, *((_DWORD *)this + 4), (uint64_t)a2, &v7);
  }
  std::string::size_type v6 = a2;
  BOOL v7 = 0;
  if (sub_1CD6A14B4(*((void *)this + 3), *((_DWORD *)this + 10), (uint64_t *)&v6, &v7)) {
    BOOL v5 = v7 == (const void ***)(*((void *)this + 3) + 8 * *((unsigned int *)this + 10));
  }
  else {
    BOOL v5 = 1;
  }
  return !v5 && *v7 == a2;
}

void sub_1CD6A0C94()
{
}

uint64_t sub_1CD6A0CA8(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)(result + 24)) {
    return sub_1CD6A0D14(result, a2);
  }
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)uint64_t result = *(void *)a2;
  *(void *)a2 = 0;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = 0;
  int v2 = *(_DWORD *)(result + 12);
  *(_DWORD *)(result + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = v2;
  int v3 = *(_DWORD *)(result + 16);
  *(_DWORD *)(result + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v3;
  *(unsigned char *)(result + 24) = 1;
  return result;
}

uint64_t sub_1CD6A0D14(uint64_t a1, uint64_t a2)
{
  sub_1CC009394(a1);
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)a1 = *(void *)a2;
  *(void *)a2 = 0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = 0;
  int v4 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = v4;
  int v5 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v5;
  return a1;
}

void sub_1CD6A0D8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a4 && *(void *)(a4 + 8) != a2) {
    llvm::SymbolTableListTraits<llvm::GlobalVariable>::transferNodesFromList();
  }
}

void *sub_1CD6A0E0C(uint64_t *a1, void *a2)
{
  BOOL v7 = 0;
  char v4 = sub_1CB915048(a1, a2, &v7);
  int v5 = v7;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CC7BBA58((uint64_t)a1, (uint64_t)a2, a2, v7);
    *int v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

BOOL sub_1CD6A0E6C(uint64_t a1, uint64_t *a2)
{
  sub_1CD6A0FB8(a1, a2, (uint64_t)&v8);
  int v4 = v9;
  if (v9)
  {
    uint64_t v5 = *a2;
    unsigned int v6 = *(_DWORD *)(a1 + 144);
    if (v6 >= *(_DWORD *)(a1 + 148)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 136) + 8 * v6) = v5;
    ++*(_DWORD *)(a1 + 144);
  }
  return v4 != 0;
}

void *sub_1CD6A0EFC(void *result, uint64_t *a2, uint64_t *a3)
{
  if (a2 != a3)
  {
    uint64_t v11 = v3;
    uint64_t v12 = v4;
    unsigned int v6 = a2;
    uint64_t v7 = (uint64_t)result;
    do
    {
      uint64_t v9 = *v6;
      uint64_t result = sub_1CD529884((uint64_t)v10, v7, &v9);
      if (v10[16])
      {
        unint64_t v8 = *(unsigned int *)(v7 + 144);
        if (v8 >= *(unsigned int *)(v7 + 148)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v7 + 136) + 8 * v8) = *v6;
        ++*(_DWORD *)(v7 + 144);
      }
      ++v6;
    }
    while (v6 != a3);
  }
  return result;
}

void *sub_1CD6A0FB8@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v14 = 0;
  uint64_t result = (void *)sub_1CD6A1074(a1, a2, &v14);
  uint64_t v7 = v14;
  if (result)
  {
    uint64_t v8 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v9 = 16;
    }
    else
    {
      uint64_t v8 = *(void *)(a1 + 8);
      uint64_t v9 = *(unsigned int *)(a1 + 16);
    }
    char v10 = 0;
    uint64_t v11 = v8 + 8 * v9;
  }
  else
  {
    uint64_t result = sub_1CD6A1124((_DWORD *)a1, (uint64_t)a2, a2, v14);
    uint64_t v7 = result;
    void *result = *a2;
    uint64_t v12 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v13 = 16;
    }
    else
    {
      uint64_t v12 = *(void *)(a1 + 8);
      uint64_t v13 = *(unsigned int *)(a1 + 16);
    }
    uint64_t v11 = v12 + 8 * v13;
    char v10 = 1;
  }
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v11;
  *(unsigned char *)(a3 + 16) = v10;
  return result;
}

uint64_t sub_1CD6A1074(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 16;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  uint64_t v7 = (void *)(v3 + 8 * v6);
  uint64_t v8 = *v7;
  if (*a2 == *v7)
  {
    uint64_t result = 1;
  }
  else
  {
    char v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        char v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 8 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    if (v10) {
      uint64_t v7 = v10;
    }
  }
LABEL_7:
  *a3 = v7;
  return result;
}

void *sub_1CD6A1124(_DWORD *a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *a1 >> 1;
  if (*a1) {
    unsigned int v7 = 16;
  }
  else {
    unsigned int v7 = a1[4];
  }
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - a1[1] > v7 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD6A11E4((uint64_t)a1, v7);
  uint64_t v9 = 0;
  sub_1CD6A1074((uint64_t)a1, a3, &v9);
  a4 = v9;
LABEL_6:
  *a1 += 2;
  if (*a4 != -4096) {
    --a1[1];
  }
  return a4;
}

uint64_t sub_1CD6A11E4(uint64_t a1, unsigned int a2)
{
  v14[16] = *MEMORY[0x1E4F143B8];
  if (a2 >= 0x11)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    int v6 = *(void **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 0x10)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD6A1360(a1, v6, &v6[v7]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = v14;
  for (uint64_t i = 8; i != 136; i += 8)
  {
    uint64_t v10 = *(void *)(a1 + i);
    if ((v10 | 0x1000) != 0xFFFFFFFFFFFFF000) {
      *v8++ = v10;
    }
  }
  if (a2 > 0x10)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD6A1360(a1, v14, v8);
}

uint64_t sub_1CD6A1360(uint64_t result, void *a2, void *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 136);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[v7];
  }
  do
    *v8++ = -4096;
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v10 = 0;
      uint64_t result = sub_1CD6A1074((uint64_t)v5, a2, &v10);
      *uint64_t v10 = *a2;
      *v5 += 2;
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD6A1428(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD6A14B4(*(void *)a2, *(_DWORD *)(a2 + 16), a3, &v10);
  uint64_t v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD6A15A8(a2, a3, v10);
    uint64_t v7 = (const void ***)result;
    *(void *)uint64_t result = *a3;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a2 + 8 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v9;
  *(unsigned char *)(a1 + 16) = v8;
  return result;
}

uint64_t sub_1CD6A14B4(uint64_t a1, int a2, uint64_t *a3, const void ****a4)
{
  if (a2)
  {
    int v10 = sub_1CD5D9F48(*a3);
    int v11 = a2 - 1;
    BOOL v12 = (const void **)*a3;
    unsigned int v13 = v10 & (a2 - 1);
    int v5 = (const void ***)(a1 + 8 * v13);
    uint64_t v14 = *v5;
    if (llvm::IRMover::StructTypeKeyInfo::isEqual(v12, *v5, v15))
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v17 = 0;
      int v18 = 1;
      while (v14 != (const void **)-4096)
      {
        if (v17) {
          BOOL v19 = 0;
        }
        else {
          BOOL v19 = v14 == (const void **)-8192;
        }
        if (v19) {
          uint64_t v17 = v5;
        }
        int v20 = v18 + 1;
        unsigned int v13 = (v13 + v18) & v11;
        int v5 = (const void ***)(a1 + 8 * v13);
        uint64_t v14 = *v5;
        BOOL isEqual = llvm::IRMover::StructTypeKeyInfo::isEqual(v12, *v5, v16);
        uint64_t result = 1;
        int v18 = v20;
        if (isEqual) {
          goto LABEL_3;
        }
      }
      uint64_t result = 0;
      if (v17) {
        int v5 = v17;
      }
    }
  }
  else
  {
    int v5 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a4 = v5;
  return result;
}

const void ***sub_1CD6A15A8(uint64_t a1, uint64_t *a2, const void ***a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD6A165C(a1, v6);
  char v8 = 0;
  sub_1CD6A14B4(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != (const void **)-4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD6A165C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  unint64_t v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD6A1728(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD6A1728(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v9 = 0;
      uint64_t result = sub_1CD6A14B4(*(void *)v5, *(_DWORD *)(v5 + 16), a2, &v9);
      *uint64_t v9 = (const void **)*a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD6A17DC(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v10 = 0;
      uint64_t result = sub_1CCB99544(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v10);
      *uint64_t v10 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD6A1884(uint64_t a1, int a2, const void **a3, unint64_t **a4)
{
  if (a2)
  {
    unint64_t v20 = sub_1CC13A6B8(*a3, (uint64_t)*a3 + 8 * (void)a3[1]);
    int v10 = a2 - 1;
    unsigned int v11 = (a2 - 1) & sub_1CC623948(&v20, (unsigned char *)a3 + 16);
    uint64_t v5 = (unint64_t *)(a1 + 8 * v11);
    unint64_t v12 = *v5;
    if (llvm::IRMover::StructTypeKeyInfo::isEqual(a3, *v5, v13))
    {
      uint64_t result = 1;
    }
    else
    {
      char v15 = 0;
      int v16 = 1;
      while (v12 != -4096)
      {
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v12 == -8192;
        }
        if (v17) {
          char v15 = v5;
        }
        int v18 = v16 + 1;
        unsigned int v11 = (v11 + v16) & v10;
        uint64_t v5 = (unint64_t *)(a1 + 8 * v11);
        unint64_t v12 = *v5;
        BOOL isEqual = llvm::IRMover::StructTypeKeyInfo::isEqual(a3, *v5, v14);
        uint64_t result = 1;
        int v16 = v18;
        if (isEqual) {
          goto LABEL_3;
        }
      }
      uint64_t result = 0;
      if (v15) {
        uint64_t v5 = v15;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a4 = v5;
  return result;
}

uint64_t llvm::Linker::linkModules(llvm::Module *a1, llvm::Module **a2, int a3, void *a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  llvm::IRMover::IRMover((llvm::IRMover *)&v17, a1);
  int v7 = *a2;
  *a2 = 0;
  int v16 = v7;
  uint64_t v8 = (void *)a4[3];
  if (v8)
  {
    if (v8 == a4)
    {
      char v22 = v21;
      (*(void (**)(void *, void *))(*a4 + 24))(a4, v21);
    }
    else
    {
      char v22 = (void *)a4[3];
      a4[3] = 0;
    }
  }
  else
  {
    char v22 = 0;
  }
  uint64_t v9 = llvm::Linker::linkInModule(&v17, &v16, a3, v21);
  if (v22 == v21)
  {
    (*(void (**)(void *))(v21[0] + 32))(v21);
  }
  else if (v22)
  {
    (*(void (**)(void *))(*v22 + 40))(v22);
  }
  int v10 = v16;
  int v16 = 0;
  if (v10)
  {
    llvm::Module::~Module(v10);
    MEMORY[0x1D25D9CE0](v11);
  }
  uint64_t v12 = v19;
  if (v20)
  {
    uint64_t v13 = 16 * v20;
    uint64_t v14 = (unsigned __int8 **)(v19 + 8);
    do
    {
      if (((unint64_t)*(v14 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000 && *v14) {
        llvm::MetadataTracking::untrack((uint64_t)v14, *v14);
      }
      v14 += 2;
      v13 -= 16;
    }
    while (v13);
    uint64_t v12 = v19;
  }
  MEMORY[0x1D25D9CD0](v12, 8);
  sub_1CC9159BC(v18);
  return v9;
}

void sub_1CD6A1B6C(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = 32 * a2;
    uint64_t v3 = (void *)(a1 + 16);
    do
    {
      if ((*(v3 - 2) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unint64_t v4 = (void *)*(v3 - 1);
        if (v4)
        {
          *uint64_t v3 = v4;
          operator delete(v4);
        }
      }
      v3 += 4;
      v2 -= 32;
    }
    while (v2);
  }
}

uint64_t sub_1CD6A1BCC(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      int v10 = 0;
      uint64_t result = sub_1CD40EE24((uint64_t *)v5, (void *)a2, &v10);
      uint64_t v9 = v10;
      *int v10 = *(void *)a2;
      *((_DWORD *)v9 + 2) = *(_DWORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

void llvm::createELFObjectWriter()
{
}

void llvm::createELFDwoObjectWriter()
{
}

void sub_1CD6A1DBC(unsigned int *a1)
{
  uint64_t v1 = a1[4];
  if (v1)
  {
    uint64_t v2 = 32 * v1;
    uint64_t v3 = (void *)(*(void *)a1 + 16);
    do
    {
      if ((*(v3 - 2) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unint64_t v4 = (void *)*(v3 - 1);
        if (v4)
        {
          *uint64_t v3 = v4;
          operator delete(v4);
        }
      }
      v3 += 4;
      v2 -= 32;
    }
    while (v2);
  }
}

void sub_1CD6A1E20(unsigned int *a1)
{
  unsigned int v2 = a1[2];
  if (!v2 && !a1[3]) {
    return;
  }
  uint64_t v3 = a1[4];
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_12:
      *((void *)a1 + 1) = 0;
      return;
    }
    unint64_t v4 = *(void **)a1;
    uint64_t v5 = 32 * v3;
    while (1)
    {
      if (*v4 == -8192) {
        goto LABEL_10;
      }
      if (*v4 != -4096) {
        break;
      }
LABEL_11:
      v4 += 4;
      v5 -= 32;
      if (!v5) {
        goto LABEL_12;
      }
    }
    uint64_t v6 = (void *)v4[1];
    if (v6)
    {
      _OWORD v4[2] = v6;
      operator delete(v6);
    }
LABEL_10:
    *unint64_t v4 = -4096;
    goto LABEL_11;
  }

  sub_1CD6A1EDC(a1);
}

void sub_1CD6A1EDC(unsigned int *a1)
{
  unsigned int v2 = a1[2];
  sub_1CD6A1DBC(a1);
  if (v2)
  {
    int v3 = 1 << (33 - __clz(v2 - 1));
    if (v3 <= 64) {
      unsigned int v4 = 64;
    }
    else {
      unsigned int v4 = v3;
    }
    if (v4 == a1[4])
    {
      *((void *)a1 + 1) = 0;
      uint64_t v5 = 32 * v4;
      uint64_t v6 = *(void **)a1;
      do
      {
        *uint64_t v6 = -4096;
        v6 += 4;
        v5 -= 32;
      }
      while (v5);
      return;
    }
  }
  else
  {
    if (!a1[4])
    {
      *((void *)a1 + 1) = 0;
      return;
    }
    unsigned int v4 = 0;
  }
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);

  sub_1CBC04C8C(a1, v4);
}

void *sub_1CD6A1F98(uint64_t *a1, void *a2)
{
  int v7 = 0;
  char v4 = sub_1CC48C528(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD57D368((uint64_t)a1, (uint64_t)a2, a2, v7);
    *uint64_t v5 = *a2;
    *((_DWORD *)v5 + 2) = 0;
  }
  return v5;
}

uint64_t llvm::MCAsmBackend::MCAsmBackend(uint64_t result, int a2)
{
  *(void *)uint64_t result = &unk_1F262D5C8;
  *(_DWORD *)(result + 8) = a2;
  return result;
}

uint64_t llvm::MCAsmBackend::createObjectWriter(llvm::MCAsmBackend *this, llvm::raw_pwrite_stream *a2)
{
  (*(void (**)(uint64_t *__return_ptr))(*(void *)this + 56))(&v3);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
  if (result == 5)
  {
    uint64_t v3 = 0;
    llvm::createMachObjectWriter();
  }
  switch((int)result)
  {
    case 2:
    case 4:
    case 5:
    case 8:
      __break(1u);
      return result;
    case 3:
      uint64_t v3 = 0;
      llvm::createELFObjectWriter();
    case 6:
      uint64_t v3 = 0;
      llvm::createSPIRVObjectWriter();
    case 7:
      uint64_t v3 = 0;
      llvm::createWasmObjectWriter();
    case 9:
      uint64_t v3 = 0;
      llvm::createXCOFFObjectWriter();
    default:
      uint64_t v3 = 0;
      llvm::createWinCOFFObjectWriter();
  }
}

void llvm::MCAsmBackend::createDwoObjectWriter(llvm::MCAsmBackend *this, llvm::raw_pwrite_stream *a2, llvm::raw_pwrite_stream *a3)
{
  (*(void (**)(uint64_t *__return_ptr))(*(void *)this + 56))(&v4);
  int v3 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
  if (v3 != 7)
  {
    if (v3 == 3)
    {
      uint64_t v4 = 0;
      llvm::createELFDwoObjectWriter();
    }
    llvm::report_fatal_error((llvm *)"dwo only supported with ELF and Wasm", (const llvm::Twine *)1);
  }
  uint64_t v4 = 0;
  llvm::createWasmDwoObjectWriter();
}

uint64_t llvm::MCAsmBackend::getFixupKind()
{
  return 0;
}

uint64_t sub_1CD6A23C8()
{
  return 0;
}

uint64_t sub_1CD6A23D4()
{
  return 1;
}

uint64_t llvm::MCAsmInfo::MCAsmInfo(uint64_t this)
{
  *(void *)this = &unk_1F262D6C0;
  *(void *)(this + 8) = 0x400000004;
  *(unsigned char *)(this + 16) = 1;
  *(_DWORD *)(this + 17) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(void *)(this + 24) = 0x100000004;
  *(_WORD *)(this + 32) = 256;
  *(unsigned char *)(this + 34) = 0;
  *(_WORD *)(this + 64) = 256;
  *(unsigned char *)(this + 66) = 1;
  *(_WORD *)(this + 80) = 0;
  *(unsigned char *)(this + 82) = 0;
  *(unsigned char *)(this + 184) = 0;
  *(_DWORD *)(this + 185) = 16777217;
  *(unsigned char *)(this + 200) = 1;
  *(void *)(this + 224) = 0;
  *(void *)(this + 232) = 0;
  *(_DWORD *)(this + 240) = 0;
  *(unsigned char *)(this + 280) = 1;
  *(_OWORD *)(this + 288) = 0u;
  *(_OWORD *)(this + 304) = 0u;
  *(_OWORD *)(this + 320) = 0u;
  *(_DWORD *)(this + 335) = 0;
  *(unsigned char *)(this + 339) = 1;
  *(_DWORD *)(this + 340) = 0;
  *(_WORD *)(this + 352) = 256;
  *(unsigned char *)(this + 354) = 1;
  *(_DWORD *)(this + 356) = 0;
  *(_DWORD *)(this + 360) = 16842753;
  *(unsigned char *)(this + 364) = 1;
  *(_DWORD *)(this + 365) = 0;
  *(void *)(this + 384) = 0;
  *(_DWORD *)(this + 391) = 0;
  *(_DWORD *)(this + 396) = 12;
  *(void *)(this + 400) = 0x150000000CLL;
  *(_WORD *)(this + 408) = 0;
  *(_DWORD *)(this + 412) = 0;
  *(unsigned char *)(this + 416) = 0;
  *(_DWORD *)(this + 420) = 0;
  *(void *)(this + 424) = 0x101000001010001;
  *(void *)(this + 432) = 0;
  *(void *)(this + 440) = 0;
  *(void *)(this + 448) = 0;
  *(void *)(this + 456) = 0x1A00000002;
  *(_DWORD *)(this + 468) = 0;
  *(_DWORD *)(this + 472) = 257;
  *(unsigned char *)(this + 476) = 0;
  *(void *)(this + 40) = ";";
  *(void *)(this + 48) = "#";
  *(void *)(this + 56) = 1;
  *(void *)(this + 72) = ":";
  *(void *)(this + 88) = "L";
  *(void *)(this + 96) = 1;
  *(_OWORD *)(this + 104) = *(_OWORD *)(this + 88);
  *(void *)(this + 120) = "";
  *(void *)(this + 128) = 0;
  *(void *)(this + 136) = "APP";
  *(void *)(this + 144) = "NO_APP";
  *(void *)(this + 152) = ".code16";
  *(void *)(this + 160) = ".code32";
  *(void *)(this + 168) = ".code64";
  *(void *)(this + 176) = 0;
  *(void *)(this + 192) = "\t.zero\t";
  *(void *)(this + 208) = "\t.ascii\t";
  *(void *)(this + 216) = "\t.asciz\t";
  *(void *)(this + 248) = "\t.byte\t";
  *(void *)(this + 256) = "\t.short\t";
  *(void *)(this + 264) = "\t.long\t";
  *(void *)(this + 272) = "\t.quad\t";
  *(void *)(this + 344) = "\t.globl\t";
  *(void *)(this + 376) = "\t.weak\t";
  if (dword_1EBCEE470) {
    *(unsigned char *)(this + 431) = dword_1EBCEE470 == 1;
  }
  if (dword_1EBD0A290) {
    *(unsigned char *)(this + 188) = dword_1EBD0A290 == 1;
  }
  *(_WORD *)(this + 464) = 1;
  *(unsigned char *)(this + 466) = 1;
  return this;
}

void llvm::MCAsmInfo::~MCAsmInfo(llvm::MCAsmInfo *this)
{
  *(void *)this = &unk_1F262D6C0;
  uint64_t v1 = (void **)((char *)this + 432);
  sub_1CC34C338(&v1);
}

{
  void **v1;

  *(void *)this = &unk_1F262D6C0;
  uint64_t v1 = (void **)((char *)this + 432);
  sub_1CC34C338(&v1);
}

{
  void **v2;

  *(void *)this = &unk_1F262D6C0;
  unsigned int v2 = (void **)((char *)this + 432);
  sub_1CC34C338(&v2);
  MEMORY[0x1D25D9CE0](this, 0x10F1C40308258B8);
}

uint64_t llvm::MCAsmInfo::isSectionAtomizableBySymbols(llvm::MCAsmInfo *this, const llvm::MCSection *a2)
{
  return 0;
}

uint64_t llvm::MCAsmInfo::getExprForPersonalitySymbol(llvm::MCAsmInfo *this, const llvm::MCSymbol *a2, uint64_t a3, llvm::MCStreamer *a4)
{
  return (*(uint64_t (**)(llvm::MCAsmInfo *, const llvm::MCSymbol *, uint64_t, llvm::MCStreamer *))(*(void *)this + 40))(this, a2, a3, a4);
}

uint64_t llvm::MCAsmInfo::isAcceptableChar(llvm::MCAsmInfo *this, int a2)
{
  if (a2 == 64) {
    return *((unsigned char *)this + 180) != 0;
  }
  unint64_t v3 = (0x800000000000401uLL >> (a2 - 36)) & 1;
  if ((a2 - 36) > 0x3B) {
    LODWORD(v3) = 0;
  }
  if (((a2 & 0xDF) - 65) >= 0x1Au) {
    unsigned int v4 = v3;
  }
  else {
    unsigned int v4 = 1;
  }
  if ((a2 - 48) >= 0xA) {
    return v4;
  }
  else {
    return 1;
  }
}

uint64_t llvm::MCAsmInfo::isValidUnquotedName(uint64_t a1, char *a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t v5 = a3 - 1;
  do
  {
    unsigned int v6 = *a2++;
    uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 48))(a1, v6);
    if (result) {
      BOOL v8 = v5 == 0;
    }
    else {
      BOOL v8 = 1;
    }
    --v5;
  }
  while (!v8);
  return result;
}

uint64_t llvm::MCAsmInfo::shouldOmitSectionDirective(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 == 4)
  {
    if (*(_DWORD *)a2 == 1936941614) {
      return *(unsigned char *)(a1 + 337) == 0;
    }
    return 0;
  }
  if (a3 != 5) {
    return 0;
  }
  if (*(_DWORD *)a2 == 2019914798 && *(unsigned char *)(a2 + 4) == 116) {
    return 1;
  }
  return *(_DWORD *)a2 == 1952539694 && *(unsigned char *)(a2 + 4) == 97;
}

void sub_1CD6A28C0(_WORD *a1, __n128 *a2, int **a3)
{
  sub_1CB883A14((uint64_t)&llvm::UseLEB128Directives, 0, 0);
  dword_1EBD0A290 = 0;
  qword_1EBD0A298 = (uint64_t)&unk_1F2643C00;
  *(void *)&dword_1EBD0A2A0 = 0;
  llvm::UseLEB128Directives = (uint64_t)&unk_1F2609740;
  qword_1EBD0A2A8 = (uint64_t)&unk_1F2643CF0;
  qword_1EBD0A2B0 = (uint64_t)&unk_1F26097A8;
  qword_1EBD0A2C8 = (uint64_t)&qword_1EBD0A2B0;
  sub_1CD6A29B0(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&llvm::UseLEB128Directives);
}

__n128 sub_1CD6A29B0(_WORD *a1, __n128 *a2, int **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&llvm::UseLEB128Directives, "use-leb128-directives", 0x15uLL);
  word_1EBD0A21A = (32 * (*a1 & 3)) | word_1EBD0A21A & 0xFF9F;
  __n128 result = *a2;
  xmmword_1EBD0A230 = (__int128)*a2;
  int v7 = *a3;
  dword_1EBD0A290 = **a3;
  byte_1EBD0A2A4 = 1;
  dword_1EBD0A2A0 = *v7;
  return result;
}

uint64_t llvm::MCAsmInfoDarwin::MCAsmInfoDarwin(llvm::MCAsmInfoDarwin *this)
{
  uint64_t result = llvm::MCAsmInfo::MCAsmInfo((uint64_t)this);
  *(void *)uint64_t result = &unk_1F262D9F8;
  *(void *)(result + 120) = "l";
  *(void *)(result + 128) = 1;
  *(unsigned char *)(result + 18) = 1;
  *(unsigned char *)(result + 339) = 0;
  *(_DWORD *)(result + 356) = 2;
  *(void *)(result + 136) = " InlineAsm Start";
  *(void *)(result + 144) = " InlineAsm End";
  *(_WORD *)(result + 392) = 257;
  *(void *)(result + 384) = "\t.weak_reference ";
  *(void *)(result + 192) = "\t.space\t";
  *(_WORD *)(result + 19) = 257;
  *(_WORD *)(result + 353) = 0;
  *(_DWORD *)(result + 396) = 20;
  *(void *)(result + 400) = 0;
  *(_WORD *)(result + 363) = 0;
  *(_WORD *)(result + 367) = 257;
  *(unsigned char *)(result + 424) = 0;
  *(unsigned char *)(result + 352) = 1;
  return result;
}

void sub_1CD6A2AF4(llvm::MCAsmInfo *a1)
{
  llvm::MCAsmInfo::~MCAsmInfo(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::createAsmStreamer()
{
}

double llvm::MCAssembler::MCAssembler(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  *(void *)a1 = a2;
  uint64_t v5 = *a3;
  *a3 = 0;
  *(void *)(a1 + 8) = v5;
  uint64_t v6 = *a4;
  *a4 = 0;
  *(void *)(a1 + 16) = v6;
  uint64_t v7 = *a5;
  *a5 = 0;
  *(void *)(a1 + 24) = v7;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(void *)(a1 + 192) = 0;
  *(_WORD *)(a1 + 200) = -1267;
  *(unsigned char *)(a1 + 202) = 14;
  *(void *)(a1 + 208) = a1 + 240;
  *(void *)(a1 + 216) = a1 + 240;
  *(void *)(a1 + 224) = 32;
  *(_DWORD *)(a1 + 232) = 0;
  *(_DWORD *)(a1 + 496) = 0;
  *(unsigned char *)(a1 + 500) &= 0xF8u;
  *(_DWORD *)(a1 + 504) = 0;
  *(void *)(a1 + 512) = 0;
  *(void *)(a1 + 520) = a1 + 536;
  *(void *)(a1 + 528) = 0x2000000000;
  *(_OWORD *)(a1 + 2092) = 0u;
  *(_DWORD *)(a1 + 2080) = 0;
  *(_DWORD *)(a1 + 2116) = 0;
  *(void *)(a1 + 2136) = 0;
  *(void *)(a1 + 2128) = 0;
  *(unsigned char *)(a1 + 2152) = 0;
  *(void *)(a1 + 2144) = 0;
  *(_OWORD *)(a1 + 2192) = 0u;
  *(_OWORD *)(a1 + 2176) = 0u;
  *(_OWORD *)(a1 + 2160) = 0u;
  return result;
}

void llvm::MCAssembler::~MCAssembler(llvm::MCAssembler *this)
{
  unsigned int v2 = (void *)*((void *)this + 273);
  if (v2)
  {
    *((void *)this + 274) = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)*((void *)this + 270);
  if (v3)
  {
    *((void *)this + 271) = v3;
    operator delete(v3);
  }
  sub_1CD6A33FC((void **)this + 65);
  unsigned int v4 = (void *)*((void *)this + 27);
  if (v4 != *((void **)this + 26)) {
    free(v4);
  }
  uint64_t v12 = (void **)((char *)this + 176);
  sub_1CC658304(&v12);
  uint64_t v12 = (void **)((char *)this + 152);
  sub_1CB8338B8(&v12);
  uint64_t v12 = (void **)((char *)this + 128);
  sub_1CCBB4288(&v12);
  uint64_t v5 = (void *)*((void *)this + 13);
  if (v5)
  {
    *((void *)this + 14) = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)*((void *)this + 10);
  if (v6)
  {
    *((void *)this + 11) = v6;
    operator delete(v6);
  }
  uint64_t v7 = (void *)*((void *)this + 7);
  if (v7)
  {
    *((void *)this + 8) = v7;
    operator delete(v7);
  }
  BOOL v8 = (void *)*((void *)this + 4);
  if (v8)
  {
    *((void *)this + 5) = v8;
    operator delete(v8);
  }
  uint64_t v9 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t v11 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
}

uint64_t sub_1CD6A3028(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(unsigned int *)(a2 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    if (v5 >= v4)
    {
      if (v4) {
        memmove(*(void **)a1, *(const void **)a2, 24 * v4);
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 12) < v4)
      {
        *(_DWORD *)(a1 + 8) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v5) {
        memmove(*(void **)a1, *(const void **)a2, 24 * v5);
      }
      else {
        uint64_t v5 = 0;
      }
      uint64_t v6 = *(unsigned int *)(a2 + 8);
      if (v5 != v6) {
        memcpy((void *)(*(void *)a1 + 24 * v5), (const void *)(*(void *)a2 + 24 * v5), *(void *)a2 + 24 * v6 - (*(void *)a2 + 24 * v5));
      }
    }
    *(_DWORD *)(a1 + 8) = v4;
  }
  return a1;
}

BOOL llvm::MCAssembler::relaxLEB(int a1, uint64_t **a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 + 72);
  uint64_t v16 = 0;
  if ((llvm::MCExpr::evaluateKnownAbsolute(*(llvm::MCExpr **)(a3 + 56), &v16, a2) & 1) == 0) {
    llvm::report_fatal_error((llvm *)"sleb128 and uleb128 expressions must be absolute", (const llvm::Twine *)1);
  }
  *(void *)(a3 + 72) = 0;
  int v8 = 0;
  char v12 = 0;
  uint64_t v13 = 0;
  uint64_t v15 = a3 + 64;
  int v14 = 0;
  uint64_t v7 = &unk_1F2646FA8;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  if (*(unsigned char *)(a3 + 51)) {
    sub_1CCBB3A20((llvm::raw_ostream *)v16, (llvm::raw_ostream *)&v7, v4);
  }
  else {
    sub_1CC659844(v16, (llvm::raw_ostream *)&v7, v4);
  }
  BOOL v5 = v4 != *(void *)(a3 + 72);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v7);
  return v5;
}

BOOL llvm::MCAssembler::relaxPseudoProbeAddr(int a1, uint64_t **a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a3 + 72);
  uint64_t v16 = 0;
  llvm::MCExpr::evaluateKnownAbsolute(*(llvm::MCExpr **)(a3 + 136), &v16, a2);
  *(void *)(a3 + 72) = 0;
  int v8 = 0;
  char v12 = 0;
  uint64_t v13 = 0;
  uint64_t v15 = a3 + 64;
  int v14 = 0;
  uint64_t v7 = &unk_1F2646FA8;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  *(_DWORD *)(a3 + 104) = 0;
  sub_1CCBB3A20((llvm::raw_ostream *)v16, (llvm::raw_ostream *)&v7, v4);
  BOOL v5 = v4 != *(void *)(a3 + 72);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v7);
  return v5;
}

llvm::raw_ostream *llvm::MCAssembler::dump(llvm::MCAssembler *this)
{
  unsigned int v2 = (llvm::raw_ostream *)llvm::errs(this);
  sub_1CB8E509C(v2, "<MCAssembler\n");
  sub_1CB8E509C(v2, "  Sections:[\n    ");
  unint64_t v3 = (llvm::MCFragment ***)*((void *)this + 4);
  uint64_t v4 = (llvm::MCFragment ***)*((void *)this + 5);
  while (v3 != v4)
  {
    if (v3 != *((llvm::MCFragment ****)this + 4)) {
      sub_1CB8E509C(v2, ",\n    ");
    }
    BOOL v5 = *v3++;
    llvm::MCSection::dump(v5);
  }
  sub_1CB8E509C(v2, "],\n");
  sub_1CB8E509C(v2, "  Symbols:[");
  uint64_t v6 = (llvm::MCSymbol **)*((void *)this + 7);
  uint64_t v7 = (llvm::MCSymbol **)*((void *)this + 8);
  while (v6 != v7)
  {
    if (v6 != *((llvm::MCSymbol ***)this + 7)) {
      sub_1CB8E509C(v2, ",\n           ");
    }
    sub_1CB8E509C(v2, "(");
    llvm::MCSymbol::dump(*v6);
    int v8 = sub_1CB8E509C(v2, ", Index:");
    uint64_t v9 = *v6++;
    uint64_t v10 = llvm::raw_ostream::operator<<(v8, *((unsigned int *)v9 + 4));
    sub_1CB8E509C(v10, ", ");
    sub_1CB8E509C(v2, ")");
  }

  return sub_1CB8E509C(v2, "]>\n");
}

void **sub_1CD6A33FC(void **result)
{
  uint64_t v1 = (void **)*result;
  uint64_t v2 = *((unsigned int *)result + 2);
  if (v2)
  {
    uint64_t v6 = (char *)*result;
    uint64_t v7 = result;
    uint64_t v3 = 48 * v2;
    do
    {
      uint64_t v4 = *(char **)&v6[v3 - 40];
      if (&v6[v3 - 24] != v4) {
        free(v4);
      }
      v3 -= 48;
    }
    while (v3);
    double result = v7;
    uint64_t v1 = (void **)*v7;
  }
  if (v1 != result + 2)
  {
    BOOL v5 = result;
    free(v1);
    return v5;
  }
  return result;
}

void *llvm::MCCodeEmitter::MCCodeEmitter(void *this)
{
  *this = &unk_1F262E190;
  return this;
}

void llvm::CodeViewContext::~CodeViewContext(llvm::CodeViewContext *this)
{
  if (!*((unsigned char *)this + 40))
  {
    uint64_t v2 = (void *)*((void *)this + 4);
    if (v2)
    {
      uint64_t v3 = (void *)v2[15];
      if (v3 != v2 + 17) {
        free(v3);
      }
      uint64_t v4 = (void *)v2[8];
      if (v4 != v2 + 11) {
        free(v4);
      }
      MEMORY[0x1D25D9CE0](v2, 0x10E0C400AE5E4C8);
    }
  }
  if (*((void *)this + 30))
  {
    sub_1CCBB5624((void *)this + 30);
    operator delete(*((void **)this + 30));
  }
  BOOL v5 = (void *)*((void *)this + 27);
  if (v5)
  {
    *((void *)this + 28) = v5;
    operator delete(v5);
  }
  sub_1CD40B1BC(*((void **)this + 25));
  uint64_t v6 = (char *)*((void *)this + 6);
  if (v6 != (char *)this + 64) {
    free(v6);
  }

  sub_1CC3724DC((uint64_t)this);
}

BOOL llvm::CodeViewContext::isValidFileNumber(llvm::CodeViewContext *this, int a2)
{
  uint64_t v2 = (a2 - 1);
  return *((_DWORD *)this + 14) > v2 && *(unsigned char *)(*((void *)this + 6) + 32 * v2 + 4) != 0;
}

BOOL llvm::CodeViewContext::addFile(uint64_t a1, uint64_t a2, unsigned int a3, unsigned __int8 *a4, size_t a5, uint64_t a6, uint64_t a7, char a8)
{
  llvm::CodeViewContext::addToStringTable((llvm::CodeViewContext *)a1, a4, a5, (uint64_t)v29);
  int v14 = (unsigned __int8 *)v29[0];
  size_t v15 = v29[1];
  uint64_t v16 = a3 - 1;
  if (*(_DWORD *)(a1 + 56) <= v16) {
    sub_1CD6A5038(a1 + 48, a3);
  }
  uint64_t v17 = *(void *)(a1 + 48) + 32 * v16;
  int v18 = *(unsigned __int8 *)(v17 + 4);
  if (!*(unsigned char *)(v17 + 4))
  {
    if (v15) {
      size_t v20 = v15;
    }
    else {
      size_t v20 = 7;
    }
    if (v15) {
      uint64_t v21 = v14;
    }
    else {
      uint64_t v21 = "<stdin>";
    }
    llvm::CodeViewContext::addToStringTable((llvm::CodeViewContext *)a1, v21, v20, (uint64_t)v26);
    int v22 = v27;
    uint64_t v23 = *(llvm::MCContext **)(a2 + 8);
    v26[0] = "checksum_offset";
    __int16 v28 = 259;
    uint64_t TempSymbol = llvm::MCContext::createTempSymbol(v23, (const llvm::Twine *)v26, 0);
    uint64_t v25 = *(void *)(a1 + 48) + 32 * v16;
    *(_DWORD *)uint64_t v25 = v22;
    *(void *)(v25 + 16) = a7;
    *(void *)(v25 + 24) = TempSymbol;
    *(unsigned char *)(v25 + 4) = 1;
    *(void *)(v25 + 8) = a6;
    *(unsigned char *)(*(void *)(a1 + 48) + 32 * v16 + 5) = a8;
  }
  return v18 == 0;
}

uint64_t **llvm::CodeViewContext::addToStringTable@<X0>(llvm::CodeViewContext *a1@<X0>, unsigned __int8 *a2@<X1>, size_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t StringTableFragment = llvm::CodeViewContext::getStringTableFragment(a1);
  int v15 = *(void *)(StringTableFragment + 72);
  double result = (uint64_t **)sub_1CC60E44C(a1, a2, a3, &v15);
  char v11 = v10;
  char v12 = *result;
  uint64_t v13 = *result + 2;
  uint64_t v14 = **result;
  *(void *)a4 = v13;
  *(void *)(a4 + 8) = v14;
  *(_DWORD *)(a4 + 16) = *((_DWORD *)v12 + 2);
  if (v11) {
    return (uint64_t **)sub_1CC22C75C((void *)(StringTableFragment + 64), v13, &v13[v14 + 1]);
  }
  return result;
}

_DWORD *llvm::CodeViewContext::getCVFunctionInfo(llvm::CodeViewContext *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 30);
  if (0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 31) - v2) >> 4) <= a2) {
    return 0;
  }
  uint64_t v3 = (_DWORD *)(v2 + 48 * a2);
  if (*v3) {
    return v3;
  }
  else {
    return 0;
  }
}

BOOL llvm::CodeViewContext::recordFunctionId(llvm::CodeViewContext *this, unsigned int a2)
{
  uint64_t v3 = *((void *)this + 30);
  uint64_t v4 = (uint64_t *)((char *)this + 240);
  if (0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 31) - v3) >> 4) <= a2)
  {
    sub_1CD6A3888((uint64_t *)this + 30, a2 + 1);
    uint64_t v3 = *v4;
  }
  BOOL v5 = (int *)(v3 + 48 * a2);
  int v6 = *v5;
  if (!*v5) {
    *BOOL v5 = -1;
  }
  return v6 == 0;
}

void sub_1CD6A3888(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 4);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1CD6A50B4(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 48 * a2;
    if (v3 != v7)
    {
      do
      {
        uint64_t v8 = v3 - 48;
        MEMORY[0x1D25D9CD0](*(void *)(v3 - 24), 4);
        uint64_t v3 = v8;
      }
      while (v8 != v7);
    }
    a1[1] = v7;
  }
}

BOOL llvm::CodeViewContext::recordInlinedCallSiteId(llvm::CodeViewContext *this, unsigned int a2, unsigned int a3, int a4, int a5, int a6)
{
  unsigned int v24 = a2;
  uint64_t v12 = *((void *)this + 30);
  uint64_t v13 = (uint64_t *)((char *)this + 240);
  if (0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 31) - v12) >> 4) <= a2)
  {
    sub_1CD6A3888((uint64_t *)this + 30, a2 + 1);
    uint64_t v12 = *v13;
  }
  uint64_t v14 = (_DWORD *)(v12 + 48 * a2);
  int v15 = *v14;
  if (!*v14)
  {
    *uint64_t v14 = a3 + 1;
    uint64_t v17 = (_DWORD *)(v12 + 48 * a2);
    v17[1] = a4;
    v17[2] = a5;
    v17[3] = a6;
    if (a3 <= 0xFFFFFFFD)
    {
      do
      {
        uint64_t v18 = *((void *)this + 30);
        if (0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 31) - v18) >> 4) <= a3)
        {
          size_t v20 = 0;
        }
        else
        {
          uint64_t v19 = (_DWORD *)(v18 + 48 * a3);
          if (*v19) {
            size_t v20 = v19;
          }
          else {
            size_t v20 = 0;
          }
        }
        uint64_t v21 = *(void *)(v14 + 1);
        int v22 = v14[3];
        uint64_t v23 = sub_1CD6A5314((uint64_t)(v20 + 6), &v24);
        *(void *)(v23 + 1) = v21;
        v23[3] = v22;
        a3 = *v20 - 1;
        uint64_t v14 = v20;
      }
      while (a3 < 0xFFFFFFFE);
    }
  }
  return v15 == 0;
}

char *llvm::CodeViewContext::recordCVLoc(llvm::CodeViewContext *this, llvm::MCContext *a2, const llvm::MCSymbol *a3, int a4, int a5, int a6, __int16 a7, char a8, BOOL a9)
{
  char v11 = a3;
  int v12 = a4;
  int v13 = a5;
  int v14 = a6;
  __int16 v15 = a7;
  if (a9) {
    char v9 = 2;
  }
  else {
    char v9 = 0;
  }
  char v16 = v9 | a8;
  return llvm::CodeViewContext::addLineEntry((uint64_t)this, (uint64_t)&v11);
}

char *llvm::CodeViewContext::addLineEntry(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = (void **)(a1 + 216);
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 224) - *(void *)(a1 + 216)) >> 3);
  unsigned int v12 = *(_DWORD *)(a2 + 8);
  unint64_t v6 = (uint64_t *)(v5 + 1);
  unint64_t v13 = v5;
  unint64_t v14 = v5 + 1;
  uint64_t v7 = sub_1CD6A562C((uint64_t **)(a1 + 192), v12, (uint64_t)&v12);
  if (!v8) {
    v7[6] = v6;
  }
  unint64_t v9 = *(void *)(a1 + 224);
  if (v9 >= *(void *)(a1 + 232))
  {
    double result = sub_1CCBB5760(v4, a2);
  }
  else
  {
    long long v10 = *(_OWORD *)a2;
    *(void *)(v9 + 16) = *(void *)(a2 + 16);
    *(_OWORD *)unint64_t v9 = v10;
    double result = (char *)(v9 + 24);
  }
  *(void *)(a1 + 224) = result;
  return result;
}

uint64_t llvm::CodeViewContext::getStringTableFragment(llvm::CodeViewContext *this)
{
  uint64_t result = *((void *)this + 4);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t llvm::CodeViewContext::emitStringTable(llvm::CodeViewContext *this, llvm::MCObjectStreamer *a2)
{
  unint64_t v4 = (llvm::MCContext *)*((void *)a2 + 1);
  v13[0] = "strtab_begin";
  __int16 v14 = 259;
  uint64_t TempSymbol = llvm::MCContext::createTempSymbol(v4, (const llvm::Twine *)v13, 0);
  v13[0] = "strtab_end";
  __int16 v14 = 259;
  uint64_t v6 = llvm::MCContext::createTempSymbol(v4, (const llvm::Twine *)v13, 0);
  (*(void (**)(llvm::MCObjectStreamer *, uint64_t, uint64_t))(*(void *)a2 + 520))(a2, 243, 4);
  (*(void (**)(llvm::MCObjectStreamer *, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 840))(a2, v6, TempSymbol, 4);
  (*(void (**)(llvm::MCObjectStreamer *, uint64_t, void))(*(void *)a2 + 192))(a2, TempSymbol, 0);
  if (!*((unsigned char *)this + 40))
  {
    uint64_t StringTableFragment = (uint64_t *)llvm::CodeViewContext::getStringTableFragment(this);
    llvm::MCObjectStreamer::flushPendingLabels(a2, (unint64_t)StringTableFragment, 0);
    uint64_t v9 = *((unsigned int *)a2 + 30);
    if (v9) {
      uint64_t v10 = *(void *)(*((void *)a2 + 14) + 32 * v9 - 32);
    }
    else {
      uint64_t v10 = 0;
    }
    char v11 = (uint64_t *)*((void *)a2 + 35);
    uint64_t v12 = *v11;
    *uint64_t StringTableFragment = *v11;
    StringTableFragment[1] = (uint64_t)v11;
    *(void *)(v12 + 8) = StringTableFragment;
    *char v11 = (uint64_t)StringTableFragment;
    StringTableFragment[2] = v10;
    *((unsigned char *)this + 40) = 1;
  }
  (*(void (**)(llvm::MCObjectStreamer *, uint64_t, void, uint64_t, void))(*(void *)a2 + 640))(a2, 4, 0, 1, 0);
  return (*(uint64_t (**)(llvm::MCObjectStreamer *, uint64_t, void))(*(void *)a2 + 192))(a2, v6, 0);
}

uint64_t llvm::CodeViewContext::emitFileChecksums(uint64_t this, llvm::MCObjectStreamer *a2)
{
  if (*(_DWORD *)(this + 56))
  {
    uint64_t v3 = this;
    unint64_t v4 = (llvm::MCContext *)*((void *)a2 + 1);
    v19[0] = "filechecksums_begin";
    __int16 v20 = 259;
    uint64_t TempSymbol = llvm::MCContext::createTempSymbol(v4, (const llvm::Twine *)v19, 0);
    v19[0] = "filechecksums_end";
    __int16 v20 = 259;
    uint64_t v6 = llvm::MCContext::createTempSymbol(v4, (const llvm::Twine *)v19, 0);
    (*(void (**)(llvm::MCObjectStreamer *, uint64_t, uint64_t))(*(void *)a2 + 520))(a2, 244, 4);
    uint64_t v17 = v6;
    (*(void (**)(llvm::MCObjectStreamer *, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 840))(a2, v6, TempSymbol, 4);
    (*(void (**)(llvm::MCObjectStreamer *, uint64_t, void))(*(void *)a2 + 192))(a2, TempSymbol, 0);
    uint64_t v18 = v3;
    uint64_t v7 = *(unsigned int *)(v3 + 56);
    if (v7)
    {
      unsigned int v8 = 0;
      uint64_t v9 = *(unsigned int **)(v18 + 48);
      uint64_t v10 = &v9[8 * v7];
      do
      {
        uint64_t v11 = *v9;
        uint64_t v12 = *((unsigned __int8 *)v9 + 5);
        uint64_t v13 = *((void *)v9 + 1);
        uint64_t v14 = *((void *)v9 + 2);
        uint64_t v15 = *((void *)v9 + 3);
        unint64_t v16 = llvm::MCConstantExpr::create((llvm::MCConstantExpr *)v8, (uint64_t)v4, 0, 0);
        (*(void (**)(llvm::MCObjectStreamer *, uint64_t, unint64_t))(*(void *)a2 + 280))(a2, v15, v16);
        if (v12) {
          unsigned int v8 = (v8 + v14 + 9) & 0xFFFFFFFC;
        }
        else {
          v8 += 8;
        }
        (*(void (**)(llvm::MCObjectStreamer *, uint64_t, uint64_t))(*(void *)a2 + 520))(a2, v11, 4);
        if (v12)
        {
          (*(void (**)(llvm::MCObjectStreamer *, void, uint64_t))(*(void *)a2 + 520))(a2, v14, 1);
          (*(void (**)(llvm::MCObjectStreamer *, uint64_t, uint64_t))(*(void *)a2 + 520))(a2, v12, 1);
          (*(void (**)(llvm::MCObjectStreamer *, uint64_t, uint64_t))(*(void *)a2 + 488))(a2, v13, v14);
          (*(void (**)(llvm::MCObjectStreamer *, uint64_t, void, uint64_t, void))(*(void *)a2 + 640))(a2, 4, 0, 1, 0);
        }
        else
        {
          (*(void (**)(llvm::MCObjectStreamer *, void, uint64_t))(*(void *)a2 + 520))(a2, 0, 4);
        }
        v9 += 8;
      }
      while (v9 != v10);
    }
    this = (*(uint64_t (**)(llvm::MCObjectStreamer *, uint64_t, void))(*(void *)a2 + 192))(a2, v17, 0);
    *(unsigned char *)(v18 + 264) = 1;
  }
  return this;
}

uint64_t llvm::CodeViewContext::emitFileChecksumOffset(llvm::CodeViewContext *this, llvm::MCObjectStreamer *a2, unsigned int a3)
{
  uint64_t v5 = a3 - 1;
  if (*((_DWORD *)this + 14) <= v5) {
    sub_1CD6A5038((uint64_t)this + 48, a3);
  }
  uint64_t v6 = *((void *)this + 6) + 32 * v5;
  uint64_t v7 = *(const llvm::MCSymbol **)(v6 + 24);
  if (*((unsigned char *)this + 264))
  {
    return llvm::MCStreamer::emitSymbolValue(a2, v7, 4, 0);
  }
  else
  {
    unint64_t v9 = llvm::MCSymbolRefExpr::create(*(void *)(v6 + 24), 0, *((void *)a2 + 1), 0);
    uint64_t v10 = *(uint64_t (**)(llvm::MCObjectStreamer *, unint64_t, uint64_t, void))(*(void *)a2 + 512);
    return v10(a2, v9, 4, 0);
  }
}

void llvm::CodeViewContext::emitLineTableForFunction(llvm::CodeViewContext *this, llvm::MCObjectStreamer *a2, unsigned int a3, const llvm::MCSymbol *a4, const llvm::MCSymbol *a5)
{
  uint64_t v10 = (llvm::MCContext *)*((void *)a2 + 1);
  v36[0] = "linetable_begin";
  __int16 v37 = 259;
  uint64_t TempSymbol = llvm::MCContext::createTempSymbol(v10, (const llvm::Twine *)v36, 0);
  v36[0] = "linetable_end";
  __int16 v37 = 259;
  uint64_t v12 = llvm::MCContext::createTempSymbol(v10, (const llvm::Twine *)v36, 0);
  (*(void (**)(llvm::MCObjectStreamer *, uint64_t, uint64_t))(*(void *)a2 + 520))(a2, 242, 4);
  uint64_t v25 = v12;
  (*(void (**)(llvm::MCObjectStreamer *, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 840))(a2, v12, TempSymbol, 4);
  (*(void (**)(llvm::MCObjectStreamer *, uint64_t, void))(*(void *)a2 + 192))(a2, TempSymbol, 0);
  (*(void (**)(llvm::MCObjectStreamer *, const llvm::MCSymbol *, void))(*(void *)a2 + 376))(a2, a4, 0);
  (*(void (**)(llvm::MCObjectStreamer *, const llvm::MCSymbol *))(*(void *)a2 + 368))(a2, a4);
  char v26 = this;
  llvm::CodeViewContext::getFunctionLineEntries(this, a3, &v34);
  uint64_t v13 = v34;
  uint64_t v14 = v35;
  if (v34 == v35)
  {
    BOOL v16 = 0;
  }
  else
  {
    uint64_t v15 = v34 + 24;
    do
    {
      BOOL v16 = *((_WORD *)v15 - 2) != 0;
      if (*((_WORD *)v15 - 2)) {
        BOOL v17 = 1;
      }
      else {
        BOOL v17 = v15 == v35;
      }
      v15 += 24;
    }
    while (!v17);
  }
  (*(void (**)(llvm::MCObjectStreamer *, BOOL, uint64_t))(*(void *)a2 + 520))(a2, v16, 2);
  (*(void (**)(llvm::MCObjectStreamer *, const llvm::MCSymbol *, const llvm::MCSymbol *, uint64_t))(*(void *)a2 + 840))(a2, a5, a4, 4);
  if (v13 != v14)
  {
    uint64_t v18 = v13;
    do
    {
      uint64_t v19 = v18;
      uint64_t v20 = *((unsigned int *)v18 + 3);
      while (*((_DWORD *)v18 + 3) == v20)
      {
        v18 += 24;
        if (v18 == v14)
        {
          uint64_t v18 = v14;
          break;
        }
      }
      uint64_t v31 = "Segment for file '";
      __int16 v32 = 259;
      char v21 = *(unsigned char *)(*(void *)(llvm::CodeViewContext::getStringTableFragment(v26) + 64)
                     + *(unsigned int *)(*((void *)v26 + 6) + 32 * (v20 - 1)));
      __int16 v30 = 263;
      LOBYTE(v29[0]) = v21;
      sub_1CB8F1E58((uint64_t *)&v31, v29, (uint64_t)v33);
      int v27 = "' begins";
      __int16 v28 = 259;
      sub_1CB8F1E58(v33, (uint64_t *)&v27, (uint64_t)v36);
      (*(void (**)(llvm::MCObjectStreamer *, void *, uint64_t))(*(void *)a2 + 112))(a2, v36, 1);
      (*(void (**)(llvm::MCObjectStreamer *, uint64_t))(*(void *)a2 + 824))(a2, v20);
      (*(void (**)(llvm::MCObjectStreamer *, void, uint64_t))(*(void *)a2 + 520))(a2, -1431655765 * ((v18 - v19) >> 3), 4);
      int v22 = -1431655764 * ((v18 - v19) >> 3);
      if (!v16) {
        int v22 = 0;
      }
      (*(void (**)(llvm::MCObjectStreamer *, void, uint64_t))(*(void *)a2 + 520))(a2, v22 + 1431655768 * ((v18 - v19) >> 3) + 12, 4);
      for (uint64_t i = v19; i != v18; i += 24)
      {
        (*(void (**)(llvm::MCObjectStreamer *, void, const llvm::MCSymbol *, uint64_t))(*(void *)a2 + 840))(a2, *(void *)i, a4, 4);
        (*(void (**)(llvm::MCObjectStreamer *, void, uint64_t))(*(void *)a2 + 520))(a2, *((_DWORD *)i + 4) | ((i[22] & 2) << 30), 4);
      }
      char v24 = !v16;
      if (v19 == v18) {
        char v24 = 1;
      }
      if ((v24 & 1) == 0)
      {
        do
        {
          (*(void (**)(llvm::MCObjectStreamer *, void, uint64_t))(*(void *)a2 + 520))(a2, *((unsigned __int16 *)v19 + 10), 2);
          (*(void (**)(llvm::MCObjectStreamer *, void, uint64_t))(*(void *)a2 + 520))(a2, 0, 2);
          v19 += 24;
        }
        while (v19 != v18);
      }
    }
    while (v18 != v14);
  }
  (*(void (**)(llvm::MCObjectStreamer *, uint64_t, void))(*(void *)a2 + 192))(a2, v25, 0);
  if (v13) {
    operator delete(v13);
  }
}

void llvm::CodeViewContext::emitInlineLineTableForFunction(llvm::CodeViewContext *this, llvm::MCObjectStreamer *a2, unsigned int a3, unsigned int a4, unsigned int a5, const llvm::MCSymbol *a6, const llvm::MCSymbol *a7)
{
}

void llvm::CodeViewContext::emitDefRange()
{
}

void *llvm::CodeViewContext::encodeInlineLineTable(void *result, uint64_t **a2, uint64_t a3)
{
  unsigned int v4 = *(_DWORD *)(a3 + 52);
  uint64_t v5 = result + 25;
  uint64_t v6 = result[25];
  if (!v6) {
    goto LABEL_12;
  }
  uint64_t v7 = result[25];
  unsigned int v8 = result + 25;
  do
  {
    unsigned int v9 = *(_DWORD *)(v7 + 32);
    BOOL v10 = v9 >= v4;
    if (v9 >= v4) {
      uint64_t v11 = (uint64_t *)v7;
    }
    else {
      uint64_t v11 = (uint64_t *)(v7 + 8);
    }
    if (v10) {
      unsigned int v8 = (void *)v7;
    }
    uint64_t v7 = *v11;
  }
  while (*v11);
  if (v8 != v5 && *((_DWORD *)v8 + 8) <= v4)
  {
    unint64_t v13 = v8[5];
    unint64_t v12 = v8[6];
  }
  else
  {
LABEL_12:
    unint64_t v12 = 0;
    unint64_t v13 = -1;
  }
  uint64_t v14 = (_DWORD *)(result[30] + 48 * v4);
  if (*v14) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t v16 = *((void *)v15 + 3);
  uint64_t v17 = v15[10];
  uint64_t v18 = (unsigned int *)(v16 + 16 * v17);
  if (v15[8])
  {
    if (v17)
    {
      uint64_t v19 = 16 * v17;
      uint64_t v20 = (unsigned int *)*((void *)v15 + 3);
      while (*v20 >= 0xFFFFFFFE)
      {
        v20 += 4;
        v19 -= 16;
        if (!v19) {
          goto LABEL_21;
        }
      }
    }
    else
    {
      uint64_t v20 = (unsigned int *)*((void *)v15 + 3);
    }
  }
  else
  {
LABEL_21:
    uint64_t v20 = (unsigned int *)(v16 + 16 * v17);
  }
  char v21 = (unsigned int *)(v16 + 16 * v17);
LABEL_23:
  while (v20 != v21)
  {
    if (!v6) {
      goto LABEL_35;
    }
    unsigned int v22 = *v20;
    uint64_t v23 = result[25];
    char v24 = result + 25;
    do
    {
      unsigned int v25 = *(_DWORD *)(v23 + 32);
      BOOL v26 = v25 >= v22;
      if (v25 >= v22) {
        int v27 = (uint64_t *)v23;
      }
      else {
        int v27 = (uint64_t *)(v23 + 8);
      }
      if (v26) {
        char v24 = (void *)v23;
      }
      uint64_t v23 = *v27;
    }
    while (*v27);
    if (v24 != v5 && *((_DWORD *)v24 + 8) <= v22)
    {
      unint64_t v29 = v24[5];
      unint64_t v28 = v24[6];
    }
    else
    {
LABEL_35:
      unint64_t v28 = 0;
      unint64_t v29 = -1;
    }
    if (v29 < v13) {
      unint64_t v13 = v29;
    }
    if (v12 <= v28) {
      unint64_t v12 = v28;
    }
    __int16 v30 = v20 + 4;
    while (v30 != v18)
    {
      unsigned int v31 = *v30;
      v30 += 4;
      if (v31 <= 0xFFFFFFFD)
      {
        uint64_t v20 = v30 - 4;
        goto LABEL_23;
      }
    }
    uint64_t v20 = v18;
  }
  if (v13 < v12)
  {
    uint64_t v32 = result[27];
    if (0xAAAAAAAAAAAAAAABLL * ((result[28] - v32) >> 3) > v13)
    {
      uint64_t v71 = v15;
      unint64_t v72 = result;
      unint64_t v33 = 0;
      char v34 = 0;
      uint64_t v35 = *(void *)(a3 + 64);
      int v36 = *(_DWORD *)(a3 + 56);
      int v75 = *(_DWORD *)(a3 + 60);
      uint64_t v74 = (void *)(a3 + 80);
      *(void *)(a3 + 88) = 0;
      uint64_t v37 = 3 * v13;
      uint64_t v38 = 24 * v12 - 8 * v37 - 24;
      uint64_t v39 = v32 + 8 * v37 + 16;
      while (1)
      {
        int v40 = *(_DWORD *)(v39 - 8);
        if (v40 == *(_DWORD *)(a3 + 52)) {
          break;
        }
        uint64_t v59 = v35;
        uint64_t v60 = *((void *)v71 + 3);
        uint64_t v61 = v71[10];
        uint64_t v62 = sub_1CD57516C(v60, v71[10], v40);
        if ((int *)(v60 + 16 * v61) != v62)
        {
          int v41 = v62 + 1;
          uint64_t v42 = v62 + 2;
          uint64_t v35 = v59;
          goto LABEL_51;
        }
        uint64_t v35 = v59;
        if (v34)
        {
          uint64_t v52 = sub_1CCBB49F8(a2, v59, *(void *)(v39 - 16));
          char v34 = 0;
          uint64_t v55 = *(void *)(a3 + 88);
          char v58 = 4;
          if ((unint64_t)(v55 + 1) > *(void *)(a3 + 96)) {
            goto LABEL_98;
          }
LABEL_73:
          *(unsigned char *)(*(void *)(a3 + 80) + v55) = v58;
          ++*(void *)(a3 + 88);
          sub_1CCBB4CD8(v52, v74);
          uint64_t v35 = *(void *)(v39 - 16);
          unint64_t v33 = *(void *)(a3 + 88);
          goto LABEL_74;
        }
        char v34 = 0;
LABEL_74:
        if (v38)
        {
          v38 -= 24;
          v39 += 24;
          if (v33 < 0xFEEC) {
            continue;
          }
        }
        uint64_t v63 = v35;
        unsigned int v64 = sub_1CCBB49F8(a2, v35, *(void *)(a3 + 72));
        if (v12 != -1
          && (uint64_t v65 = v72[27], 0xAAAAAAAAAAAAAAABLL * ((v72[28] - v65) >> 3) > v12)
          && (unsigned int v66 = (uint64_t *)(v65 + 24 * v12),
              uint64_t v67 = *(void *)(sub_1CC34BE58(*v66, 1) + 16),
              v67 == *(void *)(sub_1CC34BE58(v63, 1) + 16)))
        {
          unsigned int v68 = sub_1CCBB49F8(a2, v63, *v66);
        }
        else
        {
          unsigned int v68 = -1;
        }
        uint64_t v69 = *(void *)(a3 + 88);
        if ((unint64_t)(v69 + 1) > *(void *)(a3 + 96)) {
          llvm::SmallVectorBase<unsigned long long>::grow_pod();
        }
        *(unsigned char *)(*(void *)(a3 + 80) + v69) = 4;
        ++*(void *)(a3 + 88);
        if (v68 >= v64) {
          uint64_t v70 = v64;
        }
        else {
          uint64_t v70 = v68;
        }
        return (void *)sub_1CCBB4CD8(v70, v74);
      }
      int v41 = (int *)(v39 - 4);
      uint64_t v42 = (int *)v39;
LABEL_51:
      int v43 = *v42;
      int v44 = *v41;
      if ((v34 & (*v41 == v36)) == 1 && v43 == v75)
      {
        char v34 = 1;
        goto LABEL_74;
      }
      if (v44 != v36)
      {
        uint64_t v46 = v35;
        uint64_t v47 = *(void *)(v72[6] + 32 * (v44 - 1) + 24);
        *(_DWORD *)(v47 + 8) |= 4u;
        uint64_t v48 = *(unsigned int *)(*(void *)(v47 + 24) + 16);
        uint64_t v49 = *(void *)(a3 + 88);
        if ((unint64_t)(v49 + 1) > *(void *)(a3 + 96)) {
          llvm::SmallVectorBase<unsigned long long>::grow_pod();
        }
        *(unsigned char *)(*(void *)(a3 + 80) + v49) = 5;
        ++*(void *)(a3 + 88);
        sub_1CCBB4CD8(v48, v74);
        uint64_t v35 = v46;
      }
      if (v43 - v75 >= 0) {
        uint64_t v50 = (2 * (v43 - v75));
      }
      else {
        uint64_t v50 = (1 - 2 * (v43 - v75));
      }
      uint64_t v51 = sub_1CCBB49F8(a2, v35, *(void *)(v39 - 16));
      uint64_t v52 = v51;
      if (v50 > 7 || v51 > 0xF)
      {
        if (v43 != v75)
        {
          uint64_t v54 = *(void *)(a3 + 88);
          if ((unint64_t)(v54 + 1) > *(void *)(a3 + 96)) {
            llvm::SmallVectorBase<unsigned long long>::grow_pod();
          }
          *(unsigned char *)(*(void *)(a3 + 80) + v54) = 6;
          ++*(void *)(a3 + 88);
          sub_1CCBB4CD8(v50, v74);
        }
        uint64_t v55 = *(void *)(a3 + 88);
        unint64_t v56 = *(void *)(a3 + 96);
        unint64_t v57 = v55 + 1;
        char v34 = 1;
        char v58 = 3;
      }
      else
      {
        uint64_t v52 = v51 | (16 * v50);
        uint64_t v55 = *(void *)(a3 + 88);
        unint64_t v56 = *(void *)(a3 + 96);
        unint64_t v57 = v55 + 1;
        char v34 = 1;
        char v58 = 11;
      }
      if (v57 > v56) {
LABEL_98:
      }
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      int v75 = v43;
      int v36 = v44;
      goto LABEL_73;
    }
  }
  return result;
}

uint64_t sub_1CD6A4F6C(uint64_t a1, unsigned char *a2, uint64_t a3, unsigned char *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = llvm::MCFragment::MCFragment(a1, 14, 0, a6);
  *(_WORD *)(v11 + 51) = 0;
  *(void *)(v11 + 56) = 0;
  *(void *)(v11 + 64) = v11 + 88;
  *(_OWORD *)(v11 + 72) = xmmword_1CDC7F9D0;
  *(void *)(v11 + 120) = v11 + 136;
  *(void *)(v11 + 128) = 0x400000000;
  *(void *)(v11 + 232) = v11 + 248;
  *(void *)(a1 + 240) = 0x200000000;
  sub_1CD3D61B4((unsigned int *)(v11 + 232), a2, &a2[16 * a3]);
  *(void *)(a1 + 280) = a1 + 304;
  *(_OWORD *)(a1 + 288) = xmmword_1CDC7F9D0;
  sub_1CC22C75C((void *)(a1 + 280), a4, &a4[a5]);
  return a1;
}

void sub_1CD6A5038(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2 != a2)
  {
    int v3 = a2;
    if (v2 <= a2)
    {
      if (*(unsigned int *)(a1 + 12) < a2) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v2 != a2) {
        bzero((void *)(*(void *)a1 + 32 * v2), 32 * a2 - 32 * v2);
      }
    }
    *(_DWORD *)(a1 + 8) = v3;
  }
}

void sub_1CD6A50B4(uint64_t *a1, unint64_t a2)
{
  unsigned int v4 = a1 + 2;
  uint64_t v5 = a1[2];
  uint64_t v6 = (char *)a1[1];
  if (0xAAAAAAAAAAAAAAABLL * ((v5 - (uint64_t)v6) >> 4) < a2)
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v6[-*a1] >> 4);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x555555555555555) {
      abort();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 4);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v11 = 0x555555555555555;
    }
    else {
      unint64_t v11 = v9;
    }
    char v21 = v4;
    if (v11)
    {
      if (v11 > 0x555555555555555) {
        sub_1CB833614();
      }
      unint64_t v12 = (char *)operator new(48 * v11);
    }
    else
    {
      unint64_t v12 = 0;
    }
    std::string __p = v12;
    uint64_t v18 = &v12[48 * v8];
    uint64_t v20 = &v12[48 * v11];
    uint64_t v13 = 3 * a2;
    bzero(v18, 48 * ((16 * v13 - 48) / 0x30uLL) + 48);
    uint64_t v19 = &v18[16 * v13];
    sub_1CD6A5258(a1, &__p);
    uint64_t v15 = v18;
    uint64_t v14 = v19;
    if (v19 != v18)
    {
      do
      {
        uint64_t v16 = v14 - 48;
        MEMORY[0x1D25D9CD0](*((void *)v14 - 3), 4);
        uint64_t v14 = v16;
      }
      while (v16 != v15);
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else
  {
    if (a2)
    {
      uint64_t v7 = &v6[48 * a2];
      bzero(v6, 48 * ((48 * a2 - 48) / 0x30) + 48);
      uint64_t v6 = v7;
    }
    a1[1] = (uint64_t)v6;
  }
}

uint64_t *sub_1CD6A5258(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v4 + v5;
      uint64_t v7 = v2 + v5;
      uint64_t v8 = *(void *)(v2 + v5 - 32);
      *(_OWORD *)(v6 - 48) = *(_OWORD *)(v2 + v5 - 48);
      *(void *)(v6 - 24) = 0;
      *(void *)(v6 - 16) = 0;
      *(void *)(v6 - 32) = v8;
      *(_DWORD *)(v6 - 8) = 0;
      *(void *)(v6 - 24) = *(void *)(v2 + v5 - 24);
      *(void *)(v7 - 24) = 0;
      *(_DWORD *)(v6 - 16) = *(_DWORD *)(v2 + v5 - 16);
      *(_DWORD *)(v7 - 16) = 0;
      LODWORD(v8) = *(_DWORD *)(v4 + v5 - 12);
      *(_DWORD *)(v6 - 12) = *(_DWORD *)(v2 + v5 - 12);
      *(_DWORD *)(v7 - 12) = v8;
      LODWORD(v8) = *(_DWORD *)(v4 + v5 - 8);
      *(_DWORD *)(v6 - 8) = *(_DWORD *)(v2 + v5 - 8);
      *(_DWORD *)(v7 - 8) = v8;
      v5 -= 48;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  uint64_t v9 = *result;
  char *result = v4;
  a2[1] = v9;
  uint64_t v10 = result[1];
  result[1] = a2[2];
  a2[2] = v10;
  uint64_t v11 = result[2];
  result[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return result;
}

_DWORD *sub_1CD6A5314(uint64_t a1, _DWORD *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    uint64_t v9 = 0;
LABEL_5:
    uint64_t v6 = sub_1CD6A53D8(a1, a2, v9);
    *uint64_t v6 = *a2;
    void v6[3] = 0;
    *(void *)(v6 + 1) = 0;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = (37 * *a2) & (v3 - 1);
  uint64_t v6 = (_DWORD *)(*(void *)a1 + 16 * v5);
  int v7 = *v6;
  if (*a2 != *v6)
  {
    uint64_t v10 = 0;
    int v11 = 1;
    while (v7 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        uint64_t v10 = v6;
      }
      unsigned int v13 = v5 + v11++;
      unsigned int v5 = v13 & v4;
      uint64_t v6 = (_DWORD *)(*(void *)a1 + 16 * (v13 & v4));
      int v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      uint64_t v9 = v10;
    }
    else {
      uint64_t v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

_DWORD *sub_1CD6A53D8(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_3;
    }
    sub_1CD6A5560(a1, v6);
    int v16 = *(_DWORD *)(a1 + 16);
    if (v16)
    {
      int v17 = v16 - 1;
      unsigned int v18 = (37 * *a2) & v17;
      a3 = (_DWORD *)(*(void *)a1 + 16 * v18);
      int v19 = *a3;
      if (*a2 == *a3) {
        goto LABEL_3;
      }
      BOOL v12 = 0;
      int v20 = 1;
      while (v19 != -1)
      {
        if (v12) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v19 == -2;
        }
        if (v21) {
          BOOL v12 = a3;
        }
        unsigned int v22 = v18 + v20++;
        unsigned int v18 = v22 & v17;
        a3 = (_DWORD *)(*(void *)a1 + 16 * v18);
        int v19 = *a3;
        if (*a2 == *a3) {
          goto LABEL_3;
        }
      }
      goto LABEL_21;
    }
LABEL_24:
    a3 = 0;
    goto LABEL_3;
  }
  sub_1CD6A5560(a1, 2 * v6);
  int v8 = *(_DWORD *)(a1 + 16);
  if (!v8) {
    goto LABEL_24;
  }
  int v9 = v8 - 1;
  unsigned int v10 = (37 * *a2) & v9;
  a3 = (_DWORD *)(*(void *)a1 + 16 * v10);
  int v11 = *a3;
  if (*a2 == *a3) {
    goto LABEL_3;
  }
  BOOL v12 = 0;
  int v13 = 1;
  while (v11 != -1)
  {
    if (v12) {
      BOOL v14 = 0;
    }
    else {
      BOOL v14 = v11 == -2;
    }
    if (v14) {
      BOOL v12 = a3;
    }
    unsigned int v15 = v10 + v13++;
    unsigned int v10 = v15 & v9;
    a3 = (_DWORD *)(*(void *)a1 + 16 * v10);
    int v11 = *a3;
    if (*a2 == *a3) {
      goto LABEL_3;
    }
  }
LABEL_21:
  if (v12) {
    a3 = v12;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD6A5560(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)4uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CCBB5678(a1, v4, &v4[4 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      _DWORD *result = -1;
      result += 4;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t **sub_1CD6A562C(uint64_t **a1, unsigned int a2, uint64_t a3)
{
  unint64_t v6 = a1 + 1;
  unint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        int v7 = (uint64_t **)v5;
        unsigned int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        unint64_t v5 = *v7;
        unint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      unint64_t v5 = v7[1];
      if (!v5)
      {
        unint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    int v7 = a1 + 1;
LABEL_9:
    int v9 = (uint64_t *)v7;
    int v7 = (uint64_t **)operator new(0x38uLL);
    *((_OWORD *)v7 + 2) = *(_OWORD *)a3;
    v7[6] = *(uint64_t **)(a3 + 16);
    *int v7 = 0;
    v7[1] = 0;
    void v7[2] = v9;
    *unint64_t v6 = (uint64_t *)v7;
    uint64_t v10 = (uint64_t *)**a1;
    uint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      uint64_t v11 = *v6;
    }
    sub_1CB8358B8(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t llvm::MCContext::MCContext(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8, uint64_t a9, uint64_t a10)
{
  *(void *)(a1 + 8) = a9;
  *(void *)(a1 + 16) = a10;
  uint64_t v12 = a1 + 24;
  if (*((char *)a2 + 23) < 0)
  {
    uint64_t v30 = a5;
    uint64_t v31 = a3;
    uint64_t v27 = a4;
    uint64_t v28 = a7;
    char v22 = a8;
    uint64_t v29 = a6;
    sub_1CB8BDF7C(v12, *(const void **)a2, *((void *)a2 + 1));
    a6 = v29;
    a5 = v30;
    a3 = v31;
    a4 = v27;
    a7 = v28;
    a8 = v22;
  }
  else
  {
    long long v13 = *a2;
    *(void *)(v12 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v12 = v13;
  }
  long long v14 = *(long long *)((char *)a2 + 24);
  uint64_t v15 = *((void *)a2 + 5);
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 48) = v14;
  *(void *)(a1 + 64) = v15;
  *(void *)(a1 + 72) = a6;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(void *)(a1 + 112) = &unk_1F262E228;
  *(void *)(a1 + 120) = sub_1CCBB58A4;
  *(void *)(a1 + 136) = a1 + 112;
  *(_DWORD *)(a1 + 144) = 0;
  *(unsigned char *)(a1 + 148) = 0;
  *(void *)(a1 + 152) = a3;
  *(void *)(a1 + 160) = a4;
  *(void *)(a1 + 176) = a5;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 208) = a1 + 224;
  *(void *)(a1 + 216) = 0x400000000;
  *(void *)(a1 + 256) = a1 + 272;
  *(_OWORD *)(a1 + 264) = 0u;
  *(void *)(a1 + 280) = 1;
  *(_OWORD *)(a1 + 288) = 0u;
  *(void *)(a1 + 304) = a1 + 320;
  *(void *)(a1 + 312) = 0x400000000;
  *(void *)(a1 + 352) = a1 + 368;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = a1 + 416;
  *(void *)(a1 + 408) = 0x400000000;
  *(void *)(a1 + 448) = a1 + 464;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(void *)(a1 + 488) = 0;
  *(void *)(a1 + 496) = a1 + 512;
  *(void *)(a1 + 504) = 0x400000000;
  *(void *)(a1 + 544) = a1 + 560;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(void *)(a1 + 584) = 0;
  *(void *)(a1 + 592) = a1 + 608;
  *(void *)(a1 + 600) = 0x400000000;
  *(void *)(a1 + 640) = a1 + 656;
  *(_OWORD *)(a1 + 648) = 0u;
  *(_OWORD *)(a1 + 664) = 0u;
  *(void *)(a1 + 680) = 0;
  *(void *)(a1 + 688) = a1 + 704;
  *(void *)(a1 + 696) = 0x400000000;
  *(void *)(a1 + 736) = a1 + 752;
  *(_OWORD *)(a1 + 744) = 0u;
  *(_OWORD *)(a1 + 760) = 0u;
  *(void *)(a1 + 776) = 0;
  *(void *)(a1 + 784) = a1 + 800;
  *(void *)(a1 + 792) = 0x400000000;
  *(void *)(a1 + 832) = a1 + 848;
  *(void *)(a1 + 872) = 0;
  *(_OWORD *)(a1 + 856) = 0u;
  *(_OWORD *)(a1 + 840) = 0u;
  *(void *)(a1 + 880) = a1 + 896;
  *(void *)(a1 + 888) = 0x400000000;
  *(void *)(a1 + 928) = a1 + 944;
  *(void *)(a1 + 968) = 0;
  *(_OWORD *)(a1 + 952) = 0u;
  *(_OWORD *)(a1 + 936) = 0u;
  *(void *)(a1 + 976) = a1 + 992;
  *(void *)(a1 + 984) = 0x400000000;
  *(void *)(a1 + 1024) = a1 + 1040;
  *(_OWORD *)(a1 + 1060) = 0u;
  *(_OWORD *)(a1 + 1048) = 0u;
  *(_OWORD *)(a1 + 1032) = 0u;
  *(_DWORD *)(a1 + 1076) = 16;
  *(void *)(a1 + 1080) = a1 + 192;
  *(_DWORD *)(a1 + 1104) = 0;
  *(_OWORD *)(a1 + 1088) = 0u;
  *(_DWORD *)(a1 + 1128) = 0;
  *(_OWORD *)(a1 + 1112) = 0u;
  *(_DWORD *)(a1 + 1132) = 16;
  *(void *)(a1 + 1136) = a1 + 192;
  *(_DWORD *)(a1 + 1160) = 0;
  *(_OWORD *)(a1 + 1144) = 0u;
  *(_DWORD *)(a1 + 1164) = 16;
  *(void *)(a1 + 1168) = a1 + 192;
  *(_DWORD *)(a1 + 1192) = 0;
  *(_OWORD *)(a1 + 1176) = 0u;
  *(_DWORD *)(a1 + 1196) = 16;
  int v16 = (std::string *)(a1 + 1232);
  *(_DWORD *)(a1 + 1224) = 0;
  *(_OWORD *)(a1 + 1208) = 0u;
  *(unsigned char *)(a1 + 1264) = 0;
  *(_OWORD *)(a1 + 1248) = 0u;
  *(_OWORD *)(a1 + 1232) = 0u;
  *(void *)(a1 + 1272) = a1 + 1296;
  *(_OWORD *)(a1 + 1280) = xmmword_1CFAC3020;
  *(_OWORD *)(a1 + 1432) = 0u;
  *(void *)(a1 + 1424) = a1 + 1432;
  int v17 = (void **)(a1 + 1448);
  *(void *)(a1 + 1464) = 0;
  *(_OWORD *)(a1 + 1448) = 0u;
  *(_OWORD *)(a1 + 1480) = 0u;
  *(void *)(a1 + 1472) = a1 + 1480;
  *(void *)(a1 + 1496) = 0;
  *(_WORD *)(a1 + 1504) = 0;
  *(unsigned char *)(a1 + 1506) = 1;
  *(_DWORD *)(a1 + 1510) = 0;
  *(_DWORD *)(a1 + 1507) = 0;
  *(void *)(a1 + 1532) = 0;
  *(_OWORD *)(a1 + 1516) = 0u;
  *(_OWORD *)(a1 + 1608) = 0u;
  *(_OWORD *)(a1 + 1592) = 0u;
  *(_OWORD *)(a1 + 1576) = 0u;
  *(_OWORD *)(a1 + 1560) = 0u;
  *(_OWORD *)(a1 + 1544) = 0u;
  *(_DWORD *)(a1 + 1624) = 16777220;
  *(unsigned char *)(a1 + 1628) = 0;
  *(_DWORD *)(a1 + 1632) = 0;
  *(_OWORD *)(a1 + 1648) = 0u;
  *(void *)(a1 + 1640) = a1 + 1648;
  *(_DWORD *)(a1 + 1680) = 0;
  *(_OWORD *)(a1 + 1664) = 0u;
  *(_DWORD *)(a1 + 1684) = 16;
  *(_OWORD *)(a1 + 1704) = 0u;
  *(void *)(a1 + 1696) = a1 + 1704;
  *(_OWORD *)(a1 + 1728) = 0u;
  *(_OWORD *)(a1 + 1752) = 0u;
  *(void *)(a1 + 1720) = a1 + 1728;
  *(void *)(a1 + 1744) = a1 + 1752;
  *(_OWORD *)(a1 + 1776) = 0u;
  *(void *)(a1 + 1768) = a1 + 1776;
  *(_OWORD *)(a1 + 1800) = 0u;
  *(void *)(a1 + 1792) = a1 + 1800;
  *(_DWORD *)(a1 + 1832) = 0;
  *(_OWORD *)(a1 + 1816) = 0u;
  *(_DWORD *)(a1 + 1836) = 16;
  *(_OWORD *)(a1 + 1848) = 0u;
  *(void *)(a1 + 1864) = a1 + 1880;
  *(void *)(a1 + 1872) = 0x400000000;
  *(void *)(a1 + 1912) = a1 + 1928;
  *(void *)(a1 + 1936) = 0;
  *(_OWORD *)(a1 + 1920) = 0u;
  *(unsigned char *)(a1 + 1944) = a8;
  *(void *)(a1 + 1952) = a7;
  *(unsigned char *)(a1 + 1960) = 0;
  *(_DWORD *)(a1 + 1984) = 0;
  *(_OWORD *)(a1 + 1968) = 0u;
  *(_DWORD *)(a1 + 1988) = 96;
  *(_OWORD *)(a1 + 2008) = 0u;
  *(void *)(a1 + 2000) = a1 + 2008;
  *(_DWORD *)(a1 + 2040) = 0;
  *(_OWORD *)(a1 + 2024) = 0u;
  if (a7)
  {
    if (*(char *)(a7 + 111) < 0)
    {
      sub_1CB8BDF7C((uint64_t)&__str, *(const void **)(a7 + 88), *(void *)(a7 + 96));
      int v16 = (std::string *)(a1 + 1232);
    }
    else
    {
      std::string __str = *(std::string *)(a7 + 88);
    }
  }
  else
  {
    *((unsigned char *)&__str.__r_.__value_.__s + 23) = 0;
    __str.__r_.__value_.__s.__data_[0] = 0;
  }
  std::string::operator=(v16, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  unsigned int v18 = *(uint64_t **)(a1 + 72);
  if (v18)
  {
    uint64_t v23 = *v18;
    if (-1431655765 * ((unint64_t)(*(void *)(*(void *)(a1 + 72) + 8) - v23) >> 3))
    {
      char v24 = (const std::string::value_type *)(*(uint64_t (**)(void))(**(void **)v23 + 16))();
      std::string::__init(&__str, v24, v25);
      if (*(char *)(a1 + 1471) < 0) {
        operator delete(*v17);
      }
      *(_OWORD *)int v17 = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
      *(void *)(a1 + 1464) = *((void *)&__str.__r_.__value_.__l + 2);
    }
  }
  int v19 = *((_DWORD *)a2 + 11);
  if (v19 == 5)
  {
    int v20 = 0;
  }
  else
  {
    switch(v19)
    {
      case 0:
        BOOL v26 = "Cannot initialize MC for unknown object file format.";
        goto LABEL_30;
      case 1:
        if (*((_DWORD *)a2 + 9) != 15)
        {
          BOOL v26 = "Cannot initialize MC for non-Windows COFF object files.";
LABEL_30:
          llvm::report_fatal_error((llvm *)v26, (const llvm::Twine *)1);
        }
        int v20 = 3;
        break;
      case 2:
        int v20 = 7;
        break;
      case 3:
        int v20 = 1;
        break;
      case 4:
        int v20 = 2;
        break;
      case 6:
        int v20 = 4;
        break;
      case 7:
        int v20 = 5;
        break;
      case 8:
        BOOL v26 = "Cannot initialize MC for MetalLib object files.";
        goto LABEL_30;
      case 9:
        int v20 = 6;
        break;
      default:
        return a1;
    }
  }
  *(_DWORD *)a1 = v20;
  return a1;
}

{
  return llvm::MCContext::MCContext(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

void llvm::MCContext::~MCContext(llvm::MCContext *this)
{
  if (*((unsigned char *)this + 1944)) {
    llvm::MCContext::reset(this);
  }
  MEMORY[0x1D25D9CD0](*((void *)this + 253), 8);
  sub_1CCBB9180(*((char **)this + 251));
  sub_1CD6A8EC8((uint64_t)this + 1968);
  sub_1CCBB692C((uint64_t)this + 1848);
  sub_1CBFFBA64((uint64_t)this + 1848);
  sub_1CC0D7CD8((uint64_t)this + 1816);
  sub_1CCBB9180(*((char **)this + 225));
  sub_1CCBB9180(*((char **)this + 222));
  sub_1CCBB9180(*((char **)this + 219));
  sub_1CCBB9180(*((char **)this + 216));
  sub_1CCBB9180(*((char **)this + 213));
  sub_1CD61201C((uint64_t)this + 1664);
  sub_1CD6A8A90(*((void **)this + 206));
  uint64_t v2 = (void *)*((void *)this + 196);
  if (v2)
  {
    *((void *)this + 197) = v2;
    operator delete(v2);
  }
  sub_1CC189978((void *)this + 190);
  sub_1CCBB90A0(*((char **)this + 185));
  if (*((char *)this + 1471) < 0) {
    operator delete(*((void **)this + 181));
  }
  sub_1CD6A8E70(*((void **)this + 179));
  uint64_t v3 = (char *)*((void *)this + 159);
  if (v3 != (char *)this + 1296) {
    free(v3);
  }
  uint64_t v4 = *((void *)this + 157);
  *((void *)this + 157) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  if (*((char *)this + 1255) < 0) {
    operator delete(*((void **)this + 154));
  }
  MEMORY[0x1D25D9CD0](*((void *)this + 151), 8);
  sub_1CC3724DC((uint64_t)this + 1176);
  free(*((void **)this + 143));
  free(*((void **)this + 139));
  MEMORY[0x1D25D9CD0](*((void *)this + 136), 8);
  free(*((void **)this + 132));
  sub_1CCBB6790((uint64_t)this + 960);
  sub_1CBFFBA64((uint64_t)this + 960);
  sub_1CCBB6614((unint64_t)this + 864);
  sub_1CBFFBA64((uint64_t)this + 864);
  sub_1CCBB6498((unint64_t)this + 768);
  sub_1CBFFBA64((uint64_t)this + 768);
  sub_1CCBB6100((unint64_t)this + 672);
  sub_1CBFFBA64((uint64_t)this + 672);
  sub_1CCBB6100((unint64_t)this + 576);
  sub_1CBFFBA64((uint64_t)this + 576);
  sub_1CCBB627C((unint64_t)this + 480);
  sub_1CBFFBA64((uint64_t)this + 480);
  sub_1CCBB5F84((unint64_t)this + 384);
  sub_1CBFFBA64((uint64_t)this + 384);
  sub_1CCBB5E08((unint64_t)this + 288);
  sub_1CBFFBA64((uint64_t)this + 288);
  sub_1CBFFBA64((uint64_t)this + 192);
  unint64_t v5 = (llvm::CodeViewContext *)*((void *)this + 23);
  *((void *)this + 23) = 0;
  if (v5)
  {
    llvm::CodeViewContext::~CodeViewContext(v5);
    MEMORY[0x1D25D9CE0]();
  }
  unint64_t v6 = (llvm::MCContext *)*((void *)this + 17);
  if (v6 == (llvm::MCContext *)((char *)this + 112))
  {
    (*(void (**)(char *))(*((void *)this + 14) + 32))((char *)this + 112);
  }
  else if (v6)
  {
    (*(void (**)(llvm::MCContext *))(*(void *)v6 + 40))(v6);
  }
  int v7 = (void *)*((void *)this + 11);
  if (v7)
  {
    *((void *)this + 12) = v7;
    operator delete(v7);
  }
  unsigned int v8 = (llvm::SourceMgr *)*((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v8)
  {
    llvm::SourceMgr::~SourceMgr(v8);
    MEMORY[0x1D25D9CE0]();
  }
  if (*((char *)this + 47) < 0) {
    operator delete(*((void **)this + 3));
  }
}

uint64_t llvm::MCContext::initInlineSourceManager(uint64_t this)
{
  if (!*(void *)(this + 80)) {
    operator new();
  }
  return this;
}

uint64_t llvm::MCContext::getOrCreateFrameAllocSymbol(llvm::MCContext *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6 = *((void *)a1 + 19);
  uint64_t v8 = *(void *)(v6 + 88);
  uint64_t v7 = *(void *)(v6 + 96);
  __int16 v17 = 261;
  v16[0] = v8;
  v16[1] = v7;
  __int16 v15 = 261;
  v14[0] = a2;
  v14[1] = a3;
  sub_1CB8F1E58(v16, v14, (uint64_t)v18);
  uint64_t v12 = "$frame_escape_";
  __int16 v13 = 259;
  sub_1CB8F1E58(v18, (uint64_t *)&v12, (uint64_t)v19);
  __int16 v11 = 264;
  LODWORD(v10[0]) = a4;
  sub_1CB8F1E58(v19, v10, (uint64_t)v20);
  return llvm::MCContext::getOrCreateSymbol(a1, v20);
}

uint64_t llvm::MCContext::getOrCreateParentFrameOffsetSymbol(llvm::MCContext *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *((void *)a1 + 19);
  uint64_t v6 = *(void *)(v4 + 88);
  uint64_t v5 = *(void *)(v4 + 96);
  __int16 v13 = 261;
  v12[0] = v6;
  v12[1] = v5;
  __int16 v11 = 261;
  v10[0] = a2;
  v10[1] = a3;
  sub_1CB8F1E58(v12, v10, (uint64_t)v14);
  uint64_t v8 = "$parent_frame_offset";
  __int16 v9 = 259;
  sub_1CB8F1E58(v14, (uint64_t *)&v8, (uint64_t)v15);
  return llvm::MCContext::getOrCreateSymbol(a1, v15);
}

uint64_t llvm::MCContext::getOrCreateLSDASymbol(llvm::MCContext *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *((void *)a1 + 19);
  uint64_t v8 = *(void *)(v6 + 88);
  uint64_t v7 = *(void *)(v6 + 96);
  __int16 v15 = 261;
  v14[0] = v8;
  v14[1] = v7;
  uint64_t v12 = "__ehtable$";
  __int16 v13 = 259;
  sub_1CB8F1E58(v14, (uint64_t *)&v12, (uint64_t)v16);
  __int16 v11 = 261;
  v10[0] = a2;
  v10[1] = a3;
  sub_1CB8F1E58(v16, v10, (uint64_t)v17);
  return llvm::MCContext::getOrCreateSymbol(a1, v17);
}

uint64_t llvm::MCContext::createXCOFFSymbolImpl(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    uint64_t v8 = sub_1CB906F34((uint64_t *)(a1 + 192), 72, 3);
    *(_DWORD *)(v8 + 8) = *(_DWORD *)(v8 + 8) & 0xFFFC0000 | a3 | 0x180;
    *(_WORD *)(v8 + 12) = 0;
    *(_DWORD *)(v8 + 16) = 0;
    *(void *)(v8 + 24) = 0;
    *(void *)uint64_t v8 = 0;
    *(_WORD *)(v8 + 32) = 0;
    *(void *)(v8 + 40) = 0;
    *(_WORD *)(v8 + 48) = 0;
    *(void *)(v8 + 56) = 0;
    *(void *)(v8 + 64) = 0;
    return v8;
  }
  uint64_t v7 = (unsigned char *)(a2 + 16);
  uint64_t v6 = *(void *)a2;
  if (*(void *)a2 >= 0xBuLL)
  {
    if (*(void *)v7 == 0x656D616E65525F2ELL && *(void *)(a2 + 19) == 0x2E2E64656D616E65) {
      goto LABEL_17;
    }
  }
  else if (v6 != 10)
  {
    goto LABEL_14;
  }
  if (*(void *)v7 == 0x64656D616E65525FLL && *(_WORD *)(a2 + 24) == 11822)
  {
LABEL_17:
    uint64_t v38 = "invalid symbol name from source";
    uint64_t v40[4] = 259;
    llvm::MCContext::reportError(a1, 0, (uint64_t)&v38);
  }
LABEL_14:
  if ((*(unsigned int (**)(void, unsigned char *, uint64_t))(**(void **)(a1 + 152) + 56))(*(void *)(a1 + 152), v7, v6))
  {
    uint64_t v11 = sub_1CB906F34((uint64_t *)(a1 + 192), 80, 3);
    *(_DWORD *)(v11 + 16) = *(_DWORD *)(v11 + 16) & 0xFFFC0000 | a3 | 0x180;
    *(_WORD *)(v11 + 20) = 0;
    *(_DWORD *)(v11 + 24) = 0;
    *(void *)(v11 + 32) = 0;
    *(void *)uint64_t v11 = a2;
    *(_WORD *)(v11 + 40) = 0;
    *(void *)(v11 + 48) = 0;
    *(_WORD *)(v11 + 56) = 0;
    *(void *)(v11 + 64) = 0;
    *(void *)(v11 + 72) = 0;
    *(void *)(v11 + 8) = 4;
    return v11 + 8;
  }
  else
  {
    uint64_t v38 = (char *)v40;
    long long v39 = xmmword_1CFAC3020;
    sub_1CC22C75C(&v38, v7, &v7[v6]);
    if ((void)v39)
    {
      BOOL v13 = *v38 == 46;
      if (*v38 == 46) {
        long long v14 = "._Renamed..";
      }
      else {
        long long v14 = "_Renamed..";
      }
      uint64_t v15 = 10;
      if (*v38 == 46) {
        uint64_t v15 = 11;
      }
    }
    else
    {
      BOOL v13 = 0;
      long long v14 = "_Renamed..";
      uint64_t v15 = 10;
    }
    uint64_t v35 = v37;
    long long v36 = xmmword_1CFAC3020;
    sub_1CC22C75C(&v35, v14, &v14[v15]);
    uint64_t v16 = v39;
    if ((void)v39)
    {
      unint64_t v17 = 0;
      do
      {
        if (!(*(unsigned int (**)(void, void))(**(void **)(a1 + 152) + 48))(*(void *)(a1 + 152), v38[v17])|| v38[v17] == 95)
        {
          int v27 = 0;
          char v31 = 0;
          uint64_t v32 = 0;
          BOOL v26 = &unk_1F2646FA8;
          char v34 = &v35;
          int v33 = 0;
          uint64_t v29 = 0;
          uint64_t v30 = 0;
          uint64_t v28 = 0;
          llvm::raw_ostream::write_hex((llvm::raw_ostream *)&v26, v38[v17]);
          llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v26);
          v38[v17] = 95;
        }
        ++v17;
        uint64_t v16 = v39;
      }
      while (v17 < (unint64_t)v39);
    }
    if (v13)
    {
      uint64_t v18 = v16 - 1;
      if (v16 - (unint64_t)(v16 != 0) < v16 - 1) {
        uint64_t v18 = v16 - (v16 != 0);
      }
      if (v16) {
        int v19 = v38 + 1;
      }
      else {
        int v19 = v38;
      }
      int v20 = &v38[(v16 != 0) + v18];
    }
    else
    {
      int v19 = v38;
      int v20 = &v38[v16];
    }
    sub_1CC22C75C(&v35, v19, v20);
    v25[0] = 1;
    BOOL v21 = sub_1CCBB9468(a1 + 1112, (unsigned __int8 *)v35, v36, v25);
    uint64_t v22 = *v21;
    *(unsigned char *)(v22 + 8) = 1;
    if (v22) {
      uint64_t v23 = 80;
    }
    else {
      uint64_t v23 = 72;
    }
    uint64_t v8 = sub_1CB906F34((uint64_t *)(a1 + 192), v23, 3) + 8 * (v22 != 0);
    sub_1CD6A8B68(v8, *v21, a3);
    *(void *)(v8 + 56) = sub_1CD586E78((uint64_t)v7, v6);
    *(void *)(v8 + 64) = v24;
    if (v35 != v37) {
      free(v35);
    }
    if (v38 != (char *)v40) {
      free(v38);
    }
  }
  return v8;
}

uint64_t llvm::MCContext::createNamedTempSymbol(llvm::MCContext *this, const llvm::Twine *a2)
{
  v19[16] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = &v17;
  unint64_t v17 = v19;
  long long v18 = xmmword_1CFAC3020;
  int v9 = 0;
  char v13 = 0;
  uint64_t v14 = 0;
  int v15 = 0;
  uint64_t v8 = &unk_1F2646FA8;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v4 = *((void *)this + 19);
  size_t v5 = *(void *)(v4 + 96);
  if (v5) {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v8, *(const char **)(v4 + 88), v5);
  }
  llvm::Twine::print(a2, (llvm::raw_ostream *)&v8);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v8);
  uint64_t Symbol = llvm::MCContext::createSymbol((uint64_t)this, (unsigned __int8 *)v17, v18, 1, 0);
  if (v17 != v19) {
    free(v17);
  }
  return Symbol;
}

uint64_t llvm::MCContext::createNamedTempSymbol(llvm::MCContext *this)
{
  uint64_t v2 = "tmp";
  __int16 v3 = 259;
  return llvm::MCContext::createNamedTempSymbol(this, (const llvm::Twine *)&v2);
}

uint64_t llvm::MCContext::NextInstance(llvm::MCContext *this, int a2)
{
  int v7 = a2;
  __int16 v3 = sub_1CD52C224((uint64_t)this + 1208, &v7);
  uint64_t v4 = (_DWORD *)*((void *)v3 + 1);
  if (v4)
  {
    uint64_t v5 = (*v4 + 1);
  }
  else
  {
    uint64_t v4 = (_DWORD *)sub_1CB906F34((uint64_t *)this + 24, 4, 3);
    *uint64_t v4 = 0;
    *((void *)v3 + 1) = v4;
    uint64_t v5 = 1;
  }
  *uint64_t v4 = v5;
  return v5;
}

uint64_t llvm::MCContext::GetInstance(llvm::MCContext *this, int a2)
{
  int v8 = a2;
  __int16 v3 = sub_1CD52C224((uint64_t)this + 1208, &v8);
  uint64_t v4 = (unsigned int *)*((void *)v3 + 1);
  if (v4) {
    return *v4;
  }
  uint64_t v6 = v3;
  int v7 = (_DWORD *)sub_1CB906F34((uint64_t *)this + 24, 4, 3);
  uint64_t result = 0;
  *int v7 = 0;
  *((void *)v6 + 1) = v7;
  return result;
}

uint64_t llvm::MCContext::getOrCreateDirectionalLocalSymbol(llvm::MCContext *this, unsigned int a2, uint64_t a3)
{
  *(void *)uint64_t v6 = a2 | (unint64_t)(a3 << 32);
  uint64_t v4 = sub_1CD6A901C((uint64_t)this + 1088, v6);
  uint64_t result = *((void *)v4 + 1);
  if (!result)
  {
    *(void *)uint64_t v6 = "tmp";
    __int16 v7 = 259;
    uint64_t result = llvm::MCContext::createNamedTempSymbol(this, (const llvm::Twine *)v6);
    *((void *)v4 + 1) = result;
  }
  return result;
}

uint64_t llvm::MCContext::createDirectionalLocalSymbol(llvm::MCContext *this, unsigned int a2)
{
  uint64_t Instance = llvm::MCContext::NextInstance(this, a2);

  return llvm::MCContext::getOrCreateDirectionalLocalSymbol(this, a2, Instance);
}

uint64_t llvm::MCContext::getDirectionalLocalSymbol(llvm::MCContext *this, unsigned int a2, int a3)
{
  uint64_t v5 = llvm::MCContext::GetInstance(this, a2) + (a3 ^ 1);

  return llvm::MCContext::getOrCreateDirectionalLocalSymbol(this, a2, v5);
}

uint64_t llvm::MCContext::lookupSymbol(llvm::MCContext *this, const llvm::Twine *a2)
{
  v10[16] = *MEMORY[0x1E4F143B8];
  int v8 = v10;
  long long v9 = xmmword_1CFAC3020;
  __int16 v3 = (unsigned __int8 *)sub_1CC229614((void **)a2, (uint64_t)&v8);
  int Key = llvm::StringMapImpl::FindKey((uint64_t *)this + 132, v3, v4);
  if (Key == -1 || Key == (unint64_t)*((unsigned int *)this + 266)) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = *(void *)(*(void *)(*((void *)this + 132) + 8 * Key) + 8);
  }
  if (v8 != v10) {
    free(v8);
  }
  return v6;
}

uint64_t llvm::MCContext::setSymbolValue(llvm::MCContext *a1, uint64_t a2, unsigned __int8 **a3, unsigned __int8 **a4, llvm::MCConstantExpr *a5)
{
  __int16 v13 = 261;
  v12[0] = a3;
  v12[1] = a4;
  uint64_t Symbol = llvm::MCContext::getOrCreateSymbol(a1, v12);
  unint64_t v9 = llvm::MCConstantExpr::create(a5, (uint64_t)a1, 0, 0);
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, unint64_t))(*(void *)a2 + 280);

  return v10(a2, Symbol, v9);
}

uint64_t *llvm::MCContext::registerInlineAsmLabel(llvm::MCContext *this, llvm::MCSymbol *a2)
{
  if ((*(unsigned char *)a2 & 4) != 0)
  {
    uint64_t v5 = (void *)*((void *)a2 - 1);
    size_t v6 = *v5;
    __int16 v3 = (unsigned __int8 *)(v5 + 2);
    size_t v4 = v6;
  }
  else
  {
    __int16 v3 = 0;
    size_t v4 = 0;
  }
  uint64_t result = sub_1CCBB9364((uint64_t)this + 1144, v3, v4);
  *(void *)(*result + 8) = a2;
  return result;
}

uint64_t llvm::MCContext::reportError(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(a1 + 1960) = 1;
  uint64_t v4 = a2;
  v5[0] = &unk_1F262E270;
  v5[1] = &v4;
  uint64_t v5[2] = a3;
  size_t v6 = v5;
  llvm::MCContext::reportCommon((void *)a1, a2, (uint64_t)v5);
  uint64_t result = (uint64_t)v6;
  if (v6 == v5) {
    return (*(uint64_t (**)(void *))(v5[0] + 32))(v5);
  }
  if (v6) {
    return (*(uint64_t (**)(void))(*v6 + 40))();
  }
  return result;
}

void llvm::MCContext::renameELFSection(uint64_t a1, uint64_t a2, const std::string::value_type *a3, std::string::size_type a4)
{
  int v8 = (unsigned char *)(*(void *)(a2 + 240) & 0xFFFFFFFFFFFFFFF8);
  if (v8 && (*v8 & 4) != 0)
  {
    int v20 = (uint64_t *)*((void *)v8 - 1);
    uint64_t v21 = *v20;
    unint64_t v9 = v20 + 2;
    uint64_t v10 = v21;
  }
  else
  {
    unint64_t v9 = 0;
    uint64_t v10 = 0;
  }
  int v11 = *(_DWORD *)(a2 + 232);
  std::string::__init(&v26, *(const std::string::value_type **)(a2 + 200), *(void *)(a2 + 208));
  *(void *)&long long v27 = v9;
  *((void *)&v27 + 1) = v10;
  *(void *)&long long v28 = &unk_1CFBF5F4A;
  *((void *)&v28 + 1) = 0;
  int v29 = v11;
  uint64_t v12 = sub_1CD6A9094(a1 + 1696, (uint64_t *)&v26);
  if ((void *)(a1 + 1704) != v12) {
    sub_1CD4F3F94((uint64_t **)(a1 + 1696), (uint64_t)v12);
  }
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  std::string::__init(&__p, a3, a4);
  *((void *)&v23 + 1) = v10;
  long long v24 = (unint64_t)&unk_1CFBF5F4A;
  int v25 = v11;
  std::string v26 = __p;
  memset(&__p, 0, sizeof(__p));
  *(void *)&long long v23 = v9;
  int v29 = v11;
  long long v27 = v23;
  long long v28 = (unint64_t)&unk_1CFBF5F4A;
  uint64_t v30 = a2;
  __int16 v13 = sub_1CD6A925C(a1 + 1696, (uint64_t *)&v26, (uint64_t)&v26);
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  uint64_t v16 = (_OWORD *)*((void *)v13 + 4);
  int v15 = v13 + 2;
  uint64_t v14 = v16;
  char v17 = *((unsigned char *)v15 + 23);
  int v18 = v17;
  if (v17 >= 0) {
    uint64_t v14 = v15;
  }
  uint64_t v19 = v17 & 0x7F;
  if (v18 < 0) {
    uint64_t v19 = *((void *)v15 + 1);
  }
  *(void *)(a2 + 200) = v14;
  *(void *)(a2 + 208) = v19;
}

void llvm::MCContext::createELFSectionImpl(uint64_t a1, unsigned __int8 *a2, size_t a3, int a4, int a5, int a6, int a7, uint64_t a8, char a9, int a10, uint64_t a11)
{
  uint64_t v19 = sub_1CCBB9364(a1 + 1056, a2, a3);
  uint64_t v20 = *v19;
  uint64_t v21 = *(void *)(*v19 + 8);
  if (!v21) {
    goto LABEL_2;
  }
  if (sub_1CC34BE58(v21, 1))
  {
    uint64_t v34 = *(void *)(v20 + 8);
    if (sub_1CC34BE58(v34, 1))
    {
      if ((_UNKNOWN *)sub_1CC34BE58(v34, 1) != llvm::MCSymbol::AbsolutePseudoFragment)
      {
        uint64_t v33 = *(void *)(*(void *)(sub_1CC34BE58(*(void *)(v20 + 8), 1) + 16) + 8);
        if (v33 == *(void *)(v20 + 8))
        {
LABEL_16:
          if (v33 && !sub_1CC34BE58(v33, 1))
          {
            uint64_t v28 = *(void *)(v20 + 8);
            goto LABEL_13;
          }
LABEL_2:
          int v35 = a4;
          int v22 = a5;
          int v23 = a7;
          uint64_t v24 = a8;
          v36[0] = 0;
          int v25 = sub_1CCBB9468(a1 + 1112, a2, a3, v36);
          if (*v25) {
            uint64_t v27 = 48;
          }
          else {
            uint64_t v27 = 40;
          }
          BOOL v26 = *v25 != 0;
          uint64_t v28 = sub_1CB906F34((uint64_t *)(a1 + 192), v27, 3) + 8 * v26;
          uint64_t v29 = *v25;
          BOOL v30 = *v25 == 0;
          *(_DWORD *)(v28 + 8) = *(_DWORD *)(v28 + 8) & 0xFFFC0000 | 0x80;
          unsigned int v31 = !v30;
          *(_WORD *)(v28 + 12) = 0;
          *(_DWORD *)(v28 + 16) = 0;
          *(void *)(v28 + 24) = 0;
          *(void *)uint64_t v28 = 4 * v31;
          if (v29) {
            *(void *)(v28 - 8) = v29;
          }
          *(void *)(v28 + 32) = 0;
          if (!*(void *)(v20 + 8)) {
            *(void *)(v20 + 8) = v28;
          }
          a8 = v24;
          a7 = v23;
          a5 = v22;
          a4 = v35;
LABEL_13:
          llvm::MCSymbolELF::setBinding(v28, 0);
          llvm::MCSymbolELF::setType(v28, 3);
          uint64_t v32 = sub_1CB906F34((uint64_t *)(a1 + 384), 256, 3);
          sub_1CD6A8BB4(v32, (uint64_t)a2, a3, a4, a5, a6, a7, a8, a9, a10, v28, a11);
          operator new();
        }
      }
    }
    uint64_t v37 = "invalid symbol redefinition";
    __int16 v38 = 259;
    llvm::MCContext::reportError(a1, 0, (uint64_t)&v37);
  }
  uint64_t v33 = *(void *)(v20 + 8);
  goto LABEL_16;
}

void llvm::MCContext::createELFRelSection(llvm::MCContext *this, const llvm::Twine *a2, int a3, int a4, int a5, const llvm::MCSymbolELF *a6, const llvm::MCSectionELF *a7)
{
  __int16 v13 = (char *)this + 1816;
  llvm::Twine::str(a2, v17);
  int64_t v20 = v18;
  *(_OWORD *)std::string __p = *(_OWORD *)v17;
  v17[1] = 0;
  uint64_t v18 = 0;
  v17[0] = 0;
  if (v20 >= 0) {
    uint64_t v14 = (unsigned __int8 *)__p;
  }
  else {
    uint64_t v14 = (unsigned __int8 *)__p[0];
  }
  char v21 = 1;
  if (v20 >= 0) {
    int v15 = (void *)(HIBYTE(v20) & 0x7F);
  }
  else {
    int v15 = __p[1];
  }
  int v22 = v14;
  int v23 = v15;
  v24[0] = 1;
  uint64_t v16 = sub_1CD6A93C4((uint64_t)v13, v14, (size_t)v15, v24);
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(v17[0]);
  }
  llvm::MCContext::createELFSectionImpl((uint64_t)this, (unsigned __int8 *)(*v16 + 16), *(void *)*v16, a3, a4, 4, a5, (uint64_t)a6, 1, 1, *((void *)a7 + 1));
}

uint64_t llvm::MCContext::getELFSection(llvm::MCContext *this, const llvm::Twine *a2, int a3, int a4, int a5, const llvm::Twine *a6, char a7, int a8, const llvm::MCSymbolELF *a9)
{
  if (*((unsigned __int8 *)a6 + 32) < 2u) {
    goto LABEL_2;
  }
  llvm::Twine::str(a6, __p);
  uint64_t v19 = (v21 & 0x80u) == 0 ? (void *)v21 : __p[1];
  if ((char)v21 < 0) {
    operator delete(__p[0]);
  }
  if (v19) {
    uint64_t Symbol = (const llvm::MCSymbolELF *)llvm::MCContext::getOrCreateSymbol(this, (unsigned __int8 ***)a6);
  }
  else {
LABEL_2:
  }
    uint64_t Symbol = 0;
  return llvm::MCContext::getELFSection(this, a2, a3, a4, a5, Symbol, a7, a8, a9);
}

uint64_t llvm::MCContext::getELFSection(llvm::MCContext *this, const llvm::Twine *a2, int a3, int a4, int a5, const llvm::MCSymbolELF *a6, char a7, int a8, const llvm::MCSymbolELF *a9)
{
  if (a6)
  {
    if ((*(unsigned char *)a6 & 4) != 0)
    {
      int v23 = (uint64_t *)*((void *)a6 - 1);
      uint64_t v24 = *v23;
      uint64_t v14 = v23 + 2;
      uint64_t v13 = v24;
    }
    else
    {
      uint64_t v14 = 0;
      uint64_t v13 = 0;
    }
  }
  else
  {
    uint64_t v13 = 0;
    uint64_t v14 = &unk_1CFBF5F4A;
  }
  llvm::Twine::str(a2, v40);
  if (v41 >= 0) {
    int v15 = v40;
  }
  else {
    int v15 = (void **)v40[0];
  }
  if (v41 >= 0) {
    std::string::size_type v16 = v41 & 0x7F;
  }
  else {
    std::string::size_type v16 = (std::string::size_type)v40[1];
  }
  if (a9)
  {
    if ((*(unsigned char *)a9 & 4) != 0)
    {
      int v25 = (uint64_t *)*((void *)a9 - 1);
      uint64_t v26 = *v25;
      uint64_t v18 = v25 + 2;
      uint64_t v17 = v26;
    }
    else
    {
      uint64_t v18 = 0;
      uint64_t v17 = 0;
    }
  }
  else
  {
    uint64_t v17 = 0;
    uint64_t v18 = &unk_1CFBF5F4A;
  }
  std::string::__init(&v42, (const std::string::value_type *)v15, v16);
  *((void *)&v43 + 1) = v13;
  *(void *)&long long v44 = v18;
  *((void *)&v44 + 1) = v17;
  int v45 = a8;
  std::string __p = v42;
  memset(&v42, 0, sizeof(v42));
  *(void *)&long long v43 = v14;
  int v49 = a8;
  long long v47 = v43;
  long long v48 = v44;
  uint64_t v50 = 0;
  uint64_t v19 = sub_1CD6A94CC((uint64_t)this + 1696, (uint64_t *)&__p, (uint64_t)&__p);
  char v21 = v20;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  if (v41 < 0) {
    operator delete(v40[0]);
  }
  if (v21)
  {
    uint64_t v29 = (unsigned __int8 *)*((void *)v19 + 4);
    uint64_t v28 = v19 + 2;
    uint64_t v27 = v29;
    char v30 = *((unsigned char *)v28 + 23);
    int v31 = v30;
    if (v30 >= 0) {
      uint64_t v32 = (unsigned __int8 *)v28;
    }
    else {
      uint64_t v32 = v27;
    }
    size_t v33 = v30 & 0x7F;
    if (v31 >= 0) {
      size_t v34 = v33;
    }
    else {
      size_t v34 = *((void *)v28 + 1);
    }
    int v35 = 2;
    if ((a4 & 4) == 0) {
      int v35 = 4;
    }
    if ((a4 & 0x20000000) != 0) {
      int v36 = 3;
    }
    else {
      int v36 = v35;
    }
    llvm::MCContext::createELFSectionImpl((uint64_t)this, v32, v34, a3, a4, v36, a5, (uint64_t)a6, a7, a8, (uint64_t)a9);
  }
  return *((void *)v19 + 12);
}

void llvm::MCContext::recordELFMergeableSectionInfo(uint64_t a1, std::string::value_type *a2, unint64_t a3, unsigned int a4, int a5, unsigned int a6)
{
  std::string::size_type v16 = a2;
  unint64_t v17 = a3;
  if (a5 == -1)
  {
    sub_1CC5059B0(a1 + 2024, (uint64_t)&v16, (uint64_t)__p);
    a2 = v16;
    a3 = v17;
  }
  if ((a4 & 0x10) == 0)
  {
    if (!llvm::MCContext::isELFGenericMergeableSection(a1, a2, a3)) {
      return;
    }
    a2 = v16;
    a3 = v17;
  }
  std::string::__init(&v10, a2, a3);
  unint64_t v11 = __PAIR64__(a6, a4);
  *(_OWORD *)std::string __p = *(_OWORD *)&v10.__r_.__value_.__l.__data_;
  memset(&v10, 0, sizeof(v10));
  std::string::size_type v13 = v10.__r_.__value_.__r.__words[2];
  unint64_t v14 = __PAIR64__(a6, a4);
  int v15 = a5;
  sub_1CD6A95A4(a1 + 2000, (uint64_t *)__p, (uint64_t)__p);
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void llvm::MCContext::createELFGroupSection(llvm::MCContext *this, const llvm::MCSymbolELF *a2, char a3)
{
}

uint64_t llvm::MCContext::isELFGenericMergeableSection(uint64_t a1, void *a2, unint64_t a3)
{
  v5[0] = a2;
  v5[1] = a3;
  if (llvm::MCContext::isELFImplicitMergeableSectionNamePrefix(a1, a2, a3)) {
    return 1;
  }
  uint64_t v6 = 0;
  return sub_1CC18A4C4((uint64_t *)(a1 + 2024), (uint64_t)v5, &v6);
}

BOOL llvm::MCContext::isELFImplicitMergeableSectionNamePrefix(uint64_t a1, void *a2, unint64_t a3)
{
  if (a3 < 0xB) {
    return 0;
  }
  if (*a2 == 0x2E617461646F722ELL && *(void *)((char *)a2 + 3) == 0x7274732E61746164) {
    return 1;
  }
  return *a2 == 0x2E617461646F722ELL && *(void *)((char *)a2 + 3) == 0x7473632E61746164;
}

void llvm::MCContext::getGOFFSection(uint64_t a1, std::string::value_type *__s, std::string::size_type __sz, int a4)
{
  uint64_t v8 = a1 + 1744;
  if (__s) {
    std::string::__init(&v12, __s, __sz);
  }
  else {
    memset(&v12, 0, sizeof(v12));
  }
  std::string::size_type v13 = &v12;
  unint64_t v9 = sub_1CD6A9778(v8, (uint64_t)&v12, (uint64_t)&std::piecewise_construct, (_OWORD **)&v13);
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v12.__r_.__value_.__l.__data_);
  }
  if (!*((void *)v9 + 7))
  {
    uint64_t v10 = sub_1CB906F34((uint64_t *)(a1 + 576), 224, 3);
    llvm::MCSection::MCSection(v10, 2, (uint64_t)__s, __sz, a4, 0);
    *unint64_t v11 = &unk_1F262E1C8;
    *((void *)v9 + 7) = v11;
  }
}

uint64_t llvm::MCContext::getCOFFSection(llvm::MCContext *this, std::string::value_type *__s, std::string::size_type __sz, int a4, int a5, std::string::size_type a6, std::string::size_type a7, unsigned int a8, unsigned int a9, unsigned char *a10)
{
  unint64_t v11 = (void *)a6;
  if (a7)
  {
    WORD4(v39) = 261;
    __p.__r_.__value_.__r.__words[0] = a6;
    __p.__r_.__value_.__l.__size_ = a7;
    uint64_t Symbol = (unsigned char *)llvm::MCContext::getOrCreateSymbol(this, (unsigned __int8 ***)&__p);
    unint64_t v17 = Symbol;
    if ((*Symbol & 4) != 0)
    {
      int v35 = (uint64_t *)*((void *)Symbol - 1);
      uint64_t v36 = *v35;
      unint64_t v11 = v35 + 2;
      uint64_t v16 = v36;
    }
    else
    {
      unint64_t v11 = 0;
      uint64_t v16 = 0;
    }
  }
  else
  {
    uint64_t v16 = 0;
    unint64_t v17 = 0;
  }
  std::string::__init(&v42, __s, __sz);
  *(void *)&long long v43 = v11;
  *((void *)&v43 + 1) = v16;
  unint64_t v44 = __PAIR64__(a9, a8);
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    sub_1CB8BDF7C((uint64_t)&__p, v42.__r_.__value_.__l.__data_, v42.__r_.__value_.__l.__size_);
  }
  else {
    std::string __p = v42;
  }
  long long v39 = v43;
  unint64_t v40 = v44;
  uint64_t v41 = 0;
  uint64_t v19 = sub_1CD6A983C((uint64_t)this + 1720, (uint64_t *)&__p, (uint64_t)&__p);
  char v21 = v20;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v21)
  {
    if (a10)
    {
      char v23 = 1;
      BYTE9(v39) = 1;
      if (*a10)
      {
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)a10;
        char v23 = 3;
      }
      BYTE8(v39) = v23;
      uint64_t TempSymbol = llvm::MCContext::createTempSymbol(this, (const llvm::Twine *)&__p, 0);
    }
    else
    {
      uint64_t TempSymbol = 0;
    }
    uint64_t v27 = *((void *)v19 + 4);
    uint64_t v26 = v19 + 2;
    uint64_t v25 = v27;
    char v28 = *((unsigned char *)v26 + 23);
    int v29 = v28;
    if (v28 >= 0) {
      uint64_t v30 = (uint64_t)v26;
    }
    else {
      uint64_t v30 = v25;
    }
    uint64_t v31 = v28 & 0x7F;
    if (v29 >= 0) {
      uint64_t v32 = v31;
    }
    else {
      uint64_t v32 = *((void *)v26 + 1);
    }
    uint64_t v22 = sub_1CB906F34((uint64_t *)this + 36, 248, 3);
    llvm::MCSection::MCSection(v22, 0, v30, v32, a5, TempSymbol);
    *(void *)uint64_t v33 = &unk_1F262FAF8;
    *(_DWORD *)(v33 + 224) = a4;
    *(_DWORD *)(v33 + 228) = -1;
    *(void *)(v33 + 232) = v17;
    *(_DWORD *)(v33 + 240) = a8;
    *((void *)v26 + 6) = v33;
  }
  else
  {
    uint64_t v22 = *((void *)v19 + 10);
  }
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
  return v22;
}

uint64_t llvm::MCContext::getCOFFSection(llvm::MCContext *a1, std::string::value_type *a2, std::string::size_type a3, int a4, int a5, unsigned char *a6)
{
  return llvm::MCContext::getCOFFSection(a1, a2, a3, a4, a5, (std::string::size_type)&unk_1CFBF5F4A, 0, 0, 0xFFFFFFFF, a6);
}

llvm::MCSectionCOFF *llvm::MCContext::getAssociativeCOFFSection(llvm::MCContext *this, llvm::MCSectionCOFF *a2, const llvm::MCSymbol *a3, unsigned int a4)
{
  if (!a3 && a4 == -1) {
    return a2;
  }
  int v6 = *((_DWORD *)a2 + 56);
  if (!a3) {
    return (llvm::MCSectionCOFF *)llvm::MCContext::getCOFFSection(this, *((std::string::value_type **)a2 + 25), *((void *)a2 + 26), v6, *((_DWORD *)a2 + 55), (std::string::size_type)&unk_1CFBF5F4A, 0, 0, a4, 0);
  }
  int v7 = v6 | 0x1000;
  uint64_t v8 = (std::string::value_type *)*((void *)a2 + 25);
  if ((*(unsigned char *)a3 & 4) != 0)
  {
    unint64_t v11 = (std::string::size_type *)*((void *)a3 - 1);
    std::string::size_type v12 = *v11;
    std::string::size_type v9 = (std::string::size_type)(v11 + 2);
    std::string::size_type v10 = v12;
  }
  else
  {
    std::string::size_type v9 = 0;
    std::string::size_type v10 = 0;
  }
  return (llvm::MCSectionCOFF *)llvm::MCContext::getCOFFSection(this, v8, *((void *)a2 + 26), v7, *((_DWORD *)a2 + 55), v9, v10, 5u, a4, 0);
}

uint64_t llvm::MCContext::getWasmSection(llvm::MCContext *a1, llvm::Twine *this, int a3, int a4, llvm::Twine *a5, int a6)
{
  if (*((unsigned __int8 *)a5 + 32) < 2u) {
    goto LABEL_2;
  }
  llvm::Twine::str(a5, __p);
  unint64_t v14 = (v16 & 0x80u) == 0 ? (void *)v16 : __p[1];
  if ((char)v16 < 0) {
    operator delete(__p[0]);
  }
  if (v14)
  {
    uint64_t Symbol = (unsigned char *)llvm::MCContext::getOrCreateSymbol(a1, (unsigned __int8 ***)a5);
    Symbol[42] = 1;
  }
  else
  {
LABEL_2:
    uint64_t Symbol = 0;
  }
  return llvm::MCContext::getWasmSection((uint64_t)a1, this, a3, a4, Symbol, a6);
}

uint64_t llvm::MCContext::getWasmSection(uint64_t a1, llvm::Twine *this, int a3, int a4, unsigned char *a5, int a6)
{
  if (a5)
  {
    if ((*a5 & 4) != 0)
    {
      int v29 = (uint64_t *)*((void *)a5 - 1);
      uint64_t v30 = *v29;
      std::string::size_type v12 = v29 + 2;
      uint64_t v11 = v30;
    }
    else
    {
      std::string::size_type v12 = 0;
      uint64_t v11 = 0;
    }
  }
  else
  {
    uint64_t v11 = 0;
    std::string::size_type v12 = &unk_1CFBF5F4A;
  }
  llvm::Twine::str(this, v31);
  if (v32 >= 0) {
    std::string::size_type v13 = v31;
  }
  else {
    std::string::size_type v13 = (void **)v31[0];
  }
  if (v32 >= 0) {
    std::string::size_type v14 = v32 & 0x7F;
  }
  else {
    std::string::size_type v14 = (std::string::size_type)v31[1];
  }
  std::string::__init(&v33, (const std::string::value_type *)v13, v14);
  *(void *)&long long v34 = v12;
  *((void *)&v34 + 1) = v11;
  int v35 = a6;
  std::string __p = v33;
  memset(&v33, 0, sizeof(v33));
  int v38 = a6;
  long long v37 = v34;
  uint64_t v39 = 0;
  int v15 = sub_1CD6A9AB4(a1 + 1768, (uint64_t *)&__p, (uint64_t)&__p);
  char v17 = v16;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v33.__r_.__value_.__l.__data_);
  }
  if (v32 < 0) {
    operator delete(v31[0]);
  }
  if (v17)
  {
    char v18 = *((unsigned char *)v15 + 55);
    if (v18 >= 0) {
      uint64_t v19 = (unsigned __int8 *)(v15 + 2);
    }
    else {
      uint64_t v19 = (unsigned __int8 *)*((void *)v15 + 4);
    }
    if (v18 >= 0) {
      size_t v20 = v18 & 0x7F;
    }
    else {
      size_t v20 = *((void *)v15 + 5);
    }
    uint64_t Symbol = llvm::MCContext::createSymbol(a1, v19, v20, 1, 0);
    if ((*(unsigned char *)Symbol & 4) != 0)
    {
      uint64_t v24 = *(void **)(Symbol - 8);
      size_t v25 = *v24;
      uint64_t v22 = (unsigned __int8 *)(v24 + 2);
      size_t v23 = v25;
    }
    else
    {
      uint64_t v22 = 0;
      size_t v23 = 0;
    }
    *(void *)(*sub_1CCBB9364(a1 + 1056, v22, v23) + 8) = Symbol;
    if (!*(unsigned char *)(Symbol + 36)) {
      *(unsigned char *)(Symbol + 36) = 1;
    }
    *(_DWORD *)(Symbol + 32) = 3;
    uint64_t v26 = sub_1CB906F34((uint64_t *)(a1 + 768), 264, 3);
    llvm::MCSection::MCSection(v26, 4, (uint64_t)v19, v20, a3, Symbol);
    *(void *)uint64_t v27 = &unk_1F262FB88;
    *(_DWORD *)(v27 + 224) = a6;
    *(void *)(v27 + 232) = a5;
    *(void *)(v27 + 240) = 0;
    *(_DWORD *)(v27 + 248) = 0;
    *(unsigned char *)(v27 + 252) = 0;
    *(_DWORD *)(v27 + 256) = a4;
    *((void *)v15 + 10) = v27;
    operator new();
  }
  return *((void *)v15 + 10);
}

uint64_t llvm::MCContext::getXCOFFSection(uint64_t *a1, const std::string::value_type *a2, std::string::size_type a3, int a4, __int16 a5, int a6, unsigned char *TempSymbol, uint64_t a8)
{
  int v8 = a8;
  uint64_t v14 = (uint64_t)(a1 + 224);
  uint64_t v15 = a8 & 0xFF00000000;
  if ((a8 & 0xFF00000000) != 0)
  {
    if (a2)
    {
      std::string::__init(&v67, a2, a3);
      char v21 = HIBYTE(v67.__r_.__value_.__r.__words[2]);
      std::string::size_type size = v67.__r_.__value_.__l.__size_;
      std::string::size_type v20 = v67.__r_.__value_.__r.__words[0];
    }
    else
    {
      std::string::size_type size = 0;
      std::string::size_type v20 = 0;
      char v21 = 0;
      memset(&v67, 0, sizeof(v67));
    }
    BOOL v27 = v21 < 0;
    if (v21 >= 0) {
      char v28 = &v67;
    }
    else {
      char v28 = (std::string *)v20;
    }
    std::string::size_type v29 = v21 & 0x7F;
    if (v27) {
      std::string::size_type v30 = size;
    }
    else {
      std::string::size_type v30 = v29;
    }
    std::string::__init(&v63, (const std::string::value_type *)v28, v30);
    char v26 = 0;
    int v64 = v8;
  }
  else
  {
    if (a2)
    {
      std::string::__init(&v66, a2, a3);
      char v18 = HIBYTE(v66.__r_.__value_.__r.__words[2]);
      std::string::size_type v16 = v66.__r_.__value_.__l.__size_;
      std::string::size_type v17 = v66.__r_.__value_.__r.__words[0];
    }
    else
    {
      std::string::size_type v16 = 0;
      std::string::size_type v17 = 0;
      char v18 = 0;
      memset(&v66, 0, sizeof(v66));
    }
    BOOL v22 = v18 < 0;
    if (v18 >= 0) {
      size_t v23 = &v66;
    }
    else {
      size_t v23 = (std::string *)v17;
    }
    std::string::size_type v24 = v18 & 0x7F;
    if (v22) {
      std::string::size_type v25 = v16;
    }
    else {
      std::string::size_type v25 = v24;
    }
    std::string::__init(&v63, (const std::string::value_type *)v23, v25);
    LOBYTE(v64) = a5;
    char v26 = 1;
  }
  char v65 = v26;
  std::string v68 = v63;
  memset(&v63, 0, sizeof(v63));
  int v69 = v64;
  char v70 = v26;
  uint64_t v71 = 0;
  uint64_t v31 = sub_1CD6A9D5C(v14, (uint64_t)&v68, (uint64_t)&v68);
  char v33 = v32;
  if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v68.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v63.__r_.__value_.__l.__data_);
  }
  if (v15)
  {
    if ((SHIBYTE(v67.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_28;
    }
    int v35 = (void *)v67.__r_.__value_.__r.__words[0];
  }
  else
  {
    if ((SHIBYTE(v66.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_28;
    }
    int v35 = (void *)v66.__r_.__value_.__r.__words[0];
  }
  operator delete(v35);
LABEL_28:
  if (v33)
  {
    char v36 = *((unsigned char *)v31 + 55);
    if (v36 >= 0) {
      uint64_t v37 = (uint64_t)(v31 + 2);
    }
    else {
      uint64_t v37 = *((void *)v31 + 4);
    }
    if (v36 >= 0) {
      uint64_t v38 = v36 & 0x7F;
    }
    else {
      uint64_t v38 = *((void *)v31 + 5);
    }
    uint64_t v56 = v37;
    if (v15)
    {
      LOWORD(v71) = 261;
      v68.__r_.__value_.__r.__words[0] = v37;
      v68.__r_.__value_.__l.__size_ = v38;
    }
    else
    {
      __int16 v62 = 773;
      v61[0] = v37;
      v61[1] = v38;
      v61[2] = (uint64_t)"[";
      __int16 v60 = 261;
      v59[0] = (uint64_t)llvm::XCOFF::getMappingClassString(a5);
      v59[1] = v39;
      sub_1CB8F1E58(v61, v59, (uint64_t)&v63);
      unint64_t v57 = "]";
      __int16 v58 = 259;
      sub_1CB8F1E58((uint64_t *)&v63, (uint64_t *)&v57, (uint64_t)&v68);
    }
    uint64_t Symbol = (uint64_t *)llvm::MCContext::getOrCreateSymbol((llvm::MCContext *)a1, (unsigned __int8 ***)&v68);
    if (TempSymbol)
    {
      char v41 = 1;
      BYTE1(v71) = 1;
      if (*TempSymbol)
      {
        v68.__r_.__value_.__r.__words[0] = (std::string::size_type)TempSymbol;
        char v41 = 3;
      }
      LOBYTE(v71) = v41;
      uint64_t TempSymbol = (unsigned char *)llvm::MCContext::createTempSymbol((llvm::MCContext *)a1, (const llvm::Twine *)&v68, 0);
    }
    uint64_t v42 = sub_1CB906F34(a1 + 108, 272, 3);
    uint64_t v43 = *Symbol;
    if (v15)
    {
      if ((v43 & 4) != 0)
      {
        uint64_t v52 = (uint64_t *)*(Symbol - 1);
        uint64_t v53 = *v52;
        uint64_t v46 = (uint64_t)(v52 + 2);
        uint64_t v47 = v53;
      }
      else
      {
        uint64_t v46 = 0;
        uint64_t v47 = 0;
      }
      uint64_t v54 = sub_1CD586E78(v46, v47);
      llvm::MCSection::MCSection(v42, 5, v54, v55, a4, (uint64_t)TempSymbol);
      *(void *)uint64_t v42 = &unk_1F262FBB8;
      *(unsigned char *)(v42 + 224) = 0;
      *(unsigned char *)(v42 + 226) = 0;
      *(void *)(v42 + 232) = Symbol;
      *(void *)(v42 + 240) = v56;
      *(void *)(v42 + 248) = v38;
      *(_DWORD *)(v42 + 256) = v8;
      *(unsigned char *)(v42 + 260) = 1;
      *(unsigned char *)(v42 + 264) = a6;
      llvm::MCSymbolXCOFF::setRepresentedCsect((uint64_t)Symbol, (llvm::MCSectionXCOFF *)v42);
      *(unsigned char *)(v42 + 24) = 2;
    }
    else
    {
      if ((v43 & 4) != 0)
      {
        long long v48 = (uint64_t *)*(Symbol - 1);
        uint64_t v49 = *v48;
        uint64_t v44 = (uint64_t)(v48 + 2);
        uint64_t v45 = v49;
      }
      else
      {
        uint64_t v44 = 0;
        uint64_t v45 = 0;
      }
      uint64_t v50 = sub_1CD586E78(v44, v45);
      sub_1CD6A8D08((llvm::MCSectionXCOFF *)v42, v50, v51, a5, HIBYTE(a5), a4, (uint64_t)Symbol, (uint64_t)TempSymbol, v56, v38, a6);
    }
    *((void *)v31 + 8) = v42;
    operator new();
  }
  if ((*(unsigned char *)(*((void *)v31 + 8) + 264) != 0) != a6) {
    llvm::report_fatal_error((llvm *)"section's multiply symbols policy does not match", (const llvm::Twine *)1);
  }
  return *((void *)v31 + 8);
}

void llvm::MCContext::getSPIRVSection(llvm::MCContext *this)
{
  uint64_t v1 = sub_1CB906F34((uint64_t *)this + 84, 224, 3);
  llvm::MCSection::MCSection(v1, 6, (uint64_t)&unk_1CFBF5F4A, 0, 2, 0);
  *uint64_t v2 = &unk_1F262E1F8;
  operator new();
}

void llvm::MCContext::addDebugPrefixMapEntry(uint64_t a1, long long *a2, long long *a3)
{
  uint64_t v3 = a1 + 1424;
  sub_1CCBB8DD4((uint64_t)v4, a2, a3);
  sub_1CD6A9EC0(v3, (uint64_t)v4);
  if (v7 < 0) {
    operator delete(__p);
  }
  if (v5 < 0) {
    operator delete(v4[0]);
  }
}

void llvm::MCContext::setGenDwarfRootFile(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v37[2] = *MEMORY[0x1E4F143B8];
  if (*(unsigned __int16 *)(a1 + 1624) < 5u)
  {
    unsigned __int8 v11 = 0;
    char v12 = 0;
  }
  else
  {
    double v10 = llvm::MD5::MD5((llvm::MD5 *)&v34);
    llvm::MD5::update(&v34, a4, a5, v10);
    llvm::MD5::final((int *)&v34, (int *)&v31);
    unsigned __int8 v11 = v31.n128_u8[0];
    v37[0] = *(unint64_t *)((char *)v31.n128_u64 + 1);
    *(void *)((char *)v37 + 7) = v31.n128_u64[1];
    char v12 = 1;
  }
  long long v34 = v36;
  long long v35 = xmmword_1CFB1BC20;
  sub_1CC22C75C(&v34, a2, &a2[a3]);
  if (!(void)v35 || (void)v35 == 1 && *(unsigned char *)v34 == 45)
  {
    *(void *)&long long v35 = 0;
    sub_1CC22C75C(&v34, "<stdin>", "");
  }
  uint64_t v13 = *(unsigned __int8 *)(a1 + 1471);
  if (*(char *)(a1 + 1471) < 0) {
    uint64_t v14 = *(void *)(a1 + 1456);
  }
  else {
    uint64_t v14 = *(unsigned __int8 *)(a1 + 1471);
  }
  uint64_t v15 = (char *)v34;
  size_t v16 = v35;
  if (v14)
  {
    if ((v13 & 0x80u) == 0) {
      std::string::size_type v17 = (const void *)(a1 + 1448);
    }
    else {
      std::string::size_type v17 = *(const void **)(a1 + 1448);
    }
    if ((v13 & 0x80u) != 0) {
      uint64_t v13 = *(void *)(a1 + 1456);
    }
    if ((void)v35 != v13 || (void)v35 && memcmp(v34, v17, v35))
    {
      llvm::sys::path::remove_filename((uint64_t)&v34, 0);
      __int16 v33 = 260;
      v31.n128_u64[0] = a1 + 1448;
      __int16 v30 = 257;
      __int16 v27 = 257;
      v25[16] = 257;
      llvm::sys::path::append(&v34, (const char **)&v31, (void **)&v28, (uint64_t)v26, (uint64_t)v25);
      uint64_t v15 = (char *)v34;
      size_t v16 = v35;
    }
  }
  size_t v18 = *(void *)(a1 + 1280);
  if (v16 >= v18 && (!v18 || !memcmp(v15, *(const void **)(a1 + 1272), *(void *)(a1 + 1280))))
  {
    size_t v22 = v16 >= v18 ? v18 : v16;
    v15 += v22;
    v16 -= v22;
    BOOL is_separator = llvm::sys::path::is_separator((llvm::sys::path *)*v15, 0);
    uint64_t v24 = (uint64_t)(v16 ? v15 + 1 : v15);
    if (is_separator)
    {
      v16 -= v16 != 0;
      uint64_t v15 = (char *)v24;
    }
  }
  uint64_t v19 = *(void **)(a1 + 1272);
  size_t v20 = *(void *)(a1 + 1280);
  LODWORD(v28) = 0;
  v31.n128_u64[0] = (unint64_t)&v28;
  char v21 = sub_1CCBB8E50((uint64_t **)(a1 + 1472), (unsigned int *)&v28, (uint64_t)&std::piecewise_construct, &v31);
  LOBYTE(v28) = v11;
  *(void *)((char *)&v28 + 1) = v37[0];
  *((void *)&v28 + 1) = *(void *)((char *)v37 + 7);
  char v29 = v12;
  v31.n128_u8[0] = 0;
  char v32 = 0;
  sub_1CCBB0D74((uint64_t)(v21 + 40), v19, v20, v15, v16, &v28, &v31);
  if (v34 != v36) {
    free(v34);
  }
}

BOOL llvm::MCContext::isValidDwarfFileNumber(uint64_t **this, unsigned int a2, unsigned int a3)
{
  unsigned int v9 = a3;
  double v10 = &v9;
  char v5 = sub_1CCBB8E50(this + 184, &v9, (uint64_t)&std::piecewise_construct, &v10);
  if (!a2) {
    return *((unsigned __int16 *)this + 812) > 4u;
  }
  if (*((_DWORD *)v5 + 36) <= a2) {
    return 0;
  }
  uint64_t v6 = *((void *)v5 + 17) + 72 * a2;
  if (*(char *)(v6 + 23) < 0) {
    uint64_t v7 = *(void *)(v6 + 8);
  }
  else {
    uint64_t v7 = *(unsigned __int8 *)(v6 + 23);
  }
  return v7 != 0;
}

uint64_t llvm::MCContext::finalizeDwarfSections(uint64_t this, llvm::MCStreamer *a2)
{
  uint64_t v2 = this;
  uint64_t v3 = *(void **)(this + 1544);
  uint64_t v4 = *(void **)(this + 1552);
  v6[0] = a2;
  v6[1] = this + 1520;
  if (v3 != v4)
  {
    while (1)
    {
      this = sub_1CCBB9804(v6, v3);
      char v5 = v3 + 1;
      if (this) {
        break;
      }
      ++v3;
      if (v5 == v4)
      {
        uint64_t v3 = v4;
        goto LABEL_9;
      }
    }
    while (v5 != v4)
    {
      this = sub_1CCBB9804(v6, v5);
      if ((this & 1) == 0) {
        *v3++ = *v5;
      }
      ++v5;
    }
  }
LABEL_9:
  if (v3 != *(void **)(v2 + 1552)) {
    *(void *)(v2 + 1552) = v3;
  }
  return this;
}

uint64_t llvm::MCContext::getCVContext(llvm::MCContext *this)
{
  uint64_t result = *((void *)this + 23);
  if (!result) {
    operator new();
  }
  return result;
}

void llvm::MCContext::diagnose(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[9];
  uint64_t v3 = v2;
  if (!v2) {
    uint64_t v3 = a1[10];
  }
  BOOL v8 = v2 == 0;
  uint64_t v4 = a1[17];
  if (v4)
  {
    (*(void (**)(void, uint64_t, BOOL *, uint64_t, void *))(*(void *)v4 + 48))(a1[17], a2, &v8, v3, a1 + 11);
  }
  else
  {
    sub_1CB920400();
    llvm::MCContext::reportCommon(v5, v6, v7);
  }
}

void llvm::MCContext::reportCommon(void *a1, uint64_t a2, uint64_t a3)
{
  v20[21] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = v9;
  llvm::SourceMgr::SourceMgr((llvm::SourceMgr *)v9);
  if (a2)
  {
    uint64_t v6 = (unsigned char *)a1[9];
    if (v6)
    {
      LOBYTE(a2) = 0;
    }
    else
    {
      uint64_t v6 = (unsigned char *)a1[10];
      LOBYTE(a2) = 1;
    }
  }
  int v12 = 0;
  memset(v11, 0, sizeof(v11));
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  uint64_t v17 = 0;
  size_t v18 = v20;
  uint64_t v19 = 0x400000000;
  double v10 = v6;
  uint64_t v7 = *(void *)(a3 + 24);
  if (!v7
    || ((*(void (**)(uint64_t, _OWORD *, unsigned char **))(*(void *)v7 + 48))(v7, v11, &v10),
        LOBYTE(v10) = a2,
        (uint64_t v8 = a1[17]) == 0))
  {
    sub_1CB920400();
  }
  (*(void (**)(uint64_t, _OWORD *, unsigned char **, unsigned char *, void *))(*(void *)v8 + 48))(v8, v11, &v10, v6, a1 + 11);
  sub_1CC192528((uint64_t)v11);
  llvm::SourceMgr::~SourceMgr((llvm::SourceMgr *)v9);
}

void *llvm::MCContext::reportWarning(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a2;
  uint64_t v3 = (__int16 *)result[244];
  if (!v3) {
    goto LABEL_5;
  }
  __int16 v4 = *v3;
  if ((v4 & 8) != 0) {
    return result;
  }
  if ((v4 & 4) != 0)
  {
    return (void *)llvm::MCContext::reportError((uint64_t)result, a2, a3);
  }
  else
  {
LABEL_5:
    v6[0] = &unk_1F262E2B8;
    v6[1] = &v5;
    void v6[2] = a3;
    uint64_t v7 = v6;
    llvm::MCContext::reportCommon(result, a2, (uint64_t)v6);
    uint64_t result = v7;
    if (v7 == v6)
    {
      return (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
    }
    else if (v7)
    {
      return (void *)(*(uint64_t (**)(void *))(*v7 + 40))(v7);
    }
  }
  return result;
}

void sub_1CD6A8A90(void *a1)
{
  if (a1)
  {
    sub_1CD6A8A90(*a1);
    sub_1CD6A8A90(a1[1]);
    sub_1CCBB8C08((uint64_t)(a1 + 5));
    operator delete(a1);
  }
}

uint64_t sub_1CD6A8AE8(uint64_t result, uint64_t a2, int a3)
{
  *(_DWORD *)(result + 8) = *(_DWORD *)(result + 8) & 0xFFFC0000 | a3 | 0x140;
  *(_WORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)uint64_t result = 4 * (a2 != 0);
  if (a2) {
    *(void *)(result - 8) = a2;
  }
  *(unsigned char *)(result + 32) = 0;
  *(unsigned char *)(result + 36) = 0;
  *(unsigned char *)(result + 48) = 0;
  *(unsigned char *)(result + 64) = 0;
  *(unsigned char *)(result + 72) = 0;
  *(unsigned char *)(result + 88) = 0;
  *(unsigned char *)(result + 96) = 0;
  *(unsigned char *)(result + 112) = 0;
  *(void *)(result + 120) = 0;
  *(unsigned char *)(result + 128) = 0;
  *(unsigned char *)(result + 130) = 0;
  *(unsigned char *)(result + 136) = 0;
  *(unsigned char *)(result + 168) = 0;
  *(void *)(result + 176) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_WORD *)(result + 44) = 0;
  return result;
}

uint64_t sub_1CD6A8B68(uint64_t result, uint64_t a2, int a3)
{
  *(_DWORD *)(result + 8) = *(_DWORD *)(result + 8) & 0xFFFC0000 | a3 | 0x180;
  *(_WORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)uint64_t result = 4 * (a2 != 0);
  if (a2) {
    *(void *)(result - 8) = a2;
  }
  *(_WORD *)(result + 32) = 0;
  *(void *)(result + 40) = 0;
  *(_WORD *)(result + 48) = 0;
  *(void *)(result + 56) = 0;
  *(void *)(result + 64) = 0;
  return result;
}

uint64_t sub_1CD6A8BB4(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7, uint64_t a8, char a9, int a10, uint64_t a11, uint64_t a12)
{
  llvm::MCSection::MCSection(a1, 1, a2, a3, a6, a11);
  *(void *)uint64_t v17 = &unk_1F262FB28;
  *(_DWORD *)(v17 + 224) = a4;
  *(_DWORD *)(v17 + 228) = a5;
  *(_DWORD *)(v17 + 232) = a10;
  *(_DWORD *)(v17 + 236) = a7;
  uint64_t v18 = 4;
  if (!a9) {
    uint64_t v18 = 0;
  }
  *(void *)(v17 + 240) = a8 & 0xFFFFFFFFFFFFFFFBLL | v18;
  *(void *)(v17 + 248) = a12;
  if ((a8 & 0xFFFFFFFFFFFFFFF8) != 0) {
    llvm::MCSymbolELF::setIsSignature(a8 & 0xFFFFFFFFFFFFFFF8);
  }
  return a1;
}

llvm::raw_ostream *sub_1CD6A8C6C(uint64_t a1, int a2, int a3, llvm::raw_ostream *a4)
{
  uint64_t v5 = sub_1CB8E509C(a4, "\t.section\t\"");
  uint64_t v6 = *(const void **)(a1 + 200);
  size_t v7 = *(void *)(a1 + 208);
  uint64_t v8 = (void *)*((void *)v5 + 4);
  if (v7 <= *((void *)v5 + 3) - (void)v8)
  {
    if (v7)
    {
      memcpy(v8, v6, v7);
      *((void *)v5 + 4) += v7;
    }
  }
  else
  {
    llvm::raw_ostream::write(v5, (const char *)v6, v7);
  }

  return sub_1CB8E509C(v5, "\"\n");
}

uint64_t sub_1CD6A8CF8()
{
  return 0;
}

uint64_t sub_1CD6A8D00()
{
  return 0;
}

llvm::MCSectionXCOFF *sub_1CD6A8D08(llvm::MCSectionXCOFF *a1, uint64_t a2, uint64_t a3, __int16 a4, int a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  llvm::MCSection::MCSection((uint64_t)a1, 5, a2, a3, a6, a8);
  *(void *)uint64_t v15 = &unk_1F262FBB8;
  *(_WORD *)(v15 + 224) = a4 | ((_WORD)a5 << 8);
  *(unsigned char *)(v15 + 226) = 1;
  *(void *)(v15 + 232) = a7;
  *(void *)(v15 + 240) = a9;
  *(void *)(v15 + 248) = a10;
  *(unsigned char *)(v15 + 256) = 0;
  *(unsigned char *)(v15 + 260) = 0;
  *(unsigned char *)(v15 + 264) = a11;
  llvm::MCSymbolXCOFF::setRepresentedCsect(a7, a1);
  if (!*(unsigned char *)(a7 + 33)) {
    *(unsigned char *)(a7 + 33) = 1;
  }
  *(unsigned char *)(a7 + 32) = 107;
  if (a5) {
    *((unsigned char *)a1 + 24) = 2;
  }
  return a1;
}

uint64_t sub_1CD6A8DE0()
{
  return 0;
}

uint64_t sub_1CD6A8DE8()
{
  return 0;
}

void sub_1CD6A8DF4()
{
}

void *sub_1CD6A8E08(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1F262E228;
  result[1] = v3;
  return result;
}

uint64_t sub_1CD6A8E54(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(a1 + 8))(a2, *a3, a4, a5);
}

void sub_1CD6A8E70(void *a1)
{
  if (a1)
  {
    sub_1CD6A8E70(*a1);
    sub_1CD6A8E70(a1[1]);
    sub_1CD3C4FA4((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

uint64_t sub_1CD6A8EC8(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 12))
  {
    uint64_t v3 = *(unsigned int *)(a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t v6 = *(void *)(*(void *)a1 + v4);
        if (v6 != -8 && v6 != 0)
        {
          uint64_t v8 = (void **)(v6 + 64);
          sub_1CB8338B8(&v8);
          uint64_t v8 = (void **)(v6 + 40);
          sub_1CCBB91F0(&v8);
          MEMORY[0x1D25D9CD0](v6, 8);
        }
        v4 += 8;
      }
      while (v5 != v4);
    }
  }
  free(*(void **)a1);
  return a1;
}

_DWORD *sub_1CD6A8F6C(_DWORD *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[4];
  int v3 = result[2];
  int v4 = 1 << (33 - __clz(v3 - 1));
  if (v4 <= 64) {
    int v4 = 64;
  }
  if (v3) {
    int v5 = v4;
  }
  else {
    int v5 = 0;
  }
  if (v5 == v2)
  {
    *((void *)result + 1) = 0;
    if (v2)
    {
      uint64_t v6 = *(_OWORD **)result;
      uint64_t v7 = 16 * v2;
      do
      {
        *v6++ = xmmword_1CFAC4A20;
        v7 -= 16;
      }
      while (v7);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)result, 8);
    return sub_1CCBB8B70(v1, v5);
  }
  return result;
}

_DWORD *sub_1CD6A901C(uint64_t a1, int *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD50FE20(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v7);
  int v5 = v7;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CD50FF04(a1, a2, v7);
    *int v5 = *a2;
    v5[1] = a2[1];
    *((void *)v5 + 1) = 0;
  }
  return v5;
}

void *sub_1CD6A9094(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  int v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  int v5 = (void *)(a1 + 8);
  do
  {
    BOOL v6 = sub_1CD6A9114((uint64_t)(v3 + 4), a2);
    uint64_t v7 = v3 + 1;
    if (!v6)
    {
      uint64_t v7 = v3;
      int v5 = v3;
    }
    int v3 = (void *)*v7;
  }
  while (*v7);
  if (v5 == v2 || sub_1CD6A9114((uint64_t)a2, v5 + 4)) {
    return v2;
  }
  return v5;
}

BOOL sub_1CD6A9114(uint64_t a1, uint64_t *a2)
{
  if (!sub_1CBAD746C((unsigned __int8 *)a1, (unsigned __int8 *)a2))
  {
    char v15 = *((unsigned char *)a2 + 23);
    BOOL v16 = v15 < 0;
    uint64_t v17 = (uint64_t *)*a2;
    if (v15 >= 0) {
      uint64_t v17 = a2;
    }
    uint64_t v18 = v15 & 0x7F;
    if (v16) {
      uint64_t v18 = a2[1];
    }
    v22[0] = v17;
    v22[1] = v18;
    return sub_1CC0C5278((const void **)a1, (uint64_t)v22) >> 31;
  }
  int v5 = *(const void **)(a1 + 24);
  size_t v4 = *(void *)(a1 + 32);
  BOOL v6 = (const void *)a2[3];
  size_t v7 = a2[4];
  if (v4 != v7)
  {
    if (v7 >= v4) {
      size_t v9 = *(void *)(a1 + 32);
    }
    else {
      size_t v9 = a2[4];
    }
    if (!v9)
    {
LABEL_24:
      if (v4 < v7) {
        int v21 = -1;
      }
      else {
        int v21 = 1;
      }
      return v21 == -1;
    }
LABEL_20:
    int v20 = memcmp(v5, v6, v9);
    int v21 = (v20 >> 31) | 1;
    if (!v20) {
      int v21 = 0;
    }
    if (v4 == v7 || v20) {
      return v21 == -1;
    }
    goto LABEL_24;
  }
  if (v4)
  {
    int v8 = memcmp(*(const void **)(a1 + 24), (const void *)a2[3], *(void *)(a1 + 32));
    size_t v9 = v4;
    if (v8) {
      goto LABEL_20;
    }
  }
  unint64_t v10 = a2[6];
  unint64_t v11 = *(void *)(a1 + 48);
  if (v10 >= v11) {
    size_t v12 = *(void *)(a1 + 48);
  }
  else {
    size_t v12 = a2[6];
  }
  if (v12 && (int v13 = memcmp(*(const void **)(a1 + 40), (const void *)a2[5], v12)) != 0)
  {
    unsigned int v14 = (v13 >> 31) | 1;
  }
  else
  {
    if (v11 == v10) {
      return *(_DWORD *)(a1 + 56) < *((_DWORD *)a2 + 14);
    }
    if (v11 < v10) {
      unsigned int v14 = -1;
    }
    else {
      unsigned int v14 = 1;
    }
  }
  return v14 >> 31;
}

_OWORD *sub_1CD6A925C(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  int v5 = (void **)sub_1CD6A9330(a1, &v12, a2);
  BOOL v6 = *v5;
  if (!*v5)
  {
    int v8 = v5;
    BOOL v6 = operator new(0x68uLL);
    void v6[2] = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(_OWORD *)((char *)v6 + 56) = *(_OWORD *)(a3 + 24);
    *(_OWORD *)((char *)v6 + 72) = *(_OWORD *)(a3 + 40);
    *((_DWORD *)v6 + 22) = *(_DWORD *)(a3 + 56);
    *((void *)v6 + 12) = *(void *)(a3 + 64);
    uint64_t v9 = v12;
    *(void *)BOOL v6 = 0;
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = v9;
    void *v8 = v6;
    unint64_t v10 = (uint64_t *)v6;
    uint64_t v11 = **(void **)a1;
    if (v11)
    {
      *(void *)a1 = v11;
      unint64_t v10 = (uint64_t *)*v8;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v10);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

void *sub_1CD6A9330(uint64_t a1, void *a2, uint64_t *a3)
{
  int v5 = (void *)(a1 + 8);
  size_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        size_t v7 = v4;
        uint64_t v8 = (uint64_t)(v4 + 4);
        if (!sub_1CD6A9114((uint64_t)a3, v4 + 4)) {
          break;
        }
        size_t v4 = (void *)*v7;
        int v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (!sub_1CD6A9114(v8, a3)) {
        break;
      }
      int v5 = v7 + 1;
      size_t v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    size_t v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t *sub_1CD6A93C4(uint64_t a1, unsigned __int8 *a2, size_t a3, char *a4)
{
  uint64_t v8 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  uint64_t i = (uint64_t *)(*(void *)a1 + 8 * v8);
  uint64_t v10 = *i;
  if (*i == -8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v10)
  {
    while (!v10 || v10 == -8)
    {
      uint64_t v11 = i[1];
      ++i;
      uint64_t v10 = v11;
    }
    return i;
  }
  uint64_t v12 = (char *)operator new(a3 + 17, (std::align_val_t)8uLL);
  int v13 = v12;
  unsigned int v14 = v12 + 16;
  if (a3) {
    memcpy(v12 + 16, a2, a3);
  }
  v14[a3] = 0;
  *(void *)int v13 = a3;
  v13[8] = *a4;
  *uint64_t i = (uint64_t)v13;
  ++*(_DWORD *)(a1 + 12);
  for (uint64_t i = (uint64_t *)(*(void *)a1
                      + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v8));
        !*i || *i == -8;
  return i;
}

_OWORD *sub_1CD6A94CC(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  int v5 = (void **)sub_1CD6A9330(a1, &v12, a2);
  BOOL v6 = *v5;
  if (!*v5)
  {
    uint64_t v8 = v5;
    BOOL v6 = operator new(0x68uLL);
    void v6[2] = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(_OWORD *)((char *)v6 + 56) = *(_OWORD *)(a3 + 24);
    *(_OWORD *)((char *)v6 + 72) = *(_OWORD *)(a3 + 40);
    *((_DWORD *)v6 + 22) = *(_DWORD *)(a3 + 56);
    *((void *)v6 + 12) = 0;
    uint64_t v9 = v12;
    *(void *)BOOL v6 = 0;
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = v9;
    void *v8 = v6;
    uint64_t v10 = (uint64_t *)v6;
    uint64_t v11 = **(void **)a1;
    if (v11)
    {
      *(void *)a1 = v11;
      uint64_t v10 = (uint64_t *)*v8;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v10);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

uint64_t **sub_1CD6A95A4(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t result = (uint64_t **)sub_1CD6A965C(a1, &v13, a2);
  if (!*result)
  {
    BOOL v6 = result;
    size_t v7 = operator new(0x48uLL);
    void v7[2] = *(_OWORD *)a3;
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    uint64_t v8 = *(void *)(a3 + 16);
    uint64_t v9 = *(void *)(a3 + 24);
    *(void *)(a3 + 16) = 0;
    *((void *)v7 + 6) = v8;
    *((void *)v7 + 7) = v9;
    *((_DWORD *)v7 + 16) = *(_DWORD *)(a3 + 32);
    uint64_t v10 = v13;
    *(void *)size_t v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = v10;
    *BOOL v6 = (uint64_t *)v7;
    uint64_t v11 = **(void **)a1;
    if (v11)
    {
      *(void *)a1 = v11;
      uint64_t v12 = *v6;
    }
    else
    {
      uint64_t v12 = (uint64_t *)v7;
    }
    uint64_t result = (uint64_t **)sub_1CB8358B8(*(uint64_t **)(a1 + 8), v12);
    ++*(void *)(a1 + 16);
  }
  return result;
}

void *sub_1CD6A965C(uint64_t a1, void *a2, uint64_t *a3)
{
  int v5 = (void *)(a1 + 8);
  size_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        size_t v7 = v4;
        uint64_t v8 = (uint64_t)(v4 + 4);
        if (!sub_1CD6A96F0((uint64_t)a3, v4 + 4)) {
          break;
        }
        size_t v4 = (void *)*v7;
        int v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (!sub_1CD6A96F0(v8, a3)) {
        break;
      }
      int v5 = v7 + 1;
      size_t v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    size_t v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

BOOL sub_1CD6A96F0(uint64_t a1, uint64_t *a2)
{
  if (sub_1CBAD746C((unsigned __int8 *)a1, (unsigned __int8 *)a2))
  {
    unsigned int v4 = *(_DWORD *)(a1 + 24);
    unsigned int v5 = *((_DWORD *)a2 + 6);
    BOOL v6 = v4 >= v5;
    if (v4 == v5) {
      BOOL v6 = *(_DWORD *)(a1 + 28) >= *((_DWORD *)a2 + 7);
    }
    return !v6;
  }
  else
  {
    char v8 = *((unsigned char *)a2 + 23);
    BOOL v9 = v8 < 0;
    uint64_t v10 = (uint64_t *)*a2;
    if (v8 >= 0) {
      uint64_t v10 = a2;
    }
    uint64_t v11 = v8 & 0x7F;
    if (v9) {
      uint64_t v11 = a2[1];
    }
    v12[0] = v10;
    v12[1] = v11;
    return sub_1CC0C5278((const void **)a1, (uint64_t)v12) >> 31;
  }
}

_OWORD *sub_1CD6A9778(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD **a4)
{
  BOOL v6 = (void **)sub_1CD4AF8D4(a1, &v15, a2);
  size_t v7 = *v6;
  if (!*v6)
  {
    BOOL v9 = v6;
    size_t v7 = operator new(0x40uLL);
    uint64_t v10 = *a4;
    uint64_t v11 = *((void *)*a4 + 2);
    void v7[2] = **a4;
    *((void *)v7 + 6) = v11;
    *uint64_t v10 = 0;
    v10[1] = 0;
    uint64_t v10[2] = 0;
    *((void *)v7 + 7) = 0;
    uint64_t v12 = v15;
    *(void *)size_t v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = v12;
    *BOOL v9 = v7;
    uint64_t v13 = **(void **)a1;
    unsigned int v14 = (uint64_t *)v7;
    if (v13)
    {
      *(void *)a1 = v13;
      unsigned int v14 = (uint64_t *)*v9;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v14);
    ++*(void *)(a1 + 16);
  }
  return v7;
}

_OWORD *sub_1CD6A983C(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  unsigned int v5 = (void **)sub_1CD6A9908(a1, &v12, a2);
  BOOL v6 = *v5;
  if (!*v5)
  {
    char v8 = v5;
    BOOL v6 = operator new(0x58uLL);
    void v6[2] = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(_OWORD *)((char *)v6 + 56) = *(_OWORD *)(a3 + 24);
    *((void *)v6 + 9) = *(void *)(a3 + 40);
    *((void *)v6 + 10) = 0;
    uint64_t v9 = v12;
    *(void *)BOOL v6 = 0;
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = v9;
    void *v8 = v6;
    uint64_t v10 = **(void **)a1;
    uint64_t v11 = (uint64_t *)v6;
    if (v10)
    {
      *(void *)a1 = v10;
      uint64_t v11 = (uint64_t *)*v8;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v11);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

void *sub_1CD6A9908(uint64_t a1, void *a2, uint64_t *a3)
{
  unsigned int v5 = (void *)(a1 + 8);
  unsigned int v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        size_t v7 = v4;
        uint64_t v8 = (uint64_t)(v4 + 4);
        if (!sub_1CD6A999C((uint64_t)a3, v4 + 4)) {
          break;
        }
        unsigned int v4 = (void *)*v7;
        unsigned int v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (!sub_1CD6A999C(v8, a3)) {
        break;
      }
      unsigned int v5 = v7 + 1;
      unsigned int v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    size_t v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

BOOL sub_1CD6A999C(uint64_t a1, uint64_t *a2)
{
  if (sub_1CBAD746C((unsigned __int8 *)a1, (unsigned __int8 *)a2))
  {
    unsigned int v5 = *(const void **)(a1 + 24);
    size_t v4 = *(void *)(a1 + 32);
    BOOL v6 = (const void *)a2[3];
    size_t v7 = a2[4];
    if (v4 == v7)
    {
      if (!v4 || (v8 = memcmp(*(const void **)(a1 + 24), (const void *)a2[3], *(void *)(a1 + 32)), size_t v9 = v4, !v8))
      {
        int v10 = *(_DWORD *)(a1 + 40);
        int v11 = *((_DWORD *)a2 + 10);
        if (v10 == v11) {
          return *(_DWORD *)(a1 + 44) < *((_DWORD *)a2 + 11);
        }
        else {
          return v10 < v11;
        }
      }
    }
    else
    {
      if (v7 >= v4) {
        size_t v9 = *(void *)(a1 + 32);
      }
      else {
        size_t v9 = a2[4];
      }
      if (!v9)
      {
LABEL_20:
        if (v4 < v7) {
          int v18 = -1;
        }
        else {
          int v18 = 1;
        }
        return v18 == -1;
      }
    }
    int v17 = memcmp(v5, v6, v9);
    int v18 = (v17 >> 31) | 1;
    if (!v17) {
      int v18 = 0;
    }
    if (v4 == v7 || v17) {
      return v18 == -1;
    }
    goto LABEL_20;
  }
  char v13 = *((unsigned char *)a2 + 23);
  BOOL v14 = v13 < 0;
  uint64_t v15 = (uint64_t *)*a2;
  if (v13 >= 0) {
    uint64_t v15 = a2;
  }
  uint64_t v16 = v13 & 0x7F;
  if (v14) {
    uint64_t v16 = a2[1];
  }
  v19[0] = v15;
  v19[1] = v16;
  return sub_1CC0C5278((const void **)a1, (uint64_t)v19) >> 31;
}

_OWORD *sub_1CD6A9AB4(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  unsigned int v5 = (void **)sub_1CD6A9B84(a1, &v12, a2);
  BOOL v6 = *v5;
  if (!*v5)
  {
    int v8 = v5;
    BOOL v6 = operator new(0x58uLL);
    void v6[2] = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(_OWORD *)((char *)v6 + 56) = *(_OWORD *)(a3 + 24);
    *((_DWORD *)v6 + 18) = *(_DWORD *)(a3 + 40);
    *((void *)v6 + 10) = 0;
    uint64_t v9 = v12;
    *(void *)BOOL v6 = 0;
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = v9;
    void *v8 = v6;
    uint64_t v10 = **(void **)a1;
    int v11 = (uint64_t *)v6;
    if (v10)
    {
      *(void *)a1 = v10;
      int v11 = (uint64_t *)*v8;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v11);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

void *sub_1CD6A9B84(uint64_t a1, void *a2, uint64_t *a3)
{
  unsigned int v5 = (void *)(a1 + 8);
  size_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        size_t v7 = v4;
        uint64_t v8 = (uint64_t)(v4 + 4);
        if (!sub_1CD6A9C18((uint64_t)a3, v4 + 4)) {
          break;
        }
        size_t v4 = (void *)*v7;
        unsigned int v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (!sub_1CD6A9C18(v8, a3)) {
        break;
      }
      unsigned int v5 = v7 + 1;
      size_t v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    size_t v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

BOOL sub_1CD6A9C18(uint64_t a1, uint64_t *a2)
{
  if (sub_1CBAD746C((unsigned __int8 *)a1, (unsigned __int8 *)a2))
  {
    unsigned int v5 = *(const void **)(a1 + 24);
    size_t v4 = *(void *)(a1 + 32);
    BOOL v6 = (const void *)a2[3];
    size_t v7 = a2[4];
    if (v4 == v7)
    {
      if (!v4) {
        return *(_DWORD *)(a1 + 40) < *((_DWORD *)a2 + 10);
      }
      int v8 = memcmp(*(const void **)(a1 + 24), (const void *)a2[3], *(void *)(a1 + 32));
      size_t v9 = v4;
      if (!v8) {
        return *(_DWORD *)(a1 + 40) < *((_DWORD *)a2 + 10);
      }
    }
    else
    {
      if (v7 >= v4) {
        size_t v9 = *(void *)(a1 + 32);
      }
      else {
        size_t v9 = a2[4];
      }
      if (!v9)
      {
LABEL_19:
        if (v4 < v7) {
          int v16 = -1;
        }
        else {
          int v16 = 1;
        }
        return v16 == -1;
      }
    }
    int v15 = memcmp(v5, v6, v9);
    int v16 = (v15 >> 31) | 1;
    if (!v15) {
      int v16 = 0;
    }
    if (v4 == v7 || v15) {
      return v16 == -1;
    }
    goto LABEL_19;
  }
  char v11 = *((unsigned char *)a2 + 23);
  BOOL v12 = v11 < 0;
  char v13 = (uint64_t *)*a2;
  if (v11 >= 0) {
    char v13 = a2;
  }
  uint64_t v14 = v11 & 0x7F;
  if (v12) {
    uint64_t v14 = a2[1];
  }
  v17[0] = v13;
  v17[1] = v14;
  return sub_1CC0C5278((const void **)a1, (uint64_t)v17) >> 31;
}

BOOL sub_1CD6A9D18(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 28);
  int v3 = *(unsigned __int8 *)(a2 + 28);
  if (*(unsigned char *)(a1 + 28)) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4) {
    return sub_1CCBB95EC((const void **)a1, (unsigned __int8 *)(a1 + 24), (const void **)a2, (unsigned __int8 *)(a2 + 24));
  }
  if (v2 == v3) {
    return sub_1CCBB96F8((const void **)a1, (_DWORD *)(a1 + 24), (const void **)a2, (_DWORD *)(a2 + 24));
  }
  return v2 != 0;
}

_OWORD *sub_1CD6A9D5C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v5 = (void **)sub_1CD6A9E2C(a1, &v12, a2);
  BOOL v6 = *v5;
  if (!*v5)
  {
    int v8 = v5;
    BOOL v6 = operator new(0x48uLL);
    void v6[2] = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *((_DWORD *)v6 + 14) = *(_DWORD *)(a3 + 24);
    *((unsigned char *)v6 + 60) = *(unsigned char *)(a3 + 28);
    *((void *)v6 + 8) = 0;
    uint64_t v9 = v12;
    *(void *)BOOL v6 = 0;
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = v9;
    void *v8 = v6;
    uint64_t v10 = **(void **)a1;
    char v11 = (uint64_t *)v6;
    if (v10)
    {
      *(void *)a1 = v10;
      char v11 = (uint64_t *)*v8;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v11);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

void *sub_1CD6A9E2C(uint64_t a1, void *a2, uint64_t a3)
{
  unsigned int v5 = (void *)(a1 + 8);
  BOOL v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        size_t v7 = v4;
        uint64_t v8 = (uint64_t)(v4 + 4);
        if (!sub_1CD6A9D18(a3, (uint64_t)(v4 + 4))) {
          break;
        }
        BOOL v4 = (void *)*v7;
        unsigned int v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (!sub_1CD6A9D18(v8, a3)) {
        break;
      }
      unsigned int v5 = v7 + 1;
      BOOL v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    size_t v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

void sub_1CD6A9EC0(uint64_t a1, uint64_t a2)
{
  BOOL v4 = operator new(0x50uLL);
  *((_OWORD *)v4 + 2) = *(_OWORD *)a2;
  v4[6] = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(_OWORD *)(v4 + 7) = *(_OWORD *)(a2 + 24);
  v4[9] = *(void *)(a2 + 40);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  unsigned int v5 = sub_1CD4AF8D4(a1, &v8, (uint64_t)(v4 + 4));
  if (*v5)
  {
    sub_1CD3C4FA4((uint64_t)(v4 + 4));
    operator delete(v4);
  }
  else
  {
    uint64_t v6 = v8;
    *BOOL v4 = 0;
    v4[1] = 0;
    _OWORD v4[2] = v6;
    *unsigned int v5 = v4;
    uint64_t v7 = **(void **)a1;
    if (v7)
    {
      *(void *)a1 = v7;
      BOOL v4 = (void *)*v5;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v4);
    ++*(void *)(a1 + 16);
  }
}

uint64_t llvm::mcdwarf::emitListsTableHeaderStart(llvm::mcdwarf *this, llvm::MCStreamer *a2)
{
  int v3 = (llvm::MCContext *)*((void *)this + 1);
  v10[0] = "debug_list_header_start";
  __int16 v11 = 259;
  uint64_t TempSymbol = llvm::MCContext::createTempSymbol(v3, (const llvm::Twine *)v10, 1);
  unsigned int v5 = (llvm::MCContext *)*((void *)this + 1);
  v10[0] = "debug_list_header_end";
  __int16 v11 = 259;
  uint64_t v6 = llvm::MCContext::createTempSymbol(v5, (const llvm::Twine *)v10, 1);
  int v7 = *(unsigned __int8 *)(*((void *)this + 1) + 1626);
  if (v7 == 1)
  {
    v10[0] = "DWARF64 mark";
    __int16 v11 = 259;
    (*(void (**)(llvm::mcdwarf *, void *, uint64_t))(*(void *)this + 112))(this, v10, 1);
    (*(void (**)(llvm::mcdwarf *, uint64_t, uint64_t))(*(void *)this + 520))(this, 0xFFFFFFFFLL, 4);
  }
  v10[0] = "Length";
  __int16 v11 = 259;
  (*(void (**)(llvm::mcdwarf *, void *, uint64_t))(*(void *)this + 112))(this, v10, 1);
  if (v7) {
    uint64_t v8 = 8;
  }
  else {
    uint64_t v8 = 4;
  }
  (*(void (**)(llvm::mcdwarf *, uint64_t, uint64_t, uint64_t))(*(void *)this + 840))(this, v6, TempSymbol, v8);
  (*(void (**)(llvm::mcdwarf *, uint64_t, void))(*(void *)this + 192))(this, TempSymbol, 0);
  v10[0] = "Version";
  __int16 v11 = 259;
  (*(void (**)(llvm::mcdwarf *, void *, uint64_t))(*(void *)this + 112))(this, v10, 1);
  (*(void (**)(llvm::mcdwarf *, void, uint64_t))(*(void *)this + 520))(this, *(unsigned __int16 *)(*((void *)this + 1) + 1624), 2);
  v10[0] = "Address size";
  __int16 v11 = 259;
  (*(void (**)(llvm::mcdwarf *, void *, uint64_t))(*(void *)this + 112))(this, v10, 1);
  (*(void (**)(llvm::mcdwarf *, void, uint64_t))(*(void *)this + 520))(this, *(unsigned int *)(*(void *)(*((void *)this + 1) + 152) + 8), 1);
  v10[0] = "Segment selector size";
  __int16 v11 = 259;
  (*(void (**)(llvm::mcdwarf *, void *, uint64_t))(*(void *)this + 112))(this, v10, 1);
  (*(void (**)(llvm::mcdwarf *, void, uint64_t))(*(void *)this + 520))(this, 0, 1);
  return v6;
}

void llvm::MCDwarfLineStr::emitSection(llvm::MCDwarfLineStr *this, llvm::MCStreamer *a2)
{
  (*(void (**)(llvm::MCStreamer *, void, void))(*(void *)a2 + 168))(a2, *(void *)(*(void *)(*((void *)a2 + 1) + 168) + 96), 0);
  llvm::StringTableBuilder::finalizeInOrder((llvm::MCDwarfLineStr *)((char *)this + 8));
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  BOOL v4 = (unsigned __int8 *)&v7;
  sub_1CC22C7F8(&v4, *((void *)this + 4));
  llvm::StringTableBuilder::write((unsigned int *)this + 2, v4);
  (*(void (**)(llvm::MCStreamer *, unsigned __int8 *, uint64_t))(*(void *)a2 + 504))(a2, v4, v5);
  if (v4 != (unsigned __int8 *)&v7) {
    free(v4);
  }
}

void llvm::MCDwarfDwoLineTable::Emit(llvm::MCDwarfLineTableHeader *a1, llvm::MCStreamer *a2, int a3, uint64_t a4)
{
  if (*((unsigned char *)a1 + 464))
  {
    v7[0] = 0;
    char v9 = 0;
    (*(void (**)(llvm::MCStreamer *, uint64_t, void))(*(void *)a2 + 168))(a2, a4, 0);
    llvm::MCDwarfLineTableHeader::Emit(a1, a2, a3 & 0xFFFFFF, 0, 0, (uint64_t)v7);
    (*(void (**)(llvm::MCStreamer *))(*(void *)a2 + 192))(a2);
    if (v9) {
      llvm::StringTableBuilder::~StringTableBuilder((llvm::StringTableBuilder *)&v8);
    }
  }
}

uint64_t llvm::MCDwarfLineStr::emitRef(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  unsigned int v4 = a4;
  if (*(unsigned char *)(a2[1] + 1626)) {
    uint64_t v8 = 8;
  }
  else {
    uint64_t v8 = 4;
  }
  uint64_t v9 = a1 + 8;
  unsigned int HashValue = llvm::DenseMapInfo<llvm::StringRef,void>::getHashValue(a3, a4);
  unint64_t v11 = llvm::StringTableBuilder::add(v9, (uint64_t)a3, v4 | ((unint64_t)HashValue << 32));
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t v12 = a2[1];
    unint64_t v13 = llvm::MCSymbolRefExpr::create(*(void *)a1, 0, v12, 0);
    unint64_t v14 = llvm::MCConstantExpr::create((llvm::MCConstantExpr *)(int)v11, v12, 0, 0);
    unint64_t v15 = llvm::MCBinaryExpr::create(0, v13, v14, v12, 0);
    int v16 = *(uint64_t (**)(void *, unint64_t, uint64_t, void))(*a2 + 512);
    return v16(a2, v15, v8, 0);
  }
  else
  {
    int v18 = *(uint64_t (**)(void *, unint64_t, uint64_t))(*a2 + 520);
    return v18(a2, v11, v8);
  }
}

uint64_t llvm::MCGenDwarfInfo::Emit(llvm::MCGenDwarfInfo *this, llvm::MCStreamer *a2)
{
  int v3 = (llvm::MCContext *)*((void *)this + 1);
  uint64_t v4 = *((void *)v3 + 19);
  int v5 = *(unsigned __int8 *)(v4 + 424);
  if (*(unsigned char *)(v4 + 424))
  {
    uint64_t v6 = (*(uint64_t (**)(llvm::MCGenDwarfInfo *, void))(*(void *)this + 856))(this, 0);
    uint64_t v7 = *((void *)this + 1);
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v7 = *((void *)this + 1);
  }
  uint64_t result = llvm::MCContext::finalizeDwarfSections(v7, this);
  uint64_t v9 = *((void *)this + 1);
  uint64_t v10 = *(void *)(v9 + 1544);
  uint64_t v11 = *(void *)(v9 + 1552);
  if (v10 != v11)
  {
    BOOL v12 = (unint64_t)(v11 - v10) >= 9 && *(unsigned __int16 *)(v9 + 1624) > 2u;
    BOOL v88 = v12;
    if (v5) {
      int v13 = 1;
    }
    else {
      int v13 = v12;
    }
    (*(void (**)(llvm::MCGenDwarfInfo *, void, void))(*(void *)this + 168))(this, *(void *)(*((void *)v3 + 21) + 80), 0);
    uint64_t TempSymbol = 0;
    if (v13 == 1)
    {
      v92[0] = "tmp";
      __int16 v93 = 259;
      uint64_t TempSymbol = llvm::MCContext::createTempSymbol(v3, (const llvm::Twine *)v92, 1);
      (*(void (**)(llvm::MCGenDwarfInfo *, uint64_t, void))(*(void *)this + 192))(this, TempSymbol, 0);
    }
    uint64_t v86 = (const llvm::MCSymbol *)v6;
    uint64_t v87 = (llvm::MCSymbol *)TempSymbol;
    (*(void (**)(llvm::MCGenDwarfInfo *, void, void))(*(void *)this + 168))(this, *(void *)(*((void *)v3 + 21) + 72), 0);
    unsigned int v90 = 0;
    if (v13)
    {
      v92[0] = "tmp";
      __int16 v93 = 259;
      unsigned int v90 = (llvm::MCSymbol *)llvm::MCContext::createTempSymbol(v3, (const llvm::Twine *)v92, 1);
      (*(void (**)(llvm::MCGenDwarfInfo *))(*(void *)this + 192))(this);
    }
    (*(void (**)(llvm::MCGenDwarfInfo *, void, void))(*(void *)this + 168))(this, *(void *)(*((void *)v3 + 21) + 144), 0);
    uint64_t v15 = *((void *)this + 1);
    (*(void (**)(llvm::MCGenDwarfInfo *, void, void))(*(void *)this + 168))(this, *(void *)(*(void *)(v15 + 168) + 144), 0);
    int v16 = *(unsigned __int8 *)(v15 + 1626);
    if (*(unsigned char *)(v15 + 1626)) {
      uint64_t v17 = 8;
    }
    else {
      uint64_t v17 = 4;
    }
    if (*(unsigned char *)(v15 + 1626)) {
      int v18 = 24;
    }
    else {
      int v18 = 12;
    }
    uint64_t v19 = *(void *)(v15 + 152);
    uint64_t v20 = *(int *)(v19 + 8);
    int v21 = 2 * v20;
    int v22 = 2 * v20 - 1;
    if ((v22 & v18) != 0) {
      int v23 = 2 * v20 - (v22 & v18);
    }
    else {
      int v23 = 0;
    }
    int v24 = v21 * ((*(void *)(v15 + 1552) - *(void *)(v15 + 1544)) >> 3);
    if (v16 == 1) {
      (*(void (**)(llvm::MCGenDwarfInfo *, uint64_t, uint64_t))(*(void *)this + 520))(this, 0xFFFFFFFFLL, 4);
    }
    if (v16) {
      int v25 = 12;
    }
    else {
      int v25 = 8;
    }
    (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, (v25 + v21 + v23 + v24), v17);
    (*(void (**)(llvm::MCGenDwarfInfo *, uint64_t, uint64_t))(*(void *)this + 520))(this, 2, 2);
    if (v87) {
      llvm::MCStreamer::emitSymbolValue(this, v87, v17, *(unsigned char *)(v19 + 338));
    }
    else {
      (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, 0, v17);
    }
    (*(void (**)(llvm::MCGenDwarfInfo *, uint64_t, uint64_t))(*(void *)this + 520))(this, v20, 1);
    (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, 0, 1);
    if (v23 >= 1)
    {
      do
      {
        (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, 0, 1);
        --v23;
      }
      while (v23);
    }
    char v26 = *(llvm::MCSection ***)(v15 + 1544);
    __int16 v27 = *(llvm::MCSection ***)(v15 + 1552);
    while (v26 != v27)
    {
      long long v28 = *v26++;
      uint64_t v29 = *((void *)v28 + 1);
      Enduint64_t Symbol = llvm::MCSection::getEndSymbol(v28, (llvm::MCContext *)v15);
      unint64_t v31 = llvm::MCSymbolRefExpr::create(v29, 0, v15, 0);
      unint64_t v32 = sub_1CCBBEE8C(v15, v29, EndSymbol, 0);
      (*(void (**)(llvm::MCGenDwarfInfo *, unint64_t, uint64_t, void))(*(void *)this + 512))(this, v31, v20, 0);
      sub_1CCBBF2C4(this, v32, v20);
    }
    (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, 0, v20);
    (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, 0, v20);
    __int16 v33 = 0;
    if (v88)
    {
      uint64_t v34 = *((void *)this + 1);
      uint64_t v35 = *(int *)(*(void *)(v34 + 152) + 8);
      uint64_t v36 = *(void *)(v34 + 168);
      uint64_t v37 = *(void (**)(llvm::MCGenDwarfInfo *, void, void))(*(void *)this + 168);
      if (*(unsigned __int16 *)(v34 + 1624) >= 5u)
      {
        v37(this, *(void *)(v36 + 312), 0);
        uint64_t v89 = llvm::mcdwarf::emitListsTableHeaderStart(this, v78);
        v92[0] = "Offset entry count";
        __int16 v93 = 259;
        (*(void (**)(llvm::MCGenDwarfInfo *, _DWORD **, uint64_t))(*(void *)this + 112))(this, v92, 1);
        (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, 0, 4);
        v92[0] = "debug_rnglist0_start";
        __int16 v93 = 259;
        __int16 v33 = (const llvm::MCSymbol *)llvm::MCContext::createTempSymbol((llvm::MCContext *)v34, (const llvm::Twine *)v92, 1);
        (*(void (**)(llvm::MCGenDwarfInfo *, const llvm::MCSymbol *, void))(*(void *)this + 192))(this, v33, 0);
        uint64_t v79 = *(llvm::MCSection ***)(v34 + 1544);
        uint64_t v80 = *(llvm::MCSection ***)(v34 + 1552);
        while (v79 != v80)
        {
          uint64_t v81 = *v79++;
          uint64_t v82 = *((void *)v81 + 1);
          uint64_t v83 = llvm::MCSection::getEndSymbol(v81, (llvm::MCContext *)v34);
          unint64_t v84 = llvm::MCSymbolRefExpr::create(v82, 0, v34, 0);
          unint64_t v85 = sub_1CCBBEE8C(v34, v82, v83, 0);
          (*(void (**)(llvm::MCGenDwarfInfo *, uint64_t, uint64_t))(*(void *)this + 520))(this, 7, 1);
          (*(void (**)(llvm::MCGenDwarfInfo *, unint64_t, uint64_t, void))(*(void *)this + 512))(this, v84, v35, 0);
          (*(void (**)(llvm::MCGenDwarfInfo *, unint64_t))(*(void *)this + 552))(this, v85);
        }
        (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, 0, 1);
        (*(void (**)(llvm::MCGenDwarfInfo *, uint64_t, void))(*(void *)this + 192))(this, v89, 0);
      }
      else
      {
        v37(this, *(void *)(v36 + 152), 0);
        v92[0] = "debug_ranges_start";
        __int16 v93 = 259;
        __int16 v33 = (const llvm::MCSymbol *)llvm::MCContext::createTempSymbol((llvm::MCContext *)v34, (const llvm::Twine *)v92, 1);
        (*(void (**)(llvm::MCGenDwarfInfo *, const llvm::MCSymbol *, void))(*(void *)this + 192))(this, v33, 0);
        uint64_t v38 = *(llvm::MCSection ***)(v34 + 1544);
        uint64_t v39 = *(llvm::MCSection ***)(v34 + 1552);
        while (v38 != v39)
        {
          unint64_t v40 = *v38++;
          uint64_t v41 = *((void *)v40 + 1);
          uint64_t v42 = llvm::MCSection::getEndSymbol(v40, (llvm::MCContext *)v34);
          unint64_t v43 = llvm::MCSymbolRefExpr::create(v41, 0, v34, 0);
          llvm::MCStreamer::emitFill(this, (llvm::MCConstantExpr *)v35, 0xFFu);
          (*(void (**)(llvm::MCGenDwarfInfo *, unint64_t, uint64_t, void))(*(void *)this + 512))(this, v43, v35, 0);
          unint64_t v44 = sub_1CCBBEE8C(v34, v41, v42, 0);
          (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, 0, v35);
          sub_1CCBBF2C4(this, v44, v35);
        }
        (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, 0, v35);
        (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, 0, v35);
      }
    }
    uint64_t v45 = *((void *)this + 1);
    (*(void (**)(llvm::MCGenDwarfInfo *, void, void))(*(void *)this + 168))(this, *(void *)(*(void *)(v45 + 168) + 72), 0);
    llvm::MCStreamer::emitULEB128IntValue(this, 1uLL, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, 0x11uLL, 0);
    (*(void (**)(llvm::MCGenDwarfInfo *, uint64_t, uint64_t))(*(void *)this + 520))(this, 1, 1);
    if (*(unsigned __int16 *)(v45 + 1624) <= 3u)
    {
      if (*(unsigned char *)(v45 + 1626) == 1) {
        unint64_t v46 = 7;
      }
      else {
        unint64_t v46 = 6;
      }
    }
    else
    {
      unint64_t v46 = 23;
    }
    llvm::MCStreamer::emitULEB128IntValue(this, 0x10uLL, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, v46, 0);
    if (*(void *)(v45 + 1552) - *(void *)(v45 + 1544) < 9uLL || *(unsigned __int16 *)(v45 + 1624) <= 2u)
    {
      llvm::MCStreamer::emitULEB128IntValue(this, 0x11uLL, 0);
      unint64_t v46 = 1;
      llvm::MCStreamer::emitULEB128IntValue(this, 1uLL, 0);
      unint64_t v47 = 18;
    }
    else
    {
      unint64_t v47 = 85;
    }
    llvm::MCStreamer::emitULEB128IntValue(this, v47, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, v46, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, 3uLL, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, 8uLL, 0);
    if (*(void *)(v45 + 1280))
    {
      llvm::MCStreamer::emitULEB128IntValue(this, 0x1BuLL, 0);
      llvm::MCStreamer::emitULEB128IntValue(this, 8uLL, 0);
    }
    if (*(void *)(v45 + 1600))
    {
      llvm::MCStreamer::emitULEB128IntValue(this, 0x3FE2uLL, 0);
      llvm::MCStreamer::emitULEB128IntValue(this, 8uLL, 0);
    }
    llvm::MCStreamer::emitULEB128IntValue(this, 0x25uLL, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, 8uLL, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, 0x13uLL, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, 5uLL, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, 0, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, 0, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, 2uLL, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, 0xAuLL, 0);
    (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, 0, 1);
    llvm::MCStreamer::emitULEB128IntValue(this, 3uLL, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, 8uLL, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, 0x3AuLL, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, 6uLL, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, 0x3BuLL, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, 6uLL, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, 0x11uLL, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, 1uLL, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, 0, 0);
    llvm::MCStreamer::emitULEB128IntValue(this, 0, 0);
    (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, 0, 1);
    uint64_t v48 = *((void *)this + 1);
    (*(void (**)(llvm::MCGenDwarfInfo *, void, void))(*(void *)this + 168))(this, *(void *)(*(void *)(v48 + 168) + 80), 0);
    v92[0] = "tmp";
    __int16 v93 = 259;
    uint64_t v49 = llvm::MCContext::createTempSymbol((llvm::MCContext *)v48, (const llvm::Twine *)v92, 1);
    (*(void (**)(llvm::MCGenDwarfInfo *, uint64_t, void))(*(void *)this + 192))(this, v49, 0);
    v92[0] = "tmp";
    __int16 v93 = 259;
    uint64_t v50 = llvm::MCContext::createTempSymbol((llvm::MCContext *)v48, (const llvm::Twine *)v92, 1);
    if (*(unsigned char *)(v48 + 1626)) {
      size_t v51 = 12;
    }
    else {
      size_t v51 = 4;
    }
    if (*(unsigned char *)(v48 + 1626)) {
      uint64_t v52 = 8;
    }
    else {
      uint64_t v52 = 4;
    }
    if (*(unsigned char *)(v48 + 1626) == 1) {
      (*(void (**)(llvm::MCGenDwarfInfo *, uint64_t, uint64_t))(*(void *)this + 520))(this, 0xFFFFFFFFLL, 4);
    }
    unint64_t v53 = sub_1CCBBEE8C(v48, v49, v50, v51);
    sub_1CCBBF2C4(this, v53, v52);
    (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, *(unsigned __int16 *)(v48 + 1624), 2);
    uint64_t v54 = *(void *)(v48 + 152);
    uint64_t v55 = *(int *)(v54 + 8);
    if (*(unsigned __int16 *)(v48 + 1624) >= 5u)
    {
      (*(void (**)(llvm::MCGenDwarfInfo *, uint64_t, uint64_t))(*(void *)this + 520))(this, 1, 1);
      (*(void (**)(llvm::MCGenDwarfInfo *, uint64_t, uint64_t))(*(void *)this + 520))(this, v55, 1);
    }
    if (v90) {
      llvm::MCStreamer::emitSymbolValue(this, v90, v52, *(unsigned char *)(v54 + 338));
    }
    else {
      (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, 0, v52);
    }
    if (*(unsigned __int16 *)(v48 + 1624) <= 4u) {
      (*(void (**)(llvm::MCGenDwarfInfo *, uint64_t, uint64_t))(*(void *)this + 520))(this, v55, 1);
    }
    llvm::MCStreamer::emitULEB128IntValue(this, 1uLL, 0);
    if (v86) {
      llvm::MCStreamer::emitSymbolValue(this, v86, v52, *(unsigned char *)(v54 + 338));
    }
    else {
      (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, 0, v52);
    }
    if (v33)
    {
      llvm::MCStreamer::emitSymbolValue(this, v33, v52, 0);
    }
    else
    {
      uint64_t v73 = *(llvm::MCSection ***)(v48 + 1544);
      uint64_t v74 = *((void *)*v73 + 1);
      uint64_t v75 = llvm::MCSection::getEndSymbol(*v73, (llvm::MCContext *)v48);
      unint64_t v76 = llvm::MCSymbolRefExpr::create(v74, 0, v48, 0);
      (*(void (**)(llvm::MCGenDwarfInfo *, unint64_t, uint64_t, void))(*(void *)this + 512))(this, v76, v55, 0);
      unint64_t v77 = llvm::MCSymbolRefExpr::create(v75, 0, v48, 0);
      (*(void (**)(llvm::MCGenDwarfInfo *, unint64_t, uint64_t, void))(*(void *)this + 512))(this, v77, v55, 0);
    }
    unsigned int v91 = 0;
    v92[0] = &v91;
    uint64_t v56 = sub_1CCBB8E50((uint64_t **)(v48 + 1472), &v91, (uint64_t)&std::piecewise_construct, v92);
    if (*((_DWORD *)v56 + 14))
    {
      unint64_t v57 = (uint64_t *)*((void *)v56 + 6);
      char v58 = *((unsigned char *)v57 + 23);
      if (v58 >= 0) {
        uint64_t v59 = *((void *)v56 + 6);
      }
      else {
        uint64_t v59 = *v57;
      }
      if (v58 >= 0) {
        uint64_t v60 = v58 & 0x7F;
      }
      else {
        uint64_t v60 = v57[1];
      }
      (*(void (**)(llvm::MCGenDwarfInfo *, uint64_t, uint64_t))(*(void *)this + 488))(this, v59, v60);
      separator = llvm::sys::path::get_separator(0);
      (*(void (**)(llvm::MCGenDwarfInfo *, const char *, uint64_t))(*(void *)this + 488))(this, separator, v62);
    }
    unsigned int v91 = 0;
    v92[0] = &v91;
    std::string v63 = sub_1CCBB8E50((uint64_t **)(v48 + 1472), &v91, (uint64_t)&std::piecewise_construct, v92);
    if (*((_DWORD *)v63 + 36))
    {
      int v64 = (char *)(*((void *)v63 + 17) + 72);
    }
    else
    {
      unsigned int v91 = 0;
      v92[0] = &v91;
      int v64 = sub_1CCBB8E50((uint64_t **)(v48 + 1472), &v91, (uint64_t)&std::piecewise_construct, v92) + 424;
    }
    char v65 = v64[23];
    if (v65 >= 0) {
      std::string v66 = v64;
    }
    else {
      std::string v66 = *(char **)v64;
    }
    if (v65 >= 0) {
      uint64_t v67 = v65 & 0x7F;
    }
    else {
      uint64_t v67 = *((void *)v64 + 1);
    }
    (*(void (**)(llvm::MCGenDwarfInfo *, char *, uint64_t))(*(void *)this + 488))(this, v66, v67);
    (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, 0, 1);
    if (*(void *)(v48 + 1280))
    {
      (*(void (**)(llvm::MCGenDwarfInfo *, void))(*(void *)this + 488))(this, *(void *)(v48 + 1272));
      (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, 0, 1);
    }
    if (*(void *)(v48 + 1600))
    {
      (*(void (**)(llvm::MCGenDwarfInfo *, void))(*(void *)this + 488))(this, *(void *)(v48 + 1592));
      (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, 0, 1);
    }
    if (*(void *)(v48 + 1616)) {
      std::string v68 = *(const char **)(v48 + 1608);
    }
    else {
      std::string v68 = "llvm-mc (based on LLVM 32023.408)";
    }
    (*(void (**)(llvm::MCGenDwarfInfo *, const char *))(*(void *)this + 488))(this, v68);
    (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, 0, 1);
    (*(void (**)(llvm::MCGenDwarfInfo *, uint64_t, uint64_t))(*(void *)this + 520))(this, 32769, 2);
    uint64_t v69 = *((void *)this + 1);
    uint64_t v70 = *(void *)(v69 + 1568);
    uint64_t v71 = *(void *)(v69 + 1576);
    while (v70 != v71)
    {
      llvm::MCStreamer::emitULEB128IntValue(this, 2uLL, 0);
      (*(void (**)(llvm::MCGenDwarfInfo *, void, void))(*(void *)this + 488))(this, *(void *)v70, *(void *)(v70 + 8));
      (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, 0, 1);
      (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, *(unsigned int *)(v70 + 16), 4);
      (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, *(unsigned int *)(v70 + 20), 4);
      unint64_t v72 = llvm::MCSymbolRefExpr::create(*(void *)(v70 + 24), 0, v48, 0);
      (*(void (**)(llvm::MCGenDwarfInfo *, unint64_t, uint64_t, void))(*(void *)this + 512))(this, v72, v55, 0);
      v70 += 32;
    }
    (*(void (**)(llvm::MCGenDwarfInfo *, void, uint64_t))(*(void *)this + 520))(this, 0, 1);
    return (*(uint64_t (**)(llvm::MCGenDwarfInfo *, uint64_t, void))(*(void *)this + 192))(this, v50, 0);
  }
  return result;
}

uint64_t llvm::MCGenDwarfLabelEntry::Make(uint64_t result, uint64_t a2, uint64_t *a3, unint64_t *a4)
{
  if ((*(unsigned char *)(result + 8) & 1) == 0)
  {
    uint64_t v7 = (unsigned char *)result;
    uint64_t v8 = *(void *)(a2 + 8);
    uint64_t v9 = *(unsigned int *)(a2 + 120);
    uint64_t v10 = v9 ? *(void *)(*(void *)(a2 + 112) + 32 * v9 - 32) : 0;
    uint64_t v23 = 0;
    *(void *)&long long v24 = v10;
    uint64_t result = sub_1CD420258((uint64_t *)(v8 + 1520), &v24, &v23);
    if (result)
    {
      if ((*v7 & 4) != 0)
      {
        uint64_t v20 = (void *)*((void *)v7 - 1);
        uint64_t v11 = v20 + 2;
        uint64_t v21 = *v20;
        if (*v20)
        {
          int v22 = (char *)v20 + 17;
          if (*v11 == 95)
          {
            uint64_t v11 = v22;
            uint64_t v12 = v21 - 1;
          }
          else
          {
            uint64_t v12 = v21;
          }
LABEL_10:
          unsigned int v13 = *(_DWORD *)(v8 + 1516);
          int BufferContainingLoc = llvm::SourceMgr::FindBufferContainingLoc(a3, *a4);
          unsigned int LineAndColumn = llvm::SourceMgr::getLineAndColumn(a3, (char *)*a4, BufferContainingLoc);
          *(void *)&long long v24 = "tmp";
          __int16 v26 = 259;
          uint64_t TempSymbol = llvm::MCContext::createTempSymbol((llvm::MCContext *)v8, (const llvm::Twine *)&v24, 1);
          (*(void (**)(uint64_t, uint64_t, void))(*(void *)a2 + 192))(a2, TempSymbol, 0);
          uint64_t v17 = *(void *)(a2 + 8);
          *(void *)&long long v24 = v11;
          *((void *)&v24 + 1) = v12;
          *(void *)&long long v25 = __PAIR64__(LineAndColumn, v13);
          *((void *)&v25 + 1) = TempSymbol;
          int v18 = *(_OWORD **)(v17 + 1576);
          if ((unint64_t)v18 >= *(void *)(v17 + 1584))
          {
            uint64_t result = (uint64_t)sub_1CBFF08A8((void **)(v17 + 1568), &v24);
          }
          else
          {
            long long v19 = v25;
            *int v18 = v24;
            v18[1] = v19;
            uint64_t result = (uint64_t)(v18 + 2);
          }
          *(void *)(v17 + 1576) = result;
          return result;
        }
      }
      else
      {
        uint64_t v11 = 0;
      }
      uint64_t v12 = 0;
      goto LABEL_10;
    }
  }
  return result;
}

void llvm::MCDwarfFrameEmitter::EmitAdvanceLoc(llvm::MCDwarfFrameEmitter *this, llvm::MCObjectStreamer *a2, unint64_t a3, llvm::raw_ostream *a4)
{
  v17[32] = *MEMORY[0x1E4F143B8];
  int v5 = (llvm::raw_ostream *)*((void *)this + 1);
  unint64_t v14 = &v15;
  uint64_t v15 = v17;
  long long v16 = xmmword_1CD96DBF0;
  int v7 = 0;
  char v11 = 0;
  uint64_t v12 = 0;
  int v13 = 0;
  uint64_t v6 = &unk_1F2646FA8;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  llvm::MCDwarfFrameEmitter::EncodeAdvanceLoc(v5, (unint64_t)a2, (llvm::raw_ostream *)&v6, a4);
  (*(void (**)(llvm::MCDwarfFrameEmitter *, void *, void *))(*(void *)this + 488))(this, *v14, v14[1]);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v6);
  if (v15 != v17) {
    free(v15);
  }
}

uint64_t sub_1CD6AC038(uint64_t a1, uint64_t a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 64);
  *(void *)a1 = *(void *)a2;
  if (v4)
  {
    if (a2 != a1) {
      sub_1CC8B60AC(a1 + 8, a2 + 8);
    }
    long long v5 = *(_OWORD *)(a2 + 32);
    *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v5;
    *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  }
  else
  {
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 24) = 0;
    sub_1CC8B60AC(a1 + 8, a2 + 8);
    long long v7 = *(_OWORD *)(a2 + 32);
    *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v7;
    *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
    *(unsigned char *)(a1 + 64) = 1;
  }
  return a1;
}

void sub_1CD6AC0E0(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    long long v5 = *a1;
    uint64_t v2 = (uint64_t)a1[1];
    int v3 = v1;
    if ((void *)v2 != v1)
    {
      do
        uint64_t v2 = sub_1CCBBFE28(v2 - 80);
      while ((void *)v2 != v5);
      int v3 = *a1;
    }
    a1[1] = v5;
    operator delete(v3);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

unint64_t sub_1CD6AC158(uint64_t *a1, int *a2, int *a3, char *a4, char *a5, int *a6, char *a7)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  memset(v19, 0, sizeof(v19));
  uint64_t v14 = sub_1CBF65470();
  uint64_t v15 = *a1;
  uint64_t v20 = v14;
  int v16 = *a2;
  uint64_t v18 = v15;
  return sub_1CD6AC238((char *)&v18, v19, (char *)&v19[3] + 8, v16, a3, a4, a5, a6, a7);
}

unint64_t sub_1CD6AC238(char *a1, _DWORD *__dst, char *a3, int a4, int *a5, char *a6, char *a7, int *a8, char *a9)
{
  uint64_t v18 = 0;
  uint64_t v15 = sub_1CC0AC9D0(a1, &v18, __dst, (unint64_t)a3, a4);
  uint64_t v19 = v18;
  int v16 = sub_1CC0AC9D0(a1, &v19, v15, (unint64_t)a3, *a5);
  return sub_1CD6AC2EC(a1, v19, v16, a3, *a6, a7, a8, a9);
}

unint64_t sub_1CD6AC2EC(char *a1, uint64_t a2, unsigned char *a3, char *a4, char a5, char *a6, int *a7, char *a8)
{
  uint64_t v16 = a2;
  int v13 = sub_1CC0AC730(a1, &v16, a3, (unint64_t)a4, a5 != 0);
  uint64_t v17 = v16;
  uint64_t v14 = sub_1CC0AC730(a1, &v17, v13, (unint64_t)a4, *a6);
  return sub_1CCBC1B4C(a1, v17, v14, a4, *a7, a8);
}

void llvm::MCELFStreamer::MCELFStreamer(llvm::MCStreamer *a1, llvm::MCContext *a2, void *a3, void *a4, void *a5)
{
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  llvm::MCObjectStreamer::MCObjectStreamer(a1, a2);
}

void *llvm::MCELFStreamer::mergeFragment(llvm::MCObjectStreamer *this, llvm::MCFragment *a2, uint64_t a3)
{
  v31[32] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *((void *)this + 34);
  unint64_t v7 = *(unsigned int *)(v6 + 496);
  if (!v7 || (*(unsigned char *)(v6 + 500) & 1) == 0) {
    goto LABEL_3;
  }
  unint64_t v17 = *(void *)(a3 + 72);
  if (v17 > v7)
  {
    uint64_t v19 = "Fragment can't be larger than a bundle size";
    goto LABEL_17;
  }
  unint64_t v18 = llvm::computeBundlePadding(*((void *)this + 34), a3, *((void *)a2 + 9), *(void *)(a3 + 72));
  if (v18 >= 0x100)
  {
    uint64_t v19 = "Padding cannot exceed 255 bytes";
LABEL_17:
    llvm::report_fatal_error((llvm *)v19, (const llvm::Twine *)1);
  }
  if (v18)
  {
    long long v28 = &v29;
    uint64_t v29 = v31;
    long long v30 = xmmword_1CD96DBF0;
    int v21 = 0;
    char v25 = 0;
    uint64_t v26 = 0;
    int v27 = 0;
    uint64_t v20 = &unk_1F2646FA8;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    *(unsigned char *)(a3 + 52) = v18;
    llvm::MCAssembler::writeFragmentPadding(v6, (uint64_t)&v20, a3, v17);
    sub_1CC22A954((void *)a2 + 8, v29, (unsigned char *)v29 + v30);
    llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v20);
    if (v29 != v31) {
      free(v29);
    }
  }
LABEL_3:
  llvm::MCObjectStreamer::flushPendingLabels(this, (unint64_t)a2, *((void *)a2 + 9));
  uint64_t v8 = *(unsigned int *)(a3 + 128);
  if (v8)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 24 * v8;
    do
    {
      unint64_t v11 = *(void *)(a3 + 120) + v9;
      *(_DWORD *)(v11 + 8) += *((_DWORD *)a2 + 18);
      unint64_t v12 = sub_1CD41C4F0((uint64_t)a2 + 120, v11, 1);
      uint64_t v13 = *((void *)a2 + 15) + 24 * *((unsigned int *)a2 + 32);
      long long v14 = *(_OWORD *)v12;
      *(void *)(v13 + 16) = *(void *)(v12 + 16);
      *(_OWORD *)uint64_t v13 = v14;
      ++*((_DWORD *)a2 + 32);
      v9 += 24;
    }
    while (v10 != v9);
  }
  if (!*((void *)a2 + 7))
  {
    uint64_t v16 = *(void *)(a3 + 56);
    if (v16)
    {
      *((unsigned char *)a2 + 50) = 1;
      *((void *)a2 + 7) = v16;
    }
  }
  return sub_1CC22A954((void *)a2 + 8, *(unsigned char **)(a3 + 64), (unsigned char *)(*(void *)(a3 + 64) + *(void *)(a3 + 72)));
}

uint64_t llvm::MCELFStreamer::initSections(llvm::MCELFStreamer *this, int a2, const llvm::MCSubtargetInfo *a3)
{
  uint64_t v6 = *((void *)this + 1);
  (*(void (**)(llvm::MCELFStreamer *, void, void))(*(void *)this + 168))(this, *(void *)(*(void *)(v6 + 168) + 24), 0);
  uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(v6 + 168) + 16))(*(void *)(v6 + 168));
  uint64_t result = (*(uint64_t (**)(llvm::MCELFStreamer *, uint64_t, const llvm::MCSubtargetInfo *, void))(*(void *)this + 648))(this, v7, a3, 0);
  if (a2)
  {
    uint64_t v9 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 152) + 16))(*(void *)(v6 + 152), v6);
    uint64_t v10 = *(uint64_t (**)(llvm::MCELFStreamer *, uint64_t, void))(*(void *)this + 168);
    return v10(this, v9, 0);
  }
  return result;
}

void llvm::MCELFStreamer::emitLabel(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(unsigned char *)(*(void *)(*(void *)(a1 + 112) + 32 * *(unsigned int *)(a1 + 120) - 32) + 229) & 4) != 0) {
    *(_WORD *)(a2 + 12) = *(_WORD *)(a2 + 12) & 0xFFF8 | 5;
  }
}

llvm::MCSection *llvm::MCELFStreamer::emitLabelAtPos(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = llvm::MCObjectStreamer::emitLabelAtPos((uint64_t *)a1, a2, a3, a4, a5);
  if ((*(unsigned char *)(*(void *)(*(void *)(a1 + 112) + 32 * *(unsigned int *)(a1 + 120) - 32) + 229) & 4) != 0) {
    *(_WORD *)(a2 + 12) = *(_WORD *)(a2 + 12) & 0xFFF8 | 5;
  }
  return result;
}

uint64_t llvm::MCELFStreamer::emitAssemblerFlag(uint64_t a1, int a2)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 272) + 8) + 208))(*(void *)(*(void *)(a1 + 272) + 8));
  if (a2 == 1) {
    *(unsigned char *)(*(void *)(a1 + 272) + 500) |= 2u;
  }
  return result;
}

uint64_t llvm::MCELFStreamer::changeSection(llvm::MCELFStreamer *this, llvm::MCSection *a2, const llvm::MCExpr *a3)
{
  uint64_t v6 = *((unsigned int *)this + 30);
  if (v6 && (uint64_t v7 = *(void *)(*((void *)this + 14) + 32 * v6 - 32)) != 0)
  {
    if (*(_DWORD *)(v7 + 36)) {
      llvm::report_fatal_error((llvm *)"Unterminated .bundle_lock when changing a section", (const llvm::Twine *)1);
    }
    uint64_t v8 = *((void *)this + 34);
    unint64_t v9 = *(unsigned int *)(v8 + 496);
    if (v9 && (*(unsigned char *)(v7 + 44) & 2) != 0 && v9 > (1 << *(unsigned char *)(v7 + 24))) {
      *(unsigned char *)(v7 + 24) = __clz(v9) ^ 0x3F;
    }
  }
  else
  {
    uint64_t v8 = *((void *)this + 34);
  }
  unint64_t v10 = *((void *)a2 + 30) & 0xFFFFFFFFFFFFFFF8;
  if (v10) {
    llvm::MCAssembler::registerSymbol(v8, v10, 0);
  }
  if ((*((unsigned char *)a2 + 230) & 0x20) != 0) {
    (*(void (**)(void, unint64_t))(**(void **)(v8 + 24) + 56))(*(void *)(v8 + 24), v10);
  }
  llvm::MCObjectStreamer::changeSectionImpl(this, a2, a3);
  uint64_t v11 = *((void *)a2 + 1);

  return llvm::MCAssembler::registerSymbol(v8, v11, 0);
}

uint64_t llvm::MCELFStreamer::emitWeakReference(llvm::MCELFStreamer *this, llvm::MCSymbol *a2, const llvm::MCSymbol *a3)
{
  llvm::MCAssembler::registerSymbol(*((void *)this + 34), (uint64_t)a3, 0);
  uint64_t v6 = (const llvm::MCExpr *)llvm::MCSymbolRefExpr::create((uint64_t)a3, 29, *((void *)this + 1), 0);

  return llvm::MCSymbol::setVariableValue((uint64_t)a2, v6);
}

uint64_t sub_1CD6ACAC0(unsigned char *a1)
{
  if ((*a1 & 4) != 0) {
    return *((void *)a1 - 1) + 16;
  }
  else {
    return 0;
  }
}

unint64_t llvm::MCELFStreamer::emitCommonSymbol(llvm::MCELFStreamer *this, llvm::MCSymbol *a2, llvm::MCConstantExpr *a3, uint64_t a4)
{
  llvm::MCAssembler::registerSymbol(*((void *)this + 34), (uint64_t)a2, 0);
  __int16 v8 = *((_WORD *)a2 + 6);
  if ((v8 & 0x1000) == 0) {
    __int16 v8 = v8 & 0xEFE0 | 0x1008;
  }
  *((_WORD *)a2 + 6) = v8 & 0xFFF8 | 1;
  if (llvm::MCSymbolELF::getBinding(a2))
  {
    if (sub_1CD6ACD48((uint64_t)a2, (uint64_t)a3, a4))
    {
      int v21 = "Symbol: ";
      __int16 v22 = 259;
      __int16 v20 = 261;
      v19[0] = sub_1CD6ACAC0(a2);
      v19[1] = v16;
      sub_1CD3E3950((uint64_t *)&v21, v19, (uint64_t)v23);
      unint64_t v17 = " redeclared as different type";
      __int16 v18 = 259;
      sub_1CD3E3950(v23, (uint64_t *)&v17, (uint64_t)v25);
      llvm::report_fatal_error((llvm *)v25, (const llvm::Twine *)1);
    }
  }
  else
  {
    unint64_t v9 = (llvm::MCContext *)**((void **)this + 34);
    v23[0] = (uint64_t)".bss";
    __int16 v24 = 259;
    __int16 v26 = 257;
    uint64_t ELFSection = llvm::MCContext::getELFSection(v9, (const llvm::Twine *)v23, 8, 3, 0, (const llvm::Twine *)v25, 0, -1, 0);
    uint64_t v11 = *((unsigned int *)this + 30);
    if (v11)
    {
      uint64_t v12 = *((void *)this + 14) + 32 * v11;
      uint64_t v14 = *(void *)(v12 - 32);
      uint64_t v13 = *(void *)(v12 - 24);
    }
    else
    {
      uint64_t v13 = 0;
      uint64_t v14 = 0;
    }
    (*(void (**)(llvm::MCELFStreamer *, uint64_t, void))(*(void *)this + 168))(this, ELFSection, 0);
    (*(void (**)(llvm::MCELFStreamer *, uint64_t, void, uint64_t, void))(*(void *)this + 640))(this, a4, 0, 1, 0);
    (*(void (**)(llvm::MCELFStreamer *, llvm::MCSymbol *, void))(*(void *)this + 192))(this, a2, 0);
    llvm::MCStreamer::emitZeros(this, (uint64_t)a3);
    (*(void (**)(llvm::MCELFStreamer *, uint64_t, uint64_t))(*(void *)this + 168))(this, v14, v13);
  }
  unint64_t result = llvm::MCConstantExpr::create(a3, *((void *)this + 1), 0, 0);
  *((void *)a2 + 4) = result;
  return result;
}

uint64_t sub_1CD6ACD48(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v3 = *(_DWORD *)(a1 + 8);
  if (((v3 >> 10) & 7) - 3 > 1)
  {
    *(void *)(a1 + 24) = a2;
    *(_DWORD *)(a1 + 8) = (-8192 * __clz(a3)) & 0x3E000 | v3 & 0xFFFC03FF | 0xC00;
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t result = 1;
  if (v4 == a2)
  {
    int v6 = 1 << (((v3 >> 13) & 0x1F) - 1);
    if (((v3 >> 13) & 0x1F) == 0) {
      int v6 = 0;
    }
    if ((v3 & 0x1C00) != 0x1000 && v6 == a3) {
      return 0;
    }
  }
  return result;
}

void llvm::MCELFStreamer::emitELFSize(llvm::MCELFStreamer *this, llvm::MCSymbol *a2, const llvm::MCExpr *a3)
{
  *((void *)a2 + 4) = a3;
}

char *llvm::MCELFStreamer::emitELFSymverDirective(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v5 = *(void *)(a1 + 272);
  int v6 = *(void **)(a1 + 256);
  if (v6) {
    int v6 = (void *)*v6;
  }
  *(void *)&long long v10 = v6;
  *((void *)&v10 + 1) = a2;
  *(void *)&long long v11 = a3;
  *((void *)&v11 + 1) = a4;
  LOBYTE(v12) = a5;
  unint64_t v7 = *(void *)(v5 + 2168);
  if (v7 >= *(void *)(v5 + 2176))
  {
    uint64_t result = sub_1CCBC2900((void **)(v5 + 2160), (uint64_t)&v10);
  }
  else
  {
    long long v8 = v11;
    *(_OWORD *)unint64_t v7 = v10;
    *(_OWORD *)(v7 + 16) = v8;
    *(void *)(v7 + 32) = v12;
    uint64_t result = (char *)(v7 + 40);
  }
  *(void *)(v5 + 2168) = result;
  return result;
}

uint64_t llvm::MCELFStreamer::emitLocalCommonSymbol(llvm::MCELFStreamer *this, llvm::MCSymbol *a2, uint64_t a3, uint64_t a4)
{
  llvm::MCAssembler::registerSymbol(*((void *)this + 34), (uint64_t)a2, 0);
  *((_WORD *)a2 + 6) = *((_WORD *)a2 + 6) & 0xEFE7 | 0x1000;
  long long v8 = *(uint64_t (**)(llvm::MCELFStreamer *, llvm::MCSymbol *, uint64_t, uint64_t))(*(void *)this + 456);

  return v8(this, a2, a3, a4);
}

void llvm::MCELFStreamer::emitValueImpl(uint64_t a1, const llvm::MCExpr *a2, unsigned int a3, uint64_t a4)
{
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 112) + 32 * *(unsigned int *)(a1 + 120) - 32) + 36)) {
    llvm::report_fatal_error((llvm *)"Emitting values inside a locked bundle is forbidden", (const llvm::Twine *)1);
  }
  llvm::MCELFStreamer::fixSymbolsInTLSFixups((uint64_t *)a1, a2);

  llvm::MCObjectStreamer::emitValueImpl(a1, (uint64_t)a2, a3, a4);
}

uint64_t *llvm::MCELFStreamer::fixSymbolsInTLSFixups(uint64_t *this, const llvm::MCExpr *a2)
{
  unsigned int v3 = this;
  while (1)
  {
    int v4 = *(unsigned __int8 *)a2;
    if (v4 == 3)
    {
      uint64_t v5 = (const llvm::MCExpr **)((char *)a2 + 16);
      goto LABEL_4;
    }
    if (*(unsigned char *)a2) {
      break;
    }
    this = (uint64_t *)llvm::MCELFStreamer::fixSymbolsInTLSFixups((llvm::MCELFStreamer *)v3, *((const llvm::MCExpr **)a2 + 2));
    uint64_t v5 = (const llvm::MCExpr **)((char *)a2 + 24);
LABEL_4:
    a2 = *v5;
  }
  if (v4 == 2)
  {
    switch(*(_WORD *)((char *)a2 + 1))
    {
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xD:
      case 0xE:
      case 0xF:
      case 0x10:
      case 0x11:
      case 0x12:
      case 0x13:
      case 0x43:
      case 0x44:
      case 0x45:
      case 0x46:
      case 0x47:
      case 0x48:
      case 0x49:
      case 0x4A:
      case 0x4B:
      case 0x4C:
      case 0x4D:
      case 0x4E:
      case 0x4F:
      case 0x50:
      case 0x51:
      case 0x52:
      case 0x53:
      case 0x54:
      case 0x55:
      case 0x56:
      case 0x57:
      case 0x58:
      case 0x59:
      case 0x5A:
      case 0x5B:
      case 0x5C:
      case 0x5D:
      case 0x5E:
      case 0x5F:
      case 0x60:
      case 0x61:
      case 0x62:
      case 0x63:
      case 0x66:
      case 0x67:
      case 0x68:
      case 0x69:
      case 0x6B:
      case 0x6D:
      case 0x6E:
      case 0x6F:
        goto LABEL_13;
      case 0xC:
      case 0x14:
      case 0x15:
      case 0x16:
      case 0x17:
      case 0x18:
      case 0x19:
      case 0x1A:
      case 0x1B:
      case 0x1C:
      case 0x1D:
      case 0x1E:
      case 0x1F:
      case 0x20:
      case 0x21:
      case 0x22:
      case 0x23:
      case 0x24:
      case 0x25:
      case 0x26:
      case 0x27:
      case 0x28:
      case 0x29:
      case 0x2A:
      case 0x2B:
      case 0x2C:
      case 0x2D:
      case 0x2E:
      case 0x2F:
      case 0x30:
      case 0x31:
      case 0x32:
      case 0x33:
      case 0x34:
      case 0x35:
      case 0x36:
      case 0x37:
      case 0x38:
      case 0x39:
      case 0x3A:
      case 0x3B:
      case 0x3C:
      case 0x3D:
      case 0x3E:
      case 0x3F:
      case 0x40:
      case 0x41:
      case 0x42:
      case 0x64:
      case 0x65:
      case 0x6A:
      case 0x6C:
        return this;
      default:
        if (*(unsigned __int16 *)((char *)a2 + 1) - 158 < 2)
        {
LABEL_13:
          this = (uint64_t *)llvm::MCAssembler::registerSymbol(v3[34], *((void *)a2 + 2), 0);
          *(_WORD *)(*((void *)a2 + 2) + 12) = *(_WORD *)(*((void *)a2 + 2) + 12) & 0xFFF8 | 5;
        }
        break;
    }
  }
  else if (v4 == 4)
  {
    uint64_t v6 = v3[34];
    unint64_t v7 = *(uint64_t (**)(char *, uint64_t))(*((void *)a2 - 1) + 72);
    return (uint64_t *)v7((char *)a2 - 8, v6);
  }
  return this;
}

void llvm::MCELFStreamer::emitValueToAlignment(llvm::MCELFStreamer *this)
{
  if (!*(_DWORD *)(*(void *)(*((void *)this + 14) + 32 * *((unsigned int *)this + 30) - 32) + 36))
  {
    llvm::MCObjectStreamer::emitValueToAlignment(this);
  }
  llvm::report_fatal_error((llvm *)"Emitting values inside a locked bundle is forbidden", (const llvm::Twine *)1);
}

char *llvm::MCELFStreamer::emitCGProfileEntry(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 272);
  *(void *)&long long v7 = a2;
  *((void *)&v7 + 1) = a3;
  uint64_t v8 = a4;
  unint64_t v5 = *(void *)(v4 + 2192);
  if (v5 >= *(void *)(v4 + 2200))
  {
    uint64_t result = sub_1CBF99908((void **)(v4 + 2184), (uint64_t)&v7);
  }
  else
  {
    *(_OWORD *)unint64_t v5 = v7;
    *(void *)(v5 + 16) = v8;
    uint64_t result = (char *)(v5 + 24);
  }
  *(void *)(v4 + 2192) = result;
  return result;
}

BOOL llvm::MCELFStreamer::emitIdent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = **(llvm::MCContext ***)(a1 + 272);
  long long v10 = ".comment";
  __int16 v11 = 259;
  __int16 v13 = 257;
  uint64_t ELFSection = llvm::MCContext::getELFSection(v6, (const llvm::Twine *)&v10, 1, 48, 1, (const llvm::Twine *)v12, 0, -1, 0);
  __n128 v8 = sub_1CD6AD2C8(a1);
  (*(void (**)(uint64_t, uint64_t, void, __n128))(*(void *)a1 + 168))(a1, ELFSection, 0, v8);
  if (!*(unsigned char *)(a1 + 5696))
  {
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)a1 + 520))(a1, 0, 1);
    *(unsigned char *)(a1 + 5696) = 1;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 488))(a1, a2, a3);
  (*(void (**)(uint64_t, void, uint64_t))(*(void *)a1 + 520))(a1, 0, 1);
  return sub_1CCBC2468(a1);
}

__n128 sub_1CD6AD2C8(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 112);
  uint64_t v3 = *(unsigned int *)(a1 + 120);
  if (v3)
  {
    uint64_t v4 = *v2 + 32 * v3;
    long long v5 = *(_OWORD *)(v4 - 32);
    long long v6 = *(_OWORD *)(v4 - 16);
  }
  else
  {
    long long v5 = 0uLL;
    long long v6 = 0uLL;
  }
  v11[0] = v5;
  v11[1] = v6;
  unint64_t v7 = sub_1CBA9C894((uint64_t)v2, (unint64_t)v11, 1);
  __n128 v8 = (_OWORD *)(*(void *)(a1 + 112) + 32 * *(unsigned int *)(a1 + 120));
  __n128 result = *(__n128 *)v7;
  long long v10 = *(_OWORD *)(v7 + 16);
  _OWORD *v8 = *(_OWORD *)v7;
  v8[1] = v10;
  ++*(_DWORD *)(a1 + 120);
  return result;
}

void llvm::MCELFStreamer::finalizeCGProfileEntry(uint64_t *a1, const llvm::MCExpr ***a2, llvm::MCConstantExpr *this)
{
  long long v6 = (*a2)[2];
  if ((*((unsigned char *)v6 + 8) & 1) == 0) {
    goto LABEL_2;
  }
  if (sub_1CC34BE58((uint64_t)(*a2)[2], 1)
    && (_UNKNOWN *)sub_1CC34BE58((uint64_t)v6, 1) != llvm::MCSymbol::AbsolutePseudoFragment)
  {
    uint64_t v8 = *(void *)(*(void *)(sub_1CC34BE58((uint64_t)v6, 1) + 16) + 8);
    *(_DWORD *)(v8 + 8) |= 0x200u;
    *a2 = (const llvm::MCExpr **)llvm::MCSymbolRefExpr::create(v8, 0, a1[1], (uint64_t)(*a2)[1]);
LABEL_2:
    unint64_t v7 = llvm::MCConstantExpr::create(this, a1[1], 0, 0);
    llvm::MCStreamer::visitUsedExpr((llvm::MCStreamer *)a1, *a2);
    llvm::MCObjectStreamer::emitRelocDirective(a1, v7, (uint64_t)"BFD_RELOC_NONE", 14, (unint64_t)*a2, (*a2)[1], *(const llvm::MCSubtargetInfo **)(a1[1] + 176), (uint64_t)v26);
    if (v27[24])
    {
      v23[0] = (uint64_t)"Relocation for CG Profile could not be created: ";
      __int16 v24 = 259;
      __int16 v22 = 260;
      v21[0] = (uint64_t)v27;
      sub_1CD3E3950(v23, v21, (uint64_t)v25);
      llvm::report_fatal_error((llvm *)v25, (const llvm::Twine *)1);
    }
    return;
  }
  uint64_t v9 = a1[1];
  uint64_t v10 = (uint64_t)(*a2)[1];
  v21[0] = (uint64_t)"Reference to undefined temporary symbol ";
  __int16 v22 = 259;
  __int16 v20 = 259;
  sub_1CB8F1E58(v21, (uint64_t *)&v19, (uint64_t)v23);
  if ((*(unsigned char *)v6 & 4) != 0)
  {
    __int16 v13 = (uint64_t *)*((void *)v6 - 1);
    uint64_t v14 = *v13;
    uint64_t v11 = (uint64_t)(v13 + 2);
    uint64_t v12 = v14;
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v12 = 0;
  }
  __int16 v18 = 261;
  v17[0] = v11;
  v17[1] = v12;
  sub_1CB8F1E58(v23, v17, (uint64_t)v25);
  __int16 v16 = 259;
  sub_1CB8F1E58(v25, (uint64_t *)&v15, (uint64_t)v26);
  llvm::MCContext::reportError(v9, v10, (uint64_t)v26);
}

uint64_t *llvm::MCELFStreamer::finalizeCGProfile(uint64_t *this)
{
  uint64_t v1 = this[34];
  if (*(void *)(v1 + 2184) != *(void *)(v1 + 2192))
  {
    uint64_t v2 = this;
    uint64_t v3 = *(llvm::MCContext **)v1;
    uint64_t v9 = ".llvm.call-graph-profile";
    __int16 v10 = 259;
    __int16 v12 = 257;
    uint64_t ELFSection = llvm::MCContext::getELFSection(v3, (const llvm::Twine *)&v9, 1879002121, 0x80000000, 8, (const llvm::Twine *)v11, 0, -1, 0);
    __n128 v5 = sub_1CD6AD2C8((uint64_t)v2);
    (*(void (**)(uint64_t *, uint64_t, void, __n128))(*v2 + 168))(v2, ELFSection, 0, v5);
    uint64_t v6 = *(void *)(v1 + 2184);
    uint64_t v7 = *(void *)(v1 + 2192);
    if (v6 != v7)
    {
      uint64_t v8 = 0;
      do
      {
        llvm::MCELFStreamer::finalizeCGProfileEntry(v2, (const llvm::MCExpr ***)v6, v8);
        llvm::MCELFStreamer::finalizeCGProfileEntry(v2, (const llvm::MCExpr ***)(v6 + 8), v8);
        (*(void (**)(uint64_t *, void, uint64_t))(*v2 + 520))(v2, *(void *)(v6 + 16), 8);
        uint64_t v8 = (llvm::MCConstantExpr *)((char *)v8 + 8);
        v6 += 24;
      }
      while (v6 != v7);
    }
    return (uint64_t *)sub_1CCBC2468((uint64_t)v2);
  }
  return this;
}

void llvm::MCELFStreamer::emitInstToFragment()
{
}

void llvm::MCELFStreamer::emitInstToData(uint64_t a1, uint64_t a2, const llvm::MCSubtargetInfo *a3)
{
  v35[12] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 272);
  __int16 v33 = (const llvm::MCExpr **)v35;
  uint64_t v34 = 0x400000000;
  uint64_t v29 = &v30;
  long long v30 = v32;
  long long v31 = xmmword_1CD96DBF0;
  int v22 = 0;
  char v26 = 0;
  uint64_t v27 = 0;
  int v28 = 0;
  int v21 = &unk_1F2646FA8;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  (*(void (**)(void, uint64_t, void **, const llvm::MCExpr ***, const llvm::MCSubtargetInfo *))(**(void **)(v5 + 16) + 32))(*(void *)(v5 + 16), a2, &v21, &v33, a3);
  if (v34)
  {
    uint64_t v6 = v33;
    uint64_t v7 = 24 * v34;
    do
    {
      uint64_t v8 = *v6;
      v6 += 3;
      llvm::MCELFStreamer::fixSymbolsInTLSFixups((uint64_t *)a1, v8);
      v7 -= 24;
    }
    while (v7);
  }
  if (!*(_DWORD *)(v5 + 496))
  {
    uint64_t DataFragment = llvm::MCObjectStreamer::getOrCreateDataFragment((llvm::MCObjectStreamer *)a1, a3);
    goto LABEL_23;
  }
  uint64_t v9 = *(unsigned int *)(a1 + 120);
  if (v9) {
    uint64_t v10 = *(void *)(*(void *)(a1 + 112) + 32 * v9 - 32);
  }
  else {
    uint64_t v10 = 0;
  }
  if (*(unsigned char *)(v5 + 500))
  {
    if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 112) + 32 * v9 - 32) + 36)) {
      operator new();
    }
    uint64_t DataFragment = *(void *)(*(void *)(a1 + 5704) + 8 * *(unsigned int *)(a1 + 5712) - 8);
    __int16 v12 = *(const llvm::MCSubtargetInfo **)(DataFragment + 56);
    if (!v12) {
      goto LABEL_20;
    }
    goto LABEL_15;
  }
  if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 112) + 32 * v9 - 32) + 36))
  {
    if (!v34) {
      operator new();
    }
LABEL_19:
    operator new();
  }
  if (*(unsigned char *)(v10 + 44)) {
    goto LABEL_19;
  }
  uint64_t DataFragment = llvm::MCObjectStreamer::getCurrentFragment((llvm::MCObjectStreamer *)a1);
  __int16 v12 = *(const llvm::MCSubtargetInfo **)(DataFragment + 56);
  if (v12)
  {
LABEL_15:
    if (v12 != a3) {
      llvm::report_fatal_error((llvm *)"A Bundle can only have one Subtarget.", (const llvm::Twine *)1);
    }
  }
LABEL_20:
  if (*(_DWORD *)(v10 + 36) == 2) {
    *(unsigned char *)(DataFragment + 51) = 1;
  }
  *(unsigned char *)(v10 + 44) &= ~1u;
LABEL_23:
  if (v34)
  {
    __int16 v13 = v33;
    uint64_t v14 = 24 * v34;
    do
    {
      *((_DWORD *)v13 + 2) += *(_DWORD *)(DataFragment + 72);
      unint64_t v15 = sub_1CD41C4F0(DataFragment + 120, (unint64_t)v13, 1);
      uint64_t v16 = *(void *)(DataFragment + 120) + 24 * *(unsigned int *)(DataFragment + 128);
      long long v17 = *(_OWORD *)v15;
      *(void *)(v16 + 16) = *(void *)(v15 + 16);
      *(_OWORD *)uint64_t v16 = v17;
      ++*(_DWORD *)(DataFragment + 128);
      v13 += 3;
      v14 -= 24;
    }
    while (v14);
  }
  *(unsigned char *)(DataFragment + 50) = 1;
  *(void *)(DataFragment + 56) = a3;
  sub_1CC22A954((void *)(DataFragment + 64), v30, (unsigned char *)v30 + v31);
  if (*(_DWORD *)(v5 + 496)
    && (*(unsigned char *)(v5 + 500) & 1) != 0
    && !*(_DWORD *)(*(void *)(*(void *)(a1 + 112) + 32 * *(unsigned int *)(a1 + 120) - 32) + 36))
  {
    __int16 v18 = (llvm::MCFragment *)llvm::MCObjectStreamer::getOrCreateDataFragment((llvm::MCObjectStreamer *)a1, a3);
    llvm::MCELFStreamer::mergeFragment((llvm::MCObjectStreamer *)a1, v18, DataFragment);
    uint64_t v19 = *(void **)(DataFragment + 120);
    if (v19 != (void *)(DataFragment + 136)) {
      free(v19);
    }
    __int16 v20 = *(void **)(DataFragment + 64);
    if (v20 != (void *)(DataFragment + 88)) {
      free(v20);
    }
    MEMORY[0x1D25D9CE0](DataFragment, 0x10E0C400AE5E4C8);
  }
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v21);
  if (v30 != v32) {
    free(v30);
  }
  if (v33 != v35) {
    free(v33);
  }
}

uint64_t llvm::MCELFStreamer::emitBundleAlignMode(uint64_t this, int a2)
{
  if (!a2
    || ((uint64_t v2 = *(void *)(this + 272), v3 = *(_DWORD *)(v2 + 496), v4 = 1 << a2, v3) ? (v5 = v3 == v4) : (v5 = 1), !v5))
  {
    llvm::report_fatal_error((llvm *)".bundle_align_mode cannot be changed once set", (const llvm::Twine *)1);
  }
  *(_DWORD *)(v2 + 496) = v4;
  return this;
}

uint64_t llvm::MCELFStreamer::emitBundleLock(llvm::MCELFStreamer *this, int a2)
{
  uint64_t v2 = *((unsigned int *)this + 30);
  if (v2) {
    uint64_t v3 = *(void *)(*((void *)this + 14) + 32 * v2 - 32);
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *((void *)this + 34);
  if (!*(_DWORD *)(v4 + 496)) {
    llvm::report_fatal_error((llvm *)".bundle_lock forbidden when bundling is disabled", (const llvm::Twine *)1);
  }
  if (!*(_DWORD *)(*(void *)(*((void *)this + 14) + 32 * v2 - 32) + 36))
  {
    *(unsigned char *)(v3 + 44) |= 1u;
    uint64_t v4 = *((void *)this + 34);
  }
  if ((*(unsigned char *)(v4 + 500) & 1) != 0
    && !*(_DWORD *)(*(void *)(*((void *)this + 14) + 32 * *((unsigned int *)this + 30) - 32) + 36))
  {
    operator new();
  }
  if (a2) {
    int v5 = 2;
  }
  else {
    int v5 = 1;
  }

  return llvm::MCSection::setBundleLockState(v3, v5);
}

uint64_t llvm::MCELFStreamer::emitBundleUnlock(llvm::MCELFStreamer *this)
{
  uint64_t v2 = *((unsigned int *)this + 30);
  if (v2) {
    uint64_t v3 = *(void *)(*((void *)this + 14) + 32 * v2 - 32);
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *((void *)this + 34);
  if (!*(_DWORD *)(v4 + 496))
  {
    uint64_t v10 = ".bundle_unlock forbidden when bundling is disabled";
    goto LABEL_23;
  }
  if (!*(_DWORD *)(*(void *)(*((void *)this + 14) + 32 * v2 - 32) + 36))
  {
    uint64_t v10 = ".bundle_unlock without matching lock";
    goto LABEL_23;
  }
  if (*(unsigned char *)(v3 + 44))
  {
    uint64_t v10 = "Empty bundle-locked group is forbidden";
LABEL_23:
    llvm::report_fatal_error((llvm *)v10, (const llvm::Twine *)1);
  }
  if (*(unsigned char *)(v4 + 500))
  {
    uint64_t v6 = *(void *)(*((void *)this + 713) + 8 * *((unsigned int *)this + 1428) - 8);
    uint64_t result = llvm::MCSection::setBundleLockState(v3, 0);
    if (!*(_DWORD *)(*(void *)(*((void *)this + 14) + 32 * *((unsigned int *)this + 30) - 32) + 36))
    {
      uint64_t DataFragment = (llvm::MCFragment *)llvm::MCObjectStreamer::getOrCreateDataFragment(this, *(const llvm::MCSubtargetInfo **)(v6 + 56));
      llvm::MCELFStreamer::mergeFragment(this, DataFragment, v6);
      --*((_DWORD *)this + 1428);
      uint64_t v8 = *(void **)(v6 + 120);
      if (v8 != (void *)(v6 + 136)) {
        free(v8);
      }
      uint64_t v9 = *(void **)(v6 + 64);
      if (v9 != (void *)(v6 + 88)) {
        free(v9);
      }
      uint64_t result = MEMORY[0x1D25D9CE0](v6, 0x10E0C400AE5E4C8);
    }
    if (*(_DWORD *)(v3 + 36) != 2)
    {
      uint64_t result = llvm::MCObjectStreamer::getOrCreateDataFragment(this, 0);
      *(unsigned char *)(result + 51) = 0;
    }
  }
  else
  {
    return llvm::MCSection::setBundleLockState(v3, 0);
  }
  return result;
}

void llvm::MCELFStreamer::finishImpl(llvm::MCELFStreamer *this)
{
  if (*((_DWORD *)this + 782))
  {
    uint64_t v7 = 0;
    int v5 = ".gnu.attributes";
    __int16 v6 = 259;
    llvm::MCELFStreamer::createAttributesSection(this, (uint64_t)"gnu", 3, (llvm::Twine *)&v5, 1879048181, &v7, (uint64_t)this + 3120);
  }
  uint64_t v2 = *((unsigned int *)this + 30);
  if (v2)
  {
    uint64_t v3 = *(void *)(*((void *)this + 14) + 32 * v2 - 32);
    if (v3)
    {
      unint64_t v4 = *(unsigned int *)(*((void *)this + 34) + 496);
      if (v4)
      {
        if ((*(unsigned char *)(v3 + 44) & 2) != 0 && v4 > (1 << *(unsigned char *)(v3 + 24))) {
          *(unsigned char *)(v3 + 24) = __clz(v4) ^ 0x3F;
        }
      }
    }
  }
  llvm::MCELFStreamer::finalizeCGProfile((uint64_t *)this);
  llvm::MCObjectStreamer::emitFrames(this, 0);
  llvm::MCObjectStreamer::finishImpl((llvm::MCContext **)this);
}

void llvm::MCELFStreamer::createAttributesSection(llvm::MCStreamer *a1, uint64_t a2, uint64_t a3, llvm::Twine *a4, int a5, uint64_t *a6, uint64_t a7)
{
  if (*a6)
  {
    uint64_t v14 = (*(uint64_t (**)(llvm::MCStreamer *, uint64_t, void, llvm::Twine *))(*(void *)a1 + 168))(a1, *a6, 0, a4);
  }
  else
  {
    __int16 v12 = (llvm::MCContext *)*((void *)a1 + 1);
    LOWORD(v30) = 257;
    uint64_t ELFSection = llvm::MCContext::getELFSection(v12, a4, a5, 0, 0, (const llvm::Twine *)&v27, 0, -1, 0);
    *a6 = ELFSection;
    (*(void (**)(llvm::MCStreamer *, uint64_t, void))(*(void *)a1 + 168))(a1, ELFSection, 0);
    uint64_t v14 = (*(uint64_t (**)(llvm::MCStreamer *, uint64_t, uint64_t))(*(void *)a1 + 520))(a1, 65, 1);
  }
  uint64_t v15 = llvm::MCELFStreamer::calculateContentSize(v14, a7);
  (*(void (**)(llvm::MCStreamer *, uint64_t, uint64_t))(*(void *)a1 + 520))(a1, a3 + v15 + 10, 4);
  (*(void (**)(llvm::MCStreamer *, uint64_t, uint64_t))(*(void *)a1 + 488))(a1, a2, a3);
  (*(void (**)(llvm::MCStreamer *, void, uint64_t))(*(void *)a1 + 520))(a1, 0, 1);
  (*(void (**)(llvm::MCStreamer *, uint64_t, uint64_t))(*(void *)a1 + 520))(a1, 1, 1);
  (*(void (**)(llvm::MCStreamer *, uint64_t, uint64_t))(*(void *)a1 + 520))(a1, v15 + 5, 4);
  if (*(_DWORD *)(a7 + 8))
  {
    uint64_t v16 = 0;
    unint64_t v17 = 0;
    do
    {
      uint64_t v18 = *(void *)a7 + v16;
      int v19 = *(_DWORD *)(v18 + 8);
      unint64_t v27 = *(void *)v18;
      LODWORD(v28) = v19;
      __int16 v20 = (const void **)(v18 + 16);
      if (*(char *)(v18 + 39) < 0)
      {
        sub_1CB8BDF7C((uint64_t)&__p, *v20, *(void *)(v18 + 24));
      }
      else
      {
        long long v21 = *(_OWORD *)v20;
        uint64_t v30 = *(void *)(v18 + 32);
        long long __p = v21;
      }
      llvm::MCStreamer::emitULEB128IntValue(a1, HIDWORD(v27), 0);
      if (v27 == 1)
      {
        llvm::MCStreamer::emitULEB128IntValue(a1, v28, 0);
      }
      else
      {
        if (v27 != 2) {
          llvm::MCStreamer::emitULEB128IntValue(a1, v28, 0);
        }
        if (v30 >= 0) {
          p_p = &__p;
        }
        else {
          p_p = (long long *)__p;
        }
        if (v30 >= 0) {
          uint64_t v23 = HIBYTE(v30) & 0x7F;
        }
        else {
          uint64_t v23 = *((void *)&__p + 1);
        }
        (*(void (**)(llvm::MCStreamer *, long long *, uint64_t))(*(void *)a1 + 488))(a1, p_p, v23);
        (*(void (**)(llvm::MCStreamer *, void, uint64_t))(*(void *)a1 + 520))(a1, 0, 1);
      }
      if (SHIBYTE(v30) < 0) {
        operator delete((void *)__p);
      }
      ++v17;
      unint64_t v24 = *(unsigned int *)(a7 + 8);
      v16 += 40;
    }
    while (v17 < v24);
    if (v24)
    {
      uint64_t v25 = *(void *)a7;
      uint64_t v26 = 40 * v24;
      do
      {
        if (*(char *)(v25 + v26 - 1) < 0) {
          operator delete(*(void **)(v25 + v26 - 24));
        }
        v26 -= 40;
      }
      while (v26);
    }
  }
  *(_DWORD *)(a7 + 8) = 0;
}

unint64_t sub_1CD6AE42C(uint64_t a1, unint64_t a2)
{
  unint64_t result = sub_1CD6AE8C8(a1, a2);
  uint64_t v4 = *(void *)a1 + 40 * *(unsigned int *)(a1 + 8);
  uint64_t v5 = *(void *)result;
  *(_DWORD *)(v4 + 8) = *(_DWORD *)(result + 8);
  *(void *)uint64_t v4 = v5;
  uint64_t v6 = v4 + 16;
  if (*(char *)(result + 39) < 0)
  {
    unint64_t result = (unint64_t)sub_1CB8BDF7C(v6, *(const void **)(result + 16), *(void *)(result + 24));
  }
  else
  {
    long long v7 = *(_OWORD *)(result + 16);
    *(void *)(v6 + 16) = *(void *)(result + 32);
    *(_OWORD *)uint64_t v6 = v7;
  }
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t llvm::MCELFStreamer::calculateContentSize(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 8))
  {
    uint64_t v3 = 0;
    unint64_t v4 = 0;
    uint64_t v5 = 0;
    while (1)
    {
      uint64_t v6 = *(void *)a2 + v3;
      uint64_t v16 = *(llvm **)v6;
      unsigned int v17 = *(_DWORD *)(v6 + 8);
      long long v7 = (const void **)(v6 + 16);
      if (*(char *)(v6 + 39) < 0)
      {
        sub_1CB8BDF7C((uint64_t)&__p, *v7, *(void *)(v6 + 24));
      }
      else
      {
        long long v8 = *(_OWORD *)v7;
        uint64_t v19 = *(void *)(v6 + 32);
        long long __p = v8;
      }
      if (v16 == 3)
      {
        unsigned int ULEB128Size = llvm::getULEB128Size(HIDWORD(v16));
        unsigned int v11 = llvm::getULEB128Size(v17);
        uint64_t v12 = HIBYTE(v19) & 0x7F;
        if (v19 < 0) {
          uint64_t v12 = *((void *)&__p + 1);
        }
        uint64_t v13 = v5 + ULEB128Size + v11;
      }
      else
      {
        if (v16 != 2)
        {
          if (v16 == 1)
          {
            uint64_t v9 = v5 + llvm::getULEB128Size(HIDWORD(v16));
            uint64_t v5 = v9 + llvm::getULEB128Size(v17);
          }
          goto LABEL_17;
        }
        unsigned int v14 = llvm::getULEB128Size(HIDWORD(v16));
        uint64_t v12 = HIBYTE(v19) & 0x7F;
        if (v19 < 0) {
          uint64_t v12 = *((void *)&__p + 1);
        }
        uint64_t v13 = v5 + v14;
      }
      uint64_t v5 = v13 + v12 + 1;
LABEL_17:
      if (SHIBYTE(v19) < 0) {
        operator delete((void *)__p);
      }
      ++v4;
      v3 += 40;
      if (v4 >= *(unsigned int *)(a2 + 8)) {
        return v5;
      }
    }
  }
  return 0;
}

void llvm::createELFStreamer()
{
}

void sub_1CD6AE748(uint64_t a1)
{
}

double sub_1CD6AE780(llvm::MCObjectStreamer *this)
{
  *((unsigned char *)this + 5696) = 0;
  *((_DWORD *)this + 1428) = 0;
  return llvm::MCObjectStreamer::reset(this);
}

void sub_1CD6AE790(uint64_t a1, int a2, int a3)
{
  v3[0] = 1;
  v3[1] = a2;
  void v3[2] = a3;
  char v5 = 0;
  LOBYTE(__p) = 0;
  sub_1CD6AE42C(a1 + 3120, (unint64_t)v3);
  if (v5 < 0) {
    operator delete(__p);
  }
}

void sub_1CD6AE7DC(uint64_t a1)
{
  *(void *)a1 = &unk_1F262E348;
  uint64_t v2 = *(void **)(a1 + 5704);
  if (v2 != (void *)(a1 + 5720)) {
    free(v2);
  }
  sub_1CD6AE854((char **)(a1 + 3120));
  sub_1CD6AE854((char **)(a1 + 544));

  llvm::MCObjectStreamer::~MCObjectStreamer((llvm::MCObjectStreamer *)a1);
}

char **sub_1CD6AE854(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 40 * v3;
    do
    {
      if (v2[v4 - 1] < 0) {
        operator delete(*(void **)&v2[v4 - 24]);
      }
      v4 -= 40;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

unint64_t sub_1CD6AE8C8(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 40 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      sub_1CD6AE934();
    }
    sub_1CD6AE934();
  }
  return a2;
}

void sub_1CD6AE934()
{
}

void sub_1CD6AE9A4(uint64_t **a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    uint64_t v3 = *a1;
    uint64_t v4 = (uint64_t)&(*a1)[5 * v2];
    do
    {
      uint64_t v5 = *v3;
      *(_DWORD *)(a2 + 8) = *((_DWORD *)v3 + 2);
      *(void *)a2 = v5;
      long long v6 = *((_OWORD *)v3 + 1);
      *(void *)(a2 + 32) = v3[4];
      *(_OWORD *)(a2 + 16) = v6;
      void v3[3] = 0;
      _DWORD v3[4] = 0;
      void v3[2] = 0;
      v3 += 5;
      a2 += 40;
    }
    while (v3 != (uint64_t *)v4);
    uint64_t v7 = *((unsigned int *)a1 + 2);
    if (v7)
    {
      long long v8 = *a1;
      uint64_t v9 = 5 * v7;
      do
      {
        if (SHIBYTE(v8[v9 - 1]) < 0) {
          operator delete((void *)v8[v9 - 3]);
        }
        v9 -= 5;
      }
      while (v9 * 8);
    }
  }
}

llvm::raw_ostream *llvm::MCExpr::print(llvm::raw_ostream *this, llvm::raw_ostream *a2, const llvm::MCAsmInfo *a3, char a4)
{
  int v6 = *(unsigned __int8 *)this;
  while (2)
  {
    while (1)
    {
      uint64_t v7 = this;
      if (v6 != 3) {
        break;
      }
      switch(*(_DWORD *)((unsigned char *)this + 1) & 0xFFFFFF)
      {
        case 0:
          long long v8 = (unsigned char *)*((void *)a2 + 4);
          if ((unint64_t)v8 >= *((void *)a2 + 3))
          {
            uint64_t v13 = a2;
            char v14 = 33;
            goto LABEL_20;
          }
          *((void *)a2 + 4) = v8 + 1;
          unsigned char *v8 = 33;
          break;
        case 1:
          unsigned int v11 = (unsigned char *)*((void *)a2 + 4);
          if ((unint64_t)v11 >= *((void *)a2 + 3))
          {
            uint64_t v13 = a2;
            char v14 = 45;
            goto LABEL_20;
          }
          *((void *)a2 + 4) = v11 + 1;
          *unsigned int v11 = 45;
          break;
        case 2:
          uint64_t v9 = (unsigned char *)*((void *)a2 + 4);
          if ((unint64_t)v9 >= *((void *)a2 + 3))
          {
            uint64_t v13 = a2;
            char v14 = 126;
            goto LABEL_20;
          }
          *((void *)a2 + 4) = v9 + 1;
          *uint64_t v9 = 126;
          break;
        case 3:
          uint64_t v10 = (unsigned char *)*((void *)a2 + 4);
          if ((unint64_t)v10 >= *((void *)a2 + 3))
          {
            uint64_t v13 = a2;
            char v14 = 43;
LABEL_20:
            llvm::raw_ostream::write(v13, v14);
          }
          else
          {
            *((void *)a2 + 4) = v10 + 1;
            *uint64_t v10 = 43;
          }
          break;
        default:
          break;
      }
      a4 = 0;
      this = (llvm::raw_ostream *)*((void *)v7 + 2);
      int v6 = *(unsigned __int8 *)this;
      if (!*(unsigned char *)this)
      {
        sub_1CB8E509C(a2, "(");
        llvm::MCExpr::print(*((llvm::MCExpr **)v7 + 2), a2, a3, 0);
        return sub_1CB8E509C(a2, ")");
      }
    }
    switch(v6)
    {
      case 1:
        uint64_t v22 = *((void *)this + 2);
        if (a3 && v22 < 0 && !*((unsigned char *)a3 + 280) || (*(_DWORD *)((unsigned char *)this + 1) & 0x100) != 0)
        {
          switch(*(_DWORD *)((char *)this + 1))
          {
            case 1u:
              uint64_t v25 = "0x%02llx";
              goto LABEL_60;
            case 2u:
              uint64_t v25 = "0x%04llx";
              goto LABEL_60;
            case 4u:
              uint64_t v25 = "0x%08llx";
              goto LABEL_60;
            case 8u:
              uint64_t v25 = "0x%016llx";
LABEL_60:
              v50[0] = &unk_1F2618EA8;
              v50[1] = v25;
              uint64_t v51 = v22;
              this = llvm::raw_ostream::operator<<(a2, (uint64_t)v50);
              break;
            default:
              uint64_t v30 = sub_1CB8E509C(a2, "0x");
              uint64_t v49 = v22;
              v50[0] = &v49;
              uint64_t v51 = 0;
              __int16 v52 = 270;
              this = llvm::Twine::print((llvm::Twine *)v50, v30);
              break;
          }
        }
        else
        {
          uint64_t v23 = a2;
          unint64_t v24 = *((void *)v7 + 2);
LABEL_45:
          this = llvm::raw_ostream::operator<<(v23, v24);
        }
        break;
      case 2:
        __int16 v20 = (llvm::MCSymbol *)*((void *)this + 2);
        if (a3
          && !(a4 & 1 | (*((unsigned char *)a3 + 430) == 0))
          && (*(unsigned char *)v20 & 4) != 0
          && (uint64_t v28 = *((void *)v20 - 1), *(void *)v28)
          && *(unsigned char *)(v28 + 16) == 36)
        {
          uint64_t v29 = (unsigned char *)*((void *)a2 + 4);
          if ((unint64_t)v29 >= *((void *)a2 + 3))
          {
            llvm::raw_ostream::write(a2, 40);
          }
          else
          {
            *((void *)a2 + 4) = v29 + 1;
            *uint64_t v29 = 40;
          }
          this = llvm::MCSymbol::print(v20, a2, a3);
          unint64_t v40 = (unsigned char *)*((void *)a2 + 4);
          if ((unint64_t)v40 >= *((void *)a2 + 3))
          {
            this = llvm::raw_ostream::write(a2, 41);
          }
          else
          {
            *((void *)a2 + 4) = v40 + 1;
            unsigned char *v40 = 41;
          }
        }
        else
        {
          this = llvm::MCSymbol::print(*((llvm::MCSymbol **)this + 2), a2, a3);
        }
        int v21 = *(_DWORD *)((char *)v7 + 1);
        if ((_WORD)v21)
        {
          if (a3 && *((unsigned char *)a3 + 429))
          {
            unint64_t v44 = (unsigned char *)*((void *)a2 + 4);
            if ((unint64_t)v44 >= *((void *)a2 + 3))
            {
              a2 = llvm::raw_ostream::write(a2, 40);
            }
            else
            {
              *((void *)a2 + 4) = v44 + 1;
              *unint64_t v44 = 40;
            }
            VariantKindName = llvm::MCSymbolRefExpr::getVariantKindName(v21);
            size_t v47 = v45;
            this = (llvm::raw_ostream *)*((void *)a2 + 4);
            if (v45 <= *((void *)a2 + 3) - (void)this)
            {
              if (v45)
              {
                memcpy(this, VariantKindName, v45);
                this = (llvm::raw_ostream *)(*((void *)a2 + 4) + v47);
                *((void *)a2 + 4) = this;
              }
            }
            else
            {
              llvm::raw_ostream::write(a2, VariantKindName, v45);
              this = (llvm::raw_ostream *)*((void *)a2 + 4);
            }
            if ((unint64_t)this >= *((void *)a2 + 3))
            {
LABEL_136:
              this = llvm::raw_ostream::write(a2, 41);
            }
            else
            {
              *((void *)a2 + 4) = (char *)this + 1;
              *(unsigned char *)this = 41;
            }
          }
          else
          {
            uint64_t v37 = (unsigned char *)*((void *)a2 + 4);
            if ((unint64_t)v37 >= *((void *)a2 + 3))
            {
              a2 = llvm::raw_ostream::write(a2, 64);
            }
            else
            {
              *((void *)a2 + 4) = v37 + 1;
              *uint64_t v37 = 64;
            }
            uint64_t v42 = llvm::MCSymbolRefExpr::getVariantKindName(v21);
            size_t v43 = v41;
            this = (llvm::raw_ostream *)*((void *)a2 + 4);
            if (v41 <= *((void *)a2 + 3) - (void)this)
            {
              if (v41)
              {
                this = (llvm::raw_ostream *)memcpy(this, v42, v41);
                *((void *)a2 + 4) += v43;
              }
            }
            else
            {
              this = llvm::raw_ostream::write(a2, v42, v41);
            }
          }
        }
        break;
      case 3:
        __break(1u);
        break;
      case 4:
        uint64_t v18 = *(uint64_t (**)(char *, llvm::raw_ostream *, const llvm::MCAsmInfo *))(*((void *)this - 1)
                                                                                             + 24);
        uint64_t v19 = (char *)this - 8;
        this = (llvm::raw_ostream *)v18(v19, a2, a3);
        break;
      default:
        uint64_t v12 = (llvm::MCExpr *)*((void *)this + 2);
        if (*(unsigned __int8 *)v12 - 1 > 1)
        {
          uint64_t v16 = (unsigned char *)*((void *)a2 + 4);
          if ((unint64_t)v16 >= *((void *)a2 + 3))
          {
            llvm::raw_ostream::write(a2, 40);
          }
          else
          {
            *((void *)a2 + 4) = v16 + 1;
            *uint64_t v16 = 40;
          }
          llvm::MCExpr::print(*((llvm::MCExpr **)v7 + 2), a2, a3, 0);
          uint64_t v15 = (unsigned char *)*((void *)a2 + 4);
          if ((unint64_t)v15 >= *((void *)a2 + 3))
          {
            llvm::raw_ostream::write(a2, 41);
          }
          else
          {
            *((void *)a2 + 4) = v15 + 1;
            unsigned char *v15 = 41;
          }
        }
        else
        {
          llvm::MCExpr::print(v12, a2, a3, 0);
        }
        switch(*(_DWORD *)((unsigned char *)v7 + 1) & 0xFFFFFF)
        {
          case 0:
            uint64_t v34 = *((void *)v7 + 3);
            if (*(unsigned char *)v34 == 1)
            {
              unint64_t v24 = *(void *)(v34 + 16);
              if ((v24 & 0x8000000000000000) != 0)
              {
                uint64_t v23 = a2;
                goto LABEL_45;
              }
            }
            uint64_t v35 = (unsigned char *)*((void *)a2 + 4);
            if ((unint64_t)v35 < *((void *)a2 + 3))
            {
              *((void *)a2 + 4) = v35 + 1;
              *uint64_t v35 = 43;
              goto LABEL_28;
            }
            uint64_t v38 = a2;
            char v39 = 43;
            goto LABEL_112;
          case 1:
            unint64_t v32 = (char *)*((void *)a2 + 4);
            if ((unint64_t)v32 < *((void *)a2 + 3))
            {
              *((void *)a2 + 4) = v32 + 1;
              char v33 = 38;
              goto LABEL_93;
            }
            uint64_t v38 = a2;
            char v39 = 38;
            goto LABEL_112;
          case 2:
            unint64_t v32 = (char *)*((void *)a2 + 4);
            if ((unint64_t)v32 < *((void *)a2 + 3))
            {
              *((void *)a2 + 4) = v32 + 1;
              char v33 = 47;
              goto LABEL_93;
            }
            uint64_t v38 = a2;
            char v39 = 47;
            goto LABEL_112;
          case 3:
            uint64_t v26 = a2;
            unint64_t v27 = "==";
            goto LABEL_27;
          case 4:
            unint64_t v32 = (char *)*((void *)a2 + 4);
            if ((unint64_t)v32 < *((void *)a2 + 3))
            {
              *((void *)a2 + 4) = v32 + 1;
              char v33 = 62;
              goto LABEL_93;
            }
            uint64_t v38 = a2;
            char v39 = 62;
            goto LABEL_112;
          case 5:
            uint64_t v26 = a2;
            unint64_t v27 = ">=";
            goto LABEL_27;
          case 6:
            uint64_t v26 = a2;
            unint64_t v27 = "&&";
            goto LABEL_27;
          case 7:
            uint64_t v26 = a2;
            unint64_t v27 = "||";
            goto LABEL_27;
          case 8:
            unint64_t v32 = (char *)*((void *)a2 + 4);
            if ((unint64_t)v32 < *((void *)a2 + 3))
            {
              *((void *)a2 + 4) = v32 + 1;
              char v33 = 60;
              goto LABEL_93;
            }
            uint64_t v38 = a2;
            char v39 = 60;
            goto LABEL_112;
          case 9:
            uint64_t v26 = a2;
            unint64_t v27 = "<=";
            goto LABEL_27;
          case 0xA:
            unint64_t v32 = (char *)*((void *)a2 + 4);
            if ((unint64_t)v32 < *((void *)a2 + 3))
            {
              *((void *)a2 + 4) = v32 + 1;
              char v33 = 37;
              goto LABEL_93;
            }
            uint64_t v38 = a2;
            char v39 = 37;
            goto LABEL_112;
          case 0xB:
            unint64_t v32 = (char *)*((void *)a2 + 4);
            if ((unint64_t)v32 < *((void *)a2 + 3))
            {
              *((void *)a2 + 4) = v32 + 1;
              char v33 = 42;
              goto LABEL_93;
            }
            uint64_t v38 = a2;
            char v39 = 42;
            goto LABEL_112;
          case 0xC:
            uint64_t v26 = a2;
            unint64_t v27 = "!=";
            goto LABEL_27;
          case 0xD:
            unint64_t v32 = (char *)*((void *)a2 + 4);
            if ((unint64_t)v32 < *((void *)a2 + 3))
            {
              *((void *)a2 + 4) = v32 + 1;
              char v33 = 124;
              goto LABEL_93;
            }
            uint64_t v38 = a2;
            char v39 = 124;
            goto LABEL_112;
          case 0xE:
            long long v31 = (unsigned char *)*((void *)a2 + 4);
            if ((unint64_t)v31 < *((void *)a2 + 3))
            {
              *((void *)a2 + 4) = v31 + 1;
              *long long v31 = 33;
              goto LABEL_28;
            }
            uint64_t v38 = a2;
            char v39 = 33;
            goto LABEL_112;
          case 0xF:
            uint64_t v26 = a2;
            unint64_t v27 = "<<";
            goto LABEL_27;
          case 0x10:
          case 0x11:
            uint64_t v26 = a2;
            unint64_t v27 = ">>";
LABEL_27:
            sub_1CB8E509C(v26, v27);
            goto LABEL_28;
          case 0x12:
            uint64_t v36 = (unsigned char *)*((void *)a2 + 4);
            if ((unint64_t)v36 < *((void *)a2 + 3))
            {
              *((void *)a2 + 4) = v36 + 1;
              *uint64_t v36 = 45;
              goto LABEL_28;
            }
            uint64_t v38 = a2;
            char v39 = 45;
            goto LABEL_112;
          case 0x13:
            unint64_t v32 = (char *)*((void *)a2 + 4);
            if ((unint64_t)v32 >= *((void *)a2 + 3))
            {
              uint64_t v38 = a2;
              char v39 = 94;
LABEL_112:
              llvm::raw_ostream::write(v38, v39);
            }
            else
            {
              *((void *)a2 + 4) = v32 + 1;
              char v33 = 94;
LABEL_93:
              *unint64_t v32 = v33;
            }
LABEL_28:
            a4 = 0;
            this = (llvm::raw_ostream *)*((void *)v7 + 3);
            int v6 = *(unsigned __int8 *)this;
            if ((v6 - 1) < 2) {
              continue;
            }
            unsigned int v17 = (unsigned char *)*((void *)a2 + 4);
            if ((unint64_t)v17 >= *((void *)a2 + 3))
            {
              llvm::raw_ostream::write(a2, 40);
            }
            else
            {
              *((void *)a2 + 4) = v17 + 1;
              *unsigned int v17 = 40;
            }
            this = (llvm::raw_ostream *)llvm::MCExpr::print(*((llvm::MCExpr **)v7 + 3), a2, a3, 0);
            uint64_t v48 = (unsigned char *)*((void *)a2 + 4);
            if ((unint64_t)v48 >= *((void *)a2 + 3)) {
              goto LABEL_136;
            }
            *((void *)a2 + 4) = v48 + 1;
            *uint64_t v48 = 41;
            break;
          default:
            goto LABEL_28;
        }
        break;
    }
    return this;
  }
}

char *llvm::MCSymbolRefExpr::getVariantKindName(__int16 a1)
{
  return off_1E684AEB0[a1];
}

llvm *llvm::MCExpr::dump(llvm::MCExpr *this)
{
  unsigned int v2 = llvm::dbgs(this);
  uint64_t v3 = llvm::MCExpr::print(this, v2, 0, 0);
  unint64_t result = llvm::dbgs(v3);
  uint64_t v5 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v5 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v5 + 1;
    *uint64_t v5 = 10;
  }
  return result;
}

uint64_t llvm::MCUnaryExpr::create(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = sub_1CB906F34((uint64_t *)(a3 + 192), 24, 3);
  *(unsigned char *)uint64_t result = 3;
  *(_DWORD *)(result + 1) = a1 & 0xFFFFFF | (*(unsigned __int8 *)(result + 4) << 24);
  *(void *)(result + 8) = a4;
  *(void *)(result + 16) = a2;
  return result;
}

uint64_t llvm::MCExpr::evaluateAsAbsolute(llvm::MCExpr *this, uint64_t *a2)
{
  return llvm::MCExpr::evaluateAsAbsolute((uint64_t)this, a2, 0, 0, 0, 0);
}

uint64_t llvm::MCExpr::evaluateAsAbsolute(uint64_t a1, void *a2, uint64_t **a3, uint64_t *a4)
{
  return llvm::MCExpr::evaluateAsAbsolute(a1, a2, *a3, (uint64_t)a3, a4, 1);
}

uint64_t llvm::MCExpr::evaluateAsValue(llvm::MCExpr *this, llvm::MCValue *a2, uint64_t **a3)
{
  return llvm::MCExpr::evaluateAsRelocatableImpl((uint64_t)this, (uint64_t)a2, *a3, (uint64_t)a3, 0, 0, 1);
}

uint64_t llvm::MCAsmLayout::getSymbolOffset(llvm::MCAsmLayout *this, const llvm::MCSymbol *a2, unint64_t *a3)
{
  return sub_1CCBC6418(this, a2, 0, a3);
}

const llvm::MCSymbol *llvm::MCAsmLayout::getBaseSymbol(uint64_t **this, const llvm::MCSymbol *a2)
{
  if ((*((_DWORD *)a2 + 2) & 0x1C00) == 0x800)
  {
    *((_DWORD *)a2 + 2) |= 4u;
    uint64_t v3 = *((void *)a2 + 3);
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    int v32 = 0;
    uint64_t v31 = 0;
    if (llvm::MCExpr::evaluateAsRelocatableImpl(v3, (uint64_t)&v29, *this, (uint64_t)this, 0, 0, 1))
    {
      if (v30)
      {
        uint64_t v4 = **this;
        uint64_t v5 = *(void *)(v3 + 8);
        v23[0] = (uint64_t)"symbol '";
        __int16 v24 = 259;
        int v6 = *(unsigned char **)(v30 + 16);
        if ((*v6 & 4) != 0)
        {
          char v14 = (uint64_t *)*((void *)v6 - 1);
          uint64_t v15 = *v14;
          uint64_t v7 = (uint64_t)(v14 + 2);
          uint64_t v8 = v15;
        }
        else
        {
          uint64_t v7 = 0;
          uint64_t v8 = 0;
        }
        __int16 v22 = 261;
        v21[0] = v7;
        v21[1] = v8;
        sub_1CB8F1E58(v23, v21, (uint64_t)v25);
        uint64_t v19 = "' could not be evaluated in a subtraction expression";
        __int16 v20 = 259;
        uint64_t v16 = (uint64_t *)&v19;
      }
      else
      {
        if (!v29) {
          return 0;
        }
        a2 = *(const llvm::MCSymbol **)(v29 + 16);
        if (((*((_DWORD *)a2 + 2) >> 10) & 7u) - 3 > 1) {
          return a2;
        }
        uint64_t v4 = **this;
        uint64_t v5 = *(void *)(v3 + 8);
        if ((*(unsigned char *)a2 & 4) != 0)
        {
          unsigned int v17 = (uint64_t *)*((void *)a2 - 1);
          uint64_t v18 = *v17;
          uint64_t v12 = (uint64_t)(v17 + 2);
          uint64_t v13 = v18;
        }
        else
        {
          uint64_t v12 = 0;
          uint64_t v13 = 0;
        }
        __int16 v26 = 1283;
        v25[0] = (uint64_t)"Common symbol '";
        v25[2] = v12;
        v25[3] = v13;
        v23[0] = (uint64_t)"' cannot be used in assignment expr";
        __int16 v24 = 259;
        uint64_t v16 = v23;
      }
      sub_1CB8F1E58(v25, v16, (uint64_t)v27);
      uint64_t v9 = v4;
      uint64_t v10 = v5;
    }
    else
    {
      uint64_t v9 = **this;
      uint64_t v10 = *(void *)(v3 + 8);
      v27[0] = "expression could not be evaluated";
      __int16 v28 = 259;
    }
    llvm::MCContext::reportError(v9, v10, (uint64_t)v27);
    return 0;
  }
  return a2;
}

unint64_t llvm::computeBundlePadding(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = *(unsigned int *)(a1 + 496);
  uint64_t v5 = (v4 - 1) & a3;
  unint64_t v6 = v5 + a4;
  if (*(unsigned char *)(a2 + 51))
  {
    unint64_t result = v4 - v6;
    if (v4 != v6 && v4 <= v6) {
      return 2 * v4 - v6;
    }
  }
  else if (v4 >= v6 || v5 == 0)
  {
    return 0;
  }
  else
  {
    return v4 - v5;
  }
  return result;
}

llvm::raw_ostream *llvm::MCFragment::dump(llvm::MCFragment *this)
{
  unsigned int v2 = (llvm::raw_ostream *)llvm::errs(this);
  sub_1CB8E509C(v2, "<");
  unint64_t v3 = *((char *)this + 48);
  if (v3 <= 0x10) {
    sub_1CB8E509C(v2, off_1E684B3B0[v3]);
  }
  unint64_t v4 = sub_1CB8E509C(v2, "<MCFragment ");
  uint64_t v5 = llvm::raw_ostream::operator<<(v4, (unint64_t)this);
  unint64_t v6 = sub_1CB8E509C(v5, " LayoutOrder:");
  uint64_t v7 = llvm::raw_ostream::operator<<(v6, *((unsigned int *)this + 10));
  uint64_t v8 = sub_1CB8E509C(v7, " Offset:");
  uint64_t v9 = llvm::raw_ostream::operator<<(v8, *((void *)this + 4));
  uint64_t v10 = sub_1CB8E509C(v9, " HasInstructions:");
  llvm::raw_ostream::operator<<(v10, *((unsigned __int8 *)this + 50));
  unsigned int v11 = *((unsigned __int8 *)this + 48);
  if (v11 <= 0xF && ((1 << v11) & 0x834A) != 0)
  {
    uint64_t v12 = sub_1CB8E509C(v2, " BundlePadding:");
    llvm::raw_ostream::operator<<(v12, *((unsigned __int8 *)this + 52));
  }
  sub_1CB8E509C(v2, ">");
  switch(*((unsigned char *)this + 48))
  {
    case 0:
      if (*((unsigned char *)this + 56)) {
        sub_1CB8E509C(v2, " (emit nops)");
      }
      sub_1CB8E509C(v2, "\n       ");
      uint64_t v15 = sub_1CB8E509C(v2, " Alignment:");
      uint64_t v16 = llvm::raw_ostream::operator<<(v15, *((unsigned int *)this + 13));
      unsigned int v17 = sub_1CB8E509C(v16, " Value:");
      uint64_t v18 = llvm::raw_ostream::operator<<(v17, *((void *)this + 8));
      uint64_t v19 = sub_1CB8E509C(v18, " ValueSize:");
      __int16 v20 = llvm::raw_ostream::operator<<(v19, *((unsigned int *)this + 18));
      int v21 = sub_1CB8E509C(v20, " MaxBytesToEmit:");
      __int16 v22 = llvm::raw_ostream::operator<<(v21, *((unsigned int *)this + 19));
      uint64_t v23 = ">";
      goto LABEL_49;
    case 1:
      sub_1CB8E509C(v2, "\n       ");
      sub_1CB8E509C(v2, " Contents:[");
      uint64_t v24 = *((unsigned int *)this + 18);
      if (*((_DWORD *)this + 18))
      {
        uint64_t v25 = 0;
        do
        {
          if (v25) {
            sub_1CB8E509C(v2, ",");
          }
          char v26 = a0123456789abcd_6[(unint64_t)*(unsigned __int8 *)(*((void *)this + 8) + v25) >> 4];
          unint64_t v27 = (char *)*((void *)v2 + 4);
          if ((unint64_t)v27 >= *((void *)v2 + 3))
          {
            __int16 v28 = llvm::raw_ostream::write(v2, v26);
          }
          else
          {
            *((void *)v2 + 4) = v27 + 1;
            *unint64_t v27 = v26;
            __int16 v28 = v2;
          }
          char v29 = a0123456789abcd_6[*(unsigned char *)(*((void *)this + 8) + v25) & 0xF];
          uint64_t v30 = (char *)*((void *)v28 + 4);
          if ((unint64_t)v30 >= *((void *)v28 + 3))
          {
            llvm::raw_ostream::write(v28, v29);
          }
          else
          {
            *((void *)v28 + 4) = v30 + 1;
            *uint64_t v30 = v29;
          }
          ++v25;
        }
        while (v24 != v25);
      }
      uint64_t v31 = sub_1CB8E509C(v2, "] (");
      int v32 = llvm::raw_ostream::operator<<(v31, *((void *)this + 9));
      sub_1CB8E509C(v32, " bytes)");
      if (!*((_DWORD *)this + 32)) {
        break;
      }
      sub_1CB8E509C(v2, ",\n       ");
      sub_1CB8E509C(v2, " Fixups:[");
      uint64_t v33 = *((unsigned int *)this + 32);
      if (v33)
      {
        uint64_t v34 = *((void *)this + 15);
        uint64_t v35 = 24 * v33;
        do
        {
          if (v34 != *((void *)this + 15)) {
            sub_1CB8E509C(v2, ",\n                ");
          }
          llvm::operator<<(v2, v34);
          v34 += 24;
          v35 -= 24;
        }
        while (v35);
      }
      uint64_t v23 = "]";
      __int16 v22 = v2;
      goto LABEL_49;
    case 2:
      uint64_t v36 = sub_1CB8E509C(v2, " FileName:");
      uint64_t v37 = (const void *)*((void *)this + 7);
      unint64_t v38 = *((void *)this + 8);
      char v39 = (void *)*((void *)v36 + 4);
      if (v38 <= *((void *)v36 + 3) - (void)v39)
      {
        if (v38)
        {
          memcpy(v39, v37, *((void *)this + 8));
          *((void *)v36 + 4) += v38;
        }
      }
      else
      {
        llvm::raw_ostream::write(v36, (const char *)v37, *((void *)this + 8));
      }
      unint64_t v40 = sub_1CB8E509C(v2, " Offset:");
      llvm::raw_ostream::operator<<(v40, *((unsigned int *)this + 36));
      size_t v41 = sub_1CB8E509C(v2, " Size:");
      unint64_t v42 = *((unsigned int *)this + 38);
      goto LABEL_54;
    case 3:
      sub_1CB8E509C(v2, "\n       ");
      sub_1CB8E509C(v2, " Contents:[");
      uint64_t v43 = *((unsigned int *)this + 18);
      if (*((_DWORD *)this + 18))
      {
        uint64_t v44 = 0;
        do
        {
          if (v44) {
            sub_1CB8E509C(v2, ",");
          }
          char v45 = a0123456789abcd_6[(unint64_t)*(unsigned __int8 *)(*((void *)this + 8) + v44) >> 4];
          unint64_t v46 = (char *)*((void *)v2 + 4);
          if ((unint64_t)v46 >= *((void *)v2 + 3))
          {
            size_t v47 = llvm::raw_ostream::write(v2, v45);
          }
          else
          {
            *((void *)v2 + 4) = v46 + 1;
            *unint64_t v46 = v45;
            size_t v47 = v2;
          }
          char v48 = a0123456789abcd_6[*(unsigned char *)(*((void *)this + 8) + v44) & 0xF];
          uint64_t v49 = (char *)*((void *)v47 + 4);
          if ((unint64_t)v49 >= *((void *)v47 + 3))
          {
            llvm::raw_ostream::write(v47, v48);
          }
          else
          {
            *((void *)v47 + 4) = v49 + 1;
            char *v49 = v48;
          }
          ++v44;
        }
        while (v43 != v44);
      }
      uint64_t v50 = "] (";
      goto LABEL_48;
    case 4:
      uint64_t v51 = sub_1CB8E509C(v2, " Value:");
      __int16 v52 = llvm::raw_ostream::operator<<(v51, *((unsigned int *)this + 14));
      unint64_t v53 = sub_1CB8E509C(v52, " ValueSize:");
      uint64_t v54 = llvm::raw_ostream::operator<<(v53, *((unsigned __int8 *)this + 51));
      uint64_t v13 = sub_1CB8E509C(v54, " NumValues:");
      char v14 = (llvm::raw_ostream *)*((void *)this + 8);
      goto LABEL_8;
    case 5:
      uint64_t v55 = sub_1CB8E509C(v2, " NumBytes:");
      uint64_t v56 = llvm::raw_ostream::operator<<(v55, *((void *)this + 7));
      unint64_t v57 = sub_1CB8E509C(v56, " ControlledNopLength:");
      unint64_t v58 = *((void *)this + 8);
      goto LABEL_56;
    case 6:
      sub_1CB8E509C(v2, "\n       ");
      sub_1CB8E509C(v2, " Inst:");
      llvm::MCInst::dump_pretty((unsigned int *)this + 34, v2, 0, " ", 1uLL, 0);
      uint64_t v50 = " (";
LABEL_48:
      uint64_t v59 = sub_1CB8E509C(v2, v50);
      __int16 v22 = llvm::raw_ostream::operator<<(v59, *((void *)this + 9));
      uint64_t v23 = " bytes)";
LABEL_49:
      sub_1CB8E509C(v22, v23);
      break;
    case 7:
      sub_1CB8E509C(v2, "\n       ");
      uint64_t v61 = sub_1CB8E509C(v2, " Offset:");
      llvm::MCExpr::print(*((llvm::raw_ostream **)this + 7), v61, 0, 0);
      size_t v41 = sub_1CB8E509C(v61, " Value:");
      unint64_t v42 = *((unsigned __int8 *)this + 51);
LABEL_54:
      llvm::raw_ostream::operator<<(v41, v42);
      break;
    case 8:
      sub_1CB8E509C(v2, "\n       ");
      uint64_t v62 = sub_1CB8E509C(v2, " AddrDelta:");
      llvm::MCExpr::print(*((llvm::raw_ostream **)this + 18), v62, 0, 0);
      unint64_t v57 = sub_1CB8E509C(v62, " LineDelta:");
      unint64_t v58 = *((void *)this + 17);
LABEL_56:
      llvm::raw_ostream::operator<<(v57, v58);
      break;
    case 9:
    case 0xF:
      sub_1CB8E509C(v2, "\n       ");
      uint64_t v13 = sub_1CB8E509C(v2, " AddrDelta:");
      char v14 = (llvm::raw_ostream *)*((void *)this + 17);
LABEL_8:
      llvm::MCExpr::print(v14, v13, 0, 0);
      break;
    case 0xA:
      sub_1CB8E509C(v2, "\n       ");
      std::string v63 = sub_1CB8E509C(v2, " Value:");
      llvm::MCExpr::print(*((llvm::raw_ostream **)this + 7), v63, 0, 0);
      int v64 = sub_1CB8E509C(v63, " Signed:");
      llvm::raw_ostream::operator<<(v64, *((unsigned __int8 *)this + 51));
      break;
    case 0xB:
      sub_1CB8E509C(v2, "\n       ");
      char v65 = sub_1CB8E509C(v2, " BoundarySize:");
      std::string v66 = llvm::raw_ostream::operator<<(v65, 1 << *((unsigned char *)this + 51));
      uint64_t v67 = sub_1CB8E509C(v66, " LastFragment:");
      std::string v68 = llvm::raw_ostream::operator<<(v67, *((void *)this + 7));
      uint64_t v69 = sub_1CB8E509C(v68, " Size:");
      llvm::raw_ostream::operator<<(v69, *((void *)this + 8));
      break;
    case 0xC:
      sub_1CB8E509C(v2, "\n       ");
      uint64_t v70 = sub_1CB8E509C(v2, " Sym:");
      llvm::raw_ostream::operator<<(v70, *((void *)this + 7));
      break;
    case 0xD:
      sub_1CB8E509C(v2, "\n       ");
      uint64_t v71 = sub_1CB8E509C(v2, " Sym:");
      llvm::MCSymbol::print(*((llvm::MCSymbol **)this + 8), v71, 0);
      break;
    case 0xE:
      sub_1CB8E509C(v2, "\n       ");
      uint64_t v72 = *((unsigned int *)this + 60);
      if (v72)
      {
        uint64_t v73 = (unint64_t *)*((void *)this + 29);
        uint64_t v74 = &v73[2 * v72];
        do
        {
          unint64_t v75 = *v73;
          unint64_t v76 = v73[1];
          v73 += 2;
          unint64_t v77 = sub_1CB8E509C(v2, " RangeStart:");
          llvm::raw_ostream::operator<<(v77, v75);
          uint64_t v78 = sub_1CB8E509C(v2, " RangeEnd:");
          llvm::raw_ostream::operator<<(v78, v76);
        }
        while (v73 != v74);
      }
      break;
    default:
      break;
  }

  return sub_1CB8E509C(v2, ">");
}

void *sub_1CD6AFF7C(void *a1)
{
  unsigned int v2 = (void *)a1[35];
  if (v2 != a1 + 38) {
    free(v2);
  }
  unint64_t v3 = (void *)a1[29];
  if (v3 != a1 + 31) {
    free(v3);
  }
  unint64_t v4 = (void *)a1[15];
  if (v4 != a1 + 17) {
    free(v4);
  }
  uint64_t v5 = (void *)a1[8];
  if (v5 != a1 + 11) {
    free(v5);
  }
  return a1;
}

llvm::raw_ostream *llvm::MCOperand::print(llvm::MCOperand *this, llvm::raw_ostream *a2, const llvm::MCRegisterInfo *a3)
{
  sub_1CB8E509C(a2, "<MCOperand ");
  switch(*(unsigned char *)this)
  {
    case 0:
      unint64_t v6 = "INVALID";
      goto LABEL_4;
    case 1:
      sub_1CB8E509C(a2, "Reg:");
      unint64_t v9 = *((unsigned int *)this + 2);
      if (a3)
      {
        unint64_t v6 = (char *)(*((void *)a3 + 8) + *(unsigned int *)(*(void *)a3 + 24 * v9));
LABEL_4:
        uint64_t v7 = a2;
LABEL_5:
        sub_1CB8E509C(v7, v6);
      }
      else
      {
        llvm::raw_ostream::operator<<(a2, v9);
      }
LABEL_6:
      return sub_1CB8E509C(a2, ">");
    case 2:
      uint64_t v10 = sub_1CB8E509C(a2, "Imm:");
      llvm::raw_ostream::operator<<(v10, *((void *)this + 1));
      goto LABEL_6;
    case 3:
      unsigned int v11 = sub_1CB8E509C(a2, "SFPImm:");
      double v12 = *((float *)this + 2);
      goto LABEL_14;
    case 4:
      unsigned int v11 = sub_1CB8E509C(a2, "DFPImm:");
      double v12 = *((double *)this + 1);
LABEL_14:
      llvm::raw_ostream::operator<<(v11, v12);
      goto LABEL_6;
    case 5:
      uint64_t v13 = sub_1CB8E509C(a2, "Expr:(");
      llvm::MCExpr::print(*((llvm::raw_ostream **)this + 1), v13, 0, 0);
      unint64_t v6 = ")";
      uint64_t v7 = v13;
      goto LABEL_5;
    case 6:
      sub_1CB8E509C(a2, "Inst:(");
      llvm::MCInst::print(*((llvm::MCInst **)this + 1), a2, a3);
      unint64_t v6 = ")";
      goto LABEL_4;
    default:
      unint64_t v6 = "UNDEFINED";
      goto LABEL_4;
  }
}

llvm::raw_ostream *llvm::MCInst::print(llvm::MCInst *this, llvm::raw_ostream *a2, const llvm::MCRegisterInfo *a3)
{
  unint64_t v6 = sub_1CB8E509C(a2, "<MCInst ");
  llvm::raw_ostream::operator<<(v6, *(unsigned int *)this);
  uint64_t v7 = *((unsigned int *)this + 6);
  if (v7)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 16 * v7;
    do
    {
      sub_1CB8E509C(a2, " ");
      llvm::MCOperand::print((llvm::MCOperand *)(*((void *)this + 2) + v8), a2, a3);
      v8 += 16;
    }
    while (v9 != v8);
  }

  return sub_1CB8E509C(a2, ">");
}

llvm::raw_ostream *llvm::MCOperand::dump(llvm::MCOperand *this)
{
  unsigned int v2 = llvm::dbgs(this);
  unint64_t v3 = llvm::MCOperand::print(this, v2, 0);
  unint64_t v4 = llvm::dbgs(v3);

  return sub_1CB8E509C(v4, "\n");
}

llvm::raw_ostream *llvm::MCInst::dump_pretty(unsigned int *a1, llvm::raw_ostream *a2, llvm::MCInstPrinter *a3, const void *a4, size_t a5, const llvm::MCRegisterInfo *a6)
{
  if (a3)
  {
    OpcodeName = (const char *)llvm::MCInstPrinter::getOpcodeName(a3, *a1);
    size_t v11 = v13;
  }
  else
  {
    size_t v11 = 0;
    OpcodeName = "";
  }

  return llvm::MCInst::dump_pretty(a1, a2, OpcodeName, v11, a4, a5, a6);
}

llvm::raw_ostream *llvm::MCInst::dump_pretty(unsigned int *a1, llvm::raw_ostream *a2, const void *a3, size_t a4, const void *a5, size_t a6, const llvm::MCRegisterInfo *a7)
{
  char v14 = sub_1CB8E509C(a2, "<MCInst #");
  llvm::raw_ostream::operator<<(v14, *a1);
  if (a4)
  {
    uint64_t v15 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v15 >= *((void *)a2 + 3))
    {
      uint64_t v16 = llvm::raw_ostream::write(a2, 32);
    }
    else
    {
      *((void *)a2 + 4) = v15 + 1;
      unsigned char *v15 = 32;
      uint64_t v16 = a2;
    }
    unsigned int v17 = (void *)*((void *)v16 + 4);
    if (a4 <= *((void *)v16 + 3) - (void)v17)
    {
      memcpy(v17, a3, a4);
      *((void *)v16 + 4) += a4;
    }
    else
    {
      llvm::raw_ostream::write(v16, (const char *)a3, a4);
    }
  }
  uint64_t v18 = a1[6];
  if (v18)
  {
    uint64_t v19 = 0;
    uint64_t v20 = 16 * v18;
    do
    {
      int v21 = (void *)*((void *)a2 + 4);
      if (a6 <= *((void *)a2 + 3) - (void)v21)
      {
        if (a6)
        {
          memcpy(v21, a5, a6);
          *((void *)a2 + 4) += a6;
        }
      }
      else
      {
        llvm::raw_ostream::write(a2, (const char *)a5, a6);
      }
      llvm::MCOperand::print((llvm::MCOperand *)(*((void *)a1 + 2) + v19), a2, a7);
      v19 += 16;
    }
    while (v20 != v19);
  }

  return sub_1CB8E509C(a2, ">");
}

llvm::raw_ostream *llvm::MCInst::dump(llvm::MCInst *this)
{
  unsigned int v2 = llvm::dbgs(this);
  unint64_t v3 = llvm::MCInst::print(this, v2, 0);
  unint64_t v4 = llvm::dbgs(v3);

  return sub_1CB8E509C(v4, "\n");
}

uint64_t llvm::MCInstPrinter::getOpcodeName(llvm::MCInstPrinter *this, unsigned int a2)
{
  uint64_t v2 = *(void *)(*((void *)this + 3) + 16);
  uint64_t v3 = *(unsigned int *)(*(void *)(*((void *)this + 3) + 8) + 4 * a2);
  uint64_t v4 = v2 + v3;
  if (v2) {
    strlen((const char *)(v2 + v3));
  }
  return v4;
}

llvm::raw_ostream *llvm::MCInstPrinter::printAnnotation(llvm::raw_ostream *result, llvm::raw_ostream *a2, char *a3, size_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    uint64_t v7 = (llvm::raw_ostream *)*((void *)result + 1);
    if (v7)
    {
      uint64_t v8 = (void *)*((void *)v7 + 4);
      if (a4 <= *((void *)v7 + 3) - (void)v8)
      {
        unint64_t result = (llvm::raw_ostream *)memcpy(v8, a3, a4);
        *((void *)v7 + 4) += a4;
      }
      else
      {
        unint64_t result = llvm::raw_ostream::write(v7, a3, a4);
      }
      if (a3[a4 - 1] != 10)
      {
        unint64_t result = (llvm::raw_ostream *)*((void *)v6 + 1);
        uint64_t v16 = (unsigned char *)*((void *)result + 4);
        if ((unint64_t)v16 >= *((void *)result + 3))
        {
          return llvm::raw_ostream::write(result, 10);
        }
        else
        {
          *((void *)result + 4) = v16 + 1;
          *uint64_t v16 = 10;
        }
      }
    }
    else
    {
      uint64_t v9 = sub_1CB8E509C(a2, " ");
      uint64_t v10 = *((void *)v6 + 2);
      size_t v11 = *(const void **)(v10 + 48);
      size_t v12 = *(void *)(v10 + 56);
      size_t v13 = (void *)*((void *)v9 + 4);
      if (v12 <= *((void *)v9 + 3) - (void)v13)
      {
        if (v12)
        {
          memcpy(v13, v11, v12);
          *((void *)v9 + 4) += v12;
        }
      }
      else
      {
        llvm::raw_ostream::write(v9, (const char *)v11, v12);
      }
      char v14 = sub_1CB8E509C(v9, " ");
      uint64_t v15 = (void *)*((void *)v14 + 4);
      if (a4 <= *((void *)v14 + 3) - (void)v15)
      {
        unint64_t result = (llvm::raw_ostream *)memcpy(v15, a3, a4);
        *((void *)v14 + 4) += a4;
      }
      else
      {
        return llvm::raw_ostream::write(v14, a3, a4);
      }
    }
  }
  return result;
}

void llvm::MCInstPrinter::formatDec(uint64_t a1@<X1>, void *a2@<X8>)
{
  *a2 = &unk_1F2618EA8;
  a2[1] = "%lld";
  a2[2] = a1;
}

uint64_t llvm::MCInstPrinter::formatHex@<X0>(uint64_t this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (*(_DWORD *)(this + 52))
  {
    if (a2 < 0)
    {
      if (a2 == 0x8000000000000000)
      {
        uint64_t v5 = "-8000000000000000h";
        a2 = 0x8000000000000000;
      }
      else
      {
        a2 = -a2;
        uint64_t v8 = a2;
        while (v8)
        {
          unint64_t v9 = v8;
          v8 *= 16;
          if (v9 >> 60)
          {
            if (v9 >> 61 > 4)
            {
              uint64_t v5 = "-0%llxh";
              goto LABEL_12;
            }
            break;
          }
        }
        uint64_t v5 = "-%llxh";
      }
    }
    else
    {
      uint64_t v3 = a2;
      while (v3)
      {
        unint64_t v4 = v3;
        v3 *= 16;
        if (v4 >> 60)
        {
          if (v4 >> 61 > 4)
          {
            uint64_t v5 = "0%llxh";
            goto LABEL_12;
          }
          break;
        }
      }
      uint64_t v5 = "%llxh";
    }
  }
  else
  {
    uint64_t v5 = "0x%llx";
    unint64_t v6 = 0x8000000000000000;
    uint64_t v7 = "-0x8000000000000000";
    if (a2 != 0x8000000000000000)
    {
      uint64_t v7 = "-0x%llx";
      unint64_t v6 = -a2;
    }
    if (a2 < 0)
    {
      uint64_t v5 = v7;
      a2 = v6;
    }
  }
LABEL_12:
  *a3 = &unk_1F2618EA8;
  a3[1] = v5;
  a3[2] = a2;
  return this;
}

uint64_t llvm::MCInstPrinter::formatHex@<X0>(uint64_t this@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  if (*(_DWORD *)(this + 52))
  {
    unint64_t v3 = a2;
    while (v3)
    {
      unint64_t v4 = v3;
      v3 *= 16;
      if (v4 >> 60)
      {
        if (v4 >> 61 > 4)
        {
          uint64_t v5 = "0%llxh";
          goto LABEL_8;
        }
        break;
      }
    }
    uint64_t v5 = "%llxh";
  }
  else
  {
    uint64_t v5 = "0x%llx";
  }
LABEL_8:
  *a3 = &unk_1F25FF808;
  a3[1] = v5;
  a3[2] = a2;
  return this;
}

uint64_t sub_1CD6B084C()
{
  return 0;
}

uint64_t llvm::MCInstrAnalysis::clearsSuperRegisters(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(unsigned int *)(a4 + 8);
  if (v4 > 0x40) {
    bzero(*(void **)a4, ((unint64_t)(v4 + 63) >> 3) & 0x3FFFFFF8);
  }
  else {
    *(void *)a4 = 0;
  }
  return 0;
}

uint64_t llvm::MCInstrAnalysis::evaluateMemoryOperandAddress()
{
  return 0;
}

uint64_t llvm::MCInstrAnalysis::getMemoryOperandRelocationOffset()
{
  return 0;
}

uint64_t llvm::MCLOHDirective::emit_impl(llvm::MCLOHDirective *this, llvm::raw_ostream *a2, const llvm::MachObjectWriter *a3, const llvm::MCAsmLayout *a4)
{
  sub_1CC659844(*(unsigned int *)this, a2, 0);
  uint64_t result = sub_1CC659844(*((unsigned int *)this + 4), a2, 0);
  uint64_t v9 = *((unsigned int *)this + 4);
  if (v9)
  {
    uint64_t v10 = (const llvm::MCSymbol **)*((void *)this + 1);
    uint64_t v11 = 8 * v9;
    do
    {
      size_t v12 = *v10++;
      unint64_t SymbolAddress = llvm::MachObjectWriter::getSymbolAddress(a3, v12, a4);
      uint64_t result = sub_1CC659844(SymbolAddress, a2, 0);
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t llvm::MCLOHDirective::emit(llvm::MCLOHDirective *this, llvm::raw_ostream **a2, const llvm::MCAsmLayout *a3)
{
  return llvm::MCLOHDirective::emit_impl(this, a2[26], (const llvm::MachObjectWriter *)a2, a3);
}

uint64_t llvm::MCLOHDirective::getEmitSize(llvm::MCLOHDirective *this, const llvm::MachObjectWriter *a2, const llvm::MCAsmLayout *a3)
{
  int v8 = 0;
  char v12 = 0;
  uint64_t v13 = 0;
  int v14 = 1;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v9 = 0;
  uint64_t v7 = (uint64_t (**)(void **))&unk_1F262E9B8;
  uint64_t v15 = 0;
  llvm::MCLOHDirective::emit_impl(this, (llvm::raw_ostream *)&v7, a2, a3);
  uint64_t v3 = v7[10]((void **)&v7);
  uint64_t v4 = v11;
  uint64_t v5 = v9;
  uint64_t v7 = (uint64_t (**)(void **))&unk_1F262E9B8;
  if (v11 != v9)
  {
    uint64_t v11 = v9;
    llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)&v7, v9);
  }
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v7);
  return &v4[v3] - v5;
}

void llvm::createMachOStreamer()
{
}

void sub_1CD6B0BEC(uint64_t a1, int a2, unsigned char *__src, int a4)
{
  void v7[3] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a1 + 8;
  int v5 = a2;
  v6[0] = v7;
  v6[1] = (void *)0x300000000;
  sub_1CD47792C((unsigned int *)v6, __src, &__src[8 * a4]);
  sub_1CD6B0C8C(v4, (unint64_t)&v5);
  if (v6[0] != v7) {
    free(v6[0]);
  }
}

_DWORD *sub_1CD6B0C8C(uint64_t a1, unint64_t a2)
{
  uint64_t result = (_DWORD *)sub_1CD6B0D00(a1, a2);
  uint64_t v4 = *(void *)a1 + 48 * *(unsigned int *)(a1 + 8);
  *(_DWORD *)uint64_t v4 = *result;
  *(void *)(v4 + 16) = 0x300000000;
  *(void *)(v4 + 8) = v4 + 24;
  uint64_t v5 = v4 + 8;
  if (result[4]) {
    uint64_t result = (_DWORD *)sub_1CD41C56C(v5, (uint64_t)(result + 2));
  }
  ++*(_DWORD *)(a1 + 8);
  return result;
}

unint64_t sub_1CD6B0D00(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 48 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      sub_1CD6B0D6C();
    }
    sub_1CD6B0D6C();
  }
  return a2;
}

void sub_1CD6B0D6C()
{
}

void sub_1CD6B0DDC(uint64_t *a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    uint64_t v5 = 0;
    uint64_t v6 = *a1;
    uint64_t v7 = *a1 + 48 * v2;
    do
    {
      uint64_t v8 = a2 + v5;
      uint64_t v9 = v6 + v5;
      *(_DWORD *)uint64_t v8 = *(_DWORD *)(v6 + v5);
      *(void *)(v8 + 16) = 0x300000000;
      *(void *)(v8 + 8) = a2 + v5 + 24;
      if (*(_DWORD *)(v6 + v5 + 16)) {
        sub_1CD41C56C(a2 + v5 + 8, v9 + 8);
      }
      v5 += 48;
    }
    while (v9 + 48 != v7);
    uint64_t v10 = *((unsigned int *)a1 + 2);
    if (v10)
    {
      uint64_t v11 = *a1;
      uint64_t v12 = 48 * v10;
      do
      {
        uint64_t v13 = *(void **)(v11 + v12 - 40);
        if ((void *)(v11 + v12 - 24) != v13) {
          free(v13);
        }
        v12 -= 48;
      }
      while (v12);
    }
  }
}

uint64_t llvm::MCMachObjectTargetWriter::MCMachObjectTargetWriter(uint64_t this, char a2, int a3, int a4)
{
  *(void *)this = &unk_1F262EF68;
  *(unsigned char *)(this + 8) = *(unsigned char *)(this + 8) & 0xFE | a2;
  *(_DWORD *)(this + 12) = a3;
  *(_DWORD *)(this + 16) = a4;
  return this;
}

void llvm::createNullStreamer(llvm *this, llvm::MCContext *a2)
{
}

uint64_t llvm::MCObjectFileInfo::initELFMCObjectFileInfo(llvm::MCObjectFileInfo *this, const llvm::Triple *a2, int a3)
{
  int v5 = *((_DWORD *)a2 + 6);
  int v6 = 12;
  switch(v5)
  {
    case 3:
    case 4:
    case 23:
    case 24:
      goto LABEL_2;
    case 5:
    case 6:
    case 7:
    case 10:
    case 11:
    case 13:
    case 14:
    case 15:
    case 20:
    case 21:
    case 22:
      goto LABEL_24;
    case 8:
    case 9:
      goto LABEL_5;
    case 12:
      int v6 = 16 * *((unsigned __int8 *)this + 832);
      goto LABEL_5;
    case 16:
    case 17:
    case 18:
    case 19:
      if (*((unsigned char *)this + 832)) {
        BOOL v69 = a3 == 0;
      }
      else {
        BOOL v69 = 0;
      }
      if (v69) {
        goto LABEL_24;
      }
      BOOL v7 = *(_DWORD *)(*(void *)(*((void *)this + 105) + 152) + 8) == 4;
      int v6 = 11;
      goto LABEL_3;
    default:
      if (v5 == 42)
      {
LABEL_2:
        BOOL v7 = a3 == 0;
        int v6 = 27;
LABEL_3:
        if (!v7) {
          ++v6;
        }
      }
      else
      {
LABEL_24:
        int v6 = 27;
      }
LABEL_5:
      *((_DWORD *)this + 3) = v6;
      int v8 = *((_DWORD *)a2 + 9);
      if (v5 == 42) {
        int v9 = 2;
      }
      else {
        int v9 = 3;
      }
      if (v5 == 42) {
        int v10 = 1879048193;
      }
      else {
        int v10 = 1;
      }
      uint64_t v11 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".bss";
      __int16 v71 = 259;
      __int16 v73 = 257;
      if (v8 == 14) {
        int v12 = v9;
      }
      else {
        int v12 = 2;
      }
      *((void *)this + 5) = llvm::MCContext::getELFSection(v11, (const llvm::Twine *)v70, 8, 3, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v13 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".text";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 3) = llvm::MCContext::getELFSection(v13, (const llvm::Twine *)v70, 1, 6, 0, (const llvm::Twine *)v72, 0, -1, 0);
      int v14 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".data";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 4) = llvm::MCContext::getELFSection(v14, (const llvm::Twine *)v70, 1, 3, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v15 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".rodata";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 6) = llvm::MCContext::getELFSection(v15, (const llvm::Twine *)v70, 1, 2, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v16 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".tdata";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 52) = llvm::MCContext::getELFSection(v16, (const llvm::Twine *)v70, 1, 1027, 0, (const llvm::Twine *)v72, 0, -1, 0);
      unsigned int v17 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".tbss";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 53) = llvm::MCContext::getELFSection(v17, (const llvm::Twine *)v70, 8, 1027, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v18 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".data.rel.ro";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 61) = llvm::MCContext::getELFSection(v18, (const llvm::Twine *)v70, 1, 3, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v19 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".rodata.cst4";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 62) = llvm::MCContext::getELFSection(v19, (const llvm::Twine *)v70, 1, 18, 4, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v20 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".rodata.cst8";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 63) = llvm::MCContext::getELFSection(v20, (const llvm::Twine *)v70, 1, 18, 8, (const llvm::Twine *)v72, 0, -1, 0);
      int v21 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".rodata.cst16";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 64) = llvm::MCContext::getELFSection(v21, (const llvm::Twine *)v70, 1, 18, 16, (const llvm::Twine *)v72, 0, -1, 0);
      __int16 v22 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".rodata.cst32";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 65) = llvm::MCContext::getELFSection(v22, (const llvm::Twine *)v70, 1, 18, 32, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v23 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".gcc_except_table";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 7) = llvm::MCContext::getELFSection(v23, (const llvm::Twine *)v70, 1, 2, 0, (const llvm::Twine *)v72, 0, -1, 0);
      *((void *)this + 48) = 0;
      *((void *)this + 49) = 0;
      if ((*((_DWORD *)a2 + 6) & 0xFFFFFFFC) == 0x10) {
        int v24 = 1879048222;
      }
      else {
        int v24 = 1;
      }
      uint64_t v25 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_abbrev";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 9) = llvm::MCContext::getELFSection(v25, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      char v26 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_info";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 10) = llvm::MCContext::getELFSection(v26, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      unint64_t v27 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_line";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 11) = llvm::MCContext::getELFSection(v27, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      __int16 v28 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_line_str";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 12) = llvm::MCContext::getELFSection(v28, (const llvm::Twine *)v70, v24, 48, 1, (const llvm::Twine *)v72, 0, -1, 0);
      char v29 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_frame";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 13) = llvm::MCContext::getELFSection(v29, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v30 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_pubnames";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 22) = llvm::MCContext::getELFSection(v30, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v31 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_pubtypes";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 14) = llvm::MCContext::getELFSection(v31, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      int v32 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_gnu_pubnames";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 45) = llvm::MCContext::getELFSection(v32, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v33 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_gnu_pubtypes";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 46) = llvm::MCContext::getELFSection(v33, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v34 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_str";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 16) = llvm::MCContext::getELFSection(v34, (const llvm::Twine *)v70, v24, 48, 1, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v35 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_loc";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 17) = llvm::MCContext::getELFSection(v35, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v36 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_aranges";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 18) = llvm::MCContext::getELFSection(v36, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v37 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_ranges";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 19) = llvm::MCContext::getELFSection(v37, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      unint64_t v38 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_macinfo";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 20) = llvm::MCContext::getELFSection(v38, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      char v39 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_macro";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 21) = llvm::MCContext::getELFSection(v39, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      unint64_t v40 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_names";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 23) = llvm::MCContext::getELFSection(v40, (const llvm::Twine *)v70, 1, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      size_t v41 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".apple_names";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 24) = llvm::MCContext::getELFSection(v41, (const llvm::Twine *)v70, 1, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      unint64_t v42 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".apple_objc";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 25) = llvm::MCContext::getELFSection(v42, (const llvm::Twine *)v70, 1, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v43 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".apple_namespaces";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 26) = llvm::MCContext::getELFSection(v43, (const llvm::Twine *)v70, 1, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v44 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".apple_types";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 27) = llvm::MCContext::getELFSection(v44, (const llvm::Twine *)v70, 1, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      char v45 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_str_offsets";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 37) = llvm::MCContext::getELFSection(v45, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      unint64_t v46 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_addr";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 38) = llvm::MCContext::getELFSection(v46, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      size_t v47 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_rnglists";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 39) = llvm::MCContext::getELFSection(v47, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      char v48 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_loclists";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 40) = llvm::MCContext::getELFSection(v48, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v49 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_info.dwo";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 28) = llvm::MCContext::getELFSection(v49, (const llvm::Twine *)v70, v24, 0x80000000, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v50 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_types.dwo";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 29) = llvm::MCContext::getELFSection(v50, (const llvm::Twine *)v70, v24, 0x80000000, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v51 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_abbrev.dwo";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 30) = llvm::MCContext::getELFSection(v51, (const llvm::Twine *)v70, v24, 0x80000000, 0, (const llvm::Twine *)v72, 0, -1, 0);
      __int16 v52 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_str.dwo";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 31) = llvm::MCContext::getELFSection(v52, (const llvm::Twine *)v70, v24, -2147483600, 1, (const llvm::Twine *)v72, 0, -1, 0);
      unint64_t v53 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_line.dwo";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 32) = llvm::MCContext::getELFSection(v53, (const llvm::Twine *)v70, v24, 0x80000000, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v54 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_loc.dwo";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 33) = llvm::MCContext::getELFSection(v54, (const llvm::Twine *)v70, v24, 0x80000000, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v55 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_str_offsets.dwo";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 34) = llvm::MCContext::getELFSection(v55, (const llvm::Twine *)v70, v24, 0x80000000, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v56 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_rnglists.dwo";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 41) = llvm::MCContext::getELFSection(v56, (const llvm::Twine *)v70, v24, 0x80000000, 0, (const llvm::Twine *)v72, 0, -1, 0);
      unint64_t v57 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_macinfo.dwo";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 35) = llvm::MCContext::getELFSection(v57, (const llvm::Twine *)v70, v24, 0x80000000, 0, (const llvm::Twine *)v72, 0, -1, 0);
      unint64_t v58 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_macro.dwo";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 36) = llvm::MCContext::getELFSection(v58, (const llvm::Twine *)v70, v24, 0x80000000, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v59 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_loclists.dwo";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 42) = llvm::MCContext::getELFSection(v59, (const llvm::Twine *)v70, v24, 0x80000000, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v60 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_cu_index";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 43) = llvm::MCContext::getELFSection(v60, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v61 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".debug_tu_index";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 44) = llvm::MCContext::getELFSection(v61, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v62 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".llvm_stackmaps";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 54) = llvm::MCContext::getELFSection(v62, (const llvm::Twine *)v70, 1, 2, 0, (const llvm::Twine *)v72, 0, -1, 0);
      std::string v63 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".llvm_faultmaps";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 55) = llvm::MCContext::getELFSection(v63, (const llvm::Twine *)v70, 1, 2, 0, (const llvm::Twine *)v72, 0, -1, 0);
      int v64 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".eh_frame";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 57) = llvm::MCContext::getELFSection(v64, (const llvm::Twine *)v70, v10, v12, 0, (const llvm::Twine *)v72, 0, -1, 0);
      char v65 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".stack_sizes";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 58) = llvm::MCContext::getELFSection(v65, (const llvm::Twine *)v70, 1, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      std::string v66 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".pseudo_probe";
      __int16 v71 = 259;
      __int16 v73 = 257;
      *((void *)this + 59) = llvm::MCContext::getELFSection(v66, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      uint64_t v67 = (llvm::MCContext *)*((void *)this + 105);
      v70[0] = ".pseudo_probe_desc";
      __int16 v71 = 259;
      __int16 v73 = 257;
      uint64_t result = llvm::MCContext::getELFSection(v67, (const llvm::Twine *)v70, v24, 0, 0, (const llvm::Twine *)v72, 0, -1, 0);
      *((void *)this + 60) = result;
      return result;
  }
}

uint64_t llvm::MCObjectFileInfo::initCOFFMCObjectFileInfo(llvm::MCObjectFileInfo *this, const llvm::Triple *a2)
{
  *((void *)this + 57) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".eh_frame", 9uLL, 1073741888, 19, 0);
  int v4 = *((_DWORD *)a2 + 6);
  *((unsigned char *)this + 8) = 1;
  *((void *)this + 5) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".bss", 4uLL, -1073741696, 15, 0);
  if (v4 == 39) {
    int v5 = 1610743840;
  }
  else {
    int v5 = 1610612768;
  }
  *((void *)this + 3) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".text", 5uLL, v5, 2, 0);
  *((void *)this + 4) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".data", 5uLL, -1073741760, 19, 0);
  uint64_t COFFSection = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".rdata", 6uLL, 1073741888, 4, 0);
  uint64_t v7 = 0;
  *((void *)this + 6) = COFFSection;
  int v8 = *((_DWORD *)a2 + 6);
  if (v8 != 3 && v8 != 42) {
    uint64_t v7 = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".gcc_except_table", 0x11uLL, 1073741888, 4, 0);
  }
  *((void *)this + 7) = v7;
  *((void *)this + 48) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug$S", 8uLL, 1107296320, 0, 0);
  *((void *)this + 49) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug$T", 8uLL, 1107296320, 0, 0);
  *((void *)this + 50) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug$H", 8uLL, 1107296320, 0, 0);
  *((void *)this + 9) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_abbrev", 0xDuLL, 1107296320, 0, "section_abbrev");
  *((void *)this + 10) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_info", 0xBuLL, 1107296320, 0, "section_info");
  *((void *)this + 11) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_line", 0xBuLL, 1107296320, 0, "section_line");
  *((void *)this + 12) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_line_str", 0xFuLL, 1107296320, 0, "section_line_str");
  *((void *)this + 13) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_frame", 0xCuLL, 1107296320, 0, 0);
  *((void *)this + 22) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_pubnames", 0xFuLL, 1107296320, 0, 0);
  *((void *)this + 14) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_pubtypes", 0xFuLL, 1107296320, 0, 0);
  *((void *)this + 45) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_gnu_pubnames", 0x13uLL, 1107296320, 0, 0);
  *((void *)this + 46) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_gnu_pubtypes", 0x13uLL, 1107296320, 0, 0);
  *((void *)this + 16) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_str", 0xAuLL, 1107296320, 0, "info_string");
  *((void *)this + 37) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_str_offsets", 0x12uLL, 1107296320, 0, "section_str_off");
  *((void *)this + 17) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_loc", 0xAuLL, 1107296320, 0, "section_debug_loc");
  *((void *)this + 40) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_loclists", 0xFuLL, 1107296320, 0, "section_debug_loclists");
  *((void *)this + 18) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_aranges", 0xEuLL, 1107296320, 0, 0);
  *((void *)this + 19) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_ranges", 0xDuLL, 1107296320, 0, "debug_range");
  *((void *)this + 39) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_rnglists", 0xFuLL, 1107296320, 0, "debug_rnglists");
  *((void *)this + 20) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_macinfo", 0xEuLL, 1107296320, 0, "debug_macinfo");
  *((void *)this + 21) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_macro", 0xCuLL, 1107296320, 0, "debug_macro");
  *((void *)this + 35) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_macinfo.dwo", 0x12uLL, 1107296320, 0, "debug_macinfo.dwo");
  *((void *)this + 36) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_macro.dwo", 0x10uLL, 1107296320, 0, "debug_macro.dwo");
  *((void *)this + 28) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_info.dwo", 0xFuLL, 1107296320, 0, "section_info_dwo");
  *((void *)this + 29) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_types.dwo", 0x10uLL, 1107296320, 0, "section_types_dwo");
  *((void *)this + 30) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_abbrev.dwo", 0x11uLL, 1107296320, 0, "section_abbrev_dwo");
  *((void *)this + 31) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_str.dwo", 0xEuLL, 1107296320, 0, "skel_string");
  *((void *)this + 32) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_line.dwo", 0xFuLL, 1107296320, 0, 0);
  *((void *)this + 33) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_loc.dwo", 0xEuLL, 1107296320, 0, "skel_loc");
  *((void *)this + 34) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_str_offsets.dwo", 0x16uLL, 1107296320, 0, "section_str_off_dwo");
  *((void *)this + 38) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_addr", 0xBuLL, 1107296320, 0, "addr_sec");
  *((void *)this + 43) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_cu_index", 0xFuLL, 1107296320, 0, 0);
  *((void *)this + 44) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_tu_index", 0xFuLL, 1107296320, 0, 0);
  *((void *)this + 23) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".debug_names", 0xCuLL, 1107296320, 0, "debug_names_begin");
  *((void *)this + 24) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".apple_names", 0xCuLL, 1107296320, 0, "names_begin");
  *((void *)this + 26) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".apple_namespaces", 0x11uLL, 1107296320, 0, "namespac_begin");
  *((void *)this + 27) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".apple_types", 0xCuLL, 1107296320, 0, "types_begin");
  *((void *)this + 25) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".apple_objc", 0xBuLL, 1107296320, 0, "objc_begin");
  *((void *)this + 83) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".drectve", 8uLL, 2560, 0, 0);
  *((void *)this + 84) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".pdata", 6uLL, 1073741888, 19, 0);
  *((void *)this + 85) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".xdata", 6uLL, 1073741888, 19, 0);
  *((void *)this + 86) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".sxdata", 7uLL, 512, 0, 0);
  *((void *)this + 87) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".gehcont$y", 0xAuLL, 1073741888, 0, 0);
  *((void *)this + 88) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".gfids$y", 8uLL, 1073741888, 0, 0);
  *((void *)this + 89) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".giats$y", 8uLL, 1073741888, 0, 0);
  *((void *)this + 90) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".gljmp$y", 8uLL, 1073741888, 0, 0);
  *((void *)this + 52) = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".tls$", 5uLL, -1073741760, 19, 0);
  uint64_t result = llvm::MCContext::getCOFFSection(*((llvm::MCContext **)this + 105), ".llvm_stackmaps", 0xFuLL, 1073741888, 4, 0);
  *((void *)this + 54) = result;
  return result;
}

uint64_t llvm::MCObjectFileInfo::initWasmMCObjectFileInfo(llvm::MCObjectFileInfo *this, const llvm::Triple *a2)
{
  uint64_t v3 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".text";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 3) = llvm::MCContext::getWasmSection(v3, (llvm::Twine *)v42, 2, 0, (llvm::Twine *)v44, -1);
  int v4 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".data";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 4) = llvm::MCContext::getWasmSection(v4, (llvm::Twine *)v42, 19, 0, (llvm::Twine *)v44, -1);
  int v5 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_line";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 11) = llvm::MCContext::getWasmSection(v5, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  int v6 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_line_str";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 12) = llvm::MCContext::getWasmSection(v6, (llvm::Twine *)v42, 0, 1, (llvm::Twine *)v44, -1);
  uint64_t v7 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_str";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 16) = llvm::MCContext::getWasmSection(v7, (llvm::Twine *)v42, 0, 1, (llvm::Twine *)v44, -1);
  int v8 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_loc";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 17) = llvm::MCContext::getWasmSection(v8, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  int v9 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_abbrev";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 9) = llvm::MCContext::getWasmSection(v9, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  int v10 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_aranges";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 18) = llvm::MCContext::getWasmSection(v10, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  uint64_t v11 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_ranges";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 19) = llvm::MCContext::getWasmSection(v11, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  int v12 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_macinfo";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 20) = llvm::MCContext::getWasmSection(v12, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  uint64_t v13 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_macro";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 21) = llvm::MCContext::getWasmSection(v13, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  int v14 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_cu_index";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 43) = llvm::MCContext::getWasmSection(v14, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  uint64_t v15 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_tu_index";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 44) = llvm::MCContext::getWasmSection(v15, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  uint64_t v16 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_info";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 10) = llvm::MCContext::getWasmSection(v16, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  unsigned int v17 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_frame";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 13) = llvm::MCContext::getWasmSection(v17, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  uint64_t v18 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_pubnames";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 22) = llvm::MCContext::getWasmSection(v18, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  uint64_t v19 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_pubtypes";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 14) = llvm::MCContext::getWasmSection(v19, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  uint64_t v20 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_gnu_pubnames";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 45) = llvm::MCContext::getWasmSection(v20, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  int v21 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_gnu_pubtypes";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 46) = llvm::MCContext::getWasmSection(v21, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  __int16 v22 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_names";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 23) = llvm::MCContext::getWasmSection(v22, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  uint64_t v23 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_str_offsets";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 37) = llvm::MCContext::getWasmSection(v23, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  int v24 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_addr";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 38) = llvm::MCContext::getWasmSection(v24, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  uint64_t v25 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_rnglists";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 39) = llvm::MCContext::getWasmSection(v25, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  char v26 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_loclists";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 40) = llvm::MCContext::getWasmSection(v26, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  unint64_t v27 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_info.dwo";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 28) = llvm::MCContext::getWasmSection(v27, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  __int16 v28 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_types.dwo";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 29) = llvm::MCContext::getWasmSection(v28, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  char v29 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_abbrev.dwo";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 30) = llvm::MCContext::getWasmSection(v29, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  uint64_t v30 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_str.dwo";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 31) = llvm::MCContext::getWasmSection(v30, (llvm::Twine *)v42, 0, 1, (llvm::Twine *)v44, -1);
  uint64_t v31 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_line.dwo";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 32) = llvm::MCContext::getWasmSection(v31, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  int v32 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_loc.dwo";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 33) = llvm::MCContext::getWasmSection(v32, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  uint64_t v33 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_str_offsets.dwo";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 34) = llvm::MCContext::getWasmSection(v33, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  uint64_t v34 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_rnglists.dwo";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 41) = llvm::MCContext::getWasmSection(v34, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  uint64_t v35 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_macinfo.dwo";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 35) = llvm::MCContext::getWasmSection(v35, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  uint64_t v36 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_macro.dwo";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 36) = llvm::MCContext::getWasmSection(v36, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  uint64_t v37 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_loclists.dwo";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 42) = llvm::MCContext::getWasmSection(v37, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  unint64_t v38 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_cu_index";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 43) = llvm::MCContext::getWasmSection(v38, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  char v39 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".debug_tu_index";
  __int16 v43 = 259;
  __int16 v45 = 257;
  *((void *)this + 44) = llvm::MCContext::getWasmSection(v39, (llvm::Twine *)v42, 0, 0, (llvm::Twine *)v44, -1);
  unint64_t v40 = (llvm::MCContext *)*((void *)this + 105);
  v42[0] = ".rodata.gcc_except_table";
  __int16 v43 = 259;
  __int16 v45 = 257;
  uint64_t result = llvm::MCContext::getWasmSection(v40, (llvm::Twine *)v42, 20, 0, (llvm::Twine *)v44, -1);
  *((void *)this + 7) = result;
  return result;
}

uint64_t llvm::MCObjectFileInfo::initXCOFFMCObjectFileInfo(llvm::MCObjectFileInfo *this, const llvm::Triple *a2)
{
  *((void *)this + 3) = llvm::MCContext::getXCOFFSection(*((uint64_t **)this + 105), ".text", 5uLL, 2, 256, 1, 0, 0);
  *((void *)this + 4) = llvm::MCContext::getXCOFFSection(*((uint64_t **)this + 105), ".data", 5uLL, 19, 261, 1, 0, 0);
  Xuint64_t COFFSection = llvm::MCContext::getXCOFFSection(*((uint64_t **)this + 105), ".rodata", 7uLL, 4, 257, 1, 0, 0);
  *((void *)this + 6) = XCOFFSection;
  *(unsigned char *)(XCOFFSection + 24) = 2;
  uint64_t v4 = llvm::MCContext::getXCOFFSection(*((uint64_t **)this + 105), ".rodata.8", 9uLL, 4, 257, 1, 0, 0);
  *((void *)this + 92) = v4;
  *(unsigned char *)(v4 + 24) = 3;
  uint64_t v5 = llvm::MCContext::getXCOFFSection(*((uint64_t **)this + 105), ".rodata.16", 0xAuLL, 4, 257, 1, 0, 0);
  *((void *)this + 93) = v5;
  *(unsigned char *)(v5 + 24) = 4;
  *((void *)this + 52) = llvm::MCContext::getXCOFFSection(*((uint64_t **)this + 105), ".tdata", 6uLL, 13, 276, 1, 0, 0);
  uint64_t v6 = llvm::MCContext::getXCOFFSection(*((uint64_t **)this + 105), "TOC", 3uLL, 19, 271, 0, 0, 0);
  *((void *)this + 91) = v6;
  *(unsigned char *)(v6 + 24) = 2;
  *((void *)this + 7) = llvm::MCContext::getXCOFFSection(*((uint64_t **)this + 105), ".gcc_except_table", 0x11uLL, 4, 257, 0, 0, 0);
  *((void *)this + 8) = llvm::MCContext::getXCOFFSection(*((uint64_t **)this + 105), ".eh_info_table", 0xEuLL, 19, 261, 0, 0, 0);
  *((void *)this + 9) = llvm::MCContext::getXCOFFSection(*((uint64_t **)this + 105), ".dwabrev", 8uLL, 0, 0, 1, ".dwabrev", 0x100060000);
  *((void *)this + 10) = llvm::MCContext::getXCOFFSection(*((uint64_t **)this + 105), ".dwinfo", 7uLL, 0, 0, 1, ".dwinfo", 0x100010000);
  *((void *)this + 11) = llvm::MCContext::getXCOFFSection(*((uint64_t **)this + 105), ".dwline", 7uLL, 0, 0, 1, ".dwline", 0x100020000);
  *((void *)this + 13) = llvm::MCContext::getXCOFFSection(*((uint64_t **)this + 105), ".dwframe", 8uLL, 0, 0, 1, ".dwframe", 0x1000A0000);
  *((void *)this + 22) = llvm::MCContext::getXCOFFSection(*((uint64_t **)this + 105), ".dwpbnms", 8uLL, 0, 0, 1, ".dwpbnms", 0x100030000);
  *((void *)this + 14) = llvm::MCContext::getXCOFFSection(*((uint64_t **)this + 105), ".dwpbtyp", 8uLL, 0, 0, 1, ".dwpbtyp", 0x100040000);
  *((void *)this + 16) = llvm::MCContext::getXCOFFSection(*((uint64_t **)this + 105), ".dwstr", 6uLL, 0, 0, 1, ".dwstr", 0x100070000);
  *((void *)this + 17) = llvm::MCContext::getXCOFFSection(*((uint64_t **)this + 105), ".dwloc", 6uLL, 0, 0, 1, ".dwloc", 0x100090000);
  *((void *)this + 18) = llvm::MCContext::getXCOFFSection(*((uint64_t **)this + 105), ".dwarnge", 8uLL, 0, 0, 1, ".dwarnge", 0x100050000);
  *((void *)this + 19) = llvm::MCContext::getXCOFFSection(*((uint64_t **)this + 105), ".dwrnges", 8uLL, 0, 0, 1, ".dwrnges", 0x100080000);
  uint64_t result = llvm::MCContext::getXCOFFSection(*((uint64_t **)this + 105), ".dwmac", 6uLL, 0, 0, 1, ".dwmac", 0x1000B0000);
  *((void *)this + 20) = result;
  return result;
}

void llvm::MCObjectFileInfo::~MCObjectFileInfo(void **this)
{
  *this = &unk_1F262F500;
  if (*((unsigned char *)this + 912))
  {
    if (*((char *)this + 887) < 0) {
      operator delete(this[108]);
    }
    *((unsigned char *)this + 912) = 0;
  }
}

{
  *this = &unk_1F262F500;
  if (*((unsigned char *)this + 912))
  {
    if (*((char *)this + 887) < 0) {
      operator delete(this[108]);
    }
    *((unsigned char *)this + 912) = 0;
  }
}

{
  uint64_t vars8;

  *this = &unk_1F262F500;
  if (*((unsigned char *)this + 912))
  {
    if (*((char *)this + 887) < 0) {
      operator delete(this[108]);
    }
    *((unsigned char *)this + 912) = 0;
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t llvm::MCObjectFileInfo::getDwarfComdatSection(llvm::MCObjectFileInfo *this, const char *a2, unint64_t a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (llvm::MCContext *)*((void *)this + 105);
  int v4 = *((_DWORD *)v3 + 17);
  if (v4 == 7)
  {
    char v5 = 1;
    char v17 = 1;
    if (*a2)
    {
      v15[0] = a2;
      char v5 = 3;
    }
    char v16 = v5;
    if (a3)
    {
      uint64_t v6 = v20;
      do
      {
        *--uint64_t v6 = (a3 % 0xA) | 0x30;
        BOOL v7 = a3 > 9;
        a3 /= 0xAuLL;
      }
      while (v7);
    }
    else
    {
      uint64_t v6 = &v19;
      char v19 = 48;
    }
    sub_1CC028D80(__p, v6, v20, v20 - v6);
    __int16 v21 = 260;
    v18[0] = __p;
    uint64_t WasmSection = llvm::MCContext::getWasmSection(v3, (llvm::Twine *)v15, 0, 0, (llvm::Twine *)v18, -1);
  }
  else
  {
    if (v4 != 3) {
      llvm::report_fatal_error((llvm *)"Cannot get DWARF comdat section for this object file format: not implemented.", (const llvm::Twine *)1);
    }
    char v11 = 1;
    char v17 = 1;
    if (*a2)
    {
      v15[0] = a2;
      char v11 = 3;
    }
    char v16 = v11;
    if (a3)
    {
      int v12 = v20;
      do
      {
        *--int v12 = (a3 % 0xA) | 0x30;
        BOOL v7 = a3 > 9;
        a3 /= 0xAuLL;
      }
      while (v7);
    }
    else
    {
      int v12 = &v19;
      char v19 = 48;
    }
    sub_1CC028D80(__p, v12, v20, v20 - v12);
    __int16 v21 = 260;
    v18[0] = __p;
    uint64_t WasmSection = llvm::MCContext::getELFSection(v3, (const llvm::Twine *)v15, 1, 512, 0, (const llvm::Twine *)v18, 1, -1, 0);
  }
  uint64_t v9 = WasmSection;
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  return v9;
}

uint64_t llvm::MCObjectFileInfo::getStackSizesSection(llvm::MCObjectFileInfo *this, const llvm::MCSection *a2)
{
  uint64_t v3 = (llvm::MCContext *)*((void *)this + 105);
  if (*(_DWORD *)v3 != 1) {
    return *((void *)this + 58);
  }
  char v5 = (unsigned char *)(*((void *)a2 + 30) & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    if ((*v5 & 4) != 0)
    {
      int v8 = (void *)*((void *)v5 - 1);
      uint64_t v9 = *v8;
      char v5 = v8 + 2;
      uint64_t v6 = v9;
    }
    else
    {
      uint64_t v6 = 0;
      char v5 = 0;
    }
    int v7 = 640;
  }
  else
  {
    uint64_t v6 = 0;
    int v7 = 128;
  }
  int v12 = ".stack_sizes";
  __int16 v13 = 259;
  __int16 v11 = 261;
  v10[0] = v5;
  v10[1] = v6;
  return llvm::MCContext::getELFSection(v3, (const llvm::Twine *)&v12, 1, v7, 0, (const llvm::Twine *)v10, 1, *((_DWORD *)a2 + 58), *((const llvm::MCSymbolELF **)a2 + 1));
}

uint64_t llvm::MCObjectFileInfo::getBBAddrMapSection(llvm::MCObjectFileInfo *this, const llvm::MCSection *a2)
{
  unsigned int v2 = (llvm::MCContext *)*((void *)this + 105);
  if (*(_DWORD *)v2 != 1) {
    return 0;
  }
  int v4 = (unsigned char *)(*((void *)a2 + 30) & 0xFFFFFFFFFFFFFFF8);
  if (v4)
  {
    if ((*v4 & 4) != 0)
    {
      int v7 = (void *)*((void *)v4 - 1);
      uint64_t v8 = *v7;
      int v4 = v7 + 2;
      uint64_t v5 = v8;
    }
    else
    {
      uint64_t v5 = 0;
      int v4 = 0;
    }
    int v6 = 640;
  }
  else
  {
    uint64_t v5 = 0;
    int v6 = 128;
  }
  __int16 v11 = ".llvm_bb_addr_map";
  __int16 v12 = 259;
  __int16 v10 = 261;
  v9[0] = v4;
  v9[1] = v5;
  return llvm::MCContext::getELFSection(v2, (const llvm::Twine *)&v11, 1879002120, v6, 0, (const llvm::Twine *)v9, 1, *((_DWORD *)a2 + 58), *((const llvm::MCSymbolELF **)a2 + 1));
}

uint64_t llvm::MCObjectFileInfo::getPseudoProbeSection(llvm::MCObjectFileInfo *this, const llvm::MCSection *a2)
{
  uint64_t v3 = (llvm::MCContext *)*((void *)this + 105);
  if (*(_DWORD *)v3 != 1) {
    return *((void *)this + 59);
  }
  int v4 = (unsigned char *)(*((void *)a2 + 30) & 0xFFFFFFFFFFFFFFF8);
  if (!v4) {
    return *((void *)this + 59);
  }
  uint64_t v6 = *((void *)this + 59);
  int v7 = *(_DWORD *)(v6 + 224);
  int v8 = *(_DWORD *)(v6 + 228) | 0x200;
  uint64_t v9 = *(void *)(v6 + 200);
  uint64_t v10 = *(void *)(v6 + 208);
  __int16 v19 = 261;
  v18[0] = v9;
  v18[1] = v10;
  int v11 = *(_DWORD *)(v6 + 236);
  if ((*v4 & 4) != 0)
  {
    char v14 = (uint64_t *)*((void *)v4 - 1);
    uint64_t v15 = *v14;
    __int16 v12 = v14 + 2;
    uint64_t v13 = v15;
  }
  else
  {
    __int16 v12 = 0;
    uint64_t v13 = 0;
  }
  __int16 v17 = 261;
  v16[0] = v12;
  v16[1] = v13;
  return llvm::MCContext::getELFSection(v3, (const llvm::Twine *)v18, v7, v8, v11, (const llvm::Twine *)v16, 1, -1, 0);
}

void llvm::MCObjectStreamer::MCObjectStreamer(llvm::MCStreamer *a1, llvm::MCContext *a2)
{
  *(void *)llvm::MCStreamer::MCStreamer(a1, a2) = &unk_1F262F528;
  sub_1CCBA3D5C();
}

void llvm::MCObjectStreamer::~MCObjectStreamer(llvm::MCObjectStreamer *this)
{
  *(void *)this = &unk_1F262F528;
  sub_1CD6B5824((uint64_t)this + 520);
  MEMORY[0x1D25D9CD0](*((void *)this + 65), 8);
  unsigned int v2 = (char *)*((void *)this + 53);
  if (v2 != (char *)this + 440) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 46);
  if (v3 != (char *)this + 384) {
    free(v3);
  }
  if ((*((unsigned char *)this + 328) & 1) == 0) {
    MEMORY[0x1D25D9CD0](*((void *)this + 42), 8);
  }
  int v4 = (char *)*((void *)this + 37);
  if (v4 != (char *)this + 312) {
    free(v4);
  }
  uint64_t v5 = (llvm::MCAssembler *)*((void *)this + 34);
  *((void *)this + 34) = 0;
  if (v5)
  {
    llvm::MCAssembler::~MCAssembler(v5);
    MEMORY[0x1D25D9CE0]();
  }

  llvm::MCStreamer::~MCStreamer(this);
}

void llvm::MCObjectStreamer::emitAbsoluteSymbolDiffAsULEB128(llvm::MCObjectStreamer *this, const llvm::MCSymbol *a2, const llvm::MCSymbol *a3)
{
  if ((*(_DWORD *)(**((void **)this + 34) + 48) - 31) >= 2
    && (unint64_t v6 = sub_1CCBCACEC((uint64_t)a2, (uint64_t)a3), v7))
  {
    llvm::MCStreamer::emitULEB128IntValue(this, v6, 0);
  }
  else
  {
    llvm::MCStreamer::emitAbsoluteSymbolDiffAsULEB128(this, a2, a3);
  }
}

uint64_t llvm::MCObjectStreamer::getCurrentFragment(llvm::MCObjectStreamer *this)
{
  uint64_t v1 = *((void *)this + 35);
  if (v1 == *(void *)(*(void *)(*((void *)this + 14) + 32 * *((unsigned int *)this + 30) - 32) + 112)) {
    return 0;
  }
  else {
    return *(void *)v1;
  }
}

uint64_t llvm::MCObjectStreamer::emitCFILabel(llvm::MCObjectStreamer *this)
{
  unsigned int v2 = (llvm::MCContext *)*((void *)this + 1);
  uint64_t v5 = "cfi";
  __int16 v6 = 259;
  uint64_t TempSymbol = llvm::MCContext::createTempSymbol(v2, (const llvm::Twine *)&v5, 1);
  (*(void (**)(llvm::MCObjectStreamer *, uint64_t, void))(*(void *)this + 192))(this, TempSymbol, 0);
  return TempSymbol;
}

llvm::MCSection *llvm::MCObjectStreamer::emitLabelAtPos(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  llvm::MCStreamer::emitLabel((uint64_t)a1, a2, a3);
  uint64_t result = (llvm::MCSection *)llvm::MCAssembler::registerSymbol(a1[34], a2, 0);
  if (a4)
  {
    int v10 = *(unsigned __int8 *)(a4 + 48);
    *(void *)(a2 + 24) = a5;
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(a2 + 8) & 0xFFFFE3FF | 0x400;
    if (v10 == 1)
    {
      *(void *)a2 = *(void *)a2 & 7 | a4;
      return result;
    }
  }
  else
  {
    *(void *)(a2 + 24) = a5;
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(a2 + 8) & 0xFFFFE3FF | 0x400;
  }

  return llvm::MCObjectStreamer::addPendingLabel((llvm::MCSection *)a1, (llvm::MCSymbol *)a2);
}

void llvm::MCObjectStreamer::emitULEB128Value(llvm::MCObjectStreamer *this, const llvm::MCExpr *a2)
{
  unint64_t v6 = 0;
  int v4 = (const llvm::MCAssembler *)(*(uint64_t (**)(llvm::MCObjectStreamer *))(*(void *)this + 72))(this);
  if (!llvm::MCExpr::evaluateAsAbsolute(a2, (uint64_t *)&v6, v4)) {
    operator new();
  }
  unint64_t v5 = v6;

  llvm::MCStreamer::emitULEB128IntValue(this, v5, 0);
}

void llvm::MCObjectStreamer::emitSLEB128Value(llvm::MCObjectStreamer *this, const llvm::MCExpr *a2)
{
  uint64_t v6 = 0;
  int v4 = (const llvm::MCAssembler *)(*(uint64_t (**)(llvm::MCObjectStreamer *))(*(void *)this + 72))(this);
  if (!llvm::MCExpr::evaluateAsAbsolute(a2, &v6, v4)) {
    operator new();
  }
  uint64_t v5 = v6;

  llvm::MCStreamer::emitSLEB128IntValue(this, v5);
}

void llvm::MCObjectStreamer::emitWeakReference(llvm::MCObjectStreamer *this, llvm::MCSymbol *a2, const llvm::MCSymbol *a3)
{
}

void *llvm::MCObjectStreamer::emitConditionalAssignment(llvm::MCObjectStreamer *this, llvm::MCSymbol *a2, const llvm::MCExpr *a3)
{
  uint64_t v9 = *((void *)a3 + 2);
  if ((*(unsigned char *)(v9 + 8) & 8) != 0)
  {
    uint64_t v5 = *(uint64_t (**)(void))(*(void *)this + 280);
    return (void *)v5();
  }
  else
  {
    uint64_t result = sub_1CD6B5AE0((uint64_t)this + 520, &v9);
    unsigned int v7 = *((_DWORD *)result + 4);
    if (v7 >= *((_DWORD *)result + 5)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    int v8 = (void *)(result[1] + 16 * v7);
    void *v8 = a2;
    v8[1] = a3;
    ++*((_DWORD *)result + 4);
  }
  return result;
}

uint64_t llvm::MCObjectStreamer::mayHaveInstructions(llvm::MCObjectStreamer *this, llvm::MCSection *a2)
{
  return (*((unsigned __int8 *)a2 + 44) >> 1) & 1;
}

uint64_t llvm::MCObjectStreamer::emitDwarfLineEndEntry(llvm::MCContext **this, llvm::MCSection *a2, llvm::MCSymbol *a3)
{
  uint64_t v5 = llvm::MCStreamer::endSection(this, a2);
  uint64_t v6 = this[1];
  (*((void (**)(llvm::MCContext **, void, void))*this + 21))(this, *(void *)(*((void *)v6 + 21) + 88), 0);
  uint64_t v7 = *(unsigned int *)(*((void *)v6 + 19) + 8);
  int v8 = (uint64_t (*)(llvm::MCContext **, uint64_t, llvm::MCSymbol *, uint64_t, uint64_t))*((void *)*this + 160);

  return v8(this, 0x7FFFFFFFFFFFFFFFLL, a3, v5, v7);
}

void llvm::MCObjectStreamer::emitDwarfAdvanceFrameAddr(llvm::MCObjectStreamer *this, const llvm::MCSymbol *a2, const llvm::MCSymbol *a3)
{
  int v4 = (llvm::MCExpr *)sub_1CCBCC780((uint64_t)this, (uint64_t)a3, (uint64_t)a2);
  uint64_t v9 = 0;
  uint64_t v5 = (const llvm::MCAssembler *)(*(uint64_t (**)(llvm::MCObjectStreamer *))(*(void *)this + 72))(this);
  if (!llvm::MCExpr::evaluateAsAbsolute(v4, (uint64_t *)&v9, v5)) {
    operator new();
  }
  int v8 = v9;

  llvm::MCDwarfFrameEmitter::EmitAdvanceLoc(this, v8, v6, v7);
}

char *llvm::MCObjectStreamer::emitCVLocDirective(llvm::MCContext **a1, unsigned int a2, uint64_t a3, int a4, __int16 a5, char a6, BOOL a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v15 = a3;
  uint64_t result = (char *)llvm::MCStreamer::checkCVLocSection((uint64_t)a1, a2, a3, a11);
  if (result)
  {
    __int16 v19 = a1[1];
    uint64_t v23 = "tmp";
    __int16 v24 = 259;
    uint64_t TempSymbol = (const llvm::MCSymbol *)llvm::MCContext::createTempSymbol(v19, (const llvm::Twine *)&v23, 1);
    (*((void (**)(llvm::MCContext **, const llvm::MCSymbol *, void))*a1 + 24))(a1, TempSymbol, 0);
    CVuint64_t Context = (llvm::CodeViewContext *)llvm::MCContext::getCVContext(a1[1]);
    uint64_t v22 = a1[1];
    return llvm::CodeViewContext::recordCVLoc(CVContext, v22, TempSymbol, a2, v15, a4, a5, a6, a7);
  }
  return result;
}

uint64_t llvm::MCObjectStreamer::emitCVLinetableDirective(llvm::MCContext **this, unsigned int a2, const llvm::MCSymbol *a3, const llvm::MCSymbol *a4)
{
  CVuint64_t Context = (llvm::CodeViewContext *)llvm::MCContext::getCVContext(this[1]);
  llvm::CodeViewContext::emitLineTableForFunction(CVContext, (llvm::MCObjectStreamer *)this, a2, a3, a4);

  return llvm::MCStreamer::emitCVLinetableDirective((llvm::MCStreamer *)this, a2, a3, a4);
}

void llvm::MCObjectStreamer::emitCVInlineLinetableDirective(llvm::MCContext **this, unsigned int a2, unsigned int a3, unsigned int a4, const llvm::MCSymbol *a5, const llvm::MCSymbol *a6)
{
  CVuint64_t Context = (llvm::CodeViewContext *)llvm::MCContext::getCVContext(this[1]);
  llvm::CodeViewContext::emitInlineLineTableForFunction(CVContext, (llvm::MCObjectStreamer *)this, a2, a3, a4, a5, a6);
}

void llvm::MCObjectStreamer::emitCVDefRangeDirective(uint64_t a1)
{
}

uint64_t llvm::MCObjectStreamer::emitCVStringTableDirective(llvm::MCContext **this)
{
  CVuint64_t Context = (llvm::CodeViewContext *)llvm::MCContext::getCVContext(this[1]);

  return llvm::CodeViewContext::emitStringTable(CVContext, (llvm::MCObjectStreamer *)this);
}

uint64_t llvm::MCObjectStreamer::emitCVFileChecksumsDirective(llvm::MCContext **this)
{
  CVuint64_t Context = llvm::MCContext::getCVContext(this[1]);

  return llvm::CodeViewContext::emitFileChecksums(CVContext, (llvm::MCObjectStreamer *)this);
}

uint64_t llvm::MCObjectStreamer::emitCVFileChecksumOffsetDirective(llvm::MCContext **this, unsigned int a2)
{
  CVuint64_t Context = (llvm::CodeViewContext *)llvm::MCContext::getCVContext(this[1]);

  return llvm::CodeViewContext::emitFileChecksumOffset(CVContext, (llvm::MCObjectStreamer *)this, a2);
}

void llvm::MCObjectStreamer::emitLazyBytes(uint64_t a1, uint64_t a2, llvm::MCSection *a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 120);
  if (v3) {
    int v4 = *(llvm::MCStreamer **)(*(void *)(a1 + 112) + 32 * v3 - 32);
  }
  else {
    int v4 = 0;
  }
  llvm::MCDwarfLineEntry::make((llvm::MCDwarfLineEntry *)a1, v4, a3);
  operator new();
}

void llvm::MCObjectStreamer::emitValueToOffset()
{
}

void *llvm::MCObjectStreamer::emitDTPRel32Value(llvm::MCObjectStreamer *this, const llvm::MCExpr *a2)
{
  unint64_t DataFragment = llvm::MCObjectStreamer::getOrCreateDataFragment(this, 0);
  llvm::MCObjectStreamer::flushPendingLabels(this, DataFragment, *(void *)(DataFragment + 72));
  uint64_t v5 = *(void *)(DataFragment + 72);
  int v10 = a2;
  int v11 = v5;
  int v12 = 14;
  uint64_t v13 = 0;
  uint64_t result = (void *)sub_1CD41C4F0(DataFragment + 120, (unint64_t)&v10, 1);
  uint64_t v7 = *(void *)(DataFragment + 120) + 24 * *(unsigned int *)(DataFragment + 128);
  long long v8 = *(_OWORD *)result;
  *(void *)(v7 + 16) = result[2];
  *(_OWORD *)uint64_t v7 = v8;
  ++*(_DWORD *)(DataFragment + 128);
  unint64_t v9 = *(void *)(DataFragment + 72);
  if (v9 < 0xFFFFFFFFFFFFFFFCLL) {
    return sub_1CD68E82C((void *)(DataFragment + 64), 4uLL, 0);
  }
  *(void *)(DataFragment + 72) = v9 + 4;
  return result;
}

void *llvm::MCObjectStreamer::emitDTPRel64Value(llvm::MCObjectStreamer *this, const llvm::MCExpr *a2)
{
  unint64_t DataFragment = llvm::MCObjectStreamer::getOrCreateDataFragment(this, 0);
  llvm::MCObjectStreamer::flushPendingLabels(this, DataFragment, *(void *)(DataFragment + 72));
  uint64_t v5 = *(void *)(DataFragment + 72);
  int v10 = a2;
  int v11 = v5;
  int v12 = 15;
  uint64_t v13 = 0;
  uint64_t result = (void *)sub_1CD41C4F0(DataFragment + 120, (unint64_t)&v10, 1);
  uint64_t v7 = *(void *)(DataFragment + 120) + 24 * *(unsigned int *)(DataFragment + 128);
  long long v8 = *(_OWORD *)result;
  *(void *)(v7 + 16) = result[2];
  *(_OWORD *)uint64_t v7 = v8;
  ++*(_DWORD *)(DataFragment + 128);
  unint64_t v9 = *(void *)(DataFragment + 72);
  if (v9 < 0xFFFFFFFFFFFFFFF8) {
    return sub_1CD68E82C((void *)(DataFragment + 64), 8uLL, 0);
  }
  *(void *)(DataFragment + 72) = v9 + 8;
  return result;
}

void *llvm::MCObjectStreamer::emitTPRel32Value(llvm::MCObjectStreamer *this, const llvm::MCExpr *a2)
{
  unint64_t DataFragment = llvm::MCObjectStreamer::getOrCreateDataFragment(this, 0);
  llvm::MCObjectStreamer::flushPendingLabels(this, DataFragment, *(void *)(DataFragment + 72));
  uint64_t v5 = *(void *)(DataFragment + 72);
  int v10 = a2;
  int v11 = v5;
  int v12 = 16;
  uint64_t v13 = 0;
  uint64_t result = (void *)sub_1CD41C4F0(DataFragment + 120, (unint64_t)&v10, 1);
  uint64_t v7 = *(void *)(DataFragment + 120) + 24 * *(unsigned int *)(DataFragment + 128);
  long long v8 = *(_OWORD *)result;
  *(void *)(v7 + 16) = result[2];
  *(_OWORD *)uint64_t v7 = v8;
  ++*(_DWORD *)(DataFragment + 128);
  unint64_t v9 = *(void *)(DataFragment + 72);
  if (v9 < 0xFFFFFFFFFFFFFFFCLL) {
    return sub_1CD68E82C((void *)(DataFragment + 64), 4uLL, 0);
  }
  *(void *)(DataFragment + 72) = v9 + 4;
  return result;
}

void *llvm::MCObjectStreamer::emitTPRel64Value(llvm::MCObjectStreamer *this, const llvm::MCExpr *a2)
{
  unint64_t DataFragment = llvm::MCObjectStreamer::getOrCreateDataFragment(this, 0);
  llvm::MCObjectStreamer::flushPendingLabels(this, DataFragment, *(void *)(DataFragment + 72));
  uint64_t v5 = *(void *)(DataFragment + 72);
  int v10 = a2;
  int v11 = v5;
  int v12 = 17;
  uint64_t v13 = 0;
  uint64_t result = (void *)sub_1CD41C4F0(DataFragment + 120, (unint64_t)&v10, 1);
  uint64_t v7 = *(void *)(DataFragment + 120) + 24 * *(unsigned int *)(DataFragment + 128);
  long long v8 = *(_OWORD *)result;
  *(void *)(v7 + 16) = result[2];
  *(_OWORD *)uint64_t v7 = v8;
  ++*(_DWORD *)(DataFragment + 128);
  unint64_t v9 = *(void *)(DataFragment + 72);
  if (v9 < 0xFFFFFFFFFFFFFFF8) {
    return sub_1CD68E82C((void *)(DataFragment + 64), 8uLL, 0);
  }
  *(void *)(DataFragment + 72) = v9 + 8;
  return result;
}

void *llvm::MCObjectStreamer::emitGPRel32Value(llvm::MCObjectStreamer *this, const llvm::MCExpr *a2)
{
  unint64_t DataFragment = llvm::MCObjectStreamer::getOrCreateDataFragment(this, 0);
  llvm::MCObjectStreamer::flushPendingLabels(this, DataFragment, *(void *)(DataFragment + 72));
  uint64_t v5 = *(void *)(DataFragment + 72);
  int v10 = a2;
  int v11 = v5;
  int v12 = 12;
  uint64_t v13 = 0;
  uint64_t result = (void *)sub_1CD41C4F0(DataFragment + 120, (unint64_t)&v10, 1);
  uint64_t v7 = *(void *)(DataFragment + 120) + 24 * *(unsigned int *)(DataFragment + 128);
  long long v8 = *(_OWORD *)result;
  *(void *)(v7 + 16) = result[2];
  *(_OWORD *)uint64_t v7 = v8;
  ++*(_DWORD *)(DataFragment + 128);
  unint64_t v9 = *(void *)(DataFragment + 72);
  if (v9 < 0xFFFFFFFFFFFFFFFCLL) {
    return sub_1CD68E82C((void *)(DataFragment + 64), 4uLL, 0);
  }
  *(void *)(DataFragment + 72) = v9 + 4;
  return result;
}

void *llvm::MCObjectStreamer::emitGPRel64Value(llvm::MCObjectStreamer *this, const llvm::MCExpr *a2)
{
  unint64_t DataFragment = llvm::MCObjectStreamer::getOrCreateDataFragment(this, 0);
  llvm::MCObjectStreamer::flushPendingLabels(this, DataFragment, *(void *)(DataFragment + 72));
  uint64_t v5 = *(void *)(DataFragment + 72);
  int v10 = a2;
  int v11 = v5;
  int v12 = 12;
  uint64_t v13 = 0;
  uint64_t result = (void *)sub_1CD41C4F0(DataFragment + 120, (unint64_t)&v10, 1);
  uint64_t v7 = *(void *)(DataFragment + 120) + 24 * *(unsigned int *)(DataFragment + 128);
  long long v8 = *(_OWORD *)result;
  *(void *)(v7 + 16) = result[2];
  *(_OWORD *)uint64_t v7 = v8;
  ++*(_DWORD *)(DataFragment + 128);
  unint64_t v9 = *(void *)(DataFragment + 72);
  if (v9 < 0xFFFFFFFFFFFFFFF8) {
    return sub_1CD68E82C((void *)(DataFragment + 64), 8uLL, 0);
  }
  *(void *)(DataFragment + 72) = v9 + 8;
  return result;
}

void llvm::MCObjectStreamer::emitRelocDirective(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unint64_t a5@<X4>, void *a6@<X5>, const llvm::MCSubtargetInfo *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v14 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1[34] + 8) + 72))(*(void *)(a1[34] + 8), a3, a4);
  if ((v14 & 0xFF00000000) == 0)
  {
    int v23 = 25;
    __int16 v24 = (char *)operator new(0x19uLL);
    strcpy(v24, "unknown relocation name");
    *(unsigned char *)a8 = 1;
    uint64_t v25 = 23;
LABEL_10:
    *(void *)(a8 + 8) = v24;
    *(void *)(a8 + 16) = v25;
    *(unsigned char *)(a8 + 30) = 0;
    *(_WORD *)(a8 + 28) = 0;
    *(_DWORD *)(a8 + 24) = v23;
    *(_WORD *)(a8 + 31) = 384;
    return;
  }
  unsigned int v15 = v14;
  if (!a5)
  {
    char v16 = (llvm::MCContext *)a1[1];
    unint64_t v53 = "tmp";
    __int16 v56 = 259;
    uint64_t TempSymbol = llvm::MCContext::createTempSymbol(v16, (const llvm::Twine *)&v53, 1);
    a5 = llvm::MCSymbolRefExpr::create(TempSymbol, 0, a1[1], 0);
  }
  uint64_t DataFragment = llvm::MCObjectStreamer::getOrCreateDataFragment((llvm::MCObjectStreamer *)a1, a7);
  llvm::MCObjectStreamer::flushPendingLabels(a1, DataFragment, *(void *)(DataFragment + 72));
  long long v47 = 0uLL;
  int v49 = 0;
  uint64_t v48 = 0;
  if ((llvm::MCExpr::evaluateAsRelocatable(a2, (uint64_t)&v47, 0, 0) & 1) == 0)
  {
    int v23 = 40;
    __int16 v24 = (char *)operator new(0x28uLL);
    strcpy(v24, ".reloc offset is not relocatable");
    *(unsigned char *)a8 = 0;
    uint64_t v25 = 32;
    goto LABEL_10;
  }
  uint64_t v19 = v47;
  if (v47 == 0)
  {
    if ((v48 & 0x8000000000000000) == 0)
    {
      unint64_t v53 = (const char *)a5;
      v54[0] = (void *)__PAIR64__(v15, v48);
      v54[1] = a6;
      unint64_t v20 = sub_1CD41C4F0(DataFragment + 120, (unint64_t)&v53, 1);
      uint64_t v21 = *(void *)(DataFragment + 120) + 24 * *(unsigned int *)(DataFragment + 128);
      long long v22 = *(_OWORD *)v20;
      *(void *)(v21 + 16) = *(void *)(v20 + 16);
      *(_OWORD *)uint64_t v21 = v22;
      ++*(_DWORD *)(DataFragment + 128);
LABEL_8:
      *(unsigned char *)a8 = 0;
      *(unsigned char *)(a8 + 32) = 0;
      return;
    }
    int v23 = 32;
    __int16 v24 = (char *)operator new(0x20uLL);
    strcpy(v24, ".reloc offset is negative");
    *(unsigned char *)a8 = 0;
    uint64_t v25 = 25;
    goto LABEL_10;
  }
  if (*((void *)&v47 + 1))
  {
    int v23 = 40;
    __int16 v24 = (char *)operator new(0x28uLL);
    strcpy(v24, ".reloc offset is not representable");
    *(unsigned char *)a8 = 0;
    uint64_t v25 = 34;
    goto LABEL_10;
  }
  uint64_t v26 = *(void *)(v47 + 16);
  if (!sub_1CC34BE58(v26, 1))
  {
    uint64_t v27 = *(void *)(v19 + 16);
    unint64_t v53 = (const char *)a5;
    v54[0] = (void *)__PAIR64__(v15, v48);
    v54[1] = a6;
    sub_1CD6B52E8((uint64_t)(a1 + 53), v27, DataFragment, (long long *)&v53);
    goto LABEL_8;
  }
  LOBYTE(v53) = 0;
  LOBYTE(v56) = 0;
  if ((*(_DWORD *)(v26 + 8) & 0x1C00) != 0x800)
  {
    int v30 = *(_DWORD *)(v26 + 24);
    unint64_t v33 = sub_1CC34BE58(v26, 1);
    if (!v33 || *(unsigned char *)(v33 + 48) != 1)
    {
      uint64_t v34 = (char *)operator new(0x28uLL);
      strcpy(v34, "symbol in offset has no data fragment");
      LOBYTE(v43) = 0;
      long long __p = v34;
      uint64_t v45 = 37;
      v46[6] = 0;
      *(_WORD *)&v46[4] = 0;
      *(_DWORD *)unint64_t v46 = 40;
      *(_WORD *)&v46[7] = 384;
      goto LABEL_32;
    }
    goto LABEL_26;
  }
  *(_DWORD *)(v26 + 8) |= 4u;
  uint64_t v28 = *(void *)(v26 + 24);
  long long v50 = 0uLL;
  int v52 = 0;
  uint64_t v51 = 0;
  if ((llvm::MCExpr::evaluateAsRelocatable(v28, (uint64_t)&v50, 0, 0) & 1) == 0)
  {
    uint64_t v35 = (char *)operator new(0x30uLL);
    int v30 = 0;
    strcpy(v35, "symbol in .reloc offset is not relocatable");
    LOBYTE(v43) = 0;
    uint64_t v36 = 42;
LABEL_29:
    long long __p = v35;
    uint64_t v45 = v36;
    uint64_t v37 = 48;
LABEL_30:
    *(void *)unint64_t v46 = v37 & 0xFFFFFFFFFFFFLL | 0x8000000000000000;
    char v32 = 1;
    goto LABEL_31;
  }
  uint64_t v29 = v50;
  if (v50 != 0)
  {
    if (*((void *)&v50 + 1))
    {
      uint64_t v35 = (char *)operator new(0x30uLL);
      int v30 = 0;
      strcpy(v35, ".reloc symbol offset is not representable");
      LOBYTE(v43) = 0;
      uint64_t v36 = 41;
      goto LABEL_29;
    }
    if (!sub_1CC34BE58(*(void *)(v50 + 16), 1))
    {
      uint64_t v35 = (char *)operator new(0x30uLL);
      int v30 = 0;
      strcpy(v35, "symbol used in the .reloc offset is not defined");
      LOBYTE(v43) = 0;
      uint64_t v36 = 47;
      goto LABEL_29;
    }
    uint64_t v42 = *(void *)(v29 + 16);
    if ((*(_DWORD *)(v42 + 8) & 0x1C00) == 0x800)
    {
      uint64_t v35 = (char *)operator new(0x30uLL);
      int v30 = 0;
      strcpy(v35, "symbol used in the .reloc offset is variable");
      LOBYTE(v43) = 0;
      uint64_t v36 = 44;
      goto LABEL_29;
    }
    unint64_t v33 = sub_1CC34BE58(v42, 1);
    if (!v33 || *(unsigned char *)(v33 + 48) != 1)
    {
      size_t v41 = (char *)operator new(0x28uLL);
      int v30 = 0;
      goto LABEL_44;
    }
    int v30 = v51 + *(_DWORD *)(*(void *)(v29 + 16) + 24);
LABEL_26:
    LOBYTE(v43) = 0;
    v46[8] = 0;
    uint64_t DataFragment = v33;
    goto LABEL_32;
  }
  int v30 = v51;
  unint64_t v31 = sub_1CC34BE58(v26, 1);
  if (!v31 || *(unsigned char *)(v31 + 48) != 1)
  {
    size_t v41 = (char *)operator new(0x28uLL);
LABEL_44:
    strcpy(v41, "symbol in offset has no data fragment");
    LOBYTE(v43) = 0;
    long long __p = v41;
    uint64_t v45 = 37;
    uint64_t v37 = 40;
    goto LABEL_30;
  }
  char v32 = 0;
  LOBYTE(v43) = 0;
  uint64_t DataFragment = v31;
LABEL_31:
  v46[8] = v32;
LABEL_32:
  sub_1CD6B5770((uint64_t)&v53, (uint64_t)&v43);
  if (v46[8] && (v46[7] & 0x80000000) != 0) {
    operator delete(__p);
  }
  if ((_BYTE)v56)
  {
    *(unsigned char *)a8 = (_BYTE)v53;
    *(_OWORD *)(a8 + 8) = *(_OWORD *)v54;
    *(void *)(a8 + 24) = v55;
    *(unsigned char *)(a8 + 32) = 1;
  }
  else
  {
    unint64_t v43 = a5;
    LODWORD(__p) = v30 + v48;
    HIDWORD(__p) = v15;
    uint64_t v45 = (uint64_t)a6;
    unint64_t v38 = sub_1CD41C4F0(DataFragment + 120, (unint64_t)&v43, 1);
    uint64_t v39 = *(void *)(DataFragment + 120) + 24 * *(unsigned int *)(DataFragment + 128);
    long long v40 = *(_OWORD *)v38;
    *(void *)(v39 + 16) = *(void *)(v38 + 16);
    *(_OWORD *)uint64_t v39 = v40;
    ++*(_DWORD *)(DataFragment + 128);
    *(unsigned char *)a8 = 0;
    *(unsigned char *)(a8 + 32) = 0;
    if ((_BYTE)v56)
    {
      if (SHIBYTE(v55) < 0) {
        operator delete(v54[0]);
      }
    }
  }
}

uint64_t sub_1CD6B52E8(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  unsigned int v4 = *(_DWORD *)(a1 + 8);
  if (v4 >= *(_DWORD *)(a1 + 12)) {
    return sub_1CD6B5DE4(a1, a2, a3, a4);
  }
  uint64_t v5 = *(void *)a1 + 40 * v4;
  long long v6 = *a4;
  uint64_t v7 = *((void *)a4 + 2);
  *(void *)uint64_t v5 = a2;
  *(_OWORD *)(v5 + 8) = v6;
  *(void *)(v5 + 24) = v7;
  *(void *)(v5 + 32) = a3;
  ++*(_DWORD *)(a1 + 8);
  return a1;
}

uint64_t llvm::MCObjectStreamer::emitFill(llvm::MCObjectStreamer *a1, llvm::MCExpr *a2, uint64_t a3, uint64_t a4, char *a5)
{
  uint64_t v19 = 0;
  int v10 = (const llvm::MCAssembler *)(*(uint64_t (**)(llvm::MCObjectStreamer *))(*(void *)a1 + 72))(a1);
  uint64_t result = llvm::MCExpr::evaluateAsAbsolute(a2, &v19, v10);
  if (!result)
  {
    unint64_t DataFragment = llvm::MCObjectStreamer::getOrCreateDataFragment(a1, 0);
    llvm::MCObjectStreamer::flushPendingLabels(a1, DataFragment, *(void *)(DataFragment + 72));
    operator new();
  }
  uint64_t v12 = v19;
  if (v19 < 0)
  {
    char v16 = *(llvm **)(*((void *)a1 + 1) + 72);
    __int16 v17 = "'.fill' directive with negative repeat count has no effect";
    __int16 v18 = 259;
    return llvm::SourceMgr::PrintMessage(v16, a5, 1, (llvm::Twine *)&v17, 0, 0, 0, 0, 1u);
  }
  else
  {
    if (a3 >= 4) {
      uint64_t v13 = 4;
    }
    else {
      uint64_t v13 = a3;
    }
    if (v19)
    {
      unint64_t v14 = (0xFFFFFFFFFFFFFFFFLL >> (-8 * v13)) & a4;
      do
      {
        uint64_t result = (*(uint64_t (**)(llvm::MCObjectStreamer *, unint64_t, uint64_t))(*(void *)a1 + 520))(a1, v14, v13);
        if (a3 >= 5) {
          uint64_t result = (*(uint64_t (**)(llvm::MCObjectStreamer *, void, void))(*(void *)a1 + 520))(a1, 0, (a3 - v13));
        }
        --v12;
      }
      while (v12);
    }
  }
  return result;
}

void llvm::MCObjectStreamer::emitNops(llvm::MCObjectStreamer *a1)
{
  unint64_t DataFragment = llvm::MCObjectStreamer::getOrCreateDataFragment(a1, 0);
  llvm::MCObjectStreamer::flushPendingLabels(a1, DataFragment, *(void *)(DataFragment + 72));
  operator new();
}

void llvm::MCObjectStreamer::emitFileDirective(uint64_t a1, const std::string::value_type *a2, std::string::size_type a3)
{
}

{
  sub_1CD6B5644(*(int64x2_t **)(a1 + 272), a2, a3);
}

void sub_1CD6B5644(int64x2_t *a1, const std::string::value_type *a2, std::string::size_type a3)
{
  std::string::__init(&v10, a2, a3);
  uint64_t v4 = (a1[4].i64[0] - a1[3].i64[1]) >> 3;
  uint64_t v9 = v4;
  unint64_t v5 = a1[11].u64[1];
  if (v5 >= a1[12].i64[0])
  {
    uint64_t v7 = sub_1CCBCD1A4(a1 + 11, (uint64_t)&v10, &v9);
    int v8 = SHIBYTE(v10.__r_.__value_.__r.__words[2]);
    a1[11].i64[1] = (uint64_t)v7;
    if (v8 < 0) {
      operator delete(v10.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    std::string::size_type v6 = v10.__r_.__value_.__r.__words[2];
    *(_OWORD *)unint64_t v5 = *(_OWORD *)&v10.__r_.__value_.__l.__data_;
    *(void *)(v5 + 16) = v6;
    *(void *)(v5 + 24) = v4;
    a1[11].i64[1] = v5 + 32;
  }
}

uint64_t llvm::MCObjectStreamer::emitAddrsig(llvm::MCObjectStreamer *this)
{
  return (*(uint64_t (**)(void))(**(void **)(*((void *)this + 34) + 24) + 64))();
}

uint64_t llvm::MCObjectStreamer::emitAddrsigSym(llvm::MCObjectStreamer *this, const llvm::MCSymbol *a2)
{
  llvm::MCAssembler::registerSymbol(*((void *)this + 34), (uint64_t)a2, 0);
  uint64_t v3 = *(uint64_t (**)(void))(**(void **)(*((void *)this + 34) + 24) + 72);

  return v3();
}

uint64_t sub_1CD6B5770(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 32);
  if (*(unsigned char *)(a2 + 32))
  {
    *(unsigned char *)a1 = *(unsigned char *)a2;
    unint64_t v5 = (void **)(a1 + 8);
    if (v3)
    {
      if (*(char *)(a1 + 31) < 0) {
        operator delete(*v5);
      }
      long long v6 = *(_OWORD *)(a2 + 8);
      *(void *)(a1 + 24) = *(void *)(a2 + 24);
      *(_OWORD *)unint64_t v5 = v6;
      *(unsigned char *)(a2 + 31) = 0;
      *(unsigned char *)(a2 + 8) = 0;
    }
    else
    {
      long long v8 = *(_OWORD *)(a2 + 8);
      *(void *)(a1 + 24) = *(void *)(a2 + 24);
      *(_OWORD *)unint64_t v5 = v8;
      *(void *)(a2 + 16) = 0;
      *(void *)(a2 + 24) = 0;
      *(void *)(a2 + 8) = 0;
      *(unsigned char *)(a1 + 32) = 1;
    }
  }
  else if (*(unsigned char *)(a1 + 32))
  {
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*(void **)(a1 + 8));
    }
    *(unsigned char *)(a1 + 32) = 0;
  }
  return a1;
}

void sub_1CD6B5824(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = 40 * v1;
    uint64_t v3 = *(void *)a1 + 24;
    do
    {
      if ((*(void *)(v3 - 24) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v4 = *(void **)(v3 - 16);
        if ((void *)v3 != v4) {
          free(v4);
        }
      }
      v3 += 40;
      v2 -= 40;
    }
    while (v2);
  }
}

uint64_t sub_1CD6B588C(uint64_t a1, unsigned int a2)
{
  uint64_t v14[4] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    int v11 = *(uint64_t **)(a1 + 8);
    uint64_t v12 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CCBCD4C8(a1, v11, &v11[v12]);
    JUMPOUT(0x1D25D9CD0);
  }
  long long v6 = v14;
  for (uint64_t i = 8; i != 40; i += 8)
  {
    uint64_t v8 = *(void *)(a1 + i);
    if ((v8 | 0x1000) != 0xFFFFFFFFFFFFF000) {
      *v6++ = v8;
    }
  }
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v9 = a2;
    *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v9;
  }
  return sub_1CCBCD4C8(a1, v14, v6);
}

void *sub_1CD6B5A08(void *result)
{
  uint64_t v1 = result;
  unsigned int v2 = *(_DWORD *)result;
  unsigned int v3 = __clz((*(_DWORD *)result >> 1) - 1);
  if (v3 - 28 >= 3) {
    int v4 = 1 << (33 - v3);
  }
  else {
    int v4 = 64;
  }
  if (v2 >= 2) {
    unsigned int v5 = v4;
  }
  else {
    unsigned int v5 = 0;
  }
  if ((v2 & 1) != 0 && v5 < 5)
  {
    long long v6 = result + 1;
    void *result = 1;
    uint64_t v7 = result + 5;
    do
LABEL_10:
      *v6++ = -4096;
    while (v6 != v7);
    return result;
  }
  if ((v2 & 1) == 0)
  {
    if (v5 == *((_DWORD *)result + 4))
    {
      void *result = 0;
      if (!v5) {
        return result;
      }
      long long v6 = (void *)result[1];
      uint64_t v7 = &v6[v5];
      goto LABEL_10;
    }
    MEMORY[0x1D25D9CD0](result[1], 8);
  }

  return sub_1CC007FAC(v1, v5);
}

void *sub_1CD6B5AE0(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CCBCD600(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  unsigned int v5 = v7;
  if ((v4 & 1) == 0)
  {
    unsigned int v5 = sub_1CD6B5B5C(a1, a2, v7);
    *unsigned int v5 = *a2;
    v5[1] = v5 + 3;
    void v5[2] = 0x100000000;
  }
  return v5;
}

void *sub_1CD6B5B5C(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD6B5C10(a1, v6);
  uint64_t v8 = 0;
  sub_1CCBCD600(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD6B5C10(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(40 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD6B5CE8(a1, v4, v4 + 40 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 40 * v10;
    do
    {
      void *result = -4096;
      result += 5;
      v11 -= 40;
    }
    while (v11);
  }
  return result;
}

void sub_1CD6B5CE8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 40 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 5;
      v8 -= 40;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v9 = *(void *)v4;
      if ((*(void *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v13 = 0;
        sub_1CCBCD600(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        uint64_t v10 = v13;
        *uint64_t v13 = *(void *)v4;
        uint64_t v10[2] = 0x100000000;
        v10[1] = v10 + 3;
        uint64_t v11 = (uint64_t)(v10 + 1);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CD4684F0(v11, v4 + 8);
        }
        ++*(_DWORD *)(a1 + 8);
        uint64_t v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12) {
          free(v12);
        }
      }
      v4 += 40;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1CD6B5DE4(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  long long v12 = *a4;
  uint64_t v5 = *((void *)a4 + 2);
  uint64_t v11 = a2;
  uint64_t v13 = v5;
  uint64_t v14 = a3;
  unint64_t v6 = sub_1CC47EC6C(a1, (unint64_t)&v11);
  uint64_t v7 = *(void *)a1 + 40 * *(unsigned int *)(a1 + 8);
  uint64_t v8 = *(void *)(v6 + 32);
  long long v9 = *(_OWORD *)(v6 + 16);
  *(_OWORD *)uint64_t v7 = *(_OWORD *)v6;
  *(_OWORD *)(v7 + 16) = v9;
  *(void *)(v7 + 32) = v8;
  LODWORD(v7) = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v7;
  return *(void *)a1 + 40 * v7 - 40;
}

BOOL llvm::MCObjectWriter::isSymbolRefDifferenceFullyResolvedImpl(llvm::MCObjectWriter *this, const llvm::MCAssembler *a2, const llvm::MCSymbol *a3, const llvm::MCFragment *a4)
{
  return *(void *)(sub_1CC34BE58((uint64_t)a3, 1) + 16) == *((void *)a4 + 2);
}

void llvm::MCPseudoProbe::emit(uint64_t a1, llvm::MCStreamer *this, uint64_t a3)
{
  uint64_t v6 = a3 != 0;
  llvm::MCStreamer::emitULEB128IntValue(this, *(void *)(a1 + 8), 0);
  (*(void (**)(llvm::MCStreamer *, unint64_t, uint64_t))(*(void *)this + 520))(this, (*(unsigned char *)(a1 + 17) | (16 * *(unsigned char *)(a1 + 16))) | (unint64_t)(v6 << 7), 1);
  uint64_t v7 = *(const llvm::MCSymbol **)(a1 + 24);
  if (a3)
  {
    uint64_t v8 = *(void *)(a3 + 24);
    uint64_t v9 = *((void *)this + 1);
    unint64_t v10 = llvm::MCSymbolRefExpr::create((uint64_t)v7, 0, v9, 0);
    unint64_t v11 = llvm::MCSymbolRefExpr::create(v8, 0, v9, 0);
    long long v12 = (llvm::MCExpr *)llvm::MCBinaryExpr::create(18, v10, v11, v9, 0);
    uint64_t v15 = 0;
    uint64_t v13 = (const llvm::MCAssembler *)(*(uint64_t (**)(llvm::MCStreamer *))(*(void *)this + 72))(this);
    if (!llvm::MCExpr::evaluateAsAbsolute(v12, &v15, v13)) {
      operator new();
    }
    llvm::MCStreamer::emitSLEB128IntValue(this, v15);
  }
  else
  {
    uint64_t v14 = *(unsigned int *)(*(void *)(*((void *)this + 1) + 152) + 8);
    llvm::MCStreamer::emitSymbolValue(this, v7, v14, 0);
  }
}

void llvm::MCPseudoProbeInlineTree::addPseudoProbe()
{
}

void sub_1CD6B61C4()
{
}

void llvm::MCPseudoProbeInlineTree::emit(void *a1, llvm::MCStreamer *a2, uint64_t *a3)
{
  uint64_t v6 = a1[8];
  if (v6)
  {
    (*(void (**)(llvm::MCStreamer *, uint64_t, uint64_t))(*(void *)a2 + 520))(a2, v6, 8);
    llvm::MCStreamer::emitULEB128IntValue(a2, (uint64_t)(a1[6] - a1[5]) >> 5, 0);
    llvm::MCStreamer::emitULEB128IntValue(a2, a1[3], 0);
    uint64_t v7 = a1[5];
    uint64_t v8 = a1[6];
    if (v7 != v8)
    {
      uint64_t v9 = *a3;
      do
      {
        llvm::MCPseudoProbe::emit(v7, a2, v9);
        *a3 = v7;
        uint64_t v9 = v7;
        v7 += 32;
      }
      while (v7 != v8);
    }
  }
  v18[0] = 0;
  v18[1] = 0;
  __int16 v17 = v18;
  unint64_t v10 = (uint64_t *)a1[2];
  if (v10)
  {
    do
    {
      uint64_t v11 = v10[4];
      unint64_t v12 = v10[2];
      uint64_t v19 = v10 + 2;
      *((void *)sub_1CD6B64DC((uint64_t)&v17, v12, *((_DWORD *)v10 + 6), &v19) + 6) = v11;
      unint64_t v10 = (uint64_t *)*v10;
    }
    while (v10);
    uint64_t v13 = v17;
    if (v17 != v18)
    {
      do
      {
        if (a1[8]) {
          llvm::MCStreamer::emitULEB128IntValue(a2, *((unsigned int *)v13 + 10), 0);
        }
        llvm::MCPseudoProbeInlineTree::emit(v13[6], a2, a3);
        uint64_t v14 = v13[1];
        if (v14)
        {
          do
          {
            uint64_t v15 = (void **)v14;
            uint64_t v14 = (void *)*v14;
          }
          while (v14);
        }
        else
        {
          do
          {
            uint64_t v15 = (void **)v13[2];
            BOOL v16 = *v15 == v13;
            uint64_t v13 = v15;
          }
          while (!v16);
        }
        uint64_t v13 = v15;
      }
      while (v15 != v18);
    }
  }
  sub_1CD40B1BC(v18[0]);
}

void llvm::MCPseudoProbeSection::emit(llvm::MCPseudoProbeSection **this, llvm::MCObjectStreamer *a2)
{
  unsigned int v2 = this + 1;
  unsigned int v3 = *this;
  if (*this != (llvm::MCPseudoProbeSection *)(this + 1))
  {
    uint64_t v5 = *((void *)a2 + 1);
    do
    {
      uint64_t v10 = 0;
      uint64_t PseudoProbeSection = llvm::MCObjectFileInfo::getPseudoProbeSection(*(llvm::MCObjectFileInfo **)(v5 + 168), *((const llvm::MCSection **)v3 + 4));
      if (PseudoProbeSection)
      {
        (*(void (**)(llvm::MCObjectStreamer *, uint64_t, void))(*(void *)a2 + 168))(a2, PseudoProbeSection, 0);
        llvm::MCPseudoProbeInlineTree::emit((void *)v3 + 5, a2, &v10);
      }
      uint64_t v7 = (llvm::MCPseudoProbeSection *)*((void *)v3 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = (llvm::MCPseudoProbeSection **)v7;
          uint64_t v7 = *(llvm::MCPseudoProbeSection **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v8 = (llvm::MCPseudoProbeSection **)*((void *)v3 + 2);
          BOOL v9 = *v8 == v3;
          unsigned int v3 = (llvm::MCPseudoProbeSection *)v8;
        }
        while (!v9);
      }
      unsigned int v3 = (llvm::MCPseudoProbeSection *)v8;
    }
    while (v8 != v2);
  }
}

_OWORD *sub_1CD6B64DC(uint64_t a1, unint64_t a2, unsigned int a3, _OWORD **a4)
{
  uint64_t v6 = sub_1CD6B658C(a1, &v13, a2, a3);
  uint64_t v7 = (_OWORD *)*v6;
  if (!*v6)
  {
    BOOL v9 = v6;
    uint64_t v7 = operator new(0x38uLL);
    void v7[2] = **a4;
    *((void *)v7 + 6) = 0;
    uint64_t v10 = v13;
    *(void *)uint64_t v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = v10;
    *BOOL v9 = (uint64_t)v7;
    uint64_t v11 = **(void **)a1;
    unint64_t v12 = (uint64_t *)v7;
    if (v11)
    {
      *(void *)a1 = v11;
      unint64_t v12 = (uint64_t *)*v9;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v12);
    ++*(void *)(a1 + 16);
  }
  return v7;
}

uint64_t *sub_1CD6B658C(uint64_t a1, void *a2, unint64_t a3, unsigned int a4)
{
  uint64_t v6 = *(uint64_t **)(a1 + 8);
  uint64_t result = (uint64_t *)(a1 + 8);
  uint64_t v5 = v6;
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = v5;
        unint64_t v8 = v5[4];
        if (v8 <= a3) {
          break;
        }
LABEL_3:
        uint64_t v5 = (uint64_t *)*v7;
        uint64_t result = v7;
        if (!*v7) {
          goto LABEL_12;
        }
      }
      if (v8 >= a3)
      {
        unsigned int v9 = *((_DWORD *)v7 + 10);
        if (v9 > a4) {
          goto LABEL_3;
        }
        if (v9 >= a4) {
          goto LABEL_12;
        }
      }
      uint64_t result = v7 + 1;
      uint64_t v5 = (uint64_t *)v7[1];
      if (!v5) {
        goto LABEL_12;
      }
    }
  }
  uint64_t v7 = result;
LABEL_12:
  *a2 = v7;
  return result;
}

uint64_t llvm::MCRegisterInfo::getLLVMRegNum(llvm::MCRegisterInfo *this, unsigned int a2, int a3)
{
  uint64_t v3 = 144;
  if (a3) {
    uint64_t v3 = 152;
  }
  uint64_t v4 = *(_DWORD **)((char *)this + v3);
  if (!v4) {
    goto LABEL_15;
  }
  uint64_t v5 = 120;
  if (a3) {
    uint64_t v5 = 124;
  }
  unint64_t v6 = *(unsigned int *)((char *)this + v5);
  uint64_t v7 = &v4[2 * v6];
  if (v6)
  {
    do
    {
      unint64_t v8 = v6 >> 1;
      unsigned int v9 = &v4[2 * (v6 >> 1)];
      unsigned int v11 = *v9;
      uint64_t v10 = v9 + 2;
      v6 += ~(v6 >> 1);
      if (v11 < a2) {
        uint64_t v4 = v10;
      }
      else {
        unint64_t v6 = v8;
      }
    }
    while (v6);
  }
  if (v4 == v7 || *v4 != a2)
  {
    LODWORD(v4) = 0;
LABEL_15:
    unsigned int v12 = 0;
    uint64_t v13 = 0;
    return v13 | v12 | v4;
  }
  LODWORD(v4) = v4[1];
  unsigned int v12 = v4 & 0xFFFFFF00;
  LODWORD(v4) = v4;
  uint64_t v13 = 0x100000000;
  return v13 | v12 | v4;
}

uint64_t llvm::MCRegisterInfo::getSEHRegNum(uint64_t a1, int a2)
{
  int v6 = a2;
  uint64_t v3 = sub_1CBA9CB98((uint64_t *)(a1 + 160), &v6);
  if ((int *)(*(void *)(a1 + 160) + 8 * *(unsigned int *)(a1 + 176)) == v3) {
    uint64_t v4 = (unsigned int *)&v6;
  }
  else {
    uint64_t v4 = (unsigned int *)(v3 + 1);
  }
  return *v4;
}

uint64_t llvm::MCRegisterInfo::getCodeViewRegNum(uint64_t a1, unsigned int a2)
{
  unsigned int v12 = a2;
  if (!*(_DWORD *)(a1 + 192)) {
    llvm::report_fatal_error((llvm *)"target does not implement codeview register mapping", (const llvm::Twine *)1);
  }
  uint64_t v3 = sub_1CBA9CB98((uint64_t *)(a1 + 184), &v12);
  if ((int *)(*(void *)(a1 + 184) + 8 * *(unsigned int *)(a1 + 200)) == v3)
  {
    unsigned int v9 = "unknown codeview register ";
    __int16 v10 = 259;
    if (v12 >= *(_DWORD *)(a1 + 8))
    {
      __int16 v8 = 264;
      LODWORD(v7[0]) = v12;
    }
    else
    {
      uint64_t v5 = (unsigned char *)(*(void *)(a1 + 64) + *(unsigned int *)(*(void *)a1 + 24 * v12));
      char v6 = 1;
      HIBYTE(v8) = 1;
      if (*v5)
      {
        v7[0] = (uint64_t)v5;
        char v6 = 3;
      }
      LOBYTE(v8) = v6;
    }
    sub_1CD3E3950((uint64_t *)&v9, v7, (uint64_t)v11);
    llvm::report_fatal_error((llvm *)v11, (const llvm::Twine *)1);
  }
  return v3[1];
}

uint64_t llvm::MCSection::getEndSymbol(llvm::MCSection *this, llvm::MCContext *a2)
{
  uint64_t result = *((void *)this + 2);
  if (!result)
  {
    uint64_t v4 = "sec_end";
    __int16 v5 = 259;
    uint64_t result = llvm::MCContext::createTempSymbol(a2, (const llvm::Twine *)&v4, 1);
    *((void *)this + 2) = result;
  }
  return result;
}

uint64_t llvm::MCSection::setBundleLockState(uint64_t result, int a2)
{
  if (a2)
  {
    if (*(_DWORD *)(result + 36) != 2) {
      *(_DWORD *)(result + 36) = a2;
    }
    ++*(_DWORD *)(result + 40);
  }
  else
  {
    int v2 = *(_DWORD *)(result + 40);
    if (!v2) {
      llvm::report_fatal_error((llvm *)"Mismatched bundle_lock/unlock directives", (const llvm::Twine *)1);
    }
    int v3 = v2 - 1;
    *(_DWORD *)(result + 40) = v3;
    if (!v3) {
      *(_DWORD *)(result + 36) = 0;
    }
  }
  return result;
}

const char *llvm::MCSection::getVirtualSectionKind(llvm::MCSection *this)
{
  return "virtual";
}

llvm::raw_ostream *llvm::MCSection::dump(llvm::MCFragment **this)
{
  int v2 = (llvm::raw_ostream *)llvm::errs((llvm *)this);
  sub_1CB8E509C(v2, "<MCSection");
  sub_1CB8E509C(v2, " Fragments:[\n      ");
  for (uint64_t i = this[14]; i != (llvm::MCFragment *)(this + 13); uint64_t i = (llvm::MCFragment *)*((void *)i + 1))
  {
    if (i != this[14]) {
      sub_1CB8E509C(v2, ",\n      ");
    }
    llvm::MCFragment::dump(i);
  }

  return sub_1CB8E509C(v2, "]>");
}

uint64_t *sub_1CD6B6948(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *result;
  uint64_t v4 = *((unsigned int *)result + 2);
  if (*result + 16 * v4 == a2)
  {
    if (v4 >= *((_DWORD *)result + 3)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(_OWORD *)(v3 + 16 * v4) = *(_OWORD *)a3;
    ++*((_DWORD *)result + 2);
  }
  else
  {
    if (v4 >= *((_DWORD *)result + 3)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v5 = v3 + 16 * ((a2 - v3) >> 4);
    *(_OWORD *)(v3 + 16 * v4) = *(_OWORD *)(v3 + 16 * v4 - 16);
    uint64_t v6 = *((unsigned int *)result + 2);
    uint64_t v7 = *result + 16 * v6 - 16;
    if (v7 != v5)
    {
      uint64_t v8 = *result + 16 * v6 - 16;
      do
      {
        int v9 = *(_DWORD *)(v8 - 16);
        v8 -= 16;
        *(_DWORD *)uint64_t v7 = v9;
        *(void *)(v7 + 8) = *(void *)(v7 - 8);
        uint64_t v7 = v8;
      }
      while (v8 != v5);
    }
    *((_DWORD *)result + 2) = v6 + 1;
    *(_DWORD *)uint64_t v5 = *(_DWORD *)a3;
    *(void *)(v5 + 8) = *(void *)(a3 + 8);
  }
  return result;
}

BOOL llvm::MCSectionCOFF::shouldOmitSectionDirective(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a1 + 232)) {
    return 0;
  }
  if (a3 == 4)
  {
    return *(_DWORD *)a2 == 1936941614;
  }
  else
  {
    if (a3 != 5) {
      return 0;
    }
    if (*(_DWORD *)a2 == 2019914798 && *(unsigned char *)(a2 + 4) == 116) {
      return 1;
    }
    return *(_DWORD *)a2 == 1952539694 && *(unsigned char *)(a2 + 4) == 97;
  }
}

uint64_t llvm::MCSectionCOFF::setSelection(uint64_t this, int a2)
{
  *(_DWORD *)(this + 240) = a2;
  *(_DWORD *)(this + 224) |= 0x1000u;
  return this;
}

llvm::raw_ostream *llvm::MCSectionCOFF::printSwitchToSection(llvm::MCSectionCOFF *this, const llvm::MCAsmInfo *a2, const llvm::Triple *a3, llvm::raw_ostream *a4, const llvm::MCExpr *a5)
{
  if (llvm::MCSectionCOFF::shouldOmitSectionDirective((uint64_t)this, *((void *)this + 25), *((void *)this + 26)))
  {
    uint64_t v8 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v8 >= *((void *)a4 + 3))
    {
      a4 = llvm::raw_ostream::write(a4, 9);
    }
    else
    {
      *((void *)a4 + 4) = v8 + 1;
      unsigned char *v8 = 9;
    }
    BOOL v16 = (const void *)*((void *)this + 25);
    size_t v17 = *((void *)this + 26);
    uint64_t result = (llvm::raw_ostream *)*((void *)a4 + 4);
    if (v17 <= *((void *)a4 + 3) - (void)result)
    {
      if (v17)
      {
        memcpy(result, v16, v17);
        uint64_t result = (llvm::raw_ostream *)(*((void *)a4 + 4) + v17);
        *((void *)a4 + 4) = result;
      }
    }
    else
    {
      llvm::raw_ostream::write(a4, (const char *)v16, v17);
      uint64_t result = (llvm::raw_ostream *)*((void *)a4 + 4);
    }
    if ((unint64_t)result < *((void *)a4 + 3))
    {
      *((void *)a4 + 4) = (char *)result + 1;
      *(unsigned char *)uint64_t result = 10;
      return result;
    }
    goto LABEL_61;
  }
  int v9 = sub_1CB8E509C(a4, "\t.section\t");
  __int16 v10 = (const void *)*((void *)this + 25);
  unint64_t v11 = *((void *)this + 26);
  unsigned int v12 = (void *)*((void *)v9 + 4);
  if (v11 <= *((void *)v9 + 3) - (void)v12)
  {
    if (v11)
    {
      memcpy(v12, v10, *((void *)this + 26));
      *((void *)v9 + 4) += v11;
    }
  }
  else
  {
    llvm::raw_ostream::write(v9, (const char *)v10, *((void *)this + 26));
  }
  uint64_t result = sub_1CB8E509C(v9, ",\"");
  if ((*((unsigned char *)this + 224) & 0x40) != 0)
  {
    __int16 v18 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v18 >= *((void *)a4 + 3))
    {
      uint64_t result = llvm::raw_ostream::write(a4, 100);
    }
    else
    {
      *((void *)a4 + 4) = v18 + 1;
      *__int16 v18 = 100;
    }
  }
  if ((*((unsigned char *)this + 224) & 0x80) != 0)
  {
    uint64_t v19 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v19 >= *((void *)a4 + 3))
    {
      uint64_t result = llvm::raw_ostream::write(a4, 98);
    }
    else
    {
      *((void *)a4 + 4) = v19 + 1;
      *uint64_t v19 = 98;
    }
  }
  int v14 = *((_DWORD *)this + 56);
  if ((v14 & 0x20000000) != 0)
  {
    uint64_t v15 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v15 >= *((void *)a4 + 3))
    {
      uint64_t result = llvm::raw_ostream::write(a4, 120);
    }
    else
    {
      *((void *)a4 + 4) = v15 + 1;
      unsigned char *v15 = 120;
    }
    int v14 = *((_DWORD *)this + 56);
  }
  if (v14 < 0)
  {
    unint64_t v20 = (char *)*((void *)a4 + 4);
    if ((unint64_t)v20 < *((void *)a4 + 3))
    {
      *((void *)a4 + 4) = v20 + 1;
      char v22 = 119;
      goto LABEL_34;
    }
    int v23 = a4;
    char v24 = 119;
  }
  else
  {
    unint64_t v21 = *((void *)a4 + 3);
    unint64_t v20 = (char *)*((void *)a4 + 4);
    if ((v14 & 0x40000000) != 0)
    {
      if ((unint64_t)v20 < v21)
      {
        *((void *)a4 + 4) = v20 + 1;
        char v22 = 114;
        goto LABEL_34;
      }
      int v23 = a4;
      char v24 = 114;
    }
    else
    {
      if ((unint64_t)v20 < v21)
      {
        *((void *)a4 + 4) = v20 + 1;
        char v22 = 121;
LABEL_34:
        *unint64_t v20 = v22;
        goto LABEL_41;
      }
      int v23 = a4;
      char v24 = 121;
    }
  }
  uint64_t result = llvm::raw_ostream::write(v23, v24);
LABEL_41:
  if ((*((unsigned char *)this + 225) & 8) != 0)
  {
    uint64_t v26 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v26 >= *((void *)a4 + 3))
    {
      uint64_t result = llvm::raw_ostream::write(a4, 110);
    }
    else
    {
      *((void *)a4 + 4) = v26 + 1;
      *uint64_t v26 = 110;
    }
  }
  if ((*((unsigned char *)this + 227) & 0x10) != 0)
  {
    uint64_t v27 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v27 >= *((void *)a4 + 3))
    {
      uint64_t result = llvm::raw_ostream::write(a4, 115);
    }
    else
    {
      *((void *)a4 + 4) = v27 + 1;
      *uint64_t v27 = 115;
    }
  }
  if ((*((unsigned char *)this + 227) & 2) != 0)
  {
    if (*((void *)this + 26) < 6uLL
      || ((uint64_t v28 = (int *)*((void *)this + 25), v29 = *v28, v30 = *((unsigned __int16 *)v28 + 2), v29 == 1650811950)
        ? (BOOL v31 = v30 == 26485)
        : (BOOL v31 = 0),
          !v31))
    {
      char v32 = (unsigned char *)*((void *)a4 + 4);
      if ((unint64_t)v32 >= *((void *)a4 + 3))
      {
        uint64_t result = llvm::raw_ostream::write(a4, 68);
      }
      else
      {
        *((void *)a4 + 4) = v32 + 1;
        *char v32 = 68;
      }
    }
  }
  uint64_t v25 = (unsigned char *)*((void *)a4 + 4);
  if ((unint64_t)v25 >= *((void *)a4 + 3))
  {
    uint64_t result = llvm::raw_ostream::write(a4, 34);
  }
  else
  {
    *((void *)a4 + 4) = v25 + 1;
    *uint64_t v25 = 34;
  }
  if ((*((unsigned char *)this + 225) & 0x10) != 0)
  {
    if (*((void *)this + 29)) {
      uint64_t v34 = ",";
    }
    else {
      uint64_t v34 = "\n\t.linkonce\t";
    }
    uint64_t result = sub_1CB8E509C(a4, v34);
    unsigned int v35 = *((_DWORD *)this + 60) - 1;
    if (v35 <= 6) {
      uint64_t result = sub_1CB8E509C(a4, off_1E684B450[v35]);
    }
    if (*((void *)this + 29))
    {
      sub_1CB8E509C(a4, ",");
      uint64_t result = llvm::MCSymbol::print(*((llvm::MCSymbol **)this + 29), a4, a2);
    }
  }
  unint64_t v33 = (unsigned char *)*((void *)a4 + 4);
  if ((unint64_t)v33 < *((void *)a4 + 3))
  {
    *((void *)a4 + 4) = v33 + 1;
    *unint64_t v33 = 10;
    return result;
  }
LABEL_61:

  return llvm::raw_ostream::write(a4, 10);
}

BOOL llvm::MCSectionCOFF::useCodeAlign(llvm::MCSectionCOFF *this)
{
  return (*((_DWORD *)this + 55) & 0xFE) == 2;
}

uint64_t llvm::MCSectionCOFF::isVirtualSection(llvm::MCSectionCOFF *this)
{
  return *((unsigned __int8 *)this + 224) >> 7;
}

const char *llvm::MCSectionCOFF::getVirtualSectionKind(llvm::MCSectionCOFF *this)
{
  return "IMAGE_SCN_CNT_UNINITIALIZED_DATA";
}

llvm::raw_ostream *llvm::MCSectionELF::printSwitchToSection(llvm::MCSectionELF *this, const llvm::MCAsmInfo *a2, const llvm::Triple *a3, llvm::raw_ostream *a4, const llvm::MCExpr *a5)
{
  if (*((_DWORD *)this + 58) == -1
    && (*(unsigned int (**)(const llvm::MCAsmInfo *, void, void))(*(void *)a2 + 64))(a2, *((void *)this + 25), *((void *)this + 26)))
  {
    int v14 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v14 >= *((void *)a4 + 3))
    {
      llvm::raw_ostream::write(a4, 9);
    }
    else
    {
      *((void *)a4 + 4) = v14 + 1;
      *int v14 = 9;
    }
    uint64_t v37 = (const void *)*((void *)this + 25);
    size_t v38 = *((void *)this + 26);
    uint64_t result = (llvm::raw_ostream *)*((void *)a4 + 4);
    if (v38 <= *((void *)a4 + 3) - (void)result)
    {
      if (v38)
      {
        memcpy(result, v37, v38);
        uint64_t result = (llvm::raw_ostream *)(*((void *)a4 + 4) + v38);
        *((void *)a4 + 4) = result;
      }
    }
    else
    {
      llvm::raw_ostream::write(a4, (const char *)v37, v38);
      uint64_t result = (llvm::raw_ostream *)*((void *)a4 + 4);
    }
    unint64_t v39 = *((void *)a4 + 3);
    if (a5)
    {
      if ((unint64_t)result >= v39)
      {
        llvm::raw_ostream::write(a4, 9);
      }
      else
      {
        *((void *)a4 + 4) = (char *)result + 1;
        *(unsigned char *)uint64_t result = 9;
      }
      llvm::MCExpr::print(a5, a4, a2, 0);
      unint64_t v39 = *((void *)a4 + 3);
      uint64_t result = (llvm::raw_ostream *)*((void *)a4 + 4);
    }
    if ((unint64_t)result < v39)
    {
      *((void *)a4 + 4) = (char *)result + 1;
      *(unsigned char *)uint64_t result = 10;
      return result;
    }
LABEL_141:
    return llvm::raw_ostream::write(a4, 10);
  }
  sub_1CB8E509C(a4, "\t.section\t");
  uint64_t result = sub_1CCBD1154(a4, *((unsigned __int8 **)this + 25), *((void *)this + 26));
  if (*((unsigned char *)a2 + 336))
  {
    int v11 = *((_DWORD *)this + 57);
    if ((v11 & 0x10) == 0)
    {
      if ((v11 & 2) != 0)
      {
        uint64_t result = sub_1CB8E509C(a4, ",#alloc");
        int v11 = *((_DWORD *)this + 57);
      }
      if ((v11 & 4) != 0)
      {
        uint64_t result = sub_1CB8E509C(a4, ",#execinstr");
        int v11 = *((_DWORD *)this + 57);
      }
      if (v11)
      {
        uint64_t result = sub_1CB8E509C(a4, ",#write");
        int v11 = *((_DWORD *)this + 57);
      }
      if (v11 < 0)
      {
        uint64_t result = sub_1CB8E509C(a4, ",#exclude");
        int v11 = *((_DWORD *)this + 57);
      }
      if ((v11 & 0x400) != 0) {
        uint64_t result = sub_1CB8E509C(a4, ",#tls");
      }
LABEL_138:
      unint64_t v46 = (unsigned char *)*((void *)a4 + 4);
      if ((unint64_t)v46 < *((void *)a4 + 3))
      {
        *((void *)a4 + 4) = v46 + 1;
        *unint64_t v46 = 10;
        return result;
      }
      goto LABEL_141;
    }
  }
  sub_1CB8E509C(a4, ",\"");
  int v12 = *((_DWORD *)this + 57);
  if ((v12 & 2) != 0)
  {
    uint64_t v13 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v13 >= *((void *)a4 + 3))
    {
      llvm::raw_ostream::write(a4, 97);
    }
    else
    {
      *((void *)a4 + 4) = v13 + 1;
      *uint64_t v13 = 97;
    }
    int v12 = *((_DWORD *)this + 57);
  }
  if (v12 < 0)
  {
    int v29 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v29 >= *((void *)a4 + 3))
    {
      llvm::raw_ostream::write(a4, 101);
    }
    else
    {
      *((void *)a4 + 4) = v29 + 1;
      *int v29 = 101;
    }
  }
  if ((*((unsigned char *)this + 228) & 4) != 0)
  {
    size_t v17 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v17 >= *((void *)a4 + 3))
    {
      llvm::raw_ostream::write(a4, 120);
    }
    else
    {
      *((void *)a4 + 4) = v17 + 1;
      *size_t v17 = 120;
    }
  }
  if ((*((unsigned char *)this + 229) & 2) != 0)
  {
    __int16 v18 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v18 >= *((void *)a4 + 3))
    {
      llvm::raw_ostream::write(a4, 71);
    }
    else
    {
      *((void *)a4 + 4) = v18 + 1;
      *__int16 v18 = 71;
    }
  }
  if (*((unsigned char *)this + 228))
  {
    uint64_t v19 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v19 >= *((void *)a4 + 3))
    {
      llvm::raw_ostream::write(a4, 119);
    }
    else
    {
      *((void *)a4 + 4) = v19 + 1;
      *uint64_t v19 = 119;
    }
  }
  if ((*((unsigned char *)this + 228) & 0x10) != 0)
  {
    unint64_t v20 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v20 >= *((void *)a4 + 3))
    {
      llvm::raw_ostream::write(a4, 77);
    }
    else
    {
      *((void *)a4 + 4) = v20 + 1;
      *unint64_t v20 = 77;
    }
  }
  if ((*((unsigned char *)this + 228) & 0x20) != 0)
  {
    unint64_t v21 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v21 >= *((void *)a4 + 3))
    {
      llvm::raw_ostream::write(a4, 83);
    }
    else
    {
      *((void *)a4 + 4) = v21 + 1;
      *unint64_t v21 = 83;
    }
  }
  if ((*((unsigned char *)this + 229) & 4) != 0)
  {
    char v22 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v22 >= *((void *)a4 + 3))
    {
      llvm::raw_ostream::write(a4, 84);
    }
    else
    {
      *((void *)a4 + 4) = v22 + 1;
      *char v22 = 84;
    }
  }
  if ((*((unsigned char *)this + 228) & 0x80) != 0)
  {
    int v23 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v23 >= *((void *)a4 + 3))
    {
      llvm::raw_ostream::write(a4, 111);
    }
    else
    {
      *((void *)a4 + 4) = v23 + 1;
      unsigned char *v23 = 111;
    }
  }
  if ((*((unsigned char *)this + 230) & 0x20) != 0)
  {
    char v24 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v24 >= *((void *)a4 + 3))
    {
      llvm::raw_ostream::write(a4, 82);
    }
    else
    {
      *((void *)a4 + 4) = v24 + 1;
      *char v24 = 82;
    }
  }
  if (*((_DWORD *)a3 + 9) == 14 && (*((unsigned char *)this + 230) & 0x10) != 0)
  {
    char v32 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v32 >= *((void *)a4 + 3))
    {
      llvm::raw_ostream::write(a4, 82);
    }
    else
    {
      *((void *)a4 + 4) = v32 + 1;
      *char v32 = 82;
    }
  }
  uint64_t v15 = *((unsigned int *)a3 + 6);
  if (v15 <= 0x2B)
  {
    if (((1 << v15) & 0x18000000006) != 0)
    {
      if ((*((unsigned char *)this + 231) & 0x20) == 0) {
        goto LABEL_36;
      }
      int v30 = (char *)*((void *)a4 + 4);
      if ((unint64_t)v30 < *((void *)a4 + 3))
      {
        *((void *)a4 + 4) = v30 + 1;
        char v31 = 121;
        goto LABEL_74;
      }
      long long v40 = a4;
      char v41 = 121;
LABEL_106:
      llvm::raw_ostream::write(v40, v41);
      goto LABEL_36;
    }
    if (v15 == 12)
    {
      if ((*((unsigned char *)this + 231) & 0x10) == 0) {
        goto LABEL_36;
      }
      int v30 = (char *)*((void *)a4 + 4);
      if ((unint64_t)v30 < *((void *)a4 + 3))
      {
        *((void *)a4 + 4) = v30 + 1;
        char v31 = 115;
        goto LABEL_74;
      }
      long long v40 = a4;
      char v41 = 115;
      goto LABEL_106;
    }
    if (v15 == 43)
    {
      if ((*((unsigned char *)this + 231) & 0x20) != 0)
      {
        uint64_t v42 = (unsigned char *)*((void *)a4 + 4);
        if ((unint64_t)v42 >= *((void *)a4 + 3))
        {
          llvm::raw_ostream::write(a4, 99);
        }
        else
        {
          *((void *)a4 + 4) = v42 + 1;
          *uint64_t v42 = 99;
        }
      }
      if ((*((unsigned char *)this + 231) & 0x10) != 0)
      {
        int v30 = (char *)*((void *)a4 + 4);
        if ((unint64_t)v30 < *((void *)a4 + 3))
        {
          *((void *)a4 + 4) = v30 + 1;
          char v31 = 100;
LABEL_74:
          *int v30 = v31;
          goto LABEL_36;
        }
        long long v40 = a4;
        char v41 = 100;
        goto LABEL_106;
      }
    }
  }
LABEL_36:
  BOOL v16 = (unsigned char *)*((void *)a4 + 4);
  if ((unint64_t)v16 >= *((void *)a4 + 3))
  {
    llvm::raw_ostream::write(a4, 34);
  }
  else
  {
    *((void *)a4 + 4) = v16 + 1;
    *BOOL v16 = 34;
  }
  uint64_t v25 = (unsigned char *)*((void *)a4 + 4);
  if ((unint64_t)v25 >= *((void *)a4 + 3))
  {
    llvm::raw_ostream::write(a4, 44);
  }
  else
  {
    *((void *)a4 + 4) = v25 + 1;
    *uint64_t v25 = 44;
  }
  unint64_t v27 = *((void *)a4 + 3);
  uint64_t v26 = (char *)*((void *)a4 + 4);
  if (**((unsigned char **)a2 + 6) == 64)
  {
    if ((unint64_t)v26 < v27)
    {
      *((void *)a4 + 4) = v26 + 1;
      char v28 = 37;
LABEL_63:
      *uint64_t v26 = v28;
      goto LABEL_88;
    }
    unint64_t v33 = a4;
    char v34 = 37;
  }
  else
  {
    if ((unint64_t)v26 < v27)
    {
      *((void *)a4 + 4) = v26 + 1;
      char v28 = 64;
      goto LABEL_63;
    }
    unint64_t v33 = a4;
    char v34 = 64;
  }
  llvm::raw_ostream::write(v33, v34);
LABEL_88:
  uint64_t v35 = *((unsigned int *)this + 56);
  if ((int)v35 <= 1879002111)
  {
    uint64_t v36 = "init_array";
    switch((int)v35)
    {
      case 7:
        uint64_t v36 = "note";
        break;
      case 8:
        uint64_t v36 = "nobits";
        break;
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
        goto LABEL_161;
      case 14:
        break;
      case 15:
        uint64_t v36 = "fini_array";
        break;
      case 16:
        uint64_t v36 = "preinit_array";
        break;
      default:
        if (v35 != 1) {
          goto LABEL_161;
        }
        uint64_t v36 = "progbits";
        break;
    }
  }
  else
  {
    switch((int)v35)
    {
      case 1879002112:
        uint64_t v36 = "llvm_odrtab";
        break;
      case 1879002113:
        uint64_t v36 = "llvm_linker_options";
        break;
      case 1879002114:
      case 1879002115:
      case 1879002118:
      case 1879002119:
        goto LABEL_161;
      case 1879002116:
        uint64_t v36 = "llvm_dependent_libraries";
        break;
      case 1879002117:
        uint64_t v36 = "llvm_sympart";
        break;
      case 1879002120:
        uint64_t v36 = "llvm_bb_addr_map";
        break;
      case 1879002121:
        uint64_t v36 = "llvm_call_graph_profile";
        break;
      default:
        if (v35 == 1879048193)
        {
          uint64_t v36 = "unwind";
        }
        else
        {
          if (v35 != 1879048222)
          {
LABEL_161:
            uint64_t v67 = "unsupported type 0x";
            __int16 v68 = 259;
            uint64_t v64 = v35;
            v65[0] = (uint64_t)&v64;
            v65[2] = 0;
            __int16 v66 = 270;
            sub_1CD3E3950((uint64_t *)&v67, v65, (uint64_t)v69);
            uint64_t v62 = " for section ";
            __int16 v63 = 259;
            sub_1CD3E3950(v69, (uint64_t *)&v62, (uint64_t)v70);
            uint64_t v58 = *((void *)this + 25);
            uint64_t v59 = *((void *)this + 26);
            __int16 v61 = 261;
            v60[0] = v58;
            v60[1] = v59;
            sub_1CD3E3950(v70, v60, (uint64_t)v71);
            llvm::report_fatal_error((llvm *)v71, (const llvm::Twine *)1);
          }
          uint64_t v36 = "0x7000001e";
        }
        break;
    }
  }
  uint64_t result = sub_1CB8E509C(a4, v36);
  if (*((_DWORD *)this + 59))
  {
    unint64_t v43 = sub_1CB8E509C(a4, ",");
    uint64_t result = llvm::raw_ostream::operator<<(v43, *((unsigned int *)this + 59));
  }
  if ((*((unsigned char *)this + 229) & 2) != 0)
  {
    sub_1CB8E509C(a4, ",");
    long long v47 = (unsigned char *)(*((void *)this + 30) & 0xFFFFFFFFFFFFFFF8);
    if ((*v47 & 4) != 0)
    {
      unint64_t v53 = (void *)*((void *)v47 - 1);
      int64_t v54 = *v53;
      uint64_t v48 = (unsigned __int8 *)(v53 + 2);
      int64_t v49 = v54;
    }
    else
    {
      uint64_t v48 = 0;
      int64_t v49 = 0;
    }
    uint64_t result = sub_1CCBD1154(a4, v48, v49);
    if ((*((unsigned char *)this + 240) & 4) != 0) {
      uint64_t result = sub_1CB8E509C(a4, ",comdat");
    }
  }
  if ((*((unsigned char *)this + 228) & 0x80) != 0)
  {
    uint64_t result = sub_1CB8E509C(a4, ",");
    long long v50 = (unsigned char *)*((void *)this + 31);
    if (v50)
    {
      if ((*v50 & 4) != 0)
      {
        __int16 v56 = (void *)*((void *)v50 - 1);
        int64_t v57 = *v56;
        uint64_t v51 = (unsigned __int8 *)(v56 + 2);
        int64_t v52 = v57;
      }
      else
      {
        uint64_t v51 = 0;
        int64_t v52 = 0;
      }
      uint64_t result = sub_1CCBD1154(a4, v51, v52);
    }
    else
    {
      uint64_t v55 = (unsigned char *)*((void *)a4 + 4);
      if ((unint64_t)v55 >= *((void *)a4 + 3))
      {
        uint64_t result = llvm::raw_ostream::write(a4, 48);
      }
      else
      {
        *((void *)a4 + 4) = v55 + 1;
        *uint64_t v55 = 48;
      }
    }
  }
  if (*((_DWORD *)this + 58) != -1)
  {
    uint64_t v44 = sub_1CB8E509C(a4, ",unique,");
    uint64_t result = llvm::raw_ostream::operator<<(v44, *((unsigned int *)this + 58));
  }
  uint64_t v45 = (unsigned char *)*((void *)a4 + 4);
  if ((unint64_t)v45 >= *((void *)a4 + 3))
  {
    uint64_t result = llvm::raw_ostream::write(a4, 10);
  }
  else
  {
    *((void *)a4 + 4) = v45 + 1;
    unsigned char *v45 = 10;
  }
  if (a5)
  {
    sub_1CB8E509C(a4, "\t.subsection\t");
    uint64_t result = llvm::MCExpr::print(a5, a4, a2, 0);
    goto LABEL_138;
  }
  return result;
}

uint64_t llvm::MCSectionELF::useCodeAlign(llvm::MCSectionELF *this)
{
  return (*((unsigned __int8 *)this + 228) >> 2) & 1;
}

BOOL llvm::MCSectionELF::isVirtualSection(llvm::MCSectionELF *this)
{
  return *((_DWORD *)this + 56) == 8;
}

const char *llvm::MCSectionELF::getVirtualSectionKind(llvm::MCSectionELF *this)
{
  return "SHT_NOBITS";
}

llvm::raw_ostream *llvm::MCSectionMachO::printSwitchToSection(llvm::MCSectionMachO *this, const llvm::MCAsmInfo *a2, const llvm::Triple *a3, llvm::raw_ostream *a4, const llvm::MCExpr *a5)
{
  uint64_t v7 = sub_1CB8E509C(a4, "\t.section\t");
  uint64_t v8 = v7;
  if (*((unsigned char *)this + 239))
  {
    __int16 v10 = (void *)((char *)v7 + 32);
    int v9 = (unsigned char *)*((void *)v7 + 4);
    size_t v11 = 16;
    if (*((void *)v8 + 3) - (void)v9 <= 0xFuLL)
    {
LABEL_3:
      llvm::raw_ostream::write(v8, (const char *)this + 224, v11);
      int v9 = (unsigned char *)*((void *)v8 + 4);
      goto LABEL_4;
    }
LABEL_17:
    memcpy(v9, (char *)this + 224, v11);
    int v9 = (unsigned char *)(*v10 + v11);
    *__int16 v10 = v9;
    goto LABEL_4;
  }
  size_t v11 = strlen((const char *)this + 224);
  __int16 v10 = (void *)((char *)v8 + 32);
  int v9 = (unsigned char *)*((void *)v8 + 4);
  if (v11 > *((void *)v8 + 3) - (void)v9) {
    goto LABEL_3;
  }
  if (v11) {
    goto LABEL_17;
  }
LABEL_4:
  if ((unint64_t)v9 >= *((void *)v8 + 3))
  {
    uint64_t v8 = llvm::raw_ostream::write(v8, 44);
  }
  else
  {
    *((void *)v8 + 4) = v9 + 1;
    *int v9 = 44;
  }
  int v12 = (const void *)*((void *)this + 25);
  unint64_t v13 = *((void *)this + 26);
  uint64_t result = (llvm::raw_ostream *)*((void *)v8 + 4);
  if (v13 <= *((void *)v8 + 3) - (void)result)
  {
    if (v13)
    {
      uint64_t result = (llvm::raw_ostream *)memcpy(result, v12, *((void *)this + 26));
      *((void *)v8 + 4) += v13;
    }
  }
  else
  {
    uint64_t result = llvm::raw_ostream::write(v8, (const char *)v12, *((void *)this + 26));
  }
  int v15 = *((_DWORD *)this + 60);
  if (!v15) {
    goto LABEL_48;
  }
  BOOL v16 = &(&off_1E684B488)[4 * *((_DWORD *)this + 60)];
  size_t v17 = (size_t)v16[1];
  unint64_t v19 = *((void *)a4 + 3);
  __int16 v18 = (unsigned char *)*((void *)a4 + 4);
  BOOL v20 = (unint64_t)v18 >= v19;
  if (!v17) {
    goto LABEL_50;
  }
  if ((unint64_t)v18 >= v19)
  {
    llvm::raw_ostream::write(a4, 44);
  }
  else
  {
    *((void *)a4 + 4) = v18 + 1;
    *__int16 v18 = 44;
  }
  unint64_t v21 = *v16;
  char v22 = (void *)*((void *)a4 + 4);
  if (v17 <= *((void *)a4 + 3) - (void)v22)
  {
    uint64_t result = (llvm::raw_ostream *)memcpy(v22, v21, v17);
    *((void *)a4 + 4) += v17;
  }
  else
  {
    uint64_t result = llvm::raw_ostream::write(a4, v21, v17);
  }
  unsigned int v23 = v15 & 0xFFFFFF00;
  if ((v15 & 0xFFFFFF00) != 0)
  {
    uint64_t v24 = 0;
    char v25 = 44;
    do
    {
      uint64_t v26 = v24 + 40;
      if (v24 == 400) {
        break;
      }
      int v27 = *(int *)((char *)dword_1E684B748 + v24);
      if ((v27 & v23) != 0)
      {
        char v28 = (char *)*((void *)a4 + 4);
        if ((unint64_t)v28 >= *((void *)a4 + 3))
        {
          llvm::raw_ostream::write(a4, v25);
        }
        else
        {
          *((void *)a4 + 4) = v28 + 1;
          *char v28 = v25;
        }
        v23 &= ~v27;
        int v29 = (void *)((char *)dword_1E684B748 + v24);
        size_t v30 = *(void *)((char *)&dword_1E684B748[4] + v24);
        if (v30)
        {
          char v31 = (const void *)v29[1];
          char v32 = (void *)*((void *)a4 + 4);
          if (v30 <= *((void *)a4 + 3) - (void)v32)
          {
            uint64_t result = (llvm::raw_ostream *)memcpy(v32, v31, v30);
            *((void *)a4 + 4) += v30;
          }
          else
          {
            uint64_t result = llvm::raw_ostream::write(a4, (const char *)v31, v30);
          }
        }
        else
        {
          unint64_t v33 = sub_1CB8E509C(a4, "<<");
          char v34 = (const void *)v29[3];
          size_t v35 = v29[4];
          uint64_t v36 = (void *)*((void *)v33 + 4);
          if (v35 <= *((void *)v33 + 3) - (void)v36)
          {
            if (v35)
            {
              memcpy(v36, v34, v35);
              *((void *)v33 + 4) += v35;
            }
          }
          else
          {
            llvm::raw_ostream::write(v33, (const char *)v34, v35);
          }
          uint64_t result = sub_1CB8E509C(v33, ">>");
        }
        char v25 = 43;
      }
      uint64_t v24 = v26;
    }
    while (v23);
    unint64_t v37 = *((void *)a4 + 3);
    __int16 v18 = (unsigned char *)*((void *)a4 + 4);
    if (!*((_DWORD *)this + 61)) {
      goto LABEL_49;
    }
    if ((unint64_t)v18 >= v37)
    {
      size_t v38 = llvm::raw_ostream::write(a4, 44);
    }
    else
    {
      *((void *)a4 + 4) = v18 + 1;
      *__int16 v18 = 44;
      size_t v38 = a4;
    }
    goto LABEL_47;
  }
  if (*((_DWORD *)this + 61))
  {
    size_t v38 = sub_1CB8E509C(a4, ",none,");
LABEL_47:
    uint64_t result = llvm::raw_ostream::operator<<(v38, *((unsigned int *)this + 61));
  }
LABEL_48:
  unint64_t v37 = *((void *)a4 + 3);
  __int16 v18 = (unsigned char *)*((void *)a4 + 4);
LABEL_49:
  BOOL v20 = (unint64_t)v18 >= v37;
LABEL_50:
  if (v20)
  {
    return llvm::raw_ostream::write(a4, 10);
  }
  else
  {
    *((void *)a4 + 4) = v18 + 1;
    *__int16 v18 = 10;
  }
  return result;
}

void llvm::MCSectionMachO::ParseSectionSpecifier(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, int *a5@<X4>, unsigned char *a6@<X5>, _DWORD *a7@<X6>, void *a8@<X8>)
{
  v55[10] = *MEMORY[0x1E4F143B8];
  v48[0] = a1;
  v48[1] = a2;
  *a6 = 0;
  unint64_t v53 = v55;
  uint64_t v54 = 0x500000000;
  uint64_t v13 = (uint64_t)llvm::StringRef::split((char *)v48, (uint64_t)&v53, 44, -1, 1);
  if (!v54)
  {
    *a3 = 0;
    a3[1] = 0;
    *a4 = 0;
    a4[1] = 0;
    goto LABEL_3;
  }
  uint64_t v13 = sub_1CD5A69D0(v53, " \t\n\v\f\r", 6);
  unsigned int v34 = v54;
  *a3 = v13;
  a3[1] = v35;
  if (v34 <= 1)
  {
    int v14 = 0;
    int v15 = 0;
    *a4 = 0;
    a4[1] = 0;
    goto LABEL_4;
  }
  uint64_t v13 = sub_1CD5A69D0((void *)v53 + 2, " \t\n\v\f\r", 6);
  unsigned int v38 = v54;
  *a4 = v13;
  a4[1] = v39;
  if (v38 <= 2)
  {
LABEL_3:
    int v14 = 0;
    int v15 = 0;
LABEL_4:
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    __int16 v18 = 0;
    uint64_t v46 = 0;
    uint64_t v47 = 0;
    goto LABEL_5;
  }
  uint64_t v13 = sub_1CD5A69D0((void *)v53 + 4, " \t\n\v\f\r", 6);
  int v14 = (const void *)v13;
  int v15 = v40;
  if (v54 <= 3) {
    goto LABEL_4;
  }
  uint64_t v13 = sub_1CD5A69D0((void *)v53 + 6, " \t\n\v\f\r", 6);
  uint64_t v16 = v41;
  uint64_t v46 = v13;
  uint64_t v47 = v41;
  if (v54 >= 5)
  {
    uint64_t v13 = sub_1CD5A69D0((void *)v53 + 8, " \t\n\v\f\r", 6);
    __int16 v18 = (unsigned __int8 *)v13;
    uint64_t v17 = v42;
  }
  else
  {
    uint64_t v17 = 0;
    __int16 v18 = 0;
  }
LABEL_5:
  unint64_t v19 = a4[1];
  if (!v19)
  {
    BOOL v20 = (llvm *)llvm::inconvertibleErrorCode((llvm *)v13);
    v22.__cat_ = (const std::error_category *)"mach-o section specifier requires a segment and section separated by a comma";
    goto LABEL_9;
  }
  if (v19 >= 0x11)
  {
    BOOL v20 = (llvm *)llvm::inconvertibleErrorCode((llvm *)v13);
    v22.__cat_ = (const std::error_category *)"mach-o section specifier requires a section whose length is between 1 and 16 characters";
    goto LABEL_9;
  }
  *a5 = 0;
  *a7 = 0;
  if (!v15)
  {
    *a8 = 0;
    goto LABEL_10;
  }
  uint64_t v44 = a7;
  uint64_t v23 = 0;
  int v24 = 0;
  while (1)
  {
    if (v15 == (&off_1E684B488)[v23 + 1])
    {
      uint64_t v13 = memcmp(v14, (&off_1E684B488)[v23], (size_t)v15);
      if (!v13) {
        break;
      }
    }
    --v24;
    v23 += 4;
    if (v23 == 88)
    {
      BOOL v20 = (llvm *)llvm::inconvertibleErrorCode((llvm *)v13);
      v22.__cat_ = (const std::error_category *)"mach-o section specifier uses an unknown section type";
      goto LABEL_9;
    }
  }
  *a5 = -v24;
  *a6 = 1;
  if (v16)
  {
    long long v50 = v52;
    uint64_t v51 = 0x100000000;
    uint64_t v25 = (uint64_t)llvm::StringRef::split((char *)&v46, (uint64_t)&v50, 43, -1, 0);
    if (v51)
    {
      uint64_t v26 = (char *)v50;
      unint64_t v43 = (char *)v50 + 16 * v51;
      int v27 = v44;
      do
      {
        uint64_t v28 = 0;
        while (1)
        {
          uint64_t v25 = sub_1CD5A69D0(v26, " \t\n\v\f\r", 6);
          size_t v29 = *(void *)&dword_1E684B748[v28 + 4];
          if (v30 == v29)
          {
            if (!v29) {
              break;
            }
            uint64_t v25 = memcmp((const void *)v25, *(const void **)&dword_1E684B748[v28 + 2], v29);
            if (!v25) {
              break;
            }
          }
          v28 += 10;
          if (v28 == 110)
          {
            char v31 = (llvm *)llvm::inconvertibleErrorCode((llvm *)v25);
            v33.__cat_ = (const std::error_category *)"mach-o section specifier has invalid attribute";
            goto LABEL_29;
          }
        }
        int v36 = *a5 | dword_1E684B748[v28];
        *a5 = v36;
        v26 += 16;
      }
      while (v26 != v43);
    }
    else
    {
      int v36 = *a5;
      int v27 = v44;
    }
    if (v17)
    {
      if (v36 == 8)
      {
        unint64_t v49 = 0;
        uint64_t AsUnsignedInteger = llvm::getAsUnsignedInteger(v18, v17, 0, &v49);
        if ((AsUnsignedInteger & 1) == 0 && !HIDWORD(v49))
        {
          *int v27 = v49;
LABEL_46:
          *a8 = 0;
          if (v50 != v52) {
            free(v50);
          }
          goto LABEL_10;
        }
        char v31 = (llvm *)llvm::inconvertibleErrorCode((llvm *)AsUnsignedInteger);
        v33.__cat_ = (const std::error_category *)"mach-o section specifier has a malformed stub size";
      }
      else
      {
        char v31 = (llvm *)llvm::inconvertibleErrorCode((llvm *)v25);
        v33.__cat_ = (const std::error_category *)"mach-o section specifier cannot have a stub size specified because it "
                                                  "does not have type 'symbol_stubs'";
      }
    }
    else
    {
      if (v36 != 8) {
        goto LABEL_46;
      }
      char v31 = (llvm *)llvm::inconvertibleErrorCode((llvm *)v25);
      v33.__cat_ = (const std::error_category *)"mach-o section specifier of type 'symbol_stubs' requires a size specifier";
    }
LABEL_29:
    llvm::createStringError(v31, v33, v32);
  }
  if (v24 == -8)
  {
    BOOL v20 = (llvm *)llvm::inconvertibleErrorCode((llvm *)v13);
    v22.__cat_ = (const std::error_category *)"mach-o section specifier of type 'symbol_stubs' requires a size specifier";
LABEL_9:
    llvm::createStringError(v20, v22, v21);
  }
  *a8 = 0;
LABEL_10:
  if (v53 != v55) {
    free(v53);
  }
}

llvm::raw_ostream *llvm::MCSectionWasm::printSwitchToSection(llvm::MCSectionWasm *this, const llvm::MCAsmInfo *a2, const llvm::Triple *a3, llvm::raw_ostream *a4, const llvm::MCExpr *a5)
{
  if ((*(unsigned int (**)(const llvm::MCAsmInfo *, void, void))(*(void *)a2 + 64))(a2, *((void *)this + 25), *((void *)this + 26)))
  {
    int v9 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v9 >= *((void *)a4 + 3))
    {
      llvm::raw_ostream::write(a4, 9);
    }
    else
    {
      *((void *)a4 + 4) = v9 + 1;
      *int v9 = 9;
    }
    int v12 = (const void *)*((void *)this + 25);
    size_t v13 = *((void *)this + 26);
    uint64_t result = (llvm::raw_ostream *)*((void *)a4 + 4);
    if (v13 <= *((void *)a4 + 3) - (void)result)
    {
      if (v13)
      {
        memcpy(result, v12, v13);
        uint64_t result = (llvm::raw_ostream *)(*((void *)a4 + 4) + v13);
        *((void *)a4 + 4) = result;
      }
    }
    else
    {
      llvm::raw_ostream::write(a4, (const char *)v12, v13);
      uint64_t result = (llvm::raw_ostream *)*((void *)a4 + 4);
    }
    unint64_t v14 = *((void *)a4 + 3);
    if (a5)
    {
      if ((unint64_t)result >= v14)
      {
        llvm::raw_ostream::write(a4, 9);
      }
      else
      {
        *((void *)a4 + 4) = (char *)result + 1;
        *(unsigned char *)uint64_t result = 9;
      }
      llvm::MCExpr::print(a5, a4, a2, 0);
      unint64_t v14 = *((void *)a4 + 3);
      uint64_t result = (llvm::raw_ostream *)*((void *)a4 + 4);
    }
    if ((unint64_t)result < v14)
    {
      *((void *)a4 + 4) = (char *)result + 1;
      *(unsigned char *)uint64_t result = 10;
      return result;
    }
    goto LABEL_60;
  }
  sub_1CB8E509C(a4, "\t.section\t");
  sub_1CCBD1154(a4, *((unsigned __int8 **)this + 25), *((void *)this + 26));
  uint64_t result = sub_1CB8E509C(a4, ",\"");
  if (*((unsigned char *)this + 252))
  {
    size_t v11 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v11 >= *((void *)a4 + 3))
    {
      uint64_t result = llvm::raw_ostream::write(a4, 112);
    }
    else
    {
      *((void *)a4 + 4) = v11 + 1;
      *size_t v11 = 112;
    }
  }
  if (*((void *)this + 29))
  {
    int v15 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v15 >= *((void *)a4 + 3))
    {
      uint64_t result = llvm::raw_ostream::write(a4, 71);
    }
    else
    {
      *((void *)a4 + 4) = v15 + 1;
      unsigned char *v15 = 71;
    }
  }
  if (*((unsigned char *)this + 256))
  {
    uint64_t v17 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v17 >= *((void *)a4 + 3))
    {
      uint64_t result = llvm::raw_ostream::write(a4, 83);
    }
    else
    {
      *((void *)a4 + 4) = v17 + 1;
      *uint64_t v17 = 83;
    }
  }
  if ((*((unsigned char *)this + 256) & 2) != 0)
  {
    __int16 v18 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v18 >= *((void *)a4 + 3))
    {
      uint64_t result = llvm::raw_ostream::write(a4, 84);
    }
    else
    {
      *((void *)a4 + 4) = v18 + 1;
      *__int16 v18 = 84;
    }
  }
  uint64_t v16 = (unsigned char *)*((void *)a4 + 4);
  if ((unint64_t)v16 >= *((void *)a4 + 3))
  {
    uint64_t result = llvm::raw_ostream::write(a4, 34);
  }
  else
  {
    *((void *)a4 + 4) = v16 + 1;
    *uint64_t v16 = 34;
  }
  unint64_t v19 = (unsigned char *)*((void *)a4 + 4);
  if ((unint64_t)v19 >= *((void *)a4 + 3))
  {
    uint64_t result = llvm::raw_ostream::write(a4, 44);
  }
  else
  {
    *((void *)a4 + 4) = v19 + 1;
    *unint64_t v19 = 44;
  }
  unint64_t v21 = *((void *)a4 + 3);
  BOOL v20 = (char *)*((void *)a4 + 4);
  if (**((unsigned char **)a2 + 6) == 64)
  {
    if ((unint64_t)v20 < v21)
    {
      *((void *)a4 + 4) = v20 + 1;
      char v22 = 37;
LABEL_42:
      *BOOL v20 = v22;
      goto LABEL_48;
    }
    uint64_t v23 = a4;
    char v24 = 37;
  }
  else
  {
    if ((unint64_t)v20 < v21)
    {
      *((void *)a4 + 4) = v20 + 1;
      char v22 = 64;
      goto LABEL_42;
    }
    uint64_t v23 = a4;
    char v24 = 64;
  }
  uint64_t result = llvm::raw_ostream::write(v23, v24);
LABEL_48:
  if (*((void *)this + 29))
  {
    sub_1CB8E509C(a4, ",");
    uint64_t v25 = (unsigned char *)*((void *)this + 29);
    if ((*v25 & 4) != 0)
    {
      uint64_t v28 = (void *)*((void *)v25 - 1);
      int64_t v29 = *v28;
      uint64_t v26 = (unsigned __int8 *)(v28 + 2);
      int64_t v27 = v29;
    }
    else
    {
      uint64_t v26 = 0;
      int64_t v27 = 0;
    }
    sub_1CCBD1154(a4, v26, v27);
    uint64_t result = sub_1CB8E509C(a4, ",comdat");
  }
  if (*((_DWORD *)this + 56) != -1)
  {
    uint64_t v30 = sub_1CB8E509C(a4, ",unique,");
    uint64_t result = llvm::raw_ostream::operator<<(v30, *((unsigned int *)this + 56));
  }
  char v31 = (unsigned char *)*((void *)a4 + 4);
  if ((unint64_t)v31 >= *((void *)a4 + 3))
  {
    uint64_t result = llvm::raw_ostream::write(a4, 10);
  }
  else
  {
    *((void *)a4 + 4) = v31 + 1;
    *char v31 = 10;
  }
  if (a5)
  {
    sub_1CB8E509C(a4, "\t.subsection\t");
    uint64_t result = llvm::MCExpr::print(a5, a4, a2, 0);
    char v32 = (unsigned char *)*((void *)a4 + 4);
    if ((unint64_t)v32 < *((void *)a4 + 3))
    {
      *((void *)a4 + 4) = v32 + 1;
      *char v32 = 10;
      return result;
    }
LABEL_60:
    return llvm::raw_ostream::write(a4, 10);
  }
  return result;
}

uint64_t llvm::MCSectionWasm::useCodeAlign(llvm::MCSectionWasm *this)
{
  return 0;
}

uint64_t llvm::MCSectionWasm::isVirtualSection(llvm::MCSectionWasm *this)
{
  return 0;
}

llvm::raw_ostream *llvm::MCSectionXCOFF::printCsectDirective(llvm::MCSectionXCOFF *this, llvm::raw_ostream *a2)
{
  uint64_t v3 = sub_1CB8E509C(a2, "\t.csect ");
  uint64_t v4 = v3;
  uint64_t v5 = (unsigned char *)*((void *)this + 29);
  if ((*v5 & 4) != 0)
  {
    int v9 = (size_t *)*((void *)v5 - 1);
    size_t v12 = *v9;
    __int16 v10 = v9 + 2;
    size_t v11 = v12;
    size_t v13 = (void *)*((void *)v3 + 4);
    if (v12 <= *((void *)v4 + 3) - (void)v13)
    {
      if (v11)
      {
        memcpy(v13, v10, v11);
        *((void *)v4 + 4) += v11;
      }
    }
    else
    {
      llvm::raw_ostream::write(v4, (const char *)v10, v11);
    }
  }
  uint64_t v6 = sub_1CB8E509C(v4, ",");
  uint64_t result = llvm::raw_ostream::operator<<(v6, 31 - __clz(1 << *((unsigned char *)this + 24)));
  uint64_t v8 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v8 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v8 + 1;
    unsigned char *v8 = 10;
  }
  return result;
}

unsigned __int8 *llvm::MCSectionXCOFF::printSwitchToSection(unsigned __int8 *this, const llvm::MCAsmInfo *a2, const llvm::Triple *a3, llvm::raw_ostream *a4, const llvm::MCExpr *a5)
{
  uint64_t v5 = (unsigned __int8 *)a4;
  uint64_t v6 = this;
  int v7 = this[220];
  if ((v7 & 0xFE) == 2)
  {
    if (this[224])
    {
      char v22 = "Unhandled storage-mapping class for .text csect";
      goto LABEL_48;
    }
    goto LABEL_43;
  }
  if ((v7 & 0xFC) == 8 || (v7 & 0xFC) == 4)
  {
    int v20 = this[224];
    if (v20 != 1 && v20 != 16)
    {
      char v22 = "Unhandled storage-mapping class for .rodata csect.";
      goto LABEL_48;
    }
    goto LABEL_43;
  }
  if (v7 != 19)
  {
    if (v7 == 13)
    {
      if (this[224] != 20)
      {
        char v22 = "Unhandled storage-mapping class for .tdata csect.";
        goto LABEL_48;
      }
    }
    else
    {
      if (!this[226]) {
        goto LABEL_11;
      }
      if (this[224] != 16)
      {
        if (this[225] == 3) {
          return this;
        }
LABEL_11:
        if ((v7 & 0xFFFFFFFD) != 0xC)
        {
          if (!this[220] && this[260])
          {
            __int16 v10 = sub_1CB8E509C(a4, "\n\t.dwsect ");
            uint64_t v11 = *((unsigned int *)v6 + 64);
            v23[0] = &unk_1F262FBE8;
            v23[1] = "0x%x";
            v23[2] = v11;
            size_t v12 = llvm::raw_ostream::operator<<(v10, (uint64_t)v23);
            size_t v13 = (unsigned char *)*((void *)v12 + 4);
            if ((unint64_t)v13 >= *((void *)v12 + 3))
            {
              llvm::raw_ostream::write(v12, 10);
            }
            else
            {
              *((void *)v12 + 4) = v13 + 1;
              *size_t v13 = 10;
            }
            int v15 = (const void *)*((void *)a2 + 13);
            size_t v16 = *((void *)a2 + 14);
            this = (unsigned __int8 *)*((void *)v5 + 4);
            if (v16 <= *((void *)v5 + 3) - (void)this)
            {
              if (v16)
              {
                memcpy(this, v15, v16);
                this = (unsigned __int8 *)(*((void *)v5 + 4) + v16);
                *((void *)v5 + 4) = this;
              }
            }
            else
            {
              llvm::raw_ostream::write((llvm::raw_ostream *)v5, (const char *)v15, v16);
              this = (unsigned __int8 *)*((void *)v5 + 4);
            }
            uint64_t v17 = (const void *)*((void *)v6 + 25);
            size_t v18 = *((void *)v6 + 26);
            if (v18 <= *((void *)v5 + 3) - (void)this)
            {
              if (v18)
              {
                memcpy(this, v17, v18);
                this = (unsigned __int8 *)(*((void *)v5 + 4) + v18);
                *((void *)v5 + 4) = this;
              }
            }
            else
            {
              llvm::raw_ostream::write((llvm::raw_ostream *)v5, (const char *)v17, v18);
              this = (unsigned __int8 *)*((void *)v5 + 4);
            }
            if ((unint64_t)this >= *((void *)v5 + 3))
            {
              this = (unsigned __int8 *)llvm::raw_ostream::write((llvm::raw_ostream *)v5, 58);
              uint64_t v5 = this;
            }
            else
            {
              *((void *)v5 + 4) = this + 1;
              *this = 58;
            }
            unint64_t v19 = (unsigned char *)*((void *)v5 + 4);
            if ((unint64_t)v19 >= *((void *)v5 + 3)) {
              return (unsigned __int8 *)llvm::raw_ostream::write((llvm::raw_ostream *)v5, 10);
            }
            *((void *)v5 + 4) = v19 + 1;
            *unint64_t v19 = 10;
            return this;
          }
          char v22 = "Printing for this SectionKind is unimplemented.";
LABEL_48:
          llvm::report_fatal_error((llvm *)v22, (const llvm::Twine *)1);
        }
      }
    }
LABEL_43:
    return (unsigned __int8 *)llvm::MCSectionXCOFF::printCsectDirective((llvm::MCSectionXCOFF *)this, a4);
  }
  unsigned int v14 = this[224];
  if (v14 > 0x16)
  {
LABEL_52:
    char v22 = "Unhandled storage-mapping class for .data csect.";
    goto LABEL_48;
  }
  if (((1 << v14) & 0x400008) != 0) {
    return this;
  }
  if (v14 != 15)
  {
    if (((1 << v14) & 0x10420) != 0) {
      goto LABEL_43;
    }
    goto LABEL_52;
  }

  return (unsigned __int8 *)sub_1CB8E509C(a4, "\t.toc\n");
}

BOOL llvm::MCSectionXCOFF::useCodeAlign(llvm::MCSectionXCOFF *this)
{
  return (*((_DWORD *)this + 55) & 0xFE) == 2;
}

BOOL llvm::MCSectionXCOFF::isVirtualSection(llvm::MCSectionXCOFF *this)
{
  return !*((unsigned char *)this + 260) && *((unsigned char *)this + 225) == 3;
}

uint64_t sub_1CD6B8934(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(unsigned int *)(a1 + 16));
}

void *llvm::MCTargetStreamer::MCTargetStreamer(void *this, llvm::MCStreamer *a2)
{
  *this = &unk_1F262FC08;
  this[1] = a2;
  uint64_t v2 = *((void *)a2 + 2);
  *((void *)a2 + 2) = this;
  if (v2)
  {
    uint64_t v3 = this;
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    return v3;
  }
  return this;
}

void llvm::MCTargetStreamer::~MCTargetStreamer(llvm::MCTargetStreamer *this)
{
}

uint64_t llvm::MCTargetStreamer::changeSection(llvm::MCTargetStreamer *this, const llvm::MCSection *a2, llvm::MCSection *a3, const llvm::MCExpr *a4, llvm::raw_ostream *a5)
{
  return (**(uint64_t (***)(llvm::MCSection *, void, uint64_t, llvm::raw_ostream *, const llvm::MCExpr *))a3)(a3, *(void *)(*(void *)(*((void *)this + 1) + 8) + 152), *(void *)(*((void *)this + 1) + 8) + 24, a5, a4);
}

void llvm::MCTargetStreamer::emitDwarfFileDirective(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(llvm::MCStreamer **)(a1 + 8);
  __int16 v5 = 261;
  v4[0] = a2;
  v4[1] = a3;
  llvm::MCStreamer::emitRawText(v3, (const llvm::Twine *)v4);
}

void llvm::MCStreamer::emitRawText(llvm::MCStreamer *this, const llvm::Twine *a2)
{
  v7[16] = *MEMORY[0x1E4F143B8];
  __int16 v5 = v7;
  long long v6 = xmmword_1CFAC3020;
  uint64_t v3 = sub_1CC229614((void **)a2, (uint64_t)&v5);
  (*(void (**)(llvm::MCStreamer *, const char *, uint64_t))(*(void *)this + 32))(this, v3, v4);
  if (v5 != v7) {
    free(v5);
  }
}

void llvm::MCTargetStreamer::emitValue(llvm::MCTargetStreamer *this, const llvm::MCExpr *a2)
{
  v19[16] = *MEMORY[0x1E4F143B8];
  size_t v16 = &v17;
  uint64_t v17 = v19;
  long long v18 = xmmword_1CFAC3020;
  int v9 = 0;
  char v13 = 0;
  uint64_t v14 = 0;
  int v15 = 0;
  uint64_t v8 = &unk_1F2646FA8;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  llvm::MCExpr::print(a2, (llvm::raw_ostream *)&v8, *(const llvm::MCAsmInfo **)(*(void *)(*((void *)this + 1) + 8) + 152), 0);
  uint64_t v3 = (llvm::MCStreamer *)*((void *)this + 1);
  __int16 v5 = *v16;
  uint64_t v4 = v16[1];
  __int16 v7 = 261;
  v6[0] = v5;
  v6[1] = v4;
  llvm::MCStreamer::emitRawText(v3, (const llvm::Twine *)v6);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v8);
  if (v17 != v19) {
    free(v17);
  }
}

void llvm::MCTargetStreamer::emitRawBytes(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  v25[16] = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    uint64_t v3 = a3;
    long long v6 = *(char **)(*(void *)(*(void *)(*(void *)(a1 + 8) + 8) + 152) + 248);
    do
    {
      unint64_t v7 = *a2;
      char v22 = &v23;
      uint64_t v23 = v25;
      long long v24 = xmmword_1CFAC3020;
      int v15 = 0;
      char v19 = 0;
      uint64_t v20 = 0;
      uint64_t v14 = &unk_1F2646FA8;
      int v21 = 0;
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v16 = 0;
      uint64_t v8 = sub_1CB8E509C((llvm::raw_ostream *)&v14, v6);
      sub_1CD098D14(v8, v7, 0, 0, 0);
      int v9 = *(llvm::MCStreamer **)(a1 + 8);
      uint64_t v11 = *v22;
      uint64_t v10 = v22[1];
      __int16 v13 = 261;
      v12[0] = v11;
      v12[1] = v10;
      llvm::MCStreamer::emitRawText(v9, (const llvm::Twine *)v12);
      llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v14);
      if (v23 != v25) {
        free(v23);
      }
      ++a2;
      --v3;
    }
    while (v3);
  }
}

llvm::MCStreamer *llvm::MCStreamer::MCStreamer(llvm::MCStreamer *this, llvm::MCContext *a2)
{
  *(void *)this = &unk_1F262FC70;
  *((void *)this + 1) = a2;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 92) = 0u;
  *((void *)this + 14) = (char *)this + 128;
  uint64_t v3 = (void *)((char *)this + 112);
  *((void *)this + 15) = 0x400000000;
  *((void *)this + 32) = 0;
  *(void *)((char *)this + 262) = 0;
  memset(v8, 0, sizeof(v8));
  uint64_t v4 = (_OWORD *)sub_1CBA9C894((uint64_t)this + 112, (unint64_t)v8, 1);
  __int16 v5 = (_OWORD *)(*v3 + 32 * *((unsigned int *)this + 30));
  long long v6 = v4[1];
  *__int16 v5 = *v4;
  v5[1] = v6;
  ++*((_DWORD *)this + 30);
  return this;
}

void llvm::MCStreamer::~MCStreamer(llvm::MCStreamer *this)
{
  *(void *)this = &unk_1F262FC70;
  uint64_t v2 = (char *)*((void *)this + 14);
  if (v2 != (char *)this + 128) {
    free(v2);
  }
  llvm::deallocate_buffer(*((llvm **)this + 11), (void *)(16 * *((unsigned int *)this + 26)));
}

uint64_t llvm::MCStreamer::generateCompactUnwindEncodings(uint64_t this, llvm::MCAsmBackend *a2)
{
  uint64_t v2 = *(void *)(this + 24);
  for (uint64_t i = *(void *)(this + 32); v2 != i; v2 += 88)
  {
    if (a2) {
      this = (*(uint64_t (**)(llvm::MCAsmBackend *))(*(void *)a2 + 216))(a2);
    }
    else {
      this = 0;
    }
    *(_DWORD *)(v2 + 68) = this;
  }
  return this;
}

void llvm::MCStreamer::emitIntValue(void *a1, unsigned int *a2)
{
  uint64_t v2 = a2;
  void v12[2] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a2[2];
  if (((v4 + 63) & 0x1FFFFFFC0) == 0x40)
  {
    if (v4 >= 0x41)
    {
      if (v4 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)a2) > 0x40)
      {
        uint64_t v5 = -1;
        goto LABEL_4;
      }
      uint64_t v2 = *(unsigned int **)v2;
    }
    uint64_t v5 = *(void *)v2;
LABEL_4:
    long long v6 = *(void (**)(void *, uint64_t, void))(*a1 + 520);
    v6(a1, v5, v4 >> 3);
    return;
  }
  if (*(unsigned char *)(*(void *)(a1[1] + 152) + 16))
  {
    unsigned int v9 = a2[2];
    if (v4 > 0x40) {
      llvm::APInt::initSlowCase((llvm::APInt *)&v8, (const llvm::APInt *)a2);
    }
    uint64_t v8 = *(llvm **)a2;
  }
  else
  {
    llvm::APInt::byteSwap((llvm::APInt *)a2, (uint64_t)&v8);
  }
  unint64_t v7 = (unint64_t)v2[2] >> 3;
  __dst = (llvm::APInt *)v12;
  long long v11 = xmmword_1CFAC67E0;
  sub_1CC22C7F8(&__dst, v7);
  llvm::StoreIntToMemory(&v8, __dst, v7);
  (*(void (**)(void *, llvm::APInt *, void))(*a1 + 488))(a1, __dst, v11);
  if (__dst != (llvm::APInt *)v12) {
    free(__dst);
  }
  if (v9 >= 0x41 && v8) {
    MEMORY[0x1D25D9CB0](v8, 0x1000C8000313F17);
  }
}

void llvm::MCStreamer::emitDTPRel64Value(llvm::MCStreamer *this, const llvm::MCExpr *a2)
{
}

void llvm::MCStreamer::emitDTPRel32Value(llvm::MCStreamer *this, const llvm::MCExpr *a2)
{
}

void llvm::MCStreamer::emitTPRel64Value(llvm::MCStreamer *this, const llvm::MCExpr *a2)
{
}

void llvm::MCStreamer::emitTPRel32Value(llvm::MCStreamer *this, const llvm::MCExpr *a2)
{
}

void llvm::MCStreamer::emitGPRel64Value(llvm::MCStreamer *this, const llvm::MCExpr *a2)
{
}

void llvm::MCStreamer::emitGPRel32Value(llvm::MCStreamer *this, const llvm::MCExpr *a2)
{
}

uint64_t llvm::MCStreamer::emitFill(llvm::MCStreamer *this, llvm::MCConstantExpr *a2, unsigned int a3)
{
  unint64_t v5 = llvm::MCConstantExpr::create(a2, *((void *)this + 1), 0, 0);
  long long v6 = *(uint64_t (**)(llvm::MCStreamer *, unint64_t, void, void))(*(void *)this + 616);

  return v6(this, v5, a3, 0);
}

uint64_t llvm::MCStreamer::emitCFIBKeyFrame(llvm::MCStreamer *this)
{
  uint64_t result = llvm::MCStreamer::getCurrentDwarfFrameInfo(this);
  if (result) {
    *(unsigned char *)(result + 80) = 1;
  }
  return result;
}

BOOL llvm::MCStreamer::EmitCVFileDirective(uint64_t a1, unsigned int a2, unsigned __int8 *a3, size_t a4, uint64_t a5, uint64_t a6, char a7)
{
  CVuint64_t Context = llvm::MCContext::getCVContext(*(llvm::MCContext **)(a1 + 8));

  return llvm::CodeViewContext::addFile(CVContext, a1, a2, a3, a4, a5, a6, a7);
}

BOOL llvm::MCStreamer::EmitCVFuncIdDirective(llvm::MCContext **this, unsigned int a2)
{
  CVuint64_t Context = (llvm::CodeViewContext *)llvm::MCContext::getCVContext(this[1]);

  return llvm::CodeViewContext::recordFunctionId(CVContext, a2);
}

BOOL llvm::MCStreamer::EmitCVInlineSiteIdDirective(uint64_t a1, unsigned int a2, unsigned int a3, int a4, int a5, int a6, uint64_t a7)
{
  CVuint64_t Context = (llvm::CodeViewContext *)llvm::MCContext::getCVContext(*(llvm::MCContext **)(a1 + 8));
  CVFunctionInfo = llvm::CodeViewContext::getCVFunctionInfo(CVContext, a3);
  uint64_t v16 = *(llvm::MCContext **)(a1 + 8);
  if (CVFunctionInfo)
  {
    uint64_t v17 = (llvm::CodeViewContext *)llvm::MCContext::getCVContext(v16);
    return llvm::CodeViewContext::recordInlinedCallSiteId(v17, a2, a3, a4, a5, a6);
  }
  else
  {
    char v19 = "parent function id not introduced by .cv_func_id or .cv_inline_site_id";
    __int16 v20 = 259;
    llvm::MCContext::reportError((uint64_t)v16, a7, (uint64_t)&v19);
    return 1;
  }
}

uint64_t llvm::MCStreamer::checkCVLocSection(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  CVuint64_t Context = (llvm::CodeViewContext *)llvm::MCContext::getCVContext(*(llvm::MCContext **)(a1 + 8));
  CVFunctionInfo = llvm::CodeViewContext::getCVFunctionInfo(CVContext, a2);
  if (!CVFunctionInfo)
  {
    uint64_t v11 = *(void *)(a1 + 8);
    uint64_t v12 = "function id not introduced by .cv_func_id or .cv_inline_site_id";
    goto LABEL_7;
  }
  uint64_t v9 = *((void *)CVFunctionInfo + 2);
  uint64_t v10 = *(unsigned int *)(a1 + 120);
  if (!v9)
  {
    if (v10) {
      uint64_t v14 = *(void *)(*(void *)(a1 + 112) + 32 * v10 - 32);
    }
    else {
      uint64_t v14 = 0;
    }
    *((void *)CVFunctionInfo + 2) = v14;
    return 1;
  }
  if (v10 && v9 == *(void *)(*(void *)(a1 + 112) + 32 * v10 - 32)) {
    return 1;
  }
  uint64_t v11 = *(void *)(a1 + 8);
  uint64_t v12 = "all .cv_loc directives for a function must be in the same section";
LABEL_7:
  int v15 = v12;
  __int16 v16 = 259;
  llvm::MCContext::reportError(v11, a4, (uint64_t)&v15);
  return 0;
}

void llvm::MCStreamer::emitCVDefRangeDirective(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v10[3] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = v10;
  long long v9 = xmmword_1CFB28E20;
  sub_1CC22C7F8(&v8, 0xAuLL);
  *(_WORD *)uint64_t v8 = 4421;
  *(void *)((char *)v8 + 2) = a4;
  (*(void (**)(uint64_t, uint64_t, uint64_t, void *, void))(*(void *)a1 + 768))(a1, a2, a3, v8, v9);
  if (v8 != v10) {
    free(v8);
  }
}

{
  void *v8;
  long long v9;
  void v10[4];

  v10[3] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = v10;
  long long v9 = xmmword_1CFB28E20;
  sub_1CC22C7F8(&v8, 0xAuLL);
  *(_WORD *)uint64_t v8 = 4419;
  *(void *)((char *)v8 + 2) = a4;
  (*(void (**)(uint64_t, uint64_t, uint64_t, void *, void))(*(void *)a1 + 768))(a1, a2, a3, v8, v9);
  if (v8 != v10) {
    free(v8);
  }
}

void llvm::MCStreamer::emitCVDefRangeDirective(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  v10[3] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = v10;
  long long v9 = xmmword_1CFB28E20;
  sub_1CC22C7F8(&v8, 6uLL);
  *(_WORD *)uint64_t v8 = 4417;
  *(_DWORD *)((char *)v8 + 2) = a4;
  (*(void (**)(uint64_t, uint64_t, uint64_t, void *, void))(*(void *)a1 + 768))(a1, a2, a3, v8, v9);
  if (v8 != v10) {
    free(v8);
  }
}

{
  void *v8;
  long long v9;
  void v10[4];

  v10[3] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = v10;
  long long v9 = xmmword_1CFB28E20;
  sub_1CC22C7F8(&v8, 6uLL);
  *(_WORD *)uint64_t v8 = 4418;
  *(_DWORD *)((char *)v8 + 2) = a4;
  (*(void (**)(uint64_t, uint64_t, uint64_t, void *, void))(*(void *)a1 + 768))(a1, a2, a3, v8, v9);
  if (v8 != v10) {
    free(v8);
  }
}

void *llvm::MCStreamer::AssignFragment(llvm::MCStreamer *this, llvm::MCSymbol *a2, unint64_t a3)
{
  unint64_t v5 = a2;
  *(void *)a2 = *(void *)a2 & 7 | a3;
  int v3 = *((_DWORD *)this + 24) + 1;
  uint64_t result = sub_1CD6A1F98((uint64_t *)this + 11, &v5);
  *((_DWORD *)result + 2) = v3;
  return result;
}

void llvm::MCStreamer::emitCFIEndProcImpl(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 8) = 1;
}

uint64_t llvm::MCStreamer::emitCFILabel(llvm::MCStreamer *this)
{
  return 1;
}

void llvm::MCStreamer::emitCFIDefCfa(llvm::MCStreamer *this, int a2, int a3)
{
  uint64_t v6 = (*(uint64_t (**)(llvm::MCStreamer *))(*(void *)this + 80))(this);
  LODWORD(v11) = 7;
  *((void *)&v11 + 1) = v6;
  int v12 = a2;
  int v13 = a3;
  char v18 = 0;
  int v15 = 0;
  uint64_t v16 = 0;
  uint64_t v14 = 0;
  LOBYTE(__p) = 0;
  uint64_t CurrentDwarfFrameInfo = llvm::MCStreamer::getCurrentDwarfFrameInfo(this);
  if (CurrentDwarfFrameInfo)
  {
    uint64_t v8 = CurrentDwarfFrameInfo;
    unint64_t v9 = *(void *)(CurrentDwarfFrameInfo + 40);
    if (v9 < *(void *)(v8 + 48)) {
      uint64_t v10 = sub_1CC34C598(v9, &v11) + 80;
    }
    else {
      uint64_t v10 = sub_1CC34C40C((uint64_t *)(v8 + 32), (uint64_t)&v11);
    }
    *(void *)(v8 + 40) = v10;
    *(_DWORD *)(v8 + 56) = a2;
    if (v18 < 0) {
      operator delete(__p);
    }
    if (v14)
    {
      int v15 = v14;
      operator delete(v14);
    }
  }
}

void llvm::MCStreamer::emitCFIDefCfaRegister(llvm::MCStreamer *this, int a2)
{
  uint64_t v4 = (*(uint64_t (**)(llvm::MCStreamer *))(*(void *)this + 80))(this);
  LODWORD(v9) = 5;
  *((void *)&v9 + 1) = v4;
  int v10 = a2;
  int v11 = 0;
  char v16 = 0;
  int v13 = 0;
  uint64_t v14 = 0;
  int v12 = 0;
  LOBYTE(__p) = 0;
  uint64_t CurrentDwarfFrameInfo = llvm::MCStreamer::getCurrentDwarfFrameInfo(this);
  if (CurrentDwarfFrameInfo)
  {
    uint64_t v6 = CurrentDwarfFrameInfo;
    unint64_t v7 = *(void *)(CurrentDwarfFrameInfo + 40);
    if (v7 >= *(void *)(v6 + 48)) {
      uint64_t v8 = sub_1CC34C40C((uint64_t *)(v6 + 32), (uint64_t)&v9);
    }
    else {
      uint64_t v8 = sub_1CC34C598(v7, &v9) + 80;
    }
    *(void *)(v6 + 40) = v8;
    *(_DWORD *)(v6 + 56) = a2;
    if (v16 < 0) {
      operator delete(__p);
    }
    if (v12)
    {
      int v13 = v12;
      operator delete(v12);
    }
  }
}

void llvm::MCStreamer::emitCFILLVMDefAspaceCfa(llvm::MCStreamer *this, int a2, int a3, int a4)
{
  uint64_t v8 = (*(uint64_t (**)(llvm::MCStreamer *))(*(void *)this + 80))(this);
  LODWORD(v13) = 4;
  *((void *)&v13 + 1) = v8;
  int v14 = a2;
  int v15 = a3;
  int v16 = a4;
  *(_OWORD *)uint64_t v17 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v19 = 0u;
  uint64_t CurrentDwarfFrameInfo = llvm::MCStreamer::getCurrentDwarfFrameInfo(this);
  if (CurrentDwarfFrameInfo)
  {
    uint64_t v10 = CurrentDwarfFrameInfo;
    unint64_t v11 = *(void *)(CurrentDwarfFrameInfo + 40);
    if (v11 >= *(void *)(v10 + 48)) {
      uint64_t v12 = sub_1CC34C40C((uint64_t *)(v10 + 32), (uint64_t)&v13);
    }
    else {
      uint64_t v12 = sub_1CC34C598(v11, &v13) + 80;
    }
    *(void *)(v10 + 40) = v12;
    *(_DWORD *)(v10 + 56) = a2;
    if (SHIBYTE(v19) < 0) {
      operator delete(__p[1]);
    }
    if (v17[0])
    {
      v17[1] = v17[0];
      operator delete(v17[0]);
    }
  }
}

uint64_t llvm::MCStreamer::emitCFIPersonality(llvm::MCStreamer *this, const llvm::MCSymbol *a2, int a3)
{
  uint64_t result = llvm::MCStreamer::getCurrentDwarfFrameInfo(this);
  if (result)
  {
    *(void *)(result + 16) = a2;
    *(_DWORD *)(result + 60) = a3;
  }
  return result;
}

uint64_t llvm::MCStreamer::emitCFILsda(llvm::MCStreamer *this, const llvm::MCSymbol *a2, int a3)
{
  uint64_t result = llvm::MCStreamer::getCurrentDwarfFrameInfo(this);
  if (result)
  {
    *(void *)(result + 24) = a2;
    *(_DWORD *)(result + 64) = a3;
  }
  return result;
}

uint64_t llvm::MCStreamer::emitCFISignalFrame(llvm::MCStreamer *this)
{
  uint64_t result = llvm::MCStreamer::getCurrentDwarfFrameInfo(this);
  if (result) {
    *(unsigned char *)(result + 72) = 1;
  }
  return result;
}

uint64_t llvm::MCStreamer::emitCFIReturnColumn(llvm::MCStreamer *this, int a2)
{
  uint64_t result = llvm::MCStreamer::getCurrentDwarfFrameInfo(this);
  if (result) {
    *(_DWORD *)(result + 76) = a2;
  }
  return result;
}

uint64_t llvm::MCStreamer::EnsureValidWinFrameInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(v3 + 152);
  if (*(_DWORD *)(v4 + 412) != 4 || ((int v5 = *(_DWORD *)(v4 + 420), v5 != 6) ? (v6 = v5 == 0) : (v6 = 1), v6))
  {
    unint64_t v7 = ".seh_* directives are not supported on this target";
LABEL_8:
    uint64_t v10 = v7;
    __int16 v11 = 259;
    llvm::MCContext::reportError(v3, a2, (uint64_t)&v10);
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 72);
  if (!v8 || *(void *)(v8 + 8))
  {
    unint64_t v7 = ".seh_ directive must appear within an active frame";
    goto LABEL_8;
  }
  return v8;
}

uint64_t llvm::MCStreamer::EmitWinCFIStartProc(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1[1];
  uint64_t v5 = *(void *)(v4 + 152);
  if (*(_DWORD *)(v5 + 412) == 4)
  {
    int v6 = *(_DWORD *)(v5 + 420);
    if (v6 != 6 && v6 != 0)
    {
      uint64_t v9 = a1[9];
      if (v9)
      {
        if (!*(void *)(v9 + 8))
        {
          v10[0] = "Starting a function before ending the previous one!";
          __int16 v11 = 259;
          llvm::MCContext::reportError(v4, a3, (uint64_t)v10);
        }
      }
      (*(void (**)(void *))(*a1 + 80))(a1);
      a1[10] = (uint64_t)(a1[7] - a1[6]) >> 3;
      operator new();
    }
  }
  v10[0] = ".seh_* directives are not supported on this target";
  __int16 v11 = 259;
  return llvm::MCContext::reportError(v4, a3, (uint64_t)v10);
}

uint64_t llvm::MCStreamer::EmitWinCFIEndProc(void *a1, uint64_t a2)
{
  uint64_t result = llvm::MCStreamer::EnsureValidWinFrameInfo((uint64_t)a1, a2);
  if (result)
  {
    uint64_t v5 = (void *)result;
    if (*(void *)(result + 80))
    {
      uint64_t v6 = a1[1];
      __int16 v11 = "Not all chained regions terminated!";
      __int16 v12 = 259;
      llvm::MCContext::reportError(v6, a2, (uint64_t)&v11);
    }
    uint64_t v7 = (*(uint64_t (**)(void *))(*a1 + 80))(a1);
    v5[1] = v7;
    if (!v5[2]) {
      void v5[2] = v7;
    }
    uint64_t v8 = a1[10];
    uint64_t v9 = a1[7] - a1[6];
    if (v8 != v9 >> 3)
    {
      uint64_t v10 = v9 >> 3;
      do
        (*(void (**)(void *, void))(*a1 + 16))(a1, *(void *)(a1[6] + 8 * v8++));
      while (v10 != v8);
    }
    return (*(uint64_t (**)(void *, void, void))(*a1 + 168))(a1, v5[7], 0);
  }
  return result;
}

uint64_t llvm::MCStreamer::EmitWinCFIFuncletOrFuncEnd(void *a1, uint64_t a2)
{
  uint64_t result = llvm::MCStreamer::EnsureValidWinFrameInfo((uint64_t)a1, a2);
  if (result)
  {
    uint64_t v5 = result;
    if (*(void *)(result + 80))
    {
      uint64_t v6 = a1[1];
      uint64_t v7 = "Not all chained regions terminated!";
      __int16 v8 = 259;
      llvm::MCContext::reportError(v6, a2, (uint64_t)&v7);
    }
    uint64_t result = (*(uint64_t (**)(void *))(*a1 + 80))(a1);
    *(void *)(v5 + 16) = result;
  }
  return result;
}

uint64_t llvm::MCStreamer::EmitWinCFIStartChained(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::MCStreamer::EnsureValidWinFrameInfo(a1, a2);
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 80))(a1);
    operator new();
  }
  return result;
}

uint64_t llvm::MCStreamer::EmitWinCFIEndChained(void *a1, uint64_t a2)
{
  uint64_t result = llvm::MCStreamer::EnsureValidWinFrameInfo((uint64_t)a1, a2);
  if (result)
  {
    uint64_t v5 = result;
    if (*(void *)(result + 80))
    {
      uint64_t result = (*(uint64_t (**)(void *))(*a1 + 80))(a1);
      *(void *)(v5 + 8) = result;
      a1[9] = *(void *)(v5 + 80);
    }
    else
    {
      uint64_t v6 = a1[1];
      uint64_t v7 = "End of a chained region outside a chained region!";
      __int16 v8 = 259;
      return llvm::MCContext::reportError(v6, a2, (uint64_t)&v7);
    }
  }
  return result;
}

uint64_t llvm::MCStreamer::EmitWinEHHandler(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5)
{
  uint64_t result = llvm::MCStreamer::EnsureValidWinFrameInfo(a1, a5);
  if (result)
  {
    uint64_t v11 = result;
    if (*(void *)(result + 80))
    {
      uint64_t v12 = *(void *)(a1 + 8);
      v14[0] = "Chained unwind areas can't have handlers!";
      __int16 v15 = 259;
      return llvm::MCContext::reportError(v12, a5, (uint64_t)v14);
    }
    else
    {
      *(void *)(result + 24) = a2;
      if ((a3 & 1) == 0 && (a4 & 1) == 0)
      {
        uint64_t v13 = *(void *)(a1 + 8);
        v14[0] = "Don't know what kind of handler this is!";
        __int16 v15 = 259;
        uint64_t result = llvm::MCContext::reportError(v13, a5, (uint64_t)v14);
      }
      if (a3) {
        *(unsigned char *)(v11 + 68) = 1;
      }
      if (a4) {
        *(unsigned char *)(v11 + 69) = 1;
      }
    }
  }
  return result;
}

uint64_t llvm::MCStreamer::EmitWinEHHandlerData(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::MCStreamer::EnsureValidWinFrameInfo(a1, a2);
  if (result)
  {
    if (*(void *)(result + 80))
    {
      uint64_t v5 = *(void *)(a1 + 8);
      uint64_t v6 = "Chained unwind areas can't have handlers!";
      __int16 v7 = 259;
      return llvm::MCContext::reportError(v5, a2, (uint64_t)&v6);
    }
  }
  return result;
}

llvm::MCSectionCOFF *llvm::MCStreamer::getAssociatedXDataSection(llvm::MCContext **this, const llvm::MCSection *a2)
{
  return sub_1CCBD37A0(this[1], (_DWORD *)this + 66, *(llvm::MCSectionCOFF **)(*((void *)this[1] + 21) + 680), (uint64_t)a2);
}

uint64_t llvm::MCStreamer::EmitWinCFIPushReg(void *a1, int a2, uint64_t a3)
{
  uint64_t result = llvm::MCStreamer::EnsureValidWinFrameInfo((uint64_t)a1, a3);
  if (result)
  {
    uint64_t v6 = result;
    uint64_t v7 = (*(uint64_t (**)(void *))(*a1 + 80))(a1);
    int SEHRegNum = llvm::MCRegisterInfo::getSEHRegNum(*(void *)(a1[1] + 160), a2);
    *(void *)&long long v11 = v7;
    DWORD2(v11) = -1;
    HIDWORD(v11) = SEHRegNum;
    LODWORD(v12) = 0;
    unint64_t v9 = *(void *)(v6 + 96);
    if (v9 >= *(void *)(v6 + 104))
    {
      uint64_t result = (uint64_t)sub_1CC9AEA78((void **)(v6 + 88), (uint64_t)&v11);
    }
    else
    {
      long long v10 = v11;
      *(void *)(v9 + 16) = v12;
      *(_OWORD *)unint64_t v9 = v10;
      uint64_t result = v9 + 24;
    }
    *(void *)(v6 + 96) = result;
  }
  return result;
}

uint64_t llvm::MCStreamer::EmitWinCFISetFrame(void *a1, int a2, unsigned int a3, uint64_t a4)
{
  uint64_t result = llvm::MCStreamer::EnsureValidWinFrameInfo((uint64_t)a1, a4);
  if (result)
  {
    uint64_t v9 = result;
    if ((*(_DWORD *)(result + 72) & 0x80000000) == 0)
    {
      uint64_t v10 = a1[1];
      long long v11 = "frame register and offset can be set at most once";
LABEL_4:
      *(void *)&long long v17 = v11;
      __int16 v19 = 259;
      return llvm::MCContext::reportError(v10, a4, (uint64_t)&v17);
    }
    if ((a3 & 0xF) != 0)
    {
      uint64_t v10 = a1[1];
      long long v11 = "offset is not a multiple of 16";
      goto LABEL_4;
    }
    if (a3 >= 0xF1)
    {
      uint64_t v10 = a1[1];
      long long v11 = "frame offset must be less than or equal to 240";
      goto LABEL_4;
    }
    uint64_t v12 = (*(uint64_t (**)(void *))(*a1 + 80))(a1);
    unsigned int SEHRegNum = llvm::MCRegisterInfo::getSEHRegNum(*(void *)(a1[1] + 160), a2);
    *(void *)&long long v17 = v12;
    *((void *)&v17 + 1) = __PAIR64__(SEHRegNum, a3);
    LODWORD(v18) = 3;
    unint64_t v14 = *(void *)(v9 + 96);
    unint64_t v15 = *(void *)(v9 + 104);
    *(_DWORD *)(v9 + 72) = -1431655765 * ((v14 - *(void *)(v9 + 88)) >> 3);
    if (v14 >= v15)
    {
      uint64_t result = (uint64_t)sub_1CC9AEA78((void **)(v9 + 88), (uint64_t)&v17);
    }
    else
    {
      long long v16 = v17;
      *(void *)(v14 + 16) = v18;
      *(_OWORD *)unint64_t v14 = v16;
      uint64_t result = v14 + 24;
    }
    *(void *)(v9 + 96) = result;
  }
  return result;
}

uint64_t llvm::MCStreamer::EmitWinCFIAllocStack(void *a1, unsigned int a2, uint64_t a3)
{
  uint64_t result = llvm::MCStreamer::EnsureValidWinFrameInfo((uint64_t)a1, a3);
  if (result)
  {
    if (!a2)
    {
      uint64_t v7 = a1[1];
      __int16 v8 = "stack allocation size must be non-zero";
      goto LABEL_6;
    }
    if ((a2 & 7) != 0)
    {
      uint64_t v7 = a1[1];
      __int16 v8 = "stack allocation size is not a multiple of 8";
LABEL_6:
      *(void *)&long long v14 = v8;
      __int16 v16 = 259;
      return llvm::MCContext::reportError(v7, a3, (uint64_t)&v14);
    }
    uint64_t v9 = result;
    uint64_t v10 = (*(uint64_t (**)(void *))(*a1 + 80))(a1);
    if (a2 > 0x80) {
      int v11 = 1;
    }
    else {
      int v11 = 2;
    }
    *(void *)&long long v14 = v10;
    *((void *)&v14 + 1) = a2 | 0xFFFFFFFF00000000;
    LODWORD(v15) = v11;
    unint64_t v12 = *(void *)(v9 + 96);
    if (v12 >= *(void *)(v9 + 104))
    {
      uint64_t result = (uint64_t)sub_1CC9AEA78((void **)(v9 + 88), (uint64_t)&v14);
    }
    else
    {
      long long v13 = v14;
      *(void *)(v12 + 16) = v15;
      *(_OWORD *)unint64_t v12 = v13;
      uint64_t result = v12 + 24;
    }
    *(void *)(v9 + 96) = result;
  }
  return result;
}

uint64_t llvm::MCStreamer::EmitWinCFISaveReg(void *a1, int a2, unsigned int a3, uint64_t a4)
{
  uint64_t result = llvm::MCStreamer::EnsureValidWinFrameInfo((uint64_t)a1, a4);
  if (result)
  {
    if ((a3 & 7) != 0)
    {
      uint64_t v9 = a1[1];
      *(void *)&long long v16 = "register save offset is not 8 byte aligned";
      __int16 v18 = 259;
      return llvm::MCContext::reportError(v9, a4, (uint64_t)&v16);
    }
    else
    {
      uint64_t v10 = result;
      uint64_t v11 = (*(uint64_t (**)(void *))(*a1 + 80))(a1);
      unsigned int SEHRegNum = llvm::MCRegisterInfo::getSEHRegNum(*(void *)(a1[1] + 160), a2);
      if (a3 <= 0x7FFF8) {
        int v13 = 4;
      }
      else {
        int v13 = 5;
      }
      *(void *)&long long v16 = v11;
      *((void *)&v16 + 1) = __PAIR64__(SEHRegNum, a3);
      LODWORD(v17) = v13;
      unint64_t v14 = *(void *)(v10 + 96);
      if (v14 >= *(void *)(v10 + 104))
      {
        uint64_t result = (uint64_t)sub_1CC9AEA78((void **)(v10 + 88), (uint64_t)&v16);
      }
      else
      {
        long long v15 = v16;
        *(void *)(v14 + 16) = v17;
        *(_OWORD *)unint64_t v14 = v15;
        uint64_t result = v14 + 24;
      }
      *(void *)(v10 + 96) = result;
    }
  }
  return result;
}

uint64_t llvm::MCStreamer::EmitWinCFISaveXMM(void *a1, int a2, unsigned int a3, uint64_t a4)
{
  uint64_t result = llvm::MCStreamer::EnsureValidWinFrameInfo((uint64_t)a1, a4);
  if (result)
  {
    if ((a3 & 0xF) != 0)
    {
      uint64_t v9 = a1[1];
      *(void *)&long long v16 = "offset is not a multiple of 16";
      __int16 v18 = 259;
      return llvm::MCContext::reportError(v9, a4, (uint64_t)&v16);
    }
    else
    {
      uint64_t v10 = result;
      uint64_t v11 = (*(uint64_t (**)(void *))(*a1 + 80))(a1);
      unsigned int SEHRegNum = llvm::MCRegisterInfo::getSEHRegNum(*(void *)(a1[1] + 160), a2);
      if (a3 <= 0x7FFF8) {
        int v13 = 8;
      }
      else {
        int v13 = 9;
      }
      *(void *)&long long v16 = v11;
      *((void *)&v16 + 1) = __PAIR64__(SEHRegNum, a3);
      LODWORD(v17) = v13;
      unint64_t v14 = *(void *)(v10 + 96);
      if (v14 >= *(void *)(v10 + 104))
      {
        uint64_t result = (uint64_t)sub_1CC9AEA78((void **)(v10 + 88), (uint64_t)&v16);
      }
      else
      {
        long long v15 = v16;
        *(void *)(v14 + 16) = v17;
        *(_OWORD *)unint64_t v14 = v15;
        uint64_t result = v14 + 24;
      }
      *(void *)(v10 + 96) = result;
    }
  }
  return result;
}

uint64_t llvm::MCStreamer::EmitWinCFIPushFrame(void *a1, int a2, uint64_t a3)
{
  uint64_t result = llvm::MCStreamer::EnsureValidWinFrameInfo((uint64_t)a1, a3);
  if (result)
  {
    uint64_t v7 = result;
    __int16 v8 = (void **)(result + 88);
    if (*(void *)(result + 88) == *(void *)(result + 96))
    {
      *(void *)unint64_t v12 = (*(uint64_t (**)(void *))(*a1 + 80))(a1);
      *(_DWORD *)&v12[8] = a2;
      *(void *)&v12[12] = 0xAFFFFFFFFLL;
      unint64_t v10 = *(void *)(v7 + 96);
      if (v10 >= *(void *)(v7 + 104))
      {
        uint64_t result = (uint64_t)sub_1CC9AEA78(v8, (uint64_t)v12);
      }
      else
      {
        long long v11 = *(_OWORD *)v12;
        *(void *)(v10 + 16) = *(void *)&v12[16];
        *(_OWORD *)unint64_t v10 = v11;
        uint64_t result = v10 + 24;
      }
      *(void *)(v7 + 96) = result;
    }
    else
    {
      uint64_t v9 = a1[1];
      *(void *)unint64_t v12 = "If present, PushMachFrame must be the first UOP";
      __int16 v13 = 259;
      return llvm::MCContext::reportError(v9, a3, (uint64_t)v12);
    }
  }
  return result;
}

uint64_t llvm::MCStreamer::EmitWinCFIEndProlog(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::MCStreamer::EnsureValidWinFrameInfo(a1, a2);
  if (result)
  {
    uint64_t v4 = result;
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 80))(a1);
    *(void *)(v4 + 40) = result;
  }
  return result;
}

void llvm::MCStreamer::emitRawTextImpl()
{
}

uint64_t llvm::MCTargetStreamer::prettyPrintAsm(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, void, uint64_t, uint64_t))(*(void *)a2 + 32))(a2, a4, a3, "", 0, a5, a6);
}

void llvm::MCStreamer::emitPseudoProbe(uint64_t a1, uint64_t a2, uint64_t a3, char a4, char a5)
{
  unint64_t v10 = *(uint64_t ***)(a1 + 8);
  v15[0] = "tmp";
  __int16 v19 = 259;
  uint64_t TempSymbol = llvm::MCContext::createTempSymbol((llvm::MCContext *)v10, (const llvm::Twine *)v15, 1);
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 192))(a1, TempSymbol, 0);
  unint64_t v12 = 0;
  v15[0] = a2;
  v15[1] = a3;
  char v16 = a5;
  char v17 = a4;
  uint64_t v18 = TempSymbol;
  uint64_t v13 = *(unsigned int *)(a1 + 120);
  if (v13) {
    unint64_t v12 = *(void *)(*(void *)(a1 + 112) + 32 * v13 - 32);
  }
  unint64_t v14 = v12;
  sub_1CD6BAEE0(v10 + 205, v12, &v14);
  llvm::MCPseudoProbeInlineTree::addPseudoProbe();
}

uint64_t llvm::MCStreamer::emitAbsoluteSymbolDiffAsULEB128(llvm::MCStreamer *this, const llvm::MCSymbol *a2, const llvm::MCSymbol *a3)
{
  unint64_t v5 = llvm::MCSymbolRefExpr::create((uint64_t)a2, 0, *((void *)this + 1), 0);
  unint64_t v6 = llvm::MCSymbolRefExpr::create((uint64_t)a3, 0, *((void *)this + 1), 0);
  unint64_t v7 = llvm::MCBinaryExpr::create(18, v5, v6, *((void *)this + 1), 0);
  __int16 v8 = *(uint64_t (**)(llvm::MCStreamer *, unint64_t))(*(void *)this + 552);

  return v8(this, v7);
}

uint64_t llvm::MCStreamer::emitBinaryData(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 488))();
}

uint64_t llvm::MCStreamer::endSection(llvm::MCContext **this, llvm::MCSection *a2)
{
  Enduint64_t Symbol = llvm::MCSection::getEndSymbol(a2, this[1]);
  if (!sub_1CC34BE58(EndSymbol, 1) || (_UNKNOWN *)sub_1CC34BE58(EndSymbol, 1) == llvm::MCSymbol::AbsolutePseudoFragment)
  {
    (*((void (**)(llvm::MCContext **, llvm::MCSection *, void))*this + 21))(this, a2, 0);
    (*((void (**)(llvm::MCContext **, uint64_t, void))*this + 24))(this, EndSymbol, 0);
  }
  return EndSymbol;
}

char *sub_1CD6BAEE0(uint64_t **a1, unint64_t a2, void *a3)
{
  unint64_t v6 = a1 + 1;
  unint64_t v5 = (char *)a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v7 = v5;
        unint64_t v8 = *((void *)v5 + 4);
        if (v8 <= a2) {
          break;
        }
        unint64_t v5 = *(char **)v7;
        unint64_t v6 = (uint64_t **)v7;
        if (!*(void *)v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      unint64_t v5 = (char *)*((void *)v7 + 1);
      if (!v5)
      {
        unint64_t v6 = (uint64_t **)(v7 + 8);
        goto LABEL_9;
      }
    }
  }
  else
  {
    unint64_t v7 = (char *)(a1 + 1);
LABEL_9:
    uint64_t v9 = v7;
    unint64_t v7 = (char *)operator new(0x78uLL);
    *((void *)v7 + 4) = *a3;
    *(_OWORD *)(v7 + 72) = 0u;
    *(_OWORD *)(v7 + 88) = 0u;
    *(_OWORD *)(v7 + 104) = 0u;
    *(_OWORD *)(v7 + 40) = 0u;
    *(_OWORD *)(v7 + 56) = 0u;
    *((_DWORD *)v7 + 18) = 1065353216;
    *(void *)unint64_t v7 = 0;
    *((void *)v7 + 1) = 0;
    *((_OWORD *)v7 + 5) = 0u;
    *((_OWORD *)v7 + 6) = 0u;
    *((void *)v7 + 2) = v9;
    *unint64_t v6 = (uint64_t *)v7;
    unint64_t v10 = (uint64_t *)**a1;
    long long v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      long long v11 = *v6;
    }
    sub_1CB8358B8(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t *sub_1CD6BAFD0(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  if (v3 == *result)
  {
    uint64_t v5 = a2[1];
  }
  else
  {
    do
    {
      uint64_t v5 = v4 - 88;
      long long v6 = *(_OWORD *)(v3 - 88);
      *(_OWORD *)(v4 - 72) = *(_OWORD *)(v3 - 72);
      *(_OWORD *)(v4 - 88) = v6;
      *(void *)(v4 - 48) = 0;
      *(void *)(v4 - 40) = 0;
      *(void *)(v4 - 56) = 0;
      *(_OWORD *)(v4 - 56) = *(_OWORD *)(v3 - 56);
      *(void *)(v4 - 40) = *(void *)(v3 - 40);
      *(void *)(v3 - 56) = 0;
      *(void *)(v3 - 48) = 0;
      *(void *)(v3 - 40) = 0;
      long long v7 = *(_OWORD *)(v3 - 32);
      *(_OWORD *)(v4 - 23) = *(_OWORD *)(v3 - 23);
      *(_OWORD *)(v4 - 32) = v7;
      v3 -= 88;
      v4 -= 88;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  uint64_t v8 = *result;
  void *result = v5;
  a2[1] = v8;
  uint64_t v9 = result[1];
  result[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = result[2];
  result[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

void sub_1CD6BB07C(uint64_t a1)
{
}

uint64_t sub_1CD6BB098()
{
  uint64_t v1 = *(void **)(v0 + 88);
  if (v1)
  {
    *(void *)(v0 + 96) = v1;
    operator delete(v1);
  }
  return v0;
}

void sub_1CD6BB0B8(uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 24);
  sub_1CC4CDFC0(&v2);
  llvm::deallocate_buffer(*(llvm **)a1, (void *)(16 * *(unsigned int *)(a1 + 16)));
}

uint64_t sub_1CD6BB0F4()
{
  return v0;
}

void llvm::MCSPIRVStreamer::emitInstToData(llvm::MCObjectStreamer *a1, uint64_t a2, uint64_t a3)
{
  v19[32] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *((void *)a1 + 34);
  v16[0] = &v17;
  v16[1] = 0;
  char v17 = v19;
  long long v18 = xmmword_1CD96DBF0;
  int v8 = 0;
  char v12 = 0;
  uint64_t v13 = 0;
  long long v15 = &v17;
  int v14 = 0;
  long long v7 = &unk_1F2646FA8;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  (*(void (**)(void, uint64_t, void **, void **, uint64_t))(**(void **)(v5 + 16) + 32))(*(void *)(v5 + 16), a2, &v7, v16, a3);
  uint64_t DataFragment = llvm::MCObjectStreamer::getOrCreateDataFragment(a1, 0);
  *(unsigned char *)(DataFragment + 50) = 1;
  *(void *)(DataFragment + 56) = a3;
  sub_1CC22A954((void *)(DataFragment + 64), v17, (unsigned char *)v17 + v18);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v7);
  if (v17 != v19) {
    free(v17);
  }
  if (v16[0] != &v17) {
    free(v16[0]);
  }
}

void llvm::createSPIRVStreamer()
{
}

void sub_1CD6BB390(llvm::MCObjectStreamer *a1)
{
}

uint64_t sub_1CD6BB3C8()
{
  return 0;
}

void sub_1CD6BB3D8(llvm::MCStreamer *a1, llvm::MCContext *a2, void *a3, void *a4, void *a5)
{
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  llvm::MCObjectStreamer::MCObjectStreamer(a1, a2);
}

long long *llvm::MCSubtargetInfo::InitMCProcessorInfo(uint64_t a1, _DWORD *a2, size_t a3, _DWORD *a4, size_t a5, const std::string::value_type *a6, std::string::size_type a7, uint64_t a8)
{
  sub_1CCBD4E3C((uint64_t)v16, a2, a3, a4, a5, (uint64_t)a6, a7, a8, *(uint64_t **)(a1 + 120), *(void *)(a1 + 128), *(const char ***)(a1 + 104), *(void *)(a1 + 112));
  long long v13 = *(_OWORD *)&v16[16];
  *(_OWORD *)(a1 + 192) = *(_OWORD *)v16;
  *(_OWORD *)(a1 + 208) = v13;
  *(void *)(a1 + 224) = v17;
  std::string::__init((std::string *)v16, a6, a7);
  int v14 = (void **)(a1 + 232);
  if (*(char *)(a1 + 255) < 0) {
    operator delete(*v14);
  }
  *(_OWORD *)int v14 = *(_OWORD *)v16;
  *(void *)(a1 + 248) = *(void *)&v16[16];
  if (a5) {
    uint64_t result = llvm::MCSubtargetInfo::getSchedModelForCPU(a1, a4, a5);
  }
  else {
    uint64_t result = &llvm::MCSchedModel::Default;
  }
  *(void *)(a1 + 160) = result;
  return result;
}

long long *llvm::MCSubtargetInfo::getSchedModelForCPU(uint64_t a1, _DWORD *a2, size_t a3)
{
  uint64_t v5 = sub_1CCBD5F98(a2, a3, *(const char ***)(a1 + 120), *(void *)(a1 + 128));
  if (v5) {
    return (long long *)v5[11];
  }
  if (a3 != 4 || *a2 != 1886152040)
  {
    long long v7 = (llvm::raw_ostream *)llvm::errs(0);
    int v8 = sub_1CB8E509C(v7, "'");
    uint64_t v9 = (void *)*((void *)v8 + 4);
    if (a3 <= *((void *)v8 + 3) - (void)v9)
    {
      if (a3)
      {
        memcpy(v9, a2, a3);
        *((void *)v8 + 4) += a3;
      }
    }
    else
    {
      llvm::raw_ostream::write(v8, (const char *)a2, a3);
    }
    uint64_t v10 = sub_1CB8E509C(v8, "' is not a recognized processor for this target");
    sub_1CB8E509C(v10, " (ignoring processor)\n");
  }
  return &llvm::MCSchedModel::Default;
}

uint64_t llvm::MCSubtargetInfo::getCacheSize(llvm::MCSubtargetInfo *this)
{
  return 0;
}

uint64_t llvm::MCSubtargetInfo::getCacheAssociativity(llvm::MCSubtargetInfo *this)
{
  return 0;
}

uint64_t llvm::MCSubtargetInfo::getCacheLineSize(llvm::MCSubtargetInfo *this)
{
  return 0;
}

uint64_t llvm::MCSubtargetInfo::getPrefetchDistance(llvm::MCSubtargetInfo *this)
{
  return 0;
}

uint64_t llvm::MCSubtargetInfo::getMaxPrefetchIterationsAhead(llvm::MCSubtargetInfo *this)
{
  return 0xFFFFFFFFLL;
}

uint64_t llvm::MCSubtargetInfo::enableWritePrefetching(llvm::MCSubtargetInfo *this)
{
  return 0;
}

uint64_t llvm::MCSubtargetInfo::getMinPrefetchStride(llvm::MCSubtargetInfo *this)
{
  return 1;
}

void sub_1CD6BB854(void **a1)
{
  llvm::TargetSubtargetInfo::~TargetSubtargetInfo(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD6BB88C(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(unsigned int *)(a1 + 16), *(void *)(a1 + 24), *(void *)(a1 + 32));
}

BOOL sub_1CD6BB8CC(char *__s, const void *a2, size_t a3)
{
  if (__s) {
    size_t v6 = strlen(__s);
  }
  else {
    size_t v6 = 0;
  }
  if (a3 >= v6) {
    size_t v7 = v6;
  }
  else {
    size_t v7 = a3;
  }
  if (v7 && (int v8 = memcmp(__s, a2, v7)) != 0)
  {
    int v9 = (v8 >> 31) | 1;
  }
  else
  {
    if (v6 < a3) {
      int v9 = -1;
    }
    else {
      int v9 = 1;
    }
    if (v6 == a3) {
      int v9 = 0;
    }
  }
  return v9 == -1;
}

llvm::raw_ostream *llvm::MCSymbol::print(llvm::MCSymbol *this, llvm::raw_ostream *a2, const llvm::MCAsmInfo *a3)
{
  if ((*(unsigned char *)this & 4) != 0)
  {
    int v8 = (void *)*((void *)this - 1);
    size_t v9 = *v8;
    uint64_t v5 = (unsigned __int8 *)(v8 + 2);
    size_t v6 = v9;
  }
  else
  {
    uint64_t v5 = 0;
    size_t v6 = 0;
  }
  if (!a3
    || (uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(const llvm::MCAsmInfo *, unsigned __int8 *, size_t))(*(void *)a3 + 56))(a3, v5, v6), result))
  {
    uint64_t result = (llvm::raw_ostream *)*((void *)a2 + 4);
    if (v6 <= *((void *)a2 + 3) - (void)result)
    {
      if (v6)
      {
        uint64_t result = (llvm::raw_ostream *)memcpy(result, v5, v6);
        *((void *)a2 + 4) += v6;
      }
    }
    else
    {
      return llvm::raw_ostream::write(a2, (const char *)v5, v6);
    }
    return result;
  }
  if (!*((unsigned char *)a3 + 185)) {
    llvm::report_fatal_error((llvm *)"Symbol name with unsupported characters", (const llvm::Twine *)1);
  }
  uint64_t v10 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)v10 >= *((void *)a2 + 3))
  {
    uint64_t result = llvm::raw_ostream::write(a2, 34);
  }
  else
  {
    *((void *)a2 + 4) = v10 + 1;
    *uint64_t v10 = 34;
  }
  for (; v6; --v6)
  {
    int v11 = *v5;
    if (v11 == 34)
    {
      char v12 = a2;
      long long v13 = "\\\"";
    }
    else
    {
      if (v11 != 10)
      {
        int v14 = (unsigned char *)*((void *)a2 + 4);
        if ((unint64_t)v14 >= *((void *)a2 + 3))
        {
          uint64_t result = llvm::raw_ostream::write(a2, v11);
        }
        else
        {
          *((void *)a2 + 4) = v14 + 1;
          *int v14 = v11;
        }
        goto LABEL_22;
      }
      char v12 = a2;
      long long v13 = "\\n";
    }
    uint64_t result = sub_1CB8E509C(v12, v13);
LABEL_22:
    ++v5;
  }
  long long v15 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)v15 >= *((void *)a2 + 3))
  {
    return llvm::raw_ostream::write(a2, 34);
  }
  else
  {
    *((void *)a2 + 4) = v15 + 1;
    unsigned char *v15 = 34;
  }
  return result;
}

llvm::raw_ostream *llvm::MCSymbol::dump(llvm::MCSymbol *this)
{
  uint64_t v2 = llvm::dbgs(this);

  return llvm::MCSymbol::print(this, v2, 0);
}

uint64_t llvm::MCSymbolELF::setBinding(uint64_t this, int a2)
{
  if (a2 == 2) {
    __int16 v2 = 16;
  }
  else {
    __int16 v2 = 24;
  }
  if (a2) {
    __int16 v3 = 8;
  }
  else {
    __int16 v3 = 0;
  }
  if (a2 <= 1) {
    __int16 v2 = v3;
  }
  *(_WORD *)(this + 12) = *(_WORD *)(this + 12) & 0xFFE7 | v2 | 0x1000;
  return this;
}

uint64_t llvm::MCSymbolELF::getBinding(llvm::MCSymbolELF *this)
{
  unint64_t v1 = *((unsigned __int16 *)this + 6);
  if ((v1 & 0x1000) != 0) {
    return dword_1CFB28E40[(v1 >> 3) & 3];
  }
  if (sub_1CC34BE58((uint64_t)this, 1)) {
    return 0;
  }
  if ((*((unsigned char *)this + 9) & 2) != 0) {
    return 1;
  }
  if ((*((_WORD *)this + 6) & 0x800) != 0) {
    return 2;
  }
  return (*((_WORD *)this + 6) & 0x400) == 0;
}

uint64_t llvm::MCSymbolELF::isBindingSet(llvm::MCSymbolELF *this)
{
  return (*((unsigned __int16 *)this + 6) >> 12) & 1;
}

uint64_t llvm::MCSymbolELF::isWeakrefUsedInReloc(llvm::MCSymbolELF *this)
{
  return (*((unsigned __int16 *)this + 6) >> 11) & 1;
}

uint64_t llvm::MCSymbolELF::isSignature(llvm::MCSymbolELF *this)
{
  return (*((unsigned __int16 *)this + 6) >> 10) & 1;
}

uint64_t llvm::MCSymbolELF::setType(uint64_t this, int a2)
{
  *(_WORD *)(this + 12) = *(_WORD *)(this + 12) & 0xFFF8 | word_1CFB28E50[a2];
  return this;
}

uint64_t llvm::MCSymbolELF::getType(llvm::MCSymbolELF *this)
{
  return dword_1CFB28E68[*((_WORD *)this + 6) & 7];
}

uint64_t llvm::MCSymbolELF::setVisibility(uint64_t this, __int16 a2)
{
  *(_WORD *)(this + 12) = *(_WORD *)(this + 12) & 0xFF9F | (32 * a2);
  return this;
}

uint64_t llvm::MCSymbolELF::getVisibility(llvm::MCSymbolELF *this)
{
  return (*((unsigned __int16 *)this + 6) >> 5) & 3;
}

uint64_t llvm::MCSymbolELF::setOther(uint64_t this, __int16 a2)
{
  *(_WORD *)(this + 12) = *(_WORD *)(this + 12) & 0xFC7F | (4 * a2) & 0xFF80;
  return this;
}

uint64_t llvm::MCSymbolELF::getOther(llvm::MCSymbolELF *this)
{
  return (*((unsigned __int16 *)this + 6) >> 2) & 0xE0;
}

uint64_t llvm::MCSymbolELF::setIsWeakrefUsedInReloc(uint64_t this)
{
  *(_WORD *)(this + 12) |= 0x800u;
  return this;
}

uint64_t llvm::MCSymbolELF::setIsSignature(uint64_t this)
{
  *(_WORD *)(this + 12) |= 0x400u;
  return this;
}

uint64_t llvm::MCSymbolXCOFF::getRepresentedCsect(llvm::MCSymbolXCOFF *this)
{
  return *((void *)this + 5);
}

uint64_t llvm::MCSymbolXCOFF::setRepresentedCsect(uint64_t this, llvm::MCSectionXCOFF *a2)
{
  *(void *)(this + 40) = a2;
  return this;
}

char *llvm::MCTargetOptions::getABIName(llvm::MCTargetOptions *this)
{
  uint64_t v3 = *((void *)this + 2);
  unint64_t v1 = (char *)this + 16;
  uint64_t v2 = v3;
  if (v1[23] >= 0) {
    return v1;
  }
  return (char *)v2;
}

void sub_1CD6BBD70(llvm *a1)
{
  unint64_t v1 = a1;
  if (!*((void *)a1 + 3))
  {
    v7[0] = "cl::alias must have argument name specified!";
    __int16 v8 = 259;
    uint64_t v4 = (llvm::raw_ostream *)llvm::errs(a1);
    a1 = (llvm *)llvm::cl::Option::error(v1, (llvm::Twine *)v7, 0, 0, v4);
  }
  if (!*((void *)v1 + 16))
  {
    v7[0] = "cl::alias must have an cl::aliasopt(option) specified!";
    __int16 v8 = 259;
    uint64_t v5 = (llvm::raw_ostream *)llvm::errs(a1);
    a1 = (llvm *)llvm::cl::Option::error(v1, (llvm::Twine *)v7, 0, 0, v5);
  }
  if (*((_DWORD *)v1 + 27) != *((_DWORD *)v1 + 28))
  {
    v7[0] = "cl::alias must not have cl::sub(), aliased option's cl::sub() will be used!";
    __int16 v8 = 259;
    size_t v6 = (llvm::raw_ostream *)llvm::errs(a1);
    llvm::cl::Option::error(v1, (llvm::Twine *)v7, 0, 0, v6);
  }
  uint64_t v2 = (llvm *)*((void *)v1 + 16);
  uint64_t v3 = v1;
  if (v2 != v1)
  {
    llvm::SmallPtrSetImplBase::CopyFrom((llvm *)((char *)v1 + 88), (llvm *)((char *)v2 + 88));
    uint64_t v3 = (llvm *)*((void *)v1 + 16);
  }
  sub_1CD6BBEE8((uint64_t)v1 + 64, (uint64_t)v3 + 64);
  llvm::cl::Option::addArgument(v1);
}

void *sub_1CD6BBE84(void *result, uint64_t a2)
{
  if (result[16])
  {
    uint64_t v4 = result;
    uint64_t v5 = "cl::alias must only have one cl::aliasopt(...) specified!";
    __int16 v6 = 259;
    uint64_t v3 = a2;
    uint64_t v2 = (llvm::raw_ostream *)llvm::errs((llvm *)result);
    llvm::cl::Option::error(v4, (llvm::Twine *)&v5, 0, 0, v2);
    a2 = v3;
    uint64_t result = v4;
  }
  result[16] = a2;
  return result;
}

uint64_t sub_1CD6BBEE8(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v3 = *(unsigned int *)(a2 + 8);
    unsigned int v4 = *(_DWORD *)(a1 + 8);
    if (v4 < v3)
    {
      uint64_t v8 = *(unsigned int *)(a1 + 8);
      if (*(_DWORD *)(a1 + 12) < v3)
      {
        *(_DWORD *)(a1 + 8) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v4) {
        memmove(*(void **)a1, *(const void **)a2, 8 * v8);
      }
      else {
        uint64_t v8 = 0;
      }
      uint64_t v6 = *(unsigned int *)(a2 + 8);
      if (v8 != v6) {
        memcpy((void *)(*(void *)a1 + 8 * v8), (const void *)(*(void *)a2 + 8 * v8), *(void *)a2 + 8 * v6 - (*(void *)a2 + 8 * v8));
      }
    }
    else if (v3)
    {
      memmove(*(void **)a1, *(const void **)a2, 8 * v3);
    }
    *(_DWORD *)(a1 + 8) = v3;
  }
  return a1;
}

llvm::raw_ostream *llvm::MCValue::print(llvm::MCValue *this, llvm::raw_ostream *a2)
{
  uint64_t v2 = a2;
  if (*(_OWORD *)this == 0)
  {
    uint64_t v6 = (unint64_t *)((char *)this + 16);
LABEL_14:
    unint64_t v11 = *v6;
    return llvm::raw_ostream::operator<<(v2, v11);
  }
  if (*((_DWORD *)this + 6))
  {
    unsigned int v4 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v4 >= *((void *)a2 + 3))
    {
      uint64_t v5 = llvm::raw_ostream::write(a2, 58);
    }
    else
    {
      *((void *)a2 + 4) = v4 + 1;
      *unsigned int v4 = 58;
      uint64_t v5 = a2;
    }
    size_t v7 = llvm::raw_ostream::operator<<(v5, *((unsigned int *)this + 6));
    uint64_t v8 = (unsigned char *)*((void *)v7 + 4);
    if ((unint64_t)v8 >= *((void *)v7 + 3))
    {
      llvm::raw_ostream::write(v7, 58);
    }
    else
    {
      *((void *)v7 + 4) = v8 + 1;
      unsigned char *v8 = 58;
    }
  }
  uint64_t result = llvm::MCExpr::print(*(llvm::raw_ostream **)this, v2, 0, 0);
  if (*((void *)this + 1))
  {
    sub_1CB8E509C(v2, " - ");
    uint64_t result = llvm::MCExpr::print(*((llvm::raw_ostream **)this + 1), v2, 0, 0);
  }
  uint64_t v10 = *((void *)this + 2);
  uint64_t v6 = (unint64_t *)((char *)this + 16);
  if (v10)
  {
    uint64_t v2 = sub_1CB8E509C(v2, " + ");
    goto LABEL_14;
  }
  return result;
}

llvm::raw_ostream *llvm::MCValue::dump(llvm::MCValue *this)
{
  uint64_t v2 = llvm::dbgs(this);

  return llvm::MCValue::print(this, v2);
}

void llvm::MCWasmStreamer::~MCWasmStreamer(llvm::MCWasmStreamer *this)
{
}

void llvm::MCWasmStreamer::emitLabel(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(unsigned char *)(*(void *)(*(void *)(a1 + 112) + 32 * *(unsigned int *)(a1 + 120) - 32) + 256) & 2) != 0) {
    *(_WORD *)(a2 + 12) |= 0x100u;
  }
}

llvm::MCSection *llvm::MCWasmStreamer::emitLabelAtPos(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = llvm::MCObjectStreamer::emitLabelAtPos((uint64_t *)a1, a2, a3, a4, a5);
  if ((*(unsigned char *)(*(void *)(*(void *)(a1 + 112) + 32 * *(unsigned int *)(a1 + 120) - 32) + 256) & 2) != 0) {
    *(_WORD *)(a2 + 12) |= 0x100u;
  }
  return result;
}

void llvm::MCWasmStreamer::emitAssemblerFlag(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(*(void *)(a1 + 272) + 8) + 208))(*(void *)(*(void *)(a1 + 272)
                                                                                                  + 8));
  __break(1u);
}

uint64_t llvm::MCWasmStreamer::changeSection(llvm::MCWasmStreamer *this, llvm::MCSection *a2, const llvm::MCExpr *a3)
{
  uint64_t v6 = *((void *)this + 34);
  uint64_t v7 = *((void *)a2 + 29);
  if (v7) {
    llvm::MCAssembler::registerSymbol(*((void *)this + 34), v7, 0);
  }
  llvm::MCObjectStreamer::changeSection(this, a2, a3);
  uint64_t v8 = *((void *)a2 + 1);

  return llvm::MCAssembler::registerSymbol(v6, v8, 0);
}

uint64_t llvm::MCWasmStreamer::emitWeakReference(llvm::MCWasmStreamer *this, llvm::MCSymbol *a2, const llvm::MCSymbol *a3)
{
  llvm::MCAssembler::registerSymbol(*((void *)this + 34), (uint64_t)a3, 0);
  uint64_t v6 = (const llvm::MCExpr *)llvm::MCSymbolRefExpr::create((uint64_t)a3, 29, *((void *)this + 1), 0);

  return llvm::MCSymbol::setVariableValue((uint64_t)a2, v6);
}

uint64_t llvm::MCWasmStreamer::emitSymbolAttribute(uint64_t a1, uint64_t a2, int a3)
{
  llvm::MCAssembler::registerSymbol(*(void *)(a1 + 272), a2, 0);
  uint64_t result = 0;
  switch(a3)
  {
    case 1:
    case 4:
      goto LABEL_4;
    case 2:
      int v7 = *(unsigned __int8 *)(a2 + 36);
      *(_DWORD *)(a2 + 32) = 0;
      if (!v7) {
        *(unsigned char *)(a2 + 36) = 1;
      }
      goto LABEL_4;
    case 3:
    case 6:
    case 7:
    case 8:
    case 10:
    case 11:
    case 14:
    case 16:
    case 19:
      __break(1u);
      return result;
    case 5:
      __int16 v6 = *(_WORD *)(a2 + 12) | 0x100;
      goto LABEL_7;
    case 9:
      goto LABEL_3;
    case 12:
      *(unsigned char *)(a2 + 41) = 1;
      goto LABEL_4;
    case 17:
      __int16 v6 = *(_WORD *)(a2 + 12) | 0x80;
LABEL_7:
      *(_WORD *)(a2 + 12) = v6;
      goto LABEL_4;
    case 23:
    case 25:
      *(unsigned char *)(a2 + 40) = 1;
LABEL_3:
      *(_DWORD *)(a2 + 8) |= 0x10u;
LABEL_4:
      uint64_t result = 1;
      break;
    default:
      return result;
  }
  return result;
}

void llvm::MCWasmStreamer::emitELFSize(llvm::MCWasmStreamer *this, llvm::MCSymbol *a2, const llvm::MCExpr *a3)
{
  *((void *)a2 + 22) = a3;
}

void llvm::MCWasmStreamer::emitInstToFragment()
{
}

uint64_t *llvm::MCWasmStreamer::fixSymbolsInTLSFixups(uint64_t *this, const llvm::MCExpr *a2)
{
  uint64_t v3 = this;
  while (1)
  {
    int v4 = *(unsigned __int8 *)a2;
    if (v4 == 3)
    {
      uint64_t v5 = (const llvm::MCExpr **)((char *)a2 + 16);
      goto LABEL_4;
    }
    if (*(unsigned char *)a2) {
      break;
    }
    this = (uint64_t *)llvm::MCWasmStreamer::fixSymbolsInTLSFixups((llvm::MCWasmStreamer *)v3, *((const llvm::MCExpr **)a2 + 2));
    uint64_t v5 = (const llvm::MCExpr **)((char *)a2 + 24);
LABEL_4:
    a2 = *v5;
  }
  if (v4 == 2)
  {
    int v6 = *(unsigned __int16 *)((char *)a2 + 1);
    if (v6 == 129 || v6 == 126)
    {
      this = (uint64_t *)llvm::MCAssembler::registerSymbol(v3[34], *((void *)a2 + 2), 0);
      *(_WORD *)(*((void *)a2 + 2) + 12) |= 0x100u;
    }
  }
  return this;
}

void llvm::MCWasmStreamer::emitInstToData(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v30[12] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1[34];
  uint64_t v28 = (const llvm::MCExpr **)v30;
  uint64_t v29 = 0x400000000;
  long long v24 = &v25;
  uint64_t v25 = v27;
  long long v26 = xmmword_1CD96DBF0;
  int v17 = 0;
  char v21 = 0;
  uint64_t v22 = 0;
  int v23 = 0;
  char v16 = &unk_1F2646FA8;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  (*(void (**)(void, uint64_t, void **, const llvm::MCExpr ***, uint64_t))(**(void **)(v5 + 16) + 32))(*(void *)(v5 + 16), a2, &v16, &v28, a3);
  if (v29)
  {
    int v6 = v28;
    uint64_t v7 = 24 * v29;
    do
    {
      uint64_t v8 = *v6;
      v6 += 3;
      llvm::MCWasmStreamer::fixSymbolsInTLSFixups(a1, v8);
      v7 -= 24;
    }
    while (v7);
  }
  uint64_t DataFragment = llvm::MCObjectStreamer::getOrCreateDataFragment((llvm::MCObjectStreamer *)a1, 0);
  if (v29)
  {
    unint64_t v10 = 0;
    uint64_t v11 = 24 * v29;
    do
    {
      char v12 = (char *)&v28[v10 / 8];
      *((_DWORD *)v12 + 2) = LODWORD(v28[v10 / 8 + 1]) + *(_DWORD *)(DataFragment + 72);
      unint64_t v13 = sub_1CD41C4F0(DataFragment + 120, (unint64_t)v12, 1);
      uint64_t v14 = *(void *)(DataFragment + 120) + 24 * *(unsigned int *)(DataFragment + 128);
      long long v15 = *(_OWORD *)v13;
      *(void *)(v14 + 16) = *(void *)(v13 + 16);
      *(_OWORD *)uint64_t v14 = v15;
      ++*(_DWORD *)(DataFragment + 128);
      v10 += 24;
    }
    while (v11 != v10);
  }
  *(unsigned char *)(DataFragment + 50) = 1;
  *(void *)(DataFragment + 56) = a3;
  sub_1CC22A954((void *)(DataFragment + 64), v25, (unsigned char *)v25 + v26);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v16);
  if (v25 != v27) {
    free(v25);
  }
  if (v28 != v30) {
    free(v28);
  }
}

void llvm::MCWasmStreamer::finishImpl(llvm::MCWasmStreamer *this)
{
  llvm::MCObjectStreamer::emitFrames(this, 0);

  llvm::MCObjectStreamer::finishImpl((llvm::MCContext **)this);
}

void llvm::createWasmStreamer()
{
}

double sub_1CD6BC854(llvm::MCObjectStreamer *this)
{
  *((unsigned char *)this + 544) = 0;
  return llvm::MCObjectStreamer::reset(this);
}

void sub_1CD6BC85C(llvm::MCStreamer *a1, llvm::MCContext *a2, void *a3, void *a4, void *a5)
{
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  llvm::MCObjectStreamer::MCObjectStreamer(a1, a2);
}

void llvm::MCXCOFFStreamer::MCXCOFFStreamer(llvm::MCStreamer *a1, llvm::MCContext *a2, void *a3, void *a4, void *a5)
{
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  llvm::MCObjectStreamer::MCObjectStreamer(a1, a2);
}

uint64_t llvm::MCXCOFFStreamer::emitSymbolAttribute(uint64_t a1, uint64_t a2, int a3)
{
  llvm::MCAssembler::registerSymbol(*(void *)(a1 + 272), a2, 0);
  switch(a3)
  {
    case 9:
    case 11:
      if (!*(unsigned char *)(a2 + 33)) {
        *(unsigned char *)(a2 + 33) = 1;
      }
      char v5 = 2;
      goto LABEL_5;
    case 10:
      if (!*(unsigned char *)(a2 + 33)) {
        *(unsigned char *)(a2 + 33) = 1;
      }
      char v5 = 107;
      goto LABEL_5;
    case 12:
      __int16 v7 = 0x2000;
      goto LABEL_12;
    case 21:
      __int16 v7 = 12288;
LABEL_12:
      *(_WORD *)(a2 + 48) = v7;
      break;
    case 23:
      if (!*(unsigned char *)(a2 + 33)) {
        *(unsigned char *)(a2 + 33) = 1;
      }
      char v5 = 111;
LABEL_5:
      *(unsigned char *)(a2 + 32) = v5;
      *(_DWORD *)(a2 + 8) |= 0x10u;
      break;
    default:
      llvm::report_fatal_error((llvm *)"Not implemented yet.", (const llvm::Twine *)1);
  }
  return 1;
}

uint64_t llvm::MCXCOFFStreamer::emitXCOFFSymbolLinkageWithVisibility(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 304))(a1);
  if (a4)
  {
    uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 304);
    return v8(a1, a2, a4);
  }
  return result;
}

uint64_t llvm::MCXCOFFStreamer::emitCommonSymbol(llvm::MCXCOFFStreamer *this, llvm::MCSymbol *a2, uint64_t a3, uint64_t a4)
{
  llvm::MCAssembler::registerSymbol(*((void *)this + 34), (uint64_t)a2, 0);
  BOOL v8 = *((unsigned __int8 *)a2 + 32) != 107;
  unsigned int v9 = *((_DWORD *)a2 + 2) & 0xFFFC03EF;
  *((void *)a2 + 3) = a3;
  *((_DWORD *)a2 + 2) = (-8192 * __clz(a4)) & 0x3E000 | (16 * v8) | v9 | 0xC00;
  *(unsigned char *)(llvm::MCSymbolXCOFF::getRepresentedCsect(a2) + 24) = 63 - __clz(a4);
  (*(void (**)(llvm::MCXCOFFStreamer *, uint64_t, void, uint64_t, void))(*(void *)this + 640))(this, a4, 0, 1, 0);

  return llvm::MCStreamer::emitZeros(this, a3);
}

void llvm::MCXCOFFStreamer::emitZerofill()
{
}

void llvm::MCXCOFFStreamer::emitInstToData(llvm::MCObjectStreamer *a1, uint64_t a2, const llvm::MCSubtargetInfo *a3)
{
  v29[12] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *((void *)a1 + 34);
  int64_t v27 = v29;
  uint64_t v28 = 0x400000000;
  int v23 = &v24;
  long long v24 = v26;
  long long v25 = xmmword_1CD96DBF0;
  int v16 = 0;
  char v20 = 0;
  uint64_t v21 = 0;
  int v22 = 0;
  long long v15 = &unk_1F2646FA8;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  (*(void (**)(void, uint64_t, void **, void **, const llvm::MCSubtargetInfo *))(**(void **)(v5 + 16)
                                                                                             + 32))(*(void *)(v5 + 16), a2, &v15, &v27, a3);
  uint64_t DataFragment = llvm::MCObjectStreamer::getOrCreateDataFragment(a1, a3);
  uint64_t v7 = DataFragment;
  BOOL v8 = (void *)(DataFragment + 64);
  if (v28)
  {
    unsigned int v9 = v27;
    int v10 = *(_DWORD *)(DataFragment + 72);
    uint64_t v11 = 24 * v28;
    do
    {
      v9[2] += v10;
      unint64_t v12 = sub_1CD41C4F0(v7 + 120, (unint64_t)v9, 1);
      uint64_t v13 = *(void *)(v7 + 120) + 24 * *(unsigned int *)(v7 + 128);
      long long v14 = *(_OWORD *)v12;
      *(void *)(v13 + 16) = *(void *)(v12 + 16);
      *(_OWORD *)uint64_t v13 = v14;
      ++*(_DWORD *)(v7 + 128);
      v9 += 6;
      v11 -= 24;
    }
    while (v11);
  }
  *(unsigned char *)(v7 + 50) = 1;
  *(void *)(v7 + 56) = a3;
  sub_1CC22A954(v8, v24, (unsigned char *)v24 + v25);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v15);
  if (v24 != v26) {
    free(v24);
  }
  if (v27 != v29) {
    free(v27);
  }
}

void llvm::createXCOFFStreamer()
{
}

uint64_t llvm::MCXCOFFStreamer::emitXCOFFLocalCommonSymbol(llvm::MCXCOFFStreamer *this, llvm::MCSymbol *a2, uint64_t a3, llvm::MCSymbol *a4, uint64_t a5)
{
  return (*(uint64_t (**)(llvm::MCXCOFFStreamer *, llvm::MCSymbol *, uint64_t, uint64_t))(*(void *)this + 456))(this, a4, a3, a5);
}

void sub_1CD6BD060(llvm::MCObjectStreamer *a1)
{
}

void sub_1CD6BD098()
{
}

void sub_1CD6BD0B4()
{
}

llvm::raw_ostream *llvm::MachObjectWriter::writeLinkeditLoadCommand(llvm::MachObjectWriter *this, unsigned int a2, unsigned int a3, unsigned int a4)
{
  (*(void (**)(void))(**((void **)this + 26) + 80))(*((void *)this + 26));
  BOOL v8 = (llvm::raw_ostream *)*((void *)this + 26);
  unsigned int v9 = bswap32(a2);
  if ((*((_DWORD *)this + 54) - 1) >= 2) {
    unsigned int v10 = v9;
  }
  else {
    unsigned int v10 = a2;
  }
  *(_DWORD *)char v20 = v10;
  llvm::raw_ostream::write(v8, v20, 4uLL);
  uint64_t v11 = (llvm::raw_ostream *)*((void *)this + 26);
  if ((*((_DWORD *)this + 54) - 1) >= 2) {
    int v12 = 0x10000000;
  }
  else {
    int v12 = 16;
  }
  *(_DWORD *)char v20 = v12;
  llvm::raw_ostream::write(v11, v20, 4uLL);
  uint64_t v13 = (llvm::raw_ostream *)*((void *)this + 26);
  unsigned int v14 = bswap32(a3);
  if ((*((_DWORD *)this + 54) - 1) >= 2) {
    unsigned int v15 = v14;
  }
  else {
    unsigned int v15 = a3;
  }
  *(_DWORD *)char v20 = v15;
  llvm::raw_ostream::write(v13, v20, 4uLL);
  int v16 = (llvm::raw_ostream *)*((void *)this + 26);
  unsigned int v17 = bswap32(a4);
  if ((*((_DWORD *)this + 54) - 1) >= 2) {
    unsigned int v18 = v17;
  }
  else {
    unsigned int v18 = a4;
  }
  *(_DWORD *)char v20 = v18;
  return llvm::raw_ostream::write(v16, v20, 4uLL);
}

llvm::raw_ostream *llvm::MachObjectWriter::writeLinkerOptionsLoadCommand(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  int v5 = 12;
  while (v4 != a2[1])
  {
    if (*(char *)(v4 + 23) < 0) {
      uint64_t v6 = *(void *)(v4 + 8);
    }
    else {
      LODWORD(v6) = *(unsigned __int8 *)(v4 + 23);
    }
    v5 += v6 + 1;
    v4 += 24;
  }
  if (*(unsigned char *)(*(void *)(a1 + 8) + 8)) {
    int v7 = -8;
  }
  else {
    int v7 = -4;
  }
  if (*(unsigned char *)(*(void *)(a1 + 8) + 8)) {
    int v8 = 7;
  }
  else {
    int v8 = 3;
  }
  unsigned int v9 = (v5 + v8) & v7;
  (*(void (**)(void))(**(void **)(a1 + 208) + 80))(*(void *)(a1 + 208));
  unsigned int v10 = *(llvm::raw_ostream **)(a1 + 208);
  if ((*(_DWORD *)(a1 + 216) - 1) >= 2) {
    int v11 = 754974720;
  }
  else {
    int v11 = 45;
  }
  *(_DWORD *)char v31 = v11;
  llvm::raw_ostream::write(v10, v31, 4uLL);
  int v12 = *(llvm::raw_ostream **)(a1 + 208);
  unsigned int v13 = bswap32(v9);
  if ((*(_DWORD *)(a1 + 216) - 1) >= 2) {
    unsigned int v14 = v13;
  }
  else {
    unsigned int v14 = v9;
  }
  *(_DWORD *)char v32 = v14;
  llvm::raw_ostream::write(v12, v32, 4uLL);
  unsigned int v15 = -1431655765 * ((unint64_t)(a2[1] - *a2) >> 3);
  int v16 = *(llvm::raw_ostream **)(a1 + 208);
  unsigned int v17 = bswap32(v15);
  if ((*(_DWORD *)(a1 + 216) - 1) >= 2) {
    unsigned int v15 = v17;
  }
  *(_DWORD *)std::error_code v33 = v15;
  llvm::raw_ostream::write(v16, v33, 4uLL);
  uint64_t v18 = *a2;
  uint64_t v19 = a2[1];
  int v20 = 12;
  while (v18 != v19)
  {
    char v21 = *(unsigned char *)(v18 + 23);
    BOOL v22 = v21 < 0;
    if (v21 >= 0) {
      int v23 = (const char *)v18;
    }
    else {
      int v23 = *(const char **)v18;
    }
    size_t v24 = v21 & 0x7F;
    if (v22) {
      size_t v25 = *(void *)(v18 + 8);
    }
    else {
      size_t v25 = v24;
    }
    long long v26 = llvm::raw_ostream::write(*(llvm::raw_ostream **)(a1 + 208), v23, v25);
    int64_t v27 = (unsigned char *)*((void *)v26 + 4);
    if ((unint64_t)v27 >= *((void *)v26 + 3))
    {
      llvm::raw_ostream::write(v26, 0);
    }
    else
    {
      *((void *)v26 + 4) = v27 + 1;
      *int64_t v27 = 0;
    }
    if (*(char *)(v18 + 23) < 0) {
      uint64_t v28 = *(void *)(v18 + 8);
    }
    else {
      LODWORD(v28) = *(unsigned __int8 *)(v18 + 23);
    }
    v20 += v28 + 1;
    v18 += 24;
  }
  int v29 = 1 << (*(unsigned char *)(*(void *)(a1 + 8) + 8) & 1 | 2);
  return llvm::raw_ostream::write_zeros(*(llvm::raw_ostream **)(a1 + 208), ((v20 + v29 - 1) & -v29) - v20);
}

void llvm::createMachObjectWriter()
{
}

void sub_1CD6BD414(uint64_t a1)
{
  sub_1CCBE1D3C(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD6BD44C(unsigned int *a1)
{
  unsigned int v2 = a1[2];
  sub_1CCBE1E20(a1);
  if (v2)
  {
    int v3 = 1 << (33 - __clz(v2 - 1));
    if (v3 <= 64) {
      unsigned int v4 = 64;
    }
    else {
      unsigned int v4 = v3;
    }
    if (v4 == a1[4])
    {
      *((void *)a1 + 1) = 0;
      uint64_t v5 = 32 * v4;
      uint64_t v6 = *(void **)a1;
      do
      {
        *uint64_t v6 = -4096;
        v6 += 4;
        v5 -= 32;
      }
      while (v5);
      return;
    }
  }
  else
  {
    if (!a1[4])
    {
      *((void *)a1 + 1) = 0;
      return;
    }
    unsigned int v4 = 0;
  }
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);

  sub_1CBC04C8C(a1, v4);
}

uint64_t sub_1CD6BD508(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  int v12 = 0;
  uint64_t result = sub_1CC48C528((uint64_t *)a2, a3, &v12);
  unsigned int v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CCBE1E8C(a2, (uint64_t)a3, a3, v12);
    unsigned int v9 = (void *)result;
    *(void *)uint64_t result = *a3;
    *(_DWORD *)(result + 8) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1CD6BD5A4(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CC137310(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      char v10 = v11;
      *uint64_t v11 = *(void *)a2;
      *((unsigned char *)v10 + 8) = *(unsigned char *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

uint64_t sub_1CD6BD654(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t v7 = *a2;
  *a2 = 0;
  *(void *)a1 = &unk_1F2631930;
  *(void *)(a1 + 8) = v7;
  uint64_t v8 = a1 + 88;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  if (*(unsigned char *)(v7 + 8)) {
    unsigned int v9 = 3;
  }
  else {
    unsigned int v9 = 2;
  }
  llvm::StringTableBuilder::StringTableBuilder(v8, v9, 1);
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = a3;
  *(_DWORD *)(a1 + 216) = a4;
  return a1;
}

llvm::raw_ostream *SPIRVObjectWriter::writeHeader(SPIRVObjectWriter *this, const llvm::MCAssembler *a2)
{
  int v3 = (llvm::raw_ostream *)*((void *)this + 1);
  if ((*((_DWORD *)this + 4) - 1) >= 2) {
    int v4 = 50471687;
  }
  else {
    int v4 = 119734787;
  }
  *(_DWORD *)int v12 = v4;
  llvm::raw_ostream::write(v3, v12, 4uLL);
  uint64_t v5 = (llvm::raw_ostream *)*((void *)this + 1);
  if ((*((_DWORD *)this + 4) - 1) >= 2) {
    int v6 = 256;
  }
  else {
    int v6 = 0x10000;
  }
  *(_DWORD *)int v12 = v6;
  llvm::raw_ostream::write(v5, v12, 4uLL);
  uint64_t v7 = (llvm::raw_ostream *)*((void *)this + 1);
  *(_DWORD *)int v12 = 0;
  llvm::raw_ostream::write(v7, v12, 4uLL);
  uint64_t v8 = (llvm::raw_ostream *)*((void *)this + 1);
  if ((*((_DWORD *)this + 4) - 1) >= 2) {
    int v9 = -2080178176;
  }
  else {
    int v9 = 900;
  }
  *(_DWORD *)int v12 = v9;
  llvm::raw_ostream::write(v8, v12, 4uLL);
  char v10 = (llvm::raw_ostream *)*((void *)this + 1);
  *(_DWORD *)int v12 = 0;
  return llvm::raw_ostream::write(v10, v12, 4uLL);
}

uint64_t SPIRVObjectWriter::writeObject(SPIRVObjectWriter *this, llvm::MCAssembler *a2, const llvm::MCAsmLayout *a3)
{
  int v6 = (void *)*((void *)this + 1);
  uint64_t v7 = (*(uint64_t (**)(void *))(*v6 + 80))(v6);
  uint64_t v8 = v6[4];
  uint64_t v9 = v6[2];
  SPIRVObjectWriter::writeHeader(this, v10);
  uint64_t v11 = (const llvm::MCSection **)*((void *)a2 + 4);
  int v12 = (const llvm::MCSection **)*((void *)a2 + 5);
  while (v11 != v12)
  {
    unsigned int v13 = *v11++;
    llvm::MCAssembler::writeSectionData(a2, *((llvm::raw_ostream **)this + 1), v13, a3);
  }
  unsigned int v14 = (void *)*((void *)this + 1);
  return v9 - v8 - v7 + (*(uint64_t (**)(void *))(*v14 + 80))(v14) + v14[4] - v14[2];
}

void llvm::createSPIRVObjectWriter()
{
}

void sub_1CD6BD93C(llvm::MCObjectWriter *this)
{
  *(void *)this = &unk_1F2631998;
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  llvm::MCObjectWriter::~MCObjectWriter(this);
}

void sub_1CD6BD9BC(llvm::MCObjectWriter *this)
{
  *(void *)this = &unk_1F2631998;
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  llvm::MCObjectWriter::~MCObjectWriter(this);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD6BDA58(uint64_t *a1, _OWORD *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CCBE38EC(a1, (uint64_t)a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CCBE3A20((uint64_t)a1, (uint64_t)a2, (uint64_t)a2, v7);
    *(_OWORD *)uint64_t v5 = *a2;
    *(void *)(v5 + 16) = 0;
  }
  return v5;
}

void llvm::SubtargetFeatures::Split(int64x2_t *a1, uint64_t a2, uint64_t a3)
{
  v14[6] = *MEMORY[0x1E4F143B8];
  v11[0] = a2;
  v11[1] = a3;
  int v12 = v14;
  uint64_t v13 = 0x300000000;
  llvm::StringRef::split((char *)v11, (uint64_t)&v12, 44, -1, 0);
  sub_1CCBE3DDC((unint64_t *)a1, v13);
  char v4 = (char *)v12;
  if (v13)
  {
    uint64_t v5 = (char *)v12 + 16 * v13;
    do
    {
      std::string::__init(&__p, *(const std::string::value_type **)v4, *((void *)v4 + 1));
      unint64_t v6 = a1->u64[1];
      if (v6 >= a1[1].i64[0])
      {
        uint64_t v8 = sub_1CBF4ECB4(a1, (uint64_t)&__p);
        int v9 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
        a1->i64[1] = (uint64_t)v8;
        if (v9 < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      else
      {
        long long v7 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        *(void *)(v6 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
        *(_OWORD *)unint64_t v6 = v7;
        a1->i64[1] = v6 + 24;
      }
      v4 += 16;
    }
    while (v4 != v5);
    char v4 = (char *)v12;
  }
  if (v4 != (char *)v14) {
    free(v4);
  }
}

void llvm::SubtargetFeatures::AddFeature(int64x2_t *a1, unsigned __int8 *a2, uint64_t a3, int a4)
{
  v16[0] = a2;
  v16[1] = a3;
  if (a3)
  {
    int v5 = *a2;
    if (v5 == 45 || v5 == 43)
    {
      llvm::StringRef::lower((llvm::StringRef *)v16, v14);
    }
    else
    {
      if (a4) {
        char v10 = "+";
      }
      else {
        char v10 = "-";
      }
      llvm::StringRef::lower((llvm::StringRef *)v16, &__p);
      uint64_t v11 = std::string::insert(&__p, 0, v10);
      std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
      *(_OWORD *)unsigned int v14 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
      std::string::size_type v15 = v12;
      v11->__r_.__value_.__l.__size_ = 0;
      v11->__r_.__value_.__r.__words[2] = 0;
      v11->__r_.__value_.__r.__words[0] = 0;
    }
    unint64_t v6 = a1->u64[1];
    if (v6 >= a1[1].i64[0])
    {
      uint64_t v8 = sub_1CBF4ECB4(a1, (uint64_t)v14);
      int v9 = SHIBYTE(v15);
      a1->i64[1] = (uint64_t)v8;
      if (v9 < 0) {
        operator delete(v14[0]);
      }
    }
    else
    {
      long long v7 = *(_OWORD *)v14;
      *(void *)(v6 + 16) = v15;
      *(_OWORD *)unint64_t v6 = v7;
      v14[1] = 0;
      std::string::size_type v15 = 0;
      v14[0] = 0;
      a1->i64[1] = v6 + 24;
    }
    if (v5 != 43 && v5 != 45 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

std::string *llvm::SubtargetFeatures::getString@<X0>(std::string **this@<X0>, std::string *a2@<X8>)
{
  return sub_1CD4FB688(*this, this[1], ",", 1uLL, a2);
}

llvm::raw_ostream *llvm::SubtargetFeatures::print(llvm::SubtargetFeatures *this, llvm::raw_ostream *a2)
{
  uint64_t v3 = *(void *)this;
  uint64_t v4 = *((void *)this + 1);
  if (*(void *)this != v4)
  {
    do
    {
      char v5 = *(unsigned char *)(v3 + 23);
      BOOL v6 = v5 < 0;
      if (v5 >= 0) {
        long long v7 = (const char *)v3;
      }
      else {
        long long v7 = *(const char **)v3;
      }
      size_t v8 = v5 & 0x7F;
      if (v6) {
        size_t v9 = *(void *)(v3 + 8);
      }
      else {
        size_t v9 = v8;
      }
      char v10 = llvm::raw_ostream::write(a2, v7, v9);
      sub_1CB8E509C(v10, " ");
      v3 += 24;
    }
    while (v3 != v4);
  }

  return sub_1CB8E509C(a2, "\n");
}

llvm::raw_ostream *llvm::SubtargetFeatures::dump(llvm::SubtargetFeatures *this)
{
  uint64_t v2 = llvm::dbgs(this);

  return llvm::SubtargetFeatures::print(this, v2);
}

void llvm::SubtargetFeatures::getDefaultSubtargetFeatures(int64x2_t *this, const llvm::Triple *a2)
{
  if (*((_DWORD *)a2 + 8) == 1)
  {
    int v3 = *((_DWORD *)a2 + 6);
    if (v3 != 21)
    {
      if (v3 != 23) {
        return;
      }
      llvm::SubtargetFeatures::AddFeature(this, "64bit", 5, 1);
    }
    llvm::SubtargetFeatures::AddFeature(this, "altivec", 7, 1);
  }
}

uint64_t *llvm::TargetRegistry::lookupTarget(std::string::size_type a1, uint64_t a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (qword_1EBD0A2D0)
  {
    __int16 v28 = 260;
    v27.__r_.__value_.__r.__words[0] = a1;
    llvm::Triple::Triple((llvm::Triple *)&__p, (const llvm::Twine *)&v27);
    uint64_t v3 = v25;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    uint64_t v4 = &qword_1EBD0A2D0;
    while (1)
    {
      uint64_t v4 = (uint64_t *)*v4;
      if (!v4) {
        break;
      }
      if (((unsigned int (*)(uint64_t))v4[1])(v3))
      {
        uint64_t v5 = *v4;
        if (!*v4) {
          return v4;
        }
        while (((*(uint64_t (**)(uint64_t))(v5 + 8))(v3) & 1) == 0)
        {
          uint64_t v5 = *(void *)v5;
          if (!v5) {
            return v4;
          }
        }
        v22.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
        *(_OWORD *)&v22.__r_.__value_.__r.__words[1] = xmmword_1CDB15B60;
        strcpy(v22.__r_.__value_.__l.__data_, "Cannot choose between targets \"");
        std::string::size_type v12 = std::string::append(&v22, (const std::string::value_type *)v4[2]);
        std::string::size_type v13 = v12->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v23.__r_.__value_.__l.__data_ = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
        v23.__r_.__value_.__r.__words[2] = v13;
        v12->__r_.__value_.__l.__size_ = 0;
        v12->__r_.__value_.__r.__words[2] = 0;
        v12->__r_.__value_.__r.__words[0] = 0;
        unsigned int v14 = std::string::append(&v23, "\" and \"");
        std::string::size_type v15 = v14->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v27.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
        v27.__r_.__value_.__r.__words[2] = v15;
        v14->__r_.__value_.__l.__size_ = 0;
        v14->__r_.__value_.__r.__words[2] = 0;
        v14->__r_.__value_.__r.__words[0] = 0;
        int v16 = std::string::append(&v27, *(const std::string::value_type **)(v5 + 16));
        std::string::size_type v17 = v16->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v17;
        v16->__r_.__value_.__l.__size_ = 0;
        v16->__r_.__value_.__r.__words[2] = 0;
        v16->__r_.__value_.__r.__words[0] = 0;
        uint64_t v18 = std::string::append(&__p, "\"");
        std::string::size_type v19 = v18->__r_.__value_.__r.__words[0];
        v26[0] = v18->__r_.__value_.__l.__size_;
        *(void *)((char *)v26 + 7) = *(std::string::size_type *)((char *)&v18->__r_.__value_.__r.__words[1] + 7);
        char v20 = HIBYTE(v18->__r_.__value_.__r.__words[2]);
        v18->__r_.__value_.__l.__size_ = 0;
        v18->__r_.__value_.__r.__words[2] = 0;
        v18->__r_.__value_.__r.__words[0] = 0;
        if (*(char *)(a2 + 23) < 0) {
          operator delete(*(void **)a2);
        }
        uint64_t v21 = v26[0];
        *(void *)a2 = v19;
        *(void *)(a2 + 8) = v21;
        *(void *)(a2 + 15) = *(void *)((char *)v26 + 7);
        *(unsigned char *)(a2 + 23) = v20;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v27.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v23.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
        {
          uint64_t v11 = (void *)v22.__r_.__value_.__r.__words[0];
          goto LABEL_18;
        }
        return 0;
      }
    }
    std::operator+<char>();
    BOOL v6 = std::string::append(&__p, "\"");
    std::string::size_type v7 = v6->__r_.__value_.__r.__words[0];
    v27.__r_.__value_.__r.__words[0] = v6->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v27.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v6->__r_.__value_.__r.__words[1] + 7);
    char v8 = HIBYTE(v6->__r_.__value_.__r.__words[2]);
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    if (*(char *)(a2 + 23) < 0) {
      operator delete(*(void **)a2);
    }
    std::string::size_type v9 = v27.__r_.__value_.__r.__words[0];
    *(void *)a2 = v7;
    *(void *)(a2 + 8) = v9;
    *(void *)(a2 + 15) = *(std::string::size_type *)((char *)v27.__r_.__value_.__r.__words + 7);
    *(unsigned char *)(a2 + 23) = v8;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      uint64_t v11 = (void *)__p.__r_.__value_.__r.__words[0];
LABEL_18:
      operator delete(v11);
    }
  }
  else
  {
    MEMORY[0x1D25D9630](a2, "Unable to find target for this triple (no targets are registered)");
  }
  return 0;
}

uint64_t llvm::TargetRegistry::RegisterTarget(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  if (!*(void *)(result + 16))
  {
    uint64_t v6 = qword_1EBD0A2D0;
    qword_1EBD0A2D0 = result;
    *(void *)(result + 16) = a2;
    *(void *)(result + 24) = a3;
    *(void *)(result + 32) = a4;
    *(void *)uint64_t result = v6;
    *(void *)(result + 8) = a5;
    *(unsigned char *)(result + 40) = a6;
  }
  return result;
}

void llvm::TargetRegistry::printRegisteredTargetsForVersion(llvm::TargetRegistry *this, llvm::raw_ostream *a2)
{
  __base = 0;
  char v20 = 0;
  unint64_t v21 = 0;
  uint64_t v3 = (char *)qword_1EBD0A2D0;
  if (qword_1EBD0A2D0)
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    do
    {
      uint64_t v6 = (const char *)*((void *)v3 + 2);
      *(void *)&long long v17 = v6;
      if (v6) {
        uint64_t v6 = (const char *)strlen(v6);
      }
      *((void *)&v17 + 1) = v6;
      uint64_t v18 = v3;
      if ((unint64_t)v4 >= v21)
      {
        uint64_t v4 = sub_1CBF56DE8(&__base, (uint64_t)&v17);
      }
      else
      {
        long long v7 = v17;
        *((void *)v4 + 2) = v18;
        *(_OWORD *)uint64_t v4 = v7;
        v4 += 24;
      }
      char v20 = v4;
      if (v5 <= *((void *)v4 - 2)) {
        unint64_t v5 = *((void *)v4 - 2);
      }
      uint64_t v3 = *(char **)v3;
    }
    while (v3);
    uint64_t v3 = (char *)__base;
  }
  else
  {
    uint64_t v4 = 0;
    LODWORD(v5) = 0;
  }
  if (v4 - v3 >= 48) {
    qsort(v3, (v4 - v3) / 0x18uLL, 0x18uLL, (int (__cdecl *)(const void *, const void *))sub_1CCBE419C);
  }
  sub_1CB8E509C(this, "  Registered Targets:\n");
  if (v3 == v4)
  {
    sub_1CB8E509C(this, "    (none)\n");
  }
  else
  {
    char v8 = v3;
    do
    {
      std::string::size_type v9 = sub_1CB8E509C(this, "    ");
      char v10 = *(const void **)v8;
      unint64_t v11 = *((void *)v8 + 1);
      std::string::size_type v12 = (void *)*((void *)v9 + 4);
      if (v11 <= *((void *)v9 + 3) - (void)v12)
      {
        if (v11)
        {
          memcpy(v12, v10, *((void *)v8 + 1));
          *((void *)v9 + 4) += v11;
        }
      }
      else
      {
        llvm::raw_ostream::write(v9, (const char *)v10, *((void *)v8 + 1));
      }
      std::string::size_type v13 = llvm::raw_ostream::indent(this, (int)v5 - *((_DWORD *)v8 + 2));
      unsigned int v14 = sub_1CB8E509C(v13, " - ");
      std::string::size_type v15 = sub_1CB8E509C(v14, *(char **)(*((void *)v8 + 2) + 24));
      int v16 = (unsigned char *)*((void *)v15 + 4);
      if ((unint64_t)v16 >= *((void *)v15 + 3))
      {
        llvm::raw_ostream::write(v15, 10);
      }
      else
      {
        *((void *)v15 + 4) = v16 + 1;
        *int v16 = 10;
      }
      v8 += 24;
    }
    while (v8 != v4);
  }
  if (v3)
  {
    operator delete(v3);
  }
}

void llvm::createWasmObjectWriter()
{
}

void llvm::createWasmDwoObjectWriter()
{
}

void sub_1CD6BE58C(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = 0;
  v4[0] = &v5;
  v4[1] = (void *)0x100000000;
  uint64_t v6 = v8;
  uint64_t v7 = 0x400000000;
  void v8[4] = 1;
  uint64_t v1 = *(unsigned int *)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = *(void *)a1;
    uint64_t v3 = 72 * v1;
    do
    {
      uint64_t v2 = sub_1CD6BE664(v2, v4) + 72;
      v3 -= 72;
    }
    while (v3);
    if (v6 != v8) {
      free(v6);
    }
  }
  if (v4[0] != &v5) {
    free(v4[0]);
  }
}

uint64_t sub_1CD6BE664(uint64_t a1, _DWORD *a2)
{
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x100000000;
  if (a2[2]) {
    sub_1CD59F0BC(a1, (uint64_t)a2);
  }
  *(void *)(a1 + 24) = a1 + 40;
  *(void *)(a1 + 32) = 0x400000000;
  if (a2[8]) {
    sub_1CD59F0BC(a1 + 24, (uint64_t)(a2 + 6));
  }
  *(_DWORD *)(a1 + 56) = a2[14];
  return a1;
}

char **sub_1CD6BE6EC(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = v3 << 6;
    do
    {
      uint64_t v5 = &v2[v4];
      uint64_t v6 = *(char **)&v2[v4 - 40];
      if (&v2[v4 - 24] != v6) {
        free(v6);
      }
      uint64_t v7 = (char *)*((void *)v5 - 8);
      if (v5 - 48 != v7) {
        free(v7);
      }
      v4 -= 64;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

void sub_1CD6BE774(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(unsigned int *)(a1 + 16);
  if (v1)
  {
    uint64_t v7 = &v9;
    uint64_t v8 = 0x100000000;
    char v10 = v12;
    uint64_t v11 = 0x400000000;
    char v12[4] = 1;
    uint64_t v2 = 72 * v1;
    uint64_t v3 = *(void *)a1 + 40;
    int v6 = 2;
    do
    {
      uint64_t v4 = *(void **)(v3 - 16);
      if ((void *)v3 != v4) {
        free(v4);
      }
      uint64_t v5 = *(void **)(v3 - 40);
      if ((void *)(v3 - 24) != v5) {
        free(v5);
      }
      v3 += 72;
      v2 -= 72;
    }
    while (v2);
    if (v10 != v12) {
      free(v10);
    }
    if (v7 != &v9) {
      free(v7);
    }
  }
}

BOOL sub_1CD6BE8B4(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 56) != *(_DWORD *)(a2 + 56)) {
    return 0;
  }
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2 != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  if (v2)
  {
    uint64_t v3 = *(_DWORD **)a1;
    uint64_t v4 = *(_DWORD **)a2;
    uint64_t v5 = 4 * v2;
    while (*v3 == *v4)
    {
      ++v3;
      ++v4;
      v5 -= 4;
      if (!v5) {
        goto LABEL_7;
      }
    }
    return 0;
  }
LABEL_7:
  uint64_t v6 = *(unsigned int *)(a1 + 32);
  if (v6 != *(_DWORD *)(a2 + 32)) {
    return 0;
  }
  if (!v6) {
    return 1;
  }
  uint64_t v7 = *(int **)(a1 + 24);
  uint64_t v8 = *(int **)(a2 + 24);
  uint64_t v9 = 4 * v6 - 4;
  do
  {
    int v11 = *v7++;
    int v10 = v11;
    int v12 = *v8++;
    BOOL result = v10 == v12;
    BOOL v14 = v10 != v12 || v9 == 0;
    v9 -= 4;
  }
  while (!v14);
  return result;
}

void sub_1CD6BE958(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 || *(_DWORD *)(a1 + 12))
  {
    uint64_t v3 = *(unsigned int *)(a1 + 16);
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      sub_1CD6BEB88(a1);
    }
    else
    {
      v6[0] = &v7;
      v6[1] = (void *)0x100000000;
      v8[0] = v9;
      v8[1] = (void *)0x400000000;
      int v10 = 1;
      if (v3)
      {
        uint64_t v4 = *(void *)a1;
        uint64_t v5 = 72 * v3;
        do
        {
          sub_1CD59F0BC(v4, (uint64_t)v6);
          sub_1CD59F0BC(v4 + 24, (uint64_t)v8);
          *(_DWORD *)(v4 + 56) = v10;
          v4 += 72;
          v5 -= 72;
        }
        while (v5);
        *(void *)(a1 + 8) = 0;
      }
      else
      {
        *(void *)(a1 + 8) = 0;
      }
      if (v8[0] != v9) {
        free(v8[0]);
      }
      if (v6[0] != &v7) {
        free(v6[0]);
      }
    }
  }
}

void sub_1CD6BEB18(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 2);
  if (v2)
  {
    uint64_t v3 = *a1;
    uint64_t v4 = v2 << 6;
    do
    {
      uint64_t v5 = v3 + v4;
      uint64_t v6 = *(void **)(v3 + v4 - 40);
      if ((void *)(v3 + v4 - 24) != v6) {
        free(v6);
      }
      uint64_t v7 = *(void **)(v5 - 64);
      if ((void *)(v5 - 48) != v7) {
        free(v7);
      }
      v4 -= 64;
    }
    while (v4);
  }
  *((_DWORD *)a1 + 2) = 0;
}

void sub_1CD6BEB88(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 8);
  sub_1CD6BE774(a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    int v4 = v3;
  }
  else {
    int v4 = 0;
  }
  if (v4 == *(_DWORD *)(a1 + 16))
  {
    sub_1CD6BE58C(a1);
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CCBE5408(a1, v4);
  }
}

uint64_t sub_1CD6BEC2C(uint64_t result, void *a2, void *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    uint64_t v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *uint64_t v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      int v10 = 0;
      BOOL result = sub_1CCBE5534((uint64_t *)v5, a2, &v10);
      uint64_t v9 = v10;
      *int v10 = *a2;
      v9[1] = a2[1];
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 2;
  }
  return result;
}

unint64_t sub_1CD6BECDC(unint64_t result, long long *a2)
{
  unint64_t v2 = result;
  unsigned int v3 = *(_DWORD *)(result + 8);
  if (v3 >= *(_DWORD *)(result + 12))
  {
    long long v11 = a2[5];
    uint64_t v21[4] = a2[4];
    v21[5] = v11;
    v21[6] = a2[6];
    uint64_t v22 = *((void *)a2 + 14);
    long long v12 = a2[1];
    v21[0] = *a2;
    v21[1] = v12;
    long long v13 = a2[3];
    v21[2] = a2[2];
    void v21[3] = v13;
    BOOL result = sub_1CD59F204(result, (unint64_t)v21);
    uint64_t v14 = *(void *)v2 + 120 * *(unsigned int *)(v2 + 8);
    long long v16 = *(_OWORD *)(result + 80);
    long long v15 = *(_OWORD *)(result + 96);
    long long v17 = *(_OWORD *)(result + 64);
    *(void *)(v14 + 112) = *(void *)(result + 112);
    *(_OWORD *)(v14 + 80) = v16;
    *(_OWORD *)(v14 + 96) = v15;
    *(_OWORD *)(v14 + 64) = v17;
    long long v18 = *(_OWORD *)result;
    long long v19 = *(_OWORD *)(result + 16);
    long long v20 = *(_OWORD *)(result + 48);
    *(_OWORD *)(v14 + 32) = *(_OWORD *)(result + 32);
    *(_OWORD *)(v14 + 48) = v20;
    *(_OWORD *)uint64_t v14 = v18;
    *(_OWORD *)(v14 + 16) = v19;
  }
  else
  {
    uint64_t v4 = *(void *)result + 120 * v3;
    long long v5 = *a2;
    long long v6 = a2[1];
    long long v7 = a2[3];
    *(_OWORD *)(v4 + 32) = a2[2];
    *(_OWORD *)(v4 + 48) = v7;
    *(_OWORD *)uint64_t v4 = v5;
    *(_OWORD *)(v4 + 16) = v6;
    long long v8 = a2[4];
    long long v9 = a2[5];
    long long v10 = a2[6];
    *(void *)(v4 + 112) = *((void *)a2 + 14);
    *(_OWORD *)(v4 + 80) = v9;
    *(_OWORD *)(v4 + 96) = v10;
    *(_OWORD *)(v4 + 64) = v8;
  }
  ++*(_DWORD *)(v2 + 8);
  return result;
}

uint64_t sub_1CD6BEDC0(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  unint64_t v4 = *(void *)a1;
  if (v3 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v6 = v4 + (v3 << 6);
    if (v4 > (unint64_t)a2 || v6 <= (unint64_t)a2) {
      sub_1CD6BF714();
    }
    sub_1CD6BF714();
  }
  uint64_t result = sub_1CD6BE664(v4 + ((unint64_t)*(unsigned int *)(a1 + 8) << 6), a2);
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1CD6BEE4C(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CD6BEF08(*(void *)a2, *(_DWORD *)(a2 + 16), a3, &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t v9 = sub_1CD6BF2DC(a2, a3, v12);
    sub_1CD41B598(v9, a3);
    uint64_t result = sub_1CD41B598(v9 + 24, a3 + 24);
    *(_DWORD *)(v9 + 56) = *(_DWORD *)(a3 + 56);
    *(_DWORD *)(v9 + 64) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 72 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1CD6BEF08(uint64_t a1, int a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    v21[0] = &v22;
    v21[1] = (void *)0x100000000;
    std::string v23 = v25;
    uint64_t v24 = 0x400000000;
    uint64_t v5 = 1;
    uint64_t v25[4] = 1;
    v16[0] = &v17;
    v16[1] = (void *)0x100000000;
    long long v18 = v20;
    uint64_t v19 = 0x400000000;
    char v20[4] = 2;
    int v9 = a2 - 1;
    unsigned int v10 = sub_1CD6BF0F4(a3) & (a2 - 1);
    uint64_t v11 = a1 + 72 * v10;
    if (!sub_1CD6BE8B4(a3, v11))
    {
      uint64_t v15 = 0;
      int v14 = 1;
      while (!sub_1CD6BE8B4(v11, (uint64_t)v21))
      {
        BOOL v12 = sub_1CD6BE8B4(v11, (uint64_t)v16);
        uint64_t v13 = v15;
        if (v12 && v15 == 0) {
          uint64_t v13 = v11;
        }
        uint64_t v15 = v13;
        unsigned int v10 = (v10 + v14) & v9;
        uint64_t v11 = a1 + 72 * v10;
        ++v14;
        if (sub_1CD6BE8B4(a3, v11)) {
          goto LABEL_5;
        }
      }
      uint64_t v5 = 0;
      if (v15) {
        uint64_t v11 = v15;
      }
    }
LABEL_5:
    *a4 = v11;
    if (v18 != v20) {
      free(v18);
    }
    if (v16[0] != &v17) {
      free(v16[0]);
    }
    if (v23 != v25) {
      free(v23);
    }
    if (v21[0] != &v22) {
      free(v21[0]);
    }
  }
  else
  {
    uint64_t v5 = 0;
    *a4 = 0;
  }
  return v5;
}

unint64_t sub_1CD6BF0F4(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 56);
  uint64_t v3 = sub_1CBF65470();
  unint64_t v4 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v3 + 8 * v2)) ^ ((0x9DDFEA08EB382D69 * (v3 + 8 * v2)) >> 47));
  unint64_t result = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  unint64_t v15 = result;
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  if (v6)
  {
    long long v7 = *(int **)a1;
    uint64_t v8 = 4 * v6;
    do
    {
      int v9 = *v7++;
      int v14 = v9;
      unint64_t result = sub_1CD6BF1B8((uint64_t *)&v15, &v14);
      unint64_t v15 = result;
      v8 -= 4;
    }
    while (v8);
  }
  uint64_t v10 = *(unsigned int *)(a1 + 32);
  if (v10)
  {
    uint64_t v11 = *(int **)(a1 + 24);
    uint64_t v12 = 4 * v10;
    do
    {
      int v13 = *v11++;
      int v14 = v13;
      unint64_t result = sub_1CD6BF1B8((uint64_t *)&v15, &v14);
      unint64_t v15 = result;
      v12 -= 4;
    }
    while (v12);
  }
  return result;
}

unint64_t sub_1CD6BF1B8(uint64_t *a1, int *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  memset(v5, 0, sizeof(v5));
  uint64_t v8 = sub_1CBF65470();
  return sub_1CD6BF258(v5, v5, (char *)v6, *a1, a2);
}

unint64_t sub_1CD6BF258(void *a1, void *__dst, char *a3, uint64_t a4, int *a5)
{
  uint64_t v11 = 0;
  uint64_t v8 = sub_1CBFFCBA0(a1, &v11, __dst, (unint64_t)a3, a4);
  uint64_t v12 = v11;
  uint64_t v9 = (char *)sub_1CC0AC9D0(a1, &v12, v8, (unint64_t)a3, *a5);
  return sub_1CC36B0E4((uint64_t)a1, v12, v9, a3);
}

uint64_t sub_1CD6BF2DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD6BF400(a1, v6);
  v9[0] = 0;
  sub_1CD6BEF08(*(void *)a1, *(_DWORD *)(a1 + 16), a2, v9);
  a3 = v9[0];
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  v9[0] = (uint64_t)v10;
  v9[1] = 0x100000000;
  v10[1] = v11;
  uint64_t v10[2] = 0x400000000;
  _DWORD v11[4] = 1;
  if (!sub_1CD6BE8B4(a3, (uint64_t)v9)) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void sub_1CD6BF400(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  *(void *)a1 = operator new(72 * v8, (std::align_val_t)8uLL);
  if (v4)
  {
    sub_1CD6BF4C8(a1, v4, v4 + 72 * v3);
    JUMPOUT(0x1D25D9CD0);
  }

  sub_1CD6BE58C(a1);
}

void sub_1CD6BF4C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  sub_1CD6BE58C(a1);
  v14[0] = &v15;
  v14[1] = (void *)0x100000000;
  long long v16 = v18;
  uint64_t v17 = 0x400000000;
  void v18[4] = 1;
  v9[0] = &v10;
  v9[1] = (void *)0x100000000;
  uint64_t v11 = v13;
  uint64_t v12 = 0x400000000;
  void v13[4] = 2;
  if (a2 != a3)
  {
    do
    {
      if (!sub_1CD6BE8B4(a2, (uint64_t)v14) && !sub_1CD6BE8B4(a2, (uint64_t)v9))
      {
        uint64_t v8 = 0;
        sub_1CD6BEF08(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v8);
        uint64_t v7 = v8;
        sub_1CD41B598(v8, a2);
        sub_1CD41B598(v7 + 24, a2 + 24);
        *(_DWORD *)(v7 + 56) = *(_DWORD *)(a2 + 56);
        *(_DWORD *)(v7 + 64) = *(_DWORD *)(a2 + 64);
        ++*(_DWORD *)(a1 + 8);
      }
      unint64_t v6 = *(void **)(a2 + 24);
      if ((void *)(a2 + 40) != v6) {
        free(v6);
      }
      if (a2 + 16 != *(void *)a2) {
        free(*(void **)a2);
      }
      a2 += 72;
    }
    while (a2 != a3);
    if (v11 != v13) {
      free(v11);
    }
  }
  if (v9[0] != &v10) {
    free(v9[0]);
  }
  if (v16 != v18) {
    free(v16);
  }
  if (v14[0] != &v15) {
    free(v14[0]);
  }
}

uint64_t sub_1CD6BF68C(uint64_t a1, _DWORD *a2)
{
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x100000000;
  if (a2[2]) {
    sub_1CD41B598(a1, (uint64_t)a2);
  }
  *(void *)(a1 + 24) = a1 + 40;
  *(void *)(a1 + 32) = 0x400000000;
  if (a2[8]) {
    sub_1CD41B598(a1 + 24, (uint64_t)(a2 + 6));
  }
  *(_DWORD *)(a1 + 56) = a2[14];
  return a1;
}

void sub_1CD6BF714()
{
}

void sub_1CD6BF784(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2)
  {
    unint64_t v5 = *(_DWORD **)a1;
    uint64_t v6 = v2 << 6;
    do
    {
      sub_1CD6BF68C(a2, v5);
      v5 += 16;
      a2 += 64;
      v6 -= 64;
    }
    while (v6);
    uint64_t v7 = *(unsigned int *)(a1 + 8);
    if (v7)
    {
      uint64_t v8 = *(_DWORD **)a1;
      uint64_t v9 = v7 << 6;
      do
      {
        uint64_t v10 = (char *)v8 + v9;
        uint64_t v11 = *(char **)((char *)v8 + v9 - 40);
        if ((char *)v8 + v9 - 24 != v11) {
          free(v11);
        }
        uint64_t v12 = (char *)*((void *)v10 - 8);
        if (v10 - 48 != v12) {
          free(v12);
        }
        v9 -= 64;
      }
      while (v9);
    }
  }
}

void llvm::createWinCOFFObjectWriter()
{
}

void llvm::createXCOFFObjectWriter()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

uint64_t *sub_1CD6BFBEC(uint64_t *result, unsigned int a2, int a3)
{
  uint64_t v3 = 1 << a2;
  if (a3)
  {
    if (*((_DWORD *)result + 2) <= 0x40u)
    {
      uint64_t v4 = *result | v3;
LABEL_6:
      llvm::MCSection *result = v4;
      return result;
    }
    uint64_t v6 = *result;
    unsigned int v7 = a2 >> 6;
    uint64_t v8 = *(void *)(*result + 8 * (a2 >> 6)) | v3;
  }
  else
  {
    uint64_t v5 = ~v3;
    if (*((_DWORD *)result + 2) <= 0x40u)
    {
      uint64_t v4 = *result & v5;
      goto LABEL_6;
    }
    uint64_t v6 = *result;
    unsigned int v7 = a2 >> 6;
    uint64_t v8 = *(void *)(*result + 8 * (a2 >> 6)) & v5;
  }
  *(void *)(v6 + 8 * v7) = v8;
  return result;
}

uint64_t llvm::objcarc::createCallInstWithColors(uint64_t **a1, uint64_t **a2, uint64_t *a3, uint64_t a4, const char **a5, uint64_t a6, uint64_t a7)
{
  v34[6] = *MEMORY[0x1E4F143B8];
  char v32 = v34;
  uint64_t v33 = 0x100000000;
  if (*(_DWORD *)(a7 + 8))
  {
    uint64_t v21 = *(void *)(a6 + 40);
    uint64_t v30 = 0;
    uint64_t FirstNonPHI = v21;
    int v22 = sub_1CD3C8538((uint64_t *)a7, &FirstNonPHI, &v30);
    uint64_t v23 = v30;
    if (!v22) {
      uint64_t v23 = *(void *)a7 + 16 * *(unsigned int *)(a7 + 16);
    }
    uint64_t v24 = *(void *)(v23 + 8);
    unsigned int v25 = (llvm::BasicBlock *)(v24 & 0xFFFFFFFFFFFFFFF8);
    if ((v24 & 4) != 0) {
      unsigned int v25 = **(llvm::BasicBlock ***)v25;
    }
    uint64_t FirstNonPHI = llvm::BasicBlock::getFirstNonPHI(v25);
    unsigned int v26 = *(unsigned __int8 *)(FirstNonPHI + 16) - 38;
    BOOL v27 = v26 > 0x38;
    uint64_t v28 = (1 << v26) & 0x100060000000001;
    if (!v27 && v28 != 0) {
      sub_1CD697EF8((uint64_t *)&v32, "funclet", &FirstNonPHI);
    }
    int v14 = v32;
    uint64_t v13 = v33;
  }
  else
  {
    uint64_t v13 = 0;
    int v14 = v34;
  }
  uint64_t v15 = sub_1CC19A3E0(a1, a2, a3, a4, (uint64_t)v14, v13, a5, a6);
  long long v16 = v32;
  if (v33)
  {
    uint64_t v17 = 48 * v33;
    long long v18 = (char *)v32 - 48;
    do
    {
      sub_1CD4AF9B4((uint64_t)&v18[v17]);
      v17 -= 48;
    }
    while (v17);
    long long v16 = v32;
  }
  if (v16 != v34) {
    free(v16);
  }
  return v15;
}

const char *llvm::objcarc::BundledRetainClaimRVs::insertRVCall(llvm::objcarc::BundledRetainClaimRVs *this, uint64_t **a2, llvm::CallBase *a3)
{
  v5[0] = 0;
  v5[1] = 0;
  int v6 = 0;
  inserted = llvm::objcarc::BundledRetainClaimRVs::insertRVCallWithColors((uint64_t)this, a2, (char *)a3, (uint64_t)v5);
  sub_1CC0CADD4(v5);
  return inserted;
}

const char *llvm::objcarc::BundledRetainClaimRVs::insertRVCallWithColors(uint64_t a1, uint64_t **a2, char *a3, uint64_t a4)
{
  v18[15] = *MEMORY[0x1E4F143B8];
  sub_1CC243A10((uint64_t)v17, a2, 0, 0, 0);
  sub_1CC233A58(a3, 6, (uint64_t *)v13);
  uint64_t v8 = 0;
  if (v14) {
    uint64_t v8 = *(void *)v13[0];
  }
  if (*(_WORD *)(v8 + 18)) {
    llvm::Function::BuildLazyArguments((llvm::Function *)v8);
  }
  uint64_t v9 = **(void **)(v8 + 88);
  __int16 v15 = 257;
  long long v16 = sub_1CB84580C((uint64_t)v17, 49, (uint64_t)a3, v9, (uint64_t)v13);
  if (v8) {
    uint64_t v10 = *(uint64_t ***)(v8 + 24);
  }
  else {
    uint64_t v10 = 0;
  }
  __int16 v15 = 257;
  v13[0] = (const char *)llvm::objcarc::createCallInstWithColors(v10, (uint64_t **)v8, (uint64_t *)&v16, 1, v13, (uint64_t)a2, a4);
  sub_1CD467E2C(a1, (uint64_t *)v13)[1] = a3;
  uint64_t v11 = v13[0];
  if (v17[0] != v18) {
    free(v17[0]);
  }
  return v11;
}

void llvm::objcarc::BundledRetainClaimRVs::~BundledRetainClaimRVs(uint64_t **this)
{
  uint64_t v2 = *((unsigned int *)this + 4);
  if (*((_DWORD *)this + 2))
  {
    if (v2)
    {
      uint64_t v17 = 16 * v2;
      uint64_t v3 = *this;
      while ((*v3 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v3 += 2;
        v17 -= 16;
        if (!v17) {
          goto LABEL_2;
        }
      }
    }
    else
    {
      uint64_t v3 = *this;
    }
  }
  else
  {
LABEL_2:
    uint64_t v3 = &(*this)[2 * v2];
  }
  if (v3 != &(*this)[2 * v2])
  {
    uint64_t v4 = *v3;
    if (*((unsigned char *)this + 32))
    {
      uint64_t v5 = v3[1];
      if (*(unsigned char *)(v5 + 16) == 84 && v5 != 0) {
        *(_WORD *)(v5 + 18) |= 3u;
      }
      if (*((unsigned char *)this + 33))
      {
        uint64_t v7 = sub_1CC5CB4FC(v5);
        if ((unsigned int *)v7 != v8)
        {
          uint64_t v9 = (unsigned int *)v7;
          uint64_t v10 = v8;
          while (1)
          {
            if (*(_DWORD *)(*(void *)v9 + 8) == 6)
            {
              uint64_t v11 = v9[2];
              uint64_t v12 = *(void *)(v5 - 32 * (*(_DWORD *)(v5 + 20) & 0x7FFFFFF) + 32 * v11);
              uint64_t v13 = this[3];
              uint64_t Declaration = v13[7];
              if (!Declaration)
              {
                uint64_t Declaration = llvm::Intrinsic::getDeclaration((uint64_t **)*v13, 226, 0, 0);
                unint64_t v13[7] = Declaration;
              }
              if (v12 == Declaration) {
                break;
              }
            }
            v9 += 4;
            if (v9 == v10) {
              goto LABEL_18;
            }
          }
          __int16 v15 = this[3];
          uint64_t v16 = v15[8];
          if (!v16)
          {
            uint64_t v16 = llvm::Intrinsic::getDeclaration((uint64_t **)*v15, 212, 0, 0);
            v15[8] = v16;
          }
          LLVMSetArgOperand_0(v5, v11, v16);
        }
      }
    }
LABEL_18:
    if (*(void *)(v4 + 8))
    {
      llvm::Value::replaceAllUsesWith((llvm::Value *)v4, *(llvm::Value **)(v4 - 32 * (*(_DWORD *)(v4 + 20) & 0x7FFFFFF)));
      llvm::Instruction::eraseFromParent((llvm::Instruction *)v4);
    }
    llvm::Instruction::eraseFromParent((llvm::Instruction *)v4);
  }
  sub_1CD3C7F68(this);
  MEMORY[0x1D25D9CD0](*this, 8);
}

void llvm::createObjCARCOptPass(llvm *this)
{
}

void llvm::ObjCARCOptPass::run(uint64_t a1, uint64_t a2)
{
  LOBYTE(v5) = 0;
  BYTE4(v5) = 0;
  LOBYTE(v6) = 0;
  BYTE4(v6) = 0;
  LOBYTE(v7) = 0;
  BYTE4(v7) = 0;
  uint64_t v8 = 0;
  char v9 = 0;
  memset(v3, 0, sizeof(v3));
  if (llvm::objcarc::EnableARCOpts)
  {
    uint64_t v2 = *(void *)(a2 + 40);
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v5 = 0;
    *(void *)&v3[0] = v2;
    *(_OWORD *)((char *)v3 + 8) = 0uLL;
    *(_OWORD *)((char *)&v3[1] + 8) = 0uLL;
    *(_OWORD *)((char *)&v3[2] + 8) = 0uLL;
    *(_OWORD *)((char *)&v3[3] + 8) = 0uLL;
    *(_OWORD *)((char *)&v3[4] + 8) = 0uLL;
    *((void *)&v3[5] + 1) = 0;
    uint64_t v4 = v2;
  }
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

llvm::ValueHandleBase *sub_1CD6C03F0(llvm::ValueHandleBase *result)
{
  uint64_t v1 = result;
  int v2 = *((_DWORD *)result + 2);
  if (!v2 && !*((_DWORD *)result + 3)) {
    return result;
  }
  uint64_t v3 = *((unsigned int *)result + 4);
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_11:
      *((void *)v1 + 1) = 0;
      return result;
    }
    uint64_t v4 = 56 * v3;
    unint64_t result = (llvm::ValueHandleBase *)(*(void *)result + 8);
    while (1)
    {
      uint64_t v5 = *((void *)result - 1);
      if (v5 == -8192) {
        goto LABEL_9;
      }
      if (v5 != -4096) {
        break;
      }
LABEL_10:
      unint64_t result = (llvm::ValueHandleBase *)((char *)result + 56);
      v4 -= 56;
      if (!v4) {
        goto LABEL_11;
      }
    }
    unint64_t result = sub_1CD4A76CC(result);
LABEL_9:
    *((void *)result - 1) = -4096;
    goto LABEL_10;
  }

  return sub_1CD6C04A8(result);
}

llvm::ValueHandleBase *sub_1CD6C04A8(llvm::ValueHandleBase *result)
{
  uint64_t v1 = result;
  uint64_t v2 = *((unsigned int *)result + 4);
  int v3 = *((_DWORD *)result + 2);
  if (v2)
  {
    uint64_t v4 = 56 * v2;
    unint64_t result = (llvm::ValueHandleBase *)(*(void *)result + 8);
    do
    {
      if ((*((void *)result - 1) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        unint64_t result = sub_1CD4A76CC(result);
      }
      unint64_t result = (llvm::ValueHandleBase *)((char *)result + 56);
      v4 -= 56;
    }
    while (v4);
  }
  int v5 = 1 << (33 - __clz(v3 - 1));
  if (v5 <= 64) {
    int v5 = 64;
  }
  if (v3) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v6 == *((_DWORD *)v1 + 4))
  {
    *((void *)v1 + 1) = 0;
    if (v6)
    {
      uint64_t v7 = *(void **)v1;
      uint64_t v8 = 56 * v6;
      do
      {
        *uint64_t v7 = -4096;
        v7 += 7;
        v8 -= 56;
      }
      while (v8);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)v1, 8);
    return (llvm::ValueHandleBase *)sub_1CBF7A0E8(v1, v6);
  }
  return result;
}

uint64_t sub_1CD6C05A4(uint64_t a1)
{
  int v3 = (void **)(a1 + 24);
  sub_1CCC0FDAC(&v3);
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);
  return a1;
}

void *sub_1CD6C05EC(void *a1)
{
  uint64_t v2 = (void *)a1[9];
  if (v2 != (void *)a1[8]) {
    free(v2);
  }
  int v3 = (void *)a1[3];
  if (v3 != (void *)a1[2]) {
    free(v3);
  }
  return a1;
}

uint64_t sub_1CD6C0634(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    sub_1CBFCBCC4(a1, a2);
    sub_1CCC10048(a1 + 24, *(void *)(a2 + 24), *(void *)(a2 + 32), 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 3));
  }
  return a1;
}

void sub_1CD6C068C(void **a1)
{
  uint64_t v1 = (char *)*a1;
  if (*a1)
  {
    int v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        int v5 = v3 - 136;
        sub_1CD6C05EC((void *)v3 - 15);
        int v3 = v5;
      }
      while (v5 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_1CD6C06F8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  if (a2 != a1)
  {
    llvm::SmallPtrSetImplBase::CopyFrom((llvm::SmallPtrSetImplBase *)(a1 + 16), (const llvm::SmallPtrSetImplBase *)(a2 + 16));
    llvm::SmallPtrSetImplBase::CopyFrom((llvm::SmallPtrSetImplBase *)(a1 + 64), (const llvm::SmallPtrSetImplBase *)(a2 + 64));
  }
  *(unsigned char *)(a1 + 112) = *(unsigned char *)(a2 + 112);
  return a1;
}

uint64_t sub_1CD6C0750(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = *a2;
  uint64_t v8 = 0;
  sub_1CD481EB8((uint64_t)&v9, a1, &v7, &v8);
  uint64_t v4 = (uint64_t *)(a1 + 24);
  if (!v10) {
    return *v4 + 136 * *(void *)(v9 + 8);
  }
  uint64_t v5 = *(void *)(a1 + 32) - *(void *)(a1 + 24);
  *(void *)(v9 + 8) = 0xF0F0F0F0F0F0F0F1 * (v5 >> 3);
  sub_1CCC10400(v4, (uint64_t)a2);
  return *(void *)(a1 + 24) + v5;
}

uint64_t sub_1CD6C0800(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  if (sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v7))
  {
    uint64_t v3 = v7;
    uint64_t v4 = *(void *)a1;
    uint64_t v5 = *(unsigned int *)(a1 + 16);
  }
  else
  {
    uint64_t v4 = *(void *)a1;
    uint64_t v5 = *(unsigned int *)(a1 + 16);
    uint64_t v3 = *(void *)a1 + 16 * v5;
  }
  if (v3 == v4 + 16 * v5) {
    return *(void *)(a1 + 32);
  }
  else {
    return *(void *)(a1 + 24) + 136 * *(void *)(v3 + 8);
  }
}

uint64_t sub_1CD6C0884(uint64_t a1, uint64_t *a2)
{
  uint64_t v14 = *a2;
  v15[0] = 0;
  sub_1CD6C0B48((uint64_t)&v26, a1, &v14, v15);
  uint64_t v4 = (void **)(a1 + 24);
  if (v27)
  {
    uint64_t v5 = (uint64_t)(*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 7;
    *(void *)(v26 + 8) = v5;
    long long v11 = 0u;
    long long v12 = 0u;
    long long v8 = 0u;
    uint64_t v9 = &v12;
    char v10 = &v12;
    uint64_t v6 = *a2;
    uint64_t v13 = 0;
    uint64_t v14 = v6;
    v15[0] = 0;
    v15[1] = 0;
    uint64_t v16 = v20;
    uint64_t v17 = v20;
    uint64_t v18 = 2;
    int v19 = 0;
    uint64_t v21 = v25;
    int v22 = v25;
    uint64_t v23 = 2;
    int v24 = 0;
    LODWORD(v11) = 2;
    DWORD2(v11) = 0;
    v25[16] = 0;
    sub_1CCC10BFC(v4, (uint64_t)&v14);
    if (v22 != v21) {
      free(v22);
    }
    if (v17 != v16) {
      free(v17);
    }
    if (v10 != v9) {
      free(v10);
    }
  }
  else
  {
    uint64_t v5 = *(void *)(v26 + 8);
  }
  return (uint64_t)*v4 + 128 * v5 + 8;
}

uint64_t sub_1CD6C09D8(uint64_t a1, uint64_t *a2)
{
  uint64_t v12 = *a2;
  uint64_t v13 = 0;
  sub_1CD481EB8((uint64_t)&v25, a1, &v12, &v13);
  uint64_t v4 = (uint64_t *)(a1 + 24);
  if (v26)
  {
    unint64_t v5 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3);
    *(void *)(v25 + 8) = v5;
    uint64_t v8 = 0;
    memset(v11, 0, sizeof(v11));
    long long v7 = 0u;
    uint64_t v9 = (char *)v11 + 8;
    long long v10 = (unint64_t)v11 + 8;
    uint64_t v12 = *a2;
    LOWORD(v13) = 0;
    BYTE2(v13) = 0;
    long long v14 = 0uLL;
    __int16 v15 = v19;
    uint64_t v16 = v19;
    uint64_t v17 = 2;
    int v18 = 0;
    long long v20 = v24;
    uint64_t v21 = v24;
    uint64_t v22 = 2;
    int v23 = 0;
    DWORD2(v10) = 2;
    LODWORD(v11[0]) = 0;
    v24[16] = 0;
    sub_1CCC1090C(v4, (uint64_t)&v12);
    if (v21 != v20) {
      free(v21);
    }
    if (v16 != v15) {
      free(v16);
    }
    if ((char *)v10 != v9) {
      free((void *)v10);
    }
  }
  else
  {
    unint64_t v5 = *(void *)(v25 + 8);
  }
  return *v4 + 136 * v5 + 8;
}

uint64_t sub_1CD6C0B48(uint64_t a1, uint64_t a2, void *a3, uint64_t *a4)
{
  uint64_t v13 = 0;
  uint64_t result = sub_1CD3C8538((uint64_t *)a2, a3, &v13);
  uint64_t v9 = v13;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD4D7068(a2, (uint64_t)a3, a3, v13);
    uint64_t v9 = (void *)result;
    uint64_t v12 = *a4;
    *(void *)uint64_t result = *a3;
    *(void *)(result + 8) = v12;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

void *sub_1CD6C0BE0(uint64_t a1, uint64_t *a2)
{
  long long v7 = 0;
  char v4 = sub_1CD6C0C8C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  unint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CD6C0D20(a1, a2, v7);
    *unint64_t v5 = *a2;
    *(_OWORD *)(v5 + 3) = 0u;
    *(_OWORD *)(v5 + 5) = 0u;
    *(_OWORD *)(v5 + 9) = 0u;
    *(_OWORD *)(v5 + 11) = 0u;
    v5[15] = 0;
    *(_OWORD *)(v5 + 1) = 0u;
    *(_OWORD *)(v5 + 13) = 0u;
    *(_OWORD *)(v5 + 7) = 0u;
    void v5[3] = v5 + 7;
    _OWORD v5[4] = v5 + 7;
    *((_DWORD *)v5 + 10) = 2;
    v5[9] = v5 + 13;
    v5[10] = v5 + 13;
    *((_DWORD *)v5 + 22) = 2;
  }
  return v5;
}

uint64_t sub_1CD6C0C8C(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    uint64_t v4 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    unint64_t v5 = (void *)(a1 + (v4 << 7));
    uint64_t v6 = *v5;
    if (*v5 == a3)
    {
      uint64_t v7 = 1;
    }
    else
    {
      uint64_t v9 = 0;
      int v10 = 1;
      while (v6 != -4096)
      {
        if (v9) {
          BOOL v11 = 0;
        }
        else {
          BOOL v11 = v6 == -8192;
        }
        if (v11) {
          uint64_t v9 = v5;
        }
        int v12 = v4 + v10++;
        uint64_t v4 = v12 & (a2 - 1);
        unint64_t v5 = (void *)(a1 + (v4 << 7));
        uint64_t v6 = *v5;
        uint64_t v7 = 1;
        if (*v5 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v7 = 0;
      if (v9) {
        unint64_t v5 = v9;
      }
    }
  }
  else
  {
    unint64_t v5 = 0;
    uint64_t v7 = 0;
  }
LABEL_4:
  *a4 = v5;
  return v7;
}

void *sub_1CD6C0D20(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD6C0DD4(a1, v6);
  uint64_t v8 = 0;
  sub_1CD6C0C8C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD6C0DD4(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new((unint64_t)v8 << 7, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD6C0EA0((void *)a1, v4, v4 + (v3 << 7));
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = v10 << 7;
    do
    {
      void *result = -4096;
      result += 16;
      v11 -= 128;
    }
    while (v11);
  }
  return result;
}

void *sub_1CD6C0EA0(void *result, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = result;
  result[1] = 0;
  uint64_t v6 = *((unsigned int *)result + 4);
  if (v6)
  {
    int v7 = (void *)*result;
    uint64_t v8 = v6 << 7;
    do
    {
      *int v7 = -4096;
      v7 += 16;
      v8 -= 128;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      sub_1CD6C0C8C(*v5, *((_DWORD *)v5 + 4), v9, &v11);
      uint64_t v10 = v11;
      *uint64_t v11 = *(void *)a2;
      *(_OWORD *)(v10 + 1) = *(_OWORD *)(a2 + 8);
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(v10 + 3), v10 + 7, 2, (uint64_t *)(a2 + 24));
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(v10 + 9), v10 + 13, 2, (uint64_t *)(a2 + 72));
      *((unsigned char *)v10 + 120) = *(unsigned char *)(a2 + 120);
      ++*((_DWORD *)v5 + 2);
      uint64_t result = sub_1CD6C05EC((void *)(a2 + 8));
    }
    a2 += 128;
  }
  return result;
}

void sub_1CD6C0F9C(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = 56 * a2;
    uint64_t v3 = (void **)(a1 + 16);
    do
    {
      if (((unint64_t)*(v3 - 2) | 0x1000) != 0xFFFFFFFFFFFFF000 && *v3 != *(v3 - 1)) {
        free(*v3);
      }
      v3 += 7;
      v2 -= 56;
    }
    while (v2);
  }
}

uint64_t sub_1CD6C1000(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0;
  if (sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v5)) {
    BOOL v3 = v5 == *(void *)a1 + 16 * *(unsigned int *)(a1 + 16);
  }
  else {
    BOOL v3 = 1;
  }
  if (v3) {
    return *(void *)(a1 + 32);
  }
  else {
    return *(void *)(a1 + 24) + (*(void *)(v5 + 8) << 7);
  }
}

int32x2_t sub_1CD6C1070(uint64_t a1, uint64_t a2)
{
  int v7 = 0;
  int v3 = sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v7);
  uint64_t v5 = v7;
  if (v3) {
    BOOL v6 = v7 == (void *)(*(void *)a1 + 16 * *(unsigned int *)(a1 + 16));
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    *(void *)(*(void *)(a1 + 24) + (v7[1] << 7)) = 0;
    *uint64_t v5 = -8192;
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + 8) = result;
  }
  return result;
}

int32x2_t sub_1CD6C10F8(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0;
  if (sub_1CD6C0C8C(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v5))
  {
    uint64_t v4 = v5;
    sub_1CD6C05EC(v5 + 1);
    *uint64_t v4 = -8192;
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + 8) = result;
  }
  return result;
}

uint64_t sub_1CD6C1168(uint64_t a1)
{
  int v3 = (void **)(a1 + 24);
  sub_1CCC10F78(&v3);
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);
  return a1;
}

uint64_t *sub_1CD6C11B0(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v4 = v2 << 7;
    uint64_t v5 = (void *)(v3 + 8);
    do
    {
      if ((*(v5 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        uint64_t v5 = sub_1CD6C05EC(v5);
      }
      v5 += 16;
      v4 -= 128;
    }
    while (v4);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

uint64_t sub_1CD6C121C(uint64_t a1)
{
  return a1;
}

void llvm::createObjCARCExpandPass(llvm *this)
{
}

double llvm::ObjCARCExpandPass::run@<D0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  char v3 = sub_1CCC1124C(a1);
  *(void *)a2 = a2 + 32;
  *(void *)(a2 + 8) = a2 + 32;
  *(_DWORD *)(a2 + 16) = 2;
  if (v3)
  {
    *(_DWORD *)(a2 + 20) = 0;
    *(_DWORD *)(a2 + 24) = 0;
    *(void *)(a2 + 48) = a2 + 80;
    *(void *)(a2 + 56) = a2 + 80;
    *(void *)(a2 + 64) = 2;
    *(_DWORD *)(a2 + 72) = 0;
    sub_1CBF541A4((llvm::SmallPtrSetImplBase *)a2, (uint64_t)&llvm::CFGAnalyses::SetKey);
  }
  else
  {
    *(void *)(a2 + 48) = a2 + 80;
    *(void *)(a2 + 56) = a2 + 80;
    *(void *)(a2 + 64) = 2;
    *(_DWORD *)(a2 + 72) = 0;
    *(void *)&double result = 1;
    *(void *)(a2 + 20) = 1;
    *(void *)(a2 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  }
  return result;
}

BOOL sub_1CD6C1340(uint64_t a1)
{
  return llvm::Module::getNamedValue(a1, "llvm.objc.retain", 0x10uLL)
      || llvm::Module::getNamedValue(a1, "llvm.objc.release", 0x11uLL)
      || llvm::Module::getNamedValue(a1, "llvm.objc.autorelease", 0x15uLL)
      || llvm::Module::getNamedValue(a1, "llvm.objc.retainAutoreleasedReturnValue", 0x27uLL)
      || llvm::Module::getNamedValue(a1, "llvm.objc.unsafeClaimAutoreleasedReturnValue", 0x2CuLL)
      || llvm::Module::getNamedValue(a1, "llvm.objc.retainBlock", 0x15uLL)
      || llvm::Module::getNamedValue(a1, "llvm.objc.autoreleaseReturnValue", 0x20uLL)
      || llvm::Module::getNamedValue(a1, "llvm.objc.autoreleasePoolPush", 0x1DuLL)
      || llvm::Module::getNamedValue(a1, "llvm.objc.loadWeakRetained", 0x1AuLL)
      || llvm::Module::getNamedValue(a1, "llvm.objc.loadWeak", 0x12uLL)
      || llvm::Module::getNamedValue(a1, "llvm.objc.destroyWeak", 0x15uLL)
      || llvm::Module::getNamedValue(a1, "llvm.objc.storeWeak", 0x13uLL)
      || llvm::Module::getNamedValue(a1, "llvm.objc.initWeak", 0x12uLL)
      || llvm::Module::getNamedValue(a1, "llvm.objc.moveWeak", 0x12uLL)
      || llvm::Module::getNamedValue(a1, "llvm.objc.copyWeak", 0x12uLL)
      || llvm::Module::getNamedValue(a1, "llvm.objc.retainedObject", 0x18uLL)
      || llvm::Module::getNamedValue(a1, "llvm.objc.unretainedObject", 0x1AuLL)
      || llvm::Module::getNamedValue(a1, "llvm.objc.unretainedPointer", 0x1BuLL)
      || llvm::Module::getNamedValue(a1, "llvm.objc.clang.arc.use", 0x17uLL) != 0;
}

void llvm::createObjCARCAPElimPass(llvm *this)
{
}

double llvm::ObjCARCAPElimPass::run@<D0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  char v3 = sub_1CCC11608(a1);
  *(void *)a2 = a2 + 32;
  *(void *)(a2 + 8) = a2 + 32;
  *(_DWORD *)(a2 + 16) = 2;
  if (v3)
  {
    *(_DWORD *)(a2 + 20) = 0;
    *(_DWORD *)(a2 + 24) = 0;
    *(void *)(a2 + 48) = a2 + 80;
    *(void *)(a2 + 56) = a2 + 80;
    *(void *)(a2 + 64) = 2;
    *(_DWORD *)(a2 + 72) = 0;
    sub_1CBF541A4((llvm::SmallPtrSetImplBase *)a2, (uint64_t)&llvm::CFGAnalyses::SetKey);
  }
  else
  {
    *(void *)(a2 + 48) = a2 + 80;
    *(void *)(a2 + 56) = a2 + 80;
    *(void *)(a2 + 64) = 2;
    *(_DWORD *)(a2 + 72) = 0;
    *(void *)&double result = 1;
    *(void *)(a2 + 20) = 1;
    *(void *)(a2 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  }
  return result;
}

void llvm::createObjCARCContractPass(llvm *this)
{
}

void llvm::ObjCARCContractPass::run(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  int v5 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  int v8 = 0;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  memset(v14, 0, sizeof(v14));
  __int16 v15 = v19;
  uint64_t v16 = v19;
  uint64_t v17 = 8;
  int v18 = 0;
  sub_1CCC11D80((uint64_t)&v2, *(llvm::Module **)(a2 + 40));
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

uint64_t sub_1CD6C17D0(uint64_t a1, int a2)
{
  if (a2 == 10)
  {
    uint64_t result = *(void *)(a1 + 88);
    if (!result)
    {
      uint64_t result = llvm::Intrinsic::getDeclaration(*(uint64_t ***)a1, 225, 0, 0);
      *(void *)(a1 + 88) = result;
    }
  }
  else
  {
    uint64_t result = *(void *)(a1 + 80);
    if (!result)
    {
      uint64_t result = llvm::Intrinsic::getDeclaration(*(uint64_t ***)a1, 224, 0, 0);
      *(void *)(a1 + 80) = result;
    }
  }
  return result;
}

void sub_1CD6C183C(long long *a1)
{
  uint64_t v2 = sub_1CB883A14((uint64_t)&qword_1EBCEF320, 0, 0);
  dword_1EBCEF3A0 = 0;
  qword_1EBCEF3A8 = (uint64_t)&unk_1F2643C00;
  unk_1EBCEF3B0 = 0;
  qword_1EBCEF320 = (uint64_t)&unk_1F2609740;
  qword_1EBCEF3B8 = (uint64_t)&unk_1F2643CF0;
  qword_1EBCEF3C0 = (uint64_t)&unk_1F26097A8;
  qword_1EBCEF3D8 = (uint64_t)&qword_1EBCEF3C0;
  llvm::cl::Option::setArgStr(v2, "arc-contract-use-objc-claim-rv", 0x1EuLL);
  xmmword_1EBCEF340 = *a1;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCEF320);
}

uint64_t llvm::objcarc::CanDecrementRefCount(uint64_t a1, const llvm::Value *a2, uint64_t *a3, int a4)
{
  uint64_t result = llvm::objcarc::CanDecrementRefCount(a4);
  if (result)
  {
    return llvm::objcarc::CanAlterRefCount(a1, a2, a3, a4);
  }
  return result;
}

uint64_t llvm::objcarc::Depends(int a1, llvm::objcarc *this, llvm::objcarc *a3, uint64_t *a4)
{
  if (this == a3) {
    return 1;
  }
  switch(a1)
  {
    case 1:
      uint64_t result = llvm::objcarc::GetARCInstKind(this, this) - 7 < 2;
      break;
    case 2:
      int ARCInstKind = llvm::objcarc::GetARCInstKind(this, this);
      switch(ARCInstKind)
      {
        case 24:
          goto LABEL_5;
        case 8:
          return 1;
        case 7:
          goto LABEL_5;
      }
      uint64_t result = llvm::objcarc::CanAlterRefCount((uint64_t)this, a3, a4, ARCInstKind);
      break;
    case 3:
      unsigned int v10 = sub_1CD4B36C8((uint64_t)this, this);
      if (v10 - 7 < 2) {
        return 1;
      }
      if (v10 > 1) {
        goto LABEL_5;
      }
      goto LABEL_24;
    case 4:
      unsigned int v11 = sub_1CD4B36C8((uint64_t)this, this);
      if (v11 <= 1)
      {
LABEL_24:
        uint64_t result = sub_1CD4B3548(*((llvm::Value **)this - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF))) == a3;
      }
      else
      {
        uint64_t result = llvm::objcarc::CanInterruptRV(v11);
      }
      break;
    default:
      unsigned int v7 = llvm::objcarc::GetARCInstKind(this, this);
      if (v7 <= 0x18 && ((1 << v7) & 0x1000180) != 0)
      {
LABEL_5:
        uint64_t result = 0;
      }
      else
      {
        uint64_t result = llvm::objcarc::CanUse((uint64_t)this, a3, (const llvm::Value **)a4, v7);
      }
      break;
  }
  return result;
}

uint64_t llvm::objcarc::ProvenanceAnalysis::relatedSelect(llvm::objcarc::ProvenanceAnalysis *this, const llvm::SelectInst *a2, const llvm::Value *a3)
{
  if (!a3 || *((unsigned char *)a3 + 16) != 85 || *((void *)a2 - 12) != *((void *)a3 - 12))
  {
    if ((llvm::objcarc::ProvenanceAnalysis::related(this, *((const llvm::Value **)a2 - 8), a3) & 1) == 0)
    {
      uint64_t v6 = (const llvm::Value *)*((void *)a2 - 4);
      int v8 = this;
      unsigned int v7 = a3;
      goto LABEL_9;
    }
    return 1;
  }
  if (llvm::objcarc::ProvenanceAnalysis::related(this, *((const llvm::Value **)a2 - 8), *((const llvm::Value **)a3 - 8)))return 1; {
  uint64_t v6 = (const llvm::Value *)*((void *)a2 - 4);
  }
  unsigned int v7 = (const llvm::Value *)*((void *)a3 - 4);
  int v8 = this;
LABEL_9:

  return llvm::objcarc::ProvenanceAnalysis::related(v8, v6, v7);
}

BOOL llvm::objcarc::ProvenanceAnalysis::related(llvm::objcarc::ProvenanceAnalysis *this, const llvm::Value *a2, const llvm::Value *a3)
{
  int v5 = (char *)this + 32;
  uint64_t v6 = sub_1CD6C1E20(a2, (uint64_t)this + 32);
  unsigned int v7 = sub_1CD6C1E20(a3, (uint64_t)v5);
  uint64_t v8 = 1;
  if (v6 != v7)
  {
    if (v6 <= v7) {
      unsigned int v10 = v7;
    }
    else {
      unsigned int v10 = v6;
    }
    if (v6 <= v7) {
      unsigned int v11 = v6;
    }
    else {
      unsigned int v11 = v7;
    }
    long long v12 = v11;
    long long v13 = v10;
    v14[0] = 1;
    sub_1CD6C221C((uint64_t)this + 8, (uint64_t *)&v12, v14, (uint64_t)&v15);
    if (v16)
    {
      uint64_t v8 = llvm::objcarc::ProvenanceAnalysis::relatedCheck(this, v11, v10);
      long long v12 = v11;
      long long v13 = v10;
      *((unsigned char *)sub_1CD6C253C((uint64_t)this + 8, (uint64_t *)&v12) + 16) = v8;
    }
    else
    {
      return *(unsigned char *)(v15 + 16) != 0;
    }
  }
  return v8;
}

uint64_t llvm::objcarc::ProvenanceAnalysis::relatedCheck(llvm::objcarc::ProvenanceAnalysis *this, const llvm::Value *a2, const llvm::Value *a3)
{
  uint64_t v6 = *(void *)this;
  v23[0] = a2;
  v23[1] = -1;
  long long v24 = 0u;
  long long v25 = 0u;
  v20[0] = a3;
  v20[1] = -1;
  long long v21 = 0u;
  long long v22 = 0u;
  int v7 = llvm::AAResults::alias(v6, (uint64_t)v23, (uint64_t)v20);
  if ((v7 - 2) < 2) {
    return 1;
  }
  if (!v7) {
    return 0;
  }
  BOOL v9 = sub_1CCC0F60C((uint64_t)a2);
  BOOL v10 = sub_1CCC0F60C((uint64_t)a3);
  if (v9)
  {
    if (*((unsigned char *)a3 + 16) == 60)
    {
      unsigned int v11 = a2;
      return sub_1CCC14D98((uint64_t)v11);
    }
    if (v10)
    {
      if (*((unsigned char *)a2 + 16) != 60) {
        return 0;
      }
      goto LABEL_12;
    }
  }
  else if (v10 && *((unsigned char *)a2 + 16) == 60)
  {
LABEL_12:
    unsigned int v11 = a3;
    return sub_1CCC14D98((uint64_t)v11);
  }
  int v12 = *((unsigned __int8 *)a2 + 16);
  if (a2 && v12 == 83)
  {
    long long v13 = this;
    long long v14 = a2;
    uint64_t v15 = a3;
    return llvm::objcarc::ProvenanceAnalysis::relatedPHI(v13, v14, v15);
  }
  int v16 = *((unsigned __int8 *)a3 + 16);
  if (a3 && v16 == 83)
  {
    long long v13 = this;
    long long v14 = a3;
    uint64_t v15 = a2;
    return llvm::objcarc::ProvenanceAnalysis::relatedPHI(v13, v14, v15);
  }
  if (a2 && v12 == 85)
  {
    uint64_t v17 = this;
    int v18 = a2;
    int v19 = a3;
    return llvm::objcarc::ProvenanceAnalysis::relatedSelect(v17, v18, v19);
  }
  uint64_t result = 1;
  if (a3 && v16 == 85)
  {
    uint64_t v17 = this;
    int v18 = a3;
    int v19 = a2;
    return llvm::objcarc::ProvenanceAnalysis::relatedSelect(v17, v18, v19);
  }
  return result;
}

llvm *sub_1CD6C1E20(llvm *a1, uint64_t a2)
{
  BOOL v10 = a1;
  sub_1CD6C1EC0(v8, *(void *)a2, *(_DWORD *)(a2 + 16), (uint64_t)a1);
  uint64_t v4 = v9;
  if (v8[2]) {
    BOOL v5 = v9 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    uint64_t v4 = sub_1CD4B35A0(a1);
    uint64_t v6 = sub_1CD6C1F48(a2, (uint64_t *)&v10);
    sub_1CC002D7C((llvm::ValueHandleBase *)(v6 + 1), (uint64_t)a1);
    sub_1CC002D7C((llvm::ValueHandleBase *)(v6 + 4), (uint64_t)v4);
  }
  sub_1CD4A76CC((llvm::ValueHandleBase *)v8);
  return v4;
}

unint64_t *sub_1CD6C1EC0(unint64_t *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v7 = 0;
  uint64_t result = (unint64_t *)sub_1CD4A7E9C(a2, a3, a4, &v7);
  if (result)
  {
    uint64_t v6 = (void *)(v7 + 8);
    return sub_1CCC15080(a1, v6);
  }
  else
  {
    *a1 = 4;
    a1[1] = 0;
    a1[2] = 0;
    a1[3] = 6;
    a1[4] = 0;
    a1[5] = 0;
  }
  return result;
}

void *sub_1CD6C1F48(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD4A7E9C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  BOOL v5 = v7;
  if ((v4 & 1) == 0)
  {
    BOOL v5 = sub_1CD6C1FC8(a1, a2, v7);
    *BOOL v5 = *a2;
    v5[1] = 4;
    uint64_t v5[2] = 0;
    void v5[3] = 0;
    _OWORD v5[4] = 6;
    v5[5] = 0;
    v5[6] = 0;
  }
  return v5;
}

void *sub_1CD6C1FC8(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD6C207C(a1, v6);
  uint64_t v8 = 0;
  sub_1CD4A7E9C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD6C207C(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  char v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(56 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD6C2154((llvm::ValueHandleBase *)a1, v4, &v4[7 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 56 * v10;
    do
    {
      void *result = -4096;
      result += 7;
      v11 -= 56;
    }
    while (v11);
  }
  return result;
}

llvm::ValueHandleBase *sub_1CD6C2154(llvm::ValueHandleBase *result, uint64_t *a2, uint64_t *a3)
{
  unint64_t v5 = result;
  *((void *)result + 1) = 0;
  uint64_t v6 = *((unsigned int *)result + 4);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 56 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 7;
      v8 -= 56;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      sub_1CD4A7E9C(*(void *)v5, *((_DWORD *)v5 + 4), v9, &v11);
      uint64_t v10 = v11;
      *uint64_t v11 = *a2;
      sub_1CCC15080((unint64_t *)v10 + 1, a2 + 1);
      ++*((_DWORD *)v5 + 2);
      uint64_t result = sub_1CD4A76CC((llvm::ValueHandleBase *)(a2 + 1));
    }
    a2 += 7;
  }
  return result;
}

uint64_t sub_1CD6C221C@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, unsigned char *a3@<X2>, uint64_t a4@<X8>)
{
  int v12 = 0;
  uint64_t result = sub_1CD553C1C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD6C22C4(a1, a2, v12);
    uint64_t v9 = (void *)result;
    *(void *)uint64_t result = *a2;
    *(void *)(result + 8) = a2[1];
    *(unsigned char *)(result + 16) = *a3;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a1 + 24 * *(unsigned int *)(a1 + 16);
  *(void *)a4 = v9;
  *(void *)(a4 + 8) = v11;
  *(unsigned char *)(a4 + 16) = v10;
  return result;
}

void *sub_1CD6C22C4(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
    goto LABEL_8;
  }
  if (v6 + ~v5 - *(_DWORD *)(a1 + 12) <= v6 >> 3)
  {
LABEL_8:
    sub_1CD6C2384(a1, v6);
    uint64_t v8 = 0;
    sub_1CD553C1C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v8);
    a3 = v8;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096 || a3[1] != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_OWORD *sub_1CD6C2384(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD6C2460(a1, v4, v4 + 24 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 24 * v10;
    int64x2_t v12 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    do
    {
      _OWORD *result = v12;
      uint64_t result = (_OWORD *)((char *)result + 24);
      v11 -= 24;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD6C2460(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(int64x2_t **)result;
    uint64_t v8 = 24 * v6;
    int64x2_t v9 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    do
    {
      *int v7 = v9;
      int v7 = (int64x2_t *)((char *)v7 + 24);
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v10 = *(void *)a2;
    uint64_t v11 = *(void *)(a2 + 8);
    if ((*(void *)a2 != -4096 || v11 != -4096) && (v10 != -8192 || v11 != -8192))
    {
      long long v13 = 0;
      uint64_t result = sub_1CD553C1C(*(void *)v5, *(_DWORD *)(v5 + 16), v10, v11, &v13);
      int64x2_t v12 = v13;
      *long long v13 = *(void *)a2;
      v12[1] = *(void *)(a2 + 8);
      *((unsigned char *)v12 + 16) = *(unsigned char *)(a2 + 16);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 24;
  }
  return result;
}

void *sub_1CD6C253C(uint64_t a1, uint64_t *a2)
{
  int v7 = 0;
  char v4 = sub_1CD553C1C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD6C22C4(a1, a2, v7);
    *uint64_t v5 = *a2;
    v5[1] = a2[1];
    *((unsigned char *)v5 + 16) = 0;
  }
  return v5;
}

void llvm::createPAEvalPass(llvm *this)
{
}

BOOL llvm::objcarc::RRInfo::Merge(llvm::objcarc::RRInfo *this, const llvm::objcarc::RRInfo *a2)
{
  if (*((void *)this + 1) != *((void *)a2 + 1)) {
    *((void *)this + 1) = 0;
  }
  *(unsigned char *)this &= *(unsigned char *)a2;
  *((unsigned char *)this + 1) &= *((unsigned char *)a2 + 1);
  *((unsigned char *)this + 112) |= *((unsigned char *)a2 + 112);
  char v4 = (llvm::objcarc::RRInfo *)((char *)this + 16);
  uint64_t v6 = (unint64_t *)*((void *)a2 + 2);
  uint64_t v5 = (unint64_t *)*((void *)a2 + 3);
  if (v5 == v6) {
    int v7 = (char *)a2 + 36;
  }
  else {
    int v7 = (char *)a2 + 32;
  }
  uint64_t v8 = *(unsigned int *)v7;
  int64x2_t v9 = &v5[v8];
  if (v8)
  {
    uint64_t v10 = 8 * v8;
    while (*v5 >= 0xFFFFFFFFFFFFFFFELL)
    {
      ++v5;
      v10 -= 8;
      if (!v10)
      {
        uint64_t v5 = v9;
        break;
      }
    }
  }
  sub_1CC002B9C(v4, v5, v9, v9);
  unsigned int v11 = *((_DWORD *)a2 + 21);
  BOOL v12 = *((_DWORD *)this + 21) - *((_DWORD *)this + 22) != v11 - *((_DWORD *)a2 + 22);
  uint64_t v13 = *((void *)a2 + 9);
  if (v13 == *((void *)a2 + 8)) {
    uint64_t v14 = v11;
  }
  else {
    uint64_t v14 = *((unsigned int *)a2 + 20);
  }
  if (v14)
  {
    uint64_t v15 = 8 * v14;
    for (uint64_t i = (uint64_t *)*((void *)a2 + 9); (unint64_t)*i >= 0xFFFFFFFFFFFFFFFELL; ++i)
    {
      v15 -= 8;
      if (!v15) {
        return v12;
      }
    }
  }
  else
  {
    uint64_t i = (uint64_t *)*((void *)a2 + 9);
  }
  uint64_t v17 = (void *)(v13 + 8 * v14);
  if (i != v17)
  {
    int v18 = (llvm::objcarc::RRInfo *)((char *)this + 64);
    uint64_t v19 = *i;
LABEL_22:
    sub_1CB89694C(v18, v19);
    v12 |= v20;
    long long v21 = (unint64_t *)(i + 1);
    while (v21 != v17)
    {
      unint64_t v22 = *v21++;
      uint64_t v19 = v22;
      if (v22 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        uint64_t i = (uint64_t *)(v21 - 1);
        goto LABEL_22;
      }
    }
  }
  return v12;
}

void *llvm::objcarc::PtrState::ResetSequenceProgress(uint64_t a1, char a2)
{
  *(unsigned char *)(a1 + 2) = a2;
  *(unsigned char *)(a1 + 1) = 0;
  *(_WORD *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  sub_1CBFF3560((llvm::SmallPtrSetImplBase *)(a1 + 24));
  uint64_t result = sub_1CBFF3560((llvm::SmallPtrSetImplBase *)(a1 + 72));
  *(unsigned char *)(a1 + 120) = 0;
  return result;
}

BOOL llvm::objcarc::BottomUpPtrState::InitBottomUp(uint64_t a1, uint64_t a2, llvm::Instruction *this)
{
  int v6 = *(unsigned __int8 *)(a1 + 2);
  if (*(unsigned char *)(a2 + 12))
  {
    int MDKindID = *(_DWORD *)(a2 + 8);
  }
  else
  {
    int MDKindID = llvm::LLVMContext::getMDKindID(**(uint64_t ***)a2, "clang.imprecise_release", 0x17uLL);
    int v11 = *(unsigned __int8 *)(a2 + 12);
    *(_DWORD *)(a2 + 8) = MDKindID;
    if (!v11) {
      *(unsigned char *)(a2 + 12) = 1;
    }
  }
  if (*((void *)this + 6) || (*((unsigned char *)this + 23) & 0x20) != 0) {
    uint64_t MetadataImpl = llvm::Instruction::getMetadataImpl(this, MDKindID);
  }
  else {
    uint64_t MetadataImpl = 0;
  }
  if (MetadataImpl) {
    char v9 = 5;
  }
  else {
    char v9 = 4;
  }
  *(unsigned char *)(a1 + 2) = v9;
  *(unsigned char *)(a1 + 1) = 0;
  *(_WORD *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  sub_1CBFF3560((llvm::SmallPtrSetImplBase *)(a1 + 24));
  sub_1CBFF3560((llvm::SmallPtrSetImplBase *)(a1 + 72));
  *(unsigned char *)(a1 + 120) = 0;
  if (!MetadataImpl) {
    sub_1CB89694C((llvm::SmallPtrSetImplBase *)(a1 + 72), (uint64_t)this);
  }
  *(void *)(a1 + 16) = MetadataImpl;
  *(unsigned char *)(a1 + 8) = *(unsigned char *)a1;
  *(unsigned char *)(a1 + 9) = (*((_WORD *)this + 9) & 3u) - 1 < 2;
  sub_1CB89694C((llvm::SmallPtrSetImplBase *)(a1 + 24), (uint64_t)this);
  BOOL result = v6 == 5;
  *(unsigned char *)a1 = 1;
  return result;
}

uint64_t llvm::objcarc::BottomUpPtrState::MatchWithRetain(llvm::objcarc::BottomUpPtrState *this)
{
  uint64_t result = 1;
  *(unsigned char *)this = 1;
  switch(*((unsigned char *)this + 2))
  {
    case 1:
      __break(1u);
      break;
    case 2:
      return result;
    case 3:
      if (*((void *)this + 2)) {
        goto LABEL_2;
      }
      break;
    case 4:
    case 5:
LABEL_2:
      sub_1CBFF3560((llvm::objcarc::BottomUpPtrState *)((char *)this + 72));
      uint64_t result = 1;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t llvm::objcarc::BottomUpPtrState::HandlePotentialAlterRefCount(uint64_t a1, uint64_t a2, const llvm::Value *a3, uint64_t *a4, int a5)
{
  int v10 = *(unsigned __int8 *)(a1 + 2);
  uint64_t result = llvm::objcarc::CanDecrementRefCount(a5);
  if (result)
  {
    int CanAlterRefCount = llvm::objcarc::CanAlterRefCount(a2, a3, a4, a5);
    uint64_t result = 0;
    if (CanAlterRefCount)
    {
      if (v10 == 3)
      {
        *(unsigned char *)(a1 + 2) = 2;
        return 1;
      }
    }
  }
  return result;
}

llvm::Value *llvm::objcarc::BottomUpPtrState::HandlePotentialUse(llvm::Value *result, uint64_t a2, uint64_t a3, const llvm::Value *a4, const llvm::Value **a5, int a6)
{
  uint64_t v22 = a3;
  uint64_t v23 = a2;
  v21[0] = result;
  v21[1] = &v22;
  v21[2] = &v23;
  int v9 = *((unsigned __int8 *)result + 2);
  if (v9 == 4)
  {
    int v11 = result;
    uint64_t result = (llvm::Value *)llvm::objcarc::CanUse(a3, a4, a5, a6);
    if (result) {
      *((unsigned char *)v11 + 2) = 3;
    }
  }
  else if (v9 == 5)
  {
    uint64_t result = (llvm::Value *)llvm::objcarc::CanUse(a3, a4, a5, a6);
    if (result)
    {
      char v10 = 3;
      return (llvm::Value *)sub_1CCC15D0C(v21, v10);
    }
    if (a6 == 1)
    {
      int v12 = *(_DWORD *)(v22 + 20);
      uint64_t v13 = (v12 & 0x40000000) != 0 ? *(llvm::Value ***)(v22 - 8) : (llvm::Value **)(v22 - 32 * (v12 & 0x7FFFFFF));
      uint64_t result = llvm::Value::stripPointerCasts(*v13);
      int v15 = *((unsigned __int8 *)result + 16);
      BOOL v16 = result && v15 == 84;
      BOOL v17 = v16;
      if (v15 == 33 || v17)
      {
        uint64_t v19 = (uint64_t)result;
        int v20 = sub_1CD4B36C8((uint64_t)result, v14);
        uint64_t result = (llvm::Value *)llvm::objcarc::CanUse(v19, a4, a5, v20);
        if (result)
        {
          char v10 = 4;
          return (llvm::Value *)sub_1CCC15D0C(v21, v10);
        }
      }
    }
  }
  return result;
}

BOOL llvm::objcarc::TopDownPtrState::InitTopDown(uint64_t a1, int a2, uint64_t a3)
{
  if (a2 == 1)
  {
    BOOL v4 = 0;
  }
  else
  {
    BOOL v4 = *(unsigned __int8 *)(a1 + 2) == 1;
    *(_WORD *)(a1 + 1) = 256;
    *(_WORD *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    sub_1CBFF3560((llvm::SmallPtrSetImplBase *)(a1 + 24));
    sub_1CBFF3560((llvm::SmallPtrSetImplBase *)(a1 + 72));
    *(unsigned char *)(a1 + 120) = 0;
    *(unsigned char *)(a1 + 8) = *(unsigned char *)a1;
    sub_1CB89694C((llvm::SmallPtrSetImplBase *)(a1 + 24), a3);
  }
  *(unsigned char *)a1 = 1;
  return v4;
}

uint64_t llvm::objcarc::TopDownPtrState::MatchWithRelease(uint64_t a1, uint64_t a2, llvm::Instruction *this)
{
  *(unsigned char *)a1 = 0;
  int v6 = *(unsigned __int8 *)(a1 + 2);
  if (*(unsigned char *)(a2 + 12))
  {
    int MDKindID = *(_DWORD *)(a2 + 8);
  }
  else
  {
    int MDKindID = llvm::LLVMContext::getMDKindID(**(uint64_t ***)a2, "clang.imprecise_release", 0x17uLL);
    int v10 = *(unsigned __int8 *)(a2 + 12);
    *(_DWORD *)(a2 + 8) = MDKindID;
    if (!v10) {
      *(unsigned char *)(a2 + 12) = 1;
    }
  }
  if (*((void *)this + 6) || (*((unsigned char *)this + 23) & 0x20) != 0) {
    uint64_t MetadataImpl = llvm::Instruction::getMetadataImpl(this, MDKindID);
  }
  else {
    uint64_t MetadataImpl = 0;
  }
  if ((v6 - 1) >= 2)
  {
    if (!v6) {
      return 0;
    }
  }
  else if (v6 == 1 || MetadataImpl)
  {
    sub_1CBFF3560((llvm::SmallPtrSetImplBase *)(a1 + 72));
  }
  *(void *)(a1 + 16) = MetadataImpl;
  *(unsigned char *)(a1 + 9) = (*((_WORD *)this + 9) & 3u) - 1 < 2;
  return 1;
}

uint64_t llvm::objcarc::TopDownPtrState::HandlePotentialUse(uint64_t result, uint64_t a2, const llvm::Value *a3, const llvm::Value **a4, int a5)
{
  if (*(unsigned char *)(result + 2) == 2)
  {
    uint64_t v5 = result;
    uint64_t result = llvm::objcarc::CanUse(a2, a3, a4, a5);
    if (result) {
      *(unsigned char *)(v5 + 2) = 3;
    }
  }
  return result;
}

uint64_t llvm::object::CommonArchiveMemberHeader<llvm::object::UnixArMemHdrType>::getRawAccessMode(uint64_t a1)
{
  v2[0] = *(void *)(a1 + 16) + 40;
  v2[1] = 8;
  llvm::StringRef::find_last_not_of(v2, " ", 1, 0xFFFFFFFFFFFFFFFFLL);
  return v2[0];
}

uint64_t llvm::object::CommonArchiveMemberHeader<llvm::object::UnixArMemHdrType>::getRawLastModified(uint64_t a1)
{
  v2[0] = *(void *)(a1 + 16) + 16;
  v2[1] = 12;
  llvm::StringRef::find_last_not_of(v2, " ", 1, 0xFFFFFFFFFFFFFFFFLL);
  return v2[0];
}

uint64_t llvm::object::CommonArchiveMemberHeader<llvm::object::UnixArMemHdrType>::getRawUID(uint64_t a1)
{
  v2[0] = *(void *)(a1 + 16) + 28;
  v2[1] = 6;
  llvm::StringRef::find_last_not_of(v2, " ", 1, 0xFFFFFFFFFFFFFFFFLL);
  return v2[0];
}

uint64_t llvm::object::CommonArchiveMemberHeader<llvm::object::UnixArMemHdrType>::getRawGID(uint64_t a1)
{
  v2[0] = *(void *)(a1 + 16) + 34;
  v2[1] = 6;
  llvm::StringRef::find_last_not_of(v2, " ", 1, 0xFFFFFFFFFFFFFFFFLL);
  return v2[0];
}

uint64_t llvm::object::CommonArchiveMemberHeader<llvm::object::UnixArMemHdrType>::getOffset(uint64_t a1)
{
  return *(void *)(a1 + 16) - *(void *)(*(void *)(a1 + 8) + 16);
}

uint64_t llvm::object::CommonArchiveMemberHeader<llvm::object::UnixArMemHdrType>::getSizeOf()
{
  return 60;
}

uint64_t llvm::object::CommonArchiveMemberHeader<llvm::object::BigArMemHdrType>::getRawAccessMode(uint64_t a1)
{
  v2[0] = *(void *)(a1 + 16) + 96;
  v2[1] = 12;
  llvm::StringRef::find_last_not_of(v2, " ", 1, 0xFFFFFFFFFFFFFFFFLL);
  return v2[0];
}

uint64_t llvm::object::CommonArchiveMemberHeader<llvm::object::BigArMemHdrType>::getRawLastModified(uint64_t a1)
{
  v2[0] = *(void *)(a1 + 16) + 60;
  v2[1] = 12;
  llvm::StringRef::find_last_not_of(v2, " ", 1, 0xFFFFFFFFFFFFFFFFLL);
  return v2[0];
}

uint64_t llvm::object::CommonArchiveMemberHeader<llvm::object::BigArMemHdrType>::getRawUID(uint64_t a1)
{
  v2[0] = *(void *)(a1 + 16) + 72;
  v2[1] = 12;
  llvm::StringRef::find_last_not_of(v2, " ", 1, 0xFFFFFFFFFFFFFFFFLL);
  return v2[0];
}

uint64_t llvm::object::CommonArchiveMemberHeader<llvm::object::BigArMemHdrType>::getRawGID(uint64_t a1)
{
  v2[0] = *(void *)(a1 + 16) + 84;
  v2[1] = 12;
  llvm::StringRef::find_last_not_of(v2, " ", 1, 0xFFFFFFFFFFFFFFFFLL);
  return v2[0];
}

uint64_t llvm::object::CommonArchiveMemberHeader<llvm::object::BigArMemHdrType>::getOffset(uint64_t a1)
{
  return *(void *)(a1 + 16) - *(void *)(*(void *)(a1 + 8) + 16);
}

uint64_t llvm::object::CommonArchiveMemberHeader<llvm::object::BigArMemHdrType>::getSizeOf()
{
  return 114;
}

void *llvm::object::ArchiveMemberHeader::ArchiveMemberHeader(void *result, uint64_t a2, uint64_t a3, unint64_t a4, void *a5)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  result[1] = a2;
  result[2] = a3;
  void *result = &unk_1F26326B8;
  if (!a3) {
    return result;
  }
  if (a4 <= 0x3B) {
    sub_1CCC16254((int)&v23, result, a3, a4);
  }
  if (*(unsigned char *)(a3 + 58) != 96)
  {
    if (!a5) {
      return result;
    }
LABEL_12:
    int v10 = result;
    memset(v32, 0, sizeof(v32));
    int v24 = 0;
    char v28 = 0;
    uint64_t v29 = 0;
    char v31 = v32;
    int v30 = 0;
    uint64_t v23 = &unk_1F2646F30;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    llvm::raw_ostream::write_escaped((llvm::raw_ostream *)&v23, (char *)(a3 + 58), 2, 0);
    if (v27 != v25) {
      llvm::raw_ostream::flush_nonempty((llvm::raw_ostream *)&v23);
    }
    std::operator+<char>();
    std::string::size_type v6 = v5->__r_.__value_.__r.__words[2];
    long long v21 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
    std::string::size_type v22 = v6;
    v5->__r_.__value_.__l.__size_ = 0;
    v5->__r_.__value_.__r.__words[2] = 0;
    v5->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v15.__r_.__value_.__l.__data_);
    }
    (*(void (**)(void *__return_ptr))(*v10 + 64))(v33);
    if ((v34 & 1) == 0)
    {
      sub_1CBAD7600("for ", (const void **)&v21, __p);
      __int16 v16 = 260;
      v15.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
      __int16 v13 = 261;
      v12[0] = v33[0];
      v12[1] = v33[1];
      sub_1CB8F1E58((uint64_t *)&v15, v12, (uint64_t)v11);
      sub_1CCC16404((int)&v19, (llvm::Twine *)v11);
    }
    int v7 = (void *)v33[0];
    v33[0] = 0;
    int v20 = v7;
    sub_1CD4515D0(&v20);
    if (v20) {
      (*(void (**)(void *))(*v20 + 8))(v20);
    }
    uint64_t v19 = a3 - *(void *)(a2 + 16);
    sub_1CBAD7600("at offset ", (const void **)&v21, __p);
    __int16 v16 = 260;
    v15.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
    __int16 v13 = 268;
    v12[0] = (uint64_t)&v19;
    sub_1CB8F1E58((uint64_t *)&v15, v12, (uint64_t)v17);
    sub_1CCC16404((int)&v18, (llvm::Twine *)v17);
  }
  if (a5 && *(unsigned char *)(a3 + 59) != 10) {
    goto LABEL_12;
  }
  if (a5)
  {
    if (!*a5) {
      *a5 = 0;
    }
  }
  return result;
}

void *llvm::object::BigArchiveMemberHeader::BigArchiveMemberHeader(void *result, uint64_t a2, uint64_t a3, unint64_t a4, void *a5)
{
  result[1] = a2;
  result[2] = a3;
  void *result = &unk_1F2632738;
  if (a3)
  {
    if (a4 <= 0x71) {
      sub_1CCC16254((int)&v5, result, a3, a4);
    }
    if (a5)
    {
      if (!*a5) {
        *a5 = 0;
      }
    }
  }
  return result;
}

unsigned char *llvm::object::ArchiveMemberHeader::getRawName@<X0>(llvm::object::ArchiveMemberHeader *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *((void *)this + 1);
  int v4 = *(unsigned char *)(v3 + 98) & 7;
  if (v4 == 4 || v4 == 2)
  {
    std::string::size_type v6 = (unsigned char *)*((void *)this + 2);
    if (*v6 == 32)
    {
      BOOL v17 = &v6[-*(void *)(v3 + 16)];
      uint64_t v14 = "name contains a leading space for archive member header at offset ";
      __int16 v15 = 259;
      __int16 v13 = 268;
      v12[0] = (uint64_t)&v17;
      sub_1CB8F1E58((uint64_t *)&v14, v12, (uint64_t)v16);
      sub_1CCC16404(a2, (llvm::Twine *)v16);
    }
    int v7 = 32;
  }
  else
  {
    std::string::size_type v6 = (unsigned char *)*((void *)this + 2);
    int v10 = *v6;
    if (v10 == 35 || v10 == 47) {
      int v7 = 32;
    }
    else {
      int v7 = 47;
    }
  }
  uint64_t result = memchr(v6, v7, 0x10uLL);
  uint64_t v9 = result - v6;
  if (!result) {
    uint64_t v9 = -1;
  }
  *(unsigned char *)(a2 + 16) &= ~1u;
  if (v9 == -1) {
    uint64_t v9 = 16;
  }
  *(void *)a2 = v6;
  *(void *)(a2 + 8) = v9;
  return result;
}

uint64_t getArchiveMemberDecField@<X0>(uint64_t *a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  v25[0] = 0;
  uint64_t result = llvm::getAsUnsignedInteger(a2, a3, 0xAu, (unint64_t *)v25);
  if (result)
  {
    uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)a4 + 80))(a4);
    int v20 = "characters in ";
    __int16 v21 = 259;
    sub_1CB8F1E58((uint64_t *)&v20, a1, (uint64_t)v22);
    uint64_t v18 = " field in archive member header are not all decimal numbers: '";
    __int16 v19 = 259;
    sub_1CB8F1E58(v22, (uint64_t *)&v18, (uint64_t)v23);
    __int16 v17 = 261;
    v16[0] = (uint64_t)a2;
    v16[1] = a3;
    sub_1CB8F1E58(v23, v16, (uint64_t)v24);
    uint64_t v14 = "' for the archive member header at offset ";
    __int16 v15 = 259;
    sub_1CB8F1E58(v24, (uint64_t *)&v14, (uint64_t)v25);
    __int16 v13 = 268;
    int v12 = &v28;
    sub_1CB8F1E58(v25, (uint64_t *)&v12, (uint64_t)v26);
    sub_1CCC16404((int)&v27, (llvm::Twine *)v26);
  }
  uint64_t v11 = v25[0];
  *(unsigned char *)(a5 + 8) &= ~1u;
  *(void *)a5 = v11;
  return result;
}

uint64_t llvm::object::BigArchiveMemberHeader::getRawName@<X0>(llvm::object::BigArchiveMemberHeader *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  int v20 = "NameLen";
  __int16 v21 = 259;
  __int16 v15 = (unsigned __int8 *)(*((void *)this + 2) + 108);
  unint64_t v16 = 4;
  uint64_t last_not_of = llvm::StringRef::find_last_not_of(&v15, " ", 1, 0xFFFFFFFFFFFFFFFFLL);
  if (last_not_of + 1 < v16) {
    unint64_t v5 = last_not_of + 1;
  }
  else {
    unint64_t v5 = v16;
  }
  unint64_t v6 = v16 + v5 - 4;
  if (v16 >= v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = v16;
  }
  uint64_t result = getArchiveMemberDecField((uint64_t *)&v20, v15, v7, (uint64_t)this, (uint64_t)&v22);
  if (v23)
  {
    uint64_t v12 = v22;
    *(unsigned char *)(a2 + 16) |= 1u;
    *(void *)a2 = v12;
  }
  else
  {
    uint64_t v9 = v22;
    unint64_t v10 = (v22 + 1) & 0xFFFFFFFFFFFFFFFELL;
    uint64_t v11 = *((void *)this + 2) + 112;
    if (v10 == -2 || *(_WORD *)(v11 + v10) != 2656)
    {
      unint64_t v19 = v11 + v10 - *(void *)(*((void *)this + 1) + 16);
      __int16 v17 = 259;
      __int16 v14 = 268;
      __int16 v13 = &v19;
      sub_1CB8F1E58((uint64_t *)&v15, (uint64_t *)&v13, (uint64_t)v18);
      sub_1CCC16404(a2, (llvm::Twine *)v18);
    }
    *(unsigned char *)(a2 + 16) &= ~1u;
    *(void *)a2 = v11;
    *(void *)(a2 + 8) = v9;
  }
  return result;
}

void *llvm::object::ArchiveMemberHeader::getName@<X0>(llvm::object::ArchiveMemberHeader *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  if (a2 <= 0xF)
  {
    v68[0] = *((void *)this + 2) - *(void *)(*((void *)this + 1) + 16);
    uint64_t v72 = "archive header truncated before the name field for archive member header at offset ";
    LOWORD(v76) = 259;
    __int16 v85 = 268;
    uint64_t v83 = (char *)v68;
    sub_1CB8F1E58((uint64_t *)&v72, (uint64_t *)&v83, (uint64_t)v86);
    sub_1CCC16404(a3, (llvm::Twine *)v86);
  }
  uint64_t result = (*(void *(**)(long long *__return_ptr, llvm::object::ArchiveMemberHeader *))(*(void *)this
                                                                                                  + 24))(&v87, this);
  if (v88)
  {
    uint64_t v25 = v87;
    *(unsigned char *)(a3 + 16) |= 1u;
    *(void *)a3 = v25;
    return result;
  }
  long long v82 = v87;
  uint64_t v7 = v87;
  if (*(unsigned char *)v87 != 47)
  {
    uint64_t v8 = *((void *)&v87 + 1) - 3;
    if (*((void *)&v87 + 1) < 3uLL || (*(_WORD *)v87 == 12579 ? (BOOL v9 = *(unsigned char *)(v87 + 2) == 47) : (BOOL v9 = 0), !v9))
    {
      uint64_t v23 = *((void *)&v82 + 1);
      unint64_t v24 = *((void *)&v87 + 1) - 1;
      if (*(unsigned char *)(v87 + *((void *)&v87 + 1) - 1) == 47)
      {
        if (*((void *)&v82 + 1) < v24) {
          unint64_t v24 = *((void *)&v82 + 1);
        }
        *(unsigned char *)(a3 + 16) &= ~1u;
        *(void *)a3 = v7;
        *(void *)(a3 + 8) = v24;
        goto LABEL_25;
      }
      uint64_t result = (void *)llvm::StringRef::find_last_not_of((llvm::StringRef *)&v82, 0x20u, 0xFFFFFFFFFFFFFFFFLL);
      unint64_t v18 = *((void *)&v82 + 1);
      unint64_t v19 = (unsigned __int8 *)v82;
      if ((unint64_t)result + 1 < *((void *)&v82 + 1)) {
        int v20 = (char *)result + 1;
      }
      else {
        int v20 = (char *)*((void *)&v82 + 1);
      }
      unint64_t v21 = *((void *)&v82 + 1) - v23;
      goto LABEL_22;
    }
    unint64_t v10 = (char *)(v87 + 3);
    uint64_t v11 = 3 - *((void *)&v87 + 1);
    uint64_t v72 = (unsigned __int8 *)(v87 + 3);
    unint64_t v73 = *((void *)&v87 + 1) - 3;
    unint64_t last_not_of = llvm::StringRef::find_last_not_of((llvm::StringRef *)&v72, 0x20u, 0xFFFFFFFFFFFFFFFFLL);
    if (last_not_of + 1 < v73) {
      unint64_t v13 = last_not_of + 1;
    }
    else {
      unint64_t v13 = v73;
    }
    unint64_t v14 = v73 + v11 + v13;
    if (v73 >= v14) {
      uint64_t v15 = v14;
    }
    else {
      uint64_t v15 = v73;
    }
    uint64_t v83 = 0;
    if ((llvm::getAsUnsignedInteger(v72, v15, 0xAu, (unint64_t *)&v83) & 1) == 0)
    {
      unint64_t v16 = v83;
      uint64_t v81 = v83;
      if ((unint64_t)&v16[(*(uint64_t (**)(llvm::object::ArchiveMemberHeader *))(*(void *)this
                                                                                                 + 104))(this)] <= a2)
      {
        uint64_t v17 = *((void *)this + 2);
        uint64_t v72 = (unsigned __int8 *)(v17
                                + (*(uint64_t (**)(llvm::object::ArchiveMemberHeader *))(*(void *)this
                                                                                                 + 104))(this));
        unint64_t v73 = (unint64_t)v16;
        uint64_t result = (void *)llvm::StringRef::find_last_not_of((llvm::StringRef *)&v72, 0, 0xFFFFFFFFFFFFFFFFLL);
        unint64_t v19 = v72;
        unint64_t v18 = v73;
        if ((unint64_t)result + 1 < v73) {
          int v20 = (char *)result + 1;
        }
        else {
          int v20 = (char *)v73;
        }
        unint64_t v21 = v73 - (void)v16;
LABEL_22:
        uint64_t v22 = &v20[v21];
        *(unsigned char *)(a3 + 16) &= ~1u;
        if (v18 < (unint64_t)v22) {
          uint64_t v22 = (char *)v18;
        }
LABEL_24:
        *(void *)a3 = v19;
        *(void *)(a3 + 8) = v22;
        goto LABEL_25;
      }
      uint64_t v71 = *((void *)this + 2) - *(void *)(*((void *)this + 1) + 16);
      v68[0] = (uint64_t)"long name length: ";
      __int16 v69 = 259;
      __int16 v66 = 268;
      __int16 v63 = &v81;
      sub_1CB8F1E58(v68, (uint64_t *)&v63, (uint64_t)&v83);
      __p[0] = " extends past the end of the member or archive for archive member header at offset ";
      __int16 v62 = 259;
      sub_1CB8F1E58((uint64_t *)&v83, (uint64_t *)__p, (uint64_t)&v72);
      __int16 v59 = 268;
      v58.__r_.__value_.__r.__words[0] = (std::string::size_type)&v71;
      sub_1CB8F1E58((uint64_t *)&v72, (uint64_t *)&v58, (uint64_t)v55);
      uint64_t v33 = (llvm::Twine *)v55;
LABEL_48:
      sub_1CCC16404(a3, v33);
    }
    __int16 v63 = 0;
    uint64_t v64 = 0;
    uint64_t v65 = 0;
    LODWORD(v73) = 0;
    char v77 = 0;
    uint64_t v78 = 0;
    uint64_t v80 = &v63;
    int v79 = 0;
    uint64_t v72 = (unsigned __int8 *)&unk_1F2646F30;
    uint64_t v74 = 0;
    uint64_t v75 = 0;
    uint64_t v76 = 0;
    uint64_t v83 = v10;
    unint64_t v84 = v8;
    unint64_t v26 = llvm::StringRef::find_last_not_of((llvm::StringRef *)&v83, 0x20u, 0xFFFFFFFFFFFFFFFFLL);
    if (v26 + 1 < v84) {
      unint64_t v27 = v26 + 1;
    }
    else {
      unint64_t v27 = v84;
    }
    unint64_t v28 = v84 + v11 + v27;
    if (v84 >= v28) {
      uint64_t v29 = v28;
    }
    else {
      uint64_t v29 = v84;
    }
    llvm::raw_ostream::write_escaped((llvm::raw_ostream *)&v72, v83, v29, 0);
    if (v76 != v74) {
      llvm::raw_ostream::flush_nonempty((llvm::raw_ostream *)&v72);
    }
    uint64_t v71 = *((void *)this + 2) - *(void *)(*((void *)this + 1) + 16);
    std::operator+<char>();
    int v30 = std::string::append(&v58, "' for archive member header at offset ");
    std::string::size_type v31 = v30->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    std::string::size_type v61 = v31;
    v30->__r_.__value_.__l.__size_ = 0;
    v30->__r_.__value_.__r.__words[2] = 0;
    v30->__r_.__value_.__r.__words[0] = 0;
    __int16 v85 = 260;
    uint64_t v83 = (char *)__p;
    __int16 v69 = 268;
    v68[0] = (uint64_t)&v71;
    sub_1CB8F1E58((uint64_t *)&v83, v68, (uint64_t)v56);
    char v32 = (llvm::Twine *)v56;
    goto LABEL_46;
  }
  if (*((void *)&v87 + 1) == 14)
  {
    if (*(void *)v87 == 0x5341484746583C2FLL && *(void *)(v87 + 6) == 0x2F3E50414D485341) {
      goto LABEL_36;
    }
    goto LABEL_59;
  }
  if (*((void *)&v87 + 1) == 2)
  {
    if (*(unsigned char *)(v87 + 1) == 47) {
      goto LABEL_36;
    }
LABEL_59:
    BOOL v35 = *((void *)&v82 + 1) != 0;
    if (*((void *)&v82 + 1)) {
      int v36 = (unsigned __int8 *)(v87 + 1);
    }
    else {
      int v36 = (unsigned __int8 *)v82;
    }
    uint64_t v37 = *((void *)&v82 + 1) - v35;
    uint64_t v72 = v36;
    unint64_t v73 = *((void *)&v82 + 1) - v35;
    unint64_t v38 = llvm::StringRef::find_last_not_of((llvm::StringRef *)&v72, 0x20u, 0xFFFFFFFFFFFFFFFFLL);
    if (v38 + 1 < v73) {
      unint64_t v39 = v38 + 1;
    }
    else {
      unint64_t v39 = v73;
    }
    unint64_t v40 = v73 - v37 + v39;
    if (v73 >= v40) {
      uint64_t v41 = v40;
    }
    else {
      uint64_t v41 = v73;
    }
    uint64_t v83 = 0;
    if ((llvm::getAsUnsignedInteger(v72, v41, 0xAu, (unint64_t *)&v83) & 1) == 0)
    {
      uint64_t v48 = v83;
      uint64_t v81 = v83;
      uint64_t v49 = *((void *)this + 1);
      unint64_t v50 = *(void *)(v49 + 72);
      if (v50 <= (unint64_t)v83)
      {
        uint64_t v71 = *((void *)this + 2) - *(void *)(v49 + 16);
        v68[0] = (uint64_t)"long name offset ";
        __int16 v69 = 259;
        __int16 v66 = 266;
        __int16 v63 = &v81;
        sub_1CB8F1E58(v68, (uint64_t *)&v63, (uint64_t)&v83);
        __p[0] = " past the end of the string table for archive member header at offset ";
        __int16 v62 = 259;
        sub_1CB8F1E58((uint64_t *)&v83, (uint64_t *)__p, (uint64_t)&v72);
        __int16 v59 = 268;
        v58.__r_.__value_.__r.__words[0] = (std::string::size_type)&v71;
        sub_1CB8F1E58((uint64_t *)&v72, (uint64_t *)&v58, (uint64_t)v67);
        uint64_t v33 = (llvm::Twine *)v67;
      }
      else
      {
        uint64_t v51 = *(void *)(v49 + 64);
        int64_t v52 = &v83[v51];
        if ((*(unsigned char *)(v49 + 98) & 6) != 0)
        {
          *(unsigned char *)(a3 + 16) &= ~1u;
          *(void *)a3 = v52;
          if (v51) {
            uint64_t result = (void *)strlen(v52);
          }
          else {
            uint64_t result = 0;
          }
          *(void *)(a3 + 8) = result;
          goto LABEL_25;
        }
        uint64_t result = memchr(v52, 10, v50 - (void)v83);
        if (result)
        {
          if ((unint64_t)result - v51 + 1 >= 2)
          {
            unint64_t v53 = (unint64_t)result - v51 - 1;
            if (*((unsigned char *)result - 1) == 47)
            {
              if (v50 >= (unint64_t)v48) {
                unint64_t v54 = (unint64_t)v48;
              }
              else {
                unint64_t v54 = v50;
              }
              if (v54 > v53) {
                unint64_t v53 = v54;
              }
              if (v50 < v53) {
                unint64_t v53 = v50;
              }
              unint64_t v19 = (unsigned __int8 *)(v51 + v54);
              *(unsigned char *)(a3 + 16) &= ~1u;
              uint64_t v22 = (char *)(v53 - v54);
              goto LABEL_24;
            }
          }
        }
        uint64_t v83 = "string table at long name offset ";
        __int16 v85 = 259;
        __int16 v69 = 266;
        v68[0] = (uint64_t)&v81;
        sub_1CB8F1E58((uint64_t *)&v83, v68, (uint64_t)&v72);
        __int16 v63 = "not terminated";
        __int16 v66 = 259;
        sub_1CB8F1E58((uint64_t *)&v72, (uint64_t *)&v63, (uint64_t)v57);
        uint64_t v33 = (llvm::Twine *)v57;
      }
      goto LABEL_48;
    }
    __int16 v63 = 0;
    uint64_t v64 = 0;
    uint64_t v65 = 0;
    LODWORD(v73) = 0;
    char v77 = 0;
    uint64_t v78 = 0;
    uint64_t v80 = &v63;
    int v79 = 0;
    uint64_t v72 = (unsigned __int8 *)&unk_1F2646F30;
    uint64_t v74 = 0;
    uint64_t v75 = 0;
    uint64_t v76 = 0;
    uint64_t v83 = (char *)v36;
    unint64_t v84 = v37;
    unint64_t v42 = llvm::StringRef::find_last_not_of((llvm::StringRef *)&v83, 0x20u, 0xFFFFFFFFFFFFFFFFLL);
    if (v42 + 1 < v84) {
      unint64_t v43 = v42 + 1;
    }
    else {
      unint64_t v43 = v84;
    }
    unint64_t v44 = v84 - v37 + v43;
    if (v84 >= v44) {
      uint64_t v45 = v44;
    }
    else {
      uint64_t v45 = v84;
    }
    llvm::raw_ostream::write_escaped((llvm::raw_ostream *)&v72, v83, v45, 0);
    if (v76 != v74) {
      llvm::raw_ostream::flush_nonempty((llvm::raw_ostream *)&v72);
    }
    uint64_t v71 = *((void *)this + 2) - *(void *)(*((void *)this + 1) + 16);
    std::operator+<char>();
    uint64_t v46 = std::string::append(&v58, "' for archive member header at offset ");
    std::string::size_type v47 = v46->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
    std::string::size_type v61 = v47;
    v46->__r_.__value_.__l.__size_ = 0;
    v46->__r_.__value_.__r.__words[2] = 0;
    v46->__r_.__value_.__r.__words[0] = 0;
    __int16 v85 = 260;
    uint64_t v83 = (char *)__p;
    __int16 v69 = 268;
    v68[0] = (uint64_t)&v71;
    sub_1CB8F1E58((uint64_t *)&v83, v68, (uint64_t)v70);
    char v32 = (llvm::Twine *)v70;
LABEL_46:
    sub_1CCC16404(a3, v32);
  }
  if (*((void *)&v87 + 1) != 1) {
    goto LABEL_59;
  }
LABEL_36:
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(_OWORD *)a3 = v87;
LABEL_25:
  if (v88)
  {
    uint64_t result = (void *)v87;
    *(void *)&long long v87 = 0;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  return result;
}

uint64_t llvm::object::BigArchiveMemberHeader::getName(llvm::object::BigArchiveMemberHeader *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 24))();
}

uint64_t llvm::object::ArchiveMemberHeader::getSize@<X0>(llvm::object::ArchiveMemberHeader *this@<X0>, uint64_t a2@<X8>)
{
  BOOL v9 = "size";
  __int16 v10 = 259;
  uint64_t v11 = (unsigned __int8 *)(*((void *)this + 2) + 48);
  unint64_t v12 = 10;
  uint64_t last_not_of = llvm::StringRef::find_last_not_of(&v11, " ", 1, 0xFFFFFFFFFFFFFFFFLL);
  if (last_not_of + 1 < v12) {
    unint64_t v5 = last_not_of + 1;
  }
  else {
    unint64_t v5 = v12;
  }
  unint64_t v6 = v12 + v5 - 10;
  if (v12 >= v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = v12;
  }
  return getArchiveMemberDecField((uint64_t *)&v9, v11, v7, (uint64_t)this, a2);
}

uint64_t llvm::object::BigArchiveMemberHeader::getSize@<X0>(llvm::object::BigArchiveMemberHeader *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = "size";
  __int16 v12 = 259;
  uint64_t v15 = (unsigned __int8 *)*((void *)this + 2);
  unint64_t v16 = 20;
  uint64_t last_not_of = llvm::StringRef::find_last_not_of(&v15, " ", 1, 0xFFFFFFFFFFFFFFFFLL);
  if (last_not_of + 1 < v16) {
    unint64_t v5 = last_not_of + 1;
  }
  else {
    unint64_t v5 = v16;
  }
  unint64_t v6 = v16 + v5 - 20;
  if (v16 >= v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = v16;
  }
  uint64_t result = getArchiveMemberDecField((uint64_t *)&v11, v15, v7, (uint64_t)this, (uint64_t)&v15);
  if (v16)
  {
    BOOL v9 = v15;
  }
  else
  {
    uint64_t result = llvm::object::BigArchiveMemberHeader::getRawNameSize(this, (uint64_t)&v13);
    if ((v14 & 1) == 0)
    {
      BOOL v9 = &v15[(unint64_t)(v13 + 1) & 0xFFFFFFFFFFFFFFFELL];
      char v10 = *(unsigned char *)(a2 + 8) & 0xFE;
      goto LABEL_10;
    }
    BOOL v9 = v13;
  }
  char v10 = *(unsigned char *)(a2 + 8) | 1;
LABEL_10:
  *(unsigned char *)(a2 + 8) = v10;
  *(void *)a2 = v9;
  return result;
}

uint64_t llvm::object::BigArchiveMemberHeader::getRawNameSize@<X0>(llvm::object::BigArchiveMemberHeader *this@<X0>, uint64_t a2@<X8>)
{
  BOOL v9 = "NameLen";
  __int16 v10 = 259;
  uint64_t v11 = (unsigned __int8 *)(*((void *)this + 2) + 108);
  unint64_t v12 = 4;
  uint64_t last_not_of = llvm::StringRef::find_last_not_of(&v11, " ", 1, 0xFFFFFFFFFFFFFFFFLL);
  if (last_not_of + 1 < v12) {
    unint64_t v5 = last_not_of + 1;
  }
  else {
    unint64_t v5 = v12;
  }
  unint64_t v6 = v12 + v5 - 4;
  if (v12 >= v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = v12;
  }
  return getArchiveMemberDecField((uint64_t *)&v9, v11, v7, (uint64_t)this, a2);
}

uint64_t llvm::object::BigArchiveMemberHeader::getNextOffset@<X0>(llvm::object::BigArchiveMemberHeader *this@<X0>, uint64_t a2@<X8>)
{
  BOOL v9 = "NextOffset";
  __int16 v10 = 259;
  uint64_t v11 = (unsigned __int8 *)(*((void *)this + 2) + 20);
  unint64_t v12 = 20;
  uint64_t last_not_of = llvm::StringRef::find_last_not_of(&v11, " ", 1, 0xFFFFFFFFFFFFFFFFLL);
  if (last_not_of + 1 < v12) {
    unint64_t v5 = last_not_of + 1;
  }
  else {
    unint64_t v5 = v12;
  }
  unint64_t v6 = v12 + v5 - 20;
  if (v12 >= v6) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = v12;
  }
  return getArchiveMemberDecField((uint64_t *)&v9, v11, v7, (uint64_t)this, a2);
}

void *llvm::object::ArchiveMemberHeader::isThin@<X0>(llvm::object::ArchiveMemberHeader *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t result = (*(void *(**)(_DWORD **__return_ptr))(*(void *)this + 24))(&v8);
  if (v10)
  {
    unint64_t v6 = v8;
    *(unsigned char *)(a2 + 8) |= 1u;
    *(void *)a2 = v6;
    return result;
  }
  if ((*(unsigned char *)(*((void *)this + 1) + 98) & 8) == 0) {
    goto LABEL_3;
  }
  if (v9 == 7)
  {
    BOOL v5 = *v8 != 1297699631 || *(_DWORD *)((char *)v8 + 3) != 791950925;
    goto LABEL_4;
  }
  if (v9 == 2)
  {
    if (*(_WORD *)v8 != 12079)
    {
LABEL_19:
      BOOL v5 = 1;
      goto LABEL_4;
    }
  }
  else if (v9 != 1 || *(unsigned char *)v8 != 47)
  {
    goto LABEL_19;
  }
LABEL_3:
  BOOL v5 = 0;
LABEL_4:
  *(unsigned char *)(a2 + 8) &= ~1u;
  *(unsigned char *)a2 = v5;
  return result;
}

void llvm::object::ArchiveMemberHeader::getNextChildLoc(llvm::object::ArchiveMemberHeader *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (*(uint64_t (**)(llvm::object::ArchiveMemberHeader *))(*(void *)this + 104))(this);
  (*(void (**)(unint64_t *__return_ptr, llvm::object::ArchiveMemberHeader *))(*(void *)this + 96))(&v12, this);
  if (v13)
  {
    unint64_t v9 = v12;
    unint64_t v12 = 0;
LABEL_11:
    *(unsigned char *)(a2 + 8) |= 1u;
    *(void *)a2 = v9;
    goto LABEL_7;
  }
  if ((_BYTE)v12) {
    goto LABEL_5;
  }
  (*(void (**)(__n128 *__return_ptr, llvm::object::ArchiveMemberHeader *))(*(void *)this + 72))(v11, this);
  if (v11[0].n128_u8[8])
  {
    unint64_t v9 = v11[0].n128_u64[0];
    goto LABEL_11;
  }
  v4 += v11[0].n128_u64[0];
LABEL_5:
  unint64_t v6 = (__n128 *)*((void *)this + 1);
  unint64_t v7 = *((void *)this + 2) + ((v4 + 1) & 0xFFFFFFFFFFFFFFFELL);
  __n128 MemoryBufferRef = llvm::object::Binary::getMemoryBufferRef(v6, v11);
  unint64_t v8 = v11[0].n128_u64[0] + v11[0].n128_u64[1];
  *(unsigned char *)(a2 + 8) &= ~1u;
  if (v7 == v8) {
    *(void *)a2 = 0;
  }
  else {
    *(void *)a2 = v7;
  }
LABEL_7:
  if (v13)
  {
    unint64_t v10 = v12;
    unint64_t v12 = 0;
    if (v10) {
      (*(void (**)(unint64_t, __n128))(*(void *)v10 + 8))(v10, MemoryBufferRef);
    }
  }
}

uint64_t llvm::object::BigArchiveMemberHeader::getNextChildLoc@<X0>(llvm::object::BigArchiveMemberHeader *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t result = (*(uint64_t (**)(llvm::object::BigArchiveMemberHeader *))(*(void *)this + 80))(this);
  if (result == *(void *)(*((void *)this + 1) + 144))
  {
    *(unsigned char *)(a2 + 8) &= ~1u;
    *(void *)a2 = 0;
  }
  else
  {
    uint64_t result = llvm::object::BigArchiveMemberHeader::getNextOffset(this, (uint64_t)&v7);
    if (v8)
    {
      uint64_t v5 = v7;
      char v6 = *(unsigned char *)(a2 + 8) | 1;
    }
    else
    {
      uint64_t v5 = *(void *)(*((void *)this + 1) + 16) + v7;
      char v6 = *(unsigned char *)(a2 + 8) & 0xFE;
    }
    *(unsigned char *)(a2 + 8) = v6;
    *(void *)a2 = v5;
  }
  return result;
}

void llvm::object::Archive::Child::Child(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int16 a5)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = a4;
  *(_WORD *)(a1 + 32) = a5;
  llvm::object::Archive::createArchiveMemberHeader();
}

void llvm::object::Archive::createArchiveMemberHeader()
{
}

void *llvm::object::Archive::Child::Child(void *result, uint64_t a2, uint64_t a3)
{
  void *result = a2;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  if (a3) {
    llvm::object::Archive::createArchiveMemberHeader();
  }
  return result;
}

void llvm::object::Archive::Child::getFullName(llvm::object::Archive::Child *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 1) + 96))(&v23);
  if (v24)
  {
    uint64_t v4 = v23;
    *(unsigned char *)(a2 + 24) |= 1u;
    *(void *)a2 = v4;
  }
  else
  {
    llvm::object::Archive::Child::getName(this, (uint64_t)&v21);
    uint64_t v5 = (const std::string::value_type *)v21;
    if (v22)
    {
      *(unsigned char *)(a2 + 24) |= 1u;
      *(void *)a2 = v5;
    }
    else
    {
      std::string::size_type v6 = *((void *)&v21 + 1);
      char v20[4] = 261;
      *(_OWORD *)&v19.__r_.__value_.__l.__data_ = v21;
      if (llvm::sys::path::is_absolute((const char **)&v19.__r_.__value_.__l.__data_, 0))
      {
        std::string::__init(&v19, v5, v6);
        *(unsigned char *)(a2 + 24) &= ~1u;
        *(std::string *)a2 = v19;
      }
      else
      {
        llvm::object::Binary::getMemoryBufferRef(*(__n128 **)this, (__n128 *)&v16);
        char v8 = llvm::sys::path::parent_path((unsigned __int8 *)v16.__r_.__value_.__r.__words[2], v17, 0);
        v19.__r_.__value_.__r.__words[0] = (std::string::size_type)v20;
        *(_OWORD *)&v19.__r_.__value_.__r.__words[1] = xmmword_1CFAC3020;
        sub_1CC22C75C(&v19, v8, &v8[v9]);
        __int16 v18 = 261;
        v16.__r_.__value_.__r.__words[0] = (std::string::size_type)v5;
        v16.__r_.__value_.__l.__size_ = v6;
        __int16 v15 = 257;
        __int16 v13 = 257;
        __int16 v11 = 257;
        llvm::sys::path::append(&v19, (const char **)&v16.__r_.__value_.__l.__data_, &v14, (uint64_t)v12, (uint64_t)v10);
        std::string::__init(&v16, v19.__r_.__value_.__l.__data_, v19.__r_.__value_.__l.__size_);
        *(unsigned char *)(a2 + 24) &= ~1u;
        *(std::string *)a2 = v16;
        if (v19.__r_.__value_.__l.__data_ != (std::string::pointer)v20) {
          free(v19.__r_.__value_.__l.__data_);
        }
      }
    }
    if (v24)
    {
      uint64_t v7 = v23;
      uint64_t v23 = 0;
      if (v7) {
        (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
      }
    }
  }
}

void *llvm::object::Archive::Child::getName@<X0>(llvm::object::Archive::Child *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t result = (*(void *(**)(void **__return_ptr))(**((void **)this + 1) + 72))(&v12);
  if (v13)
  {
    char v8 = v12;
    *(unsigned char *)(a2 + 16) |= 1u;
    *(void *)a2 = v8;
  }
  else
  {
    uint64_t v5 = v12;
    uint64_t v6 = *((void *)this + 1);
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 104))(v6);
    uint64_t result = (*(void *(**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v6 + 64))(&v10, v6, (uint64_t)v5 + v7);
    if (v11)
    {
      uint64_t v9 = v10;
      *(unsigned char *)(a2 + 16) |= 1u;
      *(void *)a2 = v9;
    }
    else
    {
      *(_OWORD *)a2 = v10;
      *(unsigned char *)(a2 + 16) &= ~1u;
    }
    if (v13)
    {
      uint64_t result = v12;
      unint64_t v12 = 0;
      if (result) {
        return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
      }
    }
  }
  return result;
}

void llvm::object::Archive::Child::getBuffer(llvm::object::Archive::Child *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 1) + 96))(&v31);
  if (v32)
  {
    uint64_t v7 = v31;
    uint64_t v31 = 0;
    *(unsigned char *)(a2 + 16) |= 1u;
    *(void *)a2 = v7;
    goto LABEL_7;
  }
  if (!(_BYTE)v31)
  {
    if ((*(unsigned char *)(*(void *)this + 98) & 8) != 0)
    {
      (*(void (**)(void ***__return_ptr))(**((void **)this + 1) + 72))(&v23);
      if (v24)
      {
        uint64_t v6 = v23;
        *(unsigned char *)(a2 + 16) |= 1u;
        goto LABEL_6;
      }
      uint64_t v4 = *((unsigned __int16 *)this + 16);
      uint64_t v5 = v23;
    }
    else
    {
      uint64_t v4 = *((unsigned __int16 *)this + 16);
      uint64_t v5 = (void **)(*((void *)this + 3) - v4);
    }
    uint64_t v6 = (void **)(*((void *)this + 2) + v4);
    *(unsigned char *)(a2 + 16) &= ~1u;
    *(void *)(a2 + 8) = v5;
LABEL_6:
    *(void *)a2 = v6;
    goto LABEL_7;
  }
  llvm::object::Archive::Child::getFullName(this, (uint64_t)__p);
  char v9 = v30;
  if ((v30 & 1) == 0)
  {
    __int16 v25 = 260;
    uint64_t v23 = __p;
    llvm::MemoryBuffer::getFile((llvm::MemoryBuffer *)&v23, 0, 1, 0, (uint64_t)&v26);
    if ((uint64_t)v27.__cat_)
    {
      if (v26)
      {
        *(void *)&v10.__val_ = *(void *)&v27.__val_;
        llvm::errorCodeToError(v26, v10, &v22);
        *(unsigned char *)(a2 + 16) |= 1u;
        *(void *)a2 = v22;
        uint64_t v22 = 0;
LABEL_24:
        if (((uint64_t)v27.__cat_ & 1) == 0)
        {
          int v20 = v26;
          unint64_t v26 = 0;
          if (v20) {
            (*(void (**)(llvm *))(*(void *)v20 + 8))(v20);
          }
        }
        char v9 = v30;
        goto LABEL_28;
      }
    }
    else
    {
      std::system_category();
    }
    char v11 = *(char ***)this;
    unint64_t v12 = *(llvm ***)(*(void *)this + 112);
    if ((unint64_t)v12 >= *(void *)(*(void *)this + 120))
    {
      uint64_t v14 = sub_1CCC16D34(v11 + 13, &v26);
      __int16 v15 = *(void **)this;
    }
    else
    {
      char v13 = v26;
      unint64_t v26 = 0;
      *unint64_t v12 = v13;
      uint64_t v14 = (char *)(v12 + 1);
      __int16 v15 = v11;
    }
    v11[14] = v14;
    uint64_t v17 = *(void *)(v15[14] - 8);
    uint64_t v18 = *(void *)(v17 + 8);
    uint64_t v19 = *(void *)(v17 + 16) - v18;
    *(unsigned char *)(a2 + 16) &= ~1u;
    *(void *)a2 = v18;
    *(void *)(a2 + 8) = v19;
    goto LABEL_24;
  }
  std::string v16 = __p[0];
  __p[0] = 0;
  *(unsigned char *)(a2 + 16) |= 1u;
  *(void *)a2 = v16;
LABEL_28:
  if (v9)
  {
    long long v21 = __p[0];
    __p[0] = 0;
    if (v21) {
      (*(void (**)(void *))(*(void *)v21 + 8))(v21);
    }
  }
  else if (v29 < 0)
  {
    operator delete(__p[0]);
  }
LABEL_7:
  if (v32)
  {
    uint64_t v8 = v31;
    uint64_t v31 = 0;
    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    }
  }
}

void *llvm::object::Archive::Child::getNext@<X0>(llvm::object::Archive::Child *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t result = (*(void *(**)(unint64_t *__return_ptr))(**((void **)this + 1) + 88))(&v22);
  unint64_t v5 = v22;
  if (v23)
  {
    unint64_t v22 = 0;
    *(unsigned char *)(a2 + 40) |= 1u;
    *(void *)a2 = v5;
  }
  else if (v22)
  {
    uint64_t v6 = *(void **)this;
    if (v22 > *(void *)(*(void *)this + 16) + *(void *)(*(void *)this + 24))
    {
      uint64_t v18 = (char *)operator new(0x48uLL);
      long long v19 = xmmword_1CFB29060;
      strcpy(v18, "offset to next archive member past the end of the archive after member ");
      llvm::object::Archive::Child::getName(this, (uint64_t)v20);
      if ((v21 & 1) == 0)
      {
        __int16 v14 = 260;
        *(void *)&v13[0] = &v18;
        __int16 v11 = 261;
        v10[0] = v20[0];
        v10[1] = v20[1];
        sub_1CB8F1E58((uint64_t *)v13, v10, (uint64_t)v9);
        sub_1CCC16404(a2, (llvm::Twine *)v9);
      }
      uint64_t v17 = (void *)v20[0];
      sub_1CD4515D0(&v17);
      if (v17) {
        (*(void (**)(void *))(*v17 + 8))(v17);
      }
      uint64_t v16 = *((void *)this + 2) - *(void *)(*(void *)this + 16);
      sub_1CBAD7600("at offset ", (const void **)&v18, __p);
      __int16 v14 = 260;
      *(void *)&v13[0] = __p;
      __int16 v11 = 268;
      v10[0] = (uint64_t)&v16;
      sub_1CB8F1E58((uint64_t *)v13, v10, (uint64_t)v15);
      sub_1CCC16404(a2, (llvm::Twine *)v15);
    }
    v10[0] = 0;
    uint64_t result = llvm::object::Archive::Child::Child(v13, (uint64_t)v6, v22);
    *(unsigned char *)(a2 + 40) &= ~1u;
    *(_WORD *)(a2 + 32) = v14;
    long long v8 = v13[0];
    long long v7 = v13[1];
    *((void *)&v13[0] + 1) = 0;
    *(_OWORD *)a2 = v8;
    *(_OWORD *)(a2 + 16) = v7;
  }
  else
  {
    *(unsigned char *)(a2 + 40) &= ~1u;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
  }
  if (v23)
  {
    uint64_t result = (void *)v22;
    unint64_t v22 = 0;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  return result;
}

double llvm::object::Archive::Child::getMemoryBufferRef@<D0>(llvm::object::Archive::Child *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  llvm::object::Archive::Child::getName(this, (uint64_t)v12);
  uint64_t v5 = v12[0];
  if (v13)
  {
    *(unsigned char *)(a2 + 32) |= 1u;
    *(void *)a2 = v5;
  }
  else
  {
    uint64_t v6 = v12[1];
    llvm::object::Archive::Child::getBuffer(this, (uint64_t)&v10);
    if (v11)
    {
      __int16 v8 = 261;
      v7[0] = v5;
      v7[1] = v6;
      uint64_t v9 = v10;
      sub_1CC226C78((uint64_t)v7, 0, 0, &v9);
    }
    *(unsigned char *)(a2 + 32) &= ~1u;
    double result = *(double *)&v10;
    *(_OWORD *)a2 = v10;
    *(void *)(a2 + 16) = v5;
    *(void *)(a2 + 24) = v6;
  }
  return result;
}

void llvm::object::Archive::create(uint64_t a1)
{
  uint64_t v1 = 0;
  if (*(void *)(a1 + 8) >= 8uLL && **(void **)a1 == 0xA3E66616769623CLL) {
    operator new();
  }
  operator new();
}

uint64_t llvm::object::Archive::Archive(uint64_t a1, _OWORD *a2, uint64_t *a3)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  long long v5 = a2[1];
  v46[0] = *a2;
  v46[1] = v5;
  llvm::object::Binary::Binary(a1, 0, (uint64_t)v46);
  *(void *)uint64_t v6 = &unk_1F26327B8;
  *(_OWORD *)(v6 + 48) = 0u;
  long long v7 = (_OWORD *)(v6 + 48);
  *(_OWORD *)(v6 + 64) = 0u;
  __int16 v8 = (_OWORD *)(v6 + 64);
  *(_OWORD *)(v6 + 80) = 0u;
  uint64_t v9 = (_OWORD *)(v6 + 80);
  *(_WORD *)(v6 + 96) = -1;
  *(void *)(v6 + 112) = 0;
  *(void *)(v6 + 120) = 0;
  *(void *)(v6 + 104) = 0;
  if (*(void *)(v6 + 24) < 8uLL) {
    goto LABEL_43;
  }
  long long v10 = *(void **)(a1 + 16);
  if (*v10 != 0xA3E6E6968743C21)
  {
    if (*v10 == 0xA3E686372613C21)
    {
      char v11 = *(unsigned char *)(a1 + 98) & 0xF7;
      goto LABEL_5;
    }
    if (*v10 == 0xA3E66616769623CLL)
    {
      *(unsigned char *)(a1 + 98) = *(unsigned char *)(a1 + 98) & 0xF0 | 6;
      goto LABEL_37;
    }
LABEL_43:
    int v37 = 2;
    sub_1CCC16E40();
  }
  char v11 = *(unsigned char *)(a1 + 98) | 8;
LABEL_5:
  *(unsigned char *)(a1 + 98) = v11 & 0xF8;
  llvm::object::Archive::child_begin(a1, a3, 0, (uint64_t)&v41);
  if (!*a3)
  {
    llvm::object::Archive::child_end((uint64_t)&v37);
    unint64_t v12 = v40;
    if (v45 <= 7 && v40 < 8 || (uint64_t v13 = v39, (void)v43 == v39))
    {
      *a3 = 0;
LABEL_33:
      if (v38) {
        (*(void (**)(uint64_t))(*(void *)v38 + 16))(v38);
      }
      goto LABEL_35;
    }
    uint64_t v14 = (llvm::object *)(*(void *(**)(uint64_t *__return_ptr))(*(void *)v42 + 24))(&v51);
    uint64_t v15 = v51;
    if (v53)
    {
      uint64_t v51 = 0;
      goto LABEL_45;
    }
    if (v52 == 12)
    {
      if (*(void *)v51 != 0x45444D59532E5F5FLL || *(_DWORD *)(v51 + 8) != 875978566) {
        goto LABEL_13;
      }
      char v23 = 4;
    }
    else
    {
      if (v52 != 9)
      {
        if (v52 < 3)
        {
          uint64_t v25 = v52;
          if (v52 != 1)
          {
            BOOL v36 = 0;
LABEL_81:
            if (v25 != 2) {
              goto LABEL_85;
            }
            if (*(_WORD *)v15 != 12079)
            {
              uint64_t v25 = 2;
              goto LABEL_85;
            }
            *(unsigned char *)(a1 + 98) = *(unsigned char *)(a1 + 98) & 0xF8 | v36;
            llvm::object::Archive::Child::getBuffer((llvm::object::Archive::Child *)&v41, (uint64_t)&v49);
            if (v50) {
              goto LABEL_88;
            }
            _OWORD *v8 = v49;
            goto LABEL_60;
          }
          if (*(unsigned char *)v51 != 47)
          {
            BOOL v36 = 0;
            goto LABEL_89;
          }
          goto LABEL_107;
        }
LABEL_13:
        if (*(_WORD *)v51 != 12579 || *(unsigned char *)(v51 + 2) != 47)
        {
          uint64_t v25 = v52;
          if (v52 != 7)
          {
            BOOL v36 = 0;
LABEL_85:
            if (*(unsigned char *)v15 == 47)
            {
              if (v25 != 1)
              {
                *(void *)&v55.__val_ = llvm::object::object_category(v14);
                llvm::errorCodeToError((llvm *)3, v55, &v49);
                goto LABEL_88;
              }
              *(unsigned char *)(a1 + 98) = *(unsigned char *)(a1 + 98) & 0xF8 | 5;
              llvm::object::Archive::Child::getBuffer((llvm::object::Archive::Child *)&v41, (uint64_t)&v49);
              if (v50) {
                goto LABEL_88;
              }
              *long long v7 = v49;
              sub_1CD5DF480((uint64_t)&v41);
              if (!*a3)
              {
                BOOL v33 = v12 >= 8 || v45 >= 8;
                if (v33 && (void)v43 != v13)
                {
                  (*(void (**)(long long *__return_ptr))(*(void *)v42 + 24))(&v47);
                  sub_1CD452A68(&v51, &v47);
                  if (v48)
                  {
                    uint64_t v34 = v47;
                    *(void *)&long long v47 = 0;
                    if (v34) {
                      (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
                    }
                  }
                  if (v53)
                  {
                    uint64_t v17 = v51;
                    uint64_t v51 = 0;
                    goto LABEL_132;
                  }
                  if (v52 == 2 && *(_WORD *)v51 == 12079)
                  {
                    llvm::object::Archive::Child::getBuffer((llvm::object::Archive::Child *)&v41, (uint64_t)&v47);
                    if (v48) {
                      goto LABEL_131;
                    }
                    _OWORD *v8 = v47;
                    sub_1CD5DF480((uint64_t)&v41);
                    if (*a3) {
                      goto LABEL_32;
                    }
                  }
                }
                goto LABEL_90;
              }
LABEL_32:
              if (v53)
              {
                uint64_t v28 = v51;
                uint64_t v51 = 0;
                if (v28) {
                  (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
                }
              }
              goto LABEL_33;
            }
LABEL_89:
            *(unsigned char *)(a1 + 98) = *(unsigned char *)(a1 + 98) & 0xF8 | v36;
LABEL_90:
            *uint64_t v9 = v43;
            *(_WORD *)(a1 + 96) = v44;
LABEL_91:
            *a3 = 0;
            goto LABEL_32;
          }
          if (*(_DWORD *)v51 != 1297699631 || *(_DWORD *)(v51 + 3) != 791950925)
          {
            BOOL v36 = 0;
            uint64_t v25 = 7;
            goto LABEL_85;
          }
LABEL_107:
          llvm::object::Archive::Child::getBuffer((llvm::object::Archive::Child *)&v41, (uint64_t)&v49);
          if (v50) {
            goto LABEL_88;
          }
          *long long v7 = v49;
          if (v25 == 7)
          {
            BOOL v32 = *(_DWORD *)v15 == 1297699631 && *(_DWORD *)(v15 + 3) == 791950925;
            BOOL v36 = v32;
          }
          else
          {
            BOOL v36 = 0;
          }
          sub_1CD5DF480((uint64_t)&v41);
          if (*a3) {
            goto LABEL_32;
          }
          BOOL v35 = v12 >= 8 || v45 >= 8;
          if (!v35 || (void)v43 == v13) {
            goto LABEL_91;
          }
          uint64_t v14 = (llvm::object *)(*(void *(**)(long long *__return_ptr))(*(void *)v42 + 24))(&v47);
          uint64_t v15 = v47;
          if ((v48 & 1) == 0)
          {
            uint64_t v25 = *((void *)&v47 + 1);
            goto LABEL_81;
          }
LABEL_45:
          *a3 = v15;
          goto LABEL_32;
        }
        *(unsigned char *)(a1 + 98) = *(unsigned char *)(a1 + 98) & 0xF8 | 2;
        llvm::object::Archive::Child::getName((llvm::object::Archive::Child *)&v41, (uint64_t)&v49);
        uint64_t v17 = v49;
        if (v50) {
          goto LABEL_132;
        }
        switch(*((void *)&v49 + 1))
        {
          case 0x13:
            if (*(void *)v49 != 0x45444D59532E5F5FLL
              || *(void *)(v49 + 8) != 0x524F532034365F46
              || *(void *)(v49 + 11) != 0x444554524F532034)
            {
              goto LABEL_31;
            }
            break;
          case 9:
            if (*(void *)v49 != 0x45444D59532E5F5FLL || *(unsigned char *)(v49 + 8) != 70) {
              goto LABEL_31;
            }
            goto LABEL_29;
          case 0xCLL:
            if (*(void *)v49 != 0x45444D59532E5F5FLL || *(_DWORD *)(v49 + 8) != 875978566) {
              goto LABEL_31;
            }
            break;
          case 0x10:
            if (*(void *)v49 != 0x45444D59532E5F5FLL || *(void *)(v49 + 8) != 0x444554524F532046) {
              goto LABEL_31;
            }
            goto LABEL_29;
          default:
            goto LABEL_31;
        }
        *(unsigned char *)(a1 + 98) = *(unsigned char *)(a1 + 98) & 0xF8 | 4;
LABEL_29:
        llvm::object::Archive::Child::getBuffer((llvm::object::Archive::Child *)&v41, (uint64_t)&v47);
        if (v48)
        {
LABEL_131:
          uint64_t v17 = v47;
          goto LABEL_132;
        }
        *long long v7 = v47;
        sub_1CD5DF480((uint64_t)&v41);
        if (*a3) {
          goto LABEL_32;
        }
LABEL_31:
        *uint64_t v9 = v43;
        *(_WORD *)(a1 + 96) = v44;
        goto LABEL_32;
      }
      if (*(void *)v51 != 0x45444D59532E5F5FLL || *(unsigned char *)(v51 + 8) != 70) {
        goto LABEL_13;
      }
      char v23 = 2;
    }
    *(unsigned char *)(a1 + 98) = *(unsigned char *)(a1 + 98) & 0xF8 | v23;
    llvm::object::Archive::Child::getBuffer((llvm::object::Archive::Child *)&v41, (uint64_t)&v49);
    if (v50)
    {
LABEL_88:
      uint64_t v17 = v49;
      goto LABEL_132;
    }
    *long long v7 = v49;
LABEL_60:
    sub_1CD5DF480((uint64_t)&v41);
    uint64_t v17 = *a3;
    if (*a3) {
      goto LABEL_32;
    }
    *uint64_t v9 = v43;
    *(_WORD *)(a1 + 96) = v44;
LABEL_132:
    *a3 = v17;
    goto LABEL_32;
  }
LABEL_35:
  uint64_t v20 = v42;
  uint64_t v42 = 0;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 16))(v20);
  }
LABEL_37:
  if (!*a3) {
    *a3 = 0;
  }
  return a1;
}

uint64_t llvm::object::Archive::child_begin@<X0>(uint64_t a1@<X0>, void *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (*(void *)(a1 + 24) == 8)
  {
    return llvm::object::Archive::child_end(a4);
  }
  else
  {
    if (a3) {
      llvm::object::Archive::Child::Child((uint64_t)&v17, a1, *(void *)(a1 + 80), *(void *)(a1 + 88), *(_WORD *)(a1 + 96));
    }
    uint64_t v7 = *(void *)(a1 + 16);
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
    llvm::object::Archive::Child::Child(&v17, a1, v7 + v8);
    if (*a2)
    {
      llvm::object::Archive::child_end(a4);
    }
    else
    {
      sub_1CD5E0680((uint64_t)&v13, (uint64_t)&v17);
      uint64_t v9 = v14;
      uint64_t v10 = v15;
      __int16 v11 = v16;
      *(_OWORD *)a4 = v13;
      *(void *)(a4 + 16) = v9;
      *(void *)(a4 + 24) = v10;
      *(_WORD *)(a4 + 32) = v11;
      *(void *)(a4 + 40) = a2;
      *((void *)&v13 + 1) = 0;
    }
    uint64_t result = v18;
    uint64_t v18 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
    }
  }
  return result;
}

uint64_t llvm::object::Archive::child_end@<X0>(uint64_t a1@<X8>)
{
  memset(v7, 0, 32);
  sub_1CD5E0680((uint64_t)&v8, (uint64_t)v7);
  uint64_t v3 = v9;
  uint64_t v4 = v10;
  __int16 v5 = v11;
  *(_OWORD *)a1 = v8;
  *(void *)(a1 + 16) = v3;
  *(void *)(a1 + 24) = v4;
  *(_WORD *)(a1 + 32) = v5;
  *(void *)(a1 + 40) = 0;
  *((void *)&v8 + 1) = 0;
  uint64_t result = *((void *)&v7[0] + 1);
  *((void *)&v7[0] + 1) = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
  }
  return result;
}

__n128 llvm::object::Archive::Symbol::getMember@<Q0>(llvm::object::Archive::Symbol *this@<X0>, __n128 *a2@<X8>)
{
  uint64_t v3 = *(void *)this;
  int v4 = *(unsigned char *)(*(void *)this + 98) & 7;
  BOOL v5 = v4 == 4 || v4 == 1;
  uint64_t v6 = 1;
  if (v5) {
    uint64_t v6 = 2;
  }
  uint64_t v7 = *(unsigned int **)(v3 + 48);
  long long v8 = &v7[v6];
  switch(*(unsigned char *)(*(void *)this + 98) & 7)
  {
    case 0:
      unint64_t v15 = bswap32(*(unsigned int *)((char *)v8 + (4 * *((_DWORD *)this + 2))));
      goto LABEL_17;
    case 1:
      unint64_t v15 = bswap64(*(void *)((char *)v8 + (8 * *((_DWORD *)this + 2))));
      goto LABEL_17;
    case 2:
      unint64_t v15 = *(unsigned int *)((char *)v8 + (8 * *((_DWORD *)this + 2)) + 4);
      goto LABEL_17;
    case 4:
      unint64_t v15 = *(void *)((char *)v8 + (16 * *((_DWORD *)this + 2)) + 8);
      goto LABEL_17;
    default:
      unsigned int v9 = *v7;
      uint64_t v10 = &v7[*v7 + 1];
      unsigned int v11 = *((_DWORD *)this + 2);
      if (v11 >= *v10)
      {
        *(void *)&v25.__val_ = llvm::object::object_category(this);
        llvm::errorCodeToError((llvm *)3, v25, &v23);
        a2[2].n128_u8[8] |= 1u;
        unint64_t v14 = v23;
        goto LABEL_11;
      }
      unsigned __int16 v12 = *((_WORD *)v10 + v11 + 2) - 1;
      if (v9 <= v12)
      {
        *(void *)&v24.__val_ = llvm::object::object_category(this);
        llvm::errorCodeToError((llvm *)3, v24, &v22);
        a2[2].n128_u8[8] |= 1u;
        unint64_t v14 = v22;
LABEL_11:
        a2->n128_u64[0] = v14;
        return result;
      }
      unint64_t v15 = v8[v12];
LABEL_17:
      uint64_t v16 = *(void *)(v3 + 16) + v15;
      unint64_t v21 = 0;
      llvm::object::Archive::Child::Child(v19, v3, v16);
      unint64_t v17 = v21;
      if (v21)
      {
        unint64_t v21 = 0;
        a2[2].n128_u8[8] |= 1u;
        uint64_t v18 = *((void *)&v19[0] + 1);
        a2->n128_u64[0] = v17;
        *((void *)&v19[0] + 1) = 0;
        if (v18)
        {
          (*(void (**)(uint64_t))(*(void *)v18 + 16))(v18);
          if (v21) {
            (*(void (**)(unint64_t))(*(void *)v21 + 8))(v21);
          }
        }
      }
      else
      {
        a2[2].n128_u8[8] &= ~1u;
        a2[2].n128_u16[0] = v20;
        __n128 result = (__n128)v19[1];
        *a2 = (__n128)v19[0];
        a2[1] = result;
      }
      return result;
  }
}

uint64_t llvm::object::Archive::Symbol::getNext(llvm::object::Archive::Symbol *this)
{
  uint64_t v1 = *(void *)this;
  unint64_t v2 = *((void *)this + 1);
  if ((*(unsigned char *)(*(void *)this + 98) & 7) != 2)
  {
    unint64_t v3 = *(void *)(v1 + 56);
    if (v3 > HIDWORD(v2)) {
      memchr((void *)(*(void *)(v1 + 48) + HIDWORD(v2)), 0, v3 - HIDWORD(v2));
    }
  }
  return v1;
}

BOOL llvm::object::Archive::hasSymbolTable(llvm::object::Archive *this)
{
  return *((void *)this + 7) != 0;
}

unint64_t llvm::object::Archive::getNumberOfSymbols(llvm::object::Archive *this)
{
  if (!*((void *)this + 7)) {
    return 0;
  }
  uint64_t v1 = (unsigned int *)*((void *)this + 6);
  switch(*((unsigned char *)this + 98) & 7)
  {
    case 0:
      unint64_t result = bswap32(*v1);
      break;
    case 1:
      unint64_t result = bswap64(*(void *)v1);
      break;
    case 2:
      unint64_t result = *v1 >> 3;
      break;
    case 4:
      unint64_t result = *(void *)v1 >> 4;
      break;
    default:
      unint64_t result = v1[*v1 + 1];
      break;
  }
  return result;
}

unint64_t llvm::object::Archive::findSym@<X0>(llvm::object::Archive *a1@<X0>, const void *a2@<X1>, size_t a3@<X2>, __n128 *a4@<X8>)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  llvm::object::Archive::symbol_begin(a1);
  unsigned int v9 = v8;
  unint64_t v11 = v10;
  unint64_t v25 = (unint64_t)v8;
  unint64_t v26 = v10;
  unint64_t result = llvm::object::Archive::getNumberOfSymbols(a1);
  int v13 = result;
  if (v9 != a1) {
    goto LABEL_5;
  }
LABEL_2:
  if (v13 == v11)
  {
    a4[3].n128_u8[0] &= ~1u;
    a4->n128_u8[0] = 0;
    a4[2].n128_u8[8] = 0;
  }
  else
  {
LABEL_5:
    while (1)
    {
      uint64_t v14 = *((void *)v9 + 6);
      unint64_t v15 = (const void *)(v14 + HIDWORD(v11));
      size_t v16 = v14 ? strlen((const char *)(v14 + HIDWORD(v11))) : 0;
      if (v16 == a3 && (!a3 || !memcmp(v15, a2, a3))) {
        break;
      }
      unint64_t result = llvm::object::Archive::Symbol::getNext((llvm::object::Archive::Symbol *)&v25);
      unsigned int v9 = (llvm::object::Archive *)result;
      unint64_t v11 = v17;
      unint64_t v25 = result;
      unint64_t v26 = v17;
      if ((llvm::object::Archive *)result == a1) {
        goto LABEL_2;
      }
    }
    __n128 Member = llvm::object::Archive::Symbol::getMember((llvm::object::Archive::Symbol *)&v25, v27);
    char v19 = v28;
    if (v28)
    {
      unint64_t v20 = v27[0].n128_u64[0];
      v27[0].n128_u64[0] = 0;
      unsigned __int8 v21 = a4[3].n128_u8[0] | 1;
    }
    else
    {
      sub_1CD5E0680((uint64_t)v22, (uint64_t)v27);
      unsigned __int8 v21 = a4[3].n128_u8[0] & 0xFE;
      unint64_t v20 = v22[0];
      a4->n128_u64[1] = v22[1];
      __n128 Member = v23;
      a4[1] = v23;
      a4[2].n128_u16[0] = v24;
      a4[2].n128_u8[8] = 1;
      char v19 = v28;
    }
    a4[3].n128_u8[0] = v21;
    a4->n128_u64[0] = v20;
    if (v19)
    {
      unint64_t result = v27[0].n128_u64[0];
      v27[0].n128_u64[0] = 0;
      if (result) {
        return (*(uint64_t (**)(unint64_t, __n128))(*(void *)result + 8))(result, Member);
      }
    }
    else
    {
      unint64_t result = v27[0].n128_u64[1];
      v27[0].n128_u64[1] = 0;
      if (result) {
        return (*(uint64_t (**)(unint64_t, __n128))(*(void *)result + 16))(result, Member);
      }
    }
  }
  return result;
}

uint64_t llvm::object::BigArchive::BigArchive(uint64_t a1, _OWORD *a2, uint64_t *a3)
{
  long long v5 = a2[1];
  v33[0] = *a2;
  v33[1] = v5;
  uint64_t v6 = (void *)llvm::object::Archive::Archive(a1, v33, a3);
  *uint64_t v6 = &unk_1F26327F0;
  v6[17] = 0;
  uint64_t v7 = (const char **)(v6 + 17);
  v6[18] = 0;
  uint64_t v8 = v6[2];
  v6[16] = v8;
  unint64_t v25 = (const char *)(v8 + 68);
  unint64_t v26 = 20;
  uint64_t last_not_of = llvm::StringRef::find_last_not_of(&v25, " ", 1, 0xFFFFFFFFFFFFFFFFLL);
  unint64_t v10 = (unsigned __int8 *)v25;
  if (last_not_of + 1 < v26) {
    unint64_t v11 = last_not_of + 1;
  }
  else {
    unint64_t v11 = v26;
  }
  unint64_t v12 = v26 + v11 - 20;
  if (v26 >= v12) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = v26;
  }
  unint64_t v25 = 0;
  if (llvm::getAsUnsignedInteger(v10, v13, 0xAu, (unint64_t *)&v25))
  {
    __int16 v28 = 1283;
    unint64_t v25 = "malformed AIX big archive: first member offset \"";
    *(void *)&long long v27 = v10;
    *((void *)&v27 + 1) = v13;
    unint64_t v20 = "\" is not a number";
    __int16 v23 = 259;
    sub_1CB8F1E58((uint64_t *)&v25, (uint64_t *)&v20, (uint64_t)v31);
    sub_1CCC16404((int)&v32, (llvm::Twine *)v31);
  }
  *uint64_t v7 = v25;
  unint64_t v25 = (const char *)(*(void *)(a1 + 128) + 88);
  unint64_t v26 = 20;
  uint64_t v14 = llvm::StringRef::find_last_not_of(&v25, " ", 1, 0xFFFFFFFFFFFFFFFFLL);
  unint64_t v15 = (unsigned __int8 *)v25;
  if (v14 + 1 < v26) {
    unint64_t v16 = v14 + 1;
  }
  else {
    unint64_t v16 = v26;
  }
  unint64_t v17 = v26 + v16 - 20;
  if (v26 >= v17) {
    uint64_t v18 = v17;
  }
  else {
    uint64_t v18 = v26;
  }
  unint64_t v25 = 0;
  if (llvm::getAsUnsignedInteger(v15, v18, 0xAu, (unint64_t *)&v25))
  {
    __int16 v28 = 1283;
    unint64_t v25 = "malformed AIX big archive: last member offset \"";
    *(void *)&long long v27 = v15;
    *((void *)&v27 + 1) = v18;
    unint64_t v20 = "\" is not a number";
    __int16 v23 = 259;
    sub_1CB8F1E58((uint64_t *)&v25, (uint64_t *)&v20, (uint64_t)v30);
    sub_1CCC16404((int)&v32, (llvm::Twine *)v30);
  }
  *(void *)(a1 + 144) = v25;
  llvm::object::Archive::child_begin(a1, a3, 0, (uint64_t)&v25);
  if (!*a3)
  {
    llvm::object::Archive::child_end((uint64_t)&v20);
    if ((v29 > 7 || v24 >= 8) && (void)v27 != v22)
    {
      *(_OWORD *)(a1 + 80) = v27;
      *(_WORD *)(a1 + 96) = v28;
    }
    *a3 = 0;
    if (v21) {
      (*(void (**)(uint64_t))(*(void *)v21 + 16))(v21);
    }
  }
  if (v26) {
    (*(void (**)(unint64_t))(*(void *)v26 + 16))(v26);
  }
  if (!*a3) {
    *a3 = 0;
  }
  return a1;
}

void sub_1CD6C6BAC(void **a1)
{
  *a1 = &unk_1F26327B8;
  unint64_t v2 = a1 + 13;
  sub_1CC66CFA8(&v2);
  llvm::object::Binary::~Binary((llvm::object::Binary *)a1);
}

uint64_t sub_1CD6C6C08(void **a1)
{
  *a1 = &unk_1F26327B8;
  unint64_t v3 = a1 + 13;
  sub_1CC66CFA8(&v3);
  llvm::object::Binary::~Binary((llvm::object::Binary *)a1);
  return MEMORY[0x1D25D9CE0]();
}

void sub_1CD6C6C78(void *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1CD6C6C80()
{
  return 8;
}

void sub_1CD6C6C88()
{
}

void sub_1CD6C6CF0()
{
}

void sub_1CD6C6D04()
{
}

void sub_1CD6C6D6C()
{
}

void sub_1CD6C6D80(unsigned char *a1@<X8>)
{
  a1[8] &= ~1u;
  *a1 = 0;
}

void sub_1CD6C6D94(void **a1)
{
  *a1 = &unk_1F26327B8;
  unint64_t v2 = a1 + 13;
  sub_1CC66CFA8(&v2);
  llvm::object::Binary::~Binary((llvm::object::Binary *)a1);
}

uint64_t sub_1CD6C6DF0(void **a1)
{
  *a1 = &unk_1F26327B8;
  unint64_t v3 = a1 + 13;
  sub_1CC66CFA8(&v3);
  llvm::object::Binary::~Binary((llvm::object::Binary *)a1);
  return MEMORY[0x1D25D9CE0]();
}

uint64_t sub_1CD6C6E60(uint64_t a1)
{
  return *(void *)(a1 + 136);
}

_OWORD *sub_1CD6C6E68(uint64_t a1, uint64_t a2, _OWORD **a3)
{
  long long v5 = (void **)sub_1CC9164B8(a1, &v12, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v8 = v5;
    uint64_t v6 = operator new(0x38uLL);
    void v6[2] = **a3;
    *((_DWORD *)v6 + 12) = 0;
    uint64_t v9 = v12;
    *(void *)uint64_t v6 = 0;
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = v9;
    llvm::object::Archive *v8 = v6;
    uint64_t v10 = **(void **)a1;
    unint64_t v11 = (uint64_t *)v6;
    if (v10)
    {
      *(void *)a1 = v10;
      unint64_t v11 = (uint64_t *)*v8;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v11);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

void llvm::object::Binary::~Binary(llvm::object::Binary *this)
{
}

uint64_t llvm::object::Binary::getFileName(llvm::object::Binary *this)
{
  return *((void *)this + 4);
}

__n128 llvm::object::Binary::getMemoryBufferRef@<Q0>(__n128 *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result = this[1];
  __n128 v3 = this[2];
  *a2 = result;
  a2[1] = v3;
  return result;
}

uint64_t llvm::object::COFFObjectFile::moveSymbolNext(uint64_t result, uint64_t a2)
{
  unint64_t v2 = *(void *)(result + 112);
  if (*(void *)(result + 96)) {
    unint64_t v3 = *(void *)a2 + 18 * *(unsigned __int8 *)(*(void *)a2 + 17) + 18;
  }
  else {
    unint64_t v3 = *(void *)a2 + 20 * *(unsigned __int8 *)(*(void *)a2 + 19) + 20;
  }
  if (v2 >= v3) {
    unint64_t v2 = v3;
  }
  *(void *)a2 = v2;
  return result;
}

uint64_t sub_1CD6C6F8C(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    int v2 = *(unsigned __int8 *)(a2 + 18);
    if (v2 == 2)
    {
      if (!*(_DWORD *)(a2 + 12) && !*(_DWORD *)(a2 + 8)) {
        return 1;
      }
      goto LABEL_8;
    }
    return v2 == 105;
  }
  int v2 = *(unsigned __int8 *)(a1 + 16);
  if (v2 != 2) {
    return v2 == 105;
  }
  if (*(_WORD *)(a1 + 12) || *(_DWORD *)(a1 + 8))
  {
LABEL_8:
    int v2 = 2;
    return v2 == 105;
  }
  return 1;
}

uint64_t sub_1CD6C6FE4(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    int v2 = *(unsigned __int8 *)(a1 + 16);
    BOOL v3 = v2 == 2 && *(__int16 *)(a1 + 12) == -1;
    int v4 = (unsigned __int8 *)(a1 + 17);
  }
  else
  {
    int v2 = *(unsigned __int8 *)(a2 + 18);
    BOOL v3 = v2 == 2 && *(_DWORD *)(a2 + 12) == -1;
    int v4 = (unsigned __int8 *)(a2 + 19);
  }
  int v5 = *v4;
  unsigned int v6 = v2 == 3 || v3;
  if (v5) {
    return v6;
  }
  else {
    return 0;
  }
}

void llvm::object::COFFObjectFile::moveSectionNext(uint64_t a1, void *a2)
{
  *a2 += 40;
}

uint64_t llvm::object::COFFObjectFile::getSectionAddress(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (v2)
  {
    uint64_t v3 = *(unsigned int *)(v2 + 28);
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 72);
    if (v3) {
      uint64_t v3 = *(void *)(v3 + 24);
    }
  }
  return v3 + *(unsigned int *)(a2 + 12);
}

unint64_t llvm::object::COFFObjectFile::getSectionIndex(uint64_t a1, uint64_t a2)
{
  return 0xCCCCCCCCCCCCCCCDLL * ((a2 - *(void *)(a1 + 88)) >> 3);
}

double llvm::object::COFFObjectFile::getSectionContents@<D0>(llvm::object *a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X8>)
{
  long long v7 = 0uLL;
  llvm::object::COFFObjectFile::getSectionContents(a1, a2, (unint64_t *)&v7, &v6);
  uint64_t v5 = v6;
  if (v6)
  {
    *(unsigned char *)(a3 + 16) |= 1u;
    *(void *)a3 = v5;
  }
  else
  {
    *(unsigned char *)(a3 + 16) &= ~1u;
    double result = *(double *)&v7;
    *(_OWORD *)a3 = v7;
  }
  return result;
}

llvm::object *llvm::object::COFFObjectFile::getSectionContents@<X0>(llvm::object *result@<X0>, _DWORD *a2@<X1>, unint64_t *a3@<X2>, void *a4@<X8>)
{
  uint64_t v5 = a2[5];
  if (!v5) {
    goto LABEL_8;
  }
  uint64_t v7 = *((void *)result + 2);
  unint64_t v8 = v7 + v5;
  if (*((void *)result + 8))
  {
    if (v7)
    {
LABEL_4:
      unsigned int v9 = a2[4];
      if (v9 >= a2[2]) {
        unsigned int v9 = a2[2];
      }
      goto LABEL_6;
    }
  }
  else
  {
    if (*((void *)result + 9)) {
      BOOL v12 = v7 == 0;
    }
    else {
      BOOL v12 = 1;
    }
    if (!v12) {
      goto LABEL_4;
    }
  }
  unsigned int v9 = a2[4];
LABEL_6:
  long long v10 = *((_OWORD *)result + 2);
  unint64_t v11 = v9;
  v13[0] = *((_OWORD *)result + 1);
  v13[1] = v10;
  double result = sub_1CCC207AC((llvm::object *)v13, v8, v9, a4);
  if (*a4) {
    return result;
  }
  *a3 = v8;
  a3[1] = v11;
LABEL_8:
  *a4 = 0;
  return result;
}

uint64_t llvm::object::COFFObjectFile::getSectionAlignment(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 36);
  uint64_t result = 1;
  if ((v2 & 8) == 0)
  {
    BOOL v4 = ((v2 >> 20) & 0xF) == 0;
    unsigned int v5 = 1 << (((v2 >> 20) & 0xF) - 1);
    if (v4) {
      return 16;
    }
    else {
      return v5;
    }
  }
  return result;
}

uint64_t llvm::object::COFFObjectFile::isSectionCompressed()
{
  return 0;
}

uint64_t llvm::object::COFFObjectFile::isSectionText(uint64_t a1, uint64_t a2)
{
  return (*(unsigned __int8 *)(a2 + 36) >> 5) & 1;
}

uint64_t llvm::object::COFFObjectFile::isSectionData(uint64_t a1, uint64_t a2)
{
  return (*(unsigned __int8 *)(a2 + 36) >> 6) & 1;
}

BOOL llvm::object::COFFObjectFile::isSectionBSS(uint64_t a1, uint64_t a2)
{
  return (~*(_DWORD *)(a2 + 36) & 0xC0000080) == 0;
}

BOOL llvm::object::COFFObjectFile::isSectionVirtual(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 20) == 0;
}

unint64_t llvm::object::COFFObjectFile::section_rel_begin(uint64_t a1, uint64_t a2)
{
  long long v3 = *(_OWORD *)(a1 + 32);
  v5[0] = *(_OWORD *)(a1 + 16);
  v5[1] = v3;
  unint64_t result = sub_1CCC1FD74(a2, v5, *(void *)(a1 + 16));
  if (result)
  {
    if (*(_DWORD *)(a2 + 12)) {
      llvm::report_fatal_error((llvm *)"Sections with relocations should have an address of 0", (const llvm::Twine *)1);
    }
  }
  return result;
}

unint64_t llvm::object::COFFObjectFile::section_rel_end(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1 + 16;
  long long v4 = *(_OWORD *)(a1 + 32);
  v8[0] = *(_OWORD *)(a1 + 16);
  v8[1] = v4;
  unint64_t result = sub_1CCC1FD74(a2, v8, *(uint64_t *)&v8[0]);
  if (result)
  {
    long long v6 = *(_OWORD *)(v3 + 16);
    v7[0] = *(_OWORD *)v3;
    v7[1] = v6;
    result += 10 * sub_1CCC1FE88(a2, v7, *(void *)v3);
  }
  return result;
}

llvm::object *llvm::object::COFFObjectFile::initImportTablePtr@<X0>(llvm::object *this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *((void *)this + 10);
  if (!v3) {
    goto LABEL_9;
  }
  long long v4 = this;
  uint64_t v5 = *((void *)this + 8);
  long long v6 = (_DWORD *)(v5 ? v5 + 92 : *((void *)this + 9) + 108);
  if (*v6 <= 1u) {
    goto LABEL_9;
  }
  unsigned int v7 = *(_DWORD *)(v3 + 8);
  if (!v7) {
    goto LABEL_9;
  }
  unint64_t v11 = 0;
  this = llvm::object::COFFObjectFile::getRvaPtr(this, &v11, "import table", v7, a2);
  if (!*a2)
  {
    long long v8 = *((_OWORD *)v4 + 2);
    v10[0] = *((_OWORD *)v4 + 1);
    v10[1] = v8;
    unint64_t v9 = v11;
    this = sub_1CCC207AC((llvm::object *)v10, v11, *(unsigned int *)(v3 + 12), a2);
    if (!*a2)
    {
      *((void *)v4 + 16) = v9;
LABEL_9:
      *a2 = 0;
    }
  }
  return this;
}

llvm::object *llvm::object::COFFObjectFile::initDelayImportTablePtr@<X0>(llvm::object *this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *((void *)this + 10);
  if (v3)
  {
    long long v4 = this;
    uint64_t v5 = *((void *)this + 8);
    long long v6 = (_DWORD *)(v5 ? v5 + 92 : *((void *)this + 9) + 108);
    if (*v6 > 0xDu)
    {
      unsigned int v7 = *(_DWORD *)(v3 + 104);
      if (v7)
      {
        *((_DWORD *)this + 36) = (*(_DWORD *)(v3 + 108) >> 5) - 1;
        unint64_t v8 = 0;
        this = llvm::object::COFFObjectFile::getRvaPtr(this, &v8, "delay import table", v7, a2);
        if (*a2) {
          return this;
        }
        *((void *)v4 + 17) = v8;
      }
    }
  }
  *a2 = 0;
  return this;
}

llvm::object *llvm::object::COFFObjectFile::initExportTablePtr@<X0>(llvm::object *this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = (unsigned int *)*((void *)this + 10);
  if (v3)
  {
    long long v4 = this;
    uint64_t v5 = *((void *)this + 8);
    long long v6 = (_DWORD *)(v5 ? v5 + 92 : *((void *)this + 9) + 108);
    if (*v6)
    {
      unsigned int v7 = *v3;
      if (*v3)
      {
        unint64_t v8 = 0;
        this = llvm::object::COFFObjectFile::getRvaPtr(this, &v8, "export table", v7, a2);
        if (*a2) {
          return this;
        }
        *((void *)v4 + 19) = v8;
      }
    }
  }
  *a2 = 0;
  return this;
}

llvm::object *llvm::object::COFFObjectFile::initBaseRelocPtr@<X0>(llvm::object *this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *((void *)this + 10);
  if (v3)
  {
    long long v4 = this;
    uint64_t v5 = *((void *)this + 8);
    long long v6 = (_DWORD *)(v5 ? v5 + 92 : *((void *)this + 9) + 108);
    if (*v6 > 5u)
    {
      unsigned int v7 = *(_DWORD *)(v3 + 40);
      if (v7)
      {
        unint64_t v9 = 0;
        this = llvm::object::COFFObjectFile::getRvaPtr(this, &v9, "base reloc table", v7, a2);
        if (*a2) {
          return this;
        }
        unint64_t v8 = v9;
        *((void *)v4 + 20) = v9;
        *((void *)v4 + 21) = v8 + *(unsigned int *)(v3 + 44);
      }
    }
  }
  *a2 = 0;
  return this;
}

llvm::object *llvm::object::COFFObjectFile::initDebugDirectoryPtr@<X0>(llvm::object *this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *((void *)this + 10);
  if (!v3) {
    goto LABEL_11;
  }
  long long v4 = this;
  uint64_t v5 = *((void *)this + 8);
  long long v6 = (_DWORD *)(v5 ? v5 + 92 : *((void *)this + 9) + 108);
  if (*v6 <= 6u) {
    goto LABEL_11;
  }
  unsigned int v7 = *(_DWORD *)(v3 + 48);
  if (!v7) {
    goto LABEL_11;
  }
  HIDWORD(v8) = -1227133513 * *(_DWORD *)(v3 + 52);
  LODWORD(v8) = HIDWORD(v8);
  if ((v8 >> 2) >= 0x924924A)
  {
    v10[0] = 3;
    v10[1] = llvm::object::object_category(this);
    sub_1CD06481C();
  }
  v10[0] = 0;
  this = llvm::object::COFFObjectFile::getRvaPtr(this, v10, "debug directory", v7, a2);
  if (!*a2)
  {
    unint64_t v9 = v10[0];
    *((void *)v4 + 22) = v10[0];
    *((void *)v4 + 23) = v9 + *(unsigned int *)(v3 + 52);
LABEL_11:
    *a2 = 0;
  }
  return this;
}

llvm::object *llvm::object::COFFObjectFile::initTLSDirectoryPtr@<X0>(llvm::object *this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *((void *)this + 10);
  if (!v3) {
    goto LABEL_13;
  }
  long long v4 = this;
  uint64_t v5 = *((void *)this + 8);
  long long v6 = (_DWORD *)(v5 ? v5 + 92 : *((void *)this + 9) + 108);
  if (*v6 <= 9u) {
    goto LABEL_13;
  }
  unsigned int v7 = *(_DWORD *)(v3 + 72);
  if (!v7) {
    goto LABEL_13;
  }
  uint64_t v8 = 40;
  if (!*((void *)this + 9)) {
    uint64_t v8 = 24;
  }
  uint64_t v12 = v8;
  if (v8 != *(_DWORD *)(v3 + 76))
  {
    atomic_ullong v10 = llvm::object::object_category(this);
    LODWORD(v11) = *(_DWORD *)(v3 + 76);
    sub_1CD5E4E84(3, v10, (uint64_t)"TLS Directory size (%u) is not the expected size (%llu).", (int *)&v11, &v12);
  }
  unint64_t v11 = 0;
  this = llvm::object::COFFObjectFile::getRvaPtr(this, &v11, "TLS directory", v7, a2);
  if (!*a2)
  {
    uint64_t v9 = 200;
    if (!*((void *)v4 + 9)) {
      uint64_t v9 = 192;
    }
    *(void *)((char *)v4 + v9) = v11;
LABEL_13:
    *a2 = 0;
  }
  return this;
}

llvm::object *llvm::object::COFFObjectFile::initLoadConfigPtr@<X0>(llvm::object *this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *((void *)this + 10);
  if (v3)
  {
    long long v4 = this;
    uint64_t v5 = *((void *)this + 8);
    long long v6 = (_DWORD *)(v5 ? v5 + 92 : *((void *)this + 9) + 108);
    if (*v6 > 0xAu)
    {
      unsigned int v7 = *(_DWORD *)(v3 + 80);
      if (v7)
      {
        unint64_t v8 = 0;
        this = llvm::object::COFFObjectFile::getRvaPtr(this, &v8, "load config table", v7, a2);
        if (*a2) {
          return this;
        }
        *((void *)v4 + 26) = v8;
      }
    }
  }
  *a2 = 0;
  return this;
}

void llvm::object::COFFObjectFile::create()
{
}

double llvm::object::COFFObjectFile::COFFObjectFile(uint64_t a1, long long *a2)
{
  long long v2 = a2[1];
  v5[0] = *a2;
  v5[1] = v2;
  llvm::object::ObjectFile::ObjectFile(a1, 9, v5);
  *(void *)uint64_t v3 = &unk_1F2632850;
  double result = 0.0;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_OWORD *)(v3 + 96) = 0u;
  *(_OWORD *)(v3 + 108) = 0u;
  *(void *)(v3 + 128) = 0;
  *(void *)(v3 + 136) = 0;
  *(_DWORD *)(v3 + 144) = 0;
  *(_OWORD *)(v3 + 152) = 0u;
  *(_OWORD *)(v3 + 168) = 0u;
  *(_OWORD *)(v3 + 184) = 0u;
  *(_OWORD *)(v3 + 200) = 0u;
  return result;
}

uint64_t llvm::object::COFFObjectFile::symbol_begin(llvm::object::COFFObjectFile *this)
{
  uint64_t result = *((void *)this + 12);
  if (!result) {
    return *((void *)this + 13);
  }
  return result;
}

uint64_t llvm::object::COFFObjectFile::symbol_end(llvm::object::COFFObjectFile *this)
{
  return *((void *)this + 14);
}

uint64_t llvm::object::COFFObjectFile::section_begin(llvm::object::COFFObjectFile *this)
{
  return *((void *)this + 11);
}

uint64_t llvm::object::COFFObjectFile::getBytesInAddress(llvm::object::COFFObjectFile *this)
{
  uint64_t v2 = 8;
  if ((*(unsigned int (**)(llvm::object::COFFObjectFile *))(*(void *)this + 376))(this) != 42)
  {
    if ((*(unsigned int (**)(llvm::object::COFFObjectFile *))(*(void *)this + 376))(this) == 3) {
      return 8;
    }
    else {
      return 4;
    }
  }
  return v2;
}

const char *llvm::object::COFFObjectFile::getFileFormatName(llvm::object::COFFObjectFile *this)
{
  uint64_t v1 = (unsigned __int16 *)*((void *)this + 6);
  if (!v1) {
    uint64_t v1 = (unsigned __int16 *)(*((void *)this + 7) + 6);
  }
  int v2 = *v1;
  if (v2 > 34403)
  {
    if (v2 != 43620)
    {
      if (v2 == 34404) {
        return "COFF-x86-64";
      }
      return "COFF-<unknown arch>";
    }
    return "COFF-ARM64";
  }
  else
  {
    if (v2 != 332)
    {
      if (v2 == 452) {
        return "COFF-ARM";
      }
      return "COFF-<unknown arch>";
    }
    return "COFF-i386";
  }
}

uint64_t llvm::object::COFFObjectFile::getArch(llvm::object::COFFObjectFile *this)
{
  uint64_t v1 = (unsigned __int16 *)*((void *)this + 6);
  if (!v1) {
    uint64_t v1 = (unsigned __int16 *)(*((void *)this + 7) + 6);
  }
  int v2 = *v1;
  if (v2 > 34403)
  {
    if (v2 != 43620)
    {
      if (v2 == 34404) {
        return 42;
      }
      return 0;
    }
    return 3;
  }
  else
  {
    if (v2 != 332)
    {
      if (v2 == 452) {
        return 39;
      }
      return 0;
    }
    return 41;
  }
}

uint64_t llvm::object::COFFObjectFile::getStartAddress@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 64);
  *(unsigned char *)(a2 + 8) &= ~1u;
  if (v2) {
    uint64_t v2 = *(unsigned int *)(v2 + 16);
  }
  *(void *)a2 = v2;
  return this;
}

uint64_t llvm::object::COFFObjectFile::getString@<X0>(llvm::object::COFFObjectFile *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned int v4 = *((_DWORD *)this + 30);
  if (v4 <= 4)
  {
    llvm::object::object_category(this);
    sub_1CD06481C();
  }
  if (v4 <= a2)
  {
    *(void *)&v8.__val_ = llvm::object::object_category(this);
    uint64_t result = llvm::errorCodeToError((llvm *)4, v8, (void *)a3);
    *(unsigned char *)(a3 + 16) |= 1u;
  }
  else
  {
    uint64_t v5 = *((void *)this + 14);
    uint64_t v6 = v5 + a2;
    if (v5) {
      uint64_t result = strlen((const char *)(v5 + a2));
    }
    else {
      uint64_t result = 0;
    }
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(void *)a3 = v6;
    *(void *)(a3 + 8) = result;
  }
  return result;
}

llvm::object::COFFObjectFile *llvm::object::COFFObjectFile::getSymbolName@<X0>(char *__s@<X1>, llvm::object::COFFObjectFile *result@<X0>, uint64_t a3@<X8>)
{
  if (*(_DWORD *)__s)
  {
    if (__s[7])
    {
      *(unsigned char *)(a3 + 16) &= ~1u;
      *(void *)a3 = __s;
      *(void *)(a3 + 8) = 8;
    }
    else
    {
      uint64_t result = (llvm::object::COFFObjectFile *)strlen(__s);
      *(unsigned char *)(a3 + 16) &= ~1u;
      *(void *)a3 = __s;
      *(void *)(a3 + 8) = result;
    }
  }
  else
  {
    unsigned int v5 = *((_DWORD *)__s + 1);
    return (llvm::object::COFFObjectFile *)llvm::object::COFFObjectFile::getString(result, v5, a3);
  }
  return result;
}

void llvm::object::COFFObjectFile::moveRelocationNext(uint64_t a1, void *a2)
{
  *a2 += 10;
}

uint64_t llvm::object::COFFObjectFile::getRelocationOffset(uint64_t a1, unsigned int *a2)
{
  return *a2;
}

uint64_t llvm::object::COFFObjectFile::getRelocationSymbol(void *a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 4);
  uint64_t v3 = a1[12];
  if (!v3 && !a1[13]) {
    return (*(uint64_t (**)(void *))(*a1 + 56))(a1);
  }
  uint64_t v4 = a1[6];
  if (v4)
  {
    if (*(__int16 *)(v4 + 2) == -1) {
      return (*(uint64_t (**)(void *))(*a1 + 56))(a1);
    }
    unsigned int v5 = (unsigned int *)(v4 + 12);
  }
  else
  {
    unsigned int v5 = (unsigned int *)(a1[7] + 52);
  }
  if (v2 >= *v5) {
    return (*(uint64_t (**)(void *))(*a1 + 56))(a1);
  }
  if (v3)
  {
    unsigned int v6 = 18;
  }
  else
  {
    uint64_t v3 = a1[13];
    unsigned int v6 = 20;
  }
  return v3 + v2 * (unint64_t)v6;
}

uint64_t llvm::object::COFFObjectFile::getRelocationType(uint64_t a1, uint64_t a2)
{
  return *(unsigned __int16 *)(a2 + 8);
}

const char *llvm::object::COFFObjectFile::getRelocationTypeName(llvm::object::COFFObjectFile *this, unsigned int a2)
{
  unsigned int v2 = (unsigned __int16 *)*((void *)this + 6);
  if (!v2) {
    unsigned int v2 = (unsigned __int16 *)(*((void *)this + 7) + 6);
  }
  unsigned int v3 = *v2;
  uint64_t result = "Unknown";
  if (v3 > 0x8663)
  {
    if (v3 == 43620)
    {
      if (a2 >= 0x12) {
        return result;
      }
      unsigned int v5 = off_1E684BA40;
      return v5[(__int16)a2];
    }
    if (v3 == 34404 && a2 < 0x11)
    {
      unsigned int v5 = off_1E684B900;
      return v5[(__int16)a2];
    }
  }
  else
  {
    if (v3 == 332)
    {
      if (a2 >= 0x15) {
        return result;
      }
      unsigned int v5 = off_1E684BAD0;
      return v5[(__int16)a2];
    }
    if (v3 == 452 && a2 < 0x17)
    {
      unsigned int v5 = off_1E684B988;
      return v5[(__int16)a2];
    }
  }
  return result;
}

void *llvm::object::COFFObjectFile::getRelocationTypeName(llvm::object::COFFObjectFile *a1, uint64_t a2, void *a3)
{
  RelocationTypeName = (char *)llvm::object::COFFObjectFile::getRelocationTypeName(a1, *(unsigned __int16 *)(a2 + 8));

  return sub_1CC22C75C(a3, RelocationTypeName, &RelocationTypeName[v4]);
}

BOOL llvm::object::COFFObjectFile::isRelocatableObject(llvm::object::COFFObjectFile *this)
{
  return *((void *)this + 10) == 0;
}

const char *llvm::object::COFFObjectFile::mapDebugSectionName(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t result = (const char *)a2;
  if (a3 == 7 && !(*a2 ^ 0x665F6865 | *(_DWORD *)((char *)a2 + 3) ^ 0x6D617266)) {
    return "eh_frame";
  }
  return result;
}

void llvm::object::ObjectFile::createCOFFObjectFile()
{
}

uint64_t sub_1CD6C7F64@<X0>(uint64_t a1@<X0>, _WORD *a2@<X1>, void *a3@<X8>)
{
  uint64_t result = llvm::BinaryStreamReader::readBytes(a1, 2u, a3);
  if (!*a3)
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24));
    __int16 v7 = MEMORY[0];
    unsigned int v8 = bswap32(MEMORY[0]) >> 16;
    if ((result - 1) >= 2) {
      __int16 v7 = v8;
    }
    *a2 = v7;
    *a3 = 0;
  }
  return result;
}

void sub_1CD6C8008(llvm::object::SymbolicFile *a1)
{
  llvm::object::SymbolicFile::~SymbolicFile(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD6C8040()
{
  return 10;
}

void sub_1CD6C8048(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

int64x2_t *sub_1CD6C8054@<X0>(int64x2_t *a1@<X8>)
{
  return llvm::SubtargetFeatures::SubtargetFeatures(a1, (uint64_t)&unk_1CFBFB355, 0);
}

void sub_1CD6C8068(unsigned char *a1@<X8>)
{
  *a1 = 0;
  a1[16] = 0;
}

void sub_1CD6C8078()
{
}

uint64_t sub_1CD6C808C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t sub_1CD6C8094@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, void *a5@<X8>)
{
  uint64_t result = sub_1CD6C8158(a1, a2, a3, a5);
  if (!*a5)
  {
    *a4 = *(void *)(a1 + 16) + a2;
    a4[1] = a3;
    *a5 = 0;
  }
  return result;
}

uint64_t sub_1CD6C80F0@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  uint64_t result = sub_1CD6C8158(a1, a2, 1, a4);
  if (!*a4)
  {
    unint64_t v9 = *(void *)(a1 + 24) - a2;
    *a3 = *(void *)(a1 + 16) + a2;
    a3[1] = v9;
    *a4 = 0;
  }
  return result;
}

uint64_t sub_1CD6C8148(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t sub_1CD6C8150()
{
  return 0;
}

uint64_t sub_1CD6C8158@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) < a2) {
    operator new();
  }
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) < a3 + a2) {
    operator new();
  }
  uint64_t result = 0;
  *a4 = 0;
  return result;
}

const char *llvm::object::getELFRelocationTypeName(llvm::object *this, unsigned int a2)
{
  if ((int)this <= 82)
  {
    if ((int)this <= 39)
    {
      switch((int)this)
      {
        case 2:
        case 18:
          goto LABEL_8;
        case 3:
        case 6:
          if (a2 >= 0x2C) {
            return "Unknown";
          }
          uint64_t v4 = off_1E684BE28;
          return v4[a2];
        case 4:
          if (a2 >= 0x2B) {
            return "Unknown";
          }
          uint64_t v4 = off_1E684BB78;
          return v4[a2];
        case 8:
          if (a2 >= 0xFA) {
            return "Unknown";
          }
          uint64_t v4 = off_1E684BF88;
          return v4[a2];
        case 20:
          uint64_t result = "R_PPC_NONE";
          switch(a2)
          {
            case 0u:
              return result;
            case 1u:
              uint64_t result = "R_PPC_ADDR32";
              break;
            case 2u:
              uint64_t result = "R_PPC_ADDR24";
              break;
            case 3u:
              uint64_t result = "R_PPC_ADDR16";
              break;
            case 4u:
              uint64_t result = "R_PPC_ADDR16_LO";
              break;
            case 5u:
              uint64_t result = "R_PPC_ADDR16_HI";
              break;
            case 6u:
              uint64_t result = "R_PPC_ADDR16_HA";
              break;
            case 7u:
              uint64_t result = "R_PPC_ADDR14";
              break;
            case 8u:
              uint64_t result = "R_PPC_ADDR14_BRTAKEN";
              break;
            case 9u:
              uint64_t result = "R_PPC_ADDR14_BRNTAKEN";
              break;
            case 0xAu:
              uint64_t result = "R_PPC_REL24";
              break;
            case 0xBu:
              uint64_t result = "R_PPC_REL14";
              break;
            case 0xCu:
              uint64_t result = "R_PPC_REL14_BRTAKEN";
              break;
            case 0xDu:
              uint64_t result = "R_PPC_REL14_BRNTAKEN";
              break;
            case 0xEu:
              uint64_t result = "R_PPC_GOT16";
              break;
            case 0xFu:
              uint64_t result = "R_PPC_GOT16_LO";
              break;
            case 0x10u:
              uint64_t result = "R_PPC_GOT16_HI";
              break;
            case 0x11u:
              uint64_t result = "R_PPC_GOT16_HA";
              break;
            case 0x12u:
              uint64_t result = "R_PPC_PLTREL24";
              break;
            case 0x13u:
              uint64_t result = "R_PPC_COPY";
              break;
            case 0x14u:
              uint64_t result = "R_PPC_GLOB_DAT";
              break;
            case 0x15u:
              uint64_t result = "R_PPC_JMP_SLOT";
              break;
            case 0x16u:
              uint64_t result = "R_PPC_RELATIVE";
              break;
            case 0x17u:
              uint64_t result = "R_PPC_LOCAL24PC";
              break;
            case 0x18u:
              uint64_t result = "R_PPC_UADDR32";
              break;
            case 0x19u:
              uint64_t result = "R_PPC_UADDR16";
              break;
            case 0x1Au:
              uint64_t result = "R_PPC_REL32";
              break;
            case 0x1Bu:
              uint64_t result = "R_PPC_PLT32";
              break;
            case 0x1Cu:
              uint64_t result = "R_PPC_PLTREL32";
              break;
            case 0x1Du:
              uint64_t result = "R_PPC_PLT16_LO";
              break;
            case 0x1Eu:
              uint64_t result = "R_PPC_PLT16_HI";
              break;
            case 0x1Fu:
              uint64_t result = "R_PPC_PLT16_HA";
              break;
            case 0x20u:
              uint64_t result = "R_PPC_SDAREL16";
              break;
            case 0x21u:
              uint64_t result = "R_PPC_SECTOFF";
              break;
            case 0x22u:
              uint64_t result = "R_PPC_SECTOFF_LO";
              break;
            case 0x23u:
              uint64_t result = "R_PPC_SECTOFF_HI";
              break;
            case 0x24u:
              uint64_t result = "R_PPC_SECTOFF_HA";
              break;
            case 0x25u:
              uint64_t result = "R_PPC_ADDR30";
              break;
            case 0x26u:
            case 0x27u:
            case 0x28u:
            case 0x29u:
            case 0x2Au:
            case 0x2Bu:
            case 0x2Cu:
            case 0x2Du:
            case 0x2Eu:
            case 0x2Fu:
            case 0x30u:
            case 0x31u:
            case 0x32u:
            case 0x33u:
            case 0x34u:
            case 0x35u:
            case 0x36u:
            case 0x37u:
            case 0x38u:
            case 0x39u:
            case 0x3Au:
            case 0x3Bu:
            case 0x3Cu:
            case 0x3Du:
            case 0x3Eu:
            case 0x3Fu:
            case 0x40u:
            case 0x41u:
            case 0x42u:
              return "Unknown";
            case 0x43u:
              uint64_t result = "R_PPC_TLS";
              break;
            case 0x44u:
              uint64_t result = "R_PPC_DTPMOD32";
              break;
            case 0x45u:
              uint64_t result = "R_PPC_TPREL16";
              break;
            case 0x46u:
              uint64_t result = "R_PPC_TPREL16_LO";
              break;
            case 0x47u:
              uint64_t result = "R_PPC_TPREL16_HI";
              break;
            case 0x48u:
              uint64_t result = "R_PPC_TPREL16_HA";
              break;
            case 0x49u:
              uint64_t result = "R_PPC_TPREL32";
              break;
            case 0x4Au:
              uint64_t result = "R_PPC_DTPREL16";
              break;
            case 0x4Bu:
              uint64_t result = "R_PPC_DTPREL16_LO";
              break;
            case 0x4Cu:
              uint64_t result = "R_PPC_DTPREL16_HI";
              break;
            case 0x4Du:
              uint64_t result = "R_PPC_DTPREL16_HA";
              break;
            case 0x4Eu:
              uint64_t result = "R_PPC_DTPREL32";
              break;
            case 0x4Fu:
              uint64_t result = "R_PPC_GOT_TLSGD16";
              break;
            case 0x50u:
              uint64_t result = "R_PPC_GOT_TLSGD16_LO";
              break;
            case 0x51u:
              uint64_t result = "R_PPC_GOT_TLSGD16_HI";
              break;
            case 0x52u:
              uint64_t result = "R_PPC_GOT_TLSGD16_HA";
              break;
            case 0x53u:
              uint64_t result = "R_PPC_GOT_TLSLD16";
              break;
            case 0x54u:
              uint64_t result = "R_PPC_GOT_TLSLD16_LO";
              break;
            case 0x55u:
              uint64_t result = "R_PPC_GOT_TLSLD16_HI";
              break;
            case 0x56u:
              uint64_t result = "R_PPC_GOT_TLSLD16_HA";
              break;
            case 0x57u:
              uint64_t result = "R_PPC_GOT_TPREL16";
              break;
            case 0x58u:
              uint64_t result = "R_PPC_GOT_TPREL16_LO";
              break;
            case 0x59u:
              uint64_t result = "R_PPC_GOT_TPREL16_HI";
              break;
            case 0x5Au:
              uint64_t result = "R_PPC_GOT_TPREL16_HA";
              break;
            case 0x5Bu:
              uint64_t result = "R_PPC_GOT_DTPREL16";
              break;
            case 0x5Cu:
              uint64_t result = "R_PPC_GOT_DTPREL16_LO";
              break;
            case 0x5Du:
              uint64_t result = "R_PPC_GOT_DTPREL16_HI";
              break;
            case 0x5Eu:
              uint64_t result = "R_PPC_GOT_DTPREL16_HA";
              break;
            case 0x5Fu:
              uint64_t result = "R_PPC_TLSGD";
              break;
            case 0x60u:
              uint64_t result = "R_PPC_TLSLD";
              break;
            default:
              switch(a2)
              {
                case 0xF8u:
                  uint64_t result = "R_PPC_IRELATIVE";
                  break;
                case 0xF9u:
                  uint64_t result = "R_PPC_REL16";
                  break;
                case 0xFAu:
                  uint64_t result = "R_PPC_REL16_LO";
                  break;
                case 0xFBu:
                  uint64_t result = "R_PPC_REL16_HI";
                  break;
                case 0xFCu:
                  uint64_t result = "R_PPC_REL16_HA";
                  break;
                default:
                  return "Unknown";
              }
              break;
          }
          return result;
        case 21:
          if (a2 >= 0xFD) {
            return "Unknown";
          }
          unsigned int v2 = off_1E684D428;
          return v2[a2];
        case 22:
          if (a2 >= 0x42) {
            return "Unknown";
          }
          unsigned int v2 = off_1E684DDE8;
          return v2[a2];
        default:
          return "Unknown";
      }
    }
    if (this == 40)
    {
      if (a2 < 0xA1)
      {
        unsigned int v2 = off_1E684C758;
        return v2[a2];
      }
      return "Unknown";
    }
    if (this == 43)
    {
LABEL_8:
      if (a2 < 0x55)
      {
        unsigned int v2 = off_1E684DFF8;
        return v2[a2];
      }
      return "Unknown";
    }
    if (this != 62 || a2 >= 0x2B) {
      return "Unknown";
    }
    uint64_t v4 = off_1E684BCD0;
    return v4[a2];
  }
  else
  {
    if ((int)this > 223)
    {
      switch((int)this)
      {
        case 243:
          if (a2 >= 0x3B) {
            return "Unknown";
          }
          unsigned int v2 = off_1E684DC10;
          return v2[a2];
        case 244:
          if (a2 >= 7) {
            return "Unknown";
          }
          unsigned int v2 = off_1E684D3F0;
          return v2[a2];
        case 245:
        case 246:
        case 248:
        case 249:
        case 250:
          return "Unknown";
        case 247:
          if (a2 >= 0xB) {
            return "Unknown";
          }
          unsigned int v2 = off_1E684E318;
          return v2[a2];
        case 251:
          if (a2 >= 0x25) {
            return "Unknown";
          }
          unsigned int v2 = off_1E684E3C8;
          return v2[a2];
        case 252:
          if (a2 >= 0x45) {
            return "Unknown";
          }
          unsigned int v2 = off_1E684E4F0;
          return v2[a2];
        default:
          if (this != 224)
          {
            if (this == 258 && a2 < 0x3B)
            {
              unsigned int v2 = off_1E684E718;
              return v2[a2];
            }
            return "Unknown";
          }
          if (a2 >= 0xF) {
            return "Unknown";
          }
          unsigned int v2 = off_1E684E2A0;
          break;
      }
      return v2[a2];
    }
    if ((int)this <= 163)
    {
      if (this != 83)
      {
        if (this != 93)
        {
          if (this == 105 && a2 < 0xB)
          {
            unsigned int v2 = off_1E684E370;
            return v2[a2];
          }
          return "Unknown";
        }
        goto LABEL_25;
      }
      if (a2 < 0x24)
      {
        unsigned int v2 = off_1E684CFB0;
        return v2[a2];
      }
      return "Unknown";
    }
    if (this == 164)
    {
      if (a2 < 0x64)
      {
        unsigned int v2 = off_1E684D0D0;
        return v2[a2];
      }
      return "Unknown";
    }
    if (this != 183)
    {
      if (this == 195)
      {
LABEL_25:
        if (a2 < 0x6A)
        {
          unsigned int v2 = off_1E684CC60;
          return v2[a2];
        }
        return "Unknown";
      }
      return "Unknown";
    }
    uint64_t result = "R_AARCH64_NONE";
    switch(a2)
    {
      case 0u:
        return result;
      case 1u:
        uint64_t result = "R_AARCH64_P32_ABS32";
        break;
      case 2u:
        uint64_t result = "R_AARCH64_P32_ABS16";
        break;
      case 3u:
        uint64_t result = "R_AARCH64_P32_PREL32";
        break;
      case 4u:
        uint64_t result = "R_AARCH64_P32_PREL16";
        break;
      case 5u:
        uint64_t result = "R_AARCH64_P32_MOVW_UABS_G0";
        break;
      case 6u:
        uint64_t result = "R_AARCH64_P32_MOVW_UABS_G0_NC";
        break;
      case 7u:
        uint64_t result = "R_AARCH64_P32_MOVW_UABS_G1";
        break;
      case 8u:
        uint64_t result = "R_AARCH64_P32_MOVW_SABS_G0";
        break;
      case 9u:
        uint64_t result = "R_AARCH64_P32_LD_PREL_LO19";
        break;
      case 0xAu:
        uint64_t result = "R_AARCH64_P32_ADR_PREL_LO21";
        break;
      case 0xBu:
        uint64_t result = "R_AARCH64_P32_ADR_PREL_PG_HI21";
        break;
      case 0xCu:
        uint64_t result = "R_AARCH64_P32_ADD_ABS_LO12_NC";
        break;
      case 0xDu:
        uint64_t result = "R_AARCH64_P32_LDST8_ABS_LO12_NC";
        break;
      case 0xEu:
        uint64_t result = "R_AARCH64_P32_LDST16_ABS_LO12_NC";
        break;
      case 0xFu:
        uint64_t result = "R_AARCH64_P32_LDST32_ABS_LO12_NC";
        break;
      case 0x10u:
        uint64_t result = "R_AARCH64_P32_LDST64_ABS_LO12_NC";
        break;
      case 0x11u:
        uint64_t result = "R_AARCH64_P32_LDST128_ABS_LO12_NC";
        break;
      case 0x12u:
        uint64_t result = "R_AARCH64_P32_TSTBR14";
        break;
      case 0x13u:
        uint64_t result = "R_AARCH64_P32_CONDBR19";
        break;
      case 0x14u:
        uint64_t result = "R_AARCH64_P32_JUMP26";
        break;
      case 0x15u:
        uint64_t result = "R_AARCH64_P32_CALL26";
        break;
      case 0x16u:
        uint64_t result = "R_AARCH64_P32_MOVW_PREL_G0";
        break;
      case 0x17u:
        uint64_t result = "R_AARCH64_P32_MOVW_PREL_G0_NC";
        break;
      case 0x18u:
        uint64_t result = "R_AARCH64_P32_MOVW_PREL_G1";
        break;
      case 0x19u:
        uint64_t result = "R_AARCH64_P32_GOT_LD_PREL19";
        break;
      case 0x1Au:
        uint64_t result = "R_AARCH64_P32_ADR_GOT_PAGE";
        break;
      case 0x1Bu:
        uint64_t result = "R_AARCH64_P32_LD32_GOT_LO12_NC";
        break;
      case 0x1Cu:
        uint64_t result = "R_AARCH64_P32_LD32_GOTPAGE_LO14";
        break;
      case 0x1Du:
        uint64_t result = "R_AARCH64_P32_PLT32";
        break;
      case 0x1Eu:
      case 0x1Fu:
      case 0x20u:
      case 0x21u:
      case 0x22u:
      case 0x23u:
      case 0x24u:
      case 0x25u:
      case 0x26u:
      case 0x27u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Eu:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x33u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x3Fu:
      case 0x40u:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Cu:
      case 0x4Du:
      case 0x4Eu:
      case 0x4Fu:
      case 0x80u:
      case 0x81u:
      case 0x82u:
      case 0x83u:
      case 0x84u:
      case 0x85u:
      case 0x86u:
      case 0x87u:
      case 0x88u:
      case 0x89u:
      case 0x8Au:
      case 0x8Bu:
      case 0x8Cu:
      case 0x8Du:
      case 0x8Eu:
      case 0x8Fu:
      case 0x90u:
      case 0x91u:
      case 0x92u:
      case 0x93u:
      case 0x94u:
      case 0x95u:
      case 0x96u:
      case 0x97u:
      case 0x98u:
      case 0x99u:
      case 0x9Au:
      case 0x9Bu:
      case 0x9Cu:
      case 0x9Du:
      case 0x9Eu:
      case 0x9Fu:
      case 0xA0u:
      case 0xA1u:
      case 0xA2u:
      case 0xA3u:
      case 0xA4u:
      case 0xA5u:
      case 0xA6u:
      case 0xA7u:
      case 0xA8u:
      case 0xA9u:
      case 0xAAu:
      case 0xABu:
      case 0xACu:
      case 0xADu:
      case 0xAEu:
      case 0xAFu:
      case 0xB0u:
      case 0xB1u:
      case 0xB2u:
      case 0xB3u:
      case 0xBDu:
      case 0xBEu:
      case 0xBFu:
      case 0xC0u:
      case 0xC1u:
      case 0xC2u:
      case 0xC3u:
      case 0xC4u:
      case 0xC5u:
      case 0xC6u:
      case 0xC7u:
      case 0xC8u:
      case 0xC9u:
      case 0xCAu:
      case 0xCBu:
      case 0xCCu:
      case 0xCDu:
      case 0xCEu:
      case 0xCFu:
      case 0xD0u:
      case 0xD1u:
      case 0xD2u:
      case 0xD3u:
      case 0xD4u:
      case 0xD5u:
      case 0xD6u:
      case 0xD7u:
      case 0xD8u:
      case 0xD9u:
      case 0xDAu:
      case 0xDBu:
      case 0xDCu:
      case 0xDDu:
      case 0xDEu:
      case 0xDFu:
      case 0xE0u:
      case 0xE1u:
      case 0xE2u:
      case 0xE3u:
      case 0xE4u:
      case 0xE5u:
      case 0xE6u:
      case 0xE7u:
      case 0xE8u:
      case 0xE9u:
      case 0xEAu:
      case 0xEBu:
      case 0xECu:
      case 0xEDu:
      case 0xEEu:
      case 0xEFu:
      case 0xF0u:
      case 0xF1u:
      case 0xF2u:
      case 0xF3u:
      case 0xF4u:
      case 0xF5u:
      case 0xF6u:
      case 0xF7u:
      case 0xF8u:
      case 0xF9u:
      case 0xFAu:
      case 0xFBu:
      case 0xFCu:
      case 0xFDu:
      case 0xFEu:
      case 0xFFu:
      case 0x100u:
      case 0x119u:
      case 0x126u:
      case 0x127u:
      case 0x128u:
      case 0x129u:
      case 0x12Au:
        return "Unknown";
      case 0x50u:
        uint64_t result = "R_AARCH64_P32_TLSGD_ADR_PREL21";
        break;
      case 0x51u:
        uint64_t result = "R_AARCH64_P32_TLSGD_ADR_PAGE21";
        break;
      case 0x52u:
        uint64_t result = "R_AARCH64_P32_TLSGD_ADD_LO12_NC";
        break;
      case 0x53u:
        uint64_t result = "R_AARCH64_P32_TLSLD_ADR_PREL21";
        break;
      case 0x54u:
        uint64_t result = "R_AARCH64_P32_TLSLD_ADR_PAGE21";
        break;
      case 0x55u:
        uint64_t result = "R_AARCH64_P32_TLSLD_ADD_LO12_NC";
        break;
      case 0x56u:
        uint64_t result = "R_AARCH64_P32_TLSLD_LD_PREL19";
        break;
      case 0x57u:
        uint64_t result = "R_AARCH64_P32_TLSLD_MOVW_DTPREL_G1";
        break;
      case 0x58u:
        uint64_t result = "R_AARCH64_P32_TLSLD_MOVW_DTPREL_G0";
        break;
      case 0x59u:
        uint64_t result = "R_AARCH64_P32_TLSLD_MOVW_DTPREL_G0_NC";
        break;
      case 0x5Au:
        uint64_t result = "R_AARCH64_P32_TLSLD_ADD_DTPREL_HI12";
        break;
      case 0x5Bu:
        uint64_t result = "R_AARCH64_P32_TLSLD_ADD_DTPREL_LO12";
        break;
      case 0x5Cu:
        uint64_t result = "R_AARCH64_P32_TLSLD_ADD_DTPREL_LO12_NC";
        break;
      case 0x5Du:
        uint64_t result = "R_AARCH64_P32_TLSLD_LDST8_DTPREL_LO12";
        break;
      case 0x5Eu:
        uint64_t result = "R_AARCH64_P32_TLSLD_LDST8_DTPREL_LO12_NC";
        break;
      case 0x5Fu:
        uint64_t result = "R_AARCH64_P32_TLSLD_LDST16_DTPREL_LO12";
        break;
      case 0x60u:
        uint64_t result = "R_AARCH64_P32_TLSLD_LDST16_DTPREL_LO12_NC";
        break;
      case 0x61u:
        uint64_t result = "R_AARCH64_P32_TLSLD_LDST32_DTPREL_LO12";
        break;
      case 0x62u:
        uint64_t result = "R_AARCH64_P32_TLSLD_LDST32_DTPREL_LO12_NC";
        break;
      case 0x63u:
        uint64_t result = "R_AARCH64_P32_TLSLD_LDST64_DTPREL_LO12";
        break;
      case 0x64u:
        uint64_t result = "R_AARCH64_P32_TLSLD_LDST64_DTPREL_LO12_NC";
        break;
      case 0x65u:
        uint64_t result = "R_AARCH64_P32_TLSLD_LDST128_DTPREL_LO12";
        break;
      case 0x66u:
        uint64_t result = "R_AARCH64_P32_TLSLD_LDST128_DTPREL_LO12_NC";
        break;
      case 0x67u:
        uint64_t result = "R_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21";
        break;
      case 0x68u:
        uint64_t result = "R_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC";
        break;
      case 0x69u:
        uint64_t result = "R_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19";
        break;
      case 0x6Au:
        uint64_t result = "R_AARCH64_P32_TLSLE_MOVW_TPREL_G1";
        break;
      case 0x6Bu:
        uint64_t result = "R_AARCH64_P32_TLSLE_MOVW_TPREL_G0";
        break;
      case 0x6Cu:
        uint64_t result = "R_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC";
        break;
      case 0x6Du:
        uint64_t result = "R_AARCH64_P32_TLSLE_ADD_TPREL_HI12";
        break;
      case 0x6Eu:
        uint64_t result = "R_AARCH64_P32_TLSLE_ADD_TPREL_LO12";
        break;
      case 0x6Fu:
        uint64_t result = "R_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC";
        break;
      case 0x70u:
        uint64_t result = "R_AARCH64_P32_TLSLE_LDST8_TPREL_LO12";
        break;
      case 0x71u:
        uint64_t result = "R_AARCH64_P32_TLSLE_LDST8_TPREL_LO12_NC";
        break;
      case 0x72u:
        uint64_t result = "R_AARCH64_P32_TLSLE_LDST16_TPREL_LO12";
        break;
      case 0x73u:
        uint64_t result = "R_AARCH64_P32_TLSLE_LDST16_TPREL_LO12_NC";
        break;
      case 0x74u:
        uint64_t result = "R_AARCH64_P32_TLSLE_LDST32_TPREL_LO12";
        break;
      case 0x75u:
        uint64_t result = "R_AARCH64_P32_TLSLE_LDST32_TPREL_LO12_NC";
        break;
      case 0x76u:
        uint64_t result = "R_AARCH64_P32_TLSLE_LDST64_TPREL_LO12";
        break;
      case 0x77u:
        uint64_t result = "R_AARCH64_P32_TLSLE_LDST64_TPREL_LO12_NC";
        break;
      case 0x78u:
        uint64_t result = "R_AARCH64_P32_TLSLE_LDST128_TPREL_LO12";
        break;
      case 0x79u:
        uint64_t result = "R_AARCH64_P32_TLSLE_LDST128_TPREL_LO12_NC";
        break;
      case 0x7Au:
        uint64_t result = "R_AARCH64_P32_TLSDESC_LD_PREL19";
        break;
      case 0x7Bu:
        uint64_t result = "R_AARCH64_P32_TLSDESC_ADR_PREL21";
        break;
      case 0x7Cu:
        uint64_t result = "R_AARCH64_P32_TLSDESC_ADR_PAGE21";
        break;
      case 0x7Du:
        uint64_t result = "R_AARCH64_P32_TLSDESC_LD32_LO12";
        break;
      case 0x7Eu:
        uint64_t result = "R_AARCH64_P32_TLSDESC_ADD_LO12";
        break;
      case 0x7Fu:
        uint64_t result = "R_AARCH64_P32_TLSDESC_CALL";
        break;
      case 0xB4u:
        uint64_t result = "R_AARCH64_P32_COPY";
        break;
      case 0xB5u:
        uint64_t result = "R_AARCH64_P32_GLOB_DAT";
        break;
      case 0xB6u:
        uint64_t result = "R_AARCH64_P32_JUMP_SLOT";
        break;
      case 0xB7u:
        uint64_t result = "R_AARCH64_P32_RELATIVE";
        break;
      case 0xB8u:
        uint64_t result = "R_AARCH64_P32_TLS_DTPREL";
        break;
      case 0xB9u:
        uint64_t result = "R_AARCH64_P32_TLS_DTPMOD";
        break;
      case 0xBAu:
        uint64_t result = "R_AARCH64_P32_TLS_TPREL";
        break;
      case 0xBBu:
        uint64_t result = "R_AARCH64_P32_TLSDESC";
        break;
      case 0xBCu:
        uint64_t result = "R_AARCH64_P32_IRELATIVE";
        break;
      case 0x101u:
        uint64_t result = "R_AARCH64_ABS64";
        break;
      case 0x102u:
        uint64_t result = "R_AARCH64_ABS32";
        break;
      case 0x103u:
        uint64_t result = "R_AARCH64_ABS16";
        break;
      case 0x104u:
        uint64_t result = "R_AARCH64_PREL64";
        break;
      case 0x105u:
        uint64_t result = "R_AARCH64_PREL32";
        break;
      case 0x106u:
        uint64_t result = "R_AARCH64_PREL16";
        break;
      case 0x107u:
        uint64_t result = "R_AARCH64_MOVW_UABS_G0";
        break;
      case 0x108u:
        uint64_t result = "R_AARCH64_MOVW_UABS_G0_NC";
        break;
      case 0x109u:
        uint64_t result = "R_AARCH64_MOVW_UABS_G1";
        break;
      case 0x10Au:
        uint64_t result = "R_AARCH64_MOVW_UABS_G1_NC";
        break;
      case 0x10Bu:
        uint64_t result = "R_AARCH64_MOVW_UABS_G2";
        break;
      case 0x10Cu:
        uint64_t result = "R_AARCH64_MOVW_UABS_G2_NC";
        break;
      case 0x10Du:
        uint64_t result = "R_AARCH64_MOVW_UABS_G3";
        break;
      case 0x10Eu:
        uint64_t result = "R_AARCH64_MOVW_SABS_G0";
        break;
      case 0x10Fu:
        uint64_t result = "R_AARCH64_MOVW_SABS_G1";
        break;
      case 0x110u:
        uint64_t result = "R_AARCH64_MOVW_SABS_G2";
        break;
      case 0x111u:
        uint64_t result = "R_AARCH64_LD_PREL_LO19";
        break;
      case 0x112u:
        uint64_t result = "R_AARCH64_ADR_PREL_LO21";
        break;
      case 0x113u:
        uint64_t result = "R_AARCH64_ADR_PREL_PG_HI21";
        break;
      case 0x114u:
        uint64_t result = "R_AARCH64_ADR_PREL_PG_HI21_NC";
        break;
      case 0x115u:
        uint64_t result = "R_AARCH64_ADD_ABS_LO12_NC";
        break;
      case 0x116u:
        uint64_t result = "R_AARCH64_LDST8_ABS_LO12_NC";
        break;
      case 0x117u:
        uint64_t result = "R_AARCH64_TSTBR14";
        break;
      case 0x118u:
        uint64_t result = "R_AARCH64_CONDBR19";
        break;
      case 0x11Au:
        uint64_t result = "R_AARCH64_JUMP26";
        break;
      case 0x11Bu:
        uint64_t result = "R_AARCH64_CALL26";
        break;
      case 0x11Cu:
        uint64_t result = "R_AARCH64_LDST16_ABS_LO12_NC";
        break;
      case 0x11Du:
        uint64_t result = "R_AARCH64_LDST32_ABS_LO12_NC";
        break;
      case 0x11Eu:
        uint64_t result = "R_AARCH64_LDST64_ABS_LO12_NC";
        break;
      case 0x11Fu:
        uint64_t result = "R_AARCH64_MOVW_PREL_G0";
        break;
      case 0x120u:
        uint64_t result = "R_AARCH64_MOVW_PREL_G0_NC";
        break;
      case 0x121u:
        uint64_t result = "R_AARCH64_MOVW_PREL_G1";
        break;
      case 0x122u:
        uint64_t result = "R_AARCH64_MOVW_PREL_G1_NC";
        break;
      case 0x123u:
        uint64_t result = "R_AARCH64_MOVW_PREL_G2";
        break;
      case 0x124u:
        uint64_t result = "R_AARCH64_MOVW_PREL_G2_NC";
        break;
      case 0x125u:
        uint64_t result = "R_AARCH64_MOVW_PREL_G3";
        break;
      case 0x12Bu:
        uint64_t result = "R_AARCH64_LDST128_ABS_LO12_NC";
        break;
      case 0x12Cu:
        uint64_t result = "R_AARCH64_MOVW_GOTOFF_G0";
        break;
      case 0x12Du:
        uint64_t result = "R_AARCH64_MOVW_GOTOFF_G0_NC";
        break;
      case 0x12Eu:
        uint64_t result = "R_AARCH64_MOVW_GOTOFF_G1";
        break;
      case 0x12Fu:
        uint64_t result = "R_AARCH64_MOVW_GOTOFF_G1_NC";
        break;
      case 0x130u:
        uint64_t result = "R_AARCH64_MOVW_GOTOFF_G2";
        break;
      case 0x131u:
        uint64_t result = "R_AARCH64_MOVW_GOTOFF_G2_NC";
        break;
      case 0x132u:
        uint64_t result = "R_AARCH64_MOVW_GOTOFF_G3";
        break;
      case 0x133u:
        uint64_t result = "R_AARCH64_GOTREL64";
        break;
      case 0x134u:
        uint64_t result = "R_AARCH64_GOTREL32";
        break;
      case 0x135u:
        uint64_t result = "R_AARCH64_GOT_LD_PREL19";
        break;
      case 0x136u:
        uint64_t result = "R_AARCH64_LD64_GOTOFF_LO15";
        break;
      case 0x137u:
        uint64_t result = "R_AARCH64_ADR_GOT_PAGE";
        break;
      case 0x138u:
        uint64_t result = "R_AARCH64_LD64_GOT_LO12_NC";
        break;
      case 0x139u:
        uint64_t result = "R_AARCH64_LD64_GOTPAGE_LO15";
        break;
      case 0x13Au:
        uint64_t result = "R_AARCH64_PLT32";
        break;
      default:
        switch(a2)
        {
          case 0x200u:
            uint64_t result = "R_AARCH64_TLSGD_ADR_PREL21";
            break;
          case 0x201u:
            uint64_t result = "R_AARCH64_TLSGD_ADR_PAGE21";
            break;
          case 0x202u:
            uint64_t result = "R_AARCH64_TLSGD_ADD_LO12_NC";
            break;
          case 0x203u:
            uint64_t result = "R_AARCH64_TLSGD_MOVW_G1";
            break;
          case 0x204u:
            uint64_t result = "R_AARCH64_TLSGD_MOVW_G0_NC";
            break;
          case 0x205u:
            uint64_t result = "R_AARCH64_TLSLD_ADR_PREL21";
            break;
          case 0x206u:
            uint64_t result = "R_AARCH64_TLSLD_ADR_PAGE21";
            break;
          case 0x207u:
            uint64_t result = "R_AARCH64_TLSLD_ADD_LO12_NC";
            break;
          case 0x208u:
            uint64_t result = "R_AARCH64_TLSLD_MOVW_G1";
            break;
          case 0x209u:
            uint64_t result = "R_AARCH64_TLSLD_MOVW_G0_NC";
            break;
          case 0x20Au:
            uint64_t result = "R_AARCH64_TLSLD_LD_PREL19";
            break;
          case 0x20Bu:
            uint64_t result = "R_AARCH64_TLSLD_MOVW_DTPREL_G2";
            break;
          case 0x20Cu:
            uint64_t result = "R_AARCH64_TLSLD_MOVW_DTPREL_G1";
            break;
          case 0x20Du:
            uint64_t result = "R_AARCH64_TLSLD_MOVW_DTPREL_G1_NC";
            break;
          case 0x20Eu:
            uint64_t result = "R_AARCH64_TLSLD_MOVW_DTPREL_G0";
            break;
          case 0x20Fu:
            uint64_t result = "R_AARCH64_TLSLD_MOVW_DTPREL_G0_NC";
            break;
          case 0x210u:
            uint64_t result = "R_AARCH64_TLSLD_ADD_DTPREL_HI12";
            break;
          case 0x211u:
            uint64_t result = "R_AARCH64_TLSLD_ADD_DTPREL_LO12";
            break;
          case 0x212u:
            uint64_t result = "R_AARCH64_TLSLD_ADD_DTPREL_LO12_NC";
            break;
          case 0x213u:
            uint64_t result = "R_AARCH64_TLSLD_LDST8_DTPREL_LO12";
            break;
          case 0x214u:
            uint64_t result = "R_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC";
            break;
          case 0x215u:
            uint64_t result = "R_AARCH64_TLSLD_LDST16_DTPREL_LO12";
            break;
          case 0x216u:
            uint64_t result = "R_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC";
            break;
          case 0x217u:
            uint64_t result = "R_AARCH64_TLSLD_LDST32_DTPREL_LO12";
            break;
          case 0x218u:
            uint64_t result = "R_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC";
            break;
          case 0x219u:
            uint64_t result = "R_AARCH64_TLSLD_LDST64_DTPREL_LO12";
            break;
          case 0x21Au:
            uint64_t result = "R_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC";
            break;
          case 0x21Bu:
            uint64_t result = "R_AARCH64_TLSIE_MOVW_GOTTPREL_G1";
            break;
          case 0x21Cu:
            uint64_t result = "R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC";
            break;
          case 0x21Du:
            uint64_t result = "R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21";
            break;
          case 0x21Eu:
            uint64_t result = "R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC";
            break;
          case 0x21Fu:
            uint64_t result = "R_AARCH64_TLSIE_LD_GOTTPREL_PREL19";
            break;
          case 0x220u:
            uint64_t result = "R_AARCH64_TLSLE_MOVW_TPREL_G2";
            break;
          case 0x221u:
            uint64_t result = "R_AARCH64_TLSLE_MOVW_TPREL_G1";
            break;
          case 0x222u:
            uint64_t result = "R_AARCH64_TLSLE_MOVW_TPREL_G1_NC";
            break;
          case 0x223u:
            uint64_t result = "R_AARCH64_TLSLE_MOVW_TPREL_G0";
            break;
          case 0x224u:
            uint64_t result = "R_AARCH64_TLSLE_MOVW_TPREL_G0_NC";
            break;
          case 0x225u:
            uint64_t result = "R_AARCH64_TLSLE_ADD_TPREL_HI12";
            break;
          case 0x226u:
            uint64_t result = "R_AARCH64_TLSLE_ADD_TPREL_LO12";
            break;
          case 0x227u:
            uint64_t result = "R_AARCH64_TLSLE_ADD_TPREL_LO12_NC";
            break;
          case 0x228u:
            uint64_t result = "R_AARCH64_TLSLE_LDST8_TPREL_LO12";
            break;
          case 0x229u:
            uint64_t result = "R_AARCH64_TLSLE_LDST8_TPREL_LO12_NC";
            break;
          case 0x22Au:
            uint64_t result = "R_AARCH64_TLSLE_LDST16_TPREL_LO12";
            break;
          case 0x22Bu:
            uint64_t result = "R_AARCH64_TLSLE_LDST16_TPREL_LO12_NC";
            break;
          case 0x22Cu:
            uint64_t result = "R_AARCH64_TLSLE_LDST32_TPREL_LO12";
            break;
          case 0x22Du:
            uint64_t result = "R_AARCH64_TLSLE_LDST32_TPREL_LO12_NC";
            break;
          case 0x22Eu:
            uint64_t result = "R_AARCH64_TLSLE_LDST64_TPREL_LO12";
            break;
          case 0x22Fu:
            uint64_t result = "R_AARCH64_TLSLE_LDST64_TPREL_LO12_NC";
            break;
          case 0x230u:
            uint64_t result = "R_AARCH64_TLSDESC_LD_PREL19";
            break;
          case 0x231u:
            uint64_t result = "R_AARCH64_TLSDESC_ADR_PREL21";
            break;
          case 0x232u:
            uint64_t result = "R_AARCH64_TLSDESC_ADR_PAGE21";
            break;
          case 0x233u:
            uint64_t result = "R_AARCH64_TLSDESC_LD64_LO12";
            break;
          case 0x234u:
            uint64_t result = "R_AARCH64_TLSDESC_ADD_LO12";
            break;
          case 0x235u:
            uint64_t result = "R_AARCH64_TLSDESC_OFF_G1";
            break;
          case 0x236u:
            uint64_t result = "R_AARCH64_TLSDESC_OFF_G0_NC";
            break;
          case 0x237u:
            uint64_t result = "R_AARCH64_TLSDESC_LDR";
            break;
          case 0x238u:
            uint64_t result = "R_AARCH64_TLSDESC_ADD";
            break;
          case 0x239u:
            uint64_t result = "R_AARCH64_TLSDESC_CALL";
            break;
          case 0x23Au:
            uint64_t result = "R_AARCH64_TLSLE_LDST128_TPREL_LO12";
            break;
          case 0x23Bu:
            uint64_t result = "R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC";
            break;
          case 0x23Cu:
            uint64_t result = "R_AARCH64_TLSLD_LDST128_DTPREL_LO12";
            break;
          case 0x23Du:
            uint64_t result = "R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC";
            break;
          default:
            switch(a2)
            {
              case 0x400u:
                uint64_t result = "R_AARCH64_COPY";
                break;
              case 0x401u:
                uint64_t result = "R_AARCH64_GLOB_DAT";
                break;
              case 0x402u:
                uint64_t result = "R_AARCH64_JUMP_SLOT";
                break;
              case 0x403u:
                uint64_t result = "R_AARCH64_RELATIVE";
                break;
              case 0x404u:
                uint64_t result = "R_AARCH64_TLS_DTPMOD64";
                break;
              case 0x405u:
                uint64_t result = "R_AARCH64_TLS_DTPREL64";
                break;
              case 0x406u:
                uint64_t result = "R_AARCH64_TLS_TPREL64";
                break;
              case 0x407u:
                uint64_t result = "R_AARCH64_TLSDESC";
                break;
              case 0x408u:
                uint64_t result = "R_AARCH64_IRELATIVE";
                break;
              default:
                return "Unknown";
            }
            break;
        }
        break;
    }
  }
  return result;
}

const char *llvm::object::getELFSectionTypeName(llvm::object *this, int a2)
{
  if ((int)this <= 61)
  {
    if (this == 8 || this == 10)
    {
      if (a2 > 1879048221)
      {
        if (a2 == 1879048222) {
          return "SHT_MIPS_DWARF";
        }
        if (a2 == 1879048234) {
          return "SHT_MIPS_ABIFLAGS";
        }
      }
      else
      {
        if (a2 == 1879048198) {
          return "SHT_MIPS_REGINFO";
        }
        if (a2 == 1879048205) {
          return "SHT_MIPS_OPTIONS";
        }
      }
    }
    else if (this == 40 && (a2 - 1879048193) < 5)
    {
      return off_1E684E8F0[a2 - 1879048193];
    }
  }
  else if ((int)this > 163)
  {
    if (this == 164)
    {
      if (a2 == 1879048192) {
        return "SHT_HEX_ORDERED";
      }
    }
    else if (this == 243 && a2 == 1879048195)
    {
      return "SHT_RISCV_ATTRIBUTES";
    }
  }
  else if (this == 62)
  {
    if (a2 == 1879048193) {
      return "SHT_X86_64_UNWIND";
    }
  }
  else if (this == 105 && a2 == 1879048195)
  {
    return "SHT_MSP430_ATTRIBUTES";
  }
  if (a2 > 1879002111)
  {
    switch(a2)
    {
      case 1879002112:
        uint64_t result = "SHT_LLVM_ODRTAB";
        break;
      case 1879002113:
        uint64_t result = "SHT_LLVM_LINKER_OPTIONS";
        break;
      case 1879002114:
LABEL_60:
        uint64_t result = "Unknown";
        break;
      case 1879002115:
        uint64_t result = "SHT_LLVM_ADDRSIG";
        break;
      case 1879002116:
        uint64_t result = "SHT_LLVM_DEPENDENT_LIBRARIES";
        break;
      case 1879002117:
        uint64_t result = "SHT_LLVM_SYMPART";
        break;
      case 1879002118:
        uint64_t result = "SHT_LLVM_PART_EHDR";
        break;
      case 1879002119:
        uint64_t result = "SHT_LLVM_PART_PHDR";
        break;
      case 1879002120:
        uint64_t result = "SHT_LLVM_BB_ADDR_MAP";
        break;
      case 1879002121:
        uint64_t result = "SHT_LLVM_CALL_GRAPH_PROFILE";
        break;
      default:
        switch(a2)
        {
          case 1879048181:
            uint64_t result = "SHT_GNU_ATTRIBUTES";
            break;
          case 1879048182:
            uint64_t result = "SHT_GNU_HASH";
            break;
          case 1879048183:
          case 1879048184:
          case 1879048185:
          case 1879048186:
          case 1879048187:
          case 1879048188:
            goto LABEL_60;
          case 1879048189:
            uint64_t result = "SHT_GNU_verdef";
            break;
          case 1879048190:
            uint64_t result = "SHT_GNU_verneed";
            break;
          case 1879048191:
            uint64_t result = "SHT_GNU_versym";
            break;
          default:
            if (a2 != 1879047936) {
              goto LABEL_60;
            }
            uint64_t result = "SHT_ANDROID_RELR";
            break;
        }
        break;
    }
  }
  else
  {
    uint64_t result = "SHT_NULL";
    switch(a2)
    {
      case 0:
        return result;
      case 1:
        return "SHT_PROGBITS";
      case 2:
        return "SHT_SYMTAB";
      case 3:
        return "SHT_STRTAB";
      case 4:
        return "SHT_RELA";
      case 5:
        return "SHT_HASH";
      case 6:
        return "SHT_DYNAMIC";
      case 7:
        return "SHT_NOTE";
      case 8:
        return "SHT_NOBITS";
      case 9:
        return "SHT_REL";
      case 10:
        return "SHT_SHLIB";
      case 11:
        return "SHT_DYNSYM";
      case 12:
      case 13:
        goto LABEL_60;
      case 14:
        return "SHT_INIT_ARRAY";
      case 15:
        return "SHT_FINI_ARRAY";
      case 16:
        return "SHT_PREINIT_ARRAY";
      case 17:
        return "SHT_GROUP";
      case 18:
        return "SHT_SYMTAB_SHNDX";
      case 19:
        return "SHT_RELR";
      default:
        if (a2 == 1610612737)
        {
          uint64_t result = "SHT_ANDROID_REL";
        }
        else
        {
          if (a2 != 1610612738) {
            goto LABEL_60;
          }
          uint64_t result = "SHT_ANDROID_RELA";
        }
        break;
    }
  }
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getStringTable(void *a1@<X0>, uint64_t a2@<X1>, void (*a3)(uint64_t *__return_ptr, uint64_t, void *)@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a2 + 4) != 3)
  {
    sub_1CD6C9BF8(a1, a2, (char *)&v30);
    uint64_t v12 = std::string::insert(&v30, 0, "invalid sh_type for string table section ");
    std::string::size_type v13 = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    uint64_t v14 = std::string::append(&v31, ": expected SHT_STRTAB, but got ");
    std::string::size_type v15 = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    __int16 v39 = 260;
    p_p = &__p;
    ELFSectionTypeName = llvm::object::getELFSectionTypeName((llvm::object *)*(unsigned __int16 *)(*a1 + 18), *(_DWORD *)(a2 + 4));
    __int16 v29 = 261;
    v27[0] = (void *)ELFSectionTypeName;
    v27[1] = v17;
    sub_1CB8F1E58((uint64_t *)&p_p, (uint64_t *)v27, (uint64_t)v33);
    a3(&v35, a4, v33);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v31.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v30.__r_.__value_.__l.__data_);
    }
    uint64_t v18 = v35;
    if (v35)
    {
      *(unsigned char *)(a5 + 16) |= 1u;
      *(void *)a5 = v18;
      return;
    }
  }
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSectionContents(a1, a2, (uint64_t)&p_p);
  uint64_t v8 = (uint64_t)p_p;
  if ((v38 & 1) == 0)
  {
    uint64_t v9 = v37;
    if (v37)
    {
      if (!p_p->__r_.__value_.__s.__data_[v37 - 1])
      {
        *(unsigned char *)(a5 + 16) &= ~1u;
        *(void *)a5 = v8;
        *(void *)(a5 + 8) = v9;
        goto LABEL_16;
      }
      sub_1CD6C9BF8(a1, a2, (char *)&v31);
      unint64_t v25 = std::string::insert(&v31, 0, "SHT_STRTAB string table section ");
      std::string::size_type v26 = v25->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v26;
      v25->__r_.__value_.__l.__size_ = 0;
      v25->__r_.__value_.__r.__words[2] = 0;
      v25->__r_.__value_.__r.__words[0] = 0;
      uint64_t v22 = " is non-null terminated";
    }
    else
    {
      sub_1CD6C9BF8(a1, a2, (char *)&v31);
      unint64_t v20 = std::string::insert(&v31, 0, "SHT_STRTAB string table section ");
      std::string::size_type v21 = v20->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v21;
      v20->__r_.__value_.__l.__size_ = 0;
      v20->__r_.__value_.__r.__words[2] = 0;
      v20->__r_.__value_.__r.__words[0] = 0;
      uint64_t v22 = " is empty";
    }
    __int16 v23 = std::string::append(&__p, v22);
    std::string::size_type v24 = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)long long v27 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    std::string::size_type v28 = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    __int16 v34 = 260;
    v33[0] = v27;
    operator new();
  }
  p_p = 0;
  *(unsigned char *)(a5 + 16) |= 1u;
  *(void *)a5 = v8;
LABEL_16:
  if (v38)
  {
    uint64_t v19 = (uint64_t)p_p;
    p_p = 0;
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
    }
  }
}

void sub_1CD6C9BF8(void *a1@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::sections(a1, (uint64_t)&v13);
  if (v14)
  {
    uint64_t v9 = v13;
    std::string::size_type v13 = 0;
    atomic_ullong v10 = v9;
    sub_1CD4515D0(&v10);
    if (v10) {
      (*(void (**)(void *))(*v10 + 8))(v10);
    }
    a3[23] = 15;
    strcpy(a3, "[unknown index]");
  }
  else
  {
    std::to_string(&v11, 0xCCCCCCCCCCCCCCCDLL * ((a2 - (uint64_t)v13) >> 3));
    unsigned int v5 = std::string::insert(&v11, 0, "[index ");
    std::string::size_type v6 = v5->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v12.__r_.__value_.__l.__data_ = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
    v12.__r_.__value_.__r.__words[2] = v6;
    v5->__r_.__value_.__l.__size_ = 0;
    v5->__r_.__value_.__r.__words[2] = 0;
    v5->__r_.__value_.__r.__words[0] = 0;
    __int16 v7 = std::string::append(&v12, "]");
    *(std::string *)a3 = *v7;
    v7->__r_.__value_.__r.__words[0] = 0;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v12.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v11.__r_.__value_.__l.__data_);
    }
  }
  if (v14)
  {
    uint64_t v8 = v13;
    std::string::size_type v13 = 0;
    if (v8) {
      (*(void (**)(void *))(*v8 + 8))(v8);
    }
  }
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSectionContents@<X0>(void *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3 = result;
  uint64_t v6 = *(unsigned int *)(a2 + 16);
  unsigned int v5 = (void *)*(unsigned int *)(a2 + 20);
  if (__CFADD__(v6, v5))
  {
    sub_1CD6C9BF8(result, a2, (char *)&v19);
    uint64_t v8 = std::string::insert(&v19, 0, "section ");
    std::string::size_type v9 = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v21.__r_.__value_.__l.__data_ = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v21.__r_.__value_.__r.__words[2] = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    atomic_ullong v10 = std::string::append(&v21, " has a sh_offset (0x");
    std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
    long long __p = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    std::string::size_type v25 = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    __int16 v41 = 260;
    v40[0] = (uint64_t)&__p;
    v16[0] = v6;
    v38[0] = (uint64_t)v16;
    v38[2] = 0;
    __int16 v39 = 270;
    sub_1CB8F1E58(v40, v38, (uint64_t)v42);
    v36[0] = (uint64_t)") + sh_size (0x";
    __int16 v37 = 259;
    sub_1CB8F1E58(v42, v36, (uint64_t)v43);
    v30[0] = v5;
    v33[0] = (uint64_t)v30;
    uint64_t v34 = 0;
    __int16 v35 = 270;
    sub_1CB8F1E58(v43, v33, (uint64_t)v44);
    v31[0] = (uint64_t)") that cannot be represented";
    __int16 v32 = 259;
    sub_1CB8F1E58(v44, v31, (uint64_t)v45);
    operator new();
  }
  if (result[1] < (unint64_t)(v5 + v6))
  {
    sub_1CD6C9BF8(result, a2, (char *)&v28);
    std::string v12 = std::string::insert(&v28, 0, "section ");
    std::string::size_type v13 = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v29.__r_.__value_.__r.__words[2] = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    char v14 = std::string::append(&v29, " has a sh_offset (0x");
    uint64_t v15 = (void *)v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string v30 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    void v30[2] = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    __int16 v37 = 260;
    v36[0] = (uint64_t)v30;
    uint64_t v27 = v6;
    v33[0] = (uint64_t)&v27;
    uint64_t v34 = 0;
    __int16 v35 = 270;
    sub_1CB8F1E58(v36, v33, (uint64_t)v38);
    v31[0] = (uint64_t)") + sh_size (0x";
    __int16 v32 = 259;
    sub_1CB8F1E58(v38, v31, (uint64_t)v40);
    __int16 v23 = v5;
    *(void *)&long long __p = &v23;
    std::string::size_type v25 = 0;
    __int16 v26 = 270;
    sub_1CB8F1E58(v40, (uint64_t *)&__p, (uint64_t)v42);
    v21.__r_.__value_.__r.__words[0] = (std::string::size_type)") that is greater than the file size (0x";
    __int16 v22 = 259;
    sub_1CB8F1E58(v42, (uint64_t *)&v21, (uint64_t)v43);
    uint64_t v18 = v3[1];
    v19.__r_.__value_.__r.__words[0] = (std::string::size_type)&v18;
    v19.__r_.__value_.__r.__words[2] = 0;
    __int16 v20 = 270;
    sub_1CB8F1E58(v43, (uint64_t *)&v19, (uint64_t)v44);
    v16[0] = (uint64_t)")";
    __int16 v17 = 259;
    sub_1CB8F1E58(v44, v16, (uint64_t)v45);
    operator new();
  }
  uint64_t v7 = *result + v6;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v5;
  return result;
}

uint64_t sub_1CD6CA180@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  if (a2 <= a3)
  {
    uint64_t v6 = "invalid section index: ";
    __int16 v7 = 259;
    __int16 v5 = 264;
    LODWORD(v4[0]) = a3;
    sub_1CB8F1E58((uint64_t *)&v6, v4, (uint64_t)v8);
    operator new();
  }
  *(unsigned char *)(a4 + 8) &= ~1u;
  *(void *)a4 = result + 40 * a3;
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSection@<X0>(void *a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t result = (uint64_t)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::sections(a1, (uint64_t)v7);
  if (v8)
  {
    uint64_t v6 = v7[0];
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v6;
  }
  else
  {
    uint64_t result = sub_1CD6CA180(v7[0], v7[1], a2, a3);
    if (v8)
    {
      uint64_t result = v7[0];
      v7[0] = 0;
      if (result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
    }
  }
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSHNDXTable@<X0>(void *a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t result = (uint64_t)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::sections(a1, (uint64_t)v8);
  if (v9)
  {
    uint64_t v7 = v8[0];
    *(unsigned char *)(a3 + 16) |= 1u;
    *(void *)a3 = v7;
  }
  else
  {
    uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSHNDXTable(a1, a2, v8[0], v8[1], a3);
    if (v9)
    {
      uint64_t result = v8[0];
      v8[0] = 0;
      if (result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
    }
  }
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSHNDXTable@<X0>(void *a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t result = (uint64_t)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::relrs(a1, a2, (uint64_t)v36);
  uint64_t v11 = v36[0];
  if (v37)
  {
    *(unsigned char *)(a5 + 16) |= 1u;
    *(void *)a5 = v11;
    return result;
  }
  uint64_t v12 = v36[1];
  uint64_t result = sub_1CD6CA180(a3, a4, a2[6], (uint64_t)&v34);
  uint64_t v13 = v34;
  if (v35)
  {
    uint64_t v34 = 0;
    *(unsigned char *)(a5 + 16) |= 1u;
    *(void *)a5 = v13;
  }
  else
  {
    int v14 = *(_DWORD *)(v34 + 4);
    if (v14 != 2 && v14 != 11)
    {
      ELFSectionTypeName = llvm::object::getELFSectionTypeName((llvm::object *)*(unsigned __int16 *)(*a1 + 18), v14);
      __int16 v32 = 1283;
      v31[0] = (uint64_t)"SHT_SYMTAB_SHNDX section is linked with ";
      v31[2] = (uint64_t)ELFSectionTypeName;
      void v31[3] = v17;
      v29[0] = (uint64_t)" section (expected SHT_SYMTAB/SHT_DYNSYM)";
      __int16 v30 = 259;
      uint64_t v18 = v29;
      goto LABEL_14;
    }
    unint64_t v28 = (unint64_t)*(unsigned int *)(v34 + 20) >> 4;
    if (v12 != v28)
    {
      __int16 v26 = "SHT_SYMTAB_SHNDX has ";
      __int16 v27 = 259;
      __int16 v25 = 266;
      uint64_t v23 = v12;
      v24[0] = (uint64_t)&v23;
      sub_1CB8F1E58((uint64_t *)&v26, v24, (uint64_t)v29);
      std::string v21 = " entries, but the symbol table associated has ";
      __int16 v22 = 259;
      sub_1CB8F1E58(v29, (uint64_t *)&v21, (uint64_t)v31);
      __int16 v20 = 268;
      std::string v19 = &v28;
      uint64_t v18 = (uint64_t *)&v19;
LABEL_14:
      sub_1CB8F1E58(v31, v18, (uint64_t)v33);
      operator new();
    }
    *(unsigned char *)(a5 + 16) &= ~1u;
    *(void *)(a5 + 8) = v12;
    *(void *)a5 = v11;
  }
  if (v35)
  {
    uint64_t result = v34;
    uint64_t v34 = 0;
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  if (v37)
  {
    uint64_t result = v36[0];
    v36[0] = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::relrs@<X0>(void *result@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = result;
  if (a2[9] != 4)
  {
    sub_1CD6C9BF8(result, (uint64_t)a2, (char *)&v35);
    char v9 = std::string::insert(&v35, 0, "section ");
    std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v41.__r_.__value_.__l.__data_ = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v41.__r_.__value_.__r.__words[2] = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    uint64_t v11 = std::string::append(&v41, " has invalid sh_entsize: expected ");
    std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
    long long __p = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    std::string::size_type v44 = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    __int16 v53 = 260;
    v52[0] = (uint64_t)&__p;
    v32.__r_.__value_.__r.__words[0] = 4;
    __int16 v51 = 266;
    v50[0] = (uint64_t)&v32;
    sub_1CB8F1E58(v52, v50, (uint64_t)v54);
    v48[0] = (uint64_t)", but got ";
    __int16 v49 = 259;
    sub_1CB8F1E58(v54, v48, (uint64_t)v55);
    unsigned int v13 = a2[9];
    __int16 v47 = 264;
    LODWORD(v46[0]) = v13;
    sub_1CB8F1E58(v55, v46, (uint64_t)v56);
    operator new();
  }
  unint64_t v6 = a2[5];
  if ((v6 & 3) != 0)
  {
    sub_1CD6C9BF8(result, (uint64_t)a2, (char *)&v30);
    int v14 = std::string::insert(&v30, 0, "section ");
    std::string::size_type v15 = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    unint64_t v16 = std::string::append(&v32, " has an invalid sh_size (");
    std::string::size_type v17 = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    __int16 v51 = 260;
    v50[0] = (uint64_t)&v35;
    __int16 v49 = 264;
    LODWORD(v48[0]) = v6;
    sub_1CB8F1E58(v50, v48, (uint64_t)v52);
    v46[0] = (uint64_t)") which is not a multiple of its sh_entsize (";
    __int16 v47 = 259;
    sub_1CB8F1E58(v52, v46, (uint64_t)v54);
    unsigned int v18 = a2[9];
    __int16 v45 = 264;
    LODWORD(__p) = v18;
    sub_1CB8F1E58(v54, (uint64_t *)&__p, (uint64_t)v55);
    v41.__r_.__value_.__r.__words[0] = (std::string::size_type)")";
    __int16 v42 = 259;
    goto LABEL_9;
  }
  uint64_t v7 = a2[4];
  if (__CFADD__(v7, v6))
  {
    sub_1CD6C9BF8(result, (uint64_t)a2, (char *)&v30);
    std::string v19 = std::string::insert(&v30, 0, "section ");
    std::string::size_type v20 = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    std::string v21 = std::string::append(&v32, " has a sh_offset (0x");
    std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    __int16 v51 = 260;
    v50[0] = (uint64_t)&v35;
    v27[0] = v7;
    v48[0] = (uint64_t)v27;
    void v48[2] = 0;
    __int16 v49 = 270;
    sub_1CB8F1E58(v50, v48, (uint64_t)v52);
    v46[0] = (uint64_t)") + sh_size (0x";
    __int16 v47 = 259;
    sub_1CB8F1E58(v52, v46, (uint64_t)v54);
    v40[0] = (void *)v6;
    *(void *)&long long __p = v40;
    std::string::size_type v44 = 0;
    __int16 v45 = 270;
    sub_1CB8F1E58(v54, (uint64_t *)&__p, (uint64_t)v55);
    v41.__r_.__value_.__r.__words[0] = (std::string::size_type)") that cannot be represented";
    __int16 v42 = 259;
LABEL_9:
    sub_1CB8F1E58(v55, (uint64_t *)&v41, (uint64_t)v56);
    operator new();
  }
  if (result[1] < (unint64_t)(v6 + v7))
  {
    sub_1CD6C9BF8(result, (uint64_t)a2, (char *)&v38);
    uint64_t v23 = std::string::insert(&v38, 0, "section ");
    std::string::size_type v24 = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v39.__r_.__value_.__l.__data_ = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v39.__r_.__value_.__r.__words[2] = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    __int16 v25 = std::string::append(&v39, " has a sh_offset (0x");
    __int16 v26 = (void *)v25->__r_.__value_.__r.__words[2];
    *(_OWORD *)uint64_t v40 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
    v40[2] = v26;
    v25->__r_.__value_.__l.__size_ = 0;
    v25->__r_.__value_.__r.__words[2] = 0;
    v25->__r_.__value_.__r.__words[0] = 0;
    __int16 v47 = 260;
    v46[0] = (uint64_t)v40;
    uint64_t v37 = v7;
    *(void *)&long long __p = &v37;
    std::string::size_type v44 = 0;
    __int16 v45 = 270;
    sub_1CB8F1E58(v46, (uint64_t *)&__p, (uint64_t)v48);
    v41.__r_.__value_.__r.__words[0] = (std::string::size_type)") + sh_size (0x";
    __int16 v42 = 259;
    sub_1CB8F1E58(v48, (uint64_t *)&v41, (uint64_t)v50);
    unint64_t v34 = v6;
    v35.__r_.__value_.__r.__words[0] = (std::string::size_type)&v34;
    v35.__r_.__value_.__r.__words[2] = 0;
    __int16 v36 = 270;
    sub_1CB8F1E58(v50, (uint64_t *)&v35, (uint64_t)v52);
    v32.__r_.__value_.__r.__words[0] = (std::string::size_type)") that is greater than the file size (0x";
    __int16 v33 = 259;
    sub_1CB8F1E58(v52, (uint64_t *)&v32, (uint64_t)v54);
    uint64_t v29 = v4[1];
    v30.__r_.__value_.__r.__words[0] = (std::string::size_type)&v29;
    v30.__r_.__value_.__r.__words[2] = 0;
    __int16 v31 = 270;
    sub_1CB8F1E58(v54, (uint64_t *)&v30, (uint64_t)v55);
    v27[0] = (uint64_t)")";
    __int16 v28 = 259;
    sub_1CB8F1E58(v55, v27, (uint64_t)v56);
    operator new();
  }
  uint64_t v8 = *result + v7;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v8;
  *(void *)(a3 + 8) = v6 >> 2;
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getRelocationTypeName(uint64_t *a1, unsigned int a2, void *a3)
{
  uint64_t v6 = *a1;
  uint64_t v7 = (llvm::object *)*(unsigned __int16 *)(*a1 + 18);
  if (v7 == 8 && *(unsigned char *)(v6 + 4) == 2)
  {
    ELFRelocationTypeName = (char *)llvm::object::getELFRelocationTypeName((llvm::object *)8, a2);
    sub_1CC22C75C(a3, ELFRelocationTypeName, &ELFRelocationTypeName[v9]);
    std::string::size_type v10 = (char *)llvm::object::getELFRelocationTypeName((llvm::object *)*(unsigned __int16 *)(*a1 + 18), BYTE1(a2));
    uint64_t v12 = v11;
    sub_1CD68E82C(a3, 1uLL, 47);
    sub_1CC22C75C(a3, v10, &v10[v12]);
    unsigned int v13 = llvm::object::getELFRelocationTypeName((llvm::object *)*(unsigned __int16 *)(*a1 + 18), BYTE2(a2));
    uint64_t v15 = v14;
    sub_1CD68E82C(a3, 1uLL, 47);
    unint64_t v16 = (char *)&v13[v15];
    std::string::size_type v17 = a3;
    unsigned int v18 = (char *)v13;
  }
  else
  {
    std::string v19 = llvm::object::getELFRelocationTypeName(v7, a2);
    unint64_t v16 = (char *)&v19[v20];
    std::string::size_type v17 = a3;
    unsigned int v18 = (char *)v19;
  }

  return sub_1CC22C75C(v17, v18, v16);
}

void *sub_1CD6CAE48@<X0>(void *a1@<X0>, unsigned int *a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t result = sub_1CD6CB19C(a1, a2, (uint64_t)v26);
  if (v27)
  {
    uint64_t v8 = v26[0];
    char v9 = *(unsigned char *)(a4 + 8) | 1;
  }
  else
  {
    if (v26[1] <= (unint64_t)a3)
    {
      uint64_t v20 = "can't read an entry at 0x";
      __int16 v21 = 259;
      uint64_t v17 = 16 * a3;
      v18[0] = (uint64_t)&v17;
      void v18[2] = 0;
      __int16 v19 = 270;
      sub_1CB8F1E58((uint64_t *)&v20, v18, (uint64_t)v22);
      uint64_t v15 = ": it goes past the end of the section (0x";
      __int16 v16 = 259;
      sub_1CB8F1E58(v22, (uint64_t *)&v15, (uint64_t)v23);
      uint64_t v12 = a2[5];
      v13[0] = (uint64_t)&v12;
      _OWORD v13[2] = 0;
      __int16 v14 = 270;
      sub_1CB8F1E58(v23, v13, (uint64_t)v24);
      std::string::size_type v10 = ")";
      __int16 v11 = 259;
      sub_1CB8F1E58(v24, (uint64_t *)&v10, (uint64_t)v25);
      operator new();
    }
    uint64_t v8 = v26[0] + 16 * a3;
    char v9 = *(unsigned char *)(a4 + 8) & 0xFE;
  }
  *(unsigned char *)(a4 + 8) = v9;
  *(void *)a4 = v8;
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::create@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2 <= 0x33)
  {
    unsigned int v13 = "invalid buffer: the size (";
    __int16 v14 = 259;
    __int16 v12 = 266;
    unint64_t v10 = a2;
    __int16 v11 = &v10;
    sub_1CB8F1E58((uint64_t *)&v13, (uint64_t *)&v11, (uint64_t)v15);
    uint64_t v8 = ") is smaller than an ELF header (";
    __int16 v9 = 259;
    sub_1CB8F1E58(v15, (uint64_t *)&v8, (uint64_t)v16);
    uint64_t v5 = 52;
    __int16 v7 = 266;
    uint64_t v6 = &v5;
    sub_1CB8F1E58(v16, (uint64_t *)&v6, (uint64_t)v17);
    unsigned int v3 = ")";
    __int16 v4 = 259;
    sub_1CB8F1E58(v17, (uint64_t *)&v3, (uint64_t)v18);
    operator new();
  }
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)(a3 + 8) = a2;
  *(void *)a3 = result;
  return result;
}

void *sub_1CD6CB19C@<X0>(void *result@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  __int16 v4 = result;
  if (a2[9] != 16)
  {
    sub_1CD6C9BF8(result, (uint64_t)a2, (char *)&v35);
    __int16 v9 = std::string::insert(&v35, 0, "section ");
    std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v41.__r_.__value_.__l.__data_ = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v41.__r_.__value_.__r.__words[2] = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    __int16 v11 = std::string::append(&v41, " has invalid sh_entsize: expected ");
    std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
    long long __p = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    std::string::size_type v44 = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    __int16 v53 = 260;
    v52[0] = (uint64_t)&__p;
    v32.__r_.__value_.__r.__words[0] = 16;
    __int16 v51 = 266;
    v50[0] = (uint64_t)&v32;
    sub_1CB8F1E58(v52, v50, (uint64_t)v54);
    v48[0] = (uint64_t)", but got ";
    __int16 v49 = 259;
    sub_1CB8F1E58(v54, v48, (uint64_t)v55);
    unsigned int v13 = a2[9];
    __int16 v47 = 264;
    LODWORD(v46[0]) = v13;
    sub_1CB8F1E58(v55, v46, (uint64_t)v56);
    operator new();
  }
  unint64_t v6 = a2[5];
  if ((v6 & 0xF) != 0)
  {
    sub_1CD6C9BF8(result, (uint64_t)a2, (char *)&v30);
    __int16 v14 = std::string::insert(&v30, 0, "section ");
    std::string::size_type v15 = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    __int16 v16 = std::string::append(&v32, " has an invalid sh_size (");
    std::string::size_type v17 = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    __int16 v51 = 260;
    v50[0] = (uint64_t)&v35;
    __int16 v49 = 264;
    LODWORD(v48[0]) = v6;
    sub_1CB8F1E58(v50, v48, (uint64_t)v52);
    v46[0] = (uint64_t)") which is not a multiple of its sh_entsize (";
    __int16 v47 = 259;
    sub_1CB8F1E58(v52, v46, (uint64_t)v54);
    unsigned int v18 = a2[9];
    __int16 v45 = 264;
    LODWORD(__p) = v18;
    sub_1CB8F1E58(v54, (uint64_t *)&__p, (uint64_t)v55);
    v41.__r_.__value_.__r.__words[0] = (std::string::size_type)")";
    __int16 v42 = 259;
    goto LABEL_9;
  }
  uint64_t v7 = a2[4];
  if (__CFADD__(v7, v6))
  {
    sub_1CD6C9BF8(result, (uint64_t)a2, (char *)&v30);
    __int16 v19 = std::string::insert(&v30, 0, "section ");
    std::string::size_type v20 = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    __int16 v21 = std::string::append(&v32, " has a sh_offset (0x");
    std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    __int16 v51 = 260;
    v50[0] = (uint64_t)&v35;
    v27[0] = v7;
    v48[0] = (uint64_t)v27;
    void v48[2] = 0;
    __int16 v49 = 270;
    sub_1CB8F1E58(v50, v48, (uint64_t)v52);
    v46[0] = (uint64_t)") + sh_size (0x";
    __int16 v47 = 259;
    sub_1CB8F1E58(v52, v46, (uint64_t)v54);
    v40[0] = (void *)v6;
    *(void *)&long long __p = v40;
    std::string::size_type v44 = 0;
    __int16 v45 = 270;
    sub_1CB8F1E58(v54, (uint64_t *)&__p, (uint64_t)v55);
    v41.__r_.__value_.__r.__words[0] = (std::string::size_type)") that cannot be represented";
    __int16 v42 = 259;
LABEL_9:
    sub_1CB8F1E58(v55, (uint64_t *)&v41, (uint64_t)v56);
    operator new();
  }
  if (result[1] < (unint64_t)(v6 + v7))
  {
    sub_1CD6C9BF8(result, (uint64_t)a2, (char *)&v38);
    uint64_t v23 = std::string::insert(&v38, 0, "section ");
    std::string::size_type v24 = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v39.__r_.__value_.__l.__data_ = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v39.__r_.__value_.__r.__words[2] = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    __int16 v25 = std::string::append(&v39, " has a sh_offset (0x");
    __int16 v26 = (void *)v25->__r_.__value_.__r.__words[2];
    *(_OWORD *)uint64_t v40 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
    v40[2] = v26;
    v25->__r_.__value_.__l.__size_ = 0;
    v25->__r_.__value_.__r.__words[2] = 0;
    v25->__r_.__value_.__r.__words[0] = 0;
    __int16 v47 = 260;
    v46[0] = (uint64_t)v40;
    uint64_t v37 = v7;
    *(void *)&long long __p = &v37;
    std::string::size_type v44 = 0;
    __int16 v45 = 270;
    sub_1CB8F1E58(v46, (uint64_t *)&__p, (uint64_t)v48);
    v41.__r_.__value_.__r.__words[0] = (std::string::size_type)") + sh_size (0x";
    __int16 v42 = 259;
    sub_1CB8F1E58(v48, (uint64_t *)&v41, (uint64_t)v50);
    unint64_t v34 = v6;
    v35.__r_.__value_.__r.__words[0] = (std::string::size_type)&v34;
    v35.__r_.__value_.__r.__words[2] = 0;
    __int16 v36 = 270;
    sub_1CB8F1E58(v50, (uint64_t *)&v35, (uint64_t)v52);
    v32.__r_.__value_.__r.__words[0] = (std::string::size_type)") that is greater than the file size (0x";
    __int16 v33 = 259;
    sub_1CB8F1E58(v52, (uint64_t *)&v32, (uint64_t)v54);
    uint64_t v29 = v4[1];
    v30.__r_.__value_.__r.__words[0] = (std::string::size_type)&v29;
    v30.__r_.__value_.__r.__words[2] = 0;
    __int16 v31 = 270;
    sub_1CB8F1E58(v54, (uint64_t *)&v30, (uint64_t)v55);
    v27[0] = (uint64_t)")";
    __int16 v28 = 259;
    sub_1CB8F1E58(v55, v27, (uint64_t)v56);
    operator new();
  }
  uint64_t v8 = *result + v7;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v8;
  *(void *)(a3 + 8) = v6 >> 4;
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::relas@<X0>(void *result@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  __int16 v4 = result;
  if (a2[9] != 12)
  {
    sub_1CD6C9BF8(result, (uint64_t)a2, (char *)&v34);
    uint64_t v8 = std::string::insert(&v34, 0, "section ");
    std::string::size_type v9 = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v40.__r_.__value_.__l.__data_ = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v40.__r_.__value_.__r.__words[2] = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v10 = std::string::append(&v40, " has invalid sh_entsize: expected ");
    std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
    long long __p = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    std::string::size_type v43 = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    __int16 v52 = 260;
    v51[0] = (uint64_t)&__p;
    v31.__r_.__value_.__r.__words[0] = 12;
    __int16 v50 = 266;
    v49[0] = (uint64_t)&v31;
    sub_1CB8F1E58(v51, v49, (uint64_t)v53);
    v47[0] = (uint64_t)", but got ";
    __int16 v48 = 259;
    sub_1CB8F1E58(v53, v47, (uint64_t)v54);
    unsigned int v12 = a2[9];
    __int16 v46 = 264;
    LODWORD(v45[0]) = v12;
    sub_1CB8F1E58(v54, v45, (uint64_t)v55);
    operator new();
  }
  uint64_t v5 = (void *)a2[5];
  if (v5 % 0xC)
  {
    sub_1CD6C9BF8(result, (uint64_t)a2, (char *)&v29);
    unsigned int v13 = std::string::insert(&v29, 0, "section ");
    std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v15 = std::string::append(&v31, " has an invalid sh_size (");
    std::string::size_type v16 = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v34.__r_.__value_.__l.__data_ = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v34.__r_.__value_.__r.__words[2] = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    __int16 v50 = 260;
    v49[0] = (uint64_t)&v34;
    __int16 v48 = 264;
    LODWORD(v47[0]) = v5;
    sub_1CB8F1E58(v49, v47, (uint64_t)v51);
    v45[0] = (uint64_t)") which is not a multiple of its sh_entsize (";
    __int16 v46 = 259;
    sub_1CB8F1E58(v51, v45, (uint64_t)v53);
    unsigned int v17 = a2[9];
    __int16 v44 = 264;
    LODWORD(__p) = v17;
    sub_1CB8F1E58(v53, (uint64_t *)&__p, (uint64_t)v54);
    v40.__r_.__value_.__r.__words[0] = (std::string::size_type)")";
    __int16 v41 = 259;
    goto LABEL_9;
  }
  uint64_t v6 = a2[4];
  if (__CFADD__(v6, v5))
  {
    sub_1CD6C9BF8(result, (uint64_t)a2, (char *)&v29);
    unsigned int v18 = std::string::insert(&v29, 0, "section ");
    std::string::size_type v19 = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v20 = std::string::append(&v31, " has a sh_offset (0x");
    std::string::size_type v21 = v20->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v34.__r_.__value_.__l.__data_ = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v34.__r_.__value_.__r.__words[2] = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    __int16 v50 = 260;
    v49[0] = (uint64_t)&v34;
    v26[0] = v6;
    v47[0] = (uint64_t)v26;
    v47[2] = 0;
    __int16 v48 = 270;
    sub_1CB8F1E58(v49, v47, (uint64_t)v51);
    v45[0] = (uint64_t)") + sh_size (0x";
    __int16 v46 = 259;
    sub_1CB8F1E58(v51, v45, (uint64_t)v53);
    v39[0] = v5;
    *(void *)&long long __p = v39;
    std::string::size_type v43 = 0;
    __int16 v44 = 270;
    sub_1CB8F1E58(v53, (uint64_t *)&__p, (uint64_t)v54);
    v40.__r_.__value_.__r.__words[0] = (std::string::size_type)") that cannot be represented";
    __int16 v41 = 259;
LABEL_9:
    sub_1CB8F1E58(v54, (uint64_t *)&v40, (uint64_t)v55);
    operator new();
  }
  if (result[1] < (unint64_t)(v5 + v6))
  {
    sub_1CD6C9BF8(result, (uint64_t)a2, (char *)&v37);
    std::string::size_type v22 = std::string::insert(&v37, 0, "section ");
    std::string::size_type v23 = v22->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v38.__r_.__value_.__l.__data_ = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v38.__r_.__value_.__r.__words[2] = v23;
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v24 = std::string::append(&v38, " has a sh_offset (0x");
    __int16 v25 = (void *)v24->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string v39 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
    v39[2] = v25;
    v24->__r_.__value_.__l.__size_ = 0;
    v24->__r_.__value_.__r.__words[2] = 0;
    v24->__r_.__value_.__r.__words[0] = 0;
    __int16 v46 = 260;
    v45[0] = (uint64_t)v39;
    uint64_t v36 = v6;
    *(void *)&long long __p = &v36;
    std::string::size_type v43 = 0;
    __int16 v44 = 270;
    sub_1CB8F1E58(v45, (uint64_t *)&__p, (uint64_t)v47);
    v40.__r_.__value_.__r.__words[0] = (std::string::size_type)") + sh_size (0x";
    __int16 v41 = 259;
    sub_1CB8F1E58(v47, (uint64_t *)&v40, (uint64_t)v49);
    __int16 v33 = v5;
    v34.__r_.__value_.__r.__words[0] = (std::string::size_type)&v33;
    v34.__r_.__value_.__r.__words[2] = 0;
    __int16 v35 = 270;
    sub_1CB8F1E58(v49, (uint64_t *)&v34, (uint64_t)v51);
    v31.__r_.__value_.__r.__words[0] = (std::string::size_type)") that is greater than the file size (0x";
    __int16 v32 = 259;
    sub_1CB8F1E58(v51, (uint64_t *)&v31, (uint64_t)v53);
    uint64_t v28 = v4[1];
    v29.__r_.__value_.__r.__words[0] = (std::string::size_type)&v28;
    v29.__r_.__value_.__r.__words[2] = 0;
    __int16 v30 = 270;
    sub_1CB8F1E58(v53, (uint64_t *)&v29, (uint64_t)v54);
    v26[0] = (uint64_t)")";
    __int16 v27 = 259;
    sub_1CB8F1E58(v54, v26, (uint64_t)v55);
    operator new();
  }
  uint64_t v7 = *result + v6;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v5 / 0xC;
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::rels@<X0>(void *result@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  __int16 v4 = result;
  if (a2[9] != 8)
  {
    sub_1CD6C9BF8(result, (uint64_t)a2, (char *)&v35);
    std::string::size_type v9 = std::string::insert(&v35, 0, "section ");
    std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v41.__r_.__value_.__l.__data_ = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v41.__r_.__value_.__r.__words[2] = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v11 = std::string::append(&v41, " has invalid sh_entsize: expected ");
    std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
    long long __p = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    std::string::size_type v44 = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    __int16 v53 = 260;
    v52[0] = (uint64_t)&__p;
    v32.__r_.__value_.__r.__words[0] = 8;
    __int16 v51 = 266;
    v50[0] = (uint64_t)&v32;
    sub_1CB8F1E58(v52, v50, (uint64_t)v54);
    v48[0] = (uint64_t)", but got ";
    __int16 v49 = 259;
    sub_1CB8F1E58(v54, v48, (uint64_t)v55);
    unsigned int v13 = a2[9];
    __int16 v47 = 264;
    LODWORD(v46[0]) = v13;
    sub_1CB8F1E58(v55, v46, (uint64_t)v56);
    operator new();
  }
  unint64_t v6 = a2[5];
  if ((v6 & 7) != 0)
  {
    sub_1CD6C9BF8(result, (uint64_t)a2, (char *)&v30);
    std::string::size_type v14 = std::string::insert(&v30, 0, "section ");
    std::string::size_type v15 = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v16 = std::string::append(&v32, " has an invalid sh_size (");
    std::string::size_type v17 = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    __int16 v51 = 260;
    v50[0] = (uint64_t)&v35;
    __int16 v49 = 264;
    LODWORD(v48[0]) = v6;
    sub_1CB8F1E58(v50, v48, (uint64_t)v52);
    v46[0] = (uint64_t)") which is not a multiple of its sh_entsize (";
    __int16 v47 = 259;
    sub_1CB8F1E58(v52, v46, (uint64_t)v54);
    unsigned int v18 = a2[9];
    __int16 v45 = 264;
    LODWORD(__p) = v18;
    sub_1CB8F1E58(v54, (uint64_t *)&__p, (uint64_t)v55);
    v41.__r_.__value_.__r.__words[0] = (std::string::size_type)")";
    __int16 v42 = 259;
    goto LABEL_9;
  }
  uint64_t v7 = a2[4];
  if (__CFADD__(v7, v6))
  {
    sub_1CD6C9BF8(result, (uint64_t)a2, (char *)&v30);
    std::string::size_type v19 = std::string::insert(&v30, 0, "section ");
    std::string::size_type v20 = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v21 = std::string::append(&v32, " has a sh_offset (0x");
    std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    __int16 v51 = 260;
    v50[0] = (uint64_t)&v35;
    v27[0] = v7;
    v48[0] = (uint64_t)v27;
    void v48[2] = 0;
    __int16 v49 = 270;
    sub_1CB8F1E58(v50, v48, (uint64_t)v52);
    v46[0] = (uint64_t)") + sh_size (0x";
    __int16 v47 = 259;
    sub_1CB8F1E58(v52, v46, (uint64_t)v54);
    v40[0] = (void *)v6;
    *(void *)&long long __p = v40;
    std::string::size_type v44 = 0;
    __int16 v45 = 270;
    sub_1CB8F1E58(v54, (uint64_t *)&__p, (uint64_t)v55);
    v41.__r_.__value_.__r.__words[0] = (std::string::size_type)") that cannot be represented";
    __int16 v42 = 259;
LABEL_9:
    sub_1CB8F1E58(v55, (uint64_t *)&v41, (uint64_t)v56);
    operator new();
  }
  if (result[1] < (unint64_t)(v6 + v7))
  {
    sub_1CD6C9BF8(result, (uint64_t)a2, (char *)&v38);
    std::string::size_type v23 = std::string::insert(&v38, 0, "section ");
    std::string::size_type v24 = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v39.__r_.__value_.__l.__data_ = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v39.__r_.__value_.__r.__words[2] = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    __int16 v25 = std::string::append(&v39, " has a sh_offset (0x");
    __int16 v26 = (void *)v25->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string v40 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
    v40[2] = v26;
    v25->__r_.__value_.__l.__size_ = 0;
    v25->__r_.__value_.__r.__words[2] = 0;
    v25->__r_.__value_.__r.__words[0] = 0;
    __int16 v47 = 260;
    v46[0] = (uint64_t)v40;
    uint64_t v37 = v7;
    *(void *)&long long __p = &v37;
    std::string::size_type v44 = 0;
    __int16 v45 = 270;
    sub_1CB8F1E58(v46, (uint64_t *)&__p, (uint64_t)v48);
    v41.__r_.__value_.__r.__words[0] = (std::string::size_type)") + sh_size (0x";
    __int16 v42 = 259;
    sub_1CB8F1E58(v48, (uint64_t *)&v41, (uint64_t)v50);
    unint64_t v34 = v6;
    v35.__r_.__value_.__r.__words[0] = (std::string::size_type)&v34;
    v35.__r_.__value_.__r.__words[2] = 0;
    __int16 v36 = 270;
    sub_1CB8F1E58(v50, (uint64_t *)&v35, (uint64_t)v52);
    v32.__r_.__value_.__r.__words[0] = (std::string::size_type)") that is greater than the file size (0x";
    __int16 v33 = 259;
    sub_1CB8F1E58(v52, (uint64_t *)&v32, (uint64_t)v54);
    uint64_t v29 = v4[1];
    v30.__r_.__value_.__r.__words[0] = (std::string::size_type)&v29;
    v30.__r_.__value_.__r.__words[2] = 0;
    __int16 v31 = 270;
    sub_1CB8F1E58(v54, (uint64_t *)&v30, (uint64_t)v55);
    v27[0] = (uint64_t)")";
    __int16 v28 = 259;
    sub_1CB8F1E58(v55, v27, (uint64_t)v56);
    operator new();
  }
  uint64_t v8 = *result + v7;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v8;
  *(void *)(a3 + 8) = v6 >> 3;
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSectionStringTable(void *a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, void (*a4)(uint64_t *__return_ptr, uint64_t, void *)@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  unsigned int v7 = *(unsigned __int16 *)(*a1 + 50);
  if (v7 == 0xFFFF)
  {
    if (!a3)
    {
      std::string::size_type v16 = "e_shstrndx == SHN_XINDEX, but the section header table is empty";
      __int16 v17 = 259;
LABEL_5:
      operator new();
    }
    unsigned int v7 = *(_DWORD *)(a2 + 24);
  }
  if (v7)
  {
    if (a3 <= v7)
    {
      unsigned int v13 = "section header string table index ";
      __int16 v14 = 259;
      __int16 v12 = 264;
      LODWORD(v11[0]) = v7;
      sub_1CB8F1E58((uint64_t *)&v13, v11, (uint64_t)v15);
      std::string::size_type v9 = " does not exist";
      __int16 v10 = 259;
      sub_1CB8F1E58(v15, (uint64_t *)&v9, (uint64_t)&v16);
      goto LABEL_5;
    }
    uint64_t v8 = a2 + 40 * v7;
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getStringTable(a1, v8, a4, a5, a6);
  }
  else
  {
    *(unsigned char *)(a6 + 16) &= ~1u;
    *(void *)a6 = "";
    *(void *)(a6 + 8) = 0;
  }
}

uint64_t *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSectionIndex@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, _OWORD *a3@<X4>, uint64_t a4@<X8>)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  int v5 = *(unsigned __int16 *)(a1 + 14);
  if (v5 == 0xFFFF)
  {
    long long v6 = a3[1];
    v9[0] = *a3;
    v9[1] = v6;
    uint64_t result = sub_1CD6CC798((unint64_t)(a1 - a2) >> 4, (uint64_t *)v9, (uint64_t)&v10);
    if (v11)
    {
      uint64_t v8 = v10;
      *(unsigned char *)(a4 + 8) |= 1u;
      *(void *)a4 = v8;
      return result;
    }
    *(unsigned char *)(a4 + 8) &= ~1u;
    int v5 = v10;
  }
  else
  {
    *(unsigned char *)(a4 + 8) &= ~1u;
    if ((unsigned __int16)(v5 + 256) <= 0x100u)
    {
      *(_DWORD *)a4 = 0;
      return result;
    }
  }
  *(_DWORD *)a4 = v5;
  return result;
}

uint64_t *sub_1CD6CC798@<X0>(unsigned int a1@<W1>, uint64_t *a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!*a2)
  {
    v17[0] = (uint64_t)"found an extended symbol index (";
    __int16 v18 = 259;
    __int16 v16 = 264;
    LODWORD(v15[0]) = a1;
    sub_1CB8F1E58(v17, v15, (uint64_t)v19);
    v13[0] = (uint64_t)"), but unable to locate the extended symbol index table";
    __int16 v14 = 259;
    sub_1CB8F1E58(v19, v13, (uint64_t)v20);
    operator new();
  }
  uint64_t result = sub_1CD6D614C(a2, a1, (uint64_t)&v21);
  if (v22)
  {
    v15[0] = (uint64_t)"unable to read an extended symbol table at index ";
    __int16 v16 = 259;
    __int16 v14 = 264;
    LODWORD(v13[0]) = a1;
    sub_1CB8F1E58(v15, v13, (uint64_t)v17);
    char v11 = ": ";
    __int16 v12 = 259;
    sub_1CB8F1E58(v17, (uint64_t *)&v11, (uint64_t)v19);
    if (v22)
    {
      uint64_t v6 = v21;
      uint64_t v21 = 0;
    }
    else
    {
      uint64_t v6 = 0;
    }
    uint64_t v7 = v6;
    sub_1CD4FB504(&v7, &__p);
    __int16 v10 = 260;
    p_p = &__p;
    sub_1CB8F1E58(v19, (uint64_t *)&p_p, (uint64_t)v20);
    operator new();
  }
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(_DWORD *)a3 = v21;
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSection@<X0>(void *a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>, _OWORD *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a3)
  {
    v13[0] = 0;
    v13[1] = 0;
    char v14 = 0;
    goto LABEL_3;
  }
  sub_1CD6CB19C(a1, a3, (uint64_t)v13);
  if ((v14 & 1) == 0)
  {
    a3 = (unsigned int *)v13[0];
LABEL_3:
    long long v9 = a4[1];
    v12[0] = *a4;
    v12[1] = v9;
    uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSection(a1, a2, (uint64_t)a3, v12, a5);
    if ((v14 & 1) == 0) {
      return result;
    }
    goto LABEL_7;
  }
  uint64_t v11 = v13[0];
  v13[0] = 0;
  *(unsigned char *)(a5 + 8) |= 1u;
  *(void *)a5 = v11;
LABEL_7:
  uint64_t result = v13[0];
  v13[0] = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSection@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _OWORD *a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  long long v7 = a4[1];
  v10[0] = *a4;
  v10[1] = v7;
  uint64_t result = (uint64_t)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSectionIndex(a2, a3, v10, (uint64_t)&v11);
  if (v12)
  {
    uint64_t v9 = v11;
    *(unsigned char *)(a5 + 8) |= 1u;
    *(void *)a5 = v9;
  }
  else if (v11)
  {
    uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSection(a1, v11, a5);
    if (v12)
    {
      uint64_t result = v11;
      uint64_t v11 = 0;
      if (result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
    }
  }
  else
  {
    *(unsigned char *)(a5 + 8) &= ~1u;
    *(void *)a5 = 0;
  }
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSectionName(void *a1@<X0>, unsigned int *a2@<X1>, void (*a3)(uint64_t *__return_ptr, uint64_t, void *)@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::sections(a1, (uint64_t)v16);
  if (v17)
  {
    uint64_t v10 = v16[0];
    *(unsigned char *)(a5 + 16) |= 1u;
    *(void *)a5 = v10;
  }
  else
  {
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSectionStringTable(a1, v16[0], v16[1], a3, a4, (uint64_t)v14);
    if (v15)
    {
      uint64_t v11 = v14[0];
      *(unsigned char *)(a5 + 16) |= 1u;
      *(void *)a5 = v11;
    }
    else
    {
      llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSectionName(a1, a2, v14[0], v14[1], a5);
      if (v15)
      {
        uint64_t v13 = v14[0];
        v14[0] = 0;
        if (v13) {
          (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
        }
      }
    }
    if (v17)
    {
      uint64_t v12 = v16[0];
      v16[0] = 0;
      if (v12) {
        (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
      }
    }
  }
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSectionName@<X0>(void *result@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v6 = *a2;
  if (v6)
  {
    if (a4 <= v6)
    {
      sub_1CD6C9BF8(result, (uint64_t)a2, (char *)&v17);
      uint64_t v8 = std::string::insert(&v17, 0, "a section ");
      std::string::size_type v9 = v8->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v18.__r_.__value_.__l.__data_ = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      v18.__r_.__value_.__r.__words[2] = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      uint64_t v10 = std::string::append(&v18, " has an invalid sh_name (0x");
      std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
      std::string::size_type v20 = v11;
      v10->__r_.__value_.__l.__size_ = 0;
      v10->__r_.__value_.__r.__words[2] = 0;
      v10->__r_.__value_.__r.__words[0] = 0;
      __int16 v22 = 260;
      uint64_t v21 = __p;
      unint64_t v14 = v6;
      v15[0] = (uint64_t)&v14;
      uint64_t v15[2] = 0;
      __int16 v16 = 270;
      sub_1CB8F1E58((uint64_t *)&v21, v15, (uint64_t)v23);
      uint64_t v12 = ") offset which goes past the end of the section name string table";
      __int16 v13 = 259;
      sub_1CB8F1E58(v23, (uint64_t *)&v12, (uint64_t)v24);
      operator new();
    }
    long long v7 = (const char *)(a3 + v6);
    uint64_t result = (void *)strlen(v7);
    *(unsigned char *)(a5 + 16) &= ~1u;
    *(void *)a5 = v7;
    *(void *)(a5 + 8) = result;
  }
  else
  {
    *(unsigned char *)(a5 + 16) &= ~1u;
    *(void *)a5 = 0;
    *(void *)(a5 + 8) = 0;
  }
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getStringTable(void *a1@<X0>, uint64_t a2@<X1>, void (*a3)(uint64_t *__return_ptr, uint64_t, void *)@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a2 + 4) != 50331648)
  {
    sub_1CD6CD2F0(a1, a2, (char *)&v30);
    uint64_t v12 = std::string::insert(&v30, 0, "invalid sh_type for string table section ");
    std::string::size_type v13 = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    unint64_t v14 = std::string::append(&v31, ": expected SHT_STRTAB, but got ");
    std::string::size_type v15 = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    __int16 v39 = 260;
    p_p = &__p;
    ELFSectionTypeName = llvm::object::getELFSectionTypeName((llvm::object *)(bswap32(*(unsigned __int16 *)(*a1 + 18)) >> 16), bswap32(*(_DWORD *)(a2 + 4)));
    __int16 v29 = 261;
    v27[0] = (void *)ELFSectionTypeName;
    v27[1] = v17;
    sub_1CB8F1E58((uint64_t *)&p_p, (uint64_t *)v27, (uint64_t)v33);
    a3(&v35, a4, v33);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v31.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v30.__r_.__value_.__l.__data_);
    }
    uint64_t v18 = v35;
    if (v35)
    {
      *(unsigned char *)(a5 + 16) |= 1u;
      *(void *)a5 = v18;
      return;
    }
  }
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSectionContents(a1, a2, (uint64_t)&p_p);
  uint64_t v8 = (uint64_t)p_p;
  if ((v38 & 1) == 0)
  {
    uint64_t v9 = v37;
    if (v37)
    {
      if (!p_p->__r_.__value_.__s.__data_[v37 - 1])
      {
        *(unsigned char *)(a5 + 16) &= ~1u;
        *(void *)a5 = v8;
        *(void *)(a5 + 8) = v9;
        goto LABEL_16;
      }
      sub_1CD6CD2F0(a1, a2, (char *)&v31);
      __int16 v25 = std::string::insert(&v31, 0, "SHT_STRTAB string table section ");
      std::string::size_type v26 = v25->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v26;
      v25->__r_.__value_.__l.__size_ = 0;
      v25->__r_.__value_.__r.__words[2] = 0;
      v25->__r_.__value_.__r.__words[0] = 0;
      __int16 v22 = " is non-null terminated";
    }
    else
    {
      sub_1CD6CD2F0(a1, a2, (char *)&v31);
      std::string::size_type v20 = std::string::insert(&v31, 0, "SHT_STRTAB string table section ");
      std::string::size_type v21 = v20->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v21;
      v20->__r_.__value_.__l.__size_ = 0;
      v20->__r_.__value_.__r.__words[2] = 0;
      v20->__r_.__value_.__r.__words[0] = 0;
      __int16 v22 = " is empty";
    }
    uint64_t v23 = std::string::append(&__p, v22);
    std::string::size_type v24 = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)__int16 v27 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    std::string::size_type v28 = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    __int16 v34 = 260;
    v33[0] = v27;
    operator new();
  }
  p_p = 0;
  *(unsigned char *)(a5 + 16) |= 1u;
  *(void *)a5 = v8;
LABEL_16:
  if (v38)
  {
    uint64_t v19 = (uint64_t)p_p;
    p_p = 0;
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
    }
  }
}

void sub_1CD6CD2F0(void *a1@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::sections(a1, (uint64_t)&v13);
  if (v14)
  {
    uint64_t v9 = v13;
    std::string::size_type v13 = 0;
    uint64_t v10 = v9;
    sub_1CD4515D0(&v10);
    if (v10) {
      (*(void (**)(void *))(*v10 + 8))(v10);
    }
    a3[23] = 15;
    strcpy(a3, "[unknown index]");
  }
  else
  {
    std::to_string(&v11, 0xCCCCCCCCCCCCCCCDLL * ((a2 - (uint64_t)v13) >> 3));
    int v5 = std::string::insert(&v11, 0, "[index ");
    std::string::size_type v6 = v5->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v12.__r_.__value_.__l.__data_ = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
    v12.__r_.__value_.__r.__words[2] = v6;
    v5->__r_.__value_.__l.__size_ = 0;
    v5->__r_.__value_.__r.__words[2] = 0;
    v5->__r_.__value_.__r.__words[0] = 0;
    long long v7 = std::string::append(&v12, "]");
    *(std::string *)a3 = *v7;
    v7->__r_.__value_.__r.__words[0] = 0;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v12.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v11.__r_.__value_.__l.__data_);
    }
  }
  if (v14)
  {
    uint64_t v8 = v13;
    std::string::size_type v13 = 0;
    if (v8) {
      (*(void (**)(void *))(*v8 + 8))(v8);
    }
  }
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSectionContents@<X0>(void *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3 = result;
  uint64_t v5 = bswap32(*(_DWORD *)(a2 + 16));
  std::string::size_type v6 = (void *)bswap32(*(_DWORD *)(a2 + 20));
  if (__CFADD__(v5, v6))
  {
    sub_1CD6CD2F0(result, a2, (char *)&v19);
    uint64_t v8 = std::string::insert(&v19, 0, "section ");
    std::string::size_type v9 = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v21.__r_.__value_.__l.__data_ = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v21.__r_.__value_.__r.__words[2] = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    uint64_t v10 = std::string::append(&v21, " has a sh_offset (0x");
    std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
    long long __p = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    std::string::size_type v25 = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    __int16 v41 = 260;
    v40[0] = (uint64_t)&__p;
    v16[0] = v5;
    v38[0] = (uint64_t)v16;
    v38[2] = 0;
    __int16 v39 = 270;
    sub_1CB8F1E58(v40, v38, (uint64_t)v42);
    v36[0] = (uint64_t)") + sh_size (0x";
    __int16 v37 = 259;
    sub_1CB8F1E58(v42, v36, (uint64_t)v43);
    v30[0] = v6;
    v33[0] = (uint64_t)v30;
    uint64_t v34 = 0;
    __int16 v35 = 270;
    sub_1CB8F1E58(v43, v33, (uint64_t)v44);
    v31[0] = (uint64_t)") that cannot be represented";
    __int16 v32 = 259;
    sub_1CB8F1E58(v44, v31, (uint64_t)v45);
    operator new();
  }
  if (result[1] < (unint64_t)(v6 + v5))
  {
    sub_1CD6CD2F0(result, a2, (char *)&v28);
    std::string v12 = std::string::insert(&v28, 0, "section ");
    std::string::size_type v13 = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v29.__r_.__value_.__r.__words[2] = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    char v14 = std::string::append(&v29, " has a sh_offset (0x");
    uint64_t v15 = (void *)v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string v30 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    void v30[2] = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    __int16 v37 = 260;
    v36[0] = (uint64_t)v30;
    uint64_t v27 = v5;
    v33[0] = (uint64_t)&v27;
    uint64_t v34 = 0;
    __int16 v35 = 270;
    sub_1CB8F1E58(v36, v33, (uint64_t)v38);
    v31[0] = (uint64_t)") + sh_size (0x";
    __int16 v32 = 259;
    sub_1CB8F1E58(v38, v31, (uint64_t)v40);
    uint64_t v23 = v6;
    *(void *)&long long __p = &v23;
    std::string::size_type v25 = 0;
    __int16 v26 = 270;
    sub_1CB8F1E58(v40, (uint64_t *)&__p, (uint64_t)v42);
    v21.__r_.__value_.__r.__words[0] = (std::string::size_type)") that is greater than the file size (0x";
    __int16 v22 = 259;
    sub_1CB8F1E58(v42, (uint64_t *)&v21, (uint64_t)v43);
    uint64_t v18 = v3[1];
    v19.__r_.__value_.__r.__words[0] = (std::string::size_type)&v18;
    v19.__r_.__value_.__r.__words[2] = 0;
    __int16 v20 = 270;
    sub_1CB8F1E58(v43, (uint64_t *)&v19, (uint64_t)v44);
    v16[0] = (uint64_t)")";
    __int16 v17 = 259;
    sub_1CB8F1E58(v44, v16, (uint64_t)v45);
    operator new();
  }
  uint64_t v7 = *result + v5;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v6;
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSection@<X0>(void *a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t result = (uint64_t)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::sections(a1, (uint64_t)v7);
  if (v8)
  {
    uint64_t v6 = v7[0];
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v6;
  }
  else
  {
    uint64_t result = sub_1CD6CA180(v7[0], v7[1], a2, a3);
    if (v8)
    {
      uint64_t result = v7[0];
      v7[0] = 0;
      if (result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
    }
  }
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSHNDXTable@<X0>(void *a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t result = (uint64_t)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::sections(a1, (uint64_t)v8);
  if (v9)
  {
    uint64_t v7 = v8[0];
    *(unsigned char *)(a3 + 16) |= 1u;
    *(void *)a3 = v7;
  }
  else
  {
    uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSHNDXTable(a1, a2, v8[0], v8[1], a3);
    if (v9)
    {
      uint64_t result = v8[0];
      v8[0] = 0;
      if (result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
    }
  }
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSHNDXTable@<X0>(void *a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t result = (uint64_t)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::relrs(a1, a2, (uint64_t)v36);
  uint64_t v11 = v36[0];
  if (v37)
  {
    *(unsigned char *)(a5 + 16) |= 1u;
    *(void *)a5 = v11;
    return result;
  }
  uint64_t v12 = v36[1];
  uint64_t result = sub_1CD6CA180(a3, a4, bswap32(a2[6]), (uint64_t)&v34);
  uint64_t v13 = v34;
  if (v35)
  {
    uint64_t v34 = 0;
    *(unsigned char *)(a5 + 16) |= 1u;
    *(void *)a5 = v13;
  }
  else
  {
    unsigned int v14 = *(_DWORD *)(v34 + 4);
    if (v14 != 0x2000000 && v14 != 184549376)
    {
      ELFSectionTypeName = llvm::object::getELFSectionTypeName((llvm::object *)(bswap32(*(unsigned __int16 *)(*a1 + 18)) >> 16), bswap32(v14));
      __int16 v32 = 1283;
      v31[0] = (uint64_t)"SHT_SYMTAB_SHNDX section is linked with ";
      v31[2] = (uint64_t)ELFSectionTypeName;
      void v31[3] = v17;
      v29[0] = (uint64_t)" section (expected SHT_SYMTAB/SHT_DYNSYM)";
      __int16 v30 = 259;
      uint64_t v18 = v29;
      goto LABEL_14;
    }
    uint64_t v28 = bswap32(*(_DWORD *)(v34 + 20)) >> 4;
    if (v12 != v28)
    {
      __int16 v26 = "SHT_SYMTAB_SHNDX has ";
      __int16 v27 = 259;
      __int16 v25 = 266;
      uint64_t v23 = v12;
      v24[0] = (uint64_t)&v23;
      sub_1CB8F1E58((uint64_t *)&v26, v24, (uint64_t)v29);
      std::string v21 = " entries, but the symbol table associated has ";
      __int16 v22 = 259;
      sub_1CB8F1E58(v29, (uint64_t *)&v21, (uint64_t)v31);
      __int16 v20 = 268;
      std::string v19 = &v28;
      uint64_t v18 = (uint64_t *)&v19;
LABEL_14:
      sub_1CB8F1E58(v31, v18, (uint64_t)v33);
      operator new();
    }
    *(unsigned char *)(a5 + 16) &= ~1u;
    *(void *)(a5 + 8) = v12;
    *(void *)a5 = v11;
  }
  if (v35)
  {
    uint64_t result = v34;
    uint64_t v34 = 0;
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  if (v37)
  {
    uint64_t result = v36[0];
    v36[0] = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::relrs@<X0>(void *result@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  __int16 v4 = result;
  if (a2[9] != 0x4000000)
  {
    sub_1CD6CD2F0(result, (uint64_t)a2, (char *)&v35);
    char v9 = std::string::insert(&v35, 0, "section ");
    std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v41.__r_.__value_.__l.__data_ = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v41.__r_.__value_.__r.__words[2] = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    uint64_t v11 = std::string::append(&v41, " has invalid sh_entsize: expected ");
    std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
    long long __p = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    std::string::size_type v44 = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    __int16 v53 = 260;
    v52[0] = (uint64_t)&__p;
    v32.__r_.__value_.__r.__words[0] = 4;
    __int16 v51 = 266;
    v50[0] = (uint64_t)&v32;
    sub_1CB8F1E58(v52, v50, (uint64_t)v54);
    v48[0] = (uint64_t)", but got ";
    __int16 v49 = 259;
    sub_1CB8F1E58(v54, v48, (uint64_t)v55);
    unsigned int v13 = bswap32(a2[9]);
    __int16 v47 = 264;
    LODWORD(v46[0]) = v13;
    sub_1CB8F1E58(v55, v46, (uint64_t)v56);
    operator new();
  }
  unint64_t v6 = bswap32(a2[5]);
  if ((v6 & 3) != 0)
  {
    sub_1CD6CD2F0(result, (uint64_t)a2, (char *)&v30);
    unsigned int v14 = std::string::insert(&v30, 0, "section ");
    std::string::size_type v15 = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    __int16 v16 = std::string::append(&v32, " has an invalid sh_size (");
    std::string::size_type v17 = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    __int16 v51 = 260;
    v50[0] = (uint64_t)&v35;
    __int16 v49 = 264;
    LODWORD(v48[0]) = v6;
    sub_1CB8F1E58(v50, v48, (uint64_t)v52);
    v46[0] = (uint64_t)") which is not a multiple of its sh_entsize (";
    __int16 v47 = 259;
    sub_1CB8F1E58(v52, v46, (uint64_t)v54);
    unsigned int v18 = bswap32(a2[9]);
    __int16 v45 = 264;
    LODWORD(__p) = v18;
    sub_1CB8F1E58(v54, (uint64_t *)&__p, (uint64_t)v55);
    v41.__r_.__value_.__r.__words[0] = (std::string::size_type)")";
    __int16 v42 = 259;
    goto LABEL_9;
  }
  uint64_t v7 = bswap32(a2[4]);
  if (__CFADD__(v7, v6))
  {
    sub_1CD6CD2F0(result, (uint64_t)a2, (char *)&v30);
    std::string v19 = std::string::insert(&v30, 0, "section ");
    std::string::size_type v20 = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    std::string v21 = std::string::append(&v32, " has a sh_offset (0x");
    std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    __int16 v51 = 260;
    v50[0] = (uint64_t)&v35;
    v27[0] = v7;
    v48[0] = (uint64_t)v27;
    void v48[2] = 0;
    __int16 v49 = 270;
    sub_1CB8F1E58(v50, v48, (uint64_t)v52);
    v46[0] = (uint64_t)") + sh_size (0x";
    __int16 v47 = 259;
    sub_1CB8F1E58(v52, v46, (uint64_t)v54);
    v40[0] = (void *)v6;
    *(void *)&long long __p = v40;
    std::string::size_type v44 = 0;
    __int16 v45 = 270;
    sub_1CB8F1E58(v54, (uint64_t *)&__p, (uint64_t)v55);
    v41.__r_.__value_.__r.__words[0] = (std::string::size_type)") that cannot be represented";
    __int16 v42 = 259;
LABEL_9:
    sub_1CB8F1E58(v55, (uint64_t *)&v41, (uint64_t)v56);
    operator new();
  }
  if (result[1] < (unint64_t)(v6 + v7))
  {
    sub_1CD6CD2F0(result, (uint64_t)a2, (char *)&v38);
    uint64_t v23 = std::string::insert(&v38, 0, "section ");
    std::string::size_type v24 = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v39.__r_.__value_.__l.__data_ = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v39.__r_.__value_.__r.__words[2] = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    __int16 v25 = std::string::append(&v39, " has a sh_offset (0x");
    __int16 v26 = (void *)v25->__r_.__value_.__r.__words[2];
    *(_OWORD *)uint64_t v40 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
    v40[2] = v26;
    v25->__r_.__value_.__l.__size_ = 0;
    v25->__r_.__value_.__r.__words[2] = 0;
    v25->__r_.__value_.__r.__words[0] = 0;
    __int16 v47 = 260;
    v46[0] = (uint64_t)v40;
    uint64_t v37 = v7;
    *(void *)&long long __p = &v37;
    std::string::size_type v44 = 0;
    __int16 v45 = 270;
    sub_1CB8F1E58(v46, (uint64_t *)&__p, (uint64_t)v48);
    v41.__r_.__value_.__r.__words[0] = (std::string::size_type)") + sh_size (0x";
    __int16 v42 = 259;
    sub_1CB8F1E58(v48, (uint64_t *)&v41, (uint64_t)v50);
    unint64_t v34 = v6;
    v35.__r_.__value_.__r.__words[0] = (std::string::size_type)&v34;
    v35.__r_.__value_.__r.__words[2] = 0;
    __int16 v36 = 270;
    sub_1CB8F1E58(v50, (uint64_t *)&v35, (uint64_t)v52);
    v32.__r_.__value_.__r.__words[0] = (std::string::size_type)") that is greater than the file size (0x";
    __int16 v33 = 259;
    sub_1CB8F1E58(v52, (uint64_t *)&v32, (uint64_t)v54);
    uint64_t v29 = v4[1];
    v30.__r_.__value_.__r.__words[0] = (std::string::size_type)&v29;
    v30.__r_.__value_.__r.__words[2] = 0;
    __int16 v31 = 270;
    sub_1CB8F1E58(v54, (uint64_t *)&v30, (uint64_t)v55);
    v27[0] = (uint64_t)")";
    __int16 v28 = 259;
    sub_1CB8F1E58(v55, v27, (uint64_t)v56);
    operator new();
  }
  uint64_t v8 = *result + v7;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v8;
  *(void *)(a3 + 8) = v6 >> 2;
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getRelocationTypeName(uint64_t a1, unsigned int a2, void *a3)
{
  unsigned int v5 = *(unsigned __int16 *)(*(void *)a1 + 18);
  if (v5 == 2048 && *(unsigned char *)(*(void *)a1 + 4) == 2)
  {
    ELFRelocationTypeName = (char *)llvm::object::getELFRelocationTypeName((llvm::object *)8, a2);
    sub_1CC22C75C(a3, ELFRelocationTypeName, &ELFRelocationTypeName[v8]);
    char v9 = (char *)llvm::object::getELFRelocationTypeName((llvm::object *)(bswap32(*(unsigned __int16 *)(*(void *)a1 + 18)) >> 16), BYTE1(a2));
    uint64_t v11 = v10;
    sub_1CD68E82C(a3, 1uLL, 47);
    sub_1CC22C75C(a3, v9, &v9[v11]);
    std::string::size_type v12 = llvm::object::getELFRelocationTypeName((llvm::object *)(bswap32(*(unsigned __int16 *)(*(void *)a1 + 18)) >> 16), BYTE2(a2));
    uint64_t v14 = v13;
    sub_1CD68E82C(a3, 1uLL, 47);
    std::string::size_type v15 = (char *)&v12[v14];
    __int16 v16 = a3;
    std::string::size_type v17 = (char *)v12;
  }
  else
  {
    unsigned int v18 = llvm::object::getELFRelocationTypeName((llvm::object *)__rev16(v5), a2);
    std::string::size_type v15 = (char *)&v18[v19];
    __int16 v16 = a3;
    std::string::size_type v17 = (char *)v18;
  }

  return sub_1CC22C75C(v16, v17, v15);
}

void *sub_1CD6CE4A0@<X0>(void *a1@<X0>, unsigned int *a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t result = sub_1CD6CE6A4(a1, a2, (uint64_t)v26);
  if (v27)
  {
    uint64_t v8 = v26[0];
    char v9 = *(unsigned char *)(a4 + 8) | 1;
  }
  else
  {
    if (v26[1] <= (unint64_t)a3)
    {
      std::string::size_type v20 = "can't read an entry at 0x";
      __int16 v21 = 259;
      uint64_t v17 = 16 * a3;
      v18[0] = (uint64_t)&v17;
      void v18[2] = 0;
      __int16 v19 = 270;
      sub_1CB8F1E58((uint64_t *)&v20, v18, (uint64_t)v22);
      std::string::size_type v15 = ": it goes past the end of the section (0x";
      __int16 v16 = 259;
      sub_1CB8F1E58(v22, (uint64_t *)&v15, (uint64_t)v23);
      uint64_t v12 = bswap32(a2[5]);
      v13[0] = (uint64_t)&v12;
      void v13[2] = 0;
      __int16 v14 = 270;
      sub_1CB8F1E58(v23, v13, (uint64_t)v24);
      uint64_t v10 = ")";
      __int16 v11 = 259;
      sub_1CB8F1E58(v24, (uint64_t *)&v10, (uint64_t)v25);
      operator new();
    }
    uint64_t v8 = v26[0] + 16 * a3;
    char v9 = *(unsigned char *)(a4 + 8) & 0xFE;
  }
  *(unsigned char *)(a4 + 8) = v9;
  *(void *)a4 = v8;
  return result;
}

void *sub_1CD6CE6A4@<X0>(void *result@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  __int16 v4 = result;
  if (a2[9] != 0x10000000)
  {
    sub_1CD6CD2F0(result, (uint64_t)a2, (char *)&v35);
    char v9 = std::string::insert(&v35, 0, "section ");
    std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v41.__r_.__value_.__l.__data_ = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v41.__r_.__value_.__r.__words[2] = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    __int16 v11 = std::string::append(&v41, " has invalid sh_entsize: expected ");
    std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
    long long __p = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    std::string::size_type v44 = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    __int16 v53 = 260;
    v52[0] = (uint64_t)&__p;
    v32.__r_.__value_.__r.__words[0] = 16;
    __int16 v51 = 266;
    v50[0] = (uint64_t)&v32;
    sub_1CB8F1E58(v52, v50, (uint64_t)v54);
    v48[0] = (uint64_t)", but got ";
    __int16 v49 = 259;
    sub_1CB8F1E58(v54, v48, (uint64_t)v55);
    unsigned int v13 = bswap32(a2[9]);
    __int16 v47 = 264;
    LODWORD(v46[0]) = v13;
    sub_1CB8F1E58(v55, v46, (uint64_t)v56);
    operator new();
  }
  unint64_t v6 = bswap32(a2[5]);
  if ((v6 & 0xF) != 0)
  {
    sub_1CD6CD2F0(result, (uint64_t)a2, (char *)&v30);
    __int16 v14 = std::string::insert(&v30, 0, "section ");
    std::string::size_type v15 = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    __int16 v16 = std::string::append(&v32, " has an invalid sh_size (");
    std::string::size_type v17 = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    __int16 v51 = 260;
    v50[0] = (uint64_t)&v35;
    __int16 v49 = 264;
    LODWORD(v48[0]) = v6;
    sub_1CB8F1E58(v50, v48, (uint64_t)v52);
    v46[0] = (uint64_t)") which is not a multiple of its sh_entsize (";
    __int16 v47 = 259;
    sub_1CB8F1E58(v52, v46, (uint64_t)v54);
    unsigned int v18 = bswap32(a2[9]);
    __int16 v45 = 264;
    LODWORD(__p) = v18;
    sub_1CB8F1E58(v54, (uint64_t *)&__p, (uint64_t)v55);
    v41.__r_.__value_.__r.__words[0] = (std::string::size_type)")";
    __int16 v42 = 259;
    goto LABEL_9;
  }
  uint64_t v7 = bswap32(a2[4]);
  if (__CFADD__(v7, v6))
  {
    sub_1CD6CD2F0(result, (uint64_t)a2, (char *)&v30);
    __int16 v19 = std::string::insert(&v30, 0, "section ");
    std::string::size_type v20 = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    __int16 v21 = std::string::append(&v32, " has a sh_offset (0x");
    std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    __int16 v51 = 260;
    v50[0] = (uint64_t)&v35;
    v27[0] = v7;
    v48[0] = (uint64_t)v27;
    void v48[2] = 0;
    __int16 v49 = 270;
    sub_1CB8F1E58(v50, v48, (uint64_t)v52);
    v46[0] = (uint64_t)") + sh_size (0x";
    __int16 v47 = 259;
    sub_1CB8F1E58(v52, v46, (uint64_t)v54);
    v40[0] = (void *)v6;
    *(void *)&long long __p = v40;
    std::string::size_type v44 = 0;
    __int16 v45 = 270;
    sub_1CB8F1E58(v54, (uint64_t *)&__p, (uint64_t)v55);
    v41.__r_.__value_.__r.__words[0] = (std::string::size_type)") that cannot be represented";
    __int16 v42 = 259;
LABEL_9:
    sub_1CB8F1E58(v55, (uint64_t *)&v41, (uint64_t)v56);
    operator new();
  }
  if (result[1] < (unint64_t)(v6 + v7))
  {
    sub_1CD6CD2F0(result, (uint64_t)a2, (char *)&v38);
    uint64_t v23 = std::string::insert(&v38, 0, "section ");
    std::string::size_type v24 = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v39.__r_.__value_.__l.__data_ = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v39.__r_.__value_.__r.__words[2] = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    __int16 v25 = std::string::append(&v39, " has a sh_offset (0x");
    __int16 v26 = (void *)v25->__r_.__value_.__r.__words[2];
    *(_OWORD *)uint64_t v40 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
    v40[2] = v26;
    v25->__r_.__value_.__l.__size_ = 0;
    v25->__r_.__value_.__r.__words[2] = 0;
    v25->__r_.__value_.__r.__words[0] = 0;
    __int16 v47 = 260;
    v46[0] = (uint64_t)v40;
    uint64_t v37 = v7;
    *(void *)&long long __p = &v37;
    std::string::size_type v44 = 0;
    __int16 v45 = 270;
    sub_1CB8F1E58(v46, (uint64_t *)&__p, (uint64_t)v48);
    v41.__r_.__value_.__r.__words[0] = (std::string::size_type)") + sh_size (0x";
    __int16 v42 = 259;
    sub_1CB8F1E58(v48, (uint64_t *)&v41, (uint64_t)v50);
    unint64_t v34 = v6;
    v35.__r_.__value_.__r.__words[0] = (std::string::size_type)&v34;
    v35.__r_.__value_.__r.__words[2] = 0;
    __int16 v36 = 270;
    sub_1CB8F1E58(v50, (uint64_t *)&v35, (uint64_t)v52);
    v32.__r_.__value_.__r.__words[0] = (std::string::size_type)") that is greater than the file size (0x";
    __int16 v33 = 259;
    sub_1CB8F1E58(v52, (uint64_t *)&v32, (uint64_t)v54);
    uint64_t v29 = v4[1];
    v30.__r_.__value_.__r.__words[0] = (std::string::size_type)&v29;
    v30.__r_.__value_.__r.__words[2] = 0;
    __int16 v31 = 270;
    sub_1CB8F1E58(v54, (uint64_t *)&v30, (uint64_t)v55);
    v27[0] = (uint64_t)")";
    __int16 v28 = 259;
    sub_1CB8F1E58(v55, v27, (uint64_t)v56);
    operator new();
  }
  uint64_t v8 = *result + v7;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v8;
  *(void *)(a3 + 8) = v6 >> 4;
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::relas@<X0>(void *result@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  __int16 v4 = result;
  if (a2[9] != 201326592)
  {
    sub_1CD6CD2F0(result, (uint64_t)a2, (char *)&v34);
    uint64_t v8 = std::string::insert(&v34, 0, "section ");
    std::string::size_type v9 = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v40.__r_.__value_.__l.__data_ = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v40.__r_.__value_.__r.__words[2] = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v10 = std::string::append(&v40, " has invalid sh_entsize: expected ");
    std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
    long long __p = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    std::string::size_type v43 = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    __int16 v52 = 260;
    v51[0] = (uint64_t)&__p;
    v31.__r_.__value_.__r.__words[0] = 12;
    __int16 v50 = 266;
    v49[0] = (uint64_t)&v31;
    sub_1CB8F1E58(v51, v49, (uint64_t)v53);
    v47[0] = (uint64_t)", but got ";
    __int16 v48 = 259;
    sub_1CB8F1E58(v53, v47, (uint64_t)v54);
    unsigned int v12 = bswap32(a2[9]);
    __int16 v46 = 264;
    LODWORD(v45[0]) = v12;
    sub_1CB8F1E58(v54, v45, (uint64_t)v55);
    operator new();
  }
  unsigned int v5 = (void *)bswap32(a2[5]);
  if (v5 % 0xC)
  {
    sub_1CD6CD2F0(result, (uint64_t)a2, (char *)&v29);
    unsigned int v13 = std::string::insert(&v29, 0, "section ");
    std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v15 = std::string::append(&v31, " has an invalid sh_size (");
    std::string::size_type v16 = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v34.__r_.__value_.__l.__data_ = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v34.__r_.__value_.__r.__words[2] = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    __int16 v50 = 260;
    v49[0] = (uint64_t)&v34;
    __int16 v48 = 264;
    LODWORD(v47[0]) = v5;
    sub_1CB8F1E58(v49, v47, (uint64_t)v51);
    v45[0] = (uint64_t)") which is not a multiple of its sh_entsize (";
    __int16 v46 = 259;
    sub_1CB8F1E58(v51, v45, (uint64_t)v53);
    unsigned int v17 = bswap32(a2[9]);
    __int16 v44 = 264;
    LODWORD(__p) = v17;
    sub_1CB8F1E58(v53, (uint64_t *)&__p, (uint64_t)v54);
    v40.__r_.__value_.__r.__words[0] = (std::string::size_type)")";
    __int16 v41 = 259;
    goto LABEL_9;
  }
  uint64_t v6 = bswap32(a2[4]);
  if (__CFADD__(v6, v5))
  {
    sub_1CD6CD2F0(result, (uint64_t)a2, (char *)&v29);
    unsigned int v18 = std::string::insert(&v29, 0, "section ");
    std::string::size_type v19 = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v20 = std::string::append(&v31, " has a sh_offset (0x");
    std::string::size_type v21 = v20->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v34.__r_.__value_.__l.__data_ = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v34.__r_.__value_.__r.__words[2] = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    __int16 v50 = 260;
    v49[0] = (uint64_t)&v34;
    v26[0] = v6;
    v47[0] = (uint64_t)v26;
    v47[2] = 0;
    __int16 v48 = 270;
    sub_1CB8F1E58(v49, v47, (uint64_t)v51);
    v45[0] = (uint64_t)") + sh_size (0x";
    __int16 v46 = 259;
    sub_1CB8F1E58(v51, v45, (uint64_t)v53);
    v39[0] = v5;
    *(void *)&long long __p = v39;
    std::string::size_type v43 = 0;
    __int16 v44 = 270;
    sub_1CB8F1E58(v53, (uint64_t *)&__p, (uint64_t)v54);
    v40.__r_.__value_.__r.__words[0] = (std::string::size_type)") that cannot be represented";
    __int16 v41 = 259;
LABEL_9:
    sub_1CB8F1E58(v54, (uint64_t *)&v40, (uint64_t)v55);
    operator new();
  }
  if (result[1] < (unint64_t)(v5 + v6))
  {
    sub_1CD6CD2F0(result, (uint64_t)a2, (char *)&v37);
    std::string::size_type v22 = std::string::insert(&v37, 0, "section ");
    std::string::size_type v23 = v22->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v38.__r_.__value_.__l.__data_ = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v38.__r_.__value_.__r.__words[2] = v23;
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v24 = std::string::append(&v38, " has a sh_offset (0x");
    __int16 v25 = (void *)v24->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string v39 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
    v39[2] = v25;
    v24->__r_.__value_.__l.__size_ = 0;
    v24->__r_.__value_.__r.__words[2] = 0;
    v24->__r_.__value_.__r.__words[0] = 0;
    __int16 v46 = 260;
    v45[0] = (uint64_t)v39;
    uint64_t v36 = v6;
    *(void *)&long long __p = &v36;
    std::string::size_type v43 = 0;
    __int16 v44 = 270;
    sub_1CB8F1E58(v45, (uint64_t *)&__p, (uint64_t)v47);
    v40.__r_.__value_.__r.__words[0] = (std::string::size_type)") + sh_size (0x";
    __int16 v41 = 259;
    sub_1CB8F1E58(v47, (uint64_t *)&v40, (uint64_t)v49);
    __int16 v33 = v5;
    v34.__r_.__value_.__r.__words[0] = (std::string::size_type)&v33;
    v34.__r_.__value_.__r.__words[2] = 0;
    __int16 v35 = 270;
    sub_1CB8F1E58(v49, (uint64_t *)&v34, (uint64_t)v51);
    v31.__r_.__value_.__r.__words[0] = (std::string::size_type)") that is greater than the file size (0x";
    __int16 v32 = 259;
    sub_1CB8F1E58(v51, (uint64_t *)&v31, (uint64_t)v53);
    uint64_t v28 = v4[1];
    v29.__r_.__value_.__r.__words[0] = (std::string::size_type)&v28;
    v29.__r_.__value_.__r.__words[2] = 0;
    __int16 v30 = 270;
    sub_1CB8F1E58(v53, (uint64_t *)&v29, (uint64_t)v54);
    v26[0] = (uint64_t)")";
    __int16 v27 = 259;
    sub_1CB8F1E58(v54, v26, (uint64_t)v55);
    operator new();
  }
  uint64_t v7 = *result + v6;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v5 / 0xC;
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::rels@<X0>(void *result@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  __int16 v4 = result;
  if (a2[9] != 0x8000000)
  {
    sub_1CD6CD2F0(result, (uint64_t)a2, (char *)&v35);
    std::string::size_type v9 = std::string::insert(&v35, 0, "section ");
    std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v41.__r_.__value_.__l.__data_ = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v41.__r_.__value_.__r.__words[2] = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v11 = std::string::append(&v41, " has invalid sh_entsize: expected ");
    std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
    long long __p = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    std::string::size_type v44 = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    __int16 v53 = 260;
    v52[0] = (uint64_t)&__p;
    v32.__r_.__value_.__r.__words[0] = 8;
    __int16 v51 = 266;
    v50[0] = (uint64_t)&v32;
    sub_1CB8F1E58(v52, v50, (uint64_t)v54);
    v48[0] = (uint64_t)", but got ";
    __int16 v49 = 259;
    sub_1CB8F1E58(v54, v48, (uint64_t)v55);
    unsigned int v13 = bswap32(a2[9]);
    __int16 v47 = 264;
    LODWORD(v46[0]) = v13;
    sub_1CB8F1E58(v55, v46, (uint64_t)v56);
    operator new();
  }
  unint64_t v6 = bswap32(a2[5]);
  if ((v6 & 7) != 0)
  {
    sub_1CD6CD2F0(result, (uint64_t)a2, (char *)&v30);
    std::string::size_type v14 = std::string::insert(&v30, 0, "section ");
    std::string::size_type v15 = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v16 = std::string::append(&v32, " has an invalid sh_size (");
    std::string::size_type v17 = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    __int16 v51 = 260;
    v50[0] = (uint64_t)&v35;
    __int16 v49 = 264;
    LODWORD(v48[0]) = v6;
    sub_1CB8F1E58(v50, v48, (uint64_t)v52);
    v46[0] = (uint64_t)") which is not a multiple of its sh_entsize (";
    __int16 v47 = 259;
    sub_1CB8F1E58(v52, v46, (uint64_t)v54);
    unsigned int v18 = bswap32(a2[9]);
    __int16 v45 = 264;
    LODWORD(__p) = v18;
    sub_1CB8F1E58(v54, (uint64_t *)&__p, (uint64_t)v55);
    v41.__r_.__value_.__r.__words[0] = (std::string::size_type)")";
    __int16 v42 = 259;
    goto LABEL_9;
  }
  uint64_t v7 = bswap32(a2[4]);
  if (__CFADD__(v7, v6))
  {
    sub_1CD6CD2F0(result, (uint64_t)a2, (char *)&v30);
    std::string::size_type v19 = std::string::insert(&v30, 0, "section ");
    std::string::size_type v20 = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v21 = std::string::append(&v32, " has a sh_offset (0x");
    std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    __int16 v51 = 260;
    v50[0] = (uint64_t)&v35;
    v27[0] = v7;
    v48[0] = (uint64_t)v27;
    void v48[2] = 0;
    __int16 v49 = 270;
    sub_1CB8F1E58(v50, v48, (uint64_t)v52);
    v46[0] = (uint64_t)") + sh_size (0x";
    __int16 v47 = 259;
    sub_1CB8F1E58(v52, v46, (uint64_t)v54);
    v40[0] = (void *)v6;
    *(void *)&long long __p = v40;
    std::string::size_type v44 = 0;
    __int16 v45 = 270;
    sub_1CB8F1E58(v54, (uint64_t *)&__p, (uint64_t)v55);
    v41.__r_.__value_.__r.__words[0] = (std::string::size_type)") that cannot be represented";
    __int16 v42 = 259;
LABEL_9:
    sub_1CB8F1E58(v55, (uint64_t *)&v41, (uint64_t)v56);
    operator new();
  }
  if (result[1] < (unint64_t)(v6 + v7))
  {
    sub_1CD6CD2F0(result, (uint64_t)a2, (char *)&v38);
    std::string::size_type v23 = std::string::insert(&v38, 0, "section ");
    std::string::size_type v24 = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v39.__r_.__value_.__l.__data_ = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v39.__r_.__value_.__r.__words[2] = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    __int16 v25 = std::string::append(&v39, " has a sh_offset (0x");
    __int16 v26 = (void *)v25->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string v40 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
    v40[2] = v26;
    v25->__r_.__value_.__l.__size_ = 0;
    v25->__r_.__value_.__r.__words[2] = 0;
    v25->__r_.__value_.__r.__words[0] = 0;
    __int16 v47 = 260;
    v46[0] = (uint64_t)v40;
    uint64_t v37 = v7;
    *(void *)&long long __p = &v37;
    std::string::size_type v44 = 0;
    __int16 v45 = 270;
    sub_1CB8F1E58(v46, (uint64_t *)&__p, (uint64_t)v48);
    v41.__r_.__value_.__r.__words[0] = (std::string::size_type)") + sh_size (0x";
    __int16 v42 = 259;
    sub_1CB8F1E58(v48, (uint64_t *)&v41, (uint64_t)v50);
    unint64_t v34 = v6;
    v35.__r_.__value_.__r.__words[0] = (std::string::size_type)&v34;
    v35.__r_.__value_.__r.__words[2] = 0;
    __int16 v36 = 270;
    sub_1CB8F1E58(v50, (uint64_t *)&v35, (uint64_t)v52);
    v32.__r_.__value_.__r.__words[0] = (std::string::size_type)") that is greater than the file size (0x";
    __int16 v33 = 259;
    sub_1CB8F1E58(v52, (uint64_t *)&v32, (uint64_t)v54);
    uint64_t v29 = v4[1];
    v30.__r_.__value_.__r.__words[0] = (std::string::size_type)&v29;
    v30.__r_.__value_.__r.__words[2] = 0;
    __int16 v31 = 270;
    sub_1CB8F1E58(v54, (uint64_t *)&v30, (uint64_t)v55);
    v27[0] = (uint64_t)")";
    __int16 v28 = 259;
    sub_1CB8F1E58(v55, v27, (uint64_t)v56);
    operator new();
  }
  uint64_t v8 = *result + v7;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v8;
  *(void *)(a3 + 8) = v6 >> 3;
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSectionStringTable(void *a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, void (*a4)(uint64_t *__return_ptr, uint64_t, void *)@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  unsigned int v7 = *(unsigned __int16 *)(*a1 + 50);
  if (v7 == 0xFFFF)
  {
    if (!a3)
    {
      std::string::size_type v17 = "e_shstrndx == SHN_XINDEX, but the section header table is empty";
      __int16 v18 = 259;
LABEL_6:
      operator new();
    }
    unsigned int v8 = bswap32(*(_DWORD *)(a2 + 24));
  }
  else
  {
    unsigned int v8 = __rev16(v7);
  }
  if (v8)
  {
    if (a3 <= v8)
    {
      std::string::size_type v14 = "section header string table index ";
      __int16 v15 = 259;
      __int16 v13 = 264;
      LODWORD(v12[0]) = v8;
      sub_1CB8F1E58((uint64_t *)&v14, v12, (uint64_t)v16);
      std::string::size_type v10 = " does not exist";
      __int16 v11 = 259;
      sub_1CB8F1E58(v16, (uint64_t *)&v10, (uint64_t)&v17);
      goto LABEL_6;
    }
    uint64_t v9 = a2 + 40 * v8;
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getStringTable(a1, v9, a4, a5, a6);
  }
  else
  {
    *(unsigned char *)(a6 + 16) &= ~1u;
    *(void *)a6 = "";
    *(void *)(a6 + 8) = 0;
  }
}

uint64_t *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSectionIndex@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, _OWORD *a3@<X4>, uint64_t a4@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = *(unsigned __int16 *)(a1 + 14);
  if (v5 == 0xFFFF)
  {
    long long v7 = a3[1];
    v10[0] = *a3;
    v10[1] = v7;
    uint64_t result = sub_1CD6CFCE8((unint64_t)(a1 - a2) >> 4, (uint64_t *)v10, (uint64_t)&v11);
    if (v12)
    {
      uint64_t v9 = v11;
      *(unsigned char *)(a4 + 8) |= 1u;
      *(void *)a4 = v9;
      return result;
    }
    *(unsigned char *)(a4 + 8) &= ~1u;
    unsigned int v6 = v11;
  }
  else
  {
    unsigned int v6 = __rev16(v5);
    *(unsigned char *)(a4 + 8) &= ~1u;
    if ((unsigned __int16)(v6 + 256) <= 0x100u)
    {
      *(_DWORD *)a4 = 0;
      return result;
    }
  }
  *(_DWORD *)a4 = v6;
  return result;
}

uint64_t *sub_1CD6CFCE8@<X0>(unsigned int a1@<W1>, uint64_t *a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!*a2)
  {
    v17[0] = (uint64_t)"found an extended symbol index (";
    __int16 v18 = 259;
    __int16 v16 = 264;
    LODWORD(v15[0]) = a1;
    sub_1CB8F1E58(v17, v15, (uint64_t)v19);
    v13[0] = (uint64_t)"), but unable to locate the extended symbol index table";
    __int16 v14 = 259;
    sub_1CB8F1E58(v19, v13, (uint64_t)v20);
    operator new();
  }
  uint64_t result = sub_1CD6D614C(a2, a1, (uint64_t)&v21);
  if (v22)
  {
    v15[0] = (uint64_t)"unable to read an extended symbol table at index ";
    __int16 v16 = 259;
    __int16 v14 = 264;
    LODWORD(v13[0]) = a1;
    sub_1CB8F1E58(v15, v13, (uint64_t)v17);
    uint64_t v11 = ": ";
    __int16 v12 = 259;
    sub_1CB8F1E58(v17, (uint64_t *)&v11, (uint64_t)v19);
    if (v22)
    {
      uint64_t v6 = v21;
      uint64_t v21 = 0;
    }
    else
    {
      uint64_t v6 = 0;
    }
    uint64_t v7 = v6;
    sub_1CD4FB504(&v7, &__p);
    __int16 v10 = 260;
    p_p = &__p;
    sub_1CB8F1E58(v19, (uint64_t *)&p_p, (uint64_t)v20);
    operator new();
  }
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(_DWORD *)a3 = bswap32(v21);
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSection@<X0>(void *a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>, _OWORD *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a3)
  {
    v13[0] = 0;
    v13[1] = 0;
    char v14 = 0;
    goto LABEL_3;
  }
  sub_1CD6CE6A4(a1, a3, (uint64_t)v13);
  if ((v14 & 1) == 0)
  {
    a3 = (unsigned int *)v13[0];
LABEL_3:
    long long v9 = a4[1];
    v12[0] = *a4;
    v12[1] = v9;
    uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSection(a1, a2, (uint64_t)a3, v12, a5);
    if ((v14 & 1) == 0) {
      return result;
    }
    goto LABEL_7;
  }
  uint64_t v11 = v13[0];
  v13[0] = 0;
  *(unsigned char *)(a5 + 8) |= 1u;
  *(void *)a5 = v11;
LABEL_7:
  uint64_t result = v13[0];
  v13[0] = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSection@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _OWORD *a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  long long v7 = a4[1];
  v10[0] = *a4;
  v10[1] = v7;
  uint64_t result = (uint64_t)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSectionIndex(a2, a3, v10, (uint64_t)&v11);
  if (v12)
  {
    uint64_t v9 = v11;
    *(unsigned char *)(a5 + 8) |= 1u;
    *(void *)a5 = v9;
  }
  else if (v11)
  {
    uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSection(a1, v11, a5);
    if (v12)
    {
      uint64_t result = v11;
      uint64_t v11 = 0;
      if (result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
    }
  }
  else
  {
    *(unsigned char *)(a5 + 8) &= ~1u;
    *(void *)a5 = 0;
  }
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSectionName(void *a1@<X0>, unsigned int *a2@<X1>, void (*a3)(uint64_t *__return_ptr, uint64_t, void *)@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::sections(a1, (uint64_t)v16);
  if (v17)
  {
    uint64_t v10 = v16[0];
    *(unsigned char *)(a5 + 16) |= 1u;
    *(void *)a5 = v10;
  }
  else
  {
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSectionStringTable(a1, v16[0], v16[1], a3, a4, (uint64_t)v14);
    if (v15)
    {
      uint64_t v11 = v14[0];
      *(unsigned char *)(a5 + 16) |= 1u;
      *(void *)a5 = v11;
    }
    else
    {
      llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSectionName(a1, a2, v14[0], v14[1], a5);
      if (v15)
      {
        uint64_t v13 = v14[0];
        v14[0] = 0;
        if (v13) {
          (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
        }
      }
    }
    if (v17)
    {
      uint64_t v12 = v16[0];
      v16[0] = 0;
      if (v12) {
        (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
      }
    }
  }
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSectionName@<X0>(void *result@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  if (*a2)
  {
    unint64_t v6 = bswap32(*a2);
    if (a4 <= v6)
    {
      sub_1CD6CD2F0(result, (uint64_t)a2, (char *)&v17);
      unsigned int v8 = std::string::insert(&v17, 0, "a section ");
      std::string::size_type v9 = v8->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v18.__r_.__value_.__l.__data_ = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      v18.__r_.__value_.__r.__words[2] = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      uint64_t v10 = std::string::append(&v18, " has an invalid sh_name (0x");
      std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
      std::string::size_type v20 = v11;
      v10->__r_.__value_.__l.__size_ = 0;
      v10->__r_.__value_.__r.__words[2] = 0;
      v10->__r_.__value_.__r.__words[0] = 0;
      __int16 v22 = 260;
      uint64_t v21 = __p;
      unint64_t v14 = v6;
      v15[0] = (uint64_t)&v14;
      uint64_t v15[2] = 0;
      __int16 v16 = 270;
      sub_1CB8F1E58((uint64_t *)&v21, v15, (uint64_t)v23);
      uint64_t v12 = ") offset which goes past the end of the section name string table";
      __int16 v13 = 259;
      sub_1CB8F1E58(v23, (uint64_t *)&v12, (uint64_t)v24);
      operator new();
    }
    long long v7 = (const char *)(a3 + v6);
    uint64_t result = (void *)strlen(v7);
    *(unsigned char *)(a5 + 16) &= ~1u;
    *(void *)a5 = v7;
    *(void *)(a5 + 8) = result;
  }
  else
  {
    *(unsigned char *)(a5 + 16) &= ~1u;
    *(void *)a5 = 0;
    *(void *)(a5 + 8) = 0;
  }
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getStringTable(void *a1@<X0>, uint64_t a2@<X1>, void (*a3)(uint64_t *__return_ptr, uint64_t, void *)@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a2 + 4) != 3)
  {
    sub_1CD6D0838(a1, a2, (char *)&v30);
    uint64_t v12 = std::string::insert(&v30, 0, "invalid sh_type for string table section ");
    std::string::size_type v13 = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    unint64_t v14 = std::string::append(&v31, ": expected SHT_STRTAB, but got ");
    std::string::size_type v15 = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    __int16 v39 = 260;
    p_p = &__p;
    ELFSectionTypeName = llvm::object::getELFSectionTypeName((llvm::object *)*(unsigned __int16 *)(*a1 + 18), *(_DWORD *)(a2 + 4));
    __int16 v29 = 261;
    v27[0] = (void *)ELFSectionTypeName;
    v27[1] = v17;
    sub_1CB8F1E58((uint64_t *)&p_p, (uint64_t *)v27, (uint64_t)v33);
    a3(&v35, a4, v33);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v31.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v30.__r_.__value_.__l.__data_);
    }
    uint64_t v18 = v35;
    if (v35)
    {
      *(unsigned char *)(a5 + 16) |= 1u;
      *(void *)a5 = v18;
      return;
    }
  }
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSectionContents(a1, a2, (uint64_t)&p_p);
  uint64_t v8 = (uint64_t)p_p;
  if ((v38 & 1) == 0)
  {
    uint64_t v9 = v37;
    if (v37)
    {
      if (!p_p->__r_.__value_.__s.__data_[v37 - 1])
      {
        *(unsigned char *)(a5 + 16) &= ~1u;
        *(void *)a5 = v8;
        *(void *)(a5 + 8) = v9;
        goto LABEL_16;
      }
      sub_1CD6D0838(a1, a2, (char *)&v31);
      __int16 v25 = std::string::insert(&v31, 0, "SHT_STRTAB string table section ");
      std::string::size_type v26 = v25->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v26;
      v25->__r_.__value_.__l.__size_ = 0;
      v25->__r_.__value_.__r.__words[2] = 0;
      v25->__r_.__value_.__r.__words[0] = 0;
      __int16 v22 = " is non-null terminated";
    }
    else
    {
      sub_1CD6D0838(a1, a2, (char *)&v31);
      std::string::size_type v20 = std::string::insert(&v31, 0, "SHT_STRTAB string table section ");
      std::string::size_type v21 = v20->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v21;
      v20->__r_.__value_.__l.__size_ = 0;
      v20->__r_.__value_.__r.__words[2] = 0;
      v20->__r_.__value_.__r.__words[0] = 0;
      __int16 v22 = " is empty";
    }
    uint64_t v23 = std::string::append(&__p, v22);
    std::string::size_type v24 = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)__int16 v27 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    std::string::size_type v28 = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    __int16 v34 = 260;
    v33[0] = v27;
    operator new();
  }
  p_p = 0;
  *(unsigned char *)(a5 + 16) |= 1u;
  *(void *)a5 = v8;
LABEL_16:
  if (v38)
  {
    uint64_t v19 = (uint64_t)p_p;
    p_p = 0;
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
    }
  }
}

void sub_1CD6D0838(void *a1@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::sections(a1, (uint64_t)&v13);
  if (v14)
  {
    uint64_t v9 = v13;
    std::string::size_type v13 = 0;
    uint64_t v10 = v9;
    sub_1CD4515D0(&v10);
    if (v10) {
      (*(void (**)(void *))(*v10 + 8))(v10);
    }
    a3[23] = 15;
    strcpy(a3, "[unknown index]");
  }
  else
  {
    std::to_string(&v11, (a2 - (uint64_t)v13) >> 6);
    unsigned int v5 = std::string::insert(&v11, 0, "[index ");
    std::string::size_type v6 = v5->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v12.__r_.__value_.__l.__data_ = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
    v12.__r_.__value_.__r.__words[2] = v6;
    v5->__r_.__value_.__l.__size_ = 0;
    v5->__r_.__value_.__r.__words[2] = 0;
    v5->__r_.__value_.__r.__words[0] = 0;
    long long v7 = std::string::append(&v12, "]");
    *(std::string *)a3 = *v7;
    v7->__r_.__value_.__r.__words[0] = 0;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v12.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v11.__r_.__value_.__l.__data_);
    }
  }
  if (v14)
  {
    uint64_t v8 = v13;
    std::string::size_type v13 = 0;
    if (v8) {
      (*(void (**)(void *))(*v8 + 8))(v8);
    }
  }
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSectionContents@<X0>(void *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3 = result;
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 32);
  uint64_t v44 = v5;
  uint64_t v45 = v6;
  if (__CFADD__(v6, v5))
  {
    sub_1CD6D0838(result, a2, (char *)&v19);
    uint64_t v8 = std::string::insert(&v19, 0, "section ");
    std::string::size_type v9 = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v21.__r_.__value_.__l.__data_ = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v21.__r_.__value_.__r.__words[2] = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    uint64_t v10 = std::string::append(&v21, " has a sh_offset (0x");
    std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
    long long __p = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    std::string::size_type v24 = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    __int16 v39 = 260;
    v38[0] = (uint64_t)&__p;
    v36[0] = (uint64_t)&v45;
    void v36[2] = 0;
    __int16 v37 = 270;
    sub_1CB8F1E58(v38, v36, (uint64_t)v40);
    v34[0] = (uint64_t)") + sh_size (0x";
    __int16 v35 = 259;
    sub_1CB8F1E58(v40, v34, (uint64_t)v41);
    v31[0] = (uint64_t)&v44;
    uint64_t v32 = 0;
    __int16 v33 = 270;
    sub_1CB8F1E58(v41, v31, (uint64_t)v42);
    v29[0] = (uint64_t)") that cannot be represented";
    __int16 v30 = 259;
    sub_1CB8F1E58(v42, v29, (uint64_t)v43);
    operator new();
  }
  if ((unint64_t)(v5 + v6) > result[1])
  {
    sub_1CD6D0838(result, a2, (char *)&v26);
    std::string v12 = std::string::insert(&v26, 0, "section ");
    std::string::size_type v13 = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v27.__r_.__value_.__l.__data_ = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v27.__r_.__value_.__r.__words[2] = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    char v14 = std::string::append(&v27, " has a sh_offset (0x");
    uint64_t v15 = (void *)v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string::size_type v28 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v28[2] = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    __int16 v35 = 260;
    v34[0] = (uint64_t)v28;
    v31[0] = (uint64_t)&v45;
    uint64_t v32 = 0;
    __int16 v33 = 270;
    sub_1CB8F1E58(v34, v31, (uint64_t)v36);
    v29[0] = (uint64_t)") + sh_size (0x";
    __int16 v30 = 259;
    sub_1CB8F1E58(v36, v29, (uint64_t)v38);
    *(void *)&long long __p = &v44;
    std::string::size_type v24 = 0;
    __int16 v25 = 270;
    sub_1CB8F1E58(v38, (uint64_t *)&__p, (uint64_t)v40);
    v21.__r_.__value_.__r.__words[0] = (std::string::size_type)") that is greater than the file size (0x";
    __int16 v22 = 259;
    sub_1CB8F1E58(v40, (uint64_t *)&v21, (uint64_t)v41);
    uint64_t v18 = v3[1];
    v19.__r_.__value_.__r.__words[0] = (std::string::size_type)&v18;
    v19.__r_.__value_.__r.__words[2] = 0;
    __int16 v20 = 270;
    sub_1CB8F1E58(v41, (uint64_t *)&v19, (uint64_t)v42);
    __int16 v16 = ")";
    __int16 v17 = 259;
    sub_1CB8F1E58(v42, (uint64_t *)&v16, (uint64_t)v43);
    operator new();
  }
  uint64_t v7 = *result + v6;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v5;
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::sections@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *result;
  unint64_t v4 = *(void *)(*result + 40);
  unint64_t v32 = v4;
  if (!v4)
  {
    *(unsigned char *)(a2 + 16) &= ~1u;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    return result;
  }
  int v5 = *(unsigned __int16 *)(v3 + 58);
  if (v5 != 64)
  {
    v28[0] = (uint64_t)"invalid e_shentsize in ELF header: ";
    __int16 v29 = 259;
    __int16 v27 = 265;
    LODWORD(v26[0]) = v5;
    goto LABEL_11;
  }
  unint64_t v6 = result[1];
  if (v4 > 0xFFFFFFFFFFFFFFBFLL || v4 + 64 > v6)
  {
    v28[0] = (uint64_t)"section header table goes past the end of the file: e_shoff = 0x";
    __int16 v29 = 259;
    v26[0] = (uint64_t)&v32;
    void v26[2] = 0;
    __int16 v27 = 270;
LABEL_11:
    uint64_t v8 = v26;
LABEL_12:
    sub_1CB8F1E58(v28, v8, (uint64_t)&v30);
    goto LABEL_13;
  }
  uint64_t v9 = v3 + v4;
  unint64_t v10 = *(unsigned __int16 *)(v3 + 60);
  unint64_t v25 = v10;
  if (!v10)
  {
    unint64_t v10 = *(void *)(v9 + 32);
    unint64_t v25 = v10;
    if (v10 >> 58)
    {
      v26[0] = (uint64_t)"invalid number of sections specified in the NULL section's sh_size field (";
      __int16 v27 = 259;
      __int16 v24 = 268;
      v23[0] = (uint64_t)&v25;
      sub_1CB8F1E58(v26, v23, (uint64_t)v28);
      v21[0] = (uint64_t)")";
      __int16 v22 = 259;
      uint64_t v8 = v21;
      goto LABEL_12;
    }
  }
  BOOL v11 = __CFADD__(v4, v10 << 6);
  unint64_t v12 = v4 + (v10 << 6);
  if (v11)
  {
    v21[0] = (uint64_t)"invalid section header table offset (e_shoff = 0x";
    __int16 v22 = 259;
    v19[0] = (uint64_t)&v32;
    _OWORD v19[2] = 0;
    __int16 v20 = 270;
    sub_1CB8F1E58(v21, v19, (uint64_t)v23);
    __int16 v17 = ") or invalid number of sections specified in the first section header's sh_size field (0x";
    __int16 v18 = 259;
    sub_1CB8F1E58(v23, (uint64_t *)&v17, (uint64_t)v26);
    v15[0] = (uint64_t)&v25;
    uint64_t v15[2] = 0;
    __int16 v16 = 270;
    sub_1CB8F1E58(v26, v15, (uint64_t)v28);
    std::string::size_type v13 = ")";
    __int16 v14 = 259;
    uint64_t v8 = (uint64_t *)&v13;
    goto LABEL_12;
  }
  if (v12 > v6)
  {
    __int16 v30 = "section table goes past the end of file";
    __int16 v31 = 259;
LABEL_13:
    operator new();
  }
  *(unsigned char *)(a2 + 16) &= ~1u;
  *(void *)a2 = v9;
  *(void *)(a2 + 8) = v10;
  return result;
}

uint64_t sub_1CD6D1030@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  if (a2 <= a3)
  {
    unint64_t v6 = "invalid section index: ";
    __int16 v7 = 259;
    __int16 v5 = 264;
    LODWORD(v4[0]) = a3;
    sub_1CB8F1E58((uint64_t *)&v6, v4, (uint64_t)v8);
    operator new();
  }
  *(unsigned char *)(a4 + 8) &= ~1u;
  *(void *)a4 = result + ((unint64_t)a3 << 6);
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSection@<X0>(void *a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t result = (uint64_t)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::sections(a1, (uint64_t)v7);
  if (v8)
  {
    uint64_t v6 = v7[0];
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v6;
  }
  else
  {
    uint64_t result = sub_1CD6D1030(v7[0], v7[1], a2, a3);
    if (v8)
    {
      uint64_t result = v7[0];
      v7[0] = 0;
      if (result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
    }
  }
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSHNDXTable@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t result = (uint64_t)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::sections(a1, (uint64_t)v8);
  if (v9)
  {
    uint64_t v7 = v8[0];
    *(unsigned char *)(a3 + 16) |= 1u;
    *(void *)a3 = v7;
  }
  else
  {
    uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSHNDXTable(a1, a2, v8[0], v8[1], a3);
    if (v9)
    {
      uint64_t result = v8[0];
      v8[0] = 0;
      if (result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
    }
  }
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSHNDXTable@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t result = (uint64_t)sub_1CD6D1574(a1, (void *)a2, (uint64_t)v36);
  uint64_t v11 = v36[0];
  if (v37)
  {
    *(unsigned char *)(a5 + 16) |= 1u;
    *(void *)a5 = v11;
    return result;
  }
  uint64_t v12 = v36[1];
  uint64_t result = sub_1CD6D1030(a3, a4, *(_DWORD *)(a2 + 40), (uint64_t)&v34);
  uint64_t v13 = v34;
  if (v35)
  {
    uint64_t v34 = 0;
    *(unsigned char *)(a5 + 16) |= 1u;
    *(void *)a5 = v13;
  }
  else
  {
    int v14 = *(_DWORD *)(v34 + 4);
    if (v14 != 2 && v14 != 11)
    {
      ELFSectionTypeName = llvm::object::getELFSectionTypeName((llvm::object *)*(unsigned __int16 *)(*a1 + 18), v14);
      __int16 v32 = 1283;
      v31[0] = (uint64_t)"SHT_SYMTAB_SHNDX section is linked with ";
      uint64_t v31[2] = (uint64_t)ELFSectionTypeName;
      void v31[3] = v17;
      v29[0] = (uint64_t)" section (expected SHT_SYMTAB/SHT_DYNSYM)";
      __int16 v30 = 259;
      __int16 v18 = v29;
      goto LABEL_14;
    }
    unint64_t v28 = *(void *)(v34 + 32) / 0x18uLL;
    if (v12 != v28)
    {
      std::string v26 = "SHT_SYMTAB_SHNDX has ";
      __int16 v27 = 259;
      __int16 v25 = 266;
      uint64_t v23 = v12;
      v24[0] = (uint64_t)&v23;
      sub_1CB8F1E58((uint64_t *)&v26, v24, (uint64_t)v29);
      std::string v21 = " entries, but the symbol table associated has ";
      __int16 v22 = 259;
      sub_1CB8F1E58(v29, (uint64_t *)&v21, (uint64_t)v31);
      __int16 v20 = 268;
      std::string v19 = &v28;
      __int16 v18 = (uint64_t *)&v19;
LABEL_14:
      sub_1CB8F1E58(v31, v18, (uint64_t)v33);
      operator new();
    }
    *(unsigned char *)(a5 + 16) &= ~1u;
    *(void *)(a5 + 8) = v12;
    *(void *)a5 = v11;
  }
  if (v35)
  {
    uint64_t result = v34;
    uint64_t v34 = 0;
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  if (v37)
  {
    uint64_t result = v36[0];
    v36[0] = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  return result;
}

void *sub_1CD6D1574@<X0>(void *result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v4 = result;
  if (a2[7] != 4)
  {
    sub_1CD6D0838(result, (uint64_t)a2, (char *)&v32);
    char v9 = std::string::insert(&v32, 0, "section ");
    std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v37.__r_.__value_.__l.__data_ = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v37.__r_.__value_.__r.__words[2] = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    uint64_t v11 = std::string::append(&v37, " has invalid sh_entsize: expected ");
    std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
    long long __p = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    std::string::size_type v40 = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    __int16 v51 = 260;
    v50[0] = (uint64_t)&__p;
    v30.__r_.__value_.__r.__words[0] = 4;
    __int16 v49 = 266;
    v48[0] = (uint64_t)&v30;
    sub_1CB8F1E58(v50, v48, (uint64_t)v52);
    v46[0] = (uint64_t)", but got ";
    __int16 v47 = 259;
    sub_1CB8F1E58(v52, v46, (uint64_t)v53);
    v28.__r_.__value_.__r.__words[0] = a2[7];
    __int16 v45 = 268;
    v44[0] = (uint64_t)&v28;
    sub_1CB8F1E58(v53, v44, (uint64_t)v54);
    operator new();
  }
  uint64_t v6 = a2[3];
  unint64_t v7 = a2[4];
  unint64_t v42 = v7;
  uint64_t v43 = v6;
  if ((v7 & 3) != 0)
  {
    sub_1CD6D0838(result, (uint64_t)a2, (char *)&v28);
    uint64_t v13 = std::string::insert(&v28, 0, "section ");
    std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    uint64_t v15 = std::string::append(&v30, " has an invalid sh_size (");
    std::string::size_type v16 = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    __int16 v49 = 260;
    v48[0] = (uint64_t)&v32;
    __int16 v47 = 268;
    v46[0] = (uint64_t)&v42;
    sub_1CB8F1E58(v48, v46, (uint64_t)v50);
    v44[0] = (uint64_t)") which is not a multiple of its sh_entsize (";
    __int16 v45 = 259;
    sub_1CB8F1E58(v50, v44, (uint64_t)v52);
    v25[0] = a2[7];
    __int16 v41 = 268;
    *(void *)&long long __p = v25;
    sub_1CB8F1E58(v52, (uint64_t *)&__p, (uint64_t)v53);
    v37.__r_.__value_.__r.__words[0] = (std::string::size_type)")";
    __int16 v38 = 259;
    goto LABEL_9;
  }
  if (__CFADD__(v6, v7))
  {
    sub_1CD6D0838(result, (uint64_t)a2, (char *)&v28);
    uint64_t v17 = std::string::insert(&v28, 0, "section ");
    std::string::size_type v18 = v17->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v18;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v17->__r_.__value_.__r.__words[0] = 0;
    std::string v19 = std::string::append(&v30, " has a sh_offset (0x");
    std::string::size_type v20 = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    __int16 v49 = 260;
    v48[0] = (uint64_t)&v32;
    v46[0] = (uint64_t)&v43;
    _OWORD v46[2] = 0;
    __int16 v47 = 270;
    sub_1CB8F1E58(v48, v46, (uint64_t)v50);
    v44[0] = (uint64_t)") + sh_size (0x";
    __int16 v45 = 259;
    sub_1CB8F1E58(v50, v44, (uint64_t)v52);
    *(void *)&long long __p = &v42;
    std::string::size_type v40 = 0;
    __int16 v41 = 270;
    sub_1CB8F1E58(v52, (uint64_t *)&__p, (uint64_t)v53);
    v37.__r_.__value_.__r.__words[0] = (std::string::size_type)") that cannot be represented";
    __int16 v38 = 259;
LABEL_9:
    sub_1CB8F1E58(v53, (uint64_t *)&v37, (uint64_t)v54);
    operator new();
  }
  if (v7 + v6 > result[1])
  {
    sub_1CD6D0838(result, (uint64_t)a2, (char *)&v34);
    std::string v21 = std::string::insert(&v34, 0, "section ");
    std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    uint64_t v23 = std::string::append(&v35, " has a sh_offset (0x");
    __int16 v24 = (void *)v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)__int16 v36 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    void v36[2] = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    __int16 v45 = 260;
    v44[0] = (uint64_t)v36;
    *(void *)&long long __p = &v43;
    std::string::size_type v40 = 0;
    __int16 v41 = 270;
    sub_1CB8F1E58(v44, (uint64_t *)&__p, (uint64_t)v46);
    v37.__r_.__value_.__r.__words[0] = (std::string::size_type)") + sh_size (0x";
    __int16 v38 = 259;
    sub_1CB8F1E58(v46, (uint64_t *)&v37, (uint64_t)v48);
    v32.__r_.__value_.__r.__words[0] = (std::string::size_type)&v42;
    v32.__r_.__value_.__r.__words[2] = 0;
    __int16 v33 = 270;
    sub_1CB8F1E58(v48, (uint64_t *)&v32, (uint64_t)v50);
    v30.__r_.__value_.__r.__words[0] = (std::string::size_type)") that is greater than the file size (0x";
    __int16 v31 = 259;
    sub_1CB8F1E58(v50, (uint64_t *)&v30, (uint64_t)v52);
    uint64_t v27 = v4[1];
    v28.__r_.__value_.__r.__words[0] = (std::string::size_type)&v27;
    v28.__r_.__value_.__r.__words[2] = 0;
    __int16 v29 = 270;
    sub_1CB8F1E58(v52, (uint64_t *)&v28, (uint64_t)v53);
    v25[0] = (uint64_t)")";
    __int16 v26 = 259;
    sub_1CB8F1E58(v53, v25, (uint64_t)v54);
    operator new();
  }
  uint64_t v8 = *result + v6;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v8;
  *(void *)(a3 + 8) = v7 >> 2;
  return result;
}

void *sub_1CD6D1BF4@<X0>(void *a1@<X0>, void *a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::relas(a1, a2, (uint64_t)v26);
  if (v27)
  {
    uint64_t v8 = v26[0];
    char v9 = *(unsigned char *)(a4 + 8) | 1;
  }
  else
  {
    if (v26[1] <= (unint64_t)a3)
    {
      std::string::size_type v20 = "can't read an entry at 0x";
      __int16 v21 = 259;
      uint64_t v17 = 24 * a3;
      v18[0] = (uint64_t)&v17;
      void v18[2] = 0;
      __int16 v19 = 270;
      sub_1CB8F1E58((uint64_t *)&v20, v18, (uint64_t)v22);
      uint64_t v15 = ": it goes past the end of the section (0x";
      __int16 v16 = 259;
      sub_1CB8F1E58(v22, (uint64_t *)&v15, (uint64_t)v23);
      uint64_t v12 = a2[4];
      v13[0] = (uint64_t)&v12;
      void v13[2] = 0;
      __int16 v14 = 270;
      sub_1CB8F1E58(v23, v13, (uint64_t)v24);
      std::string::size_type v10 = ")";
      __int16 v11 = 259;
      sub_1CB8F1E58(v24, (uint64_t *)&v10, (uint64_t)v25);
      operator new();
    }
    uint64_t v8 = v26[0] + 24 * a3;
    char v9 = *(unsigned char *)(a4 + 8) & 0xFE;
  }
  *(unsigned char *)(a4 + 8) = v9;
  *(void *)a4 = v8;
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::create@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2 <= 0x3F)
  {
    uint64_t v13 = "invalid buffer: the size (";
    __int16 v14 = 259;
    __int16 v12 = 266;
    unint64_t v10 = a2;
    __int16 v11 = &v10;
    sub_1CB8F1E58((uint64_t *)&v13, (uint64_t *)&v11, (uint64_t)v15);
    uint64_t v8 = ") is smaller than an ELF header (";
    __int16 v9 = 259;
    sub_1CB8F1E58(v15, (uint64_t *)&v8, (uint64_t)v16);
    uint64_t v5 = 64;
    __int16 v7 = 266;
    uint64_t v6 = &v5;
    sub_1CB8F1E58(v16, (uint64_t *)&v6, (uint64_t)v17);
    uint64_t v3 = ")";
    __int16 v4 = 259;
    sub_1CB8F1E58(v17, (uint64_t *)&v3, (uint64_t)v18);
    operator new();
  }
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)(a3 + 8) = a2;
  *(void *)a3 = result;
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::relas@<X0>(void *result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  __int16 v4 = result;
  if (a2[7] != 24)
  {
    sub_1CD6D0838(result, (uint64_t)a2, (char *)&v32);
    __int16 v9 = std::string::insert(&v32, 0, "section ");
    std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v37.__r_.__value_.__l.__data_ = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v37.__r_.__value_.__r.__words[2] = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    __int16 v11 = std::string::append(&v37, " has invalid sh_entsize: expected ");
    std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
    long long __p = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    std::string::size_type v40 = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    __int16 v51 = 260;
    v50[0] = (uint64_t)&__p;
    v30.__r_.__value_.__r.__words[0] = 24;
    __int16 v49 = 266;
    v48[0] = (uint64_t)&v30;
    sub_1CB8F1E58(v50, v48, (uint64_t)v52);
    v46[0] = (uint64_t)", but got ";
    __int16 v47 = 259;
    sub_1CB8F1E58(v52, v46, (uint64_t)v53);
    v28.__r_.__value_.__r.__words[0] = a2[7];
    __int16 v45 = 268;
    v44[0] = (uint64_t)&v28;
    sub_1CB8F1E58(v53, v44, (uint64_t)v54);
    operator new();
  }
  uint64_t v6 = a2[3];
  unint64_t v7 = a2[4];
  unint64_t v42 = v7;
  uint64_t v43 = v6;
  if (v7 % 0x18)
  {
    sub_1CD6D0838(result, (uint64_t)a2, (char *)&v28);
    uint64_t v13 = std::string::insert(&v28, 0, "section ");
    std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    uint64_t v15 = std::string::append(&v30, " has an invalid sh_size (");
    std::string::size_type v16 = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    __int16 v49 = 260;
    v48[0] = (uint64_t)&v32;
    __int16 v47 = 268;
    v46[0] = (uint64_t)&v42;
    sub_1CB8F1E58(v48, v46, (uint64_t)v50);
    v44[0] = (uint64_t)") which is not a multiple of its sh_entsize (";
    __int16 v45 = 259;
    sub_1CB8F1E58(v50, v44, (uint64_t)v52);
    v25[0] = a2[7];
    __int16 v41 = 268;
    *(void *)&long long __p = v25;
    sub_1CB8F1E58(v52, (uint64_t *)&__p, (uint64_t)v53);
    v37.__r_.__value_.__r.__words[0] = (std::string::size_type)")";
    __int16 v38 = 259;
    goto LABEL_9;
  }
  if (__CFADD__(v6, v7))
  {
    sub_1CD6D0838(result, (uint64_t)a2, (char *)&v28);
    uint64_t v17 = std::string::insert(&v28, 0, "section ");
    std::string::size_type v18 = v17->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v18;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v17->__r_.__value_.__r.__words[0] = 0;
    __int16 v19 = std::string::append(&v30, " has a sh_offset (0x");
    std::string::size_type v20 = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    __int16 v49 = 260;
    v48[0] = (uint64_t)&v32;
    v46[0] = (uint64_t)&v43;
    _OWORD v46[2] = 0;
    __int16 v47 = 270;
    sub_1CB8F1E58(v48, v46, (uint64_t)v50);
    v44[0] = (uint64_t)") + sh_size (0x";
    __int16 v45 = 259;
    sub_1CB8F1E58(v50, v44, (uint64_t)v52);
    *(void *)&long long __p = &v42;
    std::string::size_type v40 = 0;
    __int16 v41 = 270;
    sub_1CB8F1E58(v52, (uint64_t *)&__p, (uint64_t)v53);
    v37.__r_.__value_.__r.__words[0] = (std::string::size_type)") that cannot be represented";
    __int16 v38 = 259;
LABEL_9:
    sub_1CB8F1E58(v53, (uint64_t *)&v37, (uint64_t)v54);
    operator new();
  }
  if (v7 + v6 > result[1])
  {
    sub_1CD6D0838(result, (uint64_t)a2, (char *)&v34);
    __int16 v21 = std::string::insert(&v34, 0, "section ");
    std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    uint64_t v23 = std::string::append(&v35, " has a sh_offset (0x");
    __int16 v24 = (void *)v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)__int16 v36 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    void v36[2] = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    __int16 v45 = 260;
    v44[0] = (uint64_t)v36;
    *(void *)&long long __p = &v43;
    std::string::size_type v40 = 0;
    __int16 v41 = 270;
    sub_1CB8F1E58(v44, (uint64_t *)&__p, (uint64_t)v46);
    v37.__r_.__value_.__r.__words[0] = (std::string::size_type)") + sh_size (0x";
    __int16 v38 = 259;
    sub_1CB8F1E58(v46, (uint64_t *)&v37, (uint64_t)v48);
    v32.__r_.__value_.__r.__words[0] = (std::string::size_type)&v42;
    v32.__r_.__value_.__r.__words[2] = 0;
    __int16 v33 = 270;
    sub_1CB8F1E58(v48, (uint64_t *)&v32, (uint64_t)v50);
    v30.__r_.__value_.__r.__words[0] = (std::string::size_type)") that is greater than the file size (0x";
    __int16 v31 = 259;
    sub_1CB8F1E58(v50, (uint64_t *)&v30, (uint64_t)v52);
    uint64_t v27 = v4[1];
    v28.__r_.__value_.__r.__words[0] = (std::string::size_type)&v27;
    v28.__r_.__value_.__r.__words[2] = 0;
    __int16 v29 = 270;
    sub_1CB8F1E58(v52, (uint64_t *)&v28, (uint64_t)v53);
    v25[0] = (uint64_t)")";
    __int16 v26 = 259;
    sub_1CB8F1E58(v53, v25, (uint64_t)v54);
    operator new();
  }
  uint64_t v8 = *result + v6;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v8;
  *(void *)(a3 + 8) = v7 / 0x18;
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::rels@<X0>(void *result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  __int16 v4 = result;
  if (a2[7] != 16)
  {
    sub_1CD6D0838(result, (uint64_t)a2, (char *)&v32);
    __int16 v9 = std::string::insert(&v32, 0, "section ");
    std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v37.__r_.__value_.__l.__data_ = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v37.__r_.__value_.__r.__words[2] = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    __int16 v11 = std::string::append(&v37, " has invalid sh_entsize: expected ");
    std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
    long long __p = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    std::string::size_type v40 = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    __int16 v51 = 260;
    v50[0] = (uint64_t)&__p;
    v30.__r_.__value_.__r.__words[0] = 16;
    __int16 v49 = 266;
    v48[0] = (uint64_t)&v30;
    sub_1CB8F1E58(v50, v48, (uint64_t)v52);
    v46[0] = (uint64_t)", but got ";
    __int16 v47 = 259;
    sub_1CB8F1E58(v52, v46, (uint64_t)v53);
    v28.__r_.__value_.__r.__words[0] = a2[7];
    __int16 v45 = 268;
    v44[0] = (uint64_t)&v28;
    sub_1CB8F1E58(v53, v44, (uint64_t)v54);
    operator new();
  }
  uint64_t v6 = a2[3];
  unint64_t v7 = a2[4];
  unint64_t v42 = v7;
  uint64_t v43 = v6;
  if ((v7 & 0xF) != 0)
  {
    sub_1CD6D0838(result, (uint64_t)a2, (char *)&v28);
    uint64_t v13 = std::string::insert(&v28, 0, "section ");
    std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    uint64_t v15 = std::string::append(&v30, " has an invalid sh_size (");
    std::string::size_type v16 = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    __int16 v49 = 260;
    v48[0] = (uint64_t)&v32;
    __int16 v47 = 268;
    v46[0] = (uint64_t)&v42;
    sub_1CB8F1E58(v48, v46, (uint64_t)v50);
    v44[0] = (uint64_t)") which is not a multiple of its sh_entsize (";
    __int16 v45 = 259;
    sub_1CB8F1E58(v50, v44, (uint64_t)v52);
    v25[0] = a2[7];
    __int16 v41 = 268;
    *(void *)&long long __p = v25;
    sub_1CB8F1E58(v52, (uint64_t *)&__p, (uint64_t)v53);
    v37.__r_.__value_.__r.__words[0] = (std::string::size_type)")";
    __int16 v38 = 259;
    goto LABEL_9;
  }
  if (__CFADD__(v6, v7))
  {
    sub_1CD6D0838(result, (uint64_t)a2, (char *)&v28);
    uint64_t v17 = std::string::insert(&v28, 0, "section ");
    std::string::size_type v18 = v17->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v18;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v17->__r_.__value_.__r.__words[0] = 0;
    __int16 v19 = std::string::append(&v30, " has a sh_offset (0x");
    std::string::size_type v20 = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    __int16 v49 = 260;
    v48[0] = (uint64_t)&v32;
    v46[0] = (uint64_t)&v43;
    _OWORD v46[2] = 0;
    __int16 v47 = 270;
    sub_1CB8F1E58(v48, v46, (uint64_t)v50);
    v44[0] = (uint64_t)") + sh_size (0x";
    __int16 v45 = 259;
    sub_1CB8F1E58(v50, v44, (uint64_t)v52);
    *(void *)&long long __p = &v42;
    std::string::size_type v40 = 0;
    __int16 v41 = 270;
    sub_1CB8F1E58(v52, (uint64_t *)&__p, (uint64_t)v53);
    v37.__r_.__value_.__r.__words[0] = (std::string::size_type)") that cannot be represented";
    __int16 v38 = 259;
LABEL_9:
    sub_1CB8F1E58(v53, (uint64_t *)&v37, (uint64_t)v54);
    operator new();
  }
  if (v7 + v6 > result[1])
  {
    sub_1CD6D0838(result, (uint64_t)a2, (char *)&v34);
    __int16 v21 = std::string::insert(&v34, 0, "section ");
    std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    uint64_t v23 = std::string::append(&v35, " has a sh_offset (0x");
    __int16 v24 = (void *)v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)__int16 v36 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    void v36[2] = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    __int16 v45 = 260;
    v44[0] = (uint64_t)v36;
    *(void *)&long long __p = &v43;
    std::string::size_type v40 = 0;
    __int16 v41 = 270;
    sub_1CB8F1E58(v44, (uint64_t *)&__p, (uint64_t)v46);
    v37.__r_.__value_.__r.__words[0] = (std::string::size_type)") + sh_size (0x";
    __int16 v38 = 259;
    sub_1CB8F1E58(v46, (uint64_t *)&v37, (uint64_t)v48);
    v32.__r_.__value_.__r.__words[0] = (std::string::size_type)&v42;
    v32.__r_.__value_.__r.__words[2] = 0;
    __int16 v33 = 270;
    sub_1CB8F1E58(v48, (uint64_t *)&v32, (uint64_t)v50);
    v30.__r_.__value_.__r.__words[0] = (std::string::size_type)") that is greater than the file size (0x";
    __int16 v31 = 259;
    sub_1CB8F1E58(v50, (uint64_t *)&v30, (uint64_t)v52);
    uint64_t v27 = v4[1];
    v28.__r_.__value_.__r.__words[0] = (std::string::size_type)&v27;
    v28.__r_.__value_.__r.__words[2] = 0;
    __int16 v29 = 270;
    sub_1CB8F1E58(v52, (uint64_t *)&v28, (uint64_t)v53);
    v25[0] = (uint64_t)")";
    __int16 v26 = 259;
    sub_1CB8F1E58(v53, v25, (uint64_t)v54);
    operator new();
  }
  uint64_t v8 = *result + v6;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v8;
  *(void *)(a3 + 8) = v7 >> 4;
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSectionStringTable(void *a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, void (*a4)(uint64_t *__return_ptr, uint64_t, void *)@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  unsigned int v7 = *(unsigned __int16 *)(*a1 + 62);
  if (v7 == 0xFFFF)
  {
    if (!a3)
    {
      std::string::size_type v16 = "e_shstrndx == SHN_XINDEX, but the section header table is empty";
      __int16 v17 = 259;
LABEL_5:
      operator new();
    }
    unsigned int v7 = *(_DWORD *)(a2 + 40);
  }
  if (v7)
  {
    if (a3 <= v7)
    {
      uint64_t v13 = "section header string table index ";
      __int16 v14 = 259;
      __int16 v12 = 264;
      LODWORD(v11[0]) = v7;
      sub_1CB8F1E58((uint64_t *)&v13, v11, (uint64_t)v15);
      __int16 v9 = " does not exist";
      __int16 v10 = 259;
      sub_1CB8F1E58(v15, (uint64_t *)&v9, (uint64_t)&v16);
      goto LABEL_5;
    }
    uint64_t v8 = a2 + ((unint64_t)v7 << 6);
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getStringTable(a1, v8, a4, a5, a6);
  }
  else
  {
    *(unsigned char *)(a6 + 16) &= ~1u;
    *(void *)a6 = "";
    *(void *)(a6 + 8) = 0;
  }
}

uint64_t *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSectionIndex@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, _OWORD *a3@<X4>, uint64_t a4@<X8>)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  int v5 = *(unsigned __int16 *)(a1 + 6);
  if (v5 == 0xFFFF)
  {
    long long v6 = a3[1];
    v9[0] = *a3;
    v9[1] = v6;
    uint64_t result = sub_1CD6CC798(-1431655765 * ((unint64_t)(a1 - a2) >> 3), (uint64_t *)v9, (uint64_t)&v10);
    if (v11)
    {
      uint64_t v8 = v10;
      *(unsigned char *)(a4 + 8) |= 1u;
      *(void *)a4 = v8;
      return result;
    }
    *(unsigned char *)(a4 + 8) &= ~1u;
    int v5 = v10;
  }
  else
  {
    *(unsigned char *)(a4 + 8) &= ~1u;
    if ((unsigned __int16)(v5 + 256) <= 0x100u)
    {
      *(_DWORD *)a4 = 0;
      return result;
    }
  }
  *(_DWORD *)a4 = v5;
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSection@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, _OWORD *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a3)
  {
    v13[0] = 0;
    v13[1] = 0;
    char v14 = 0;
    goto LABEL_3;
  }
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::relas(a1, a3, (uint64_t)v13);
  if ((v14 & 1) == 0)
  {
    a3 = (void *)v13[0];
LABEL_3:
    long long v9 = a4[1];
    v12[0] = *a4;
    v12[1] = v9;
    uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSection(a1, a2, (uint64_t)a3, v12, a5);
    if ((v14 & 1) == 0) {
      return result;
    }
    goto LABEL_7;
  }
  uint64_t v11 = v13[0];
  v13[0] = 0;
  *(unsigned char *)(a5 + 8) |= 1u;
  *(void *)a5 = v11;
LABEL_7:
  uint64_t result = v13[0];
  v13[0] = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSection@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _OWORD *a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  long long v7 = a4[1];
  v10[0] = *a4;
  v10[1] = v7;
  uint64_t result = (uint64_t)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSectionIndex(a2, a3, v10, (uint64_t)&v11);
  if (v12)
  {
    uint64_t v9 = v11;
    *(unsigned char *)(a5 + 8) |= 1u;
    *(void *)a5 = v9;
  }
  else if (v11)
  {
    uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSection(a1, v11, a5);
    if (v12)
    {
      uint64_t result = v11;
      uint64_t v11 = 0;
      if (result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
    }
  }
  else
  {
    *(unsigned char *)(a5 + 8) &= ~1u;
    *(void *)a5 = 0;
  }
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSectionName(void *a1@<X0>, unsigned int *a2@<X1>, void (*a3)(uint64_t *__return_ptr, uint64_t, void *)@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::sections(a1, (uint64_t)v16);
  if (v17)
  {
    uint64_t v10 = v16[0];
    *(unsigned char *)(a5 + 16) |= 1u;
    *(void *)a5 = v10;
  }
  else
  {
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSectionStringTable(a1, v16[0], v16[1], a3, a4, (uint64_t)v14);
    if (v15)
    {
      uint64_t v11 = v14[0];
      *(unsigned char *)(a5 + 16) |= 1u;
      *(void *)a5 = v11;
    }
    else
    {
      llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSectionName(a1, a2, v14[0], v14[1], a5);
      if (v15)
      {
        uint64_t v13 = v14[0];
        v14[0] = 0;
        if (v13) {
          (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
        }
      }
    }
    if (v17)
    {
      uint64_t v12 = v16[0];
      v16[0] = 0;
      if (v12) {
        (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
      }
    }
  }
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSectionName@<X0>(void *result@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v6 = *a2;
  if (v6)
  {
    if (a4 <= v6)
    {
      sub_1CD6D0838(result, (uint64_t)a2, (char *)&v17);
      uint64_t v8 = std::string::insert(&v17, 0, "a section ");
      std::string::size_type v9 = v8->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v18.__r_.__value_.__l.__data_ = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      v18.__r_.__value_.__r.__words[2] = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      uint64_t v10 = std::string::append(&v18, " has an invalid sh_name (0x");
      std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
      *(_OWORD *)long long __p = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
      std::string::size_type v20 = v11;
      v10->__r_.__value_.__l.__size_ = 0;
      v10->__r_.__value_.__r.__words[2] = 0;
      v10->__r_.__value_.__r.__words[0] = 0;
      __int16 v22 = 260;
      __int16 v21 = __p;
      unint64_t v14 = v6;
      v15[0] = (uint64_t)&v14;
      uint64_t v15[2] = 0;
      __int16 v16 = 270;
      sub_1CB8F1E58((uint64_t *)&v21, v15, (uint64_t)v23);
      uint64_t v12 = ") offset which goes past the end of the section name string table";
      __int16 v13 = 259;
      sub_1CB8F1E58(v23, (uint64_t *)&v12, (uint64_t)v24);
      operator new();
    }
    long long v7 = (const char *)(a3 + v6);
    uint64_t result = (void *)strlen(v7);
    *(unsigned char *)(a5 + 16) &= ~1u;
    *(void *)a5 = v7;
    *(void *)(a5 + 8) = result;
  }
  else
  {
    *(unsigned char *)(a5 + 16) &= ~1u;
    *(void *)a5 = 0;
    *(void *)(a5 + 8) = 0;
  }
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getStringTable(void *a1@<X0>, uint64_t a2@<X1>, void (*a3)(uint64_t *__return_ptr, uint64_t, void *)@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a2 + 4) != 50331648)
  {
    sub_1CD6D3754(a1, a2, (char *)&v30);
    uint64_t v12 = std::string::insert(&v30, 0, "invalid sh_type for string table section ");
    std::string::size_type v13 = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    unint64_t v14 = std::string::append(&v31, ": expected SHT_STRTAB, but got ");
    std::string::size_type v15 = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    __int16 v39 = 260;
    p_p = &__p;
    ELFSectionTypeName = llvm::object::getELFSectionTypeName((llvm::object *)(bswap32(*(unsigned __int16 *)(*a1 + 18)) >> 16), bswap32(*(_DWORD *)(a2 + 4)));
    __int16 v29 = 261;
    v27[0] = (void *)ELFSectionTypeName;
    v27[1] = v17;
    sub_1CB8F1E58((uint64_t *)&p_p, (uint64_t *)v27, (uint64_t)v33);
    a3(&v35, a4, v33);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v31.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v30.__r_.__value_.__l.__data_);
    }
    uint64_t v18 = v35;
    if (v35)
    {
      *(unsigned char *)(a5 + 16) |= 1u;
      *(void *)a5 = v18;
      return;
    }
  }
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSectionContents(a1, a2, (uint64_t)&p_p);
  uint64_t v8 = (uint64_t)p_p;
  if ((v38 & 1) == 0)
  {
    uint64_t v9 = v37;
    if (v37)
    {
      if (!p_p->__r_.__value_.__s.__data_[v37 - 1])
      {
        *(unsigned char *)(a5 + 16) &= ~1u;
        *(void *)a5 = v8;
        *(void *)(a5 + 8) = v9;
        goto LABEL_16;
      }
      sub_1CD6D3754(a1, a2, (char *)&v31);
      __int16 v25 = std::string::insert(&v31, 0, "SHT_STRTAB string table section ");
      std::string::size_type v26 = v25->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v26;
      v25->__r_.__value_.__l.__size_ = 0;
      v25->__r_.__value_.__r.__words[2] = 0;
      v25->__r_.__value_.__r.__words[0] = 0;
      __int16 v22 = " is non-null terminated";
    }
    else
    {
      sub_1CD6D3754(a1, a2, (char *)&v31);
      std::string::size_type v20 = std::string::insert(&v31, 0, "SHT_STRTAB string table section ");
      std::string::size_type v21 = v20->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v21;
      v20->__r_.__value_.__l.__size_ = 0;
      v20->__r_.__value_.__r.__words[2] = 0;
      v20->__r_.__value_.__r.__words[0] = 0;
      __int16 v22 = " is empty";
    }
    uint64_t v23 = std::string::append(&__p, v22);
    std::string::size_type v24 = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)uint64_t v27 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    std::string::size_type v28 = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    __int16 v34 = 260;
    v33[0] = v27;
    operator new();
  }
  p_p = 0;
  *(unsigned char *)(a5 + 16) |= 1u;
  *(void *)a5 = v8;
LABEL_16:
  if (v38)
  {
    uint64_t v19 = (uint64_t)p_p;
    p_p = 0;
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
    }
  }
}

void sub_1CD6D3754(void *a1@<X0>, uint64_t a2@<X1>, char *a3@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::sections(a1, (uint64_t)&v13);
  if (v14)
  {
    uint64_t v9 = v13;
    std::string::size_type v13 = 0;
    uint64_t v10 = v9;
    sub_1CD4515D0(&v10);
    if (v10) {
      (*(void (**)(void *))(*v10 + 8))(v10);
    }
    a3[23] = 15;
    strcpy(a3, "[unknown index]");
  }
  else
  {
    std::to_string(&v11, (a2 - (uint64_t)v13) >> 6);
    int v5 = std::string::insert(&v11, 0, "[index ");
    std::string::size_type v6 = v5->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v12.__r_.__value_.__l.__data_ = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
    v12.__r_.__value_.__r.__words[2] = v6;
    v5->__r_.__value_.__l.__size_ = 0;
    v5->__r_.__value_.__r.__words[2] = 0;
    v5->__r_.__value_.__r.__words[0] = 0;
    long long v7 = std::string::append(&v12, "]");
    *(std::string *)a3 = *v7;
    v7->__r_.__value_.__r.__words[0] = 0;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v12.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v11.__r_.__value_.__l.__data_);
    }
  }
  if (v14)
  {
    uint64_t v8 = v13;
    std::string::size_type v13 = 0;
    if (v8) {
      (*(void (**)(void *))(*v8 + 8))(v8);
    }
  }
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSectionContents@<X0>(void *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = result;
  unint64_t v5 = bswap64(*(void *)(a2 + 24));
  unint64_t v6 = bswap64(*(void *)(a2 + 32));
  unint64_t v44 = v6;
  unint64_t v45 = v5;
  if (__CFADD__(v5, v6))
  {
    sub_1CD6D3754(result, a2, (char *)&v19);
    uint64_t v8 = std::string::insert(&v19, 0, "section ");
    std::string::size_type v9 = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v21.__r_.__value_.__l.__data_ = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v21.__r_.__value_.__r.__words[2] = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    uint64_t v10 = std::string::append(&v21, " has a sh_offset (0x");
    std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
    long long __p = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    std::string::size_type v24 = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    __int16 v39 = 260;
    v38[0] = (uint64_t)&__p;
    v36[0] = (uint64_t)&v45;
    void v36[2] = 0;
    __int16 v37 = 270;
    sub_1CB8F1E58(v38, v36, (uint64_t)v40);
    v34[0] = (uint64_t)") + sh_size (0x";
    __int16 v35 = 259;
    sub_1CB8F1E58(v40, v34, (uint64_t)v41);
    v31[0] = (uint64_t)&v44;
    uint64_t v32 = 0;
    __int16 v33 = 270;
    sub_1CB8F1E58(v41, v31, (uint64_t)v42);
    v29[0] = (uint64_t)") that cannot be represented";
    __int16 v30 = 259;
    sub_1CB8F1E58(v42, v29, (uint64_t)v43);
    operator new();
  }
  if (v6 + v5 > result[1])
  {
    sub_1CD6D3754(result, a2, (char *)&v26);
    std::string v12 = std::string::insert(&v26, 0, "section ");
    std::string::size_type v13 = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v27.__r_.__value_.__l.__data_ = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v27.__r_.__value_.__r.__words[2] = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    char v14 = std::string::append(&v27, " has a sh_offset (0x");
    uint64_t v15 = (void *)v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string::size_type v28 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v28[2] = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    __int16 v35 = 260;
    v34[0] = (uint64_t)v28;
    v31[0] = (uint64_t)&v45;
    uint64_t v32 = 0;
    __int16 v33 = 270;
    sub_1CB8F1E58(v34, v31, (uint64_t)v36);
    v29[0] = (uint64_t)") + sh_size (0x";
    __int16 v30 = 259;
    sub_1CB8F1E58(v36, v29, (uint64_t)v38);
    *(void *)&long long __p = &v44;
    std::string::size_type v24 = 0;
    __int16 v25 = 270;
    sub_1CB8F1E58(v38, (uint64_t *)&__p, (uint64_t)v40);
    v21.__r_.__value_.__r.__words[0] = (std::string::size_type)") that is greater than the file size (0x";
    __int16 v22 = 259;
    sub_1CB8F1E58(v40, (uint64_t *)&v21, (uint64_t)v41);
    uint64_t v18 = v3[1];
    v19.__r_.__value_.__r.__words[0] = (std::string::size_type)&v18;
    v19.__r_.__value_.__r.__words[2] = 0;
    __int16 v20 = 270;
    sub_1CB8F1E58(v41, (uint64_t *)&v19, (uint64_t)v42);
    __int16 v16 = ")";
    __int16 v17 = 259;
    sub_1CB8F1E58(v42, (uint64_t *)&v16, (uint64_t)v43);
    operator new();
  }
  unint64_t v7 = *result + v5;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v6;
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::sections@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *result;
  unint64_t v4 = *(void *)(*result + 40);
  unint64_t v5 = bswap64(v4);
  unint64_t v34 = v5;
  if (!v4)
  {
    *(unsigned char *)(a2 + 16) &= ~1u;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    return result;
  }
  unsigned int v6 = *(unsigned __int16 *)(v3 + 58);
  if (v6 != 0x4000)
  {
    v30[0] = (uint64_t)"invalid e_shentsize in ELF header: ";
    __int16 v31 = 259;
    __int16 v29 = 265;
    LODWORD(v28[0]) = __rev16(v6);
    goto LABEL_11;
  }
  unint64_t v7 = result[1];
  if (v5 > 0xFFFFFFFFFFFFFFBFLL || v5 + 64 > v7)
  {
    v30[0] = (uint64_t)"section header table goes past the end of the file: e_shoff = 0x";
    __int16 v31 = 259;
    v28[0] = (uint64_t)&v34;
    v28[2] = 0;
    __int16 v29 = 270;
LABEL_11:
    std::string::size_type v9 = v28;
LABEL_12:
    sub_1CB8F1E58(v30, v9, (uint64_t)&v32);
    goto LABEL_13;
  }
  uint64_t v10 = v3 + v5;
  unsigned int v11 = *(unsigned __int16 *)(v3 + 60);
  unint64_t v12 = __rev16(v11);
  unint64_t v27 = v12;
  if (!v11)
  {
    unint64_t v12 = bswap64(*(void *)(v10 + 32));
    unint64_t v27 = v12;
    if (v12 >> 58)
    {
      v28[0] = (uint64_t)"invalid number of sections specified in the NULL section's sh_size field (";
      __int16 v29 = 259;
      __int16 v26 = 268;
      v25[0] = (uint64_t)&v27;
      sub_1CB8F1E58(v28, v25, (uint64_t)v30);
      v23[0] = (uint64_t)")";
      __int16 v24 = 259;
      std::string::size_type v9 = v23;
      goto LABEL_12;
    }
  }
  BOOL v13 = __CFADD__(v5, v12 << 6);
  unint64_t v14 = v5 + (v12 << 6);
  if (v13)
  {
    v23[0] = (uint64_t)"invalid section header table offset (e_shoff = 0x";
    __int16 v24 = 259;
    v21[0] = (uint64_t)&v34;
    v21[2] = 0;
    __int16 v22 = 270;
    sub_1CB8F1E58(v23, v21, (uint64_t)v25);
    std::string v19 = ") or invalid number of sections specified in the first section header's sh_size field (0x";
    __int16 v20 = 259;
    sub_1CB8F1E58(v25, (uint64_t *)&v19, (uint64_t)v28);
    v17[0] = (uint64_t)&v27;
    void v17[2] = 0;
    __int16 v18 = 270;
    sub_1CB8F1E58(v28, v17, (uint64_t)v30);
    uint64_t v15 = ")";
    __int16 v16 = 259;
    std::string::size_type v9 = (uint64_t *)&v15;
    goto LABEL_12;
  }
  if (v14 > v7)
  {
    uint64_t v32 = "section table goes past the end of file";
    __int16 v33 = 259;
LABEL_13:
    operator new();
  }
  *(unsigned char *)(a2 + 16) &= ~1u;
  *(void *)a2 = v10;
  *(void *)(a2 + 8) = v12;
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSection@<X0>(void *a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t result = (uint64_t)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::sections(a1, (uint64_t)v7);
  if (v8)
  {
    uint64_t v6 = v7[0];
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v6;
  }
  else
  {
    uint64_t result = sub_1CD6D1030(v7[0], v7[1], a2, a3);
    if (v8)
    {
      uint64_t result = v7[0];
      v7[0] = 0;
      if (result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
    }
  }
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSHNDXTable@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t result = (uint64_t)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::sections(a1, (uint64_t)v8);
  if (v9)
  {
    uint64_t v7 = v8[0];
    *(unsigned char *)(a3 + 16) |= 1u;
    *(void *)a3 = v7;
  }
  else
  {
    uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSHNDXTable(a1, a2, v8[0], v8[1], a3);
    if (v9)
    {
      uint64_t result = v8[0];
      v8[0] = 0;
      if (result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
    }
  }
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSHNDXTable@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t result = (uint64_t)sub_1CD6D43DC(a1, (unint64_t *)a2, (uint64_t)v36);
  uint64_t v11 = v36[0];
  if (v37)
  {
    *(unsigned char *)(a5 + 16) |= 1u;
    *(void *)a5 = v11;
    return result;
  }
  uint64_t v12 = v36[1];
  uint64_t result = sub_1CD6D1030(a3, a4, bswap32(*(_DWORD *)(a2 + 40)), (uint64_t)&v34);
  uint64_t v13 = v34;
  if (v35)
  {
    uint64_t v34 = 0;
    *(unsigned char *)(a5 + 16) |= 1u;
    *(void *)a5 = v13;
  }
  else
  {
    unsigned int v14 = *(_DWORD *)(v34 + 4);
    if (v14 != 0x2000000 && v14 != 184549376)
    {
      ELFSectionTypeName = llvm::object::getELFSectionTypeName((llvm::object *)(bswap32(*(unsigned __int16 *)(*a1 + 18)) >> 16), bswap32(v14));
      __int16 v32 = 1283;
      v31[0] = (uint64_t)"SHT_SYMTAB_SHNDX section is linked with ";
      uint64_t v31[2] = (uint64_t)ELFSectionTypeName;
      void v31[3] = v17;
      v29[0] = (uint64_t)" section (expected SHT_SYMTAB/SHT_DYNSYM)";
      __int16 v30 = 259;
      __int16 v18 = v29;
      goto LABEL_14;
    }
    unint64_t v28 = bswap64(*(void *)(v34 + 32)) / 0x18;
    if (v12 != v28)
    {
      __int16 v26 = "SHT_SYMTAB_SHNDX has ";
      __int16 v27 = 259;
      __int16 v25 = 266;
      uint64_t v23 = v12;
      v24[0] = (uint64_t)&v23;
      sub_1CB8F1E58((uint64_t *)&v26, v24, (uint64_t)v29);
      std::string v21 = " entries, but the symbol table associated has ";
      __int16 v22 = 259;
      sub_1CB8F1E58(v29, (uint64_t *)&v21, (uint64_t)v31);
      __int16 v20 = 268;
      std::string v19 = &v28;
      __int16 v18 = (uint64_t *)&v19;
LABEL_14:
      sub_1CB8F1E58(v31, v18, (uint64_t)v33);
      operator new();
    }
    *(unsigned char *)(a5 + 16) &= ~1u;
    *(void *)(a5 + 8) = v12;
    *(void *)a5 = v11;
  }
  if (v35)
  {
    uint64_t result = v34;
    uint64_t v34 = 0;
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  if (v37)
  {
    uint64_t result = v36[0];
    v36[0] = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  return result;
}

void *sub_1CD6D43DC@<X0>(void *result@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v4 = result;
  if (a2[7] != 0x400000000000000)
  {
    sub_1CD6D3754(result, (uint64_t)a2, (char *)&v32);
    char v9 = std::string::insert(&v32, 0, "section ");
    std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v37.__r_.__value_.__l.__data_ = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v37.__r_.__value_.__r.__words[2] = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    uint64_t v11 = std::string::append(&v37, " has invalid sh_entsize: expected ");
    std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
    long long __p = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    std::string::size_type v40 = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    __int16 v51 = 260;
    v50[0] = (uint64_t)&__p;
    v30.__r_.__value_.__r.__words[0] = 4;
    __int16 v49 = 266;
    v48[0] = (uint64_t)&v30;
    sub_1CB8F1E58(v50, v48, (uint64_t)v52);
    v46[0] = (uint64_t)", but got ";
    __int16 v47 = 259;
    sub_1CB8F1E58(v52, v46, (uint64_t)v53);
    v28.__r_.__value_.__r.__words[0] = bswap64(a2[7]);
    __int16 v45 = 268;
    v44[0] = (uint64_t)&v28;
    sub_1CB8F1E58(v53, v44, (uint64_t)v54);
    operator new();
  }
  unint64_t v6 = bswap64(a2[3]);
  unint64_t v7 = bswap64(a2[4]);
  unint64_t v42 = v7;
  unint64_t v43 = v6;
  if ((v7 & 3) != 0)
  {
    sub_1CD6D3754(result, (uint64_t)a2, (char *)&v28);
    uint64_t v13 = std::string::insert(&v28, 0, "section ");
    std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    uint64_t v15 = std::string::append(&v30, " has an invalid sh_size (");
    std::string::size_type v16 = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    __int16 v49 = 260;
    v48[0] = (uint64_t)&v32;
    __int16 v47 = 268;
    v46[0] = (uint64_t)&v42;
    sub_1CB8F1E58(v48, v46, (uint64_t)v50);
    v44[0] = (uint64_t)") which is not a multiple of its sh_entsize (";
    __int16 v45 = 259;
    sub_1CB8F1E58(v50, v44, (uint64_t)v52);
    v25[0] = bswap64(a2[7]);
    __int16 v41 = 268;
    *(void *)&long long __p = v25;
    sub_1CB8F1E58(v52, (uint64_t *)&__p, (uint64_t)v53);
    v37.__r_.__value_.__r.__words[0] = (std::string::size_type)")";
    __int16 v38 = 259;
    goto LABEL_9;
  }
  if (__CFADD__(v6, v7))
  {
    sub_1CD6D3754(result, (uint64_t)a2, (char *)&v28);
    uint64_t v17 = std::string::insert(&v28, 0, "section ");
    std::string::size_type v18 = v17->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v18;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v17->__r_.__value_.__r.__words[0] = 0;
    std::string v19 = std::string::append(&v30, " has a sh_offset (0x");
    std::string::size_type v20 = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    __int16 v49 = 260;
    v48[0] = (uint64_t)&v32;
    v46[0] = (uint64_t)&v43;
    _OWORD v46[2] = 0;
    __int16 v47 = 270;
    sub_1CB8F1E58(v48, v46, (uint64_t)v50);
    v44[0] = (uint64_t)") + sh_size (0x";
    __int16 v45 = 259;
    sub_1CB8F1E58(v50, v44, (uint64_t)v52);
    *(void *)&long long __p = &v42;
    std::string::size_type v40 = 0;
    __int16 v41 = 270;
    sub_1CB8F1E58(v52, (uint64_t *)&__p, (uint64_t)v53);
    v37.__r_.__value_.__r.__words[0] = (std::string::size_type)") that cannot be represented";
    __int16 v38 = 259;
LABEL_9:
    sub_1CB8F1E58(v53, (uint64_t *)&v37, (uint64_t)v54);
    operator new();
  }
  if (v7 + v6 > result[1])
  {
    sub_1CD6D3754(result, (uint64_t)a2, (char *)&v34);
    std::string v21 = std::string::insert(&v34, 0, "section ");
    std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    uint64_t v23 = std::string::append(&v35, " has a sh_offset (0x");
    __int16 v24 = (void *)v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)__int16 v36 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    void v36[2] = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    __int16 v45 = 260;
    v44[0] = (uint64_t)v36;
    *(void *)&long long __p = &v43;
    std::string::size_type v40 = 0;
    __int16 v41 = 270;
    sub_1CB8F1E58(v44, (uint64_t *)&__p, (uint64_t)v46);
    v37.__r_.__value_.__r.__words[0] = (std::string::size_type)") + sh_size (0x";
    __int16 v38 = 259;
    sub_1CB8F1E58(v46, (uint64_t *)&v37, (uint64_t)v48);
    v32.__r_.__value_.__r.__words[0] = (std::string::size_type)&v42;
    v32.__r_.__value_.__r.__words[2] = 0;
    __int16 v33 = 270;
    sub_1CB8F1E58(v48, (uint64_t *)&v32, (uint64_t)v50);
    v30.__r_.__value_.__r.__words[0] = (std::string::size_type)") that is greater than the file size (0x";
    __int16 v31 = 259;
    sub_1CB8F1E58(v50, (uint64_t *)&v30, (uint64_t)v52);
    uint64_t v27 = v4[1];
    v28.__r_.__value_.__r.__words[0] = (std::string::size_type)&v27;
    v28.__r_.__value_.__r.__words[2] = 0;
    __int16 v29 = 270;
    sub_1CB8F1E58(v52, (uint64_t *)&v28, (uint64_t)v53);
    v25[0] = (uint64_t)")";
    __int16 v26 = 259;
    sub_1CB8F1E58(v53, v25, (uint64_t)v54);
    operator new();
  }
  unint64_t v8 = *result + v6;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v8;
  *(void *)(a3 + 8) = v7 >> 2;
  return result;
}

void *sub_1CD6D4A70@<X0>(void *a1@<X0>, unint64_t *a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::relas(a1, a2, (uint64_t)v26);
  if (v27)
  {
    uint64_t v8 = v26[0];
    char v9 = *(unsigned char *)(a4 + 8) | 1;
  }
  else
  {
    if (v26[1] <= (unint64_t)a3)
    {
      std::string::size_type v20 = "can't read an entry at 0x";
      __int16 v21 = 259;
      uint64_t v17 = 24 * a3;
      v18[0] = (uint64_t)&v17;
      void v18[2] = 0;
      __int16 v19 = 270;
      sub_1CB8F1E58((uint64_t *)&v20, v18, (uint64_t)v22);
      uint64_t v15 = ": it goes past the end of the section (0x";
      __int16 v16 = 259;
      sub_1CB8F1E58(v22, (uint64_t *)&v15, (uint64_t)v23);
      unint64_t v12 = bswap64(a2[4]);
      v13[0] = (uint64_t)&v12;
      void v13[2] = 0;
      __int16 v14 = 270;
      sub_1CB8F1E58(v23, v13, (uint64_t)v24);
      std::string::size_type v10 = ")";
      __int16 v11 = 259;
      sub_1CB8F1E58(v24, (uint64_t *)&v10, (uint64_t)v25);
      operator new();
    }
    uint64_t v8 = v26[0] + 24 * a3;
    char v9 = *(unsigned char *)(a4 + 8) & 0xFE;
  }
  *(unsigned char *)(a4 + 8) = v9;
  *(void *)a4 = v8;
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::relas@<X0>(void *result@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v4 = result;
  if (a2[7] != 0x1800000000000000)
  {
    sub_1CD6D3754(result, (uint64_t)a2, (char *)&v31);
    uint64_t v8 = std::string::insert(&v31, 0, "section ");
    std::string::size_type v9 = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v36.__r_.__value_.__l.__data_ = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v36.__r_.__value_.__r.__words[2] = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v10 = std::string::append(&v36, " has invalid sh_entsize: expected ");
    std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
    long long __p = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    std::string::size_type v39 = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    __int16 v50 = 260;
    v49[0] = (uint64_t)&__p;
    v29.__r_.__value_.__r.__words[0] = 24;
    __int16 v48 = 266;
    v47[0] = (uint64_t)&v29;
    sub_1CB8F1E58(v49, v47, (uint64_t)v51);
    v45[0] = (uint64_t)", but got ";
    __int16 v46 = 259;
    sub_1CB8F1E58(v51, v45, (uint64_t)v52);
    v27.__r_.__value_.__r.__words[0] = bswap64(a2[7]);
    __int16 v44 = 268;
    v43[0] = (uint64_t)&v27;
    sub_1CB8F1E58(v52, v43, (uint64_t)v53);
    operator new();
  }
  unint64_t v5 = bswap64(a2[3]);
  unint64_t v6 = bswap64(a2[4]);
  unint64_t v41 = v6;
  unint64_t v42 = v5;
  if (v6 % 0x18)
  {
    sub_1CD6D3754(result, (uint64_t)a2, (char *)&v27);
    unint64_t v12 = std::string::insert(&v27, 0, "section ");
    std::string::size_type v13 = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v29.__r_.__value_.__r.__words[2] = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    __int16 v14 = std::string::append(&v29, " has an invalid sh_size (");
    std::string::size_type v15 = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    __int16 v48 = 260;
    v47[0] = (uint64_t)&v31;
    __int16 v46 = 268;
    v45[0] = (uint64_t)&v41;
    sub_1CB8F1E58(v47, v45, (uint64_t)v49);
    v43[0] = (uint64_t)") which is not a multiple of its sh_entsize (";
    __int16 v44 = 259;
    sub_1CB8F1E58(v49, v43, (uint64_t)v51);
    v24[0] = bswap64(a2[7]);
    __int16 v40 = 268;
    *(void *)&long long __p = v24;
    sub_1CB8F1E58(v51, (uint64_t *)&__p, (uint64_t)v52);
    v36.__r_.__value_.__r.__words[0] = (std::string::size_type)")";
    __int16 v37 = 259;
    goto LABEL_9;
  }
  if (__CFADD__(v5, v6))
  {
    sub_1CD6D3754(result, (uint64_t)a2, (char *)&v27);
    __int16 v16 = std::string::insert(&v27, 0, "section ");
    std::string::size_type v17 = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v29.__r_.__value_.__r.__words[2] = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v18 = std::string::append(&v29, " has a sh_offset (0x");
    std::string::size_type v19 = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    __int16 v48 = 260;
    v47[0] = (uint64_t)&v31;
    v45[0] = (uint64_t)&v42;
    v45[2] = 0;
    __int16 v46 = 270;
    sub_1CB8F1E58(v47, v45, (uint64_t)v49);
    v43[0] = (uint64_t)") + sh_size (0x";
    __int16 v44 = 259;
    sub_1CB8F1E58(v49, v43, (uint64_t)v51);
    *(void *)&long long __p = &v41;
    std::string::size_type v39 = 0;
    __int16 v40 = 270;
    sub_1CB8F1E58(v51, (uint64_t *)&__p, (uint64_t)v52);
    v36.__r_.__value_.__r.__words[0] = (std::string::size_type)") that cannot be represented";
    __int16 v37 = 259;
LABEL_9:
    sub_1CB8F1E58(v52, (uint64_t *)&v36, (uint64_t)v53);
    operator new();
  }
  if (v6 + v5 > result[1])
  {
    sub_1CD6D3754(result, (uint64_t)a2, (char *)&v33);
    std::string::size_type v20 = std::string::insert(&v33, 0, "section ");
    std::string::size_type v21 = v20->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v34.__r_.__value_.__l.__data_ = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v34.__r_.__value_.__r.__words[2] = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v22 = std::string::append(&v34, " has a sh_offset (0x");
    uint64_t v23 = (void *)v22->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string v35 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v35[2] = v23;
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    __int16 v44 = 260;
    v43[0] = (uint64_t)v35;
    *(void *)&long long __p = &v42;
    std::string::size_type v39 = 0;
    __int16 v40 = 270;
    sub_1CB8F1E58(v43, (uint64_t *)&__p, (uint64_t)v45);
    v36.__r_.__value_.__r.__words[0] = (std::string::size_type)") + sh_size (0x";
    __int16 v37 = 259;
    sub_1CB8F1E58(v45, (uint64_t *)&v36, (uint64_t)v47);
    v31.__r_.__value_.__r.__words[0] = (std::string::size_type)&v41;
    v31.__r_.__value_.__r.__words[2] = 0;
    __int16 v32 = 270;
    sub_1CB8F1E58(v47, (uint64_t *)&v31, (uint64_t)v49);
    v29.__r_.__value_.__r.__words[0] = (std::string::size_type)") that is greater than the file size (0x";
    __int16 v30 = 259;
    sub_1CB8F1E58(v49, (uint64_t *)&v29, (uint64_t)v51);
    uint64_t v26 = v4[1];
    v27.__r_.__value_.__r.__words[0] = (std::string::size_type)&v26;
    v27.__r_.__value_.__r.__words[2] = 0;
    __int16 v28 = 270;
    sub_1CB8F1E58(v51, (uint64_t *)&v27, (uint64_t)v52);
    v24[0] = (uint64_t)")";
    __int16 v25 = 259;
    sub_1CB8F1E58(v52, v24, (uint64_t)v53);
    operator new();
  }
  unint64_t v7 = *result + v5;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v6 / 0x18;
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::rels@<X0>(void *result@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v4 = result;
  if (a2[7] != 0x1000000000000000)
  {
    sub_1CD6D3754(result, (uint64_t)a2, (char *)&v32);
    std::string::size_type v9 = std::string::insert(&v32, 0, "section ");
    std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v37.__r_.__value_.__l.__data_ = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v37.__r_.__value_.__r.__words[2] = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v11 = std::string::append(&v37, " has invalid sh_entsize: expected ");
    std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
    long long __p = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    std::string::size_type v40 = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    __int16 v51 = 260;
    v50[0] = (uint64_t)&__p;
    v30.__r_.__value_.__r.__words[0] = 16;
    __int16 v49 = 266;
    v48[0] = (uint64_t)&v30;
    sub_1CB8F1E58(v50, v48, (uint64_t)v52);
    v46[0] = (uint64_t)", but got ";
    __int16 v47 = 259;
    sub_1CB8F1E58(v52, v46, (uint64_t)v53);
    v28.__r_.__value_.__r.__words[0] = bswap64(a2[7]);
    __int16 v45 = 268;
    v44[0] = (uint64_t)&v28;
    sub_1CB8F1E58(v53, v44, (uint64_t)v54);
    operator new();
  }
  unint64_t v6 = bswap64(a2[3]);
  unint64_t v7 = bswap64(a2[4]);
  unint64_t v42 = v7;
  unint64_t v43 = v6;
  if ((v7 & 0xF) != 0)
  {
    sub_1CD6D3754(result, (uint64_t)a2, (char *)&v28);
    std::string::size_type v13 = std::string::insert(&v28, 0, "section ");
    std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v15 = std::string::append(&v30, " has an invalid sh_size (");
    std::string::size_type v16 = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    __int16 v49 = 260;
    v48[0] = (uint64_t)&v32;
    __int16 v47 = 268;
    v46[0] = (uint64_t)&v42;
    sub_1CB8F1E58(v48, v46, (uint64_t)v50);
    v44[0] = (uint64_t)") which is not a multiple of its sh_entsize (";
    __int16 v45 = 259;
    sub_1CB8F1E58(v50, v44, (uint64_t)v52);
    v25[0] = bswap64(a2[7]);
    __int16 v41 = 268;
    *(void *)&long long __p = v25;
    sub_1CB8F1E58(v52, (uint64_t *)&__p, (uint64_t)v53);
    v37.__r_.__value_.__r.__words[0] = (std::string::size_type)")";
    __int16 v38 = 259;
    goto LABEL_9;
  }
  if (__CFADD__(v6, v7))
  {
    sub_1CD6D3754(result, (uint64_t)a2, (char *)&v28);
    std::string::size_type v17 = std::string::insert(&v28, 0, "section ");
    std::string::size_type v18 = v17->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v18;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v17->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v19 = std::string::append(&v30, " has a sh_offset (0x");
    std::string::size_type v20 = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    __int16 v49 = 260;
    v48[0] = (uint64_t)&v32;
    v46[0] = (uint64_t)&v43;
    _OWORD v46[2] = 0;
    __int16 v47 = 270;
    sub_1CB8F1E58(v48, v46, (uint64_t)v50);
    v44[0] = (uint64_t)") + sh_size (0x";
    __int16 v45 = 259;
    sub_1CB8F1E58(v50, v44, (uint64_t)v52);
    *(void *)&long long __p = &v42;
    std::string::size_type v40 = 0;
    __int16 v41 = 270;
    sub_1CB8F1E58(v52, (uint64_t *)&__p, (uint64_t)v53);
    v37.__r_.__value_.__r.__words[0] = (std::string::size_type)") that cannot be represented";
    __int16 v38 = 259;
LABEL_9:
    sub_1CB8F1E58(v53, (uint64_t *)&v37, (uint64_t)v54);
    operator new();
  }
  if (v7 + v6 > result[1])
  {
    sub_1CD6D3754(result, (uint64_t)a2, (char *)&v34);
    std::string::size_type v21 = std::string::insert(&v34, 0, "section ");
    std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    uint64_t v23 = std::string::append(&v35, " has a sh_offset (0x");
    __int16 v24 = (void *)v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string v36 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    void v36[2] = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    __int16 v45 = 260;
    v44[0] = (uint64_t)v36;
    *(void *)&long long __p = &v43;
    std::string::size_type v40 = 0;
    __int16 v41 = 270;
    sub_1CB8F1E58(v44, (uint64_t *)&__p, (uint64_t)v46);
    v37.__r_.__value_.__r.__words[0] = (std::string::size_type)") + sh_size (0x";
    __int16 v38 = 259;
    sub_1CB8F1E58(v46, (uint64_t *)&v37, (uint64_t)v48);
    v32.__r_.__value_.__r.__words[0] = (std::string::size_type)&v42;
    v32.__r_.__value_.__r.__words[2] = 0;
    __int16 v33 = 270;
    sub_1CB8F1E58(v48, (uint64_t *)&v32, (uint64_t)v50);
    v30.__r_.__value_.__r.__words[0] = (std::string::size_type)") that is greater than the file size (0x";
    __int16 v31 = 259;
    sub_1CB8F1E58(v50, (uint64_t *)&v30, (uint64_t)v52);
    uint64_t v27 = v4[1];
    v28.__r_.__value_.__r.__words[0] = (std::string::size_type)&v27;
    v28.__r_.__value_.__r.__words[2] = 0;
    __int16 v29 = 270;
    sub_1CB8F1E58(v52, (uint64_t *)&v28, (uint64_t)v53);
    v25[0] = (uint64_t)")";
    __int16 v26 = 259;
    sub_1CB8F1E58(v53, v25, (uint64_t)v54);
    operator new();
  }
  unint64_t v8 = *result + v6;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v8;
  *(void *)(a3 + 8) = v7 >> 4;
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSectionStringTable(void *a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, void (*a4)(uint64_t *__return_ptr, uint64_t, void *)@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  unsigned int v7 = *(unsigned __int16 *)(*a1 + 62);
  if (v7 == 0xFFFF)
  {
    if (!a3)
    {
      std::string::size_type v17 = "e_shstrndx == SHN_XINDEX, but the section header table is empty";
      __int16 v18 = 259;
LABEL_6:
      operator new();
    }
    unsigned int v8 = bswap32(*(_DWORD *)(a2 + 40));
  }
  else
  {
    unsigned int v8 = __rev16(v7);
  }
  if (v8)
  {
    if (a3 <= v8)
    {
      std::string::size_type v14 = "section header string table index ";
      __int16 v15 = 259;
      __int16 v13 = 264;
      LODWORD(v12[0]) = v8;
      sub_1CB8F1E58((uint64_t *)&v14, v12, (uint64_t)v16);
      std::string::size_type v10 = " does not exist";
      __int16 v11 = 259;
      sub_1CB8F1E58(v16, (uint64_t *)&v10, (uint64_t)&v17);
      goto LABEL_6;
    }
    uint64_t v9 = a2 + ((unint64_t)v8 << 6);
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getStringTable(a1, v9, a4, a5, a6);
  }
  else
  {
    *(unsigned char *)(a6 + 16) &= ~1u;
    *(void *)a6 = "";
    *(void *)(a6 + 8) = 0;
  }
}

uint64_t *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSectionIndex@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, _OWORD *a3@<X4>, uint64_t a4@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = *(unsigned __int16 *)(a1 + 6);
  if (v5 == 0xFFFF)
  {
    long long v7 = a3[1];
    v10[0] = *a3;
    v10[1] = v7;
    uint64_t result = sub_1CD6CFCE8(-1431655765 * ((unint64_t)(a1 - a2) >> 3), (uint64_t *)v10, (uint64_t)&v11);
    if (v12)
    {
      uint64_t v9 = v11;
      *(unsigned char *)(a4 + 8) |= 1u;
      *(void *)a4 = v9;
      return result;
    }
    *(unsigned char *)(a4 + 8) &= ~1u;
    unsigned int v6 = v11;
  }
  else
  {
    unsigned int v6 = __rev16(v5);
    *(unsigned char *)(a4 + 8) &= ~1u;
    if ((unsigned __int16)(v6 + 256) <= 0x100u)
    {
      *(_DWORD *)a4 = 0;
      return result;
    }
  }
  *(_DWORD *)a4 = v6;
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSection@<X0>(void *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, _OWORD *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a3)
  {
    v13[0] = 0;
    v13[1] = 0;
    char v14 = 0;
    goto LABEL_3;
  }
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::relas(a1, a3, (uint64_t)v13);
  if ((v14 & 1) == 0)
  {
    a3 = (unint64_t *)v13[0];
LABEL_3:
    long long v9 = a4[1];
    v12[0] = *a4;
    v12[1] = v9;
    uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSection(a1, a2, (uint64_t)a3, v12, a5);
    if ((v14 & 1) == 0) {
      return result;
    }
    goto LABEL_7;
  }
  uint64_t v11 = v13[0];
  v13[0] = 0;
  *(unsigned char *)(a5 + 8) |= 1u;
  *(void *)a5 = v11;
LABEL_7:
  uint64_t result = v13[0];
  v13[0] = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSection@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _OWORD *a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  long long v7 = a4[1];
  v10[0] = *a4;
  v10[1] = v7;
  uint64_t result = (uint64_t)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSectionIndex(a2, a3, v10, (uint64_t)&v11);
  if (v12)
  {
    uint64_t v9 = v11;
    *(unsigned char *)(a5 + 8) |= 1u;
    *(void *)a5 = v9;
  }
  else if (v11)
  {
    uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSection(a1, v11, a5);
    if (v12)
    {
      uint64_t result = v11;
      uint64_t v11 = 0;
      if (result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
    }
  }
  else
  {
    *(unsigned char *)(a5 + 8) &= ~1u;
    *(void *)a5 = 0;
  }
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSectionName(void *a1@<X0>, unsigned int *a2@<X1>, void (*a3)(uint64_t *__return_ptr, uint64_t, void *)@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::sections(a1, (uint64_t)v16);
  if (v17)
  {
    uint64_t v10 = v16[0];
    *(unsigned char *)(a5 + 16) |= 1u;
    *(void *)a5 = v10;
  }
  else
  {
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSectionStringTable(a1, v16[0], v16[1], a3, a4, (uint64_t)v14);
    if (v15)
    {
      uint64_t v11 = v14[0];
      *(unsigned char *)(a5 + 16) |= 1u;
      *(void *)a5 = v11;
    }
    else
    {
      llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSectionName(a1, a2, v14[0], v14[1], a5);
      if (v15)
      {
        uint64_t v13 = v14[0];
        v14[0] = 0;
        if (v13) {
          (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
        }
      }
    }
    if (v17)
    {
      uint64_t v12 = v16[0];
      v16[0] = 0;
      if (v12) {
        (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
      }
    }
  }
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSectionName@<X0>(void *result@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  if (*a2)
  {
    unint64_t v6 = bswap32(*a2);
    if (a4 <= v6)
    {
      sub_1CD6D3754(result, (uint64_t)a2, (char *)&v17);
      unsigned int v8 = std::string::insert(&v17, 0, "a section ");
      std::string::size_type v9 = v8->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v18.__r_.__value_.__l.__data_ = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      v18.__r_.__value_.__r.__words[2] = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      uint64_t v10 = std::string::append(&v18, " has an invalid sh_name (0x");
      std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
      *(_OWORD *)long long __p = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
      std::string::size_type v20 = v11;
      v10->__r_.__value_.__l.__size_ = 0;
      v10->__r_.__value_.__r.__words[2] = 0;
      v10->__r_.__value_.__r.__words[0] = 0;
      __int16 v22 = 260;
      std::string::size_type v21 = __p;
      unint64_t v14 = v6;
      v15[0] = (uint64_t)&v14;
      uint64_t v15[2] = 0;
      __int16 v16 = 270;
      sub_1CB8F1E58((uint64_t *)&v21, v15, (uint64_t)v23);
      uint64_t v12 = ") offset which goes past the end of the section name string table";
      __int16 v13 = 259;
      sub_1CB8F1E58(v23, (uint64_t *)&v12, (uint64_t)v24);
      operator new();
    }
    long long v7 = (const char *)(a3 + v6);
    uint64_t result = (void *)strlen(v7);
    *(unsigned char *)(a5 + 16) &= ~1u;
    *(void *)a5 = v7;
    *(void *)(a5 + 8) = result;
  }
  else
  {
    *(unsigned char *)(a5 + 16) &= ~1u;
    *(void *)a5 = 0;
    *(void *)(a5 + 8) = 0;
  }
  return result;
}

uint64_t sub_1CD6D6140(uint64_t (**a1)(uint64_t), uint64_t a2)
{
  return (*a1)(a2);
}

uint64_t *sub_1CD6D614C@<X0>(uint64_t *result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*((unsigned char *)result + 16))
  {
    uint64_t v4 = *result;
    if (*result + 4 * a2 + 4 <= result[3]) {
      goto LABEL_4;
    }
    uint64_t v12 = "can't read past the end of the file";
    __int16 v13 = 259;
LABEL_8:
    operator new();
  }
  if (result[1] <= a2)
  {
    std::string::size_type v9 = "the index is greater than or equal to the number of entries (";
    __int16 v10 = 259;
    __int16 v8 = 268;
    v7[0] = (uint64_t)(result + 1);
    sub_1CB8F1E58((uint64_t *)&v9, v7, (uint64_t)v11);
    unsigned int v5 = ")";
    __int16 v6 = 259;
    sub_1CB8F1E58(v11, (uint64_t *)&v5, (uint64_t)&v12);
    goto LABEL_8;
  }
  uint64_t v4 = *result;
LABEL_4:
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(_DWORD *)a3 = *(_DWORD *)(v4 + 4 * a2);
  return result;
}

void llvm::object::ELFObjectFileBase::getMIPSFeatures(llvm::object::ELFObjectFileBase *this@<X0>, int64x2_t *a2@<X8>)
{
  a2->i64[0] = 0;
  a2->i64[1] = 0;
  a2[1].i64[0] = 0;
  llvm::SubtargetFeatures::Split(a2, (uint64_t)"", 0);
  unsigned int v4 = (*(uint64_t (**)(llvm::object::ELFObjectFileBase *))(*(void *)this + 512))(this);
  unsigned int v5 = "mips2";
  uint64_t v6 = 5;
  unsigned int v7 = v4;
  switch((v4 >> 28) ^ 8)
  {
    case 1u:
      unsigned int v5 = "mips32r6";
      goto LABEL_21;
    case 2u:
      unsigned int v5 = "mips64r6";
      goto LABEL_21;
    case 3u:
    case 4u:
    case 5u:
    case 6u:
    case 7u:
      __break(1u);
      return;
    case 8u:
      goto LABEL_2;
    case 9u:
      goto LABEL_22;
    case 0xAu:
      unsigned int v5 = "mips3";
      goto LABEL_19;
    case 0xBu:
      unsigned int v5 = "mips4";
      goto LABEL_19;
    case 0xCu:
      unsigned int v5 = "mips5";
LABEL_19:
      uint64_t v6 = 5;
      goto LABEL_22;
    case 0xDu:
      unsigned int v5 = "mips32";
      goto LABEL_17;
    case 0xEu:
      unsigned int v5 = "mips64";
LABEL_17:
      uint64_t v6 = 6;
      goto LABEL_22;
    case 0xFu:
      unsigned int v5 = "mips32r2";
      goto LABEL_21;
    default:
      unsigned int v5 = "mips64r2";
LABEL_21:
      uint64_t v6 = 8;
LABEL_22:
      llvm::SubtargetFeatures::AddFeature(a2, (unsigned __int8 *)v5, v6, 1);
LABEL_2:
      if ((v7 & 0xFF0000) != 0) {
        llvm::SubtargetFeatures::AddFeature(a2, "cnmips", 6, 1);
      }
      if ((v7 & 0x4000000) != 0) {
        llvm::SubtargetFeatures::AddFeature(a2, "mips16", 6, 1);
      }
      if ((v7 & 0x2000000) != 0)
      {
        llvm::SubtargetFeatures::AddFeature(a2, "micromips", 9, 1);
      }
      return;
  }
}

void *llvm::object::ELFObjectFileBase::getRISCVFeatures@<X0>(llvm::object::ELFObjectFileBase *this@<X0>, int64x2_t *a2@<X8>)
{
  a2->i64[0] = 0;
  a2->i64[1] = 0;
  a2[1].i64[0] = 0;
  llvm::SubtargetFeatures::Split(a2, (uint64_t)"", 0);
  if ((*(uint64_t (**)(llvm::object::ELFObjectFileBase *))(*(void *)this + 512))(this)) {
    llvm::SubtargetFeatures::AddFeature(a2, "c", 1, 1);
  }
  double v4 = sub_1CCC48030((uint64_t)v22);
  (*(void (**)(void **__return_ptr, llvm::object::ELFObjectFileBase *, void *, double))(*(void *)this + 496))(&v21, this, v22, v4);
  if (v21)
  {
    std::string::size_type v20 = v21;
    std::string::size_type v21 = 0;
    sub_1CD4515D0(&v20);
    if (v20) {
      (*(void (**)(void *))(*v20 + 8))(v20);
    }
    if (v21) {
      (*(void (**)(void *))(*v21 + 8))(v21);
    }
    return sub_1CD6D6C64(v22);
  }
  unsigned int v5 = sub_1CD6D6BB8(v22[8], v22[9], 5u);
  if (!v5) {
    return sub_1CD6D6C64(v22);
  }
  uint64_t v6 = (unsigned __int8 *)v5[3];
  unint64_t v7 = v5[4];
  if (v7 >= 4)
  {
    int v19 = *(_DWORD *)v6;
    if (*(_DWORD *)v6 == 842233458 || *(_DWORD *)v6 == 875984498)
    {
      v6 += 4;
      llvm::SubtargetFeatures::AddFeature(a2, "64bit", 5, v19 != 842233458);
      v7 -= 4;
      goto LABEL_6;
    }
    while (1)
    {
LABEL_7:
      unsigned int v8 = (char)*v6 - 97;
      if (v8 > 0xC) {
        goto LABEL_11;
      }
      if (((1 << v8) & 0x1035) != 0) {
        goto LABEL_30;
      }
      if (*v6 == 100) {
        break;
      }
      if (*v6 != 105) {
        goto LABEL_11;
      }
      char v15 = a2;
      __int16 v16 = "e";
      int v17 = 0;
LABEL_31:
      llvm::SubtargetFeatures::AddFeature(v15, v16, 1, v17);
LABEL_11:
      unint64_t v9 = 0;
      while (1)
      {
        int v10 = v6[v9];
        if (v10 == 95 || v10 == 0) {
          break;
        }
        if (v7 == ++v9)
        {
          unint64_t v9 = -1;
          break;
        }
      }
      if (v7 < v9) {
        unint64_t v9 = v7;
      }
      uint64_t v12 = (char *)&v6[v9];
      unint64_t v13 = v7 - v9;
      if (v13)
      {
        unint64_t v14 = 0;
        while (v12[v14] == 95)
        {
          if (v13 == ++v14) {
            goto LABEL_24;
          }
        }
      }
      else
      {
LABEL_24:
        unint64_t v14 = -1;
      }
      if (v13 < v14) {
        unint64_t v14 = v13;
      }
      uint64_t v6 = (unsigned __int8 *)&v12[v14];
      unint64_t v7 = v13 - v14;
      if (v13 == v14) {
        return sub_1CD6D6C64(v22);
      }
    }
    llvm::SubtargetFeatures::AddFeature(a2, "f", 1, 1);
LABEL_30:
    char v15 = a2;
    __int16 v16 = v6;
    int v17 = 1;
    goto LABEL_31;
  }
LABEL_6:
  if (v7) {
    goto LABEL_7;
  }
  return sub_1CD6D6C64(v22);
}

void llvm::object::ELFObjectFileBase::getFeatures(llvm::object::ELFObjectFileBase *this@<X0>, int64x2_t *a2@<X8>)
{
  int v4 = (*(uint64_t (**)(llvm::object::ELFObjectFileBase *))(*(void *)this + 528))(this);
  switch(v4)
  {
    case 40:
      llvm::object::ELFObjectFileBase::getARMFeatures(this, a2);
      break;
    case 243:
      llvm::object::ELFObjectFileBase::getRISCVFeatures(this, a2);
      break;
    case 8:
      llvm::object::ELFObjectFileBase::getMIPSFeatures(this, a2);
      break;
    default:
      a2->i64[0] = 0;
      a2->i64[1] = 0;
      a2[1].i64[0] = 0;
      llvm::SubtargetFeatures::Split(a2, (uint64_t)"", 0);
      break;
  }
}

const char *llvm::object::ELFObjectFileBase::tryGetCPUName@<X0>(llvm::object::ELFObjectFileBase *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = (const char *)(*(uint64_t (**)(llvm::object::ELFObjectFileBase *))(*(void *)this + 528))(this);
  if (result == 224)
  {
    uint64_t result = llvm::object::ELFObjectFileBase::getAMDGPUCPUName(this);
    *(void *)a2 = result;
    *(void *)(a2 + 8) = v6;
    char v5 = 1;
  }
  else
  {
    char v5 = 0;
    *(unsigned char *)a2 = 0;
  }
  *(unsigned char *)(a2 + 16) = v5;
  return result;
}

const char *llvm::object::ELFObjectFileBase::getAMDGPUCPUName(llvm::object::ELFObjectFileBase *this)
{
  int v1 = (*(unsigned __int8 (**)(llvm::object::ELFObjectFileBase *))(*(void *)this + 512))(this);
  uint64_t result = "r600";
  switch(v1)
  {
    case 2:
      uint64_t result = "r630";
      break;
    case 3:
      uint64_t result = "rs880";
      break;
    case 4:
      uint64_t result = "rv670";
      break;
    case 5:
      uint64_t result = "rv710";
      break;
    case 6:
      uint64_t result = "rv730";
      break;
    case 7:
      uint64_t result = "rv770";
      break;
    case 8:
      uint64_t result = "cedar";
      break;
    case 9:
      uint64_t result = "cypress";
      break;
    case 10:
      uint64_t result = "juniper";
      break;
    case 11:
      uint64_t result = "redwood";
      break;
    case 12:
      uint64_t result = "sumo";
      break;
    case 13:
      uint64_t result = "barts";
      break;
    case 14:
      uint64_t result = "caicos";
      break;
    case 15:
      uint64_t result = "cayman";
      break;
    case 16:
      uint64_t result = "turks";
      break;
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 39:
    case 65:
    case 67:
    case 68:
      __break(1u);
      break;
    case 32:
      uint64_t result = "gfx600";
      break;
    case 33:
      uint64_t result = "gfx601";
      break;
    case 34:
      uint64_t result = "gfx700";
      break;
    case 35:
      uint64_t result = "gfx701";
      break;
    case 36:
      uint64_t result = "gfx702";
      break;
    case 37:
      uint64_t result = "gfx703";
      break;
    case 38:
      uint64_t result = "gfx704";
      break;
    case 40:
      uint64_t result = "gfx801";
      break;
    case 41:
      uint64_t result = "gfx802";
      break;
    case 42:
      uint64_t result = "gfx803";
      break;
    case 43:
      uint64_t result = "gfx810";
      break;
    case 44:
      uint64_t result = "gfx900";
      break;
    case 45:
      uint64_t result = "gfx902";
      break;
    case 46:
      uint64_t result = "gfx904";
      break;
    case 47:
      uint64_t result = "gfx906";
      break;
    case 48:
      uint64_t result = "gfx908";
      break;
    case 49:
      uint64_t result = "gfx909";
      break;
    case 50:
      uint64_t result = "gfx90c";
      break;
    case 51:
      uint64_t result = "gfx1010";
      break;
    case 52:
      uint64_t result = "gfx1011";
      break;
    case 53:
      uint64_t result = "gfx1012";
      break;
    case 54:
      uint64_t result = "gfx1030";
      break;
    case 55:
      uint64_t result = "gfx1031";
      break;
    case 56:
      uint64_t result = "gfx1032";
      break;
    case 57:
      uint64_t result = "gfx1033";
      break;
    case 58:
      uint64_t result = "gfx602";
      break;
    case 59:
      uint64_t result = "gfx705";
      break;
    case 60:
      uint64_t result = "gfx805";
      break;
    case 61:
      uint64_t result = "gfx1035";
      break;
    case 62:
      uint64_t result = "gfx1034";
      break;
    case 63:
      uint64_t result = "gfx90a";
      break;
    case 64:
      uint64_t result = "gfx940";
      break;
    case 66:
      uint64_t result = "gfx1013";
      break;
    case 69:
      uint64_t result = "gfx1036";
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_1CD6D6B64@<X0>(llvm::object *a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)&v4.__val_ = llvm::object::object_category(a1);
  uint64_t result = llvm::errorCodeToError((llvm *)3, v4, (void *)a2);
  *(unsigned char *)(a2 + 8) |= 1u;
  return result;
}

uint64_t sub_1CD6D6BA4(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t *sub_1CD6D6BB8(uint64_t a1, unint64_t a2, unsigned int a3)
{
  if (!a2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a3;
    if (a3 >= a2) {
      unint64_t v4 = a3 % a2;
    }
  }
  else
  {
    unint64_t v4 = (a2 - 1) & a3;
  }
  char v5 = *(uint64_t ***)(a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (uint64_t result = *v5; result; uint64_t result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a3)
    {
      if (*((_DWORD *)result + 4) == a3) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= a2) {
          v7 %= a2;
        }
      }
      else
      {
        v7 &= a2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

void *sub_1CD6D6C64(void *a1)
{
  *a1 = &unk_1F2632CA0;
  uint64_t v2 = a1[20];
  a1[20] = 0;
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    uint64_t v3 = a1[20];
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
  }
  sub_1CD4CAAF4((uint64_t)(a1 + 8));
  sub_1CD4CAAF4((uint64_t)(a1 + 3));
  return a1;
}

void sub_1CD6D6D10(uint64_t a1, long long *a2, int a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::create(*(void *)a2, *((void *)a2 + 1), (uint64_t)&v23);
  if (v25)
  {
    uint64_t v6 = v23;
    uint64_t v23 = 0;
    if (v6)
    {
      *(unsigned char *)(a1 + 104) |= 1u;
      *(void *)a1 = v6;
      return;
    }
  }
  else
  {
    uint64_t v6 = v23;
  }
  long long v7 = a2[1];
  long long v17 = *a2;
  long long v18 = v7;
  uint64_t v8 = v24;
  int v16 = 12;
  char v15 = &unk_1F2632CC8;
  char v19 = 0;
  uint64_t v20 = v6;
  uint64_t v21 = v24;
  memset(v22, 0, 24);
  long long v9 = 0uLL;
  if (!a3)
  {
    uint64_t v10 = 0;
LABEL_5:
    *(unsigned char *)(a1 + 104) &= ~1u;
    *(_DWORD *)(a1 + 8) = 12;
    long long v11 = v18;
    *(_OWORD *)(a1 + 16) = v17;
    *(_OWORD *)(a1 + 32) = v11;
    *(void *)a1 = &unk_1F2632CC8;
    *(unsigned char *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = v6;
    *(void *)(a1 + 64) = v8;
    *(_OWORD *)(a1 + 72) = v9;
    *(void *)(a1 + 88) = v10;
    goto LABEL_6;
  }
  sub_1CD6D6EC0((uint64_t)&v15, &v14);
  uint64_t v13 = v14;
  if (!v14)
  {
    uint64_t v6 = v20;
    uint64_t v8 = v21;
    long long v9 = v22[0];
    uint64_t v10 = *(void *)&v22[1];
    goto LABEL_5;
  }
  *(unsigned char *)(a1 + 104) |= 1u;
  *(void *)a1 = v13;
LABEL_6:
  llvm::object::SymbolicFile::~SymbolicFile((llvm::object::SymbolicFile *)&v15);
  if (v25)
  {
    uint64_t v12 = v23;
    uint64_t v23 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
}

void *sub_1CD6D6EC0@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::sections((void *)(a1 + 56), (uint64_t)&v10);
  uint64_t v5 = v10;
  if ((v12 & 1) == 0)
  {
    if (v11)
    {
      uint64_t v6 = 40 * v11;
      long long v7 = (int *)(v10 + 4);
      while (1)
      {
        int v8 = *v7;
        if (*v7 == 2) {
          break;
        }
        if (v8 != 18)
        {
          if (v8 != 11) {
            goto LABEL_11;
          }
          long long v9 = (void *)(a1 + 72);
          if (*(void *)(a1 + 72)) {
            goto LABEL_11;
          }
LABEL_10:
          *long long v9 = v7 - 1;
          goto LABEL_11;
        }
        long long v9 = (void *)(a1 + 88);
        if (!*(void *)(a1 + 88)) {
          goto LABEL_10;
        }
LABEL_11:
        v7 += 10;
        v6 -= 40;
        if (!v6) {
          goto LABEL_15;
        }
      }
      long long v9 = (void *)(a1 + 80);
      if (*(void *)(a1 + 80)) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
LABEL_15:
    uint64_t v5 = 0;
    *(unsigned char *)(a1 + 48) = 1;
  }
  *a2 = v5;
  return result;
}

void sub_1CD6D6FC4(llvm::object::SymbolicFile *a1)
{
  llvm::object::SymbolicFile::~SymbolicFile(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD6D6FFC(uint64_t a1, uint64_t a2)
{
}

unint64_t sub_1CD6D700C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 80);
  if (v1) {
    unsigned int v2 = *(_DWORD *)(v1 + 20) > 0xFu;
  }
  else {
    unsigned int v2 = 0;
  }
  return sub_1CD6D9128(a1, v1, v2);
}

unint64_t sub_1CD6D7054(void *a1)
{
  uint64_t v1 = a1[10];
  if (v1) {
    return sub_1CD6D9128((uint64_t)a1, v1, *(_DWORD *)(v1 + 20) >> 4);
  }
  else {
    return (*(uint64_t (**)(void *))(*a1 + 48))(a1);
  }
}

void sub_1CD6D70C0(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a1 + 7;
  sub_1CD6D904C((uint64_t)&v31, a1 + 7, a2, HIDWORD(a2));
  if (v32)
  {
    long long v7 = v31;
    *(unsigned char *)(a3 + 16) |= 1u;
    *(void *)a3 = v7;
    return;
  }
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSection(v6, a2, (uint64_t)&v29);
  uint64_t v8 = v29;
  if ((v30 & 1) == 0)
  {
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSection(v6, *(_DWORD *)(v29 + 24), (uint64_t)&v27);
    uint64_t v10 = v27;
    if (v28)
    {
      uint64_t v27 = 0;
      *(unsigned char *)(a3 + 16) |= 1u;
      *(void *)a3 = v10;
LABEL_11:
      if (v30)
      {
        uint64_t v11 = v29;
        uint64_t v29 = 0;
        if (v11) {
          (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
        }
      }
      goto LABEL_6;
    }
    *(void *)&long long v23 = sub_1CCC487E0;
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getStringTable(v6, v27, (void (*)(uint64_t *__return_ptr, uint64_t, void *))sub_1CD6D6140, (uint64_t)&v23, (uint64_t)v25);
    if (v26)
    {
      uint64_t v12 = v25[0];
      v25[0] = 0;
      *(unsigned char *)(a3 + 16) |= 1u;
      *(void *)a3 = v12;
LABEL_16:
      if (v28)
      {
        uint64_t v13 = v27;
        uint64_t v27 = 0;
        if (v13) {
          (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
        }
      }
      goto LABEL_11;
    }
    sub_1CD6D91F8((uint64_t)&v23, v31, v25[0], v25[1]);
    if ((v24 & 1) != 0 || !*((void *)&v23 + 1))
    {
      int v15 = v24 & 1;
      if ((v31[3] & 0xF) == 3)
      {
        (*(void (**)(uint64_t *__return_ptr, void *, uint64_t))(*a1 + 120))(&v20, a1, a2);
        if ((v22 & 1) == 0)
        {
          if (v15)
          {
            long long v17 = (void *)v23;
            *(void *)&long long v23 = 0;
          }
          else
          {
            long long v17 = 0;
          }
          char v19 = v17;
          sub_1CD4515D0(&v19);
          if (v19) {
            (*(void (**)(void *))(*v19 + 8))(v19);
          }
          (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 136))(v21, v20);
          if (v22)
          {
            uint64_t v18 = v20;
            uint64_t v20 = 0;
            if (v18) {
              (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
            }
          }
          if (v15 && (void)v23) {
            (*(void (**)(void))(*(void *)v23 + 8))(v23);
          }
          goto LABEL_23;
        }
        uint64_t v16 = v20;
        uint64_t v20 = 0;
        if (v16) {
          (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
        }
      }
      *(unsigned char *)(a3 + 16) = *(unsigned char *)(a3 + 16) & 0xFE | v15;
      if (v15)
      {
        *(void *)a3 = v23;
        goto LABEL_23;
      }
    }
    else
    {
      *(unsigned char *)(a3 + 16) &= ~1u;
    }
    *(_OWORD *)a3 = v23;
LABEL_23:
    if (v26)
    {
      uint64_t v14 = v25[0];
      v25[0] = 0;
      if (v14) {
        (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
      }
    }
    goto LABEL_16;
  }
  uint64_t v29 = 0;
  *(unsigned char *)(a3 + 16) |= 1u;
  *(void *)a3 = v8;
LABEL_6:
  if (v32)
  {
    long long v9 = v31;
    __int16 v31 = 0;
    if (v9) {
      (*(void (**)(int *))(*(void *)v9 + 8))(v9);
    }
  }
}

unsigned int *sub_1CD6D74B0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t result = (unsigned int *)llvm::object::ObjectFile::getSymbolValue(a1, a2, (uint64_t)&v25);
  if (v26)
  {
    long long v7 = v25;
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v7;
    return result;
  }
  uint64_t v8 = v25;
  uint64_t result = sub_1CD6D904C((uint64_t)&v23, (void *)(a1 + 56), a2, HIDWORD(a2));
  uint64_t v9 = v23;
  if (v24)
  {
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v9;
  }
  else
  {
    int v10 = *(unsigned __int16 *)(v23 + 14);
    if ((v10 - 65521) >= 2 && v10 != 0)
    {
      uint64_t result = (unsigned int *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSection((void *)(a1 + 56), a2, (uint64_t)&v21);
      if (v22)
      {
        uint64_t v12 = v21;
        uint64_t v21 = 0;
      }
      else
      {
        if (*(_WORD *)(*(void *)(a1 + 56) + 16) != 1)
        {
LABEL_17:
          *(unsigned char *)(a3 + 8) &= ~1u;
          *(void *)a3 = v8;
          goto LABEL_20;
        }
        uint64_t v13 = *(unsigned int **)(a1 + 88);
        if (v13)
        {
          uint64_t result = (unsigned int *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSHNDXTable((void *)(a1 + 56), v13, (uint64_t)&v18);
          uint64_t v12 = v18;
          if (v20) {
            goto LABEL_19;
          }
          uint64_t v14 = v19;
        }
        else
        {
          uint64_t v12 = 0;
          uint64_t v14 = 0;
        }
        *(void *)&long long v15 = v12;
        *((void *)&v15 + 1) = v14;
        char v16 = 1;
        uint64_t v17 = 0;
        uint64_t result = (unsigned int *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSection((void *)(a1 + 56), v23, v21, &v15, (uint64_t)&v18);
        uint64_t v12 = v18;
        if ((v19 & 1) == 0)
        {
          if (v18) {
            uint64_t v8 = (unsigned int *)((char *)v8 + v18[3]);
          }
          goto LABEL_17;
        }
      }
LABEL_19:
      *(unsigned char *)(a3 + 8) |= 1u;
      *(void *)a3 = v12;
LABEL_20:
      if (v22)
      {
        uint64_t result = v21;
        uint64_t v21 = 0;
        if (result) {
          uint64_t result = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 8))(result);
        }
      }
      if (v24)
      {
        uint64_t result = (unsigned int *)v23;
        uint64_t v23 = 0;
        if (result) {
          uint64_t result = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 8))(result);
        }
      }
      goto LABEL_12;
    }
    *(unsigned char *)(a3 + 8) &= ~1u;
    *(void *)a3 = v8;
  }
LABEL_12:
  if (v26)
  {
    uint64_t result = v25;
    char v25 = 0;
    if (result) {
      return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 8))(result);
    }
  }
  return result;
}

uint64_t sub_1CD6D771C(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1 + 56;
  sub_1CD6D904C((uint64_t)&v7, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v8)
  {
    uint64_t v6 = v7;
    uint64_t v7 = 0;
    llvm::report_fatal_error(&v6);
  }
  uint64_t result = *(unsigned int *)(v7 + 4);
  if (*(__int16 *)(v7 + 14) != -15)
  {
    int v4 = *(unsigned __int16 *)(*(void *)v2 + 18);
    if ((v4 == 40 || v4 == 8) && (*(unsigned char *)(v7 + 12) & 0xF) == 2) {
      return result & 0xFFFFFFFE;
    }
  }
  return result;
}

uint64_t sub_1CD6D77DC(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  sub_1CD6D904C((uint64_t)&v4, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v5)
  {
    uint64_t v3 = v4;
    uint64_t v4 = 0;
    llvm::report_fatal_error(&v3);
  }
  if (*(__int16 *)(v4 + 14) == -14) {
    return *(unsigned int *)(v4 + 4);
  }
  else {
    return 0;
  }
}

uint64_t sub_1CD6D7870(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 432))();
}

unsigned int *sub_1CD6D789C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t result = sub_1CD6D904C((uint64_t)&v7, (void *)(a1 + 56), a2, HIDWORD(a2));
  uint64_t v5 = v7;
  if (v8)
  {
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v5;
  }
  else
  {
    switch(*(unsigned char *)(v7 + 12) & 0xF)
    {
      case 0:
        *(unsigned char *)(a3 + 8) &= ~1u;
        *(_DWORD *)a3 = 0;
        return result;
      case 1:
      case 5:
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v6 = 2;
        goto LABEL_4;
      case 2:
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v6 = 5;
        goto LABEL_4;
      case 3:
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v6 = 3;
        goto LABEL_4;
      case 4:
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v6 = 4;
        goto LABEL_4;
      default:
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v6 = 1;
LABEL_4:
        *(_DWORD *)a3 = v6;
        break;
    }
  }
  return result;
}

unsigned int *sub_1CD6D79CC@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3 = a2;
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  int v6 = a1 + 7;
  uint64_t result = sub_1CD6D904C((uint64_t)&v12, a1 + 7, a2, HIDWORD(a2));
  if (v13)
  {
    uint64_t v8 = (uint64_t)v12;
    *(unsigned char *)(a3 + 16) |= 1u;
    *(void *)a3 = v8;
  }
  else
  {
    uint64_t result = (unsigned int *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSection(v6, v3, (uint64_t)&v10);
    if (v11)
    {
      uint64_t v9 = v10;
      *(unsigned char *)(a3 + 16) |= 1u;
      *(void *)a3 = v9;
    }
    else
    {
      uint64_t result = (unsigned int *)sub_1CD6D93DC(a3, a1, (uint64_t)v12, v10);
      if (v11)
      {
        uint64_t result = v10;
        int v10 = 0;
        if (result) {
          uint64_t result = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 8))(result);
        }
      }
    }
    if (v13)
    {
      uint64_t result = v12;
      uint64_t v12 = 0;
      if (result) {
        return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 8))(result);
      }
    }
  }
  return result;
}

void sub_1CD6D7B1C(uint64_t a1, void *a2)
{
  *a2 += 40;
}

void sub_1CD6D7B2C(uint64_t a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3 = sub_1CCC487E0;
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSectionName((void *)(a1 + 56), a2, (void (*)(uint64_t *__return_ptr, uint64_t, void *))sub_1CD6D6140, (uint64_t)&v3, a3);
}

uint64_t sub_1CD6D7B74(uint64_t a1, uint64_t a2)
{
  return *(unsigned int *)(a2 + 12);
}

unint64_t sub_1CD6D7B7C(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::sections((void *)(a1 + 56), (uint64_t)&v7);
  if (v8)
  {
    unsigned int v3 = v7;
    uint64_t v7 = 0;
  }
  else
  {
    unsigned int v3 = 0;
  }
  int v6 = v3;
  sub_1CCC4886C(&v6);
  if (v6) {
    (*(void (**)(void *))(*v6 + 8))(v6);
  }
  uint64_t v4 = v7;
  if (v8)
  {
    uint64_t v7 = 0;
    if (v4) {
      (*(void (**)(void *))(*v4 + 8))(v4);
    }
  }
  return 0xCCCCCCCCCCCCCCCDLL * ((a2 - (uint64_t)v4) >> 3);
}

uint64_t sub_1CD6D7C7C(uint64_t a1, uint64_t a2)
{
  return *(unsigned int *)(a2 + 20);
}

__n128 *sub_1CD6D7C84@<X0>(__n128 *this@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3 = this;
  if (a2[1] == 8)
  {
    unint64_t v5 = this[1].n128_u64[0];
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(void *)a3 = v5;
    *(void *)(a3 + 8) = 0;
  }
  else
  {
    llvm::object::Binary::getMemoryBufferRef(this, v10);
    this = (__n128 *)sub_1CCC207AC((llvm::object *)v10, a2[4] + v3[1].n128_u64[0], a2[5], &v11);
    uint64_t v7 = v11;
    if (v11)
    {
      *(unsigned char *)(a3 + 16) |= 1u;
      *(void *)a3 = v7;
    }
    else
    {
      uint64_t v8 = a2[5];
      unint64_t v9 = v3[1].n128_u64[0] + a2[4];
      *(unsigned char *)(a3 + 16) &= ~1u;
      *(void *)a3 = v9;
      *(void *)(a3 + 8) = v8;
    }
  }
  return this;
}

uint64_t sub_1CD6D7D3C(uint64_t a1, uint64_t a2)
{
  return *(unsigned int *)(a2 + 32);
}

uint64_t sub_1CD6D7D44(uint64_t a1, uint64_t a2)
{
  return (*(unsigned __int8 *)(a2 + 9) >> 3) & 1;
}

uint64_t sub_1CD6D7D50(uint64_t a1, uint64_t a2)
{
  return (*(unsigned __int8 *)(a2 + 8) >> 2) & 1;
}

BOOL sub_1CD6D7D5C(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 4) != 1) {
    return 0;
  }
  if ((*(_DWORD *)(a2 + 8) & 2) != 0) {
    return (*(_DWORD *)(a2 + 8) & 4) == 0;
  }
  return 0;
}

BOOL sub_1CD6D7D88(uint64_t a1, uint64_t a2)
{
  return (*(unsigned char *)(a2 + 8) & 3) != 0 && *(_DWORD *)(a2 + 4) == 8;
}

BOOL sub_1CD6D7DAC(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 4) == 8;
}

BOOL sub_1CD6D7DBC(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 8);
  BOOL v3 = (v2 & 4) != 0 || (*(_DWORD *)(a2 + 8) & 1) == 0;
  return (v2 & 2) != 0 && v3;
}

uint64_t sub_1CD6D7DE0(uint64_t a1, uint64_t a2)
{
  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 240))(a1) & 1) != 0 || *(_DWORD *)(a2 + 4) == 8) {
    return 0;
  }
  else {
    return (*(unsigned __int8 *)(a2 + 8) >> 1) & 1;
  }
}

uint64_t sub_1CD6D7E44(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::sections((void *)(a1 + 56), (uint64_t)&v5);
  uint64_t result = v5;
  if ((v6 & 1) == 0) {
    return ((a2 - v5) / (unint64_t)*(unsigned __int16 *)(*(void *)(a1 + 56) + 46));
  }
  uint64_t v5 = 0;
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 8))(result);
    return 0;
  }
  return result;
}

unint64_t sub_1CD6D7F0C(void *a1, _DWORD *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (*(uint64_t (**)(void *))(*a1 + 264))(a1);
  int v5 = a2[1];
  if (v5 == 4 || v5 == 9)
  {
    uint64_t v8 = sub_1CD6D9704((uint64_t)a1, v4);
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSection(a1 + 7, *((_DWORD *)v8 + 6), (uint64_t)&v16);
    if (v17)
    {
      unint64_t v9 = v16;
      char v16 = 0;
      uint64_t v11 = v9;
      *(void *)&v12.__val_ = llvm::errorToErrorCode(&v11);
      v12.__cat_ = v10;
      std::error_code::message(&v13, &v12);
      __int16 v15 = 260;
      uint64_t v14 = &v13;
      llvm::report_fatal_error((llvm *)&v14, (const llvm::Twine *)1);
    }
    return v4 | ((unint64_t)(a2[5] / a2[9] + HIDWORD(v4)) << 32);
  }
  return v4;
}

uint64_t sub_1CD6D8038@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  int v5 = *(_DWORD *)(a2 + 4);
  if (v5 == 4 || v5 == 9)
  {
    uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSection(a1 + 7, *(_DWORD *)(a2 + 28), (uint64_t)&v10);
    uint64_t v9 = v10;
    if (v11)
    {
      *(unsigned char *)(a3 + 16) |= 1u;
    }
    else
    {
      *(unsigned char *)(a3 + 16) &= ~1u;
      *(void *)(a3 + 8) = a1;
    }
    *(void *)a3 = v9;
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(void *))(*a1 + 352))(a1);
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(void *)a3 = result;
    *(void *)(a3 + 8) = v8;
  }
  return result;
}

void sub_1CD6D8124(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1CD6D8134(uint64_t a1, uint64_t a2)
{
  if (*((_DWORD *)sub_1CD6D9704(a1, a2) + 1) == 9) {
    uint64_t v4 = sub_1CD6D97AC(a1, a2);
  }
  else {
    uint64_t v4 = sub_1CD6D9858(a1, a2);
  }
  return *(unsigned int *)v4;
}

unint64_t sub_1CD6D8180(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1CD6D9704(a1, a2);
  if (*((_DWORD *)v4 + 1) == 9) {
    int v5 = sub_1CD6D97AC(a1, a2);
  }
  else {
    int v5 = sub_1CD6D9858(a1, a2);
  }
  unsigned int v6 = *((_DWORD *)v5 + 1);
  if (v6 > 0xFF) {
    return *((unsigned int *)v4 + 6) | ((unint64_t)(v6 >> 8) << 32);
  }
  else {
    return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
  }
}

uint64_t sub_1CD6D8220(uint64_t a1, uint64_t a2)
{
  if (*((_DWORD *)sub_1CD6D9704(a1, a2) + 1) == 9) {
    uint64_t v4 = sub_1CD6D97AC(a1, a2);
  }
  else {
    uint64_t v4 = sub_1CD6D9858(a1, a2);
  }
  return v4[4];
}

void *sub_1CD6D826C(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t v4 = a1 + 7;
  unsigned int v5 = (*(uint64_t (**)(uint64_t *))(*a1 + 312))(a1);

  return llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getRelocationTypeName(v4, v5, a3);
}

void sub_1CD6D82D8(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  long long __p = 0;
  uint64_t v18 = 0;
  unint64_t v19 = 0;
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::sections((void *)(a1 + 56), (uint64_t)&v20);
  if ((v22 & 1) == 0 && v21)
  {
    uint64_t v4 = 0;
    uint64_t v5 = v20;
    uint64_t v6 = v20 + 40 * v21;
    do
    {
      if (*(_DWORD *)(v5 + 4) == 6)
      {
        uint64_t v7 = (int *)(*(unsigned int *)(v5 + 16) + *(void *)(a1 + 16));
        int v8 = *v7;
        if (*v7)
        {
          uint64_t v9 = v7 + 2;
          do
          {
            if (v8 == 17 || v8 == 7 || v8 == 23)
            {
              uint64_t v10 = *(v9 - 1);
              if ((unint64_t)v4 >= v19)
              {
                uint64_t v4 = sub_1CC9C7F0C((char **)&__p, v10);
              }
              else
              {
                *(void *)uint64_t v4 = v10;
                v4 += 8;
              }
              uint64_t v18 = v4;
            }
            int v11 = *v9;
            v9 += 2;
            int v8 = v11;
          }
          while (v11);
        }
      }
      v5 += 40;
    }
    while (v5 != v6);
    if (v21)
    {
      uint64_t v12 = 0;
      uint64_t v13 = v20;
      uint64_t v14 = v20 + 40 * v21;
      do
      {
        __int16 v15 = (char *)__p;
        if (__p != v18)
        {
          while (*(void *)v15 != *(_DWORD *)(v13 + 12))
          {
            v15 += 8;
            if (v15 == v18)
            {
              __int16 v15 = v18;
              break;
            }
          }
        }
        if (v15 != v18)
        {
          if ((unint64_t)v12 >= *(void *)(a2 + 16))
          {
            uint64_t v12 = sub_1CCC488E4((char **)a2, v13, a1);
          }
          else
          {
            *(void *)uint64_t v12 = v13;
            *((void *)v12 + 1) = a1;
            v12 += 16;
          }
          *(void *)(a2 + 8) = v12;
        }
        v13 += 40;
      }
      while (v13 != v14);
    }
  }
  if (v22)
  {
    uint64_t v16 = v20;
    uint64_t v20 = 0;
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
    }
  }
  if (__p) {
    operator delete(__p);
  }
}

uint64_t sub_1CD6D84B4(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::sections((void *)(a1 + 56), (uint64_t)&v2);
  uint64_t result = v2;
  if (v3)
  {
    uint64_t v2 = 0;
    if (result)
    {
      (*(void (**)(uint64_t))(*(void *)result + 8))(result);
      return 0;
    }
  }
  return result;
}

uint64_t sub_1CD6D8564(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::sections((void *)(a1 + 56), (uint64_t)v2);
  uint64_t result = v2[0];
  if ((v3 & 1) == 0) {
    return v2[0] + 40 * v2[1];
  }
  v2[0] = 0;
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 8))(result);
    return 0;
  }
  return result;
}

uint64_t sub_1CD6D8620()
{
  return 4;
}

const char *sub_1CD6D8628(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  int v2 = *(unsigned __int8 *)(v1 + 4);
  if (v2 == 2)
  {
    int v5 = *(unsigned __int16 *)(v1 + 18);
    if (v5 > 182)
    {
      if (v5 > 246)
      {
        switch(v5)
        {
          case 247:
            return "elf64-bpf";
          case 251:
            return "elf64-ve";
          case 258:
            return "elf64-loongarch";
        }
      }
      else
      {
        switch(v5)
        {
          case 183:
            return "elf64-littleaarch64";
          case 224:
            return "elf64-amdgpu";
          case 243:
            return "elf64-littleriscv";
        }
      }
    }
    else if (v5 > 21)
    {
      switch(v5)
      {
        case 22:
          return "elf64-s390";
        case 43:
          return "elf64-sparc";
        case 62:
          return "elf64-x86-64";
      }
    }
    else
    {
      switch(v5)
      {
        case 3:
          return "elf64-i386";
        case 8:
          return "elf64-mips";
        case 21:
          return "elf64-powerpcle";
      }
    }
    return "elf64-unknown";
  }
  else
  {
    if (v2 != 1) {
      llvm::report_fatal_error((llvm *)"Invalid ELFCLASS!", (const llvm::Twine *)1);
    }
    int v3 = *(unsigned __int16 *)(v1 + 18);
    if (v3 > 61)
    {
      if (v3 <= 223)
      {
        if (v3 > 104)
        {
          if (v3 == 105) {
            return "elf32-msp430";
          }
          if (v3 == 164) {
            return "elf32-hexagon";
          }
        }
        else
        {
          if (v3 == 62) {
            return "elf32-x86-64";
          }
          if (v3 == 83) {
            return "elf32-avr";
          }
        }
      }
      else if (v3 <= 243)
      {
        if (v3 == 224) {
          return "elf32-amdgpu";
        }
        if (v3 == 243) {
          return "elf32-littleriscv";
        }
      }
      else
      {
        switch(v3)
        {
          case 244:
            return "elf32-lanai";
          case 252:
            return "elf32-csky";
          case 258:
            return "elf32-loongarch";
        }
      }
      return "elf32-unknown";
    }
    if (v3 > 17)
    {
      if (v3 != 18)
      {
        if (v3 == 20) {
          return "elf32-powerpcle";
        }
        if (v3 == 40) {
          return "elf32-littlearm";
        }
        return "elf32-unknown";
      }
      return "elf32-sparc";
    }
    else
    {
      uint64_t result = "elf32-m68k";
      switch(v3)
      {
        case 2:
          return "elf32-sparc";
        case 3:
          uint64_t result = "elf32-i386";
          break;
        case 4:
          return result;
        case 6:
          uint64_t result = "elf32-iamcu";
          break;
        case 8:
          uint64_t result = "elf32-mips";
          break;
        default:
          return "elf32-unknown";
      }
    }
  }
  return result;
}

uint64_t sub_1CD6D8920(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  unsigned int v2 = *(unsigned __int16 *)(v1 + 18);
  if (v2 <= 0x3D)
  {
    uint64_t result = 15;
    switch(*(_WORD *)(v1 + 18))
    {
      case 2:
      case 0x12:
        return 35;
      case 3:
      case 6:
        return 41;
      case 4:
        return result;
      case 5:
      case 7:
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
      case 0xD:
      case 0xE:
      case 0xF:
      case 0x10:
      case 0x11:
      case 0x13:
        return 0;
      case 8:
        int v6 = *(unsigned __int8 *)(v1 + 4);
        if (v6 == 1)
        {
          uint64_t result = 17;
        }
        else
        {
          if (v6 != 2) {
            goto LABEL_51;
          }
          uint64_t result = 19;
        }
        break;
      case 0x14:
        return 22;
      case 0x15:
        return 24;
      case 0x16:
        return 36;
      default:
        if (v2 == 40) {
          return 1;
        }
        if (v2 != 43) {
          return 0;
        }
        return 34;
    }
  }
  else
  {
    if (*(unsigned __int16 *)(v1 + 18) <= 0xDFu)
    {
      if (*(unsigned __int16 *)(v1 + 18) <= 0x68u)
      {
        if (v2 == 62) {
          return 42;
        }
        if (v2 == 83) {
          return 7;
        }
      }
      else
      {
        switch(v2)
        {
          case 0x69u:
            return 20;
          case 0xA4u:
            return 12;
          case 0xB7u:
            return 3;
        }
      }
      return 0;
    }
    switch(*(_WORD *)(v1 + 18))
    {
      case 0xF3:
        int v4 = *(unsigned __int8 *)(v1 + 4);
        if (v4 != 1)
        {
          if (v4 == 2) {
            return 32;
          }
          goto LABEL_51;
        }
        uint64_t result = 31;
        break;
      case 0xF4:
        return 62;
      case 0xF5:
      case 0xF6:
      case 0xF8:
      case 0xF9:
      case 0xFA:
        return 0;
      case 0xF7:
        return 8;
      case 0xFB:
        return 67;
      case 0xFC:
        return 10;
      default:
        if (v2 == 224)
        {
          int v7 = *(unsigned __int8 *)(v1 + 36);
          unsigned int v8 = v7 - 1;
          if ((v7 - 32) >= 0x26) {
            unsigned int v9 = 0;
          }
          else {
            unsigned int v9 = 30;
          }
          if (v8 >= 0x10) {
            uint64_t result = v9;
          }
          else {
            uint64_t result = 25;
          }
        }
        else
        {
          if (v2 != 258) {
            return 0;
          }
          int v5 = *(unsigned __int8 *)(v1 + 4);
          if (v5 != 1)
          {
            if (v5 == 2) {
              return 14;
            }
LABEL_51:
            llvm::report_fatal_error((llvm *)"Invalid ELFCLASS!", (const llvm::Twine *)1);
          }
          uint64_t result = 13;
        }
        break;
    }
  }
  return result;
}

uint64_t sub_1CD6D8B20@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 56);
  *(unsigned char *)(a2 + 8) &= ~1u;
  *(void *)a2 = *(unsigned int *)(v2 + 24);
  return result;
}

BOOL sub_1CD6D8B3C(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(a1 + 56) + 16) == 1;
}

uint64_t sub_1CD6D8B50(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  sub_1CD6D904C((uint64_t)&v4, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v5)
  {
    uint64_t v3 = v4;
    uint64_t v4 = 0;
    llvm::report_fatal_error(&v3);
  }
  return *(unsigned int *)(v4 + 8);
}

uint64_t sub_1CD6D8BD0(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  sub_1CD6D904C((uint64_t)&v4, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v5)
  {
    uint64_t v3 = v4;
    uint64_t v4 = 0;
    llvm::report_fatal_error(&v3);
  }
  return *(unsigned __int8 *)(v4 + 12) >> 4;
}

uint64_t sub_1CD6D8C54(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  sub_1CD6D904C((uint64_t)&v4, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v5)
  {
    uint64_t v3 = v4;
    uint64_t v4 = 0;
    llvm::report_fatal_error(&v3);
  }
  return *(unsigned __int8 *)(v4 + 13);
}

uint64_t sub_1CD6D8CD4(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  sub_1CD6D904C((uint64_t)&v4, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v5)
  {
    uint64_t v3 = v4;
    uint64_t v4 = 0;
    llvm::report_fatal_error(&v3);
  }
  return *(unsigned char *)(v4 + 12) & 0xF;
}

uint64_t sub_1CD6D8D58(uint64_t a1, uint64_t a2)
{
  return *(unsigned int *)(a2 + 4);
}

uint64_t sub_1CD6D8D60(uint64_t a1, uint64_t a2)
{
  return *(unsigned int *)(a2 + 8);
}

uint64_t sub_1CD6D8D68(uint64_t a1, uint64_t a2)
{
  return *(unsigned int *)(a2 + 16);
}

char *sub_1CD6D8D70@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (*((_DWORD *)sub_1CD6D9704(a1, a2) + 1) != 4)
  {
    unsigned int v8 = "Section is not SHT_RELA";
    __int16 v9 = 259;
    operator new();
  }
  uint64_t result = sub_1CD6D9858(a1, a2);
  uint64_t v7 = *((int *)result + 2);
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(void *)a3 = v7;
  return result;
}

void *sub_1CD6D8E54@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  char v5 = (void *)(a1 + 56);
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::sections((void *)(a1 + 56), (uint64_t)&v16);
  if (v18)
  {
    uint64_t v9 = v16;
    uint64_t v16 = 0;
    *a3 = v9;
    goto LABEL_8;
  }
  if (!v17)
  {
LABEL_6:
    *a3 = 0;
    goto LABEL_8;
  }
  uint64_t v7 = (_DWORD *)(v16 + 4);
  uint64_t v8 = 40 * v17;
  while (*v7 != 1879048195)
  {
    v7 += 10;
    v8 -= 40;
    if (!v8) {
      goto LABEL_6;
    }
  }
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSectionContents(v5, (uint64_t)(v7 - 1), (uint64_t)&v13);
  uint64_t v10 = v13;
  if (v15) {
    goto LABEL_19;
  }
  if (*v13 != 65 || v14 == 1)
  {
    uint64_t v10 = 0;
LABEL_19:
    *a3 = (uint64_t)v10;
    goto LABEL_8;
  }
  uint64_t result = llvm::ELFAttributeParser::parse(a2, (uint64_t)v13, v14, 1, a3);
  uint64_t v12 = *a3;
  if (v15)
  {
    uint64_t result = v13;
    uint64_t v13 = 0;
    if (result) {
      uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  if (!v12) {
    goto LABEL_6;
  }
LABEL_8:
  if (v18)
  {
    uint64_t result = (void *)v16;
    uint64_t v16 = 0;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  return result;
}

unint64_t sub_1CD6D8FE0@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X8>)
{
  unint64_t v4 = sub_1CD6D9ED4(a1);
  unint64_t v6 = v5;
  unint64_t result = sub_1CD6D9F24(a1);
  *a2 = v4;
  a2[1] = v6;
  a2[2] = result;
  a2[3] = v8;
  return result;
}

uint64_t sub_1CD6D9028(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 56) + 36);
}

uint64_t sub_1CD6D9034(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(a1 + 56) + 16);
}

uint64_t sub_1CD6D9040(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(a1 + 56) + 18);
}

unsigned int *sub_1CD6D904C(uint64_t a1, void *a2, unsigned int a3, unsigned int a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t result = (unsigned int *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSection(a2, a3, (uint64_t)&v9);
  unint64_t v8 = v9;
  if (v10)
  {
    *(unsigned char *)(a1 + 8) |= 1u;
    *(void *)a1 = v8;
  }
  else
  {
    unint64_t result = (unsigned int *)sub_1CD6CAE48(a2, v9, a4, a1);
    if (v10)
    {
      unint64_t result = v9;
      uint64_t v9 = 0;
      if (result) {
        return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 8))(result);
      }
    }
  }
  return result;
}

unint64_t sub_1CD6D9128(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::sections((void *)(a1 + 56), (uint64_t)&v7);
    unint64_t v5 = v7;
    if (v8)
    {
      unint64_t v7 = 0;
      if (v5)
      {
        (*(void (**)(unint64_t))(*(void *)v5 + 8))(v5);
        LODWORD(v5) = 0;
      }
      a3 = 0;
    }
    else
    {
      unint64_t v5 = (a2 - v7) / 0x28;
    }
  }
  else
  {
    a3 = 0;
    LODWORD(v5) = 0;
  }
  return v5 | ((unint64_t)a3 << 32);
}

size_t sub_1CD6D91F8(uint64_t a1, int *a2, uint64_t a3, unint64_t a4)
{
  unsigned int v10 = *a2;
  if (a4 <= v10)
  {
    atomic_ullong v8 = llvm::object::object_category((llvm::object *)a1);
    unint64_t v9 = a4;
    sub_1CD6D929C(3, v8, (uint64_t)"st_name (0x%x) is past the end of the string table of size 0x%zx", (int *)&v10, (uint64_t *)&v9);
  }
  uint64_t v5 = a3 + v10;
  if (a3) {
    size_t result = strlen((const char *)(a3 + v10));
  }
  else {
    size_t result = 0;
  }
  *(unsigned char *)(a1 + 16) &= ~1u;
  *(void *)a1 = v5;
  *(void *)(a1 + 8) = result;
  return result;
}

void sub_1CD6D929C(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, uint64_t *a5)
{
  memset(__p, 0, sizeof(__p));
  int v8 = 0;
  char v12 = 0;
  uint64_t v13 = 0;
  char v15 = __p;
  int v14 = 0;
  unint64_t v7 = &unk_1F2646F30;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  int v5 = *a4;
  uint64_t v6 = *a5;
  v17[0] = &unk_1F26088A8;
  v17[1] = a3;
  int v18 = v5;
  uint64_t v19 = v6;
  llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v7, (uint64_t)v17);
  operator new();
}

uint64_t sub_1CD6D93DC(uint64_t a1, void *a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  int v8 = (unsigned int *)a2[11];
  if (v8)
  {
    uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSHNDXTable(a2 + 7, v8, (uint64_t)&v16);
    uint64_t v9 = v16;
    if (v18) {
      goto LABEL_7;
    }
    uint64_t v10 = v17;
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
  }
  *(void *)&long long v13 = v9;
  *((void *)&v13 + 1) = v10;
  char v14 = 1;
  uint64_t v15 = 0;
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSection(a2 + 7, a3, a4, &v13, (uint64_t)&v16);
  uint64_t v9 = v16;
  if (v17)
  {
LABEL_7:
    *(unsigned char *)(a1 + 16) |= 1u;
    *(void *)a1 = v9;
    return result;
  }
  if (v16)
  {
    *(unsigned char *)(a1 + 16) &= ~1u;
    *(void *)a1 = v9;
    *(void *)(a1 + 8) = a2;
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(void *))(*a2 + 352))(a2);
    *(unsigned char *)(a1 + 16) &= ~1u;
    *(void *)a1 = result;
    *(void *)(a1 + 8) = v12;
    if (v17)
    {
      uint64_t result = v16;
      uint64_t v16 = 0;
      if (result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
    }
  }
  return result;
}

void *sub_1CD6D954C(void *result, void **a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *a2;
  if (*a2)
  {
    *a2 = 0;
    if ((*(unsigned int (**)(void *, void *))(*v3 + 48))(v3, &llvm::ErrorList::ID))
    {
      *uint64_t v2 = 0;
      unint64_t v4 = (char **)v3[1];
      int v5 = (char **)v3[2];
      if (v4 != v5)
      {
        uint64_t v6 = 0;
        do
        {
          uint64_t v9 = v6;
          unint64_t v7 = *v4;
          *unint64_t v4 = 0;
          (*(void (**)(char *, void *))(*(void *)v7 + 48))(v7, &llvm::ErrorInfoBase::ID);
          int v8 = v7;
          sub_1CD451630(&v9, &v8, &v10);
          uint64_t v6 = v10;
          *uint64_t v2 = v10;
          uint64_t v10 = 0;
          if (v8) {
            (*(void (**)(char *))(*(void *)v8 + 8))(v8);
          }
          if (v9) {
            (*(void (**)(char *))(*(void *)v9 + 8))(v9);
          }
          ++v4;
        }
        while (v4 != v5);
      }
      return (void *)(*(uint64_t (**)(void *))(*v3 + 8))(v3);
    }
    else
    {
      uint64_t result = (void *)(*(uint64_t (**)(void *, void *))(*v3 + 48))(v3, &llvm::ErrorInfoBase::ID);
      *uint64_t v2 = v3;
    }
  }
  else
  {
    unsigned int *result = 0;
  }
  return result;
}

char *sub_1CD6D9704(uint64_t a1, unsigned int a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSection((void *)(a1 + 56), a2, (uint64_t)&v10);
  if (v11)
  {
    uint64_t v3 = v10;
    uint64_t v10 = 0;
    int v5 = v3;
    *(void *)&v6.__val_ = llvm::errorToErrorCode(&v5);
    v6.__cat_ = v4;
    std::error_code::message(&v7, &v6);
    __int16 v9 = 260;
    int v8 = &v7;
    llvm::report_fatal_error((llvm *)&v8, (const llvm::Twine *)1);
  }
  return v10;
}

char *sub_1CD6D97AC(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  sub_1CD6D9904((uint64_t)&v9, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v10)
  {
    unint64_t v4 = v9;
    *(void *)&v5.__val_ = llvm::errorToErrorCode(&v4);
    v5.__cat_ = v3;
    std::error_code::message(&v6, &v5);
    __int16 v8 = 260;
    std::string v7 = &v6;
    llvm::report_fatal_error((llvm *)&v7, (const llvm::Twine *)1);
  }
  return v9;
}

char *sub_1CD6D9858(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  sub_1CD6D9BE8((uint64_t)&v9, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v10)
  {
    unint64_t v4 = v9;
    *(void *)&v5.__val_ = llvm::errorToErrorCode(&v4);
    v5.__cat_ = v3;
    std::error_code::message(&v6, &v5);
    __int16 v8 = 260;
    std::string v7 = &v6;
    llvm::report_fatal_error((llvm *)&v7, (const llvm::Twine *)1);
  }
  return v9;
}

unsigned int *sub_1CD6D9904(uint64_t a1, void *a2, unsigned int a3, unsigned int a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t result = (unsigned int *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSection(a2, a3, (uint64_t)&v9);
  __int16 v8 = v9;
  if (v10)
  {
    *(unsigned char *)(a1 + 8) |= 1u;
    *(void *)a1 = v8;
  }
  else
  {
    uint64_t result = (unsigned int *)sub_1CD6D99E0(a1, a2, v9, a4);
    if (v10)
    {
      uint64_t result = v9;
      __int16 v9 = 0;
      if (result) {
        return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 8))(result);
      }
    }
  }
  return result;
}

void *sub_1CD6D99E0(uint64_t a1, void *a2, unsigned int *a3, unsigned int a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::rels(a2, a3, (uint64_t)v26);
  if (v27)
  {
    uint64_t v8 = v26[0];
    char v9 = *(unsigned char *)(a1 + 8) | 1;
  }
  else
  {
    if (v26[1] <= (unint64_t)a4)
    {
      uint64_t v20 = "can't read an entry at 0x";
      __int16 v21 = 259;
      uint64_t v17 = 8 * a4;
      v18[0] = (uint64_t)&v17;
      void v18[2] = 0;
      __int16 v19 = 270;
      sub_1CB8F1E58((uint64_t *)&v20, v18, (uint64_t)v22);
      uint64_t v15 = ": it goes past the end of the section (0x";
      __int16 v16 = 259;
      sub_1CB8F1E58(v22, (uint64_t *)&v15, (uint64_t)v23);
      uint64_t v12 = a3[5];
      v13[0] = (uint64_t)&v12;
      void v13[2] = 0;
      __int16 v14 = 270;
      sub_1CB8F1E58(v23, v13, (uint64_t)v24);
      char v10 = ")";
      __int16 v11 = 259;
      sub_1CB8F1E58(v24, (uint64_t *)&v10, (uint64_t)v25);
      operator new();
    }
    uint64_t v8 = v26[0] + 8 * a4;
    char v9 = *(unsigned char *)(a1 + 8) & 0xFE;
  }
  *(unsigned char *)(a1 + 8) = v9;
  *(void *)a1 = v8;
  return result;
}

unsigned int *sub_1CD6D9BE8(uint64_t a1, void *a2, unsigned int a3, unsigned int a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t result = (unsigned int *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSection(a2, a3, (uint64_t)&v9);
  uint64_t v8 = v9;
  if (v10)
  {
    *(unsigned char *)(a1 + 8) |= 1u;
    *(void *)a1 = v8;
  }
  else
  {
    uint64_t result = (unsigned int *)sub_1CD6D9CC4(a1, a2, v9, a4);
    if (v10)
    {
      uint64_t result = v9;
      char v9 = 0;
      if (result) {
        return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 8))(result);
      }
    }
  }
  return result;
}

void *sub_1CD6D9CC4(uint64_t a1, void *a2, unsigned int *a3, unsigned int a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::relas(a2, a3, (uint64_t)v26);
  if (v27)
  {
    uint64_t v8 = v26[0];
    char v9 = *(unsigned char *)(a1 + 8) | 1;
  }
  else
  {
    if (v26[1] <= (unint64_t)a4)
    {
      uint64_t v20 = "can't read an entry at 0x";
      __int16 v21 = 259;
      uint64_t v17 = 12 * a4;
      v18[0] = (uint64_t)&v17;
      void v18[2] = 0;
      __int16 v19 = 270;
      sub_1CB8F1E58((uint64_t *)&v20, v18, (uint64_t)v22);
      uint64_t v15 = ": it goes past the end of the section (0x";
      __int16 v16 = 259;
      sub_1CB8F1E58(v22, (uint64_t *)&v15, (uint64_t)v23);
      uint64_t v12 = a3[5];
      v13[0] = (uint64_t)&v12;
      void v13[2] = 0;
      __int16 v14 = 270;
      sub_1CB8F1E58(v23, v13, (uint64_t)v24);
      char v10 = ")";
      __int16 v11 = 259;
      sub_1CB8F1E58(v24, (uint64_t *)&v10, (uint64_t)v25);
      operator new();
    }
    uint64_t v8 = v26[0] + 12 * a4;
    char v9 = *(unsigned char *)(a1 + 8) & 0xFE;
  }
  *(unsigned char *)(a1 + 8) = v9;
  *(void *)a1 = v8;
  return result;
}

unint64_t sub_1CD6D9ED4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 72);
  unsigned int v2 = v1 && *(_DWORD *)(v1 + 20) > 0xFu;
  return sub_1CD6D9128(a1, v1, v2);
}

unint64_t sub_1CD6D9F24(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 72);
  if (v1) {
    return sub_1CD6D9128(a1, v1, *(_DWORD *)(v1 + 20) >> 4);
  }
  else {
    return sub_1CD6D9ED4(a1);
  }
}

void sub_1CD6D9F70(uint64_t a1, long long *a2, int a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::create(*(void *)a2, *((void *)a2 + 1), (uint64_t)&v23);
  if (v25)
  {
    uint64_t v6 = v23;
    uint64_t v23 = 0;
    if (v6)
    {
      *(unsigned char *)(a1 + 104) |= 1u;
      *(void *)a1 = v6;
      return;
    }
  }
  else
  {
    uint64_t v6 = v23;
  }
  long long v7 = a2[1];
  long long v17 = *a2;
  long long v18 = v7;
  uint64_t v8 = v24;
  int v16 = 13;
  uint64_t v15 = &unk_1F2632EF0;
  char v19 = 0;
  uint64_t v20 = v6;
  uint64_t v21 = v24;
  memset(v22, 0, 24);
  long long v9 = 0uLL;
  if (!a3)
  {
    uint64_t v10 = 0;
LABEL_5:
    *(unsigned char *)(a1 + 104) &= ~1u;
    *(_DWORD *)(a1 + 8) = 13;
    long long v11 = v18;
    *(_OWORD *)(a1 + 16) = v17;
    *(_OWORD *)(a1 + 32) = v11;
    *(void *)a1 = &unk_1F2632EF0;
    *(unsigned char *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = v6;
    *(void *)(a1 + 64) = v8;
    *(_OWORD *)(a1 + 72) = v9;
    *(void *)(a1 + 88) = v10;
    goto LABEL_6;
  }
  sub_1CD6DA120((uint64_t)&v15, &v14);
  uint64_t v13 = v14;
  if (!v14)
  {
    uint64_t v6 = v20;
    uint64_t v8 = v21;
    long long v9 = v22[0];
    uint64_t v10 = *(void *)&v22[1];
    goto LABEL_5;
  }
  *(unsigned char *)(a1 + 104) |= 1u;
  *(void *)a1 = v13;
LABEL_6:
  llvm::object::SymbolicFile::~SymbolicFile((llvm::object::SymbolicFile *)&v15);
  if (v25)
  {
    uint64_t v12 = v23;
    uint64_t v23 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
}

void *sub_1CD6DA120@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::sections((void *)(a1 + 56), (uint64_t)&v10);
  uint64_t v5 = v10;
  if ((v12 & 1) == 0)
  {
    if (v11)
    {
      uint64_t v6 = 40 * v11;
      long long v7 = (unsigned int *)(v10 + 4);
      while (1)
      {
        unsigned int v8 = bswap32(*v7);
        if (v8 == 2) {
          break;
        }
        if (v8 != 18)
        {
          if (v8 != 11) {
            goto LABEL_11;
          }
          long long v9 = (void *)(a1 + 72);
          if (*(void *)(a1 + 72)) {
            goto LABEL_11;
          }
LABEL_10:
          *long long v9 = v7 - 1;
          goto LABEL_11;
        }
        long long v9 = (void *)(a1 + 88);
        if (!*(void *)(a1 + 88)) {
          goto LABEL_10;
        }
LABEL_11:
        v7 += 10;
        v6 -= 40;
        if (!v6) {
          goto LABEL_15;
        }
      }
      long long v9 = (void *)(a1 + 80);
      if (*(void *)(a1 + 80)) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
LABEL_15:
    uint64_t v5 = 0;
    *(unsigned char *)(a1 + 48) = 1;
  }
  *a2 = v5;
  return result;
}

void sub_1CD6DA228(llvm::object::SymbolicFile *a1)
{
  llvm::object::SymbolicFile::~SymbolicFile(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD6DA260(uint64_t a1, uint64_t a2)
{
}

unint64_t sub_1CD6DA270(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 80);
  if (v1) {
    unsigned int v2 = bswap32(*(_DWORD *)(v1 + 20)) > 0xF;
  }
  else {
    unsigned int v2 = 0;
  }
  return sub_1CD6DC478(a1, v1, v2);
}

unint64_t sub_1CD6DA2BC(void *a1)
{
  uint64_t v1 = a1[10];
  if (v1) {
    return sub_1CD6DC478((uint64_t)a1, v1, bswap32(*(_DWORD *)(v1 + 20)) >> 4);
  }
  else {
    return (*(uint64_t (**)(void *))(*a1 + 48))(a1);
  }
}

void sub_1CD6DA32C(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a1 + 7;
  sub_1CD6DC39C((uint64_t)&v31, a1 + 7, a2, HIDWORD(a2));
  if (v32)
  {
    long long v7 = v31;
    *(unsigned char *)(a3 + 16) |= 1u;
    *(void *)a3 = v7;
    return;
  }
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSection(v6, a2, (uint64_t)&v29);
  uint64_t v8 = v29;
  if ((v30 & 1) == 0)
  {
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSection(v6, bswap32(*(_DWORD *)(v29 + 24)), (uint64_t)&v27);
    uint64_t v10 = v27;
    if (v28)
    {
      uint64_t v27 = 0;
      *(unsigned char *)(a3 + 16) |= 1u;
      *(void *)a3 = v10;
LABEL_11:
      if (v30)
      {
        uint64_t v11 = v29;
        uint64_t v29 = 0;
        if (v11) {
          (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
        }
      }
      goto LABEL_6;
    }
    *(void *)&long long v23 = sub_1CCC487E0;
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getStringTable(v6, v27, (void (*)(uint64_t *__return_ptr, uint64_t, void *))sub_1CD6D6140, (uint64_t)&v23, (uint64_t)v25);
    if (v26)
    {
      uint64_t v12 = v25[0];
      v25[0] = 0;
      *(unsigned char *)(a3 + 16) |= 1u;
      *(void *)a3 = v12;
LABEL_16:
      if (v28)
      {
        uint64_t v13 = v27;
        uint64_t v27 = 0;
        if (v13) {
          (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
        }
      }
      goto LABEL_11;
    }
    sub_1CD6DC548((uint64_t)&v23, v31, v25[0], v25[1]);
    if ((v24 & 1) != 0 || !*((void *)&v23 + 1))
    {
      int v15 = v24 & 1;
      if ((v31[3] & 0xF) == 3)
      {
        (*(void (**)(uint64_t *__return_ptr, void *, uint64_t))(*a1 + 120))(&v20, a1, a2);
        if ((v22 & 1) == 0)
        {
          if (v15)
          {
            long long v17 = (void *)v23;
            *(void *)&long long v23 = 0;
          }
          else
          {
            long long v17 = 0;
          }
          char v19 = v17;
          sub_1CD4515D0(&v19);
          if (v19) {
            (*(void (**)(void *))(*v19 + 8))(v19);
          }
          (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 136))(v21, v20);
          if (v22)
          {
            uint64_t v18 = v20;
            uint64_t v20 = 0;
            if (v18) {
              (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
            }
          }
          if (v15 && (void)v23) {
            (*(void (**)(void))(*(void *)v23 + 8))(v23);
          }
          goto LABEL_23;
        }
        uint64_t v16 = v20;
        uint64_t v20 = 0;
        if (v16) {
          (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
        }
      }
      *(unsigned char *)(a3 + 16) = *(unsigned char *)(a3 + 16) & 0xFE | v15;
      if (v15)
      {
        *(void *)a3 = v23;
        goto LABEL_23;
      }
    }
    else
    {
      *(unsigned char *)(a3 + 16) &= ~1u;
    }
    *(_OWORD *)a3 = v23;
LABEL_23:
    if (v26)
    {
      uint64_t v14 = v25[0];
      v25[0] = 0;
      if (v14) {
        (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
      }
    }
    goto LABEL_16;
  }
  uint64_t v29 = 0;
  *(unsigned char *)(a3 + 16) |= 1u;
  *(void *)a3 = v8;
LABEL_6:
  if (v32)
  {
    long long v9 = v31;
    __int16 v31 = 0;
    if (v9) {
      (*(void (**)(unsigned int *))(*(void *)v9 + 8))(v9);
    }
  }
}

unsigned int *sub_1CD6DA720@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t result = (unsigned int *)llvm::object::ObjectFile::getSymbolValue(a1, a2, (uint64_t)&v25);
  if (v26)
  {
    long long v7 = v25;
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v7;
    return result;
  }
  uint64_t v8 = v25;
  uint64_t result = sub_1CD6DC39C((uint64_t)&v23, (void *)(a1 + 56), a2, HIDWORD(a2));
  uint64_t v9 = v23;
  if (v24)
  {
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v9;
  }
  else
  {
    unsigned int v10 = bswap32(*(unsigned __int16 *)(v23 + 14)) >> 16;
    if (v10 - 65521 >= 2 && v10 != 0)
    {
      uint64_t result = (unsigned int *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSection((void *)(a1 + 56), a2, (uint64_t)&v21);
      if (v22)
      {
        uint64_t v12 = v21;
        uint64_t v21 = 0;
      }
      else
      {
        if (*(_WORD *)(*(void *)(a1 + 56) + 16) != 256)
        {
LABEL_17:
          *(unsigned char *)(a3 + 8) &= ~1u;
          *(void *)a3 = v8;
          goto LABEL_20;
        }
        uint64_t v13 = *(unsigned int **)(a1 + 88);
        if (v13)
        {
          uint64_t result = (unsigned int *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSHNDXTable((void *)(a1 + 56), v13, (uint64_t)&v18);
          uint64_t v12 = v18;
          if (v20) {
            goto LABEL_19;
          }
          uint64_t v14 = v19;
        }
        else
        {
          uint64_t v12 = 0;
          uint64_t v14 = 0;
        }
        *(void *)&long long v15 = v12;
        *((void *)&v15 + 1) = v14;
        char v16 = 1;
        uint64_t v17 = 0;
        uint64_t result = (unsigned int *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSection((void *)(a1 + 56), v23, v21, &v15, (uint64_t)&v18);
        uint64_t v12 = v18;
        if ((v19 & 1) == 0)
        {
          if (v18) {
            uint64_t v8 = (unsigned int *)((char *)v8 + bswap32(v18[3]));
          }
          goto LABEL_17;
        }
      }
LABEL_19:
      *(unsigned char *)(a3 + 8) |= 1u;
      *(void *)a3 = v12;
LABEL_20:
      if (v22)
      {
        uint64_t result = v21;
        uint64_t v21 = 0;
        if (result) {
          uint64_t result = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 8))(result);
        }
      }
      if (v24)
      {
        uint64_t result = (unsigned int *)v23;
        uint64_t v23 = 0;
        if (result) {
          uint64_t result = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 8))(result);
        }
      }
      goto LABEL_12;
    }
    *(unsigned char *)(a3 + 8) &= ~1u;
    *(void *)a3 = v8;
  }
LABEL_12:
  if (v26)
  {
    uint64_t result = v25;
    char v25 = 0;
    if (result) {
      return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 8))(result);
    }
  }
  return result;
}

uint64_t sub_1CD6DA998(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1 + 56;
  sub_1CD6DC39C((uint64_t)&v6, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v7)
  {
    uint64_t v5 = v6;
    uint64_t v6 = 0;
    llvm::report_fatal_error(&v5);
  }
  uint64_t result = bswap32(*(_DWORD *)(v6 + 4));
  if (*(__int16 *)(v6 + 14) != -3585)
  {
    int v4 = *(unsigned __int16 *)(*(void *)v2 + 18);
    if ((v4 == 10240 || v4 == 2048) && (*(unsigned char *)(v6 + 12) & 0xF) == 2) {
      return result & 0xFFFFFFFE;
    }
  }
  return result;
}

uint64_t sub_1CD6DAA68(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  sub_1CD6DC39C((uint64_t)&v4, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v5)
  {
    uint64_t v3 = v4;
    uint64_t v4 = 0;
    llvm::report_fatal_error(&v3);
  }
  if (*(__int16 *)(v4 + 14) == -3329) {
    return bswap32(*(_DWORD *)(v4 + 4));
  }
  else {
    return 0;
  }
}

uint64_t sub_1CD6DAB00(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 432))();
}

unsigned int *sub_1CD6DAB2C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t result = sub_1CD6DC39C((uint64_t)&v7, (void *)(a1 + 56), a2, HIDWORD(a2));
  uint64_t v5 = v7;
  if (v8)
  {
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v5;
  }
  else
  {
    switch(*(unsigned char *)(v7 + 12) & 0xF)
    {
      case 0:
        *(unsigned char *)(a3 + 8) &= ~1u;
        *(_DWORD *)a3 = 0;
        return result;
      case 1:
      case 5:
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v6 = 2;
        goto LABEL_4;
      case 2:
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v6 = 5;
        goto LABEL_4;
      case 3:
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v6 = 3;
        goto LABEL_4;
      case 4:
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v6 = 4;
        goto LABEL_4;
      default:
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v6 = 1;
LABEL_4:
        *(_DWORD *)a3 = v6;
        break;
    }
  }
  return result;
}

unsigned int *sub_1CD6DAC5C@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3 = a2;
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  int v6 = a1 + 7;
  uint64_t result = sub_1CD6DC39C((uint64_t)&v12, a1 + 7, a2, HIDWORD(a2));
  if (v13)
  {
    uint64_t v8 = (uint64_t)v12;
    *(unsigned char *)(a3 + 16) |= 1u;
    *(void *)a3 = v8;
  }
  else
  {
    uint64_t result = (unsigned int *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSection(v6, v3, (uint64_t)&v10);
    if (v11)
    {
      uint64_t v9 = v10;
      *(unsigned char *)(a3 + 16) |= 1u;
      *(void *)a3 = v9;
    }
    else
    {
      uint64_t result = (unsigned int *)sub_1CD6DC5F0(a3, a1, (uint64_t)v12, v10);
      if (v11)
      {
        uint64_t result = v10;
        unsigned int v10 = 0;
        if (result) {
          uint64_t result = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 8))(result);
        }
      }
    }
    if (v13)
    {
      uint64_t result = v12;
      uint64_t v12 = 0;
      if (result) {
        return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 8))(result);
      }
    }
  }
  return result;
}

void sub_1CD6DADAC(uint64_t a1, void *a2)
{
  *a2 += 40;
}

void sub_1CD6DADBC(uint64_t a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3 = sub_1CCC487E0;
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSectionName((void *)(a1 + 56), a2, (void (*)(uint64_t *__return_ptr, uint64_t, void *))sub_1CD6D6140, (uint64_t)&v3, a3);
}

uint64_t sub_1CD6DAE04(uint64_t a1, uint64_t a2)
{
  return bswap32(*(_DWORD *)(a2 + 12));
}

unint64_t sub_1CD6DAE10(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::sections((void *)(a1 + 56), (uint64_t)&v7);
  if (v8)
  {
    unsigned int v3 = v7;
    uint64_t v7 = 0;
  }
  else
  {
    unsigned int v3 = 0;
  }
  int v6 = v3;
  sub_1CCC4886C(&v6);
  if (v6) {
    (*(void (**)(void *))(*v6 + 8))(v6);
  }
  uint64_t v4 = v7;
  if (v8)
  {
    uint64_t v7 = 0;
    if (v4) {
      (*(void (**)(void *))(*v4 + 8))(v4);
    }
  }
  return 0xCCCCCCCCCCCCCCCDLL * ((a2 - (uint64_t)v4) >> 3);
}

uint64_t sub_1CD6DAF10(uint64_t a1, uint64_t a2)
{
  return bswap32(*(_DWORD *)(a2 + 20));
}

__n128 *sub_1CD6DAF1C@<X0>(__n128 *this@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3 = this;
  if (a2[1] == 0x8000000)
  {
    unint64_t v5 = this[1].n128_u64[0];
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(void *)a3 = v5;
    *(void *)(a3 + 8) = 0;
  }
  else
  {
    llvm::object::Binary::getMemoryBufferRef(this, v10);
    this = (__n128 *)sub_1CCC207AC((llvm::object *)v10, bswap32(a2[4]) + v3[1].n128_u64[0], bswap32(a2[5]), &v11);
    uint64_t v7 = v11;
    if (v11)
    {
      *(unsigned char *)(a3 + 16) |= 1u;
      *(void *)a3 = v7;
    }
    else
    {
      unint64_t v8 = v3[1].n128_u64[0] + bswap32(a2[4]);
      uint64_t v9 = bswap32(a2[5]);
      *(unsigned char *)(a3 + 16) &= ~1u;
      *(void *)a3 = v8;
      *(void *)(a3 + 8) = v9;
    }
  }
  return this;
}

uint64_t sub_1CD6DAFE8(uint64_t a1, uint64_t a2)
{
  return bswap32(*(_DWORD *)(a2 + 32));
}

uint64_t sub_1CD6DAFF4(uint64_t a1, uint64_t a2)
{
  return (*(unsigned __int8 *)(a2 + 10) >> 3) & 1;
}

uint64_t sub_1CD6DB000(uint64_t a1, uint64_t a2)
{
  return (*(unsigned __int8 *)(a2 + 11) >> 2) & 1;
}

BOOL sub_1CD6DB00C(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 4) != 0x1000000) {
    return 0;
  }
  char v2 = bswap32(*(_DWORD *)(a2 + 8));
  return (v2 & 2) != 0 && (v2 & 4) == 0;
}

BOOL sub_1CD6DB040(uint64_t a1, uint64_t a2)
{
  return (*(unsigned char *)(a2 + 11) & 3) != 0 && *(_DWORD *)(a2 + 4) == 0x8000000;
}

BOOL sub_1CD6DB068(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 4) == 0x8000000;
}

BOOL sub_1CD6DB07C(uint64_t a1, uint64_t a2)
{
  char v2 = bswap32(*(_DWORD *)(a2 + 8));
  if ((v2 & 2) == 0) {
    return 0;
  }
  if ((v2 & 4) != 0) {
    return 1;
  }
  return (v2 & 1) == 0;
}

uint64_t sub_1CD6DB0A8(uint64_t a1, uint64_t a2)
{
  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 240))(a1) & 1) != 0 || *(_DWORD *)(a2 + 4) == 0x8000000) {
    return 0;
  }
  else {
    return (*(unsigned __int8 *)(a2 + 11) >> 1) & 1;
  }
}

uint64_t sub_1CD6DB110(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::sections((void *)(a1 + 56), (uint64_t)&v5);
  uint64_t result = v5;
  if ((v6 & 1) == 0) {
    return ((a2 - v5)
  }
                        / (unint64_t)(bswap32(*(unsigned __int16 *)(*(void *)(a1 + 56) + 46)) >> 16));
  uint64_t v5 = 0;
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 8))(result);
    return 0;
  }
  return result;
}

unint64_t sub_1CD6DB1E0(void *a1, _DWORD *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (*(uint64_t (**)(void *))(*a1 + 264))(a1);
  int v5 = a2[1];
  if (v5 == 0x4000000 || v5 == 150994944)
  {
    unint64_t v8 = sub_1CD6DC760((uint64_t)a1, v4);
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSection(a1 + 7, bswap32(*((_DWORD *)v8 + 6)), (uint64_t)&v16);
    if (v17)
    {
      uint64_t v9 = v16;
      char v16 = 0;
      uint64_t v11 = v9;
      *(void *)&v12.__val_ = llvm::errorToErrorCode(&v11);
      v12.__cat_ = v10;
      std::error_code::message(&v13, &v12);
      __int16 v15 = 260;
      uint64_t v14 = &v13;
      llvm::report_fatal_error((llvm *)&v14, (const llvm::Twine *)1);
    }
    return v4 | ((unint64_t)(bswap32(a2[5]) / bswap32(a2[9]) + HIDWORD(v4)) << 32);
  }
  return v4;
}

uint64_t sub_1CD6DB320@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = bswap32(*(_DWORD *)(a2 + 4));
  if (v5 == 4 || v5 == 9)
  {
    uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSection(a1 + 7, bswap32(*(_DWORD *)(a2 + 28)), (uint64_t)&v10);
    uint64_t v9 = v10;
    if (v11)
    {
      *(unsigned char *)(a3 + 16) |= 1u;
    }
    else
    {
      *(unsigned char *)(a3 + 16) &= ~1u;
      *(void *)(a3 + 8) = a1;
    }
    *(void *)a3 = v9;
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(void *))(*a1 + 352))(a1);
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(void *)a3 = result;
    *(void *)(a3 + 8) = v8;
  }
  return result;
}

void sub_1CD6DB414(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1CD6DB424(uint64_t a1, uint64_t a2)
{
  if (*((_DWORD *)sub_1CD6DC760(a1, a2) + 1) == 150994944) {
    uint64_t v4 = (unsigned int *)sub_1CD6DC808(a1, a2);
  }
  else {
    uint64_t v4 = (unsigned int *)sub_1CD6DC8B4(a1, a2);
  }
  return bswap32(*v4);
}

unint64_t sub_1CD6DB478(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1CD6DC760(a1, a2);
  if (*((_DWORD *)v4 + 1) == 150994944) {
    unsigned int v5 = sub_1CD6DC808(a1, a2);
  }
  else {
    unsigned int v5 = sub_1CD6DC8B4(a1, a2);
  }
  unsigned int v6 = bswap32(*((_DWORD *)v5 + 1));
  if (v6 > 0xFF) {
    return bswap32(*((_DWORD *)v4 + 6)) | ((unint64_t)(v6 >> 8) << 32);
  }
  else {
    return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
  }
}

uint64_t sub_1CD6DB524(uint64_t a1, uint64_t a2)
{
  if (*((_DWORD *)sub_1CD6DC760(a1, a2) + 1) == 150994944) {
    uint64_t v4 = sub_1CD6DC808(a1, a2);
  }
  else {
    uint64_t v4 = sub_1CD6DC8B4(a1, a2);
  }
  return v4[7];
}

void *sub_1CD6DB574(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = a1 + 56;
  unsigned int v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 312))(a1);

  return llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getRelocationTypeName(v4, v5, a3);
}

void sub_1CD6DB5E0(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  long long __p = 0;
  uint64_t v21 = 0;
  unint64_t v22 = 0;
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::sections((void *)(a1 + 56), (uint64_t)&v23);
  if ((v25 & 1) == 0 && v24)
  {
    uint64_t v4 = 0;
    uint64_t v5 = v23;
    uint64_t v6 = v23 + 40 * v24;
    do
    {
      if (*(_DWORD *)(v5 + 4) == 100663296)
      {
        uint64_t v7 = (int *)(bswap32(*(_DWORD *)(v5 + 16)) + *(void *)(a1 + 16));
        int v8 = *v7;
        if (*v7)
        {
          uint64_t v9 = v7 + 2;
          do
          {
            if (v8 == 285212672 || v8 == 117440512 || v8 == 385875968)
            {
              uint64_t v12 = bswap32(*(v9 - 1));
              if ((unint64_t)v4 >= v22)
              {
                uint64_t v4 = sub_1CC9C7F0C((char **)&__p, v12);
              }
              else
              {
                *(void *)uint64_t v4 = v12;
                v4 += 8;
              }
              uint64_t v21 = v4;
            }
            int v13 = *v9;
            v9 += 2;
            int v8 = v13;
          }
          while (v13);
        }
      }
      v5 += 40;
    }
    while (v5 != v6);
    if (v24)
    {
      uint64_t v14 = 0;
      uint64_t v15 = v23;
      uint64_t v16 = v23 + 40 * v24;
      do
      {
        char v17 = (char *)__p;
        if (__p != v21)
        {
          uint64_t v18 = bswap32(*(_DWORD *)(v15 + 12));
          while (*(void *)v17 != v18)
          {
            v17 += 8;
            if (v17 == v21)
            {
              char v17 = v21;
              break;
            }
          }
        }
        if (v17 != v21)
        {
          if ((unint64_t)v14 >= *(void *)(a2 + 16))
          {
            uint64_t v14 = sub_1CCC488E4((char **)a2, v15, a1);
          }
          else
          {
            *(void *)uint64_t v14 = v15;
            *((void *)v14 + 1) = a1;
            v14 += 16;
          }
          *(void *)(a2 + 8) = v14;
        }
        v15 += 40;
      }
      while (v15 != v16);
    }
  }
  if (v25)
  {
    uint64_t v19 = v23;
    uint64_t v23 = 0;
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
    }
  }
  if (__p) {
    operator delete(__p);
  }
}

uint64_t sub_1CD6DB7E0(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::sections((void *)(a1 + 56), (uint64_t)&v2);
  uint64_t result = v2;
  if (v3)
  {
    uint64_t v2 = 0;
    if (result)
    {
      (*(void (**)(uint64_t))(*(void *)result + 8))(result);
      return 0;
    }
  }
  return result;
}

uint64_t sub_1CD6DB890(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::sections((void *)(a1 + 56), (uint64_t)v2);
  uint64_t result = v2[0];
  if ((v3 & 1) == 0) {
    return v2[0] + 40 * v2[1];
  }
  v2[0] = 0;
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 8))(result);
    return 0;
  }
  return result;
}

uint64_t sub_1CD6DB94C()
{
  return 4;
}

const char *sub_1CD6DB954(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  int v2 = *(unsigned __int8 *)(v1 + 4);
  if (v2 == 2)
  {
    signed int v5 = bswap32(*(unsigned __int16 *)(v1 + 18)) >> 16;
    if (v5 > 182)
    {
      if (v5 > 246)
      {
        switch(v5)
        {
          case 247:
            return "elf64-bpf";
          case 251:
            return "elf64-ve";
          case 258:
            return "elf64-loongarch";
        }
      }
      else
      {
        switch(v5)
        {
          case 183:
            return "elf64-bigaarch64";
          case 224:
            return "elf64-amdgpu";
          case 243:
            return "elf64-littleriscv";
        }
      }
    }
    else if (v5 > 21)
    {
      switch(v5)
      {
        case 22:
          return "elf64-s390";
        case 43:
          return "elf64-sparc";
        case 62:
          return "elf64-x86-64";
      }
    }
    else
    {
      switch(v5)
      {
        case 3:
          return "elf64-i386";
        case 8:
          return "elf64-mips";
        case 21:
          return "elf64-powerpc";
      }
    }
    return "elf64-unknown";
  }
  else
  {
    if (v2 != 1) {
      llvm::report_fatal_error((llvm *)"Invalid ELFCLASS!", (const llvm::Twine *)1);
    }
    signed int v3 = bswap32(*(unsigned __int16 *)(v1 + 18)) >> 16;
    if (v3 > 61)
    {
      if (v3 <= 223)
      {
        if (v3 > 104)
        {
          if (v3 == 105) {
            return "elf32-msp430";
          }
          if (v3 == 164) {
            return "elf32-hexagon";
          }
        }
        else
        {
          if (v3 == 62) {
            return "elf32-x86-64";
          }
          if (v3 == 83) {
            return "elf32-avr";
          }
        }
      }
      else if (v3 <= 243)
      {
        if (v3 == 224) {
          return "elf32-amdgpu";
        }
        if (v3 == 243) {
          return "elf32-littleriscv";
        }
      }
      else
      {
        switch(v3)
        {
          case 244:
            return "elf32-lanai";
          case 252:
            return "elf32-csky";
          case 258:
            return "elf32-loongarch";
        }
      }
      return "elf32-unknown";
    }
    if (v3 > 17)
    {
      if (v3 != 18)
      {
        if (v3 == 20) {
          return "elf32-powerpc";
        }
        if (v3 == 40) {
          return "elf32-bigarm";
        }
        return "elf32-unknown";
      }
      return "elf32-sparc";
    }
    else
    {
      uint64_t result = "elf32-m68k";
      switch(v3)
      {
        case 2:
          return "elf32-sparc";
        case 3:
          uint64_t result = "elf32-i386";
          break;
        case 4:
          return result;
        case 6:
          uint64_t result = "elf32-iamcu";
          break;
        case 8:
          uint64_t result = "elf32-mips";
          break;
        default:
          return "elf32-unknown";
      }
    }
  }
  return result;
}

uint64_t sub_1CD6DBC5C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  signed int v2 = bswap32(*(unsigned __int16 *)(v1 + 18)) >> 16;
  if (v2 <= 61)
  {
    uint64_t result = 15;
    switch(v2)
    {
      case 2:
      case 18:
        return 33;
      case 3:
      case 6:
        return 41;
      case 4:
        return result;
      case 5:
      case 7:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 19:
        return 0;
      case 8:
        int v6 = *(unsigned __int8 *)(v1 + 4);
        if (v6 == 1) {
          return 16;
        }
        if (v6 == 2) {
          return 18;
        }
        break;
      case 20:
        return 21;
      case 21:
        return 23;
      case 22:
        return 36;
      default:
        if (v2 == 40) {
          return 1;
        }
        if (v2 != 43) {
          return 0;
        }
        return 34;
    }
    goto LABEL_44;
  }
  if (v2 > 223)
  {
    switch(v2)
    {
      case 243:
        int v4 = *(unsigned __int8 *)(v1 + 4);
        if (v4 == 1) {
          return 31;
        }
        if (v4 == 2) {
          return 32;
        }
        break;
      case 244:
        return 62;
      case 245:
      case 246:
      case 248:
      case 249:
      case 250:
        return 0;
      case 247:
        return 9;
      case 251:
        return 67;
      case 252:
        return 10;
      default:
        if (v2 != 258) {
          return 0;
        }
        int v5 = *(unsigned __int8 *)(v1 + 4);
        if (v5 == 1) {
          return 13;
        }
        if (v5 == 2) {
          return 14;
        }
        break;
    }
LABEL_44:
    llvm::report_fatal_error((llvm *)"Invalid ELFCLASS!", (const llvm::Twine *)1);
  }
  if (v2 <= 104)
  {
    if (v2 != 62)
    {
      if (v2 == 83) {
        return 7;
      }
      return 0;
    }
    return 42;
  }
  else
  {
    switch(v2)
    {
      case 105:
        return 20;
      case 164:
        return 12;
      case 183:
        return 4;
      default:
        return 0;
    }
  }
}

uint64_t sub_1CD6DBE3C@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 56);
  *(unsigned char *)(a2 + 8) &= ~1u;
  *(void *)a2 = bswap32(*(_DWORD *)(v2 + 24));
  return result;
}

BOOL sub_1CD6DBE5C(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(a1 + 56) + 16) == 256;
}

uint64_t sub_1CD6DBE70(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  sub_1CD6DC39C((uint64_t)&v4, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v5)
  {
    uint64_t v3 = v4;
    uint64_t v4 = 0;
    llvm::report_fatal_error(&v3);
  }
  return bswap32(*(_DWORD *)(v4 + 8));
}

uint64_t sub_1CD6DBEF4(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  sub_1CD6DC39C((uint64_t)&v4, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v5)
  {
    uint64_t v3 = v4;
    uint64_t v4 = 0;
    llvm::report_fatal_error(&v3);
  }
  return *(unsigned __int8 *)(v4 + 12) >> 4;
}

uint64_t sub_1CD6DBF78(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  sub_1CD6DC39C((uint64_t)&v4, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v5)
  {
    uint64_t v3 = v4;
    uint64_t v4 = 0;
    llvm::report_fatal_error(&v3);
  }
  return *(unsigned __int8 *)(v4 + 13);
}

uint64_t sub_1CD6DBFF8(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  sub_1CD6DC39C((uint64_t)&v4, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v5)
  {
    uint64_t v3 = v4;
    uint64_t v4 = 0;
    llvm::report_fatal_error(&v3);
  }
  return *(unsigned char *)(v4 + 12) & 0xF;
}

uint64_t sub_1CD6DC07C(uint64_t a1, uint64_t a2)
{
  return bswap32(*(_DWORD *)(a2 + 4));
}

uint64_t sub_1CD6DC088(uint64_t a1, uint64_t a2)
{
  return bswap32(*(_DWORD *)(a2 + 8));
}

uint64_t sub_1CD6DC094(uint64_t a1, uint64_t a2)
{
  return bswap32(*(_DWORD *)(a2 + 16));
}

char *sub_1CD6DC0A0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (*((_DWORD *)sub_1CD6DC760(a1, a2) + 1) != 0x4000000)
  {
    int v8 = "Section is not SHT_RELA";
    __int16 v9 = 259;
    operator new();
  }
  uint64_t result = sub_1CD6DC8B4(a1, a2);
  uint64_t v7 = (int)bswap32(*((_DWORD *)result + 2));
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(void *)a3 = v7;
  return result;
}

void *sub_1CD6DC190@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  char v5 = (void *)(a1 + 56);
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::sections((void *)(a1 + 56), (uint64_t)&v16);
  if (v18)
  {
    uint64_t v9 = v16;
    uint64_t v16 = 0;
    *a3 = v9;
    goto LABEL_8;
  }
  if (!v17)
  {
LABEL_6:
    *a3 = 0;
    goto LABEL_8;
  }
  uint64_t v7 = (_DWORD *)(v16 + 4);
  uint64_t v8 = 40 * v17;
  while (*v7 != 50331760)
  {
    v7 += 10;
    v8 -= 40;
    if (!v8) {
      goto LABEL_6;
    }
  }
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSectionContents(v5, (uint64_t)(v7 - 1), (uint64_t)&v13);
  uint64_t v10 = v13;
  if (v15) {
    goto LABEL_19;
  }
  if (*v13 != 65 || v14 == 1)
  {
    uint64_t v10 = 0;
LABEL_19:
    *a3 = (uint64_t)v10;
    goto LABEL_8;
  }
  uint64_t result = llvm::ELFAttributeParser::parse(a2, (uint64_t)v13, v14, 0, a3);
  uint64_t v12 = *a3;
  if (v15)
  {
    uint64_t result = v13;
    int v13 = 0;
    if (result) {
      uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  if (!v12) {
    goto LABEL_6;
  }
LABEL_8:
  if (v18)
  {
    uint64_t result = (void *)v16;
    uint64_t v16 = 0;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  return result;
}

unint64_t sub_1CD6DC31C@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X8>)
{
  unint64_t v4 = sub_1CD6DCF38(a1);
  unint64_t v6 = v5;
  unint64_t result = sub_1CD6DCF8C(a1);
  *a2 = v4;
  a2[1] = v6;
  a2[2] = result;
  a2[3] = v8;
  return result;
}

uint64_t sub_1CD6DC364(uint64_t a1)
{
  return bswap32(*(_DWORD *)(*(void *)(a1 + 56) + 36));
}

uint64_t sub_1CD6DC374(uint64_t a1)
{
  return bswap32(*(unsigned __int16 *)(*(void *)(a1 + 56) + 16)) >> 16;
}

uint64_t sub_1CD6DC388(uint64_t a1)
{
  return bswap32(*(unsigned __int16 *)(*(void *)(a1 + 56) + 18)) >> 16;
}

unsigned int *sub_1CD6DC39C(uint64_t a1, void *a2, unsigned int a3, unsigned int a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t result = (unsigned int *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSection(a2, a3, (uint64_t)&v9);
  unint64_t v8 = v9;
  if (v10)
  {
    *(unsigned char *)(a1 + 8) |= 1u;
    *(void *)a1 = v8;
  }
  else
  {
    unint64_t result = (unsigned int *)sub_1CD6CE4A0(a2, v9, a4, a1);
    if (v10)
    {
      unint64_t result = v9;
      uint64_t v9 = 0;
      if (result) {
        return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 8))(result);
      }
    }
  }
  return result;
}

unint64_t sub_1CD6DC478(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::sections((void *)(a1 + 56), (uint64_t)&v7);
    unint64_t v5 = v7;
    if (v8)
    {
      unint64_t v7 = 0;
      if (v5)
      {
        (*(void (**)(unint64_t))(*(void *)v5 + 8))(v5);
        LODWORD(v5) = 0;
      }
      a3 = 0;
    }
    else
    {
      unint64_t v5 = (a2 - v7) / 0x28;
    }
  }
  else
  {
    a3 = 0;
    LODWORD(v5) = 0;
  }
  return v5 | ((unint64_t)a3 << 32);
}

size_t sub_1CD6DC548(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4)
{
  unint64_t v5 = bswap32(*a2);
  int v11 = v5;
  if (a4 <= v5)
  {
    atomic_ullong v9 = llvm::object::object_category((llvm::object *)a1);
    unint64_t v10 = a4;
    sub_1CD6D929C(3, v9, (uint64_t)"st_name (0x%x) is past the end of the string table of size 0x%zx", &v11, (uint64_t *)&v10);
  }
  uint64_t v6 = a3 + v5;
  if (a3) {
    size_t result = strlen((const char *)(a3 + v5));
  }
  else {
    size_t result = 0;
  }
  *(unsigned char *)(a1 + 16) &= ~1u;
  *(void *)a1 = v6;
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t sub_1CD6DC5F0(uint64_t a1, void *a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  char v8 = (unsigned int *)a2[11];
  if (v8)
  {
    uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSHNDXTable(a2 + 7, v8, (uint64_t)&v16);
    uint64_t v9 = v16;
    if (v18) {
      goto LABEL_7;
    }
    uint64_t v10 = v17;
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
  }
  *(void *)&long long v13 = v9;
  *((void *)&v13 + 1) = v10;
  char v14 = 1;
  uint64_t v15 = 0;
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSection(a2 + 7, a3, a4, &v13, (uint64_t)&v16);
  uint64_t v9 = v16;
  if (v17)
  {
LABEL_7:
    *(unsigned char *)(a1 + 16) |= 1u;
    *(void *)a1 = v9;
    return result;
  }
  if (v16)
  {
    *(unsigned char *)(a1 + 16) &= ~1u;
    *(void *)a1 = v9;
    *(void *)(a1 + 8) = a2;
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(void *))(*a2 + 352))(a2);
    *(unsigned char *)(a1 + 16) &= ~1u;
    *(void *)a1 = result;
    *(void *)(a1 + 8) = v12;
    if (v17)
    {
      uint64_t result = v16;
      uint64_t v16 = 0;
      if (result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
    }
  }
  return result;
}

char *sub_1CD6DC760(uint64_t a1, unsigned int a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSection((void *)(a1 + 56), a2, (uint64_t)&v10);
  if (v11)
  {
    uint64_t v3 = v10;
    uint64_t v10 = 0;
    unint64_t v5 = v3;
    *(void *)&v6.__val_ = llvm::errorToErrorCode(&v5);
    v6.__cat_ = v4;
    std::error_code::message(&v7, &v6);
    __int16 v9 = 260;
    char v8 = &v7;
    llvm::report_fatal_error((llvm *)&v8, (const llvm::Twine *)1);
  }
  return v10;
}

char *sub_1CD6DC808(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  sub_1CD6DC960((uint64_t)&v9, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v10)
  {
    unint64_t v4 = v9;
    *(void *)&v5.__val_ = llvm::errorToErrorCode(&v4);
    v5.__cat_ = v3;
    std::error_code::message(&v6, &v5);
    __int16 v8 = 260;
    std::string v7 = &v6;
    llvm::report_fatal_error((llvm *)&v7, (const llvm::Twine *)1);
  }
  return v9;
}

char *sub_1CD6DC8B4(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  sub_1CD6DCC48((uint64_t)&v9, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v10)
  {
    unint64_t v4 = v9;
    *(void *)&v5.__val_ = llvm::errorToErrorCode(&v4);
    v5.__cat_ = v3;
    std::error_code::message(&v6, &v5);
    __int16 v8 = 260;
    std::string v7 = &v6;
    llvm::report_fatal_error((llvm *)&v7, (const llvm::Twine *)1);
  }
  return v9;
}

unsigned int *sub_1CD6DC960(uint64_t a1, void *a2, unsigned int a3, unsigned int a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t result = (unsigned int *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSection(a2, a3, (uint64_t)&v9);
  __int16 v8 = v9;
  if (v10)
  {
    *(unsigned char *)(a1 + 8) |= 1u;
    *(void *)a1 = v8;
  }
  else
  {
    uint64_t result = (unsigned int *)sub_1CD6DCA3C(a1, a2, v9, a4);
    if (v10)
    {
      uint64_t result = v9;
      __int16 v9 = 0;
      if (result) {
        return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 8))(result);
      }
    }
  }
  return result;
}

void *sub_1CD6DCA3C(uint64_t a1, void *a2, unsigned int *a3, unsigned int a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::rels(a2, a3, (uint64_t)v26);
  if (v27)
  {
    uint64_t v8 = v26[0];
    char v9 = *(unsigned char *)(a1 + 8) | 1;
  }
  else
  {
    if (v26[1] <= (unint64_t)a4)
    {
      char v20 = "can't read an entry at 0x";
      __int16 v21 = 259;
      uint64_t v17 = 8 * a4;
      v18[0] = (uint64_t)&v17;
      void v18[2] = 0;
      __int16 v19 = 270;
      sub_1CB8F1E58((uint64_t *)&v20, v18, (uint64_t)v22);
      uint64_t v15 = ": it goes past the end of the section (0x";
      __int16 v16 = 259;
      sub_1CB8F1E58(v22, (uint64_t *)&v15, (uint64_t)v23);
      uint64_t v12 = bswap32(a3[5]);
      v13[0] = (uint64_t)&v12;
      void v13[2] = 0;
      __int16 v14 = 270;
      sub_1CB8F1E58(v23, v13, (uint64_t)v24);
      char v10 = ")";
      __int16 v11 = 259;
      sub_1CB8F1E58(v24, (uint64_t *)&v10, (uint64_t)v25);
      operator new();
    }
    uint64_t v8 = v26[0] + 8 * a4;
    char v9 = *(unsigned char *)(a1 + 8) & 0xFE;
  }
  *(unsigned char *)(a1 + 8) = v9;
  *(void *)a1 = v8;
  return result;
}

unsigned int *sub_1CD6DCC48(uint64_t a1, void *a2, unsigned int a3, unsigned int a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t result = (unsigned int *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSection(a2, a3, (uint64_t)&v9);
  uint64_t v8 = v9;
  if (v10)
  {
    *(unsigned char *)(a1 + 8) |= 1u;
    *(void *)a1 = v8;
  }
  else
  {
    uint64_t result = (unsigned int *)sub_1CD6DCD24(a1, a2, v9, a4);
    if (v10)
    {
      uint64_t result = v9;
      char v9 = 0;
      if (result) {
        return (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 8))(result);
      }
    }
  }
  return result;
}

void *sub_1CD6DCD24(uint64_t a1, void *a2, unsigned int *a3, unsigned int a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::relas(a2, a3, (uint64_t)v26);
  if (v27)
  {
    uint64_t v8 = v26[0];
    char v9 = *(unsigned char *)(a1 + 8) | 1;
  }
  else
  {
    if (v26[1] <= (unint64_t)a4)
    {
      char v20 = "can't read an entry at 0x";
      __int16 v21 = 259;
      uint64_t v17 = 12 * a4;
      v18[0] = (uint64_t)&v17;
      void v18[2] = 0;
      __int16 v19 = 270;
      sub_1CB8F1E58((uint64_t *)&v20, v18, (uint64_t)v22);
      uint64_t v15 = ": it goes past the end of the section (0x";
      __int16 v16 = 259;
      sub_1CB8F1E58(v22, (uint64_t *)&v15, (uint64_t)v23);
      uint64_t v12 = bswap32(a3[5]);
      v13[0] = (uint64_t)&v12;
      void v13[2] = 0;
      __int16 v14 = 270;
      sub_1CB8F1E58(v23, v13, (uint64_t)v24);
      char v10 = ")";
      __int16 v11 = 259;
      sub_1CB8F1E58(v24, (uint64_t *)&v10, (uint64_t)v25);
      operator new();
    }
    uint64_t v8 = v26[0] + 12 * a4;
    char v9 = *(unsigned char *)(a1 + 8) & 0xFE;
  }
  *(unsigned char *)(a1 + 8) = v9;
  *(void *)a1 = v8;
  return result;
}

unint64_t sub_1CD6DCF38(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 72);
  unsigned int v2 = v1 && bswap32(*(_DWORD *)(v1 + 20)) > 0xF;
  return sub_1CD6DC478(a1, v1, v2);
}

unint64_t sub_1CD6DCF8C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 72);
  if (v1) {
    return sub_1CD6DC478(a1, v1, bswap32(*(_DWORD *)(v1 + 20)) >> 4);
  }
  else {
    return sub_1CD6DCF38(a1);
  }
}

void sub_1CD6DCFDC(uint64_t a1, long long *a2, int a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::create(*(void *)a2, *((void *)a2 + 1), (uint64_t)&v23);
  if (v25)
  {
    uint64_t v6 = v23;
    uint64_t v23 = 0;
    if (v6)
    {
      *(unsigned char *)(a1 + 104) |= 1u;
      *(void *)a1 = v6;
      return;
    }
  }
  else
  {
    uint64_t v6 = v23;
  }
  long long v7 = a2[1];
  long long v17 = *a2;
  long long v18 = v7;
  uint64_t v8 = v24;
  int v16 = 14;
  uint64_t v15 = &unk_1F2633118;
  char v19 = 0;
  uint64_t v20 = v6;
  uint64_t v21 = v24;
  memset(v22, 0, 24);
  long long v9 = 0uLL;
  if (!a3)
  {
    uint64_t v10 = 0;
LABEL_5:
    *(unsigned char *)(a1 + 104) &= ~1u;
    *(_DWORD *)(a1 + 8) = 14;
    long long v11 = v18;
    *(_OWORD *)(a1 + 16) = v17;
    *(_OWORD *)(a1 + 32) = v11;
    *(void *)a1 = &unk_1F2633118;
    *(unsigned char *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = v6;
    *(void *)(a1 + 64) = v8;
    *(_OWORD *)(a1 + 72) = v9;
    *(void *)(a1 + 88) = v10;
    goto LABEL_6;
  }
  sub_1CD6DD18C((uint64_t)&v15, &v14);
  uint64_t v13 = v14;
  if (!v14)
  {
    uint64_t v6 = v20;
    uint64_t v8 = v21;
    long long v9 = v22[0];
    uint64_t v10 = *(void *)&v22[1];
    goto LABEL_5;
  }
  *(unsigned char *)(a1 + 104) |= 1u;
  *(void *)a1 = v13;
LABEL_6:
  llvm::object::SymbolicFile::~SymbolicFile((llvm::object::SymbolicFile *)&v15);
  if (v25)
  {
    uint64_t v12 = v23;
    uint64_t v23 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
}

void *sub_1CD6DD18C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::sections((void *)(a1 + 56), (uint64_t)&v10);
  uint64_t v5 = v10;
  if ((v12 & 1) == 0)
  {
    if (v11)
    {
      uint64_t v6 = v11 << 6;
      long long v7 = (int *)(v10 + 4);
      while (1)
      {
        int v8 = *v7;
        if (*v7 == 2) {
          break;
        }
        if (v8 != 18)
        {
          if (v8 != 11) {
            goto LABEL_11;
          }
          long long v9 = (void *)(a1 + 72);
          if (*(void *)(a1 + 72)) {
            goto LABEL_11;
          }
LABEL_10:
          *long long v9 = v7 - 1;
          goto LABEL_11;
        }
        long long v9 = (void *)(a1 + 88);
        if (!*(void *)(a1 + 88)) {
          goto LABEL_10;
        }
LABEL_11:
        v7 += 16;
        v6 -= 64;
        if (!v6) {
          goto LABEL_15;
        }
      }
      long long v9 = (void *)(a1 + 80);
      if (*(void *)(a1 + 80)) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
LABEL_15:
    uint64_t v5 = 0;
    *(unsigned char *)(a1 + 48) = 1;
  }
  *a2 = v5;
  return result;
}

void sub_1CD6DD28C(llvm::object::SymbolicFile *a1)
{
  llvm::object::SymbolicFile::~SymbolicFile(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD6DD2C4(uint64_t a1, uint64_t a2)
{
}

unint64_t sub_1CD6DD2D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 80);
  if (v1) {
    unsigned int v2 = *(void *)(v1 + 32) > 0x17uLL;
  }
  else {
    unsigned int v2 = 0;
  }
  return sub_1CD6DF474(a1, v1, v2);
}

unint64_t sub_1CD6DD31C(void *a1)
{
  uint64_t v1 = a1[10];
  if (v1) {
    return sub_1CD6DF474((uint64_t)a1, v1, *(void *)(v1 + 32) / 0x18uLL);
  }
  else {
    return (*(uint64_t (**)(void *))(*a1 + 48))(a1);
  }
}

void sub_1CD6DD394(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a1 + 7;
  sub_1CD6DF398((uint64_t)&v31, a1 + 7, a2, HIDWORD(a2));
  if (v32)
  {
    long long v7 = v31;
    *(unsigned char *)(a3 + 16) |= 1u;
    *(void *)a3 = v7;
    return;
  }
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSection(v6, a2, (uint64_t)&v29);
  uint64_t v8 = v29;
  if ((v30 & 1) == 0)
  {
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSection(v6, *(_DWORD *)(v29 + 40), (uint64_t)&v27);
    uint64_t v10 = v27;
    if (v28)
    {
      uint64_t v27 = 0;
      *(unsigned char *)(a3 + 16) |= 1u;
      *(void *)a3 = v10;
LABEL_11:
      if (v30)
      {
        uint64_t v11 = v29;
        uint64_t v29 = 0;
        if (v11) {
          (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
        }
      }
      goto LABEL_6;
    }
    *(void *)&long long v23 = sub_1CCC487E0;
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getStringTable(v6, v27, (void (*)(uint64_t *__return_ptr, uint64_t, void *))sub_1CD6D6140, (uint64_t)&v23, (uint64_t)v25);
    if (v26)
    {
      uint64_t v12 = v25[0];
      v25[0] = 0;
      *(unsigned char *)(a3 + 16) |= 1u;
      *(void *)a3 = v12;
LABEL_16:
      if (v28)
      {
        uint64_t v13 = v27;
        uint64_t v27 = 0;
        if (v13) {
          (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
        }
      }
      goto LABEL_11;
    }
    sub_1CD6D91F8((uint64_t)&v23, v31, v25[0], v25[1]);
    if ((v24 & 1) != 0 || !*((void *)&v23 + 1))
    {
      int v15 = v24 & 1;
      if ((v31[1] & 0xF) == 3)
      {
        (*(void (**)(uint64_t *__return_ptr, void *, uint64_t))(*a1 + 120))(&v20, a1, a2);
        if ((v22 & 1) == 0)
        {
          if (v15)
          {
            long long v17 = (void *)v23;
            *(void *)&long long v23 = 0;
          }
          else
          {
            long long v17 = 0;
          }
          char v19 = v17;
          sub_1CD4515D0(&v19);
          if (v19) {
            (*(void (**)(void *))(*v19 + 8))(v19);
          }
          (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 136))(v21, v20);
          if (v22)
          {
            uint64_t v18 = v20;
            uint64_t v20 = 0;
            if (v18) {
              (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
            }
          }
          if (v15 && (void)v23) {
            (*(void (**)(void))(*(void *)v23 + 8))(v23);
          }
          goto LABEL_23;
        }
        uint64_t v16 = v20;
        uint64_t v20 = 0;
        if (v16) {
          (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
        }
      }
      *(unsigned char *)(a3 + 16) = *(unsigned char *)(a3 + 16) & 0xFE | v15;
      if (v15)
      {
        *(void *)a3 = v23;
        goto LABEL_23;
      }
    }
    else
    {
      *(unsigned char *)(a3 + 16) &= ~1u;
    }
    *(_OWORD *)a3 = v23;
LABEL_23:
    if (v26)
    {
      uint64_t v14 = v25[0];
      v25[0] = 0;
      if (v14) {
        (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
      }
    }
    goto LABEL_16;
  }
  uint64_t v29 = 0;
  *(unsigned char *)(a3 + 16) |= 1u;
  *(void *)a3 = v8;
LABEL_6:
  if (v32)
  {
    long long v9 = v31;
    __int16 v31 = 0;
    if (v9) {
      (*(void (**)(int *))(*(void *)v9 + 8))(v9);
    }
  }
}

void *sub_1CD6DD784@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t result = llvm::object::ObjectFile::getSymbolValue(a1, a2, (uint64_t)&v25);
  if (v26)
  {
    long long v7 = v25;
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v7;
    return result;
  }
  uint64_t v8 = v25;
  uint64_t result = sub_1CD6DF398((uint64_t)&v23, (void *)(a1 + 56), a2, HIDWORD(a2));
  uint64_t v9 = v23;
  if (v24)
  {
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v9;
  }
  else
  {
    int v10 = *(unsigned __int16 *)(v23 + 6);
    if ((v10 - 65521) >= 2 && v10 != 0)
    {
      uint64_t result = (void *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSection((void *)(a1 + 56), a2, (uint64_t)&v21);
      if (v22)
      {
        uint64_t v12 = v21;
        uint64_t v21 = 0;
      }
      else
      {
        if (*(_WORD *)(*(void *)(a1 + 56) + 16) != 1)
        {
LABEL_17:
          *(unsigned char *)(a3 + 8) &= ~1u;
          *(void *)a3 = v8;
          goto LABEL_20;
        }
        uint64_t v13 = *(void *)(a1 + 88);
        if (v13)
        {
          uint64_t result = (void *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSHNDXTable((void *)(a1 + 56), v13, (uint64_t)&v18);
          uint64_t v12 = v18;
          if (v20) {
            goto LABEL_19;
          }
          uint64_t v14 = v19;
        }
        else
        {
          uint64_t v12 = 0;
          uint64_t v14 = 0;
        }
        *(void *)&long long v15 = v12;
        *((void *)&v15 + 1) = v14;
        char v16 = 1;
        uint64_t v17 = 0;
        uint64_t result = (void *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSection((void *)(a1 + 56), v23, v21, &v15, (uint64_t)&v18);
        uint64_t v12 = v18;
        if ((v19 & 1) == 0)
        {
          if (v18) {
            uint64_t v8 = (void *)((char *)v8 + v18[2]);
          }
          goto LABEL_17;
        }
      }
LABEL_19:
      *(unsigned char *)(a3 + 8) |= 1u;
      *(void *)a3 = v12;
LABEL_20:
      if (v22)
      {
        uint64_t result = v21;
        uint64_t v21 = 0;
        if (result) {
          uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
        }
      }
      if (v24)
      {
        uint64_t result = (void *)v23;
        uint64_t v23 = 0;
        if (result) {
          uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
        }
      }
      goto LABEL_12;
    }
    *(unsigned char *)(a3 + 8) &= ~1u;
    *(void *)a3 = v8;
  }
LABEL_12:
  if (v26)
  {
    uint64_t result = v25;
    char v25 = 0;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  return result;
}

unint64_t sub_1CD6DD9F0(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1 + 56;
  sub_1CD6DF398((uint64_t)&v7, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v8)
  {
    uint64_t v6 = v7;
    uint64_t v7 = 0;
    llvm::report_fatal_error(&v6);
  }
  unint64_t result = *(void *)(v7 + 8);
  if (*(__int16 *)(v7 + 6) != -15)
  {
    int v4 = *(unsigned __int16 *)(*(void *)v2 + 18);
    if ((v4 == 40 || v4 == 8) && (*(unsigned char *)(v7 + 4) & 0xF) == 2) {
      result &= ~1uLL;
    }
  }
  return result;
}

uint64_t sub_1CD6DDAB0(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  sub_1CD6DF398((uint64_t)&v4, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v5)
  {
    uint64_t v3 = v4;
    uint64_t v4 = 0;
    llvm::report_fatal_error(&v3);
  }
  if (*(__int16 *)(v4 + 6) == -14) {
    return *(unsigned int *)(v4 + 8);
  }
  else {
    return 0;
  }
}

uint64_t sub_1CD6DDB44(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 432))();
}

void *sub_1CD6DDB70@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t result = sub_1CD6DF398((uint64_t)&v7, (void *)(a1 + 56), a2, HIDWORD(a2));
  uint64_t v5 = v7;
  if (v8)
  {
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v5;
  }
  else
  {
    switch(*(unsigned char *)(v7 + 4) & 0xF)
    {
      case 0:
        *(unsigned char *)(a3 + 8) &= ~1u;
        *(_DWORD *)a3 = 0;
        return result;
      case 1:
      case 5:
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v6 = 2;
        goto LABEL_4;
      case 2:
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v6 = 5;
        goto LABEL_4;
      case 3:
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v6 = 3;
        goto LABEL_4;
      case 4:
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v6 = 4;
        goto LABEL_4;
      default:
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v6 = 1;
LABEL_4:
        *(_DWORD *)a3 = v6;
        break;
    }
  }
  return result;
}

void *sub_1CD6DDCA0@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3 = a2;
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  int v6 = a1 + 7;
  unint64_t result = sub_1CD6DF398((uint64_t)&v12, a1 + 7, a2, HIDWORD(a2));
  if (v13)
  {
    uint64_t v8 = (uint64_t)v12;
    *(unsigned char *)(a3 + 16) |= 1u;
    *(void *)a3 = v8;
  }
  else
  {
    unint64_t result = (void *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSection(v6, v3, (uint64_t)&v10);
    if (v11)
    {
      uint64_t v9 = v10;
      *(unsigned char *)(a3 + 16) |= 1u;
      *(void *)a3 = v9;
    }
    else
    {
      unint64_t result = (void *)sub_1CD6DF53C(a3, a1, (uint64_t)v12, v10);
      if (v11)
      {
        unint64_t result = v10;
        int v10 = 0;
        if (result) {
          unint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
        }
      }
    }
    if (v13)
    {
      unint64_t result = v12;
      uint64_t v12 = 0;
      if (result) {
        return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
      }
    }
  }
  return result;
}

void sub_1CD6DDDF0(uint64_t a1, void *a2)
{
  *a2 += 64;
}

void sub_1CD6DDE00(uint64_t a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3 = sub_1CCC487E0;
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSectionName((void *)(a1 + 56), a2, (void (*)(uint64_t *__return_ptr, uint64_t, void *))sub_1CD6D6140, (uint64_t)&v3, a3);
}

uint64_t sub_1CD6DDE48(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16);
}

uint64_t sub_1CD6DDE50(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::sections((void *)(a1 + 56), (uint64_t)&v7);
  if (v8)
  {
    unsigned int v3 = v7;
    uint64_t v7 = 0;
  }
  else
  {
    unsigned int v3 = 0;
  }
  int v6 = v3;
  sub_1CCC4886C(&v6);
  if (v6) {
    (*(void (**)(void *))(*v6 + 8))(v6);
  }
  uint64_t v4 = v7;
  if (v8)
  {
    uint64_t v7 = 0;
    if (v4) {
      (*(void (**)(void *))(*v4 + 8))(v4);
    }
  }
  return (a2 - (uint64_t)v4) >> 6;
}

uint64_t sub_1CD6DDF44(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 32);
}

__n128 *sub_1CD6DDF4C@<X0>(__n128 *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3 = this;
  if (*(_DWORD *)(a2 + 4) == 8)
  {
    unint64_t v5 = this[1].n128_u64[0];
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(void *)a3 = v5;
    *(void *)(a3 + 8) = 0;
  }
  else
  {
    llvm::object::Binary::getMemoryBufferRef(this, v10);
    this = (__n128 *)sub_1CCC207AC((llvm::object *)v10, *(void *)(a2 + 24) + v3[1].n128_u64[0], *(void *)(a2 + 32), &v11);
    uint64_t v7 = v11;
    if (v11)
    {
      *(unsigned char *)(a3 + 16) |= 1u;
      *(void *)a3 = v7;
    }
    else
    {
      uint64_t v8 = *(void *)(a2 + 32);
      unint64_t v9 = v3[1].n128_u64[0] + *(void *)(a2 + 24);
      *(unsigned char *)(a3 + 16) &= ~1u;
      *(void *)a3 = v9;
      *(void *)(a3 + 8) = v8;
    }
  }
  return this;
}

uint64_t sub_1CD6DE004(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 48);
}

uint64_t sub_1CD6DE00C(uint64_t a1, uint64_t a2)
{
  return (*(unsigned __int8 *)(a2 + 9) >> 3) & 1;
}

uint64_t sub_1CD6DE018(uint64_t a1, uint64_t a2)
{
  return (*(unsigned __int8 *)(a2 + 8) >> 2) & 1;
}

BOOL sub_1CD6DE024(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 4) != 1) {
    return 0;
  }
  if ((*(void *)(a2 + 8) & 2) != 0) {
    return (*(void *)(a2 + 8) & 4) == 0;
  }
  return 0;
}

BOOL sub_1CD6DE050(uint64_t a1, uint64_t a2)
{
  return (*(unsigned char *)(a2 + 8) & 3) != 0 && *(_DWORD *)(a2 + 4) == 8;
}

BOOL sub_1CD6DE074(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 4) == 8;
}

BOOL sub_1CD6DE084(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  BOOL v3 = (v2 & 4) != 0 || (*(void *)(a2 + 8) & 1) == 0;
  return (v2 & 2) != 0 && v3;
}

uint64_t sub_1CD6DE0A8(uint64_t a1, uint64_t a2)
{
  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 240))(a1) & 1) != 0 || *(_DWORD *)(a2 + 4) == 8) {
    return 0;
  }
  else {
    return (*(unsigned __int8 *)(a2 + 8) >> 1) & 1;
  }
}

uint64_t sub_1CD6DE10C(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::sections((void *)(a1 + 56), (uint64_t)&v5);
  uint64_t result = v5;
  if ((v6 & 1) == 0) {
    return ((a2 - v5) / (unint64_t)*(unsigned __int16 *)(*(void *)(a1 + 56) + 58));
  }
  uint64_t v5 = 0;
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 8))(result);
    return 0;
  }
  return result;
}

uint64_t sub_1CD6DE1D4(void *a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (*(uint64_t (**)(void *))(*a1 + 264))(a1);
  int v5 = *(_DWORD *)(a2 + 4);
  if (v5 == 4 || v5 == 9)
  {
    uint64_t v8 = sub_1CD6DF6AC((uint64_t)a1, v4);
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSection(a1 + 7, *((_DWORD *)v8 + 10), (uint64_t)&v16);
    if (v17)
    {
      unint64_t v9 = v16;
      char v16 = 0;
      uint64_t v11 = v9;
      *(void *)&v12.__val_ = llvm::errorToErrorCode(&v11);
      v12.__cat_ = v10;
      std::error_code::message(&v13, &v12);
      __int16 v15 = 260;
      uint64_t v14 = &v13;
      llvm::report_fatal_error((llvm *)&v14, (const llvm::Twine *)1);
    }
    v4 += (*(void *)(a2 + 32) / *(void *)(a2 + 56)) << 32;
  }
  return v4;
}

uint64_t sub_1CD6DE2F8@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  int v5 = *(_DWORD *)(a2 + 4);
  if (v5 == 4 || v5 == 9)
  {
    uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSection(a1 + 7, *(_DWORD *)(a2 + 44), (uint64_t)&v10);
    uint64_t v9 = v10;
    if (v11)
    {
      *(unsigned char *)(a3 + 16) |= 1u;
    }
    else
    {
      *(unsigned char *)(a3 + 16) &= ~1u;
      *(void *)(a3 + 8) = a1;
    }
    *(void *)a3 = v9;
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(void *))(*a1 + 352))(a1);
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(void *)a3 = result;
    *(void *)(a3 + 8) = v8;
  }
  return result;
}

void sub_1CD6DE3E4(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1CD6DE3F4(uint64_t a1, uint64_t a2)
{
  if (*((_DWORD *)sub_1CD6DF6AC(a1, a2) + 1) == 9) {
    uint64_t v4 = sub_1CD6DF754(a1, a2);
  }
  else {
    uint64_t v4 = sub_1CD6DF800(a1, a2);
  }
  return *(void *)v4;
}

unint64_t sub_1CD6DE440(void *a1, uint64_t a2)
{
  uint64_t v4 = sub_1CD6DF6AC((uint64_t)a1, a2);
  if (*((_DWORD *)v4 + 1) == 9) {
    int v5 = sub_1CD6DF754((uint64_t)a1, a2);
  }
  else {
    int v5 = sub_1CD6DF800((uint64_t)a1, a2);
  }
  uint64_t v6 = a1[7];
  if (*(_WORD *)(v6 + 18) == 8 && *(unsigned char *)(v6 + 4) == 2)
  {
    unint64_t v7 = *((void *)v5 + 1);
    BOOL v8 = *(unsigned char *)(v6 + 5) == 1;
    unint64_t v9 = (v7 << 32) | (v7 >> 8) & 0xFF000000 | (v7 >> 24) & 0xFF0000 | (unsigned __int16)(HIDWORD(v7) >> 8) & 0xFF00 | HIBYTE(v7);
    if (!v8) {
      unint64_t v9 = *((void *)v5 + 1);
    }
  }
  else
  {
    unint64_t v9 = *((void *)v5 + 1);
  }
  if (HIDWORD(v9)) {
    return v9 & 0xFFFFFFFF00000000 | *((unsigned int *)v4 + 10);
  }
  else {
    return (*(uint64_t (**)(void *))(*a1 + 56))(a1);
  }
}

uint64_t sub_1CD6DE524(uint64_t a1, uint64_t a2)
{
  if (*((_DWORD *)sub_1CD6DF6AC(a1, a2) + 1) == 9) {
    uint64_t v4 = sub_1CD6DF754(a1, a2);
  }
  else {
    uint64_t v4 = sub_1CD6DF800(a1, a2);
  }
  uint64_t v5 = *(void *)(a1 + 56);
  if (*(_WORD *)(v5 + 18) == 8 && *(unsigned char *)(v5 + 4) == 2)
  {
    BOOL v6 = *(unsigned char *)(v5 + 5) == 1;
    uint64_t v7 = (*((void *)v4 + 1) >> 24) & 0xFF0000 | HIBYTE(*((void *)v4 + 1)) | (*((void *)v4 + 1) >> 8) & 0xFF000000 | (*((void *)v4 + 1) >> 40) & 0xFF00;
    if (!v6) {
      return *((void *)v4 + 1);
    }
  }
  else
  {
    LODWORD(v7) = *((_DWORD *)v4 + 2);
  }
  return v7;
}

void *sub_1CD6DE5C8(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t v4 = a1 + 7;
  unsigned int v5 = (*(uint64_t (**)(uint64_t *))(*a1 + 312))(a1);

  return llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getRelocationTypeName(v4, v5, a3);
}

void sub_1CD6DE634(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  long long __p = 0;
  uint64_t v18 = 0;
  unint64_t v19 = 0;
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::sections((void *)(a1 + 56), (uint64_t)&v20);
  if ((v22 & 1) == 0 && v21)
  {
    uint64_t v4 = 0;
    uint64_t v5 = v20;
    uint64_t v6 = v20 + (v21 << 6);
    do
    {
      if (*(_DWORD *)(v5 + 4) == 6)
      {
        uint64_t v7 = (uint64_t *)(*(void *)(v5 + 24) + *(void *)(a1 + 16));
        uint64_t v8 = *v7;
        if (*v7)
        {
          unint64_t v9 = v7 + 2;
          do
          {
            if (v8 == 17 || v8 == 7 || v8 == 23)
            {
              uint64_t v10 = *(v9 - 1);
              if ((unint64_t)v4 >= v19)
              {
                uint64_t v4 = sub_1CC9C7F0C((char **)&__p, v10);
              }
              else
              {
                *(void *)uint64_t v4 = v10;
                v4 += 8;
              }
              uint64_t v18 = v4;
            }
            uint64_t v11 = *v9;
            v9 += 2;
            uint64_t v8 = v11;
          }
          while (v11);
        }
      }
      v5 += 64;
    }
    while (v5 != v6);
    if (v21)
    {
      uint64_t v12 = 0;
      uint64_t v13 = v20;
      uint64_t v14 = v20 + (v21 << 6);
      do
      {
        __int16 v15 = (char *)__p;
        if (__p != v18)
        {
          while (*(void *)v15 != *(void *)(v13 + 16))
          {
            v15 += 8;
            if (v15 == v18)
            {
              __int16 v15 = v18;
              break;
            }
          }
        }
        if (v15 != v18)
        {
          if ((unint64_t)v12 >= *(void *)(a2 + 16))
          {
            uint64_t v12 = sub_1CCC488E4((char **)a2, v13, a1);
          }
          else
          {
            *(void *)uint64_t v12 = v13;
            *((void *)v12 + 1) = a1;
            v12 += 16;
          }
          *(void *)(a2 + 8) = v12;
        }
        v13 += 64;
      }
      while (v13 != v14);
    }
  }
  if (v22)
  {
    uint64_t v16 = v20;
    uint64_t v20 = 0;
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
    }
  }
  if (__p) {
    operator delete(__p);
  }
}

uint64_t sub_1CD6DE808(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::sections((void *)(a1 + 56), (uint64_t)&v2);
  uint64_t result = v2;
  if (v3)
  {
    uint64_t v2 = 0;
    if (result)
    {
      (*(void (**)(uint64_t))(*(void *)result + 8))(result);
      return 0;
    }
  }
  return result;
}

uint64_t sub_1CD6DE8B8(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::sections((void *)(a1 + 56), (uint64_t)v2);
  uint64_t result = v2[0];
  if ((v3 & 1) == 0) {
    return v2[0] + (v2[1] << 6);
  }
  v2[0] = 0;
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 8))(result);
    return 0;
  }
  return result;
}

uint64_t sub_1CD6DE970()
{
  return 8;
}

const char *sub_1CD6DE978(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  int v2 = *(unsigned __int8 *)(v1 + 4);
  if (v2 == 2)
  {
    int v5 = *(unsigned __int16 *)(v1 + 18);
    if (v5 > 182)
    {
      if (v5 > 246)
      {
        switch(v5)
        {
          case 247:
            return "elf64-bpf";
          case 251:
            return "elf64-ve";
          case 258:
            return "elf64-loongarch";
        }
      }
      else
      {
        switch(v5)
        {
          case 183:
            return "elf64-littleaarch64";
          case 224:
            return "elf64-amdgpu";
          case 243:
            return "elf64-littleriscv";
        }
      }
    }
    else if (v5 > 21)
    {
      switch(v5)
      {
        case 22:
          return "elf64-s390";
        case 43:
          return "elf64-sparc";
        case 62:
          return "elf64-x86-64";
      }
    }
    else
    {
      switch(v5)
      {
        case 3:
          return "elf64-i386";
        case 8:
          return "elf64-mips";
        case 21:
          return "elf64-powerpcle";
      }
    }
    return "elf64-unknown";
  }
  else
  {
    if (v2 != 1) {
      llvm::report_fatal_error((llvm *)"Invalid ELFCLASS!", (const llvm::Twine *)1);
    }
    int v3 = *(unsigned __int16 *)(v1 + 18);
    if (v3 > 61)
    {
      if (v3 <= 223)
      {
        if (v3 > 104)
        {
          if (v3 == 105) {
            return "elf32-msp430";
          }
          if (v3 == 164) {
            return "elf32-hexagon";
          }
        }
        else
        {
          if (v3 == 62) {
            return "elf32-x86-64";
          }
          if (v3 == 83) {
            return "elf32-avr";
          }
        }
      }
      else if (v3 <= 243)
      {
        if (v3 == 224) {
          return "elf32-amdgpu";
        }
        if (v3 == 243) {
          return "elf32-littleriscv";
        }
      }
      else
      {
        switch(v3)
        {
          case 244:
            return "elf32-lanai";
          case 252:
            return "elf32-csky";
          case 258:
            return "elf32-loongarch";
        }
      }
      return "elf32-unknown";
    }
    if (v3 > 17)
    {
      if (v3 != 18)
      {
        if (v3 == 20) {
          return "elf32-powerpcle";
        }
        if (v3 == 40) {
          return "elf32-littlearm";
        }
        return "elf32-unknown";
      }
      return "elf32-sparc";
    }
    else
    {
      uint64_t result = "elf32-m68k";
      switch(v3)
      {
        case 2:
          return "elf32-sparc";
        case 3:
          uint64_t result = "elf32-i386";
          break;
        case 4:
          return result;
        case 6:
          uint64_t result = "elf32-iamcu";
          break;
        case 8:
          uint64_t result = "elf32-mips";
          break;
        default:
          return "elf32-unknown";
      }
    }
  }
  return result;
}

uint64_t sub_1CD6DEC70(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  unsigned int v2 = *(unsigned __int16 *)(v1 + 18);
  if (v2 <= 0x3D)
  {
    uint64_t result = 15;
    switch(*(_WORD *)(v1 + 18))
    {
      case 2:
      case 0x12:
        return 35;
      case 3:
      case 6:
        return 41;
      case 4:
        return result;
      case 5:
      case 7:
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
      case 0xD:
      case 0xE:
      case 0xF:
      case 0x10:
      case 0x11:
      case 0x13:
        return 0;
      case 8:
        int v6 = *(unsigned __int8 *)(v1 + 4);
        if (v6 == 1)
        {
          uint64_t result = 17;
        }
        else
        {
          if (v6 != 2) {
            goto LABEL_51;
          }
          uint64_t result = 19;
        }
        break;
      case 0x14:
        return 22;
      case 0x15:
        return 24;
      case 0x16:
        return 36;
      default:
        if (v2 == 40) {
          return 1;
        }
        if (v2 != 43) {
          return 0;
        }
        return 34;
    }
  }
  else
  {
    if (*(unsigned __int16 *)(v1 + 18) <= 0xDFu)
    {
      if (*(unsigned __int16 *)(v1 + 18) <= 0x68u)
      {
        if (v2 == 62) {
          return 42;
        }
        if (v2 == 83) {
          return 7;
        }
      }
      else
      {
        switch(v2)
        {
          case 0x69u:
            return 20;
          case 0xA4u:
            return 12;
          case 0xB7u:
            return 3;
        }
      }
      return 0;
    }
    switch(*(_WORD *)(v1 + 18))
    {
      case 0xF3:
        int v4 = *(unsigned __int8 *)(v1 + 4);
        if (v4 != 1)
        {
          if (v4 == 2) {
            return 32;
          }
          goto LABEL_51;
        }
        uint64_t result = 31;
        break;
      case 0xF4:
        return 62;
      case 0xF5:
      case 0xF6:
      case 0xF8:
      case 0xF9:
      case 0xFA:
        return 0;
      case 0xF7:
        return 8;
      case 0xFB:
        return 67;
      case 0xFC:
        return 10;
      default:
        if (v2 == 224)
        {
          int v7 = *(unsigned __int8 *)(v1 + 48);
          unsigned int v8 = v7 - 1;
          if ((v7 - 32) >= 0x26) {
            unsigned int v9 = 0;
          }
          else {
            unsigned int v9 = 30;
          }
          if (v8 >= 0x10) {
            uint64_t result = v9;
          }
          else {
            uint64_t result = 25;
          }
        }
        else
        {
          if (v2 != 258) {
            return 0;
          }
          int v5 = *(unsigned __int8 *)(v1 + 4);
          if (v5 != 1)
          {
            if (v5 == 2) {
              return 14;
            }
LABEL_51:
            llvm::report_fatal_error((llvm *)"Invalid ELFCLASS!", (const llvm::Twine *)1);
          }
          uint64_t result = 13;
        }
        break;
    }
  }
  return result;
}

uint64_t sub_1CD6DEE70@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 56);
  *(unsigned char *)(a2 + 8) &= ~1u;
  *(void *)a2 = *(void *)(v2 + 24);
  return result;
}

BOOL sub_1CD6DEE8C(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(a1 + 56) + 16) == 1;
}

uint64_t sub_1CD6DEEA0(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  sub_1CD6DF398((uint64_t)&v4, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v5)
  {
    uint64_t v3 = v4;
    uint64_t v4 = 0;
    llvm::report_fatal_error(&v3);
  }
  return *(void *)(v4 + 16);
}

uint64_t sub_1CD6DEF20(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  sub_1CD6DF398((uint64_t)&v4, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v5)
  {
    uint64_t v3 = v4;
    uint64_t v4 = 0;
    llvm::report_fatal_error(&v3);
  }
  return *(unsigned __int8 *)(v4 + 4) >> 4;
}

uint64_t sub_1CD6DEFA4(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  sub_1CD6DF398((uint64_t)&v4, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v5)
  {
    uint64_t v3 = v4;
    uint64_t v4 = 0;
    llvm::report_fatal_error(&v3);
  }
  return *(unsigned __int8 *)(v4 + 5);
}

uint64_t sub_1CD6DF024(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  sub_1CD6DF398((uint64_t)&v4, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v5)
  {
    uint64_t v3 = v4;
    uint64_t v4 = 0;
    llvm::report_fatal_error(&v3);
  }
  return *(unsigned char *)(v4 + 4) & 0xF;
}

uint64_t sub_1CD6DF0A8(uint64_t a1, uint64_t a2)
{
  return *(unsigned int *)(a2 + 4);
}

uint64_t sub_1CD6DF0B0(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 8);
}

uint64_t sub_1CD6DF0B8(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 24);
}

char *sub_1CD6DF0C0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (*((_DWORD *)sub_1CD6DF6AC(a1, a2) + 1) != 4)
  {
    unsigned int v8 = "Section is not SHT_RELA";
    __int16 v9 = 259;
    operator new();
  }
  uint64_t result = sub_1CD6DF800(a1, a2);
  uint64_t v7 = *((void *)result + 2);
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(void *)a3 = v7;
  return result;
}

void *sub_1CD6DF1A4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  char v5 = (void *)(a1 + 56);
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::sections((void *)(a1 + 56), (uint64_t)&v16);
  if (v18)
  {
    uint64_t v9 = v16;
    uint64_t v16 = 0;
    *a3 = v9;
    goto LABEL_8;
  }
  if (!v17)
  {
LABEL_6:
    *a3 = 0;
    goto LABEL_8;
  }
  uint64_t v7 = (_DWORD *)(v16 + 4);
  uint64_t v8 = v17 << 6;
  while (*v7 != 1879048195)
  {
    v7 += 16;
    v8 -= 64;
    if (!v8) {
      goto LABEL_6;
    }
  }
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSectionContents(v5, (uint64_t)(v7 - 1), (uint64_t)&v13);
  uint64_t v10 = v13;
  if (v15) {
    goto LABEL_19;
  }
  if (*v13 != 65 || v14 == 1)
  {
    uint64_t v10 = 0;
LABEL_19:
    *a3 = (uint64_t)v10;
    goto LABEL_8;
  }
  uint64_t result = llvm::ELFAttributeParser::parse(a2, (uint64_t)v13, v14, 1, a3);
  uint64_t v12 = *a3;
  if (v15)
  {
    uint64_t result = v13;
    uint64_t v13 = 0;
    if (result) {
      uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  if (!v12) {
    goto LABEL_6;
  }
LABEL_8:
  if (v18)
  {
    uint64_t result = (void *)v16;
    uint64_t v16 = 0;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  return result;
}

unint64_t sub_1CD6DF32C@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X8>)
{
  unint64_t v4 = sub_1CD6DFE74(a1);
  unint64_t v6 = v5;
  unint64_t result = sub_1CD6DFEC4(a1);
  *a2 = v4;
  a2[1] = v6;
  a2[2] = result;
  a2[3] = v8;
  return result;
}

uint64_t sub_1CD6DF374(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 56) + 48);
}

uint64_t sub_1CD6DF380(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(a1 + 56) + 16);
}

uint64_t sub_1CD6DF38C(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(a1 + 56) + 18);
}

void *sub_1CD6DF398(uint64_t a1, void *a2, unsigned int a3, unsigned int a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t result = (void *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSection(a2, a3, (uint64_t)&v9);
  unint64_t v8 = v9;
  if (v10)
  {
    *(unsigned char *)(a1 + 8) |= 1u;
    *(void *)a1 = v8;
  }
  else
  {
    unint64_t result = sub_1CD6D1BF4(a2, v9, a4, a1);
    if (v10)
    {
      unint64_t result = v9;
      uint64_t v9 = 0;
      if (result) {
        return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
      }
    }
  }
  return result;
}

unint64_t sub_1CD6DF474(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::sections((void *)(a1 + 56), (uint64_t)&v9);
  char v6 = v10;
  uint64_t v7 = v9;
  uint64_t v8 = ((unint64_t)(a2 - v9) >> 6);
  if (v10)
  {
    uint64_t v9 = 0;
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
  }
  if (v6) {
    return 0;
  }
  else {
    return v8 | ((unint64_t)a3 << 32);
  }
}

uint64_t sub_1CD6DF53C(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = a2[11];
  if (v8)
  {
    uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSHNDXTable(a2 + 7, v8, (uint64_t)&v16);
    uint64_t v9 = v16;
    if (v18) {
      goto LABEL_7;
    }
    uint64_t v10 = v17;
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
  }
  *(void *)&long long v13 = v9;
  *((void *)&v13 + 1) = v10;
  char v14 = 1;
  uint64_t v15 = 0;
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSection(a2 + 7, a3, a4, &v13, (uint64_t)&v16);
  uint64_t v9 = v16;
  if (v17)
  {
LABEL_7:
    *(unsigned char *)(a1 + 16) |= 1u;
    *(void *)a1 = v9;
    return result;
  }
  if (v16)
  {
    *(unsigned char *)(a1 + 16) &= ~1u;
    *(void *)a1 = v9;
    *(void *)(a1 + 8) = a2;
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(void *))(*a2 + 352))(a2);
    *(unsigned char *)(a1 + 16) &= ~1u;
    *(void *)a1 = result;
    *(void *)(a1 + 8) = v12;
    if (v17)
    {
      uint64_t result = v16;
      uint64_t v16 = 0;
      if (result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
    }
  }
  return result;
}

char *sub_1CD6DF6AC(uint64_t a1, unsigned int a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSection((void *)(a1 + 56), a2, (uint64_t)&v10);
  if (v11)
  {
    uint64_t v3 = v10;
    uint64_t v10 = 0;
    unint64_t v5 = v3;
    *(void *)&v6.__val_ = llvm::errorToErrorCode(&v5);
    v6.__cat_ = v4;
    std::error_code::message(&v7, &v6);
    __int16 v9 = 260;
    uint64_t v8 = &v7;
    llvm::report_fatal_error((llvm *)&v8, (const llvm::Twine *)1);
  }
  return v10;
}

char *sub_1CD6DF754(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  sub_1CD6DF8AC((uint64_t)&v9, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v10)
  {
    unint64_t v4 = v9;
    *(void *)&v5.__val_ = llvm::errorToErrorCode(&v4);
    v5.__cat_ = v3;
    std::error_code::message(&v6, &v5);
    __int16 v8 = 260;
    std::string v7 = &v6;
    llvm::report_fatal_error((llvm *)&v7, (const llvm::Twine *)1);
  }
  return v9;
}

char *sub_1CD6DF800(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  sub_1CD6DFB8C((uint64_t)&v9, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v10)
  {
    unint64_t v4 = v9;
    *(void *)&v5.__val_ = llvm::errorToErrorCode(&v4);
    v5.__cat_ = v3;
    std::error_code::message(&v6, &v5);
    __int16 v8 = 260;
    std::string v7 = &v6;
    llvm::report_fatal_error((llvm *)&v7, (const llvm::Twine *)1);
  }
  return v9;
}

void *sub_1CD6DF8AC(uint64_t a1, void *a2, unsigned int a3, unsigned int a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t result = (void *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSection(a2, a3, (uint64_t)&v9);
  __int16 v8 = v9;
  if (v10)
  {
    *(unsigned char *)(a1 + 8) |= 1u;
    *(void *)a1 = v8;
  }
  else
  {
    uint64_t result = sub_1CD6DF988(a1, a2, v9, a4);
    if (v10)
    {
      uint64_t result = v9;
      __int16 v9 = 0;
      if (result) {
        return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
      }
    }
  }
  return result;
}

void *sub_1CD6DF988(uint64_t a1, void *a2, void *a3, unsigned int a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::rels(a2, a3, (uint64_t)v26);
  if (v27)
  {
    uint64_t v8 = v26[0];
    char v9 = *(unsigned char *)(a1 + 8) | 1;
  }
  else
  {
    if (v26[1] <= (unint64_t)a4)
    {
      uint64_t v20 = "can't read an entry at 0x";
      __int16 v21 = 259;
      uint64_t v17 = 16 * a4;
      v18[0] = (uint64_t)&v17;
      void v18[2] = 0;
      __int16 v19 = 270;
      sub_1CB8F1E58((uint64_t *)&v20, v18, (uint64_t)v22);
      uint64_t v15 = ": it goes past the end of the section (0x";
      __int16 v16 = 259;
      sub_1CB8F1E58(v22, (uint64_t *)&v15, (uint64_t)v23);
      uint64_t v12 = a3[4];
      v13[0] = (uint64_t)&v12;
      void v13[2] = 0;
      __int16 v14 = 270;
      sub_1CB8F1E58(v23, v13, (uint64_t)v24);
      char v10 = ")";
      __int16 v11 = 259;
      sub_1CB8F1E58(v24, (uint64_t *)&v10, (uint64_t)v25);
      operator new();
    }
    uint64_t v8 = v26[0] + 16 * a4;
    char v9 = *(unsigned char *)(a1 + 8) & 0xFE;
  }
  *(unsigned char *)(a1 + 8) = v9;
  *(void *)a1 = v8;
  return result;
}

void *sub_1CD6DFB8C(uint64_t a1, void *a2, unsigned int a3, unsigned int a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t result = (void *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSection(a2, a3, (uint64_t)&v9);
  uint64_t v8 = v9;
  if (v10)
  {
    *(unsigned char *)(a1 + 8) |= 1u;
    *(void *)a1 = v8;
  }
  else
  {
    uint64_t result = sub_1CD6DFC68(a1, a2, v9, a4);
    if (v10)
    {
      uint64_t result = v9;
      char v9 = 0;
      if (result) {
        return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
      }
    }
  }
  return result;
}

void *sub_1CD6DFC68(uint64_t a1, void *a2, void *a3, unsigned int a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::relas(a2, a3, (uint64_t)v26);
  if (v27)
  {
    uint64_t v8 = v26[0];
    char v9 = *(unsigned char *)(a1 + 8) | 1;
  }
  else
  {
    if (v26[1] <= (unint64_t)a4)
    {
      uint64_t v20 = "can't read an entry at 0x";
      __int16 v21 = 259;
      uint64_t v17 = 24 * a4;
      v18[0] = (uint64_t)&v17;
      void v18[2] = 0;
      __int16 v19 = 270;
      sub_1CB8F1E58((uint64_t *)&v20, v18, (uint64_t)v22);
      uint64_t v15 = ": it goes past the end of the section (0x";
      __int16 v16 = 259;
      sub_1CB8F1E58(v22, (uint64_t *)&v15, (uint64_t)v23);
      uint64_t v12 = a3[4];
      v13[0] = (uint64_t)&v12;
      void v13[2] = 0;
      __int16 v14 = 270;
      sub_1CB8F1E58(v23, v13, (uint64_t)v24);
      char v10 = ")";
      __int16 v11 = 259;
      sub_1CB8F1E58(v24, (uint64_t *)&v10, (uint64_t)v25);
      operator new();
    }
    uint64_t v8 = v26[0] + 24 * a4;
    char v9 = *(unsigned char *)(a1 + 8) & 0xFE;
  }
  *(unsigned char *)(a1 + 8) = v9;
  *(void *)a1 = v8;
  return result;
}

unint64_t sub_1CD6DFE74(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 72);
  unsigned int v2 = v1 && *(void *)(v1 + 32) > 0x17uLL;
  return sub_1CD6DF474(a1, v1, v2);
}

unint64_t sub_1CD6DFEC4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 72);
  if (v1) {
    return sub_1CD6DF474(a1, v1, *(void *)(v1 + 32) / 0x18uLL);
  }
  else {
    return sub_1CD6DFE74(a1);
  }
}

void sub_1CD6DFF1C(uint64_t a1, long long *a2, int a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::create(*(void *)a2, *((void *)a2 + 1), (uint64_t)&v23);
  if (v25)
  {
    uint64_t v6 = v23;
    uint64_t v23 = 0;
    if (v6)
    {
      *(unsigned char *)(a1 + 104) |= 1u;
      *(void *)a1 = v6;
      return;
    }
  }
  else
  {
    uint64_t v6 = v23;
  }
  long long v7 = a2[1];
  long long v17 = *a2;
  long long v18 = v7;
  uint64_t v8 = v24;
  int v16 = 15;
  uint64_t v15 = &unk_1F2633340;
  char v19 = 0;
  uint64_t v20 = v6;
  uint64_t v21 = v24;
  memset(v22, 0, 24);
  long long v9 = 0uLL;
  if (!a3)
  {
    uint64_t v10 = 0;
LABEL_5:
    *(unsigned char *)(a1 + 104) &= ~1u;
    *(_DWORD *)(a1 + 8) = 15;
    long long v11 = v18;
    *(_OWORD *)(a1 + 16) = v17;
    *(_OWORD *)(a1 + 32) = v11;
    *(void *)a1 = &unk_1F2633340;
    *(unsigned char *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = v6;
    *(void *)(a1 + 64) = v8;
    *(_OWORD *)(a1 + 72) = v9;
    *(void *)(a1 + 88) = v10;
    goto LABEL_6;
  }
  sub_1CD6E00CC((uint64_t)&v15, &v14);
  uint64_t v13 = v14;
  if (!v14)
  {
    uint64_t v6 = v20;
    uint64_t v8 = v21;
    long long v9 = v22[0];
    uint64_t v10 = *(void *)&v22[1];
    goto LABEL_5;
  }
  *(unsigned char *)(a1 + 104) |= 1u;
  *(void *)a1 = v13;
LABEL_6:
  llvm::object::SymbolicFile::~SymbolicFile((llvm::object::SymbolicFile *)&v15);
  if (v25)
  {
    uint64_t v12 = v23;
    uint64_t v23 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
}

void *sub_1CD6E00CC@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::sections((void *)(a1 + 56), (uint64_t)&v10);
  uint64_t v5 = v10;
  if ((v12 & 1) == 0)
  {
    if (v11)
    {
      uint64_t v6 = v11 << 6;
      long long v7 = (unsigned int *)(v10 + 4);
      while (1)
      {
        unsigned int v8 = bswap32(*v7);
        if (v8 == 2) {
          break;
        }
        if (v8 != 18)
        {
          if (v8 != 11) {
            goto LABEL_11;
          }
          long long v9 = (void *)(a1 + 72);
          if (*(void *)(a1 + 72)) {
            goto LABEL_11;
          }
LABEL_10:
          *long long v9 = v7 - 1;
          goto LABEL_11;
        }
        long long v9 = (void *)(a1 + 88);
        if (!*(void *)(a1 + 88)) {
          goto LABEL_10;
        }
LABEL_11:
        v7 += 16;
        v6 -= 64;
        if (!v6) {
          goto LABEL_15;
        }
      }
      long long v9 = (void *)(a1 + 80);
      if (*(void *)(a1 + 80)) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
LABEL_15:
    uint64_t v5 = 0;
    *(unsigned char *)(a1 + 48) = 1;
  }
  *a2 = v5;
  return result;
}

void sub_1CD6E01D0(llvm::object::SymbolicFile *a1)
{
  llvm::object::SymbolicFile::~SymbolicFile(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD6E0208(uint64_t a1, uint64_t a2)
{
}

unint64_t sub_1CD6E0218(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 80);
  if (v1) {
    unsigned int v2 = bswap64(*(void *)(v1 + 32)) > 0x17;
  }
  else {
    unsigned int v2 = 0;
  }
  return sub_1CD6E24AC(a1, v1, v2);
}

unint64_t sub_1CD6E0264(void *a1)
{
  uint64_t v1 = a1[10];
  if (v1) {
    return sub_1CD6E24AC((uint64_t)a1, v1, bswap64(*(void *)(v1 + 32)) / 0x18);
  }
  else {
    return (*(uint64_t (**)(void *))(*a1 + 48))(a1);
  }
}

void sub_1CD6E02E0(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a1 + 7;
  sub_1CD6E23D0((uint64_t)&v31, a1 + 7, a2, HIDWORD(a2));
  if (v32)
  {
    long long v7 = v31;
    *(unsigned char *)(a3 + 16) |= 1u;
    *(void *)a3 = v7;
    return;
  }
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSection(v6, a2, (uint64_t)&v29);
  uint64_t v8 = v29;
  if ((v30 & 1) == 0)
  {
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSection(v6, bswap32(*(_DWORD *)(v29 + 40)), (uint64_t)&v27);
    uint64_t v10 = v27;
    if (v28)
    {
      uint64_t v27 = 0;
      *(unsigned char *)(a3 + 16) |= 1u;
      *(void *)a3 = v10;
LABEL_11:
      if (v30)
      {
        uint64_t v11 = v29;
        uint64_t v29 = 0;
        if (v11) {
          (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
        }
      }
      goto LABEL_6;
    }
    *(void *)&long long v23 = sub_1CCC487E0;
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getStringTable(v6, v27, (void (*)(uint64_t *__return_ptr, uint64_t, void *))sub_1CD6D6140, (uint64_t)&v23, (uint64_t)v25);
    if (v26)
    {
      uint64_t v12 = v25[0];
      v25[0] = 0;
      *(unsigned char *)(a3 + 16) |= 1u;
      *(void *)a3 = v12;
LABEL_16:
      if (v28)
      {
        uint64_t v13 = v27;
        uint64_t v27 = 0;
        if (v13) {
          (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
        }
      }
      goto LABEL_11;
    }
    sub_1CD6DC548((uint64_t)&v23, v31, v25[0], v25[1]);
    if ((v24 & 1) != 0 || !*((void *)&v23 + 1))
    {
      int v15 = v24 & 1;
      if ((v31[1] & 0xF) == 3)
      {
        (*(void (**)(uint64_t *__return_ptr, void *, uint64_t))(*a1 + 120))(&v20, a1, a2);
        if ((v22 & 1) == 0)
        {
          if (v15)
          {
            long long v17 = (void *)v23;
            *(void *)&long long v23 = 0;
          }
          else
          {
            long long v17 = 0;
          }
          char v19 = v17;
          sub_1CD4515D0(&v19);
          if (v19) {
            (*(void (**)(void *))(*v19 + 8))(v19);
          }
          (*(void (**)(uint64_t, uint64_t))(*(void *)v21 + 136))(v21, v20);
          if (v22)
          {
            uint64_t v18 = v20;
            uint64_t v20 = 0;
            if (v18) {
              (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
            }
          }
          if (v15 && (void)v23) {
            (*(void (**)(void))(*(void *)v23 + 8))(v23);
          }
          goto LABEL_23;
        }
        uint64_t v16 = v20;
        uint64_t v20 = 0;
        if (v16) {
          (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
        }
      }
      *(unsigned char *)(a3 + 16) = *(unsigned char *)(a3 + 16) & 0xFE | v15;
      if (v15)
      {
        *(void *)a3 = v23;
        goto LABEL_23;
      }
    }
    else
    {
      *(unsigned char *)(a3 + 16) &= ~1u;
    }
    *(_OWORD *)a3 = v23;
LABEL_23:
    if (v26)
    {
      uint64_t v14 = v25[0];
      v25[0] = 0;
      if (v14) {
        (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
      }
    }
    goto LABEL_16;
  }
  uint64_t v29 = 0;
  *(unsigned char *)(a3 + 16) |= 1u;
  *(void *)a3 = v8;
LABEL_6:
  if (v32)
  {
    long long v9 = v31;
    __int16 v31 = 0;
    if (v9) {
      (*(void (**)(unsigned int *))(*(void *)v9 + 8))(v9);
    }
  }
}

unint64_t *sub_1CD6E06D4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t result = llvm::object::ObjectFile::getSymbolValue(a1, a2, (uint64_t)&v25);
  if (v26)
  {
    long long v7 = v25;
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v7;
    return result;
  }
  uint64_t v8 = v25;
  uint64_t result = sub_1CD6E23D0((uint64_t)&v23, (void *)(a1 + 56), a2, HIDWORD(a2));
  uint64_t v9 = v23;
  if (v24)
  {
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v9;
  }
  else
  {
    unsigned int v10 = bswap32(*(unsigned __int16 *)(v23 + 6)) >> 16;
    if (v10 - 65521 >= 2 && v10 != 0)
    {
      uint64_t result = (unint64_t *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSection((void *)(a1 + 56), a2, (uint64_t)&v21);
      if (v22)
      {
        uint64_t v12 = v21;
        uint64_t v21 = 0;
      }
      else
      {
        if (*(_WORD *)(*(void *)(a1 + 56) + 16) != 256)
        {
LABEL_17:
          *(unsigned char *)(a3 + 8) &= ~1u;
          *(void *)a3 = v8;
          goto LABEL_20;
        }
        uint64_t v13 = *(void *)(a1 + 88);
        if (v13)
        {
          uint64_t result = (unint64_t *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSHNDXTable((void *)(a1 + 56), v13, (uint64_t)&v18);
          uint64_t v12 = v18;
          if (v20) {
            goto LABEL_19;
          }
          uint64_t v14 = v19;
        }
        else
        {
          uint64_t v12 = 0;
          uint64_t v14 = 0;
        }
        *(void *)&long long v15 = v12;
        *((void *)&v15 + 1) = v14;
        char v16 = 1;
        uint64_t v17 = 0;
        uint64_t result = (unint64_t *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSection((void *)(a1 + 56), v23, v21, &v15, (uint64_t)&v18);
        uint64_t v12 = v18;
        if ((v19 & 1) == 0)
        {
          if (v18) {
            uint64_t v8 = (unint64_t *)((char *)v8 + bswap64(v18[2]));
          }
          goto LABEL_17;
        }
      }
LABEL_19:
      *(unsigned char *)(a3 + 8) |= 1u;
      *(void *)a3 = v12;
LABEL_20:
      if (v22)
      {
        uint64_t result = v21;
        uint64_t v21 = 0;
        if (result) {
          uint64_t result = (unint64_t *)(*(uint64_t (**)(unint64_t *))(*result + 8))(result);
        }
      }
      if (v24)
      {
        uint64_t result = (unint64_t *)v23;
        uint64_t v23 = 0;
        if (result) {
          uint64_t result = (unint64_t *)(*(uint64_t (**)(unint64_t *))(*result + 8))(result);
        }
      }
      goto LABEL_12;
    }
    *(unsigned char *)(a3 + 8) &= ~1u;
    *(void *)a3 = v8;
  }
LABEL_12:
  if (v26)
  {
    uint64_t result = v25;
    char v25 = 0;
    if (result) {
      return (unint64_t *)(*(uint64_t (**)(unint64_t *))(*result + 8))(result);
    }
  }
  return result;
}

unint64_t sub_1CD6E094C(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1 + 56;
  sub_1CD6E23D0((uint64_t)&v6, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v7)
  {
    uint64_t v5 = v6;
    uint64_t v6 = 0;
    llvm::report_fatal_error(&v5);
  }
  unint64_t result = bswap64(*(void *)(v6 + 8));
  if (*(__int16 *)(v6 + 6) != -3585)
  {
    int v4 = *(unsigned __int16 *)(*(void *)v2 + 18);
    if ((v4 == 10240 || v4 == 2048) && (*(unsigned char *)(v6 + 4) & 0xF) == 2) {
      result &= ~1uLL;
    }
  }
  return result;
}

unint64_t sub_1CD6E0A1C(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  sub_1CD6E23D0((uint64_t)&v4, (void *)(a1 + 56), a2, HIDWORD(a2));
  if (v5)
  {
    uint64_t v3 = v4;
    uint64_t v4 = 0;
    llvm::report_fatal_error(&v3);
  }
  if (*(__int16 *)(v4 + 6) == -3329) {
    return bswap64(*(void *)(v4 + 8));
  }
  else {
    return 0;
  }
}

uint64_t sub_1CD6E0AB4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 432))();
}

unint64_t *sub_1CD6E0AE0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t result = sub_1CD6E23D0((uint64_t)&v7, (void *)(a1 + 56), a2, HIDWORD(a2));
  uint64_t v5 = v7;
  if (v8)
  {
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v5;
  }
  else
  {
    switch(*(unsigned char *)(v7 + 4) & 0xF)
    {
      case 0:
        *(unsigned char *)(a3 + 8) &= ~1u;
        *(_DWORD *)a3 = 0;
        return result;
      case 1:
      case 5:
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v6 = 2;
        goto LABEL_4;
      case 2:
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v6 = 5;
        goto LABEL_4;
      case 3:
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v6 = 3;
        goto LABEL_4;
      case 4:
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v6 = 4;
        goto LABEL_4;
      default:
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v6 = 1;
LABEL_4:
        *(_DWORD *)a3 = v6;
        break;
    }
  }
  return result;
}

unint64_t *sub_1CD6E0C10@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3 = a2;
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  int v6 = a1 + 7;
  unint64_t result = sub_1CD6E23D0((uint64_t)&v12, a1 + 7, a2, HIDWORD(a2));
  if (v13)
  {
    uint64_t v8 = (uint64_t)v12;
    *(unsigned char *)(a3 + 16) |= 1u;
    *(void *)a3 = v8;
  }
  else
  {
    unint64_t result = (unint64_t *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSection(v6, v3, (uint64_t)&v10);
    if (v11)
    {
      uint64_t v9 = v10;
      *(unsigned char *)(a3 + 16) |= 1u;
      *(void *)a3 = v9;
    }
    else
    {
      unint64_t result = (unint64_t *)sub_1CD6E2574(a3, a1, (uint64_t)v12, v10);
      if (v11)
      {
        unint64_t result = v10;
        unsigned int v10 = 0;
        if (result) {
          unint64_t result = (unint64_t *)(*(uint64_t (**)(unint64_t *))(*result + 8))(result);
        }
      }
    }
    if (v13)
    {
      unint64_t result = v12;
      uint64_t v12 = 0;
      if (result) {
        return (unint64_t *)(*(uint64_t (**)(unint64_t *))(*result + 8))(result);
      }
    }
  }
  return result;
}

void sub_1CD6E0D60(uint64_t a1, void *a2)
{
  *a2 += 64;
}

void sub_1CD6E0D70(uint64_t a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3 = sub_1CCC487E0;
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSectionName((void *)(a1 + 56), a2, (void (*)(uint64_t *__return_ptr, uint64_t, void *))sub_1CD6D6140, (uint64_t)&v3, a3);
}

unint64_t sub_1CD6E0DB8(uint64_t a1, uint64_t a2)
{
  return bswap64(*(void *)(a2 + 16));
}

uint64_t sub_1CD6E0DC4(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::sections((void *)(a1 + 56), (uint64_t)&v7);
  if (v8)
  {
    unsigned int v3 = v7;
    uint64_t v7 = 0;
  }
  else
  {
    unsigned int v3 = 0;
  }
  int v6 = v3;
  sub_1CCC4886C(&v6);
  if (v6) {
    (*(void (**)(void *))(*v6 + 8))(v6);
  }
  uint64_t v4 = v7;
  if (v8)
  {
    uint64_t v7 = 0;
    if (v4) {
      (*(void (**)(void *))(*v4 + 8))(v4);
    }
  }
  return (a2 - (uint64_t)v4) >> 6;
}

unint64_t sub_1CD6E0EB8(uint64_t a1, uint64_t a2)
{
  return bswap64(*(void *)(a2 + 32));
}

__n128 *sub_1CD6E0EC4@<X0>(__n128 *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3 = this;
  if (*(_DWORD *)(a2 + 4) == 0x8000000)
  {
    unint64_t v5 = this[1].n128_u64[0];
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(void *)a3 = v5;
    *(void *)(a3 + 8) = 0;
  }
  else
  {
    llvm::object::Binary::getMemoryBufferRef(this, v10);
    this = (__n128 *)sub_1CCC207AC((llvm::object *)v10, bswap64(*(void *)(a2 + 24)) + v3[1].n128_u64[0], bswap64(*(void *)(a2 + 32)), &v11);
    uint64_t v7 = v11;
    if (v11)
    {
      *(unsigned char *)(a3 + 16) |= 1u;
      *(void *)a3 = v7;
    }
    else
    {
      unint64_t v8 = v3[1].n128_u64[0] + bswap64(*(void *)(a2 + 24));
      unint64_t v9 = bswap64(*(void *)(a2 + 32));
      *(unsigned char *)(a3 + 16) &= ~1u;
      *(void *)a3 = v8;
      *(void *)(a3 + 8) = v9;
    }
  }
  return this;
}

unint64_t sub_1CD6E0F90(uint64_t a1, uint64_t a2)
{
  return bswap64(*(void *)(a2 + 48));
}

uint64_t sub_1CD6E0F9C(uint64_t a1, uint64_t a2)
{
  return (*(unsigned __int8 *)(a2 + 14) >> 3) & 1;
}

uint64_t sub_1CD6E0FA8(uint64_t a1, uint64_t a2)
{
  return (*(unsigned __int8 *)(a2 + 15) >> 2) & 1;
}

BOOL sub_1CD6E0FB4(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 4) != 0x1000000) {
    return 0;
  }
  char v2 = bswap64(*(void *)(a2 + 8));
  return (v2 & 2) != 0 && (v2 & 4) == 0;
}

BOOL sub_1CD6E0FE8(uint64_t a1, uint64_t a2)
{
  return (*(unsigned char *)(a2 + 15) & 3) != 0 && *(_DWORD *)(a2 + 4) == 0x8000000;
}

BOOL sub_1CD6E1010(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 4) == 0x8000000;
}

BOOL sub_1CD6E1024(uint64_t a1, uint64_t a2)
{
  char v2 = bswap64(*(void *)(a2 + 8));
  if ((v2 & 2) == 0) {
    return 0;
  }
  if ((v2 & 4) != 0) {
    return 1;
  }
  return (v2 & 1) == 0;
}

uint64_t sub_1CD6E1050(uint64_t a1, uint64_t a2)
{
  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 240))(a1) & 1) != 0 || *(_DWORD *)(a2 + 4) == 0x8000000) {
    return 0;
  }
  else {
    return (*(unsigned __int8 *)(a2 + 15) >> 1) & 1;
  }
}

uint64_t sub_1CD6E10B8(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::sections((void *)(a1 + 56), (uint64_t)&v5);
  uint64_t result = v5;
  if ((v6 & 1) == 0) {
    return ((a2 - v5)
  }
                        / (unint64_t)(bswap32(*(unsigned __int16 *)(*(void *)(a1 + 56) + 58)) >> 16));
  uint64_t v5 = 0;
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 8))(result);
    return 0;
  }
  return result;
}

uint64_t sub_1CD6E1188(void *a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (*(uint64_t (**)(void *))(*a1 + 264))(a1);
  int v5 = *(_DWORD *)(a2 + 4);
  if (v5 == 0x4000000 || v5 == 150994944)
  {
    unint64_t v8 = sub_1CD6E26E4((uint64_t)a1, v4);
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSection(a1 + 7, bswap32(*((_DWORD *)v8 + 10)), (uint64_t)&v16);
    if (v17)
    {
      unint64_t v9 = v16;
      char v16 = 0;
      uint64_t v11 = v9;
      *(void *)&v12.__val_ = llvm::errorToErrorCode(&v11);
      v12.__cat_ = v10;
      std::error_code::message(&v13, &v12);
      __int16 v15 = 260;
      uint64_t v14 = &v13;
      llvm::report_fatal_error((llvm *)&v14, (const llvm::Twine *)1);
    }
    v4 += (bswap64(*(void *)(a2 + 32)) / bswap64(*(void *)(a2 + 56))) << 32;
  }
  return v4;
}

uint64_t sub_1CD6E12C0@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = bswap32(*(_DWORD *)(a2 + 4));
  if (v5 == 4 || v5 == 9)
  {
    uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSection(a1 + 7, bswap32(*(_DWORD *)(a2 + 44)), (uint64_t)&v10);
    uint64_t v9 = v10;
    if (v11)
    {
      *(unsigned char *)(a3 + 16) |= 1u;
    }
    else
    {
      *(unsigned char *)(a3 + 16) &= ~1u;
      *(void *)(a3 + 8) = a1;
    }
    *(void *)a3 = v9;
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(void *))(*a1 + 352))(a1);
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(void *)a3 = result;
    *(void *)(a3 + 8) = v8;
  }
  return result;
}

void sub_1CD6E13B4(uint64_t a1, uint64_t a2)
{
}

unint64_t sub_1CD6E13C4(uint64_t a1, uint64_t a2)
{
  if (*((_DWORD *)sub_1CD6E26E4(a1, a2) + 1) == 150994944) {
    uint64_t v4 = (unint64_t *)sub_1CD6E278C(a1, a2);
  }
  else {
    uint64_t v4 = (unint64_t *)sub_1CD6E2838(a1, a2);
  }
  return bswap64(*v4);
}

unint64_t sub_1CD6E1418(void *a1, uint64_t a2)
{
  uint64_t v4 = sub_1CD6E26E4((uint64_t)a1, a2);
  if (*((_DWORD *)v4 + 1) == 150994944) {
    unsigned int v5 = sub_1CD6E278C((uint64_t)a1, a2);
  }
  else {
    unsigned int v5 = sub_1CD6E2838((uint64_t)a1, a2);
  }
  uint64_t v6 = a1[7];
  if (*(_WORD *)(v6 + 18) == 2048 && *(unsigned char *)(v6 + 4) == 2)
  {
    unint64_t v7 = bswap64(*((void *)v5 + 1));
    BOOL v8 = *(unsigned char *)(v6 + 5) == 1;
    unint64_t v9 = (v7 << 32) | (v7 >> 8) & 0xFF000000 | (v7 >> 24) & 0xFF0000 | (unsigned __int16)(HIDWORD(v7) >> 8) & 0xFF00 | HIBYTE(v7);
    if (!v8) {
      unint64_t v9 = v7;
    }
  }
  else
  {
    unint64_t v9 = bswap64(*((void *)v5 + 1));
  }
  if (HIDWORD(v9)) {
    return v9 & 0xFFFFFFFF00000000 | bswap32(*((_DWORD *)v4 + 10));
  }
  else {
    return (*(uint64_t (**)(void *))(*a1 + 56))(a1);
  }
}