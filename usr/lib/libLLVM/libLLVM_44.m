void sub_1CCD6DE6C()
{
  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CCD6DE80(uint64_t a1)
{
  unint64_t v5 = *(unsigned int *)(a1 + 12);
  v2 = (uint64_t *)(a1 + 40);
  unint64_t v4 = sub_1CD48BB60(*(void **)(a1 + 24), *(void *)(a1 + 24) + 8 * *(unsigned int *)(a1 + 36));
  unint64_t v5 = sub_1CD76ABAC((uint64_t *)&v5, v2, (uint64_t *)&v4);
  return sub_1CD76AA6C((uint64_t *)&v5, (int *)(a1 + 48), (char *)(a1 + 52), a1 + 56);
}

void *sub_1CCD6DEF0(uint64_t *a1, unsigned __int8 a2, uint64_t *__sz)
{
  if (*((_DWORD *)a1 + 2) <= a2) {
    return (void *)sub_1CB906F34(__sz, 8 << a2, 3);
  }
  uint64_t v3 = *a1;
  result = *(void **)(*a1 + 8 * a2);
  if (!result) {
    return (void *)sub_1CB906F34(__sz, 8 << a2, 3);
  }
  *(void *)(v3 + 8 * a2) = *result;
  return result;
}

void *sub_1CCD6DF2C(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    sub_1CD541698(a1, 2 * v6);
    uint64_t v7 = *a2;
    int v9 = *(_DWORD *)(a1 + 16) - 1;
    unsigned int v10 = (37 * *a2) & v9;
    a3 = (void *)(*(void *)a1 + 16 * v10);
    uint64_t v11 = *a3;
    if (*a2 != *a3)
    {
      v12 = 0;
      int v13 = 1;
      while (v11 != -1)
      {
        if (v12) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v11 == -2;
        }
        if (v20) {
          v12 = a3;
        }
        unsigned int v21 = v10 + v13++;
        unsigned int v10 = v21 & v9;
        a3 = (void *)(*(void *)a1 + 16 * v10);
        uint64_t v11 = *a3;
        if (v7 == *a3) {
          goto LABEL_4;
        }
      }
      goto LABEL_10;
    }
  }
  else
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
    {
LABEL_3:
      uint64_t v7 = *a3;
      goto LABEL_4;
    }
    sub_1CD541698(a1, v6);
    uint64_t v7 = *a2;
    int v14 = *(_DWORD *)(a1 + 16) - 1;
    unsigned int v15 = (37 * *a2) & v14;
    a3 = (void *)(*(void *)a1 + 16 * v15);
    uint64_t v16 = *a3;
    if (*a2 != *a3)
    {
      v12 = 0;
      int v17 = 1;
      while (v16 != -1)
      {
        if (v12) {
          BOOL v18 = 0;
        }
        else {
          BOOL v18 = v16 == -2;
        }
        if (v18) {
          v12 = a3;
        }
        unsigned int v19 = v15 + v17++;
        unsigned int v15 = v19 & v14;
        a3 = (void *)(*(void *)a1 + 16 * v15);
        uint64_t v16 = *a3;
        if (v7 == *a3) {
          goto LABEL_4;
        }
      }
LABEL_10:
      if (v12) {
        a3 = v12;
      }
      goto LABEL_3;
    }
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v7 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void sub_1CCD6E0A8(uint64_t *a1)
{
  v15[4] = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)a1 + 4))
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCF22E0, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EBCF22E0))
    {
      qword_1EBCF2300 = 0;
      qword_1EBCF22F0 = (uint64_t)&qword_1EBCF2300;
      qword_1EBCF2320 = (uint64_t)&unk_1EBCF2330;
      qword_1EBCF2328 = 0x400000000;
      qword_1EBCF22F8 = 0x400000001;
      __cxa_atexit((void (*)(void *))sub_1CCD6C688, &qword_1EBCF22F0, &dword_1CB82C000);
      __cxa_guard_release(&qword_1EBCF22E0);
    }
    v12[0] = v13;
    v12[1] = (void *)0x400000000;
    if (qword_1EBCF22F8) {
      sub_1CBB08064((uint64_t)v12, (uint64_t)&qword_1EBCF22F0);
    }
    v14[0] = v15;
    v14[1] = (void *)0x400000000;
    if (qword_1EBCF2328) {
      sub_1CBB08064((uint64_t)v14, (uint64_t)&qword_1EBCF2320);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCF22E8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EBCF22E8))
    {
      qword_1EBCF2360 = 1;
      qword_1EBCF2350 = (uint64_t)&qword_1EBCF2360;
      qword_1EBCF2380 = (uint64_t)&unk_1EBCF2390;
      qword_1EBCF2388 = 0x400000000;
      qword_1EBCF2358 = 0x400000001;
      __cxa_atexit((void (*)(void *))sub_1CCD6C688, &qword_1EBCF2350, &dword_1CB82C000);
      __cxa_guard_release(&qword_1EBCF22E8);
    }
    v8[0] = v9;
    v8[1] = (void *)0x400000000;
    if (qword_1EBCF2358) {
      sub_1CBB08064((uint64_t)v8, (uint64_t)&qword_1EBCF2350);
    }
    v10[0] = v11;
    v10[1] = (void *)0x400000000;
    if (qword_1EBCF2388) {
      sub_1CBB08064((uint64_t)v10, (uint64_t)&qword_1EBCF2380);
    }
    uint64_t v2 = *((unsigned int *)a1 + 4);
    if (v2)
    {
      uint64_t v3 = *a1;
      uint64_t v4 = 96 * v2;
      int v5 = (void *)(v3 + 64);
      do
      {
        unsigned int v6 = (void *)*(v5 - 2);
        if (v5 != v6) {
          free(v6);
        }
        uint64_t v7 = (char *)*(v5 - 8);
        if (v5 - 6 != (void *)v7) {
          free(v7);
        }
        v5 += 12;
        v4 -= 96;
      }
      while (v4);
    }
    if (v10[0] != v11) {
      free(v10[0]);
    }
    if (v8[0] != v9) {
      free(v8[0]);
    }
    if (v14[0] != v15) {
      free(v14[0]);
    }
    if (v12[0] != v13) {
      free(v12[0]);
    }
  }
}

void *sub_1CCD6E34C(void *result, void *a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v3 = result;
    unsigned int v4 = *(_DWORD *)(a3 + 8);
    do
    {
      if (v4 >= *(_DWORD *)(a3 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a3 + 8 * v4) = *v3;
      unsigned int v4 = *(_DWORD *)(a3 + 8) + 1;
      *(_DWORD *)(a3 + 8) = v4;
      ++v3;
    }
    while (v3 != a2);
  }
  return result;
}

void sub_1CCD6E3EC(long long *a1, long long *a2, unint64_t a3, long long *a4, uint64_t a5)
{
  v91[4] = *MEMORY[0x1E4F143B8];
  if (a3 >= 2)
  {
    unsigned int v6 = a1;
    if (a3 == 2)
    {
      if (*((_DWORD *)a2 - 14) > *((_DWORD *)a1 + 4))
      {
        uint64_t v7 = (long long *)((char *)a2 - 72);
        sub_1CCD6EE34(a1, v7);
      }
    }
    else if ((uint64_t)a3 <= 0)
    {
      if (a1 != a2)
      {
        int v14 = (long long *)((char *)a1 + 72);
        if ((long long *)((char *)a1 + 72) != a2)
        {
          uint64_t v15 = 0;
          uint64_t v16 = a1;
          do
          {
            int v17 = v14;
            if (*((_DWORD *)v16 + 22) > *((_DWORD *)v16 + 4))
            {
              long long v87 = *v14;
              int v88 = *((_DWORD *)v14 + 4);
              v89 = v91;
              unint64_t v90 = 0x400000000;
              unsigned int v18 = *((_DWORD *)v16 + 26);
              if (v18 && &v89 != (void **)(v16 + 6))
              {
                unsigned int v19 = (long long *)*((void *)v16 + 12);
                if (v19 == v16 + 7)
                {
                  if (v18 >= 5) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  memcpy(v91, v19, 8 * *((unsigned int *)v16 + 26));
                  LODWORD(v90) = v18;
                }
                else
                {
                  v89 = (void *)*((void *)v16 + 12);
                  unint64_t v90 = __PAIR64__(*((_DWORD *)v16 + 27), v18);
                  *((void *)v16 + 12) = v16 + 7;
                  *((_DWORD *)v16 + 27) = 0;
                }
                *((_DWORD *)v16 + 26) = 0;
              }
              uint64_t v20 = v15;
              while (1)
              {
                uint64_t v21 = v20;
                uint64_t v22 = (uint64_t)v6 + v20;
                *(_OWORD *)(v22 + 72) = *(long long *)((char *)v6 + v20);
                *(_DWORD *)(v22 + 88) = *(_DWORD *)((char *)v6 + v20 + 16);
                v23 = (void **)((char *)v6 + v20 + 96);
                v24 = *(char **)((char *)v6 + v20 + 24);
                if ((char *)v6 + v20 + 40 == v24)
                {
                  v25 = (_DWORD *)(v22 + 32);
                  uint64_t v26 = *(unsigned int *)(v22 + 32);
                  uint64_t v27 = *(unsigned int *)(v22 + 104);
                  if (v27 >= v26)
                  {
                    if (v26) {
                      memmove(*v23, v24, 8 * v26);
                    }
                  }
                  else
                  {
                    if (*(_DWORD *)((char *)v6 + v20 + 108) < v26)
                    {
                      *(_DWORD *)(v22 + 104) = 0;
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    if (v27) {
                      memmove(*v23, v24, 8 * v27);
                    }
                    else {
                      uint64_t v27 = 0;
                    }
                    uint64_t v28 = *v25;
                    if (v27 != v28) {
                      memcpy((void *)(*(void *)(v22 + 96) + 8 * v27), (const void *)(*(void *)(v22 + 24) + 8 * v27), 8 * v28 - 8 * v27);
                    }
                  }
                  *(_DWORD *)(v22 + 104) = v26;
                }
                else
                {
                  v29 = *v23;
                  if ((void *)(v22 + 112) != v29)
                  {
                    free(v29);
                    v24 = *(char **)(v22 + 24);
                  }
                  uint64_t v30 = (uint64_t)v6 + v21;
                  *(void *)(v22 + 96) = v24;
                  v25 = v16 + 2;
                  *(void *)(v30 + 104) = *(void *)((char *)v6 + v21 + 32);
                  *(void *)(v22 + 24) = v22 + 40;
                  *(_DWORD *)(v30 + 36) = 0;
                }
                _DWORD *v25 = 0;
                if (!v21) {
                  break;
                }
                uint64_t v16 = (long long *)((char *)v16 - 72);
                uint64_t v20 = v21 - 72;
                if (v88 <= *(_DWORD *)((char *)v6 + v21 - 56))
                {
                  v31 = (long long *)((char *)v6 + v21);
                  goto LABEL_43;
                }
              }
              v31 = v6;
LABEL_43:
              long long *v31 = v87;
              *((_DWORD *)v31 + 4) = v88;
              v32 = v89;
              if (v31 != &v87)
              {
                v33 = (void **)((char *)v6 + v21 + 24);
                if (v89 == v91)
                {
                  int v34 = v90;
                  uint64_t v35 = *((unsigned int *)v31 + 8);
                  if (v35 >= v90)
                  {
                    if (v90) {
                      memmove(*v33, v91, 8 * v90);
                    }
                    *((_DWORD *)v31 + 8) = v34;
                  }
                  else
                  {
                    if (*((_DWORD *)v31 + 9) < v90)
                    {
                      *((_DWORD *)v31 + 8) = 0;
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    if (v35) {
                      memmove(*v33, v91, 8 * v35);
                    }
                    else {
                      uint64_t v35 = 0;
                    }
                    if (v35 != v90) {
                      memcpy((char *)*v33 + 8 * v35, (char *)v89 + 8 * v35, 8 * v90 - 8 * v35);
                    }
                    *((_DWORD *)v31 + 8) = v34;
                  }
                }
                else
                {
                  if (*v33 != (char *)v31 + 40)
                  {
                    free(*v33);
                    v32 = v89;
                  }
                  *v33 = v32;
                  *((void *)v31 + 4) = v90;
                  v89 = v91;
                  HIDWORD(v90) = 0;
                }
                LODWORD(v90) = 0;
                v32 = v89;
              }
              if (v32 != v91) {
                free(v32);
              }
            }
            int v14 = (long long *)((char *)v17 + 72);
            v15 += 72;
            uint64_t v16 = v17;
          }
          while ((long long *)((char *)v17 + 72) != a2);
        }
      }
    }
    else
    {
      unint64_t v11 = a3 >> 1;
      v12 = (long long *)((char *)a1 + 72 * (a3 >> 1));
      unint64_t v13 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        sub_1CCD6F16C(a1, v12, v13, (uint64_t)a4);
        uint64_t v36 = (uint64_t)a4 + 72 * v11;
        sub_1CCD6F16C((long long *)((char *)v6 + 72 * (a3 >> 1)), a2, a3 - (a3 >> 1), v36);
        unint64_t v83 = a3;
        v84 = a4;
        v37 = (char *)a4 + 72 * a3;
        uint64_t v38 = v36;
        v39 = a4;
        __src = v37;
        while ((char *)v38 != v37)
        {
          v40 = (void **)v6 + 3;
          if (*(_DWORD *)(v38 + 16) <= *((_DWORD *)v39 + 4))
          {
            long long v47 = *v39;
            *((_DWORD *)v6 + 4) = *((_DWORD *)v39 + 4);
            *unsigned int v6 = v47;
            if (v6 != v39)
            {
              v48 = (char *)*((void *)v39 + 3);
              if (v48 == (char *)v39 + 40)
              {
                v49 = v39 + 2;
                uint64_t v50 = *((unsigned int *)v39 + 8);
                uint64_t v51 = *((unsigned int *)v6 + 8);
                if (v51 >= v50)
                {
                  if (v50) {
                    memmove(*v40, v48, 8 * v50);
                  }
                  *((_DWORD *)v6 + 8) = v50;
                  v37 = __src;
                }
                else
                {
                  if (*((_DWORD *)v6 + 9) < v50)
                  {
                    *((_DWORD *)v6 + 8) = 0;
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  if (v51) {
                    memmove(*v40, v48, 8 * v51);
                  }
                  else {
                    uint64_t v51 = 0;
                  }
                  uint64_t v52 = *v49;
                  if (v51 != v52) {
                    memcpy((char *)*v40 + 8 * v51, (const void *)(*((void *)v39 + 3) + 8 * v51), 8 * v52 - 8 * v51);
                  }
                  *((_DWORD *)v6 + 8) = v50;
                }
              }
              else
              {
                v54 = (char *)*((void *)v6 + 3);
                if ((char *)v6 + 40 != v54)
                {
                  free(v54);
                  v48 = (char *)*((void *)v39 + 3);
                }
                *((void *)v6 + 3) = v48;
                v49 = v39 + 2;
                *((void *)v6 + 4) = *((void *)v39 + 4);
                *((void *)v39 + 3) = (char *)v39 + 40;
                *((_DWORD *)v39 + 9) = 0;
              }
              _DWORD *v49 = 0;
            }
            v39 = (long long *)((char *)v39 + 72);
          }
          else
          {
            long long v41 = *(_OWORD *)v38;
            *((_DWORD *)v6 + 4) = *(_DWORD *)(v38 + 16);
            *unsigned int v6 = v41;
            if (v6 != (long long *)v38)
            {
              v42 = *(const void **)(v38 + 24);
              if (v42 == (const void *)(v38 + 40))
              {
                v43 = (_DWORD *)(v38 + 32);
                uint64_t v44 = *(unsigned int *)(v38 + 32);
                uint64_t v45 = *((unsigned int *)v6 + 8);
                if (v45 >= v44)
                {
                  if (v44) {
                    memmove(*v40, v42, 8 * v44);
                  }
                  *((_DWORD *)v6 + 8) = v44;
                  v37 = __src;
                }
                else
                {
                  if (*((_DWORD *)v6 + 9) < v44)
                  {
                    *((_DWORD *)v6 + 8) = 0;
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  if (v45) {
                    memmove(*v40, v42, 8 * v45);
                  }
                  else {
                    uint64_t v45 = 0;
                  }
                  uint64_t v46 = *v43;
                  if (v45 != v46) {
                    memcpy((char *)*v40 + 8 * v45, (const void *)(*(void *)(v38 + 24) + 8 * v45), 8 * v46 - 8 * v45);
                  }
                  *((_DWORD *)v6 + 8) = v44;
                }
              }
              else
              {
                v53 = (char *)*((void *)v6 + 3);
                if ((char *)v6 + 40 != v53)
                {
                  free(v53);
                  v42 = *(const void **)(v38 + 24);
                }
                *((void *)v6 + 3) = v42;
                v43 = (_DWORD *)(v38 + 32);
                *((void *)v6 + 4) = *(void *)(v38 + 32);
                *(void *)(v38 + 24) = v38 + 40;
                *(_DWORD *)(v38 + 36) = 0;
              }
              _DWORD *v43 = 0;
            }
            v38 += 72;
          }
          unsigned int v6 = (long long *)((char *)v6 + 72);
          if (v39 == (long long *)v36)
          {
            if ((char *)v38 != v37)
            {
              uint64_t v67 = 0;
              uint64_t v68 = v38;
              do
              {
                uint64_t v69 = v38 + v67;
                uint64_t v70 = (uint64_t)v6 + v67;
                long long v71 = *(_OWORD *)(v38 + v67);
                *(_DWORD *)(v70 + 16) = *(_DWORD *)(v38 + v67 + 16);
                *(_OWORD *)uint64_t v70 = v71;
                if (v6 != (long long *)v38)
                {
                  v72 = *(const void **)(v69 + 24);
                  if ((const void *)(v69 + 40) == v72)
                  {
                    v74 = (_DWORD *)(v38 + v67 + 32);
                    uint64_t v73 = *v74;
                    uint64_t v75 = (uint64_t)v6 + v67;
                    uint64_t v76 = *(unsigned int *)((char *)v6 + v67 + 32);
                    if (v76 >= v73)
                    {
                      if (v73) {
                        memmove(*(void **)(v70 + 24), v72, 8 * v73);
                      }
                    }
                    else
                    {
                      v77 = (void *)(v70 + 24);
                      if (*(_DWORD *)(v75 + 36) < v73)
                      {
                        *(_DWORD *)(v75 + 32) = 0;
                        llvm::SmallVectorBase<unsigned int>::grow_pod();
                      }
                      if (v76)
                      {
                        memmove(*(void **)(v70 + 24), v72, 8 * v76);
                        v77 = (void *)(v70 + 24);
                      }
                      else
                      {
                        uint64_t v76 = 0;
                      }
                      uint64_t v78 = *v74;
                      if (v76 != v78) {
                        memcpy((void *)(*v77 + 8 * v76), (const void *)(*(void *)(v69 + 24) + 8 * v76), 8 * v78 - 8 * v76);
                      }
                    }
                    *(_DWORD *)(v75 + 32) = v73;
                  }
                  else
                  {
                    v79 = *(char **)(v70 + 24);
                    if ((char *)v6 + v67 + 40 != v79)
                    {
                      free(v79);
                      v72 = *(const void **)(v69 + 24);
                    }
                    *(void *)(v70 + 24) = v72;
                    v74 = (_DWORD *)(v68 + 32);
                    *(void *)((char *)v6 + v67 + 32) = *(void *)(v38 + v67 + 32);
                    *(void *)(v69 + 24) = v69 + 40;
                    *(_DWORD *)(v38 + v67 + 36) = 0;
                  }
                  _DWORD *v74 = 0;
                  v37 = __src;
                }
                v68 += 72;
                v67 += 72;
              }
              while ((char *)(v38 + v67) != v37);
            }
            goto LABEL_153;
          }
        }
        if (v39 != (long long *)v36)
        {
          uint64_t v55 = 0;
          v56 = v39;
          uint64_t v85 = v36;
          do
          {
            uint64_t v57 = (uint64_t)v6 + v55;
            v58 = (char *)v39 + v55;
            long long v59 = *(long long *)((char *)v39 + v55);
            *(_DWORD *)(v57 + 16) = *(_DWORD *)((char *)v39 + v55 + 16);
            *(_OWORD *)uint64_t v57 = v59;
            if (v6 != v39)
            {
              v60 = (void **)(v57 + 24);
              v61 = (char *)*((void *)v58 + 3);
              if (v58 + 40 == v61)
              {
                v63 = (_DWORD *)((char *)v39 + v55 + 32);
                uint64_t v62 = *v63;
                uint64_t v64 = (uint64_t)v6 + v55;
                uint64_t v65 = *(unsigned int *)((char *)v6 + v55 + 32);
                if (v65 >= v62)
                {
                  if (v62) {
                    memmove(*v60, v61, 8 * v62);
                  }
                }
                else
                {
                  if (*(_DWORD *)(v64 + 36) < v62)
                  {
                    *(_DWORD *)(v64 + 32) = 0;
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  if (v65) {
                    memmove(*v60, v61, 8 * v65);
                  }
                  else {
                    uint64_t v65 = 0;
                  }
                  uint64_t v66 = *v63;
                  if (v65 != v66) {
                    memcpy((char *)*v60 + 8 * v65, (const void *)(*((void *)v58 + 3) + 8 * v65), 8 * v66 - 8 * v65);
                  }
                }
                *(_DWORD *)(v64 + 32) = v62;
              }
              else
              {
                if ((char *)v6 + v55 + 40 != *v60)
                {
                  free(*v60);
                  v61 = (char *)*((void *)v58 + 3);
                }
                *v60 = v61;
                v63 = v56 + 2;
                *(void *)((char *)v6 + v55 + 32) = *(void *)((char *)v39 + v55 + 32);
                *((void *)v58 + 3) = v58 + 40;
                *(_DWORD *)((char *)v39 + v55 + 36) = 0;
              }
              _DWORD *v63 = 0;
              uint64_t v36 = v85;
            }
            v56 = (long long *)((char *)v56 + 72);
            v55 += 72;
          }
          while ((long long *)((char *)v39 + v55) != (long long *)v36);
        }
LABEL_153:
        if (v84)
        {
          unint64_t v80 = v83;
          v81 = (void *)v84 + 5;
          do
          {
            v82 = (void *)*(v81 - 2);
            if (v81 != v82) {
              free(v82);
            }
            v81 += 9;
            --v80;
          }
          while (v80);
        }
      }
      else
      {
        sub_1CCD6E3EC(a1, v12, v13, a4, a5);
        sub_1CCD6E3EC((char *)v6 + 72 * (a3 >> 1), a2, a3 - (a3 >> 1), a4, a5);
        sub_1CCD6FCFC(v6, (long long *)((char *)v6 + 72 * (a3 >> 1)), a2, a3 >> 1, a3 - (a3 >> 1), a4, a5);
      }
    }
  }
}

void sub_1CCD6EE34(long long *a1, long long *a2)
{
  v21[4] = *MEMORY[0x1E4F143B8];
  long long v17 = *a1;
  int v18 = *((_DWORD *)a1 + 4);
  unsigned int v19 = v21;
  unint64_t v20 = 0x400000000;
  uint64_t v4 = *((unsigned int *)a1 + 8);
  if (v4 && &v17 != a1)
  {
    int v5 = (char *)*((void *)a1 + 3);
    if (v5 == (char *)a1 + 40)
    {
      if (v4 >= 5) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v21, v5, 8 * v4);
      LODWORD(v20) = v4;
    }
    else
    {
      unsigned int v19 = (void *)*((void *)a1 + 3);
      unint64_t v20 = __PAIR64__(*((_DWORD *)a1 + 9), v4);
      *((void *)a1 + 3) = (char *)a1 + 40;
      *((_DWORD *)a1 + 9) = 0;
    }
    LODWORD(v4) = 0;
    *((_DWORD *)a1 + 8) = 0;
  }
  long long v6 = *a2;
  *((_DWORD *)a1 + 4) = *((_DWORD *)a2 + 4);
  *a1 = v6;
  uint64_t v7 = (void **)a2 + 3;
  if (a1 != a2)
  {
    v8 = (char *)*((void *)a2 + 3);
    if (v8 == (char *)a2 + 40)
    {
      int v9 = (void **)a1 + 3;
      unint64_t v11 = a2 + 2;
      uint64_t v10 = *((unsigned int *)a2 + 8);
      if (v4 >= v10)
      {
        if (v10) {
          memmove(*v9, v8, 8 * v10);
        }
      }
      else
      {
        if (*((_DWORD *)a1 + 9) < v10)
        {
          *((_DWORD *)a1 + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v4)
        {
          uint64_t v4 = v4;
          memmove(*v9, v8, 8 * v4);
          int v9 = (void **)a1 + 3;
        }
        else
        {
          uint64_t v4 = 0;
        }
        uint64_t v12 = *v11;
        if (v4 != v12) {
          memcpy((char *)*v9 + 8 * v4, (char *)*v7 + 8 * v4, (unsigned char *)*v7 + 8 * v12 - ((unsigned char *)*v7 + 8 * v4));
        }
      }
      *((_DWORD *)a1 + 8) = v10;
    }
    else
    {
      uint64_t v16 = (char *)*((void *)a1 + 3);
      if (v16 != (char *)a1 + 40)
      {
        free(v16);
        v8 = (char *)*v7;
      }
      *((void *)a1 + 3) = v8;
      unint64_t v11 = a2 + 2;
      *((void *)a1 + 4) = *((void *)a2 + 4);
      *((void *)a2 + 3) = (char *)a2 + 40;
      *((_DWORD *)a2 + 9) = 0;
    }
    *unint64_t v11 = 0;
  }
  *a2 = v17;
  *((_DWORD *)a2 + 4) = v18;
  unint64_t v13 = v19;
  if (&v17 != a2)
  {
    if (v19 == v21)
    {
      int v14 = v20;
      uint64_t v15 = *((unsigned int *)a2 + 8);
      if (v15 >= v20)
      {
        if (v20) {
          memmove(*v7, v21, 8 * v20);
        }
      }
      else
      {
        if (*((_DWORD *)a2 + 9) < v20)
        {
          *((_DWORD *)a2 + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v15) {
          memmove(*v7, v21, 8 * v15);
        }
        else {
          uint64_t v15 = 0;
        }
        if (v15 != v20) {
          memcpy((char *)*v7 + 8 * v15, (char *)v19 + 8 * v15, 8 * v20 - 8 * v15);
        }
      }
      *((_DWORD *)a2 + 8) = v14;
    }
    else
    {
      if (*((long long **)a2 + 3) != (long long *)((char *)a2 + 40))
      {
        free(*((void **)a2 + 3));
        unint64_t v13 = v19;
      }
      *((void *)a2 + 3) = v13;
      *((void *)a2 + 4) = v20;
      unsigned int v19 = v21;
      HIDWORD(v20) = 0;
    }
    LODWORD(v20) = 0;
    unint64_t v13 = v19;
  }
  if (v13 != v21) {
    free(v13);
  }
}

void sub_1CCD6F16C(long long *a1, long long *a2, unint64_t a3, uint64_t a4)
{
  if (!a3) {
    return;
  }
  uint64_t v4 = a4;
  uint64_t v7 = a1;
  if (a3 != 2)
  {
    if (a3 == 1)
    {
      long long v8 = *a1;
      *(_DWORD *)(a4 + 16) = *((_DWORD *)a1 + 4);
      *(_OWORD *)a4 = v8;
      *(void *)(a4 + 24) = a4 + 40;
      *(void *)(a4 + 32) = 0x400000000;
      uint64_t v10 = a1 + 2;
      unsigned int v9 = *((_DWORD *)a1 + 8);
      if (v9 && (long long *)a4 != a1)
      {
        unint64_t v11 = (long long *)*((void *)a1 + 3);
        uint64_t v12 = (char *)a1 + 40;
        if (v11 == (long long *)((char *)a1 + 40))
        {
          if (v9 >= 5) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy((void *)(a4 + 40), v12, 8 * *((unsigned int *)a1 + 8));
          *(_DWORD *)(v4 + 32) = v9;
          goto LABEL_97;
        }
        *(void *)(a4 + 24) = v11;
        int v98 = *((_DWORD *)a1 + 9);
        *(_DWORD *)(a4 + 32) = v9;
        *(_DWORD *)(a4 + 36) = v98;
LABEL_153:
        *((void *)v7 + 3) = v12;
        *((_DWORD *)v7 + 9) = 0;
LABEL_97:
        *uint64_t v10 = 0;
        return;
      }
      return;
    }
    if ((uint64_t)a3 > 8)
    {
      uint64_t v69 = (long long *)((char *)a1 + 72 * (a3 >> 1));
      sub_1CCD6E3EC(a1, v69, a3 >> 1, a4, a3 >> 1);
      sub_1CCD6E3EC((char *)v7 + 72 * (a3 >> 1), a2, a3 - (a3 >> 1), v4 + 72 * (a3 >> 1), a3 - (a3 >> 1));
      uint64_t v70 = (long long *)((char *)v7 + 72 * (a3 >> 1));
      while (v70 != a2)
      {
        long long v71 = (void *)(v4 + 40);
        if (*((_DWORD *)v70 + 4) <= *((_DWORD *)v7 + 4))
        {
          long long v75 = *v7;
          *(_DWORD *)(v4 + 16) = *((_DWORD *)v7 + 4);
          *(_OWORD *)uint64_t v4 = v75;
          *(void *)(v4 + 24) = v71;
          *(void *)(v4 + 32) = 0x400000000;
          unsigned int v76 = *((_DWORD *)v7 + 8);
          if (v76 && (long long *)v4 != v7)
          {
            v77 = (char *)*((void *)v7 + 3);
            if (v77 == (char *)v7 + 40)
            {
              if (v76 >= 5) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              memcpy(v71, v77, 8 * *((unsigned int *)v7 + 8));
              *(_DWORD *)(v4 + 32) = v76;
            }
            else
            {
              *(void *)(v4 + 24) = v77;
              int v79 = *((_DWORD *)v7 + 9);
              *(_DWORD *)(v4 + 32) = v76;
              *(_DWORD *)(v4 + 36) = v79;
              *((void *)v7 + 3) = (char *)v7 + 40;
              *((_DWORD *)v7 + 9) = 0;
            }
            *((_DWORD *)v7 + 8) = 0;
          }
          uint64_t v7 = (long long *)((char *)v7 + 72);
        }
        else
        {
          long long v72 = *v70;
          *(_DWORD *)(v4 + 16) = *((_DWORD *)v70 + 4);
          *(_OWORD *)uint64_t v4 = v72;
          *(void *)(v4 + 24) = v71;
          *(void *)(v4 + 32) = 0x400000000;
          unsigned int v73 = *((_DWORD *)v70 + 8);
          if (v73 && (long long *)v4 != v70)
          {
            v74 = (char *)*((void *)v70 + 3);
            if (v74 == (char *)v70 + 40)
            {
              if (v73 >= 5) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              memcpy(v71, v74, 8 * *((unsigned int *)v70 + 8));
              *(_DWORD *)(v4 + 32) = v73;
            }
            else
            {
              *(void *)(v4 + 24) = v74;
              int v78 = *((_DWORD *)v70 + 9);
              *(_DWORD *)(v4 + 32) = v73;
              *(_DWORD *)(v4 + 36) = v78;
              *((void *)v70 + 3) = (char *)v70 + 40;
              *((_DWORD *)v70 + 9) = 0;
            }
            *((_DWORD *)v70 + 8) = 0;
          }
          uint64_t v70 = (long long *)((char *)v70 + 72);
        }
        v4 += 72;
        if (v7 == v69)
        {
          if (v70 != a2)
          {
            uint64_t v89 = 0;
            do
            {
              uint64_t v90 = (uint64_t)v70 + v89;
              uint64_t v91 = v4 + v89;
              long long v92 = *(long long *)((char *)v70 + v89);
              *(_DWORD *)(v91 + 16) = *(_DWORD *)((char *)v70 + v89 + 16);
              *(_OWORD *)uint64_t v91 = v92;
              v93 = (void *)(v4 + v89 + 40);
              *(void *)(v4 + v89 + 24) = v93;
              *(void *)(v91 + 32) = 0x400000000;
              unsigned int v94 = *(_DWORD *)((char *)v70 + v89 + 32);
              if (v94) {
                BOOL v95 = v91 == v90;
              }
              else {
                BOOL v95 = 1;
              }
              if (!v95)
              {
                v96 = *(const void **)(v90 + 24);
                if ((const void *)(v90 + 40) == v96)
                {
                  if (v94 >= 5) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  memcpy(v93, v96, 8 * *(unsigned int *)((char *)v70 + v89 + 32));
                  *(_DWORD *)(v91 + 32) = v94;
                }
                else
                {
                  *(void *)(v91 + 24) = v96;
                  int v97 = *(_DWORD *)((char *)v70 + v89 + 36);
                  *(_DWORD *)(v91 + 32) = v94;
                  *(_DWORD *)(v91 + 36) = v97;
                  *(void *)(v90 + 24) = v90 + 40;
                  *(_DWORD *)((char *)v70 + v89 + 36) = 0;
                }
                *(_DWORD *)(v90 + 32) = 0;
              }
              v89 += 72;
            }
            while ((long long *)((char *)v70 + v89) != a2);
          }
          return;
        }
      }
      if (v7 != v69)
      {
        uint64_t v80 = 0;
        do
        {
          uint64_t v81 = v4 + v80;
          uint64_t v82 = (uint64_t)v7 + v80;
          long long v83 = *(long long *)((char *)v7 + v80);
          *(_DWORD *)(v81 + 16) = *(_DWORD *)((char *)v7 + v80 + 16);
          *(_OWORD *)uint64_t v81 = v83;
          v84 = (void *)(v4 + v80 + 40);
          *(void *)(v4 + v80 + 24) = v84;
          *(void *)(v81 + 32) = 0x400000000;
          unsigned int v85 = *(_DWORD *)((char *)v7 + v80 + 32);
          if (v85) {
            BOOL v86 = v81 == v82;
          }
          else {
            BOOL v86 = 1;
          }
          if (!v86)
          {
            long long v87 = *(const void **)(v82 + 24);
            if ((const void *)(v82 + 40) == v87)
            {
              if (v85 >= 5) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              memcpy(v84, v87, 8 * *(unsigned int *)((char *)v7 + v80 + 32));
              *(_DWORD *)(v81 + 32) = v85;
            }
            else
            {
              *(void *)(v4 + v80 + 24) = v87;
              int v88 = *(_DWORD *)((char *)v7 + v80 + 36);
              *(_DWORD *)(v81 + 32) = v85;
              *(_DWORD *)(v81 + 36) = v88;
              *(void *)(v82 + 24) = v82 + 40;
              *(_DWORD *)((char *)v7 + v80 + 36) = 0;
            }
            *(_DWORD *)(v82 + 32) = 0;
          }
          v80 += 72;
        }
        while ((long long *)((char *)v7 + v80) != v69);
      }
      return;
    }
    if (a1 == a2) {
      return;
    }
    long long v23 = *a1;
    *(_DWORD *)(a4 + 16) = *((_DWORD *)a1 + 4);
    *(_OWORD *)a4 = v23;
    *(void *)(a4 + 24) = a4 + 40;
    *(void *)(a4 + 32) = 0x400000000;
    unsigned int v24 = *((_DWORD *)a1 + 8);
    if (v24 && (long long *)a4 != a1)
    {
      v25 = (long long *)*((void *)a1 + 3);
      uint64_t v26 = (char *)a1 + 40;
      if (v25 == (long long *)((char *)a1 + 40))
      {
        if (v24 >= 5) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        memcpy((void *)(a4 + 40), v26, 8 * *((unsigned int *)a1 + 8));
        *(_DWORD *)(v4 + 32) = v24;
      }
      else
      {
        *(void *)(a4 + 24) = v25;
        int v103 = *((_DWORD *)a1 + 9);
        *(_DWORD *)(a4 + 32) = v24;
        *(_DWORD *)(a4 + 36) = v103;
        *((void *)a1 + 3) = v26;
        *((_DWORD *)a1 + 9) = 0;
      }
      *((_DWORD *)v7 + 8) = 0;
    }
    uint64_t v27 = (long long *)((char *)v7 + 72);
    if ((long long *)((char *)v7 + 72) == a2) {
      return;
    }
    uint64_t v106 = 0;
    uint64_t v28 = v4;
    v104 = a2;
    while (1)
    {
      v29 = v7;
      uint64_t v7 = v27;
      uint64_t v30 = (_OWORD *)(v28 + 72);
      v31 = (void *)(v28 + 112);
      uint64_t v105 = v28 + 72;
      if (*((_DWORD *)v29 + 22) <= *(_DWORD *)(v28 + 16))
      {
        long long v45 = *v7;
        *(_DWORD *)(v28 + 88) = *((_DWORD *)v7 + 4);
        *uint64_t v30 = v45;
        *(void *)(v28 + 96) = v31;
        *(void *)(v28 + 104) = 0x400000000;
        unsigned int v46 = *((_DWORD *)v29 + 26);
        if (!v46 || (long long *)v28 == v29) {
          goto LABEL_73;
        }
        long long v47 = (long long *)*((void *)v29 + 12);
        if (v47 == v29 + 7)
        {
          if (v46 >= 5) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy(v31, v47, 8 * *((unsigned int *)v29 + 26));
          *(_DWORD *)(v28 + 104) = v46;
        }
        else
        {
          *(void *)(v28 + 96) = v47;
          int v61 = *((_DWORD *)v29 + 27);
          *(_DWORD *)(v28 + 104) = v46;
          *(_DWORD *)(v28 + 108) = v61;
          *((void *)v29 + 12) = v29 + 7;
          *((_DWORD *)v29 + 27) = 0;
        }
        v48 = (unsigned int *)v29 + 26;
      }
      else
      {
        *uint64_t v30 = *(_OWORD *)v28;
        *(_DWORD *)(v28 + 88) = *(_DWORD *)(v28 + 16);
        *(void *)(v28 + 96) = v31;
        *(void *)(v28 + 104) = 0x400000000;
        unsigned int v32 = *(_DWORD *)(v28 + 32);
        if (v32)
        {
          v33 = *(const void **)(v28 + 24);
          if (v33 == (const void *)(v28 + 40))
          {
            if (v32 >= 5) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            memcpy(v31, v33, 8 * *(unsigned int *)(v28 + 32));
            *(_DWORD *)(v28 + 104) = v32;
          }
          else
          {
            *(void *)(v28 + 96) = v33;
            int v60 = *(_DWORD *)(v28 + 36);
            *(_DWORD *)(v28 + 104) = v32;
            *(_DWORD *)(v28 + 108) = v60;
            *(void *)(v28 + 24) = v28 + 40;
            *(_DWORD *)(v28 + 36) = 0;
          }
          *(_DWORD *)(v28 + 32) = 0;
        }
        uint64_t v34 = v4;
        if (v28 != v4)
        {
          uint64_t v35 = v106;
          while (1)
          {
            uint64_t v34 = v4 + v35;
            if (*((_DWORD *)v29 + 22) <= *(_DWORD *)(v4 + v35 - 56)) {
              break;
            }
            *(_OWORD *)uint64_t v34 = *(_OWORD *)(v34 - 72);
            *(_DWORD *)(v34 + 16) = *(_DWORD *)(v34 - 56);
            uint64_t v36 = (void **)(v34 + 24);
            v37 = *(const void **)(v34 - 48);
            if ((const void *)(v34 - 32) == v37)
            {
              uint64_t v38 = v4 + v35;
              v40 = (_DWORD *)(v4 + v35 - 40);
              uint64_t v39 = *v40;
              uint64_t v41 = *(unsigned int *)(v4 + v35 + 32);
              if (v41 >= v39)
              {
                if (v39) {
                  memmove(*v36, v37, 8 * v39);
                }
              }
              else
              {
                if (*(_DWORD *)(v38 + 36) < v39)
                {
                  *(_DWORD *)(v38 + 32) = 0;
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (v41) {
                  memmove(*v36, v37, 8 * v41);
                }
                else {
                  uint64_t v41 = 0;
                }
                uint64_t v42 = *v40;
                if (v41 != v42) {
                  memcpy((void *)(*(void *)(v34 + 24) + 8 * v41), (const void *)(*(void *)(v34 - 48) + 8 * v41), 8 * v42 - 8 * v41);
                }
              }
              *(_DWORD *)(v38 + 32) = v39;
            }
            else
            {
              v43 = *v36;
              uint64_t v44 = v4 + v35;
              if ((void *)(v4 + v35 + 40) != v43)
              {
                free(v43);
                v37 = *(const void **)(v34 - 48);
              }
              *(void *)(v34 + 24) = v37;
              v40 = (_DWORD *)(v28 - 40);
              *(void *)(v44 + 32) = *(void *)(v44 - 40);
              *(void *)(v34 - 48) = v34 - 32;
              *(_DWORD *)(v44 - 36) = 0;
            }
            v28 -= 72;
            _DWORD *v40 = 0;
            v35 -= 72;
            if (!v35)
            {
              uint64_t v34 = v4;
              break;
            }
          }
        }
        long long v49 = *v7;
        *(_DWORD *)(v34 + 16) = *((_DWORD *)v7 + 4);
        *(_OWORD *)uint64_t v34 = v49;
        if ((long long *)v34 == (long long *)((char *)v29 + 72)) {
          goto LABEL_73;
        }
        uint64_t v50 = (long long **)(v29 + 6);
        uint64_t v51 = (long long *)*((void *)v29 + 12);
        uint64_t v52 = v29 + 7;
        if (v51 == v29 + 7)
        {
          v53 = (void **)(v34 + 24);
          unsigned int v55 = *((_DWORD *)v29 + 26);
          v48 = (unsigned int *)v29 + 26;
          uint64_t v54 = v55;
          uint64_t v56 = *(unsigned int *)(v34 + 32);
          if (v56 >= v55)
          {
            if (v54) {
              memmove(*v53, v52, 8 * v54);
            }
          }
          else
          {
            if (*(_DWORD *)(v34 + 36) < v54)
            {
              *(_DWORD *)(v34 + 32) = 0;
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            if (v56) {
              memmove(*v53, v52, 8 * v56);
            }
            else {
              uint64_t v56 = 0;
            }
            uint64_t v57 = *v48;
            if (v56 != v57) {
              memcpy((char *)*v53 + 8 * v56, (char *)*v50 + 8 * v56, (char *)*v50 + 8 * v57 - ((char *)*v50 + 8 * v56));
            }
          }
          *(_DWORD *)(v34 + 32) = v54;
        }
        else
        {
          v58 = *(void **)(v34 + 24);
          if (v58 != (void *)(v34 + 40))
          {
            free(v58);
            uint64_t v52 = v29 + 7;
            uint64_t v51 = *v50;
          }
          *(void *)(v34 + 24) = v51;
          uint64_t v59 = *((void *)v29 + 13);
          v48 = (unsigned int *)v29 + 26;
          *(void *)(v34 + 32) = v59;
          *((void *)v48 - 1) = v52;
          v48[1] = 0;
        }
      }
      unsigned int *v48 = 0;
LABEL_73:
      uint64_t v27 = (long long *)((char *)v7 + 72);
      uint64_t v28 = v105;
      v106 += 72;
      if ((long long *)((char *)v7 + 72) == v104) {
        return;
      }
    }
  }
  unint64_t v13 = (long long *)((char *)a2 - 72);
  int v14 = (void *)(a4 + 40);
  if (*((_DWORD *)a2 - 14) <= *((_DWORD *)a1 + 4))
  {
    long long v62 = *a1;
    *(_DWORD *)(a4 + 16) = *((_DWORD *)a1 + 4);
    *(_OWORD *)a4 = v62;
    *(void *)(a4 + 24) = v14;
    *(void *)(a4 + 32) = 0x400000000;
    unsigned int v63 = *((_DWORD *)a1 + 8);
    if (v63 && (long long *)a4 != a1)
    {
      uint64_t v64 = (char *)*((void *)a1 + 3);
      if (v64 == (char *)a1 + 40)
      {
        if (v63 >= 5) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        memcpy(v14, v64, 8 * *((unsigned int *)a1 + 8));
        *(_DWORD *)(v4 + 32) = v63;
      }
      else
      {
        *(void *)(a4 + 24) = v64;
        int v101 = *((_DWORD *)a1 + 9);
        *(_DWORD *)(a4 + 32) = v63;
        *(_DWORD *)(a4 + 36) = v101;
        *((void *)a1 + 3) = (char *)a1 + 40;
        *((_DWORD *)a1 + 9) = 0;
      }
      *((_DWORD *)v7 + 8) = 0;
    }
    long long v65 = *v13;
    int v66 = *((_DWORD *)a2 - 14);
    *(void *)(v4 + 96) = v4 + 112;
    *(_DWORD *)(v4 + 88) = v66;
    *(_OWORD *)(v4 + 72) = v65;
    *(void *)(v4 + 104) = 0x400000000;
    uint64_t v10 = (_DWORD *)a2 - 10;
    unsigned int v67 = *((_DWORD *)a2 - 10);
    if (v67 && (long long *)(v4 + 96) != a2 - 3)
    {
      uint64_t v68 = (long long *)*((void *)a2 - 6);
      if (v68 == a2 - 2)
      {
        if (v67 >= 5) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        memcpy((void *)(v4 + 112), v68, 8 * *((unsigned int *)a2 - 10));
        *(_DWORD *)(v4 + 104) = v67;
      }
      else
      {
        *(void *)(v4 + 96) = v68;
        int v102 = *((_DWORD *)a2 - 9);
        *(_DWORD *)(v4 + 104) = v67;
        *(_DWORD *)(v4 + 108) = v102;
        *((void *)a2 - 6) = a2 - 2;
        *((_DWORD *)a2 - 9) = 0;
      }
      goto LABEL_97;
    }
  }
  else
  {
    long long v15 = *v13;
    *(_DWORD *)(a4 + 16) = *((_DWORD *)a2 - 14);
    *(_OWORD *)a4 = v15;
    *(void *)(a4 + 24) = v14;
    *(void *)(a4 + 32) = 0x400000000;
    unsigned int v16 = *((_DWORD *)a2 - 10);
    if (v16 && (long long *)(a4 + 24) != a2 - 3)
    {
      long long v17 = (long long *)*((void *)a2 - 6);
      int v18 = a2 - 2;
      if (v17 == a2 - 2)
      {
        if (v16 >= 5) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        memcpy(v14, v18, 8 * *((unsigned int *)a2 - 10));
        *(_DWORD *)(v4 + 32) = v16;
      }
      else
      {
        *(void *)(a4 + 24) = v17;
        int v99 = *((_DWORD *)a2 - 9);
        *(_DWORD *)(a4 + 32) = v16;
        *(_DWORD *)(a4 + 36) = v99;
        *((void *)a2 - 6) = v18;
        *((_DWORD *)a2 - 9) = 0;
      }
      *((_DWORD *)a2 - 10) = 0;
    }
    long long v19 = *v7;
    int v20 = *((_DWORD *)v7 + 4);
    *(void *)(v4 + 96) = v4 + 112;
    *(_DWORD *)(v4 + 88) = v20;
    *(_OWORD *)(v4 + 72) = v19;
    *(void *)(v4 + 104) = 0x400000000;
    uint64_t v10 = v7 + 2;
    unsigned int v21 = *((_DWORD *)v7 + 8);
    if (v21 && (long long *)(v4 + 96) != (long long *)((char *)v7 + 24))
    {
      uint64_t v22 = (long long *)*((void *)v7 + 3);
      uint64_t v12 = (char *)v7 + 40;
      if (v22 == (long long *)((char *)v7 + 40))
      {
        if (v21 >= 5) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        memcpy((void *)(v4 + 112), v12, 8 * *((unsigned int *)v7 + 8));
        *(_DWORD *)(v4 + 104) = v21;
        goto LABEL_97;
      }
      *(void *)(v4 + 96) = v22;
      int v100 = *((_DWORD *)v7 + 9);
      *(_DWORD *)(v4 + 104) = v21;
      *(_DWORD *)(v4 + 108) = v100;
      goto LABEL_153;
    }
  }
}

void sub_1CCD6FCFC(long long *a1, long long *a2, long long *a3, uint64_t a4, uint64_t a5, long long *a6, uint64_t a7)
{
  if (!a5) {
    return;
  }
  uint64_t v7 = a5;
  while (a4 > a7 && v7 > a7)
  {
    if (!a4) {
      return;
    }
    uint64_t v11 = 0;
    uint64_t v12 = -a4;
    while (1)
    {
      unint64_t v13 = (long long *)((char *)a1 + v11);
      if (*((_DWORD *)a2 + 4) > *(_DWORD *)((char *)a1 + v11 + 16)) {
        break;
      }
      v11 += 72;
      if (__CFADD__(v12++, 1)) {
        return;
      }
    }
    uint64_t v15 = -v12;
    if (-v12 >= v7)
    {
      if (v12 == -1)
      {
        sub_1CCD6EE34((long long *)((char *)a1 + v11), a2);
        return;
      }
      if (v12 > 0) {
        uint64_t v15 = 1 - v12;
      }
      uint64_t v25 = v15 >> 1;
      unsigned int v24 = a3;
      if (a3 != a2)
      {
        unint64_t v26 = 0x8E38E38E38E38E39 * (((char *)a3 - (char *)a2) >> 3);
        unsigned int v24 = a2;
        do
        {
          unint64_t v27 = v26 >> 1;
          uint64_t v28 = (char *)v24 + 72 * (v26 >> 1);
          int v29 = *((_DWORD *)v28 + 4);
          uint64_t v30 = (long long *)(v28 + 72);
          v26 += ~(v26 >> 1);
          if (v29 > *(_DWORD *)((char *)a1 + 72 * v25 + v11 + 16)) {
            unsigned int v24 = v30;
          }
          else {
            unint64_t v26 = v27;
          }
        }
        while (v26);
      }
      int v18 = (long long *)((char *)a1 + 72 * v25 + v11);
      uint64_t v17 = 0x8E38E38E38E38E39 * (((char *)v24 - (char *)a2) >> 3);
    }
    else
    {
      if (v7 >= 0) {
        uint64_t v16 = v7;
      }
      else {
        uint64_t v16 = v7 + 1;
      }
      uint64_t v17 = v16 >> 1;
      int v18 = a2;
      if (v13 != a2)
      {
        unint64_t v19 = 0x8E38E38E38E38E39 * (((char *)a2 - (char *)a1 - v11) >> 3);
        int v18 = (long long *)((char *)a1 + v11);
        do
        {
          unint64_t v20 = v19 >> 1;
          unsigned int v21 = (char *)v18 + 72 * (v19 >> 1);
          int v22 = *((_DWORD *)v21 + 4);
          long long v23 = (long long *)(v21 + 72);
          v19 += ~(v19 >> 1);
          if (*((_DWORD *)a2 + 18 * v17 + 4) > v22) {
            unint64_t v19 = v20;
          }
          else {
            int v18 = v23;
          }
        }
        while (v19);
      }
      unsigned int v24 = (long long *)((char *)a2 + 72 * v17);
      uint64_t v25 = 0x8E38E38E38E38E39 * (((char *)v18 - (char *)a1 - v11) >> 3);
    }
    v31 = v24;
    if (v18 != a2)
    {
      v31 = v18;
      if (a2 != v24)
      {
        uint64_t v135 = v25;
        uint64_t v136 = v17;
        uint64_t v137 = a7;
        v139 = a3;
        sub_1CCD6EE34(v18, a2);
        v31 = (long long *)((char *)v18 + 72);
        for (i = (long long *)((char *)a2 + 72); i != v24; i = (long long *)((char *)i + 72))
        {
          if (v31 == a2) {
            a2 = i;
          }
          sub_1CCD6EE34(v31, i);
          v31 = (long long *)((char *)v31 + 72);
        }
        if (v31 == a2)
        {
          v31 = a2;
        }
        else
        {
          v33 = v31;
          uint64_t v34 = a2;
          do
          {
            while (1)
            {
              sub_1CCD6EE34(v33, a2);
              v33 = (long long *)((char *)v33 + 72);
              a2 = (long long *)((char *)a2 + 72);
              if (a2 == v24) {
                break;
              }
              if (v33 == v34) {
                uint64_t v34 = a2;
              }
            }
            a2 = v34;
          }
          while (v33 != v34);
        }
        a7 = v137;
        a3 = v139;
        uint64_t v25 = v135;
        uint64_t v17 = v136;
      }
    }
    a4 = -(v25 + v12);
    uint64_t v35 = v7 - v17;
    if (v25 + v17 >= v7 - (v25 + v17) - v12)
    {
      uint64_t v38 = v25;
      uint64_t v39 = -(v25 + v12);
      uint64_t v40 = v17;
      uint64_t v37 = a7;
      sub_1CCD6FCFC(v31, v24, a3, v39, v35, a6);
      unsigned int v24 = v18;
      uint64_t v35 = v40;
      a4 = v38;
      a3 = v31;
    }
    else
    {
      uint64_t v36 = a3;
      uint64_t v37 = a7;
      sub_1CCD6FCFC(v13, v18, v31, v25, v17, a6);
      a3 = v36;
      unint64_t v13 = v31;
    }
    uint64_t v7 = v35;
    a2 = v24;
    a1 = v13;
    a7 = v37;
    if (!v35) {
      return;
    }
  }
  if (a4 <= v7)
  {
    if (a1 == a2) {
      return;
    }
    uint64_t v51 = 0;
    uint64_t v42 = 0;
    do
    {
      uint64_t v52 = (uint64_t)a6 + v51;
      uint64_t v53 = (uint64_t)a1 + v51;
      long long v54 = *(long long *)((char *)a1 + v51);
      *(_DWORD *)(v52 + 16) = *(_DWORD *)((char *)a1 + v51 + 16);
      *(_OWORD *)uint64_t v52 = v54;
      *(void *)(v52 + 24) = v52 + 40;
      *(void *)(v52 + 32) = 0x400000000;
      unsigned int v55 = *(_DWORD *)((char *)a1 + v51 + 32);
      if (v55) {
        BOOL v56 = v53 == v52;
      }
      else {
        BOOL v56 = 1;
      }
      if (!v56)
      {
        uint64_t v57 = *(const void **)(v53 + 24);
        if ((const void *)(v53 + 40) == v57)
        {
          v58 = a3;
          if (v55 >= 5) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy((char *)a6 + v51 + 40, v57, 8 * *(unsigned int *)((char *)a1 + v51 + 32));
          *(_DWORD *)(v52 + 32) = v55;
          a3 = v58;
        }
        else
        {
          *(void *)(v52 + 24) = v57;
          int v59 = *(_DWORD *)((char *)a1 + v51 + 36);
          *(_DWORD *)(v52 + 32) = v55;
          *(_DWORD *)(v52 + 36) = v59;
          *(void *)(v53 + 24) = v53 + 40;
          *(_DWORD *)((char *)a1 + v51 + 36) = 0;
        }
        *(_DWORD *)(v53 + 32) = 0;
      }
      ++v42;
      v51 += 72;
    }
    while ((long long *)((char *)a1 + v51) != a2);
    if (v51)
    {
      v84 = a6;
      unsigned int v85 = (long long *)((char *)a6 + v51);
      uint64_t v141 = (uint64_t)a6 + v51 - 72;
      while (a2 != a3)
      {
        BOOL v86 = (void **)a1 + 3;
        if (*((_DWORD *)a2 + 4) <= *((_DWORD *)v84 + 4))
        {
          long long v94 = *v84;
          *((_DWORD *)a1 + 4) = *((_DWORD *)v84 + 4);
          *a1 = v94;
          if (a1 != v84)
          {
            BOOL v95 = (char *)*((void *)v84 + 3);
            if (v95 == (char *)v84 + 40)
            {
              int v97 = v84 + 2;
              uint64_t v96 = *((unsigned int *)v84 + 8);
              uint64_t v98 = *((unsigned int *)a1 + 8);
              if (v98 >= v96)
              {
                uint64_t v106 = a3;
                if (v96) {
                  memmove(*v86, v95, 8 * v96);
                }
                *((_DWORD *)a1 + 8) = v96;
                a3 = v106;
              }
              else
              {
                int v99 = a3;
                if (*((_DWORD *)a1 + 9) < v96)
                {
                  *((_DWORD *)a1 + 8) = 0;
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (v98) {
                  memmove(*v86, v95, 8 * v98);
                }
                else {
                  uint64_t v98 = 0;
                }
                uint64_t v100 = *v97;
                if (v98 != v100) {
                  memcpy((char *)*v86 + 8 * v98, (const void *)(*((void *)v84 + 3) + 8 * v98), 8 * v100 - 8 * v98);
                }
                *((_DWORD *)a1 + 8) = v96;
                a3 = v99;
              }
            }
            else
            {
              int v102 = (char *)*((void *)a1 + 3);
              if ((char *)a1 + 40 != v102)
              {
                v104 = a3;
                free(v102);
                a3 = v104;
                BOOL v95 = (char *)*((void *)v84 + 3);
              }
              *((void *)a1 + 3) = v95;
              int v97 = v84 + 2;
              *((void *)a1 + 4) = *((void *)v84 + 4);
              *((void *)v84 + 3) = (char *)v84 + 40;
              *((_DWORD *)v84 + 9) = 0;
            }
            *int v97 = 0;
          }
          v84 = (long long *)((char *)v84 + 72);
        }
        else
        {
          long long v87 = *a2;
          *((_DWORD *)a1 + 4) = *((_DWORD *)a2 + 4);
          *a1 = v87;
          if (a1 != a2)
          {
            int v88 = (char *)*((void *)a2 + 3);
            if (v88 == (char *)a2 + 40)
            {
              uint64_t v90 = a2 + 2;
              uint64_t v89 = *((unsigned int *)a2 + 8);
              uint64_t v91 = *((unsigned int *)a1 + 8);
              if (v91 >= v89)
              {
                uint64_t v105 = a3;
                if (v89) {
                  memmove(*v86, v88, 8 * v89);
                }
                *((_DWORD *)a1 + 8) = v89;
                a3 = v105;
              }
              else
              {
                long long v92 = a3;
                if (*((_DWORD *)a1 + 9) < v89)
                {
                  *((_DWORD *)a1 + 8) = 0;
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (v91) {
                  memmove(*v86, v88, 8 * v91);
                }
                else {
                  uint64_t v91 = 0;
                }
                uint64_t v93 = *v90;
                if (v91 != v93) {
                  memcpy((char *)*v86 + 8 * v91, (const void *)(*((void *)a2 + 3) + 8 * v91), 8 * v93 - 8 * v91);
                }
                *((_DWORD *)a1 + 8) = v89;
                a3 = v92;
              }
            }
            else
            {
              int v101 = (char *)*((void *)a1 + 3);
              if ((char *)a1 + 40 != v101)
              {
                int v103 = a3;
                free(v101);
                a3 = v103;
                int v88 = (char *)*((void *)a2 + 3);
              }
              *((void *)a1 + 3) = v88;
              uint64_t v90 = a2 + 2;
              *((void *)a1 + 4) = *((void *)a2 + 4);
              *((void *)a2 + 3) = (char *)a2 + 40;
              *((_DWORD *)a2 + 9) = 0;
            }
            *uint64_t v90 = 0;
          }
          a2 = (long long *)((char *)a2 + 72);
        }
        a1 = (long long *)((char *)a1 + 72);
        if (v85 == v84) {
          goto LABEL_213;
        }
      }
      if (v85 != v84)
      {
        uint64_t v120 = 0;
        v121 = v84;
        do
        {
          uint64_t v122 = (uint64_t)a1 + v120;
          uint64_t v123 = (uint64_t)v84 + v120;
          long long v124 = *(long long *)((char *)v84 + v120);
          *(_DWORD *)(v122 + 16) = *(_DWORD *)((char *)v84 + v120 + 16);
          *(_OWORD *)uint64_t v122 = v124;
          if (a1 != v84)
          {
            v125 = (void **)(v122 + 24);
            v126 = *(void **)(v123 + 24);
            if ((void *)(v123 + 40) == v126)
            {
              v128 = (_DWORD *)((char *)v84 + v120 + 32);
              uint64_t v127 = *v128;
              uint64_t v129 = (uint64_t)a1 + v120;
              uint64_t v130 = *(unsigned int *)((char *)a1 + v120 + 32);
              if (v130 >= v127)
              {
                if (v127) {
                  memmove(*v125, v126, 8 * v127);
                }
              }
              else
              {
                if (*(_DWORD *)(v129 + 36) < v127)
                {
                  *(_DWORD *)(v129 + 32) = 0;
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (v130)
                {
                  v138 = (void **)(v122 + 24);
                  memmove(*v125, v126, 8 * v130);
                  v125 = v138;
                }
                else
                {
                  uint64_t v130 = 0;
                }
                uint64_t v131 = *v128;
                if (v130 != v131) {
                  memcpy((char *)*v125 + 8 * v130, (const void *)(*(void *)(v123 + 24) + 8 * v130), 8 * v131 - 8 * v130);
                }
              }
              *(_DWORD *)(v129 + 32) = v127;
            }
            else
            {
              if ((char *)a1 + v120 + 40 != *v125)
              {
                v132 = (void **)(v122 + 24);
                free(*v125);
                v125 = v132;
                v126 = *(void **)(v123 + 24);
              }
              *v125 = v126;
              v128 = v121 + 2;
              *(void *)((char *)a1 + v120 + 32) = *(void *)((char *)v84 + v120 + 32);
              *(void *)(v123 + 24) = v123 + 40;
              *(_DWORD *)((char *)v84 + v120 + 36) = 0;
            }
            _DWORD *v128 = 0;
          }
          v121 = (long long *)((char *)v121 + 72);
          v120 += 72;
        }
        while ((long long *)v141 != (long long *)((char *)v84 + v120 - 72));
      }
    }
  }
  else
  {
    if (a2 == a3) {
      return;
    }
    uint64_t v41 = 0;
    uint64_t v42 = 0;
    do
    {
      uint64_t v43 = (uint64_t)a6 + v41;
      uint64_t v44 = (char *)a2 + v41;
      long long v45 = *(long long *)((char *)a2 + v41);
      *(_DWORD *)(v43 + 16) = *(_DWORD *)((char *)a2 + v41 + 16);
      *(_OWORD *)uint64_t v43 = v45;
      *(void *)(v43 + 24) = v43 + 40;
      *(void *)(v43 + 32) = 0x400000000;
      unsigned int v46 = *(_DWORD *)((char *)a2 + v41 + 32);
      if (v46) {
        BOOL v47 = v44 == (char *)v43;
      }
      else {
        BOOL v47 = 1;
      }
      if (!v47)
      {
        v48 = (char *)*((void *)v44 + 3);
        if (v44 + 40 == v48)
        {
          long long v49 = a3;
          if (v46 >= 5) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy((char *)a6 + v41 + 40, v48, 8 * *(unsigned int *)((char *)a2 + v41 + 32));
          *(_DWORD *)(v43 + 32) = v46;
          a3 = v49;
        }
        else
        {
          *(void *)(v43 + 24) = v48;
          int v50 = *(_DWORD *)((char *)a2 + v41 + 36);
          *(_DWORD *)(v43 + 32) = v46;
          *(_DWORD *)(v43 + 36) = v50;
          *((void *)v44 + 3) = v44 + 40;
          *(_DWORD *)((char *)a2 + v41 + 36) = 0;
        }
        *((_DWORD *)v44 + 8) = 0;
      }
      ++v42;
      v41 += 72;
    }
    while ((long long *)((char *)a2 + v41) != a3);
    if (v41)
    {
      int v60 = (long long *)((char *)a6 + v41);
      while (1)
      {
        v140 = a3;
        if (a2 == a1)
        {
          if (v60 != a6)
          {
            uint64_t v107 = 0;
            v108 = v60;
            do
            {
              uint64_t v109 = (uint64_t)v60 + v107;
              v110 = (char *)a3 + v107;
              long long v111 = *(long long *)((char *)v60 + v107 - 72);
              *((_DWORD *)v110 - 14) = *(_DWORD *)((char *)v60 + v107 - 56);
              *(_OWORD *)(v110 - 72) = v111;
              if (a3 != v60)
              {
                v112 = (void **)(v110 - 48);
                v113 = *(void **)(v109 - 48);
                if ((void *)(v109 - 32) == v113)
                {
                  v115 = (_DWORD *)((char *)v60 + v107 - 40);
                  uint64_t v114 = *v115;
                  v116 = (char *)a3 + v107;
                  uint64_t v117 = *(unsigned int *)((char *)a3 + v107 - 40);
                  if (v117 >= v114)
                  {
                    if (v114) {
                      memmove(*v112, v113, 8 * v114);
                    }
                  }
                  else
                  {
                    if (*((_DWORD *)v116 - 9) < v114)
                    {
                      *((_DWORD *)v116 - 10) = 0;
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    if (v117) {
                      memmove(*v112, v113, 8 * v117);
                    }
                    else {
                      uint64_t v117 = 0;
                    }
                    uint64_t v118 = *v115;
                    if (v117 != v118) {
                      memcpy((char *)*v112 + 8 * v117, (const void *)(*(void *)(v109 - 48) + 8 * v117), 8 * v118 - 8 * v117);
                    }
                  }
                  *((_DWORD *)v116 - 10) = v114;
                  a3 = v140;
                }
                else
                {
                  v119 = (char *)a3 + v107;
                  if ((char *)a3 + v107 - 32 != *v112)
                  {
                    free(*v112);
                    a3 = v140;
                    v113 = *(void **)(v109 - 48);
                  }
                  *v112 = v113;
                  v115 = (_DWORD *)v108 - 10;
                  *((void *)v119 - 5) = *(void *)((char *)v60 + v107 - 40);
                  *(void *)(v109 - 48) = v109 - 32;
                  *(_DWORD *)((char *)v60 + v107 - 36) = 0;
                }
                _DWORD *v115 = 0;
              }
              v108 = (long long *)((char *)v108 - 72);
              v107 -= 72;
            }
            while ((long long *)((char *)v60 + v107) != a6);
          }
          goto LABEL_213;
        }
        int v61 = (long long *)((char *)a3 - 72);
        long long v62 = (void **)(a3 - 3);
        if (*((_DWORD *)v60 - 14) > *((_DWORD *)a2 - 14)) {
          break;
        }
        long long v71 = (long long *)((char *)v60 - 72);
        long long v72 = *(long long *)((char *)v60 - 72);
        *((_DWORD *)a3 - 14) = *((_DWORD *)v60 - 14);
        long long *v61 = v72;
        if (a3 != v60)
        {
          unsigned int v73 = (long long *)*((void *)v60 - 6);
          v74 = v60 - 2;
          if (v73 == v60 - 2)
          {
            uint64_t v68 = (_DWORD *)v60 - 10;
            uint64_t v75 = *((unsigned int *)v60 - 10);
            uint64_t v76 = *((unsigned int *)a3 - 10);
            if (v76 >= v75)
            {
              if (v75) {
                memmove(*v62, v73, 8 * v75);
              }
            }
            else
            {
              if (*((_DWORD *)a3 - 9) < v75)
              {
                *((_DWORD *)a3 - 10) = 0;
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              if (v76) {
                memmove(*v62, v73, 8 * v76);
              }
              else {
                uint64_t v76 = 0;
              }
              uint64_t v77 = *v68;
              if (v76 != v77) {
                memcpy((char *)*v62 + 8 * v76, (const void *)(*((void *)v60 - 6) + 8 * v76), 8 * v77 - 8 * v76);
              }
            }
            *((_DWORD *)v140 - 10) = v75;
          }
          else
          {
            uint64_t v81 = (long long *)*((void *)a3 - 6);
            if (a3 - 2 != v81)
            {
              free(v81);
              a3 = v140;
              unsigned int v73 = (long long *)*((void *)v60 - 6);
            }
            *((void *)a3 - 6) = v73;
            uint64_t v83 = *((void *)v60 - 5);
            uint64_t v82 = (_DWORD *)v60 - 10;
            *((void *)a3 - 5) = v83;
            *((void *)v82 - 1) = v74;
            v82[1] = 0;
            uint64_t v68 = v82;
          }
          unsigned int v63 = a2;
          int v60 = v71;
LABEL_106:
          *uint64_t v68 = 0;
LABEL_107:
          a2 = v63;
          long long v71 = v60;
        }
        int v60 = v71;
        a3 = v61;
        if (v71 == a6) {
          goto LABEL_213;
        }
      }
      unsigned int v63 = (long long *)((char *)a2 - 72);
      long long v64 = *(long long *)((char *)a2 - 72);
      *((_DWORD *)a3 - 14) = *((_DWORD *)a2 - 14);
      long long *v61 = v64;
      if (a3 != a2)
      {
        long long v65 = (long long *)*((void *)a2 - 6);
        int v66 = a2 - 2;
        if (v65 == a2 - 2)
        {
          uint64_t v68 = (_DWORD *)a2 - 10;
          uint64_t v67 = *((unsigned int *)a2 - 10);
          uint64_t v69 = *((unsigned int *)a3 - 10);
          if (v69 >= v67)
          {
            if (v67) {
              memmove(*v62, v65, 8 * v67);
            }
          }
          else
          {
            if (*((_DWORD *)a3 - 9) < v67)
            {
              *((_DWORD *)a3 - 10) = 0;
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            if (v69) {
              memmove(*v62, v65, 8 * v69);
            }
            else {
              uint64_t v69 = 0;
            }
            uint64_t v70 = *v68;
            if (v69 != v70) {
              memcpy((char *)*v62 + 8 * v69, (const void *)(*((void *)a2 - 6) + 8 * v69), 8 * v70 - 8 * v69);
            }
          }
          *((_DWORD *)v140 - 10) = v67;
        }
        else
        {
          int v78 = (long long *)*((void *)a3 - 6);
          if (a3 - 2 != v78)
          {
            free(v78);
            a3 = v140;
            long long v65 = (long long *)*((void *)a2 - 6);
          }
          *((void *)a3 - 6) = v65;
          uint64_t v80 = *((void *)a2 - 5);
          int v79 = (_DWORD *)a2 - 10;
          *((void *)a3 - 5) = v80;
          *((void *)v79 - 1) = v66;
          v79[1] = 0;
          uint64_t v68 = v79;
        }
        goto LABEL_106;
      }
      goto LABEL_107;
    }
  }
LABEL_213:
  if (a6 && v42)
  {
    v133 = (void *)a6 + 5;
    do
    {
      v134 = (void *)*(v133 - 2);
      if (v133 != v134) {
        free(v134);
      }
      v133 += 9;
      --v42;
    }
    while (v42);
  }
}

void sub_1CCD709C4()
{
}

void sub_1CCD70A04(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD70A3C(uint64_t a1, uint64_t a2)
{
}

BOOL sub_1CCD70A50(llvm::FunctionPass *a1, llvm::LLVMContextImpl ****a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (llvm::FunctionPass::skipFunction(a1, a2)) {
    return 0;
  }
  v5[0] = 0;
  v5[1] = 0;
  int v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  int v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  int v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = v17;
  uint64_t v16 = 0x400000000;
  v17[4] = v18;
  v17[5] = 0;
  v18[0] = 0;
  v18[1] = 1;
  v18[2] = v19;
  v18[3] = 0x800000000;
  v19[16] = 1;
  BOOL v3 = sub_1CCD69468((size_t)v5, a2);
  sub_1CCD6C220((uint64_t)v5);
  return v3;
}

llvm::raw_ostream *sub_1CCD70B2C(llvm *a1)
{
  uint64_t v2 = llvm::dbgs(a1);

  return sub_1CCD70B68((uint64_t)a1, v2);
}

llvm::raw_ostream *sub_1CCD70B68(uint64_t a1, llvm::raw_ostream *this)
{
  uint64_t v4 = (void *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v4 > 0x14uLL)
  {
    qmemcpy(v4, "InductiveRangeCheck:\n", 21);
    uint64_t v5 = *((void *)this + 4) + 21;
    *((void *)this + 4) = v5;
  }
  else
  {
    llvm::raw_ostream::write(this, "InductiveRangeCheck:\n", 0x15uLL);
    uint64_t v5 = *((void *)this + 4);
  }
  if ((unint64_t)(*((void *)this + 3) - v5) > 8)
  {
    *(unsigned char *)(v5 + 8) = 32;
    *(void *)uint64_t v5 = *(void *)"  Begin: ";
    *((void *)this + 4) += 9;
  }
  else
  {
    llvm::raw_ostream::write(this, "  Begin: ", 9uLL);
  }
  llvm::SCEV::print(*(llvm::SCEV **)a1, this);
  int v6 = (void *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v6 > 7uLL)
  {
    *int v6 = 0x203A706574532020;
    *((void *)this + 4) += 8;
  }
  else
  {
    llvm::raw_ostream::write(this, "  Step: ", 8uLL);
  }
  llvm::SCEV::print(*(llvm::SCEV **)(a1 + 8), this);
  uint64_t v7 = (_DWORD *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v7 > 6uLL)
  {
    *(_DWORD *)((char *)v7 + 3) = 540697710;
    *uint64_t v7 = 1850023968;
    *((void *)this + 4) += 7;
  }
  else
  {
    llvm::raw_ostream::write(this, "  End: ", 7uLL);
  }
  llvm::SCEV::print(*(llvm::SCEV **)(a1 + 16), this);
  uint64_t v8 = (void *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v8 > 0xCuLL)
  {
    qmemcpy(v8, "\n  CheckUse: ", 13);
    *((void *)this + 4) += 13;
  }
  else
  {
    llvm::raw_ostream::write(this, "\n  CheckUse: ", 0xDuLL);
  }
  llvm::Value::print(*(llvm::Value **)(*(void *)(a1 + 24) + 24), this, 0);
  uint64_t v9 = *((void *)this + 4);
  if ((unint64_t)(*((void *)this + 3) - v9) > 9)
  {
    *(_WORD *)(v9 + 8) = 8250;
    *(void *)uint64_t v9 = *(void *)" Operand: ";
    *((void *)this + 4) += 10;
  }
  else
  {
    llvm::raw_ostream::write(this, " Operand: ", 0xAuLL);
  }
  uint64_t v10 = *(void *)(a1 + 24);
  uint64_t v11 = *(void *)(v10 + 24);
  int v12 = *(_DWORD *)(v11 + 20);
  if ((v12 & 0x40000000) != 0) {
    uint64_t v13 = *(void *)(v11 - 8);
  }
  else {
    uint64_t v13 = v11 - 32 * (v12 & 0x7FFFFFF);
  }
  result = sub_1CD098D14(this, ((unint64_t)(v10 - v13) >> 5), 0, 0, 0);
  uint64_t v15 = (unsigned char *)*((void *)this + 4);
  if (*((unsigned char **)this + 3) == v15)
  {
    return llvm::raw_ostream::write(this, "\n", 1uLL);
  }
  else
  {
    *uint64_t v15 = 10;
    ++*((void *)this + 4);
  }
  return result;
}

void sub_1CCD70E14(llvm *a1, llvm::PassRegistry *a2)
{
  llvm::initializeBranchProbabilityInfoWrapperPassPass(a1, a2);
  llvm::initializeDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializeLoopInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeScalarEvolutionWrapperPassPass(a1, v3);
  operator new();
}

void llvm::IRCEPass::run()
{
}

uint64_t sub_1CCD712A8(uint64_t a1, uint64_t a2)
{
  if (dword_1EBCF2440 > (unint64_t)((uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 3)) {
    llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopPredecessor();
  }
  return 0;
}

uint64_t sub_1CCD75984(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF23B0;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263E268;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF23B8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD70E14;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCF23B8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CCD75A34()
{
}

const llvm::SCEV *sub_1CCD75A70@<X0>(const llvm::SCEV *result@<X0>, uint64_t a2@<X1>, const llvm::SCEV **a3@<X2>, uint64_t a4@<X8>)
{
  int v6 = *a3;
  uint64_t v7 = a3[1];
  if (v6 == v7
    || (uint64_t v9 = result,
        result = (const llvm::SCEV *)llvm::ScalarEvolution::isKnownPredicate(result, 0x27u, v6, v7),
        result))
  {
LABEL_23:
    char v12 = 0;
    *(unsigned char *)a4 = 0;
  }
  else
  {
    if (*(unsigned char *)(a2 + 16))
    {
      uint64_t v10 = *(const llvm::SCEV **)a2;
      while (2)
      {
        switch(*((_WORD *)v10 + 12))
        {
          case 1:
          case 2:
          case 3:
          case 0xD:
            uint64_t v13 = (uint64_t *)((char *)v10 + 40);
            goto LABEL_14;
          case 4:
            uint64_t v13 = (uint64_t *)((char *)v10 + 48);
            goto LABEL_14;
          case 5:
          case 7:
          case 8:
          case 9:
          case 0xA:
          case 0xB:
          case 0xC:
            uint64_t v11 = (const llvm::SCEV **)*((void *)v10 + 4);
            goto LABEL_7;
          case 6:
            uint64_t v11 = (const llvm::SCEV **)((char *)v10 + 40);
LABEL_7:
            uint64_t v10 = *v11;
            continue;
          case 0xE:
            uint64_t v13 = (uint64_t *)*((void *)v10 - 1);
            goto LABEL_14;
          default:
            uint64_t v13 = (uint64_t *)*((void *)v10 + 4);
LABEL_14:
            uint64_t v14 = *v13;
            uint64_t v15 = *a3;
            while (2)
            {
              switch(*((_WORD *)v15 + 12))
              {
                case 1:
                case 2:
                case 3:
                case 0xD:
                  uint64_t v17 = (void *)((char *)v15 + 40);
                  goto LABEL_22;
                case 4:
                  uint64_t v17 = (void *)((char *)v15 + 48);
                  goto LABEL_22;
                case 5:
                case 7:
                case 8:
                case 9:
                case 0xA:
                case 0xB:
                case 0xC:
                  uint64_t v16 = (const llvm::SCEV **)*((void *)v15 + 4);
                  goto LABEL_17;
                case 6:
                  uint64_t v16 = (const llvm::SCEV **)((char *)v15 + 40);
LABEL_17:
                  uint64_t v15 = *v16;
                  continue;
                case 0xE:
                  uint64_t v17 = (void *)*((void *)v15 - 1);
                  goto LABEL_22;
                default:
                  uint64_t v17 = (void *)*((void *)v15 + 4);
LABEL_22:
                  if (v14 != *v17) {
                    goto LABEL_23;
                  }
                  SMaxExpr = (const llvm::SCEV *)llvm::ScalarEvolution::getSMaxExpr(v9, *(const llvm::SCEV **)a2, *a3);
                  result = (const llvm::SCEV *)llvm::ScalarEvolution::getSMinExpr(v9, *(const llvm::SCEV **)(a2 + 8), a3[1]);
                  if (SMaxExpr == result) {
                    goto LABEL_23;
                  }
                  unint64_t v19 = result;
                  result = (const llvm::SCEV *)llvm::ScalarEvolution::isKnownPredicate(v9, 0x27u, SMaxExpr, result);
                  if (result) {
                    goto LABEL_23;
                  }
                  *(void *)a4 = SMaxExpr;
                  *(void *)(a4 + 8) = v19;
                  break;
              }
              break;
            }
            break;
        }
        break;
      }
    }
    else
    {
      *(_OWORD *)a4 = *(_OWORD *)a3;
    }
    char v12 = 1;
  }
  *(unsigned char *)(a4 + 16) = v12;
  return result;
}

const llvm::SCEV *sub_1CCD75C74@<X0>(const llvm::SCEV *result@<X0>, uint64_t a2@<X1>, const llvm::SCEV **a3@<X2>, uint64_t a4@<X8>)
{
  int v6 = *a3;
  uint64_t v7 = a3[1];
  if (v6 == v7
    || (uint64_t v9 = result,
        result = (const llvm::SCEV *)llvm::ScalarEvolution::isKnownPredicate(result, 0x23u, v6, v7),
        result))
  {
LABEL_23:
    char v12 = 0;
    *(unsigned char *)a4 = 0;
  }
  else
  {
    if (*(unsigned char *)(a2 + 16))
    {
      uint64_t v10 = *(const llvm::SCEV **)a2;
      while (2)
      {
        switch(*((_WORD *)v10 + 12))
        {
          case 1:
          case 2:
          case 3:
          case 0xD:
            uint64_t v13 = (uint64_t *)((char *)v10 + 40);
            goto LABEL_14;
          case 4:
            uint64_t v13 = (uint64_t *)((char *)v10 + 48);
            goto LABEL_14;
          case 5:
          case 7:
          case 8:
          case 9:
          case 0xA:
          case 0xB:
          case 0xC:
            uint64_t v11 = (const llvm::SCEV **)*((void *)v10 + 4);
            goto LABEL_7;
          case 6:
            uint64_t v11 = (const llvm::SCEV **)((char *)v10 + 40);
LABEL_7:
            uint64_t v10 = *v11;
            continue;
          case 0xE:
            uint64_t v13 = (uint64_t *)*((void *)v10 - 1);
            goto LABEL_14;
          default:
            uint64_t v13 = (uint64_t *)*((void *)v10 + 4);
LABEL_14:
            uint64_t v14 = *v13;
            uint64_t v15 = *a3;
            while (2)
            {
              switch(*((_WORD *)v15 + 12))
              {
                case 1:
                case 2:
                case 3:
                case 0xD:
                  uint64_t v17 = (void *)((char *)v15 + 40);
                  goto LABEL_22;
                case 4:
                  uint64_t v17 = (void *)((char *)v15 + 48);
                  goto LABEL_22;
                case 5:
                case 7:
                case 8:
                case 9:
                case 0xA:
                case 0xB:
                case 0xC:
                  uint64_t v16 = (const llvm::SCEV **)*((void *)v15 + 4);
                  goto LABEL_17;
                case 6:
                  uint64_t v16 = (const llvm::SCEV **)((char *)v15 + 40);
LABEL_17:
                  uint64_t v15 = *v16;
                  continue;
                case 0xE:
                  uint64_t v17 = (void *)*((void *)v15 - 1);
                  goto LABEL_22;
                default:
                  uint64_t v17 = (void *)*((void *)v15 + 4);
LABEL_22:
                  if (v14 != *v17) {
                    goto LABEL_23;
                  }
                  UMaxExpr = (const llvm::SCEV *)llvm::ScalarEvolution::getUMaxExpr(v9, *(const llvm::SCEV **)a2, *a3);
                  result = (const llvm::SCEV *)llvm::ScalarEvolution::getUMinExpr(v9, *(const llvm::SCEV **)(a2 + 8), a3[1], 0);
                  if (UMaxExpr == result) {
                    goto LABEL_23;
                  }
                  unint64_t v19 = result;
                  result = (const llvm::SCEV *)llvm::ScalarEvolution::isKnownPredicate(v9, 0x23u, UMaxExpr, result);
                  if (result) {
                    goto LABEL_23;
                  }
                  *(void *)a4 = UMaxExpr;
                  *(void *)(a4 + 8) = v19;
                  break;
              }
              break;
            }
            break;
        }
        break;
      }
    }
    else
    {
      *(_OWORD *)a4 = *(_OWORD *)a3;
    }
    char v12 = 1;
  }
  *(unsigned char *)(a4 + 16) = v12;
  return result;
}

double sub_1CCD75E7C(const llvm::Loop *a1, uint64_t a2, uint64_t *a3, unint64_t *a4, uint64_t a5)
{
  v97[3] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a3;
  uint64_t v11 = *(void *)(a5 + 8);
  uint64_t v12 = *(unsigned int *)(a5 + 20);
  if (v11 == *(void *)a5)
  {
    if (v12)
    {
      uint64_t v13 = 0;
      uint64_t v14 = 8 * v12;
      uint64_t v15 = *(void **)(a5 + 8);
      do
      {
        if (*v15 == v10) {
          return result;
        }
        if (*v15 == -2) {
          uint64_t v13 = v15;
        }
        ++v15;
        v14 -= 8;
      }
      while (v14);
      if (v13)
      {
        *uint64_t v13 = v10;
        --*(_DWORD *)(a5 + 24);
        goto LABEL_33;
      }
    }
    unsigned int v16 = *(_DWORD *)(a5 + 16);
    if (v12 < v16)
    {
      *(_DWORD *)(a5 + 20) = v12 + 1;
      *(void *)(v11 + 8 * v12) = v10;
      goto LABEL_33;
    }
  }
  else
  {
    unsigned int v16 = *(_DWORD *)(a5 + 16);
  }
  if (3 * v16 <= 4 * ((int)v12 - *(_DWORD *)(a5 + 24)))
  {
    if (v16 >= 0x40) {
      v16 *= 2;
    }
    else {
      unsigned int v16 = 128;
    }
  }
  else if (v16 - v12 >= v16 >> 3)
  {
    goto LABEL_14;
  }
  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a5, v16);
  unsigned int v16 = *(_DWORD *)(a5 + 16);
  uint64_t v11 = *(void *)(a5 + 8);
LABEL_14:
  unsigned int v17 = v16 - 1;
  unsigned int v18 = (v16 - 1) & ((v10 >> 4) ^ (v10 >> 9));
  unint64_t v19 = (void *)(v11 + 8 * v18);
  uint64_t v20 = *v19;
  if (*v19 != -1)
  {
    unsigned int v21 = 0;
    int v22 = 1;
    while (v20 != v10)
    {
      if (v21) {
        BOOL v23 = 0;
      }
      else {
        BOOL v23 = v20 == -2;
      }
      if (v23) {
        unsigned int v21 = v19;
      }
      unsigned int v24 = v18 + v22++;
      unsigned int v18 = v24 & v17;
      unint64_t v19 = (void *)(v11 + 8 * (v24 & v17));
      uint64_t v20 = *v19;
      if (*v19 == -1) {
        goto LABEL_26;
      }
    }
    return result;
  }
  unsigned int v21 = 0;
LABEL_26:
  if (v21) {
    uint64_t v25 = v21;
  }
  else {
    uint64_t v25 = v19;
  }
  if (*v25 != v10)
  {
    if (*v25 == -2) {
      --*(_DWORD *)(a5 + 24);
    }
    else {
      ++*(_DWORD *)(a5 + 20);
    }
    void *v25 = v10;
LABEL_33:
    if (sub_1CC262304((uint64_t)&v95, (unsigned __int8 *)v10))
    {
      int v28 = *(_DWORD *)(v10 + 20);
      if ((v28 & 0x40000000) != 0) {
        uint64_t v29 = *(void *)(v10 - 8);
      }
      else {
        uint64_t v29 = v10 - 32 * (v28 & 0x7FFFFFF);
      }
      sub_1CCD75E7C(a1, a2, v29, a4, a5);
      int v42 = *(_DWORD *)(v10 + 20);
      if ((v42 & 0x40000000) != 0) {
        uint64_t v43 = *(void *)(v10 - 8);
      }
      else {
        uint64_t v43 = v10 - 32 * (v42 & 0x7FFFFFF);
      }
      sub_1CCD75E7C(a1, a2, v43 + 32, a4, a5);
      return result;
    }
    if (!v10 || *(unsigned char *)(v10 + 16) != 81) {
      return result;
    }
    int v30 = (*(_WORD *)(v10 + 18) & 0x3F) - 34;
    unint64_t v31 = *(void *)(v10 - 64);
    unint64_t v32 = *(void *)(v10 - 32);
    unint64_t v33 = v31;
    unint64_t v34 = v31;
    switch(v30)
    {
      case 0:
        goto LABEL_40;
      case 2:
        unint64_t v33 = v32;
        unint64_t v32 = v31;
LABEL_40:
        uint64_t v35 = *(void *)(a2 + 104);
        unsigned int v36 = *(_DWORD *)(a2 + 120);
        if (!v36) {
          goto LABEL_96;
        }
        unsigned int v37 = (v36 - 1) & ((v33 >> 4) ^ (v33 >> 9));
        uint64_t v38 = v35 + 48 * v37;
        uint64_t v39 = *(void *)(v38 + 24);
        if (v39 == v33) {
          goto LABEL_97;
        }
        int v40 = 1;
        while (v39 != -4096)
        {
          unsigned int v41 = v37 + v40++;
          unsigned int v37 = v41 & (v36 - 1);
          uint64_t v38 = v35 + 48 * v37;
          uint64_t v39 = *(void *)(v38 + 24);
          if (v39 == v33) {
            goto LABEL_97;
          }
        }
        goto LABEL_96;
      case 4:
        goto LABEL_66;
      case 5:
        goto LABEL_53;
      case 6:
        unint64_t v33 = v32;
        unint64_t v32 = v31;
LABEL_66:
        if (!v32 || *(unsigned char *)(v32 + 16) != 16) {
          goto LABEL_90;
        }
        unsigned int v51 = *(_DWORD *)(v32 + 32);
        LODWORD(v96) = v51;
        if (v51 > 0x40) {
          operator new[]();
        }
        if (v51) {
          unint64_t v52 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v51;
        }
        else {
          unint64_t v52 = 0;
        }
        BOOL v95 = (void *)(v52 & ~*(void *)(v32 + 24));
        llvm::APInt::operator++((uint64_t)&v95);
        uint64_t v53 = v96;
        LODWORD(v96) = 0;
        if (v53 >= 0x41)
        {
          int v54 = 0;
          int64_t v55 = (unint64_t)(v53 + 63) >> 6;
          do
          {
            BOOL v48 = v55-- < 1;
            if (v48) {
              break;
            }
            unint64_t v56 = *((void *)v95 + v55);
            v54 += __clz(v56);
          }
          while (!v56);
          BOOL v57 = 0;
          int v58 = v53 | 0xFFFFFFC0;
          if ((v53 & 0x3F) == 0) {
            int v58 = 0;
          }
          if ((v53 - v54 - v58) <= 0x40) {
            BOOL v57 = *(void *)v95 == 1;
          }
          if (v95)
          {
            MEMORY[0x1D25D9CB0](v95, 0x1000C8000313F17);
            if (v96 >= 0x41)
            {
              if (v95) {
                MEMORY[0x1D25D9CB0](v95, 0x1000C8000313F17);
              }
            }
          }
          if (v57) {
            goto LABEL_77;
          }
        }
        else if (v95 == (void *)1)
        {
LABEL_77:
          unint64_t v32 = v33;
          unint64_t v33 = 0;
          goto LABEL_101;
        }
LABEL_90:
        uint64_t v35 = *(void *)(a2 + 104);
        unsigned int v36 = *(_DWORD *)(a2 + 120);
        if (!v36) {
          goto LABEL_96;
        }
        unsigned int v59 = (v36 - 1) & ((v33 >> 4) ^ (v33 >> 9));
        uint64_t v38 = v35 + 48 * v59;
        uint64_t v60 = *(void *)(v38 + 24);
        if (v60 != v33)
        {
          int v61 = 1;
          while (v60 != -4096)
          {
            unsigned int v62 = v59 + v61++;
            unsigned int v59 = v62 & (v36 - 1);
            uint64_t v38 = v35 + 48 * v59;
            uint64_t v60 = *(void *)(v38 + 24);
            if (v60 == v33) {
              goto LABEL_97;
            }
          }
LABEL_96:
          uint64_t v38 = v35 + 48 * v36;
        }
LABEL_97:
        if (v38 == v35 + 48 * v36 || (SCEVIter = *(const llvm::SCEV **)(v38 + 40)) == 0) {
          SCEVIter = (const llvm::SCEV *)llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)a2, v33);
        }
        if (llvm::ScalarEvolution::getLoopDisposition((llvm::ScalarEvolution *)a2, SCEVIter, a1) != 1) {
          return result;
        }
LABEL_101:
        uint64_t v64 = *(void *)(a2 + 104);
        unsigned int v65 = *(_DWORD *)(a2 + 120);
        if (!v65) {
          goto LABEL_107;
        }
        unsigned int v66 = (v65 - 1) & ((v32 >> 4) ^ (v32 >> 9));
        uint64_t v67 = v64 + 48 * v66;
        uint64_t v68 = *(void *)(v67 + 24);
        if (v68 != v32)
        {
          int v69 = 1;
          while (v68 != -4096)
          {
            unsigned int v70 = v66 + v69++;
            unsigned int v66 = v70 & (v65 - 1);
            uint64_t v67 = v64 + 48 * v66;
            uint64_t v68 = *(void *)(v67 + 24);
            if (v68 == v32) {
              goto LABEL_108;
            }
          }
LABEL_107:
          uint64_t v67 = v64 + 48 * v65;
        }
LABEL_108:
        if (v67 == v64 + 48 * v65 || (uint64_t v71 = *(void *)(v67 + 40)) == 0) {
          uint64_t v71 = llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)a2, v32);
        }
        if (v71) {
          BOOL v72 = *(unsigned __int16 *)(v71 + 24) == 7;
        }
        else {
          BOOL v72 = 0;
        }
        if (!v72 || *(const llvm::Loop **)(v71 + 48) != a1 || *(void *)(v71 + 40) != 2) {
          return result;
        }
        if (v33)
        {
          uint64_t v73 = *(void *)(a2 + 104);
          unsigned int v74 = *(_DWORD *)(a2 + 120);
          if (v74)
          {
            unsigned int v75 = (v74 - 1) & ((v33 >> 4) ^ (v33 >> 9));
            uint64_t v76 = v73 + 48 * v75;
            uint64_t v77 = *(void *)(v76 + 24);
            if (v77 == v33)
            {
LABEL_131:
              if (v76 == v73 + 48 * v74 || (unint64_t Constant = *(void *)(v76 + 40)) == 0) {
                unint64_t Constant = llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)a2, v33);
              }
              goto LABEL_148;
            }
            int v78 = 1;
            while (v77 != -4096)
            {
              unsigned int v79 = v75 + v78++;
              unsigned int v75 = v79 & (v74 - 1);
              uint64_t v76 = v73 + 48 * v75;
              uint64_t v77 = *(void *)(v76 + 24);
              if (v77 == v33) {
                goto LABEL_131;
              }
            }
          }
          uint64_t v76 = v73 + 48 * v74;
          goto LABEL_131;
        }
        uint64_t v81 = *(uint64_t **)(v71 + 32);
        while (2)
        {
          uint64_t v82 = *v81;
          switch(*(_WORD *)(v82 + 24))
          {
            case 1:
            case 2:
            case 3:
            case 0xD:
              uint64_t v83 = v82 + 40;
              break;
            case 4:
              uint64_t v83 = v82 + 48;
              break;
            case 5:
            case 7:
            case 8:
            case 9:
            case 0xA:
            case 0xB:
            case 0xC:
              uint64_t v81 = *(uint64_t **)(v82 + 32);
              continue;
            case 6:
              uint64_t v81 = (uint64_t *)(v82 + 40);
              continue;
            case 0xE:
              uint64_t v83 = *(void *)(v82 - 8);
              break;
            default:
              uint64_t v83 = *(void *)(v82 + 32);
              break;
          }
          break;
        }
        unint64_t v84 = *(unsigned int *)(*(void *)v83 + 8);
        unint64_t v85 = v84 >> 8;
        LODWORD(v96) = v84 >> 8;
        if (v84 >> 8 > 0x40) {
          operator new[]();
        }
        if (v84 <= 0xFF) {
          unint64_t v86 = 0;
        }
        else {
          unint64_t v86 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v84) + 63);
        }
        BOOL v95 = (void *)(v86 & ~(1 << (v85 - 1)));
        long long v87 = (llvm::ConstantInt *)llvm::ConstantInt::get(***(llvm::ConstantInt ****)a2, (llvm::LLVMContext *)&v95, v26);
        unint64_t Constant = llvm::ScalarEvolution::getConstant((llvm::ScalarEvolution *)a2, v87);
        if (v96 >= 0x41 && v95) {
          MEMORY[0x1D25D9CB0](v95, 0x1000C8000313F17);
        }
LABEL_148:
        v94[2] = Constant;
        uint64_t v89 = *(void **)(v71 + 32);
        uint64_t v88 = *(void *)(v71 + 40);
        v94[0] = *v89;
        if (v88 == 2)
        {
          uint64_t v90 = v89[1];
        }
        else
        {
          BOOL v95 = v97;
          uint64_t v96 = 0x300000000;
          uint64_t v91 = v88;
          size_t v92 = 8 * v88 - 8;
          if (v92 >= 0x19) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          int v93 = 0;
          if (v91 != 1)
          {
            memcpy(v95, v89 + 1, v92);
            int v93 = v96;
          }
          LODWORD(v96) = v93 + (v92 >> 3);
          uint64_t v90 = sub_1CD478318((llvm::ScalarEvolution *)a2, (uint64_t)&v95, *(const llvm::Loop **)(v71 + 48), 0);
          if (v95 != v97) {
            free(v95);
          }
        }
        v94[1] = v90;
        v94[3] = a3;
        *(void *)&double result = sub_1CB8BBE7C(a4, (unint64_t)v94).n128_u64[0];
        break;
      case 7:
        unint64_t v34 = v32;
        unint64_t v32 = v31;
LABEL_53:
        if (!v32 || *(unsigned char *)(v32 + 16) != 16) {
          return result;
        }
        uint64_t v44 = (void *)(v32 + 24);
        uint64_t v45 = *(unsigned int *)(v32 + 32);
        if (v45 < 0x41) {
          goto LABEL_63;
        }
        int v46 = 0;
        int64_t v47 = (unint64_t)(v45 + 63) >> 6;
        do
        {
          BOOL v48 = v47-- < 1;
          if (v48) {
            break;
          }
          unint64_t v49 = *(void *)(*v44 + 8 * v47);
          v46 += __clz(v49);
        }
        while (!v49);
        int v50 = v45 | 0xFFFFFFC0;
        if ((v45 & 0x3F) == 0) {
          int v50 = 0;
        }
        if ((v45 - v46 - v50) > 0x40) {
          return result;
        }
        uint64_t v44 = (void *)*v44;
LABEL_63:
        if (*v44) {
          return result;
        }
        unint64_t v33 = 0;
        unint64_t v32 = v34;
        goto LABEL_101;
      default:
        return result;
    }
  }
  return result;
}

void sub_1CCD767EC(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 56) + 40) != *(void *)(*(void *)(a1 + 56) + 32)) {
    llvm::CloneBasicBlock();
  }
  llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopLatch();
}

void sub_1CCD77560(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  char v5 = 1;
  char v8 = 1;
  if (*a5)
  {
    int v6 = a5;
    char v5 = 3;
  }
  char v7 = v5;
  operator new();
}

void sub_1CCD77640(_OWORD *a1)
{
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  operator new();
}

uint64_t sub_1CCD793AC(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  if (*(void *)(*(void *)(result + 8) + 40) != *(void *)(result + 8) + 40)
  {
    uint64_t v5 = *(void *)(*(void *)(result + 8) + 48);
    uint64_t v6 = v5 - 24;
    uint64_t v7 = v5 ? v5 - 24 : 0;
    if (v5 && *(unsigned char *)(v7 + 16) == 83)
    {
      unsigned int v9 = 0;
      do
      {
        double result = sub_1CC45E7A4(v6, a2, *(void *)(*(void *)(a3 + 16) + 8 * v9));
        uint64_t v10 = *(void *)(v6 + 32);
        uint64_t v6 = v10 - 24;
        if (v10) {
          uint64_t v11 = v10 - 24;
        }
        else {
          uint64_t v11 = 0;
        }
        if (!v10) {
          break;
        }
        ++v9;
      }
      while (*(unsigned char *)(v11 + 16) == 83);
    }
  }
  *(void *)(v4 + 56) = *(void *)(a3 + 40);
  return result;
}

unint64_t sub_1CCD7945C(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *(void *)(a1 + 32);
  *(void *)(v10 + 128) += 152;
  uint64_t v11 = *(void *)(v10 + 48);
  if (((v11 + 7) & 0xFFFFFFFFFFFFFFF8) - v11 + 152 > *(void *)(v10 + 56) - v11)
  {
    unsigned int v64 = *(_DWORD *)(v10 + 72) >> 7;
    if (v64 >= 0x1E) {
      LOBYTE(v64) = 30;
    }
    uint64_t v65 = 4096 << v64;
    unint64_t v12 = (unint64_t)operator new(4096 << v64, (std::align_val_t)8uLL);
    unsigned int v66 = *(_DWORD *)(v10 + 72);
    if (v66 >= *(_DWORD *)(v10 + 76)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(v10 + 64) + 8 * v66) = v12;
    ++*(_DWORD *)(v10 + 72);
    *(void *)(v10 + 56) = v12 + v65;
  }
  else
  {
    unint64_t v12 = (v11 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *(void *)(v10 + 48) = v12 + 152;
  *(void *)(v12 + 144) = 0;
  *(_OWORD *)(v12 + 112) = 0u;
  *(_OWORD *)(v12 + 128) = 0u;
  *(_OWORD *)(v12 + 80) = 0u;
  *(_OWORD *)(v12 + 96) = 0u;
  *(_OWORD *)(v12 + 48) = 0u;
  *(_OWORD *)(v12 + 64) = 0u;
  *(_OWORD *)(v12 + 16) = 0u;
  *(_OWORD *)(v12 + 32) = 0u;
  *(_OWORD *)unint64_t v12 = 0u;
  *(void *)(v12 + 56) = v12 + 88;
  *(void *)(v12 + 64) = v12 + 88;
  *(_DWORD *)(v12 + 72) = 8;
  if (a3)
  {
    *(void *)unint64_t v12 = a3;
    uint64_t v14 = (unint64_t *)a3[2];
    unint64_t v13 = a3[3];
    if ((unint64_t)v14 < v13)
    {
      *uint64_t v14 = v12;
      uint64_t v15 = v14 + 1;
LABEL_32:
      a3[2] = v15;
      goto LABEL_40;
    }
    uint64_t v20 = (void *)a3[1];
    uint64_t v21 = v14 - v20;
    unint64_t v22 = v21 + 1;
    if (!((unint64_t)(v21 + 1) >> 61))
    {
      uint64_t v23 = v13 - (void)v20;
      if (v23 >> 2 > v22) {
        unint64_t v22 = v23 >> 2;
      }
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v24 = v22;
      }
      if (!v24)
      {
        uint64_t v25 = 0;
        goto LABEL_27;
      }
      if (!(v24 >> 61))
      {
        uint64_t v25 = (char *)operator new(8 * v24);
LABEL_27:
        unint64_t v32 = (unint64_t *)&v25[8 * v21];
        unint64_t *v32 = v12;
        uint64_t v15 = v32 + 1;
        if (v14 != v20)
        {
          do
          {
            unint64_t v33 = *--v14;
            *--unint64_t v32 = v33;
          }
          while (v14 != v20);
          uint64_t v14 = (unint64_t *)a3[1];
        }
        a3[1] = v32;
        a3[2] = v15;
        a3[3] = &v25[8 * v24];
        if (v14) {
          operator delete(v14);
        }
        goto LABEL_32;
      }
LABEL_81:
      sub_1CB833614();
    }
LABEL_80:
    abort();
  }
  unsigned int v16 = *(void **)(a1 + 32);
  unsigned int v18 = (unint64_t *)v16[4];
  unint64_t v17 = v16[5];
  if ((unint64_t)v18 >= v17)
  {
    unint64_t v26 = (void *)v16[3];
    uint64_t v27 = v18 - v26;
    unint64_t v28 = v27 + 1;
    if ((unint64_t)(v27 + 1) >> 61) {
      goto LABEL_80;
    }
    uint64_t v29 = v17 - (void)v26;
    if (v29 >> 2 > v28) {
      unint64_t v28 = v29 >> 2;
    }
    if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v30 = v28;
    }
    if (v30)
    {
      if (v30 >> 61) {
        goto LABEL_81;
      }
      unint64_t v31 = (char *)operator new(8 * v30);
    }
    else
    {
      unint64_t v31 = 0;
    }
    unint64_t v34 = (unint64_t *)&v31[8 * v27];
    *unint64_t v34 = v12;
    unint64_t v19 = v34 + 1;
    if (v18 != v26)
    {
      do
      {
        unint64_t v35 = *--v18;
        *--unint64_t v34 = v35;
      }
      while (v18 != v26);
      unsigned int v18 = (unint64_t *)v16[3];
    }
    v16[3] = v34;
    v16[4] = v19;
    v16[5] = &v31[8 * v30];
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    *unsigned int v18 = v12;
    unint64_t v19 = v18 + 1;
  }
  v16[4] = v19;
LABEL_40:
  (*(void (**)(void, unint64_t, uint64_t))(a1 + 40))(*(void *)(a1 + 48), v12, a5);
  unsigned int v36 = (int32x2_t *****)a2[4];
  unsigned int v37 = (int32x2_t *****)a2[5];
  if (v37 != v36)
  {
    while (1)
    {
      uint64_t v38 = *v36;
      uint64_t v39 = *(uint64_t **)(a1 + 32);
      int v40 = *((_DWORD *)v39 + 4);
      if (!v40) {
        goto LABEL_47;
      }
      uint64_t v41 = *v39;
      unsigned int v42 = v40 - 1;
      uint64_t v43 = ((v38 >> 4) ^ (v38 >> 9)) & (v40 - 1);
      uint64_t v44 = *(int32x2_t *****)(v41 + 16 * v43);
      if (v38 != v44) {
        break;
      }
LABEL_46:
      int64_t v47 = *(void **)(v41 + 16 * v43 + 8);
LABEL_48:
      if (v47 == a2)
      {
        uint64_t v68 = 2;
        int v69 = 0;
        unsigned int v70 = v38;
        if (v38 != (int32x2_t ****)-8192 && v38 != (int32x2_t ****)-4096 && v38 != 0) {
          llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v68);
        }
        uint64_t v67 = &unk_1F2615EC8;
        uint64_t v71 = a4;
        sub_1CC4CFF80(a4, &v67);
        if (v70 != (int32x2_t ****)-8192 && v70 != (int32x2_t ****)-4096 && v70)
        {
          unint64_t v49 = v68 & 0xFFFFFFFFFFFFFFF8;
          *(void *)(v68 & 0xFFFFFFFFFFFFFFF8) = v69;
          if (v69)
          {
            *int v69 = *v69 & 7 | v49;
          }
          else
          {
            int v50 = v70;
            unsigned int v51 = ***v70;
            unint64_t v52 = (unint64_t)v51[303];
            if (v52 <= v49)
            {
              uint64_t v53 = v51[305].u32[0];
              if (v52 + 16 * v53 > v49)
              {
                unsigned int v54 = v53 - 1;
                LODWORD(v55) = v54 & ((v70 >> 4) ^ (v70 >> 9));
                unint64_t v56 = (int32x2_t *****)(v52 + 16 * v55);
                BOOL v57 = *v56;
                if (v70 != *v56)
                {
                  int v58 = 1;
                  do
                  {
                    if (v57 == (int32x2_t ****)-4096) {
                      goto LABEL_67;
                    }
                    int v59 = v55 + v58++;
                    uint64_t v55 = v59 & v54;
                    BOOL v57 = *(int32x2_t *****)(v52 + 16 * v55);
                  }
                  while (v70 != v57);
                  unint64_t v56 = (int32x2_t *****)(v52 + 16 * v55);
                }
                long long *v56 = (int32x2_t ****)-8192;
                v51[304] = vadd_s32(v51[304], (int32x2_t)0x1FFFFFFFFLL);
                int v50 = v70;
LABEL_67:
                *((unsigned char *)v50 + 17) &= ~1u;
              }
            }
          }
        }
        llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::addBasicBlockToLoop();
      }
      if (++v36 == v37) {
        goto LABEL_71;
      }
    }
    int v45 = 1;
    while (v44 != (int32x2_t ****)-4096)
    {
      int v46 = v43 + v45++;
      uint64_t v43 = v46 & v42;
      uint64_t v44 = *(int32x2_t *****)(v41 + 16 * v43);
      if (v38 == v44) {
        goto LABEL_46;
      }
    }
LABEL_47:
    int64_t v47 = 0;
    goto LABEL_48;
  }
LABEL_71:
  int v61 = (uint64_t *)a2[1];
  uint64_t v60 = (uint64_t *)a2[2];
  while (v61 != v60)
  {
    uint64_t v62 = *v61++;
    sub_1CCD7945C(a1, v62, v12, a4, 1);
  }
  return v12;
}

void sub_1CCD79928(const llvm::LoopInfo **a1, llvm *a2, uint64_t a3, uint64_t a4, llvm::ScalarEvolution *a5)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  llvm::formLCSSARecursively(a2, a1[3], a1[4], a1[2], a5);
}

void sub_1CCD79BD0(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD79C08(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)&llvm::BranchProbabilityInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::ScalarEvolutionWrapperPass::ID);

  sub_1CB843600(a2, a2 + 112, (uint64_t)llvm::ScalarEvolutionWrapperPass::ID);
}

uint64_t sub_1CCD79CC8(llvm::FunctionPass *a1, llvm::LLVMContextImpl ****a2)
{
  v43[4] = *MEMORY[0x1E4F143B8];
  if (llvm::FunctionPass::skipFunction(a1, a2))
  {
    LOBYTE(v3) = 0;
  }
  else
  {
    uint64_t v4 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1];
    if (v5 == v6)
    {
LABEL_6:
      uint64_t v7 = 0;
    }
    else
    {
      while (*(char **)v5 != llvm::ScalarEvolutionWrapperPass::ID)
      {
        v5 += 16;
        if (v5 == v6) {
          goto LABEL_6;
        }
      }
      uint64_t v7 = *(void *)(v5 + 8);
    }
    uint64_t v8 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v7 + 96))(v7, llvm::ScalarEvolutionWrapperPass::ID);
    unsigned int v9 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v10 = *v9;
    uint64_t v11 = v9[1];
    if (v10 == v11)
    {
LABEL_11:
      uint64_t v12 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v10 != &llvm::BranchProbabilityInfoWrapperPass::ID)
      {
        v10 += 16;
        if (v10 == v11) {
          goto LABEL_11;
        }
      }
      uint64_t v12 = *(void *)(v10 + 8);
    }
    unint64_t v13 = *(llvm::LoopInfo **)(v8 + 32);
    uint64_t v14 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v12 + 96))(v12, &llvm::BranchProbabilityInfoWrapperPass::ID)+ 32;
    uint64_t v15 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v16 = *v15;
    uint64_t v17 = v15[1];
    if (v16 == v17)
    {
LABEL_16:
      uint64_t v18 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v16 != &llvm::DominatorTreeWrapperPass::ID)
      {
        v16 += 16;
        if (v16 == v17) {
          goto LABEL_16;
        }
      }
      uint64_t v18 = *(void *)(v16 + 8);
    }
    unint64_t v19 = (llvm::Loop *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v18 + 96))(v18, &llvm::DominatorTreeWrapperPass::ID)+ 32);
    uint64_t v20 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v21 = *v20;
    uint64_t v22 = v20[1];
    if (v21 == v22)
    {
LABEL_21:
      uint64_t v23 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v21 != &llvm::LoopInfoWrapperPass::ID)
      {
        v21 += 16;
        if (v21 == v22) {
          goto LABEL_21;
        }
      }
      uint64_t v23 = *(void *)(v21 + 8);
    }
    uint64_t v24 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v23 + 96))(v23, &llvm::LoopInfoWrapperPass::ID);
    unint64_t v26 = (llvm::DominatorTree *)(v24 + 32);
    v37[0] = v13;
    v37[1] = v14;
    v37[2] = v19;
    v37[3] = v24 + 32;
    char v38 = 0;
    char v39 = 0;
    uint64_t v27 = *(llvm ***)(v24 + 56);
    if (v27 != *(llvm ***)(v24 + 64))
    {
      llvm::simplifyLoop(*v27, v19, v26, v13, 0, 0, 0, v25);
      llvm::formLCSSARecursively(*v27, v19, v26, v13, v28);
    }
    int v3 = 0;
    v40[0] = 1;
    for (uint64_t i = 1; i != 9; i += 2)
      v40[i] = -4096;
    uint64_t v41 = v43;
    uint64_t v42 = 0x400000000;
    sub_1CD1B8C08((uint64_t)v26, (char *)v40);
    for (uint64_t j = v42; v42; uint64_t j = v42)
    {
      unint64_t v31 = (char *)v41 + 8 * j;
      uint64_t v32 = *((void *)v31 - 1);
      sub_1CCD7A0C4(v40, (void *)v31 - 1);
      unsigned int v33 = v42 - 1;
      do
      {
        unsigned int v34 = v33;
        if (!v33) {
          break;
        }
      }
      while (!*((void *)v41 + --v33));
      LODWORD(v42) = v34;
      v3 |= sub_1CCD712A8((uint64_t)v37, v32);
    }
    if (v41 != v43) {
      free(v41);
    }
    if ((v40[0] & 1) == 0) {
      MEMORY[0x1D25D9CD0](v40[1], 8);
    }
  }
  return v3 & 1;
}

void sub_1CCD7A054(char **a1, uint64_t a2, char a3)
{
  if ((a3 & 1) == 0)
  {
    v7[4] = v3;
    v7[5] = v4;
    uint64_t v5 = *a1;
    uint64_t v6 = *(void *)(a2 + 8);
    v7[0] = *(void *)(a2 + 16);
    v7[1] = v7[0];
    v7[2] = v6;
    v7[3] = v6;
    sub_1CD887020((uint64_t)v7, v5);
  }
}

void sub_1CCD7A098()
{
}

uint64_t sub_1CCD7A0C4(_DWORD *a1, void *a2)
{
  uint64_t v5 = 0;
  uint64_t result = sub_1CCD7A118((uint64_t)a1, a2, &v5);
  if (result)
  {
    *uint64_t v5 = -8192;
    int v4 = a1[1] + 1;
    *a1 -= 2;
    a1[1] = v4;
  }
  return result;
}

uint64_t sub_1CCD7A118(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_16;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  uint64_t v7 = (void *)(v3 + 16 * v6);
  uint64_t v8 = *v7;
  if (*a2 == *v7)
  {
    uint64_t result = 1;
  }
  else
  {
    unsigned int v9 = 0;
    int v10 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v9) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        unsigned int v9 = v7;
      }
      unsigned int v13 = v6 + v10++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 16 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_16;
      }
    }
    uint64_t result = 0;
    if (v9) {
      uint64_t v7 = v9;
    }
  }
LABEL_16:
  *a3 = v7;
  return result;
}

void sub_1CCD7A1C8(char **a1, uint64_t a2, char a3)
{
  if ((a3 & 1) == 0)
  {
    v7[4] = v3;
    v7[5] = v4;
    int v5 = *a1;
    uint64_t v6 = *(void *)(a2 + 8);
    v7[0] = *(void *)(a2 + 16);
    v7[1] = v7[0];
    v7[2] = v6;
    v7[3] = v6;
    sub_1CD887020((uint64_t)v7, v5);
  }
}

uint64_t sub_1CCD7A20C()
{
  LODWORD(v3) = 1;
  int v4 = 64;
  v1.n128_u64[0] = (unint64_t)&v4;
  sub_1CD46FD38((uint64_t)&unk_1EBCF23C0, "irce-loop-size-cutoff", &v3, (int **)&v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF23C0, &dword_1CB82C000);
  LODWORD(v3) = 1;
  LOBYTE(v4) = 0;
  v1.n128_u64[0] = (unint64_t)&v4;
  sub_1CD76AFBC(&v3, (char **)&v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCF2480, &dword_1CB82C000);
  LODWORD(v3) = 1;
  LOBYTE(v4) = 0;
  v1.n128_u64[0] = (unint64_t)&v4;
  sub_1CD45C54C((uint64_t)&unk_1EBCF2540, "irce-print-range-checks", &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF2540, &dword_1CB82C000);
  LODWORD(v3) = 1;
  LOBYTE(v4) = 0;
  v1.n128_u64[0] = (unint64_t)&v4;
  sub_1CD76B0DC(&v3, (char **)&v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCF2600, &dword_1CB82C000);
  LODWORD(v3) = 1;
  int v4 = 10;
  v1.n128_u64[0] = (unint64_t)&v4;
  sub_1CD76B1FC(&v3, (int **)&v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCF26C0, &dword_1CB82C000);
  LODWORD(v3) = 1;
  LOBYTE(v4) = 1;
  v1.n128_u64[0] = (unint64_t)&v4;
  sub_1CD76B318(&v3, (char **)&v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCF2780, &dword_1CB82C000);
  int v4 = 1;
  char v2 = 1;
  uint64_t v3 = &v2;
  v1.n128_u64[0] = (unint64_t)"If set to true, IRCE may eliminate wide range checks in loops with narrow latch condition.";
  v1.n128_u64[1] = 90;
  sub_1CC025F34((llvm::cl::Option *)&unk_1EBCF2840, "irce-allow-narrow-latch", &v4, &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF2840, &dword_1CB82C000);
}

void llvm::IndVarSimplifyPass::run(unsigned char *a1, llvm::Loop *a2, uint64_t a3, void *a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(*(void *)(**((void **)a2 + 4) + 56) + 40) + 272;
  unsigned int v9 = a4 + 2;
  uint64_t v8 = a4[2];
  uint64_t v7 = v9[1];
  if (*a1) {
    BOOL v10 = byte_1EBD0B3B8 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  char v11 = !v10;
  sub_1CCD7A580((uint64_t)v12, v7, a4[4], v8, v6, a4[5], a4[6], a4[9], v11);
  sub_1CCD7A6A0((int)v12, a2);
}

uint64_t sub_1CCD7A580(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  *(void *)uint64_t result = a2;
  *(void *)(result + 8) = a3;
  *(void *)(result + 16) = a4;
  *(void *)(result + 24) = a5;
  *(void *)(result + 32) = a6;
  *(void *)(result + 40) = a7;
  *(void *)(result + 48) = 0;
  *(void *)(result + 56) = result + 72;
  *(void *)(result + 64) = 0x1000000000;
  *(unsigned char *)(result + 456) = a9;
  if (a8) {
    operator new();
  }
  return result;
}

void sub_1CCD7A6A0(int a1, llvm::Loop *this)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  llvm::Loop::isLoopSimplifyForm(this);
}

void sub_1CCD821DC(llvm *a1, llvm::PassRegistry *a2)
{
}

uint64_t sub_1CCD8227C(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF2900;
  *(_DWORD *)(a1 + 24) = 1;
  *(void *)a1 = &unk_1F263E430;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF2908, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD821DC;
    v5[1] = &PassRegistry;
    int v4 = v5;
    std::__call_once(&qword_1EBCF2908, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CCD8232C(llvm::SCEVExpander *a1, unint64_t a2, llvm::Loop *a3, unsigned int a4, uint64_t a5, llvm::Instruction *a6)
{
  v26[16] = *MEMORY[0x1E4F143B8];
  unint64_t v23 = a2;
  if (!a5) {
    return 1;
  }
  int v7 = a5;
  uint64_t v24 = v26;
  uint64_t v25 = 0x800000000;
  uint64_t v18 = v22;
  unint64_t v19 = v22;
  uint64_t v20 = 8;
  int v21 = 0;
  uint64_t v16 = 0;
  int v17 = 0;
  v14[0] = -1;
  unsigned int v15 = -1;
  sub_1CCD89B78((uint64_t)&v24, v14, &v15, &v23);
  do
  {
    BOOL v11 = v25 != 0;
    if (!v25) {
      break;
    }
    long long v12 = *((_OWORD *)v24 + v25 - 1);
    LODWORD(v25) = v25 - 1;
    *(_OWORD *)uint64_t v14 = v12;
  }
  while (!llvm::SCEVExpander::isHighCostExpansionHelper(a1, (uint64_t)v14, a3, a6, (uint64_t)&v16, a4, v7, (llvm::SmallPtrSetImplBase *)&v18, (uint64_t)&v24));
  if (v19 != v18) {
    free(v19);
  }
  if (v24 != v26) {
    free(v24);
  }
  return v11;
}

_DWORD *sub_1CCD82494(uint64_t a1)
{
  sub_1CCD89BB8((_DWORD *)(a1 + 32));
  sub_1CBFC9A80((_DWORD *)(a1 + 56));
  sub_1CBFC9A80((_DWORD *)(a1 + 80));
  uint64_t v2 = *(void **)(a1 + 112);
  if (v2 == *(void **)(a1 + 104)) {
    goto LABEL_2;
  }
  uint64_t v21 = *(unsigned int *)(a1 + 120);
  if (v21 < 0x21 || 4 * (*(_DWORD *)(a1 + 124) - *(_DWORD *)(a1 + 128)) >= v21)
  {
    memset(v2, 255, 8 * v21);
LABEL_2:
    *(_DWORD *)(a1 + 124) = 0;
    *(_DWORD *)(a1 + 128) = 0;
    goto LABEL_3;
  }
  llvm::SmallPtrSetImplBase::shrink_and_clear((void **)(a1 + 104));
LABEL_3:
  uint64_t result = sub_1CBFC9A80((_DWORD *)(a1 + 416));
  unsigned int v4 = *(_DWORD *)(a1 + 272);
  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 264);
    uint64_t v6 = v5 + 24 * v4;
    do
    {
      uint64_t v7 = *(void *)(v6 - 8);
      if (v7 != -8192 && v7 != -4096 && v7 != 0)
      {
        unint64_t v9 = *(void *)(v6 - 24) & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v9 = *(void *)(v6 - 16);
        BOOL v10 = *(unint64_t **)(v6 - 16);
        if (v10)
        {
          *BOOL v10 = *v10 & 7 | v9;
        }
        else
        {
          uint64_t v11 = *(void *)(v6 - 8);
          long long v12 = ***(int32x2_t ****)v11;
          unint64_t v13 = (unint64_t)v12[303];
          if (v13 <= v9)
          {
            uint64_t v14 = v12[305].u32[0];
            if (v13 + 16 * v14 > v9)
            {
              unsigned int v15 = v14 - 1;
              LODWORD(v16) = v15 & ((v11 >> 4) ^ (v11 >> 9));
              int v17 = (uint64_t *)(v13 + 16 * v16);
              uint64_t v18 = *v17;
              if (v11 == *v17)
              {
LABEL_29:
                *int v17 = -8192;
                v12[304] = vadd_s32(v12[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v11 = *(void *)(v6 - 8);
              }
              else
              {
                int v19 = 1;
                while (v18 != -4096)
                {
                  int v20 = v16 + v19++;
                  uint64_t v16 = v20 & v15;
                  uint64_t v18 = *(void *)(v13 + 16 * v16);
                  if (v11 == v18)
                  {
                    int v17 = (uint64_t *)(v13 + 16 * v16);
                    goto LABEL_29;
                  }
                }
              }
              *(unsigned char *)(v11 + 17) &= ~1u;
            }
          }
        }
      }
      v6 -= 24;
    }
    while (v6 != v5);
  }
  *(_DWORD *)(a1 + 272) = 0;
  return result;
}

uint64_t sub_1CCD82634(uint64_t a1, void *a2)
{
  char v6 = 0;
  uint64_t v5 = 0;
  if (sub_1CB87E144(a1, &v5, 1, 64, 1, 0, &v6)) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = v6 == 0;
  }
  uint64_t result = !v3;
  if (!v3) {
    *a2 = v5;
  }
  return result;
}

_DWORD *sub_1CCD8269C(_DWORD *result, int a2)
{
  uint64_t v2 = result;
  if (a2)
  {
    unint64_t v3 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    LODWORD(v4) = (((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8)) + 1;
    result[4] = v4;
    uint64_t result = operator new(40 * v4, (std::align_val_t)8uLL);
    *(void *)uint64_t v2 = result;
    *((void *)v2 + 1) = 0;
    uint64_t v5 = v2[4];
    if (v5)
    {
      uint64_t v6 = 40 * v5;
      int64x2_t v7 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
      do
      {
        *(int64x2_t *)uint64_t result = v7;
        result += 10;
        v6 -= 40;
      }
      while (v6);
    }
  }
  else
  {
    *(void *)uint64_t result = 0;
    *((void *)result + 1) = 0;
    result[4] = 0;
  }
  return result;
}

void sub_1CCD82740()
{
}

void sub_1CCD82754(uint64_t a1, unsigned __int8 *a2)
{
  int v2 = a2[16];
  BOOL v3 = v2 == 68;
  if ((v2 - 67) <= 1)
  {
    uint64_t v6 = *(void *)(a1 + 16);
    int64x2_t v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(uint64_t ***)a2;
    unsigned int v9 = *(_DWORD *)(*(void *)a2 + 8);
    uint64_t v10 = *(void *)(*(void *)v6 + 40);
    if (v9 == 15)
    {
      if ((v9 & 0xFE) == 0x12) {
        unsigned int v9 = *(_DWORD *)(*v8[2] + 8);
      }
      uint64_t v34 = *(void *)(v10 + 504);
      if (v9 < 0x100) {
        goto LABEL_37;
      }
      unsigned int v35 = v9 >> 8;
      unint64_t v36 = *(unsigned int *)(v10 + 512);
      uint64_t v37 = *(void *)(v10 + 504);
      if (v36)
      {
        uint64_t v37 = v34;
        unint64_t v38 = v36;
        do
        {
          unint64_t v39 = v38 >> 1;
          uint64_t v40 = v37 + 16 * (v38 >> 1);
          unsigned int v41 = *(_DWORD *)(v40 + 8);
          uint64_t v42 = v40 + 16;
          v38 += ~(v38 >> 1);
          if (v41 < v35) {
            uint64_t v37 = v42;
          }
          else {
            unint64_t v38 = v39;
          }
        }
        while (v38);
      }
      if (v37 == v34 + 16 * v36 || *(_DWORD *)(v37 + 8) != v35) {
LABEL_37:
      }
        uint64_t v37 = v34;
      unint64_t v12 = *(unsigned int *)(v37 + 12);
    }
    else
    {
      unint64_t v12 = sub_1CB83544C(v10 + 272, *(void *)a2);
      if (v11 == 1) {
    }
      }
    uint64_t v13 = *(void *)(*(void *)(*((void *)a2 + 5) + 56) + 40);
    uint64_t v14 = *(void *)(v13 + 304);
    unsigned int v15 = *(char **)(v13 + 312);
    uint64_t v16 = &v15[v14];
    if (v12 <= 0xFF)
    {
      int v17 = (char *)memchr(*(void **)(v13 + 304), (char)v12, *(void *)(v13 + 312));
      if (v17) {
        uint64_t v16 = v17;
      }
    }
    if (&v16[-v14] != v15)
    {
      uint64_t v18 = **(void **)(a1 + 40);
      unsigned int v19 = *(_DWORD *)(v18 + 8);
      uint64_t v20 = *(void *)(*(void *)v6 + 40);
      if (v19 == 15)
      {
        if ((v19 & 0xFE) == 0x12) {
          unsigned int v19 = *(_DWORD *)(**(void **)(v18 + 16) + 8);
        }
        uint64_t v43 = *(void *)(v20 + 504);
        if (v19 < 0x100) {
          goto LABEL_50;
        }
        unsigned int v44 = v19 >> 8;
        unint64_t v45 = *(unsigned int *)(v20 + 512);
        uint64_t v46 = *(void *)(v20 + 504);
        if (v45)
        {
          uint64_t v46 = v43;
          unint64_t v47 = v45;
          do
          {
            unint64_t v48 = v47 >> 1;
            uint64_t v49 = v46 + 16 * (v47 >> 1);
            unsigned int v50 = *(_DWORD *)(v49 + 8);
            uint64_t v51 = v49 + 16;
            v47 += ~(v47 >> 1);
            if (v50 < v44) {
              uint64_t v46 = v51;
            }
            else {
              unint64_t v47 = v48;
            }
          }
          while (v47);
        }
        if (v46 == v43 + 16 * v45 || *(_DWORD *)(v46 + 8) != v44) {
LABEL_50:
        }
          uint64_t v46 = v43;
        unint64_t v22 = *(unsigned int *)(v46 + 12);
      }
      else
      {
        unint64_t v22 = sub_1CB83544C(v20 + 272, v18);
        if (v21 == 1) {
      }
        }
      if (v22 < v12)
      {
        if (!v7) {
          goto LABEL_17;
        }
        uint64_t v23 = (*(uint64_t (**)(void, uint64_t, uint64_t **, void, void, void, void, void, void, void, void))(*(void *)*v7 + 824))(*v7, 13, v8, 0, 0, 0, 0, 0, 0, 0, 0);
        int v25 = v24;
        BOOL v27 = (*(uint64_t (**)(void, uint64_t, void))(*(void *)*v7 + 824))(*v7, 13, **((void **)a2 - 4)) < v23;
        if (v26 != v25) {
          BOOL v27 = v26 < v25;
        }
        if (!v27)
        {
LABEL_17:
          uint64_t v28 = *(void *)(a1 + 48);
          if (!v28) {
            goto LABEL_22;
          }
          unsigned int v29 = *(_DWORD *)(v28 + 8);
          uint64_t v30 = *(void *)(*(void *)v6 + 40);
          if (v29 == 15)
          {
            if ((v29 & 0xFE) == 0x12) {
              unsigned int v29 = *(_DWORD *)(**(void **)(v28 + 16) + 8);
            }
            uint64_t v52 = *(void *)(v30 + 504);
            if (v29 < 0x100) {
              goto LABEL_63;
            }
            unsigned int v53 = v29 >> 8;
            unint64_t v54 = *(unsigned int *)(v30 + 512);
            uint64_t v55 = *(void *)(v30 + 504);
            if (v54)
            {
              uint64_t v55 = v52;
              unint64_t v56 = v54;
              do
              {
                unint64_t v57 = v56 >> 1;
                uint64_t v58 = v55 + 16 * (v56 >> 1);
                unsigned int v59 = *(_DWORD *)(v58 + 8);
                uint64_t v60 = v58 + 16;
                v56 += ~(v56 >> 1);
                if (v59 < v53) {
                  uint64_t v55 = v60;
                }
                else {
                  unint64_t v56 = v57;
                }
              }
              while (v56);
            }
            if (v55 == v52 + 16 * v54 || *(_DWORD *)(v55 + 8) != v53) {
LABEL_63:
            }
              uint64_t v55 = v52;
            unint64_t v32 = *(unsigned int *)(v55 + 12);
          }
          else
          {
            unint64_t v32 = sub_1CB83544C(v30 + 272, v28);
            if (v31 == 1) {
          }
            }
          if (v12 <= v32)
          {
            *(unsigned char *)(a1 + 56) |= v3;
          }
          else
          {
LABEL_22:
            unsigned int v33 = *((_DWORD *)v8 + 2);
            if (v33 != 13)
            {
              uint64_t v61 = *(void *)(*(void *)v6 + 40);
              if ((v33 & 0xFE) == 0x12) {
                unsigned int v33 = *(_DWORD *)(*v8[2] + 8);
              }
              uint64_t v62 = *(void *)(v61 + 504);
              if (v33 < 0x100) {
                goto LABEL_76;
              }
              unsigned int v63 = v33 >> 8;
              unint64_t v64 = *(unsigned int *)(v61 + 512);
              uint64_t v65 = v62;
              if (v64)
              {
                uint64_t v65 = v62;
                unint64_t v66 = v64;
                do
                {
                  unint64_t v67 = v66 >> 1;
                  uint64_t v68 = v65 + 16 * (v66 >> 1);
                  unsigned int v69 = *(_DWORD *)(v68 + 8);
                  uint64_t v70 = v68 + 16;
                  v66 += ~(v66 >> 1);
                  if (v69 < v63) {
                    uint64_t v65 = v70;
                  }
                  else {
                    unint64_t v66 = v67;
                  }
                }
                while (v66);
              }
              if (v65 == v62 + 16 * v64 || *(_DWORD *)(v65 + 8) != v63) {
LABEL_76:
              }
                uint64_t v65 = v62;
              uint64_t v71 = (uint64_t **)llvm::IntegerType::get((llvm::IntegerType *)*v8, (llvm::LLVMContext *)*(unsigned int *)(v65 + 12));
              if ((v8[1] & 0xFE) == 0x12)
              {
                BOOL v72 = (llvm::Type *)*((unsigned int *)v8 + 8);
                if (*((_DWORD *)v8 + 2) == 19) {
                  llvm::ScalableVectorType::get(v71, v72);
                }
                else {
                  llvm::FixedVectorType::get((llvm::FixedVectorType *)v71, v72);
                }
              }
              uint64_t v8 = v71;
            }
            *(void *)(a1 + 48) = v8;
            *(unsigned char *)(a1 + 56) = v3;
          }
        }
      }
    }
  }
}

uint64_t sub_1CCD82C60(uint64_t a1, unsigned int a2, int a3)
{
  v174[1] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = **(void **)(a1 + 8);
  if (!v3 || (*(_DWORD *)(v3 + 20) & 0x7FFFFFF) != 3) {
    return 0;
  }
  unint64_t v4 = 0;
  uint64_t v5 = *(void *)(v3 - 96);
  if (!v5 || *(unsigned char *)(v5 + 16) != 81) {
    return (uint64_t)v4;
  }
  int64x2_t v7 = *(llvm::Value **)(v5 - 64);
  if (!v7) {
    return 0;
  }
  unint64_t v4 = *(llvm::Value **)(v5 - 32);
  if (!v4) {
    return (uint64_t)v4;
  }
  if (!*(void *)(v3 - 32)) {
    return 0;
  }
  uint64_t v8 = *(void *)(v3 - 64);
  if (!v8) {
    return 0;
  }
  uint64_t v11 = **(void **)a1;
  uint64_t v12 = **(void **)(a1 + 16);
  MinusSCEV = **(llvm::detail::IEEEFloat ****)(a1 + 24);
  uint64_t v14 = *(void *)(a1 + 32);
  v157 = *(llvm::SCEVExpander **)(a1 + 40);
  unsigned int v15 = *(llvm::ScalarEvolution **)(v14 + 8);
  uint64_t v16 = *(_WORD *)(v5 + 18) & 0x3F;
  uint64_t v18 = *(void *)(v11 + 56);
  uint64_t v17 = *(void *)(v11 + 64);
  if (v17 == v18)
  {
    uint64_t v19 = *(unsigned int *)(v11 + 76);
    uint64_t v20 = (void *)(v17 + 8 * v19);
    if (v19)
    {
      uint64_t v21 = 0;
      uint64_t v22 = 8 * v19;
      while (*(void *)(v17 + v21) != v8)
      {
        v21 += 8;
        if (v22 == v21) {
          goto LABEL_29;
        }
      }
      uint64_t v20 = (void *)(v17 + v21);
    }
LABEL_29:
    uint64_t v18 = *(void *)(v11 + 64);
  }
  else
  {
    uint64_t v23 = *(unsigned int *)(v11 + 72);
    int v24 = v23 - 1;
    unsigned int v25 = (v23 - 1) & ((v8 >> 4) ^ (v8 >> 9));
    uint64_t v20 = (void *)(v17 + 8 * v25);
    uint64_t v26 = *v20;
    if (*v20 == -1)
    {
      BOOL v27 = 0;
LABEL_45:
      if (v27) {
        uint64_t v20 = v27;
      }
      if (*v20 != v8) {
        uint64_t v20 = (void *)(v17 + 8 * v23);
      }
    }
    else
    {
      BOOL v27 = 0;
      int v28 = 1;
      while (v26 != v8)
      {
        if (v27) {
          BOOL v29 = 0;
        }
        else {
          BOOL v29 = v26 == -2;
        }
        if (v29) {
          BOOL v27 = v20;
        }
        unsigned int v30 = v25 + v28++;
        unsigned int v25 = v30 & v24;
        uint64_t v20 = (void *)(v17 + 8 * (v30 & v24));
        uint64_t v26 = *v20;
        if (*v20 == -1) {
          goto LABEL_45;
        }
      }
    }
  }
  uint64_t v31 = 72;
  if (v17 == v18) {
    uint64_t v31 = 76;
  }
  if (v20 != (void *)(v17 + 8 * *(unsigned int *)(v11 + v31))) {
    uint64_t v16 = dword_1CFB2CDE8[v16];
  }
  v158 = (uint64_t *)(v14 + 56);
  if (a2) {
    uint64_t v16 = dword_1CFB2CDE8[(__int16)v16];
  }
  SCEVAtScope = llvm::ScalarEvolution::getSCEVAtScope(v15, v7, (const llvm::Loop *)v11);
  unsigned int v33 = llvm::ScalarEvolution::getSCEVAtScope(v15, v4, (const llvm::Loop *)v11);
  if (llvm::ScalarEvolution::isKnownPredicateAt(v15, v16, SCEVAtScope, v33, v3))
  {
    sub_1CCD839A0(v11, v12, a2, v158);
    return 1;
  }
  if (a2) {
    return 0;
  }
  uint64_t v34 = SCEVAtScope;
  while (2)
  {
    switch(*((_WORD *)v34 + 12))
    {
      case 1:
      case 2:
      case 3:
      case 0xD:
        unint64_t v36 = (llvm::Type **)((char *)v34 + 40);
        goto LABEL_52;
      case 4:
        unint64_t v36 = (llvm::Type **)((char *)v34 + 48);
        goto LABEL_52;
      case 5:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
        unsigned int v35 = (const llvm::SCEV **)*((void *)v34 + 4);
        goto LABEL_42;
      case 6:
        unsigned int v35 = (const llvm::SCEV **)((char *)v34 + 40);
LABEL_42:
        uint64_t v34 = *v35;
        continue;
      case 0xE:
        unint64_t v36 = (llvm::Type **)*((void *)v34 - 1);
        goto LABEL_52;
      default:
        unint64_t v36 = (llvm::Type **)*((void *)v34 + 4);
LABEL_52:
        v156 = *v36;
        uint64_t v37 = MinusSCEV;
        break;
    }
    break;
  }
  while (2)
  {
    switch(*((_WORD *)v37 + 12))
    {
      case 1:
      case 2:
      case 3:
      case 0xD:
        unint64_t v39 = v37 + 5;
        goto LABEL_60;
      case 4:
        unint64_t v39 = v37 + 6;
        goto LABEL_60;
      case 5:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
        unint64_t v38 = (llvm::detail::IEEEFloat ***)v37[4];
        goto LABEL_55;
      case 6:
        unint64_t v38 = (llvm::detail::IEEEFloat ***)(v37 + 5);
LABEL_55:
        uint64_t v37 = *v38;
        continue;
      case 0xE:
        unint64_t v39 = (llvm::Type **)*(v37 - 1);
        goto LABEL_60;
      default:
        unint64_t v39 = (llvm::Type **)v37[4];
LABEL_60:
        v155 = *v39;
        unsigned int v40 = *((_DWORD *)v156 + 2);
        uint64_t v41 = *(void *)(*(void *)v15 + 40);
        if (v40 == 15)
        {
          if ((v40 & 0xFE) == 0x12) {
            unsigned int v40 = *(_DWORD *)(**((void **)v156 + 2) + 8);
          }
          uint64_t v69 = *(void *)(v41 + 504);
          if (v40 < 0x100) {
            goto LABEL_111;
          }
          unsigned int v70 = v40 >> 8;
          unint64_t v71 = *(unsigned int *)(v41 + 512);
          uint64_t v72 = *(void *)(v41 + 504);
          if (v71)
          {
            uint64_t v72 = v69;
            unint64_t v73 = v71;
            do
            {
              unint64_t v74 = v73 >> 1;
              uint64_t v75 = v72 + 16 * (v73 >> 1);
              unsigned int v76 = *(_DWORD *)(v75 + 8);
              uint64_t v77 = v75 + 16;
              v73 += ~(v73 >> 1);
              if (v76 < v70) {
                uint64_t v72 = v77;
              }
              else {
                unint64_t v73 = v74;
              }
            }
            while (v73);
          }
          if (v72 == v69 + 16 * v71 || *(_DWORD *)(v72 + 8) != v70) {
LABEL_111:
          }
            uint64_t v72 = v69;
          unint64_t v153 = *(unsigned int *)(v72 + 12);
        }
        else
        {
          unint64_t v153 = sub_1CB83544C(v41 + 272, (uint64_t)v156);
          if (v42 == 1) {
        }
          }
        unsigned int v43 = *((_DWORD *)v155 + 2);
        uint64_t v44 = *(void *)(*(void *)v15 + 40);
        if (v43 == 15)
        {
          if ((v43 & 0xFE) == 0x12) {
            unsigned int v43 = *(_DWORD *)(**((void **)v155 + 2) + 8);
          }
          uint64_t v78 = *(void *)(v44 + 504);
          if (v43 < 0x100) {
            goto LABEL_124;
          }
          unsigned int v79 = v43 >> 8;
          unint64_t v80 = *(unsigned int *)(v44 + 512);
          uint64_t v81 = *(void *)(v44 + 504);
          if (v80)
          {
            uint64_t v81 = v78;
            unint64_t v82 = v80;
            do
            {
              unint64_t v83 = v82 >> 1;
              uint64_t v84 = v81 + 16 * (v82 >> 1);
              unsigned int v85 = *(_DWORD *)(v84 + 8);
              uint64_t v86 = v84 + 16;
              v82 += ~(v82 >> 1);
              if (v85 < v79) {
                uint64_t v81 = v86;
              }
              else {
                unint64_t v82 = v83;
              }
            }
            while (v82);
          }
          if (v81 == v78 + 16 * v80 || *(_DWORD *)(v81 + 8) != v79) {
LABEL_124:
          }
            uint64_t v81 = v78;
          unint64_t v46 = *(unsigned int *)(v81 + 12);
        }
        else
        {
          unint64_t v46 = sub_1CB83544C(v44 + 272, (uint64_t)v155);
          if (v45 == 1) {
        }
          }
        if (v153 > v46)
        {
          unint64_t ZeroExtendExpr = llvm::ScalarEvolution::getZeroExtendExpr(v15, MinusSCEV, (uint64_t **)v156, 0);
LABEL_68:
          MinusSCEV = (llvm::detail::IEEEFloat **)ZeroExtendExpr;
          goto LABEL_78;
        }
        unsigned int v48 = *((_DWORD *)v156 + 2);
        uint64_t v49 = *(void *)(*(void *)v15 + 40);
        if (v48 == 15)
        {
          if ((v48 & 0xFE) == 0x12) {
            unsigned int v48 = *(_DWORD *)(**((void **)v156 + 2) + 8);
          }
          uint64_t v101 = *(void *)(v49 + 504);
          if (v48 < 0x100) {
            goto LABEL_156;
          }
          unsigned int v102 = v48 >> 8;
          unint64_t v103 = *(unsigned int *)(v49 + 512);
          uint64_t v104 = *(void *)(v49 + 504);
          if (v103)
          {
            uint64_t v104 = v101;
            unint64_t v105 = v103;
            do
            {
              unint64_t v106 = v105 >> 1;
              uint64_t v107 = v104 + 16 * (v105 >> 1);
              unsigned int v108 = *(_DWORD *)(v107 + 8);
              uint64_t v109 = v107 + 16;
              v105 += ~(v105 >> 1);
              if (v108 < v102) {
                uint64_t v104 = v109;
              }
              else {
                unint64_t v105 = v106;
              }
            }
            while (v105);
          }
          if (v104 == v101 + 16 * v103 || *(_DWORD *)(v104 + 8) != v102) {
LABEL_156:
          }
            uint64_t v104 = v101;
          unint64_t v154 = *(unsigned int *)(v104 + 12);
        }
        else
        {
          unint64_t v154 = sub_1CB83544C(v49 + 272, (uint64_t)v156);
          if (v50 == 1) {
        }
          }
        unsigned int v51 = *((_DWORD *)v155 + 2);
        uint64_t v52 = *(void *)(*(void *)v15 + 40);
        if (v51 == 15)
        {
          if ((v51 & 0xFE) == 0x12) {
            unsigned int v51 = *(_DWORD *)(**((void **)v155 + 2) + 8);
          }
          uint64_t v110 = *(void *)(v52 + 504);
          if (v51 < 0x100) {
            goto LABEL_169;
          }
          unsigned int v111 = v51 >> 8;
          unint64_t v112 = *(unsigned int *)(v52 + 512);
          uint64_t v113 = *(void *)(v52 + 504);
          if (v112)
          {
            uint64_t v113 = v110;
            unint64_t v114 = v112;
            do
            {
              unint64_t v115 = v114 >> 1;
              uint64_t v116 = v113 + 16 * (v114 >> 1);
              unsigned int v117 = *(_DWORD *)(v116 + 8);
              uint64_t v118 = v116 + 16;
              v114 += ~(v114 >> 1);
              if (v117 < v111) {
                uint64_t v113 = v118;
              }
              else {
                unint64_t v114 = v115;
              }
            }
            while (v114);
          }
          if (v113 == v110 + 16 * v112 || *(_DWORD *)(v113 + 8) != v111) {
LABEL_169:
          }
            uint64_t v113 = v110;
          unint64_t v54 = *(unsigned int *)(v113 + 12);
        }
        else
        {
          unint64_t v54 = sub_1CB83544C(v52 + 272, (uint64_t)v155);
          if (v53 == 1) {
        }
          }
        if (v154 < v54)
        {
          unint64_t Constant = (llvm::detail::IEEEFloat **)llvm::ScalarEvolution::getConstant(v15, v156, 0xFFFFFFFFFFFFFFFFLL, (const llvm::APInt *)1);
          unint64_t v56 = (const llvm::SCEV *)llvm::ScalarEvolution::getZeroExtendExpr(v15, Constant, (uint64_t **)v155, 0);
          if (llvm::ScalarEvolution::isKnownPredicateAt(v15, 37, (const llvm::SCEV *)MinusSCEV, v56, v3))
          {
            unint64_t ZeroExtendExpr = llvm::ScalarEvolution::getTruncateExpr(v15, (const llvm::SCEV *)MinusSCEV, v156, 0);
            goto LABEL_68;
          }
        }
LABEL_78:
        if (a3)
        {
          unint64_t v57 = MinusSCEV;
          while (2)
          {
            switch(*((_WORD *)v57 + 12))
            {
              case 1:
              case 2:
              case 3:
              case 0xD:
                unsigned int v59 = v57 + 5;
                goto LABEL_87;
              case 4:
                unsigned int v59 = v57 + 6;
                goto LABEL_87;
              case 5:
              case 7:
              case 8:
              case 9:
              case 0xA:
              case 0xB:
              case 0xC:
                uint64_t v58 = (llvm::detail::IEEEFloat ***)v57[4];
                goto LABEL_82;
              case 6:
                uint64_t v58 = (llvm::detail::IEEEFloat ***)(v57 + 5);
LABEL_82:
                unint64_t v57 = *v58;
                continue;
              case 0xE:
                unsigned int v59 = (llvm::Type **)*(v57 - 1);
                goto LABEL_87;
              default:
                unsigned int v59 = (llvm::Type **)v57[4];
LABEL_87:
                uint64_t v60 = (const llvm::APInt *)llvm::ScalarEvolution::getConstant(v15, *v59, 1uLL, 0);
                MinusSCEV = (llvm::detail::IEEEFloat **)llvm::ScalarEvolution::getMinusSCEV(v15, (llvm::SCEV *)MinusSCEV, v60, 0, 0);
                break;
            }
            break;
          }
        }
        llvm::ScalarEvolution::getLoopInvariantExitCondDuringFirstIterations(v33, (llvm::Loop *)v11, v15, v16, SCEVAtScope, v3, (llvm::SCEV *)MinusSCEV, (uint64_t)&v159);
        unint64_t v4 = (llvm::Value *)(v162 != 0);
        if (!v162) {
          return (uint64_t)v4;
        }
        unsigned int v61 = v159;
        unsigned int v63 = v160;
        uint64_t v62 = v161;
        if (llvm::ScalarEvolution::isKnownPredicateAt(v15, v159, (const llvm::SCEV *)v160, (const llvm::SCEV *)v161, v3))
        {
          sub_1CCD839A0(v11, v12, 0, v158);
          return (uint64_t)v4;
        }
        unint64_t v66 = *(void **)(v12 + 40);
        uint64_t v65 = (void *)(v12 + 40);
        unint64_t v64 = v66;
        if (v66 == v65)
        {
          uint64_t v68 = 0;
        }
        else
        {
          if (v64) {
            uint64_t v67 = (uint64_t)(v64 - 3);
          }
          else {
            uint64_t v67 = 0;
          }
          if (*(unsigned __int8 *)(v67 + 16) - 29 >= 0xB) {
            uint64_t v68 = 0;
          }
          else {
            uint64_t v68 = v67;
          }
        }
        *((void *)v157 + 62) = *(void *)(v68 + 40);
        *((void *)v157 + 63) = v68 + 24;
        long long v87 = *(unsigned __int8 **)(v68 + 48);
        v163[0] = v87;
        if (v87)
        {
          llvm::MetadataTracking::track((uint64_t)v163, v87, 2);
          uint64_t v88 = v163[0];
        }
        else
        {
          uint64_t v88 = 0;
        }
        sub_1CB8461A4((uint64_t)v157 + 448, 0, v88);
        if (!v163[0]) {
          goto LABEL_131;
        }
        int v145 = *(unsigned __int8 *)v163[0];
        if ((v145 - 4) > 0x1E)
        {
          if ((v145 - 3) >= 0xFFFFFFFE) {
            uint64_t v151 = v163[0];
          }
          else {
            uint64_t v151 = 0;
          }
          if ((v145 - 3) >= 0xFFFFFFFE)
          {
            unint64_t v147 = v151 + 8;
LABEL_226:
            v166[0] = v163;
            sub_1CC5FA668(v147 + 16, v166);
            goto LABEL_131;
          }
          if (v145 == 3) {
            *(void *)(v163[0] + 8) = 0;
          }
        }
        else if ((*(unsigned char *)(v163[0] + 1) & 0x7F) == 2 || *(_DWORD *)(v163[0] + 12))
        {
          uint64_t v146 = *(void *)(v163[0] + 16);
          if ((v146 & 4) != 0)
          {
            unint64_t v147 = v146 & 0xFFFFFFFFFFFFFFF8;
            if (v147) {
              goto LABEL_226;
            }
          }
        }
LABEL_131:
        uint64_t v89 = llvm::SCEVExpander::expandCodeForImpl(v157, v63, 0);
        uint64_t v90 = llvm::SCEVExpander::expandCodeForImpl(v157, v62, 0);
        uint64_t v91 = (void *)*v65;
        if ((void *)*v65 == v65)
        {
          int v93 = 0;
        }
        else
        {
          if (v91) {
            size_t v92 = (unsigned __int8 *)(v91 - 3);
          }
          else {
            size_t v92 = 0;
          }
          if (v92[16] - 29 >= 0xB) {
            int v93 = 0;
          }
          else {
            int v93 = (llvm::Instruction *)v92;
          }
        }
        uint64_t Successor = llvm::Instruction::getSuccessor(v93, 0);
        uint64_t v96 = *(void *)(v11 + 56);
        uint64_t v95 = *(void *)(v11 + 64);
        if (v95 == v96)
        {
          uint64_t v97 = *(unsigned int *)(v11 + 76);
          uint64_t v98 = (void *)(v95 + 8 * v97);
          if (v97)
          {
            uint64_t v99 = 0;
            uint64_t v100 = 8 * v97;
            while (*(void *)(v95 + v99) != Successor)
            {
              v99 += 8;
              if (v100 == v99) {
                goto LABEL_183;
              }
            }
            uint64_t v98 = (void *)(v95 + v99);
          }
LABEL_183:
          uint64_t v96 = *(void *)(v11 + 64);
        }
        else
        {
          uint64_t v119 = *(unsigned int *)(v11 + 72);
          int v120 = v119 - 1;
          unsigned int v121 = (v119 - 1) & ((Successor >> 4) ^ (Successor >> 9));
          uint64_t v98 = (void *)(v95 + 8 * v121);
          uint64_t v122 = *v98;
          if (*v98 == -1)
          {
            uint64_t v123 = 0;
LABEL_203:
            if (v123) {
              uint64_t v98 = v123;
            }
            if (*v98 != Successor) {
              uint64_t v98 = (void *)(v95 + 8 * v119);
            }
          }
          else
          {
            uint64_t v123 = 0;
            int v124 = 1;
            while (v122 != Successor)
            {
              if (v123) {
                BOOL v125 = 0;
              }
              else {
                BOOL v125 = v122 == -2;
              }
              if (v125) {
                uint64_t v123 = v98;
              }
              unsigned int v126 = v121 + v124++;
              unsigned int v121 = v126 & v120;
              uint64_t v98 = (void *)(v95 + 8 * (v126 & v120));
              uint64_t v122 = *v98;
              if (*v98 == -1) {
                goto LABEL_203;
              }
            }
          }
        }
        BOOL v29 = v95 == v96;
        uint64_t v127 = (unsigned int *)(v11 + 76);
        if (!v29) {
          uint64_t v127 = (unsigned int *)(v11 + 72);
        }
        if (v98 == (void *)(v95 + 8 * *v127)) {
          unsigned int v61 = dword_1CFB2CDE8[v61];
        }
        uint64_t v128 = 0;
        uint64_t v129 = **(void **)v68;
        v166[1] = (void *)0x200000000;
        v167[6] = v129;
        v167[7] = &v173;
        v167[8] = v174;
        v167[9] = 0;
        int v168 = 0;
        __int16 v169 = 512;
        char v170 = 7;
        uint64_t v171 = 0;
        uint64_t v172 = 0;
        v173 = &unk_1F2616E88;
        v174[0] = &unk_1F2617008;
        v167[4] = *(void *)(v68 + 40);
        v167[5] = v68 + 24;
        uint64_t v130 = *(unsigned __int8 **)(v68 + 48);
        v165 = v130;
        v166[0] = v167;
        if (v130)
        {
          llvm::MetadataTracking::track((uint64_t)&v165, v130, 2);
          uint64_t v128 = (uint64_t)v165;
        }
        sub_1CB8461A4((uint64_t)v166, 0, v128);
        if (!v165) {
          goto LABEL_191;
        }
        int v148 = *v165;
        if ((v148 - 4) > 0x1E)
        {
          if ((v148 - 3) >= 0xFFFFFFFE) {
            v152 = v165;
          }
          else {
            v152 = 0;
          }
          if ((v148 - 3) >= 0xFFFFFFFE)
          {
            unint64_t v150 = (unint64_t)(v152 + 8);
LABEL_232:
            v163[0] = &v165;
            sub_1CC5FA668(v150 + 16, v163);
            goto LABEL_191;
          }
          if (v148 == 3) {
            *((void *)v165 + 1) = 0;
          }
        }
        else if ((v165[1] & 0x7F) == 2 || *((_DWORD *)v165 + 3))
        {
          uint64_t v149 = *((void *)v165 + 2);
          if ((v149 & 4) != 0)
          {
            unint64_t v150 = v149 & 0xFFFFFFFFFFFFFFF8;
            if (v150) {
              goto LABEL_232;
            }
          }
        }
LABEL_191:
        uint64_t v131 = *(uint64_t ****)(v68 - 96);
        if ((*((unsigned char *)v131 + 23) & 0x10) != 0)
        {
          uint64_t v132 = ***v131;
          uint64_t v133 = *(void *)(v132 + 152);
          uint64_t v134 = *(unsigned int *)(v132 + 168);
          if (v134)
          {
            LODWORD(v135) = (v134 - 1) & ((v131 >> 4) ^ (v131 >> 9));
            uint64_t v136 = (uint64_t ****)(v133 + 16 * v135);
            uint64_t v137 = *v136;
            if (*v136 == v131)
            {
LABEL_199:
              v140 = v136[1];
              v143 = *v140;
              uint64_t v141 = (char *)(v140 + 2);
              v142 = v143;
              goto LABEL_200;
            }
            int v138 = 1;
            while (v137 != (uint64_t ***)-4096)
            {
              int v139 = v135 + v138++;
              uint64_t v135 = v139 & (v134 - 1);
              uint64_t v137 = *(uint64_t ****)(v133 + 16 * v135);
              if (v137 == v131)
              {
                uint64_t v136 = (uint64_t ****)(v133 + 16 * v135);
                goto LABEL_199;
              }
            }
          }
          uint64_t v136 = (uint64_t ****)(v133 + 16 * v134);
          goto LABEL_199;
        }
        v142 = 0;
        uint64_t v141 = &byte_1CFBCE98E;
LABEL_200:
        __int16 v164 = 261;
        v163[0] = v141;
        v163[1] = v142;
        v144 = sub_1CB845F20((uint64_t)v166, v61, v89, (uint64_t)v90, (uint64_t)v163);
        sub_1CCD84938(v68, (uint64_t)v144, v158);
        if (v166[0] != v167) {
          free(v166[0]);
        }
        break;
    }
    return (uint64_t)v4;
  }
}

uint64_t sub_1CCD839A0(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4)
{
  uint64_t v7 = *(void *)(a2 + 40);
  if (v7 == a2 + 40)
  {
    unsigned int v9 = 0;
  }
  else
  {
    if (v7) {
      uint64_t v8 = (unsigned __int8 *)(v7 - 24);
    }
    else {
      uint64_t v8 = 0;
    }
    if (v8[16] - 29 >= 0xB) {
      unsigned int v9 = 0;
    }
    else {
      unsigned int v9 = (llvm::Instruction *)v8;
    }
  }
  uint64_t Successor = llvm::Instruction::getSuccessor(v9, 0);
  uint64_t v12 = *(void *)(a1 + 56);
  uint64_t v11 = *(void *)(a1 + 64);
  if (v11 == v12)
  {
    uint64_t v13 = *(unsigned int *)(a1 + 76);
    uint64_t v14 = (void *)(v11 + 8 * v13);
    if (v13)
    {
      uint64_t v15 = 0;
      uint64_t v16 = 8 * v13;
      while (*(void *)(v11 + v15) != Successor)
      {
        v15 += 8;
        if (v16 == v15) {
          goto LABEL_27;
        }
      }
      uint64_t v14 = (void *)(v11 + v15);
    }
LABEL_27:
    uint64_t v12 = *(void *)(a1 + 64);
  }
  else
  {
    uint64_t v17 = *(unsigned int *)(a1 + 72);
    int v18 = v17 - 1;
    unsigned int v19 = (v17 - 1) & ((Successor >> 4) ^ (Successor >> 9));
    uint64_t v14 = (void *)(v11 + 8 * v19);
    uint64_t v20 = *v14;
    if (*v14 == -1)
    {
      uint64_t v21 = 0;
LABEL_34:
      if (v21) {
        uint64_t v14 = v21;
      }
      if (*v14 != Successor) {
        uint64_t v14 = (void *)(v11 + 8 * v17);
      }
    }
    else
    {
      uint64_t v21 = 0;
      int v22 = 1;
      while (v20 != Successor)
      {
        if (v21) {
          BOOL v23 = 0;
        }
        else {
          BOOL v23 = v20 == -2;
        }
        if (v23) {
          uint64_t v21 = v14;
        }
        unsigned int v24 = v19 + v22++;
        unsigned int v19 = v24 & v18;
        uint64_t v14 = (void *)(v11 + 8 * (v24 & v18));
        uint64_t v20 = *v14;
        if (*v14 == -1) {
          goto LABEL_34;
        }
      }
    }
  }
  BOOL v23 = v11 == v12;
  uint64_t v25 = 72;
  if (v23) {
    uint64_t v25 = 76;
  }
  uint64_t v26 = llvm::ConstantInt::get(**((llvm::ConstantInt ***)v9 - 12), (v14 != (void *)(v11 + 8 * *(unsigned int *)(a1 + v25))) ^ a3, 0);

  return sub_1CCD84938((uint64_t)v9, (uint64_t)v26, a4);
}

uint64_t sub_1CCD83B24(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v10 = (uint64_t *)result;
  while (2)
  {
    uint64_t v11 = a2 - 1;
    unsigned int v53 = a2 - 3;
    unint64_t v54 = a2 - 2;
    uint64_t i = v10;
    uint64_t v55 = a2;
    while (1)
    {
      while (1)
      {
        uint64_t v10 = i;
        uint64_t v13 = (char *)a2 - (char *)i;
        uint64_t v14 = a2 - i;
        if (v6 || !v5)
        {
          switch(v14)
          {
            case 0:
            case 1:
              return result;
            case 2:
              if (*(a2 - 1) != *v10) {
                llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
              }
              return result;
            case 3:
              uint64_t result = (uint64_t)sub_1CCD8455C(v10, v10 + 1, v11);
              break;
            case 4:
              uint64_t result = (uint64_t)sub_1CCD84860(v10, v10 + 1, v10 + 2, v11);
              break;
            case 5:
              uint64_t result = (uint64_t)sub_1CCD84450(v10, v10 + 1, v10 + 2, v10 + 3, v11);
              break;
            default:
              JUMPOUT(0);
          }
          return result;
        }
        if (v13 <= 191)
        {
          BOOL v29 = v10 + 1;
          BOOL v31 = v10 == a2 || v29 == a2;
          if (a5)
          {
            if (!v31)
            {
              uint64_t v32 = 0;
              unsigned int v33 = v10;
              do
              {
                uint64_t v35 = *v33;
                uint64_t v34 = v33[1];
                unsigned int v33 = v29;
                if (v34 != v35) {
                  llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
                }
                ++v29;
                v32 += 8;
              }
              while (v33 + 1 != a2);
            }
          }
          else if (!v31)
          {
            do
            {
              uint64_t v52 = v10;
              uint64_t v10 = v29;
              if (v52[1] != *v52) {
                llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
              }
              ++v29;
            }
            while (v10 + 1 != a2);
          }
          return result;
        }
        if (!a4)
        {
          if (v10 != a2)
          {
            int64_t v36 = (unint64_t)(v14 - 2) >> 1;
            int64_t v57 = v36;
            do
            {
              int64_t v37 = v36;
              if (v57 >= v36)
              {
                uint64_t v38 = (2 * v36) | 1;
                unint64_t v39 = &v10[v38];
                if (2 * v36 + 2 < v14 && *v39 != v39[1]) {
                  llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
                }
                if (*v39 != v10[v36]) {
                  llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
                }
                uint64_t v40 = *v39;
                v10[v36] = *v39;
                if (v57 >= v38)
                {
                  do
                  {
                    uint64_t v42 = 2 * v38;
                    uint64_t v38 = (2 * v38) | 1;
                    uint64_t v41 = &v10[v38];
                    if (v42 + 2 < v14 && *v41 != v41[1]) {
                      llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
                    }
                    if (*v41 != v40) {
                      llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
                    }
                    uint64_t *v39 = v40;
                    unint64_t v39 = &v10[v38];
                  }
                  while (v57 >= v38);
                }
                else
                {
                  uint64_t v41 = &v10[v38];
                }
                *uint64_t v41 = v40;
              }
              --v36;
            }
            while (v37);
            unsigned int v43 = v55;
            do
            {
              uint64_t v44 = 0;
              uint64_t v58 = *v10;
              unint64_t v45 = v10;
              do
              {
                unint64_t v46 = v45;
                v45 += v44 + 1;
                uint64_t v47 = 2 * v44;
                uint64_t v44 = (2 * v44) | 1;
                if (v47 + 2 < v14 && *v45 != v45[1]) {
                  llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
                }
                *unint64_t v46 = *v45;
              }
              while (v44 <= (uint64_t)((unint64_t)(v14 - 2) >> 1));
              unsigned int v48 = v43 - 1;
              if (v45 == v48)
              {
                unsigned int v50 = v48;
                *unint64_t v45 = v58;
              }
              else
              {
                *unint64_t v45 = *v48;
                unsigned int v50 = v48;
                uint64_t *v48 = v58;
                uint64_t v49 = (char *)v45 - (char *)v10 + 8;
                if (v49 >= 9 && v10[(((unint64_t)v49 >> 3) - 2) >> 1] != *v45) {
                  llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
                }
              }
              BOOL v51 = v14-- <= 2;
              unsigned int v43 = v50;
            }
            while (!v51);
          }
          return result;
        }
        unint64_t v15 = (unint64_t)v14 >> 1;
        uint64_t v16 = &v10[(unint64_t)v14 >> 1];
        if ((unint64_t)v13 < 0x401)
        {
          uint64_t result = (uint64_t)sub_1CCD8455C(v16, v10, v11);
        }
        else
        {
          sub_1CCD8455C(v10, v16, v11);
          sub_1CCD8455C(v10 + 1, v16 - 1, v54);
          sub_1CCD8455C(v10 + 2, &v10[v15 + 1], v53);
          uint64_t result = (uint64_t)sub_1CCD8455C(v16 - 1, v16, &v10[v15 + 1]);
          uint64_t v17 = *v10;
          *uint64_t v10 = *v16;
          *uint64_t v16 = v17;
        }
        --a4;
        if (a5) {
          break;
        }
        uint64_t v18 = *(v10 - 1);
        if (v18 != *v10) {
          llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
        }
        if (v18 != *v11) {
          llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
        }
        for (uint64_t i = v10 + 1; i < a2; ++i)
        {
          if (v18 != *i) {
            llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
          }
        }
        if (i < a2)
        {
          uint64_t v26 = *i;
          uint64_t *i = *a2;
          BOOL v27 = i + 1;
          *a2 = v26;
          while (v18 == *v27)
            ++v27;
          llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
        }
        int v28 = i - 1;
        BOOL v5 = i - 1 >= v10;
        BOOL v6 = i - 1 == v10;
        if (i - 1 != v10) {
          *uint64_t v10 = *v28;
        }
        a5 = 0;
        *int v28 = v18;
      }
      uint64_t v19 = *v10;
      if (v10[1] != *v10) {
        llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
      }
      uint64_t v20 = v10 + 1;
      uint64_t j = v55;
      if (v10 + 1 < v55)
      {
        for (uint64_t j = v11; ; --j)
        {
          if (*j != v19) {
            llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
          }
          if (v20 >= j) {
            break;
          }
        }
      }
      uint64_t i = v10 + 1;
      if (v20 < j)
      {
        int v22 = j;
        uint64_t v23 = *i;
        uint64_t *i = *j;
        *uint64_t j = v23;
        if (v10[2] != v19) {
          llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
        }
        do
          uint64_t v24 = *--v22;
        while (v24 == v19);
        llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
      }
      *uint64_t v10 = v19;
      a2 = v55;
      char v25 = sub_1CCD84678(v10, v10);
      uint64_t result = sub_1CCD84678(i, v55);
      if (result) {
        break;
      }
      if ((v25 & 1) == 0)
      {
        uint64_t result = sub_1CCD83B24(v10, v10, a3, a4, a5 & 1);
        a5 = 0;
      }
    }
    a2 = v10;
    if ((v25 & 1) == 0) {
      continue;
    }
    break;
  }
  return result;
}

void *sub_1CCD84450(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  uint64_t result = sub_1CCD84860(a1, a2, a3, a4);
  if (*a5 != *a4) {
    llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
  }
  return result;
}

void *sub_1CCD8455C(void *result, void *a2, void *a3)
{
  if (*a2 != *result) {
    llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
  }
  if (*a3 != *a2) {
    llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
  }
  return result;
}

uint64_t sub_1CCD84678(void *a1, void *a2)
{
  uint64_t v4 = a2 - a1;
  uint64_t result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(a2 - 1) != *a1) {
        llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
      }
      return result;
    case 3:
      sub_1CCD8455C(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      sub_1CCD84860(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      sub_1CCD84450(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      BOOL v6 = a1 + 2;
      sub_1CCD8455C(a1, a1 + 1, a1 + 2);
      uint64_t v7 = a1 + 3;
      if (a1 + 3 != a2)
      {
        uint64_t v8 = 16;
        do
        {
          if (*v7 != *v6) {
            llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
          }
          BOOL v6 = v7;
          v8 += 8;
          ++v7;
        }
        while (v7 != a2);
      }
      return 1;
  }
}

void *sub_1CCD84860(void *a1, void *a2, void *a3, void *a4)
{
  uint64_t result = sub_1CCD8455C(a1, a2, a3);
  if (*a4 != *a3) {
    llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
  }
  return result;
}

uint64_t sub_1CCD84938(uint64_t result, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = (void *)(result - 96);
  uint64_t v3 = *(void *)(result - 96);
  uint64_t v9 = v3;
  if (v3)
  {
    **(void **)(result - 80) = *(void *)(result - 88);
    uint64_t v5 = *(void *)(result - 88);
    if (v5) {
      *(void *)(v5 + 16) = *(void *)(result - 80);
    }
  }
  *uint64_t v4 = a2;
  if (a2)
  {
    uint64_t v8 = *(void *)(a2 + 8);
    BOOL v6 = (void *)(a2 + 8);
    uint64_t v7 = v8;
    *(void *)(result - 88) = v8;
    if (v8) {
      *(void *)(v7 + 16) = result - 88;
    }
    *(void *)(result - 80) = v6;
    *BOOL v6 = v4;
  }
  if (!*(void *)(v3 + 8)) {
    return sub_1CCD849B4(a3, &v9);
  }
  return result;
}

uint64_t sub_1CCD849B4(uint64_t *a1, uint64_t *a2)
{
  unsigned int v3 = *((_DWORD *)a1 + 2);
  if (v3 >= *((_DWORD *)a1 + 3))
  {
    sub_1CD76B8A8();
  }
  uint64_t v4 = *a1;
  uint64_t v5 = (llvm::ValueHandleBase *)(*a1 + 24 * v3);
  uint64_t v6 = *a2;
  *(void *)uint64_t v5 = 6;
  *((void *)v5 + 1) = 0;
  *((void *)v5 + 2) = v6;
  if (v6 != -8192 && v6 != -4096 && v6 != 0)
  {
    llvm::ValueHandleBase::AddToUseList(v5);
    unsigned int v3 = *((_DWORD *)a1 + 2);
    uint64_t v4 = *a1;
  }
  unsigned int v8 = v3 + 1;
  *((_DWORD *)a1 + 2) = v8;
  return v4 + 24 * v8 - 24;
}

char *sub_1CCD84A4C(char *result, char *a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v21 = a2;
  uint64_t v7 = result;
  uint64_t v8 = a2 - result;
  uint64_t v9 = (a2 - result) >> 3;
  if (!v6 & v5)
  {
    if (v8 <= 191)
    {
      BOOL v11 = result == a2 || result + 8 == a2;
      if (a5)
      {
        if (!v11) {
          llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
        }
      }
      else if (!v11)
      {
        llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
      }
    }
    else
    {
      if (a4)
      {
        if ((unint64_t)v8 < 0x401) {
          sub_1CCD87990();
        }
        sub_1CCD87990();
      }
      if (result != a2)
      {
        int64_t v12 = (unint64_t)(v9 - 2) >> 1;
        do
        {
          int64_t v13 = v12;
          if ((uint64_t)((unint64_t)(v9 - 2) >> 1) >= v12)
          {
            if (2 * v12 + 2 >= v9) {
              llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
            }
            llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
          }
          --v12;
        }
        while (v13);
        do
        {
          uint64_t v14 = v7;
          uint64_t v15 = 0;
          uint64_t v20 = *(void *)v14;
          do
          {
            uint64_t v16 = v14;
            v14 += 8 * v15 + 8;
            uint64_t v17 = 2 * v15;
            uint64_t v15 = (2 * v15) | 1;
            if (v17 + 2 < v9) {
              llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
            }
            *(void *)uint64_t v16 = *(void *)v14;
          }
          while (v15 <= (uint64_t)((unint64_t)(v9 - 2) >> 1));
          uint64_t v18 = v21 - 8;
          BOOL v6 = v14 == v21 - 8;
          v21 -= 8;
          if (v6)
          {
            *(void *)uint64_t v14 = v20;
          }
          else
          {
            *(void *)uint64_t v14 = *(void *)v18;
            *(void *)uint64_t v18 = v20;
            if (v14 - result + 8 >= 9) {
              llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
            }
          }
          BOOL v19 = v9-- <= 2;
          uint64_t v7 = result;
        }
        while (!v19);
      }
    }
  }
  else
  {
    switch(v9)
    {
      case 0:
      case 1:
        return result;
      case 2:
        llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
      case 3:
        sub_1CCD87990();
      case 4:
        sub_1CCD88D50();
      case 5:
        sub_1CCD88D50();
      default:
        JUMPOUT(0);
    }
  }
  return result;
}

void sub_1CCD87990()
{
}

uint64_t sub_1CCD8814C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (a2 - a1) >> 3;
  uint64_t result = 1;
  switch(v2)
  {
    case 0:
    case 1:
      return result;
    case 2:
      llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
    case 3:
      sub_1CCD87990();
    case 4:
      sub_1CCD88D50();
    case 5:
      sub_1CCD88D50();
    default:
      sub_1CCD87990();
  }
}

void sub_1CCD88D50()
{
}

uint64_t sub_1CCD8922C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  if (a1)
  {
    unsigned int v3 = *(unsigned __int8 *)(a1 + 16);
    if (v3 >= 0x1C)
    {
      if (v3 != 41 && v3 != 43 && (v3 != 62 || (*(_DWORD *)(a1 + 20) & 0x7FFFFFF) != 2)) {
        return 0;
      }
      int v4 = *(_DWORD *)(a1 + 20);
      if ((v4 & 0x40000000) != 0) {
        char v5 = *(uint64_t **)(a1 - 8);
      }
      else {
        char v5 = (uint64_t *)(a1 - 32 * (v4 & 0x7FFFFFF));
      }
      uint64_t v2 = *v5;
      if (*v5 && *(unsigned char *)(v2 + 16) == 83 && *(void *)(v2 + 40) == **(void **)(a2 + 32))
      {
        if ((v4 & 0x40000000) != 0) {
          uint64_t v8 = *(void *)(a1 - 8);
        }
        else {
          uint64_t v8 = a1 - 32 * (v4 & 0x7FFFFFF);
        }
        if (!llvm::Loop::isLoopInvariant(a2, *(void *)(v8 + 32))) {
          return 0;
        }
      }
      else
      {
        if (v3 == 62) {
          return 0;
        }
        uint64_t v6 = (v4 & 0x40000000) != 0 ? *(void *)(a1 - 8) : a1 - 32 * (v4 & 0x7FFFFFF);
        uint64_t v2 = *(void *)(v6 + 32);
        if (!v2 || *(unsigned char *)(v2 + 16) != 83 || *(void *)(v2 + 40) != **(void **)(a2 + 32)) {
          return 0;
        }
        uint64_t v7 = (v4 & 0x40000000) != 0 ? *(uint64_t **)(a1 - 8) : (uint64_t *)(a1 - 32 * (v4 & 0x7FFFFFF));
        if (!llvm::Loop::isLoopInvariant(a2, *v7)) {
          return 0;
        }
      }
    }
  }
  return v2;
}

uint64_t sub_1CCD89368(uint64_t a1, const llvm::Instruction *a2, llvm::DominatorTree *a3)
{
  v51[16] = *MEMORY[0x1E4F143B8];
  unsigned int v43 = v47;
  uint64_t v44 = v47;
  uint64_t v45 = 16;
  int v46 = 0;
  unsigned int v48 = v51;
  unsigned int v50 = 16;
  v51[0] = a1;
  unsigned int v6 = 1;
  while (1)
  {
    uint64_t v7 = *((void *)v48 + v6 - 1);
    unsigned int v49 = v6 - 1;
    if (llvm::mustTriggerUB(v7, (uint64_t *)&v43, 0))
    {
      if (llvm::DominatorTree::dominates(a3, (const llvm::Value *)v7, a2)) {
        break;
      }
    }
    if (v7 != a1)
    {
      int v8 = *(_DWORD *)(v7 + 20);
      if ((v8 & 0x40000000) != 0)
      {
        uint64_t v10 = *(uint64_t **)(v7 - 8);
        uint64_t v9 = v8 & 0x7FFFFFF;
        if (!v9) {
          goto LABEL_80;
        }
      }
      else
      {
        uint64_t v9 = v8 & 0x7FFFFFF;
        uint64_t v10 = (uint64_t *)(v7 - 32 * v9);
        if (!v9) {
          goto LABEL_80;
        }
      }
      BOOL v11 = &v10[4 * v9];
      while (1)
      {
        uint64_t v12 = *v10;
        int64_t v13 = v43;
        if (v44 == v43)
        {
          int v14 = HIDWORD(v45);
          uint64_t v15 = &v44[8 * HIDWORD(v45)];
          if (HIDWORD(v45))
          {
            uint64_t v16 = 0;
            while (*(void *)&v44[v16] != v12)
            {
              v16 += 8;
              if (8 * HIDWORD(v45) == v16) {
                goto LABEL_29;
              }
            }
            uint64_t v15 = &v44[v16];
          }
LABEL_29:
          int64_t v13 = v44;
        }
        else
        {
          int v17 = v45 - 1;
          unsigned int v18 = (v45 - 1) & ((v12 >> 4) ^ (v12 >> 9));
          uint64_t v15 = &v44[8 * v18];
          uint64_t v19 = *(void *)v15;
          if (*(void *)v15 == -1)
          {
            uint64_t v20 = 0;
LABEL_37:
            if (v20) {
              uint64_t v15 = v20;
            }
            int v14 = HIDWORD(v45);
            if (*(void *)v15 != v12) {
              uint64_t v15 = &v44[8 * v45];
            }
          }
          else
          {
            uint64_t v20 = 0;
            int v21 = 1;
            while (v19 != v12)
            {
              if (v20) {
                BOOL v22 = 0;
              }
              else {
                BOOL v22 = v19 == -2;
              }
              if (v22) {
                uint64_t v20 = v15;
              }
              unsigned int v23 = v18 + v21++;
              unsigned int v18 = v23 & v17;
              uint64_t v15 = &v44[8 * (v23 & v17)];
              uint64_t v19 = *(void *)v15;
              if (*(void *)v15 == -1) {
                goto LABEL_37;
              }
            }
            int v14 = HIDWORD(v45);
          }
        }
        int v24 = v45;
        if (v44 == v13) {
          int v24 = v14;
        }
        if (v15 != &v44[8 * v24] && llvm::propagatesPoison((uint64_t)v10)) {
          break;
        }
        v10 += 4;
        if (v10 == v11) {
          goto LABEL_80;
        }
      }
    }
    char v25 = v44;
    uint64_t v26 = HIDWORD(v45);
    if (v44 != v43)
    {
      unsigned int v30 = v45;
LABEL_53:
      if (3 * v30 <= 4 * (HIDWORD(v45) - v46))
      {
        if (v30 >= 0x40) {
          v30 *= 2;
        }
        else {
          unsigned int v30 = 128;
        }
      }
      else if (v30 - HIDWORD(v45) >= v30 >> 3)
      {
LABEL_55:
        unsigned int v31 = v30 - 1;
        unsigned int v32 = (v30 - 1) & ((v7 >> 4) ^ (v7 >> 9));
        unsigned int v33 = &v25[8 * v32];
        uint64_t v34 = *(void *)v33;
        if (*(void *)v33 != -1)
        {
          uint64_t v35 = 0;
          int v36 = 1;
          while (v34 != v7)
          {
            if (v35) {
              BOOL v37 = 0;
            }
            else {
              BOOL v37 = v34 == -2;
            }
            if (v37) {
              uint64_t v35 = (uint64_t *)v33;
            }
            unsigned int v38 = v32 + v36++;
            unsigned int v32 = v38 & v31;
            unsigned int v33 = &v25[8 * (v38 & v31)];
            uint64_t v34 = *(void *)v33;
            if (*(void *)v33 == -1) {
              goto LABEL_67;
            }
          }
          goto LABEL_80;
        }
        uint64_t v35 = 0;
LABEL_67:
        if (v35) {
          unint64_t v39 = v35;
        }
        else {
          unint64_t v39 = (uint64_t *)v33;
        }
        if (*v39 == v7) {
          goto LABEL_80;
        }
        if (*v39 == -2) {
          --v46;
        }
        else {
          ++HIDWORD(v45);
        }
        uint64_t *v39 = v7;
        goto LABEL_74;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v43, v30);
      unsigned int v30 = v45;
      char v25 = v44;
      goto LABEL_55;
    }
    if (HIDWORD(v45))
    {
      BOOL v27 = 0;
      uint64_t v28 = 8 * HIDWORD(v45);
      BOOL v29 = (uint64_t *)v44;
      while (*v29 != v7)
      {
        if (*v29 == -2) {
          BOOL v27 = v29;
        }
        ++v29;
        v28 -= 8;
        if (!v28)
        {
          if (!v27) {
            goto LABEL_50;
          }
          *BOOL v27 = v7;
          --v46;
          goto LABEL_74;
        }
      }
      goto LABEL_80;
    }
LABEL_50:
    unsigned int v30 = v45;
    if (HIDWORD(v45) >= v45) {
      goto LABEL_53;
    }
    ++HIDWORD(v45);
    *(void *)&v44[8 * v26] = v7;
LABEL_74:
    uint64_t v40 = *(void *)(v7 + 8);
    if (v40)
    {
      unsigned int v6 = v49;
      do
      {
        if (v6 >= v50) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v48 + v6) = *(void *)(v40 + 24);
        unsigned int v6 = ++v49;
        uint64_t v40 = *(void *)(v40 + 8);
      }
      while (v40);
      goto LABEL_81;
    }
LABEL_80:
    unsigned int v6 = v49;
LABEL_81:
    if (!v6)
    {
      uint64_t v41 = 0;
      goto LABEL_90;
    }
  }
  uint64_t v41 = 1;
LABEL_90:
  if (v48 != v51) {
    free(v48);
  }
  if (v44 != v43) {
    free(v44);
  }
  return v41;
}

uint64_t sub_1CCD89784(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(a1 + 20);
  uint64_t v4 = v3 & 0x7FFFFFF;
  if ((v3 & 0x7FFFFFF) != 0)
  {
    uint64_t v5 = 0;
    while (1)
    {
      uint64_t v6 = a1 - 32 * v4;
      if ((v3 & 0x40000000) != 0) {
        uint64_t v6 = *(void *)(a1 - 8);
      }
      if (*(void *)(v6 + 32 * *(unsigned int *)(a1 + 60) + 8 * v5) == a2) {
        break;
      }
      if (v4 == ++v5) {
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    LODWORD(v5) = -1;
  }
  if ((v3 & 0x40000000) != 0) {
    uint64_t v7 = *(void *)(a1 - 8);
  }
  else {
    uint64_t v7 = a1 - 32 * v4;
  }
  uint64_t v8 = *(void *)(v7 + 32 * v5);
  uint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    while (1)
    {
      uint64_t v10 = *(void *)(v9 + 24);
      if (v10 != a3 && v10 != v8) {
        return 0;
      }
      uint64_t v9 = *(void *)(v9 + 8);
      if (!v9) {
        goto LABEL_18;
      }
    }
  }
  else
  {
LABEL_18:
    uint64_t v12 = *(void *)(v8 + 8);
    if (v12)
    {
      do
      {
        uint64_t v13 = *(void *)(v12 + 24);
        BOOL v14 = v13 == a3 || v13 == a1;
        uint64_t v15 = v14;
        if (!v14) {
          break;
        }
        uint64_t v12 = *(void *)(v12 + 8);
      }
      while (v12);
    }
    else
    {
      return 1;
    }
  }
  return v15;
}

uint64_t sub_1CCD89848(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v3 = *(unsigned __int8 *)(a1 + 16);
  if (v3 <= 0x14) {
    return v3 - 13 < 0xFFFFFFFE;
  }
  uint64_t result = 0;
  if (a3 > 5 || v3 < 0x1C) {
    return result;
  }
  uint64_t v8 = v3 - 33;
  if (v8 <= 0x37)
  {
    if (((1 << v8) & 0x8000000000041) != 0)
    {
      uint64_t v31 = *(void *)(a1 + 64);
      if (!v31 || (*(unsigned char *)(v31 + 20) & 4) == 0 && (*(unsigned char *)(v31 + 17) & 0x10) == 0)
      {
        __int32 v33 = 7;
        if (sub_1CC5CB59C(a1, &v33, 1uLL))
        {
          uint64_t v32 = *(void *)(a1 - 32);
          if (!v32
            || *(unsigned char *)(v32 + 16)
            || *(void *)(v32 + 24) != *(void *)(a1 + 72)
            || *(_DWORD *)(v32 + 36) != 7)
          {
            return 0;
          }
        }
        if ((llvm::CallBase::hasFnAttrOnCalledFunction(a1, 66) & 1) == 0)
        {
          uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction(a1, 44);
          if (!result) {
            return result;
          }
        }
      }
    }
    else if (((1 << v8) & 0x808001C8000010) != 0 || v8 == 28 && (*(_WORD *)(a1 + 18) & 0x301) != 0)
    {
      return 0;
    }
  }
  uint64_t result = 0;
  int v9 = *(unsigned __int8 *)(a1 + 16);
  if (v9 != 33 && v9 != 84)
  {
    int v10 = *(_DWORD *)(a1 + 20);
    if ((v10 & 0x40000000) != 0)
    {
      uint64_t v12 = *(uint64_t **)(a1 - 8);
      uint64_t v11 = v10 & 0x7FFFFFF;
      if (v11) {
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v11 = v10 & 0x7FFFFFF;
      uint64_t v12 = (uint64_t *)(a1 - 32 * v11);
      if (v11)
      {
LABEL_14:
        uint64_t v13 = a3 + 1;
        BOOL v14 = &v12[4 * v11];
        while (1)
        {
          uint64_t v15 = *v12;
          uint64_t v16 = *(void *)(a2 + 8);
          uint64_t v17 = *(unsigned int *)(a2 + 20);
          if (v16 == *(void *)a2)
          {
            if (v17)
            {
              unsigned int v18 = 0;
              uint64_t v19 = 8 * v17;
              uint64_t v20 = *(void **)(a2 + 8);
              while (*v20 != v15)
              {
                if (*v20 == -2) {
                  unsigned int v18 = v20;
                }
                ++v20;
                v19 -= 8;
                if (!v19)
                {
                  if (!v18) {
                    goto LABEL_23;
                  }
                  *unsigned int v18 = v15;
                  --*(_DWORD *)(a2 + 24);
                  goto LABEL_47;
                }
              }
              goto LABEL_48;
            }
LABEL_23:
            unsigned int v21 = *(_DWORD *)(a2 + 16);
            if (v17 < v21)
            {
              *(_DWORD *)(a2 + 20) = v17 + 1;
              *(void *)(v16 + 8 * v17) = v15;
              goto LABEL_47;
            }
          }
          else
          {
            unsigned int v21 = *(_DWORD *)(a2 + 16);
          }
          if (3 * v21 <= 4 * ((int)v17 - *(_DWORD *)(a2 + 24)))
          {
            if (v21 >= 0x40) {
              v21 *= 2;
            }
            else {
              unsigned int v21 = 128;
            }
          }
          else if (v21 - v17 >= v21 >> 3)
          {
            goto LABEL_28;
          }
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a2, v21);
          unsigned int v21 = *(_DWORD *)(a2 + 16);
          uint64_t v16 = *(void *)(a2 + 8);
LABEL_28:
          unsigned int v22 = v21 - 1;
          unsigned int v23 = (v21 - 1) & ((v15 >> 4) ^ (v15 >> 9));
          int v24 = (void *)(v16 + 8 * v23);
          uint64_t v25 = *v24;
          if (*v24 == -1)
          {
            uint64_t v26 = 0;
LABEL_40:
            if (v26) {
              unsigned int v30 = v26;
            }
            else {
              unsigned int v30 = v24;
            }
            if (*v30 != v15)
            {
              if (*v30 == -2) {
                --*(_DWORD *)(a2 + 24);
              }
              else {
                ++*(_DWORD *)(a2 + 20);
              }
              *unsigned int v30 = v15;
LABEL_47:
              uint64_t result = sub_1CCD89848(v15, a2, v13);
              if (!result) {
                return result;
              }
            }
          }
          else
          {
            uint64_t v26 = 0;
            int v27 = 1;
            while (v25 != v15)
            {
              if (v26) {
                BOOL v28 = 0;
              }
              else {
                BOOL v28 = v25 == -2;
              }
              if (v28) {
                uint64_t v26 = v24;
              }
              unsigned int v29 = v23 + v27++;
              unsigned int v23 = v29 & v22;
              int v24 = (void *)(v16 + 8 * (v29 & v22));
              uint64_t v25 = *v24;
              if (*v24 == -1) {
                goto LABEL_40;
              }
            }
          }
LABEL_48:
          v12 += 4;
          uint64_t result = 1;
          if (v12 == v14) {
            return result;
          }
        }
      }
    }
    return 1;
  }
  return result;
}

uint64_t sub_1CCD89B78(uint64_t a1, unsigned int *a2, unsigned int *a3, unint64_t *a4)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  if (v4 >= *(_DWORD *)(a1 + 12)) {
    return sub_1CD76B9F4(a1, a2, a3, a4);
  }
  uint64_t v5 = *(void *)a1;
  uint64_t v6 = *(void *)a1 + 16 * v4;
  unsigned int v7 = *a3;
  unint64_t v8 = *a4;
  *(_DWORD *)uint64_t v6 = *a2;
  *(_DWORD *)(v6 + 4) = v7;
  *(void *)(v6 + 8) = v8;
  unsigned int v9 = v4 + 1;
  *(_DWORD *)(a1 + 8) = v9;
  return v5 + 16 * v9 - 16;
}

_DWORD *sub_1CCD89BB8(_DWORD *a1)
{
  if (*((void *)a1 + 1))
  {
    unsigned int v1 = a1[4];
    if (v1 > 4 * a1[2] && v1 >= 0x41)
    {
      return sub_1CD76BA78(a1);
    }
    else
    {
      if (v1)
      {
        uint64_t v2 = *(void **)a1;
        uint64_t v3 = *(void *)a1 + 40 * v1;
        do
        {
          uint64_t v4 = v2[1];
          if (*v2 != -4096 || v4 != -4096)
          {
            if (*v2 != -8192 || v4 != -8192)
            {
              uint64_t v5 = v2[4];
              if (v5 != -8192 && v5 != -4096 && v5 != 0)
              {
                unint64_t v7 = v2[2] & 0xFFFFFFFFFFFFFFF8;
                *(void *)unint64_t v7 = v2[3];
                unint64_t v8 = (unint64_t *)v2[3];
                if (v8)
                {
                  unint64_t *v8 = *v8 & 7 | v7;
                }
                else
                {
                  uint64_t v9 = v2[4];
                  int v10 = ***(int32x2_t ****)v9;
                  unint64_t v11 = (unint64_t)v10[303];
                  if (v11 <= v7)
                  {
                    uint64_t v12 = v10[305].u32[0];
                    if (v11 + 16 * v12 > v7)
                    {
                      unsigned int v13 = v12 - 1;
                      LODWORD(v14) = v13 & ((v9 >> 4) ^ (v9 >> 9));
                      uint64_t v15 = (uint64_t *)(v11 + 16 * v14);
                      uint64_t v16 = *v15;
                      if (v9 == *v15)
                      {
LABEL_25:
                        *uint64_t v15 = -8192;
                        v10[304] = vadd_s32(v10[304], (int32x2_t)0x1FFFFFFFFLL);
                        uint64_t v9 = v2[4];
                      }
                      else
                      {
                        int v17 = 1;
                        while (v16 != -4096)
                        {
                          int v18 = v14 + v17++;
                          uint64_t v14 = v18 & v13;
                          uint64_t v16 = *(void *)(v11 + 16 * v14);
                          if (v9 == v16)
                          {
                            uint64_t v15 = (uint64_t *)(v11 + 16 * v14);
                            goto LABEL_25;
                          }
                        }
                      }
                      *(unsigned char *)(v9 + 17) &= ~1u;
                    }
                  }
                }
              }
            }
            void *v2 = -4096;
            v2[1] = -4096;
          }
          v2 += 5;
        }
        while (v2 != (void *)v3);
      }
      *((void *)a1 + 1) = 0;
    }
  }
  return a1;
}

void sub_1CCD89D20()
{
}

void sub_1CCD89D60(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD89D98(llvm::PassRegistry *a1, llvm *a2)
{
  uint64_t v3 = (uint64_t)a2 + 112;
  v6[0] = &unk_1F2617E40;
  v6[1] = (char *)a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v6);
  sub_1CB843600((uint64_t)a2, v3, (uint64_t)&llvm::MemorySSAWrapperPass::ID);

  llvm::getLoopAnalysisUsage(a2, v5);
}

uint64_t sub_1CCD89E18(llvm::LoopPass *a1, llvm::Loop *a2)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  if ((llvm::LoopPass::skipLoop(a1, a2) & 1) == 0)
  {
    uint64_t v4 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1];
    if (v5 == v6)
    {
LABEL_6:
      uint64_t v7 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v5 != &llvm::LoopInfoWrapperPass::ID)
      {
        v5 += 16;
        if (v5 == v6) {
          goto LABEL_6;
        }
      }
      uint64_t v7 = *(void *)(v5 + 8);
    }
    uint64_t v8 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::LoopInfoWrapperPass::ID);
    uint64_t v9 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v10 = *v9;
    uint64_t v11 = v9[1];
    if (v10 == v11)
    {
LABEL_11:
      uint64_t v12 = 0;
    }
    else
    {
      while (*(char **)v10 != llvm::ScalarEvolutionWrapperPass::ID)
      {
        v10 += 16;
        if (v10 == v11) {
          goto LABEL_11;
        }
      }
      uint64_t v12 = *(void *)(v10 + 8);
    }
    uint64_t v13 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v12 + 96))(v12, llvm::ScalarEvolutionWrapperPass::ID);
    uint64_t v14 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v15 = *v14;
    uint64_t v16 = v14[1];
    if (v15 == v16)
    {
LABEL_16:
      uint64_t v17 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v15 != &llvm::DominatorTreeWrapperPass::ID)
      {
        v15 += 16;
        if (v15 == v16) {
          goto LABEL_16;
        }
      }
      uint64_t v17 = *(void *)(v15 + 8);
    }
    uint64_t v18 = *(void *)(v13 + 32);
    uint64_t v19 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v17 + 96))(v17, &llvm::DominatorTreeWrapperPass::ID);
    uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*((void *)a1 + 1) + 24), llvm::TargetLibraryInfoWrapperPass::ID, 1);
    if (AnalysisPass)
    {
      uint64_t v21 = (*(uint64_t (**)(uint64_t, char *))(*(void *)AnalysisPass + 96))(AnalysisPass, llvm::TargetLibraryInfoWrapperPass::ID);
      if (v21)
      {
        uint64_t v22 = v21 + 32;
        if (!*(unsigned char *)(v21 + 232))
        {
          uint64_t v33 = *(void *)(*(void *)(**((void **)a2 + 4) + 56) + 40) + 216;
          __int16 v36 = 260;
          v35[0] = v33;
          llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v35);
          uint64_t v46 = 0;
          uint64_t v47 = 0;
          int v48 = 0;
          long long v49 = 0u;
          long long v50 = 0u;
          long long v51 = 0u;
          *(void *)&long long v34 = -1;
          *((void *)&v34 + 1) = -1;
          *(_OWORD *)__src = v34;
          long long v40 = v34;
          long long v41 = v34;
          long long v42 = v34;
          long long v43 = v34;
          long long v44 = v34;
          *(_OWORD *)uint64_t v45 = v34;
          *(void *)&v45[13] = -1;
          sub_1CC153974((uint64_t)__src, (int *)__p);
          sub_1CD4D04B8(v22, (uint64_t)__src);
          sub_1CD4CFA4C((uint64_t *)__src);
          if (v38 < 0) {
            operator delete(__p[0]);
          }
        }
        sub_1CC1569E8(__src, v22);
      }
    }
    uint64_t v23 = v8 + 32;
    uint64_t v24 = v19 + 32;
    uint64_t v25 = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*((void *)a1 + 1) + 24), llvm::TargetTransformInfoWrapperPass::ID, 1);
    if (v25
      && (uint64_t v26 = (llvm::TargetTransformInfoWrapperPass *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v25 + 96))(v25, llvm::TargetTransformInfoWrapperPass::ID)) != 0)
    {
      TTI = llvm::TargetTransformInfoWrapperPass::getTTI(v26, *(const Function **)(**((void **)a2 + 4) + 56));
    }
    else
    {
      TTI = 0;
    }
    uint64_t v28 = *(void *)(*(void *)(**((void **)a2 + 4) + 56) + 40) + 272;
    uint64_t v29 = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*((void *)a1 + 1) + 24), &llvm::MemorySSAWrapperPass::ID, 1);
    if (v29
      && (uint64_t v30 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v29 + 96))(v29, &llvm::MemorySSAWrapperPass::ID)) != 0)
    {
      uint64_t v31 = *(void *)(v30 + 32);
    }
    else
    {
      uint64_t v31 = 0;
    }
    sub_1CCD7A580((uint64_t)__src, v23, v18, v24, v28, 0, (uint64_t)TTI, v31, byte_1EBD0B3B8);
    sub_1CCD7A6A0((int)__src, a2);
  }
  return 0;
}

void sub_1CCD8A430(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = a1;
    uint64_t v3 = a1 + 40 * a2;
    do
    {
      sub_1CD76BD6C(*(unsigned __int8 **)v2, *(void *)(v2 + 8), *(_DWORD *)(v2 + 16), *(void *)(v2 + 24), *(void *)(v2 + 32));
      v2 += 40;
    }
    while (v2 != v3);
  }
}

uint64_t sub_1CCD8A47C()
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  LODWORD(v1) = 1;
  v5.n128_u64[0] = (unint64_t)"Verify the ScalarEvolution result after running indvars. Has no effect in release b"
                                     "uilds. (Note: this adds additional SCEV queries potentially changing the analysis result)";
  v5.n128_u64[1] = 172;
  sub_1CD4C1500((uint64_t)&unk_1EBCF2910, "verify-indvars", &v1, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF2910, &dword_1CB82C000);
  int v4 = 1;
  int v2 = 1;
  uint64_t v3 = &v2;
  *(void *)&long long v1 = "Choose the strategy to replace exit value in IndVarSimplify";
  *((void *)&v1 + 1) = 59;
  v5.n128_u64[0] = (unint64_t)v6;
  v6[0] = "never";
  v6[1] = 5;
  int v7 = 0;
  uint64_t v8 = "never replace exit value";
  uint64_t v9 = 24;
  uint64_t v10 = "cheap";
  uint64_t v11 = 5;
  int v12 = 1;
  uint64_t v13 = "only replace exit value when the cost is cheap";
  uint64_t v14 = 46;
  uint64_t v15 = "noharduse";
  uint64_t v16 = 9;
  int v17 = 2;
  uint64_t v18 = "only replace exit values when loop def likely dead";
  uint64_t v19 = 50;
  uint64_t v20 = "always";
  uint64_t v21 = 6;
  int v22 = 3;
  uint64_t v23 = "always replace exit value whenever possible";
  uint64_t v24 = 43;
  v5.n128_u64[1] = 0x400000004;
  sub_1CD76BB30(&v4, &v3, &v1, (uint64_t)&v5);
  if ((void *)v5.n128_u64[0] != v6) {
    free((void *)v5.n128_u64[0]);
  }
  __cxa_atexit((void (*)(void *))sub_1CD76B438, &qword_1EBCF2C10, &dword_1CB82C000);
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"Use post increment control-dependent ranges in IndVarSimplify";
  v5.n128_u64[1] = 61;
  LOBYTE(v4) = 1;
  *(void *)&long long v1 = &v4;
  sub_1CD413E90((llvm::cl::Option *)&unk_1EBCF29D0, "indvars-post-increment-ranges", &v3, &v5, (unsigned char **)&v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF29D0, &dword_1CB82C000);
  LODWORD(v3) = 1;
  LOBYTE(v4) = 0;
  *(void *)&long long v1 = &v4;
  v5.n128_u64[0] = (unint64_t)"Disable Linear Function Test Replace optimization";
  v5.n128_u64[1] = 49;
  sub_1CC025F34((llvm::cl::Option *)&unk_1EBCF2A90, "disable-lftr", &v3, (unsigned char **)&v1, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF2A90, &dword_1CB82C000);
  LODWORD(v3) = 1;
  LOBYTE(v4) = 1;
  *(void *)&long long v1 = &v4;
  v5.n128_u64[0] = (unint64_t)"Predicate conditions in read only loops";
  v5.n128_u64[1] = 39;
  sub_1CC025F34((llvm::cl::Option *)&unk_1EBCF2B50, "indvars-predicate-loops", &v3, (unsigned char **)&v1, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF2B50, &dword_1CB82C000);
  LODWORD(v3) = 1;
  LOBYTE(v4) = 1;
  *(void *)&long long v1 = &v4;
  v5.n128_u64[0] = (unint64_t)"Allow widening of indvars to eliminate s/zext";
  v5.n128_u64[1] = 45;
  sub_1CC025F34((llvm::cl::Option *)&unk_1EBD0B338, "indvars-widen-indvars", &v3, (unsigned char **)&v1, &v5);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBD0B338, &dword_1CB82C000);
}

void sub_1CCD8A798(uint64_t a1)
{
}

void llvm::createInferAddressSpacesPass(llvm *this)
{
}

_DWORD *llvm::InferAddressSpacesPass::InferAddressSpacesPass(_DWORD *this)
{
  *this = -1;
  return this;
}

{
  *this = -1;
  return this;
}

_DWORD *llvm::InferAddressSpacesPass::InferAddressSpacesPass(_DWORD *this, int a2)
{
  *this = a2;
  return this;
}

{
  *this = a2;
  return this;
}

uint64_t sub_1CCD8A8C0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  v741[1] = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 24) = *(void *)(a2 + 40) + 272;
  if (byte_1EBCF2EE8)
  {
    *(_DWORD *)(a1 + 32) = 0;
  }
  else if (*(_DWORD *)(a1 + 32) == -1)
  {
    int v4 = (*(uint64_t (**)(void))(***(void ***)(a1 + 16) + 120))(**(void **)(a1 + 16));
    *(_DWORD *)(v3 + 32) = v4;
    if (v4 == -1) {
      return 0;
    }
  }
  p_uint64_t j = &v720;
  uint64_t v719 = 0x400000000;
  uint64_t v7 = a2 + 72;
  uint64_t v725 = 0;
  v724 = 0;
  LODWORD(v726) = 0;
  for (uint64_t i = *(void *)(a2 + 80); ; uint64_t i = *(void *)(i + 8))
  {
    if (i == v7)
    {
      uint64_t j = 0;
      v703 = 0;
      unint64_t v704 = 0;
      goto LABEL_130;
    }
    uint64_t v9 = i - 24;
    if (!i) {
      uint64_t v9 = 0;
    }
    uint64_t v10 = *(void *)(v9 + 48);
    if (v10 != v9 + 40) {
      break;
    }
  }
  while (1)
  {
    uint64_t v11 = v10 - 24;
    if (v10) {
      uint64_t v12 = v10 - 24;
    }
    else {
      uint64_t v12 = 0;
    }
    int v13 = *(unsigned __int8 *)(v12 + 16);
    if (v13 == 62) {
      uint64_t v14 = (_DWORD *)v12;
    }
    else {
      uint64_t v14 = 0;
    }
    if (v10 && v13 == 62)
    {
      if ((*(_DWORD *)(*(void *)v14 + 8) & 0xFE) == 0x12) {
        goto LABEL_31;
      }
      uint64_t v15 = (unsigned char **)&v14[-8 * (v14[5] & 0x7FFFFFF)];
LABEL_24:
      uint64_t v16 = *v15;
LABEL_30:
      sub_1CCD8E96C(v3, v16, (uint64_t)&p_j, (uint64_t)&v724);
      goto LABEL_31;
    }
    if (v10 && v13 == 60 || v10 && v13 == 61) {
      goto LABEL_29;
    }
    if (v10 && v13 == 65)
    {
      uint64_t v16 = *(unsigned char **)(v12 - 64);
      goto LABEL_30;
    }
    if (v10 && v13 == 64)
    {
      uint64_t v16 = *(unsigned char **)(v12 - 96);
      goto LABEL_30;
    }
    int v19 = sub_1CBFB3AB0(v12);
    if (v10 && v19)
    {
      sub_1CCD8E96C(v3, *(unsigned char **)(v12 - 32 * (*(_DWORD *)(v12 + 20) & 0x7FFFFFF)), (uint64_t)&p_j, (uint64_t)&v724);
      unsigned int v20 = *(_DWORD *)(*(void *)(v12 - 32) + 36) - 194;
      if (v20 <= 3 && v20 != 1)
      {
        uint64_t v16 = *(unsigned char **)(v12 - 32 * (*(_DWORD *)(v12 + 20) & 0x7FFFFFF) + 32);
        goto LABEL_30;
      }
    }
    else
    {
      int v22 = *(unsigned __int8 *)(v12 + 16);
      if (v22 == 84)
      {
        uint64_t v23 = *(void *)(v12 - 32);
        if (v23
          && !*(unsigned char *)(v23 + 16)
          && *(void *)(v23 + 24) == *(void *)(v12 + 72)
          && (*(unsigned char *)(v23 + 33) & 0x20) != 0)
        {
          if ((*(_DWORD *)(*(void *)(v10 - 56) + 36) | 0x10) == 0xFC)
          {
            uint64_t v15 = (unsigned char **)(v11 - 32 * (*(_DWORD *)(v10 - 4) & 0x7FFFFFF));
            goto LABEL_24;
          }
          v713 = &v715;
          uint64_t v714 = 0x200000000;
          int v28 = (*(uint64_t (**)(void, void **))(***(void ***)(v3 + 16) + 128))(**(void **)(v3 + 16), &v713);
          uint64_t v29 = (unsigned int *)v713;
          if (v28 && v714)
          {
            uint64_t v30 = 4 * v714;
            do
            {
              unsigned int v31 = *v29++;
              sub_1CCD8E96C(v3, *(unsigned char **)(v11 - 32 * (*(_DWORD *)(v10 - 4) & 0x7FFFFFF) + 32 * v31), (uint64_t)&p_j, (uint64_t)&v724);
              v30 -= 4;
            }
            while (v30);
            uint64_t v29 = (unsigned int *)v713;
          }
          if (v29 != (unsigned int *)&v715) {
            free(v29);
          }
        }
      }
      else if (v10 && v22 == 81)
      {
        uint64_t v24 = *(unsigned char **)(v12 - 64);
        if (*(unsigned char *)(*(void *)v24 + 8) == 15)
        {
          sub_1CCD8E96C(v3, v24, (uint64_t)&p_j, (uint64_t)&v724);
LABEL_29:
          uint64_t v16 = *(unsigned char **)(v12 - 32);
          goto LABEL_30;
        }
      }
      else
      {
        uint64_t v25 = v22 == 78 ? v12 : 0;
        if (v10 && v22 == 78)
        {
          if ((*(_DWORD *)(*(void *)v25 + 8) & 0xFE) != 0x12)
          {
            uint64_t v16 = *(unsigned char **)(v25 - 32);
            goto LABEL_30;
          }
        }
        else
        {
          if (v22 != 76) {
            uint64_t v12 = 0;
          }
          if (v10
            && v22 == 76
            && sub_1CCD8E670(v12, *(llvm::DataLayout **)(v3 + 24), *(void *)(v3 + 16)))
          {
            uint64_t v26 = *(void *)(v12 - 32);
            int v27 = *(_DWORD *)(v26 + 20);
            if ((v27 & 0x40000000) != 0) {
              uint64_t v15 = *(unsigned char ***)(v26 - 8);
            }
            else {
              uint64_t v15 = (unsigned char **)(v26 - 32 * (v27 & 0x7FFFFFF));
            }
            goto LABEL_24;
          }
        }
      }
    }
LABEL_31:
    uint64_t v10 = *(void *)(v10 + 8);
    uint64_t v17 = i - 24;
    if (!i) {
      uint64_t v17 = 0;
    }
    if (v10 == v17 + 40) {
      break;
    }
LABEL_38:
    if (i == v7) {
      goto LABEL_86;
    }
  }
  while (1)
  {
    uint64_t i = *(void *)(i + 8);
    if (i == v7) {
      break;
    }
    uint64_t v18 = i - 24;
    if (!i) {
      uint64_t v18 = 0;
    }
    uint64_t v10 = *(void *)(v18 + 48);
    if (v10 != v18 + 40) {
      goto LABEL_38;
    }
  }
LABEL_86:
  unsigned int v32 = v719;
  v703 = 0;
  unint64_t v704 = 0;
  for (uint64_t j = 0; v32; LODWORD(v719) = v32)
  {
    while (1)
    {
      uint64_t v33 = (char *)p_j + 8 * v32;
      uint64_t v34 = *((void *)v33 - 1);
      unint64_t v35 = v34 & 0xFFFFFFFFFFFFFFF8;
      if ((v34 & 4) != 0) {
        break;
      }
      *((void *)v33 - 1) = v34 | 4;
      if ((*(unsigned int (**)(void, unint64_t))(***(void ***)(v3 + 16) + 152))(**(void **)(v3 + 16), v34 & 0xFFFFFFFFFFFFFFF8) == -1)
      {
        sub_1CCD8E820(&v713, v35);
        __int16 v36 = v713;
        if (v714)
        {
          uint64_t v37 = 8 * v714;
          do
          {
            char v38 = (unsigned char *)*v36++;
            sub_1CCD8E96C(v3, v38, (uint64_t)&p_j, (uint64_t)&v724);
            v37 -= 8;
          }
          while (v37);
          __int16 v36 = v713;
        }
        if (v36 != &v715) {
          free(v36);
        }
      }
      unsigned int v32 = v719;
      if (!v719) {
        goto LABEL_130;
      }
    }
    unsigned int v39 = *(_DWORD *)(*(void *)v35 + 8);
    if ((v39 & 0xFE) == 0x12) {
      unsigned int v39 = *(_DWORD *)(**(void **)(*(void *)v35 + 16) + 8);
    }
    if (*(_DWORD *)(v3 + 32) == v39 >> 8)
    {
      v713 = (void *)6;
      uint64_t v714 = 0;
      v715 = (void ***)(v34 & 0xFFFFFFFFFFFFFFF8);
      if (v35 != -8192 && v35 != -4096 && v35 != 0) {
        llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v713);
      }
      long long v41 = v703;
      if ((unint64_t)v703 >= v704)
      {
        uint64_t v45 = (unint64_t *)sub_1CC95E138(&j, &v713);
      }
      else
      {
        unint64_t *v703 = 6;
        v41[1] = 0;
        long long v42 = v715;
        v41[2] = (unint64_t)v715;
        if (v42 != (void ***)-8192 && v42 != (void ***)-4096)
        {
          if (v42)
          {
            unint64_t v43 = (unint64_t)v713 & 0xFFFFFFFFFFFFFFF8;
            v41[1] = *(void *)((unint64_t)v713 & 0xFFFFFFFFFFFFFFF8);
            *(void *)unint64_t v43 = v41;
            *long long v41 = v43 | 6;
            long long v44 = (unint64_t *)v41[1];
            if (v44) {
              *long long v44 = *v44 & 7 | (unint64_t)(v41 + 1);
            }
          }
        }
        uint64_t v45 = v41 + 3;
      }
      v703 = v45;
      if (v715 != (void ***)-8192 && v715 != (void ***)-4096 && v715)
      {
        unint64_t v46 = (unint64_t)v713 & 0xFFFFFFFFFFFFFFF8;
        *(void *)((unint64_t)v713 & 0xFFFFFFFFFFFFFFF8) = v714;
        if (v714)
        {
          *(void *)uint64_t v714 = *(void *)v714 & 7 | v46;
        }
        else
        {
          uint64_t v47 = v715;
          int v48 = (int32x2_t *)***v715;
          unint64_t v49 = (unint64_t)v48[303];
          if (v49 <= v46)
          {
            uint64_t v50 = v48[305].u32[0];
            if (v49 + 16 * v50 > v46)
            {
              unsigned int v51 = v50 - 1;
              LODWORD(v52) = v51 & ((v715 >> 4) ^ (v715 >> 9));
              unsigned int v53 = (void *)(v49 + 16 * v52);
              unint64_t v54 = (void ***)*v53;
              if (v715 == (void ***)*v53)
              {
LABEL_125:
                void *v53 = -8192;
                v48[304] = vadd_s32(v48[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v47 = v715;
              }
              else
              {
                int v55 = 1;
                while (v54 != (void ***)-4096)
                {
                  int v56 = v52 + v55++;
                  uint64_t v52 = v56 & v51;
                  unint64_t v54 = *(void ****)(v49 + 16 * v52);
                  if (v715 == v54)
                  {
                    unsigned int v53 = (void *)(v49 + 16 * v52);
                    goto LABEL_125;
                  }
                }
              }
              *((unsigned char *)v47 + 17) &= ~1u;
            }
          }
        }
      }
      unsigned int v32 = v719;
    }
    --v32;
  }
LABEL_130:
  MEMORY[0x1D25D9CD0](v724, 8);
  if (p_j != &v720) {
    free(p_j);
  }
  v700[0] = 0;
  v700[1] = 0;
  unsigned int v701 = 0;
  v698[0] = 0;
  v698[1] = 0;
  int v699 = 0;
  uint64_t v57 = j;
  uint64_t v58 = v703;
  uint64_t v719 = 0;
  p_uint64_t j = 0;
  LODWORD(v720) = 0;
  uint64_t v723 = 0;
  __p = 0;
  v722 = 0;
  sub_1CD76C258((uint64_t)&p_j, j, (uint64_t)v703);
  if (v58 != (unint64_t *)v57)
  {
    while (2)
    {
      unsigned int v59 = *(void **)(v57 + 16);
      v713 = v59;
      if (v701)
      {
        unsigned int v60 = ((v59 >> 4) ^ (v59 >> 9)) & (v701 - 1);
        unsigned int v61 = (void *)(v700[0] + 16 * v60);
        uint64_t v62 = (void *)*v61;
        if (v59 != (void *)*v61)
        {
          unsigned int v63 = 0;
          int v64 = 1;
          while (v62 != (void *)-4096)
          {
            if (v63) {
              BOOL v65 = 0;
            }
            else {
              BOOL v65 = v62 == (void *)-8192;
            }
            if (v65) {
              unsigned int v63 = v61;
            }
            unsigned int v66 = v60 + v64++;
            unsigned int v60 = v66 & (v701 - 1);
            unsigned int v61 = (void *)(v700[0] + 16 * v60);
            uint64_t v62 = (void *)*v61;
            if (v59 == (void *)*v61) {
              goto LABEL_148;
            }
          }
          if (v63) {
            uint64_t v67 = v63;
          }
          else {
            uint64_t v67 = v61;
          }
LABEL_147:
          unsigned int v61 = sub_1CC21DC7C((uint64_t)v700, (uint64_t)&v713, (uint64_t *)&v713, v67);
          void *v61 = v713;
          *((_DWORD *)v61 + 2) = 0;
        }
LABEL_148:
        *((_DWORD *)v61 + 2) = -1;
        v57 += 24;
        if ((unint64_t *)v57 == v58) {
          goto LABEL_151;
        }
        continue;
      }
      break;
    }
    uint64_t v67 = 0;
    goto LABEL_147;
  }
LABEL_151:
  uint64_t v68 = __p;
  uint64_t v69 = v722;
  uint64_t v691 = v3;
  if (__p == v722) {
    goto LABEL_310;
  }
  unsigned int v70 = (void (*)(uint64_t, uint64_t))nullsub_608;
  unint64_t v71 = (uint64_t *)&v715;
  while (2)
  {
    uint64_t v72 = *(v69 - 1);
    sub_1CD58C650((uint64_t)&p_j);
    unsigned int v73 = *(unsigned __int8 *)(v72 + 16);
    BOOL v580 = v73 >= 0x1C;
    unsigned int v74 = v73 - 28;
    if (!v580) {
      unsigned int v74 = *(unsigned __int16 *)(v72 + 18);
    }
    if (v74 == 57)
    {
      int v75 = *(_DWORD *)(v72 + 20);
      if ((v75 & 0x40000000) != 0) {
        uint64_t v76 = *(void *)(v72 - 8);
      }
      else {
        uint64_t v76 = v72 - 32 * (v75 & 0x7FFFFFF);
      }
      unsigned int v108 = *(unsigned __int8 **)(v76 + 32);
      uint64_t v109 = v700[0];
      if (v701)
      {
        uint64_t v110 = ((v108 >> 4) ^ (v108 >> 9)) & (v701 - 1);
        unsigned int v111 = *(unsigned __int8 **)(v700[0] + 16 * v110);
        if (v108 == v111)
        {
LABEL_214:
          uint64_t v109 = v700[0] + 16 * v701;
          if (v110 == v701) {
            goto LABEL_215;
          }
          int v113 = *(_DWORD *)(v700[0] + 16 * v110 + 8);
LABEL_219:
          unint64_t v114 = *(unsigned __int8 **)(v76 + 64);
          if (v701)
          {
            LODWORD(v115) = ((v114 >> 4) ^ (v114 >> 9)) & (v701 - 1);
            uint64_t v116 = v700[0] + 16 * v115;
            unsigned int v117 = *(unsigned __int8 **)v116;
            if (v114 == *(unsigned __int8 **)v116)
            {
LABEL_221:
              if (v116 != v109)
              {
                int v77 = *(_DWORD *)(v116 + 8);
                goto LABEL_239;
              }
            }
            else
            {
              int v120 = v71;
              unsigned int v121 = v70;
              int v122 = 1;
              while (1)
              {
                uint64_t v3 = v691;
                unsigned int v70 = v121;
                unint64_t v71 = v120;
                if (v117 == (unsigned __int8 *)-4096) {
                  break;
                }
                int v123 = v115 + v122++;
                uint64_t v115 = v123 & (v701 - 1);
                unsigned int v117 = *(unsigned __int8 **)(v700[0] + 16 * v115);
                if (v114 == v117)
                {
                  uint64_t v116 = v700[0] + 16 * v115;
                  uint64_t v3 = v691;
                  unsigned int v70 = v121;
                  unint64_t v71 = v120;
                  goto LABEL_221;
                }
              }
            }
          }
          unsigned int v124 = *(_DWORD *)(*(void *)v114 + 8);
          if ((v124 & 0xFE) == 0x12) {
            unsigned int v124 = *(_DWORD *)(**(void **)(*(void *)v114 + 16) + 8);
          }
          int v77 = v124 >> 8;
LABEL_239:
          if (v108[16] >= 0x15u) {
            BOOL v125 = 0;
          }
          else {
            BOOL v125 = (uint64_t *)v108;
          }
          if (v114[16] >= 0x15u) {
            unsigned int v126 = 0;
          }
          else {
            unsigned int v126 = (uint64_t *)v114;
          }
          if (v126) {
            BOOL v127 = v113 == -1;
          }
          else {
            BOOL v127 = 0;
          }
          if (!v127 && (!v125 || v77 != -1))
          {
            if (!v125 || (sub_1CCD8EC78(v3, v125, v77) & 1) == 0)
            {
              if (v126 && (sub_1CCD8EC78(v3, v126, v113) & 1) != 0)
              {
                int v77 = v113;
              }
              else
              {
                BOOL v129 = v113 == -1;
                int v130 = *(_DWORD *)(v3 + 32);
                if (v113 == -1) {
                  int v131 = v77;
                }
                else {
                  int v131 = v113;
                }
                BOOL v132 = v130 == v113 || v130 == v77;
                int v133 = v132;
                if (v132) {
                  BOOL v129 = 1;
                }
                if (v77 == -1) {
                  BOOL v129 = 1;
                }
                if (v133) {
                  int v131 = *(_DWORD *)(v3 + 32);
                }
                if (v113 == v77) {
                  int v130 = v113;
                }
                if (v129) {
                  int v77 = v131;
                }
                else {
                  int v77 = v130;
                }
              }
            }
            goto LABEL_279;
          }
          goto LABEL_302;
        }
        int v118 = 1;
        while (v111 != (unsigned __int8 *)-4096)
        {
          int v119 = v110 + v118++;
          uint64_t v110 = v119 & (v701 - 1);
          unsigned int v111 = *(unsigned __int8 **)(v700[0] + 16 * v110);
          uint64_t v3 = v691;
          if (v108 == v111) {
            goto LABEL_214;
          }
        }
        uint64_t v109 = v700[0] + 16 * v701;
        uint64_t v3 = v691;
      }
LABEL_215:
      unsigned int v112 = *(_DWORD *)(*(void *)v108 + 8);
      if ((v112 & 0xFE) == 0x12) {
        unsigned int v112 = *(_DWORD *)(**(void **)(*(void *)v108 + 16) + 8);
      }
      int v113 = v112 >> 8;
      goto LABEL_219;
    }
    int v77 = (*(uint64_t (**)(void, uint64_t))(***(void ***)(v3 + 16) + 152))(**(void **)(v3 + 16), v72);
    if (v77 != -1) {
      goto LABEL_279;
    }
    sub_1CCD8E820(&v713, v72);
    uint64_t v78 = (uint64_t *)v713;
    if (!v714)
    {
      int v77 = -1;
      goto LABEL_226;
    }
    v695 = v71;
    v697 = (llvm::ValueHandleBase *)v70;
    unsigned int v79 = (uint64_t *)((char *)v713 + 8 * v714);
    int v77 = -1;
    while (2)
    {
      uint64_t v80 = *v78;
      if (!v701)
      {
LABEL_164:
        unsigned int v83 = *(_DWORD *)(*(void *)v80 + 8);
        if ((v83 & 0xFE) == 0x12) {
          unsigned int v83 = *(_DWORD *)(**(void **)(*(void *)v80 + 16) + 8);
        }
        int v84 = v83 >> 8;
        if (v83 >> 8 != *(_DWORD *)(v3 + 32)) {
          goto LABEL_178;
        }
        unsigned int v85 = *(unsigned __int8 *)(v72 + 16);
        uint64_t v86 = v85 >= 0x1C ? (const llvm::Instruction *)v72 : 0;
        if (v85 < 0x1C) {
          goto LABEL_178;
        }
        uint64_t v88 = llvm::Value::stripInBoundsOffsets(*v78, v70, (uint64_t)&v724);
        uint64_t v89 = *(llvm::AssumptionCache **)v3;
        if (!*(unsigned char *)(*(void *)v3 + 184)) {
          llvm::AssumptionCache::scanFunction(*(llvm::AssumptionCache **)v3);
        }
        uint64_t v90 = *((void *)v89 + 20);
        unsigned int v91 = *((_DWORD *)v89 + 44);
        if (v91)
        {
          unsigned int v96 = v91 - 1;
          unsigned int v97 = (v91 - 1) & ((v88 >> 4) ^ (v88 >> 9));
          uint64_t v92 = v90 + 88 * v97;
          uint64_t v98 = *(void *)(v92 + 24);
          if (v98 == v88) {
            goto LABEL_175;
          }
          int v99 = 1;
          while (v98 != -4096)
          {
            unsigned int v100 = v97 + v99++;
            unsigned int v97 = v100 & v96;
            uint64_t v92 = v90 + 88 * (v100 & v96);
            uint64_t v98 = *(void *)(v92 + 24);
            if (v98 == v88) {
              goto LABEL_175;
            }
          }
        }
        uint64_t v92 = v90 + 88 * v91;
LABEL_175:
        if (v92 == v90 + 88 * v91 || (uint64_t v103 = *(unsigned int *)(v92 + 48), !v103))
        {
LABEL_176:
          unsigned int v70 = (void (*)(uint64_t, uint64_t))v697;
        }
        else
        {
          uint64_t v104 = 32 * v103;
          unint64_t v105 = (llvm **)(*(void *)(v92 + 40) + 16);
          while (1)
          {
            if (*v105)
            {
              v694 = *v105;
              if (llvm::isValidAssumeForContext(*v105, v86, *(const llvm::Instruction **)(v3 + 8), v87))
              {
                if ((*(uint64_t (**)(void, void))(***(void ***)(v3 + 16) + 160))(**(void **)(v3 + 16), *((void *)v694 - 4 * (*((_DWORD *)v694 + 5) & 0x7FFFFFF))))
                {
                  break;
                }
              }
            }
            v105 += 4;
            v104 -= 32;
            if (!v104) {
              goto LABEL_176;
            }
          }
          unsigned int v70 = (void (*)(uint64_t, uint64_t))v697;
          if (v106 != -1)
          {
            int v107 = v106;
            v724 = (void *)v72;
            uint64_t v725 = v80;
            *((_DWORD *)sub_1CD57EB4C((uint64_t)v698, (uint64_t *)&v724) + 4) = v106;
            int v84 = v107;
          }
        }
        goto LABEL_178;
      }
      uint64_t v81 = ((v80 >> 4) ^ (v80 >> 9)) & (v701 - 1);
      uint64_t v82 = *(void *)(v700[0] + 16 * v81);
      if (v80 != v82)
      {
        int v101 = 1;
        while (v82 != -4096)
        {
          int v102 = v81 + v101++;
          uint64_t v81 = v102 & (v701 - 1);
          uint64_t v82 = *(void *)(v700[0] + 16 * v81);
          if (v80 == v82) {
            goto LABEL_163;
          }
        }
        goto LABEL_164;
      }
LABEL_163:
      if (v81 == v701) {
        goto LABEL_164;
      }
      int v84 = *(_DWORD *)(v700[0] + 16 * v81 + 8);
LABEL_178:
      int v93 = *(_DWORD *)(v3 + 32);
      if (v93 != v77 && v93 != v84)
      {
        if (v77 == v84) {
          int v95 = v77;
        }
        else {
          int v95 = *(_DWORD *)(v3 + 32);
        }
        if (v84 == -1) {
          int v95 = v77;
        }
        if (v77 == -1) {
          int v77 = v84;
        }
        else {
          int v77 = v95;
        }
        if (v77 == v93) {
          goto LABEL_225;
        }
        if (++v78 == v79) {
          goto LABEL_225;
        }
        continue;
      }
      break;
    }
    int v77 = *(_DWORD *)(v3 + 32);
LABEL_225:
    uint64_t v78 = (uint64_t *)v713;
    unint64_t v71 = v695;
LABEL_226:
    if (v78 != v71) {
      free(v78);
    }
LABEL_279:
    if (v701)
    {
      uint64_t v134 = (v701 - 1) & ((v72 >> 4) ^ (v72 >> 9));
      uint64_t v135 = *(void *)(v700[0] + 16 * v134);
      if (v72 == v135)
      {
LABEL_281:
        int v136 = *(_DWORD *)(v700[0] + 16 * v134 + 8);
      }
      else
      {
        int v147 = 1;
        while (v135 != -4096)
        {
          int v148 = v134 + v147++;
          uint64_t v134 = v148 & (v701 - 1);
          uint64_t v135 = *(void *)(v700[0] + 16 * v134);
          uint64_t v3 = v691;
          if (v72 == v135) {
            goto LABEL_281;
          }
        }
        int v136 = 0;
        uint64_t v3 = v691;
      }
    }
    else
    {
      int v136 = 0;
    }
    if (v136 != v77)
    {
      v713 = (void *)v72;
      *((_DWORD *)sub_1CC220A0C((uint64_t)v700, (uint64_t *)&v713) + 2) = v77;
      uint64_t v137 = *(void *)(v72 + 8);
      if (v137)
      {
        while (2)
        {
          int v138 = *(void **)(v137 + 24);
          v713 = v138;
          if (v720)
          {
            unsigned int v139 = ((v138 >> 4) ^ (v138 >> 9)) & (v720 - 1);
            v140 = (void *)*((void *)p_j + v139);
            if (v138 == v140) {
              goto LABEL_287;
            }
            int v141 = 1;
            while (v140 != (void *)-4096)
            {
              unsigned int v142 = v139 + v141++;
              unsigned int v139 = v142 & (v720 - 1);
              v140 = (void *)*((void *)p_j + v139);
              if (v138 == v140) {
                goto LABEL_287;
              }
            }
          }
          if (v701)
          {
            uint64_t v143 = (v701 - 1) & ((v138 >> 4) ^ (v138 >> 9));
            v144 = *(void **)(v700[0] + 16 * v143);
            if (v138 == v144)
            {
LABEL_295:
              if (v143 != v701 && *(_DWORD *)(v700[0] + 16 * v143 + 8) != *(_DWORD *)(v3 + 32)) {
                sub_1CBF5F714(&p_j, &v713);
              }
            }
            else
            {
              int v145 = 1;
              while (v144 != (void *)-4096)
              {
                int v146 = v143 + v145++;
                uint64_t v143 = v146 & (v701 - 1);
                v144 = *(void **)(v700[0] + 16 * v143);
                if (v138 == v144) {
                  goto LABEL_295;
                }
              }
            }
          }
LABEL_287:
          uint64_t v137 = *(void *)(v137 + 8);
          if (!v137) {
            break;
          }
          continue;
        }
      }
    }
LABEL_302:
    uint64_t v68 = __p;
    uint64_t v69 = v722;
    if (__p != v722) {
      continue;
    }
    break;
  }
LABEL_310:
  if (v68)
  {
    v722 = v68;
    operator delete(v68);
  }
  MEMORY[0x1D25D9CD0](p_j, 8);
  uint64_t v150 = j;
  uint64_t v149 = v703;
  unsigned int v707 = 128;
  uint64_t v151 = (char *)operator new(0x2000uLL, (std::align_val_t)8uLL);
  v705 = v151;
  uint64_t v706 = 0;
  uint64_t v719 = 2;
  v720 = 0;
  __p = (void *)-4096;
  unint64_t v152 = (unint64_t)&p_j;
  p_uint64_t j = &unk_1F2615EC8;
  v722 = 0;
  if (v707)
  {
    unint64_t v153 = 0;
    unint64_t v154 = (unint64_t)v707 << 6;
    v155 = v151 + 16;
    do
    {
      uint64_t v156 = v719;
      v157 = __p;
      *(v155 - 1) = v719 & 6;
      void *v155 = 0;
      v155[1] = v157;
      if (v157 != (void *)-4096 && v157 != (void *)-8192 && v157 != 0)
      {
        void *v155 = *(void *)(v156 & 0xFFFFFFFFFFFFFFF8);
        *(void *)(v156 & 0xFFFFFFFFFFFFFFF8) = v155 - 1;
        *(v155 - 1) = v156 & 0xFFFFFFFFFFFFFFFELL;
        if (*v155) {
          *(void *)void *v155 = *(void *)*v155 & 7 | (unint64_t)(v151 + 16);
        }
        unint64_t v153 = v722;
        uint64_t v3 = v691;
      }
      *(v155 - 2) = &unk_1F2615EC8;
      v155[2] = v153;
      v155 += 8;
      v151 += 64;
      v154 -= 64;
    }
    while (v154);
    if (__p != (void *)-8192 && __p != (void *)-4096 && __p)
    {
LABEL_1060:
      unint64_t v661 = v719 & 0xFFFFFFFFFFFFFFF8;
      *(void *)(v719 & 0xFFFFFFFFFFFFFFF8) = v720;
      if (v720)
      {
        unint64_t *v720 = *v720 & 7 | v661;
      }
      else
      {
        v662 = __p;
        v663 = ***(int32x2_t ****)__p;
        unint64_t v664 = (unint64_t)v663[303];
        uint64_t v3 = v691;
        if (v664 > v661) {
          goto LABEL_327;
        }
        uint64_t v665 = v663[305].u32[0];
        if (v664 + 16 * v665 <= v661) {
          goto LABEL_327;
        }
        unsigned int v666 = v665 - 1;
        LODWORD(v667) = v666 & ((__p >> 4) ^ (__p >> 9));
        v668 = (void **)(v664 + 16 * v667);
        v669 = *v668;
        if (__p == *v668)
        {
LABEL_1068:
          *v668 = (void *)-8192;
          v663[304] = vadd_s32(v663[304], (int32x2_t)0x1FFFFFFFFLL);
          v662 = __p;
        }
        else
        {
          int v670 = 1;
          while (v669 != (void *)-4096)
          {
            int v671 = v667 + v670++;
            uint64_t v667 = v671 & v666;
            v669 = *(void **)(v664 + 16 * v667);
            if (__p == v669)
            {
              v668 = (void **)(v664 + 16 * v667);
              goto LABEL_1068;
            }
          }
        }
        v662[17] &= ~1u;
      }
      uint64_t v3 = v691;
    }
  }
LABEL_327:
  LOBYTE(v708[0]) = 0;
  char v709 = 0;
  unsigned int v159 = (void *)(v152 + 16);
  p_uint64_t j = v159;
  uint64_t v719 = 0x2000000000;
  if (v149 == (unint64_t *)v150)
  {
    uint64_t v5 = 0;
    goto LABEL_1056;
  }
  v674 = (char *)v159;
  uint64_t v149 = (unint64_t *)(v150 + 8 * (((uint64_t)v149 - v150) >> 3));
  uint64_t v689 = v150;
  v696 = v149;
  while (2)
  {
    uint64_t v160 = *(void *)(v150 + 16);
    if (!v701)
    {
LABEL_337:
      v163 = 0;
      goto LABEL_338;
    }
    uint64_t v161 = ((v160 >> 4) ^ (v160 >> 9)) & (v701 - 1);
    uint64_t v162 = *(void *)(v700[0] + 16 * v161);
    if (v160 != v162)
    {
      int v164 = 1;
      while (v162 != -4096)
      {
        int v165 = v161 + v164++;
        uint64_t v161 = v165 & (v701 - 1);
        uint64_t v162 = *(void *)(v700[0] + 16 * v161);
        if (v160 == v162) {
          goto LABEL_331;
        }
      }
      goto LABEL_337;
    }
LABEL_331:
    v163 = (llvm::Type *)*(unsigned int *)(v700[0] + 16 * v161 + 8);
    if (v163 == -1) {
      goto LABEL_476;
    }
LABEL_338:
    uint64_t v166 = *(void *)v160;
    unsigned int v167 = *(_DWORD *)(*(void *)v160 + 8);
    if ((v167 & 0xFE) == 0x12) {
      unsigned int v167 = *(_DWORD *)(**(void **)(v166 + 16) + 8);
    }
    if (v163 == v167 >> 8) {
      goto LABEL_476;
    }
    if (*(unsigned __int8 *)(v160 + 16) >= 0x1Cu)
    {
      __int16 v169 = *(llvm::PointerType **)(v166 + 24);
      if (v169) {
        unint64_t v170 = llvm::PointerType::get(v169, v163);
      }
      else {
        unint64_t v170 = llvm::PointerType::get(*(uint64_t ***)v166, v163);
      }
      uint64_t v171 = (llvm::Type *)v170;
      int v172 = *(unsigned __int8 *)(v160 + 16);
      if (v172 == 84)
      {
        uint64_t v175 = *(void *)(v160 - 32);
        if (v175
          && !*(unsigned char *)(v175 + 16)
          && *(void *)(v175 + 24) == *(void *)(v160 + 72)
          && (*(unsigned char *)(v175 + 33) & 0x20) != 0)
        {
          int v276 = *(_DWORD *)(v160 + 20);
          if ((v276 & 0x40000000) != 0) {
            v277 = *(unsigned __int8 ***)(v160 - 8);
          }
          else {
            v277 = (unsigned __int8 **)(v160 - 32 * (v276 & 0x7FFFFFF));
          }
          v280 = sub_1CCD8F540(v277, v163, (uint64_t *)&v705, (uint64_t)v698, (uint64_t)&p_j);
          int v168 = (llvm::Constant *)(*(uint64_t (**)(void, uint64_t, void, llvm::UndefValue *))(***(void ***)(v3 + 16) + 168))(**(void **)(v3 + 16), v160, *(void *)(v160 - 32 * (*(_DWORD *)(v160 + 20) & 0x7FFFFFF)), v280);
          if (!v168) {
            goto LABEL_476;
          }
          goto LABEL_448;
        }
      }
      else if (v172 == 78)
      {
        int v173 = *(_DWORD *)(v160 + 20);
        if ((v173 & 0x40000000) != 0) {
          v174 = *(llvm::Constant ***)(v160 - 8);
        }
        else {
          v174 = (llvm::Constant **)(v160 - 32 * (v173 & 0x7FFFFFF));
        }
        int v168 = *v174;
        if (*(void *)*v174 != v170)
        {
          v185 = operator new(0x60uLL);
          v185[13] = v185[13] & 0x38000000 | 1;
          v186 = (llvm::Constant *)(v185 + 8);
          *(void *)v185 = 0;
          *((void *)v185 + 1) = 0;
          *((void *)v185 + 2) = 0;
          *((void *)v185 + 3) = v185 + 8;
          LOWORD(v717) = 257;
          llvm::BitCastInst::BitCastInst((llvm::BitCastInst *)(v185 + 8), v168, v171, (const char **)&v713, 0);
          int v168 = v186;
        }
        goto LABEL_448;
      }
      uint64_t v176 = (*(uint64_t (**)(void, uint64_t))(***(void ***)(v3 + 16) + 152))(**(void **)(v3 + 16), v160);
      if (v176 != -1)
      {
        v178 = (llvm::Type *)v176;
        v179 = *(llvm::PointerType **)(*(void *)v160 + 24);
        if (v179) {
          unint64_t v180 = llvm::PointerType::get(v179, v178);
        }
        else {
          unint64_t v180 = llvm::PointerType::get(**(uint64_t ****)v160, v178);
        }
        v181 = (llvm::Type *)v180;
        v182 = operator new(0x60uLL);
        v182[13] = v182[13] & 0x38000000 | 1;
        int v168 = (llvm::Constant *)(v182 + 8);
        *(void *)v182 = 0;
        *((void *)v182 + 1) = 0;
        *((void *)v182 + 2) = 0;
        *((void *)v182 + 3) = v182 + 8;
        LOWORD(v717) = 257;
        llvm::AddrSpaceCastInst::AddrSpaceCastInst((llvm::AddrSpaceCastInst *)(v182 + 8), (llvm::Value *)v160, v181, (const char **)&v713, 0);
        sub_1CC5C6C08((void *)(*(void *)(v160 + 40) + 40), v160 + 24, v168);
        goto LABEL_448;
      }
      v713 = &v715;
      uint64_t v714 = 0x400000000;
      int v183 = *(_DWORD *)(v160 + 20);
      if ((v183 & 0x40000000) != 0)
      {
        v184 = *(unsigned __int8 ***)(v160 - 8);
        unint64_t v152 = v183 & 0x7FFFFFF;
        if ((*(_DWORD *)(v160 + 20) & 0x7FFFFFF) == 0) {
          goto LABEL_375;
        }
      }
      else
      {
        unint64_t v152 = v183 & 0x7FFFFFF;
        v184 = (unsigned __int8 **)(v160 - 32 * v152);
        if ((v183 & 0x7FFFFFF) == 0)
        {
LABEL_375:
          switch(*(unsigned char *)(v160 + 16))
          {
            case 'L':
              int v189 = *(_DWORD *)(v160 + 20);
              if ((v189 & 0x40000000) != 0) {
                v190 = *(uint64_t **)(v160 - 8);
              }
              else {
                v190 = (uint64_t *)(v160 - 32 * (v189 & 0x7FFFFFF));
              }
              uint64_t v149 = v696;
              uint64_t v246 = *v190;
              int v247 = *(_DWORD *)(v246 + 20);
              if ((v247 & 0x40000000) != 0) {
                v248 = *(llvm::Constant ***)(v246 - 8);
              }
              else {
                v248 = (llvm::Constant **)(v246 - 32 * (v247 & 0x7FFFFFF));
              }
              int v168 = *v248;
              if (*(llvm::Type **)*v248 == v171) {
                goto LABEL_445;
              }
              __int16 v728 = 257;
              PointerBitCastOrAddrSpaceCast = llvm::CastInst::CreatePointerBitCastOrAddrSpaceCast(v168, v171, (const char **)&v724, 0, v177);
LABEL_444:
              int v168 = PointerBitCastOrAddrSpaceCast;
              goto LABEL_445;
            case 'M':
              v193 = operator new(0x60uLL);
              int v168 = (llvm::Constant *)(v193 + 8);
              v193[13] = v193[13] & 0x38000000 | 1;
              *(void *)v193 = 0;
              *((void *)v193 + 1) = 0;
              *((void *)v193 + 2) = 0;
              *((void *)v193 + 3) = v193 + 8;
              v194 = *(llvm::Value **)v713;
              __int16 v728 = 257;
              llvm::BitCastInst::BitCastInst((llvm::BitCastInst *)(v193 + 8), v194, v171, (const char **)&v724, 0);
              goto LABEL_425;
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'T':
              __break(1u);
              goto LABEL_1060;
            case 'S':
              int v195 = *(_DWORD *)(v160 + 20) & 0x7FFFFFF;
              __int16 v728 = 257;
              v196 = operator new(0x48uLL);
              v196[1] = v171;
              int v168 = (llvm::Constant *)(v196 + 1);
              void *v196 = 0;
              v196[2] = 0;
              v196[3] = 0x4000000000000053;
              *((_OWORD *)v196 + 2) = 0u;
              *((_OWORD *)v196 + 3) = 0u;
              *((_DWORD *)v196 + 16) = 0;
              *((_DWORD *)v196 + 17) = v195;
              llvm::Value::setNameImpl((llvm::Value *)(v196 + 1), (const char **)&v724);
              if (*((unsigned char *)v196 + 24)) {
                goto LABEL_383;
              }
              if ((*((unsigned char *)v196 + 31) & 0x10) == 0) {
                goto LABEL_516;
              }
              uint64_t v281 = ***(void ***)v168;
              uint64_t v282 = *(void *)(v281 + 152);
              uint64_t v283 = *(unsigned int *)(v281 + 168);
              if (!v283) {
                goto LABEL_508;
              }
              LODWORD(v284) = (v283 - 1) & ((v168 >> 4) ^ (v168 >> 9));
              v285 = (llvm::Constant **)(v282 + 16 * v284);
              v286 = *v285;
              if (*v285 == v168) {
                goto LABEL_509;
              }
              int v287 = 1;
              break;
            case 'U':
              int v191 = *(_DWORD *)(v160 + 20);
              if ((v191 & 0x40000000) != 0) {
                v192 = *(uint64_t **)(v160 - 8);
              }
              else {
                v192 = (uint64_t *)(v160 - 32 * (v191 & 0x7FFFFFF));
              }
              uint64_t v149 = v696;
              uint64_t v242 = *v192;
              v243 = (uint64_t *)*((void *)v713 + 1);
              uint64_t v244 = *((void *)v713 + 2);
              __int16 v728 = 257;
              PointerBitCastOrAddrSpaceCast = sub_1CC199EFC(v242, v243, v244, (const char **)&v724, 0, v160);
              goto LABEL_444;
            default:
              uint64_t v230 = *(void *)(v160 + 64);
              v231 = *(uint64_t **)v713;
              uint64_t v232 = *(_DWORD *)(v160 + 20) & 0x7FFFFFF;
              v233 = (uint64_t *)&v726;
              v724 = &v726;
              uint64_t v725 = 0x400000000;
              unint64_t v234 = -(-32 * v232 + 32);
              if (v234 >= 0x81) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              if (v160 - 32 * v232 + 32 != v160)
              {
                v235 = &v726;
                uint64_t v236 = 32 - 32 * v232;
                do
                {
                  *v235++ = *(llvm::Value **)(v160 + v236);
                  v236 += 32;
                }
                while (v236);
                v233 = (uint64_t *)v724;
              }
              uint64_t v237 = (v234 >> 5);
              LODWORD(v725) = v237;
              uint64_t v238 = (v237 + 1);
              __int16 v711 = 257;
              v239 = (llvm::Constant *)operator new(32 * v238 + 80);
              int v168 = (llvm::Constant *)((char *)v239 + 32 * v238);
              *((_DWORD *)v168 + 5) = *((_DWORD *)v168 + 5) & 0x38000000 | v238 & 0x7FFFFFF;
              if (v237 != -1)
              {
                do
                {
                  *(void *)v239 = 0;
                  *((void *)v239 + 1) = 0;
                  *((void *)v239 + 2) = 0;
                  *((void *)v239 + 3) = v168;
                  v239 = (llvm::Constant *)((char *)v239 + 32);
                }
                while (v239 != v168);
              }
              sub_1CB845A7C(v230, v231, (uint64_t)v233, v237);
              *(void *)int v168 = v240;
              *((void *)v168 + 1) = 0;
              int v241 = *((_DWORD *)v168 + 5) & 0xC0000000 | v238 & 0x7FFFFFF;
              *((_DWORD *)v168 + 4) = 62;
              *((_DWORD *)v168 + 5) = v241;
              *(_OWORD *)((char *)v168 + 24) = 0u;
              *(_OWORD *)((char *)v168 + 40) = 0u;
              *((_DWORD *)v168 + 14) = 0;
              *((void *)v168 + 8) = v230;
              *((void *)v168 + 9) = llvm::GetElementPtrInst::getIndexedType(v230, (uint64_t)v233, v237);
              llvm::GetElementPtrInst::init((uint64_t ***)v168, (uint64_t **)v231, v233, v237, v710);
              if (v724 != &v726) {
                free(v724);
              }
              *((unsigned char *)v168 + 17) = *((unsigned char *)v168 + 17) & 0xFD | *(unsigned char *)(v160 + 17) & 2;
              uint64_t v149 = v696;
              goto LABEL_445;
          }
          while (v286 != (llvm::Constant *)-4096)
          {
            int v288 = v284 + v287++;
            uint64_t v284 = v288 & (v283 - 1);
            v286 = *(llvm::Constant **)(v282 + 16 * v284);
            if (v286 == v168)
            {
              v285 = (llvm::Constant **)(v282 + 16 * v284);
              goto LABEL_509;
            }
          }
LABEL_508:
          v285 = (llvm::Constant **)(v282 + 16 * v283);
LABEL_509:
          v289 = v285[1];
          unint64_t v292 = *(void *)v289;
          v290 = (char *)v289 + 16;
          unint64_t v291 = v292;
          if (v292 >= 5 && (*(_DWORD *)v290 == *(_DWORD *)"llvm." ? (BOOL v293 = v290[4] == aLlvm_1[4]) : (BOOL v293 = 0), v293))
          {
            *((_DWORD *)v196 + 10) |= 0x2000u;
            int v294 = llvm::Function::lookupIntrinsicID(v290, v291);
          }
          else
          {
LABEL_516:
            int v294 = 0;
            *((_DWORD *)v196 + 10) &= ~0x2000u;
          }
          *((_DWORD *)v196 + 11) = v294;
LABEL_383:
          uint64_t v197 = *((unsigned int *)v196 + 17);
          v198 = operator new(40 * v197);
          void *v196 = v198;
          if (v197)
          {
            v199 = &v198[4 * v197];
            do
            {
              void *v198 = 0;
              v198[1] = 0;
              v198[2] = 0;
              v198[3] = v168;
              v198 += 4;
            }
            while (v198 != v199);
          }
          int v200 = *(_DWORD *)(v160 + 20);
          unint64_t v201 = v200 & 0x7FFFFFF;
          if ((v200 & 0x7FFFFFF) != 0)
          {
            unint64_t v202 = 0;
            do
            {
              if ((v200 & 0x40000000) != 0) {
                uint64_t v203 = *(void *)(v160 - 8);
              }
              else {
                uint64_t v203 = v160 - 32 * v201;
              }
              uint64_t v204 = *((void *)v713 + v202);
              uint64_t v205 = *(void *)(v203 + 32 * *(unsigned int *)(v160 + 60) + 8 * v202);
              int v206 = *((_DWORD *)v196 + 7);
              uint64_t v207 = v206 & 0x7FFFFFF;
              if ((v206 & 0x7FFFFFF) == *((_DWORD *)v196 + 17))
              {
                unsigned int v220 = v207 + (v207 >> 1);
                if (v220 <= 2) {
                  uint64_t v221 = 2;
                }
                else {
                  uint64_t v221 = v220;
                }
                *((_DWORD *)v196 + 17) = v221;
                if ((v206 & 0x40000000) != 0) {
                  v222 = (uint64_t *)*v196;
                }
                else {
                  v222 = (uint64_t *)((char *)v168 - 32 * v207);
                }
                v693 = v222;
                v223 = operator new(40 * v221);
                void *v196 = v223;
                v224 = v223;
                do
                {
                  void *v224 = 0;
                  v224[1] = 0;
                  v224[2] = 0;
                  v224[3] = v168;
                  v224 += 4;
                }
                while (v224 != &v223[4 * v221]);
                int v225 = *((_DWORD *)v196 + 7);
                if ((v225 & 0x40000000) != 0) {
                  uint64_t v226 = (uint64_t)v223;
                }
                else {
                  uint64_t v226 = (uint64_t)v168 - 32 * (v225 & 0x7FFFFFF);
                }
                uint64_t v692 = v226;
                sub_1CC5E4108((uint64_t)&v724, v693, &v693[4 * v207], v226);
                if (v207)
                {
                  memmove((void *)(v692 + 32 * v221), &v693[4 * v207], 8 * v207);
                  uint64_t v227 = 4 * v207;
                  do
                  {
                    v228 = &v693[v227];
                    if (v693[v227 - 4])
                    {
                      *(void *)*(v228 - 2) = *(v228 - 3);
                      uint64_t v229 = *(v228 - 3);
                      if (v229) {
                        *(void *)(v229 + 16) = *(v228 - 2);
                      }
                    }
                    v227 -= 4;
                  }
                  while (v227 * 8);
                }
                operator delete(v693);
                int v206 = *((_DWORD *)v196 + 7);
              }
              uint64_t v208 = (v206 + 1) & 0x7FFFFFF;
              *((_DWORD *)v196 + 7) = v206 & 0xF8000000 | (v206 + 1) & 0x7FFFFFF;
              if ((v206 & 0x40000000) != 0) {
                v209 = (char *)*v196;
              }
              else {
                v209 = (char *)v168 - 32 * v208;
              }
              uint64_t v210 = (v208 - 1);
              v211 = &v209[32 * v210];
              if (*(void *)v211)
              {
                **((void **)v211 + 2) = *((void *)v211 + 1);
                uint64_t v219 = *((void *)v211 + 1);
                if (v219) {
                  *(void *)(v219 + 16) = *((void *)v211 + 2);
                }
              }
              *(void *)v211 = v204;
              if (v204)
              {
                uint64_t v214 = *(void *)(v204 + 8);
                v213 = (char **)(v204 + 8);
                uint64_t v212 = v214;
                v215 = &v209[32 * v210];
                *((void *)v215 + 1) = v214;
                if (v214) {
                  *(void *)(v212 + 16) = v215 + 8;
                }
                *((void *)v215 + 2) = v213;
                *v213 = v211;
              }
              int v216 = *((_DWORD *)v196 + 7);
              uint64_t v217 = v216 & 0x7FFFFFF;
              if ((v216 & 0x40000000) != 0) {
                v218 = (char *)*v196;
              }
              else {
                v218 = (char *)v168 - 32 * v217;
              }
              *(void *)&v218[32 * *((unsigned int *)v196 + 17) + 8 * (v217 - 1)] = v205;
              ++v202;
              int v200 = *(_DWORD *)(v160 + 20);
              unint64_t v201 = v200 & 0x7FFFFFF;
            }
            while (v202 < v201);
          }
LABEL_425:
          uint64_t v149 = v696;
LABEL_445:
          if (v713 != &v715) {
            free(v713);
          }
          if (!v168) {
            goto LABEL_476;
          }
LABEL_448:
          if (*((unsigned __int8 *)v168 + 16) >= 0x1Cu && !*((void *)v168 + 5))
          {
            uint64_t v249 = *(void *)(v160 + 40);
            *((void *)v168 + 5) = v249;
            *(_WORD *)(v249 + 18) &= ~0x8000u;
            if ((*((unsigned char *)v168 + 23) & 0x10) != 0)
            {
              uint64_t v278 = *(void *)(v249 + 56);
              if (v278)
              {
                v279 = *(llvm::ValueSymbolTable **)(v278 + 104);
                if (v279) {
                  llvm::ValueSymbolTable::reinsertValue(v279, v168);
                }
              }
            }
            uint64_t v250 = *(void *)(v160 + 24);
            *((void *)v168 + 4) = v160 + 24;
            *((void *)v168 + 3) = v250;
            *(void *)(v250 + 8) = (char *)v168 + 24;
            *(void *)(v160 + 24) = (char *)v168 + 24;
            llvm::Value::takeName((int32x2_t ****)v168, (llvm::Value *)v160);
          }
          goto LABEL_452;
        }
      }
      unsigned int v187 = 0;
      uint64_t v149 = (unint64_t *)(32 * v152);
      do
      {
        if (*(unsigned char *)(*(void *)*v184 + 8) == 15)
        {
          v188 = sub_1CCD8F540(v184, v163, (uint64_t *)&v705, (uint64_t)v698, (uint64_t)&p_j);
          if (v714 >= (unint64_t)HIDWORD(v714)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          unint64_t v152 = (unint64_t)v713;
          *((void *)v713 + v714) = v188;
        }
        else
        {
          if (v187 >= HIDWORD(v714)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          unint64_t v152 = (unint64_t)v713;
          *((void *)v713 + v187) = 0;
        }
        unsigned int v187 = v714 + 1;
        LODWORD(v714) = v714 + 1;
        v184 += 4;
        v149 -= 4;
      }
      while (v149);
      goto LABEL_375;
    }
    int v168 = sub_1CCD8ED50(*(llvm::ConstantExpr **)(v150 + 16), v163, (uint64_t *)&v705);
    if (!v168) {
      goto LABEL_476;
    }
LABEL_452:
    uint64_t v714 = 2;
    v715 = 0;
    v716 = (int32x2_t ****)v160;
    if (v160 != -8192 && v160 != -4096 && v160) {
      llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v714);
    }
    v713 = &unk_1F2615EC8;
    v717 = (uint64_t *)&v705;
    v251 = sub_1CC4CFF80((uint64_t)&v705, &v713);
    if (v716 != (int32x2_t ****)-8192 && v716 != (int32x2_t ****)-4096 && v716)
    {
      unint64_t v252 = v714 & 0xFFFFFFFFFFFFFFF8;
      *(void *)(v714 & 0xFFFFFFFFFFFFFFF8) = v715;
      if (v715)
      {
        *v715 = (void **)((unint64_t)*v715 & 7 | v252);
      }
      else
      {
        v253 = v716;
        v254 = ***v716;
        unint64_t v255 = (unint64_t)v254[303];
        if (v255 <= v252)
        {
          uint64_t v256 = v254[305].u32[0];
          if (v255 + 16 * v256 > v252)
          {
            unsigned int v257 = v256 - 1;
            LODWORD(v258) = v257 & ((v716 >> 4) ^ (v716 >> 9));
            v259 = (int32x2_t *****)(v255 + 16 * v258);
            v260 = *v259;
            if (v716 == *v259)
            {
LABEL_467:
              *v259 = (int32x2_t ****)-8192;
              v254[304] = vadd_s32(v254[304], (int32x2_t)0x1FFFFFFFFLL);
              v253 = v716;
            }
            else
            {
              int v261 = 1;
              while (v260 != (int32x2_t ****)-4096)
              {
                int v262 = v258 + v261++;
                uint64_t v258 = v262 & v257;
                v260 = *(int32x2_t *****)(v255 + 16 * v258);
                if (v716 == v260)
                {
                  v259 = (int32x2_t *****)(v255 + 16 * v258);
                  goto LABEL_467;
                }
              }
            }
            *((unsigned char *)v253 + 17) &= ~1u;
          }
        }
      }
    }
    v263 = (llvm::Constant *)v251[7];
    if (v263 != v168)
    {
      if (v263 && v263 != (llvm::Constant *)-8192 && v263 != (llvm::Constant *)-4096)
      {
        unint64_t v264 = v251[5] & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v264 = v251[6];
        v265 = (unint64_t *)v251[6];
        if (v265)
        {
          unint64_t *v265 = *v265 & 7 | v264;
        }
        else
        {
          uint64_t v266 = v251[7];
          v267 = ***(int32x2_t ****)v266;
          unint64_t v268 = (unint64_t)v267[303];
          if (v268 <= v264)
          {
            uint64_t v269 = v267[305].u32[0];
            if (v268 + 16 * v269 > v264)
            {
              unsigned int v270 = v269 - 1;
              LODWORD(v271) = v270 & ((v266 >> 4) ^ (v266 >> 9));
              v272 = (uint64_t *)(v268 + 16 * v271);
              uint64_t v273 = *v272;
              if (v266 == *v272)
              {
LABEL_488:
                uint64_t *v272 = -8192;
                v267[304] = vadd_s32(v267[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v266 = v251[7];
              }
              else
              {
                int v274 = 1;
                while (v273 != -4096)
                {
                  int v275 = v271 + v274++;
                  uint64_t v271 = v275 & v270;
                  uint64_t v273 = *(void *)(v268 + 16 * v271);
                  if (v266 == v273)
                  {
                    v272 = (uint64_t *)(v268 + 16 * v271);
                    goto LABEL_488;
                  }
                }
              }
              *(unsigned char *)(v266 + 17) &= ~1u;
            }
          }
        }
      }
      v251[7] = v168;
      if (v168 != (llvm::Constant *)-8192 && v168 != (llvm::Constant *)-4096 && v168) {
        llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)(v251 + 5));
      }
    }
LABEL_476:
    v150 += 24;
    if ((unint64_t *)v150 != v149) {
      continue;
    }
    break;
  }
  v295 = (char *)p_j;
  uint64_t v5 = v706 != 0;
  if (!v706) {
    goto LABEL_1054;
  }
  v296 = (unint64_t *)v689;
  if (v719)
  {
    v297 = (char *)p_j + 8 * v719;
    do
    {
      v298 = *(void **)v295;
      if (v707)
      {
        uint64_t v299 = v298[3];
        uint64_t v300 = (v707 - 1) & ((v299 >> 4) ^ (v299 >> 9));
        v301 = &v705[64 * v300];
        uint64_t v302 = *((void *)v301 + 3);
        if (v299 == v302) {
          goto LABEL_528;
        }
        int v303 = 1;
        while (v302 != -4096)
        {
          int v304 = v300 + v303++;
          uint64_t v300 = v304 & (v707 - 1);
          v301 = &v705[64 * v300];
          uint64_t v302 = *((void *)v301 + 3);
          if (v299 == v302) {
            goto LABEL_528;
          }
        }
      }
      v301 = &v705[64 * (unint64_t)v707];
LABEL_528:
      v713 = (void *)6;
      if (v301 == &v705[64 * (unint64_t)v707])
      {
        uint64_t v305 = 0;
        v306 = 0;
        uint64_t v714 = 0;
        v715 = 0;
      }
      else
      {
        uint64_t v305 = 0;
        v306 = (void ***)*((void *)v301 + 7);
        uint64_t v714 = 0;
        v715 = v306;
        if (v306 != (void ***)-8192 && v306 != (void ***)-4096 && v306 != 0)
        {
          unint64_t v308 = *((void *)v301 + 5) & 0xFFFFFFFFFFFFFFF8;
          uint64_t v714 = *(void *)v308;
          *(void *)unint64_t v308 = &v713;
          v713 = (void *)(v308 | 6);
          uint64_t v305 = v714;
          if (v714) {
            *(void *)uint64_t v714 = *(void *)v714 & 7 | (unint64_t)&v714;
          }
          v306 = v715;
        }
      }
      if (v306 != (void ***)-8192 && v306 != (void ***)-4096 && v306 != 0)
      {
        unint64_t v318 = (unint64_t)v713 & 0xFFFFFFFFFFFFFFF8;
        *(void *)((unint64_t)v713 & 0xFFFFFFFFFFFFFFF8) = v305;
        if (v714)
        {
          *(void *)uint64_t v714 = *(void *)v714 & 7 | v318;
        }
        else
        {
          v319 = v715;
          v320 = (int32x2_t *)***v715;
          unint64_t v321 = (unint64_t)v320[303];
          if (v321 <= v318)
          {
            uint64_t v322 = v320[305].u32[0];
            if (v321 + 16 * v322 > v318)
            {
              unsigned int v323 = v322 - 1;
              LODWORD(v324) = v323 & ((v715 >> 4) ^ (v715 >> 9));
              v325 = (void *)(v321 + 16 * v324);
              v326 = (void ***)*v325;
              if (v715 == (void ***)*v325)
              {
LABEL_561:
                void *v325 = -8192;
                v320[304] = vadd_s32(v320[304], (int32x2_t)0x1FFFFFFFFLL);
                v319 = v715;
              }
              else
              {
                int v327 = 1;
                while (v326 != (void ***)-4096)
                {
                  int v328 = v324 + v327++;
                  uint64_t v324 = v328 & v323;
                  v326 = *(void ****)(v321 + 16 * v324);
                  if (v715 == v326)
                  {
                    v325 = (void *)(v321 + 16 * v324);
                    goto LABEL_561;
                  }
                }
              }
              *((unsigned char *)v319 + 17) &= ~1u;
            }
          }
        }
      }
      if (!v306) {
        goto LABEL_599;
      }
      uint64_t v310 = v298[3];
      int v311 = *(_DWORD *)(v310 + 20);
      if ((v311 & 0x40000000) != 0) {
        uint64_t v312 = *(void *)(v310 - 8);
      }
      else {
        uint64_t v312 = v310 - 32 * (v311 & 0x7FFFFFF);
      }
      if (v707)
      {
        uint64_t v313 = ((*v298 >> 4) ^ (*v298 >> 9)) & (v707 - 1);
        v314 = &v705[64 * v313];
        uint64_t v315 = *((void *)v314 + 3);
        if (*v298 == v315) {
          goto LABEL_564;
        }
        int v316 = 1;
        while (v315 != -4096)
        {
          int v317 = v313 + v316++;
          uint64_t v313 = v317 & (v707 - 1);
          v314 = &v705[64 * v313];
          uint64_t v315 = *((void *)v314 + 3);
          if (*v298 == v315) {
            goto LABEL_564;
          }
        }
      }
      v314 = &v705[64 * (unint64_t)v707];
LABEL_564:
      v713 = (void *)6;
      if (v314 == &v705[64 * (unint64_t)v707])
      {
        v329 = 0;
        uint64_t v714 = 0;
        v715 = 0;
      }
      else
      {
        v329 = (void ***)*((void *)v314 + 7);
        uint64_t v714 = 0;
        v715 = v329;
        if (v329 != (void ***)-8192 && v329 != (void ***)-4096 && v329 != 0)
        {
          unint64_t v331 = *((void *)v314 + 5) & 0xFFFFFFFFFFFFFFF8;
          uint64_t v714 = *(void *)v331;
          *(void *)unint64_t v331 = &v713;
          v713 = (void *)(v331 | 6);
          if (v714) {
            *(void *)uint64_t v714 = *(void *)v714 & 7 | (unint64_t)&v714;
          }
          v329 = v715;
        }
      }
      int v332 = *((_DWORD *)v306 + 5);
      if ((v332 & 0x40000000) != 0) {
        v333 = (void ***)*(v306 - 1);
      }
      else {
        v333 = &v306[-4 * (v332 & 0x7FFFFFF)];
      }
      uint64_t v334 = (((unint64_t)v298 - v312) >> 5);
      v335 = &v333[4 * v334];
      if (*v335)
      {
        *v335[2] = v335[1];
        v336 = v335[1];
        if (v336) {
          v336[2] = v335[2];
        }
      }
      *v335 = v329;
      if (v329)
      {
        v339 = v329[1];
        v337 = v329 + 1;
        v338 = v339;
        v340 = &v333[4 * v334];
        v340[1] = v339;
        if (v339) {
          v338[2] = v340 + 1;
        }
        v340[2] = (void **)v337;
        void *v337 = v335;
      }
      if (v715 != (void ***)-8192 && v715 != (void ***)-4096 && v715)
      {
        unint64_t v341 = (unint64_t)v713 & 0xFFFFFFFFFFFFFFF8;
        *(void *)((unint64_t)v713 & 0xFFFFFFFFFFFFFFF8) = v714;
        if (v714)
        {
          *(void *)uint64_t v714 = *(void *)v714 & 7 | v341;
        }
        else
        {
          v342 = v715;
          v343 = (int32x2_t *)***v715;
          unint64_t v344 = (unint64_t)v343[303];
          if (v344 <= v341)
          {
            uint64_t v345 = v343[305].u32[0];
            if (v344 + 16 * v345 > v341)
            {
              unsigned int v346 = v345 - 1;
              LODWORD(v347) = v346 & ((v715 >> 4) ^ (v715 >> 9));
              v348 = (void *)(v344 + 16 * v347);
              v349 = (void ***)*v348;
              if (v715 == (void ***)*v348)
              {
LABEL_594:
                void *v348 = -8192;
                v343[304] = vadd_s32(v343[304], (int32x2_t)0x1FFFFFFFFLL);
                v342 = v715;
              }
              else
              {
                int v350 = 1;
                while (v349 != (void ***)-4096)
                {
                  int v351 = v347 + v350++;
                  uint64_t v347 = v351 & v346;
                  v349 = *(void ****)(v344 + 16 * v347);
                  if (v715 == v349)
                  {
                    v348 = (void *)(v344 + 16 * v347);
                    goto LABEL_594;
                  }
                }
              }
              *((unsigned char *)v342 + 17) &= ~1u;
            }
          }
        }
      }
LABEL_599:
      v295 += 8;
    }
    while (v295 != v297);
  }
  unsigned int v673 = v5;
  v713 = &v715;
  uint64_t v714 = 0x1000000000;
LABEL_603:
  v352 = (llvm::Value *)v296[2];
  if (v707)
  {
    uint64_t v353 = (v707 - 1) & ((v352 >> 4) ^ (v352 >> 9));
    v354 = &v705[64 * v353];
    v355 = (llvm::Value *)*((void *)v354 + 3);
    if (v352 != v355)
    {
      int v356 = 1;
      while (v355 != (llvm::Value *)-4096)
      {
        int v357 = v353 + v356++;
        uint64_t v353 = v357 & (v707 - 1);
        v354 = &v705[64 * v353];
        v355 = (llvm::Value *)*((void *)v354 + 3);
        if (v352 == v355) {
          goto LABEL_610;
        }
      }
      goto LABEL_609;
    }
  }
  else
  {
LABEL_609:
    v354 = &v705[64 * (unint64_t)v707];
  }
LABEL_610:
  v724 = (void *)6;
  if (v354 == &v705[64 * (unint64_t)v707])
  {
    uint64_t v358 = 0;
    v359 = 0;
    uint64_t v725 = 0;
    v726 = 0;
  }
  else
  {
    uint64_t v358 = 0;
    v359 = (llvm::Value *)*((void *)v354 + 7);
    uint64_t v725 = 0;
    v726 = v359;
    if (v359 != (llvm::Value *)-8192 && v359 != (llvm::Value *)-4096 && v359 != 0)
    {
      unint64_t v361 = *((void *)v354 + 5) & 0xFFFFFFFFFFFFFFF8;
      uint64_t v725 = *(void *)v361;
      *(void *)unint64_t v361 = &v724;
      v724 = (void *)(v361 | 6);
      uint64_t v358 = v725;
      if (v725) {
        *(void *)uint64_t v725 = *(void *)v725 & 7 | (unint64_t)&v725;
      }
      v359 = v726;
    }
  }
  if (v359 != (llvm::Value *)-8192 && v359 != (llvm::Value *)-4096 && v359 != 0)
  {
    unint64_t v647 = (unint64_t)v724 & 0xFFFFFFFFFFFFFFF8;
    *(void *)((unint64_t)v724 & 0xFFFFFFFFFFFFFFF8) = v358;
    if (v725)
    {
      *(void *)uint64_t v725 = *(void *)v725 & 7 | v647;
    }
    else
    {
      v648 = v726;
      v649 = ***(int32x2_t ****)v726;
      unint64_t v650 = (unint64_t)v649[303];
      if (v650 <= v647)
      {
        uint64_t v651 = v649[305].u32[0];
        if (v650 + 16 * v651 > v647)
        {
          unsigned int v652 = v651 - 1;
          LODWORD(v653) = v652 & ((v726 >> 4) ^ (v726 >> 9));
          v654 = (llvm::Value **)(v650 + 16 * v653);
          v655 = *v654;
          if (v726 == *v654)
          {
LABEL_1037:
            *v654 = (llvm::Value *)-8192;
            v649[304] = vadd_s32(v649[304], (int32x2_t)0x1FFFFFFFFLL);
            v648 = v726;
          }
          else
          {
            int v656 = 1;
            while (v655 != (llvm::Value *)-4096)
            {
              int v657 = v653 + v656++;
              uint64_t v653 = v657 & v652;
              v655 = *(llvm::Value **)(v650 + 16 * v653);
              if (v726 == v655)
              {
                v654 = (llvm::Value **)(v650 + 16 * v653);
                goto LABEL_1037;
              }
            }
          }
          *((unsigned char *)v648 + 17) &= ~1u;
        }
      }
    }
  }
  if (!v359) {
    goto LABEL_1027;
  }
  if (v352)
  {
    if (*((unsigned __int8 *)v352 + 16) <= 0x14u)
    {
      AddrSpaceCast = (llvm::Value *)llvm::ConstantExpr::getAddrSpaceCast(v359, *(llvm::Constant ****)v352, 0);
      if (v352 != AddrSpaceCast)
      {
        v364 = AddrSpaceCast;
        llvm::Value::doRAUW(v352, AddrSpaceCast, (llvm::Value *)1);
        v352 = v364;
      }
    }
  }
  uint64_t v365 = *((void *)v352 + 1);
  if (!v365)
  {
LABEL_1024:
    if (*((unsigned __int8 *)v352 + 16) >= 0x1Cu)
    {
      if (v714 >= (unint64_t)HIDWORD(v714)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v713 + v714) = v352;
      LODWORD(v714) = v714 + 1;
    }
    goto LABEL_1027;
  }
  v690 = v296;
  while (2)
  {
    uint64_t v366 = v365;
    uint64_t v367 = *(void *)(v365 + 24);
    do
      uint64_t v365 = *(void *)(v365 + 8);
    while (v365 && *(void *)(v365 + 24) == v367);
    unsigned int v368 = *(_DWORD *)(*(void *)v352 + 8);
    if ((v368 & 0xFE) == 0x12) {
      unsigned int v368 = *(_DWORD *)(**(void **)(*(void *)v352 + 16) + 8);
    }
    int v369 = *(_DWORD *)(v367 + 20);
    if ((v369 & 0x40000000) != 0) {
      uint64_t v370 = *(void *)(v367 - 8);
    }
    else {
      uint64_t v370 = v367 - 32 * (v369 & 0x7FFFFFF);
    }
    unsigned int v371 = *(unsigned __int8 *)(v367 + 16);
    if (v371 >= 0x1C)
    {
      char v372 = (*(uint64_t (**)(void, uint64_t, void))(***(void ***)(v3 + 16) + 424))(**(void **)(v3 + 16), v367, v368 >> 8);
      unsigned int v371 = *(unsigned __int8 *)(v367 + 16);
    }
    else
    {
      char v372 = 0;
    }
    unint64_t v373 = (unint64_t)(v366 - v370) >> 5;
    switch(v371)
    {
      case '<':
      case '@':
      case 'A':
        if (v373) {
          char v374 = 1;
        }
        else {
          char v374 = v372;
        }
        if ((v374 & 1) == 0) {
          goto LABEL_675;
        }
        if (v373) {
          goto LABEL_649;
        }
        goto LABEL_676;
      case '=':
        BOOL v395 = v373 == 1;
        if (v373 == 1) {
          char v396 = v372;
        }
        else {
          char v396 = 1;
        }
        if (v396)
        {
          if (v395) {
            goto LABEL_676;
          }
          goto LABEL_649;
        }
LABEL_675:
        if (*(_WORD *)(v367 + 18))
        {
LABEL_649:
          v375 = *(llvm::Value **)(v366 + 24);
          if (v375 == v359) {
            goto LABEL_951;
          }
          int v376 = sub_1CBFB3AB0(*(void *)(v366 + 24));
          if (v375 && v376)
          {
            v377 = (void **)((void *)v375 - 4 * (*((_DWORD *)v375 + 5) & 0x7FFFFFF))[12];
            uint64_t v378 = *((unsigned int *)v377 + 8);
            if (v378 > 0x40)
            {
              int v400 = 0;
              int64_t v401 = (unint64_t)(v378 + 63) >> 6;
              do
              {
                if (v401-- < 1) {
                  break;
                }
                unint64_t v403 = v377[3][v401];
                v400 += __clz(v403);
              }
              while (!v403);
              int v404 = v378 | 0xFFFFFFC0;
              if ((v378 & 0x3F) == 0) {
                int v404 = 0;
              }
              if (v400 + v404 == v378)
              {
LABEL_691:
                uint64_t v405 = 0;
                uint64_t v406 = **(void **)v375;
                v724 = &v726;
                uint64_t v725 = 0x200000000;
                uint64_t v731 = v406;
                v732 = &v740;
                v733 = v741;
                uint64_t v734 = 0;
                int v735 = 0;
                __int16 v736 = 512;
                char v737 = 7;
                v729 = 0;
                v730 = 0;
                uint64_t v738 = 0;
                uint64_t v739 = 0;
                v740 = &unk_1F2616E88;
                v741[0] = &unk_1F2617008;
                v729 = (void **)*((void *)v375 + 5);
                v730 = (void ***)((char *)v375 + 24);
                v407 = (unsigned __int8 *)*((void *)v375 + 6);
                v712 = v407;
                if (v407)
                {
                  llvm::MetadataTracking::track((uint64_t)&v712, v407, 2);
                  uint64_t v405 = (uint64_t)v712;
                }
                sub_1CB8461A4((uint64_t)&v724, 0, v405);
                if (v712)
                {
                  int v506 = *v712;
                  if ((v506 - 4) > 0x1E)
                  {
                    if ((v506 - 3) >= 0xFFFFFFFE) {
                      v617 = v712;
                    }
                    else {
                      v617 = 0;
                    }
                    if ((v506 - 3) < 0xFFFFFFFE)
                    {
                      if (v506 == 3) {
                        *((void *)v712 + 1) = 0;
                      }
                      goto LABEL_694;
                    }
                    unint64_t v508 = (unint64_t)(v617 + 8);
                  }
                  else
                  {
                    if ((v712[1] & 0x7F) != 2 && !*((_DWORD *)v712 + 3)) {
                      goto LABEL_694;
                    }
                    uint64_t v507 = *((void *)v712 + 2);
                    if ((v507 & 4) == 0) {
                      goto LABEL_694;
                    }
                    unint64_t v508 = v507 & 0xFFFFFFFFFFFFFFF8;
                    if (!v508) {
                      goto LABEL_694;
                    }
                  }
                  v710[0] = (const char *)&v712;
                  sub_1CC5FA668(v508 + 16, v710);
                }
LABEL_694:
                int v408 = *((_DWORD *)v375 + 5);
                if (*((void *)v375 + 6))
                {
                  if ((v408 & 0x20000000) == 0)
                  {
LABEL_714:
                    v410 = 0;
                    goto LABEL_715;
                  }
LABEL_699:
                  uint64_t v411 = ***(void ***)v375;
                  v710[0] = (const char *)v375;
                  int v412 = *(_DWORD *)(v411 + 2496);
                  if (!v412)
                  {
                    v516 = 0;
                    goto LABEL_824;
                  }
                  uint64_t v413 = *(void *)(v411 + 2480);
                  int v414 = v412 - 1;
                  unsigned int v415 = v414 & ((v375 >> 4) ^ (v375 >> 9));
                  v416 = (void *)(v413 + 40 * v415);
                  v417 = (void ***)*v416;
                  if ((llvm::Value *)*v416 != v375)
                  {
                    v418 = 0;
                    int v419 = 1;
                    while (v417 != (void ***)-4096)
                    {
                      if (v418) {
                        BOOL v420 = 0;
                      }
                      else {
                        BOOL v420 = v417 == (void ***)-8192;
                      }
                      if (v420) {
                        v418 = v416;
                      }
                      unsigned int v421 = v415 + v419++;
                      unsigned int v415 = v421 & v414;
                      v416 = (void *)(v413 + 40 * v415);
                      v417 = (void ***)*v416;
                      if ((llvm::Value *)*v416 == v375) {
                        goto LABEL_709;
                      }
                    }
                    if (v418) {
                      v516 = v418;
                    }
                    else {
                      v516 = v416;
                    }
LABEL_824:
                    v416 = sub_1CC609054(v411 + 2480, (uint64_t)v710, (uint64_t *)v710, v516);
                    v517 = v710[0];
                    v416[4] = 0;
                    v416[3] = 0;
                    void *v416 = v517;
                    v416[1] = v416 + 3;
                    v416[2] = 0x100000000;
                  }
LABEL_709:
                  uint64_t v422 = *((unsigned int *)v416 + 4);
                  if (!v422) {
                    goto LABEL_714;
                  }
                  v423 = (llvm::MDNode **)(v416[1] + 8);
                  uint64_t v424 = 16 * v422;
                  while (*((_DWORD *)v423 - 2) != 1)
                  {
                    v410 = 0;
                    v423 += 2;
                    v424 -= 16;
                    if (!v424) {
                      goto LABEL_715;
                    }
                  }
                  v410 = *v423;
LABEL_715:
                  int v425 = *((_DWORD *)v375 + 5);
                  if (!*((void *)v375 + 6))
                  {
                    if ((v425 & 0x20000000) != 0) {
                      goto LABEL_720;
                    }
                    v409 = 0;
                    goto LABEL_751;
                  }
                  if ((v425 & 0x20000000) != 0)
                  {
LABEL_720:
                    uint64_t v426 = ***(void ***)v375;
                    v710[0] = (const char *)v375;
                    int v427 = *(_DWORD *)(v426 + 2496);
                    if (!v427)
                    {
                      v607 = v410;
                      v608 = 0;
                      goto LABEL_959;
                    }
                    uint64_t v428 = *(void *)(v426 + 2480);
                    int v429 = v427 - 1;
                    unsigned int v430 = v429 & ((v375 >> 4) ^ (v375 >> 9));
                    v431 = (void *)(v428 + 40 * v430);
                    v432 = (void ***)*v431;
                    if ((llvm::Value *)*v431 != v375)
                    {
                      v433 = 0;
                      int v434 = 1;
                      while (v432 != (void ***)-4096)
                      {
                        if (v433) {
                          BOOL v435 = 0;
                        }
                        else {
                          BOOL v435 = v432 == (void ***)-8192;
                        }
                        if (v435) {
                          v433 = v431;
                        }
                        unsigned int v436 = v430 + v434++;
                        unsigned int v430 = v436 & v429;
                        v431 = (void *)(v428 + 40 * v430);
                        v432 = (void ***)*v431;
                        if ((llvm::Value *)*v431 == v375) {
                          goto LABEL_730;
                        }
                      }
                      v607 = v410;
                      if (v433) {
                        v608 = v433;
                      }
                      else {
                        v608 = v431;
                      }
LABEL_959:
                      v431 = sub_1CC609054(v426 + 2480, (uint64_t)v710, (uint64_t *)v710, v608);
                      v609 = v710[0];
                      v431[4] = 0;
                      v431[3] = 0;
                      void *v431 = v609;
                      v431[1] = v431 + 3;
                      v431[2] = 0x100000000;
                      v410 = v607;
                    }
LABEL_730:
                    uint64_t v437 = *((unsigned int *)v431 + 4);
                    if (v437)
                    {
                      v438 = (llvm::MDNode **)(v431[1] + 8);
                      uint64_t v439 = 16 * v437;
                      while (*((_DWORD *)v438 - 2) != 7)
                      {
                        v409 = 0;
                        v438 += 2;
                        v439 -= 16;
                        if (!v439) {
                          goto LABEL_736;
                        }
                      }
                      v409 = *v438;
LABEL_736:
                      if ((*((unsigned char *)v375 + 23) & 0x20) != 0)
                      {
                        uint64_t v440 = ***(void ***)v375;
                        v710[0] = (const char *)v375;
                        int v441 = *(_DWORD *)(v440 + 2496);
                        if (!v441)
                        {
                          v613 = v409;
                          v614 = v410;
                          v615 = 0;
                          goto LABEL_964;
                        }
                        uint64_t v442 = *(void *)(v440 + 2480);
                        int v443 = v441 - 1;
                        unsigned int v444 = v443 & ((v375 >> 4) ^ (v375 >> 9));
                        v445 = (void *)(v442 + 40 * v444);
                        v446 = (void ***)*v445;
                        if ((llvm::Value *)*v445 != v375)
                        {
                          v447 = 0;
                          int v448 = 1;
                          while (v446 != (void ***)-4096)
                          {
                            if (v447) {
                              BOOL v449 = 0;
                            }
                            else {
                              BOOL v449 = v446 == (void ***)-8192;
                            }
                            if (v449) {
                              v447 = v445;
                            }
                            unsigned int v450 = v444 + v448++;
                            unsigned int v444 = v450 & v443;
                            v445 = (void *)(v442 + 40 * v444);
                            v446 = (void ***)*v445;
                            if ((llvm::Value *)*v445 == v375) {
                              goto LABEL_747;
                            }
                          }
                          v613 = v409;
                          v614 = v410;
                          if (v447) {
                            v615 = v447;
                          }
                          else {
                            v615 = v445;
                          }
LABEL_964:
                          v445 = sub_1CC609054(v440 + 2480, (uint64_t)v710, (uint64_t *)v710, v615);
                          v616 = v710[0];
                          v445[4] = 0;
                          v445[3] = 0;
                          void *v445 = v616;
                          v445[1] = v445 + 3;
                          v445[2] = 0x100000000;
                          v410 = v614;
                          v409 = v613;
                        }
LABEL_747:
                        uint64_t v451 = *((unsigned int *)v445 + 4);
                        if (v451)
                        {
                          v452 = (llvm::MDNode **)(v445[1] + 8);
                          uint64_t v453 = 16 * v451;
                          while (*((_DWORD *)v452 - 2) != 8)
                          {
                            v452 += 2;
                            v453 -= 16;
                            if (!v453) {
                              goto LABEL_751;
                            }
                          }
                          v454 = *v452;
LABEL_752:
                          int v455 = *(_DWORD *)(*((void *)v375 - 4) + 36);
                          v456 = v375;
                          if ((v455 - 196) >= 2 && v455 != 194)
                          {
                            if (v455 == 199)
                            {
                              v457 = (void ***)((char *)v375 - 32 * (*((_DWORD *)v375 + 5) & 0x7FFFFFF));
                              uint64_t v458 = (uint64_t)v457[4];
                              v459 = (uint64_t *)v457[8];
                              v460 = (void **)*((void *)v375 + 8);
                              if (!v460) {
                                goto LABEL_760;
                              }
                              if (*((_DWORD *)v460 + 2) < 3u) {
                                goto LABEL_760;
                              }
                              v461 = (llvm::AttributeSetNode *)v460[7];
                              if (!v461) {
                                goto LABEL_760;
                              }
                              v462 = v410;
                              v463 = v409;
                              v464 = v454;
                              uint64_t v465 = v458;
                              v466 = v459;
                              unsigned __int16 Alignment = llvm::AttributeSetNode::getAlignment(v461);
                              v459 = v466;
                              uint64_t v458 = v465;
                              v454 = v464;
                              v409 = v463;
                              v410 = v462;
                              if (Alignment < 0x100u) {
                                goto LABEL_760;
                              }
                              if (Alignment < 0x20u) {
                                unint64_t v468 = __clz(__rbit64((1 << Alignment))) | 0x100;
                              }
                              else {
LABEL_760:
                              }
                                LOWORD(v468) = 0;
                              llvm::IRBuilderBase::CreateMemSet((uint64_t)&v724, v359, v458, v459, v468, 0, v410, v409, v454);
                              goto LABEL_809;
                            }
                            v456 = 0;
                            int v455 = *(_DWORD *)(MEMORY[0xFFFFFFFFFFFFFFE0] + 36);
                          }
                          int v469 = *((_DWORD *)v456 + 5);
                          v470 = (llvm::Value **)((char *)v456 - 32 * (v469 & 0x7FFFFFF));
                          if (v470[4] == v352) {
                            v471 = v359;
                          }
                          else {
                            v471 = v470[4];
                          }
                          if (*v470 == v352) {
                            v472 = v359;
                          }
                          else {
                            v472 = *v470;
                          }
                          if (v455 == 194)
                          {
                            if ((v469 & 0x20000000) == 0) {
                              goto LABEL_771;
                            }
                            uint64_t v483 = ***(void ***)v456;
                            v710[0] = (const char *)v456;
                            int v484 = *(_DWORD *)(v483 + 2496);
                            if (!v484)
                            {
                              __srcc = v472;
                              v632 = v471;
                              v633 = v454;
                              v634 = v409;
                              v635 = v410;
                              v636 = 0;
                              goto LABEL_992;
                            }
                            uint64_t v485 = *(void *)(v483 + 2480);
                            int v486 = v484 - 1;
                            unsigned int v487 = v486 & ((v456 >> 4) ^ (v456 >> 9));
                            v488 = (void *)(v485 + 40 * v487);
                            v489 = (void ***)*v488;
                            if ((llvm::Value *)*v488 != v456)
                            {
                              v490 = 0;
                              int v491 = 1;
                              while (v489 != (void ***)-4096)
                              {
                                if (v490) {
                                  BOOL v492 = 0;
                                }
                                else {
                                  BOOL v492 = v489 == (void ***)-8192;
                                }
                                if (v492) {
                                  v490 = v488;
                                }
                                unsigned int v493 = v487 + v491++;
                                unsigned int v487 = v493 & v486;
                                v488 = (void *)(v485 + 40 * v487);
                                v489 = (void ***)*v488;
                                if ((llvm::Value *)*v488 == v456) {
                                  goto LABEL_787;
                                }
                              }
                              __srcc = v472;
                              v632 = v471;
                              v633 = v454;
                              v634 = v409;
                              v635 = v410;
                              if (v490) {
                                v636 = v490;
                              }
                              else {
                                v636 = v488;
                              }
LABEL_992:
                              v488 = sub_1CC609054(v483 + 2480, (uint64_t)v710, (uint64_t *)v710, v636);
                              v637 = v710[0];
                              v488[4] = 0;
                              v488[3] = 0;
                              void *v488 = v637;
                              v488[1] = v488 + 3;
                              v488[2] = 0x100000000;
                              v410 = v635;
                              v409 = v634;
                              v454 = v633;
                              v471 = v632;
                              v472 = __srcc;
                            }
LABEL_787:
                            uint64_t v494 = *((unsigned int *)v488 + 4);
                            if (v494)
                            {
                              v495 = (llvm::MDNode **)(v488[1] + 8);
                              uint64_t v496 = 16 * v494;
                              while (*((_DWORD *)v495 - 2) != 5)
                              {
                                v473 = 0;
                                v495 += 2;
                                v496 -= 16;
                                if (!v496) {
                                  goto LABEL_772;
                                }
                              }
                              v473 = *v495;
                            }
                            else
                            {
LABEL_771:
                              v473 = 0;
                            }
LABEL_772:
                            v474 = (void **)*((void *)v456 + 8);
                            if (v474 && (unsigned int v475 = *((_DWORD *)v474 + 2), v475 >= 3))
                            {
                              __src = v472;
                              v675 = v454;
                              v678 = v409;
                              v681 = v410;
                              v476 = (llvm::AttributeSetNode *)v474[7];
                              if (v476)
                              {
                                __int16 v477 = llvm::AttributeSetNode::getAlignment(v476);
                                __int16 v478 = v477;
                                __int16 v479 = HIBYTE(v477);
                              }
                              else
                              {
                                __int16 v479 = 0;
                                __int16 v478 = 0;
                              }
                              __int16 v480 = v478 | (v479 << 8);
                              if (v475 < 4)
                              {
                                __int16 v481 = 0;
                                unsigned __int8 v482 = 0;
                              }
                              else
                              {
                                v504 = (llvm::AttributeSetNode *)v474[8];
                                if (v504)
                                {
                                  __int16 v505 = llvm::AttributeSetNode::getAlignment(v504);
                                  unsigned __int8 v482 = v505;
                                  __int16 v481 = HIBYTE(v505);
                                }
                                else
                                {
                                  __int16 v481 = 0;
                                  unsigned __int8 v482 = 0;
                                }
                              }
                              v409 = v678;
                              v410 = v681;
                              v454 = v675;
                              v472 = __src;
                            }
                            else
                            {
                              __int16 v480 = 0;
                              __int16 v481 = 0;
                              unsigned __int8 v482 = 0;
                            }
                            llvm::IRBuilderBase::CreateMemTransferInst((uint64_t)&v724, 194, v472, v480, v471, v482 | (unsigned __int16)(v481 << 8), ((uint64_t **)v456 - 4 * (*((_DWORD *)v456 + 5) & 0x7FFFFFF))[8], 0, v410, v473, v409, v454);
LABEL_809:
                            llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                          }
                          if (v455 != 196)
                          {
                            v509 = (void **)*((void *)v456 + 8);
                            if (v509)
                            {
                              unsigned int v510 = *((_DWORD *)v509 + 2);
                              v511 = v472;
                              if (v510 < 3)
                              {
                                __int16 v610 = 0;
                                __int16 v611 = 0;
                                unsigned __int8 v612 = 0;
                              }
                              else
                              {
                                v683 = v410;
                                v677 = v454;
                                v680 = v409;
                                v512 = (llvm::AttributeSetNode *)v509[7];
                                if (v512)
                                {
                                  __int16 v513 = llvm::AttributeSetNode::getAlignment(v512);
                                  __int16 v514 = v513;
                                  __int16 v515 = HIBYTE(v513);
                                }
                                else
                                {
                                  __int16 v515 = 0;
                                  __int16 v514 = 0;
                                }
                                __int16 v610 = v514 | (v515 << 8);
                                if (v510 < 4)
                                {
                                  __int16 v611 = 0;
                                  unsigned __int8 v612 = 0;
                                }
                                else
                                {
                                  v640 = (llvm::AttributeSetNode *)v509[8];
                                  if (v640)
                                  {
                                    __int16 v641 = llvm::AttributeSetNode::getAlignment(v640);
                                    unsigned __int8 v612 = v641;
                                    __int16 v611 = HIBYTE(v641);
                                  }
                                  else
                                  {
                                    __int16 v611 = 0;
                                    unsigned __int8 v612 = 0;
                                  }
                                }
                                v409 = v680;
                                v410 = v683;
                                v454 = v677;
                              }
                            }
                            else
                            {
                              v511 = v472;
                              __int16 v610 = 0;
                              __int16 v611 = 0;
                              unsigned __int8 v612 = 0;
                            }
                            llvm::IRBuilderBase::CreateMemMove((uint64_t)&v724, v511, v610, v471, v612 | (unsigned __int16)(v611 << 8), v470[8], 0, v410, v409, v454);
                            goto LABEL_809;
                          }
                          __srca = v472;
                          if ((v469 & 0x20000000) == 0)
                          {
LABEL_795:
                            v497 = 0;
                            goto LABEL_796;
                          }
                          uint64_t v618 = ***(void ***)v456;
                          v710[0] = (const char *)v456;
                          int v619 = *(_DWORD *)(v618 + 2496);
                          if (v619)
                          {
                            uint64_t v620 = *(void *)(v618 + 2480);
                            int v621 = v619 - 1;
                            unsigned int v622 = v621 & ((v456 >> 4) ^ (v456 >> 9));
                            v623 = (void *)(v620 + 40 * v622);
                            v624 = (void ***)*v623;
                            if ((llvm::Value *)*v623 != v456)
                            {
                              v625 = 0;
                              int v626 = 1;
                              while (v624 != (void ***)-4096)
                              {
                                if (v625) {
                                  BOOL v627 = 0;
                                }
                                else {
                                  BOOL v627 = v624 == (void ***)-8192;
                                }
                                if (v627) {
                                  v625 = v623;
                                }
                                unsigned int v628 = v622 + v626++;
                                unsigned int v622 = v628 & v621;
                                v623 = (void *)(v620 + 40 * v622);
                                v624 = (void ***)*v623;
                                if ((llvm::Value *)*v623 == v456) {
                                  goto LABEL_982;
                                }
                              }
                              v684 = v471;
                              v642 = v454;
                              v643 = v409;
                              v644 = v410;
                              if (v625) {
                                v645 = v625;
                              }
                              else {
                                v645 = v623;
                              }
LABEL_1014:
                              v623 = sub_1CC609054(v618 + 2480, (uint64_t)v710, (uint64_t *)v710, v645);
                              v646 = v710[0];
                              v623[4] = 0;
                              v623[3] = 0;
                              void *v623 = v646;
                              v623[1] = v623 + 3;
                              v623[2] = 0x100000000;
                              v410 = v644;
                              v409 = v643;
                              v454 = v642;
                              v471 = v684;
                            }
LABEL_982:
                            uint64_t v629 = *((unsigned int *)v623 + 4);
                            if (!v629) {
                              goto LABEL_795;
                            }
                            v630 = (llvm::MDNode **)(v623[1] + 8);
                            uint64_t v631 = 16 * v629;
                            while (*((_DWORD *)v630 - 2) != 5)
                            {
                              v497 = 0;
                              v630 += 2;
                              v631 -= 16;
                              if (!v631) {
                                goto LABEL_796;
                              }
                            }
                            v497 = *v630;
LABEL_796:
                            v498 = (void **)*((void *)v456 + 8);
                            if (v498 && (unsigned int v499 = *((_DWORD *)v498 + 2), v499 >= 3))
                            {
                              v672 = v497;
                              v682 = v410;
                              v676 = v454;
                              v679 = v409;
                              v500 = (llvm::AttributeSetNode *)v498[7];
                              if (v500)
                              {
                                __int16 v501 = llvm::AttributeSetNode::getAlignment(v500);
                                __int16 v502 = v501;
                                __int16 v503 = HIBYTE(v501);
                              }
                              else
                              {
                                __int16 v503 = 0;
                                __int16 v502 = 0;
                              }
                              __int16 v604 = v502 | (v503 << 8);
                              if (v499 >= 4 && (v638 = (llvm::AttributeSetNode *)v498[8]) != 0)
                              {
                                __int16 v639 = llvm::AttributeSetNode::getAlignment(v638);
                                unsigned __int8 v606 = v639;
                                __int16 v605 = HIBYTE(v639);
                              }
                              else
                              {
                                __int16 v605 = 0;
                                unsigned __int8 v606 = 0;
                              }
                              v409 = v679;
                              v410 = v682;
                              v454 = v676;
                              v497 = v672;
                            }
                            else
                            {
                              __int16 v604 = 0;
                              __int16 v605 = 0;
                              unsigned __int8 v606 = 0;
                            }
                            llvm::IRBuilderBase::CreateMemCpyInline((uint64_t)&v724, __srca, v604, v471, v606 | (unsigned __int16)(v605 << 8), ((void **)v456 - 4 * (*((_DWORD *)v456 + 5) & 0x7FFFFFF))[8], 0, v410, v497, v409, v454);
                            goto LABEL_809;
                          }
                          v684 = v471;
                          v642 = v454;
                          v643 = v409;
                          v644 = v410;
                          v645 = 0;
                          goto LABEL_1014;
                        }
                      }
LABEL_751:
                      v454 = 0;
                      goto LABEL_752;
                    }
                  }
                  v409 = 0;
                  goto LABEL_736;
                }
                if ((v408 & 0x20000000) != 0) {
                  goto LABEL_699;
                }
                v409 = 0;
                v410 = 0;
                goto LABEL_751;
              }
            }
            else if (!v377[3])
            {
              goto LABEL_691;
            }
          }
          unsigned int v379 = *((unsigned __int8 *)v375 + 16);
          if (v379 == 84)
          {
            uint64_t v380 = *((void *)v375 - 4);
            if (!v380) {
              goto LABEL_893;
            }
            if (*(unsigned char *)(v380 + 16)) {
              goto LABEL_893;
            }
            if (*(void *)(v380 + 24) != *((void *)v375 + 9)) {
              goto LABEL_893;
            }
            if ((*(unsigned char *)(v380 + 33) & 0x20) == 0) {
              goto LABEL_893;
            }
            int v381 = *(_DWORD *)(v380 + 36);
            if (v381 == 252) {
              goto LABEL_893;
            }
            if (v381 == 236)
            {
              v382 = *(uint64_t ***)(*(void *)(*((void *)v375 + 5) + 56) + 40);
              uint64_t v383 = *(void *)v359;
              v724 = *(void **)v375;
              uint64_t v725 = v383;
              uint64_t Declaration = llvm::Intrinsic::getDeclaration(v382, 236, (uint64_t)&v724, 2);
              uint64_t v385 = *((_DWORD *)v375 + 5) & 0x7FFFFFF;
              uint64_t v386 = -v385;
              v387 = (llvm::Value **)((char *)v375 - 32 * v385);
              if (*v387)
              {
                v388 = (void ***)((char *)v375 + 32 * v386);
                v390 = v388[2];
                v389 = v388 + 2;
                void *v390 = *(v389 - 1);
                uint64_t v391 = *(v389 - 1);
                if (v391) {
                  *(void *)(v391 + 16) = *v389;
                }
              }
              *v387 = v359;
              v392 = (llvm::Value ***)((char *)v359 + 8);
              uint64_t v393 = *((void *)v359 + 1);
              v394 = (void ***)((char *)v375 + 32 * v386);
              v394[1] = (void **)v393;
              if (v393) {
                *(void *)(v393 + 16) = v394 + 1;
              }
              v394[2] = v392;
              *v392 = v387;
              sub_1CC1DDE04((uint64_t)v375, Declaration);
              if (!v365) {
                goto LABEL_1023;
              }
              continue;
            }
            v518 = (llvm::Value *)(*(uint64_t (**)(void, llvm::Value *, llvm::Value *, llvm::Value *))(***(void ***)(v3 + 16) + 168))(**(void **)(v3 + 16), v375, v352, v359);
            if (v518 != v375 && v518 != 0)
            {
              llvm::Value::doRAUW(v375, v518, (llvm::Value *)1);
              if (!v365) {
                goto LABEL_1023;
              }
              continue;
            }
            if (v518) {
              goto LABEL_951;
            }
            unsigned int v379 = *((unsigned __int8 *)v375 + 16);
          }
          if (v379 < 0x1C) {
            goto LABEL_951;
          }
          if (v379 == 81)
          {
            unsigned int v520 = *(_DWORD *)(*(void *)v359 + 8);
            if ((v520 & 0xFE) == 0x12) {
              unsigned int v520 = *(_DWORD *)(**(void **)(*(void *)v359 + 16) + 8);
            }
            uint64_t v521 = *(void *)(v366 + 24);
            int v522 = *(_DWORD *)(v521 + 20);
            if ((v522 & 0x40000000) != 0) {
              uint64_t v523 = *(void *)(v521 - 8);
            }
            else {
              uint64_t v523 = v521 - 32 * (v522 & 0x7FFFFFF);
            }
            unint64_t v524 = v366 - v523;
            BOOL v525 = ((v366 - v523) & 0x1FFFFFFFE0) == 0;
            v526 = (void ***)((char *)v375 - 64);
            v527 = (uint64_t *)((char *)v375 + 32 * v525 - 64);
            uint64_t v528 = *v527;
            if (v707)
            {
              uint64_t v529 = (v707 - 1) & ((v528 >> 4) ^ (v528 >> 9));
              v530 = &v705[64 * v529];
              uint64_t v531 = *((void *)v530 + 3);
              if (v528 == v531) {
                goto LABEL_845;
              }
              int v532 = 1;
              while (v531 != -4096)
              {
                int v533 = v529 + v532++;
                uint64_t v529 = v533 & (v707 - 1);
                v530 = &v705[64 * v529];
                uint64_t v531 = *((void *)v530 + 3);
                if (v528 == v531) {
                  goto LABEL_845;
                }
              }
            }
            v530 = &v705[64 * (unint64_t)v707];
LABEL_845:
            v724 = (void *)6;
            if (v530 == &v705[64 * (unint64_t)v707])
            {
              uint64_t v534 = 0;
              v535 = 0;
              uint64_t v725 = 0;
              v726 = 0;
            }
            else
            {
              uint64_t v534 = 0;
              v535 = (llvm::Value *)*((void *)v530 + 7);
              uint64_t v725 = 0;
              v726 = v535;
              if (v535 != (llvm::Value *)-8192 && v535 != (llvm::Value *)-4096 && v535 != 0)
              {
                unint64_t v537 = *((void *)v530 + 5) & 0xFFFFFFFFFFFFFFF8;
                uint64_t v725 = *(void *)v537;
                *(void *)unint64_t v537 = &v724;
                v724 = (void *)(v537 | 6);
                uint64_t v534 = v725;
                if (v725) {
                  *(void *)uint64_t v725 = *(void *)v725 & 7 | (unint64_t)&v725;
                }
                v535 = v726;
              }
            }
            if (v535 != (llvm::Value *)-8192 && v535 != (llvm::Value *)-4096 && v535 != 0)
            {
              unint64_t v592 = (unint64_t)v724 & 0xFFFFFFFFFFFFFFF8;
              *(void *)((unint64_t)v724 & 0xFFFFFFFFFFFFFFF8) = v534;
              if (v725)
              {
                *(void *)uint64_t v725 = *(void *)v725 & 7 | v592;
              }
              else
              {
                v593 = v726;
                v594 = ***(int32x2_t ****)v726;
                unint64_t v595 = (unint64_t)v594[303];
                if (v595 <= v592)
                {
                  uint64_t v596 = v594[305].u32[0];
                  if (v595 + 16 * v596 > v592)
                  {
                    unsigned int v597 = v596 - 1;
                    LODWORD(v598) = v597 & ((v726 >> 4) ^ (v726 >> 9));
                    v599 = (llvm::Value **)(v595 + 16 * v598);
                    v600 = *v599;
                    if (v726 == *v599)
                    {
LABEL_942:
                      *v599 = (llvm::Value *)-8192;
                      v594[304] = vadd_s32(v594[304], (int32x2_t)0x1FFFFFFFFLL);
                      v593 = v726;
                    }
                    else
                    {
                      int v601 = 1;
                      while (v600 != (llvm::Value *)-4096)
                      {
                        int v602 = v598 + v601++;
                        uint64_t v598 = v602 & v597;
                        v600 = *(llvm::Value **)(v595 + 16 * v598);
                        if (v726 == v600)
                        {
                          v599 = (llvm::Value **)(v595 + 16 * v598);
                          goto LABEL_942;
                        }
                      }
                    }
                    *((unsigned char *)v593 + 17) &= ~1u;
                  }
                }
              }
            }
            int v539 = v520 >> 8;
            if (v535)
            {
              unsigned int v540 = *(_DWORD *)(*(void *)v535 + 8);
              if ((v540 & 0xFE) == 0x12) {
                unsigned int v540 = *(_DWORD *)(**(void **)(*(void *)v535 + 16) + 8);
              }
              if (v539 == v540 >> 8)
              {
                if (*v527)
                {
                  v541 = &v526[4 * v525];
                  v543 = v541[2];
                  v542 = v541 + 2;
                  void *v543 = *(v542 - 1);
                  uint64_t v544 = *(v542 - 1);
                  if (v544) {
                    *(void *)(v544 + 16) = *v542;
                  }
                }
                uint64_t *v527 = (uint64_t)v535;
                v547 = (void **)*((void *)v535 + 1);
                v545 = (uint64_t **)((char *)v535 + 8);
                v546 = v547;
                v548 = &v526[4 * v525];
                v548[1] = v547;
                v549 = v548 + 1;
                if (v547) {
                  v546[2] = v549;
                }
                v526[4 * v525 + 2] = v545;
                *v545 = v527;
                uint64_t v550 = (v524 >> 5);
                v551 = (llvm::Value **)&v526[4 * v550];
                if (*v551)
                {
                  *(void *)v551[2] = v551[1];
                  v552 = v551[1];
                  if (v552) {
                    *((void *)v552 + 2) = v551[2];
                  }
                }
                *v551 = v359;
                v553 = (llvm::Value ***)((char *)v359 + 8);
                v554 = (llvm::Value *)*((void *)v359 + 1);
                v551[1] = v554;
                if (v554) {
                  *((void *)v554 + 2) = v551 + 1;
                }
                v526[4 * v550 + 2] = v553;
                *v553 = v551;
                if (!v365) {
                  goto LABEL_1023;
                }
                continue;
              }
            }
            BOOL __srcb = v525;
            if (!v528
              || *(unsigned __int8 *)(v528 + 16) > 0x14u
              || !sub_1CCD8EC78(v3, (uint64_t *)v528, v539))
            {
              goto LABEL_893;
            }
            uint64_t v555 = (v524 >> 5);
            v556 = (llvm::Value **)&v526[4 * v555];
            if (*v556)
            {
              *(void *)v556[2] = v556[1];
              v557 = v556[1];
              if (v557) {
                *((void *)v557 + 2) = v556[2];
              }
            }
            *v556 = v359;
            v558 = (llvm::Value *)*((void *)v359 + 1);
            v556[1] = v558;
            if (v558) {
              *((void *)v558 + 2) = v556 + 1;
            }
            v526[4 * v555 + 2] = (void **)((char *)v359 + 8);
            *((void *)v359 + 1) = v556;
            uint64_t v559 = llvm::ConstantExpr::getAddrSpaceCast((llvm::ConstantExpr *)v528, *(llvm::Constant ****)v359, 0);
            if (*v527)
            {
              v560 = &v526[4 * __srcb];
              v562 = v560[2];
              v561 = v560 + 2;
              void *v562 = *(v561 - 1);
              uint64_t v563 = *(v561 - 1);
              if (v563) {
                *(void *)(v563 + 16) = *v561;
              }
            }
            uint64_t *v527 = v559;
            if (!v559) {
              goto LABEL_951;
            }
            v566 = *(void ***)(v559 + 8);
            v564 = (uint64_t **)(v559 + 8);
            v565 = v566;
            v567 = &v526[4 * __srcb];
            v567[1] = v566;
            v568 = v567 + 1;
            if (v566) {
              v565[2] = v568;
            }
            v526[4 * __srcb + 2] = v564;
            *v564 = v527;
            if (!v365) {
              goto LABEL_1023;
            }
          }
          else
          {
LABEL_893:
            if (*((unsigned char *)v375 + 16) == 78)
            {
              v569 = *(llvm::Constant ****)v359;
              unsigned int v570 = *(_DWORD *)(*(void *)v359 + 8);
              if ((v570 & 0xFE) == 0x12) {
                unsigned int v570 = *((_DWORD *)*v569[2] + 2);
              }
              uint64_t v571 = *(void *)v375;
              int v572 = *(_DWORD *)(*(void *)v375 + 8);
              if ((v572 & 0xFE) == 0x12) {
                int v572 = *(_DWORD *)(**(void **)(v571 + 16) + 8);
              }
              if ((v572 ^ v570) <= 0xFF)
              {
                if (*(llvm::Constant ***)(v571 + 24) != v569[3])
                {
                  if (*((unsigned __int8 *)v359 + 16) >= 0x1Cu)
                  {
                    v573 = (void ***)*((void *)v359 + 4);
                  }
                  else if (*((unsigned __int8 *)v352 + 16) >= 0x1Cu)
                  {
                    v573 = (void ***)*((void *)v352 + 4);
                  }
                  else
                  {
                    v573 = (void ***)((char *)v375 + 24);
                  }
                  if (v573) {
                    uint64_t v603 = (uint64_t)(v573 - 3);
                  }
                  else {
                    uint64_t v603 = 0;
                  }
                  __int16 v728 = 257;
                  v359 = llvm::CastInst::Create(49, (uint64_t)v359, v571, (const char **)&v724, v603);
                }
                llvm::Value::doRAUW(v375, v359, (llvm::Value *)1);
                if (v714 >= (unint64_t)HIDWORD(v714)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *((void *)v713 + v714) = v375;
                LODWORD(v714) = v714 + 1;
                goto LABEL_951;
              }
            }
            unsigned int v574 = *((unsigned __int8 *)v352 + 16);
            if (v574 >= 0x1C)
            {
              if (v574 == 78 && *(llvm::Value **)v366 == v352) {
                goto LABEL_951;
              }
              if (v359) {
                BOOL v580 = *((unsigned __int8 *)v359 + 16) >= 0x1Cu;
              }
              else {
                BOOL v580 = 0;
              }
              if (v580) {
                v581 = v359;
              }
              else {
                v581 = v352;
              }
              for (uint64_t k = *((void *)v581 + 4); ; uint64_t k = *(void *)(k + 8))
              {
                v583 = (llvm::Instruction *)(k - 24);
                uint64_t v584 = k ? k - 24 : 0;
                if (*(unsigned char *)(v584 + 16) != 83) {
                  break;
                }
              }
              v585 = (char *)operator new(0x60uLL);
              *((_DWORD *)v585 + 13) = *((_DWORD *)v585 + 13) & 0x38000000 | 1;
              *(void *)v585 = 0;
              *((void *)v585 + 1) = 0;
              *((void *)v585 + 2) = 0;
              *((void *)v585 + 3) = v585 + 32;
              v586 = *(llvm::Constant ****)v352;
              __int16 v728 = 257;
              v587 = llvm::AddrSpaceCastInst::AddrSpaceCastInst((llvm::AddrSpaceCastInst *)(v585 + 32), v359, (llvm::Type *)v586, (const char **)&v724, v583);
              if (*(void *)v366)
              {
                **(void **)(v366 + 16) = *(void *)(v366 + 8);
                uint64_t v588 = *(void *)(v366 + 8);
                if (v588) {
                  *(void *)(v588 + 16) = *(void *)(v366 + 16);
                }
              }
              *(void *)uint64_t v366 = v587;
              uint64_t v591 = *((void *)v585 + 5);
              v590 = v585 + 40;
              uint64_t v589 = v591;
              *(void *)(v366 + 8) = v591;
              if (v591) {
                *(void *)(v589 + 16) = v366 + 8;
              }
              *(void *)(v366 + 16) = v590;
              void *v590 = v366;
              if (!v365) {
                goto LABEL_1023;
              }
            }
            else
            {
              uint64_t v575 = llvm::ConstantExpr::getAddrSpaceCast(v359, *(llvm::Constant ****)v352, 0);
              if (*(void *)v366)
              {
                **(void **)(v366 + 16) = *(void *)(v366 + 8);
                uint64_t v576 = *(void *)(v366 + 8);
                if (v576) {
                  *(void *)(v576 + 16) = *(void *)(v366 + 16);
                }
              }
              *(void *)uint64_t v366 = v575;
              if (!v575) {
                goto LABEL_951;
              }
              uint64_t v579 = *(void *)(v575 + 8);
              v577 = (void *)(v575 + 8);
              uint64_t v578 = v579;
              *(void *)(v366 + 8) = v579;
              if (v579) {
                *(void *)(v578 + 16) = v366 + 8;
              }
              *(void *)(v366 + 16) = v577;
              void *v577 = v366;
              if (!v365) {
                goto LABEL_1023;
              }
            }
          }
          continue;
        }
LABEL_676:
        if (*(void *)v366)
        {
          **(void **)(v366 + 16) = *(void *)(v366 + 8);
          uint64_t v397 = *(void *)(v366 + 8);
          if (v397) {
            *(void *)(v397 + 16) = *(void *)(v366 + 16);
          }
        }
        *(void *)uint64_t v366 = v359;
        if (!v359)
        {
LABEL_951:
          if (!v365) {
            goto LABEL_1023;
          }
          continue;
        }
        v398 = (void *)((char *)v359 + 8);
        uint64_t v399 = *((void *)v359 + 1);
        *(void *)(v366 + 8) = v399;
        if (v399) {
          *(void *)(v399 + 16) = v366 + 8;
        }
        *(void *)(v366 + 16) = v398;
        void *v398 = v366;
        if (v365) {
          continue;
        }
LABEL_1023:
        v296 = v690;
        if (!*((void *)v352 + 1)) {
          goto LABEL_1024;
        }
LABEL_1027:
        v296 += 3;
        if (v296 != v696) {
          goto LABEL_603;
        }
        v658 = (uint64_t *)v713;
        if (v714)
        {
          uint64_t v659 = 8 * v714;
          uint64_t v5 = v673;
          do
          {
            uint64_t v660 = *v658;
            v727 = 0;
            llvm::RecursivelyDeleteTriviallyDeadInstructions(v660, 0, 0, (uint64_t)&v724);
            if (v727 == &v724)
            {
              (*((void (**)(void **))v724 + 4))(&v724);
            }
            else if (v727)
            {
              (*((void (**)(void))*v727 + 5))();
            }
            ++v658;
            v659 -= 8;
          }
          while (v659);
          v658 = (uint64_t *)v713;
        }
        else
        {
          uint64_t v5 = v673;
        }
        if (v658 != (uint64_t *)&v715) {
          free(v658);
        }
        v295 = (char *)p_j;
LABEL_1054:
        if (v295 != v674) {
          free(v295);
        }
LABEL_1056:
        if (v709)
        {
          sub_1CC009394((uint64_t)v708);
          MEMORY[0x1D25D9CD0](v708[0], 8);
          char v709 = 0;
        }
        sub_1CC4D021C(&v705);
        MEMORY[0x1D25D9CD0](v705, 8);
        MEMORY[0x1D25D9CD0](v698[0], 8);
        MEMORY[0x1D25D9CD0](v700[0], 8);
        p_uint64_t j = &j;
        sub_1CBF6385C((void ***)&p_j);
        return v5;
      default:
        goto LABEL_649;
    }
  }
}

void sub_1CCD8E39C()
{
}

void sub_1CCD8E400(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD8E438(llvm::PassRegistry *a1, uint64_t a2)
{
  uint64_t v3 = a2 + 112;
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);
  sub_1CB843600(a2, v3, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::AssumptionCacheTracker::ID);

  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
}

uint64_t sub_1CCD8E4D8(uint64_t a1, llvm::LLVMContextImpl ****a2)
{
  if (llvm::FunctionPass::skipFunction((llvm::FunctionPass *)a1, a2)) {
    return 0;
  }
  uint64_t v5 = *(uint64_t **)(a1 + 8);
  uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass((llvm::PMDataManager *)v5[3], &llvm::DominatorTreeWrapperPass::ID, 1);
  if (AnalysisPass)
  {
    uint64_t AnalysisPass = (*(uint64_t (**)(uint64_t, void *))(*(void *)AnalysisPass + 96))(AnalysisPass, &llvm::DominatorTreeWrapperPass::ID);
    uint64_t v5 = *(uint64_t **)(a1 + 8);
  }
  if (AnalysisPass) {
    uint64_t v7 = AnalysisPass + 32;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *v5;
  uint64_t v9 = v5[1];
  if (*v5 == v9)
  {
LABEL_11:
    uint64_t v10 = 0;
  }
  else
  {
    while (*(char **)v8 != llvm::AssumptionCacheTracker::ID)
    {
      v8 += 16;
      if (v8 == v9) {
        goto LABEL_11;
      }
    }
    uint64_t v10 = *(void *)(v8 + 8);
  }
  uint64_t v11 = (llvm::AssumptionCacheTracker *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v10 + 96))(v10, llvm::AssumptionCacheTracker::ID);
  uint64_t AssumptionCache = llvm::AssumptionCacheTracker::getAssumptionCache(v11, (llvm::Function *)a2);
  int v13 = *(uint64_t **)(a1 + 8);
  uint64_t v14 = *v13;
  uint64_t v15 = v13[1];
  if (v14 == v15)
  {
LABEL_16:
    uint64_t v16 = 0;
  }
  else
  {
    while (*(char **)v14 != llvm::TargetTransformInfoWrapperPass::ID)
    {
      v14 += 16;
      if (v14 == v15) {
        goto LABEL_16;
      }
    }
    uint64_t v16 = *(void *)(v14 + 8);
  }
  uint64_t v17 = (llvm::TargetTransformInfoWrapperPass *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v16 + 96))(v16, llvm::TargetTransformInfoWrapperPass::ID);
  TTI = llvm::TargetTransformInfoWrapperPass::getTTI(v17, (const Function *)a2);
  int v19 = *(_DWORD *)(a1 + 28);
  v20[0] = AssumptionCache;
  v20[1] = v7;
  v20[2] = TTI;
  v20[3] = 0;
  int v21 = v19;
  return sub_1CCD8A8C0((uint64_t)v20, (uint64_t)a2);
}

uint64_t sub_1CCD8E670(uint64_t a1, llvm::DataLayout *this, uint64_t a3)
{
  int v6 = *(_DWORD *)(a1 + 20);
  if ((v6 & 0x40000000) != 0) {
    uint64_t v7 = *(uint64_t **)(a1 - 8);
  }
  else {
    uint64_t v7 = (uint64_t *)(a1 - 32 * (v6 & 0x7FFFFFF));
  }
  uint64_t v8 = *v7;
  unsigned int v9 = *(unsigned __int8 *)(*v7 + 16);
  unsigned int v10 = v9 - 28;
  BOOL v12 = v9 < 0x1C && v9 != 5;
  if (!v8 || v12) {
    return 0;
  }
  if (v9 <= 0x1B) {
    unsigned int v10 = *(unsigned __int16 *)(v8 + 18);
  }
  if (v10 != 47) {
    return 0;
  }
  unsigned int v13 = *(unsigned __int8 *)(a1 + 16);
  if (v13 > 0x1B)
  {
    int v14 = v13 - 28;
    if ((v6 & 0x40000000) != 0) {
      goto LABEL_17;
    }
LABEL_19:
    uint64_t v15 = (llvm::Type ***)(a1 - 32 * (v6 & 0x7FFFFFF));
    goto LABEL_20;
  }
  int v14 = *(unsigned __int16 *)(a1 + 18);
  if ((v6 & 0x40000000) == 0) {
    goto LABEL_19;
  }
LABEL_17:
  uint64_t v15 = *(llvm::Type ****)(a1 - 8);
LABEL_20:
  if (!llvm::CastInst::isNoopCast(v14, **v15, *(llvm::Type **)a1, this)) {
    return 0;
  }
  unsigned int v16 = *(unsigned __int8 *)(v8 + 16);
  int v17 = v16 > 0x1B ? v16 - 28 : *(unsigned __int16 *)(v8 + 18);
  int v18 = *(_DWORD *)(v8 + 20);
  int v19 = (v18 & 0x40000000) != 0 ? *(llvm::Type ****)(v8 - 8) : (llvm::Type ***)(v8 - 32 * (v18 & 0x7FFFFFF));
  if (!llvm::CastInst::isNoopCast(v17, **v19, *(llvm::Type **)v8, this)) {
    return 0;
  }
  int v21 = *(uint64_t (**)(void))(**(void **)a3 + 136);

  return v21();
}

void *sub_1CCD8E820(void *result, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a2 + 16);
  BOOL v3 = v2 >= 0x1C;
  unsigned int v4 = v2 - 28;
  if (!v3) {
    unsigned int v4 = *(unsigned __int16 *)(a2 + 18);
  }
  switch(v4)
  {
    case '0':
      int v7 = *(_DWORD *)(a2 + 20);
      if ((v7 & 0x40000000) != 0) {
        uint64_t v8 = *(uint64_t **)(a2 - 8);
      }
      else {
        uint64_t v8 = (uint64_t *)(a2 - 32 * (v7 & 0x7FFFFFF));
      }
      uint64_t v15 = *v8;
      int v16 = *(_DWORD *)(v15 + 20);
      if ((v16 & 0x40000000) != 0) {
        int v6 = *(void **)(v15 - 8);
      }
      else {
        int v6 = (void *)(v15 - 32 * (v16 & 0x7FFFFFF));
      }
      goto LABEL_14;
    case '3':
    case '4':
    case '5':
    case '6':
      __break(1u);
      JUMPOUT(0x1CCD8E944);
    case '7':
      int v11 = *(_DWORD *)(a2 + 20);
      if ((v11 & 0x40000000) != 0)
      {
        unsigned int v13 = *(char **)(a2 - 8);
        uint64_t v12 = v11 & 0x7FFFFFF;
      }
      else
      {
        uint64_t v12 = v11 & 0x7FFFFFF;
        unsigned int v13 = (char *)(a2 - 32 * v12);
      }
      void *result = result + 2;
      result[1] = 0x200000000;
      return (void *)sub_1CC27D070((uint64_t)result, v13, &v13[32 * v12]);
    case '8':
      int v5 = *(_DWORD *)(a2 + 20);
      goto LABEL_13;
    case '9':
      int v9 = *(_DWORD *)(a2 + 20);
      if ((v9 & 0x40000000) != 0) {
        uint64_t v10 = *(void *)(a2 - 8);
      }
      else {
        uint64_t v10 = a2 - 32 * (v9 & 0x7FFFFFF);
      }
      uint64_t v17 = *(void *)(v10 + 32);
      uint64_t v18 = *(void *)(v10 + 64);
      result[2] = v17;
      void *result = result + 2;
      result[3] = v18;
      uint64_t v14 = 0x200000002;
      goto LABEL_15;
    default:
      int v5 = *(_DWORD *)(a2 + 20);
      if ((v5 & 0x40000000) != 0) {
        int v6 = *(void **)(a2 - 8);
      }
      else {
LABEL_13:
      }
        int v6 = (void *)(a2 - 32 * (v5 & 0x7FFFFFF));
LABEL_14:
      result[2] = *v6;
      void *result = result + 2;
      uint64_t v14 = 0x200000001;
LABEL_15:
      result[1] = v14;
      return result;
  }
}

uint64_t sub_1CCD8E96C(uint64_t result, unsigned char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = result;
  unint64_t v19 = (unint64_t)a2;
  if (a2 && a2[16] == 5)
  {
    uint64_t result = sub_1CCD8EB3C((uint64_t)a2, *(llvm::DataLayout **)(result + 24), *(void **)(result + 16));
    if (result)
    {
      uint64_t v18 = a2;
      uint64_t result = sub_1CD691094(a4, &v18, (uint64_t)v20);
      if (v21) {
        return sub_1CD76C1A4(a3, (uint64_t)a2, 0);
      }
    }
  }
  else
  {
    unsigned int v8 = *(_DWORD *)(*(void *)a2 + 8);
    if ((v8 & 0xFE) == 0x12) {
      unsigned int v8 = *(_DWORD *)(**(void **)(*(void *)a2 + 16) + 8);
    }
    if (*(_DWORD *)(result + 32) == v8 >> 8)
    {
      uint64_t result = sub_1CCD8EB3C((uint64_t)a2, *(llvm::DataLayout **)(result + 24), *(void **)(result + 16));
      if (result)
      {
        uint64_t result = sub_1CBF5FAF4(a4, &v19, (uint64_t)v20);
        if (v21)
        {
          v20[0] = 0;
          uint64_t v9 = *(unsigned int *)(a3 + 8);
          if (v9 >= *(_DWORD *)(a3 + 12))
          {
            uint64_t result = sub_1CC13CB2C(a3, &v19, v20);
            uint64_t v10 = (unsigned char *)v19;
          }
          else
          {
            uint64_t v10 = (unsigned char *)v19;
            *(void *)(*(void *)a3 + 8 * v9) = v19 & 0xFFFFFFFFFFFFFFFBLL;
            *(_DWORD *)(a3 + 8) = v9 + 1;
          }
          uint64_t v11 = *((_DWORD *)v10 + 5) & 0x7FFFFFF;
          if (v11)
          {
            uint64_t v12 = 0;
            uint64_t v13 = 32 * v11;
            do
            {
              int v14 = *((_DWORD *)v10 + 5);
              if ((v14 & 0x40000000) != 0) {
                uint64_t v15 = (unsigned char *)*((void *)v10 - 1);
              }
              else {
                uint64_t v15 = &v10[-32 * (v14 & 0x7FFFFFF)];
              }
              uint64_t v16 = *(void *)&v15[v12];
              if (v16) {
                BOOL v17 = *(unsigned char *)(v16 + 16) == 5;
              }
              else {
                BOOL v17 = 0;
              }
              if (v17)
              {
                uint64_t result = sub_1CCD8EB3C(v16, *(llvm::DataLayout **)(v7 + 24), *(void **)(v7 + 16));
                if (result)
                {
                  uint64_t v18 = (unsigned char *)v16;
                  uint64_t result = sub_1CD691094(a4, &v18, (uint64_t)v20);
                  if (v21) {
                    uint64_t result = sub_1CD76C1A4(a3, v16, 0);
                  }
                }
              }
              v12 += 32;
            }
            while (v13 != v12);
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_1CCD8EB3C(uint64_t a1, llvm::DataLayout *a2, void *a3)
{
  unsigned int v3 = *(unsigned __int8 *)(a1 + 16);
  if (v3 <= 0x1B && v3 != 5) {
    return 0;
  }
  unsigned int v6 = v3 - 28;
  if (v3 < 0x1C) {
    unsigned int v6 = *(unsigned __int16 *)(a1 + 18);
  }
  uint64_t result = 1;
  switch(v6)
  {
    case '0':
      return sub_1CCD8E670(a1, a2, (uint64_t)a3);
    case '1':
    case '2':
    case '7':
      return result;
    case '3':
    case '4':
    case '5':
    case '6':
      goto LABEL_13;
    case '8':
      if (v3 != 84) {
        return 0;
      }
      uint64_t v8 = *(void *)(a1 - 32);
      if (!v8
        || *(unsigned char *)(v8 + 16)
        || *(void *)(v8 + 24) != *(void *)(a1 + 72)
        || (*(unsigned char *)(v8 + 33) & 0x20) == 0)
      {
        return 0;
      }
      BOOL v9 = *(_DWORD *)(v8 + 36) == 252;
      goto LABEL_22;
    case '9':
      BOOL v9 = *(unsigned char *)(*(void *)a1 + 8) == 15;
LABEL_22:
      uint64_t result = v9;
      break;
    default:
      if (v6 != 34) {
LABEL_13:
      }
        uint64_t result = (*(unsigned int (**)(void, uint64_t))(*(void *)*a3 + 152))(*a3, a1) != -1;
      break;
  }
  return result;
}

uint64_t sub_1CCD8EC78(uint64_t a1, uint64_t *a2, int a3)
{
  while (1)
  {
    uint64_t v3 = *a2;
    unsigned int v4 = *(_DWORD *)(*a2 + 8);
    unsigned int v5 = v4;
    if ((v4 & 0xFE) == 0x12) {
      unsigned int v5 = *(_DWORD *)(**(void **)(v3 + 16) + 8);
    }
    unsigned int v6 = v5 >> 8;
    if (v5 >> 8 == a3) {
      return 1;
    }
    unsigned int v7 = *((unsigned __int8 *)a2 + 16);
    if (v7 - 11 < 2) {
      return 1;
    }
    int v8 = *(_DWORD *)(a1 + 32);
    if (v6 != v8 && v8 != a3) {
      return 0;
    }
    if (v7 == 19) {
      return 1;
    }
    if (v7 <= 0x1B && v7 != 5) {
      return 0;
    }
    int v10 = v7 > 0x1B ? v7 - 28 : *((unsigned __int16 *)a2 + 9);
    if (v10 != 50) {
      break;
    }
    int v11 = *((_DWORD *)a2 + 5);
    if ((v11 & 0x40000000) != 0) {
      uint64_t v12 = (uint64_t *)*(a2 - 1);
    }
    else {
      uint64_t v12 = &a2[-4 * (v11 & 0x7FFFFFF)];
    }
    a2 = (uint64_t *)*v12;
  }
  if (v10 == 48)
  {
    if ((v4 & 0xFE) == 0x12) {
      unsigned int v4 = *(_DWORD *)(**(void **)(v3 + 16) + 8);
    }
    if (v8 == v4 >> 8) {
      return 1;
    }
  }
  return 0;
}

llvm::Constant *sub_1CCD8ED50(llvm::ConstantExpr *a1, llvm::Type *a2, uint64_t *a3)
{
  int v4 = (int)a2;
  v84[4] = *MEMORY[0x1E4F143B8];
  unint64_t v6 = *(void *)a1;
  if (*(unsigned char *)(*(void *)a1 + 8) == 15)
  {
    unsigned int v7 = *(llvm::PointerType **)(v6 + 24);
    if (v7) {
      unint64_t v8 = llvm::PointerType::get(v7, a2);
    }
    else {
      unint64_t v8 = llvm::PointerType::get(*(uint64_t ***)v6, a2);
    }
    unint64_t v6 = v8;
  }
  switch(*((_WORD *)a1 + 9))
  {
    case '0':
      uint64_t v9 = *((void *)a1 - 4 * (*((_DWORD *)a1 + 5) & 0x7FFFFFF));
      int v10 = (llvm::ConstantExpr **)(v9 - 32 * (*(_DWORD *)(v9 + 20) & 0x7FFFFFF));
      goto LABEL_8;
    case '1':
      uint64_t v13 = *a3;
      uint64_t v14 = *((unsigned int *)a3 + 4);
      if (!v14) {
        goto LABEL_92;
      }
      uint64_t v15 = *((void *)a1 - 4 * (*((_DWORD *)a1 + 5) & 0x7FFFFFF));
      uint64_t v16 = ((v15 >> 4) ^ (v15 >> 9)) & (v14 - 1);
      BOOL v17 = (void *)(v13 + (v16 << 6));
      uint64_t v18 = v17[3];
      if (v15 == v18) {
        goto LABEL_93;
      }
      int v19 = 1;
      while (v18 != -4096)
      {
        int v20 = v16 + v19++;
        uint64_t v16 = v20 & (v14 - 1);
        BOOL v17 = (void *)(v13 + (v16 << 6));
        uint64_t v18 = v17[3];
        if (v15 == v18) {
          goto LABEL_93;
        }
      }
LABEL_92:
      BOOL v17 = (void *)(v13 + (v14 << 6));
LABEL_93:
      uint64_t v82 = (void *)6;
      if (v17 == (void *)(v13 + (v14 << 6)))
      {
        int v64 = 0;
        unint64_t v66 = 0;
        int v11 = 0;
        uint64_t v83 = 0;
        v84[0] = 0;
      }
      else
      {
        int v64 = 0;
        int v11 = (llvm::ConstantExpr *)v17[7];
        uint64_t v83 = 0;
        v84[0] = v11;
        if (v11 == (llvm::ConstantExpr *)-8192
          || (v11 != (llvm::ConstantExpr *)-4096 ? (BOOL v65 = v11 == 0) : (BOOL v65 = 1), v65))
        {
          unint64_t v66 = 0;
        }
        else
        {
          unint64_t v66 = v17[5] & 0xFFFFFFFFFFFFFFF8;
          uint64_t v83 = *(void *)v66;
          int v64 = (void *)v83;
          *(void *)unint64_t v66 = &v82;
          uint64_t v82 = (void *)(v66 | 6);
          if (v64) {
            *int v64 = *v64 & 7 | (unint64_t)&v83;
          }
        }
      }
      if (v11 != (llvm::ConstantExpr *)-8192 && v11 != (llvm::ConstantExpr *)-4096 && v11 != 0)
      {
        *(void *)unint64_t v66 = v64;
        if (v83)
        {
          *(void *)uint64_t v83 = *(void *)v83 & 7 | v66;
        }
        else
        {
          uint64_t v69 = v84[0];
          unsigned int v70 = ***(int32x2_t ****)v84[0];
          unint64_t v71 = (unint64_t)v70[303];
          if (v71 <= v66)
          {
            uint64_t v72 = v70[305].u32[0];
            if (v71 + 16 * v72 > v66)
            {
              unsigned int v73 = v72 - 1;
              LODWORD(v74) = v73 & ((LODWORD(v84[0]) >> 4) ^ (LODWORD(v84[0]) >> 9));
              int v75 = (uint64_t *)(v71 + 16 * v74);
              uint64_t v76 = *v75;
              if (v84[0] == *v75)
              {
LABEL_122:
                *int v75 = -8192;
                v70[304] = vadd_s32(v70[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v69 = v84[0];
              }
              else
              {
                int v77 = 1;
                while (v76 != -4096)
                {
                  int v78 = v74 + v77++;
                  uint64_t v74 = v78 & v73;
                  uint64_t v76 = *(void *)(v71 + 16 * v74);
                  if (v84[0] == v76)
                  {
                    int v75 = (uint64_t *)(v71 + 16 * v74);
                    goto LABEL_122;
                  }
                }
              }
              *(unsigned char *)(v69 + 17) &= ~1u;
            }
          }
        }
      }
      if (!v11) {
        return (llvm::Constant *)llvm::ConstantExpr::getAddrSpaceCast(a1, (llvm::Constant ***)v6, 0);
      }
      if (*(void *)v11 == v6) {
        return v11;
      }
      return sub_1CC56C0C0((llvm *)0x31, v11, (llvm::Constant *)v6, 0);
    case '2':
      int v10 = (llvm::ConstantExpr **)((char *)a1 - 32 * (*((_DWORD *)a1 + 5) & 0x7FFFFFF));
LABEL_8:
      int v11 = *v10;
      if (*(void *)*v10 == v6) {
        return v11;
      }
      return sub_1CC56C0C0((llvm *)0x31, v11, (llvm::Constant *)v6, 0);
    case '9':
      unint64_t v21 = *((_DWORD *)a1 + 5) & 0x7FFFFFF;
      int v22 = (llvm::ConstantExpr **)((char *)a1 - 32 * v21);
      uint64_t v23 = v22[4];
      uint64_t v24 = v22[8];
      unsigned int v25 = *(_DWORD *)(*(void *)v23 + 8);
      if ((v25 & 0xFE) == 0x12) {
        unsigned int v25 = *(_DWORD *)(**(void **)(*(void *)v23 + 16) + 8);
      }
      int v26 = *(_DWORD *)(*(void *)v24 + 8);
      if ((v26 & 0xFE) == 0x12) {
        int v26 = *(_DWORD *)(**(void **)(*(void *)v24 + 16) + 8);
      }
      if ((v26 ^ v25) > 0xFF) {
        goto LABEL_27;
      }
      int v27 = *v22;
      AddrSpaceCast = (llvm::PoisonValue **)llvm::ConstantExpr::getAddrSpaceCast(v23, (llvm::Constant ***)v6, 0);
      uint64_t v29 = (llvm::Constant *)llvm::ConstantExpr::getAddrSpaceCast(v24, (llvm::Constant ***)v6, 0);
      return llvm::ConstantExpr::getSelect(v27, AddrSpaceCast, v29, 0, v30);
    default:
      unint64_t v21 = *((_DWORD *)a1 + 5) & 0x7FFFFFF;
LABEL_27:
      uint64_t v82 = v84;
      uint64_t v83 = 0x400000000;
      if (!v21) {
        return 0;
      }
      v79[0] = v4;
      LODWORD(v31) = 0;
      unint64_t v32 = 0;
      char v33 = 0;
      break;
  }
  do
  {
    uint64_t v34 = *((void *)a1 + 4 * v32 + -4 * v21);
    uint64_t v35 = *a3;
    uint64_t v36 = *((unsigned int *)a3 + 4);
    if (v36)
    {
      uint64_t v37 = (v36 - 1) & ((v34 >> 4) ^ (v34 >> 9));
      char v38 = (void *)(v35 + (v37 << 6));
      uint64_t v39 = v38[3];
      if (v34 == v39) {
        goto LABEL_36;
      }
      int v40 = 1;
      while (v39 != -4096)
      {
        int v41 = v37 + v40++;
        uint64_t v37 = v41 & (v36 - 1);
        char v38 = (void *)(v35 + (v37 << 6));
        uint64_t v39 = v38[3];
        if (v34 == v39) {
          goto LABEL_36;
        }
      }
    }
    char v38 = (void *)(v35 + (v36 << 6));
LABEL_36:
    *(void *)&v79[1] = 6;
    if (v38 == (void *)(v35 + (v36 << 6)))
    {
      long long v42 = 0;
      unint64_t v43 = 0;
      uint64_t v80 = 0;
      uint64_t v81 = 0;
    }
    else
    {
      long long v42 = 0;
      unint64_t v43 = (int32x2_t ****)v38[7];
      uint64_t v80 = 0;
      uint64_t v81 = v43;
      if (v43 != (int32x2_t ****)-8192 && v43 != (int32x2_t ****)-4096 && v43 != 0)
      {
        unint64_t v45 = v38[5] & 0xFFFFFFFFFFFFFFF8;
        uint64_t v80 = *(unint64_t **)v45;
        *(void *)unint64_t v45 = &v79[1];
        *(void *)&v79[1] = v45 | 6;
        long long v42 = v80;
        if (v80) {
          *uint64_t v80 = *v80 & 7 | (unint64_t)&v80;
        }
        unint64_t v43 = v81;
      }
    }
    if (v43 != (int32x2_t ****)-8192 && v43 != (int32x2_t ****)-4096 && v43 != 0)
    {
      unint64_t v49 = *(void *)&v79[1] & 0xFFFFFFFFFFFFFFF8;
      *(void *)(*(void *)&v79[1] & 0xFFFFFFFFFFFFFFF8) = v42;
      if (v80)
      {
        *uint64_t v80 = *v80 & 7 | v49;
      }
      else
      {
        uint64_t v50 = v81;
        unsigned int v51 = ***v81;
        unint64_t v52 = (unint64_t)v51[303];
        if (v52 <= v49)
        {
          uint64_t v53 = v51[305].u32[0];
          if (v52 + 16 * v53 > v49)
          {
            unsigned int v54 = v53 - 1;
            LODWORD(v55) = v54 & ((v81 >> 4) ^ (v81 >> 9));
            int v56 = (int32x2_t *****)(v52 + 16 * v55);
            uint64_t v57 = *v56;
            if (v81 == *v56)
            {
LABEL_69:
              const llvm::SCEV *v56 = (int32x2_t ****)-8192;
              v51[304] = vadd_s32(v51[304], (int32x2_t)0x1FFFFFFFFLL);
              uint64_t v50 = v81;
            }
            else
            {
              int v58 = 1;
              while (v57 != (int32x2_t ****)-4096)
              {
                int v59 = v55 + v58++;
                uint64_t v55 = v59 & v54;
                uint64_t v57 = *(int32x2_t *****)(v52 + 16 * v55);
                if (v81 == v57)
                {
                  int v56 = (int32x2_t *****)(v52 + 16 * v55);
                  goto LABEL_69;
                }
              }
            }
            *((unsigned char *)v50 + 17) &= ~1u;
          }
        }
      }
    }
    if (v43)
    {
      if (v31 >= HIDWORD(v83)) {
        goto LABEL_79;
      }
LABEL_54:
      *((void *)v82 + v31) = v43;
      char v33 = 1;
      goto LABEL_76;
    }
    if (*(unsigned char *)(v34 + 16) != 5 || v34 == 0)
    {
      unsigned int v48 = HIDWORD(v83);
    }
    else
    {
      uint64_t v60 = sub_1CCD8ED50(v34, v79[0], a3);
      LODWORD(v31) = v83;
      unsigned int v48 = HIDWORD(v83);
      if (v60)
      {
        unint64_t v43 = (int32x2_t ****)v60;
        if (v83 >= HIDWORD(v83)) {
LABEL_79:
        }
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        goto LABEL_54;
      }
    }
    if (v31 >= v48) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v82 + v31) = v34;
LABEL_76:
    uint64_t v31 = (v83 + 1);
    LODWORD(v83) = v83 + 1;
    ++v32;
    unint64_t v21 = *((_DWORD *)a1 + 5) & 0x7FFFFFF;
  }
  while (v32 < v21);
  unsigned int v61 = v82;
  if (v33)
  {
    if (*((_WORD *)a1 + 9) == 34)
    {
      uint64_t v62 = 24;
      if (*((unsigned char *)a1 + 16) == 62) {
        uint64_t v62 = 64;
      }
      unsigned int v63 = *(llvm::Type **)((char *)a1 + v62);
    }
    else
    {
      unsigned int v63 = 0;
    }
    int v11 = llvm::ConstantExpr::getWithOperands(a1, (llvm::ConstantExpr **)v82, v31, (llvm::Constant ***)v6, 0, v63);
    unsigned int v61 = v82;
  }
  else
  {
    int v11 = 0;
  }
  if (v61 != v84) {
    free(v61);
  }
  return v11;
}

llvm::UndefValue *sub_1CCD8F540(unsigned __int8 **a1, llvm::Type *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *a1;
  uint64_t v10 = *(void *)*a1;
  int v11 = *(llvm::PointerType **)(v10 + 24);
  if (v11) {
    uint64_t v12 = (llvm::Constant ***)llvm::PointerType::get(v11, a2);
  }
  else {
    uint64_t v12 = (llvm::Constant ***)llvm::PointerType::get(*(uint64_t ***)v10, a2);
  }
  uint64_t v13 = (llvm::UndefValue *)v12;
  if (v9[16] <= 0x14u)
  {
    return (llvm::UndefValue *)llvm::ConstantExpr::getAddrSpaceCast((llvm::ConstantExpr *)v9, v12, 0);
  }
  uint64_t v14 = *a3;
  uint64_t v15 = *((unsigned int *)a3 + 4);
  if (!v15) {
    goto LABEL_13;
  }
  uint64_t v16 = (v15 - 1) & ((v9 >> 4) ^ (v9 >> 9));
  BOOL v17 = (void *)(v14 + (v16 << 6));
  uint64_t v18 = (unsigned __int8 *)v17[3];
  if (v9 != v18)
  {
    int v19 = 1;
    while (v18 != (unsigned __int8 *)-4096)
    {
      int v20 = v16 + v19++;
      uint64_t v16 = v20 & (v15 - 1);
      BOOL v17 = (void *)(v14 + (v16 << 6));
      uint64_t v18 = (unsigned __int8 *)v17[3];
      if (v9 == v18) {
        goto LABEL_14;
      }
    }
LABEL_13:
    BOOL v17 = (void *)(v14 + (v15 << 6));
  }
LABEL_14:
  uint64_t v52 = 6;
  if (v17 == (void *)(v14 + (v15 << 6)))
  {
    int v22 = 0;
    unint64_t v25 = 0;
    uint64_t v23 = 0;
    uint64_t v53 = 0;
    unsigned int v54 = 0;
  }
  else
  {
    int v22 = 0;
    uint64_t v23 = (llvm::Value *)v17[7];
    uint64_t v53 = 0;
    unsigned int v54 = (int32x2_t ****)v23;
    if (v23 == (llvm::Value *)-8192 || (v23 != (llvm::Value *)-4096 ? (BOOL v24 = v23 == 0) : (BOOL v24 = 1), v24))
    {
      unint64_t v25 = 0;
    }
    else
    {
      unint64_t v25 = v17[5] & 0xFFFFFFFFFFFFFFF8;
      uint64_t v53 = *(unint64_t **)v25;
      int v22 = v53;
      *(void *)unint64_t v25 = &v52;
      uint64_t v52 = v25 | 6;
      if (v22) {
        *int v22 = *v22 & 7 | (unint64_t)&v53;
      }
    }
  }
  if (v23 != (llvm::Value *)-8192 && v23 != (llvm::Value *)-4096 && v23 != 0)
  {
    *(void *)unint64_t v25 = v22;
    if (v53)
    {
      unint64_t *v53 = *v53 & 7 | v25;
    }
    else
    {
      int v27 = v54;
      int v28 = ***v54;
      unint64_t v29 = (unint64_t)v28[303];
      if (v29 <= v25)
      {
        uint64_t v30 = v28[305].u32[0];
        if (v29 + 16 * v30 > v25)
        {
          unsigned int v31 = v30 - 1;
          LODWORD(v32) = v31 & ((v54 >> 4) ^ (v54 >> 9));
          char v33 = (int32x2_t *****)(v29 + 16 * v32);
          uint64_t v34 = *v33;
          if (v54 == *v33)
          {
LABEL_39:
            char *v33 = (int32x2_t ****)-8192;
            v28[304] = vadd_s32(v28[304], (int32x2_t)0x1FFFFFFFFLL);
            int v27 = v54;
          }
          else
          {
            int v35 = 1;
            while (v34 != (int32x2_t ****)-4096)
            {
              int v36 = v32 + v35++;
              uint64_t v32 = v36 & v31;
              uint64_t v34 = *(int32x2_t *****)(v29 + 16 * v32);
              if (v54 == v34)
              {
                char v33 = (int32x2_t *****)(v29 + 16 * v32);
                goto LABEL_39;
              }
            }
          }
          *((unsigned char *)v27 + 17) &= ~1u;
        }
      }
    }
  }
  if (!v23)
  {
    uint64_t v37 = (uint64_t)a1[3];
    uint64_t v52 = 0;
    if (sub_1CD553C1C(*(void *)a4, *(_DWORD *)(a4 + 16), v37, (uint64_t)v9, &v52)) {
      BOOL v39 = v52 == *(void *)a4 + 24 * *(unsigned int *)(a4 + 16);
    }
    else {
      BOOL v39 = 1;
    }
    if (v39)
    {
      unsigned int v40 = *(_DWORD *)(a5 + 8);
      if (v40 >= *(_DWORD *)(a5 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a5 + 8 * v40) = a1;
      ++*(_DWORD *)(a5 + 8);
      return llvm::UndefValue::get(v13, v38);
    }
    else
    {
      int v41 = (llvm::Type *)*(unsigned int *)(v52 + 16);
      long long v42 = *(llvm::PointerType **)(*(void *)v9 + 24);
      if (v42) {
        unint64_t v43 = llvm::PointerType::get(v42, v41);
      }
      else {
        unint64_t v43 = llvm::PointerType::get(**(uint64_t ****)v9, v41);
      }
      long long v44 = (llvm::Type *)v43;
      unint64_t v45 = operator new(0x60uLL);
      v45[13] = v45[13] & 0x38000000 | 1;
      uint64_t v23 = (llvm::Value *)(v45 + 8);
      *(void *)unint64_t v45 = 0;
      *((void *)v45 + 1) = 0;
      *((void *)v45 + 2) = 0;
      *((void *)v45 + 3) = v45 + 8;
      __int16 v55 = 257;
      llvm::AddrSpaceCastInst::AddrSpaceCastInst((llvm::AddrSpaceCastInst *)(v45 + 8), (llvm::Value *)v9, v44, (const char **)&v52, 0);
      uint64_t v46 = *(void *)(v37 + 40);
      *((void *)v45 + 9) = v46;
      *(_WORD *)(v46 + 18) &= ~0x8000u;
      if ((*((unsigned char *)v45 + 55) & 0x10) != 0)
      {
        uint64_t v50 = *(void *)(v46 + 56);
        if (v50)
        {
          unsigned int v51 = *(llvm::ValueSymbolTable **)(v50 + 104);
          if (v51) {
            llvm::ValueSymbolTable::reinsertValue(v51, v23);
          }
        }
      }
      uint64_t v48 = *(void *)(v37 + 24);
      uint64_t v47 = (void *)(v37 + 24);
      *((void *)v45 + 7) = v48;
      *((void *)v45 + 8) = v47;
      unint64_t v49 = (char *)(v45 + 14);
      *(void *)(v48 + 8) = v49;
      *uint64_t v47 = v49;
    }
  }
  return v23;
}

uint64_t sub_1CCD8F904()
{
  char v3 = 0;
  int v4 = &v3;
  int v2 = 2;
  v1.n128_u64[0] = (unint64_t)"The default address space is assumed as the flat address space. This is mainly for test purpose.";
  v1.n128_u64[1] = 96;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCF2E68, "assume-default-is-flat-addrspace", &v4, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF2E68, &dword_1CB82C000);
}

void sub_1CCD8F990(llvm *a1)
{
  llvm::initializeAssumptionCacheTrackerPass((uint64_t)a1);
  llvm::initializeDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializeTargetLibraryInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeOptimizationRemarkEmitterWrapperPassPass(a1, v2);
  operator new();
}

uint64_t sub_1CCD8FA48(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF2F30;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263E5C8;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF2F38, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD8F990;
    v5[1] = &PassRegistry;
    int v4 = v5;
    std::__call_once(&qword_1EBCF2F38, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void llvm::InstSimplifyPass::run()
{
}

uint64_t sub_1CCD8FC50(uint64_t a1)
{
  v19[48] = *MEMORY[0x1E4F143B8];
  __n128 v1 = &v15;
  uint64_t v15 = v19;
  uint64_t v16 = v19;
  uint64_t v17 = 8;
  int v18 = 0;
  int v2 = &v10;
  uint64_t v10 = v14;
  int v11 = v14;
  uint64_t v12 = 8;
  int v13 = 0;
  uint64_t v3 = a1 + 72;
  do
  {
    int v4 = v2;
    if (*(void *)(a1 + 80) != v3) {
      llvm::DominatorTreeBase<llvm::BasicBlock,false>::isReachableFromEntry();
    }
    unsigned int v5 = v1[1];
    if (v5 == *v1) {
      goto LABEL_5;
    }
    uint64_t v6 = *((unsigned int *)v1 + 4);
    if (v6 < 0x21 || 4 * (*((_DWORD *)v1 + 5) - *((_DWORD *)v1 + 6)) >= v6)
    {
      memset(v5, 255, 8 * v6);
LABEL_5:
      *((_DWORD *)v1 + 5) = 0;
      *((_DWORD *)v1 + 6) = 0;
      goto LABEL_6;
    }
    llvm::SmallPtrSetImplBase::shrink_and_clear((void **)v1);
LABEL_6:
    int v2 = v1;
    __n128 v1 = (void **)v4;
  }
  while (*((_DWORD *)v4 + 5) != *((_DWORD *)v4 + 6));
  if (v11 != v10) {
    free(v11);
  }
  if (v16 != v15) {
    free(v16);
  }
  return 0;
}

void sub_1CCD905CC()
{
}

void sub_1CCD9060C(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD90644(llvm::PassRegistry *a1, uint64_t a2)
{
  v4[0] = &unk_1F2617E40;
  v4[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v4);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::AssumptionCacheTracker::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetLibraryInfoWrapperPass::ID);

  sub_1CB843600(a2, a2, (uint64_t)&llvm::OptimizationRemarkEmitterWrapperPass::ID);
}

uint64_t sub_1CCD906F8(llvm::FunctionPass *a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if ((llvm::FunctionPass::skipFunction(a1, (llvm::LLVMContextImpl ****)a2) & 1) == 0)
  {
    unsigned int v5 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v6 = *v5;
    uint64_t v7 = v5[1];
    if (v6 == v7)
    {
LABEL_6:
      uint64_t v8 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v6 != &llvm::DominatorTreeWrapperPass::ID)
      {
        v6 += 16;
        if (v6 == v7) {
          goto LABEL_6;
        }
      }
      uint64_t v8 = *(void *)(v6 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v8 + 96))(v8, &llvm::DominatorTreeWrapperPass::ID);
    uint64_t v9 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v10 = *v9;
    uint64_t v11 = v9[1];
    if (v10 == v11)
    {
LABEL_11:
      uint64_t v12 = 0;
    }
    else
    {
      while (*(char **)v10 != llvm::TargetLibraryInfoWrapperPass::ID)
      {
        v10 += 16;
        if (v10 == v11) {
          goto LABEL_11;
        }
      }
      uint64_t v12 = *(void *)(v10 + 8);
    }
    uint64_t v13 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v12 + 96))(v12, llvm::TargetLibraryInfoWrapperPass::ID);
    uint64_t v14 = v13 + 32;
    if (!*(unsigned char *)(v13 + 232))
    {
      uint64_t v15 = *(void *)(a2 + 40) + 216;
      __int16 v18 = 260;
      v17[0] = v15;
      llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v17);
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      int v30 = 0;
      long long v31 = 0u;
      long long v32 = 0u;
      long long v33 = 0u;
      *(void *)&long long v16 = -1;
      *((void *)&v16 + 1) = -1;
      *(_OWORD *)__src = v16;
      long long v22 = v16;
      long long v23 = v16;
      long long v24 = v16;
      long long v25 = v16;
      long long v26 = v16;
      *(_OWORD *)int v27 = v16;
      *(void *)&v27[13] = -1;
      sub_1CC153974((uint64_t)__src, (int *)__p);
      sub_1CD4D04B8(v14, (uint64_t)__src);
      sub_1CD4CFA4C((uint64_t *)__src);
      if (v20 < 0) {
        operator delete(__p[0]);
      }
    }
    sub_1CC1569E8(__src, v14);
  }
  return 0;
}

void sub_1CCD90BB0(llvm *a1)
{
  llvm::initializeDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializeLazyValueInfoWrapperPassPass(a1, v2);
  llvm::initializeTargetLibraryInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeAAResultsWrapperPassPass(a1, v3);
  operator new();
}

uint64_t sub_1CCD90C64(uint64_t a1, char a2, int a3)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF2F40;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263E668;
  *(_WORD *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 96) = a1 + 112;
  *(void *)(a1 + 104) = 0x1000000000;
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 240) = a1 + 248;
  if (byte_1EBD0B538) {
    a2 = 1;
  }
  *(unsigned char *)(a1 + 272) = a2;
  int v5 = dword_1EBD0B478;
  if (a3 != -1) {
    int v5 = a3;
  }
  *(_DWORD *)(a1 + 268) = v5;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF2F48, memory_order_acquire) != -1)
  {
    v9[0] = sub_1CCD90BB0;
    v9[1] = &PassRegistry;
    uint64_t v8 = v9;
    std::__call_once(&qword_1EBCF2F48, &v8, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t llvm::JumpThreadingPass::JumpThreadingPass(uint64_t this, char a2, int a3)
{
  *(_WORD *)(this + 56) = 0;
  *(void *)(this + 40) = 0;
  *(void *)(this + 48) = 0;
  *(void *)(this + 64) = this + 80;
  *(void *)(this + 72) = 0x1000000000;
  *(void *)(this + 224) = 0;
  *(void *)(this + 216) = 0;
  *(void *)(this + 208) = this + 216;
  if (byte_1EBD0B538) {
    a2 = 1;
  }
  *(unsigned char *)(this + 240) = a2;
  int v4 = dword_1EBD0B478;
  if (a3 != -1) {
    int v4 = a3;
  }
  *(_DWORD *)(this + 236) = v4;
  return this;
}

{
  int v4;

  *(_WORD *)(this + 56) = 0;
  *(void *)(this + 40) = 0;
  *(void *)(this + 48) = 0;
  *(void *)(this + 64) = this + 80;
  *(void *)(this + 72) = 0x1000000000;
  *(void *)(this + 224) = 0;
  *(void *)(this + 216) = 0;
  *(void *)(this + 208) = this + 216;
  if (byte_1EBD0B538) {
    a2 = 1;
  }
  *(unsigned char *)(this + 240) = a2;
  int v4 = dword_1EBD0B478;
  if (a3 != -1) {
    int v4 = a3;
  }
  *(_DWORD *)(this + 236) = v4;
  return this;
}

void llvm::JumpThreadingPass::run()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

uint64_t llvm::JumpThreadingPass::runImpl(uint64_t a1, llvm::Function *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, uint64_t *a9, uint64_t *a10)
{
  *(void *)a1 = a3;
  *(void *)(a1 + 8) = a4;
  *(void *)(a1 + 16) = a5;
  *(void *)(a1 + 24) = a6;
  uint64_t v13 = *(uint64_t **)(a1 + 40);
  *(void *)(a1 + 32) = a7;
  *(void *)(a1 + 40) = 0;
  if (v13)
  {
    uint64_t v14 = *v13;
    *uint64_t v13 = 0;
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    }
    MEMORY[0x1D25D9CE0](v13, 0x20C4093837F09);
  }
  uint64_t v15 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v15)
  {
    uint64_t v16 = sub_1CBF8AF10(v15);
    MEMORY[0x1D25D9CE0](v16, 0x1060C40D526B124);
  }
  *(unsigned char *)(a1 + 56) = a8;
  uint64_t v17 = *(void *)(*((void *)a2 + 5) + 112);
  unsigned int v18 = *(_DWORD *)(v17 + 32);
  if (v18 <= 1) {
    uint64_t v19 = 1;
  }
  else {
    uint64_t v19 = v18;
  }
  if (v18 <= 0x16) {
    size_t v20 = v19;
  }
  else {
    size_t v20 = 23;
  }
  int v75 = *(uint64_t **)(*((void *)a2 + 5) + 112);
  uint64_t v21 = *(unsigned int *)(v17 + 8);
  if (v21)
  {
    int v74 = a8;
    uint64_t v22 = 0;
    int v23 = 0;
    do
      int v23 = 33 * v23 + aLlvmExperiment_45[v22++];
    while (v20 != v22);
    unsigned int v24 = v21 - 1;
    uint64_t v25 = *v75;
    uint64_t v73 = *(unsigned int *)(v17 + 8);
    uint64_t v26 = *v75 + 8 * v21 + 8;
    int v27 = 1;
    int v28 = v23;
    while (1)
    {
      uint64_t v29 = v28 & v24;
      uint64_t v30 = *(void *)(v25 + 8 * v29);
      if (v30 != -8)
      {
        if (!v30) {
          goto LABEL_30;
        }
        if (*(_DWORD *)(v26 + 4 * v29) == v23
          && v20 == *(void *)v30
          && !memcmp("llvm.experimental.guard", (const void *)(v30 + *((unsigned int *)v75 + 5)), v20))
        {
          break;
        }
      }
      int v28 = v27 + v29;
      ++v27;
    }
    if (v29 == -1)
    {
      LOBYTE(v30) = 0;
LABEL_30:
      a8 = v74;
      goto LABEL_31;
    }
    a8 = v74;
    if ((int)v29 == v73) {
      goto LABEL_28;
    }
    uint64_t v30 = *(void *)(*(void *)(v25 + 8 * (int)v29) + 8);
    if (v30)
    {
      if (*(unsigned char *)(v30 + 16)) {
        goto LABEL_28;
      }
      LOBYTE(v30) = *(void *)(v30 + 8) != 0;
    }
  }
  else
  {
LABEL_28:
    LOBYTE(v30) = 0;
  }
LABEL_31:
  *(unsigned char *)(a1 + 57) = v30;
  if (a8)
  {
    uint64_t v31 = *a10;
    *a10 = 0;
    uint64_t v32 = *(void *)(a1 + 48);
    *(void *)(a1 + 48) = v31;
    if (v32)
    {
      uint64_t v33 = sub_1CBF8AF10(v32);
      MEMORY[0x1D25D9CE0](v33, 0x1060C40D526B124);
    }
    uint64_t v34 = *a9;
    *a9 = 0;
    int v35 = *(uint64_t **)(a1 + 40);
    *(void *)(a1 + 40) = v34;
    if (v35)
    {
      uint64_t v36 = *v35;
      *int v35 = 0;
      if (v36) {
        (*(void (**)(uint64_t))(*(void *)v36 + 8))(v36);
      }
      MEMORY[0x1D25D9CE0](v35, 0x20C4093837F09);
    }
  }
  if (word_1EBD0B400)
  {
    int v38 = dword_1EBD0B478;
  }
  else
  {
    uint64_t v37 = *((void *)a2 + 14);
    if (v37 && *(char *)(v37 + 13) < 0) {
      int v38 = 3;
    }
    else {
      int v38 = *(_DWORD *)(a1 + 236);
    }
  }
  *(_DWORD *)(a1 + 232) = v38;
  llvm::DomTreeUpdater::getDomTree(*(llvm::DomTreeUpdater **)(a1 + 32));
  BOOL v39 = (void *)((char *)a2 + 72);
  if (*((llvm::Function **)a2 + 10) != (llvm::Function *)((char *)a2 + 72)) {
    llvm::DominatorTreeBase<llvm::BasicBlock,false>::isReachableFromEntry();
  }
  if (!byte_1EBCF3150) {
    llvm::JumpThreadingPass::findLoopHeaders((llvm::JumpThreadingPass *)a1, a2);
  }
  uint64_t v76 = (void *)(a1 + 216);
  unsigned int v40 = (void *)*((void *)a2 + 10);
  if (v40 == v39)
  {
    char v41 = 0;
    goto LABEL_119;
  }
  char v41 = 0;
  do
  {
    uint64_t v42 = 0;
    do
    {
      if (v40) {
        unint64_t v43 = (llvm::BasicBlock *)(v40 - 3);
      }
      else {
        unint64_t v43 = 0;
      }
      uint64_t v44 = v42;
      do
      {
        uint64_t v42 = v44;
        char v45 = llvm::JumpThreadingPass::processBlock((llvm::JumpThreadingPass *)a1, v43);
        uint64_t v44 = 1;
      }
      while ((v45 & 1) != 0);
      if (v42) {
        llvm::RemoveRedundantDbgInstrs(v43, v46);
      }
      BOOL v47 = v40 == 0;
      uint64_t v48 = *((void *)a2 + 10);
      if (v48) {
        BOOL v47 = v48 - 24 == (void)v43;
      }
      if (!v47 && !llvm::DomTreeUpdater::isBBPendingDeletion(*(llvm::DomTreeUpdater **)(a1 + 32), v43))
      {
        uint64_t v49 = *((void *)v43 + 1);
        if (!v49)
        {
LABEL_75:
          sub_1CCD932C8(a1 + 64, (unint64_t)v43);
          llvm::LazyValueInfo::eraseBlock(*(llvm::LazyValueInfo **)(a1 + 16), v43);
          llvm::DeleteDeadBlock(v43, *(llvm::BasicBlock **)(a1 + 32), 0);
LABEL_76:
          uint64_t v42 = 1;
          goto LABEL_62;
        }
        while (1)
        {
          uint64_t v50 = *(void *)(v49 + 24);
          unsigned int v51 = *(unsigned __int8 *)(v50 + 16);
          BOOL v52 = v50 && v51 >= 0x1C;
          if (v52 && v51 - 29 < 0xB) {
            break;
          }
          uint64_t v49 = *(void *)(v49 + 8);
          if (!v49) {
            goto LABEL_75;
          }
        }
        unsigned int v54 = (void *)*((void *)v43 + 5);
        if (v54 != (void *)((char *)v43 + 40))
        {
          __int16 v55 = v54 - 3;
          if (!v54) {
            __int16 v55 = 0;
          }
          unsigned int v56 = *((unsigned __int8 *)v55 + 16) - 40;
          if (v56 < 0xFFFFFFF5) {
            __int16 v55 = 0;
          }
          if (v54)
          {
            if (*((unsigned char *)v55 + 16) == 30 && v56 >= 0xFFFFFFF5 && (*((_DWORD *)v55 + 5) & 0x7FFFFFF) == 1)
            {
              int v58 = (llvm *)*(v55 - 4);
              if (llvm::BasicBlock::getFirstNonPHIOrDbg(v43, 1)[16] - 29 <= 0xA)
              {
                uint64_t v60 = *(void *)(a1 + 224);
                if (v60)
                {
                  unsigned int v61 = (void *)*v76;
                  if (*v76)
                  {
                    do
                    {
                      unint64_t v62 = v61[4];
                      if ((unint64_t)v43 >= v62)
                      {
                        if (v62 >= (unint64_t)v43) {
                          goto LABEL_62;
                        }
                        ++v61;
                      }
                      unsigned int v61 = (void *)*v61;
                    }
                    while (v61);
                    goto LABEL_103;
                  }
                }
                else
                {
                  uint64_t v63 = *(unsigned int *)(a1 + 72);
                  if (v63)
                  {
                    int v64 = *(llvm::BasicBlock ***)(a1 + 64);
                    uint64_t v65 = 8 * v63;
                    while (*v64 != v43)
                    {
                      ++v64;
                      v65 -= 8;
                      if (!v65) {
                        goto LABEL_103;
                      }
                    }
                    if (v65) {
                      goto LABEL_62;
                    }
LABEL_103:
                    if (v60)
                    {
                      unint64_t v66 = (void *)(a1 + 216);
                      while (1)
                      {
                        unint64_t v66 = (void *)*v66;
                        if (!v66) {
                          break;
                        }
                        unint64_t v67 = v66[4];
                        if ((unint64_t)v58 >= v67)
                        {
                          if (v67 >= (unint64_t)v58) {
                            goto LABEL_62;
                          }
                          ++v66;
                        }
                      }
                    }
                    else
                    {
                      uint64_t v68 = *(unsigned int *)(a1 + 72);
                      if (v68)
                      {
                        uint64_t v69 = *(llvm ***)(a1 + 64);
                        uint64_t v70 = 8 * v68;
                        while (*v69 != v58)
                        {
                          ++v69;
                          v70 -= 8;
                          if (!v70) {
                            goto LABEL_115;
                          }
                        }
                        if (v70) {
                          goto LABEL_62;
                        }
                      }
                    }
                  }
                }
LABEL_115:
                if (llvm::TryToSimplifyUncondBranchFromEmptyBlock(v43, *(llvm::BasicBlock **)(a1 + 32), v59))
                {
                  llvm::RemoveRedundantDbgInstrs(v58, v71);
                  llvm::LazyValueInfo::eraseBlock(*(llvm::LazyValueInfo **)(a1 + 16), v43);
                  goto LABEL_76;
                }
              }
            }
          }
        }
      }
LABEL_62:
      unsigned int v40 = (void *)v40[1];
    }
    while (v40 != v39);
    if ((v42 & 1) == 0) {
      break;
    }
    unsigned int v40 = (void *)*((void *)a2 + 10);
    char v41 = 1;
  }
  while (v40 != v39);
LABEL_119:
  *(_DWORD *)(a1 + 72) = 0;
  sub_1CB833A08(a1 + 208, *(void **)(a1 + 216));
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 208) = v76;
  return v41 & 1;
}

uint64_t llvm::JumpThreadingPass::processBlock(llvm::JumpThreadingPass *this, llvm::BasicBlock *a2)
{
  v259[16] = *MEMORY[0x1E4F143B8];
  if (llvm::DomTreeUpdater::isBBPendingDeletion(*((llvm::DomTreeUpdater **)this + 4), a2)) {
    return 0;
  }
  uint64_t v4 = *((void *)a2 + 1);
  if (v4)
  {
    while (1)
    {
      uint64_t v5 = *(void *)(v4 + 24);
      unsigned int v6 = *(unsigned __int8 *)(v5 + 16);
      BOOL v7 = v5 && v6 >= 0x1C;
      if (v7 && v6 - 29 < 0xB) {
        break;
      }
      uint64_t v4 = *(void *)(v4 + 8);
      if (!v4) {
        goto LABEL_12;
      }
    }
  }
  else
  {
LABEL_12:
    uint64_t v9 = *(void *)(*((void *)a2 + 7) + 80);
    if (v9) {
      uint64_t v10 = (llvm::BasicBlock *)(v9 - 24);
    }
    else {
      uint64_t v10 = 0;
    }
    if (v10 != a2) {
      return 0;
    }
  }
  if (llvm::JumpThreadingPass::maybeMergeBasicBlockIntoOnlyPred((llvm::LazyValueInfo **)this, (llvm::BlockAddress **)a2) & 1) != 0|| (llvm::JumpThreadingPass::tryToUnfoldSelectInCurrBB(this, a2) & 1) != 0|| *((unsigned char *)this + 57) && (llvm::JumpThreadingPass::processGuards(this, a2))
  {
    return 1;
  }
  uint64_t v17 = (void *)((char *)a2 + 40);
  uint64_t v16 = (llvm::BasicBlock *)*((void *)a2 + 5);
  if (v16 == (llvm::BasicBlock *)((char *)a2 + 40)) {
    return 0;
  }
  BOOL v18 = v16 == 0;
  if (v16) {
    uint64_t v19 = (unsigned __int8 *)v16 - 24;
  }
  else {
    uint64_t v19 = 0;
  }
  unsigned int v20 = v19[16] - 40;
  BOOL v21 = __CFADD__(v20, 11);
  if (v20 >= 0xFFFFFFF5) {
    uint64_t v22 = v19;
  }
  else {
    uint64_t v22 = 0;
  }
  int v23 = v22[16];
  if (!v21) {
    BOOL v18 = 1;
  }
  if (v23 == 30 && !v18)
  {
    if ((*((_DWORD *)v22 + 5) & 0x7FFFFFF) != 1)
    {
      uint64_t v24 = 0;
      uint64_t v25 = (llvm::Value *)*((void *)v22 - 12);
      goto LABEL_49;
    }
    return 0;
  }
  char v26 = v23 != 31 || v18;
  if (v26)
  {
    char v27 = v23 != 32 || v18;
    if (v27) {
      return 0;
    }
    int v28 = *((_DWORD *)v22 + 5);
    if ((v28 & 0x7FFFFFF) == 1) {
      return 0;
    }
    if ((v28 & 0x40000000) != 0) {
      uint64_t v29 = (llvm::Value **)*((void *)v22 - 1);
    }
    else {
      uint64_t v29 = (llvm::Value **)&v22[-32 * (v28 & 0x7FFFFFF)];
    }
    uint64_t v25 = llvm::Value::stripPointerCasts(*v29);
    uint64_t v24 = 1;
  }
  else
  {
    int v30 = *((_DWORD *)v22 + 5);
    if ((v30 & 0x40000000) != 0) {
      uint64_t v31 = (llvm::Value **)*((void *)v22 - 1);
    }
    else {
      uint64_t v31 = (llvm::Value **)&v22[-32 * (v30 & 0x7FFFFFF)];
    }
    uint64_t v24 = 0;
    uint64_t v25 = *v31;
  }
LABEL_49:
  if (v25) {
    BOOL v32 = *((unsigned __int8 *)v25 + 16) >= 0x1Cu;
  }
  else {
    BOOL v32 = 0;
  }
  if (v32
    && (uint64_t v33 = llvm::ConstantFoldInstruction((uint64_t)v25, (llvm::DataLayout *)(*(void *)(*((void *)a2 + 7) + 40) + 272), *(llvm::DSOLocalEquivalent ***)this, v12, v13, v14, v15)) != 0)
  {
    uint64_t v34 = v33;
    int v35 = 1;
    llvm::Value::doRAUW(v25, v33, (llvm::Value *)1);
    if (!*((void *)v25 + 1) && llvm::wouldInstructionBeTriviallyDead((uint64_t)v25, *(uint64_t **)this)) {
      llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
    }
    uint64_t v25 = v34;
  }
  else
  {
    int v35 = 0;
  }
  unsigned int v36 = *((unsigned __int8 *)v25 + 16);
  if (v36 == 95) {
    uint64_t v37 = v25;
  }
  else {
    uint64_t v37 = 0;
  }
  if (v36 - 11 < 2
    || v37
    && *(unsigned __int8 *)(*((void *)v37 - 4) + 16) - 11 <= 1
    && (uint64_t v42 = *((void *)v37 + 1)) != 0
    && !*(void *)(v42 + 8))
  {
    unsigned int v38 = sub_1CCD96148((uint64_t)a2);
    __p = 0;
    unint64_t v256 = 0;
    unint64_t v257 = 0;
    BOOL v39 = (void *)*((void *)a2 + 5);
    if (v39 == v17)
    {
      char v41 = 0;
    }
    else
    {
      if (v39) {
        unsigned int v40 = v39 - 3;
      }
      else {
        unsigned int v40 = 0;
      }
      if (*((unsigned __int8 *)v40 + 16) - 29 >= 0xB) {
        char v41 = 0;
      }
      else {
        char v41 = v40;
      }
    }
    if (*((unsigned char *)v41 + 16) == 30)
    {
      if ((*((_DWORD *)v41 + 5) & 0x7FFFFFF) == 3) {
        unsigned int v43 = 2;
      }
      else {
        unsigned int v43 = 1;
      }
    }
    else
    {
      unsigned int v43 = 0;
      switch(*((unsigned char *)v41 + 16))
      {
        case 0x1E:
LABEL_431:
          __break(1u);
          goto LABEL_432;
        case 0x1F:
          unsigned int v43 = (*((_DWORD *)v41 + 5) >> 1) & 0x3FFFFFF;
          break;
        case 0x20:
        case 0x26:
LABEL_432:
          unsigned int v43 = (*((_DWORD *)v41 + 5) & 0x7FFFFFF) - 1;
          break;
        case 0x21:
          unsigned int v43 = 2;
          break;
        case 0x24:
          unsigned int v43 = *((_WORD *)v41 + 9) & 1;
          break;
        case 0x25:
          unsigned int v43 = 1;
          break;
        case 0x27:
          unsigned int v43 = *((_DWORD *)v41 + 20) + 1;
          break;
        default:
          break;
      }
    }
    sub_1CC292E4C((uint64_t)&__p, v43);
    if (*((unsigned char *)v41 + 16) != 30)
    {
      int v44 = 2;
      switch(*((unsigned char *)v41 + 16))
      {
        case 0x1E:
          goto LABEL_431;
        case 0x1F:
          int v44 = (*((_DWORD *)v41 + 5) >> 1) & 0x3FFFFFF;
          goto LABEL_399;
        case 0x20:
        case 0x26:
          int v44 = (*((_DWORD *)v41 + 5) & 0x7FFFFFF) - 1;
          goto LABEL_399;
        case 0x21:
          goto LABEL_90;
        case 0x24:
          int v44 = *((_WORD *)v41 + 9) & 1;
          goto LABEL_399;
        case 0x25:
          int v44 = 1;
          goto LABEL_90;
        case 0x27:
          int v44 = *((_DWORD *)v41 + 20) + 1;
LABEL_399:
          if (!v44) {
            goto LABEL_353;
          }
          goto LABEL_90;
        default:
          goto LABEL_353;
      }
    }
    if ((*((_DWORD *)v41 + 5) & 0x7FFFFFF) == 3) {
      int v44 = 2;
    }
    else {
      int v44 = 1;
    }
LABEL_90:
    unsigned int v45 = 0;
    unsigned int v246 = v38;
    int v243 = v44;
    while (1)
    {
      if (v45 != v38)
      {
        uint64_t v46 = v41;
        uint64_t Successor = llvm::Instruction::getSuccessor((llvm::Instruction *)v41, v45);
        uint64_t v48 = Successor;
        if (*(void *)(Successor + 40) != Successor + 40)
        {
          uint64_t v49 = *(void *)(Successor + 48);
          uint64_t v50 = v49 - 24;
          uint64_t v51 = v49 ? v49 - 24 : 0;
          if (*(unsigned char *)(v51 + 16) == 83)
          {
            do
            {
              uint64_t v72 = *(void *)(v50 + 32);
              uint64_t v73 = v72 - 24;
              if (!v72) {
                uint64_t v73 = 0;
              }
              int v74 = *(unsigned __int8 *)(v73 + 16);
              if (v74 == 83) {
                uint64_t v75 = v73;
              }
              else {
                uint64_t v75 = 0;
              }
              int v76 = *(_DWORD *)(v50 + 20);
              uint64_t v77 = v76 & 0x7FFFFFF;
              if ((v76 & 0x7FFFFFF) != 0)
              {
                uint64_t v78 = 0;
                while (1)
                {
                  uint64_t v79 = v50 - 32 * v77;
                  if ((v76 & 0x40000000) != 0) {
                    uint64_t v79 = *(void *)(v50 - 8);
                  }
                  if (*(llvm::BasicBlock **)(v79 + 32 * *(unsigned int *)(v50 + 60) + 8 * v78) == a2) {
                    break;
                  }
                  if (v77 == ++v78) {
                    goto LABEL_133;
                  }
                }
                uint64_t v80 = v78;
              }
              else
              {
LABEL_133:
                uint64_t v80 = 0xFFFFFFFFLL;
              }
              if ((v76 & 0x40000000) != 0)
              {
                uint64_t v63 = *(void *)(v50 - 8);
                uint64_t v64 = v63 + 32 * v80;
                uint64_t v65 = (uint64_t *)(v63 + 32 * v77);
              }
              else
              {
                uint64_t v63 = v50 - 32 * v77;
                uint64_t v64 = v63 + 32 * v80;
                uint64_t v65 = (uint64_t *)v50;
              }
              sub_1CC5E4108((uint64_t)&v254, (uint64_t *)(v64 + 32), v65, v63 + 32 * v80);
              int v81 = *(_DWORD *)(v50 + 20);
              if ((v81 & 0x40000000) != 0)
              {
                uint64_t v67 = *(void *)(v50 - 8);
                uint64_t v68 = *(unsigned int *)(v50 + 60);
                uint64_t v69 = v67 + 32 * v68;
                uint64_t v66 = v81 & 0x7FFFFFF;
              }
              else
              {
                uint64_t v66 = v81 & 0x7FFFFFF;
                uint64_t v67 = v50 - 32 * v66;
                uint64_t v68 = *(unsigned int *)(v50 + 60);
                uint64_t v69 = v67 + 32 * v68;
              }
              uint64_t v82 = (unsigned char *)(v69 + 8 * v66);
              uint64_t v83 = (unsigned char *)(v69 + 8 * v80 + 8);
              if (v82 != v83)
              {
                memmove((void *)(v67 + 32 * v68 + 8 * v80), v83, v82 - v83);
                int v81 = *(_DWORD *)(v50 + 20);
              }
              if ((v81 & 0x40000000) != 0)
              {
                uint64_t v71 = *(void *)(v50 - 8);
                uint64_t v70 = v81 & 0x7FFFFFF;
              }
              else
              {
                uint64_t v70 = v81 & 0x7FFFFFF;
                uint64_t v71 = v50 - 32 * v70;
              }
              uint64_t v84 = v71 + 32 * v70;
              if (*(void *)(v84 - 32))
              {
                **(void **)(v84 - 16) = *(void *)(v84 - 24);
                uint64_t v85 = *(void *)(v84 - 24);
                if (v85) {
                  *(void *)(v85 + 16) = *(void *)(v84 - 16);
                }
              }
              *(void *)(v84 - 32) = 0;
              *(_DWORD *)(v50 + 20) = *(_DWORD *)(v50 + 20) & 0xF8000000 | (*(_DWORD *)(v50 + 20) - 1) & 0x7FFFFFF;
              if (!v72) {
                break;
              }
              uint64_t v50 = v75;
            }
            while (v74 == 83);
          }
        }
        uint64_t v52 = v48 | 4;
        uint64_t v53 = (void *)v256;
        if (v256 >= v257)
        {
          __int16 v55 = __p;
          uint64_t v56 = (uint64_t)(v256 - (void)__p) >> 4;
          unint64_t v57 = v56 + 1;
          if ((unint64_t)(v56 + 1) >> 60) {
            abort();
          }
          uint64_t v58 = v257 - (void)__p;
          if ((uint64_t)(v257 - (void)__p) >> 3 > v57) {
            unint64_t v57 = v58 >> 3;
          }
          if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v59 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v59 = v57;
          }
          if (v59)
          {
            if (v59 >> 60) {
              sub_1CB833614();
            }
            uint64_t v60 = (char *)operator new(16 * v59);
          }
          else
          {
            uint64_t v60 = 0;
          }
          unsigned int v61 = &v60[16 * v56];
          *(void *)unsigned int v61 = a2;
          *((void *)v61 + 1) = v52;
          unint64_t v62 = v61;
          char v41 = v46;
          if (v53 == v55)
          {
            unsigned int v38 = v246;
          }
          else
          {
            unsigned int v38 = v246;
            do
            {
              *((_OWORD *)v62 - 1) = *((_OWORD *)v53 - 1);
              v62 -= 16;
              v53 -= 2;
            }
            while (v53 != v55);
            uint64_t v53 = __p;
          }
          unsigned int v54 = v61 + 16;
          __p = v62;
          unint64_t v256 = (unint64_t)(v61 + 16);
          unint64_t v257 = (unint64_t)&v60[16 * v59];
          if (v53) {
            operator delete(v53);
          }
        }
        else
        {
          *(void *)unint64_t v256 = a2;
          v53[1] = v52;
          unsigned int v54 = v53 + 2;
          char v41 = v46;
          unsigned int v38 = v246;
        }
        int v44 = v243;
        unint64_t v256 = (unint64_t)v54;
      }
      if (++v45 == v44)
      {
LABEL_353:
        uint64_t v170 = llvm::Instruction::getSuccessor((llvm::Instruction *)v41, v38);
        uint64_t v171 = (char *)operator new(0x60uLL);
        int v172 = v171;
        *((_DWORD *)v171 + 13) = *((_DWORD *)v171 + 13) & 0x38000000 | 1;
        *((void *)v171 + 1) = 0;
        *((void *)v171 + 2) = 0;
        *(void *)uint64_t v171 = 0;
        *((void *)v171 + 4) = ***(void ***)v170 + 1576;
        int v173 = (llvm::Value *)(v171 + 32);
        *((void *)v171 + 3) = v171 + 32;
        *((void *)v171 + 5) = 0;
        v171[48] = 30;
        v171[49] = 0;
        *((_WORD *)v171 + 25) = 0;
        *((_DWORD *)v171 + 13) = 1;
        *(_OWORD *)(v171 + 56) = 0u;
        v174 = v171 + 56;
        *(_OWORD *)(v171 + 72) = 0u;
        *((_DWORD *)v171 + 22) = 0;
        if (v41)
        {
          uint64_t v202 = v41[5];
          uint64_t v203 = v41 + 3;
          *((void *)v171 + 9) = v202;
          *(_WORD *)(v202 + 18) &= ~0x8000u;
          if ((v171[55] & 0x10) != 0
            && (uint64_t v213 = *(void *)(v202 + 56)) != 0
            && (uint64_t v214 = *(llvm::ValueSymbolTable **)(v213 + 104)) != 0)
          {
            llvm::ValueSymbolTable::reinsertValue(v214, v173);
            uint64_t v215 = *(void *)v172;
            uint64_t v216 = *v203;
            *((void *)v172 + 7) = *v203;
            *((void *)v172 + 8) = v203;
            *(void *)(v216 + 8) = v174;
            *uint64_t v203 = (uint64_t)v174;
            if (v215)
            {
              **((void **)v172 + 2) = *((void *)v172 + 1);
              uint64_t v217 = *((void *)v172 + 1);
              if (v217) {
                *(void *)(v217 + 16) = *((void *)v172 + 2);
              }
            }
          }
          else
          {
            uint64_t v204 = *v203;
            *((void *)v172 + 7) = *v203;
            *((void *)v172 + 8) = v203;
            *(void *)(v204 + 8) = v174;
            *uint64_t v203 = (uint64_t)v174;
          }
        }
        *(void *)int v172 = v170;
        uint64_t v177 = *(void *)(v170 + 8);
        uint64_t v176 = (void *)(v170 + 8);
        uint64_t v175 = v177;
        *((void *)v172 + 1) = v177;
        if (v177) {
          *(void *)(v175 + 16) = v172 + 8;
        }
        *((void *)v172 + 2) = v176;
        *uint64_t v176 = v172;
        llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
      }
    }
  }
  if (v24)
  {
    if (*((unsigned char *)llvm::Value::stripPointerCasts(v25) + 16) != 4)
    {
      unsigned int v36 = *((unsigned __int8 *)v25 + 16);
      goto LABEL_79;
    }
LABEL_77:
    uint64_t v11 = 1;
    llvm::ConstantFoldTerminator(a2, 1, 0, *((void *)this + 4));
    if (!*((unsigned char *)this + 56)) {
      return v11;
    }
    llvm::BranchProbabilityInfo::eraseBlock(*((void *)this + 6), a2);
    return 1;
  }
  if (v36 == 16) {
    goto LABEL_77;
  }
LABEL_79:
  if (v36 <= 0x1B) {
    return v35 | llvm::JumpThreadingPass::processThreadableEdges((uint64_t)this, (llvm::Value **)v25, a2, v24, (llvm::Instruction *)v19);
  }
  unsigned int v86 = v36 - 83;
  long long v87 = (void *)*v17;
  if (v86 >= 0xFFFFFFFE)
  {
    if (v87 == v17)
    {
      __int16 v169 = 0;
    }
    else
    {
      __int16 v169 = v87 - 3;
      if (!v87) {
        __int16 v169 = 0;
      }
      if (*((unsigned __int8 *)v169 + 16) - 29 >= 0xB) {
        __int16 v169 = 0;
      }
    }
    unint64_t v180 = *((unsigned char *)v169 + 16) == 30 ? v169 : 0;
    v181 = *(unsigned __int8 *)(*((void *)v25 - 4) + 16) >= 0x15u ? 0 : (llvm::Constant *)*((void *)v25 - 4);
    if (v180 && v181)
    {
      int PredicateAt = llvm::LazyValueInfo::getPredicateAt(*((llvm::LazyValueInfo **)this + 2), *((_WORD *)v25 + 9) & 0x3F, *((llvm::Value **)v25 - 8), v181, (llvm::Instruction *)v180, 0);
      if (PredicateAt != -1)
      {
        int v183 = v180 - 4;
        uint64_t v245 = PredicateAt != 1;
        if (PredicateAt == 1) {
          uint64_t v184 = -1;
        }
        else {
          uint64_t v184 = 0;
        }
        uint64_t v248 = v183[4 * v184];
        if (*(void *)(v248 + 40) != v248 + 40)
        {
          uint64_t v185 = *(void *)(v248 + 48);
          uint64_t v186 = v185 - 24;
          uint64_t v187 = v185 ? v185 - 24 : 0;
          if (*(unsigned char *)(v187 + 16) == 83)
          {
            do
            {
              uint64_t v228 = *(void *)(v186 + 32);
              uint64_t v229 = v228 - 24;
              if (!v228) {
                uint64_t v229 = 0;
              }
              int v230 = *(unsigned __int8 *)(v229 + 16);
              if (v230 == 83) {
                uint64_t v231 = v229;
              }
              else {
                uint64_t v231 = 0;
              }
              int v232 = *(_DWORD *)(v186 + 20);
              uint64_t v233 = v232 & 0x7FFFFFF;
              if ((v232 & 0x7FFFFFF) != 0)
              {
                uint64_t v234 = 0;
                while (1)
                {
                  uint64_t v235 = v186 - 32 * v233;
                  if ((v232 & 0x40000000) != 0) {
                    uint64_t v235 = *(void *)(v186 - 8);
                  }
                  if (*(llvm::BasicBlock **)(v235 + 32 * *(unsigned int *)(v186 + 60) + 8 * v234) == a2) {
                    break;
                  }
                  if (v233 == ++v234) {
                    goto LABEL_455;
                  }
                }
                uint64_t v236 = v234;
              }
              else
              {
LABEL_455:
                uint64_t v236 = 0xFFFFFFFFLL;
              }
              uint64_t v237 = v233;
              if ((v232 & 0x40000000) != 0)
              {
                uint64_t v219 = *(void *)(v186 - 8);
                uint64_t v220 = v219 + 32 * v236;
                uint64_t v221 = (uint64_t *)(v219 + 32 * v237);
              }
              else
              {
                uint64_t v219 = v186 - 32 * v233;
                uint64_t v220 = v219 + 32 * v236;
                uint64_t v221 = (uint64_t *)v186;
              }
              sub_1CC5E4108((uint64_t)&__p, (uint64_t *)(v220 + 32), v221, v219 + 32 * v236);
              int v238 = *(_DWORD *)(v186 + 20);
              if ((v238 & 0x40000000) != 0)
              {
                uint64_t v223 = *(void *)(v186 - 8);
                uint64_t v224 = *(unsigned int *)(v186 + 60);
                uint64_t v225 = v223 + 32 * v224;
                uint64_t v222 = v238 & 0x7FFFFFF;
              }
              else
              {
                uint64_t v222 = v238 & 0x7FFFFFF;
                uint64_t v223 = v186 - 32 * v222;
                uint64_t v224 = *(unsigned int *)(v186 + 60);
                uint64_t v225 = v223 + 32 * v224;
              }
              v239 = (unsigned char *)(v225 + 8 * v222);
              uint64_t v240 = (unsigned char *)(v225 + 8 * v236 + 8);
              if (v239 != v240)
              {
                memmove((void *)(v223 + 32 * v224 + 8 * v236), v240, v239 - v240);
                int v238 = *(_DWORD *)(v186 + 20);
              }
              if ((v238 & 0x40000000) != 0)
              {
                uint64_t v227 = *(void *)(v186 - 8);
                uint64_t v226 = v238 & 0x7FFFFFF;
              }
              else
              {
                uint64_t v226 = v238 & 0x7FFFFFF;
                uint64_t v227 = v186 - 32 * v226;
              }
              uint64_t v241 = v227 + 32 * v226;
              if (*(void *)(v241 - 32))
              {
                **(void **)(v241 - 16) = *(void *)(v241 - 24);
                uint64_t v242 = *(void *)(v241 - 24);
                if (v242) {
                  *(void *)(v242 + 16) = *(void *)(v241 - 16);
                }
              }
              *(void *)(v241 - 32) = 0;
              *(_DWORD *)(v186 + 20) = *(_DWORD *)(v186 + 20) & 0xF8000000 | (*(_DWORD *)(v186 + 20) - 1) & 0x7FFFFFF;
              if (!v228) {
                break;
              }
              uint64_t v186 = v231;
            }
            while (v230 == 83);
          }
        }
        uint64_t v188 = v183[4 * (v245 << 63 >> 63)];
        int v189 = (char *)operator new(0x60uLL);
        *((_DWORD *)v189 + 13) = *((_DWORD *)v189 + 13) & 0x38000000 | 1;
        *((void *)v189 + 1) = 0;
        *((void *)v189 + 2) = 0;
        *(void *)int v189 = 0;
        *((void *)v189 + 4) = ***(void ***)v188 + 1576;
        *((void *)v189 + 3) = v189 + 32;
        *((void *)v189 + 5) = 0;
        v189[48] = 30;
        v189[49] = 0;
        *((_WORD *)v189 + 25) = 0;
        *((_DWORD *)v189 + 13) = 1;
        *(_OWORD *)(v189 + 56) = 0u;
        v190 = v189 + 56;
        *(_OWORD *)(v189 + 72) = 0u;
        *((_DWORD *)v189 + 22) = 0;
        uint64_t v191 = v180[5];
        v192 = v180 + 3;
        *((void *)v189 + 9) = v191;
        *(_WORD *)(v191 + 18) &= ~0x8000u;
        if ((v189[55] & 0x10) != 0
          && (uint64_t v208 = *(void *)(v191 + 56)) != 0
          && (v209 = *(llvm::ValueSymbolTable **)(v208 + 104)) != 0)
        {
          llvm::ValueSymbolTable::reinsertValue(v209, (llvm::Value *)(v189 + 32));
          uint64_t v210 = *(void *)v189;
          uint64_t v211 = *v192;
          *((void *)v189 + 7) = *v192;
          *((void *)v189 + 8) = v192;
          *(void *)(v211 + 8) = v190;
          uint64_t *v192 = (uint64_t)v190;
          if (v210)
          {
            **((void **)v189 + 2) = *((void *)v189 + 1);
            uint64_t v212 = *((void *)v189 + 1);
            if (v212) {
              *(void *)(v212 + 16) = *((void *)v189 + 2);
            }
          }
        }
        else
        {
          uint64_t v193 = *v192;
          *((void *)v189 + 7) = *v192;
          *((void *)v189 + 8) = v192;
          *(void *)(v193 + 8) = v190;
          uint64_t *v192 = (uint64_t)v190;
        }
        *(void *)int v189 = v188;
        uint64_t v196 = *(void *)(v188 + 8);
        int v195 = (void *)(v188 + 8);
        uint64_t v194 = v196;
        *((void *)v189 + 1) = v196;
        if (v196) {
          *(void *)(v194 + 16) = v189 + 8;
        }
        *((void *)v189 + 2) = v195;
        *int v195 = v189;
        uint64_t v197 = (unsigned __int8 *)v180[6];
        uint64_t v249 = v197;
        if (v197) {
          llvm::MetadataTracking::track((uint64_t)&v249, v197, 2);
        }
        int v200 = (unsigned __int8 *)*((void *)v189 + 10);
        v199 = (unsigned __int8 **)(v189 + 80);
        v198 = v200;
        if (!v200)
        {
LABEL_395:
          unint64_t v201 = v249;
          void *v199 = v249;
          if (v201)
          {
            llvm::MetadataTracking::retrack((uint64_t)&v249, v201, (uint64_t)v199);
            uint64_t v249 = 0;
          }
          llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
        }
        int v205 = *v198;
        if ((v205 - 4) > 0x1E)
        {
          if ((v205 - 3) >= 0xFFFFFFFE) {
            v218 = v198;
          }
          else {
            v218 = 0;
          }
          if ((v205 - 3) < 0xFFFFFFFE)
          {
            if (v205 == 3) {
              *((void *)v198 + 1) = 0;
            }
            goto LABEL_395;
          }
          unint64_t v207 = (unint64_t)(v218 + 8);
        }
        else
        {
          if ((v198[1] & 0x7F) != 2 && !*((_DWORD *)v198 + 3)) {
            goto LABEL_395;
          }
          uint64_t v206 = *((void *)v198 + 2);
          if ((v206 & 4) == 0) {
            goto LABEL_395;
          }
          unint64_t v207 = v206 & 0xFFFFFFFFFFFFFFF8;
          if (!v207) {
            goto LABEL_395;
          }
        }
        __p = v199;
        sub_1CC5FA668(v207 + 16, &__p);
        goto LABEL_395;
      }
      if (llvm::JumpThreadingPass::tryToUnfoldSelect((llvm::LazyValueInfo **)this, v25, a2)) {
        return 1;
      }
      long long v87 = (void *)*v17;
    }
  }
  if (v87 != v17)
  {
    uint64_t v88 = v87 ? (uint64_t)(v87 - 3) : 0;
    unsigned int v89 = *(unsigned __int8 *)(v88 + 16) - 40;
    uint64_t v90 = v89 >= 0xFFFFFFF5 ? (llvm::SwitchInst *)v88 : 0;
    if (v87
      && *((unsigned char *)v90 + 16) == 31
      && v89 >= 0xFFFFFFF5
      && (llvm::JumpThreadingPass::tryToUnfoldSelect(this, v90, a2) & 1) != 0)
    {
      return 1;
    }
  }
  unsigned int v91 = *((unsigned __int8 *)v25 + 16);
  unsigned int v92 = v91;
  int v93 = (unsigned __int8 *)v25;
  if (v91 == 95)
  {
    int v93 = (unsigned __int8 *)*((void *)v25 - 4);
    unsigned int v92 = v93[16];
  }
  if (v92 >= 0x1C && v92 - 83 >= 0xFFFFFFFE && *(unsigned __int8 *)(*((void *)v93 - 4) + 16) <= 0x14u)
  {
    int v93 = (unsigned __int8 *)*((void *)v93 - 8);
    unsigned int v92 = v93[16];
  }
  if (v92 == 60)
  {
    if (llvm::JumpThreadingPass::simplifyPartiallyRedundantLoad((llvm::AAResults **)this, (llvm::LoadInst *)v93)) {
      return 1;
    }
    unsigned int v91 = *((unsigned __int8 *)v25 + 16);
  }
  if (v91 != 83 || *((llvm::BasicBlock **)v25 + 5) != a2) {
    goto LABEL_328;
  }
  uint64_t v94 = *v17 - 24;
  if (!*v17) {
    uint64_t v94 = 0;
  }
  int v95 = *(unsigned __int8 *)(v94 + 16);
  uint64_t v96 = (v95 - 29) >= 0xB ? 0 : v94;
  if (*(unsigned char *)(v96 + 16) != 30) {
    goto LABEL_328;
  }
  unsigned int v97 = v95 - 40;
  uint64_t v98 = v97 >= 0xFFFFFFF5 ? (llvm::Instruction *)v94 : 0;
  if (v97 < 0xFFFFFFF5) {
    goto LABEL_328;
  }
  if (!*v17) {
    goto LABEL_328;
  }
  if (*((unsigned char *)v98 + 16) != 30) {
    goto LABEL_328;
  }
  unint64_t v253 = 0;
  unint64_t v254 = 0;
  if (!llvm::Instruction::extractProfMetadata(v98, &v254, &v253)) {
    goto LABEL_328;
  }
  if (!(v254 + v253)) {
    goto LABEL_328;
  }
  int v99 = *((_DWORD *)v25 + 5);
  uint64_t v100 = v99 & 0x7FFFFFF;
  if ((v99 & 0x7FFFFFF) == 0) {
    goto LABEL_328;
  }
  uint64_t v101 = 0;
  uint64_t v244 = v99 & 0x7FFFFFF;
  while (1)
  {
    int v102 = *((_DWORD *)v25 + 5);
    uint64_t v103 = (v102 & 0x40000000) != 0
         ? (llvm::Value *)*((void *)v25 - 1)
         : (llvm::Value *)((char *)v25 - 32 * (v102 & 0x7FFFFFF));
    uint64_t v104 = *((void *)v103 + 4 * v101);
    BOOL v105 = v104 && *(unsigned char *)(v104 + 16) == 16;
    if (v105 && *(_DWORD *)(*(void *)v104 + 8) == 269) {
      break;
    }
LABEL_316:
    if (++v101 == v100) {
      goto LABEL_328;
    }
  }
  uint64_t v247 = v101;
  uint64_t v106 = *(unsigned int *)(v104 + 32);
  if (v106 > 0x40)
  {
    int v112 = 0;
    int64_t v113 = (unint64_t)(v106 + 63) >> 6;
    do
    {
      if (v113-- < 1) {
        break;
      }
      unint64_t v115 = *(void *)(*(void *)(v104 + 24) + 8 * v113);
      v112 += __clz(v115);
    }
    while (!v115);
    int v116 = v106 | 0xFFFFFFC0;
    if ((v106 & 0x3F) == 0) {
      int v116 = 0;
    }
    if (v112 + v116 != v106 - 1) {
      goto LABEL_199;
    }
LABEL_209:
    unint64_t v107 = v254;
    unint64_t v108 = v253 + v254;
    unint64_t v109 = (v253 + v254) >> 32;
    if (v109)
    {
      LOBYTE(v109) = 0;
      unint64_t v162 = v253 + v254;
      do
      {
        unint64_t v108 = v162 >> 1;
        LOBYTE(v109) = v109 + 1;
        unint64_t v163 = v162 >> 33;
        v162 >>= 1;
      }
      while (v163);
    }
    goto LABEL_210;
  }
  if (*(void *)(v104 + 24) == 1) {
    goto LABEL_209;
  }
LABEL_199:
  unint64_t v107 = v253;
  unint64_t v108 = v254 + v253;
  unint64_t v109 = (v254 + v253) >> 32;
  if (v109)
  {
    LOBYTE(v109) = 0;
    unint64_t v110 = v254 + v253;
    do
    {
      unint64_t v108 = v110 >> 1;
      LOBYTE(v109) = v109 + 1;
      unint64_t v111 = v110 >> 33;
      v110 >>= 1;
    }
    while (v111);
  }
LABEL_210:
  unint64_t v117 = v107 >> v109;
  if (v108 != 0x80000000) {
    unint64_t v117 = (((unint64_t)(v107 >> v109) << 31) | (v108 >> 1)) / v108;
  }
  if ((v102 & 0x40000000) != 0) {
    int v118 = (char *)*((void *)v25 - 1);
  }
  else {
    int v118 = (char *)v25 - 32 * (v102 & 0x7FFFFFF);
  }
  unsigned int v119 = 0;
  uint64_t SinglePredecessor = *(void *)&v118[32 * *((unsigned int *)v25 + 15) + 8 * v247];
  __p = v259;
  unint64_t v256 = (unint64_t)v259;
  unint64_t v257 = 16;
  int v258 = 0;
  unsigned int v121 = 16;
  int v122 = (llvm::BasicBlock **)v259;
  int v123 = (llvm::BasicBlock **)v259;
  unsigned int v124 = a2;
  while (1)
  {
    BOOL v125 = (llvm::BasicBlock *)SinglePredecessor;
    uint64_t v127 = SinglePredecessor + 40;
    uint64_t v126 = *(void *)(SinglePredecessor + 40);
    if (v126 != v127)
    {
      uint64_t v128 = v126 - 24;
      if (!v126) {
        uint64_t v128 = 0;
      }
      unsigned int v129 = *(unsigned __int8 *)(v128 + 16) - 40;
      if (v129 < 0xFFFFFFF5) {
        uint64_t v128 = 0;
      }
      if (v126)
      {
        BOOL v130 = *(unsigned char *)(v128 + 16) == 30 && v129 >= 0xFFFFFFF5;
        if (v130 && (*(_DWORD *)(v128 + 20) & 0x7FFFFFF) == 3) {
          break;
        }
      }
    }
    if (v123 != v122) {
      goto LABEL_238;
    }
    if (v119)
    {
      int v131 = 0;
      uint64_t v132 = 8 * v119;
      int v133 = v122;
      while (*v133 != v125)
      {
        if (*v133 == (llvm::BasicBlock *)-2) {
          int v131 = v133;
        }
        ++v133;
        v132 -= 8;
        if (!v132)
        {
          if (!v131) {
            goto LABEL_236;
          }
          *int v131 = v125;
          --v258;
          goto LABEL_258;
        }
      }
      goto LABEL_258;
    }
LABEL_236:
    if (v121 <= v119)
    {
LABEL_238:
      if (3 * v121 <= 4 * (v119 - v258))
      {
        if (v121 >= 0x40) {
          v121 *= 2;
        }
        else {
          unsigned int v121 = 128;
        }
      }
      else if (v121 - v119 >= v121 >> 3)
      {
        goto LABEL_240;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&__p, v121);
      unsigned int v121 = v257;
      int v123 = (llvm::BasicBlock **)v256;
LABEL_240:
      unsigned int v134 = v121 - 1;
      unsigned int v135 = (v121 - 1) & ((v125 >> 4) ^ (v125 >> 9));
      int v136 = &v123[v135];
      uint64_t v137 = *v136;
      if (*v136 == (llvm::BasicBlock *)-1)
      {
        int v138 = 0;
LABEL_252:
        if (v138) {
          int v136 = v138;
        }
        if (*v136 != v125)
        {
          if (*v136 == (llvm::BasicBlock *)-2) {
            --v258;
          }
          else {
            ++HIDWORD(v257);
          }
          *int v136 = v125;
        }
      }
      else
      {
        int v138 = 0;
        int v139 = 1;
        while (v137 != v125)
        {
          if (v138) {
            BOOL v140 = 0;
          }
          else {
            BOOL v140 = v137 == (llvm::BasicBlock *)-2;
          }
          if (v140) {
            int v138 = v136;
          }
          unsigned int v141 = v135 + v139++;
          unsigned int v135 = v141 & v134;
          int v136 = &v123[v141 & v134];
          uint64_t v137 = *v136;
          if (*v136 == (llvm::BasicBlock *)-1) {
            goto LABEL_252;
          }
        }
      }
      goto LABEL_258;
    }
    HIDWORD(v257) = v119 + 1;
    v122[v119] = v125;
LABEL_258:
    uint64_t SinglePredecessor = llvm::BasicBlock::getSinglePredecessor(v125);
    int v122 = (llvm::BasicBlock **)__p;
    int v123 = (llvm::BasicBlock **)v256;
    if (SinglePredecessor)
    {
      if ((void *)v256 == __p)
      {
        unsigned int v119 = HIDWORD(v257);
        unsigned int v142 = (void *)(v256 + 8 * HIDWORD(v257));
        if (HIDWORD(v257))
        {
          uint64_t v143 = 0;
          while (*(void *)(v256 + v143) != SinglePredecessor)
          {
            v143 += 8;
            if (8 * HIDWORD(v257) == v143) {
              goto LABEL_278;
            }
          }
          unsigned int v142 = (void *)(v256 + v143);
        }
LABEL_278:
        int v122 = (llvm::BasicBlock **)v256;
      }
      else
      {
        int v144 = v257 - 1;
        unsigned int v145 = (v257 - 1) & ((SinglePredecessor >> 4) ^ (SinglePredecessor >> 9));
        unsigned int v142 = (void *)(v256 + 8 * v145);
        uint64_t v146 = *v142;
        if (*v142 == -1)
        {
          int v147 = 0;
LABEL_285:
          if (v147) {
            unsigned int v142 = v147;
          }
          unsigned int v119 = HIDWORD(v257);
          if (*v142 != SinglePredecessor) {
            unsigned int v142 = (void *)(v256 + 8 * v257);
          }
        }
        else
        {
          int v147 = 0;
          int v148 = 1;
          while (v146 != SinglePredecessor)
          {
            if (v147) {
              BOOL v149 = 0;
            }
            else {
              BOOL v149 = v146 == -2;
            }
            if (v149) {
              int v147 = v142;
            }
            unsigned int v150 = v145 + v148++;
            unsigned int v145 = v150 & v144;
            unsigned int v142 = (void *)(v256 + 8 * (v150 & v144));
            uint64_t v146 = *v142;
            if (*v142 == -1) {
              goto LABEL_285;
            }
          }
          unsigned int v119 = HIDWORD(v257);
        }
      }
      unsigned int v121 = v257;
      unsigned int v151 = (llvm::BasicBlock **)v256 == v122 ? v119 : v257;
      unsigned int v124 = v125;
      if (v142 == (void *)(v256 + 8 * v151)) {
        continue;
      }
    }
    unsigned int v124 = 0;
    BOOL v125 = 0;
    break;
  }
  if (v123 != v122) {
    free(v123);
  }
  if (v125)
  {
    unint64_t v152 = (void *)*((void *)v125 + 5);
    if (v152 != (void *)((char *)v125 + 40))
    {
      uint64_t v153 = v152 ? (uint64_t)(v152 - 3) : 0;
      unsigned int v154 = *(unsigned __int8 *)(v153 + 16) - 40;
      uint64_t v155 = v154 >= 0xFFFFFFF5 ? v153 : 0;
      if (v152)
      {
        if (*(unsigned char *)(v155 + 16) == 30 && v154 >= 0xFFFFFFF5)
        {
          unint64_t v251 = 0;
          unint64_t v252 = 0;
          if ((llvm::Instruction::extractProfMetadata((llvm::Instruction *)v155, &v252, &v251) & 1) == 0
            && !(v117 >> 30))
          {
            __p = &v257;
            v157 = *(llvm::BasicBlock **)(v155 - 32);
            unsigned int v158 = 0x80000000 - v117;
            BOOL v159 = v157 == v124;
            if (v157 == v124) {
              unsigned int v160 = v117;
            }
            else {
              unsigned int v160 = 0x80000000 - v117;
            }
            if (!v159) {
              unsigned int v158 = v117;
            }
            unint64_t v257 = __PAIR64__(v158, v160);
            unint64_t v256 = 0x200000002;
            uint64_t v250 = ***(uint64_t ****)(v155 + 40);
            uint64_t v161 = llvm::MDBuilder::createBranchWeights(&v250, (uint64_t)&v257, 2);
            llvm::Instruction::setMetadata((llvm::Instruction *)v155, 2, v161);
            if (__p != &v257) {
              free(__p);
            }
          }
          uint64_t v100 = v244;
          uint64_t v101 = v247;
          goto LABEL_316;
        }
      }
    }
  }
LABEL_328:
  if (llvm::JumpThreadingPass::processThreadableEdges((uint64_t)this, (llvm::Value **)v25, a2, v24, (llvm::Instruction *)v19))return 1; {
  int v164 = *((unsigned __int8 *)v25 + 16);
  }
  int v165 = v164;
  uint64_t v166 = v25;
  if (v164 == 95)
  {
    uint64_t v166 = (llvm::Value *)*((void *)v25 - 4);
    int v165 = *((unsigned __int8 *)v166 + 16);
  }
  if (v165 != 83 || *((llvm::BasicBlock **)v166 + 5) != a2) {
    goto LABEL_366;
  }
  if (*v17) {
    uint64_t v167 = *v17 - 24;
  }
  else {
    uint64_t v167 = 0;
  }
  if (*(unsigned __int8 *)(v167 + 16) - 29 >= 0xB) {
    uint64_t v167 = 0;
  }
  if (*(unsigned char *)(v167 + 16) == 30) {
    return llvm::JumpThreadingPass::processBranchOnPHI(this, v166);
  }
  if (v164 != 58 || *((llvm::BasicBlock **)v25 + 5) != a2) {
    return llvm::JumpThreadingPass::processImpliedCondition(this, a2);
  }
LABEL_366:
  uint64_t v179 = *v17 ? *v17 - 24 : 0;
  if (*(unsigned __int8 *)(v179 + 16) - 29 >= 0xB) {
    uint64_t v179 = 0;
  }
  if (*(unsigned char *)(v179 + 16) == 30) {
    return llvm::JumpThreadingPass::processBranchOnXOR(this, v25);
  }
  else {
    return llvm::JumpThreadingPass::processImpliedCondition(this, a2);
  }
}

BOOL sub_1CCD932C8(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 160)) {
    return sub_1CD4ABA00(a1 + 144, a2) != 0;
  }
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(uint64_t **)a1;
  size_t v5 = 8 * v3 - 8;
  unsigned int v6 = *(uint64_t **)a1;
  while (1)
  {
    uint64_t v7 = *v6++;
    if (v7 == a2) {
      break;
    }
    v5 -= 8;
    uint64_t v4 = v6;
    if (v5 == -8) {
      return 0;
    }
  }
  if (v5) {
    memmove(v4, v4 + 1, v5);
  }
  *(_DWORD *)(a1 + 8) = v3 - 1;
  return 1;
}

BOOL llvm::JumpThreadingPass::computeValueKnownInPredecessorsImpl(uint64_t a1, llvm::Value *a2, llvm::BasicBlock *a3, uint64_t a4, uint64_t a5, uint64_t a6, llvm::Instruction *a7)
{
  uint64_t v263 = *MEMORY[0x1E4F143B8];
  uint64_t v247 = a2;
  sub_1CBF5FAF4(a6, &v247, (uint64_t)&v259);
  if (!BYTE8(v260)) {
    return 0;
  }
  uint64_t v13 = v247;
  if (!v247) {
    goto LABEL_28;
  }
  unsigned int v14 = *((unsigned __int8 *)v247 + 16);
  if (v14 - 13 > 0xFFFFFFFD) {
    goto LABEL_8;
  }
  if (a5 == 1)
  {
    uint64_t v13 = llvm::Value::stripPointerCasts(v247);
    if (*((unsigned char *)v13 + 16) == 4) {
      goto LABEL_8;
    }
    uint64_t v13 = v247;
    unsigned int v14 = *((unsigned __int8 *)v247 + 16);
  }
  else if (v14 == 16)
  {
LABEL_8:
    while (1)
    {
      a3 = (llvm::BasicBlock *)*((void *)a3 + 1);
      if (!a3) {
        goto LABEL_38;
      }
      uint64_t v15 = *((void *)a3 + 3);
      unsigned int v16 = *(unsigned __int8 *)(v15 + 16);
      if (v15) {
        BOOL v17 = v16 >= 0x1C;
      }
      else {
        BOOL v17 = 0;
      }
      BOOL v18 = !v17 || v16 - 29 > 0xA;
      if (!v18)
      {
LABEL_16:
        v259 = *(llvm::BasicBlock **)(v15 + 40);
        sub_1CCD94EC4(a4, (uint64_t)v13, (uint64_t *)&v259);
        while (1)
        {
          a3 = (llvm::BasicBlock *)*((void *)a3 + 1);
          if (!a3) {
            goto LABEL_38;
          }
          uint64_t v15 = *((void *)a3 + 3);
          unsigned int v19 = *(unsigned __int8 *)(v15 + 16);
          if (v15) {
            BOOL v20 = v19 >= 0x1C;
          }
          else {
            BOOL v20 = 0;
          }
          if (v20 && v19 - 29 < 0xB) {
            goto LABEL_16;
          }
        }
      }
    }
  }
  if (v14 < 0x1C || *((llvm::BasicBlock **)v13 + 5) != a3)
  {
LABEL_28:
    uint64_t v22 = *((void *)a3 + 1);
    if (v22)
    {
      while (1)
      {
        uint64_t v23 = *(void *)(v22 + 24);
        unsigned int v24 = *(unsigned __int8 *)(v23 + 16);
        BOOL v25 = v23 && v24 >= 0x1C;
        if (v25 && v24 - 29 < 0xB) {
          break;
        }
        uint64_t v22 = *(void *)(v22 + 8);
        if (!v22) {
          goto LABEL_38;
        }
      }
LABEL_42:
      v259 = *(llvm::BasicBlock **)(v23 + 40);
      ConstantOnEdge = (unsigned __int8 *)llvm::LazyValueInfo::getConstantOnEdge(*(llvm::LazyValueInfo **)(a1 + 16), (llvm::ConstantInt ***)v13, v259, a3, a7);
      if (!ConstantOnEdge) {
        goto LABEL_49;
      }
      int v30 = (llvm::Value *)ConstantOnEdge;
      int v31 = ConstantOnEdge[16];
      if ((v31 - 13) <= 0xFFFFFFFD)
      {
        if (a5 == 1)
        {
          int v30 = llvm::Value::stripPointerCasts((llvm::Value *)ConstantOnEdge);
          if (*((unsigned char *)v30 + 16) != 4) {
            goto LABEL_49;
          }
        }
        else if (v31 != 16)
        {
          goto LABEL_49;
        }
      }
      sub_1CCD94EC4(a4, (uint64_t)v30, (uint64_t *)&v259);
LABEL_49:
      while (1)
      {
        uint64_t v22 = *(void *)(v22 + 8);
        if (!v22) {
          break;
        }
        uint64_t v23 = *(void *)(v22 + 24);
        unsigned int v32 = *(unsigned __int8 *)(v23 + 16);
        if (v23) {
          BOOL v33 = v32 >= 0x1C;
        }
        else {
          BOOL v33 = 0;
        }
        if (v33 && v32 - 29 <= 0xA)
        {
          uint64_t v13 = v247;
          goto LABEL_42;
        }
      }
    }
    goto LABEL_38;
  }
  if (v14 == 83)
  {
    uint64_t v35 = *((_DWORD *)v13 + 5) & 0x7FFFFFF;
    if (v35)
    {
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      uint64_t v38 = 32 * v35;
      do
      {
        int v39 = *((_DWORD *)v13 + 5);
        if ((v39 & 0x40000000) != 0) {
          unsigned int v40 = (char *)*((void *)v13 - 1);
        }
        else {
          unsigned int v40 = (char *)v13 - 32 * (v39 & 0x7FFFFFF);
        }
        char v41 = *(unsigned __int8 **)&v40[v37];
        if (v41)
        {
          int v42 = v41[16];
          if ((v42 - 13) > 0xFFFFFFFD) {
            goto LABEL_70;
          }
          if (a5 == 1)
          {
            unsigned int v43 = llvm::Value::stripPointerCasts((llvm::Value *)v41);
            int v39 = *((_DWORD *)v13 + 5);
            if (*((unsigned char *)v43 + 16) == 4) {
              goto LABEL_71;
            }
          }
          else if (v42 == 16)
          {
LABEL_70:
            unsigned int v43 = (llvm::Value *)v41;
LABEL_71:
            if ((v39 & 0x40000000) == 0)
            {
              uint64_t v44 = v39 & 0x7FFFFFF;
              goto LABEL_84;
            }
            goto LABEL_85;
          }
        }
        if ((v39 & 0x40000000) != 0) {
          unsigned int v45 = (char *)*((void *)v13 - 1);
        }
        else {
          unsigned int v45 = (char *)v13 - 32 * (v39 & 0x7FFFFFF);
        }
        uint64_t v46 = (unsigned __int8 *)llvm::LazyValueInfo::getConstantOnEdge(*(llvm::LazyValueInfo **)(a1 + 16), (llvm::ConstantInt ***)v41, *(llvm::BasicBlock **)&v45[32 * *((unsigned int *)v13 + 15) + v36], a3, a7);
        if (!v46) {
          goto LABEL_87;
        }
        unsigned int v43 = (llvm::Value *)v46;
        int v47 = v46[16];
        if ((v47 - 13) > 0xFFFFFFFD) {
          goto LABEL_82;
        }
        if (a5 == 1)
        {
          unsigned int v43 = llvm::Value::stripPointerCasts((llvm::Value *)v46);
          if (*((unsigned char *)v43 + 16) != 4) {
            goto LABEL_87;
          }
LABEL_82:
          int v48 = *((_DWORD *)v13 + 5);
          if ((v48 & 0x40000000) == 0)
          {
            uint64_t v44 = v48 & 0x7FFFFFF;
LABEL_84:
            uint64_t v49 = (char *)v13 - 32 * v44;
LABEL_86:
            v259 = *(llvm::BasicBlock **)&v49[32 * *((unsigned int *)v13 + 15) + v36];
            sub_1CCD94EF8(a4, (uint64_t)v43, &v259);
            goto LABEL_87;
          }
LABEL_85:
          uint64_t v49 = (char *)*((void *)v13 - 1);
          goto LABEL_86;
        }
        if (v47 == 16) {
          goto LABEL_82;
        }
LABEL_87:
        v37 += 32;
        v36 += 8;
      }
      while (v38 != v37);
    }
LABEL_38:
    BOOL v27 = *(_DWORD *)(a4 + 8) == 0;
    return !v27;
  }
  if (v14 - 79 >= 0xFFFFFFF3)
  {
    llvm::JumpThreadingPass::computeValueKnownInPredecessorsImpl(a1, *((void *)v13 - 4), a3, a4, a5, a6, a7);
    uint64_t v56 = *(unsigned int *)(a4 + 8);
    if (v56)
    {
      unint64_t v57 = *(llvm::ConstantExpr ***)a4;
      uint64_t v58 = 16 * v56;
      BOOL v28 = 1;
      do
      {
        *unint64_t v57 = llvm::ConstantExpr::getCast((llvm::ConstantExpr *)(*((unsigned __int8 *)v13 + 16) - 28), *v57, *(llvm::Constant ****)v13, 0);
        v57 += 2;
        v58 -= 16;
      }
      while (v58);
      return v28;
    }
    return 0;
  }
  if (v14 == 95)
  {
    llvm::JumpThreadingPass::computeValueKnownInPredecessorsImpl(a1, *((void *)v13 - 4), a3, a4, a5, a6, a7);
    uint64_t v50 = *(unsigned int *)(a4 + 8);
    if (!v50)
    {
      BOOL v28 = 0;
      *(_DWORD *)(a4 + 8) = 0;
      return v28;
    }
    uint64_t v51 = *(void **)a4;
    uint64_t v52 = *(void *)a4 + 16 * v50;
    uint64_t v53 = 16 * v50 - 16;
    unsigned int v54 = *(uint64_t *****)a4;
    while (1)
    {
      __int16 v55 = *v54;
      v54 += 2;
      if ((sub_1CC16A22C(v55, 0, 0, 0, 0, 0) & 1) == 0) {
        break;
      }
      v53 -= 16;
      uint64_t v51 = v54;
      if (v53 == -16)
      {
        uint64_t v51 = (void *)v52;
        goto LABEL_130;
      }
    }
    if (v53)
    {
      uint64_t v72 = v51 + 2;
      do
      {
        if (sub_1CC16A22C((uint64_t ***)*v72, 0, 0, 0, 0, 0))
        {
          *uint64_t v51 = *v72;
          v51[1] = v72[1];
          v51 += 2;
        }
        v72 += 2;
        v53 -= 16;
      }
      while (v53);
    }
LABEL_130:
    unint64_t v73 = ((unint64_t)v51 - *(void *)a4) >> 4;
    *(_DWORD *)(a4 + 8) = v73;
    BOOL v27 = v73 == 0;
    return !v27;
  }
  unint64_t PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits(*(llvm::Type **)v13);
  if (v59 == 1) {
  if (PrimitiveSizeInBits != 1)
  }
  {
    int v68 = *((unsigned __int8 *)v13 + 16);
    if ((v68 - 59) < 0xFFFFFFEE)
    {
      if ((v68 - 83) < 0xFFFFFFFE) {
        goto LABEL_117;
      }
      if (a5) {
        return 0;
      }
      goto LABEL_246;
    }
    if (a5) {
      return 0;
    }
    int v74 = (llvm::Constant *)*((void *)v13 - 4);
    if (!v74 || *((unsigned char *)v74 + 16) != 16) {
      goto LABEL_38;
    }
    v259 = (llvm::BasicBlock *)((char *)&v260 + 8);
    *(void *)&long long v260 = 0x800000000;
    llvm::JumpThreadingPass::computeValueKnownInPredecessorsImpl(a1, *((void *)v13 - 8), a3, &v259, 0, a6, a7);
    int v76 = v259;
    if (!v260)
    {
LABEL_200:
      if (v76 != (llvm::BasicBlock *)((char *)&v260 + 8)) {
        free(v76);
      }
      goto LABEL_38;
    }
    uint64_t v77 = 16 * v260;
    uint64_t v78 = (uint64_t *)((char *)v259 + 8);
    while (1)
    {
      uint64_t v79 = (llvm::Constant *)*(v78 - 1);
      unsigned __int8 v80 = *((unsigned char *)v13 + 16) - 28;
      int v81 = llvm::ConstantFoldBinaryInstruction((llvm *)(*((unsigned __int8 *)v13 + 16) - 28), v79, v74, v75);
      if (v81) {
        break;
      }
      unsigned int v86 = *(void ***)v79;
      if (*(void *)v79)
      {
        __src = v79;
        uint64_t v249 = v74;
        uint64_t v87 = **v86 + 1512;
        LODWORD(v253) = v80;
        uint64_t p_src = (uint64_t)&__src;
        uint64_t v255 = 2;
        long long v256 = 0u;
        long long v257 = 0u;
        uint64_t v258 = 0;
        uint64_t v82 = sub_1CC56C20C(v87, (uint64_t)v86, (unsigned __int8 *)&v253);
        if (v82) {
          goto LABEL_138;
        }
      }
LABEL_143:
      v78 += 2;
      v77 -= 16;
      if (!v77)
      {
        int v76 = v259;
        goto LABEL_200;
      }
    }
    uint64_t v82 = (uint64_t)v81;
LABEL_138:
    unsigned int v83 = *(unsigned __int8 *)(v82 + 16);
    BOOL v18 = v83 > 0x10;
    int v84 = (1 << v83) & 0x11800;
    if (!v18 && v84 != 0) {
      sub_1CCD94EC4(a4, v82, v78);
    }
    goto LABEL_143;
  }
  if (a5) {
    return 0;
  }
  uint64_t v245 = 0;
  unsigned int v246 = 0;
  v259 = (llvm::BasicBlock *)&v246;
  *(void *)&long long v260 = &v245;
  if ((sub_1CC185634((void **)&v259, (uint64_t *)v13) & 1) != 0
    || (unint64_t v253 = (llvm::BasicBlock *)&v246,
        uint64_t p_src = (uint64_t)&v245,
        (sub_1CC185750((void **)&v253, (uint64_t *)v13) & 1) != 0))
  {
    v259 = (llvm::BasicBlock *)((char *)&v260 + 8);
    *(void *)&long long v260 = 0x800000000;
    unint64_t v253 = (llvm::BasicBlock *)&v255;
    uint64_t p_src = 0x800000000;
    llvm::JumpThreadingPass::computeValueKnownInPredecessorsImpl(a1, v246, a3, &v259, 0, a6, a7);
    llvm::JumpThreadingPass::computeValueKnownInPredecessorsImpl(a1, v245, a3, &v253, 0, a6, a7);
    BOOL v28 = 0;
    if (v260 | p_src)
    {
      BOOL v61 = sub_1CCA16538((uint64_t)&__src, (unsigned __int8 *)v13);
      uint64_t v63 = ***(void ***)v13;
      if (v61)
      {
        uint64_t v64 = *(void **)(v63 + 1560);
        if (!v64)
        {
          uint64_t v65 = *(llvm::ConstantInt **)(v63 + 1888);
          unsigned int v66 = *(_DWORD *)(v63 + 1896);
          LODWORD(v249) = v66 >> 8;
          if (v66 >> 8 > 0x40) {
            operator new[]();
          }
          if (v66 <= 0xFF) {
            char v67 = 0;
          }
          else {
            char v67 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v66) + 63);
          }
          __src = (void *)(v67 & 1);
          uint64_t v64 = llvm::ConstantInt::get(v65, (llvm::LLVMContext *)&__src, v62);
          if (v249 >= 0x41 && __src) {
            MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
          }
          *(void *)(v63 + 1560) = v64;
        }
      }
      else
      {
        uint64_t v64 = *(void **)(v63 + 1568);
        if (!v64)
        {
          uint64_t v219 = *(llvm::ConstantInt **)(v63 + 1888);
          unsigned int v220 = *(_DWORD *)(v63 + 1896);
          LODWORD(v249) = v220 >> 8;
          if (v220 >> 8 > 0x40) {
            operator new[]();
          }
          __src = 0;
          uint64_t v64 = llvm::ConstantInt::get(v219, (llvm::LLVMContext *)&__src, v62);
          if (v249 >= 0x41 && __src) {
            MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
          }
          *(void *)(v63 + 1568) = v64;
        }
      }
      unsigned int v91 = (llvm::Constant *)v252;
      __src = v252;
      uint64_t v249 = (llvm::Constant *)v252;
      uint64_t v250 = 4;
      unsigned int v251 = 0;
      if (v260)
      {
        unsigned int v92 = (uint64_t *)v259;
        int v93 = (uint64_t *)((char *)v259 + 16 * v260);
        uint64_t v94 = (llvm::Constant *)v252;
        while (1)
        {
          if ((void *)*v92 != v64 && *(unsigned __int8 *)(*v92 + 16) - 11 > 1) {
            goto LABEL_192;
          }
          sub_1CCD94EC4(a4, (uint64_t)v64, v92 + 1);
          uint64_t v95 = v92[1];
          uint64_t v96 = v249;
          uint64_t v97 = HIDWORD(v250);
          if (v249 != __src) {
            break;
          }
          if (HIDWORD(v250))
          {
            uint64_t v98 = 0;
            uint64_t v99 = 8 * HIDWORD(v250);
            uint64_t v100 = (uint64_t *)v249;
            while (*v100 != v95)
            {
              if (*v100 == -2) {
                uint64_t v98 = v100;
              }
              ++v100;
              v99 -= 8;
              if (!v99)
              {
                if (!v98) {
                  goto LABEL_167;
                }
                *uint64_t v98 = v95;
                --v251;
                goto LABEL_191;
              }
            }
            goto LABEL_191;
          }
LABEL_167:
          unsigned int v101 = v250;
          if (HIDWORD(v250) >= v250) {
            goto LABEL_170;
          }
          ++HIDWORD(v250);
          *((void *)v249 + v97) = v95;
LABEL_191:
          unsigned int v91 = (llvm::Constant *)__src;
          uint64_t v94 = v249;
LABEL_192:
          v92 += 2;
          if (v92 == v93) {
            goto LABEL_203;
          }
        }
        unsigned int v101 = v250;
LABEL_170:
        if (3 * v101 <= 4 * (HIDWORD(v250) - v251))
        {
          if (v101 >= 0x40) {
            v101 *= 2;
          }
          else {
            unsigned int v101 = 128;
          }
        }
        else if (v101 - HIDWORD(v250) >= v101 >> 3)
        {
          goto LABEL_172;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&__src, v101);
        unsigned int v101 = v250;
        uint64_t v96 = v249;
LABEL_172:
        unsigned int v102 = v101 - 1;
        unsigned int v103 = (v101 - 1) & ((v95 >> 4) ^ (v95 >> 9));
        uint64_t v104 = (uint64_t *)((char *)v96 + 8 * v103);
        uint64_t v105 = *v104;
        if (*v104 == -1)
        {
          uint64_t v106 = 0;
LABEL_184:
          if (v106) {
            unint64_t v110 = v106;
          }
          else {
            unint64_t v110 = v104;
          }
          if (*v110 != v95)
          {
            if (*v110 == -2) {
              --v251;
            }
            else {
              ++HIDWORD(v250);
            }
            uint64_t *v110 = v95;
          }
        }
        else
        {
          uint64_t v106 = 0;
          int v107 = 1;
          while (v105 != v95)
          {
            if (v106) {
              BOOL v108 = 0;
            }
            else {
              BOOL v108 = v105 == -2;
            }
            if (v108) {
              uint64_t v106 = v104;
            }
            unsigned int v109 = v103 + v107++;
            unsigned int v103 = v109 & v102;
            uint64_t v104 = (uint64_t *)((char *)v96 + 8 * (v109 & v102));
            uint64_t v105 = *v104;
            if (*v104 == -1) {
              goto LABEL_184;
            }
          }
        }
        goto LABEL_191;
      }
      uint64_t v94 = (llvm::Constant *)v252;
LABEL_203:
      if (p_src)
      {
        unint64_t v111 = (uint64_t *)v253;
        int v112 = (uint64_t *)((char *)v253 + 16 * p_src);
        do
        {
          if ((void *)*v111 == v64 || *(unsigned __int8 *)(*v111 + 16) - 11 <= 1)
          {
            uint64_t v113 = v111[1];
            unint64_t v114 = (llvm::Constant *)__src;
            if (v249 == __src)
            {
              unsigned int v115 = HIDWORD(v250);
              int v116 = (void *)((char *)v249 + 8 * HIDWORD(v250));
              if (HIDWORD(v250))
              {
                uint64_t v117 = 0;
                while (*(void *)((char *)v249 + v117) != v113)
                {
                  v117 += 8;
                  if (8 * HIDWORD(v250) == v117) {
                    goto LABEL_226;
                  }
                }
                int v116 = (void *)((char *)v249 + v117);
              }
LABEL_226:
              unint64_t v114 = v249;
            }
            else
            {
              int v118 = v250 - 1;
              unsigned int v119 = (v250 - 1) & ((v113 >> 4) ^ (v113 >> 9));
              int v116 = (void *)((char *)v249 + 8 * v119);
              uint64_t v120 = *v116;
              if (*v116 == -1)
              {
                unsigned int v121 = 0;
LABEL_234:
                if (v121) {
                  int v116 = v121;
                }
                unsigned int v115 = HIDWORD(v250);
                if (*v116 != v113) {
                  int v116 = (void *)((char *)v249 + 8 * v250);
                }
              }
              else
              {
                unsigned int v121 = 0;
                int v122 = 1;
                while (v120 != v113)
                {
                  if (v121) {
                    BOOL v123 = 0;
                  }
                  else {
                    BOOL v123 = v120 == -2;
                  }
                  if (v123) {
                    unsigned int v121 = v116;
                  }
                  unsigned int v124 = v119 + v122++;
                  unsigned int v119 = v124 & v118;
                  int v116 = (void *)((char *)v249 + 8 * (v124 & v118));
                  uint64_t v120 = *v116;
                  if (*v116 == -1) {
                    goto LABEL_234;
                  }
                }
                unsigned int v115 = HIDWORD(v250);
              }
            }
            unsigned int v125 = v250;
            if (v249 == v114) {
              unsigned int v125 = v115;
            }
            if (v116 == (void *)((char *)v249 + 8 * v125)) {
              sub_1CCD94EC4(a4, (uint64_t)v64, v111 + 1);
            }
          }
          v111 += 2;
        }
        while (v111 != v112);
        unsigned int v91 = (llvm::Constant *)__src;
        uint64_t v94 = v249;
      }
      BOOL v28 = *(_DWORD *)(a4 + 8) != 0;
      if (v94 != v91) {
        free(v94);
      }
    }
    if (v253 != (llvm::BasicBlock *)&v255) {
      free(v253);
    }
    uint64_t v126 = v259;
    if (v259 != (llvm::BasicBlock *)((char *)&v260 + 8))
    {
LABEL_244:
      free(v126);
      return v28;
    }
    return v28;
  }
  int v68 = *((unsigned __int8 *)v13 + 16);
  if (v68 == 58)
  {
    int v89 = *((_DWORD *)v13 + 5);
    if ((v89 & 0x40000000) != 0) {
      uint64_t v90 = (char *)*((void *)v13 - 1);
    }
    else {
      uint64_t v90 = (char *)v13 - 32 * (v89 & 0x7FFFFFF);
    }
    uint64_t v174 = *((void *)v90 + 4);
    if (*(unsigned char *)(v174 + 16) == 16)
    {
      uint64_t v175 = *(unsigned int *)(v174 + 32);
      if (v175 <= 0x40)
      {
        if (*(void *)(v174 + 24) != 1) {
          goto LABEL_358;
        }
        goto LABEL_388;
      }
      int v186 = 0;
      int64_t v187 = (unint64_t)(v175 + 63) >> 6;
      do
      {
        BOOL v18 = v187-- < 1;
        if (v18) {
          break;
        }
        unint64_t v188 = *(void *)(*(void *)(v174 + 24) + 8 * v187);
        v186 += __clz(v188);
      }
      while (!v188);
      int v189 = v175 | 0xFFFFFFC0;
      if ((v175 & 0x3F) == 0) {
        int v189 = 0;
      }
      if (v186 + v189 == v175 - 1)
      {
LABEL_388:
        if ((v89 & 0x40000000) != 0) {
          v190 = (void *)*((void *)v13 - 1);
        }
        else {
          v190 = (void *)((char *)v13 - 32 * (v89 & 0x7FFFFFF));
        }
        llvm::JumpThreadingPass::computeValueKnownInPredecessorsImpl(a1, *v190, a3, a4, 0, a6, a7);
        uint64_t v193 = *(unsigned int *)(a4 + 8);
        if (v193)
        {
          uint64_t v194 = *(llvm::Constant ****)a4;
          uint64_t v195 = 16 * v193;
          BOOL v28 = 1;
          do
          {
            llvm::Value *v194 = (llvm::Constant **)llvm::ConstantExpr::getNot(*v194, v191, v192);
            v194 += 2;
            v195 -= 16;
          }
          while (v195);
          return v28;
        }
        return 0;
      }
    }
LABEL_358:
    unint64_t Constant = (unsigned __int8 *)llvm::LazyValueInfo::getConstant(*(llvm::LazyValueInfo **)(a1 + 16), v247, a7);
    if (Constant)
    {
      uint64_t v177 = (llvm::Value *)Constant;
      int v178 = Constant[16];
      if ((v178 - 13) > 0xFFFFFFFD) {
        goto LABEL_364;
      }
      if (a5 == 1)
      {
        uint64_t v177 = llvm::Value::stripPointerCasts((llvm::Value *)Constant);
        if (*((unsigned char *)v177 + 16) == 4) {
          goto LABEL_364;
        }
      }
      else if (v178 == 16)
      {
LABEL_364:
        while (1)
        {
          a3 = (llvm::BasicBlock *)*((void *)a3 + 1);
          if (!a3) {
            break;
          }
          uint64_t v179 = *((void *)a3 + 3);
          unsigned int v180 = *(unsigned __int8 *)(v179 + 16);
          if (v179) {
            BOOL v181 = v180 >= 0x1C;
          }
          else {
            BOOL v181 = 0;
          }
          if (v181 && v180 - 29 <= 0xA)
          {
LABEL_372:
            v259 = *(llvm::BasicBlock **)(v179 + 40);
            sub_1CCD94EC4(a4, (uint64_t)v177, (uint64_t *)&v259);
            while (1)
            {
              a3 = (llvm::BasicBlock *)*((void *)a3 + 1);
              if (!a3) {
                goto LABEL_38;
              }
              uint64_t v179 = *((void *)a3 + 3);
              unsigned int v183 = *(unsigned __int8 *)(v179 + 16);
              if (v179) {
                BOOL v184 = v183 >= 0x1C;
              }
              else {
                BOOL v184 = 0;
              }
              if (v184 && v183 - 29 < 0xB) {
                goto LABEL_372;
              }
            }
          }
        }
      }
    }
    goto LABEL_38;
  }
  if ((v68 - 83) < 0xFFFFFFFE) {
    goto LABEL_117;
  }
LABEL_246:
  uint64_t v127 = *((void *)v13 - 8);
  v239 = (llvm::Constant *)*((void *)v13 - 4);
  unsigned int v244 = *((_WORD *)v13 + 9) & 0x3F;
  unsigned int v128 = *(unsigned __int8 *)(v127 + 16);
  uint64_t v242 = (llvm::Value *)v127;
  if (v127 && v128 == 83 || (uint64_t v127 = *((void *)v13 - 4), v129 = *((unsigned __int8 *)v239 + 16), v129 == 83))
  {
    if (*(llvm::BasicBlock **)(v127 + 40) != a3)
    {
      unsigned int v129 = *((unsigned __int8 *)v239 + 16);
      goto LABEL_251;
    }
    uint64_t v135 = *(_DWORD *)(v127 + 20) & 0x7FFFFFF;
    if (!v135) {
      goto LABEL_38;
    }
    uint64_t v136 = 0;
    uint64_t v137 = 0;
    uint64_t v241 = (llvm::ConstantInt *)(*(void *)(*((void *)a3 + 7) + 40) + 272);
    if (a7) {
      int v138 = a7;
    }
    else {
      int v138 = v13;
    }
    int v238 = v138;
    uint64_t v139 = 8 * v135;
    while (1)
    {
      int v140 = *(_DWORD *)(v127 + 20);
      unsigned int v141 = v242;
      if ((v140 & 0x40000000) != 0)
      {
        uint64_t v143 = *(char **)(v127 - 8);
        unsigned int v142 = *(llvm::BasicBlock **)&v143[32 * *(unsigned int *)(v127 + 60) + v137];
        unint64_t v253 = v142;
        if ((llvm::Value *)v127 != v242)
        {
LABEL_275:
          if (v242 && *((unsigned char *)v242 + 16) == 83 && *((llvm::BasicBlock **)v242 + 5) == a3)
          {
            unsigned int v141 = (llvm::ConstantExpr *)sub_1CBF73380((uint64_t)v242, (uint64_t)v142);
            int v140 = *(_DWORD *)(v127 + 20);
          }
          if ((v140 & 0x40000000) != 0) {
            uint64_t v144 = *(void *)(v127 - 8);
          }
          else {
            uint64_t v144 = v127 - 32 * (v140 & 0x7FFFFFF);
          }
          unsigned int v145 = *(unsigned __int8 **)(v144 + v136);
          goto LABEL_287;
        }
      }
      else
      {
        unsigned int v142 = *(llvm::BasicBlock **)(v127 - 32 * (v140 & 0x7FFFFFF) + 32 * *(unsigned int *)(v127 + 60) + v137);
        unint64_t v253 = v142;
        if ((llvm::Value *)v127 != v242) {
          goto LABEL_275;
        }
        uint64_t v143 = (char *)v242 - 32 * (v140 & 0x7FFFFFF);
      }
      unsigned int v141 = *(llvm::ConstantExpr **)&v143[v136];
      unsigned int v145 = (unsigned __int8 *)v239;
      if (v239 && *((unsigned char *)v239 + 16) == 83 && *((llvm::BasicBlock **)v239 + 5) == a3) {
        unsigned int v145 = (unsigned __int8 *)sub_1CBF73380((uint64_t)v239, (uint64_t)v142);
      }
LABEL_287:
      v259 = v241;
      long long v260 = 0u;
      long long v261 = 0u;
      __int16 v262 = 257;
      uint64_t v146 = (unsigned __int8 *)sub_1CC03A634(v244, v141, v145, (uint64_t)&v259, 3);
      if (v146) {
        goto LABEL_288;
      }
      if (v145[16] <= 0x14u)
      {
        BOOL v150 = v141 && *((unsigned __int8 *)v141 + 16) >= 0x1Cu;
        if (!v150 || *((llvm::BasicBlock **)v141 + 5) != a3)
        {
          int PredicateOnEdge = llvm::LazyValueInfo::getPredicateOnEdge(*(llvm::LazyValueInfo **)(a1 + 16), v244, v141, (llvm::Constant *)v145, v253, a3, v238);
          if (PredicateOnEdge != -1)
          {
            uint64_t v153 = ***(void ***)v141;
            unsigned int v154 = *(llvm::ConstantInt **)(v153 + 1888);
            unint64_t v155 = *(unsigned int *)(v153 + 1896);
            LODWORD(v260) = v155 >> 8;
            if (v155 >> 8 > 0x40) {
              operator new[]();
            }
            if (v155 <= 0xFF) {
              unint64_t v156 = 0;
            }
            else {
              unint64_t v156 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v155) + 63);
            }
            v259 = (llvm::BasicBlock *)(v156 & PredicateOnEdge);
            uint64_t v146 = (unsigned __int8 *)llvm::ConstantInt::get(v154, (llvm::LLVMContext *)&v259, v152);
            if (v260 >= 0x41 && v259) {
              MEMORY[0x1D25D9CB0](v259, 0x1000C8000313F17);
            }
            if (v146)
            {
LABEL_288:
              unsigned int v147 = v146[16];
              BOOL v18 = v147 > 0x10;
              int v148 = (1 << v147) & 0x11800;
              if (!v18 && v148 != 0) {
                sub_1CCD94EC4(a4, (uint64_t)v146, (uint64_t *)&v253);
              }
            }
          }
        }
      }
      v137 += 8;
      v136 += 32;
      if (v139 == v137) {
        goto LABEL_38;
      }
    }
  }
LABEL_251:
  if (v129 <= 0x14)
  {
    uint64_t v240 = *(llvm::ConstantInt ***)v13;
    if ((*(_DWORD *)(*(void *)v13 + 8) & 0xFE) != 0x12)
    {
      if (v128 < 0x1C || *((llvm::BasicBlock **)v242 + 5) != a3)
      {
        uint64_t v130 = *((void *)a3 + 1);
        if (v130)
        {
          while (1)
          {
            uint64_t v131 = *(void *)(v130 + 24);
            unsigned int v132 = *(unsigned __int8 *)(v131 + 16);
            BOOL v133 = v131 && v132 >= 0x1C;
            if (v133 && v132 - 29 < 0xB) {
              break;
            }
            uint64_t v130 = *(void *)(v130 + 8);
            if (!v130) {
              goto LABEL_38;
            }
          }
          if (a7) {
            uint64_t v13 = a7;
          }
LABEL_397:
          v259 = *(llvm::BasicBlock **)(v131 + 40);
          int v196 = llvm::LazyValueInfo::getPredicateOnEdge(*(llvm::LazyValueInfo **)(a1 + 16), v244, v242, v239, v259, a3, v13);
          if (v196 != -1)
          {
            uint64_t v197 = llvm::ConstantInt::get((llvm::ConstantInt *)v240, v196, 0);
            sub_1CCD94EC4(a4, (uint64_t)v197, (uint64_t *)&v259);
          }
          while (1)
          {
            uint64_t v130 = *(void *)(v130 + 8);
            if (!v130) {
              break;
            }
            uint64_t v131 = *(void *)(v130 + 24);
            unsigned int v198 = *(unsigned __int8 *)(v131 + 16);
            if (v131) {
              BOOL v199 = v198 >= 0x1C;
            }
            else {
              BOOL v199 = 0;
            }
            if (v199 && v198 - 29 < 0xB) {
              goto LABEL_397;
            }
          }
        }
        goto LABEL_38;
      }
      if (v128 != 41
        || v129 != 16
        || (uint64_t v201 = *((void *)v242 - 8)) == 0
        || (uint64_t v202 = *((void *)v242 - 4)) == 0
        || (uint64_t v203 = *((void *)v242 - 4), *(unsigned char *)(v202 + 16) != 16)
        || *(unsigned __int8 *)(v201 + 16) >= 0x1Cu && *(llvm::BasicBlock **)(v201 + 40) == a3)
      {
        v259 = (llvm::BasicBlock *)((char *)&v260 + 8);
        *(void *)&long long v260 = 0x800000000;
        int v209 = *((_DWORD *)v13 + 5);
        if ((v209 & 0x40000000) != 0) {
          uint64_t v210 = (void *)*((void *)v13 - 1);
        }
        else {
          uint64_t v210 = (void *)((char *)v13 - 32 * (v209 & 0x7FFFFFF));
        }
        llvm::JumpThreadingPass::computeValueKnownInPredecessorsImpl(a1, *v210, a3, &v259, 0, a6, a7);
        uint64_t v126 = v259;
        if (v260)
        {
          uint64_t v212 = 16 * v260;
          uint64_t v213 = (uint64_t *)((char *)v259 + 8);
          do
          {
            uint64_t v214 = (uint64_t ***)*(v213 - 1);
            if (v244 <= 0xF) {
              uint64_t FCmp = llvm::ConstantExpr::getFCmp((llvm::ConstantExpr *)v244, v214, v239, 0);
            }
            else {
              uint64_t FCmp = (uint64_t)llvm::ConstantExpr::getICmp((llvm::ConstantExpr *)v244, (llvm::Type *)v214, v239, 0, v211);
            }
            if (FCmp)
            {
              unsigned int v216 = *(unsigned __int8 *)(FCmp + 16);
              BOOL v18 = v216 > 0x10;
              int v217 = (1 << v216) & 0x11800;
              if (!v18 && v217 != 0) {
                sub_1CCD94EC4(a4, FCmp, v213);
              }
            }
            v213 += 2;
            v212 -= 16;
          }
          while (v212);
          uint64_t v126 = v259;
        }
        BOOL v28 = *(_DWORD *)(a4 + 8) != 0;
        if (v126 != (void *)((char *)&v260 + 8)) {
          goto LABEL_244;
        }
        return v28;
      }
      uint64_t v204 = *((void *)a3 + 1);
      if (!v204) {
        goto LABEL_38;
      }
      while (1)
      {
        uint64_t v205 = *(void *)(v204 + 24);
        unsigned int v206 = *(unsigned __int8 *)(v205 + 16);
        BOOL v207 = v205 && v206 >= 0x1C;
        if (v207 && v206 - 29 < 0xB) {
          break;
        }
        uint64_t v204 = *(void *)(v204 + 8);
        if (!v204) {
          goto LABEL_38;
        }
      }
      uint64_t v221 = v242;
      if (a7) {
        uint64_t v221 = a7;
      }
      int v243 = v221;
LABEL_450:
      unsigned int v246 = *(llvm::BasicBlock **)(v205 + 40);
      llvm::LazyValueInfo::getConstantRangeOnEdge(*(llvm::LazyValueInfo **)(a1 + 16), (llvm::Value *)v201, v246, a3, v243, (uint64_t)&v259);
      unsigned int v222 = *(_DWORD *)(v203 + 32);
      if (v222 > 0x40) {
        operator new[]();
      }
      uint64_t v223 = *(void **)(v203 + 24);
      LODWORD(v249) = *(_DWORD *)(v203 + 32);
      __src = v223;
      LODWORD(p_src) = v222;
      unint64_t v253 = (llvm::BasicBlock *)v223;
      llvm::APInt::operator+=((uint64_t)&v253, 1uLL);
      unsigned int v251 = p_src;
      uint64_t v250 = (uint64_t)v253;
      llvm::ConstantRange::add((uint64_t)&v259, (const llvm::ConstantRange *)&__src, (uint64_t)&v253);
      if (v260 >= 0x41 && v259) {
        MEMORY[0x1D25D9CB0](v259, 0x1000C8000313F17);
      }
      v259 = v253;
      LODWORD(v260) = p_src;
      LODWORD(p_src) = 0;
      if (v261 >= 0x41 && *((void *)&v260 + 1))
      {
        MEMORY[0x1D25D9CB0](*((void *)&v260 + 1), 0x1000C8000313F17);
        *((void *)&v260 + 1) = v255;
        LODWORD(v261) = v256;
        LODWORD(v256) = 0;
        if (p_src >= 0x41 && v253) {
          MEMORY[0x1D25D9CB0](v253, 0x1000C8000313F17);
        }
      }
      else
      {
        *((void *)&v260 + 1) = v255;
        LODWORD(v261) = v256;
        LODWORD(v256) = 0;
      }
      if (v251 >= 0x41 && v250) {
        MEMORY[0x1D25D9CB0](v250, 0x1000C8000313F17);
      }
      if (v249 >= 0x41 && __src) {
        MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
      }
      llvm::ConstantRange::makeExactICmpRegion(v244, (uint64_t)v239 + 24, (uint64_t)&v253);
      if (llvm::ConstantRange::contains((llvm::ConstantRange *)&v253, (const llvm::ConstantRange *)&v259))
      {
        uint64_t v225 = *(void *)*v240;
        Splat = *(void **)(v225 + 1560);
        if (!Splat)
        {
          uint64_t v227 = *(llvm::ConstantInt **)(v225 + 1888);
          unsigned int v228 = *(_DWORD *)(v225 + 1896);
          LODWORD(v249) = v228 >> 8;
          if (v228 >> 8 > 0x40) {
            operator new[]();
          }
          if (v228 <= 0xFF) {
            LOBYTE(v229) = 0;
          }
          else {
            unint64_t v229 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v228) + 63);
          }
          __src = (void *)(v229 & 1);
          Splat = llvm::ConstantInt::get(v227, (llvm::LLVMContext *)&__src, v224);
          if (v249 >= 0x41 && __src) {
            MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
          }
          *(void *)(v225 + 1560) = Splat;
        }
      }
      else
      {
        llvm::ConstantRange::inverse((uint64_t)&v253, (uint64_t)&__src);
        BOOL v231 = llvm::ConstantRange::contains((llvm::ConstantRange *)&__src, (const llvm::ConstantRange *)&v259);
        if (v251 >= 0x41 && v250) {
          MEMORY[0x1D25D9CB0](v250, 0x1000C8000313F17);
        }
        if (v249 >= 0x41 && __src) {
          MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
        }
        if (!v231)
        {
LABEL_472:
          if (v256 >= 0x41 && v255) {
            MEMORY[0x1D25D9CB0](v255, 0x1000C8000313F17);
          }
          if (p_src >= 0x41 && v253) {
            MEMORY[0x1D25D9CB0](v253, 0x1000C8000313F17);
          }
          if (v261 >= 0x41 && *((void *)&v260 + 1)) {
            MEMORY[0x1D25D9CB0](*((void *)&v260 + 1), 0x1000C8000313F17);
          }
          if (v260 >= 0x41 && v259) {
            MEMORY[0x1D25D9CB0](v259, 0x1000C8000313F17);
          }
          while (1)
          {
            uint64_t v204 = *(void *)(v204 + 8);
            if (!v204) {
              goto LABEL_38;
            }
            uint64_t v205 = *(void *)(v204 + 24);
            unsigned int v233 = *(unsigned __int8 *)(v205 + 16);
            if (v205) {
              BOOL v234 = v233 >= 0x1C;
            }
            else {
              BOOL v234 = 0;
            }
            if (v234 && v233 - 29 < 0xB) {
              goto LABEL_450;
            }
          }
        }
        uint64_t v232 = *(void *)*v240;
        Splat = *(void **)(v232 + 1568);
        if (!Splat)
        {
          uint64_t v236 = *(llvm::ConstantInt **)(v232 + 1888);
          unsigned int v237 = *(_DWORD *)(v232 + 1896);
          LODWORD(v249) = v237 >> 8;
          if (v237 >> 8 > 0x40) {
            operator new[]();
          }
          __src = 0;
          Splat = llvm::ConstantInt::get(v236, (llvm::LLVMContext *)&__src, v230);
          if (v249 >= 0x41 && __src) {
            MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
          }
          *(void *)(v232 + 1568) = Splat;
        }
      }
      if ((v240[1] & 0xFE) == 0x12) {
        Splat = llvm::ConstantVector::getSplat((llvm::Type *)(*((unsigned int *)v240 + 8) | ((unint64_t)(*((_DWORD *)v240 + 2) == 19) << 32)), (uint64_t)Splat);
      }
      sub_1CCD94EC4(a4, (uint64_t)Splat, (uint64_t *)&v246);
      goto LABEL_472;
    }
  }
LABEL_117:
  if (v68 != 85) {
    goto LABEL_358;
  }
  uint64_t v69 = *((void *)v13 - 8);
  if (v69)
  {
    int v70 = *(unsigned __int8 *)(v69 + 16);
    if ((v70 - 13) <= 0xFFFFFFFD)
    {
      if (a5 == 1)
      {
        uint64_t v71 = llvm::Value::stripPointerCasts(*((llvm::Value **)v13 - 8));
        if (*((unsigned char *)v71 + 16) == 4) {
          uint64_t v69 = (uint64_t)v71;
        }
        else {
          uint64_t v69 = 0;
        }
      }
      else if (v70 != 16)
      {
        uint64_t v69 = 0;
      }
    }
  }
  uint64_t v157 = *((void *)v13 - 4);
  if (v157)
  {
    int v158 = *(unsigned __int8 *)(v157 + 16);
    if ((v158 - 13) >= 0xFFFFFFFE)
    {
      v259 = (llvm::BasicBlock *)((char *)&v260 + 8);
      *(void *)&long long v260 = 0x800000000;
      BOOL v160 = v69 != 0;
      goto LABEL_324;
    }
    if (a5 == 1)
    {
      BOOL v159 = llvm::Value::stripPointerCasts(*((llvm::Value **)v13 - 4));
      if (*((unsigned char *)v159 + 16) == 4) {
        uint64_t v157 = (uint64_t)v159;
      }
      else {
        uint64_t v157 = 0;
      }
    }
    else if (v158 != 16)
    {
      uint64_t v157 = 0;
    }
  }
  v259 = (llvm::BasicBlock *)((char *)&v260 + 8);
  *(void *)&long long v260 = 0x800000000;
  BOOL v160 = v69 != 0;
  if (!(v69 | v157)) {
    goto LABEL_358;
  }
LABEL_324:
  int v161 = llvm::JumpThreadingPass::computeValueKnownInPredecessorsImpl(a1, *((void *)v13 - 12), a3, &v259, 0, a6, a7);
  unint64_t v162 = (uint64_t *)v259;
  if (!v161)
  {
    if (v259 != (llvm::BasicBlock *)((char *)&v260 + 8)) {
      free(v259);
    }
    goto LABEL_358;
  }
  if (v260)
  {
    unint64_t v163 = (uint64_t *)((char *)v259 + 16 * v260);
    do
    {
      uint64_t v164 = *v162;
      if (*v162) {
        BOOL v165 = *(unsigned char *)(*v162 + 16) == 16;
      }
      else {
        BOOL v165 = 0;
      }
      int v166 = v160;
      if (v165)
      {
        uint64_t v167 = *(unsigned int *)(v164 + 32);
        if (v167 > 0x40)
        {
          int v169 = 0;
          int64_t v170 = (unint64_t)(v167 + 63) >> 6;
          do
          {
            BOOL v18 = v170-- < 1;
            if (v18) {
              break;
            }
            unint64_t v171 = *(void *)(*(void *)(v164 + 24) + 8 * v170);
            v169 += __clz(v171);
          }
          while (!v171);
          int v172 = v167 | 0xFFFFFFC0;
          if ((v167 & 0x3F) == 0) {
            int v172 = 0;
          }
          BOOL v168 = v169 + v172 == v167 - 1;
        }
        else
        {
          BOOL v168 = *(void *)(v164 + 24) == 1;
        }
        int v166 = v168;
      }
      if (v166) {
        uint64_t v173 = v69;
      }
      else {
        uint64_t v173 = v157;
      }
      if (v173) {
        sub_1CCD94EC4(a4, v173, v162 + 1);
      }
      v162 += 2;
    }
    while (v162 != v163);
    unint64_t v162 = (uint64_t *)v259;
  }
  BOOL v28 = *(_DWORD *)(a4 + 8) != 0;
  if (v162 != (uint64_t *)((char *)&v260 + 8))
  {
    uint64_t v126 = v162;
    goto LABEL_244;
  }
  return v28;
}

uint64_t sub_1CCD94EC4(uint64_t result, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *(unsigned int *)(result + 8);
  if (v3 >= *(_DWORD *)(result + 12)) {
    return sub_1CD76D8A0(result, a2, *a3);
  }
  uint64_t v4 = (uint64_t *)(*(void *)result + 16 * v3);
  *uint64_t v4 = a2;
  v4[1] = *a3;
  *(_DWORD *)(result + 8) = v3 + 1;
  return result;
}

uint64_t sub_1CCD94EF8(uint64_t result, uint64_t a2, void *a3)
{
  uint64_t v3 = *(unsigned int *)(result + 8);
  if (v3 >= *(_DWORD *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v4 = (void *)(*(void *)result + 16 * v3);
  *uint64_t v4 = a2;
  v4[1] = *a3;
  *(_DWORD *)(result + 8) = v3 + 1;
  return result;
}

llvm::BlockAddress **llvm::JumpThreadingPass::maybeMergeBasicBlockIntoOnlyPred(llvm::LazyValueInfo **this, llvm::BlockAddress **a2)
{
  uint64_t result = (llvm::BlockAddress **)llvm::BasicBlock::getSinglePredecessor((llvm::BasicBlock *)a2);
  if (result)
  {
    unsigned int v6 = result;
    uint64_t result = 0;
    uint64_t v7 = v6[5];
    if (v7) {
      uint64_t v8 = (uint64_t)v7 - 24;
    }
    else {
      uint64_t v8 = 0;
    }
    if (*(unsigned __int8 *)(v8 + 16) - 29 >= 0xB) {
      uint64_t v8 = 0;
    }
    if (*(unsigned __int8 *)(v8 + 16) - 33 >= 6)
    {
      switch(*(unsigned char *)(v8 + 16))
      {
        case 0x1E:
          if ((*(_DWORD *)(v8 + 20) & 0x7FFFFFF) == 3) {
            int v9 = 2;
          }
          else {
            int v9 = 1;
          }
          goto LABEL_13;
        case 0x1F:
          int v9 = (*(_DWORD *)(v8 + 20) >> 1) & 0x3FFFFFF;
          goto LABEL_13;
        case 0x20:
          int v9 = (*(_DWORD *)(v8 + 20) & 0x7FFFFFF) - 1;
          goto LABEL_13;
        case 0x21:
        case 0x22:
        case 0x23:
        case 0x24:
        case 0x25:
        case 0x26:
          __break(1u);
          goto LABEL_24;
        case 0x27:
LABEL_24:
          int v9 = *(_DWORD *)(v8 + 80) + 1;
LABEL_13:
          uint64_t result = 0;
          if (v6 != a2 && v9 == 1)
          {
            if ((*((_WORD *)a2 + 9) & 0x7FFF) == 0
              || (uint64_t v11 = llvm::BlockAddress::get(a2[7], (llvm::Function *)a2, v5),
                  llvm::Constant::removeDeadConstantUsers((uint64_t)v11),
                  !*((void *)v11 + 1)))
            {
              if (sub_1CCD932C8((uint64_t)(this + 8), (unint64_t)v6))
              {
                uint64_t v12 = a2;
                sub_1CD76C590((uint64_t)(this + 8), (unint64_t *)&v12);
              }
              llvm::LazyValueInfo::eraseBlock(this[2], (llvm::BasicBlock *)v6);
              llvm::MergeBasicBlockIntoOnlyPred((unint64_t)a2, this[4], v10);
            }
            uint64_t result = 0;
          }
          break;
        default:
          return result;
      }
    }
  }
  return result;
}

uint64_t llvm::JumpThreadingPass::tryToUnfoldSelectInCurrBB(llvm::JumpThreadingPass *this, llvm::BasicBlock *a2)
{
  uint64_t v4 = *(void *)(*((void *)a2 + 7) + 112);
  if (v4 && (*(unsigned char *)(v4 + 18) & 0x20) != 0) {
    return 0;
  }
  if (*((void *)this + 28))
  {
    for (uint64_t i = (void *)*((void *)this + 27); i; uint64_t i = (void *)*i)
    {
      unint64_t v6 = i[4];
      if (v6 <= (unint64_t)a2)
      {
        if (v6 >= (unint64_t)a2) {
          return 0;
        }
        ++i;
      }
    }
    goto LABEL_17;
  }
  uint64_t v7 = *((unsigned int *)this + 18);
  if (v7)
  {
    uint64_t v8 = (llvm::BasicBlock **)*((void *)this + 8);
    uint64_t v9 = 8 * v7;
    while (*v8 != a2)
    {
      ++v8;
      v9 -= 8;
      if (!v9) {
        goto LABEL_17;
      }
    }
    if (v9) {
      return 0;
    }
  }
LABEL_17:
  uint64_t result = 0;
  uint64_t v11 = *((void *)a2 + 6);
  uint64_t v12 = v11 - 24;
  if (v11) {
    uint64_t v13 = v11 - 24;
  }
  else {
    uint64_t v13 = 0;
  }
  if (v11 && *(unsigned char *)(v13 + 16) == 83)
  {
    do
    {
      int v14 = *(_DWORD *)(v12 + 20);
      if ((v14 & 0x40000000) != 0)
      {
        uint64_t v16 = *(void *)(v12 - 8);
        uint64_t v15 = v14 & 0x7FFFFFF;
        if (v15)
        {
LABEL_26:
          uint64_t v17 = 32 * v15;
          while (*(unsigned char *)(*(void *)v16 + 16) != 16)
          {
            v16 += 32;
            v17 -= 32;
            if (!v17) {
              goto LABEL_61;
            }
          }
          BOOL v18 = *(uint64_t **)(v12 + 8);
          if (!v18) {
            goto LABEL_61;
          }
          while (2)
          {
            uint64_t v19 = v18[3];
            int v20 = *(unsigned __int8 *)(v19 + 16);
            if (v19 && v20 == 81)
            {
              if (*(llvm::BasicBlock **)(v19 + 40) == a2)
              {
                BOOL v21 = *(uint64_t **)(v19 + 8);
                if (v21)
                {
                  if (!v21[1])
                  {
                    int v22 = *(_DWORD *)(v19 + 20);
                    uint64_t v23 = (v22 & 0x40000000) != 0 ? *(void *)(v19 - 8) : v19 - 32 * (v22 & 0x7FFFFFF);
                    if (*(unsigned char *)(*(void *)(v19
                                              + 32 * (1 - (((unint64_t)v18 - v23) >> 5))
                                              - 64)
                                  + 16) == 16)
                    {
                      uint64_t v19 = v21[3];
                      if (v19)
                      {
                        if (*(unsigned char *)(v19 + 16) == 85 && *(llvm::BasicBlock **)(v19 + 40) == a2)
                        {
                          uint64_t v24 = *v21;
LABEL_47:
                          uint64_t v25 = *(void *)(v19 - 96);
                          if (sub_1CCD9E6FC((unsigned __int8 *)v19)) {
                            LOBYTE(v26) = 0;
                          }
                          else {
                            BOOL v26 = !sub_1CCD9E7F4((unsigned __int8 *)v19);
                          }
                          if (v25) {
                            BOOL v27 = v25 == v24;
                          }
                          else {
                            BOOL v27 = 0;
                          }
                          if (v27)
                          {
                            if (*(_DWORD *)(*(void *)v24 + 8) != 269) {
                              LOBYTE(v26) = 0;
                            }
                            if (v26)
                            {
                              uint64_t v29 = *(llvm::Value **)(v19 - 96);
                              if (*((unsigned char *)this + 240))
                              {
                                uint64_t DomTree = llvm::DomTreeUpdater::getDomTree(*((llvm::DomTreeUpdater **)this + 4));
                                if ((sub_1CC16A22C((uint64_t ***)v29, 0, v19, DomTree, 0, 0) & 1) == 0)
                                {
                                  int v31 = operator new(0x60uLL);
                                  v31[13] = v31[13] & 0x38000000 | 1;
                                  unsigned int v32 = (llvm::Value *)(v31 + 8);
                                  *(void *)int v31 = 0;
                                  *((void *)v31 + 1) = 0;
                                  *((void *)v31 + 2) = 0;
                                  *((void *)v31 + 3) = v31 + 8;
                                  __p = "cond.fr";
                                  __int16 v34 = 259;
                                  llvm::FreezeInst::FreezeInst((llvm::FreezeInst *)(v31 + 8), v29, (const char **)&__p, (llvm::Instruction *)v19);
                                  uint64_t v29 = v32;
                                }
                              }
                              sub_1CD1290BC((uint64_t)v29, v19);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            else if (v19 && v20 == 85 && *(llvm::BasicBlock **)(v19 + 40) == a2)
            {
              uint64_t v24 = *v18;
              goto LABEL_47;
            }
            BOOL v18 = (uint64_t *)v18[1];
            if (!v18) {
              break;
            }
            continue;
          }
        }
      }
      else
      {
        uint64_t v15 = v14 & 0x7FFFFFF;
        uint64_t v16 = v12 - 32 * v15;
        if (v15) {
          goto LABEL_26;
        }
      }
LABEL_61:
      uint64_t result = 0;
      uint64_t v11 = *(void *)(v11 + 8);
      uint64_t v12 = v11 - 24;
      if (!v11) {
        uint64_t v12 = 0;
      }
      int v28 = *(unsigned __int8 *)(v12 + 16);
      if (v28 != 83) {
        uint64_t v12 = 0;
      }
    }
    while (v11 && v28 == 83);
  }
  return result;
}

uint64_t llvm::JumpThreadingPass::processGuards(llvm::JumpThreadingPass *this, llvm::BasicBlock *a2)
{
  uint64_t v2 = *((void *)a2 + 1);
  if (v2)
  {
    while (1)
    {
      uint64_t v5 = *(void *)(v2 + 24);
      unsigned int v6 = *(unsigned __int8 *)(v5 + 16);
      BOOL v7 = v5 && v6 >= 0x1C;
      if (v7 && v6 - 29 <= 0xA) {
        break;
      }
      uint64_t v2 = *(void *)(v2 + 8);
      if (!v2) {
        return 0;
      }
    }
    while (1)
    {
      uint64_t v2 = *(void *)(v2 + 8);
      if (!v2) {
        break;
      }
      uint64_t v9 = *(void *)(v2 + 24);
      unsigned int v10 = *(unsigned __int8 *)(v9 + 16);
      if (v9) {
        BOOL v11 = v10 >= 0x1C;
      }
      else {
        BOOL v11 = 0;
      }
      if (v11 && v10 - 29 <= 0xA)
      {
        uint64_t v13 = *(llvm::BasicBlock **)(v5 + 40);
        while (1)
        {
          uint64_t v2 = *(void *)(v2 + 8);
          if (!v2) {
            break;
          }
          uint64_t v14 = *(void *)(v2 + 24);
          unsigned int v15 = *(unsigned __int8 *)(v14 + 16);
          if (v14) {
            BOOL v16 = v15 >= 0x1C;
          }
          else {
            BOOL v16 = 0;
          }
          if (v16 && v15 - 29 < 0xB) {
            return 0;
          }
        }
        BOOL v18 = *(llvm::BasicBlock **)(v9 + 40);
        if (v13 == v18) {
          return 0;
        }
        uint64_t result = llvm::BasicBlock::getSinglePredecessor(v13);
        if (!result) {
          return result;
        }
        uint64_t v20 = result;
        if (result != llvm::BasicBlock::getSinglePredecessor(v18)) {
          return 0;
        }
        uint64_t v21 = *(void *)(v20 + 40);
        if (v21 == v20 + 40) {
          return 0;
        }
        uint64_t result = 0;
        if (v21) {
          uint64_t v22 = v21 - 24;
        }
        else {
          uint64_t v22 = 0;
        }
        unsigned int v23 = *(unsigned __int8 *)(v22 + 16) - 40;
        if (v23 >= 0xFFFFFFF5) {
          uint64_t v24 = v22;
        }
        else {
          uint64_t v24 = 0;
        }
        if (v21)
        {
          if (*(unsigned char *)(v24 + 16) == 30 && v23 >= 0xFFFFFFF5)
          {
            BOOL v26 = (void *)*((void *)a2 + 6);
            if (v26 == (void *)((char *)a2 + 40)) {
              return 0;
            }
            while (1)
            {
              uint64_t v27 = v26 ? (uint64_t)(v26 - 3) : 0;
              if (v26)
              {
                if (*(unsigned char *)(v27 + 16) == 84)
                {
                  uint64_t v28 = *(void *)(v27 - 32);
                  if (v28)
                  {
                    if (!*(unsigned char *)(v28 + 16)
                      && *(void *)(v28 + 24) == *(void *)(v27 + 72)
                      && *(_DWORD *)(v28 + 36) == 125
                      && llvm::JumpThreadingPass::threadGuard((uint64_t)this, a2, v27, v24))
                    {
                      break;
                    }
                  }
                }
              }
              uint64_t result = 0;
              BOOL v26 = (void *)v26[1];
              if (v26 == (void *)((char *)a2 + 40)) {
                return result;
              }
            }
            return 1;
          }
        }
        return result;
      }
    }
  }
  return 0;
}

uint64_t sub_1CCD96148(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1 == a1 + 40)
  {
    uint64_t v3 = 0;
  }
  else
  {
    if (v1) {
      uint64_t v2 = v1 - 24;
    }
    else {
      uint64_t v2 = 0;
    }
    if (*(unsigned __int8 *)(v2 + 16) - 29 >= 0xB) {
      uint64_t v3 = 0;
    }
    else {
      uint64_t v3 = v2;
    }
  }
  uint64_t v4 = *(void *)(llvm::Instruction::getSuccessor((llvm::Instruction *)v3, 0) + 8);
  if (v4)
  {
    while (1)
    {
      uint64_t v5 = *(void *)(v4 + 24);
      unsigned int v6 = *(unsigned __int8 *)(v5 + 16);
      BOOL v7 = v5 && v6 >= 0x1C;
      if (v7 && v6 - 29 <= 0xA) {
        break;
      }
      uint64_t v4 = *(void *)(v4 + 8);
      if (!v4) {
        goto LABEL_19;
      }
    }
    unsigned int v22 = 0;
LABEL_52:
    ++v22;
    while (1)
    {
      uint64_t v4 = *(void *)(v4 + 8);
      if (!v4) {
        break;
      }
      uint64_t v23 = *(void *)(v4 + 24);
      unsigned int v24 = *(unsigned __int8 *)(v23 + 16);
      if (v23) {
        BOOL v25 = v24 >= 0x1C;
      }
      else {
        BOOL v25 = 0;
      }
      if (v25 && v24 - 29 < 0xB) {
        goto LABEL_52;
      }
    }
  }
  else
  {
LABEL_19:
    unsigned int v22 = 0;
  }
  if (*(unsigned char *)(v3 + 16) != 30)
  {
    uint64_t v9 = 0;
    switch(*(unsigned char *)(v3 + 16))
    {
      case 0x1E:
        __break(1u);
        goto LABEL_68;
      case 0x1F:
        LODWORD(v9) = (*(_DWORD *)(v3 + 20) >> 1) & 0x3FFFFFF;
        goto LABEL_64;
      case 0x20:
      case 0x26:
LABEL_68:
        LODWORD(v9) = (*(_DWORD *)(v3 + 20) & 0x7FFFFFF) - 1;
        goto LABEL_64;
      case 0x21:
        goto LABEL_22;
      case 0x24:
        LODWORD(v9) = *(_WORD *)(v3 + 18) & 1;
        goto LABEL_64;
      case 0x25:
        return v9;
      case 0x27:
        LODWORD(v9) = *(_DWORD *)(v3 + 80) + 1;
LABEL_64:
        if (v9 == 1) {
          return 0;
        }
        goto LABEL_23;
      default:
        goto LABEL_23;
    }
  }
  if ((*(_DWORD *)(v3 + 20) & 0x7FFFFFF) != 3) {
    return 0;
  }
LABEL_22:
  LODWORD(v9) = 2;
LABEL_23:
  int v10 = v9;
  unsigned int v11 = 1;
  LODWORD(v9) = 0;
  do
  {
    uint64_t v12 = *(void *)(llvm::Instruction::getSuccessor((llvm::Instruction *)v3, v11) + 8);
    if (v12)
    {
      while (1)
      {
        uint64_t v13 = *(void *)(v12 + 24);
        unsigned int v14 = *(unsigned __int8 *)(v13 + 16);
        BOOL v15 = v13 && v14 >= 0x1C;
        if (v15 && v14 - 29 <= 0xA) {
          break;
        }
        uint64_t v12 = *(void *)(v12 + 8);
        if (!v12) {
          goto LABEL_34;
        }
      }
      unsigned int v17 = 0;
LABEL_42:
      ++v17;
      while (1)
      {
        uint64_t v12 = *(void *)(v12 + 8);
        if (!v12) {
          break;
        }
        uint64_t v18 = *(void *)(v12 + 24);
        unsigned int v19 = *(unsigned __int8 *)(v18 + 16);
        if (v18) {
          BOOL v20 = v19 >= 0x1C;
        }
        else {
          BOOL v20 = 0;
        }
        if (v20 && v19 - 29 < 0xB) {
          goto LABEL_42;
        }
      }
    }
    else
    {
LABEL_34:
      unsigned int v17 = 0;
    }
    if (v17 >= v22) {
      uint64_t v9 = v9;
    }
    else {
      uint64_t v9 = v11;
    }
    if (v17 < v22) {
      unsigned int v22 = v17;
    }
    ++v11;
  }
  while (v11 != v10);
  return v9;
}

uint64_t llvm::JumpThreadingPass::processThreadableEdges(uint64_t a1, llvm::Value **a2, llvm::BasicBlock *a3, uint64_t a4, llvm::Instruction *a5)
{
  v175[16] = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 224))
  {
    for (uint64_t i = *(void **)(a1 + 216); i; uint64_t i = (void *)*i)
    {
      unint64_t v9 = i[4];
      if (v9 <= (unint64_t)a3)
      {
        if (v9 >= (unint64_t)a3) {
          return 0;
        }
        ++i;
      }
    }
  }
  else
  {
    uint64_t v10 = *(unsigned int *)(a1 + 72);
    if (v10)
    {
      unsigned int v11 = *(llvm::BasicBlock ***)(a1 + 64);
      uint64_t v12 = 8 * v10;
      while (*v11 != a3)
      {
        ++v11;
        v12 -= 8;
        if (!v12) {
          goto LABEL_16;
        }
      }
      if (v12) {
        return 0;
      }
    }
  }
LABEL_16:
  uint64_t v173 = v175;
  uint64_t v174 = 0x800000000;
  if (!sub_1CD76C6A4(a1, (llvm::Value *)a2, a3, (uint64_t)&v173, a4, a5))
  {
    uint64_t v13 = (uint64_t)llvm::JumpThreadingPass::maybethreadThroughTwoBasicBlocks((llvm::JumpThreadingPass *)a1, a3, a2);
    goto LABEL_187;
  }
  int v158 = v162;
  BOOL v159 = v162;
  uint64_t v160 = 16;
  int v161 = 0;
  int64_t v170 = v172;
  *(void *)unint64_t v171 = 0x1000000000;
  if (!v174)
  {
    uint64_t v13 = 0;
    goto LABEL_183;
  }
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v156 = a1 + 64;
  unsigned int v17 = v173;
  uint64_t v18 = &v173[2 * v174];
  uint64_t v19 = (uint64_t)a3 + 40;
  do
  {
    BOOL v20 = (void *)v17[1];
    __p = v20;
    uint64_t v21 = v159;
    uint64_t v22 = HIDWORD(v160);
    if (v159 == v158)
    {
      if (HIDWORD(v160))
      {
        uint64_t v23 = 0;
        uint64_t v24 = 8 * HIDWORD(v160);
        BOOL v25 = v159;
        while (*(void **)v25 != v20)
        {
          if (*(void *)v25 == -2) {
            uint64_t v23 = v25;
          }
          v25 += 8;
          v24 -= 8;
          if (!v24)
          {
            if (!v23) {
              goto LABEL_27;
            }
            *(void *)uint64_t v23 = v20;
            --v161;
            goto LABEL_51;
          }
        }
        goto LABEL_112;
      }
LABEL_27:
      unsigned int v26 = v160;
      if (HIDWORD(v160) < v160)
      {
        ++HIDWORD(v160);
        *(void *)&v159[8 * v22] = v20;
        goto LABEL_51;
      }
    }
    else
    {
      unsigned int v26 = v160;
    }
    if (3 * v26 <= 4 * (HIDWORD(v160) - v161))
    {
      if (v26 >= 0x40) {
        v26 *= 2;
      }
      else {
        unsigned int v26 = 128;
      }
    }
    else if (v26 - HIDWORD(v160) >= v26 >> 3)
    {
      goto LABEL_32;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v158, v26);
    unsigned int v26 = v160;
    uint64_t v21 = v159;
LABEL_32:
    unsigned int v27 = v26 - 1;
    unsigned int v28 = (v26 - 1) & ((v20 >> 4) ^ (v20 >> 9));
    uint64_t v29 = &v21[8 * v28];
    int v30 = *(void **)v29;
    if (*(void *)v29 == -1)
    {
      int v31 = 0;
LABEL_44:
      if (v31) {
        uint64_t v35 = v31;
      }
      else {
        uint64_t v35 = (void **)v29;
      }
      if (*v35 != v20)
      {
        if (*v35 == (void *)-2) {
          --v161;
        }
        else {
          ++HIDWORD(v160);
        }
        *uint64_t v35 = v20;
LABEL_51:
        uint64_t v36 = 0;
        uint64_t v37 = *v17;
        uint64_t Successor = 0;
        if (*(unsigned __int8 *)(v37 + 16) - 11 >= 2)
        {
          uint64_t v38 = *(void *)v19;
          if (*(void *)v19 == v19) {
            goto LABEL_75;
          }
          if (v38) {
            uint64_t v39 = v38 - 24;
          }
          else {
            uint64_t v39 = 0;
          }
          unsigned int v40 = *(unsigned __int8 *)(v39 + 16) - 40;
          if (v40 >= 0xFFFFFFF5) {
            uint64_t v41 = v39;
          }
          else {
            uint64_t v41 = 0;
          }
          int v42 = *(unsigned __int8 *)(v41 + 16);
          if (v38 && (v42 == 30 ? (BOOL v43 = v40 >= 0xFFFFFFF5) : (BOOL v43 = 0), v43))
          {
            uint64_t v44 = *(unsigned int *)(v37 + 32);
            if (v44 > 0x40)
            {
              int v50 = 0;
              int64_t v51 = (unint64_t)(v44 + 63) >> 6;
              do
              {
                if (v51-- < 1) {
                  break;
                }
                unint64_t v53 = *(void *)(*(void *)(v37 + 24) + 8 * v51);
                v50 += __clz(v53);
              }
              while (!v53);
              int v54 = v44 | 0xFFFFFFC0;
              if ((v44 & 0x3F) == 0) {
                int v54 = 0;
              }
              BOOL v45 = v50 + v54 == v44;
            }
            else
            {
              BOOL v45 = *(void *)(v37 + 24) == 0;
            }
            uint64_t v55 = v45;
            uint64_t v36 = *(void *)(v41 + 32 * (v55 << 63 >> 63) - 32);
          }
          else if (v38 && (v42 == 31 ? (BOOL v46 = v40 >= 0xFFFFFFF5) : (BOOL v46 = 0), v46))
          {
            sub_1CC025540(v41, v37);
            int v48 = *(_DWORD *)(v41 + 20);
            if ((v48 & 0x40000000) != 0) {
              uint64_t v49 = *(void *)(v41 - 8);
            }
            else {
              uint64_t v49 = v41 - 32 * (v48 & 0x7FFFFFF);
            }
            if (v47 == 4294967294) {
              uint64_t v56 = 1;
            }
            else {
              uint64_t v56 = (2 * v47 + 3);
            }
            uint64_t v36 = *(void *)(v49 + 32 * v56);
          }
          else
          {
LABEL_75:
            uint64_t v36 = *(void *)(v37 - 32);
          }
          uint64_t Successor = v36;
        }
        if (v15 == v36) {
          uint64_t v57 = v15;
        }
        else {
          uint64_t v57 = -1;
        }
        if (v37 == v16) {
          uint64_t v58 = v16;
        }
        else {
          uint64_t v58 = -1;
        }
        if (v171[0]) {
          uint64_t v16 = v58;
        }
        else {
          uint64_t v16 = v37;
        }
        if (v171[0]) {
          uint64_t v15 = v57;
        }
        else {
          uint64_t v15 = v36;
        }
        uint64_t v59 = *((void *)__p + 5);
        if (v59) {
          uint64_t v60 = v59 - 24;
        }
        else {
          uint64_t v60 = 0;
        }
        if (*(unsigned __int8 *)(v60 + 16) - 29 >= 0xB) {
          uint64_t v60 = 0;
        }
        int v61 = *(unsigned __int8 *)(v60 + 16);
        if (v61 != 32 && v61 != 39) {
          sub_1CBAF10A8((uint64_t)&v170, &__p, &Successor);
        }
      }
    }
    else
    {
      int v31 = 0;
      int v32 = 1;
      while (v30 != v20)
      {
        if (v31) {
          BOOL v33 = 0;
        }
        else {
          BOOL v33 = v30 == (void *)-2;
        }
        if (v33) {
          int v31 = (void **)v29;
        }
        unsigned int v34 = v28 + v32++;
        unsigned int v28 = v34 & v27;
        uint64_t v29 = &v21[8 * (v34 & v27)];
        int v30 = *(void **)v29;
        if (*(void *)v29 == -1) {
          goto LABEL_44;
        }
      }
    }
LABEL_112:
    v17 += 2;
  }
  while (v17 != v18);
  if (v171[0])
  {
    if (v15 == -1)
    {
      uint64_t v72 = v170;
      unint64_t v73 = (char *)v170 + 16 * v171[0];
      int v74 = (char *)v170 + 16;
      while (!sub_1CD76D964(v156, *((void *)v74 - 1)))
      {
        BOOL v33 = v74 == v73;
        v74 += 16;
        if (v33) {
          goto LABEL_166;
        }
      }
      unsigned int v134 = v74 - 16;
      while (v74 != v73)
      {
        if (!sub_1CD76D964(v156, *((void *)v74 + 1)))
        {
          *(void *)unsigned int v134 = *(void *)v74;
          *((void *)v134 + 1) = *((void *)v74 + 1);
          v134 += 16;
        }
        v74 += 16;
      }
      unint64_t v73 = v134;
LABEL_166:
      v171[0] = (unint64_t)(v73 - v72) >> 4;
      if (v171[0])
      {
        __p = 0;
        unint64_t v165 = 0;
        LODWORD(v166) = 0;
        uint64_t v168 = 0;
        uint64_t v169 = 0;
        uint64_t v167 = 0;
        uint64_t Successor = 0;
        *(_DWORD *)sub_1CD76D3CC((uint64_t)&__p, &Successor) = 0;
        uint64_t v135 = *(void *)v19;
        if (*(void *)v19 != v19)
        {
          uint64_t v66 = v135 - 24;
          if (v135) {
            uint64_t v15 = v135 - 24;
          }
          else {
            uint64_t v15 = 0;
          }
          if (*(unsigned char *)(v15 + 16) != 30)
          {
            int v147 = 2;
            uint64_t v19 = (uint64_t)a3 + 40;
            switch(*(unsigned char *)(v15 + 16))
            {
              case 0x1E:
LABEL_327:
                __break(1u);
LABEL_328:
                int v79 = (*(_DWORD *)(v66 + 20) & 0x7FFFFFF) - 1;
                goto LABEL_194;
              case 0x1F:
                int v147 = (*(_DWORD *)(v15 + 20) >> 1) & 0x3FFFFFF;
                goto LABEL_318;
              case 0x20:
              case 0x26:
                int v147 = (*(_DWORD *)(v15 + 20) & 0x7FFFFFF) - 1;
                goto LABEL_318;
              case 0x21:
                goto LABEL_292;
              case 0x24:
                int v147 = *(_WORD *)(v15 + 18) & 1;
                goto LABEL_318;
              case 0x25:
                int v147 = 1;
                goto LABEL_292;
              case 0x27:
                int v147 = *(_DWORD *)(v15 + 80) + 1;
LABEL_318:
                uint64_t v19 = (uint64_t)a3 + 40;
                if (!v147) {
                  goto LABEL_294;
                }
                goto LABEL_292;
              default:
                goto LABEL_294;
            }
          }
          if ((*(_DWORD *)(v15 + 20) & 0x7FFFFFF) == 3) {
            int v147 = 2;
          }
          else {
            int v147 = 1;
          }
LABEL_292:
          for (unsigned int j = 0; j != v147; ++j)
          {
            uint64_t Successor = llvm::Instruction::getSuccessor((llvm::Instruction *)v15, j);
            *(_DWORD *)sub_1CD76D3CC((uint64_t)&__p, &Successor) = 0;
          }
        }
LABEL_294:
        if (v171[0])
        {
          uint64_t v141 = 16 * v171[0];
          unsigned int v142 = (uint64_t *)((char *)v170 + 8);
          do
          {
            if (*v142)
            {
              uint64_t v143 = (_DWORD *)sub_1CD76D3CC((uint64_t)&__p, v142);
              ++*v143;
            }
            v142 += 2;
            v141 -= 16;
          }
          while (v141);
        }
        uint64_t v137 = v167;
        uint64_t v138 = v167 + 16;
        if (v167 != v168 && v138 != v168)
        {
          do
          {
            if (*(_DWORD *)(v137 + 8) < *(_DWORD *)(v138 + 8)) {
              uint64_t v137 = v138;
            }
            v138 += 16;
          }
          while (v138 != v168);
        }
        uint64_t v15 = *(void *)v137;
        sub_1CD456CB4(&__p);
        unsigned int v77 = v171[0];
        goto LABEL_177;
      }
      uint64_t v13 = 0;
    }
    else
    {
      if (!v15)
      {
        __p = &v166;
        unint64_t v165 = 0x1000000000;
        unint64_t v62 = (char *)v170;
        uint64_t v63 = (char *)v170 + 16 * v171[0];
        do
        {
LABEL_125:
          if (*((void *)v62 + 1) == v15)
          {
            uint64_t v64 = *(void *)v62;
            uint64_t v65 = *(void *)(*(void *)v62 + 40);
            if (v65 != *(void *)v62 + 40)
            {
              uint64_t v66 = v65 - 24;
              if (v65) {
                uint64_t v67 = v65 - 24;
              }
              else {
                uint64_t v67 = 0;
              }
              if (*(unsigned char *)(v67 + 16) != 30)
              {
                uint64_t v19 = 2;
                switch(*(unsigned char *)(v67 + 16))
                {
                  case 0x1E:
                    goto LABEL_327;
                  case 0x1F:
                    LODWORD(v19) = (*(_DWORD *)(v67 + 20) >> 1) & 0x3FFFFFF;
                    goto LABEL_146;
                  case 0x20:
                  case 0x26:
                    LODWORD(v19) = (*(_DWORD *)(v67 + 20) & 0x7FFFFFF) - 1;
                    goto LABEL_146;
                  case 0x21:
                    goto LABEL_137;
                  case 0x24:
                    LODWORD(v19) = *(_WORD *)(v67 + 18) & 1;
                    goto LABEL_146;
                  case 0x25:
                    LODWORD(v19) = 1;
                    goto LABEL_137;
                  case 0x27:
                    LODWORD(v19) = *(_DWORD *)(v67 + 80) + 1;
LABEL_146:
                    if (!v19) {
                      goto LABEL_126;
                    }
                    goto LABEL_137;
                  default:
                    goto LABEL_126;
                }
              }
              if ((*(_DWORD *)(v67 + 20) & 0x7FFFFFF) == 3) {
                LODWORD(v19) = 2;
              }
              else {
                LODWORD(v19) = 1;
              }
LABEL_137:
              unsigned int v68 = 0;
              do
              {
                if ((llvm::BasicBlock *)llvm::Instruction::getSuccessor((llvm::Instruction *)v67, v68) == a3)
                {
                  if (v165 >= (unint64_t)HIDWORD(v165)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((void *)__p + v165) = v64;
                  LODWORD(v165) = v165 + 1;
                }
                ++v68;
              }
              while (v19 != v68);
            }
          }
LABEL_126:
          v62 += 16;
        }
        while (v62 != v63);
        uint64_t v19 = (uint64_t)a3 + 40;
        goto LABEL_154;
      }
      if (llvm::BasicBlock::hasNPredecessors(a3, v171[0]))
      {
        __p = 0;
        unint64_t v165 = 0;
        int v166 = 0;
        uint64_t v75 = *(void *)v19;
        if (*(void *)v19 == v19)
        {
          uint64_t v66 = 0;
        }
        else
        {
          if (v75) {
            uint64_t v76 = v75 - 24;
          }
          else {
            uint64_t v76 = 0;
          }
          if (*(unsigned __int8 *)(v76 + 16) - 29 >= 0xB) {
            uint64_t v66 = 0;
          }
          else {
            uint64_t v66 = v76;
          }
        }
        if (*(unsigned char *)(v66 + 16) != 30)
        {
          int v79 = 0;
          switch(*(unsigned char *)(v66 + 16))
          {
            case 0x1E:
              goto LABEL_327;
            case 0x1F:
              int v79 = (*(_DWORD *)(v66 + 20) >> 1) & 0x3FFFFFF;
              goto LABEL_194;
            case 0x20:
            case 0x26:
              goto LABEL_328;
            case 0x21:
              int v79 = 2;
              goto LABEL_194;
            case 0x24:
              int v79 = *(_WORD *)(v66 + 18) & 1;
              goto LABEL_194;
            case 0x25:
              int v79 = 1;
              goto LABEL_194;
            case 0x27:
              int v79 = *(_DWORD *)(v66 + 80) + 1;
              goto LABEL_194;
            default:
              goto LABEL_194;
          }
        }
        if ((*(_DWORD *)(v66 + 20) & 0x7FFFFFF) == 3) {
          int v79 = 2;
        }
        else {
          int v79 = 1;
        }
LABEL_194:
        sub_1CC292E4C((uint64_t)&__p, (v79 - 1));
        uint64_t v80 = *(void *)v19;
        if (*(void *)v19 == v19) {
          goto LABEL_272;
        }
        if (v80) {
          uint64_t v81 = v80 - 24;
        }
        else {
          uint64_t v81 = 0;
        }
        uint64_t v66 = *(unsigned __int8 *)(v81 + 16);
        if (v66 != 30)
        {
          int v140 = 2;
          switch(*(unsigned char *)(v81 + 16))
          {
            case 0x1E:
              goto LABEL_327;
            case 0x1F:
              int v140 = (*(_DWORD *)(v81 + 20) >> 1) & 0x3FFFFFF;
              goto LABEL_307;
            case 0x20:
            case 0x26:
              int v140 = (*(_DWORD *)(v81 + 20) & 0x7FFFFFF) - 1;
              goto LABEL_307;
            case 0x21:
              goto LABEL_203;
            case 0x24:
              int v140 = *(_WORD *)(v81 + 18) & 1;
              goto LABEL_307;
            case 0x25:
              int v140 = 1;
              goto LABEL_203;
            case 0x27:
              int v140 = *(_DWORD *)(v81 + 80) + 1;
LABEL_307:
              if (!v140) {
                goto LABEL_265;
              }
              goto LABEL_203;
            default:
              goto LABEL_265;
          }
        }
        int v140 = (*(_DWORD *)(v81 + 20) & 0x7FFFFFF) == 3 ? 2 : 1;
LABEL_203:
        int v82 = 0;
        unsigned int v83 = 0;
        uint64_t v154 = v81;
        int v153 = v140;
        do
        {
          uint64_t v84 = llvm::Instruction::getSuccessor((llvm::Instruction *)v81, v83);
          uint64_t v85 = v84;
          if (v84 != v15 || (v82 & 1) != 0)
          {
            int v155 = v82;
            if (*(void *)(v84 + 40) != v84 + 40)
            {
              uint64_t v86 = *(void *)(v84 + 48);
              uint64_t v87 = v86 - 24;
              uint64_t v88 = v86 ? v86 - 24 : 0;
              if (*(unsigned char *)(v88 + 16) == 83)
              {
                do
                {
                  uint64_t v109 = *(void *)(v87 + 32);
                  uint64_t v110 = v109 - 24;
                  if (!v109) {
                    uint64_t v110 = 0;
                  }
                  int v111 = *(unsigned __int8 *)(v110 + 16);
                  if (v111 == 83) {
                    uint64_t v112 = v110;
                  }
                  else {
                    uint64_t v112 = 0;
                  }
                  int v113 = *(_DWORD *)(v87 + 20);
                  uint64_t v114 = v113 & 0x7FFFFFF;
                  uint64_t v157 = v112;
                  if ((v113 & 0x7FFFFFF) != 0)
                  {
                    uint64_t v115 = 0;
                    while (1)
                    {
                      uint64_t v116 = v87 - 32 * v114;
                      if ((v113 & 0x40000000) != 0) {
                        uint64_t v116 = *(void *)(v87 - 8);
                      }
                      if (*(llvm::BasicBlock **)(v116 + 32 * *(unsigned int *)(v87 + 60) + 8 * v115) == a3) {
                        break;
                      }
                      if (v114 == ++v115) {
                        goto LABEL_249;
                      }
                    }
                    uint64_t v117 = v115;
                  }
                  else
                  {
LABEL_249:
                    uint64_t v117 = 0xFFFFFFFFLL;
                  }
                  uint64_t v118 = v114;
                  if ((v113 & 0x40000000) != 0)
                  {
                    uint64_t v100 = *(void *)(v87 - 8);
                    uint64_t v101 = v100 + 32 * v117;
                    unsigned int v102 = (uint64_t *)(v100 + 32 * v118);
                  }
                  else
                  {
                    uint64_t v100 = v87 - 32 * v114;
                    uint64_t v101 = v100 + 32 * v117;
                    unsigned int v102 = (uint64_t *)v87;
                  }
                  sub_1CC5E4108((uint64_t)&Successor, (uint64_t *)(v101 + 32), v102, v100 + 32 * v117);
                  int v119 = *(_DWORD *)(v87 + 20);
                  if ((v119 & 0x40000000) != 0)
                  {
                    uint64_t v104 = *(void *)(v87 - 8);
                    uint64_t v105 = *(unsigned int *)(v87 + 60);
                    uint64_t v106 = v104 + 32 * v105;
                    uint64_t v103 = v119 & 0x7FFFFFF;
                  }
                  else
                  {
                    uint64_t v103 = v119 & 0x7FFFFFF;
                    uint64_t v104 = v87 - 32 * v103;
                    uint64_t v105 = *(unsigned int *)(v87 + 60);
                    uint64_t v106 = v104 + 32 * v105;
                  }
                  uint64_t v120 = (unsigned char *)(v106 + 8 * v103);
                  unsigned int v121 = (unsigned char *)(v106 + 8 * v117 + 8);
                  if (v120 != v121)
                  {
                    memmove((void *)(v104 + 32 * v105 + 8 * v117), v121, v120 - v121);
                    int v119 = *(_DWORD *)(v87 + 20);
                  }
                  if ((v119 & 0x40000000) != 0)
                  {
                    uint64_t v108 = *(void *)(v87 - 8);
                    uint64_t v107 = v119 & 0x7FFFFFF;
                  }
                  else
                  {
                    uint64_t v107 = v119 & 0x7FFFFFF;
                    uint64_t v108 = v87 - 32 * v107;
                  }
                  uint64_t v19 = (uint64_t)a3 + 40;
                  uint64_t v122 = v108 + 32 * v107;
                  if (*(void *)(v122 - 32))
                  {
                    **(void **)(v122 - 16) = *(void *)(v122 - 24);
                    uint64_t v123 = *(void *)(v122 - 24);
                    if (v123) {
                      *(void *)(v123 + 16) = *(void *)(v122 - 16);
                    }
                  }
                  *(void *)(v122 - 32) = 0;
                  *(_DWORD *)(v87 + 20) = *(_DWORD *)(v87 + 20) & 0xF8000000 | (*(_DWORD *)(v87 + 20) - 1) & 0x7FFFFFF;
                  if (!v109) {
                    break;
                  }
                  uint64_t v87 = v157;
                }
                while (v111 == 83);
              }
            }
            uint64_t v89 = v85 | 4;
            uint64_t v90 = (void *)v165;
            if (v165 >= (unint64_t)v166)
            {
              unsigned int v92 = __p;
              uint64_t v93 = (uint64_t)(v165 - (void)__p) >> 4;
              unint64_t v94 = v93 + 1;
              if ((unint64_t)(v93 + 1) >> 60) {
                abort();
              }
              uint64_t v95 = v166 - (unsigned char *)__p;
              if ((v166 - (unsigned char *)__p) >> 3 > v94) {
                unint64_t v94 = v95 >> 3;
              }
              if ((unint64_t)v95 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v96 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v96 = v94;
              }
              if (v96)
              {
                if (v96 >> 60) {
                  sub_1CB833614();
                }
                uint64_t v97 = (char *)operator new(16 * v96);
              }
              else
              {
                uint64_t v97 = 0;
              }
              uint64_t v98 = (llvm::BasicBlock **)&v97[16 * v93];
              *uint64_t v98 = a3;
              v98[1] = (llvm::BasicBlock *)v89;
              uint64_t v99 = v98;
              if (v90 == v92)
              {
                uint64_t v19 = (uint64_t)a3 + 40;
                int v140 = v153;
              }
              else
              {
                uint64_t v19 = (uint64_t)a3 + 40;
                int v140 = v153;
                do
                {
                  *((_OWORD *)v99 - 1) = *((_OWORD *)v90 - 1);
                  v99 -= 2;
                  v90 -= 2;
                }
                while (v90 != v92);
                uint64_t v90 = __p;
              }
              unsigned int v91 = v98 + 2;
              __p = v99;
              unint64_t v165 = (unint64_t)(v98 + 2);
              int v166 = &v97[16 * v96];
              if (v90) {
                operator delete(v90);
              }
              uint64_t v81 = v154;
            }
            else
            {
              *(void *)unint64_t v165 = a3;
              v90[1] = v89;
              unsigned int v91 = v90 + 2;
              uint64_t v81 = v154;
              int v140 = v153;
            }
            unint64_t v165 = (unint64_t)v91;
            int v82 = v155;
          }
          else
          {
            int v82 = 1;
          }
          ++v83;
        }
        while (v140 != v83);
        uint64_t v80 = *(void *)v19;
LABEL_265:
        if (v80 == v19)
        {
LABEL_272:
          uint64_t v126 = 0;
        }
        else
        {
          uint64_t v124 = v80 - 24;
          if (v80) {
            uint64_t v125 = v80 - 24;
          }
          else {
            uint64_t v125 = 0;
          }
          if (*(unsigned __int8 *)(v125 + 16) - 29 >= 0xB) {
            uint64_t v126 = 0;
          }
          else {
            uint64_t v126 = v124;
          }
        }
        uint64_t v127 = (char *)operator new(0x60uLL);
        unsigned int v128 = v127;
        *((_DWORD *)v127 + 13) = *((_DWORD *)v127 + 13) & 0x38000000 | 1;
        *((void *)v127 + 1) = 0;
        *((void *)v127 + 2) = 0;
        *(void *)uint64_t v127 = 0;
        *((void *)v127 + 4) = ***(void ***)v15 + 1576;
        unsigned int v129 = (llvm::Value *)(v127 + 32);
        *((void *)v127 + 3) = v127 + 32;
        *((void *)v127 + 5) = 0;
        v127[48] = 30;
        v127[49] = 0;
        *((_WORD *)v127 + 25) = 0;
        *((_DWORD *)v127 + 13) = 1;
        *(_OWORD *)(v127 + 56) = 0u;
        uint64_t v130 = v127 + 56;
        *(_OWORD *)(v127 + 72) = 0u;
        *((_DWORD *)v127 + 22) = 0;
        if (v126)
        {
          uint64_t v144 = *(void *)(v126 + 40);
          unsigned int v145 = (uint64_t *)(v126 + 24);
          *((void *)v127 + 9) = v144;
          *(_WORD *)(v144 + 18) &= ~0x8000u;
          if ((v127[55] & 0x10) != 0
            && (uint64_t v148 = *(void *)(v144 + 56)) != 0
            && (BOOL v149 = *(llvm::ValueSymbolTable **)(v148 + 104)) != 0)
          {
            llvm::ValueSymbolTable::reinsertValue(v149, v129);
            uint64_t v150 = *(void *)v128;
            uint64_t v151 = *v145;
            *((void *)v128 + 7) = *v145;
            *((void *)v128 + 8) = v145;
            *(void *)(v151 + 8) = v130;
            *unsigned int v145 = (uint64_t)v130;
            if (v150)
            {
              **((void **)v128 + 2) = *((void *)v128 + 1);
              uint64_t v152 = *((void *)v128 + 1);
              if (v152) {
                *(void *)(v152 + 16) = *((void *)v128 + 2);
              }
            }
          }
          else
          {
            uint64_t v146 = *v145;
            *((void *)v128 + 7) = *v145;
            *((void *)v128 + 8) = v145;
            *(void *)(v146 + 8) = v130;
            *unsigned int v145 = (uint64_t)v130;
          }
        }
        *(void *)unsigned int v128 = v15;
        uint64_t v133 = *(void *)(v15 + 8);
        unsigned int v132 = (void *)(v15 + 8);
        uint64_t v131 = v133;
        *((void *)v128 + 1) = v133;
        if (v133) {
          *(void *)(v131 + 16) = v128 + 8;
        }
        *((void *)v128 + 2) = v132;
        *unsigned int v132 = v128;
        llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
      }
      unsigned int v77 = v171[0];
LABEL_177:
      __p = &v166;
      unint64_t v165 = 0x1000000000;
      if (v77)
      {
        unint64_t v62 = (char *)v170;
        uint64_t v63 = (char *)v170 + 16 * v77;
        goto LABEL_125;
      }
LABEL_154:
      if (!v15)
      {
        uint64_t v69 = *(void *)v19;
        if (*(void *)v19 == v19)
        {
          uint64_t v71 = 0;
        }
        else
        {
          if (v69) {
            int v70 = (unsigned __int8 *)(v69 - 24);
          }
          else {
            int v70 = 0;
          }
          if (v70[16] - 29 >= 0xB) {
            uint64_t v71 = 0;
          }
          else {
            uint64_t v71 = (llvm::Instruction *)v70;
          }
        }
        unsigned int v78 = sub_1CCD96148((uint64_t)a3);
        uint64_t v15 = llvm::Instruction::getSuccessor(v71, v78);
      }
      uint64_t v13 = llvm::JumpThreadingPass::tryThreadEdge(a1, a3, (uint64_t **)&__p, (llvm::BasicBlock *)v15);
      if (__p != &v166) {
        free(__p);
      }
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
LABEL_183:
  if (v170 != v172) {
    free(v170);
  }
  if (v159 != v158) {
    free(v159);
  }
LABEL_187:
  if (v173 != v175) {
    free(v173);
  }
  return v13;
}

void sub_1CCD973B0(llvm *a1, llvm::Instruction *a2, llvm::Value *a3)
{
  uint64_t v5 = *((void *)a1 + 5);
  llvm::replaceNonLocalUsesWith(a1, a2, a3);
  uint64_t v8 = *(void **)(v5 + 40);
  unsigned int v6 = (void *)(v5 + 40);
  for (uint64_t i = v8; i != v6; uint64_t i = (void *)*i)
  {
    uint64_t v9 = i ? (uint64_t)(i - 3) : 0;
    if ((llvm *)v9 == a1) {
      break;
    }
    int v10 = *(unsigned __int8 *)(v9 + 16);
    if (v10 != 84)
    {
      switch(*(unsigned char *)(v9 + 16))
      {
        case 0x1D:
        case 0x22:
        case 0x23:
          goto LABEL_19;
        case 0x1E:
        case 0x1F:
        case 0x20:
        case 0x21:
        case 0x25:
          goto LABEL_12;
        case 0x24:
        case 0x26:
          if (*(_WORD *)(v9 + 18)) {
            goto LABEL_12;
          }
          goto LABEL_19;
        default:
          if (v10 != 80) {
            goto LABEL_12;
          }
          PersonalityFn = (llvm::Value *)llvm::Function::getPersonalityFn(*(llvm::Function **)(*(void *)(v9 + 40)
                                                                                             + 56));
          if (llvm::classifyEHPersonality(PersonalityFn, v13) != 10) {
            goto LABEL_19;
          }
          goto LABEL_13;
      }
    }
    uint64_t v11 = *(void *)(v9 + 64);
    if ((!v11 || (*(unsigned char *)(v11 + 16) & 0x20) == 0)
      && !llvm::CallBase::hasFnAttrOnCalledFunction(v9, 37))
    {
      break;
    }
LABEL_12:
    if (!llvm::Instruction::willReturn((llvm::Instruction *)v9)) {
      break;
    }
LABEL_13:
    llvm::User::replaceUsesOfWith((llvm::User *)v9, a1, a2);
  }
LABEL_19:
  if (!*((void *)a1 + 1) && (llvm::Instruction::mayHaveSideEffects(a1) & 1) == 0) {
    llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
  }
}

uint64_t llvm::JumpThreadingPass::tryToUnfoldSelect(llvm::LazyValueInfo **this, llvm::CmpInst *a2, llvm::BasicBlock *a3)
{
  unsigned int v6 = (llvm::BasicBlock *)*((void *)a3 + 5);
  if (v6 == (llvm::BasicBlock *)((char *)a3 + 40))
  {
    BOOL v7 = 0;
  }
  else
  {
    if (v6) {
      BOOL v7 = (char *)v6 - 24;
    }
    else {
      BOOL v7 = 0;
    }
    if (v7[16] - 29 >= 0xB) {
      BOOL v7 = 0;
    }
  }
  uint64_t result = 0;
  if (*(unsigned char *)(*((void *)a2 - 8) + 16) == 83) {
    uint64_t v9 = *((void *)a2 - 8);
  }
  else {
    uint64_t v9 = 0;
  }
  if (v7 && v7[16] == 30)
  {
    if ((*((_DWORD *)v7 + 5) & 0x7FFFFFF) == 3 && v9 != 0 && *(llvm::BasicBlock **)(v9 + 40) == a3)
    {
      int v11 = *(_DWORD *)(v9 + 20);
      uint64_t v12 = v11 & 0x7FFFFFF;
      if ((v11 & 0x7FFFFFF) != 0)
      {
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        uint64_t v15 = (llvm::Constant *)*((void *)a2 - 4);
        do
        {
          int v16 = *(_DWORD *)(v9 + 20);
          if ((v16 & 0x40000000) != 0) {
            uint64_t v17 = *(void *)(v9 - 8);
          }
          else {
            uint64_t v17 = v9 - 32 * (v16 & 0x7FFFFFF);
          }
          uint64_t v18 = *(void *)(v17 + v13);
          if (v18)
          {
            if (*(unsigned char *)(v18 + 16) == 85)
            {
              uint64_t v19 = *(llvm::BasicBlock **)(v17 + 32 * *(unsigned int *)(v9 + 60) + 8 * v14);
              if (*(llvm::BasicBlock **)(v18 + 40) == v19)
              {
                uint64_t v20 = *(void *)(v18 + 8);
                if (v20)
                {
                  if (!*(void *)(v20 + 8))
                  {
                    uint64_t v21 = (void *)*((void *)v19 + 5);
                    if (v21 != (void *)((char *)v19 + 40))
                    {
                      uint64_t v22 = v21 - 3;
                      if (!v21) {
                        uint64_t v22 = 0;
                      }
                      unsigned int v23 = *((unsigned __int8 *)v22 + 16) - 40;
                      if (v23 < 0xFFFFFFF5) {
                        uint64_t v22 = 0;
                      }
                      if (v21)
                      {
                        BOOL v24 = *((unsigned char *)v22 + 16) == 30 && v23 >= 0xFFFFFFF5;
                        if (v24 && (*((_DWORD *)v22 + 5) & 0x7FFFFFF) == 1)
                        {
                          int PredicateOnEdge = llvm::LazyValueInfo::getPredicateOnEdge(this[2], *((_WORD *)a2 + 9) & 0x3F, *(llvm::Value **)(v18 - 64), v15, v19, a3, a2);
                          int v25 = llvm::LazyValueInfo::getPredicateOnEdge(this[2], *((_WORD *)a2 + 9) & 0x3F, *(llvm::Value **)(v18 - 32), v15, v19, a3, a2);
                          if ((PredicateOnEdge & v25) != 0xFFFFFFFF && PredicateOnEdge != v25) {
                            llvm::JumpThreadingPass::unfoldSelectInstr((llvm::JumpThreadingPass *)this, v19, a3, (llvm::SelectInst *)v18, (llvm::PHINode *)v9);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          ++v14;
          v13 += 32;
        }
        while (v12 != v14);
      }
    }
    return 0;
  }
  return result;
}

uint64_t llvm::JumpThreadingPass::tryToUnfoldSelect(llvm::JumpThreadingPass *this, llvm::SwitchInst *a2, llvm::BasicBlock *a3)
{
  int v3 = *((_DWORD *)a2 + 5);
  if ((v3 & 0x40000000) != 0) {
    uint64_t v4 = (uint64_t *)*((void *)a2 - 1);
  }
  else {
    uint64_t v4 = (uint64_t *)((char *)a2 - 32 * (v3 & 0x7FFFFFF));
  }
  uint64_t v5 = *v4;
  if (*v4)
  {
    if (*(unsigned char *)(v5 + 16) == 83 && *(llvm::BasicBlock **)(v5 + 40) == a3)
    {
      int v7 = *(_DWORD *)(v5 + 20);
      uint64_t v8 = v7 & 0x7FFFFFF;
      if ((v7 & 0x7FFFFFF) != 0)
      {
        uint64_t v9 = 0;
        uint64_t v10 = 0;
        do
        {
          uint64_t v11 = v5 - 32 * v8;
          if ((v7 & 0x40000000) != 0) {
            uint64_t v11 = *(void *)(v5 - 8);
          }
          uint64_t v12 = *(void *)(v11 + v9);
          if (v12)
          {
            if (*(unsigned char *)(v12 + 16) == 85)
            {
              uint64_t v13 = *(llvm::BasicBlock **)(v11 + 32 * *(unsigned int *)(v5 + 60) + 8 * v10);
              if (*(llvm::BasicBlock **)(v12 + 40) == v13)
              {
                uint64_t v14 = *(void *)(v12 + 8);
                if (v14)
                {
                  if (!*(void *)(v14 + 8))
                  {
                    uint64_t v15 = (void *)*((void *)v13 + 5);
                    if (v15 != (void *)((char *)v13 + 40))
                    {
                      int v16 = v15 - 3;
                      if (!v15) {
                        int v16 = 0;
                      }
                      unsigned int v17 = *((unsigned __int8 *)v16 + 16) - 40;
                      if (v17 < 0xFFFFFFF5) {
                        int v16 = 0;
                      }
                      if (v15)
                      {
                        BOOL v18 = *((unsigned char *)v16 + 16) == 30 && v17 >= 0xFFFFFFF5;
                        if (v18 && (*((_DWORD *)v16 + 5) & 0x7FFFFFF) == 1) {
                          llvm::JumpThreadingPass::unfoldSelectInstr(this, v13, a3, (llvm::SelectInst *)v12, (llvm::PHINode *)v5);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          ++v10;
          v9 += 32;
        }
        while (v8 != v10);
      }
    }
  }
  return 0;
}

uint64_t llvm::JumpThreadingPass::simplifyPartiallyRedundantLoad(llvm::AAResults **this, llvm::LoadInst *a2)
{
  uint64_t v260 = *MEMORY[0x1E4F143B8];
  if ((*((_WORD *)a2 + 9) & 0x301) == 0)
  {
    uint64_t v4 = (llvm::BasicBlock *)*((void *)a2 + 5);
    if (!llvm::BasicBlock::getSinglePredecessor(v4))
    {
      for (uint64_t i = *((void *)v4 + 6); ; uint64_t i = *(void *)(i + 8))
      {
        uint64_t v6 = i - 24;
        if (!i) {
          uint64_t v6 = 0;
        }
        if (*(unsigned char *)(v6 + 16) != 83) {
          break;
        }
      }
      unsigned int v7 = *(unsigned __int8 *)(i - 8) - 38;
      if (v7 >= 0x39 || ((0x100060000000001uLL >> v7) & 1) == 0)
      {
        uint64_t v8 = *((void *)a2 - 4);
        unsigned int v9 = *(unsigned __int8 *)(v8 + 16);
        BOOL v10 = v8 && v9 >= 0x1C;
        if (!v10 || (v9 != 83 ? (BOOL v11 = *(void *)(v8 + 40) == (void)v4) : (BOOL v11 = 0), !v11))
        {
          uint64_t v247 = (uint64_t *)((char *)a2 + 24);
          char v246 = 0;
          AvailableLoadedValue = llvm::FindAvailableLoadedValue(a2, (uint64_t)v4, &v247, dword_1EBD04060, this[3], &v246, 0);
          if (AvailableLoadedValue)
          {
            BitOrPointerCast = AvailableLoadedValue;
            if (v246)
            {
              long long v257 = xmmword_1CFB32AC0;
              long long v258 = unk_1CFB32AD0;
              long long v259 = xmmword_1CFB32AE0;
              llvm::combineMetadata(AvailableLoadedValue, a2, (unsigned int *)&v257, 12, 0);
            }
            if (BitOrPointerCast == a2) {
              BitOrPointerCast = llvm::UndefValue::get(*(llvm::UndefValue **)a2, v14);
            }
            unsigned int v17 = *(llvm::Value **)a2;
            if (*(void *)BitOrPointerCast != *(void *)a2)
            {
              LOWORD(v259) = 257;
              BitOrPointerCast = llvm::CastInst::CreateBitOrPointerCast(BitOrPointerCast, v17, (const char **)&v257, a2, v15);
            }
            llvm::Value::doRAUW(a2, BitOrPointerCast, (llvm::Value *)1);
            llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
          }
          if (v247 == *((uint64_t **)v4 + 6))
          {
            llvm::Instruction::getAAMetadata((uint64_t ***)a2, v244);
            BOOL v18 = (uint64_t *)v243;
            v239 = (uint64_t *)v243;
            uint64_t v240 = (uint64_t *)v243;
            uint64_t v241 = 8;
            int v242 = 0;
            *(void *)&long long v257 = &v258;
            *((void *)&v257 + 1) = 0x800000000;
            unint64_t v254 = v256;
            uint64_t v255 = 0x800000000;
            uint64_t v19 = *((void *)v4 + 1);
            if (!v19)
            {
LABEL_428:
              if (v254 != v256) {
                free(v254);
              }
              if ((long long *)v257 != &v258) {
                free((void *)v257);
              }
              if (v240 != v239) {
                free(v240);
              }
              return 0;
            }
            while (1)
            {
              uint64_t v20 = *(void *)(v19 + 24);
              unsigned int v21 = *(unsigned __int8 *)(v20 + 16);
              BOOL v22 = v20 && v21 >= 0x1C;
              if (v22 && v21 - 29 < 0xB) {
                break;
              }
              uint64_t v19 = *(void *)(v19 + 8);
              if (!v19) {
                goto LABEL_428;
              }
            }
            unsigned int v24 = 0;
            uint64_t __p = 0;
            int v25 = (uint64_t *)v243;
LABEL_41:
            uint64_t v26 = *(void *)(v20 + 40);
            if (v25 == v18)
            {
              if (v24)
              {
                unsigned int v27 = 0;
                uint64_t v28 = 8 * v24;
                uint64_t v29 = v18;
                do
                {
                  if (*v29 == v26) {
                    goto LABEL_100;
                  }
                  if (*v29 == -2) {
                    unsigned int v27 = v29;
                  }
                  ++v29;
                  v28 -= 8;
                }
                while (v28);
                if (v27)
                {
                  *unsigned int v27 = v26;
                  --v242;
                  goto LABEL_73;
                }
              }
              unsigned int v30 = v241;
              if (v24 < v241)
              {
                HIDWORD(v241) = v24 + 1;
                v18[v24] = v26;
                goto LABEL_73;
              }
            }
            else
            {
              unsigned int v30 = v241;
            }
            if (3 * v30 <= 4 * (v24 - v242))
            {
              if (v30 >= 0x40) {
                v30 *= 2;
              }
              else {
                unsigned int v30 = 128;
              }
            }
            else if (v30 - v24 >= v30 >> 3)
            {
              goto LABEL_54;
            }
            llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v239, v30);
            unsigned int v30 = v241;
            int v25 = v240;
LABEL_54:
            unsigned int v31 = v30 - 1;
            unsigned int v32 = (v30 - 1) & ((v26 >> 4) ^ (v26 >> 9));
            BOOL v33 = &v25[v32];
            uint64_t v34 = *v33;
            if (*v33 == -1)
            {
              uint64_t v35 = 0;
            }
            else
            {
              uint64_t v35 = 0;
              int v36 = 1;
              do
              {
                if (v34 == v26) {
                  goto LABEL_100;
                }
                if (v35) {
                  BOOL v37 = 0;
                }
                else {
                  BOOL v37 = v34 == -2;
                }
                if (v37) {
                  uint64_t v35 = v33;
                }
                unsigned int v38 = v32 + v36++;
                unsigned int v32 = v38 & v31;
                BOOL v33 = &v25[v38 & v31];
                uint64_t v34 = *v33;
              }
              while (*v33 != -1);
            }
            if (v35) {
              uint64_t v39 = v35;
            }
            else {
              uint64_t v39 = v33;
            }
            if (*v39 != v26)
            {
              if (*v39 == -2) {
                --v242;
              }
              else {
                ++HIDWORD(v241);
              }
              uint64_t *v39 = v26;
LABEL_73:
              uint64_t v247 = (uint64_t *)(v26 + 40);
              LODWORD(v251) = 0;
              unsigned int v40 = *(llvm::Type **)a2;
              uint64_t v41 = *(void *)(*(void *)(*((void *)a2 + 5) + 56) + 40);
              uint64_t v42 = v8;
              if (v8)
              {
                uint64_t v42 = v8;
                if (*(unsigned char *)(v8 + 16) == 83)
                {
                  uint64_t v42 = v8;
                  if (*(llvm::BasicBlock **)(v8 + 40) == v4) {
                    uint64_t v42 = sub_1CBF73380(v8, v26);
                  }
                }
              }
              unint64_t v43 = (unint64_t)(sub_1CB83544C(v41 + 272, (uint64_t)v40) + 7) >> 3;
              if (v44 == 1) {
                unint64_t v43 = -2;
              }
              *(void *)&long long v248 = v42;
              *((void *)&v248 + 1) = v43;
              long long v249 = *(_OWORD *)v244;
              v250[0] = *(_OWORD *)v245;
              int v45 = *((unsigned __int8 *)a2 + 16);
              if (v45 == 60 || v45 == 61) {
                char v46 = (*((_WORD *)a2 + 9) & 0x380) != 0;
              }
              else {
                char v46 = (v45 - 63) <= 2;
              }
              AvailablePtrLoadStore = llvm::findAvailablePtrLoadStore((uint64_t **)&v248, v40, v46, v26, &v247, dword_1EBD04060, this[3], &v246, &v251);
              if (AvailablePtrLoadStore || !v26)
              {
                if (AvailablePtrLoadStore)
                {
LABEL_94:
                  if (v246)
                  {
                    if (v255 >= (unint64_t)HIDWORD(v255)) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    *((void *)v254 + v255) = AvailablePtrLoadStore;
                    LODWORD(v255) = v255 + 1;
                  }
                  int v53 = DWORD2(v257);
                  if (DWORD2(v257) >= HIDWORD(v257)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  int v54 = (uint64_t *)(v257 + 16 * DWORD2(v257));
                  uint64_t *v54 = v26;
                  v54[1] = (uint64_t)AvailablePtrLoadStore;
                  DWORD2(v257) = v53 + 1;
                  goto LABEL_100;
                }
              }
              else
              {
                int v48 = (uint64_t **)v26;
                while (v247 == v48[6])
                {
                  int v49 = dword_1EBD04060 - v251;
                  if (dword_1EBD04060 <= v251) {
                    break;
                  }
                  uint64_t SinglePredecessor = llvm::BasicBlock::getSinglePredecessor((llvm::BasicBlock *)v48);
                  if (!SinglePredecessor) {
                    break;
                  }
                  int v48 = (uint64_t **)SinglePredecessor;
                  uint64_t v247 = (uint64_t *)(SinglePredecessor + 40);
                  int v51 = *((unsigned __int8 *)a2 + 16);
                  if (v51 == 60 || v51 == 61) {
                    char v52 = (*((_WORD *)a2 + 9) & 0x380) != 0;
                  }
                  else {
                    char v52 = (v51 - 63) <= 2;
                  }
                  AvailablePtrLoadStore = llvm::findAvailablePtrLoadStore((uint64_t **)&v248, v40, v52, SinglePredecessor, &v247, v49, this[3], &v246, &v251);
                  if (AvailablePtrLoadStore) {
                    goto LABEL_94;
                  }
                }
              }
              uint64_t __p = v26;
            }
LABEL_100:
            while (1)
            {
              uint64_t v19 = *(void *)(v19 + 8);
              if (!v19) {
                break;
              }
              uint64_t v20 = *(void *)(v19 + 24);
              unsigned int v55 = *(unsigned __int8 *)(v20 + 16);
              if (v20) {
                BOOL v56 = v55 >= 0x1C;
              }
              else {
                BOOL v56 = 0;
              }
              if (v56 && v55 - 29 <= 0xA)
              {
                BOOL v18 = v239;
                int v25 = v240;
                unsigned int v24 = HIDWORD(v241);
                goto LABEL_41;
              }
            }
            if (DWORD2(v257))
            {
              if (DWORD2(v257) != HIDWORD(v241) - v242
                && (llvm::isSafeToSpeculativelyExecute((uint64_t)a2, 0, 0, 0) & 1) == 0)
              {
                for (uint64_t j = *((void *)v4 + 6); ; uint64_t j = *(void *)(j + 8))
                {
                  uint64_t v63 = j ? j - 24 : 0;
                  if ((llvm::LoadInst *)v63 == a2) {
                    break;
                  }
                  int v64 = *(unsigned __int8 *)(v63 + 16);
                  if (v64 != 84)
                  {
                    switch(*(unsigned char *)(v63 + 16))
                    {
                      case 0x1D:
                      case 0x22:
                      case 0x23:
                        goto LABEL_428;
                      case 0x1E:
                      case 0x1F:
                      case 0x20:
                      case 0x21:
                      case 0x25:
                        goto LABEL_140;
                      case 0x24:
                      case 0x26:
                        if ((*(_WORD *)(v63 + 18) & 1) == 0) {
                          goto LABEL_428;
                        }
                        goto LABEL_140;
                      default:
                        if (v64 != 80) {
                          goto LABEL_140;
                        }
                        PersonalityFn = (llvm::Value *)llvm::Function::getPersonalityFn(*(llvm::Function **)(*(void *)(v63 + 40) + 56));
                        if (llvm::classifyEHPersonality(PersonalityFn, v67) != 10) {
                          goto LABEL_428;
                        }
                        continue;
                    }
                  }
                  uint64_t v65 = *(void *)(v63 + 64);
                  if ((!v65 || (*(unsigned char *)(v65 + 16) & 0x20) == 0)
                    && !llvm::CallBase::hasFnAttrOnCalledFunction(v63, 37))
                  {
                    goto LABEL_428;
                  }
LABEL_140:
                  if ((llvm::Instruction::willReturn((llvm::Instruction *)v63) & 1) == 0) {
                    goto LABEL_428;
                  }
                }
              }
              uint64_t v58 = (uint64_t *)(HIDWORD(v241) - v242);
              uint64_t v59 = DWORD2(v257);
              if ((uint64_t *)(DWORD2(v257) + 1) == v58)
              {
                uint64_t v60 = *(void *)(__p + 40);
                if (v60 == __p + 40)
                {
                  uint64_t v61 = 0;
                }
                else
                {
                  if (v60) {
                    uint64_t v61 = v60 - 24;
                  }
                  else {
                    uint64_t v61 = 0;
                  }
                  if (*(unsigned __int8 *)(v61 + 16) - 29 >= 0xB) {
                    uint64_t v61 = 0;
                  }
                }
                if (*(unsigned char *)(v61 + 16) != 30)
                {
                  switch(*(unsigned char *)(v61 + 16))
                  {
                    case 0x1E:
                      __break(1u);
                      goto LABEL_467;
                    case 0x1F:
                      int v209 = (*(_DWORD *)(v61 + 20) >> 1) & 0x3FFFFFF;
                      goto LABEL_408;
                    case 0x20:
                    case 0x26:
LABEL_467:
                      int v209 = (*(_DWORD *)(v61 + 20) & 0x7FFFFFF) - 1;
                      goto LABEL_408;
                    case 0x24:
                      int v209 = *(_WORD *)(v61 + 18) & 1;
                      goto LABEL_408;
                    case 0x25:
                      goto LABEL_208;
                    case 0x27:
                      int v209 = *(_DWORD *)(v61 + 80) + 1;
LABEL_408:
                      if (v209 == 1) {
                        goto LABEL_208;
                      }
                      goto LABEL_151;
                    default:
                      goto LABEL_151;
                  }
                }
                if ((*(_DWORD *)(v61 + 20) & 0x7FFFFFF) != 3) {
                  goto LABEL_208;
                }
              }
LABEL_151:
              if (v59 == v58) {
                goto LABEL_300;
              }
              unsigned int v251 = v253;
              *(void *)unint64_t v252 = 0x800000000;
              unsigned int v68 = v250;
              *(void *)&long long v248 = v250;
              *((void *)&v248 + 1) = v250;
              *(void *)&long long v249 = 8;
              DWORD2(v249) = 0;
              if (v59)
              {
                unsigned int v69 = 0;
                int v70 = (uint64_t *)v257;
                uint64_t v71 = (uint64_t *)(v257 + 16 * v59);
                unsigned int v72 = 8;
                unint64_t v73 = v250;
                while (1)
                {
                  uint64_t v74 = *v70;
                  if (v73 != v68) {
                    break;
                  }
                  if (v69)
                  {
                    uint64_t v75 = 0;
                    uint64_t v76 = 8 * v69;
                    unsigned int v77 = v68;
                    while (*v77 != v74)
                    {
                      if (*v77 == -2) {
                        uint64_t v75 = v77;
                      }
                      ++v77;
                      v76 -= 8;
                      if (!v76)
                      {
                        if (!v75) {
                          goto LABEL_162;
                        }
                        *uint64_t v75 = v74;
                        --DWORD2(v249);
                        goto LABEL_185;
                      }
                    }
                    goto LABEL_185;
                  }
LABEL_162:
                  if (v72 <= v69) {
                    break;
                  }
                  DWORD1(v249) = v69 + 1;
                  *((void *)v68 + v69) = v74;
LABEL_185:
                  unint64_t v73 = (_OWORD *)*((void *)&v248 + 1);
                  unsigned int v68 = (_OWORD *)v248;
                  unsigned int v69 = DWORD1(v249);
                  unsigned int v72 = v249;
                  v70 += 2;
                  if (v70 == v71) {
                    goto LABEL_193;
                  }
                }
                if (3 * v72 <= 4 * (v69 - DWORD2(v249)))
                {
                  if (v72 >= 0x40) {
                    v72 *= 2;
                  }
                  else {
                    unsigned int v72 = 128;
                  }
                }
                else if (v72 - v69 >= v72 >> 3)
                {
                  goto LABEL_166;
                }
                llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v248, v72);
                unsigned int v72 = v249;
                unint64_t v73 = (_OWORD *)*((void *)&v248 + 1);
LABEL_166:
                unsigned int v78 = v72 - 1;
                unsigned int v79 = (v72 - 1) & ((v74 >> 4) ^ (v74 >> 9));
                uint64_t v80 = (void *)v73 + v79;
                uint64_t v81 = *v80;
                if (*v80 == -1)
                {
                  int v82 = 0;
LABEL_178:
                  if (v82) {
                    uint64_t v86 = v82;
                  }
                  else {
                    uint64_t v86 = v80;
                  }
                  if (*v86 != v74)
                  {
                    if (*v86 == -2) {
                      --DWORD2(v249);
                    }
                    else {
                      ++DWORD1(v249);
                    }
                    *uint64_t v86 = v74;
                  }
                }
                else
                {
                  int v82 = 0;
                  int v83 = 1;
                  while (v81 != v74)
                  {
                    if (v82) {
                      BOOL v84 = 0;
                    }
                    else {
                      BOOL v84 = v81 == -2;
                    }
                    if (v84) {
                      int v82 = v80;
                    }
                    unsigned int v85 = v79 + v83++;
                    unsigned int v79 = v85 & v78;
                    uint64_t v80 = (void *)v73 + (v85 & v78);
                    uint64_t v81 = *v80;
                    if (*v80 == -1) {
                      goto LABEL_178;
                    }
                  }
                }
                goto LABEL_185;
              }
LABEL_193:
              uint64_t v87 = *((void *)v4 + 1);
              if (!v87)
              {
LABEL_203:
                uint64_t __p = llvm::JumpThreadingPass::splitBlockPreds((uint64_t)this, (uint64_t)v4, (uint64_t *)v251, v252[0], "thread-pre-split");
                if (*((void *)&v248 + 1) != (void)v248) {
                  free(*((void **)&v248 + 1));
                }
                if (v251 != v253) {
                  free(v251);
                }
                if (!__p)
                {
                  LODWORD(v58) = DWORD2(v257);
                  goto LABEL_300;
                }
LABEL_208:
                unsigned int v92 = (char *)operator new(0x60uLL);
                uint64_t v93 = (llvm::Value *)(v92 + 32);
                *((_DWORD *)v92 + 13) = *((_DWORD *)v92 + 13) & 0x38000000 | 1;
                *(void *)unsigned int v92 = 0;
                *((void *)v92 + 1) = 0;
                *((void *)v92 + 2) = 0;
                *((void *)v92 + 3) = v92 + 32;
                uint64_t v94 = *(void *)a2;
                if (v8 && *(unsigned char *)(v8 + 16) == 83 && *(llvm::BasicBlock **)(v8 + 40) == v4) {
                  uint64_t v8 = sub_1CBF73380(v8, __p);
                }
                if ((*((unsigned char *)a2 + 23) & 0x10) != 0)
                {
                  uint64_t v95 = ***(void ***)a2;
                  uint64_t v96 = *(void *)(v95 + 152);
                  uint64_t v97 = *(unsigned int *)(v95 + 168);
                  if (v97)
                  {
                    LODWORD(v98) = (v97 - 1) & ((a2 >> 4) ^ (a2 >> 9));
                    uint64_t v99 = v96 + 16 * v98;
                    uint64_t v100 = *(llvm::LoadInst **)v99;
                    if (*(llvm::LoadInst **)v99 != a2)
                    {
                      int v101 = 1;
                      do
                      {
                        if (v100 == (llvm::LoadInst *)-4096) {
                          goto LABEL_269;
                        }
                        int v102 = v98 + v101++;
                        uint64_t v98 = v102 & (v97 - 1);
                        uint64_t v100 = *(llvm::LoadInst **)(v96 + 16 * v98);
                      }
                      while (v100 != a2);
                      uint64_t v99 = v96 + 16 * v98;
                    }
                  }
                  else
                  {
LABEL_269:
                    uint64_t v99 = v96 + 16 * v97;
                  }
                  uint64_t v122 = *(void **)(v99 + 8);
                  uint64_t v125 = *v122;
                  uint64_t v123 = (char *)(v122 + 2);
                  uint64_t v124 = v125;
                }
                else
                {
                  uint64_t v124 = 0;
                  uint64_t v123 = &byte_1CFBCE98E;
                }
                LOWORD(v250[0]) = 773;
                *(void *)&long long v248 = v123;
                *((void *)&v248 + 1) = v124;
                *(void *)&long long v249 = ".pr";
                unint64_t v126 = *((unsigned __int16 *)a2 + 9);
                uint64_t v127 = (v126 >> 1) & 0x3F;
                unsigned int v128 = (v126 >> 7) & 7;
                uint64_t v129 = *(void *)(__p + 40);
                if (v129 == __p + 40)
                {
                  uint64_t v130 = 0;
                }
                else
                {
                  if (v129) {
                    uint64_t v130 = v129 - 24;
                  }
                  else {
                    uint64_t v130 = 0;
                  }
                  if (*(unsigned __int8 *)(v130 + 16) - 29 >= 0xB) {
                    uint64_t v130 = 0;
                  }
                }
                llvm::LoadInst::LoadInst(v93, v94, v8, (const char **)&v248, 0, v127, v128, *((unsigned char *)a2 + 60), v130);
                uint64_t v131 = (unsigned __int8 *)*((void *)a2 + 6);
                int v238 = v131;
                if (v131) {
                  llvm::MetadataTracking::track((uint64_t)&v238, v131, 2);
                }
                uint64_t v133 = (unsigned __int8 **)(v92 + 80);
                unsigned int v132 = (unsigned __int8 *)*((void *)v92 + 10);
                if (!v132)
                {
LABEL_282:
                  unsigned int v134 = v238;
                  void *v133 = v238;
                  if (v134)
                  {
                    llvm::MetadataTracking::retrack((uint64_t)&v238, v134, (uint64_t)(v92 + 80));
                    int v238 = 0;
                  }
                  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_s64(*(int64x2_t *)v244), (int32x4_t)vceqzq_s64(*(int64x2_t *)v245))))) & 1) == 0)goto LABEL_298; {
                  if (v244[0] || *v133 || (v92[55] & 0x20) != 0)
                  }
                  {
                    llvm::Value::setMetadata((uint64_t ***)v93, 1, v244[0]);
                    uint64_t v135 = v244[1];
                    if (v244[1])
                    {
LABEL_289:
                      llvm::Value::setMetadata((uint64_t ***)v93, 5, v135);
LABEL_290:
                      if (v245[0] || *v133 || (v92[55] & 0x20) != 0) {
                        llvm::Value::setMetadata((uint64_t ***)v93, 7, v245[0]);
                      }
                      if (v245[1] || *v133 || (v92[55] & 0x20) != 0) {
                        llvm::Value::setMetadata((uint64_t ***)v93, 8, v245[1]);
                      }
LABEL_298:
                      int v136 = DWORD2(v257);
                      if (DWORD2(v257) >= HIDWORD(v257)) {
                        llvm::SmallVectorBase<unsigned int>::grow_pod();
                      }
                      uint64_t v58 = (uint64_t *)(v257 + 16 * DWORD2(v257));
                      uint64_t *v58 = __p;
                      v58[1] = (uint64_t)v93;
                      LODWORD(v58) = v136 + 1;
                      DWORD2(v257) = v136 + 1;
LABEL_300:
                      if (v58 >= 2) {
                        qsort((void *)v257, v58, 0x10uLL, (int (__cdecl *)(const void *, const void *))sub_1CD76D91C);
                      }
                      uint64_t v137 = *((void *)v4 + 1);
                      if (v137)
                      {
                        while (1)
                        {
                          uint64_t v138 = *(void *)(v137 + 24);
                          unsigned int v139 = *(unsigned __int8 *)(v138 + 16);
                          BOOL v140 = v138 && v139 >= 0x1C;
                          if (v140 && v139 - 29 < 0xB) {
                            break;
                          }
                          uint64_t v137 = *(void *)(v137 + 8);
                          if (!v137) {
                            goto LABEL_312;
                          }
                        }
                        int v143 = 0;
                        uint64_t v144 = *(void *)a2;
                        uint64_t v145 = v137;
LABEL_313:
                        ++v143;
                        while (1)
                        {
                          uint64_t v145 = *(void *)(v145 + 8);
                          if (!v145) {
                            break;
                          }
                          uint64_t v146 = *(void *)(v145 + 24);
                          unsigned int v147 = *(unsigned __int8 *)(v146 + 16);
                          if (v146) {
                            BOOL v148 = v147 >= 0x1C;
                          }
                          else {
                            BOOL v148 = 0;
                          }
                          if (v148 && v147 - 29 < 0xB) {
                            goto LABEL_313;
                          }
                        }
                        char v142 = 0;
                      }
                      else
                      {
LABEL_312:
                        uint64_t v137 = 0;
                        int v143 = 0;
                        uint64_t v144 = *(void *)a2;
                        char v142 = 1;
                      }
                      LOWORD(v250[0]) = 257;
                      uint64_t v150 = (uint64_t *)*((void *)v4 + 6);
                      uint64_t v151 = operator new(0x48uLL);
                      uint64_t v152 = v151;
                      v151[1] = v144;
                      int v153 = (llvm::Value *)(v151 + 1);
                      *uint64_t v151 = 0;
                      v151[2] = 0;
                      v151[3] = 0x4000000000000053;
                      *((_OWORD *)v151 + 2) = 0u;
                      uint64_t v154 = (char *)(v151 + 4);
                      *((_OWORD *)v151 + 3) = 0u;
                      *((_DWORD *)v151 + 16) = 0;
                      if (v150)
                      {
                        uint64_t v213 = v150[2];
                        v151[6] = v213;
                        *(_WORD *)(v213 + 18) &= ~0x8000u;
                        if ((*((unsigned char *)v151 + 31) & 0x10) != 0)
                        {
                          uint64_t v225 = *(void *)(v213 + 56);
                          if (v225)
                          {
                            uint64_t v226 = *(llvm::ValueSymbolTable **)(v225 + 104);
                            if (v226) {
                              llvm::ValueSymbolTable::reinsertValue(v226, v153);
                            }
                          }
                        }
                        uint64_t v214 = *v150;
                        v152[4] = *v150;
                        v152[5] = v150;
                        *(void *)(v214 + 8) = v154;
                        *uint64_t v150 = (uint64_t)v154;
                      }
                      *((_DWORD *)v152 + 17) = v143;
                      llvm::Value::setNameImpl(v153, (const char **)&v248);
                      if (!*((unsigned char *)v152 + 24))
                      {
                        if ((*((unsigned char *)v152 + 31) & 0x10) == 0) {
                          goto LABEL_463;
                        }
                        uint64_t v217 = ***(void ***)v153;
                        uint64_t v218 = *(void *)(v217 + 152);
                        uint64_t v219 = *(unsigned int *)(v217 + 168);
                        if (v219)
                        {
                          LODWORD(v220) = (v219 - 1) & ((v153 >> 4) ^ (v153 >> 9));
                          uint64_t v221 = (llvm::Value **)(v218 + 16 * v220);
                          unsigned int v222 = *v221;
                          if (*v221 != v153)
                          {
                            int v223 = 1;
                            do
                            {
                              if (v222 == (llvm::Value *)-4096) {
                                goto LABEL_455;
                              }
                              int v224 = v220 + v223++;
                              uint64_t v220 = v224 & (v219 - 1);
                              unsigned int v222 = *(llvm::Value **)(v218 + 16 * v220);
                            }
                            while (v222 != v153);
                            uint64_t v221 = (llvm::Value **)(v218 + 16 * v220);
                          }
                        }
                        else
                        {
LABEL_455:
                          uint64_t v221 = (llvm::Value **)(v218 + 16 * v219);
                        }
                        uint64_t v227 = v221[1];
                        unint64_t v230 = *(void *)v227;
                        unsigned int v228 = (char *)v227 + 16;
                        unint64_t v229 = v230;
                        if (v230 >= 5
                          && (*(_DWORD *)v228 == *(_DWORD *)"llvm." ? (BOOL v231 = v228[4] == aLlvm_1[4]) : (BOOL v231 = 0), v231))
                        {
                          *((_DWORD *)v152 + 10) |= 0x2000u;
                          int v232 = llvm::Function::lookupIntrinsicID(v228, v229);
                        }
                        else
                        {
LABEL_463:
                          int v232 = 0;
                          *((_DWORD *)v152 + 10) &= ~0x2000u;
                        }
                        *((_DWORD *)v152 + 11) = v232;
                      }
                      uint64_t v155 = *((unsigned int *)v152 + 17);
                      uint64_t v156 = operator new(40 * v155);
                      void *v152 = v156;
                      if (v155)
                      {
                        uint64_t v157 = &v156[4 * v155];
                        do
                        {
                          void *v156 = 0;
                          v156[1] = 0;
                          v156[2] = 0;
                          v156[3] = v153;
                          v156 += 4;
                        }
                        while (v156 != v157);
                      }
                      llvm::Value::takeName((int32x2_t ****)v153, a2);
                      BOOL v159 = (unsigned __int8 *)*((void *)a2 + 6);
                      unsigned int v237 = v159;
                      if (v159) {
                        llvm::MetadataTracking::track((uint64_t)&v237, v159, 2);
                      }
                      uint64_t v160 = (unsigned __int8 *)v152[7];
                      if (!v160)
                      {
LABEL_332:
                        int v161 = v237;
                        v152[7] = v237;
                        if (v161)
                        {
                          llvm::MetadataTracking::retrack((uint64_t)&v237, v161, (uint64_t)(v152 + 7));
                          unsigned int v237 = 0;
                          if (v142) {
                            goto LABEL_334;
                          }
                        }
                        else if (v142)
                        {
                          goto LABEL_334;
                        }
                        uint64_t v165 = *(void *)(v137 + 24);
LABEL_340:
                        unint64_t v166 = *(void *)(v165 + 40);
                        uint64_t v167 = (uint64_t *)v257;
                        unint64_t v168 = DWORD2(v257);
                        while (v168)
                        {
                          unint64_t v169 = v168 >> 1;
                          int64_t v170 = (unint64_t *)&v167[2 * (v168 >> 1)];
                          unint64_t v172 = *v170;
                          unint64_t v171 = (uint64_t *)(v170 + 2);
                          v168 += ~(v168 >> 1);
                          if (v172 < v166) {
                            uint64_t v167 = v171;
                          }
                          else {
                            unint64_t v168 = v169;
                          }
                        }
                        uint64_t v173 = (llvm::Value *)v167[1];
                        uint64_t v174 = *(llvm::Value **)a2;
                        if (*(void *)v173 != *(void *)a2)
                        {
                          LOWORD(v250[0]) = 257;
                          uint64_t v202 = *(void *)(v166 + 40);
                          if (v202 == v166 + 40)
                          {
                            uint64_t v203 = 0;
                          }
                          else
                          {
                            uint64_t v204 = (unsigned __int8 *)(v202 - 24);
                            if (!v202) {
                              uint64_t v204 = 0;
                            }
                            if (v204[16] - 29 >= 0xB) {
                              uint64_t v203 = 0;
                            }
                            else {
                              uint64_t v203 = (const llvm::Twine *)v204;
                            }
                          }
                          uint64_t v205 = llvm::CastInst::CreateBitOrPointerCast(v173, v174, (const char **)&v248, v203, v158);
                          v167[1] = (uint64_t)v205;
                          uint64_t v173 = v205;
                        }
                        uint64_t v175 = *v167;
                        int v176 = *((_DWORD *)v152 + 7);
                        uint64_t v177 = v176 & 0x7FFFFFF;
                        if ((v176 & 0x7FFFFFF) == *((_DWORD *)v152 + 17))
                        {
                          LODWORD(v193) = v177 + (v177 >> 1);
                          if (v193 <= 2) {
                            uint64_t v193 = 2;
                          }
                          else {
                            uint64_t v193 = v193;
                          }
                          uint64_t v234 = v193;
                          *((_DWORD *)v152 + 17) = v193;
                          if ((v176 & 0x40000000) != 0) {
                            uint64_t v194 = (uint64_t *)*v152;
                          }
                          else {
                            uint64_t v194 = (uint64_t *)((char *)v153 - 32 * v177);
                          }
                          __pa = v194;
                          uint64_t v195 = operator new(40 * v193);
                          void *v152 = v195;
                          int v196 = v195;
                          do
                          {
                            void *v196 = 0;
                            v196[1] = 0;
                            v196[2] = 0;
                            v196[3] = v153;
                            v196 += 4;
                          }
                          while (v196 != &v195[4 * v234]);
                          int v197 = *((_DWORD *)v152 + 7);
                          if ((v197 & 0x40000000) != 0) {
                            uint64_t v198 = (uint64_t)v195;
                          }
                          else {
                            uint64_t v198 = (uint64_t)v153 - 32 * (v197 & 0x7FFFFFF);
                          }
                          uint64_t v233 = v198;
                          sub_1CC5E4108((uint64_t)&v248, __pa, &__pa[4 * v177], v198);
                          if (v177)
                          {
                            memmove((void *)(v233 + 32 * v234), &__pa[4 * v177], 8 * v177);
                            uint64_t v199 = 4 * v177;
                            do
                            {
                              int v200 = &__pa[v199];
                              if (__pa[v199 - 4])
                              {
                                *(void *)*(v200 - 2) = *(v200 - 3);
                                uint64_t v201 = *(v200 - 3);
                                if (v201) {
                                  *(void *)(v201 + 16) = *(v200 - 2);
                                }
                              }
                              v199 -= 4;
                            }
                            while (v199 * 8);
                          }
                          operator delete(__pa);
                          int v176 = *((_DWORD *)v152 + 7);
                        }
                        uint64_t v178 = (v176 + 1) & 0x7FFFFFF;
                        *((_DWORD *)v152 + 7) = v176 & 0xF8000000 | (v176 + 1) & 0x7FFFFFF;
                        if ((v176 & 0x40000000) != 0) {
                          uint64_t v179 = (char *)*v152;
                        }
                        else {
                          uint64_t v179 = (char *)v153 - 32 * v178;
                        }
                        uint64_t v180 = (v178 - 1);
                        BOOL v181 = &v179[32 * v180];
                        if (*(void *)v181)
                        {
                          **((void **)v181 + 2) = *((void *)v181 + 1);
                          uint64_t v192 = *((void *)v181 + 1);
                          if (v192) {
                            *(void *)(v192 + 16) = *((void *)v181 + 2);
                          }
                        }
                        *(void *)BOOL v181 = v173;
                        if (v173)
                        {
                          uint64_t v184 = *((void *)v173 + 1);
                          unsigned int v183 = (char **)((char *)v173 + 8);
                          uint64_t v182 = v184;
                          uint64_t v185 = &v179[32 * v180];
                          *((void *)v185 + 1) = v184;
                          if (v184) {
                            *(void *)(v182 + 16) = v185 + 8;
                          }
                          *((void *)v185 + 2) = v183;
                          *unsigned int v183 = v181;
                        }
                        int v186 = *((_DWORD *)v152 + 7);
                        uint64_t v187 = v186 & 0x7FFFFFF;
                        if ((v186 & 0x40000000) != 0) {
                          unint64_t v188 = (char *)*v152;
                        }
                        else {
                          unint64_t v188 = (char *)v153 - 32 * v187;
                        }
                        *(void *)&v188[32 * *((unsigned int *)v152 + 17) + 8 * (v187 - 1)] = v175;
                        while (1)
                        {
                          uint64_t v137 = *(void *)(v137 + 8);
                          if (!v137) {
                            break;
                          }
                          uint64_t v165 = *(void *)(v137 + 24);
                          unsigned int v189 = *(unsigned __int8 *)(v165 + 16);
                          if (v165) {
                            BOOL v190 = v189 >= 0x1C;
                          }
                          else {
                            BOOL v190 = 0;
                          }
                          if (v190 && v189 - 29 < 0xB) {
                            goto LABEL_340;
                          }
                        }
LABEL_334:
                        if (v255)
                        {
                          unint64_t v162 = (llvm::Instruction **)v254;
                          uint64_t v163 = 8 * v255;
                          do
                          {
                            uint64_t v164 = *v162++;
                            long long v248 = xmmword_1CFB32AC0;
                            long long v249 = unk_1CFB32AD0;
                            v250[0] = xmmword_1CFB32AE0;
                            llvm::combineMetadata(v164, a2, (unsigned int *)&v248, 12, 1);
                            v163 -= 8;
                          }
                          while (v163);
                        }
                        llvm::Value::doRAUW(a2, v153, (llvm::Value *)1);
                        llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                      }
                      int v206 = *v160;
                      if ((v206 - 4) > 0x1E)
                      {
                        if ((v206 - 3) >= 0xFFFFFFFE) {
                          uint64_t v215 = v152[7];
                        }
                        else {
                          uint64_t v215 = 0;
                        }
                        if ((v206 - 3) < 0xFFFFFFFE)
                        {
                          if (v206 == 3) {
                            *((void *)v160 + 1) = 0;
                          }
                          goto LABEL_332;
                        }
                        unint64_t v208 = v215 + 8;
                      }
                      else
                      {
                        if ((v160[1] & 0x7F) != 2 && !*((_DWORD *)v160 + 3)) {
                          goto LABEL_332;
                        }
                        uint64_t v207 = *((void *)v160 + 2);
                        if ((v207 & 4) == 0) {
                          goto LABEL_332;
                        }
                        unint64_t v208 = v207 & 0xFFFFFFFFFFFFFFF8;
                        if (!v208) {
                          goto LABEL_332;
                        }
                      }
                      *(void *)&long long v248 = v152 + 7;
                      sub_1CC5FA668(v208 + 16, &v248);
                      goto LABEL_332;
                    }
                  }
                  else
                  {
                    uint64_t v135 = v244[1];
                    if (v244[1]) {
                      goto LABEL_289;
                    }
                  }
                  if (!*v133 && (v92[55] & 0x20) == 0) {
                    goto LABEL_290;
                  }
                  goto LABEL_289;
                }
                int v210 = *v132;
                if ((v210 - 4) > 0x1E)
                {
                  if ((v210 - 3) >= 0xFFFFFFFE) {
                    uint64_t v216 = *((void *)v92 + 10);
                  }
                  else {
                    uint64_t v216 = 0;
                  }
                  if ((v210 - 3) < 0xFFFFFFFE)
                  {
                    if (v210 == 3) {
                      *((void *)v132 + 1) = 0;
                    }
                    goto LABEL_282;
                  }
                  unint64_t v212 = v216 + 8;
                }
                else
                {
                  if ((v132[1] & 0x7F) != 2 && !*((_DWORD *)v132 + 3)) {
                    goto LABEL_282;
                  }
                  uint64_t v211 = *((void *)v132 + 2);
                  if ((v211 & 4) == 0) {
                    goto LABEL_282;
                  }
                  unint64_t v212 = v211 & 0xFFFFFFFFFFFFFFF8;
                  if (!v212) {
                    goto LABEL_282;
                  }
                }
                *(void *)&long long v248 = v92 + 80;
                sub_1CC5FA668(v212 + 16, &v248);
                goto LABEL_282;
              }
              while (1)
              {
                uint64_t v88 = *(void *)(v87 + 24);
                unsigned int v89 = *(unsigned __int8 *)(v88 + 16);
                BOOL v90 = v88 && v89 >= 0x1C;
                if (v90 && v89 - 29 <= 0xA) {
                  break;
                }
                uint64_t v87 = *(void *)(v87 + 8);
                if (!v87) {
                  goto LABEL_203;
                }
              }
LABEL_220:
              uint64_t v103 = *(void *)(v88 + 40);
              uint64_t v104 = *(void *)(v103 + 40);
              if (v104) {
                uint64_t v105 = v104 - 24;
              }
              else {
                uint64_t v105 = 0;
              }
              if (*(unsigned __int8 *)(v105 + 16) - 29 >= 0xB) {
                uint64_t v105 = 0;
              }
              int v106 = *(unsigned __int8 *)(v105 + 16);
              if (v106 != 32 && v106 != 39)
              {
                uint64_t v107 = v248;
                if (*((void *)&v248 + 1) == (void)v248)
                {
                  unsigned int v108 = DWORD1(v249);
                  uint64_t v109 = (void *)(*((void *)&v248 + 1) + 8 * DWORD1(v249));
                  if (DWORD1(v249))
                  {
                    uint64_t v110 = 0;
                    while (*(void *)(*((void *)&v248 + 1) + v110) != v103)
                    {
                      v110 += 8;
                      if (8 * DWORD1(v249) == v110) {
                        goto LABEL_246;
                      }
                    }
                    uint64_t v109 = (void *)(*((void *)&v248 + 1) + v110);
                  }
LABEL_246:
                  uint64_t v107 = *((void *)&v248 + 1);
                }
                else
                {
                  int v111 = v249 - 1;
                  unsigned int v112 = (v249 - 1) & ((v103 >> 4) ^ (v103 >> 9));
                  uint64_t v109 = (void *)(*((void *)&v248 + 1) + 8 * v112);
                  uint64_t v113 = *v109;
                  if (*v109 == -1)
                  {
                    uint64_t v114 = 0;
LABEL_263:
                    if (v114) {
                      uint64_t v109 = v114;
                    }
                    unsigned int v108 = DWORD1(v249);
                    if (*v109 != v103) {
                      uint64_t v109 = (void *)(*((void *)&v248 + 1) + 8 * v249);
                    }
                  }
                  else
                  {
                    uint64_t v114 = 0;
                    int v115 = 1;
                    while (v113 != v103)
                    {
                      if (v114) {
                        BOOL v116 = 0;
                      }
                      else {
                        BOOL v116 = v113 == -2;
                      }
                      if (v116) {
                        uint64_t v114 = v109;
                      }
                      unsigned int v117 = v112 + v115++;
                      unsigned int v112 = v117 & v111;
                      uint64_t v109 = (void *)(*((void *)&v248 + 1) + 8 * (v117 & v111));
                      uint64_t v113 = *v109;
                      if (*v109 == -1) {
                        goto LABEL_263;
                      }
                    }
                    unsigned int v108 = DWORD1(v249);
                  }
                }
                if (*((void *)&v248 + 1) == v107) {
                  unsigned int v118 = v108;
                }
                else {
                  unsigned int v118 = v249;
                }
                if (v109 == (void *)(*((void *)&v248 + 1) + 8 * v118))
                {
                  if (v252[0] >= (unint64_t)v252[1]) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((void *)v251 + v252[0]++) = v103;
                }
                while (1)
                {
                  uint64_t v87 = *(void *)(v87 + 8);
                  if (!v87) {
                    goto LABEL_203;
                  }
                  uint64_t v88 = *(void *)(v87 + 24);
                  unsigned int v119 = *(unsigned __int8 *)(v88 + 16);
                  if (v88) {
                    BOOL v120 = v119 >= 0x1C;
                  }
                  else {
                    BOOL v120 = 0;
                  }
                  if (v120 && v119 - 29 < 0xB) {
                    goto LABEL_220;
                  }
                }
              }
              if (*((void *)&v248 + 1) != (void)v248) {
                free(*((void **)&v248 + 1));
              }
              if (v251 != v253) {
                free(v251);
              }
            }
            goto LABEL_428;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t llvm::JumpThreadingPass::processBranchOnPHI(llvm::JumpThreadingPass *this, llvm::PHINode *a2)
{
  v18[1] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (void *)*((void *)a2 + 5);
  v17[0] = v18;
  v17[1] = (void *)0x100000000;
  sub_1CBFC9AD0((uint64_t)v17, 1uLL);
  uint64_t v5 = *((_DWORD *)a2 + 5) & 0x7FFFFFF;
  if (v5)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 8 * v5;
    while (1)
    {
      int v8 = *((_DWORD *)a2 + 5);
      unsigned int v9 = (v8 & 0x40000000) != 0
         ? (llvm::PHINode *)*((void *)a2 - 1)
         : (llvm::PHINode *)((char *)a2 - 32 * (v8 & 0x7FFFFFF));
      uint64_t v10 = *(void *)((char *)v9 + 32 * *((unsigned int *)a2 + 15) + v6);
      uint64_t v11 = *(void *)(v10 + 40);
      if (v11 != v10 + 40)
      {
        uint64_t v12 = v11 - 24;
        if (!v11) {
          uint64_t v12 = 0;
        }
        unsigned int v13 = *(unsigned __int8 *)(v12 + 16) - 40;
        if (v13 < 0xFFFFFFF5) {
          uint64_t v12 = 0;
        }
        if (v11)
        {
          if (*(unsigned char *)(v12 + 16) == 30 && v13 >= 0xFFFFFFF5 && (*(_DWORD *)(v12 + 20) & 0x7FFFFFF) == 1)
          {
            *(void *)v17[0] = v10;
            if (llvm::JumpThreadingPass::duplicateCondBranchOnPHIIntoPred((uint64_t)this, v4, (uint64_t **)v17)) {
              break;
            }
          }
        }
      }
      v6 += 8;
      if (v7 == v6) {
        goto LABEL_20;
      }
    }
    uint64_t v15 = 1;
  }
  else
  {
LABEL_20:
    uint64_t v15 = 0;
  }
  if (v17[0] != v18) {
    free(v17[0]);
  }
  return v15;
}

uint64_t llvm::JumpThreadingPass::processBranchOnXOR(llvm::JumpThreadingPass *this, llvm::BinaryOperator *a2)
{
  v71[16] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (char *)a2 - 64;
  int v3 = (llvm::Value *)*((void *)a2 - 8);
  if (*((unsigned char *)v3 + 16) == 16 || *(unsigned char *)(*((void *)a2 - 4) + 16) == 16) {
    return 0;
  }
  uint64_t v5 = (llvm::BasicBlock *)*((void *)v4 + 13);
  uint64_t v6 = (void **)*((void *)v5 + 6);
  uint64_t v7 = v6 - 3;
  if (!v6) {
    uint64_t v7 = 0;
  }
  if (*((unsigned char *)v7 + 16) != 83) {
    return 0;
  }
  do
  {
    uint64_t v6 = (void **)v6[1];
    unsigned int v9 = v6 - 3;
    if (!v6) {
      unsigned int v9 = 0;
    }
  }
  while (*((unsigned char *)v9 + 16) == 83);
  unsigned int v10 = *((unsigned __int8 *)v6 - 8) - 38;
  if (v10 < 0x39 && ((0x100060000000001uLL >> v10) & 1) != 0) {
    return 0;
  }
  unsigned int v69 = v71;
  uint64_t v70 = 0x800000000;
  BOOL v15 = sub_1CD76C6A4((uint64_t)this, v3, v5, (uint64_t)&v69, 0, a2);
  if (v15 || (uint64_t v11 = 0, sub_1CD76C6A4((uint64_t)this, *((llvm::Value **)a2 - 4), v5, (uint64_t)&v69, 0, a2)))
  {
    if (v70)
    {
      unsigned int v16 = 0;
      unsigned int v17 = 0;
      BOOL v18 = (char *)v69;
      do
      {
        uint64_t v19 = *(void *)v18;
        if (*(unsigned __int8 *)(*(void *)v18 + 16) - 11 >= 2)
        {
          uint64_t v20 = *(unsigned int *)(v19 + 32);
          if (v20 > 0x40)
          {
            int v22 = 0;
            int64_t v23 = (unint64_t)(v20 + 63) >> 6;
            do
            {
              BOOL v24 = v23-- < 1;
              if (v24) {
                break;
              }
              unint64_t v25 = *(void *)(*(void *)(v19 + 24) + 8 * v23);
              v22 += __clz(v25);
            }
            while (!v25);
            int v26 = v20 | 0xFFFFFFC0;
            if ((v20 & 0x3F) == 0) {
              int v26 = 0;
            }
            BOOL v21 = v22 + v26 == v20;
          }
          else
          {
            BOOL v21 = *(void *)(v19 + 24) == 0;
          }
          int v27 = v21;
          v17 += v27;
          v16 += v27 ^ 1;
        }
        v18 += 16;
      }
      while (v18 != (char *)v69 + 16 * v70);
      if (v16 > v17)
      {
        uint64_t v28 = ***(void ***)v5;
        uint64_t v29 = *(void **)(v28 + 1560);
        if (!v29)
        {
          unsigned int v30 = *(llvm::ConstantInt **)(v28 + 1888);
          uint64_t v31 = ***(void ***)v5;
          unint64_t v32 = *(unsigned int *)(v28 + 1896);
          LODWORD(v67) = v32 >> 8;
          if (v32 >> 8 > 0x40) {
            operator new[]();
          }
          if (v32 <= 0xFF) {
            char v33 = 0;
          }
          else {
            char v33 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v32) + 63);
          }
          uint64_t v66 = (void *)(v33 & 1);
          uint64_t v34 = llvm::ConstantInt::get(v30, (llvm::LLVMContext *)&v66, v14);
          if (v67 >= 0x41 && v66) {
            MEMORY[0x1D25D9CB0](v66, 0x1000C8000313F17);
          }
          uint64_t v29 = v34;
          *(void *)(v31 + 1560) = v34;
        }
        goto LABEL_45;
      }
    }
    else
    {
      unsigned int v16 = 0;
      unsigned int v17 = 0;
    }
    if (v17 | v16)
    {
      uint64_t v35 = **(uint64_t ***)v5;
      uint64_t v36 = *v35;
      uint64_t v29 = *(void **)(*v35 + 1568);
      if (!v29)
      {
        BOOL v37 = *(llvm::ConstantInt **)(v36 + 1888);
        unsigned int v38 = *(_DWORD *)(v36 + 1896);
        LODWORD(v67) = v38 >> 8;
        if (v38 >> 8 > 0x40) {
          operator new[]();
        }
        uint64_t v66 = 0;
        uint64_t v29 = llvm::ConstantInt::get(v37, (llvm::LLVMContext *)&v66, v14);
        if (v67 >= 0x41 && v66)
        {
          uint64_t v65 = v29;
          MEMORY[0x1D25D9CB0](v66, 0x1000C8000313F17);
          uint64_t v29 = v65;
        }
        *(void *)(v36 + 1568) = v29;
      }
    }
    else
    {
      uint64_t v29 = 0;
    }
LABEL_45:
    uint64_t v66 = v68;
    uint64_t v67 = 0x800000000;
    if (v70)
    {
      unsigned int v39 = 0;
      uint64_t v40 = 16 * v70;
      uint64_t v41 = (char *)v69 + 8;
      do
      {
        uint64_t v42 = *(v41 - 1);
        if ((void *)v42 == v29 || *(unsigned __int8 *)(v42 + 16) - 11 <= 1)
        {
          if (v39 >= HIDWORD(v67)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v66 + v39) = *v41;
          unsigned int v39 = v67 + 1;
          LODWORD(v67) = v67 + 1;
        }
        v41 += 2;
        v40 -= 16;
      }
      while (v40);
    }
    else
    {
      unsigned int v39 = 0;
    }
    unint64_t v43 = (void **)*((void *)v5 + 6);
    if (v43) {
      int v44 = v43 - 3;
    }
    else {
      int v44 = 0;
    }
    if (v39 != (*((_DWORD *)v44 + 5) & 0x7FFFFFF))
    {
      if (v39)
      {
        uint64_t v54 = v39;
        unsigned int v55 = (char *)v66;
        uint64_t v56 = 8 * v54;
        while (1)
        {
          uint64_t v57 = *(void *)(*(void *)v55 + 40);
          if (v57) {
            uint64_t v58 = v57 - 24;
          }
          else {
            uint64_t v58 = 0;
          }
          if (*(unsigned __int8 *)(v58 + 16) - 29 >= 0xB) {
            uint64_t v58 = 0;
          }
          int v59 = *(unsigned __int8 *)(v58 + 16);
          if (v59 == 32 || v59 == 39) {
            break;
          }
          v55 += 8;
          v56 -= 8;
          if (!v56) {
            goto LABEL_78;
          }
        }
        uint64_t v11 = 0;
      }
      else
      {
LABEL_78:
        uint64_t v11 = llvm::JumpThreadingPass::duplicateCondBranchOnPHIIntoPred((uint64_t)this, v5, (uint64_t **)&v66);
      }
      goto LABEL_89;
    }
    if (v29)
    {
      uint64_t v45 = *((unsigned int *)v29 + 8);
      if (v45 > 0x40)
      {
        int v61 = 0;
        int64_t v62 = (unint64_t)(v45 + 63) >> 6;
        do
        {
          BOOL v24 = v62-- < 1;
          if (v24) {
            break;
          }
          unint64_t v63 = *(void *)(v29[3] + 8 * v62);
          v61 += __clz(v63);
        }
        while (!v63);
        int v64 = v45 | 0xFFFFFFC0;
        if ((v45 & 0x3F) == 0) {
          int v64 = 0;
        }
        if (v61 + v64 != v45) {
          goto LABEL_62;
        }
      }
      else if (v29[3])
      {
LABEL_62:
        BOOL v46 = !v15;
        int v47 = &v4[32 * v46];
        int v48 = v47;
        if (*(void *)v47)
        {
          **((void **)v47 + 2) = *((void *)v47 + 1);
          uint64_t v49 = *((void *)v47 + 1);
          if (v49) {
            *(void *)(v49 + 16) = *((void *)v47 + 2);
          }
        }
        *(void *)int v47 = v29;
        uint64_t v52 = v29[1];
        int v50 = (char **)(v29 + 1);
        uint64_t v51 = v52;
        *((void *)v47 + 1) = v52;
        int v53 = v47 + 8;
        if (v52) {
          *(void *)(v51 + 16) = v53;
        }
        *(void *)&v4[32 * v46 + 16] = v50;
        *int v50 = v48;
        uint64_t v11 = 1;
LABEL_89:
        if (v66 != v68) {
          free(v66);
        }
        goto LABEL_91;
      }
      uint64_t v60 = *(llvm::UndefValue **)&v4[32 * v15];
    }
    else
    {
      uint64_t v60 = llvm::UndefValue::get(*(llvm::UndefValue **)a2, v13);
    }
    llvm::Value::doRAUW(a2, v60, (llvm::Value *)1);
    llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
  }
LABEL_91:
  if (v69 != v71) {
    free(v69);
  }
  return v11;
}

uint64_t llvm::JumpThreadingPass::processImpliedCondition(llvm::JumpThreadingPass *this, llvm::BasicBlock *a2)
{
  v50[2] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (llvm::BasicBlock *)*((void *)a2 + 5);
  if (v2 != (llvm::BasicBlock *)((char *)a2 + 40))
  {
    uint64_t v3 = v2 ? (uint64_t)v2 - 24 : 0;
    unsigned int v4 = *(unsigned __int8 *)(v3 + 16) - 40;
    uint64_t v5 = v4 >= 0xFFFFFFF5 ? v3 : 0;
    if (v2)
    {
      if (*(unsigned char *)(v5 + 16) == 30 && v4 >= 0xFFFFFFF5 && (*(_DWORD *)(v5 + 20) & 0x7FFFFFF) == 3)
      {
        uint64_t v8 = *(void *)(v5 - 96);
        uint64_t SinglePredecessor = llvm::BasicBlock::getSinglePredecessor(a2);
        if (SinglePredecessor)
        {
          unsigned int v10 = (llvm::BasicBlock *)SinglePredecessor;
          uint64_t v11 = (const llvm::DataLayout *)(*(void *)(*((void *)a2 + 7) + 40) + 272);
          unsigned int v12 = dword_1EBCF2FD0;
          int v13 = -1;
          uint64_t v14 = a2;
          while (1)
          {
            if (++v13 >= v12) {
              return 0;
            }
            BOOL v15 = (void *)*((void *)v10 + 5);
            if (v15 == (void *)((char *)v10 + 40)) {
              return 0;
            }
            unsigned int v16 = v15 - 3;
            if (!v15) {
              unsigned int v16 = 0;
            }
            unsigned int v17 = *((unsigned __int8 *)v16 + 16) - 40;
            if (v17 < 0xFFFFFFF5) {
              unsigned int v16 = 0;
            }
            if (!v15) {
              return 0;
            }
            if (*((unsigned char *)v16 + 16) != 30 || v17 < 0xFFFFFFF5) {
              return 0;
            }
            if ((*((_DWORD *)v16 + 5) & 0x7FFFFFF) != 3) {
              return 0;
            }
            uint64_t v19 = (llvm::BasicBlock *)*(v16 - 4);
            if (v19 != v14 && (llvm::BasicBlock *)*(v16 - 8) != v14) {
              return 0;
            }
            uint64_t v20 = (uint64_t *)*(v16 - 12);
            if (v20 == (uint64_t *)v8) {
              break;
            }
            if (v8 && *(unsigned char *)(v8 + 16) == 81)
            {
              unsigned __int16 isImpliedCondition = llvm::isImpliedCondition(v20, *(_WORD *)(v8 + 18) & 0x3F, *(void *)(v8 - 64), *(void *)(v8 - 32), v11, v19 == v14, 0);
              if (isImpliedCondition >= 0x100u) {
                goto LABEL_40;
              }
              unsigned int v12 = dword_1EBCF2FD0;
            }
            uint64_t v22 = llvm::BasicBlock::getSinglePredecessor(v10);
            uint64_t v14 = v10;
            unsigned int v10 = (llvm::BasicBlock *)v22;
            if (!v22) {
              return 0;
            }
          }
          LOBYTE(isImpliedCondition) = v19 == v14;
LABEL_40:
          uint64_t v24 = v5 - 32;
          if ((_BYTE)isImpliedCondition) {
            uint64_t v25 = 0;
          }
          else {
            uint64_t v25 = -1;
          }
          uint64_t v26 = *(void *)(v24 + 32 * v25);
          llvm::BasicBlock::removePredecessor(*(llvm::Type **)(v24 - 32 * isImpliedCondition), a2, 0);
          int v27 = (char *)operator new(0x60uLL);
          *((_DWORD *)v27 + 13) = *((_DWORD *)v27 + 13) & 0x38000000 | 1;
          *((void *)v27 + 1) = 0;
          *((void *)v27 + 2) = 0;
          *(void *)int v27 = 0;
          *((void *)v27 + 4) = ***(void ***)v26 + 1576;
          *((void *)v27 + 3) = v27 + 32;
          *((void *)v27 + 5) = 0;
          v27[48] = 30;
          v27[49] = 0;
          *((_WORD *)v27 + 25) = 0;
          *((_DWORD *)v27 + 13) = 1;
          *(_OWORD *)(v27 + 56) = 0u;
          uint64_t v28 = v27 + 56;
          *(_OWORD *)(v27 + 72) = 0u;
          *((_DWORD *)v27 + 22) = 0;
          uint64_t v29 = *(void *)(v5 + 40);
          unsigned int v30 = (uint64_t *)(v5 + 24);
          *((void *)v27 + 9) = v29;
          *(_WORD *)(v29 + 18) &= ~0x8000u;
          if ((v27[55] & 0x10) != 0
            && (uint64_t v43 = *(void *)(v29 + 56)) != 0
            && (int v44 = *(llvm::ValueSymbolTable **)(v43 + 104)) != 0)
          {
            llvm::ValueSymbolTable::reinsertValue(v44, (llvm::Value *)(v27 + 32));
            uint64_t v45 = *(void *)v27;
            uint64_t v46 = *v30;
            *((void *)v27 + 7) = *v30;
            *((void *)v27 + 8) = v30;
            *(void *)(v46 + 8) = v28;
            *unsigned int v30 = (uint64_t)v28;
            if (v45)
            {
              **((void **)v27 + 2) = *((void *)v27 + 1);
              uint64_t v47 = *((void *)v27 + 1);
              if (v47) {
                *(void *)(v47 + 16) = *((void *)v27 + 2);
              }
            }
          }
          else
          {
            uint64_t v31 = *v30;
            *((void *)v27 + 7) = *v30;
            *((void *)v27 + 8) = v30;
            *(void *)(v31 + 8) = v28;
            *unsigned int v30 = (uint64_t)v28;
          }
          *(void *)int v27 = v26;
          uint64_t v34 = *(void *)(v26 + 8);
          char v33 = (void *)(v26 + 8);
          uint64_t v32 = v34;
          *((void *)v27 + 1) = v34;
          if (v34) {
            *(void *)(v32 + 16) = v27 + 8;
          }
          *((void *)v27 + 2) = v33;
          void *v33 = v27;
          uint64_t v35 = *(unsigned __int8 **)(v5 + 48);
          uint64_t v49 = v35;
          if (v35) {
            llvm::MetadataTracking::track((uint64_t)&v49, v35, 2);
          }
          unsigned int v38 = (unsigned __int8 *)*((void *)v27 + 10);
          BOOL v37 = (unsigned __int8 **)(v27 + 80);
          uint64_t v36 = v38;
          if (!v38)
          {
LABEL_50:
            unsigned int v39 = v49;
            llvm::ConstantInt *v37 = v49;
            if (v39)
            {
              llvm::MetadataTracking::retrack((uint64_t)&v49, v39, (uint64_t)v37);
              uint64_t v49 = 0;
            }
            llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
          }
          int v40 = *v36;
          if ((v40 - 4) > 0x1E)
          {
            if ((v40 - 3) >= 0xFFFFFFFE) {
              int v48 = v36;
            }
            else {
              int v48 = 0;
            }
            if ((v40 - 3) < 0xFFFFFFFE)
            {
              if (v40 == 3) {
                *((void *)v36 + 1) = 0;
              }
              goto LABEL_50;
            }
            unint64_t v42 = (unint64_t)(v48 + 8);
          }
          else
          {
            if ((v36[1] & 0x7F) != 2 && !*((_DWORD *)v36 + 3)) {
              goto LABEL_50;
            }
            uint64_t v41 = *((void *)v36 + 2);
            if ((v41 & 4) == 0) {
              goto LABEL_50;
            }
            unint64_t v42 = v41 & 0xFFFFFFFFFFFFFFF8;
            if (!v42) {
              goto LABEL_50;
            }
          }
          v50[0] = v37;
          sub_1CC5FA668(v42 + 16, v50);
          goto LABEL_50;
        }
      }
    }
  }
  return 0;
}

uint64_t llvm::JumpThreadingPass::splitBlockPreds(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, char *__s)
{
  int v7 = (int)a3;
  v90[2] = *MEMORY[0x1E4F143B8];
  uint64_t v88 = v90;
  uint64_t v89 = 0x200000000;
  v86[0] = 0;
  v86[1] = 0;
  int v87 = 0;
  if (*(unsigned char *)(a1 + 56)) {
    BOOL v10 = a4 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10)
  {
    uint64_t v19 = 8 * a4;
    uint64_t v20 = a3;
    do
    {
      std::string::size_type v21 = *v20;
      uint64_t v22 = *(uint64_t **)(a1 + 40);
      uint64_t v23 = *v22;
      if (!*v22 || (unsigned int v24 = sub_1CBF7A45C(*v22, *v20), v24 == -1)) {
        unint64_t v25 = 0;
      }
      else {
        unint64_t v25 = *(void *)(*(void *)(v23 + 8) + 24 * v24 + 16);
      }
      unint64_t v85 = v25;
      unsigned int EdgeProbability = llvm::BranchProbabilityInfo::getEdgeProbability(*(void *)(a1 + 48), v21, a2);
      std::string::size_type v27 = llvm::BlockFrequency::operator*(&v85, EdgeProbability);
      __dst.__r_.__value_.__r.__words[0] = v21;
      __dst.__r_.__value_.__l.__size_ = v27;
      sub_1CD6C0B48((uint64_t)__p, (uint64_t)v86, &__dst, (uint64_t *)&__dst.__r_.__value_.__l.__size_);
      ++v20;
      v19 -= 8;
    }
    while (v19);
  }
  uint64_t v11 = (uint64_t *)(a2 + 48);
  do
  {
    uint64_t v12 = *v11;
    uint64_t v13 = v12 - 24;
    if (!v12) {
      uint64_t v13 = 0;
    }
    int v14 = *(unsigned __int8 *)(v13 + 16);
    uint64_t v11 = (uint64_t *)(v12 + 8);
  }
  while (v14 == 83);
  if (v14 == 94)
  {
    size_t v15 = strlen(__s);
    if (v15 >= 0x7FFFFFFFFFFFFFF8) {
LABEL_127:
    }
      abort();
    std::string::size_type v16 = v15;
    if (v15 >= 0x17)
    {
      uint64_t v28 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v15 | 7) != 0x17) {
        uint64_t v28 = v15 | 7;
      }
      uint64_t v29 = v28 + 1;
      p_dst = (std::string *)operator new(v28 + 1);
      __dst.__r_.__value_.__l.__size_ = v16;
      __dst.__r_.__value_.__r.__words[2] = v29 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v15;
      p_dst = &__dst;
      if (!v15)
      {
LABEL_27:
        p_dst->__r_.__value_.__s.__data_[v16] = 0;
        unsigned int v30 = std::string::append(&__dst, ".split-lp");
        uint64_t v31 = (char *)v30->__r_.__value_.__r.__words[2];
        *(_OWORD *)uint64_t __p = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
        BOOL v84 = v31;
        v30->__r_.__value_.__l.__size_ = 0;
        v30->__r_.__value_.__r.__words[2] = 0;
        v30->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        sub_1CD127BEC((uint64_t **)a2);
      }
    }
    memcpy(p_dst, __s, v16);
    goto LABEL_27;
  }
  uint64_t v18 = sub_1CD1271B8((uint64_t **)a2, v7, a4, __s, 0, 0, 0, 0, 0);
  if (v89 >= HIDWORD(v89)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  v88[v89] = v18;
  LODWORD(v89) = v89 + 1;
  __p[0] = 0;
  __p[1] = 0;
  BOOL v84 = 0;
  sub_1CC292E4C((uint64_t)__p, 2 * a4 + v89);
  if (v89)
  {
    uint64_t v32 = v88;
    uint64_t v80 = &v88[v89];
    unint64_t v81 = a2 & 0xFFFFFFFFFFFFFFFBLL;
    uint64_t v78 = a2 | 4;
    while (1)
    {
      uint64_t v33 = *v32;
      uint64_t v34 = __p[1];
      if (__p[1] >= v84)
      {
        uint64_t v36 = __p[0];
        int64_t v37 = ((char *)__p[1] - (char *)__p[0]) >> 4;
        unint64_t v38 = v37 + 1;
        if ((unint64_t)(v37 + 1) >> 60) {
          goto LABEL_127;
        }
        uint64_t v39 = v84 - (char *)__p[0];
        if ((v84 - (char *)__p[0]) >> 3 > v38) {
          unint64_t v38 = v39 >> 3;
        }
        unint64_t v40 = (unint64_t)v39 >= 0x7FFFFFFFFFFFFFF0 ? 0xFFFFFFFFFFFFFFFLL : v38;
        if (v40)
        {
          if (v40 >> 60) {
            goto LABEL_128;
          }
          uint64_t v41 = (char *)operator new(16 * v40);
        }
        else
        {
          uint64_t v41 = 0;
        }
        unint64_t v42 = (uint64_t *)&v41[16 * v37];
        uint64_t *v42 = v33;
        v42[1] = v81;
        uint64_t v43 = v42;
        if (v34 != v36)
        {
          do
          {
            *((_OWORD *)v43 - 1) = *((_OWORD *)v34 - 1);
            v43 -= 2;
            v34 -= 2;
          }
          while (v34 != v36);
          uint64_t v34 = __p[0];
        }
        int v44 = &v41[16 * v40];
        uint64_t v35 = (char *)(v42 + 2);
        __p[0] = v43;
        __p[1] = v42 + 2;
        BOOL v84 = v44;
        if (v34) {
          operator delete(v34);
        }
      }
      else
      {
        *(void *)__p[1] = v33;
        v34[1] = v81;
        uint64_t v35 = (char *)(v34 + 2);
      }
      __p[1] = v35;
      uint64_t v45 = *(void *)(v33 + 8);
      if (v45) {
        break;
      }
LABEL_59:
      uint64_t v50 = 0;
LABEL_60:
      if (*(unsigned char *)(a1 + 56)) {
        sub_1CBF7889C(**(void **)(a1 + 40), v33, v50);
      }
      if (++v32 == v80) {
        goto LABEL_121;
      }
    }
    while (1)
    {
      uint64_t v46 = *(void *)(v45 + 24);
      unsigned int v47 = *(unsigned __int8 *)(v46 + 16);
      BOOL v48 = v46 && v47 >= 0x1C;
      if (v48 && v47 - 29 < 0xB) {
        break;
      }
      uint64_t v45 = *(void *)(v45 + 8);
      if (!v45) {
        goto LABEL_59;
      }
    }
    uint64_t v50 = 0;
    unint64_t v79 = v33 & 0xFFFFFFFFFFFFFFFBLL;
LABEL_64:
    uint64_t v51 = *(void *)(v46 + 40);
    if (v35 < v84)
    {
      *(void *)uint64_t v35 = v51;
      *((void *)v35 + 1) = v78;
      uint64_t v52 = v35 + 16;
      goto LABEL_82;
    }
    int v53 = (char *)__p[0];
    uint64_t v54 = (v35 - (char *)__p[0]) >> 4;
    unint64_t v55 = v54 + 1;
    if ((unint64_t)(v54 + 1) >> 60) {
      goto LABEL_127;
    }
    uint64_t v56 = v84 - (char *)__p[0];
    if ((v84 - (char *)__p[0]) >> 3 > v55) {
      unint64_t v55 = v56 >> 3;
    }
    if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v57 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v57 = v55;
    }
    if (v57)
    {
      if (v57 >> 60) {
        goto LABEL_128;
      }
      uint64_t v58 = (char *)operator new(16 * v57);
    }
    else
    {
      uint64_t v58 = 0;
    }
    int v59 = &v58[16 * v54];
    *(void *)int v59 = v51;
    *((void *)v59 + 1) = v78;
    uint64_t v52 = v59 + 16;
    if (v35 == v53)
    {
      __p[0] = v59;
      __p[1] = v59 + 16;
      BOOL v84 = &v58[16 * v57];
    }
    else
    {
      do
      {
        *((_OWORD *)v59 - 1) = *((_OWORD *)v35 - 1);
        v59 -= 16;
        v35 -= 16;
      }
      while (v35 != v53);
      uint64_t v35 = (char *)__p[0];
      __p[0] = v59;
      __p[1] = v52;
      BOOL v84 = &v58[16 * v57];
      if (!v35)
      {
LABEL_82:
        __p[1] = v52;
        if (v52 < v84)
        {
          *(void *)uint64_t v52 = v51;
          *((void *)v52 + 1) = v79;
          uint64_t v35 = v52 + 16;
          goto LABEL_100;
        }
        uint64_t v60 = (char *)__p[0];
        uint64_t v61 = (v52 - (char *)__p[0]) >> 4;
        unint64_t v62 = v61 + 1;
        if ((unint64_t)(v61 + 1) >> 60) {
          goto LABEL_127;
        }
        uint64_t v63 = v84 - (char *)__p[0];
        if ((v84 - (char *)__p[0]) >> 3 > v62) {
          unint64_t v62 = v63 >> 3;
        }
        if ((unint64_t)v63 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v64 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v64 = v62;
        }
        if (v64)
        {
          if (v64 >> 60) {
LABEL_128:
          }
            sub_1CB833614();
          uint64_t v65 = (char *)operator new(16 * v64);
        }
        else
        {
          uint64_t v65 = 0;
        }
        uint64_t v66 = &v65[16 * v61];
        *(void *)uint64_t v66 = v51;
        *((void *)v66 + 1) = v79;
        uint64_t v35 = v66 + 16;
        if (v52 == v60)
        {
          __p[0] = v66;
          __p[1] = v66 + 16;
          BOOL v84 = &v65[16 * v64];
        }
        else
        {
          do
          {
            *((_OWORD *)v66 - 1) = *((_OWORD *)v52 - 1);
            v66 -= 16;
            v52 -= 16;
          }
          while (v52 != v60);
          uint64_t v52 = (char *)__p[0];
          __p[0] = v66;
          __p[1] = v35;
          BOOL v84 = &v65[16 * v64];
          if (!v52)
          {
LABEL_100:
            __p[1] = v35;
            if (!*(unsigned char *)(a1 + 56)) {
              goto LABEL_112;
            }
            if (v87)
            {
              uint64_t v67 = (v87 - 1) & ((v51 >> 4) ^ (v51 >> 9));
              uint64_t v68 = *(void *)(v86[0] + 16 * v67);
              if (v51 == v68)
              {
LABEL_103:
                uint64_t v69 = *(void *)(v86[0] + 16 * v67 + 8);
LABEL_109:
                BOOL v48 = __CFADD__(v69, v50);
                uint64_t v72 = v69 + v50;
                if (v48) {
                  uint64_t v50 = -1;
                }
                else {
                  uint64_t v50 = v72;
                }
LABEL_112:
                while (1)
                {
                  uint64_t v45 = *(void *)(v45 + 8);
                  if (!v45) {
                    goto LABEL_60;
                  }
                  uint64_t v46 = *(void *)(v45 + 24);
                  unsigned int v73 = *(unsigned __int8 *)(v46 + 16);
                  if (v46) {
                    BOOL v74 = v73 >= 0x1C;
                  }
                  else {
                    BOOL v74 = 0;
                  }
                  if (v74 && v73 - 29 < 0xB) {
                    goto LABEL_64;
                  }
                }
              }
              int v70 = 1;
              while (v68 != -4096)
              {
                int v71 = v67 + v70++;
                uint64_t v67 = v71 & (v87 - 1);
                uint64_t v68 = *(void *)(v86[0] + 16 * v67);
                if (v51 == v68) {
                  goto LABEL_103;
                }
              }
            }
            uint64_t v69 = 0;
            goto LABEL_109;
          }
        }
        operator delete(v52);
        goto LABEL_100;
      }
    }
    operator delete(v35);
    goto LABEL_82;
  }
LABEL_121:
  llvm::DomTreeUpdater::applyUpdatesPermissive(*(void *)(a1 + 32), (uint64_t *)__p[0], ((char *)__p[1] - (char *)__p[0]) >> 4);
  uint64_t v76 = *v88;
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  MEMORY[0x1D25D9CD0](v86[0], 8);
  if (v88 != v90) {
    free(v88);
  }
  return v76;
}

llvm::Value **llvm::JumpThreadingPass::evaluateOnPredecessorEdge(llvm::LazyValueInfo **this, llvm::BasicBlock *a2, llvm::BasicBlock *a3, llvm::Value **a4)
{
  uint64_t SinglePredecessor = llvm::BasicBlock::getSinglePredecessor(a2);
  unsigned int v9 = (llvm::BasicBlock *)SinglePredecessor;
  unsigned int v10 = *((unsigned __int8 *)a4 + 16);
  if (a4 && v10 < 0x15) {
    return a4;
  }
  if (v10 >= 0x1C && ((v12 = a4[5], v12 != a2) ? (BOOL v13 = v12 == (llvm::BasicBlock *)SinglePredecessor) : (BOOL v13 = 1), v13))
  {
    if (v10 == 83)
    {
      if (v12 == (llvm::BasicBlock *)SinglePredecessor)
      {
        uint64_t result = (llvm::Value **)sub_1CBF73380((uint64_t)a4, (uint64_t)a3);
        if (*((unsigned __int8 *)result + 16) >= 0x15u) {
          return 0;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      uint64_t result = 0;
      if (v10 - 81 <= 1 && v12 == a2)
      {
        size_t v15 = (uint64_t ***)llvm::JumpThreadingPass::evaluateOnPredecessorEdge((llvm::JumpThreadingPass *)this, a2, a3, *(a4 - 8));
        std::string::size_type v16 = (llvm::Constant *)llvm::JumpThreadingPass::evaluateOnPredecessorEdge((llvm::JumpThreadingPass *)this, a2, a3, *(a4 - 4));
        uint64_t result = 0;
        if (v15)
        {
          if (v16)
          {
            uint64_t v18 = (llvm::ConstantExpr *)(*((_WORD *)a4 + 9) & 0x3F);
            if (v18 <= 0xF)
            {
              return (llvm::Value **)llvm::ConstantExpr::getFCmp(v18, v15, v16, 0);
            }
            else
            {
              return (llvm::Value **)llvm::ConstantExpr::getICmp(v18, (llvm::Type *)v15, v16, 0, v17);
            }
          }
        }
      }
    }
  }
  else
  {
    int v14 = this[2];
    return (llvm::Value **)llvm::LazyValueInfo::getConstantOnEdge(v14, (llvm::ConstantInt ***)a4, a3, v9, 0);
  }
  return result;
}

void *llvm::JumpThreadingPass::maybethreadThroughTwoBasicBlocks(llvm::JumpThreadingPass *this, llvm::BasicBlock *a2, llvm::Value **a3)
{
  unsigned int v4 = (void *)((char *)a2 + 40);
  uint64_t v3 = (llvm::BasicBlock *)*((void *)a2 + 5);
  if (v3 == (llvm::BasicBlock *)((char *)a2 + 40)) {
    return 0;
  }
  uint64_t result = 0;
  if (v3) {
    int v7 = (char *)v3 - 24;
  }
  else {
    int v7 = 0;
  }
  unsigned int v8 = v7[16] - 40;
  if (v8 >= 0xFFFFFFF5) {
    unsigned int v9 = v7;
  }
  else {
    unsigned int v9 = 0;
  }
  if (!v3) {
    return result;
  }
  if (v9[16] != 30 || v8 < 0xFFFFFFF5) {
    return result;
  }
  uint64_t result = (void *)llvm::BasicBlock::getSinglePredecessor(a2);
  if (!result) {
    return result;
  }
  BOOL v13 = (llvm::BasicBlock *)result;
  size_t v15 = result + 5;
  uint64_t v14 = result[5];
  if ((void *)v14 == result + 5) {
    return 0;
  }
  uint64_t result = 0;
  std::string::size_type v16 = (llvm::Instruction *)(v14 - 24);
  if (v14) {
    uint64_t v17 = v14 - 24;
  }
  else {
    uint64_t v17 = 0;
  }
  unsigned int v18 = *(unsigned __int8 *)(v17 + 16) - 40;
  if (v18 < 0xFFFFFFF5) {
    uint64_t v17 = 0;
  }
  if (v14)
  {
    if (*(unsigned char *)(v17 + 16) == 30 && v18 >= 0xFFFFFFF5)
    {
      if ((*(_DWORD *)(v17 + 20) & 0x7FFFFFF) == 1 || llvm::BasicBlock::getSinglePredecessor(v13)) {
        return 0;
      }
      if (*(unsigned char *)(v14 - 8) == 30)
      {
        if ((*(_DWORD *)(v14 - 4) & 0x7FFFFFF) == 3) {
          int v26 = 2;
        }
        else {
          int v26 = 1;
        }
      }
      else
      {
        int v26 = 2;
        switch(*(unsigned char *)(v14 - 8))
        {
          case 0x1E:
            __break(1u);
            goto LABEL_155;
          case 0x1F:
            int v26 = (*(_DWORD *)(v14 - 4) >> 1) & 0x3FFFFFF;
            break;
          case 0x20:
          case 0x26:
LABEL_155:
            int v26 = (*(_DWORD *)(v14 - 4) & 0x7FFFFFF) - 1;
            break;
          case 0x21:
            goto LABEL_36;
          case 0x24:
            int v26 = *(_WORD *)(v14 - 6) & 1;
            break;
          case 0x25:
            int v26 = 1;
            goto LABEL_36;
          case 0x27:
            int v26 = *(_DWORD *)(v14 + 56) + 1;
            break;
          default:
            goto LABEL_39;
        }
        if (!v26)
        {
LABEL_39:
          if (*((void *)this + 28))
          {
            for (uint64_t i = (void *)*((void *)this + 27); i; uint64_t i = (void *)*i)
            {
              unint64_t v22 = i[4];
              if ((unint64_t)v13 >= v22)
              {
                if (v22 >= (unint64_t)v13) {
                  return 0;
                }
                ++i;
              }
            }
          }
          else
          {
            uint64_t v23 = *((unsigned int *)this + 18);
            if (v23)
            {
              unsigned int v24 = (llvm::BasicBlock **)*((void *)this + 8);
              uint64_t v25 = 8 * v23;
              while (*v24 != v13)
              {
                ++v24;
                v25 -= 8;
                if (!v25) {
                  goto LABEL_56;
                }
              }
              if (v25) {
                return 0;
              }
            }
          }
LABEL_56:
          for (uint64_t j = *((void *)v13 + 6); ; uint64_t j = *(void *)(j + 8))
          {
            uint64_t v28 = j - 24;
            if (!j) {
              uint64_t v28 = 0;
            }
            if (*(unsigned char *)(v28 + 16) != 83) {
              break;
            }
          }
          unsigned int v29 = *(unsigned __int8 *)(j - 8) - 38;
          if (v29 >= 0x39 || ((0x100060000000001uLL >> v29) & 1) == 0)
          {
            uint64_t v30 = *((void *)v13 + 1);
            if (v30)
            {
              while (1)
              {
                uint64_t v31 = *(void *)(v30 + 24);
                unsigned int v32 = *(unsigned __int8 *)(v31 + 16);
                BOOL v33 = v31 && v32 >= 0x1C;
                BOOL v34 = !v33 || v32 - 29 > 0xA;
                if (!v34) {
                  break;
                }
                uint64_t result = 0;
                uint64_t v30 = *(void *)(v30 + 8);
                if (!v30) {
                  return result;
                }
              }
              uint64_t v75 = 0;
              uint64_t v35 = 0;
              int v74 = 0;
              int v76 = 0;
LABEL_74:
              uint64_t v36 = *(llvm::BasicBlock **)(v31 + 40);
              int64_t v37 = llvm::JumpThreadingPass::evaluateOnPredecessorEdge((llvm::LazyValueInfo **)this, a2, v36, a3);
              if (!v37 || *((unsigned char *)v37 + 16) != 16) {
                goto LABEL_93;
              }
              uint64_t v38 = *((unsigned int *)v37 + 8);
              if (v38 > 0x40)
              {
                int v41 = 0;
                int64_t v42 = (unint64_t)(v38 + 63) >> 6;
                do
                {
                  BOOL v34 = v42-- < 1;
                  if (v34) {
                    break;
                  }
                  unint64_t v43 = *((void *)v37[3] + v42);
                  v41 += __clz(v43);
                }
                while (!v43);
                int v44 = v38 | 0xFFFFFFC0;
                if ((v38 & 0x3F) == 0) {
                  int v44 = 0;
                }
                int v45 = v41 + v44;
                if (v45 != v38)
                {
                  BOOL v40 = v45 == v38 - 1;
                  goto LABEL_87;
                }
              }
              else
              {
                uint64_t v39 = v37[3];
                if (v39)
                {
                  BOOL v40 = v39 == (llvm::Value *)1;
LABEL_87:
                  int v46 = v40;
                  v74 += v46;
                  BOOL v40 = v46 == 0;
                  unsigned int v47 = v75;
                  if (!v40) {
                    unsigned int v47 = v36;
                  }
                  uint64_t v75 = v47;
LABEL_93:
                  while (1)
                  {
                    uint64_t v30 = *(void *)(v30 + 8);
                    if (!v30) {
                      break;
                    }
                    uint64_t v31 = *(void *)(v30 + 24);
                    unsigned int v48 = *(unsigned __int8 *)(v31 + 16);
                    if (v31) {
                      BOOL v49 = v48 >= 0x1C;
                    }
                    else {
                      BOOL v49 = 0;
                    }
                    if (v49 && v48 - 29 < 0xB) {
                      goto LABEL_74;
                    }
                  }
                  uint64_t v51 = v35;
                  if (v76 != 1)
                  {
                    uint64_t v51 = v75;
                    if (v74 != 1) {
                      return 0;
                    }
                  }
                  uint64_t v52 = v51 == v35 ? -1 : 0;
                  int v53 = *(llvm::BasicBlock **)&v9[32 * v52 - 32];
                  if (v53 == a2) {
                    return 0;
                  }
                  uint64_t v54 = *((void *)this + 28);
                  if (v54)
                  {
                    unint64_t v55 = (void *)*((void *)this + 27);
                    if (!v55) {
                      goto LABEL_134;
                    }
                    do
                    {
                      unint64_t v56 = v55[4];
                      if (v56 <= (unint64_t)a2)
                      {
                        if (v56 >= (unint64_t)a2) {
                          return 0;
                        }
                        ++v55;
                      }
                      unint64_t v55 = (void *)*v55;
                    }
                    while (v55);
                  }
                  else
                  {
                    uint64_t v57 = *((unsigned int *)this + 18);
                    if (!v57) {
                      goto LABEL_134;
                    }
                    uint64_t v58 = (llvm::BasicBlock **)*((void *)this + 8);
                    uint64_t v59 = 8 * v57;
                    while (*v58 != a2)
                    {
                      ++v58;
                      v59 -= 8;
                      if (!v59) {
                        goto LABEL_121;
                      }
                    }
                    if (v59) {
                      return 0;
                    }
                  }
LABEL_121:
                  if (v54)
                  {
                    for (uint64_t k = (void *)*((void *)this + 27); k; uint64_t k = (void *)*k)
                    {
                      unint64_t v61 = k[4];
                      if ((unint64_t)v53 >= v61)
                      {
                        if (v61 >= (unint64_t)v53) {
                          return 0;
                        }
                        ++k;
                      }
                    }
                  }
                  else
                  {
                    uint64_t v62 = *((unsigned int *)this + 18);
                    if (v62)
                    {
                      uint64_t v63 = (llvm::BasicBlock **)*((void *)this + 8);
                      uint64_t v64 = 8 * v62;
                      while (*v63 != v53)
                      {
                        ++v63;
                        v64 -= 8;
                        if (!v64) {
                          goto LABEL_134;
                        }
                      }
                      if (v64) {
                        return 0;
                      }
                    }
                  }
LABEL_134:
                  uint64_t v65 = (void *)*v4;
                  if ((void *)*v4 == v4)
                  {
                    uint64_t v67 = 0;
                  }
                  else
                  {
                    if (v65) {
                      uint64_t v66 = (uint64_t)(v65 - 3);
                    }
                    else {
                      uint64_t v66 = 0;
                    }
                    if (*(unsigned __int8 *)(v66 + 16) - 29 >= 0xB) {
                      uint64_t v67 = 0;
                    }
                    else {
                      uint64_t v67 = v66;
                    }
                  }
                  unsigned int v68 = sub_1CCD9C004(*((void **)this + 1), a2, v67, *((_DWORD *)this + 58));
                  uint64_t v69 = (void *)*v15;
                  if ((void *)*v15 == v15)
                  {
                    uint64_t v71 = 0;
                  }
                  else
                  {
                    if (v69) {
                      uint64_t v70 = (uint64_t)(v69 - 3);
                    }
                    else {
                      uint64_t v70 = 0;
                    }
                    if (*(unsigned __int8 *)(v70 + 16) - 29 >= 0xB) {
                      uint64_t v71 = 0;
                    }
                    else {
                      uint64_t v71 = v70;
                    }
                  }
                  unsigned int v72 = sub_1CCD9C004(*((void **)this + 1), v13, v71, *((_DWORD *)this + 58));
                  uint64_t result = 0;
                  unsigned int v73 = *((_DWORD *)this + 58);
                  if (v68 <= v73 && v72 <= v73 && v72 + v68 <= v73) {
                    llvm::JumpThreadingPass::threadThroughTwoBasicBlocks(this, v51, v13, a2, v53);
                  }
                  return result;
                }
              }
              ++v76;
              uint64_t v35 = v36;
              goto LABEL_93;
            }
          }
          return 0;
        }
      }
LABEL_36:
      unsigned int v20 = 0;
      while ((llvm::BasicBlock *)llvm::Instruction::getSuccessor(v16, v20) != v13)
      {
        if (v26 == ++v20) {
          goto LABEL_39;
        }
      }
      return 0;
    }
  }
  return result;
}

uint64_t llvm::JumpThreadingPass::tryThreadEdge(uint64_t a1, llvm::BasicBlock *a2, uint64_t **a3, llvm::BasicBlock *a4)
{
  if (a4 == a2) {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 224);
  if (v8)
  {
    unsigned int v9 = *(void **)(a1 + 216);
    if (!v9) {
      goto LABEL_29;
    }
    do
    {
      unint64_t v10 = v9[4];
      if (v10 <= (unint64_t)a2)
      {
        if (v10 >= (unint64_t)a2) {
          return 0;
        }
        ++v9;
      }
      unsigned int v9 = (void *)*v9;
    }
    while (v9);
  }
  else
  {
    uint64_t v12 = *(unsigned int *)(a1 + 72);
    if (!v12) {
      goto LABEL_29;
    }
    BOOL v13 = *(llvm::BasicBlock ***)(a1 + 64);
    uint64_t v14 = 8 * v12;
    while (*v13 != a2)
    {
      ++v13;
      v14 -= 8;
      if (!v14) {
        goto LABEL_16;
      }
    }
    if (v14) {
      return 0;
    }
  }
LABEL_16:
  if (v8)
  {
    for (uint64_t i = *(void **)(a1 + 216); i; uint64_t i = (void *)*i)
    {
      unint64_t v16 = i[4];
      if (v16 <= (unint64_t)a4)
      {
        if (v16 >= (unint64_t)a4) {
          return 0;
        }
        ++i;
      }
    }
  }
  else
  {
    uint64_t v17 = *(unsigned int *)(a1 + 72);
    if (v17)
    {
      unsigned int v18 = *(llvm::BasicBlock ***)(a1 + 64);
      uint64_t v19 = 8 * v17;
      while (*v18 != a4)
      {
        ++v18;
        v19 -= 8;
        if (!v19) {
          goto LABEL_29;
        }
      }
      if (v19) {
        return 0;
      }
    }
  }
LABEL_29:
  unsigned int v20 = *(void **)(a1 + 8);
  std::string::size_type v21 = (void *)*((void *)a2 + 5);
  if (v21 == (void *)((char *)a2 + 40))
  {
    uint64_t v23 = 0;
  }
  else
  {
    if (v21) {
      uint64_t v22 = (uint64_t)(v21 - 3);
    }
    else {
      uint64_t v22 = 0;
    }
    if (*(unsigned __int8 *)(v22 + 16) - 29 >= 0xB) {
      uint64_t v23 = 0;
    }
    else {
      uint64_t v23 = v22;
    }
  }
  if (sub_1CCD9C004(v20, a2, v23, *(_DWORD *)(a1 + 232)) <= *(_DWORD *)(a1 + 232)) {
    llvm::JumpThreadingPass::threadEdge(a1, a2, a3, a4);
  }
  return 0;
}

uint64_t llvm::JumpThreadingPass::duplicateCondBranchOnPHIIntoPred(uint64_t a1, void *a2, uint64_t **a3)
{
  uint64_t v4 = (uint64_t)a2;
  uint64_t v5 = a1;
  uint64_t v162 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 224))
  {
    for (uint64_t i = *(void **)(a1 + 216); i; uint64_t i = (void *)*i)
    {
      unint64_t v7 = i[4];
      if (v7 <= (unint64_t)a2)
      {
        if (v7 >= (unint64_t)a2) {
          return 0;
        }
        ++i;
      }
    }
LABEL_14:
    uint64_t v11 = *(void **)(a1 + 8);
    BOOL v13 = a2 + 5;
    uint64_t v12 = (void *)a2[5];
    if (v12 == a2 + 5)
    {
      uint64_t v15 = 0;
    }
    else
    {
      if (v12) {
        uint64_t v14 = (uint64_t)(v12 - 3);
      }
      else {
        uint64_t v14 = 0;
      }
      if (*(unsigned __int8 *)(v14 + 16) - 29 >= 0xB) {
        uint64_t v15 = 0;
      }
      else {
        uint64_t v15 = v14;
      }
    }
    if (sub_1CCD9C004(v11, a2, v15, *(_DWORD *)(v5 + 232)) > *(_DWORD *)(v5 + 232)) {
      return 0;
    }
    uint64_t v17 = *((unsigned int *)a3 + 2);
    if (v17 == 1) {
      uint64_t v18 = **a3;
    }
    else {
      uint64_t v18 = llvm::JumpThreadingPass::splitBlockPreds(v5, v4, *a3, v17, ".thr_comm");
    }
    uint64_t v19 = (uint64_t *)operator new(0x10uLL);
    std::string::size_type v21 = v19;
    *uint64_t v19 = v18;
    v19[1] = v4 | 4;
    uint64_t v22 = *(void *)(v18 + 40);
    if (v22 == v18 + 40) {
      goto LABEL_177;
    }
    uint64_t v23 = v22 - 24;
    if (v22) {
      uint64_t v24 = v22 - 24;
    }
    else {
      uint64_t v24 = 0;
    }
    unsigned int v25 = *(unsigned __int8 *)(v24 + 16) - 40;
    if (v25 < 0xFFFFFFF5) {
      uint64_t v24 = 0;
    }
    if (v22
      && (*(unsigned char *)(v24 + 16) == 30 ? (BOOL v26 = v25 >= 0xFFFFFFF5) : (BOOL v26 = 0),
          v26 && (*(_DWORD *)(v24 + 20) & 0x7FFFFFF) == 1))
    {
      std::string::size_type v27 = v19 + 2;
    }
    else
    {
LABEL_177:
      __int16 v161 = 257;
      uint64_t v121 = llvm::SplitEdge((llvm *)v18, (llvm::BasicBlock *)v4, 0, 0, 0, (llvm::MemorySSAUpdater *)&v158, v20);
      uint64_t v122 = operator new(0x20uLL);
      v122[2] = v18;
      v122[3] = v121 & 0xFFFFFFFFFFFFFFFBLL;
      *(_OWORD *)uint64_t v122 = *(_OWORD *)v21;
      operator delete(v21);
      std::string::size_type v21 = (uint64_t *)operator new(0x40uLL);
      v21[4] = v121;
      void v21[5] = v4 & 0xFFFFFFFFFFFFFFFBLL;
      long long v123 = *((_OWORD *)v122 + 1);
      *(_OWORD *)std::string::size_type v21 = *(_OWORD *)v122;
      *((_OWORD *)v21 + 1) = v123;
      operator delete(v122);
      v21[6] = v18;
      v21[7] = v4 | 4;
      uint64_t v124 = *(void *)(v121 + 40);
      if (v124 == v121 + 40)
      {
        uint64_t v23 = 0;
      }
      else
      {
        if (v124) {
          uint64_t v125 = v124 - 24;
        }
        else {
          uint64_t v125 = 0;
        }
        if (*(unsigned __int8 *)(v125 + 16) - 29 >= 0xB) {
          uint64_t v23 = 0;
        }
        else {
          uint64_t v23 = v125;
        }
      }
      uint64_t v18 = v121;
      std::string::size_type v27 = v21 + 8;
    }
    int v157 = 0;
    v156[0] = 0;
    v156[1] = 0;
    for (uint64_t j = *(void **)(v4 + 48); ; uint64_t j = (void *)j[1])
    {
      uint64_t v29 = j ? (uint64_t)(j - 3) : 0;
      if (!j || *(unsigned char *)(v29 + 16) != 83) {
        break;
      }
      uint64_t v30 = sub_1CBF73380((uint64_t)(j - 3), v18);
      int v158 = j - 3;
      sub_1CC01F644(v156, &v158)[1] = v30;
    }
    if (j == v13)
    {
LABEL_163:
      uint64_t v114 = (void *)*v13;
      if ((void *)*v13 == v13)
      {
        BOOL v116 = 0;
      }
      else
      {
        if (v114) {
          int v115 = v114 - 3;
        }
        else {
          int v115 = 0;
        }
        if (*((unsigned __int8 *)v115 + 16) - 29 >= 0xB) {
          BOOL v116 = 0;
        }
        else {
          BOOL v116 = v115;
        }
      }
      sub_1CCD9C390(*(v116 - 4), v4, v18, (uint64_t)v156);
      sub_1CCD9C390(*(v116 - 8), v4, v18, (uint64_t)v156);
      llvm::JumpThreadingPass::updateSSA(v117, v4, v18, v156);
      if (*(void **)(v4 + 40) != v13)
      {
        uint64_t v118 = *(void *)(v4 + 48);
        uint64_t v119 = v118 - 24;
        uint64_t v120 = v118 ? v118 - 24 : 0;
        if (*(unsigned char *)(v120 + 16) == 83)
        {
          do
          {
            uint64_t v135 = *(void *)(v119 + 32);
            uint64_t v136 = v135 - 24;
            if (!v135) {
              uint64_t v136 = 0;
            }
            int v137 = *(unsigned __int8 *)(v136 + 16);
            if (v137 == 83) {
              uint64_t v138 = v136;
            }
            else {
              uint64_t v138 = 0;
            }
            int v139 = *(_DWORD *)(v119 + 20);
            uint64_t v140 = v139 & 0x7FFFFFF;
            if ((v139 & 0x7FFFFFF) != 0)
            {
              uint64_t v141 = 0;
              while (1)
              {
                uint64_t v142 = v119 - 32 * v140;
                if ((v139 & 0x40000000) != 0) {
                  uint64_t v142 = *(void *)(v119 - 8);
                }
                if (*(void *)(v142 + 32 * *(unsigned int *)(v119 + 60) + 8 * v141) == v18) {
                  break;
                }
                if (v140 == ++v141) {
                  goto LABEL_202;
                }
              }
              uint64_t v143 = v141;
            }
            else
            {
LABEL_202:
              uint64_t v143 = 0xFFFFFFFFLL;
            }
            uint64_t v144 = v140;
            if ((v139 & 0x40000000) != 0)
            {
              uint64_t v126 = *(void *)(v119 - 8);
              uint64_t v127 = v126 + 32 * v143;
              unsigned int v128 = (uint64_t *)(v126 + 32 * v144);
            }
            else
            {
              uint64_t v126 = v119 - 32 * v140;
              uint64_t v127 = v126 + 32 * v143;
              unsigned int v128 = (uint64_t *)v119;
            }
            sub_1CC5E4108((uint64_t)&v158, (uint64_t *)(v127 + 32), v128, v126 + 32 * v143);
            int v145 = *(_DWORD *)(v119 + 20);
            if ((v145 & 0x40000000) != 0)
            {
              uint64_t v130 = *(void *)(v119 - 8);
              uint64_t v131 = *(unsigned int *)(v119 + 60);
              uint64_t v132 = v130 + 32 * v131;
              uint64_t v129 = v145 & 0x7FFFFFF;
            }
            else
            {
              uint64_t v129 = v145 & 0x7FFFFFF;
              uint64_t v130 = v119 - 32 * v129;
              uint64_t v131 = *(unsigned int *)(v119 + 60);
              uint64_t v132 = v130 + 32 * v131;
            }
            uint64_t v146 = (unsigned char *)(v132 + 8 * v129);
            unsigned int v147 = (unsigned char *)(v132 + 8 * v143 + 8);
            if (v146 != v147)
            {
              memmove((void *)(v130 + 32 * v131 + 8 * v143), v147, v146 - v147);
              int v145 = *(_DWORD *)(v119 + 20);
            }
            if ((v145 & 0x40000000) != 0)
            {
              uint64_t v134 = *(void *)(v119 - 8);
              uint64_t v133 = v145 & 0x7FFFFFF;
            }
            else
            {
              uint64_t v133 = v145 & 0x7FFFFFF;
              uint64_t v134 = v119 - 32 * v133;
            }
            uint64_t v148 = v134 + 32 * v133;
            if (*(void *)(v148 - 32))
            {
              **(void **)(v148 - 16) = *(void *)(v148 - 24);
              uint64_t v149 = *(void *)(v148 - 24);
              if (v149) {
                *(void *)(v149 + 16) = *(void *)(v148 - 16);
              }
            }
            *(void *)(v148 - 32) = 0;
            *(_DWORD *)(v119 + 20) = *(_DWORD *)(v119 + 20) & 0xF8000000 | (*(_DWORD *)(v119 + 20) - 1) & 0x7FFFFFF;
            if (!v135) {
              break;
            }
            uint64_t v119 = v138;
          }
          while (v137 == 83);
        }
      }
      llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
    }
    uint64_t v150 = (void *)(v23 + 24);
    uint64_t v31 = v27;
    uint64_t v151 = (void *)(v4 + 40);
    uint64_t v152 = v5;
    while (1)
    {
      if (j) {
        unsigned int v32 = (llvm::Instruction *)(j - 3);
      }
      else {
        unsigned int v32 = 0;
      }
      BOOL v33 = (llvm::Value *)llvm::Instruction::clone(v32);
      int64_t v37 = v33;
      int v38 = *((_DWORD *)v33 + 5);
      uint64_t v39 = v38 & 0x7FFFFFF;
      if ((v38 & 0x7FFFFFF) != 0)
      {
        uint64_t v40 = 0;
        do
        {
          int v41 = *((_DWORD *)v33 + 5);
          if ((v41 & 0x40000000) != 0) {
            int64_t v42 = (_DWORD *)*((void *)v33 - 1);
          }
          else {
            int64_t v42 = (_DWORD *)((char *)v33 - 32 * (v41 & 0x7FFFFFF));
          }
          uint64_t v43 = *(void *)&v42[8 * v40];
          if (v43) {
            BOOL v44 = *(unsigned __int8 *)(v43 + 16) >= 0x1Cu;
          }
          else {
            BOOL v44 = 0;
          }
          if (v44 && v157)
          {
            uint64_t v45 = (v157 - 1) & ((v43 >> 4) ^ (v43 >> 9));
            uint64_t v46 = *(void *)(v156[0] + 16 * v45);
            if (v43 == v46)
            {
LABEL_65:
              if (v45 != v157)
              {
                if ((v41 & 0x40000000) != 0) {
                  unsigned int v47 = (_DWORD *)*((void *)v33 - 1);
                }
                else {
                  unsigned int v47 = (_DWORD *)((char *)v33 - 32 * (v41 & 0x7FFFFFF));
                }
                uint64_t v48 = *(void *)(v156[0] + 16 * v45 + 8);
                BOOL v49 = &v47[8 * v40];
                if (*(void *)v49)
                {
                  **((void **)v49 + 2) = *((void *)v49 + 1);
                  uint64_t v50 = *((void *)v49 + 1);
                  if (v50) {
                    *(void *)(v50 + 16) = *((void *)v49 + 2);
                  }
                }
                *(void *)BOOL v49 = v48;
                if (v48)
                {
                  uint64_t v53 = *(void *)(v48 + 8);
                  uint64_t v51 = (void *)(v48 + 8);
                  uint64_t v52 = v53;
                  uint64_t v54 = &v47[8 * v40];
                  *((void *)v54 + 1) = v53;
                  if (v53) {
                    *(void *)(v52 + 16) = v54 + 2;
                  }
                  *((void *)v54 + 2) = v51;
                  *uint64_t v51 = v49;
                }
              }
            }
            else
            {
              int v55 = 1;
              while (v46 != -4096)
              {
                int v56 = v45 + v55++;
                uint64_t v45 = v56 & (v157 - 1);
                uint64_t v46 = *(void *)(v156[0] + 16 * v45);
                if (v43 == v46) {
                  goto LABEL_65;
                }
              }
            }
          }
          ++v40;
        }
        while (v40 != v39);
        int v38 = *((_DWORD *)v33 + 5);
      }
      int v153 = j;
      uint64_t v57 = *(void *)v5;
      v154[0] = *(void *)(*(void *)(v4 + 56) + 40) + 272;
      v154[1] = v57;
      v154[2] = 0;
      v154[3] = 0;
      v154[4] = v33;
      __int16 v155 = 257;
      if ((v38 & 0x40000000) != 0)
      {
        uint64_t v59 = (uint64_t *)*((void *)v33 - 1);
        unint64_t v58 = v38 & 0x7FFFFFF;
      }
      else
      {
        unint64_t v58 = v38 & 0x7FFFFFF;
        uint64_t v59 = (uint64_t *)((char *)v33 - 32 * v58);
      }
      int v158 = v160;
      uint64_t v159 = 0x800000000;
      if (v58 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v58)
      {
        uint64_t v60 = 32 * v58;
        unint64_t v61 = v160;
        do
        {
          uint64_t v62 = *v59;
          v59 += 4;
          *v61++ = v62;
          v60 -= 32;
        }
        while (v60);
        uint64_t v63 = v158;
      }
      else
      {
        uint64_t v63 = v160;
      }
      LODWORD(v159) = v58;
      uint64_t v64 = llvm::SimplifyInstructionWithOperands(v33, (uint64_t)v63, v58, (uint64_t)v154, v34, v35, v36);
      if (v158 == v160)
      {
        if (!v64) {
          goto LABEL_92;
        }
      }
      else
      {
        free(v158);
        if (!v64)
        {
LABEL_92:
          int v158 = v32;
          sub_1CC01F644(v156, &v158)[1] = v37;
LABEL_96:
          if (v37)
          {
            if ((*((unsigned char *)v32 + 23) & 0x10) != 0)
            {
              uint64_t v66 = ***(void ***)v32;
              uint64_t v67 = *(void *)(v66 + 152);
              uint64_t v68 = *(unsigned int *)(v66 + 168);
              if (v68)
              {
                LODWORD(v69) = (v68 - 1) & ((v32 >> 4) ^ (v32 >> 9));
                uint64_t v70 = (llvm::Instruction **)(v67 + 16 * v69);
                uint64_t v71 = *v70;
                if (*v70 != v32)
                {
                  int v72 = 1;
                  do
                  {
                    if (v71 == (llvm::Instruction *)-4096) {
                      goto LABEL_105;
                    }
                    int v73 = v69 + v72++;
                    uint64_t v69 = v73 & (v68 - 1);
                    uint64_t v71 = *(llvm::Instruction **)(v67 + 16 * v69);
                  }
                  while (v71 != v32);
                  uint64_t v70 = (llvm::Instruction **)(v67 + 16 * v69);
                }
              }
              else
              {
LABEL_105:
                uint64_t v70 = (llvm::Instruction **)(v67 + 16 * v68);
              }
              int v74 = v70[1];
              uint64_t v77 = *(void *)v74;
              int v76 = (char *)v74 + 16;
              uint64_t v75 = v77;
            }
            else
            {
              uint64_t v75 = 0;
              int v76 = &byte_1CFBCE98E;
            }
            __int16 v161 = 261;
            int v158 = v76;
            uint64_t v159 = v75;
            llvm::Value::setNameImpl(v37, (const char **)&v158);
            if (!*((unsigned char *)v37 + 16))
            {
              if ((*((unsigned char *)v37 + 23) & 0x10) == 0) {
                goto LABEL_161;
              }
              uint64_t v100 = ***(void ***)v37;
              uint64_t v101 = *(void *)(v100 + 152);
              uint64_t v102 = *(unsigned int *)(v100 + 168);
              if (v102)
              {
                LODWORD(v103) = (v102 - 1) & ((v37 >> 4) ^ (v37 >> 9));
                uint64_t v104 = (llvm::Value **)(v101 + 16 * v103);
                uint64_t v105 = *v104;
                if (*v104 != v37)
                {
                  int v106 = 1;
                  do
                  {
                    if (v105 == (llvm::Value *)-4096) {
                      goto LABEL_153;
                    }
                    int v107 = v103 + v106++;
                    uint64_t v103 = v107 & (v102 - 1);
                    uint64_t v105 = *(llvm::Value **)(v101 + 16 * v103);
                  }
                  while (v105 != v37);
                  uint64_t v104 = (llvm::Value **)(v101 + 16 * v103);
                }
              }
              else
              {
LABEL_153:
                uint64_t v104 = (llvm::Value **)(v101 + 16 * v102);
              }
              unsigned int v108 = v104[1];
              unint64_t v111 = *(void *)v108;
              uint64_t v109 = (char *)v108 + 16;
              unint64_t v110 = v111;
              if (v111 >= 5
                && (*(_DWORD *)v109 == *(_DWORD *)"llvm." ? (BOOL v112 = v109[4] == aLlvm_1[4]) : (BOOL v112 = 0), v112))
              {
                *((_DWORD *)v37 + 8) |= 0x2000u;
                int v113 = llvm::Function::lookupIntrinsicID(v109, v110);
              }
              else
              {
LABEL_161:
                int v113 = 0;
                *((_DWORD *)v37 + 8) &= ~0x2000u;
              }
              *((_DWORD *)v37 + 9) = v113;
            }
            *((void *)v37 + 5) = v18;
            *(_WORD *)(v18 + 18) &= ~0x8000u;
            if ((*((unsigned char *)v37 + 23) & 0x10) != 0)
            {
              uint64_t v98 = *(void *)(v18 + 56);
              if (v98)
              {
                uint64_t v99 = *(llvm::ValueSymbolTable **)(v98 + 104);
                if (v99) {
                  llvm::ValueSymbolTable::reinsertValue(v99, v37);
                }
              }
            }
            uint64_t v78 = (void *)*v150;
            *((void *)v37 + 3) = *v150;
            *((void *)v37 + 4) = v150;
            v78[1] = (char *)v37 + 24;
            *uint64_t v150 = (char *)v37 + 24;
            LODWORD(v78) = *((_DWORD *)v37 + 5);
            uint64_t v79 = v78 & 0x7FFFFFF;
            if ((v78 & 0x7FFFFFF) != 0)
            {
              uint64_t v80 = 0;
              unint64_t v81 = v31;
              do
              {
                int v82 = *((_DWORD *)v37 + 5);
                if ((v82 & 0x40000000) != 0) {
                  int v83 = (void ***)*((void *)v37 - 1);
                }
                else {
                  int v83 = (void ***)((char *)v37 - 32 * (v82 & 0x7FFFFFF));
                }
                unint64_t v84 = (unint64_t)v83[4 * v80];
                if (v84) {
                  BOOL v85 = *(unsigned char *)(v84 + 16) == 22;
                }
                else {
                  BOOL v85 = 0;
                }
                if (v85)
                {
                  unint64_t v86 = v84 & 0xFFFFFFFFFFFFFFFBLL;
                  if (v81 >= v27)
                  {
                    int v87 = v27;
                    uint64_t v88 = v4;
                    uint64_t v89 = v18;
                    uint64_t v90 = ((char *)v81 - (char *)v21) >> 4;
                    unint64_t v91 = v90 + 1;
                    if ((unint64_t)(v90 + 1) >> 60) {
                      abort();
                    }
                    unint64_t v92 = (char *)v87 - (char *)v21;
                    unint64_t v93 = v87 - v21;
                    if (v93 > v91) {
                      unint64_t v91 = v93;
                    }
                    if (v92 >= 0x7FFFFFFFFFFFFFF0) {
                      unint64_t v94 = 0xFFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v94 = v91;
                    }
                    if (v94)
                    {
                      if (v94 >> 60) {
                        sub_1CB833614();
                      }
                      uint64_t v95 = (char *)operator new(16 * v94);
                    }
                    else
                    {
                      uint64_t v95 = 0;
                    }
                    uint64_t v96 = (uint64_t *)&v95[16 * v90];
                    uint64_t v18 = v89;
                    uint64_t *v96 = v89;
                    v96[1] = v86;
                    if (v81 == v21)
                    {
                      std::string::size_type v21 = v96;
                      uint64_t v4 = v88;
                    }
                    else
                    {
                      uint64_t v97 = v96;
                      uint64_t v4 = v88;
                      do
                      {
                        *((_OWORD *)v97 - 1) = *((_OWORD *)v81 - 1);
                        v97 -= 2;
                        v81 -= 2;
                      }
                      while (v81 != v21);
                      unint64_t v81 = v21;
                      std::string::size_type v21 = v97;
                    }
                    std::string::size_type v27 = (uint64_t *)&v95[16 * v94];
                    uint64_t v31 = v96 + 2;
                    if (v81) {
                      operator delete(v81);
                    }
                  }
                  else
                  {
                    uint64_t *v81 = v18;
                    v81[1] = v86;
                    uint64_t v31 = v81 + 2;
                  }
                }
                else
                {
                  uint64_t v31 = v81;
                }
                ++v80;
                unint64_t v81 = v31;
              }
              while (v80 != v79);
            }
          }
          goto LABEL_139;
        }
      }
      int v158 = v32;
      sub_1CC01F644(v156, &v158)[1] = v64;
      if (llvm::Instruction::mayHaveSideEffects(v37)) {
        goto LABEL_96;
      }
      llvm::Value::deleteValue((void (**)(void))v37, v65);
LABEL_139:
      uint64_t j = (void *)v153[1];
      BOOL v13 = v151;
      uint64_t v5 = v152;
      if (j == v151) {
        goto LABEL_163;
      }
    }
  }
  uint64_t v8 = *(unsigned int *)(a1 + 72);
  if (!v8) {
    goto LABEL_14;
  }
  unsigned int v9 = *(void **)(a1 + 64);
  uint64_t v10 = 8 * v8;
  while ((void *)*v9 != a2)
  {
    ++v9;
    v10 -= 8;
    if (!v10) {
      goto LABEL_14;
    }
  }
  if (!v10) {
    goto LABEL_14;
  }
  return 0;
}

void llvm::JumpThreadingPass::updateSSA(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  v58[16] = *MEMORY[0x1E4F143B8];
  memset(v54, 0, sizeof(v54));
  int v56 = v58;
  uint64_t v57 = 0x1000000000;
  uint64_t v4 = a2 + 40;
  uint64_t v5 = *(void *)(a2 + 48);
  if (v5 == a2 + 40) {
    goto LABEL_71;
  }
  unsigned int v9 = (a2 >> 4) ^ (a2 >> 9);
  unsigned int v10 = (a3 >> 4) ^ (a3 >> 9);
  do
  {
    if (v5) {
      uint64_t v11 = v5 - 24;
    }
    else {
      uint64_t v11 = 0;
    }
    uint64_t v12 = *(void *)(v11 + 8);
    if (v12)
    {
      unsigned int v13 = 0;
      do
      {
        uint64_t v14 = *(void *)(v12 + 24);
        if (v14 && *(unsigned char *)(v14 + 16) == 83)
        {
          int v15 = *(_DWORD *)(v14 + 20);
          if ((v15 & 0x40000000) != 0) {
            uint64_t v16 = *(void *)(v14 - 8);
          }
          else {
            uint64_t v16 = v14 - 32 * (v15 & 0x7FFFFFF);
          }
          uint64_t v17 = *(void *)(v16
                          + 32 * *(unsigned int *)(v14 + 60)
                          + 8 * ((unint64_t)(v12 - v16) >> 5));
        }
        else
        {
          uint64_t v17 = *(void *)(v14 + 40);
        }
        if (v17 != a2)
        {
          if (v13 >= HIDWORD(v57)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v56 + v13) = v12;
          unsigned int v13 = v57 + 1;
          LODWORD(v57) = v57 + 1;
        }
        uint64_t v12 = *(void *)(v12 + 8);
      }
      while (v12);
      if (v13)
      {
        uint64_t v18 = *(uint64_t ***)v11;
        if ((*(unsigned char *)(v11 + 23) & 0x10) == 0)
        {
          size_t v29 = 0;
          uint64_t v28 = &byte_1CFBCE98E;
LABEL_33:
          llvm::SSAUpdater::Initialize((uint64_t)v54, (uint64_t)v18, v28, v29);
          uint64_t v55 = a2;
          int v31 = *(_DWORD *)(*(void *)&v54[0] + 16);
          if (v31)
          {
            int v32 = v31 - 1;
            unsigned int v33 = (v31 - 1) & v9;
            BOOL v34 = (uint64_t *)(**(void **)&v54[0] + 16 * v33);
            uint64_t v35 = *v34;
            if (*v34 == a2) {
              goto LABEL_48;
            }
            uint64_t v36 = 0;
            int v37 = 1;
            while (v35 != -4096)
            {
              if (v36) {
                BOOL v38 = 0;
              }
              else {
                BOOL v38 = v35 == -8192;
              }
              if (v38) {
                uint64_t v36 = v34;
              }
              unsigned int v39 = v33 + v37++;
              unsigned int v33 = v39 & v32;
              BOOL v34 = (uint64_t *)(**(void **)&v54[0] + 16 * (v39 & v32));
              uint64_t v35 = *v34;
              if (*v34 == a2) {
                goto LABEL_48;
              }
            }
            if (v36) {
              uint64_t v40 = v36;
            }
            else {
              uint64_t v40 = v34;
            }
          }
          else
          {
            uint64_t v40 = 0;
          }
          BOOL v34 = sub_1CC0A3E2C(*(uint64_t *)&v54[0], (uint64_t)&v55, &v55, v40);
          *BOOL v34 = v55;
          v34[1] = 0;
LABEL_48:
          v34[1] = v11;
          uint64_t v53 = v11;
          uint64_t v41 = sub_1CC01F644(a4, &v53)[1];
          uint64_t v55 = a3;
          int v42 = *(_DWORD *)(*(void *)&v54[0] + 16);
          if (v42)
          {
            int v43 = v42 - 1;
            unsigned int v44 = (v42 - 1) & v10;
            uint64_t v45 = (uint64_t *)(**(void **)&v54[0] + 16 * v44);
            uint64_t v46 = *v45;
            if (*v45 == a3) {
              goto LABEL_63;
            }
            unsigned int v47 = 0;
            int v48 = 1;
            while (v46 != -4096)
            {
              if (v47) {
                BOOL v49 = 0;
              }
              else {
                BOOL v49 = v46 == -8192;
              }
              if (v49) {
                unsigned int v47 = v45;
              }
              unsigned int v50 = v44 + v48++;
              unsigned int v44 = v50 & v43;
              uint64_t v45 = (uint64_t *)(**(void **)&v54[0] + 16 * (v50 & v43));
              uint64_t v46 = *v45;
              if (*v45 == a3) {
                goto LABEL_63;
              }
            }
            if (v47) {
              uint64_t v51 = v47;
            }
            else {
              uint64_t v51 = v45;
            }
          }
          else
          {
            uint64_t v51 = 0;
          }
          uint64_t v45 = sub_1CC0A3E2C(*(uint64_t *)&v54[0], (uint64_t)&v55, &v55, v51);
          *uint64_t v45 = v55;
          v45[1] = 0;
LABEL_63:
          v45[1] = v41;
          while (v57)
          {
            uint64_t v52 = (llvm::Use *)*((void *)v56 + v57 - 1);
            LODWORD(v57) = v57 - 1;
            llvm::SSAUpdater::RewriteUse((llvm::SSAUpdater *)v54, v52);
          }
          goto LABEL_22;
        }
        uint64_t v19 = **v18;
        uint64_t v20 = *(void *)(v19 + 152);
        uint64_t v21 = *(unsigned int *)(v19 + 168);
        if (v21)
        {
          LODWORD(v22) = (v21 - 1) & ((v11 >> 4) ^ (v11 >> 9));
          uint64_t v23 = (uint64_t *)(v20 + 16 * v22);
          uint64_t v24 = *v23;
          if (*v23 == v11)
          {
LABEL_32:
            std::string::size_type v27 = (void *)v23[1];
            size_t v30 = *v27;
            uint64_t v28 = (char *)(v27 + 2);
            size_t v29 = v30;
            goto LABEL_33;
          }
          int v25 = 1;
          while (v24 != -4096)
          {
            int v26 = v22 + v25++;
            uint64_t v22 = v26 & (v21 - 1);
            uint64_t v24 = *(void *)(v20 + 16 * v22);
            if (v24 == v11)
            {
              uint64_t v23 = (uint64_t *)(v20 + 16 * v22);
              goto LABEL_32;
            }
          }
        }
        uint64_t v23 = (uint64_t *)(v20 + 16 * v21);
        goto LABEL_32;
      }
    }
LABEL_22:
    uint64_t v5 = *(void *)(v5 + 8);
  }
  while (v5 != v4);
  if (v56 != v58) {
    free(v56);
  }
LABEL_71:
  llvm::SSAUpdater::~SSAUpdater((void **)v54);
}

void llvm::JumpThreadingPass::cloneInstructions(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t ***a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v7 = a1;
  uint64_t v111 = *MEMORY[0x1E4F143B8];
  unsigned int v9 = (unsigned char *)(a1 - 24);
  if (a1) {
    uint64_t v10 = a1 - 24;
  }
  else {
    uint64_t v10 = 0;
  }
  *(void *)a5 = 0;
  *(void *)(a5 + 8) = 0;
  *(_DWORD *)(a5 + 16) = 0;
  if (a1 && *(unsigned char *)(v10 + 16) == 83)
  {
    while (1)
    {
      uint64_t v11 = *(uint64_t ***)v9;
      if ((v9[23] & 0x10) == 0)
      {
        uint64_t v21 = 0;
        uint64_t v22 = &byte_1CFBCE98E;
        goto LABEL_15;
      }
      uint64_t v12 = **v11;
      uint64_t v13 = *(void *)(v12 + 152);
      uint64_t v14 = *(unsigned int *)(v12 + 168);
      if (!v14) {
        goto LABEL_13;
      }
      LODWORD(v15) = (v14 - 1) & ((v9 >> 4) ^ (v9 >> 9));
      uint64_t v16 = (void **)(v13 + 16 * v15);
      uint64_t v17 = *v16;
      if (*v16 != v9) {
        break;
      }
LABEL_14:
      uint64_t v20 = v16[1];
      uint64_t v23 = *v20;
      uint64_t v22 = (char *)(v20 + 2);
      uint64_t v21 = v23;
LABEL_15:
      v110[8] = 261;
      unsigned int v108 = v22;
      uint64_t v109 = v21;
      uint64_t v24 = sub_1CC292F14((uint64_t)v11, 1, (const char **)&v108, a3);
      uint64_t v25 = sub_1CBF73380((uint64_t)v9, (uint64_t)a4);
      int v26 = *((_DWORD *)v24 + 5);
      uint64_t v27 = v26 & 0x7FFFFFF;
      if ((v26 & 0x7FFFFFF) == *((_DWORD *)v24 + 15))
      {
        unsigned int v41 = v27 + (v27 >> 1);
        if (v41 <= 2) {
          uint64_t v42 = 2;
        }
        else {
          uint64_t v42 = v41;
        }
        *((_DWORD *)v24 + 15) = v42;
        if ((v26 & 0x40000000) != 0) {
          int v43 = (uint64_t *)*((void *)v24 - 1);
        }
        else {
          int v43 = (uint64_t *)&v24[-32 * v27];
        }
        uint64_t __p = v43;
        unsigned int v44 = operator new(40 * v42);
        *((void *)v24 - 1) = v44;
        uint64_t v45 = v44;
        do
        {
          *uint64_t v45 = 0;
          v45[1] = 0;
          v45[2] = 0;
          v45[3] = v24;
          v45 += 4;
        }
        while (v45 != &v44[4 * v42]);
        int v46 = *((_DWORD *)v24 + 5);
        if ((v46 & 0x40000000) != 0) {
          uint64_t v47 = (uint64_t)v44;
        }
        else {
          uint64_t v47 = (uint64_t)&v24[-32 * (v46 & 0x7FFFFFF)];
        }
        sub_1CC5E4108((uint64_t)&v108, __p, &__p[4 * v27], v47);
        if (v27)
        {
          memmove((void *)(v47 + 32 * v42), &__p[4 * v27], 8 * v27);
          uint64_t v48 = 4 * v27;
          do
          {
            BOOL v49 = &__p[v48];
            if (__p[v48 - 4])
            {
              *(void *)*(v49 - 2) = *(v49 - 3);
              uint64_t v50 = *(v49 - 3);
              if (v50) {
                *(void *)(v50 + 16) = *(v49 - 2);
              }
            }
            v48 -= 4;
          }
          while (v48 * 8);
        }
        operator delete(__p);
        int v26 = *((_DWORD *)v24 + 5);
      }
      uint64_t v28 = (v26 + 1) & 0x7FFFFFF;
      *((_DWORD *)v24 + 5) = v26 & 0xF8000000 | (v26 + 1) & 0x7FFFFFF;
      if ((v26 & 0x40000000) != 0) {
        size_t v29 = (char *)*((void *)v24 - 1);
      }
      else {
        size_t v29 = &v24[-32 * v28];
      }
      uint64_t v30 = (v28 - 1);
      int v31 = &v29[32 * v30];
      if (*(void *)v31)
      {
        **((void **)v31 + 2) = *((void *)v31 + 1);
        uint64_t v40 = *((void *)v31 + 1);
        if (v40) {
          *(void *)(v40 + 16) = *((void *)v31 + 2);
        }
      }
      *(void *)int v31 = v25;
      if (v25)
      {
        uint64_t v34 = *(void *)(v25 + 8);
        unsigned int v33 = (char **)(v25 + 8);
        uint64_t v32 = v34;
        uint64_t v35 = &v29[32 * v30];
        *((void *)v35 + 1) = v34;
        if (v34) {
          *(void *)(v32 + 16) = v35 + 8;
        }
        *((void *)v35 + 2) = v33;
        llvm::Value *v33 = v31;
      }
      int v36 = *((_DWORD *)v24 + 5);
      uint64_t v37 = v36 & 0x7FFFFFF;
      if ((v36 & 0x40000000) != 0) {
        BOOL v38 = (char *)*((void *)v24 - 1);
      }
      else {
        BOOL v38 = &v24[-32 * v37];
      }
      *(void *)&v38[32 * *((unsigned int *)v24 + 15) + 8 * (v37 - 1)] = a4;
      unsigned int v108 = v9;
      sub_1CC01F644((uint64_t *)a5, &v108)[1] = v24;
      uint64_t v7 = *(void *)(v7 + 8);
      unsigned int v9 = (unsigned char *)(v7 - 24);
      if (v7) {
        uint64_t v39 = v7 - 24;
      }
      else {
        uint64_t v39 = 0;
      }
      if (!v7 || *(unsigned char *)(v39 + 16) != 83) {
        goto LABEL_54;
      }
    }
    int v18 = 1;
    while (v17 != (unsigned char *)-4096)
    {
      int v19 = v15 + v18++;
      uint64_t v15 = v19 & (v14 - 1);
      uint64_t v17 = *(unsigned char **)(v13 + 16 * v15);
      if (v17 == v9)
      {
        uint64_t v16 = (void **)(v13 + 16 * v15);
        goto LABEL_14;
      }
    }
LABEL_13:
    uint64_t v16 = (void **)(v13 + 16 * v14);
    goto LABEL_14;
  }
LABEL_54:
  unsigned int v108 = v110;
  uint64_t v109 = 0x600000000;
  v105[0] = 0;
  v105[1] = 0;
  int v106 = 0;
  uint64_t v51 = **a4;
  llvm::identifyNoAliasScopesToClone(v7, a2, (uint64_t)&v108);
  llvm::cloneNoAliasScopes((uint64_t *)v108, v109, (uint64_t)v105, "thread", 6uLL, v51);
  if (v7 != a2)
  {
    uint64_t v52 = (uint64_t *)(a3 + 40);
    while (1)
    {
      if (v7) {
        uint64_t v53 = (llvm::Instruction *)(v7 - 24);
      }
      else {
        uint64_t v53 = 0;
      }
      uint64_t v54 = (llvm::Value *)llvm::Instruction::clone(v53);
      uint64_t v55 = v54;
      if ((*((unsigned char *)v53 + 23) & 0x10) == 0)
      {
        uint64_t v65 = 0;
        uint64_t v66 = &byte_1CFBCE98E;
        goto LABEL_68;
      }
      uint64_t v56 = ***(void ***)v53;
      uint64_t v57 = *(void *)(v56 + 152);
      uint64_t v58 = *(unsigned int *)(v56 + 168);
      if (!v58) {
        goto LABEL_66;
      }
      LODWORD(v59) = (v58 - 1) & ((v53 >> 4) ^ (v53 >> 9));
      uint64_t v60 = (llvm::Instruction **)(v57 + 16 * v59);
      unint64_t v61 = *v60;
      if (*v60 != v53) {
        break;
      }
LABEL_67:
      uint64_t v64 = v60[1];
      uint64_t v67 = *(const char **)v64;
      uint64_t v66 = (char *)v64 + 16;
      uint64_t v65 = v67;
LABEL_68:
      __int16 v104 = 261;
      v103[0] = v66;
      v103[1] = v65;
      llvm::Value::setNameImpl(v54, v103);
      if (!v55 || *((unsigned char *)v55 + 16)) {
        goto LABEL_70;
      }
      if ((*((unsigned char *)v55 + 23) & 0x10) == 0)
      {
LABEL_116:
        int v100 = 0;
        *((_DWORD *)v55 + 8) &= ~0x2000u;
        goto LABEL_117;
      }
      uint64_t v87 = ***(void ***)v55;
      uint64_t v88 = *(void *)(v87 + 152);
      uint64_t v89 = *(unsigned int *)(v87 + 168);
      if (!v89) {
        goto LABEL_108;
      }
      LODWORD(v90) = (v89 - 1) & ((v55 >> 4) ^ (v55 >> 9));
      unint64_t v91 = (llvm::Value **)(v88 + 16 * v90);
      unint64_t v92 = *v91;
      if (*v91 != v55)
      {
        int v93 = 1;
        while (v92 != (llvm::Value *)-4096)
        {
          int v94 = v90 + v93++;
          uint64_t v90 = v94 & (v89 - 1);
          unint64_t v92 = *(llvm::Value **)(v88 + 16 * v90);
          if (v92 == v55)
          {
            unint64_t v91 = (llvm::Value **)(v88 + 16 * v90);
            goto LABEL_109;
          }
        }
LABEL_108:
        unint64_t v91 = (llvm::Value **)(v88 + 16 * v89);
      }
LABEL_109:
      uint64_t v95 = v91[1];
      unint64_t v98 = *(void *)v95;
      uint64_t v96 = (char *)v95 + 16;
      unint64_t v97 = v98;
      if (v98 < 5) {
        goto LABEL_116;
      }
      if (*(_DWORD *)v96 != *(_DWORD *)"llvm." || v96[4] != aLlvm_1[4]) {
        goto LABEL_116;
      }
      *((_DWORD *)v55 + 8) |= 0x2000u;
      int v100 = llvm::Function::lookupIntrinsicID(v96, v97);
LABEL_117:
      *((_DWORD *)v55 + 9) = v100;
LABEL_70:
      *((void *)v55 + 5) = a3;
      *(_WORD *)(a3 + 18) &= ~0x8000u;
      if ((*((unsigned char *)v55 + 23) & 0x10) != 0)
      {
        uint64_t v85 = *(void *)(a3 + 56);
        if (v85)
        {
          unint64_t v86 = *(llvm::ValueSymbolTable **)(v85 + 104);
          if (v86) {
            llvm::ValueSymbolTable::reinsertValue(v86, v55);
          }
        }
      }
      uint64_t v68 = *v52;
      *((void *)v55 + 4) = v52;
      *((void *)v55 + 3) = v68;
      *(void *)(v68 + 8) = (char *)v55 + 24;
      *uint64_t v52 = (uint64_t)v55 + 24;
      v103[0] = (const char *)v53;
      sub_1CC01F644((uint64_t *)a5, v103)[1] = v55;
      llvm::adaptNoAliasScopes((uint64_t **)v55, (uint64_t)v105, (uint64_t)v51);
      uint64_t v69 = *((_DWORD *)v55 + 5) & 0x7FFFFFF;
      if (v69)
      {
        uint64_t v70 = 0;
        uint64_t v71 = 32 * v69;
        do
        {
          int v72 = *((_DWORD *)v55 + 5);
          if ((v72 & 0x40000000) != 0) {
            int v73 = (char *)*((void *)v55 - 1);
          }
          else {
            int v73 = (char *)v55 - 32 * (v72 & 0x7FFFFFF);
          }
          uint64_t v74 = *(void *)&v73[v70];
          if (v74) {
            BOOL v75 = *(unsigned __int8 *)(v74 + 16) >= 0x1Cu;
          }
          else {
            BOOL v75 = 0;
          }
          if (v75)
          {
            uint64_t v107 = v74;
            v103[0] = 0;
            if (sub_1CC89AE34((uint64_t *)a5, &v107, v103))
            {
              if (v103[0] != (const char *)(*(void *)a5 + 16 * *(unsigned int *)(a5 + 16)))
              {
                int v76 = *((_DWORD *)v55 + 5);
                if ((v76 & 0x40000000) != 0) {
                  uint64_t v77 = (char *)*((void *)v55 - 1);
                }
                else {
                  uint64_t v77 = (char *)v55 - 32 * (v76 & 0x7FFFFFF);
                }
                uint64_t v78 = *((void *)v103[0] + 1);
                uint64_t v79 = &v77[v70];
                if (*(void *)&v77[v70])
                {
                  **((void **)v79 + 2) = *((void *)v79 + 1);
                  uint64_t v80 = *((void *)v79 + 1);
                  if (v80) {
                    *(void *)(v80 + 16) = *((void *)v79 + 2);
                  }
                }
                *(void *)uint64_t v79 = v78;
                if (v78)
                {
                  uint64_t v83 = *(void *)(v78 + 8);
                  unint64_t v81 = (char **)(v78 + 8);
                  uint64_t v82 = v83;
                  unint64_t v84 = &v77[v70];
                  *((void *)v84 + 1) = v83;
                  if (v83) {
                    *(void *)(v82 + 16) = v84 + 8;
                  }
                  *((void *)v84 + 2) = v81;
                  uint64_t *v81 = v79;
                }
              }
            }
          }
          v70 += 32;
        }
        while (v71 != v70);
      }
      uint64_t v7 = *(void *)(v7 + 8);
      if (v7 == a2) {
        goto LABEL_118;
      }
    }
    int v62 = 1;
    while (v61 != (llvm::Instruction *)-4096)
    {
      int v63 = v59 + v62++;
      uint64_t v59 = v63 & (v58 - 1);
      unint64_t v61 = *(llvm::Instruction **)(v57 + 16 * v59);
      if (v61 == v53)
      {
        uint64_t v60 = (llvm::Instruction **)(v57 + 16 * v59);
        goto LABEL_67;
      }
    }
LABEL_66:
    uint64_t v60 = (llvm::Instruction **)(v57 + 16 * v58);
    goto LABEL_67;
  }
LABEL_118:
  MEMORY[0x1D25D9CD0](v105[0], 8);
  if (v108 != v110) {
    free(v108);
  }
}

uint64_t sub_1CCD9C004(void *a1, void *a2, uint64_t a3, int a4)
{
  v45[4] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a2 + 5;
  for (uint64_t i = (void *)a2[6]; i != v6; uint64_t i = (void *)i[1])
  {
    uint64_t v8 = i - 3;
    if (i) {
      unsigned int v9 = i - 3;
    }
    else {
      unsigned int v9 = 0;
    }
    if (*((unsigned char *)v9 + 16) != 83) {
      goto LABEL_9;
    }
  }
  uint64_t v8 = 0;
LABEL_9:
  BOOL v10 = v8 == 0;
  if (v8) {
    uint64_t v11 = v8 + 3;
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v12 = (void *)*v6;
  if ((void *)*v6 == v6)
  {
    uint64_t v13 = 0;
  }
  else
  {
    uint64_t v13 = v12 - 3;
    if (!v12) {
      uint64_t v13 = 0;
    }
    if (*((unsigned __int8 *)v13 + 16) - 29 >= 0xB) {
      uint64_t v13 = 0;
    }
  }
  if (v13 == (void *)a3)
  {
    int v15 = *(unsigned __int8 *)(a3 + 16);
    if (v15 == 31) {
      int v14 = 6;
    }
    else {
      int v14 = 0;
    }
    if (v15 == 32) {
      int v14 = 8;
    }
  }
  else
  {
    int v14 = 0;
  }
  if (v8) {
    uint64_t v16 = (llvm::Instruction *)(v11 - 3);
  }
  else {
    uint64_t v16 = 0;
  }
  unsigned int v43 = v14;
  if (v16 == (llvm::Instruction *)a3)
  {
    LODWORD(v35) = 0;
LABEL_77:
    BOOL v40 = v35 >= v43;
    unsigned int v41 = v35 - v43;
    if (v40) {
      return v41;
    }
    else {
      return 0;
    }
  }
  else
  {
    uint64_t v17 = 0;
    unsigned int v18 = v14 + a4;
    while (v17 <= v18)
    {
      if (*(unsigned char *)(*(void *)v16 + 8) == 12
        && (llvm::Instruction::isUsedOutsideOfBlock(v16, (const llvm::BasicBlock *)a2) & 1) != 0)
      {
        return 0xFFFFFFFFLL;
      }
      int v19 = *((unsigned __int8 *)v16 + 16);
      BOOL v20 = v19 == 84;
      BOOL v21 = v19 != 84;
      uint64_t v22 = v20 ? (uint64_t)v16 : 0;
      if (!v10 && !v21)
      {
        uint64_t v23 = *(void *)(v22 + 64);
        if (v23)
        {
          if (*(unsigned char *)(v23 + 15)) {
            return 0xFFFFFFFFLL;
          }
        }
        if (llvm::CallBase::hasFnAttrOnCalledFunction(v22, 24)) {
          return 0xFFFFFFFFLL;
        }
        uint64_t v24 = *(void *)(v22 + 64);
        if (v24)
        {
          if ((*(unsigned char *)(v24 + 12) & 0x40) != 0) {
            return 0xFFFFFFFFLL;
          }
        }
        if (llvm::CallBase::hasFnAttrOnCalledFunction(v22, 6)) {
          return 0xFFFFFFFFLL;
        }
      }
      int v25 = *((_DWORD *)v16 + 5);
      if ((v25 & 0x40000000) != 0)
      {
        uint64_t v27 = (uint64_t *)*((void *)v16 - 1);
        unint64_t v26 = v25 & 0x7FFFFFF;
      }
      else
      {
        unint64_t v26 = v25 & 0x7FFFFFF;
        uint64_t v27 = (uint64_t *)((char *)v16 - 32 * v26);
      }
      if (v26 >= 5) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v26)
      {
        uint64_t v28 = 32 * v26;
        size_t v29 = v45;
        do
        {
          uint64_t v30 = *v27;
          v27 += 4;
          *v29++ = v30;
          v28 -= 32;
        }
        while (v28);
      }
      uint64_t v32 = (*(uint64_t (**)(void, llvm::Instruction *, void *))(*(void *)*a1 + 72))(*a1, v16, v45);
      BOOL v33 = v32 < 0;
      if (v31) {
        BOOL v33 = v31 < 0;
      }
      if (v33) {
        goto LABEL_57;
      }
      BOOL v34 = v31 < 1;
      if (!v31) {
        BOOL v34 = v32 < 1;
      }
      if (!v34)
      {
LABEL_57:
        uint64_t v35 = (v17 + 1);
        int v36 = *((unsigned __int8 *)v16 + 16);
        BOOL v37 = v36 != 84;
        if (v36 == 84) {
          BOOL v38 = v16;
        }
        else {
          BOOL v38 = 0;
        }
        if (!v10 && !v37)
        {
          uint64_t v39 = *((void *)v38 - 4);
          if (v39
            && !*(unsigned char *)(v39 + 16)
            && *(void *)(v39 + 24) == *((void *)v38 + 9)
            && (*(unsigned char *)(v39 + 33) & 0x20) != 0)
          {
            if ((*(_DWORD *)(*(void *)v38 + 8) & 0xFE) == 0x12) {
              uint64_t v35 = v35;
            }
            else {
              uint64_t v35 = (v17 + 2);
            }
          }
          else
          {
            uint64_t v35 = (v17 + 4);
          }
        }
      }
      else
      {
        uint64_t v35 = v17;
      }
      uint64_t v11 = (void *)v11[1];
      BOOL v10 = v11 == 0;
      if (v11) {
        uint64_t v16 = (llvm::Instruction *)(v11 - 3);
      }
      else {
        uint64_t v16 = 0;
      }
      uint64_t v17 = v35;
      if (v16 == (llvm::Instruction *)a3) {
        goto LABEL_77;
      }
    }
  }
  return v17;
}

void sub_1CCD9C390(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(void *)(a1 + 40) != a1 + 40)
  {
    uint64_t v4 = *(void *)(a1 + 48);
    uint64_t v5 = v4 - 24;
    uint64_t v6 = v4 ? v4 - 24 : 0;
    if (v4 && *(unsigned char *)(v6 + 16) == 83)
    {
      uint64_t v8 = a3;
      do
      {
        uint64_t v10 = sub_1CBF73380(v5, a2);
        uint64_t v11 = v10;
        if (v10)
        {
          if (*(unsigned __int8 *)(v10 + 16) >= 0x1Cu)
          {
            uint64_t v39 = v10;
            uint64_t v40 = 0;
            if (sub_1CC89AE34((uint64_t *)a4, &v39, &v40))
            {
              if (v40 != *(void *)a4 + 16 * *(unsigned int *)(a4 + 16)) {
                uint64_t v11 = *(void *)(v40 + 8);
              }
            }
          }
        }
        int v12 = *(_DWORD *)(v5 + 20);
        uint64_t v13 = v12 & 0x7FFFFFF;
        if ((v12 & 0x7FFFFFF) == *(_DWORD *)(v5 + 60))
        {
          unsigned int v28 = v13 + (v13 >> 1);
          if (v28 <= 2) {
            uint64_t v29 = 2;
          }
          else {
            uint64_t v29 = v28;
          }
          *(_DWORD *)(v5 + 60) = v29;
          if ((v12 & 0x40000000) != 0) {
            uint64_t v30 = *(uint64_t **)(v5 - 8);
          }
          else {
            uint64_t v30 = (uint64_t *)(v5 - 32 * v13);
          }
          int v31 = operator new(40 * v29);
          *(void *)(v5 - 8) = v31;
          uint64_t v32 = v31;
          do
          {
            void *v32 = 0;
            v32[1] = 0;
            v32[2] = 0;
            v32[3] = v5;
            v32 += 4;
          }
          while (v32 != &v31[4 * v29]);
          int v33 = *(_DWORD *)(v5 + 20);
          if ((v33 & 0x40000000) != 0) {
            uint64_t v34 = (uint64_t)v31;
          }
          else {
            uint64_t v34 = v5 - 32 * (v33 & 0x7FFFFFF);
          }
          sub_1CC5E4108((uint64_t)&v40, v30, &v30[4 * v13], v34);
          if (v13)
          {
            memmove((void *)(v34 + 32 * v29), &v30[4 * v13], 8 * v13);
            uint64_t v35 = 4 * v13;
            do
            {
              int v36 = &v30[v35];
              if (v30[v35 - 4])
              {
                *(void *)*(v36 - 2) = *(v36 - 3);
                uint64_t v37 = *(v36 - 3);
                if (v37) {
                  *(void *)(v37 + 16) = *(v36 - 2);
                }
              }
              v35 -= 4;
            }
            while (v35 * 8);
          }
          operator delete(v30);
          int v12 = *(_DWORD *)(v5 + 20);
          uint64_t v8 = a3;
        }
        uint64_t v14 = (v12 + 1) & 0x7FFFFFF;
        *(_DWORD *)(v5 + 20) = v12 & 0xF8000000 | (v12 + 1) & 0x7FFFFFF;
        if ((v12 & 0x40000000) != 0) {
          uint64_t v15 = *(void *)(v5 - 8);
        }
        else {
          uint64_t v15 = v5 - 32 * v14;
        }
        uint64_t v16 = (v14 - 1);
        uint64_t v17 = v15 + 32 * v16;
        if (*(void *)v17)
        {
          **(void **)(v17 + 16) = *(void *)(v17 + 8);
          uint64_t v27 = *(void *)(v17 + 8);
          if (v27) {
            *(void *)(v27 + 16) = *(void *)(v17 + 16);
          }
        }
        *(void *)uint64_t v17 = v11;
        if (v11)
        {
          uint64_t v20 = *(void *)(v11 + 8);
          int v19 = (uint64_t *)(v11 + 8);
          uint64_t v18 = v20;
          uint64_t v21 = v15 + 32 * v16;
          *(void *)(v21 + 8) = v20;
          if (v20) {
            *(void *)(v18 + 16) = v21 + 8;
          }
          *(void *)(v21 + 16) = v19;
          *int v19 = v17;
        }
        int v22 = *(_DWORD *)(v5 + 20);
        uint64_t v23 = v22 & 0x7FFFFFF;
        if ((v22 & 0x40000000) != 0) {
          uint64_t v24 = *(void *)(v5 - 8);
        }
        else {
          uint64_t v24 = v5 - 32 * v23;
        }
        *(void *)(v24 + 32 * *(unsigned int *)(v5 + 60) + 8 * (v23 - 1)) = v8;
        uint64_t v25 = *(void *)(v5 + 32);
        uint64_t v5 = v25 - 24;
        if (v25) {
          uint64_t v26 = v25 - 24;
        }
        else {
          uint64_t v26 = 0;
        }
      }
      while (v25 && *(unsigned char *)(v26 + 16) == 83);
    }
  }
}

void llvm::JumpThreadingPass::unfoldSelectInstr(llvm::JumpThreadingPass *this, llvm::BasicBlock *a2, llvm::BasicBlock *a3, llvm::SelectInst *a4, llvm::PHINode *a5)
{
}

BOOL llvm::JumpThreadingPass::threadGuard(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v204 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF));
  uint64_t v8 = *(uint64_t **)(a4 - 96);
  unsigned int v9 = *(llvm **)(a4 - 32);
  uint64_t v10 = *(llvm **)(a4 - 64);
  if (v8 == (uint64_t *)v7)
  {
    int v14 = 0;
    goto LABEL_11;
  }
  uint64_t v11 = (const llvm::DataLayout *)(*(void *)(a2[7] + 40) + 272);
  int v12 = *(unsigned __int8 *)(v7 + 16);
  if (v7 && v12 == 81)
  {
    unsigned __int16 isImpliedCondition = llvm::isImpliedCondition(v8, *(_WORD *)(v7 + 18) & 0x3F, *(void *)(v7 - 64), *(void *)(v7 - 32), (const llvm::DataLayout *)(*(void *)(a2[7] + 40) + 272), 1, 0);
    if (!(_BYTE)isImpliedCondition || (int v14 = 0, isImpliedCondition <= 0xFFu))
    {
      int v12 = *(unsigned __int8 *)(v7 + 16);
      goto LABEL_7;
    }
LABEL_11:
    int v191 = 128;
    uint64_t v17 = (char *)operator new(0x2000uLL, (std::align_val_t)8uLL);
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    v190[0] = v17;
    v190[1] = 0;
    uint64_t v185 = 2;
    int v186 = 0;
    uint64_t v187 = -4096;
    uint64_t v188 = 0;
    uint64_t v184 = &unk_1F2615EC8;
    do
    {
      uint64_t v20 = &v17[v18];
      uint64_t v21 = v185;
      uint64_t v22 = v187;
      *(void *)&v17[v18 + 8] = v185 & 6;
      *((void *)v20 + 2) = 0;
      *((void *)v20 + 3) = v22;
      if (v22 != -4096 && v22 != -8192 && v22 != 0)
      {
        *((void *)v20 + 2) = *(void *)(v21 & 0xFFFFFFFFFFFFFFF8);
        *(void *)(v21 & 0xFFFFFFFFFFFFFFF8) = &v17[v18 + 8];
        *((void *)v20 + 1) = v21 & 0xFFFFFFFFFFFFFFFELL;
        uint64_t v24 = (void *)*((void *)v20 + 2);
        if (v24) {
          void *v24 = &v17[v18 + 16 + (*v24 & 7)];
        }
        uint64_t v19 = v188;
      }
      *(void *)uint64_t v20 = &unk_1F2615EC8;
      *((void *)v20 + 4) = v19;
      v18 += 64;
    }
    while (v18 != 0x2000);
    if (v187 != -8192 && v187 != -4096 && v187 != 0)
    {
      unint64_t v156 = v185 & 0xFFFFFFFFFFFFFFF8;
      *(void *)(v185 & 0xFFFFFFFFFFFFFFF8) = v186;
      if (v186)
      {
        unint64_t *v186 = *v186 & 7 | v156;
      }
      else
      {
        uint64_t v157 = v187;
        int v158 = ***(int32x2_t ****)v187;
        unint64_t v159 = (unint64_t)v158[303];
        if (v159 <= v156)
        {
          uint64_t v160 = v158[305].u32[0];
          if (v159 + 16 * v160 > v156)
          {
            unsigned int v161 = v160 - 1;
            LODWORD(v162) = v161 & ((v187 >> 4) ^ (v187 >> 9));
            uint64_t v163 = (uint64_t *)(v159 + 16 * v162);
            uint64_t v164 = *v163;
            if (v187 == *v163)
            {
LABEL_230:
              uint64_t *v163 = -8192;
              v158[304] = vadd_s32(v158[304], (int32x2_t)0x1FFFFFFFFLL);
              uint64_t v157 = v187;
            }
            else
            {
              int v165 = 1;
              while (v164 != -4096)
              {
                int v166 = v162 + v165++;
                uint64_t v162 = v166 & v161;
                uint64_t v164 = *(void *)(v159 + 16 * v162);
                if (v187 == v164)
                {
                  uint64_t v163 = (uint64_t *)(v159 + 16 * v162);
                  goto LABEL_230;
                }
              }
            }
            *(unsigned char *)(v157 + 17) &= ~1u;
          }
        }
      }
    }
    LOBYTE(v192[0]) = 0;
    char v193 = 0;
    LODWORD(v186) = 128;
    uint64_t v26 = operator new(0x2000uLL, (std::align_val_t)8uLL);
    uint64_t v184 = v26;
    uint64_t v185 = 0;
    uint64_t v200 = 2;
    uint64_t v201 = 0;
    uint64_t v202 = -4096;
    uint64_t v203 = 0;
    uint64_t v199 = (unint64_t **)&unk_1F2615EC8;
    uint64_t v27 = 0;
    uint64_t v28 = 0x2000;
    uint64_t v29 = v26 + 2;
    do
    {
      uint64_t v30 = v200;
      uint64_t v31 = v202;
      *(v29 - 1) = v200 & 6;
      void *v29 = 0;
      v29[1] = v31;
      if (v31 != -4096 && v31 != -8192 && v31 != 0)
      {
        void *v29 = *(void *)(v30 & 0xFFFFFFFFFFFFFFF8);
        *(void *)(v30 & 0xFFFFFFFFFFFFFFF8) = v29 - 1;
        *(v29 - 1) = v30 & 0xFFFFFFFFFFFFFFFELL;
        if (*v29) {
          *(void *)void *v29 = *(void *)*v29 & 7 | (unint64_t)(v26 + 2);
        }
        uint64_t v27 = v203;
      }
      *(v29 - 2) = &unk_1F2615EC8;
      v29[2] = v27;
      v29 += 8;
      v26 += 8;
      v28 -= 64;
    }
    while (v28);
    if (v202 != -8192 && v202 != -4096 && v202)
    {
      unint64_t v167 = v200 & 0xFFFFFFFFFFFFFFF8;
      *(void *)(v200 & 0xFFFFFFFFFFFFFFF8) = v201;
      if (v201)
      {
        *uint64_t v201 = *v201 & 7 | v167;
      }
      else
      {
        uint64_t v168 = v202;
        unint64_t v169 = ***(int32x2_t ****)v202;
        unint64_t v170 = (unint64_t)v169[303];
        if (v170 <= v167)
        {
          uint64_t v171 = v169[305].u32[0];
          if (v170 + 16 * v171 > v167)
          {
            unsigned int v172 = v171 - 1;
            LODWORD(v173) = v172 & ((v202 >> 4) ^ (v202 >> 9));
            uint64_t v174 = (uint64_t *)(v170 + 16 * v173);
            uint64_t v175 = *v174;
            if (v202 == *v174)
            {
LABEL_240:
              uint64_t *v174 = -8192;
              v169[304] = vadd_s32(v169[304], (int32x2_t)0x1FFFFFFFFLL);
              uint64_t v168 = v202;
            }
            else
            {
              int v176 = 1;
              while (v175 != -4096)
              {
                int v177 = v173 + v176++;
                uint64_t v173 = v177 & v172;
                uint64_t v175 = *(void *)(v170 + 16 * v173);
                if (v202 == v175)
                {
                  uint64_t v174 = (uint64_t *)(v170 + 16 * v173);
                  goto LABEL_240;
                }
              }
            }
            *(unsigned char *)(v168 + 17) &= ~1u;
          }
        }
      }
    }
    LOBYTE(v187) = 0;
    char v189 = 0;
    uint64_t v33 = *(void *)(a3 + 32);
    if (v33) {
      BOOL v34 = v33 == *(void *)(a3 + 40) + 40;
    }
    else {
      BOOL v34 = 1;
    }
    if (v34) {
      uint64_t v35 = 0;
    }
    else {
      uint64_t v35 = (int32x2_t ****)(v33 - 24);
    }
    unsigned int v36 = sub_1CCD9C004(*(void **)(a1 + 8), a2, (uint64_t)v35, *(_DWORD *)(a1 + 232));
    unsigned int v39 = *(_DWORD *)(a1 + 232);
    BOOL v16 = v36 <= v39;
    if (v36 <= v39)
    {
      if (v14) {
        uint64_t v40 = v9;
      }
      else {
        uint64_t v40 = v10;
      }
      if (v14) {
        unsigned int v41 = v10;
      }
      else {
        unsigned int v41 = v9;
      }
      uint64_t v179 = llvm::DuplicateInstructionsInSplitBetween((unint64_t)a2, v40, v35, (uint64_t)&v184, *(void *)(a1 + 32), v37, v38);
      uint64_t v178 = llvm::DuplicateInstructionsInSplitBetween((unint64_t)a2, v41, (int32x2_t ****)a3, (uint64_t)v190, *(void *)(a1 + 32), v42, v43);
      uint64_t v199 = &v201;
      uint64_t v200 = 0x400000000;
      unsigned int v44 = (void *)a2[6];
      if (v44) {
        uint64_t v45 = v44 - 3;
      }
      else {
        uint64_t v45 = 0;
      }
      if (v45 == (unint64_t *)v35)
      {
        unsigned int v46 = 0;
        uint64_t v47 = v179;
      }
      else
      {
        unsigned int v46 = 0;
        uint64_t v47 = v179;
        do
        {
          if (*((unsigned char *)v45 + 16) != 83)
          {
            if (v46 >= HIDWORD(v200)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            v199[v46] = v45;
            unsigned int v46 = v200 + 1;
            LODWORD(v200) = v200 + 1;
          }
          unsigned int v44 = (void *)v44[1];
          if (v44) {
            uint64_t v45 = v44 - 3;
          }
          else {
            uint64_t v45 = 0;
          }
        }
        while (v45 != (unint64_t *)v35);
        unsigned int v44 = (void *)a2[6];
      }
      if (v44 != a2 + 5)
      {
        while (1)
        {
          uint64_t v48 = v44 - 3;
          if (!v44) {
            uint64_t v48 = 0;
          }
          if (*((unsigned char *)v48 + 16) != 83) {
            break;
          }
          unsigned int v44 = (void *)v44[1];
          if (v44 == a2 + 5)
          {
            unsigned int v44 = a2 + 5;
            goto LABEL_82;
          }
        }
        unsigned int v49 = *((unsigned __int8 *)v44 - 8) - 38;
        BOOL v50 = v49 > 0x38;
        uint64_t v51 = (1 << v49) & 0x100060000000001;
        if (!v50 && v51 != 0) {
          unsigned int v44 = (void *)v44[1];
        }
      }
LABEL_82:
      if (v46)
      {
        uint64_t v53 = v44 - 3;
        if (!v44) {
          uint64_t v53 = 0;
        }
        uint64_t v182 = v53 + 3;
        unsigned int v183 = v53;
        uint64_t v54 = v178;
        uint64_t v55 = (int32x2_t ****)v199[v46 - 1];
        if (v55[1])
        {
          uint64_t v56 = *v55;
          LOWORD(v198) = 257;
          uint64_t v57 = operator new(0x48uLL);
          v57[1] = v56;
          uint64_t v58 = (llvm::Value *)(v57 + 1);
          *uint64_t v57 = 0;
          v57[2] = 0;
          v57[3] = 0x4000000000000053;
          *((_OWORD *)v57 + 2) = 0u;
          uint64_t v59 = (char *)(v57 + 4);
          *((_OWORD *)v57 + 3) = 0u;
          v57[8] = 0x200000000;
          llvm::Value::setNameImpl((llvm::Value *)(v57 + 1), &v194);
          if (!*((unsigned char *)v57 + 24))
          {
            if ((*((unsigned char *)v57 + 31) & 0x10) == 0) {
              goto LABEL_205;
            }
            uint64_t v141 = ***(void ***)v58;
            uint64_t v142 = *(void *)(v141 + 152);
            uint64_t v143 = *(unsigned int *)(v141 + 168);
            if (v143)
            {
              LODWORD(v144) = (v143 - 1) & ((v58 >> 4) ^ (v58 >> 9));
              int v145 = (llvm::Value **)(v142 + 16 * v144);
              uint64_t v146 = *v145;
              if (*v145 != v58)
              {
                int v147 = 1;
                do
                {
                  if (v146 == (llvm::Value *)-4096) {
                    goto LABEL_197;
                  }
                  int v148 = v144 + v147++;
                  uint64_t v144 = v148 & (v143 - 1);
                  uint64_t v146 = *(llvm::Value **)(v142 + 16 * v144);
                }
                while (v146 != v58);
                int v145 = (llvm::Value **)(v142 + 16 * v144);
              }
            }
            else
            {
LABEL_197:
              int v145 = (llvm::Value **)(v142 + 16 * v143);
            }
            uint64_t v149 = v145[1];
            unint64_t v152 = *(void *)v149;
            uint64_t v150 = (char *)v149 + 16;
            unint64_t v151 = v152;
            if (v152 >= 5
              && (*(_DWORD *)v150 == *(_DWORD *)"llvm." ? (BOOL v153 = v150[4] == aLlvm_1[4]) : (BOOL v153 = 0), v153))
            {
              *((_DWORD *)v57 + 10) |= 0x2000u;
              int v154 = llvm::Function::lookupIntrinsicID(v150, v151);
            }
            else
            {
LABEL_205:
              int v154 = 0;
              *((_DWORD *)v57 + 10) &= ~0x2000u;
            }
            *((_DWORD *)v57 + 11) = v154;
          }
          uint64_t v60 = *((unsigned int *)v57 + 17);
          unint64_t v61 = operator new(40 * v60);
          *uint64_t v57 = v61;
          if (v60)
          {
            int v62 = &v61[4 * v60];
            do
            {
              void *v61 = 0;
              v61[1] = 0;
              v61[2] = 0;
              v61[3] = v58;
              v61 += 4;
            }
            while (v61 != v62);
          }
          uint64_t v195 = 2;
          int v196 = 0;
          int v197 = v55;
          if (v55 != (int32x2_t ****)-8192 && v55 != (int32x2_t ****)-4096 && v55) {
            llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v195);
          }
          uint64_t v194 = (const char *)&unk_1F2615EC8;
          uint64_t v198 = (void **)v190;
          int v63 = sub_1CC4CFF80((uint64_t)v190, &v194);
          if (v197 != (int32x2_t ****)-8192 && v197 != (int32x2_t ****)-4096 && v197)
          {
            unint64_t v64 = v195 & 0xFFFFFFFFFFFFFFF8;
            *(void *)(v195 & 0xFFFFFFFFFFFFFFF8) = v196;
            if (v196)
            {
              unint64_t *v196 = *v196 & 7 | v64;
            }
            else
            {
              uint64_t v65 = v197;
              uint64_t v66 = ***v197;
              unint64_t v67 = (unint64_t)v66[303];
              if (v67 <= v64)
              {
                uint64_t v68 = v66[305].u32[0];
                if (v67 + 16 * v68 > v64)
                {
                  unsigned int v69 = v68 - 1;
                  LODWORD(v70) = v69 & ((v197 >> 4) ^ (v197 >> 9));
                  uint64_t v71 = (int32x2_t *****)(v67 + 16 * v70);
                  int v72 = *v71;
                  if (v197 != *v71)
                  {
                    int v73 = 1;
                    do
                    {
                      if (v72 == (int32x2_t ****)-4096) {
                        goto LABEL_106;
                      }
                      int v74 = v70 + v73++;
                      uint64_t v70 = v74 & v69;
                      int v72 = *(int32x2_t *****)(v67 + 16 * v70);
                    }
                    while (v197 != v72);
                    uint64_t v71 = (int32x2_t *****)(v67 + 16 * v70);
                  }
                  *uint64_t v71 = (int32x2_t ****)-8192;
                  v66[304] = vadd_s32(v66[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v65 = v197;
LABEL_106:
                  *((unsigned char *)v65 + 17) &= ~1u;
                }
              }
            }
          }
          uint64_t v75 = v63[7];
          int v76 = *((_DWORD *)v57 + 7);
          uint64_t v77 = v76 & 0x7FFFFFF;
          if ((v76 & 0x7FFFFFF) == *((_DWORD *)v57 + 17))
          {
            unsigned int v119 = v77 + (v77 >> 1);
            if (v119 <= 2) {
              uint64_t v120 = 2;
            }
            else {
              uint64_t v120 = v119;
            }
            *((_DWORD *)v57 + 17) = v120;
            if ((v76 & 0x40000000) != 0) {
              uint64_t v121 = (uint64_t *)*v57;
            }
            else {
              uint64_t v121 = (uint64_t *)((char *)v58 - 32 * v77);
            }
            uint64_t __p = v121;
            uint64_t v122 = operator new(40 * v120);
            *uint64_t v57 = v122;
            long long v123 = v122;
            do
            {
              *long long v123 = 0;
              v123[1] = 0;
              v123[2] = 0;
              v123[3] = v58;
              v123 += 4;
            }
            while (v123 != &v122[4 * v120]);
            int v124 = *((_DWORD *)v57 + 7);
            if ((v124 & 0x40000000) != 0) {
              uint64_t v125 = (uint64_t)v122;
            }
            else {
              uint64_t v125 = (uint64_t)v58 - 32 * (v124 & 0x7FFFFFF);
            }
            sub_1CC5E4108((uint64_t)&v194, __p, &__p[4 * v77], v125);
            if (v77)
            {
              memmove((void *)(v125 + 32 * v120), &__p[4 * v77], 8 * v77);
              uint64_t v126 = 4 * v77;
              do
              {
                uint64_t v127 = &__p[v126];
                if (__p[v126 - 4])
                {
                  *(void *)*(v127 - 2) = *(v127 - 3);
                  uint64_t v128 = *(v127 - 3);
                  if (v128) {
                    *(void *)(v128 + 16) = *(v127 - 2);
                  }
                }
                v126 -= 4;
              }
              while (v126 * 8);
            }
            operator delete(__p);
            int v76 = *((_DWORD *)v57 + 7);
            uint64_t v54 = v178;
            uint64_t v47 = v179;
          }
          uint64_t v78 = (v76 + 1) & 0x7FFFFFF;
          *((_DWORD *)v57 + 7) = v76 & 0xF8000000 | (v76 + 1) & 0x7FFFFFF;
          if ((v76 & 0x40000000) != 0) {
            uint64_t v79 = (char *)*v57;
          }
          else {
            uint64_t v79 = (char *)v58 - 32 * v78;
          }
          uint64_t v80 = (v78 - 1);
          unint64_t v81 = &v79[32 * v80];
          if (*(void *)v81)
          {
            **((void **)v81 + 2) = *((void *)v81 + 1);
            uint64_t v117 = *((void *)v81 + 1);
            if (v117) {
              *(void *)(v117 + 16) = *((void *)v81 + 2);
            }
          }
          *(void *)unint64_t v81 = v75;
          if (v75)
          {
            uint64_t v84 = *(void *)(v75 + 8);
            uint64_t v83 = (char **)(v75 + 8);
            uint64_t v82 = v84;
            uint64_t v85 = &v79[32 * v80];
            *((void *)v85 + 1) = v84;
            if (v84) {
              *(void *)(v82 + 16) = v85 + 8;
            }
            *((void *)v85 + 2) = v83;
            *uint64_t v83 = v81;
          }
          int v86 = *((_DWORD *)v57 + 7);
          uint64_t v87 = v86 & 0x7FFFFFF;
          if ((v86 & 0x40000000) != 0) {
            uint64_t v88 = (char *)*v57;
          }
          else {
            uint64_t v88 = (char *)v58 - 32 * v87;
          }
          *(void *)&v88[32 * *((unsigned int *)v57 + 17) + 8 * (v87 - 1)] = v54;
          uint64_t v195 = 2;
          int v196 = 0;
          int v197 = v55;
          if (v55 != (int32x2_t ****)-8192 && v55 != (int32x2_t ****)-4096 && v55) {
            llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v195);
          }
          uint64_t v194 = (const char *)&unk_1F2615EC8;
          uint64_t v198 = &v184;
          uint64_t v89 = sub_1CC4CFF80((uint64_t)&v184, &v194);
          if (v197 != (int32x2_t ****)-8192 && v197 != (int32x2_t ****)-4096 && v197)
          {
            unint64_t v90 = v195 & 0xFFFFFFFFFFFFFFF8;
            *(void *)(v195 & 0xFFFFFFFFFFFFFFF8) = v196;
            if (v196)
            {
              unint64_t *v196 = *v196 & 7 | v90;
            }
            else
            {
              unint64_t v91 = v197;
              unint64_t v92 = ***v197;
              unint64_t v93 = (unint64_t)v92[303];
              if (v93 <= v90)
              {
                uint64_t v94 = v92[305].u32[0];
                if (v93 + 16 * v94 > v90)
                {
                  unsigned int v95 = v94 - 1;
                  LODWORD(v96) = v95 & ((v197 >> 4) ^ (v197 >> 9));
                  unint64_t v97 = (int32x2_t *****)(v93 + 16 * v96);
                  unint64_t v98 = *v97;
                  if (v197 != *v97)
                  {
                    int v99 = 1;
                    do
                    {
                      if (v98 == (int32x2_t ****)-4096) {
                        goto LABEL_134;
                      }
                      int v100 = v96 + v99++;
                      uint64_t v96 = v100 & v95;
                      unint64_t v98 = *(int32x2_t *****)(v93 + 16 * v96);
                    }
                    while (v197 != v98);
                    unint64_t v97 = (int32x2_t *****)(v93 + 16 * v96);
                  }
                  *unint64_t v97 = (int32x2_t ****)-8192;
                  v92[304] = vadd_s32(v92[304], (int32x2_t)0x1FFFFFFFFLL);
                  unint64_t v91 = v197;
LABEL_134:
                  *((unsigned char *)v91 + 17) &= ~1u;
                }
              }
            }
          }
          uint64_t v101 = v89[7];
          int v102 = *((_DWORD *)v57 + 7);
          uint64_t v103 = v102 & 0x7FFFFFF;
          if ((v102 & 0x7FFFFFF) == *((_DWORD *)v57 + 17))
          {
            unsigned int v129 = v103 + (v103 >> 1);
            if (v129 <= 2) {
              uint64_t v130 = 2;
            }
            else {
              uint64_t v130 = v129;
            }
            *((_DWORD *)v57 + 17) = v130;
            if ((v102 & 0x40000000) != 0) {
              uint64_t v131 = (uint64_t *)*v57;
            }
            else {
              uint64_t v131 = (uint64_t *)((char *)v58 - 32 * v103);
            }
            __pa = v131;
            uint64_t v132 = operator new(40 * v130);
            *uint64_t v57 = v132;
            uint64_t v133 = v132;
            do
            {
              void *v133 = 0;
              v133[1] = 0;
              v133[2] = 0;
              v133[3] = v58;
              v133 += 4;
            }
            while (v133 != &v132[4 * v130]);
            int v134 = *((_DWORD *)v57 + 7);
            if ((v134 & 0x40000000) != 0) {
              uint64_t v135 = (uint64_t)v132;
            }
            else {
              uint64_t v135 = (uint64_t)v58 - 32 * (v134 & 0x7FFFFFF);
            }
            sub_1CC5E4108((uint64_t)&v194, __pa, &__pa[4 * v103], v135);
            if (v103)
            {
              memmove((void *)(v135 + 32 * v130), &__pa[4 * v103], 8 * v103);
              uint64_t v136 = 4 * v103;
              do
              {
                int v137 = &__pa[v136];
                if (__pa[v136 - 4])
                {
                  *(void *)*(v137 - 2) = *(v137 - 3);
                  uint64_t v138 = *(v137 - 3);
                  if (v138) {
                    *(void *)(v138 + 16) = *(v137 - 2);
                  }
                }
                v136 -= 4;
              }
              while (v136 * 8);
            }
            operator delete(__pa);
            int v102 = *((_DWORD *)v57 + 7);
            uint64_t v47 = v179;
          }
          uint64_t v104 = (v102 + 1) & 0x7FFFFFF;
          *((_DWORD *)v57 + 7) = v102 & 0xF8000000 | (v102 + 1) & 0x7FFFFFF;
          if ((v102 & 0x40000000) != 0) {
            uint64_t v105 = (char *)*v57;
          }
          else {
            uint64_t v105 = (char *)v58 - 32 * v104;
          }
          uint64_t v106 = (v104 - 1);
          uint64_t v107 = &v105[32 * v106];
          if (*(void *)v107)
          {
            **((void **)v107 + 2) = *((void *)v107 + 1);
            uint64_t v118 = *((void *)v107 + 1);
            if (v118) {
              *(void *)(v118 + 16) = *((void *)v107 + 2);
            }
          }
          *(void *)uint64_t v107 = v101;
          if (v101)
          {
            uint64_t v110 = *(void *)(v101 + 8);
            uint64_t v109 = (char **)(v101 + 8);
            uint64_t v108 = v110;
            uint64_t v111 = &v105[32 * v106];
            *((void *)v111 + 1) = v110;
            if (v110) {
              *(void *)(v108 + 16) = v111 + 8;
            }
            *((void *)v111 + 2) = v109;
            *uint64_t v109 = v107;
          }
          int v112 = *((_DWORD *)v57 + 7);
          uint64_t v113 = v112 & 0x7FFFFFF;
          if ((v112 & 0x40000000) != 0) {
            uint64_t v114 = (char *)*v57;
          }
          else {
            uint64_t v114 = (char *)v58 - 32 * v113;
          }
          *(void *)&v114[32 * *((unsigned int *)v57 + 17) + 8 * (v113 - 1)] = v47;
          uint64_t v115 = v183[5];
          v57[6] = v115;
          *(_WORD *)(v115 + 18) &= ~0x8000u;
          if ((*((unsigned char *)v57 + 31) & 0x10) != 0)
          {
            uint64_t v139 = *(void *)(v115 + 56);
            if (v139)
            {
              uint64_t v140 = *(llvm::ValueSymbolTable **)(v139 + 104);
              if (v140) {
                llvm::ValueSymbolTable::reinsertValue(v140, v58);
              }
            }
          }
          uint64_t v116 = *v182;
          v57[4] = *v182;
          v57[5] = v182;
          *(void *)(v116 + 8) = v59;
          uint64_t *v182 = (uint64_t)v59;
          llvm::Value::doRAUW((llvm::ValueAsMetadata *)v55, v58, (llvm::Value *)1);
        }
        llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
      }
      if (v199 != &v201) {
        free(v199);
      }
    }
    if (v189)
    {
      sub_1CC009394((uint64_t)&v187);
      MEMORY[0x1D25D9CD0](v187, 8);
      char v189 = 0;
    }
    sub_1CC4D021C(&v184);
    MEMORY[0x1D25D9CD0](v184, 8);
    if (v193)
    {
      sub_1CC009394((uint64_t)v192);
      MEMORY[0x1D25D9CD0](v192[0], 8);
      char v193 = 0;
    }
    sub_1CC4D021C(v190);
    MEMORY[0x1D25D9CD0](v190[0], 8);
    return v16;
  }
LABEL_7:
  if (v12 != 81) {
    return 0;
  }
  unsigned __int16 v15 = llvm::isImpliedCondition(v8, *(_WORD *)(v7 + 18) & 0x3F, *(void *)(v7 - 64), *(void *)(v7 - 32), v11, 0, 0);
  BOOL v16 = 0;
  if ((_BYTE)v15 && v15 >= 0x100u)
  {
    int v14 = 1;
    goto LABEL_11;
  }
  return v16;
}

void sub_1CCD9DBD8()
{
}

void sub_1CCD9DC1C(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F263E668;
  sub_1CD719E60((uint64_t)a1 + 32);

  llvm::Pass::~Pass(a1);
}

void sub_1CCD9DC70(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F263E668;
  sub_1CD719E60((uint64_t)a1 + 32);
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD9DCD8(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::AAResultsWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LazyValueInfoWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::LazyValueInfoWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetLibraryInfoWrapperPass::ID);

  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
}

uint64_t sub_1CCD9DDAC(uint64_t a1)
{
  return sub_1CD76D31C(a1 + 32);
}

uint64_t sub_1CCD9DDB4(llvm::FunctionPass *a1, uint64_t a2)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if ((llvm::FunctionPass::skipFunction(a1, (llvm::LLVMContextImpl ****)a2) & 1) == 0)
  {
    uint64_t v4 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1];
    if (v5 == v6)
    {
LABEL_5:
      uint64_t v7 = 0;
    }
    else
    {
      while (*(char **)v5 != llvm::TargetTransformInfoWrapperPass::ID)
      {
        v5 += 16;
        if (v5 == v6) {
          goto LABEL_5;
        }
      }
      uint64_t v7 = *(void *)(v5 + 8);
    }
    uint64_t v8 = (llvm::TargetTransformInfoWrapperPass *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v7 + 96))(v7, llvm::TargetTransformInfoWrapperPass::ID);
    TTI = llvm::TargetTransformInfoWrapperPass::getTTI(v8, (const Function *)a2);
    if (((*(uint64_t (**)(uint64_t))(*(void *)*TTI + 88))(*TTI) & 1) == 0)
    {
      uint64_t v10 = (uint64_t *)*((void *)a1 + 1);
      uint64_t v11 = *v10;
      uint64_t v12 = v10[1];
      if (v11 == v12)
      {
LABEL_12:
        uint64_t v13 = 0;
      }
      else
      {
        while (*(char **)v11 != llvm::TargetLibraryInfoWrapperPass::ID)
        {
          v11 += 16;
          if (v11 == v12) {
            goto LABEL_12;
          }
        }
        uint64_t v13 = *(void *)(v11 + 8);
      }
      uint64_t v14 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v13 + 96))(v13, llvm::TargetLibraryInfoWrapperPass::ID);
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      int v25 = 0;
      uint64_t v26 = 0;
      uint64_t v27 = 0;
      int v28 = 0;
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      LODWORD(v31) = 0;
      uint64_t v15 = v14 + 32;
      if (!*(unsigned char *)(v14 + 232))
      {
        uint64_t v17 = *(void *)(a2 + 40) + 216;
        __int16 v20 = 260;
        v19[0] = v17;
        llvm::Triple::Triple((llvm::Triple *)&__p, (const llvm::Twine *)v19);
        uint64_t v39 = 0;
        uint64_t v40 = 0;
        int v41 = 0;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v44 = 0u;
        *(void *)&long long v18 = -1;
        *((void *)&v18 + 1) = -1;
        *(_OWORD *)__src = v18;
        long long v33 = v18;
        long long v34 = v18;
        long long v35 = v18;
        long long v36 = v18;
        long long v37 = v18;
        *(_OWORD *)BOOL v38 = v18;
        *(void *)&v38[13] = -1;
        sub_1CC153974((uint64_t)__src, (int *)&__p);
        sub_1CD4D04B8(v15, (uint64_t)__src);
        sub_1CD4CFA4C((uint64_t *)__src);
        if (v22 < 0) {
          operator delete(__p);
        }
      }
      sub_1CC1569E8(__src, v15);
    }
  }
  return 0;
}

BOOL sub_1CCD9E6FC(unsigned __int8 *a1)
{
  int v1 = *(_DWORD *)(*(void *)a1 + 8);
  if ((v1 & 0xFE) == 0x12) {
    int v1 = *(_DWORD *)(**(void **)(*(void *)a1 + 16) + 8);
  }
  if (v1 != 269) {
    return 0;
  }
  int v2 = a1[16];
  if (v2 == 56) {
    return 1;
  }
  if (v2 != 85) {
    return 0;
  }
  uint64_t v3 = *((void *)a1 - 4);
  if (!v3) {
    return 0;
  }
  unsigned int v4 = *(unsigned __int8 *)(v3 + 16);
  if (v4 > 0x14) {
    return 0;
  }
  if (v4 != 16)
  {
    if (v4 == 17)
    {
      if ((sub_1CB844168(v3, 0.0) & 1) == 0) {
        return 0;
      }
    }
    else if (v4 - 18 >= 3 && v4 != 13)
    {
      return 0;
    }
    return 1;
  }
  uint64_t v5 = *(unsigned int *)(v3 + 32);
  if (v5 >= 0x41)
  {
    int v8 = 0;
    int64_t v9 = (unint64_t)(v5 + 63) >> 6;
    do
    {
      if (v9-- < 1) {
        break;
      }
      unint64_t v11 = *(void *)(*(void *)(v3 + 24) + 8 * v9);
      v8 += __clz(v11);
    }
    while (!v11);
    int v12 = v5 | 0xFFFFFFC0;
    if ((v5 & 0x3F) == 0) {
      int v12 = 0;
    }
    return v8 + v12 == v5;
  }
  return !*(void *)(v3 + 24);
}

BOOL sub_1CCD9E7F4(unsigned __int8 *a1)
{
  int v1 = *(_DWORD *)(*(void *)a1 + 8);
  if ((v1 & 0xFE) == 0x12) {
    int v1 = *(_DWORD *)(**(void **)(*(void *)a1 + 16) + 8);
  }
  BOOL result = 0;
  if (v1 == 269)
  {
    int v2 = a1[16];
    if (v2 == 57) {
      return 1;
    }
    if (v2 == 85)
    {
      uint64_t v3 = (unsigned __int8 *)*((void *)a1 - 8);
      if (v3)
      {
        if (v3[16] <= 0x14u && (llvm::Constant::isOneValue((llvm::Constant *)v3) & 1) != 0) {
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1CCD9E86C()
{
  v4.n128_u64[0] = (unint64_t)"Max block size to duplicate for jump threading";
  v4.n128_u64[1] = 46;
  uint64_t v3 = &v2;
  int v1 = 1;
  int v2 = 6;
  sub_1CD50BCD4((uint64_t)&unk_1EBD0B3F8, "jump-threading-threshold", &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBD0B3F8, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"The number of predecessors to search for a stronger condition to use to thread over"
                                     " a weaker condition";
  v4.n128_u64[1] = 102;
  int v1 = 1;
  int v2 = 3;
  uint64_t v3 = &v2;
  sub_1CD76D488((long long *)&v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCF2F50, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Print the LazyValueInfo cache after JumpThreading";
  v4.n128_u64[1] = 49;
  LOBYTE(v1) = 0;
  uint64_t v3 = &v1;
  int v2 = 1;
  sub_1CD4130FC((llvm::cl::Option *)&unk_1EBCF3010, "print-lvi-after-jump-threading", &v4, (unsigned char **)&v3, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF3010, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Freeze the condition when unfolding select";
  v4.n128_u64[1] = 42;
  LOBYTE(v1) = 0;
  uint64_t v3 = &v1;
  int v2 = 1;
  sub_1CD76D5B0(&v4, (char **)&v3, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBD0B4B8, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Allow JumpThreading to thread across loop headers, for testing";
  v4.n128_u64[1] = 62;
  LOBYTE(v1) = 0;
  uint64_t v3 = &v1;
  int v2 = 1;
  sub_1CD76D728(&v4, (char **)&v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCF30D0, &dword_1CB82C000);
}

void llvm::LICMPass::run(uint64_t *a1, llvm *a2, uint64_t a3, uint64_t a4)
{
  if (*(void *)(a4 + 72))
  {
    llvm::OptimizationRemarkEmitter::OptimizationRemarkEmitter(v10, *(const llvm::Function **)(**((void **)a2 + 4) + 56));
    char v7 = *((unsigned char *)a1 + 8);
    uint64_t v8 = *a1;
    char v9 = v7;
    sub_1CCD9EBB4((int)&v8, a2, *(void *)a4, *(void *)(a4 + 24), *(void *)(a4 + 16), *(void *)(a4 + 56), *(void *)(a4 + 40), *(void *)(a4 + 48), *(void *)(a4 + 32), *(llvm::MemorySSA **)(a4 + 72), (uint64_t)v10, 0);
  }
  llvm::report_fatal_error((llvm *)"LICM requires MemorySSA (loop-mssa)", (const llvm::Twine *)1);
}

void sub_1CCD9EBB4(int a1, llvm *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, llvm::MemorySSA *a10, uint64_t a11, char a12)
{
  llvm::MemorySSA::ensureOptimizedUses(a10);
  llvm::hasDisableLICMTransformsHint(a2, v13);
}

void sub_1CCD9F974(llvm *a1, llvm::PassRegistry *a2)
{
  llvm::initializeLoopPassPass(a1, a2);
  llvm::initializeTargetLibraryInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeTargetTransformInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeMemorySSAWrapperPassPass(a1, v3);
  llvm::initializeLazyBFIPassPass(a1, v4);
  operator new();
}

uint64_t sub_1CCD9FA34(uint64_t a1, int a2, int a3, char a4)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF3190;
  *(_DWORD *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = a2;
  *(void *)a1 = &unk_1F263E708;
  *(_DWORD *)(a1 + 32) = a3;
  *(unsigned char *)(a1 + 36) = a4;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF3198, memory_order_acquire) != -1)
  {
    v8[0] = sub_1CCD9F974;
    v8[1] = &PassRegistry;
    char v7 = v8;
    std::__call_once(&qword_1EBCF3198, &v7, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t llvm::SinkAndHoistLICMFlags::SinkAndHoistLICMFlags(llvm::SinkAndHoistLICMFlags *this, char a2, llvm::Loop *a3, llvm::MemorySSA *a4)
{
  return llvm::SinkAndHoistLICMFlags::SinkAndHoistLICMFlags((uint64_t)this, dword_1EBD0B5F8, dword_1EBD0B6B8, a2, a3, a4);
}

{
  return llvm::SinkAndHoistLICMFlags::SinkAndHoistLICMFlags((uint64_t)this, dword_1EBD0B5F8, dword_1EBD0B6B8, a2, a3, a4);
}

uint64_t llvm::SinkAndHoistLICMFlags::SinkAndHoistLICMFlags(uint64_t this, int a2, unsigned int a3, char a4, llvm::Loop *a5, llvm::MemorySSA *a6)
{
  *(unsigned char *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = a2;
  *(_DWORD *)(this + 12) = a3;
  *(unsigned char *)(this + 16) = a4;
  if (a6)
  {
    uint64_t v6 = (void *)*((void *)a5 + 4);
    char v7 = (void *)*((void *)a5 + 5);
    if (v7 != v6)
    {
      int v8 = 0;
      uint64_t v9 = *((void *)a6 + 6);
      uint64_t v10 = *((unsigned int *)a6 + 16);
      unsigned int v11 = v10 - 1;
      do
      {
        if (v10)
        {
          LODWORD(v12) = ((*v6 >> 4) ^ (*v6 >> 9)) & v11;
          uint64_t v13 = (uint64_t *)(v9 + 16 * v12);
          uint64_t v14 = *v13;
          if (*v6 == *v13)
          {
LABEL_10:
            if (v13 != (uint64_t *)(v9 + 16 * v10))
            {
              uint64_t v17 = v13[1];
              if (v17)
              {
                uint64_t v18 = v13[1];
                while (1)
                {
                  uint64_t v18 = *(void *)(v18 + 8);
                  if (v18 == v17) {
                    break;
                  }
                  if (++v8 > a3)
                  {
                    *(unsigned char *)this = 1;
                    return this;
                  }
                }
              }
            }
          }
          else
          {
            int v15 = 1;
            while (v14 != -4096)
            {
              int v16 = v12 + v15++;
              uint64_t v12 = v16 & v11;
              uint64_t v14 = *(void *)(v9 + 16 * v12);
              if (*v6 == v14)
              {
                uint64_t v13 = (uint64_t *)(v9 + 16 * v12);
                goto LABEL_10;
              }
            }
          }
        }
        ++v6;
      }
      while (v6 != v7);
    }
  }
  return this;
}

uint64_t llvm::sinkRegion(uint64_t *a1, llvm::Instruction *a2, uint64_t *a3, llvm::AAResults *a4, uint64_t a5, uint64_t *a6, void *a7, uint64_t a8, int32x2_t **a9, uint64_t a10, uint64_t a11, uint64_t ***a12, uint64_t a13)
{
  v188[54] = *(llvm::BasicBlock **)MEMORY[0x1E4F143B8];
  llvm::collectChildrenInLoop(a1, a8, (uint64_t)&v179);
  uint64_t v17 = (uint64_t *)v179;
  if (v180)
  {
    uint64_t v18 = a13;
    uint64_t v171 = (char *)v179;
    uint64_t v19 = (char *)v179 + 8 * v180;
    if (a13) {
      uint64_t v20 = a13;
    }
    else {
      uint64_t v20 = a8;
    }
    unsigned int v172 = a6;
    *(void *)uint64_t v173 = a3;
    while (1)
    {
      uint64_t v174 = v19 - 8;
      uint64_t v21 = **((void **)v19 - 1);
      int v22 = *((_DWORD *)a3 + 4);
      if (v22)
      {
        uint64_t v23 = *a3;
        unsigned int v24 = v22 - 1;
        uint64_t v25 = ((v21 >> 4) ^ (v21 >> 9)) & (v22 - 1);
        uint64_t v26 = *(void *)(*a3 + 16 * v25);
        if (v21 == v26)
        {
LABEL_11:
          uint64_t v29 = *(void *)(v23 + 16 * v25 + 8);
          goto LABEL_13;
        }
        int v27 = 1;
        while (v26 != -4096)
        {
          int v28 = v25 + v27++;
          uint64_t v25 = v28 & v24;
          uint64_t v26 = *(void *)(v23 + 16 * v25);
          if (v21 == v26) {
            goto LABEL_11;
          }
        }
      }
      uint64_t v29 = 0;
LABEL_13:
      if (v29 == a8)
      {
        uint64_t v30 = (void *)(v21 + 40);
        if (v21 + 40 != *(void *)(v21 + 48))
        {
          uint64_t v176 = v21;
          while (1)
          {
            uint64_t v30 = (void *)*v30;
            if (v30) {
              uint64_t v31 = (uint64_t)(v30 - 3);
            }
            else {
              uint64_t v31 = 0;
            }
            if (!*(void *)(v31 + 8) && llvm::wouldInstructionBeTriviallyDead(v31, v172))
            {
              if (byte_1EBD0C1D8 && *(unsigned __int8 *)(v31 + 16) - 29 >= 0xB)
              {
                uint64_t v182 = *(void **)(*(void *)(*(void *)(v31 + 40) + 56) + 40);
                uint64_t v183 = 1;
                for (uint64_t i = 16; i != 208; i += 24)
                  *(_OWORD *)((char *)&v182 + i) = xmmword_1CFAC3080;
                uint64_t v185 = v187;
                uint64_t v186 = 0x800000000;
                v187[24] = v31;
                v187[25] = 0;
                v187[26] = 0;
                sub_1CD11CA2C((uint64_t)&v182, v31, v48, v49, v50, v51, v52);
                uint64_t v162 = sub_1CD11CB94((uint64_t ***)&v182);
                if (v162)
                {
                  uint64_t v163 = (llvm::Value *)v162;
                  uint64_t v164 = *(void *)(v31 + 40);
                  *(void *)(v162 + 40) = v164;
                  *(_WORD *)(v164 + 18) &= ~0x8000u;
                  if ((*(unsigned char *)(v162 + 23) & 0x10) != 0)
                  {
                    uint64_t v167 = *(void *)(v164 + 56);
                    if (v167)
                    {
                      uint64_t v168 = *(llvm::ValueSymbolTable **)(v167 + 104);
                      if (v168) {
                        llvm::ValueSymbolTable::reinsertValue(v168, v163);
                      }
                    }
                  }
                  uint64_t v165 = *(void *)(v31 + 24);
                  *((void *)v163 + 3) = v165;
                  *((void *)v163 + 4) = v31 + 24;
                  int v166 = (void *)((char *)v163 + 24);
                  *(void *)(v165 + 8) = v166;
                  *(void *)(v31 + 24) = v166;
                }
                if (v185 != v187) {
                  free(v185);
                }
                if ((v183 & 1) == 0) {
                  MEMORY[0x1D25D9CD0](v184[0], 8);
                }
              }
              uint64_t v182 = v184;
              uint64_t v183 = 0x100000000;
              llvm::findDbgUsers((uint64_t)&v182, (uint64_t ***)v31);
              llvm::salvageDebugInfoForDbgValues((llvm::CastInst *)v31, (uint64_t *)v182, v183);
              if (v182 != v184) {
                free(v182);
              }
              __int32 v53 = (*a9)[5].i32[0];
              if (v53)
              {
                int32x2_t v54 = (*a9)[3];
                uint64_t v55 = (const llvm::Instruction *)v31;
                __int32 v56 = v53 - 1;
                uint64_t v57 = (v53 - 1) & ((v31 >> 4) ^ (v31 >> 9));
                uint64_t v58 = *(void *)(*(void *)&v54 + 16 * v57);
                if (v58 != v31)
                {
                  int v59 = 1;
                  while (v58 != -4096)
                  {
                    int v60 = v57 + v59++;
                    uint64_t v57 = v60 & v56;
                    uint64_t v58 = *(void *)(*(void *)&v54 + 16 * v57);
                    if (v58 == v31) {
                      goto LABEL_245;
                    }
                  }
LABEL_248:
                  llvm::InstructionPrecedenceTracking::removeInstruction((int32x2_t *)(a10 + 40), v55);
                  llvm::InstructionPrecedenceTracking::removeInstruction((int32x2_t *)(a10 + 72), v55);
                  llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                }
LABEL_245:
                uint64_t v160 = *(llvm::MemoryAccess **)(*(void *)&v54 + 16 * v57 + 8);
                if (!v160) {
                  goto LABEL_248;
                }
                llvm::MemorySSAUpdater::removeMemoryAccess(a9, v160, 0);
              }
              uint64_t v55 = (const llvm::Instruction *)v31;
              goto LABEL_248;
            }
            if ((llvm::Instruction::mayHaveSideEffects((llvm::Instruction *)v31) & 1) == 0) {
              break;
            }
LABEL_205:
            if (v30 == *(void **)(v21 + 48)) {
              goto LABEL_14;
            }
          }
          uint64_t v178 = v30;
          int v32 = *(unsigned __int8 *)(v31 + 16);
          if (v32 == 62) {
            uint64_t v33 = v31;
          }
          else {
            uint64_t v33 = 0;
          }
          if (v32 == 62)
          {
            int v34 = *(_DWORD *)(v31 + 20);
            if ((v34 & 0x40000000) != 0)
            {
              long long v36 = *(void ***)(v31 - 8);
              unint64_t v35 = v34 & 0x7FFFFFF;
            }
            else
            {
              unint64_t v35 = v34 & 0x7FFFFFF;
              long long v36 = (void **)(v31 - 32 * v35);
            }
            uint64_t v182 = v184;
            uint64_t v183 = 0x400000000;
            if (v35 >= 5) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            if (v35)
            {
              uint64_t v37 = 32 * v35;
              BOOL v38 = v184;
              do
              {
                uint64_t v39 = *v36;
                v36 += 4;
                *v38++ = v39;
                v37 -= 32;
              }
              while (v37);
              uint64_t v40 = v182;
            }
            else
            {
              uint64_t v40 = v184;
            }
            LODWORD(v183) = v35;
            uint64_t v61 = (*(uint64_t (**)(void, uint64_t, void *))(*(void *)*a7 + 72))(*a7, v33, v40);
            int v63 = v62;
            if (v182 != v184) {
              free(v182);
            }
            BOOL v64 = v61 < 0;
            if (v63) {
              BOOL v64 = v63 < 0;
            }
            if (v64)
            {
              BOOL v65 = 0;
              uint64_t v18 = a13;
              goto LABEL_72;
            }
            BOOL v66 = v61 > 0;
            if (v63) {
              BOOL v66 = v63 > 0;
            }
            uint64_t v68 = (unsigned int *)(v20 + 72);
            unint64_t v67 = (unsigned int *)(v20 + 76);
            uint64_t v69 = v31;
            if (v66)
            {
              BOOL v65 = 0;
              uint64_t v18 = a13;
            }
            else
            {
              uint64_t v141 = *(void *)(v33 + 8);
              uint64_t v18 = a13;
              if (v141)
              {
                uint64_t v143 = *(void *)(v20 + 56);
                uint64_t v142 = *(void *)(v20 + 64);
                if (v142 == v143) {
                  uint64_t v144 = (unsigned int *)(v20 + 76);
                }
                else {
                  uint64_t v144 = (unsigned int *)(v20 + 72);
                }
                uint64_t v145 = *(void *)(v20 + 64);
                while (1)
                {
                  uint64_t v146 = *(void *)(v141 + 24);
                  uint64_t v147 = *(void *)(v146 + 40);
                  if (v145 == v143)
                  {
                    uint64_t v148 = *(unsigned int *)(v20 + 76);
                    uint64_t v149 = (void *)(v143 + 8 * v148);
                    if (v148)
                    {
                      uint64_t v150 = 0;
                      uint64_t v151 = 8 * v148;
                      while (*(void *)(v143 + v150) != v147)
                      {
                        v150 += 8;
                        if (v151 == v150) {
                          goto LABEL_230;
                        }
                      }
                      uint64_t v149 = (void *)(v143 + v150);
                    }
LABEL_230:
                    uint64_t v145 = *(void *)(v20 + 56);
                  }
                  else
                  {
                    int v152 = *(_DWORD *)(v20 + 72) - 1;
                    unsigned int v153 = v152 & ((v147 >> 4) ^ (v147 >> 9));
                    uint64_t v149 = (void *)(v142 + 8 * v153);
                    uint64_t v154 = *v149;
                    if (*v149 == -1)
                    {
                      __int16 v155 = 0;
LABEL_232:
                      if (v155) {
                        uint64_t v149 = v155;
                      }
                      if (*v149 != v147) {
                        uint64_t v149 = (void *)(v142 + 8 * *v144);
                      }
                    }
                    else
                    {
                      __int16 v155 = 0;
                      int v156 = 1;
                      while (v154 != v147)
                      {
                        if (v155) {
                          BOOL v157 = 0;
                        }
                        else {
                          BOOL v157 = v154 == -2;
                        }
                        if (v157) {
                          __int16 v155 = v149;
                        }
                        unsigned int v158 = v153 + v156++;
                        unsigned int v153 = v158 & v152;
                        uint64_t v149 = (void *)(v142 + 8 * (v158 & v152));
                        uint64_t v154 = *v149;
                        if (*v149 == -1) {
                          goto LABEL_232;
                        }
                      }
                    }
                    uint64_t v145 = *(void *)(v20 + 64);
                  }
                  unint64_t v159 = (unsigned int *)(v145 == v143 ? v20 + 76 : v20 + 72);
                  if (v149 != (void *)(v145 + 8 * *v159)
                    && (*(void *)(v33 + 40) != v147 || (*(unsigned char *)(v146 + 16) & 0xFE) != 0x3C))
                  {
                    break;
                  }
                  uint64_t v141 = *(void *)(v141 + 8);
                  if (!v141) {
                    goto LABEL_244;
                  }
                }
                BOOL v65 = 0;
              }
              else
              {
LABEL_244:
                BOOL v65 = 1;
              }
            }
          }
          else
          {
            int v41 = *(_DWORD *)(v31 + 20);
            if ((v41 & 0x40000000) != 0)
            {
              long long v43 = *(void ***)(v31 - 8);
              unint64_t v42 = v41 & 0x7FFFFFF;
            }
            else
            {
              unint64_t v42 = v41 & 0x7FFFFFF;
              long long v43 = (void **)(v31 - 32 * v42);
            }
            uint64_t v182 = v184;
            uint64_t v183 = 0x400000000;
            if (v42 >= 5) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            if (v42)
            {
              uint64_t v44 = 32 * v42;
              uint64_t v45 = v184;
              do
              {
                unsigned int v46 = *v43;
                v43 += 4;
                *v45++ = v46;
                v44 -= 32;
              }
              while (v44);
              uint64_t v47 = v182;
            }
            else
            {
              uint64_t v47 = v184;
            }
            LODWORD(v183) = v42;
            uint64_t v70 = (*(uint64_t (**)(void, uint64_t, void *))(*(void *)*a7 + 72))(*a7, v31, v47);
            int v72 = v71;
            if (v182 != v184) {
              free(v182);
            }
            BOOL v73 = v70 < 0;
            if (v72) {
              BOOL v73 = v72 < 0;
            }
            if (v73)
            {
              BOOL v65 = 0;
            }
            else if (v72)
            {
              BOOL v65 = v72 < 1;
            }
            else
            {
              BOOL v65 = v70 < 1;
            }
LABEL_72:
            uint64_t v68 = (unsigned int *)(v20 + 72);
            unint64_t v67 = (unsigned int *)(v20 + 76);
            uint64_t v69 = v31;
          }
          for (uint64_t j = *(void *)(v69 + 8); j; uint64_t j = *(void *)(j + 8))
          {
            uint64_t v75 = *(void *)(j + 24);
            if (!v75 || *(unsigned char *)(v75 + 16) != 83) {
              goto LABEL_124;
            }
            uint64_t v76 = *(void *)(*(void *)(v75 + 40) + 40);
            if (v76) {
              uint64_t v77 = v76 - 24;
            }
            else {
              uint64_t v77 = 0;
            }
            if (*(unsigned __int8 *)(v77 + 16) - 29 >= 0xB) {
              uint64_t v77 = 0;
            }
            if (*(unsigned char *)(v77 + 16) == 38) {
              goto LABEL_204;
            }
            if (*(unsigned char *)(v69 + 16) == 84 && *(_DWORD *)(a10 + 16) != 0)
            {
              uint64_t v182 = *(void **)(v75 + 40);
              v188[0] = 0;
              int v117 = sub_1CD3C8538((uint64_t *)(a10 + 8), &v182, v188);
              uint64_t v118 = v188[0];
              if (!v117) {
                uint64_t v118 = (llvm::BasicBlock *)(*(void *)(a10 + 8) + 16 * *(unsigned int *)(a10 + 24));
              }
              unint64_t v119 = *((void *)v118 + 1);
              if (v119 < 8) {
                goto LABEL_204;
              }
              unint64_t v120 = v119 & 0xFFFFFFFFFFFFFFF8;
              if ((v119 & 4) != 0 && v120)
              {
                int v121 = *(_DWORD *)(v120 + 8);
                uint64_t v68 = (unsigned int *)(v20 + 72);
                unint64_t v67 = (unsigned int *)(v20 + 76);
                uint64_t v69 = v31;
                if (!v121) {
                  goto LABEL_204;
                }
LABEL_168:
                if (v121 != 1) {
                  goto LABEL_204;
                }
                goto LABEL_87;
              }
              uint64_t v68 = (unsigned int *)(v20 + 72);
              unint64_t v67 = (unsigned int *)(v20 + 76);
              uint64_t v69 = v31;
              if ((v119 & 4) != 0)
              {
                int v121 = *(_DWORD *)(v120 + 8);
                goto LABEL_168;
              }
            }
LABEL_87:
            if (v18)
            {
              while (*(unsigned char *)(v75 + 16) == 83)
              {
                uint64_t v79 = *(void *)(v75 + 8);
                if (!v79) {
                  break;
                }
                uint64_t v80 = *(void *)(v79 + 8);
                if (v80)
                {
                  uint64_t v81 = *(void *)(v75 + 8);
                  while (*(void *)(v80 + 24) == *(void *)(v81 + 24))
                  {
                    uint64_t v81 = *(void *)(v81 + 8);
                    uint64_t v80 = *(void *)(v80 + 8);
                    if (!v80) {
                      goto LABEL_94;
                    }
                  }
                  break;
                }
LABEL_94:
                if ((*(_DWORD *)(v75 + 20) & 0x7FFFFFF) != 1) {
                  break;
                }
                uint64_t v82 = *(void *)(v75 + 40);
                uint64_t v84 = *(void *)(v20 + 56);
                uint64_t v83 = *(void *)(v20 + 64);
                if (v83 == v84)
                {
                  uint64_t v85 = *v67;
                  int v86 = (void *)(v83 + 8 * v85);
                  if (v85)
                  {
                    uint64_t v87 = 0;
                    uint64_t v88 = 8 * v85;
                    while (*(void *)(v83 + v87) != v82)
                    {
                      v87 += 8;
                      if (v88 == v87) {
                        goto LABEL_113;
                      }
                    }
                    int v86 = (void *)(v83 + v87);
                  }
LABEL_113:
                  uint64_t v84 = *(void *)(v20 + 64);
                }
                else
                {
                  uint64_t v89 = *v68;
                  int v90 = v89 - 1;
                  unsigned int v91 = (v89 - 1) & ((v82 >> 4) ^ (v82 >> 9));
                  int v86 = (void *)(v83 + 8 * v91);
                  uint64_t v92 = *v86;
                  if (*v86 == -1)
                  {
                    unint64_t v93 = 0;
LABEL_120:
                    if (v93) {
                      int v86 = v93;
                    }
                    if (*v86 != v82) {
                      int v86 = (void *)(v83 + 8 * v89);
                    }
                  }
                  else
                  {
                    unint64_t v93 = 0;
                    int v94 = 1;
                    while (v92 != v82)
                    {
                      if (v93) {
                        BOOL v95 = 0;
                      }
                      else {
                        BOOL v95 = v92 == -2;
                      }
                      if (v95) {
                        unint64_t v93 = v86;
                      }
                      unsigned int v96 = v91 + v94++;
                      unsigned int v91 = v96 & v90;
                      int v86 = (void *)(v83 + 8 * (v96 & v90));
                      uint64_t v92 = *v86;
                      if (*v86 == -1) {
                        goto LABEL_120;
                      }
                    }
                  }
                }
                unint64_t v97 = v83 == v84 ? v67 : v68;
                if (v86 == (void *)(v83 + 8 * *v97)) {
                  break;
                }
                uint64_t v75 = *(void *)(v79 + 24);
              }
            }
LABEL_124:
            uint64_t v98 = *(void *)(v75 + 40);
            uint64_t v100 = *(void *)(v20 + 56);
            uint64_t v99 = *(void *)(v20 + 64);
            if (v99 == v100)
            {
              uint64_t v101 = *v67;
              int v102 = (void *)(v99 + 8 * v101);
              if (v101)
              {
                uint64_t v103 = 0;
                uint64_t v104 = 8 * v101;
                while (*(void *)(v99 + v103) != v98)
                {
                  v103 += 8;
                  if (v104 == v103) {
                    goto LABEL_142;
                  }
                }
                int v102 = (void *)(v99 + v103);
              }
LABEL_142:
              uint64_t v100 = *(void *)(v20 + 64);
            }
            else
            {
              uint64_t v105 = *v68;
              int v106 = v105 - 1;
              unsigned int v107 = (v105 - 1) & ((v98 >> 4) ^ (v98 >> 9));
              int v102 = (void *)(v99 + 8 * v107);
              uint64_t v108 = *v102;
              if (*v102 == -1)
              {
                uint64_t v109 = 0;
LABEL_155:
                if (v109) {
                  int v102 = v109;
                }
                if (*v102 != v98) {
                  int v102 = (void *)(v99 + 8 * v105);
                }
              }
              else
              {
                uint64_t v109 = 0;
                int v110 = 1;
                while (v108 != v98)
                {
                  if (v109) {
                    BOOL v111 = 0;
                  }
                  else {
                    BOOL v111 = v108 == -2;
                  }
                  if (v111) {
                    uint64_t v109 = v102;
                  }
                  unsigned int v112 = v107 + v110++;
                  unsigned int v107 = v112 & v106;
                  int v102 = (void *)(v99 + 8 * (v112 & v106));
                  uint64_t v108 = *v102;
                  if (*v102 == -1) {
                    goto LABEL_155;
                  }
                }
              }
            }
            if (v99 == v100) {
              uint64_t v113 = v67;
            }
            else {
              uint64_t v113 = v68;
            }
            uint64_t v114 = (void *)(v99 + 8 * *v113);
            BOOL v115 = v102 == v114;
            BOOL v116 = v102 != v114 && v65;
            if (!v116 && !v115) {
              goto LABEL_204;
            }
          }
          uint64_t v122 = v69;
          if (llvm::canSinkOrHoistInst((llvm *)v69, a2, a4, (llvm::DominatorTree *)a8, (llvm::Loop *)a9, (llvm::MemorySSAUpdater *)1, a11, a12, v170))
          {
            uint64_t v123 = *(void *)(v122 + 8);
            if (v123)
            {
              do
              {
                uint64_t v124 = *(void *)(v123 + 8);
                uint64_t v125 = *(void *)(*(void *)(v123 + 24) + 40);
                uint64_t v127 = *(void *)(a8 + 56);
                uint64_t v126 = *(void *)(a8 + 64);
                if (v126 == v127)
                {
                  uint64_t v128 = *(unsigned int *)(a8 + 76);
                  unsigned int v129 = (void *)(v126 + 8 * v128);
                  if (v128)
                  {
                    uint64_t v130 = 0;
                    uint64_t v131 = 8 * v128;
                    while (*(void *)(v126 + v130) != v125)
                    {
                      v130 += 8;
                      if (v131 == v130) {
                        goto LABEL_190;
                      }
                    }
                    unsigned int v129 = (void *)(v126 + v130);
                  }
LABEL_190:
                  uint64_t v127 = *(void *)(a8 + 64);
                }
                else
                {
                  uint64_t v132 = *(unsigned int *)(a8 + 72);
                  int v133 = v132 - 1;
                  unsigned int v134 = (v132 - 1) & ((v125 >> 4) ^ (v125 >> 9));
                  unsigned int v129 = (void *)(v126 + 8 * v134);
                  uint64_t v135 = *v129;
                  if (*v129 == -1)
                  {
                    uint64_t v136 = 0;
LABEL_199:
                    if (v136) {
                      unsigned int v129 = v136;
                    }
                    if (*v129 != v125) {
                      unsigned int v129 = (void *)(v126 + 8 * v132);
                    }
                  }
                  else
                  {
                    uint64_t v136 = 0;
                    int v137 = 1;
                    while (v135 != v125)
                    {
                      if (v136) {
                        BOOL v138 = 0;
                      }
                      else {
                        BOOL v138 = v135 == -2;
                      }
                      if (v138) {
                        uint64_t v136 = v129;
                      }
                      unsigned int v139 = v134 + v137++;
                      unsigned int v134 = v139 & v133;
                      unsigned int v129 = (void *)(v126 + 8 * (v139 & v133));
                      uint64_t v135 = *v129;
                      if (*v129 == -1) {
                        goto LABEL_199;
                      }
                    }
                  }
                }
                if (v126 == v127) {
                  uint64_t v140 = (unsigned int *)(a8 + 76);
                }
                else {
                  uint64_t v140 = (unsigned int *)(a8 + 72);
                }
                if (v129 == (void *)(v126 + 8 * *v140)) {
                  llvm::DominatorTreeBase<llvm::BasicBlock,false>::isReachableFromEntry();
                }
                uint64_t v123 = *(void *)(v123 + 8);
              }
              while (v124);
              uint64_t v18 = a13;
            }
            a3 = *(uint64_t **)v173;
          }
LABEL_204:
          uint64_t v21 = v176;
          uint64_t v30 = v178;
          goto LABEL_205;
        }
      }
LABEL_14:
      uint64_t v19 = v174;
      if (v174 == v171)
      {
        uint64_t v17 = (uint64_t *)v179;
        break;
      }
    }
  }
  if (v17 != &v181) {
    free(v17);
  }
  return 0;
}

uint64_t llvm::canSinkOrHoistInst(llvm *this, llvm::Instruction *a2, llvm::AAResults *a3, llvm::DominatorTree *a4, llvm::Loop *a5, llvm::MemorySSAUpdater *a6, uint64_t a7, uint64_t ***a8, llvm::OptimizationRemarkEmitter *a9)
{
  v203[34] = *MEMORY[0x1E4F143B8];
  unsigned int v14 = *((unsigned __int8 *)this + 16);
  BOOL v15 = v14 - 60 > 0x18 || ((1 << (v14 - 60)) & 0x100000B) == 0;
  if (v15)
  {
    if ((vmaxv_u16((uint16x4_t)vceq_s16(vdup_n_s16(v14), (int16x4_t)0x5F003E00550028)) & 1) == 0)
    {
      BOOL v55 = v14 - 66 >= 0xD && v14 - 41 >= 0x12;
      BOOL v56 = v55 && v14 - 81 >= 2;
      if (v56 && (v14 - 89) > 4u) {
        return 0;
      }
    }
    uint64_t v16 = *(void *)a5;
  }
  else
  {
    uint64_t v16 = *(void *)a5;
    if (v14 == 60) {
      uint64_t v17 = this;
    }
    else {
      uint64_t v17 = 0;
    }
    if (v14 == 60)
    {
      if ((*((_WORD *)this + 9) & 0x301) != 0) {
        return 0;
      }
      int v19 = (int)a6;
      int v197 = (llvm *)*((void *)this - 4);
      uint64_t v198 = -1;
      long long v199 = 0u;
      *(_OWORD *)uint64_t v200 = 0u;
      if ((llvm::AAResults::pointsToConstantMemory((uint64_t)a2, (uint64_t)&v197, 0) & 1) == 0)
      {
        if ((*((unsigned char *)this + 23) & 0x20) == 0)
        {
LABEL_26:
          int v34 = *((unsigned __int8 *)this + 16);
          if (v34 == 60 || v34 == 61)
          {
            BOOL v35 = (*((_WORD *)this + 9) & 0x380) != 0;
          }
          else
          {
            if ((v34 - 63) >= 3)
            {
LABEL_32:
              uint64_t v37 = *((void *)this - 4);
              uint64_t v38 = sub_1CB83544C(*(void *)(*(void *)(*((void *)this + 5) + 56) + 40) + 272, *(void *)this);
              if (v39 == 1) {
                goto LABEL_105;
              }
              unint64_t v40 = v38;
              uint64_t v41 = **((void **)this - 4);
              unsigned int v42 = *(_DWORD *)(v41 + 8);
              if ((v42 & 0xFE) == 0x12) {
                unsigned int v42 = *(_DWORD *)(**(void **)(v41 + 16) + 8);
              }
              unint64_t v43 = llvm::PointerType::get((llvm::PointerType *)(***(void ***)this + 1912), (llvm::Type *)(v42 >> 8));
              if (*(void *)v37 != v43)
              {
                unsigned int v44 = 1;
                while (v44 <= dword_1EBCF3460 && *(unsigned char *)(v37 + 16) == 77)
                {
                  uint64_t v37 = *(void *)(v37 - 32);
                  ++v44;
                  if (*(void *)v37 == v43) {
                    goto LABEL_40;
                  }
                }
LABEL_105:
                int v74 = *(_DWORD *)(v16 + 40);
                if (v74)
                {
                  uint64_t v75 = *(void *)(v16 + 24);
                  unsigned int v76 = v74 - 1;
                  uint64_t v77 = (v74 - 1) & ((v17 >> 4) ^ (v17 >> 9));
                  uint64_t v78 = *(llvm **)(v75 + 16 * v77);
                  if (v17 == v78)
                  {
LABEL_110:
                    uint64_t v81 = *(void *)(v75 + 16 * v77 + 8);
LABEL_112:
                    int v82 = sub_1CCDA6824((llvm::MemorySSA *)v16, v81, (uint64_t)a4, (uint64_t)this, a7);
                    uint64_t v73 = v82 ^ 1u;
                    if (a8)
                    {
                      if (v82)
                      {
                        if (llvm::Loop::isLoopInvariant((uint64_t)a4, *((void *)this - 4)))
                        {
                          uint64_t v83 = *(void *)***a8;
                          if (*(void *)(v83 + 128)
                            || (*(unsigned int (**)(void))(**(void **)(v83 + 72) + 48))(*(void *)(v83 + 72)))
                          {
                            llvm::OptimizationRemarkMissed::OptimizationRemarkMissed((uint64_t)&v197, (uint64_t)"licm", (uint64_t)"LoadWithLoopInvariantAddressInvalidated", 39, (uint64_t)v17);
                            uint64_t v187 = "failed to move load with loop-invariant address because the loop may invalidate its value";
                            uint64_t v188 = 89;
                            sub_1CC59ADEC((uint64_t *)&v201, (uint64_t)&v187);
                            LODWORD(v188) = v198;
                            BYTE4(v188) = BYTE4(v198);
                            long long v189 = v199;
                            uint64_t v190 = v200[0];
                            uint64_t v187 = (const char *)&unk_1F2616800;
                            long long v191 = *(_OWORD *)&v200[1];
                            long long v192 = *(_OWORD *)&v200[3];
                            uint64_t v193 = v200[5];
                            uint64_t v194 = v196;
                            uint64_t v195 = 0x400000000;
                            unsigned int v84 = v202;
                            if (v202)
                            {
                              sub_1CD494D68((uint64_t)&v194, (uint64_t)&v201);
                              unsigned int v84 = v202;
                            }
                            v196[32] = v203[32];
                            v196[33] = v203[33];
                            uint64_t v187 = (const char *)&unk_1F26165A8;
                            int v197 = (llvm *)&unk_1F2616800;
                            uint64_t v85 = (char *)v201;
                            if (v84)
                            {
                              unint64_t v86 = (unint64_t)v84 << 6;
                              do
                              {
                                uint64_t v87 = (void **)&v85[v86];
                                if (v85[v86 - 17] < 0) {
                                  operator delete(*(v87 - 5));
                                }
                                if (*((char *)v87 - 41) < 0) {
                                  operator delete(*(v87 - 8));
                                }
                                v86 -= 64;
                              }
                              while (v86);
                              uint64_t v85 = (char *)v201;
                            }
                            if (v85 != (char *)v203) {
                              free(v85);
                            }
                            llvm::OptimizationRemarkEmitter::emit(a8, (llvm::DiagnosticInfoOptimizationBase *)&v187);
                            uint64_t v187 = (const char *)&unk_1F2616800;
                            unint64_t v169 = (char *)v194;
                            if (v195)
                            {
                              unint64_t v170 = (unint64_t)v195 << 6;
                              do
                              {
                                uint64_t v171 = (void **)&v169[v170];
                                if (v169[v170 - 17] < 0) {
                                  operator delete(*(v171 - 5));
                                }
                                if (*((char *)v171 - 41) < 0) {
                                  operator delete(*(v171 - 8));
                                }
                                v170 -= 64;
                              }
                              while (v170);
                              unint64_t v169 = (char *)v194;
                            }
                            if (v169 != (char *)v196) {
                              free(v169);
                            }
                          }
                        }
                      }
                    }
                    return v73;
                  }
                  int v79 = 1;
                  while (v78 != (llvm *)-4096)
                  {
                    int v80 = v77 + v79++;
                    uint64_t v77 = v80 & v76;
                    uint64_t v78 = *(llvm **)(v75 + 16 * v77);
                    if (v17 == v78) {
                      goto LABEL_110;
                    }
                  }
                }
                uint64_t v81 = 0;
                goto LABEL_112;
              }
LABEL_40:
              if (*(unsigned __int8 *)(v37 + 16) < 0x15u) {
                goto LABEL_105;
              }
              uint64_t v45 = *(void *)(v37 + 8);
              if (!v45) {
                goto LABEL_105;
              }
              int v46 = 0;
              while (1)
              {
                if (++v46 > dword_1EBCF3460) {
                  goto LABEL_105;
                }
                uint64_t v47 = *(void *)(v45 + 24);
                if (*(unsigned char *)(v47 + 16) == 84)
                {
                  uint64_t v48 = *(void *)(v47 - 32);
                  if (v48)
                  {
                    if (!*(unsigned char *)(v48 + 16)
                      && *(void *)(v48 + 24) == *(void *)(v47 + 72)
                      && (*(unsigned char *)(v48 + 33) & 0x20) != 0
                      && *(_DWORD *)(v48 + 36) == 164
                      && !*(void *)(v47 + 8))
                    {
                      uint64_t v49 = *(void *)(v47 - 32 * (*(_DWORD *)(v47 + 20) & 0x7FFFFFF));
                      unsigned int v50 = *(_DWORD *)(v49 + 32);
                      unsigned int v51 = v50 - 1;
                      if (v50 > 0x40)
                      {
                        int32x2_t v54 = *(uint64_t **)(v49 + 24);
                        if ((((unint64_t)v54[v51 >> 6] >> v51) & 1) == 0)
                        {
                          uint64_t v53 = *v54;
LABEL_58:
                          if (v40 <= 8 * v53) {
                            llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
                          }
                        }
                      }
                      else
                      {
                        unint64_t v52 = *(void *)(v49 + 24);
                        if (((v52 >> v51) & 1) == 0)
                        {
                          uint64_t v53 = (uint64_t)(v52 << -(char)v50) >> -(char)v50;
                          goto LABEL_58;
                        }
                      }
                    }
                  }
                }
                uint64_t v45 = *(void *)(v45 + 8);
                if (!v45) {
                  goto LABEL_105;
                }
              }
            }
            BOOL v35 = 1;
          }
          if (!v35 || v19 != 0) {
            goto LABEL_32;
          }
          return 0;
        }
        uint64_t v20 = ***(void ***)this;
        int v197 = this;
        int v21 = *(_DWORD *)(v20 + 2496);
        if (v21)
        {
          uint64_t v22 = *(void *)(v20 + 2480);
          int v23 = v21 - 1;
          unsigned int v24 = v23 & ((this >> 4) ^ (this >> 9));
          uint64_t v25 = (llvm **)(v22 + 40 * v24);
          uint64_t v26 = *v25;
          if (*v25 == this)
          {
LABEL_22:
            uint64_t v31 = *((unsigned int *)v25 + 4);
            if (v31)
            {
              int v32 = (void *)((char *)v25[1] + 8);
              uint64_t v33 = 16 * v31;
              while (*((_DWORD *)v32 - 2) != 6)
              {
                v32 += 2;
                v33 -= 16;
                if (!v33) {
                  goto LABEL_26;
                }
              }
              if (*v32) {
                return 1;
              }
            }
            goto LABEL_26;
          }
          int v27 = 0;
          int v28 = 1;
          while (v26 != (llvm *)-4096)
          {
            if (v27) {
              BOOL v29 = 0;
            }
            else {
              BOOL v29 = v26 == (llvm *)-8192;
            }
            if (v29) {
              int v27 = v25;
            }
            unsigned int v30 = v24 + v28++;
            unsigned int v24 = v30 & v23;
            uint64_t v25 = (llvm **)(v22 + 40 * v24);
            uint64_t v26 = *v25;
            if (*v25 == this) {
              goto LABEL_22;
            }
          }
          if (v27) {
            uint64_t v167 = v27;
          }
          else {
            uint64_t v167 = v25;
          }
        }
        else
        {
          uint64_t v167 = 0;
        }
        uint64_t v25 = (llvm **)sub_1CC609054(v20 + 2480, (uint64_t)&v197, (uint64_t *)&v197, v167);
        uint64_t v168 = v197;
        v25[3] = 0;
        v25[4] = 0;
        uint64_t *v25 = v168;
        v25[1] = (llvm *)(v25 + 3);
        v25[2] = (llvm *)0x100000000;
        goto LABEL_22;
      }
      return 1;
    }
  }
  if (v14 == 84) {
    uint64_t v58 = this;
  }
  else {
    uint64_t v58 = 0;
  }
  if (v14 == 84)
  {
    if (sub_1CBF63B28((uint64_t)this)) {
      return 0;
    }
    unsigned int v59 = *((unsigned __int8 *)this + 16);
    if (v59 > 0x23)
    {
      if (v59 == 84)
      {
        uint64_t v100 = *((void *)this + 8);
        if ((!v100 || (*(unsigned char *)(v100 + 16) & 0x20) == 0)
          && !llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)this, 37))
        {
          return 0;
        }
      }
      else if ((v59 == 36 || v59 == 38) && (*((_WORD *)this + 9) & 1) == 0)
      {
        return 0;
      }
    }
    else if (v59 == 34)
    {
      return 0;
    }
    uint64_t v72 = *((void *)this + 8);
    if (v72)
    {
      if ((*(unsigned char *)(v72 + 12) & 0x40) != 0) {
        return 0;
      }
    }
    if (llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)this, 6)) {
      return 0;
    }
    uint64_t v88 = *((void *)this - 4);
    if (v88)
    {
      if (!*(unsigned char *)(v88 + 16) && *(void *)(v88 + 24) == *((void *)this + 9))
      {
        int v115 = *(_DWORD *)(v88 + 36);
        uint64_t v73 = 1;
        if (v115 == 7 || v115 == 138) {
          return v73;
        }
      }
    }
    int ModRefBehavior = llvm::AAResults::getModRefBehavior((uint64_t)a2, (uint64_t)this);
    if (ModRefBehavior == 4) {
      return 1;
    }
    if ((ModRefBehavior & 2) != 0) {
      return 0;
    }
    if ((ModRefBehavior & 0x30) != 0)
    {
      int v90 = (void *)*((void *)a4 + 4);
      unsigned int v91 = (void *)*((void *)a4 + 5);
      if (v91 != v90)
      {
        uint64_t v92 = *(void *)(*(void *)a5 + 72);
        uint64_t v93 = *(unsigned int *)(*(void *)a5 + 88);
        unsigned int v94 = v93 - 1;
        uint64_t v73 = 1;
        while (1)
        {
          if (v93)
          {
            LODWORD(v95) = ((*v90 >> 4) ^ (*v90 >> 9)) & v94;
            unsigned int v96 = (uint64_t *)(v92 + 16 * v95);
            uint64_t v97 = *v96;
            if (*v90 == *v96)
            {
LABEL_141:
              if (v96 != (uint64_t *)(v92 + 16 * v93) && v96[1]) {
                return 0;
              }
            }
            else
            {
              int v98 = 1;
              while (v97 != -4096)
              {
                int v99 = v95 + v98++;
                uint64_t v95 = v99 & v94;
                uint64_t v97 = *(void *)(v92 + 16 * v95);
                if (*v90 == v97)
                {
                  unsigned int v96 = (uint64_t *)(v92 + 16 * v95);
                  goto LABEL_141;
                }
              }
            }
          }
          if (++v90 == v91) {
            return v73;
          }
        }
      }
      return 1;
    }
    int v101 = *((_DWORD *)this + 5);
    int v102 = (char *)this - 32 * (v101 & 0x7FFFFFF);
    int v103 = *((unsigned __int8 *)this + 16);
    if (v103 == 84)
    {
      uint64_t v104 = 0;
    }
    else if (v103 == 39)
    {
      uint64_t v104 = (*((_DWORD *)this + 20) + 1);
    }
    else
    {
      uint64_t v104 = 2;
    }
    if (v101 < 0 && (uint64_t v181 = *((void *)v102 - 1), (v181 & 0xFFFFFFFF0) != 0)) {
      uint64_t v105 = (*((_DWORD *)v102 - 3) - *(_DWORD *)&v102[-v181]);
    }
    else {
      uint64_t v105 = 0;
    }
    int v106 = (char *)this + -32 * v105 + -32 * v104 - 32;
    if (v102 == v106) {
      return 1;
    }
    uint64_t v73 = 1;
    while (*(unsigned char *)(**(void **)v102 + 8) != 15)
    {
LABEL_170:
      v102 += 32;
      if (v102 == v106) {
        return v73;
      }
    }
    int v107 = *(_DWORD *)(v16 + 40);
    if (v107)
    {
      uint64_t v108 = *(void *)(v16 + 24);
      unsigned int v109 = v107 - 1;
      uint64_t v110 = (v107 - 1) & ((this >> 4) ^ (this >> 9));
      BOOL v111 = *(llvm **)(v108 + 16 * v110);
      if (v58 == v111)
      {
LABEL_167:
        uint64_t v114 = *(void *)(v108 + 16 * v110 + 8);
        goto LABEL_169;
      }
      int v112 = 1;
      while (v111 != (llvm *)-4096)
      {
        int v113 = v110 + v112++;
        uint64_t v110 = v113 & v109;
        BOOL v111 = *(llvm **)(v108 + 16 * v110);
        if (v58 == v111) {
          goto LABEL_167;
        }
      }
    }
    uint64_t v114 = 0;
LABEL_169:
    if (sub_1CCDA6824((llvm::MemorySSA *)v16, v114, (uint64_t)a4, (uint64_t)this, a7)) {
      return 0;
    }
    goto LABEL_170;
  }
  if (v14 != 63)
  {
    if (v14 == 61) {
      int v63 = this;
    }
    else {
      int v63 = 0;
    }
    if (v14 != 61) {
      return 1;
    }
    if ((*((_WORD *)this + 9) & 0x301) != 0) {
      return 0;
    }
    BOOL v64 = (void *)*((void *)a4 + 4);
    uint64_t v186 = (void *)*((void *)a4 + 5);
    if (sub_1CCDA6B34((uint64_t)this, v64, v186, v16)) {
      return 1;
    }
    if (*(unsigned char *)a7 || *(_DWORD *)(a7 + 4) >= *(_DWORD *)(a7 + 8)) {
      return 0;
    }
    int v65 = *(_DWORD *)(v16 + 40);
    if (v65)
    {
      uint64_t v66 = *(void *)(v16 + 24);
      unsigned int v67 = v65 - 1;
      uint64_t v68 = (v65 - 1) & ((this >> 4) ^ (this >> 9));
      uint64_t v69 = *(llvm **)(v66 + 16 * v68);
      if (v69 == this)
      {
LABEL_97:
        uint64_t v183 = *(void *)(v66 + 16 * v68 + 8);
LABEL_176:
        if (v186 == v64)
        {
LABEL_247:
          SkipSelfWalker = (void *)llvm::MemorySSA::getSkipSelfWalker((llvm::MemorySSA *)v16);
          uint64_t v159 = sub_1CCD4E10C(SkipSelfWalker, (uint64_t)v63);
          ++*(_DWORD *)(a7 + 4);
          if (*(void *)(v16 + 96) != v159)
          {
            uint64_t v160 = *(void *)(v159 + 64);
            uint64_t v162 = *((void *)a4 + 7);
            uint64_t v161 = *((void *)a4 + 8);
            if (v161 == v162)
            {
              uint64_t v163 = *((unsigned int *)a4 + 19);
              uint64_t v164 = (void *)(v161 + 8 * v163);
              if (v163)
              {
                uint64_t v165 = 0;
                uint64_t v166 = 8 * v163;
                while (*(void *)(v161 + v165) != v160)
                {
                  v165 += 8;
                  if (v166 == v165) {
                    goto LABEL_282;
                  }
                }
                uint64_t v164 = (void *)(v161 + v165);
              }
LABEL_282:
              uint64_t v162 = *((void *)a4 + 8);
            }
            else
            {
              uint64_t v172 = *((unsigned int *)a4 + 18);
              int v173 = v172 - 1;
              unsigned int v174 = (v172 - 1) & ((v160 >> 4) ^ (v160 >> 9));
              uint64_t v164 = (void *)(v161 + 8 * v174);
              uint64_t v175 = *v164;
              if (*v164 == -1)
              {
                uint64_t v176 = 0;
LABEL_287:
                if (v176) {
                  uint64_t v164 = v176;
                }
                if (*v164 != v160) {
                  uint64_t v164 = (void *)(v161 + 8 * v172);
                }
              }
              else
              {
                uint64_t v176 = 0;
                int v177 = 1;
                while (v175 != v160)
                {
                  if (v176) {
                    BOOL v178 = 0;
                  }
                  else {
                    BOOL v178 = v175 == -2;
                  }
                  if (v178) {
                    uint64_t v176 = v164;
                  }
                  unsigned int v179 = v174 + v177++;
                  unsigned int v174 = v179 & v173;
                  uint64_t v164 = (void *)(v161 + 8 * (v179 & v173));
                  uint64_t v175 = *v164;
                  if (*v164 == -1) {
                    goto LABEL_287;
                  }
                }
              }
            }
            BOOL v15 = v161 == v162;
            uint64_t v180 = 72;
            if (v15) {
              uint64_t v180 = 76;
            }
            return v164 == (void *)(v161 + 8 * *(unsigned int *)((char *)a4 + v180));
          }
          return 1;
        }
        BOOL v116 = (unsigned int *)((char *)a4 + 76);
        int v117 = (unsigned int *)((char *)a4 + 72);
        while (1)
        {
          uint64_t v118 = *(void *)(v16 + 48);
          uint64_t v119 = *(unsigned int *)(v16 + 64);
          if (v119)
          {
            LODWORD(v120) = ((*v64 >> 4) ^ (*v64 >> 9)) & (v119 - 1);
            int v121 = (uint64_t *)(v118 + 16 * v120);
            uint64_t v122 = *v121;
            if (*v64 == *v121) {
              goto LABEL_185;
            }
            int v123 = 1;
            while (v122 != -4096)
            {
              int v124 = v120 + v123++;
              uint64_t v120 = v124 & (v119 - 1);
              uint64_t v122 = *(void *)(v118 + 16 * v120);
              if (*v64 == v122)
              {
                int v121 = (uint64_t *)(v118 + 16 * v120);
                goto LABEL_185;
              }
            }
          }
          int v121 = (uint64_t *)(v118 + 16 * v119);
LABEL_185:
          if (v121 != (uint64_t *)(v118 + 16 * v119))
          {
            uint64_t v125 = v121[1];
            if (v125)
            {
              uint64_t v126 = *(void *)(v125 + 8);
              if (v126 != v125)
              {
                uint64_t v185 = v121[1];
                uint64_t v182 = v64;
                do
                {
                  uint64_t v127 = v126 - 32;
                  if (!v126) {
                    uint64_t v127 = 0;
                  }
                  int v128 = *(unsigned __int8 *)(v127 + 16);
                  if (v128 == 25) {
                    uint64_t v129 = v127;
                  }
                  else {
                    uint64_t v129 = 0;
                  }
                  if (v126 && v128 == 25)
                  {
                    if (*(unsigned char *)(v129 + 16) == 25) {
                      uint64_t v130 = v129;
                    }
                    else {
                      uint64_t v130 = 0;
                    }
                    if (v130) {
                      uint64_t v131 = (uint64_t *)(v130 - 32);
                    }
                    else {
                      uint64_t v131 = (uint64_t *)(v129 - 64);
                    }
                    uint64_t v132 = *v131;
                    if (*(void *)(v16 + 96) != v132)
                    {
                      uint64_t v133 = *(void *)(v132 + 64);
                      uint64_t v135 = *((void *)a4 + 7);
                      uint64_t v134 = *((void *)a4 + 8);
                      if (v134 == v135)
                      {
                        uint64_t v136 = *v116;
                        int v137 = (void *)(v134 + 8 * v136);
                        if (v136)
                        {
                          uint64_t v138 = 0;
                          uint64_t v139 = 8 * v136;
                          while (*(void *)(v134 + v138) != v133)
                          {
                            v138 += 8;
                            if (v139 == v138) {
                              goto LABEL_232;
                            }
                          }
                          int v137 = (void *)(v134 + v138);
                        }
LABEL_232:
                        uint64_t v135 = *((void *)a4 + 8);
                      }
                      else
                      {
                        uint64_t v148 = *v117;
                        int v149 = v148 - 1;
                        unsigned int v150 = (v148 - 1) & ((v133 >> 4) ^ (v133 >> 9));
                        int v137 = (void *)(v134 + 8 * v150);
                        uint64_t v151 = *v137;
                        if (*v137 == -1)
                        {
                          int v152 = 0;
LABEL_242:
                          if (v152) {
                            int v137 = v152;
                          }
                          if (*v137 != v133) {
                            int v137 = (void *)(v134 + 8 * v148);
                          }
                        }
                        else
                        {
                          int v152 = 0;
                          int v153 = 1;
                          while (v151 != v133)
                          {
                            if (v152) {
                              BOOL v154 = 0;
                            }
                            else {
                              BOOL v154 = v151 == -2;
                            }
                            if (v154) {
                              int v152 = v137;
                            }
                            unsigned int v155 = v150 + v153++;
                            unsigned int v150 = v155 & v149;
                            int v137 = (void *)(v134 + 8 * (v155 & v149));
                            uint64_t v151 = *v137;
                            if (*v137 == -1) {
                              goto LABEL_242;
                            }
                          }
                        }
                      }
                      int v156 = v134 == v135 ? v116 : v117;
                      if (v137 != (void *)(v134 + 8 * *v156)) {
                        return 0;
                      }
                    }
                    if (!*(unsigned char *)(a7 + 16))
                    {
                      BOOL v157 = llvm::MemorySSA::dominates((llvm::MemorySSA *)v16, v183, v129);
                      uint64_t v125 = v185;
                      if (!v157) {
                        return 0;
                      }
                    }
                  }
                  else if (v126 && v128 == 26)
                  {
                    uint64_t v140 = *(unsigned __int8 **)(v127 + 72);
                    int v141 = v140[16];
                    if (v140)
                    {
                      if (v141 == 60) {
                        return 0;
                      }
                    }
                    if (v140 && v141 == 84)
                    {
                      uint64_t v184 = (llvm *)*((void *)v63 - 4);
                      uint64_t v142 = sub_1CB83544C(*(void *)(*(void *)(*((void *)v63 + 5) + 56) + 40) + 272, **((void **)v63 - 8));
                      uint64_t v143 = v117;
                      uint64_t v144 = v116;
                      unint64_t v146 = v145 == 1 ? -2 : (unint64_t)(v142 + 7) >> 3;
                      llvm::Instruction::getAAMetadata((uint64_t ***)v63, &v199);
                      int v197 = v184;
                      uint64_t v198 = v146;
                      BOOL v116 = v144;
                      int v117 = v143;
                      BOOL v64 = v182;
                      char ModRefInfo = llvm::AAResults::getModRefInfo(a2, (const llvm::CallBase *)v140, (const llvm::MemoryLocation *)&v197);
                      uint64_t v125 = v185;
                      if ((ModRefInfo & 3) != 0) {
                        return 0;
                      }
                    }
                  }
                  uint64_t v126 = *(void *)(v126 + 8);
                }
                while (v126 != v125);
              }
            }
          }
          if (++v64 == v186) {
            goto LABEL_247;
          }
        }
      }
      int v70 = 1;
      while (v69 != (llvm *)-4096)
      {
        int v71 = v68 + v70++;
        uint64_t v68 = v71 & v67;
        uint64_t v69 = *(llvm **)(v66 + 16 * v68);
        if (v63 == v69) {
          goto LABEL_97;
        }
      }
    }
    uint64_t v183 = 0;
    goto LABEL_176;
  }
  int v60 = (void *)*((void *)a4 + 4);
  uint64_t v61 = (void *)*((void *)a4 + 5);

  return sub_1CCDA6B34((uint64_t)this, v60, v61, v16);
}

uint64_t llvm::sinkRegionForLoopNest(uint64_t a1, llvm::Instruction *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t *a6, void *a7, uint64_t a8, int32x2_t **a9, uint64_t a10, uint64_t a11, uint64_t ***a12)
{
  v42[4] = *MEMORY[0x1E4F143B8];
  uint64_t v37 = a8;
  v39[0] = 1;
  for (uint64_t i = 1; i != 9; i += 2)
    v39[i] = -4096;
  unint64_t v40 = v42;
  uint64_t v41 = 0x400000000;
  sub_1CD76DF3C((uint64_t)v39, &v37);
  uint64_t v17 = *(void *)(v37 + 8);
  v38[0] = *(void *)(v37 + 16);
  v38[1] = v38[0];
  v38[2] = v17;
  v38[3] = v17;
  sub_1CD887020((uint64_t)v38, (char *)v39);
  uint64_t v18 = v41;
  if (v41)
  {
    int v19 = 0;
    while (1)
    {
      uint64_t v20 = (char *)v40 + 8 * v18;
      uint64_t v21 = *((void *)v20 - 1);
      sub_1CCD7A0C4(v39, (void *)v20 - 1);
      unsigned int v22 = v41 - 1;
      do
      {
        unsigned int v23 = v22;
        if (!v22) {
          break;
        }
      }
      while (!*((void *)v40 + --v22));
      LODWORD(v41) = v23;
      uint64_t v25 = *(void *)(a4 + 24);
      uint64_t v26 = *(unsigned int *)(a4 + 40);
      if (!v26) {
        goto LABEL_14;
      }
      uint64_t v27 = **(void **)(v21 + 32);
      LODWORD(v28) = ((v27 >> 4) ^ (v27 >> 9)) & (v26 - 1);
      BOOL v29 = (uint64_t *)(v25 + 16 * v28);
      uint64_t v30 = *v29;
      if (v27 != *v29) {
        break;
      }
LABEL_15:
      if (v29 == (uint64_t *)(v25 + 16 * v26)) {
        uint64_t v33 = 0;
      }
      else {
        uint64_t v33 = (uint64_t *)v29[1];
      }
      v19 |= llvm::sinkRegion(v33, a2, a3, (llvm::AAResults *)a4, a5, a6, a7, v21, a9, a10, a11, a12, v37);
      uint64_t v18 = v41;
      if (!v41) {
        goto LABEL_21;
      }
    }
    int v31 = 1;
    while (v30 != -4096)
    {
      int v32 = v28 + v31++;
      uint64_t v28 = v32 & (v26 - 1);
      uint64_t v30 = *(void *)(v25 + 16 * v28);
      if (v27 == v30)
      {
        BOOL v29 = (uint64_t *)(v25 + 16 * v28);
        goto LABEL_15;
      }
    }
LABEL_14:
    BOOL v29 = (uint64_t *)(v25 + 16 * v26);
    goto LABEL_15;
  }
  LOBYTE(v19) = 0;
LABEL_21:
  if (v40 != v42) {
    free(v40);
  }
  if ((v39[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v39[1], 8);
  }
  return v19 & 1;
}

uint64_t llvm::hoistRegion(uint64_t a1, llvm::Instruction *a2, llvm::LoopInfo *a3, llvm::DominatorTree *a4, uint64_t a5, llvm::DSOLocalEquivalent **a6, llvm::DominatorTree *a7, int32x2_t **a8, llvm::ScalarEvolution *a9, int32x2_t *a10, uint64_t a11, uint64_t ***a12, char a13)
{
  uint64_t v13 = a8;
  uint64_t v16 = (uint64_t)a4;
  v406[16] = *MEMORY[0x1E4F143B8];
  v384 = a3;
  uint64_t v385 = a4;
  uint64_t v386 = a7;
  v387 = a8;
  uint64_t v388 = 0;
  uint64_t v389 = 0;
  int v390 = 0;
  uint64_t v391 = 0;
  uint64_t v392 = 0;
  unsigned int v393 = 0;
  int v404 = (char *)v406;
  uint64_t v405 = 0x1000000000;
  sub_1CBFCBAB0((uint64_t)v380, (uint64_t)a7);
  uint64_t v370 = a3;
  llvm::LoopBlocksDFS::perform((llvm::LoopBlocksDFS *)v380, a3);
  unsigned int v22 = v383;
  unsigned int v371 = (uint64_t *)v13;
  char v372 = (char *)__p;
  int v23 = 0;
  if (v383 != __p)
  {
    v377 = a10 + 5;
    int v376 = a10 + 9;
    uint64_t v373 = v16;
    while (1)
    {
      uint64_t v24 = *(v22 - 1);
      v375 = (char *)(v22 - 1);
      if ((a13 & 1) == 0) {
        break;
      }
LABEL_12:
      uint64_t v33 = v24 + 40;
      uint64_t v34 = *(void *)(v24 + 48);
      if (v34 != v24 + 40)
      {
        uint64_t v374 = *(v22 - 1);
        do
        {
          uint64_t v35 = *(void *)(v34 + 8);
          if (v34) {
            uint64_t v36 = v34 - 24;
          }
          else {
            uint64_t v36 = 0;
          }
          uint64_t v37 = llvm::ConstantFoldInstruction(v36, (llvm::DataLayout *)(*(void *)(*(void *)(*(void *)(v36 + 40) + 56) + 40) + 272), a6, v18, v19, v20, v21);
          if (v37)
          {
            int v23 = 1;
            llvm::Value::doRAUW((llvm::ValueAsMetadata *)v36, v37, (llvm::Value *)1);
            if (!*(void *)(v36 + 8) && llvm::wouldInstructionBeTriviallyDead(v36, (uint64_t *)a6))
            {
              __int32 v38 = (*v13)[5].i32[0];
              if (v38)
              {
                int32x2_t v39 = (*v13)[3];
                __int32 v40 = v38 - 1;
                uint64_t v41 = (v38 - 1) & ((v36 >> 4) ^ (v36 >> 9));
                uint64_t v42 = *(void *)(*(void *)&v39 + 16 * v41);
                if (v42 == v36)
                {
LABEL_25:
                  uint64_t v45 = *(llvm::MemoryAccess **)(*(void *)&v39 + 16 * v41 + 8);
                  if (v45) {
                    llvm::MemorySSAUpdater::removeMemoryAccess(v13, v45, 0);
                  }
                }
                else
                {
                  int v43 = 1;
                  while (v42 != -4096)
                  {
                    int v44 = v41 + v43++;
                    uint64_t v41 = v44 & v40;
                    uint64_t v42 = *(void *)(*(void *)&v39 + 16 * v41);
                    if (v42 == v36) {
                      goto LABEL_25;
                    }
                  }
                }
              }
              llvm::InstructionPrecedenceTracking::removeInstruction(v377, (const llvm::Instruction *)v36);
              llvm::InstructionPrecedenceTracking::removeInstruction(v376, (const llvm::Instruction *)v36);
              llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
            }
            goto LABEL_651;
          }
          if (llvm::Loop::hasLoopInvariantOperands((uint64_t)a7, v36)
            && llvm::canSinkOrHoistInst((llvm *)v36, a2, (llvm::AAResults *)v16, a7, (llvm::Loop *)v13, (llvm::MemorySSAUpdater *)1, a11, a12, v363))
          {
            llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopPredecessor();
          }
          int v47 = *(unsigned __int8 *)(v36 + 16);
          if (v47 == 49)
          {
            if ((*(unsigned char *)(v36 + 17) & 0x20) == 0) {
              goto LABEL_59;
            }
            int v48 = *(_DWORD *)(v36 + 20);
            if ((v48 & 0x40000000) != 0) {
              uint64_t v49 = *(void *)(v36 - 8);
            }
            else {
              uint64_t v49 = v36 - 32 * (v48 & 0x7FFFFFF);
            }
            if (llvm::Loop::isLoopInvariant((uint64_t)a7, *(void *)(v49 + 32)))
            {
              int v51 = *(_DWORD *)(v36 + 20);
              if ((v51 & 0x40000000) != 0) {
                uint64_t v52 = *(void *)(v36 - 8);
              }
              else {
                uint64_t v52 = v36 - 32 * (v51 & 0x7FFFFFF);
              }
              uint64_t v92 = *(llvm::ConstantFP ****)(v52 + 32);
              uint64_t v93 = llvm::ConstantFP::get(*v92, v50, 1.0);
              v398[0] = 257;
              unsigned int v94 = llvm::BinaryOperator::Create(21, v93, (uint64_t)v92, &v394, 0);
              *((unsigned char *)v94 + 17) |= *(unsigned char *)(v36 + 17) & 0xFE;
              uint64_t v95 = *(const llvm::BasicBlock **)(v36 + 40);
              llvm::InstructionPrecedenceTracking::insertInstructionTo((llvm::InstructionPrecedenceTracking *)v377, v94, v95);
              llvm::InstructionPrecedenceTracking::insertInstructionTo((llvm::InstructionPrecedenceTracking *)v376, v94, v95);
              uint64_t v96 = *(void *)(v36 + 40);
              *((void *)v94 + 5) = v96;
              *(_WORD *)(v96 + 18) &= ~0x8000u;
              if ((*((unsigned char *)v94 + 23) & 0x10) != 0)
              {
                uint64_t v217 = *(void *)(v96 + 56);
                if (v217)
                {
                  uint64_t v218 = *(llvm::ValueSymbolTable **)(v217 + 104);
                  if (v218) {
                    llvm::ValueSymbolTable::reinsertValue(v218, v94);
                  }
                }
              }
              uint64_t v97 = *(void *)(v36 + 24);
              *((void *)v94 + 3) = v97;
              *((void *)v94 + 4) = v36 + 24;
              *(void *)(v97 + 8) = (char *)v94 + 24;
              *(void *)(v36 + 24) = (char *)v94 + 24;
              int v98 = *(_DWORD *)(v36 + 20);
              if ((v98 & 0x40000000) != 0) {
                int v99 = *(void ***)(v36 - 8);
              }
              else {
                int v99 = (void **)(v36 - 32 * (v98 & 0x7FFFFFF));
              }
              uint64_t v100 = *v99;
              v398[0] = 257;
              int v101 = llvm::BinaryOperator::Create(18, v100, (uint64_t)v94, &v394, 0);
              *((unsigned char *)v101 + 17) |= *(unsigned char *)(v36 + 17) & 0xFE;
              int v102 = *(const llvm::BasicBlock **)(v36 + 40);
              llvm::InstructionPrecedenceTracking::insertInstructionTo((llvm::InstructionPrecedenceTracking *)v377, v101, v102);
              llvm::InstructionPrecedenceTracking::insertInstructionTo((llvm::InstructionPrecedenceTracking *)v376, v101, v102);
              sub_1CC5C6C08((void *)(*(void *)(v36 + 40) + 40), v36 + 24, v101);
              llvm::Value::doRAUW((llvm::ValueAsMetadata *)v36, v101, (llvm::Value *)1);
              __int32 v103 = (*v13)[5].i32[0];
              if (v103)
              {
                int32x2_t v104 = (*v13)[3];
                __int32 v105 = v103 - 1;
                uint64_t v106 = (v103 - 1) & ((v36 >> 4) ^ (v36 >> 9));
                uint64_t v107 = *(void *)(*(void *)&v104 + 16 * v106);
                if (v107 == v36)
                {
LABEL_155:
                  uint64_t v110 = *(llvm::MemoryAccess **)(*(void *)&v104 + 16 * v106 + 8);
                  if (v110) {
                    llvm::MemorySSAUpdater::removeMemoryAccess(v13, v110, 0);
                  }
                }
                else
                {
                  int v108 = 1;
                  while (v107 != -4096)
                  {
                    int v109 = v106 + v108++;
                    uint64_t v106 = v109 & v105;
                    uint64_t v107 = *(void *)(*(void *)&v104 + 16 * v106);
                    if (v107 == v36) {
                      goto LABEL_155;
                    }
                  }
                }
              }
              llvm::InstructionPrecedenceTracking::removeInstruction(v377, (const llvm::Instruction *)v36);
              llvm::InstructionPrecedenceTracking::removeInstruction(v376, (const llvm::Instruction *)v36);
              llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
            }
            int v47 = *(unsigned __int8 *)(v36 + 16);
          }
          if (*(void *)(v36 + 8))
          {
            if (!v34) {
              goto LABEL_59;
            }
          }
          else
          {
            if (v47 != 84) {
              goto LABEL_59;
            }
            uint64_t v54 = *(void *)(v36 - 32);
            if (v54
              && !*(unsigned char *)(v54 + 16)
              && *(void *)(v54 + 24) == *(void *)(v36 + 72)
              && *(_DWORD *)(v54 + 36) == 164)
            {
              goto LABEL_49;
            }
            int v47 = 84;
            if (!v34) {
              goto LABEL_59;
            }
          }
          if (v47 != 84) {
            goto LABEL_59;
          }
          uint64_t v53 = *(void *)(v36 - 32);
          if (!v53
            || *(unsigned char *)(v53 + 16)
            || *(void *)(v53 + 24) != *(void *)(v36 + 72)
            || *(_DWORD *)(v53 + 36) != 125)
          {
            goto LABEL_59;
          }
LABEL_49:
          if (llvm::Loop::hasLoopInvariantOperands((uint64_t)a7, v36)
            && (*(unsigned int (**)(int32x2_t *, uint64_t, uint64_t, llvm::DominatorTree *))(*(void *)a10 + 24))(a10, v36, v16, a7)&& llvm::ICFLoopSafetyInfo::doesNotWriteMemoryBefore(a10, (const llvm::Instruction *)v36, (const llvm::BasicBlock ***)a7))
          {
            uint64_t v46 = sub_1CCDA5E30((uint64_t)&v384, v374);
            sub_1CCDA5A68((unsigned __int8 *)v36, v16, (uint64_t)a7, v46, a10, (uint64_t *)v13, a9, a12);
            if (v405 >= (unint64_t)HIDWORD(v405)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)&v404[8 * v405] = v36;
            LODWORD(v405) = v405 + 1;
LABEL_372:
            int v23 = 1;
            goto LABEL_651;
          }
LABEL_59:
          int v379 = v23;
          int v55 = *(unsigned __int8 *)(v36 + 16);
          if (v55 == 83) {
            uint64_t v56 = v36;
          }
          else {
            uint64_t v56 = 0;
          }
          if (!v34
            || v55 != 83
            || !byte_1EBCF32E0
            || !llvm::Loop::hasLoopInvariantOperands((uint64_t)v386, v56))
          {
            goto LABEL_373;
          }
          v394 = (const char *)v398;
          BOOL v395 = (char *)v398;
          uint64_t v396 = 8;
          int v397 = 0;
          uint64_t v57 = *(void *)(v56 + 40);
          uint64_t v58 = *(void *)(v57 + 8);
          if (v58)
          {
            uint64_t v59 = *(void *)(v57 + 8);
            while (1)
            {
              uint64_t v60 = *(void *)(v59 + 24);
              unsigned int v61 = *(unsigned __int8 *)(v60 + 16);
              BOOL v62 = v60 && v61 >= 0x1C;
              if (v62 && v61 - 29 <= 0xA) {
                break;
              }
              uint64_t v59 = *(void *)(v59 + 8);
              if (!v59)
              {
                int v64 = 0;
                unsigned int v65 = 0;
                unsigned int v67 = (const char *)v398;
                uint64_t v68 = (char *)v398;
                goto LABEL_126;
              }
            }
            unsigned int v65 = 0;
            unsigned int v66 = 8;
            unsigned int v67 = (const char *)v398;
            uint64_t v68 = (char *)v398;
LABEL_79:
            uint64_t v69 = *(void *)(v60 + 40);
            if (v68 == v67)
            {
              if (v65)
              {
                int v70 = 0;
                uint64_t v71 = 8 * v65;
                uint64_t v72 = v67;
                while (*(void *)v72 != v69)
                {
                  if (*(void *)v72 == -2) {
                    int v70 = (char *)v72;
                  }
                  v72 += 8;
                  v71 -= 8;
                  if (!v71)
                  {
                    if (!v70) {
                      goto LABEL_87;
                    }
                    *(void *)int v70 = v69;
                    --v397;
                    break;
                  }
                }
LABEL_109:
                unsigned int v67 = v394;
                uint64_t v68 = v395;
                unsigned int v65 = HIDWORD(v396);
                unsigned int v66 = v396;
                while (1)
                {
                  uint64_t v59 = *(void *)(v59 + 8);
                  if (!v59) {
                    break;
                  }
                  uint64_t v60 = *(void *)(v59 + 24);
                  unsigned int v81 = *(unsigned __int8 *)(v60 + 16);
                  if (v60) {
                    BOOL v82 = v81 >= 0x1C;
                  }
                  else {
                    BOOL v82 = 0;
                  }
                  if (v82 && v81 - 29 < 0xB) {
                    goto LABEL_79;
                  }
                }
                int v64 = v397;
                uint64_t v58 = *(void *)(v57 + 8);
LABEL_126:
                uint64_t v13 = (int32x2_t **)v371;
                if (v58)
                {
                  while (1)
                  {
                    uint64_t v84 = *(void *)(v58 + 24);
                    unsigned int v85 = *(unsigned __int8 *)(v84 + 16);
                    BOOL v86 = v84 && v85 >= 0x1C;
                    if (v86 && v85 - 29 <= 0xA) {
                      break;
                    }
                    uint64_t v58 = *(void *)(v58 + 8);
                    if (!v58) {
                      goto LABEL_136;
                    }
                  }
                  int v111 = 0;
LABEL_158:
                  ++v111;
                  while (1)
                  {
                    uint64_t v58 = *(void *)(v58 + 8);
                    if (!v58) {
                      break;
                    }
                    uint64_t v112 = *(void *)(v58 + 24);
                    unsigned int v113 = *(unsigned __int8 *)(v112 + 16);
                    if (v112) {
                      BOOL v114 = v113 >= 0x1C;
                    }
                    else {
                      BOOL v114 = 0;
                    }
                    if (v114 && v113 - 29 < 0xB) {
                      goto LABEL_158;
                    }
                  }
                }
                else
                {
LABEL_136:
                  int v111 = 0;
                }
                if (v65 - v64 != v111)
                {
                  BOOL v91 = 0;
                  goto LABEL_359;
                }
                goto LABEL_138;
              }
LABEL_87:
              if (v66 > v65)
              {
                HIDWORD(v396) = v65 + 1;
                *(void *)&v67[8 * v65] = v69;
                goto LABEL_109;
              }
            }
            if (3 * v66 <= 4 * (v65 - v397))
            {
              if (v66 >= 0x40) {
                v66 *= 2;
              }
              else {
                unsigned int v66 = 128;
              }
            }
            else if (v66 - v65 >= v66 >> 3)
            {
              goto LABEL_91;
            }
            llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v394, v66);
            unsigned int v66 = v396;
            uint64_t v68 = v395;
LABEL_91:
            unsigned int v73 = v66 - 1;
            unsigned int v74 = (v66 - 1) & ((v69 >> 4) ^ (v69 >> 9));
            uint64_t v75 = &v68[8 * v74];
            uint64_t v76 = *(void *)v75;
            if (*(void *)v75 == -1)
            {
              uint64_t v77 = 0;
LABEL_103:
              if (v77) {
                uint64_t v75 = v77;
              }
              if (*(void *)v75 != v69)
              {
                if (*(void *)v75 == -2) {
                  --v397;
                }
                else {
                  ++HIDWORD(v396);
                }
                *(void *)uint64_t v75 = v69;
              }
            }
            else
            {
              uint64_t v77 = 0;
              int v78 = 1;
              while (v76 != v69)
              {
                if (v77) {
                  BOOL v79 = 0;
                }
                else {
                  BOOL v79 = v76 == -2;
                }
                if (v79) {
                  uint64_t v77 = v75;
                }
                unsigned int v80 = v74 + v78++;
                unsigned int v74 = v80 & v73;
                uint64_t v75 = &v68[8 * (v80 & v73)];
                uint64_t v76 = *(void *)v75;
                if (*(void *)v75 == -1) {
                  goto LABEL_103;
                }
              }
            }
            goto LABEL_109;
          }
          int v64 = 0;
          unsigned int v65 = 0;
          unsigned int v67 = (const char *)v398;
          uint64_t v68 = (char *)v398;
LABEL_138:
          uint64_t v88 = &v391[2 * v393];
          if (v392)
          {
            if (v393)
            {
              uint64_t v89 = 16 * v393;
              int v90 = v391;
              while ((*v90 | 0x1000) == 0xFFFFFFFFFFFFF000)
              {
                v90 += 2;
                v89 -= 16;
                if (!v89) {
                  goto LABEL_143;
                }
              }
            }
            else
            {
              int v90 = v391;
            }
          }
          else
          {
LABEL_143:
            int v90 = &v391[2 * v393];
          }
          BOOL v116 = &v391[2 * v393];
          if (v90 == v116) {
            goto LABEL_358;
          }
          do
          {
            if (v90[1] != v57) {
              goto LABEL_351;
            }
            uint64_t v117 = *v90;
            uint64_t v118 = *(void *)(*v90 - 32);
            if (v118 == v57)
            {
              uint64_t v125 = *(void *)(v117 + 40);
              uint64_t v127 = v394;
              uint64_t v126 = v395;
              if (v395 == v394)
              {
                unsigned int v128 = HIDWORD(v396);
                uint64_t v129 = (uint64_t *)&v395[8 * HIDWORD(v396)];
                if (HIDWORD(v396))
                {
                  uint64_t v130 = 0;
                  while (*(void *)&v395[v130] != v125)
                  {
                    v130 += 8;
                    if (8 * HIDWORD(v396) == v130) {
                      goto LABEL_229;
                    }
                  }
                  uint64_t v129 = (uint64_t *)&v395[v130];
                }
LABEL_229:
                uint64_t v151 = v395;
              }
              else
              {
                int v140 = v396 - 1;
                unsigned int v141 = (v396 - 1) & ((v125 >> 4) ^ (v125 >> 9));
                uint64_t v129 = (uint64_t *)&v395[8 * v141];
                uint64_t v18 = *v129;
                if (*v129 == -1)
                {
                  uint64_t v142 = 0;
LABEL_269:
                  if (v142) {
                    uint64_t v129 = v142;
                  }
                  unsigned int v128 = HIDWORD(v396);
                  if (*v129 != v125) {
                    uint64_t v129 = (uint64_t *)&v395[8 * v396];
                  }
                }
                else
                {
                  uint64_t v142 = 0;
                  uint64_t v19 = 1;
                  while (v18 != v125)
                  {
                    uint64_t v20 = -2;
                    if (v142) {
                      BOOL v143 = 0;
                    }
                    else {
                      BOOL v143 = v18 == -2;
                    }
                    if (v143) {
                      uint64_t v142 = v129;
                    }
                    int v144 = v141 + v19;
                    uint64_t v19 = (v19 + 1);
                    unsigned int v141 = v144 & v140;
                    uint64_t v129 = (uint64_t *)&v395[8 * (v144 & v140)];
                    uint64_t v18 = *v129;
                    if (*v129 == -1) {
                      goto LABEL_269;
                    }
                  }
                  unsigned int v128 = HIDWORD(v396);
                }
                uint64_t v151 = v394;
              }
              int v164 = v396;
              if (v395 == v151) {
                int v165 = v128;
              }
              else {
                int v165 = v396;
              }
              if (v129 != (uint64_t *)&v395[8 * v165])
              {
                *uint64_t v129 = -2;
                int v397 = ++v64;
                uint64_t v127 = v394;
                uint64_t v126 = v395;
                uint64_t v117 = *v90;
                uint64_t v151 = v394;
              }
              uint64_t v166 = *(void *)(v117 - 64);
              if (v126 == v151)
              {
                unsigned int v155 = (char *)&v151[8 * v128];
                if (v128)
                {
                  uint64_t v167 = 0;
                  while (*(void *)&v151[v167] != v166)
                  {
                    v167 += 8;
                    if (8 * v128 == v167) {
                      goto LABEL_297;
                    }
                  }
                  unsigned int v155 = (char *)&v151[v167];
                }
LABEL_297:
                uint64_t v127 = v151;
                uint64_t v126 = v151;
              }
              else
              {
                int v168 = v164 - 1;
                unsigned int v169 = ((v166 >> 4) ^ (v166 >> 9)) & (v164 - 1);
                unsigned int v155 = (char *)&v126[8 * v169];
                uint64_t v170 = *(void *)v155;
                if (*(void *)v155 == -1)
                {
                  uint64_t v171 = 0;
LABEL_303:
                  if (v171) {
                    unsigned int v155 = v171;
                  }
                  if (*(void *)v155 != v166)
                  {
                    int v177 = (uint64_t *)((char *)&v396 + 4);
                    if (v126 != v127) {
                      int v177 = &v396;
                    }
                    unsigned int v155 = (char *)&v126[8 * *(unsigned int *)v177];
                  }
                }
                else
                {
                  uint64_t v171 = 0;
                  int v172 = 1;
                  while (v170 != v166)
                  {
                    uint64_t v18 = -2;
                    if (v171) {
                      BOOL v173 = 0;
                    }
                    else {
                      BOOL v173 = v170 == -2;
                    }
                    if (v173) {
                      uint64_t v171 = v155;
                    }
                    unsigned int v174 = v169 + v172++;
                    unsigned int v169 = v174 & v168;
                    unsigned int v155 = (char *)&v126[8 * (v174 & v168)];
                    uint64_t v170 = *(void *)v155;
                    if (*(void *)v155 == -1) {
                      goto LABEL_303;
                    }
                  }
                }
              }
              if (v126 == v127) {
                uint64_t v175 = (uint64_t *)((char *)&v396 + 4);
              }
              else {
                uint64_t v175 = &v396;
              }
              uint64_t v176 = (char *)&v126[8 * *(unsigned int *)v175];
              goto LABEL_349;
            }
            uint64_t v119 = *(void *)(v117 - 64);
            if (v119 == v57)
            {
              uint64_t v131 = *(void *)(v117 + 40);
              int v121 = v394;
              uint64_t v120 = v395;
              if (v395 == v394)
              {
                unsigned int v132 = HIDWORD(v396);
                uint64_t v133 = (uint64_t *)&v395[8 * HIDWORD(v396)];
                if (HIDWORD(v396))
                {
                  uint64_t v134 = 0;
                  while (*(void *)&v395[v134] != v131)
                  {
                    v134 += 8;
                    if (8 * HIDWORD(v396) == v134) {
                      goto LABEL_232;
                    }
                  }
                  uint64_t v133 = (uint64_t *)&v395[v134];
                }
LABEL_232:
                int v152 = v395;
              }
              else
              {
                int v145 = v396 - 1;
                unsigned int v146 = (v396 - 1) & ((v131 >> 4) ^ (v131 >> 9));
                uint64_t v133 = (uint64_t *)&v395[8 * v146];
                uint64_t v18 = *v133;
                if (*v133 == -1)
                {
                  uint64_t v147 = 0;
LABEL_310:
                  if (v147) {
                    uint64_t v133 = v147;
                  }
                  unsigned int v132 = HIDWORD(v396);
                  if (*v133 != v131) {
                    uint64_t v133 = (uint64_t *)&v395[8 * v396];
                  }
                }
                else
                {
                  uint64_t v147 = 0;
                  uint64_t v19 = 1;
                  while (v18 != v131)
                  {
                    uint64_t v20 = -2;
                    if (v147) {
                      BOOL v148 = 0;
                    }
                    else {
                      BOOL v148 = v18 == -2;
                    }
                    if (v148) {
                      uint64_t v147 = v133;
                    }
                    int v149 = v146 + v19;
                    uint64_t v19 = (v19 + 1);
                    unsigned int v146 = v149 & v145;
                    uint64_t v133 = (uint64_t *)&v395[8 * (v149 & v145)];
                    uint64_t v18 = *v133;
                    if (*v133 == -1) {
                      goto LABEL_310;
                    }
                  }
                  unsigned int v132 = HIDWORD(v396);
                }
                int v152 = v394;
              }
              int v178 = v396;
              if (v395 == v152) {
                int v179 = v132;
              }
              else {
                int v179 = v396;
              }
              if (v133 != (uint64_t *)&v395[8 * v179])
              {
                uint64_t *v133 = -2;
                int v397 = ++v64;
                int v121 = v394;
                uint64_t v120 = v395;
                uint64_t v118 = *(void *)(*v90 - 32);
                int v152 = v394;
              }
              if (v120 == v152)
              {
                unsigned int v155 = (char *)&v152[8 * v132];
                if (v132)
                {
                  uint64_t v180 = 0;
                  while (*(void *)&v152[v180] != v118)
                  {
                    v180 += 8;
                    if (8 * v132 == v180) {
                      goto LABEL_338;
                    }
                  }
                  unsigned int v155 = (char *)&v152[v180];
                }
LABEL_338:
                int v121 = v152;
                uint64_t v120 = v152;
                goto LABEL_346;
              }
              int v181 = v178 - 1;
              unsigned int v182 = ((v118 >> 4) ^ (v118 >> 9)) & (v178 - 1);
              unsigned int v155 = (char *)&v120[8 * v182];
              uint64_t v183 = *(void *)v155;
              if (*(void *)v155 != -1)
              {
                uint64_t v184 = 0;
                int v185 = 1;
                while (v183 != v118)
                {
                  uint64_t v18 = -2;
                  if (v184) {
                    BOOL v186 = 0;
                  }
                  else {
                    BOOL v186 = v183 == -2;
                  }
                  if (v186) {
                    uint64_t v184 = v155;
                  }
                  unsigned int v187 = v182 + v185++;
                  unsigned int v182 = v187 & v181;
                  unsigned int v155 = (char *)&v120[8 * (v187 & v181)];
                  uint64_t v183 = *(void *)v155;
                  if (*(void *)v155 == -1) {
                    goto LABEL_340;
                  }
                }
                goto LABEL_346;
              }
              uint64_t v184 = 0;
LABEL_340:
              if (v184) {
                unsigned int v155 = v184;
              }
              if (*(void *)v155 == v118) {
                goto LABEL_346;
              }
            }
            else
            {
              int v121 = v394;
              uint64_t v120 = v395;
              if (v395 == v394)
              {
                unsigned int v122 = HIDWORD(v396);
                int v123 = (uint64_t *)&v395[8 * HIDWORD(v396)];
                if (HIDWORD(v396))
                {
                  uint64_t v124 = 0;
                  while (*(void *)&v395[v124] != v118)
                  {
                    v124 += 8;
                    if (8 * HIDWORD(v396) == v124) {
                      goto LABEL_227;
                    }
                  }
                  int v123 = (uint64_t *)&v395[v124];
                }
LABEL_227:
                unsigned int v150 = v395;
              }
              else
              {
                int v135 = v396 - 1;
                unsigned int v136 = (v396 - 1) & ((v118 >> 4) ^ (v118 >> 9));
                int v123 = (uint64_t *)&v395[8 * v136];
                uint64_t v18 = *v123;
                if (*v123 == -1)
                {
                  int v137 = 0;
LABEL_234:
                  if (v137) {
                    int v123 = v137;
                  }
                  unsigned int v122 = HIDWORD(v396);
                  if (*v123 != v118) {
                    int v123 = (uint64_t *)&v395[8 * v396];
                  }
                }
                else
                {
                  int v137 = 0;
                  uint64_t v19 = 1;
                  while (v18 != v118)
                  {
                    uint64_t v20 = -2;
                    if (v137) {
                      BOOL v138 = 0;
                    }
                    else {
                      BOOL v138 = v18 == -2;
                    }
                    if (v138) {
                      int v137 = v123;
                    }
                    int v139 = v136 + v19;
                    uint64_t v19 = (v19 + 1);
                    unsigned int v136 = v139 & v135;
                    int v123 = (uint64_t *)&v395[8 * (v139 & v135)];
                    uint64_t v18 = *v123;
                    if (*v123 == -1) {
                      goto LABEL_234;
                    }
                  }
                  unsigned int v122 = HIDWORD(v396);
                }
                unsigned int v150 = v394;
              }
              int v153 = v396;
              if (v395 == v150) {
                int v154 = v122;
              }
              else {
                int v154 = v396;
              }
              if (v123 != (uint64_t *)&v395[8 * v154])
              {
                *int v123 = -2;
                int v397 = ++v64;
                int v121 = v394;
                uint64_t v120 = v395;
                uint64_t v119 = *(void *)(*v90 - 64);
                unsigned int v150 = v394;
              }
              if (v120 == v150)
              {
                unsigned int v155 = (char *)&v150[8 * v122];
                if (v122)
                {
                  uint64_t v156 = 0;
                  while (*(void *)&v150[v156] != v119)
                  {
                    v156 += 8;
                    if (8 * v122 == v156) {
                      goto LABEL_262;
                    }
                  }
                  unsigned int v155 = (char *)&v150[v156];
                }
LABEL_262:
                int v121 = v150;
                uint64_t v120 = v150;
                goto LABEL_346;
              }
              int v157 = v153 - 1;
              unsigned int v158 = ((v119 >> 4) ^ (v119 >> 9)) & (v153 - 1);
              unsigned int v155 = (char *)&v120[8 * v158];
              uint64_t v159 = *(void *)v155;
              if (*(void *)v155 != -1)
              {
                uint64_t v160 = 0;
                int v161 = 1;
                while (v159 != v119)
                {
                  uint64_t v18 = -2;
                  if (v160) {
                    BOOL v162 = 0;
                  }
                  else {
                    BOOL v162 = v159 == -2;
                  }
                  if (v162) {
                    uint64_t v160 = v155;
                  }
                  unsigned int v163 = v158 + v161++;
                  unsigned int v158 = v163 & v157;
                  unsigned int v155 = (char *)&v120[8 * (v163 & v157)];
                  uint64_t v159 = *(void *)v155;
                  if (*(void *)v155 == -1) {
                    goto LABEL_264;
                  }
                }
                goto LABEL_346;
              }
              uint64_t v160 = 0;
LABEL_264:
              if (v160) {
                unsigned int v155 = v160;
              }
              if (*(void *)v155 == v119) {
                goto LABEL_346;
              }
            }
            uint64_t v188 = (uint64_t *)((char *)&v396 + 4);
            if (v120 != v121) {
              uint64_t v188 = &v396;
            }
            unsigned int v155 = (char *)&v120[8 * *(unsigned int *)v188];
LABEL_346:
            long long v189 = (uint64_t *)((char *)&v396 + 4);
            if (v120 != v121) {
              long long v189 = &v396;
            }
            uint64_t v176 = (char *)&v120[8 * *(unsigned int *)v189];
LABEL_349:
            if (v155 != v176)
            {
              *(void *)unsigned int v155 = -2;
              int v397 = ++v64;
            }
LABEL_351:
            uint64_t v190 = v90 + 2;
            int v90 = v88;
            if (v190 != v88)
            {
              int v90 = v190;
              while ((*v90 | 0x1000) == 0xFFFFFFFFFFFFF000)
              {
                v90 += 2;
                if (v90 == v88)
                {
                  int v90 = v88;
                  break;
                }
              }
            }
          }
          while (v90 != v116);
          unsigned int v65 = HIDWORD(v396);
          unsigned int v67 = v394;
          uint64_t v68 = v395;
LABEL_358:
          BOOL v91 = v65 == v64;
LABEL_359:
          uint64_t v16 = v373;
          if (v68 != v67) {
            free(v68);
          }
          if (v91)
          {
            int v191 = *(_DWORD *)(v56 + 20);
            unint64_t v192 = v191 & 0x7FFFFFF;
            if ((v191 & 0x7FFFFFF) != 0)
            {
              unint64_t v193 = 0;
              do
              {
                if ((v191 & 0x40000000) != 0) {
                  uint64_t v194 = *(void *)(v56 - 8);
                }
                else {
                  uint64_t v194 = v56 - 32 * v192;
                }
                uint64_t v195 = sub_1CCDA5E30((uint64_t)&v384, *(void *)(v194 + 32 * *(unsigned int *)(v56 + 60) + 8 * v193));
                int v196 = *(_DWORD *)(v56 + 20);
                if ((v196 & 0x40000000) != 0) {
                  uint64_t v197 = *(void *)(v56 - 8);
                }
                else {
                  uint64_t v197 = v56 - 32 * (v196 & 0x7FFFFFF);
                }
                *(void *)(v197 + 32 * *(unsigned int *)(v56 + 60) + 8 * v193++) = v195;
                int v191 = *(_DWORD *)(v56 + 20);
                unint64_t v192 = v191 & 0x7FFFFFF;
              }
              while (v193 < v192);
            }
            uint64_t v198 = sub_1CCDA5E30((uint64_t)&v384, v374);
            sub_1CCDA5A68((unsigned __int8 *)v56, v373, (uint64_t)a7, v198, a10, (uint64_t *)v13, a9, a12);
            goto LABEL_372;
          }
LABEL_373:
          int v199 = *(unsigned __int8 *)(v36 + 16);
          if (v199 != 30) {
            uint64_t v36 = 0;
          }
          if (!v34) {
            goto LABEL_650;
          }
          if (v199 != 30) {
            goto LABEL_650;
          }
          v403[4] = v36;
          if (!byte_1EBCF32E0
            || (*(_DWORD *)(v36 + 20) & 0x7FFFFFF) != 3
            || !llvm::Loop::hasLoopInvariantOperands((uint64_t)v386, v36))
          {
            goto LABEL_650;
          }
          uint64_t v200 = *(const llvm::BasicBlock **)(v36 - 32);
          uint64_t v201 = *(const llvm::BasicBlock **)(v36 - 64);
          uint64_t v203 = *((void *)v386 + 7);
          uint64_t v202 = *((void *)v386 + 8);
          if (v202 == v203)
          {
            uint64_t v204 = *((unsigned int *)v386 + 19);
            if (v204)
            {
              uint64_t v205 = 0;
              uint64_t v206 = 8 * v204;
              uint64_t v207 = (const llvm::BasicBlock **)(v202 + 8 * v204);
              while (*(const llvm::BasicBlock **)(v202 + v205) != v200)
              {
                v205 += 8;
                if (v206 == v205) {
                  goto LABEL_398;
                }
              }
              uint64_t v207 = (const llvm::BasicBlock **)(v202 + v205);
LABEL_398:
              uint64_t v216 = *((void *)v386 + 8);
              goto LABEL_408;
            }
            goto LABEL_650;
          }
          uint64_t v208 = *((unsigned int *)v386 + 18);
          int v209 = v208 - 1;
          unsigned int v210 = (v208 - 1) & ((v200 >> 4) ^ (v200 >> 9));
          uint64_t v207 = (const llvm::BasicBlock **)(v202 + 8 * v210);
          uint64_t v211 = *v207;
          if (*v207 == (const llvm::BasicBlock *)-1)
          {
            unint64_t v212 = 0;
LABEL_403:
            if (v212) {
              uint64_t v207 = v212;
            }
            if (*v207 != v200) {
              uint64_t v207 = (const llvm::BasicBlock **)(v202 + 8 * v208);
            }
          }
          else
          {
            unint64_t v212 = 0;
            int v213 = 1;
            while (v211 != v200)
            {
              if (v212) {
                BOOL v214 = 0;
              }
              else {
                BOOL v214 = v211 == (const llvm::BasicBlock *)-2;
              }
              if (v214) {
                unint64_t v212 = v207;
              }
              unsigned int v215 = v210 + v213++;
              unsigned int v210 = v215 & v209;
              uint64_t v207 = (const llvm::BasicBlock **)(v202 + 8 * (v215 & v209));
              uint64_t v211 = *v207;
              if (*v207 == (const llvm::BasicBlock *)-1) {
                goto LABEL_403;
              }
            }
          }
          uint64_t v216 = *((void *)v386 + 7);
LABEL_408:
          BOOL v79 = v202 == v216;
          uint64_t v219 = 72;
          if (v79) {
            uint64_t v219 = 76;
          }
          if (v207 != (const llvm::BasicBlock **)(v202 + 8 * *(unsigned int *)((char *)v386 + v219)))
          {
            if (v202 == v203)
            {
              uint64_t v220 = *((unsigned int *)v386 + 19);
              uint64_t v221 = (const llvm::BasicBlock **)(v202 + 8 * v220);
              if (v220)
              {
                uint64_t v222 = 0;
                uint64_t v223 = 8 * v220;
                while (*(const llvm::BasicBlock **)(v202 + v222) != v201)
                {
                  v222 += 8;
                  if (v223 == v222) {
                    goto LABEL_429;
                  }
                }
                uint64_t v221 = (const llvm::BasicBlock **)(v202 + v222);
              }
LABEL_429:
              uint64_t v203 = *((void *)v386 + 8);
            }
            else
            {
              uint64_t v224 = *((unsigned int *)v386 + 18);
              int v225 = v224 - 1;
              unsigned int v226 = (v224 - 1) & ((v201 >> 4) ^ (v201 >> 9));
              uint64_t v221 = (const llvm::BasicBlock **)(v202 + 8 * v226);
              uint64_t v227 = *v221;
              if (*v221 == (const llvm::BasicBlock *)-1)
              {
                unsigned int v228 = 0;
LABEL_431:
                if (v228) {
                  uint64_t v221 = v228;
                }
                if (*v221 != v201) {
                  uint64_t v221 = (const llvm::BasicBlock **)(v202 + 8 * v224);
                }
              }
              else
              {
                unsigned int v228 = 0;
                int v229 = 1;
                while (v227 != v201)
                {
                  if (v228) {
                    BOOL v230 = 0;
                  }
                  else {
                    BOOL v230 = v227 == (const llvm::BasicBlock *)-2;
                  }
                  if (v230) {
                    unsigned int v228 = v221;
                  }
                  unsigned int v231 = v226 + v229++;
                  unsigned int v226 = v231 & v225;
                  uint64_t v221 = (const llvm::BasicBlock **)(v202 + 8 * (v231 & v225));
                  uint64_t v227 = *v221;
                  if (*v221 == (const llvm::BasicBlock *)-1) {
                    goto LABEL_431;
                  }
                }
              }
            }
            int v232 = v202 == v203
                 ? (llvm::DominatorTree *)((char *)v386 + 76)
                 : (llvm::DominatorTree *)((char *)v386 + 72);
            if (v221 != (const llvm::BasicBlock **)(v202 + 8 * *(unsigned int *)v232) && v200 != v201)
            {
              v394 = (const char *)v398;
              BOOL v395 = (char *)v398;
              uint64_t v396 = 4;
              int v397 = 0;
              uint64_t v399 = (char *)v403;
              int v400 = (char *)v403;
              uint64_t v401 = 4;
              int v402 = 0;
              uint64_t v234 = (void *)*((void *)v200 + 5);
              if (v234 != (void *)((char *)v200 + 40))
              {
                if (v234) {
                  uint64_t v235 = v234 - 3;
                }
                else {
                  uint64_t v235 = 0;
                }
                int v236 = *((unsigned __int8 *)v235 + 16);
                int v237 = v236 - 29;
                if (v236 != 30)
                {
                  unsigned int v266 = 2;
                  switch(v237)
                  {
                    case 1:
LABEL_759:
                      __break(1u);
                      JUMPOUT(0x1CCDA530CLL);
                    case 2:
                      unsigned int v266 = (*((_DWORD *)v235 + 5) >> 1) & 0x3FFFFFF;
                      goto LABEL_713;
                    case 3:
                    case 9:
                      unsigned int v266 = (*((_DWORD *)v235 + 5) & 0x7FFFFFF) - 1;
                      goto LABEL_713;
                    case 4:
                      goto LABEL_451;
                    case 7:
                      unsigned int v266 = *((_WORD *)v235 + 9) & 1;
                      goto LABEL_713;
                    case 8:
                      unsigned int v266 = 1;
                      goto LABEL_451;
                    case 10:
                      unsigned int v266 = *((_DWORD *)v235 + 20) + 1;
LABEL_713:
                      if (!v266) {
                        goto LABEL_514;
                      }
                      goto LABEL_451;
                    default:
                      goto LABEL_514;
                  }
                }
                if ((*((_DWORD *)v235 + 5) & 0x7FFFFFF) == 3) {
                  unsigned int v266 = 2;
                }
                else {
                  unsigned int v266 = 1;
                }
LABEL_451:
                uint64_t v238 = 0;
                v239 = v235 + 4;
                uint64_t v240 = v235 - 4;
                uint64_t v18 = (uint64_t)(v235 - 8);
                unsigned int v241 = 4;
                uint64_t v19 = v266;
                while (2)
                {
                  int v242 = *((unsigned __int8 *)v235 + 16);
                  if (v242 == 30)
                  {
                    long long v259 = &v240[-4 * v238];
                  }
                  else
                  {
                    uint64_t v258 = (v242 - 31);
                    long long v259 = v240;
                    switch(v258)
                    {
                      case 1:
                      case 7:
                        int v263 = *((_DWORD *)v235 + 5);
                        if ((v263 & 0x40000000) != 0) {
                          unint64_t v264 = (void *)*(v235 - 1);
                        }
                        else {
                          unint64_t v264 = &v235[-4 * (v263 & 0x7FFFFFF)];
                        }
                        __int16 v262 = &v264[4 * v238];
                        goto LABEL_493;
                      case 2:
                        uint64_t v265 = 0x1FFFFFFFFFFFFFF8;
                        if (!v238) {
                          uint64_t v265 = 0x1FFFFFFFFFFFFFF4;
                        }
                        long long v259 = &v235[v265];
                        break;
                      case 3:
                      case 4:
                        goto LABEL_759;
                      case 5:
                        if ((*((_WORD *)v235 + 9) & 1) == 0)
                        {
                          uint64_t v243 = 0;
                          goto LABEL_456;
                        }
                        long long v259 = &v239[-4 * (*((_DWORD *)v235 + 5) & 0x7FFFFFF)];
                        break;
                      case 6:
                        break;
                      case 8:
                        long long v259 = (uint64_t *)(v18 - 32 * *((unsigned int *)v235 + 20));
                        if (v238) {
                          long long v259 = &v240[4 * (v238 - 1) + -4 * *((unsigned int *)v235 + 20)];
                        }
                        break;
                      default:
                        int v260 = *((_DWORD *)v235 + 5);
                        if ((v260 & 0x40000000) != 0) {
                          long long v261 = (void *)*(v235 - 1);
                        }
                        else {
                          long long v261 = &v235[-4 * (v260 & 0x7FFFFFF)];
                        }
                        __int16 v262 = &v261[8 * v238];
LABEL_493:
                        long long v259 = v262 + 4;
                        break;
                    }
                  }
                  uint64_t v243 = *v259;
LABEL_456:
                  unsigned int v244 = v395;
                  uint64_t v245 = HIDWORD(v396);
                  if (v395 == v394)
                  {
                    if (HIDWORD(v396))
                    {
                      char v246 = 0;
                      uint64_t v247 = 8 * HIDWORD(v396);
                      long long v248 = v395;
                      while (*(void *)v248 != v243)
                      {
                        if (*(void *)v248 == -2) {
                          char v246 = v248;
                        }
                        v248 += 8;
                        v247 -= 8;
                        if (!v247)
                        {
                          if (!v246) {
                            goto LABEL_464;
                          }
                          *(void *)char v246 = v243;
                          --v397;
                          goto LABEL_487;
                        }
                      }
                      goto LABEL_487;
                    }
LABEL_464:
                    if (HIDWORD(v396) < v241)
                    {
                      ++HIDWORD(v396);
                      *(void *)&v395[8 * v245] = v243;
                      goto LABEL_487;
                    }
                  }
                  if (3 * v241 <= 4 * (HIDWORD(v396) - v397))
                  {
                    if (v241 >= 0x40) {
                      v241 *= 2;
                    }
                    else {
                      unsigned int v241 = 128;
                    }
                  }
                  else if (v241 - HIDWORD(v396) >= v241 >> 3)
                  {
                    goto LABEL_468;
                  }
                  uint64_t v366 = v240;
                  unsigned int v368 = v239;
                  v363 = (llvm::OptimizationRemarkEmitter *)v19;
                  uint64_t v364 = v18;
                  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v394, v241);
                  uint64_t v19 = (uint64_t)v363;
                  uint64_t v18 = v364;
                  uint64_t v240 = v366;
                  v239 = v368;
                  unsigned int v241 = v396;
                  unsigned int v244 = v395;
LABEL_468:
                  unsigned int v249 = v241 - 1;
                  unsigned int v250 = (v241 - 1) & ((v243 >> 4) ^ (v243 >> 9));
                  unsigned int v251 = &v244[8 * v250];
                  uint64_t v252 = *(void *)v251;
                  if (*(void *)v251 == -1)
                  {
                    long long v256 = 0;
LABEL_479:
                    if (v256) {
                      long long v257 = v256;
                    }
                    else {
                      long long v257 = v251;
                    }
                    if (*(void *)v257 != v243)
                    {
                      if (*(void *)v257 == -2) {
                        --v397;
                      }
                      else {
                        ++HIDWORD(v396);
                      }
                      *(void *)long long v257 = v243;
                    }
                  }
                  else
                  {
                    long long v256 = 0;
                    int v253 = 1;
                    while (v252 != v243)
                    {
                      if (v256) {
                        BOOL v254 = 0;
                      }
                      else {
                        BOOL v254 = v252 == -2;
                      }
                      if (v254) {
                        long long v256 = v251;
                      }
                      unsigned int v255 = v250 + v253++;
                      unsigned int v250 = v255 & v249;
                      unsigned int v251 = &v244[8 * (v255 & v249)];
                      uint64_t v252 = *(void *)v251;
                      if (*(void *)v251 == -1) {
                        goto LABEL_479;
                      }
                    }
                  }
LABEL_487:
                  ++v238;
                  uint64_t v13 = (int32x2_t **)v371;
                  if (v238 == v19) {
                    break;
                  }
                  continue;
                }
              }
LABEL_514:
              v267 = (void *)*((void *)v201 + 5);
              if (v267 != (void *)((char *)v201 + 40))
              {
                if (v267) {
                  unint64_t v268 = v267 - 3;
                }
                else {
                  unint64_t v268 = 0;
                }
                int v269 = *((unsigned __int8 *)v268 + 16);
                int v270 = v269 - 29;
                if (v269 != 30)
                {
                  unsigned int v299 = 2;
                  switch(v270)
                  {
                    case 1:
                      goto LABEL_759;
                    case 2:
                      unsigned int v299 = (*((_DWORD *)v268 + 5) >> 1) & 0x3FFFFFF;
                      goto LABEL_716;
                    case 3:
                    case 9:
                      unsigned int v299 = (*((_DWORD *)v268 + 5) & 0x7FFFFFF) - 1;
                      goto LABEL_716;
                    case 4:
                      goto LABEL_523;
                    case 7:
                      unsigned int v299 = *((_WORD *)v268 + 9) & 1;
                      goto LABEL_716;
                    case 8:
                      unsigned int v299 = 1;
                      goto LABEL_523;
                    case 10:
                      unsigned int v299 = *((_DWORD *)v268 + 20) + 1;
LABEL_716:
                      if (!v299) {
                        goto LABEL_587;
                      }
                      goto LABEL_523;
                    default:
                      goto LABEL_587;
                  }
                }
                if ((*((_DWORD *)v268 + 5) & 0x7FFFFFF) == 3) {
                  unsigned int v299 = 2;
                }
                else {
                  unsigned int v299 = 1;
                }
LABEL_523:
                uint64_t v271 = 0;
                v272 = v268 + 4;
                uint64_t v273 = v268 - 4;
                uint64_t v18 = (uint64_t)(v268 - 8);
                uint64_t v19 = v299;
                while (1)
                {
                  int v274 = *((unsigned __int8 *)v268 + 16);
                  if (v274 == 30)
                  {
                    unint64_t v292 = &v273[-4 * v271];
                  }
                  else
                  {
                    uint64_t v291 = (v274 - 31);
                    unint64_t v292 = v273;
                    switch(v291)
                    {
                      case 1:
                      case 7:
                        int v296 = *((_DWORD *)v268 + 5);
                        if ((v296 & 0x40000000) != 0) {
                          v297 = (void *)*(v268 - 1);
                        }
                        else {
                          v297 = &v268[-4 * (v296 & 0x7FFFFFF)];
                        }
                        v295 = &v297[4 * v271];
                        goto LABEL_566;
                      case 2:
                        uint64_t v298 = 0x1FFFFFFFFFFFFFF8;
                        if (!v271) {
                          uint64_t v298 = 0x1FFFFFFFFFFFFFF4;
                        }
                        unint64_t v292 = &v268[v298];
                        break;
                      case 3:
                      case 4:
                        goto LABEL_759;
                      case 5:
                        if ((*((_WORD *)v268 + 9) & 1) == 0)
                        {
                          uint64_t v275 = 0;
                          goto LABEL_528;
                        }
                        unint64_t v292 = &v272[-4 * (*((_DWORD *)v268 + 5) & 0x7FFFFFF)];
                        break;
                      case 6:
                        break;
                      case 8:
                        unint64_t v292 = (uint64_t *)(v18 - 32 * *((unsigned int *)v268 + 20));
                        if (v271) {
                          unint64_t v292 = &v273[4 * (v271 - 1) + -4 * *((unsigned int *)v268 + 20)];
                        }
                        break;
                      default:
                        int v293 = *((_DWORD *)v268 + 5);
                        if ((v293 & 0x40000000) != 0) {
                          int v294 = (void *)*(v268 - 1);
                        }
                        else {
                          int v294 = &v268[-4 * (v293 & 0x7FFFFFF)];
                        }
                        v295 = &v294[8 * v271];
LABEL_566:
                        unint64_t v292 = v295 + 4;
                        break;
                    }
                  }
                  uint64_t v275 = *v292;
LABEL_528:
                  int v276 = v400;
                  uint64_t v277 = HIDWORD(v401);
                  if (v400 != v399) {
                    break;
                  }
                  if (HIDWORD(v401))
                  {
                    uint64_t v278 = 0;
                    uint64_t v279 = 8 * HIDWORD(v401);
                    v280 = v400;
                    while (*(void *)v280 != v275)
                    {
                      if (*(void *)v280 == -2) {
                        uint64_t v278 = v280;
                      }
                      v280 += 8;
                      v279 -= 8;
                      if (!v279)
                      {
                        if (!v278) {
                          goto LABEL_537;
                        }
                        *(void *)uint64_t v278 = v275;
                        --v402;
                        goto LABEL_560;
                      }
                    }
                    goto LABEL_560;
                  }
LABEL_537:
                  unsigned int v281 = v401;
                  if (HIDWORD(v401) >= v401) {
                    goto LABEL_539;
                  }
                  ++HIDWORD(v401);
                  *(void *)&v400[8 * v277] = v275;
LABEL_560:
                  ++v271;
                  uint64_t v13 = (int32x2_t **)v371;
                  if (v271 == v19) {
                    goto LABEL_587;
                  }
                }
                unsigned int v281 = v401;
LABEL_539:
                if (3 * v281 <= 4 * (HIDWORD(v401) - v402))
                {
                  if (v281 >= 0x40) {
                    v281 *= 2;
                  }
                  else {
                    unsigned int v281 = 128;
                  }
                }
                else if (v281 - HIDWORD(v401) >= v281 >> 3)
                {
                  goto LABEL_541;
                }
                uint64_t v367 = v273;
                int v369 = v272;
                v363 = (llvm::OptimizationRemarkEmitter *)v19;
                uint64_t v365 = v18;
                llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v399, v281);
                uint64_t v19 = (uint64_t)v363;
                uint64_t v18 = v365;
                uint64_t v273 = v367;
                v272 = v369;
                unsigned int v281 = v401;
                int v276 = v400;
LABEL_541:
                unsigned int v282 = v281 - 1;
                unsigned int v283 = (v281 - 1) & ((v275 >> 4) ^ (v275 >> 9));
                uint64_t v284 = &v276[8 * v283];
                uint64_t v285 = *(void *)v284;
                if (*(void *)v284 == -1)
                {
                  v289 = 0;
LABEL_552:
                  if (v289) {
                    v290 = v289;
                  }
                  else {
                    v290 = v284;
                  }
                  if (*(void *)v290 != v275)
                  {
                    if (*(void *)v290 == -2) {
                      --v402;
                    }
                    else {
                      ++HIDWORD(v401);
                    }
                    *(void *)v290 = v275;
                  }
                }
                else
                {
                  v289 = 0;
                  int v286 = 1;
                  while (v285 != v275)
                  {
                    if (v289) {
                      BOOL v287 = 0;
                    }
                    else {
                      BOOL v287 = v285 == -2;
                    }
                    if (v287) {
                      v289 = v284;
                    }
                    unsigned int v288 = v283 + v286++;
                    unsigned int v283 = v288 & v282;
                    uint64_t v284 = &v276[8 * (v288 & v282)];
                    uint64_t v285 = *(void *)v284;
                    if (*(void *)v284 == -1) {
                      goto LABEL_552;
                    }
                  }
                }
                goto LABEL_560;
              }
LABEL_587:
              uint64_t v300 = v394;
              if (v395 == v394)
              {
                int v301 = HIDWORD(v396);
                uint64_t v302 = &v395[8 * HIDWORD(v396)];
                if (HIDWORD(v396))
                {
                  uint64_t v303 = 0;
                  uint64_t v16 = v373;
                  while (*(const llvm::BasicBlock **)&v395[v303] != v201)
                  {
                    v303 += 8;
                    if (8 * HIDWORD(v396) == v303) {
                      goto LABEL_607;
                    }
                  }
                  uint64_t v302 = &v395[v303];
LABEL_607:
                  uint64_t v300 = v395;
                }
                else
                {
                  uint64_t v300 = v395;
                  uint64_t v16 = v373;
                }
              }
              else
              {
                int v304 = v396 - 1;
                unsigned int v305 = (v396 - 1) & ((v201 >> 4) ^ (v201 >> 9));
                uint64_t v302 = &v395[8 * v305];
                v306 = *(const llvm::BasicBlock **)v302;
                if (*(void *)v302 == -1)
                {
                  uint64_t v310 = 0;
                  uint64_t v16 = v373;
LABEL_609:
                  if (v310) {
                    uint64_t v302 = v310;
                  }
                  int v301 = HIDWORD(v396);
                  if (*(const llvm::BasicBlock **)v302 != v201) {
                    uint64_t v302 = &v395[8 * v396];
                  }
                }
                else
                {
                  uint64_t v310 = 0;
                  int v307 = 1;
                  uint64_t v16 = v373;
                  while (v306 != v201)
                  {
                    if (v310) {
                      BOOL v308 = 0;
                    }
                    else {
                      BOOL v308 = v306 == (const llvm::BasicBlock *)-2;
                    }
                    if (v308) {
                      uint64_t v310 = v302;
                    }
                    unsigned int v309 = v305 + v307++;
                    unsigned int v305 = v309 & v304;
                    uint64_t v302 = &v395[8 * (v309 & v304)];
                    v306 = *(const llvm::BasicBlock **)v302;
                    if (*(void *)v302 == -1) {
                      goto LABEL_609;
                    }
                  }
                  int v301 = HIDWORD(v396);
                }
              }
              if (v395 == v300) {
                int v311 = v301;
              }
              else {
                int v311 = v396;
              }
              if (v302 == &v395[8 * v311])
              {
                uint64_t v312 = v399;
                if (v400 == v399)
                {
                  int v313 = HIDWORD(v401);
                  v314 = &v400[8 * HIDWORD(v401)];
                  if (HIDWORD(v401))
                  {
                    uint64_t v315 = 0;
                    while (*(const llvm::BasicBlock **)&v400[v315] != v200)
                    {
                      v315 += 8;
                      if (8 * HIDWORD(v401) == v315) {
                        goto LABEL_637;
                      }
                    }
                    v314 = &v400[v315];
                  }
LABEL_637:
                  uint64_t v312 = v400;
                }
                else
                {
                  int v316 = v401 - 1;
                  unsigned int v317 = (v401 - 1) & ((v200 >> 4) ^ (v200 >> 9));
                  v314 = &v400[8 * v317];
                  unint64_t v318 = *(const llvm::BasicBlock **)v314;
                  if (*(void *)v314 == -1)
                  {
                    unsigned int v323 = 0;
LABEL_653:
                    if (v323) {
                      v314 = v323;
                    }
                    int v313 = HIDWORD(v401);
                    if (*(const llvm::BasicBlock **)v314 != v200) {
                      v314 = &v400[8 * v401];
                    }
                  }
                  else
                  {
                    unsigned int v323 = 0;
                    int v319 = 1;
                    while (v318 != v200)
                    {
                      if (v323) {
                        BOOL v320 = 0;
                      }
                      else {
                        BOOL v320 = v318 == (const llvm::BasicBlock *)-2;
                      }
                      if (v320) {
                        unsigned int v323 = v314;
                      }
                      unsigned int v321 = v317 + v319++;
                      unsigned int v317 = v321 & v316;
                      v314 = &v400[8 * (v321 & v316)];
                      unint64_t v318 = *(const llvm::BasicBlock **)v314;
                      if (*(void *)v314 == -1) {
                        goto LABEL_653;
                      }
                    }
                    int v313 = HIDWORD(v401);
                  }
                }
                if (v400 == v312) {
                  int v322 = v313;
                }
                else {
                  int v322 = v401;
                }
                if (v314 == &v400[8 * v322])
                {
                  sub_1CD76E044(&v394, &v399);
                  if (HIDWORD(v396) - v397 == 1)
                  {
                    uint64_t v324 = v395;
                    if (v395 == v394) {
                      uint64_t v325 = HIDWORD(v396);
                    }
                    else {
                      uint64_t v325 = v396;
                    }
                    if (v325)
                    {
                      uint64_t v326 = 8 * v325;
                      int v327 = &v395[8 * v325];
                      while (*(void *)v324 >= 0xFFFFFFFFFFFFFFFELL)
                      {
                        v324 += 8;
                        v326 -= 8;
                        if (!v326)
                        {
                          uint64_t v324 = v327;
                          break;
                        }
                      }
                    }
                    uint64_t v201 = *(const llvm::BasicBlock **)v324;
                    if (!*(void *)v324) {
                      goto LABEL_646;
                    }
LABEL_645:
                    llvm::DominatorTree::dominates(v385, (const llvm::Instruction *)v36, v201);
                  }
                  if (HIDWORD(v396) != v397)
                  {
                    uint64_t v328 = *((void *)v200 + 7);
                    uint64_t v329 = *(void *)(v328 + 80);
                    if (v329 == v328 + 72)
                    {
LABEL_711:
                      uint64_t v201 = (const llvm::BasicBlock *)(v328 + 48);
                    }
                    else
                    {
                      int v330 = v396 - 1;
                      if (v395 == v394) {
                        int v331 = HIDWORD(v396);
                      }
                      else {
                        int v331 = v396;
                      }
                      int v332 = (uint64_t *)&v395[8 * v331];
                      unsigned int v333 = HIDWORD(v396);
                      uint64_t v334 = v395;
                      while (1)
                      {
                        uint64_t v201 = (const llvm::BasicBlock *)(v329 - 24);
                        uint64_t v335 = v329 ? v329 - 24 : 0;
                        if (v334 == v394)
                        {
                          v336 = &v394[8 * v333];
                          if (v333)
                          {
                            uint64_t v337 = 0;
                            uint64_t v18 = 8 * v333;
                            while (1)
                            {
                              uint64_t v19 = *(void *)&v394[v337];
                              if (v19 == v335) {
                                break;
                              }
                              v337 += 8;
                              if (v18 == v337) {
                                goto LABEL_697;
                              }
                            }
                            v336 = &v394[v337];
                          }
LABEL_697:
                          uint64_t v334 = v394;
                        }
                        else
                        {
                          unsigned int v338 = v330 & ((v335 >> 4) ^ (v335 >> 9));
                          v339 = (uint64_t *)&v395[8 * v338];
                          uint64_t v18 = *v339;
                          if (*v339 == -1)
                          {
                            v340 = 0;
LABEL_699:
                            if (v340) {
                              v339 = v340;
                            }
                            uint64_t v343 = *v339;
                          }
                          else
                          {
                            v340 = 0;
                            uint64_t v19 = 1;
                            while (v18 != v335)
                            {
                              uint64_t v20 = -2;
                              if (v340) {
                                BOOL v341 = 0;
                              }
                              else {
                                BOOL v341 = v18 == -2;
                              }
                              if (v341) {
                                v340 = v339;
                              }
                              int v342 = v338 + v19;
                              uint64_t v19 = (v19 + 1);
                              unsigned int v338 = v342 & v330;
                              v339 = (uint64_t *)&v395[8 * (v342 & v330)];
                              uint64_t v18 = *v339;
                              if (*v339 == -1) {
                                goto LABEL_699;
                              }
                            }
                            uint64_t v343 = v335;
                          }
                          v336 = (const char *)(v343 == v335 ? v339 : v332);
                          unsigned int v333 = HIDWORD(v396);
                          uint64_t v334 = v395;
                        }
                        int v344 = v334 == v394 ? v333 : v396;
                        if (v336 != &v334[8 * v344]) {
                          break;
                        }
                        uint64_t v329 = *(void *)(v329 + 8);
                        if (v329 == v328 + 72) {
                          goto LABEL_711;
                        }
                      }
                      if (!v329) {
                        goto LABEL_646;
                      }
                    }
                    goto LABEL_645;
                  }
LABEL_646:
                  if (v400 != v399) {
                    free(v400);
                  }
                  if (v395 != v394) {
                    free(v395);
                  }
                  goto LABEL_650;
                }
                uint64_t v201 = v200;
              }
              if (v201) {
                goto LABEL_645;
              }
              goto LABEL_646;
            }
          }
LABEL_650:
          int v23 = v379;
LABEL_651:
          uint64_t v34 = v35;
        }
        while (v35 != v33);
      }
LABEL_729:
      unsigned int v22 = v375;
      if (v375 == v372) {
        goto LABEL_730;
      }
    }
    int v25 = *((_DWORD *)v370 + 4);
    if (v25)
    {
      uint64_t v26 = *(void *)v370;
      unsigned int v27 = v25 - 1;
      uint64_t v28 = (v25 - 1) & ((v24 >> 4) ^ (v24 >> 9));
      uint64_t v29 = *(void *)(*(void *)v370 + 16 * v28);
      if (v24 == v29)
      {
LABEL_9:
        int v32 = *(llvm::DominatorTree **)(v26 + 16 * v28 + 8);
        goto LABEL_11;
      }
      int v30 = 1;
      while (v29 != -4096)
      {
        int v31 = v28 + v30++;
        uint64_t v28 = v31 & v27;
        uint64_t v29 = *(void *)(v26 + 16 * v28);
        if (v24 == v29) {
          goto LABEL_9;
        }
      }
    }
    int v32 = 0;
LABEL_11:
    if (v32 != a7) {
      goto LABEL_729;
    }
    goto LABEL_12;
  }
LABEL_730:
  if (byte_1EBCF32E0 && v405)
  {
    uint64_t v345 = 0;
    unsigned int v346 = v404;
    uint64_t v347 = &v404[8 * v405];
    while (1)
    {
      v349 = (const llvm::Value *)*((void *)v347 - 1);
      v347 -= 8;
      v348 = v349;
      int v350 = (const llvm::Use *)*((void *)v349 + 1);
      if (v350) {
        break;
      }
LABEL_736:
      v348 = v345;
LABEL_753:
      uint64_t v345 = v348;
      if (v347 == v346) {
        goto LABEL_754;
      }
    }
    while ((llvm::DominatorTree::dominates((llvm::DominatorTree *)v16, v348, v350) & 1) != 0)
    {
      int v350 = (const llvm::Use *)*((void *)v350 + 1);
      if (!v350) {
        goto LABEL_736;
      }
    }
    uint64_t v351 = *(void *)(v16 + 24);
    uint64_t v352 = *(unsigned int *)(v16 + 40);
    if (v352)
    {
      uint64_t v353 = *((void *)v348 + 5);
      LODWORD(v354) = ((v353 >> 4) ^ (v353 >> 9)) & (v352 - 1);
      v355 = (uint64_t *)(v351 + 16 * v354);
      uint64_t v356 = *v355;
      if (v353 == *v355)
      {
LABEL_744:
        if (v345) {
          llvm::DominatorTreeBase<llvm::BasicBlock,false>::dominates();
        }
        uint64_t v359 = *(void *)(**(void **)(v355[1] + 8) + 40);
        if (v359) {
          uint64_t v360 = v359 - 24;
        }
        else {
          uint64_t v360 = 0;
        }
        if (*(unsigned __int8 *)(v360 + 16) - 29 >= 0xB) {
          unint64_t v361 = 0;
        }
        else {
          unint64_t v361 = (llvm::BasicBlock **)v360;
        }
        sub_1CCDA66E4(v348, v361, a10, v371, a9);
        LOBYTE(v23) = 1;
        goto LABEL_753;
      }
      int v357 = 1;
      while (v356 != -4096)
      {
        int v358 = v354 + v357++;
        uint64_t v354 = v358 & (v352 - 1);
        uint64_t v356 = *(void *)(v351 + 16 * v354);
        if (v353 == v356)
        {
          v355 = (uint64_t *)(v351 + 16 * v354);
          goto LABEL_744;
        }
      }
    }
    v355 = (uint64_t *)(v351 + 16 * v352);
    goto LABEL_744;
  }
LABEL_754:
  if (__p)
  {
    uint64_t v383 = __p;
    operator delete(__p);
  }
  MEMORY[0x1D25D9CD0](v381, 8);
  if (v404 != (char *)v406) {
    free(v404);
  }
  MEMORY[0x1D25D9CD0](v391, 8);
  MEMORY[0x1D25D9CD0](v388, 8);
  return v23 & 1;
}

uint64_t sub_1CCDA5404(uint64_t a1, uint64_t a2, uint64_t ***a3, uint64_t *a4)
{
  v45[34] = *MEMORY[0x1E4F143B8];
  llvm::Function::getEntryCount(*(uint64_t ****)(a2 + 56), 0, (uint64_t)&v35);
  if (!(_BYTE)v38) {
    return 1;
  }
  uint64_t result = 1;
  if (!a4) {
    return result;
  }
  if (!dword_1EBCF33A0) {
    return result;
  }
  uint64_t v9 = *a4;
  if (!*a4) {
    return result;
  }
  uint64_t v10 = *(void *)(a1 + 40);
  unsigned int v11 = sub_1CBF7A45C(*a4, a2);
  unint64_t v12 = v11 == -1 ? 0 : *(void *)(*(void *)(v9 + 8) + 24 * v11 + 16);
  uint64_t v13 = *a4;
  unint64_t v14 = v12 / dword_1EBCF33A0;
  if (!v13 || (unsigned int v15 = sub_1CBF7A45C(v13, v10), v15 == -1)) {
    unint64_t v16 = 0;
  }
  else {
    unint64_t v16 = *(void *)(*(void *)(v13 + 8) + 24 * v15 + 16);
  }
  if (v14 <= v16) {
    return 1;
  }
  uint64_t v17 = *(void *)***a3;
  if (*(void *)(v17 + 128)
    || (uint64_t result = (*(uint64_t (**)(void))(**(void **)(v17 + 72) + 48))(*(void *)(v17 + 72)),
        result))
  {
    llvm::OptimizationRemarkMissed::OptimizationRemarkMissed((uint64_t)&v35, (uint64_t)"licm", (uint64_t)"SinkHoistInst", 13, a1);
    int v25 = "failed to sink or hoist instruction because containing block has lower frequency than destination block";
    uint64_t v26 = 103;
    sub_1CC59ADEC((uint64_t *)&v43, (uint64_t)&v25);
    LODWORD(v26) = v36;
    BYTE4(v26) = v37;
    long long v27 = v38;
    uint64_t v28 = v39;
    int v25 = (const char *)&unk_1F2616800;
    long long v29 = v40;
    long long v30 = v41;
    uint64_t v31 = v42;
    int v32 = v34;
    uint64_t v33 = 0x400000000;
    unsigned int v18 = v44;
    if (v44)
    {
      sub_1CD494D68((uint64_t)&v32, (uint64_t)&v43);
      unsigned int v18 = v44;
    }
    v34[32] = v45[32];
    v34[33] = v45[33];
    int v25 = (const char *)&unk_1F26165A8;
    uint64_t v35 = &unk_1F2616800;
    uint64_t v19 = (char *)v43;
    if (v18)
    {
      unint64_t v20 = (unint64_t)v18 << 6;
      do
      {
        uint64_t v21 = (void **)&v19[v20];
        if (v19[v20 - 17] < 0) {
          operator delete(*(v21 - 5));
        }
        if (*((char *)v21 - 41) < 0) {
          operator delete(*(v21 - 8));
        }
        v20 -= 64;
      }
      while (v20);
      uint64_t v19 = (char *)v43;
    }
    if (v19 != (char *)v45) {
      free(v19);
    }
    llvm::OptimizationRemarkEmitter::emit(a3, (llvm::DiagnosticInfoOptimizationBase *)&v25);
    int v25 = (const char *)&unk_1F2616800;
    unsigned int v22 = (char *)v32;
    if (v33)
    {
      unint64_t v23 = (unint64_t)v33 << 6;
      do
      {
        uint64_t v24 = (void **)&v22[v23];
        if (v22[v23 - 17] < 0) {
          operator delete(*(v24 - 5));
        }
        if (*((char *)v24 - 41) < 0) {
          operator delete(*(v24 - 8));
        }
        v23 -= 64;
      }
      while (v23);
      unsigned int v22 = (char *)v32;
    }
    if (v22 != (char *)v34) {
      free(v22);
    }
    return 0;
  }
  return result;
}

uint64_t sub_1CCDA5750(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t ***a6, uint64_t *a7, int a8)
{
  v42[34] = *MEMORY[0x1E4F143B8];
  if (a8 && (llvm::isSafeToSpeculativelyExecute(a1, a7, a2, a3) & 1) != 0
    || ((*(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *, uint64_t))(*(void *)a5 + 24))(a5, a1, a2, a4) & 1) != 0)
  {
    return 1;
  }
  if (*(unsigned char *)(a1 + 16) != 60) {
    return 0;
  }
  uint64_t result = llvm::Loop::isLoopInvariant(a4, *(void *)(a1 - 32));
  if (result)
  {
    uint64_t v14 = *(void *)***a6;
    if (*(void *)(v14 + 128)
      || (uint64_t result = (*(uint64_t (**)(void))(**(void **)(v14 + 72) + 48))(*(void *)(v14 + 72)),
          result))
    {
      llvm::OptimizationRemarkMissed::OptimizationRemarkMissed((uint64_t)&v32, (uint64_t)"licm", (uint64_t)"LoadWithLoopInvariantAddressCondExecuted", 40, a1);
      unsigned int v22 = "failed to hoist load with loop-invariant address because load is conditionally executed";
      uint64_t v23 = 87;
      sub_1CC59ADEC((uint64_t *)&v40, (uint64_t)&v22);
      LODWORD(v23) = v33;
      BYTE4(v23) = v34;
      long long v24 = v35;
      uint64_t v25 = v36;
      unsigned int v22 = (const char *)&unk_1F2616800;
      long long v26 = v37;
      long long v27 = v38;
      uint64_t v28 = v39;
      long long v29 = v31;
      uint64_t v30 = 0x400000000;
      unsigned int v15 = v41;
      if (v41)
      {
        sub_1CD494D68((uint64_t)&v29, (uint64_t)&v40);
        unsigned int v15 = v41;
      }
      v31[32] = v42[32];
      v31[33] = v42[33];
      unsigned int v22 = (const char *)&unk_1F26165A8;
      int v32 = &unk_1F2616800;
      unint64_t v16 = (char *)v40;
      if (v15)
      {
        unint64_t v17 = (unint64_t)v15 << 6;
        do
        {
          unsigned int v18 = (void **)&v16[v17];
          if (v16[v17 - 17] < 0) {
            operator delete(*(v18 - 5));
          }
          if (*((char *)v18 - 41) < 0) {
            operator delete(*(v18 - 8));
          }
          v17 -= 64;
        }
        while (v17);
        unint64_t v16 = (char *)v40;
      }
      if (v16 != (char *)v42) {
        free(v16);
      }
      llvm::OptimizationRemarkEmitter::emit(a6, (llvm::DiagnosticInfoOptimizationBase *)&v22);
      unsigned int v22 = (const char *)&unk_1F2616800;
      uint64_t v19 = (char *)v29;
      if (v30)
      {
        unint64_t v20 = (unint64_t)v30 << 6;
        do
        {
          uint64_t v21 = (void **)&v19[v20];
          if (v19[v20 - 17] < 0) {
            operator delete(*(v21 - 5));
          }
          if (*((char *)v21 - 41) < 0) {
            operator delete(*(v21 - 8));
          }
          v20 -= 64;
        }
        while (v20);
        uint64_t v19 = (char *)v29;
      }
      if (v19 != (char *)v31) {
        free(v19);
      }
      return 0;
    }
  }
  return result;
}

unsigned __int8 **sub_1CCDA5A68(unsigned __int8 *a1, uint64_t a2, uint64_t a3, uint64_t a4, int32x2_t *a5, uint64_t *a6, llvm::ScalarEvolution *a7, uint64_t ***a8)
{
  v54[34] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = *(void *)***a8;
  if (*(void *)(v16 + 128)
    || (*(unsigned int (**)(void))(**(void **)(v16 + 72) + 48))(*(void *)(v16 + 72)))
  {
    llvm::OptimizationRemark::OptimizationRemark((uint64_t)v51, (uint64_t)"licm", (uint64_t)"Hoisted", 7, (uint64_t)a1);
    unsigned int v41 = "hoisting ";
    uint64_t v42 = 9;
    sub_1CC59ADEC((uint64_t *)&v52, (uint64_t)&v41);
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument((uint64_t)v37, "Inst", 4uLL, a1);
    uint64_t v24 = sub_1CD3D6290((uint64_t)v51, (long long *)v37);
    int v25 = *(_DWORD *)(v24 + 8);
    BYTE4(v42) = *(unsigned char *)(v24 + 12);
    LODWORD(v42) = v25;
    long long v26 = *(_OWORD *)(v24 + 16);
    uint64_t v44 = *(void *)(v24 + 32);
    long long v43 = v26;
    unsigned int v41 = (const char *)&unk_1F2616800;
    uint64_t v27 = *(void *)(v24 + 72);
    long long v28 = *(_OWORD *)(v24 + 56);
    long long v45 = *(_OWORD *)(v24 + 40);
    long long v46 = v28;
    uint64_t v47 = v27;
    int v48 = v50;
    uint64_t v49 = 0x400000000;
    if (*(_DWORD *)(v24 + 88)) {
      sub_1CD494D68((uint64_t)&v48, v24 + 80);
    }
    uint64_t v29 = *(void *)(v24 + 360);
    v50[32] = *(void *)(v24 + 352);
    v50[33] = v29;
    unsigned int v41 = (const char *)&unk_1F2616570;
    if (v40 < 0) {
      operator delete(__p);
    }
    if (v38 < 0) {
      operator delete(v37[0]);
    }
    v51[0] = &unk_1F2616800;
    uint64_t v30 = (char *)v52;
    if (v53)
    {
      unint64_t v31 = (unint64_t)v53 << 6;
      uint64_t v36 = (char *)v52;
      do
      {
        int v32 = (void **)&v30[v31];
        if (v30[v31 - 17] < 0)
        {
          operator delete(*(v32 - 5));
          uint64_t v30 = v36;
        }
        if (*((char *)v32 - 41) < 0)
        {
          operator delete(*(v32 - 8));
          uint64_t v30 = v36;
        }
        v31 -= 64;
      }
      while (v31);
      uint64_t v30 = (char *)v52;
    }
    if (v30 != (char *)v54) {
      free(v30);
    }
    llvm::OptimizationRemarkEmitter::emit(a8, (llvm::DiagnosticInfoOptimizationBase *)&v41);
    unsigned int v41 = (const char *)&unk_1F2616800;
    int v33 = (char *)v48;
    if (v49)
    {
      unint64_t v34 = (unint64_t)v49 << 6;
      do
      {
        long long v35 = (void **)&v33[v34];
        if (v33[v34 - 17] < 0) {
          operator delete(*(v35 - 5));
        }
        if (*((char *)v35 - 41) < 0) {
          operator delete(*(v35 - 8));
        }
        v34 -= 64;
      }
      while (v34);
      int v33 = (char *)v48;
    }
    if (v33 != (char *)v50) {
      free(v33);
    }
  }
  if ((a1[23] & 0x20) != 0 || (int v17 = a1[16], v17 == 84))
  {
    if (((*(uint64_t (**)(int32x2_t *, unsigned __int8 *, uint64_t, uint64_t))(*(void *)a5 + 24))(a5, a1, a2, a3) & 1) == 0)llvm::Instruction::dropUndefImplyingAttrsAndUnknownMetadata((uint64_t *)a1, 0, 0); {
    int v17 = a1[16];
    }
  }
  if (v17 == 83)
  {
    for (uint64_t i = *(void *)(a4 + 48); ; uint64_t i = *(void *)(i + 8))
    {
      uint64_t v19 = (llvm::BasicBlock **)(i - 24);
      uint64_t v20 = i ? i - 24 : 0;
      if (*(unsigned char *)(v20 + 16) != 83) {
        break;
      }
    }
  }
  else
  {
    uint64_t v21 = *(void *)(a4 + 40);
    if (v21) {
      uint64_t v22 = v21 - 24;
    }
    else {
      uint64_t v22 = 0;
    }
    if (*(unsigned __int8 *)(v22 + 16) - 29 >= 0xB) {
      uint64_t v19 = 0;
    }
    else {
      uint64_t v19 = (llvm::BasicBlock **)v22;
    }
  }
  sub_1CCDA66E4((llvm::Instruction *)a1, v19, a5, a6, a7);
  return llvm::Instruction::dropLocation((unsigned __int8 **)a1);
}

uint64_t sub_1CCDA5E30(uint64_t a1, uint64_t a2)
{
  v14[1] = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a2;
  if (!byte_1EBCF32E0) {
    llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopPredecessor();
  }
  __n128 v4 = (uint64_t *)(a1 + 32);
  uint64_t v12 = a2;
  v14[0] = 0;
  if (!sub_1CD3C8538((uint64_t *)(a1 + 32), &v12, v14))
  {
    uint64_t v5 = *(void *)(a1 + 56);
    uint64_t v6 = *(unsigned int *)(a1 + 72);
    char v7 = (void *)(v5 + 16 * v6);
    if (*(_DWORD *)(a1 + 64))
    {
      if (v6)
      {
        uint64_t v8 = 16 * v6;
        uint64_t v9 = *(void **)(a1 + 56);
        while ((*v9 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v9 += 2;
          v8 -= 16;
          if (!v8) {
            goto LABEL_10;
          }
        }
      }
      else
      {
        uint64_t v9 = *(void **)(a1 + 56);
      }
    }
    else
    {
LABEL_10:
      uint64_t v9 = (void *)(v5 + 16 * v6);
    }
    uint64_t v10 = (void *)(v5 + 16 * v6);
    while (v9 != v10)
    {
      if (v13 != v9[1] && (*(void *)(*v9 - 32) == v13 || *(void *)(*v9 - 64) == v13)) {
        break;
      }
      unsigned int v11 = v9 + 2;
      uint64_t v9 = v7;
      if (v11 != v7)
      {
        uint64_t v9 = v11;
        do
        {
          if ((*v9 | 0x1000) != 0xFFFFFFFFFFFFF000) {
            goto LABEL_21;
          }
          v9 += 2;
        }
        while (v9 != v7);
        uint64_t v9 = v7;
      }
LABEL_21:
      ;
    }
    llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopPredecessor();
  }
  return sub_1CC025000(v4, &v13)[1];
}

void sub_1CCDA66E4(llvm::Instruction *a1, llvm::BasicBlock **a2, int32x2_t *a3, uint64_t *a4, llvm::ScalarEvolution *a5)
{
  char v7 = a3;
  uint64_t v10 = (llvm::InstructionPrecedenceTracking *)&a3[5];
  llvm::InstructionPrecedenceTracking::removeInstruction(a3 + 5, a1);
  v7 += 9;
  llvm::InstructionPrecedenceTracking::removeInstruction(v7, a1);
  unsigned int v11 = a2[5];
  llvm::InstructionPrecedenceTracking::insertInstructionTo(v10, a1, v11);
  llvm::InstructionPrecedenceTracking::insertInstructionTo((llvm::InstructionPrecedenceTracking *)v7, a1, v11);
  llvm::Instruction::moveBefore(a1, (llvm::Instruction *)a2);
  int v12 = *(_DWORD *)(*a4 + 40);
  if (v12)
  {
    uint64_t v13 = *(void *)(*a4 + 24);
    unsigned int v14 = v12 - 1;
    uint64_t v15 = (v12 - 1) & ((a1 >> 4) ^ (a1 >> 9));
    uint64_t v16 = *(llvm::Instruction **)(v13 + 16 * v15);
    if (v16 == a1)
    {
LABEL_6:
      uint64_t v19 = *(void *)(v13 + 16 * v15 + 8);
      if (v19) {
        llvm::MemorySSAUpdater::moveToPlace(a4, v19, a2[5], 2);
      }
    }
    else
    {
      int v17 = 1;
      while (v16 != (llvm::Instruction *)-4096)
      {
        int v18 = v15 + v17++;
        uint64_t v15 = v18 & v14;
        uint64_t v16 = *(llvm::Instruction **)(v13 + 16 * v15);
        if (v16 == a1) {
          goto LABEL_6;
        }
      }
    }
  }
  if (a5)
  {
    llvm::ScalarEvolution::forgetValue(a5, a1);
  }
}

uint64_t sub_1CCDA6824(llvm::MemorySSA *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(unsigned char *)(a5 + 16))
  {
    if (*(unsigned char *)a5) {
      return 1;
    }
    uint64_t v13 = *(uint64_t **)(a3 + 32);
    uint64_t v14 = *(void *)(a3 + 40) - (void)v13;
    if (v14)
    {
      uint64_t v15 = 8 * (v14 >> 3);
      while ((sub_1CCDA9F54(*v13, this, a2) & 1) == 0)
      {
        ++v13;
        v15 -= 8;
        if (!v15) {
          goto LABEL_10;
        }
      }
      return 1;
    }
LABEL_10:
    uint64_t v16 = *(void *)(a4 + 40);
    uint64_t v18 = *(void *)(a3 + 56);
    uint64_t v17 = *(void *)(a3 + 64);
    if (v17 == v18)
    {
      uint64_t v19 = *(unsigned int *)(a3 + 76);
      uint64_t v20 = (void *)(v17 + 8 * v19);
      if (v19)
      {
        uint64_t v21 = 0;
        uint64_t v22 = 8 * v19;
        while (*(void *)(v17 + v21) != v16)
        {
          v21 += 8;
          if (v22 == v21) {
            goto LABEL_58;
          }
        }
        uint64_t v20 = (void *)(v17 + v21);
      }
LABEL_58:
      uint64_t v18 = *(void *)(a3 + 64);
    }
    else
    {
      uint64_t v40 = *(unsigned int *)(a3 + 72);
      int v41 = v40 - 1;
      unsigned int v42 = (v40 - 1) & ((v16 >> 4) ^ (v16 >> 9));
      uint64_t v20 = (void *)(v17 + 8 * v42);
      uint64_t v43 = *v20;
      if (*v20 == -1)
      {
        uint64_t v44 = 0;
LABEL_72:
        if (v44) {
          uint64_t v20 = v44;
        }
        if (*v20 != v16) {
          uint64_t v20 = (void *)(v17 + 8 * v40);
        }
      }
      else
      {
        uint64_t v44 = 0;
        int v45 = 1;
        while (v43 != v16)
        {
          if (v44) {
            BOOL v46 = 0;
          }
          else {
            BOOL v46 = v43 == -2;
          }
          if (v46) {
            uint64_t v44 = v20;
          }
          unsigned int v47 = v42 + v45++;
          unsigned int v42 = v47 & v41;
          uint64_t v20 = (void *)(v17 + 8 * (v47 & v41));
          uint64_t v43 = *v20;
          if (*v20 == -1) {
            goto LABEL_72;
          }
        }
      }
    }
    BOOL v38 = v17 == v18;
    uint64_t v49 = 72;
    if (v38) {
      uint64_t v49 = 76;
    }
    if (v20 != (void *)(v17 + 8 * *(unsigned int *)(a3 + v49))) {
      return 0;
    }
    return sub_1CCDA9F54(v16, this, a2);
  }
  else
  {
    if (*(_DWORD *)(a5 + 4) >= *(_DWORD *)(a5 + 8))
    {
      if (*(unsigned char *)(a2 + 16) == 25) {
        uint64_t v23 = a2;
      }
      else {
        uint64_t v23 = 0;
      }
      if (v23) {
        uint64_t v24 = (uint64_t *)(v23 - 32);
      }
      else {
        uint64_t v24 = (uint64_t *)(a2 - 64);
      }
      uint64_t v11 = *v24;
    }
    else
    {
      uint64_t SkipSelfWalker = llvm::MemorySSA::getSkipSelfWalker(this);
      uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)SkipSelfWalker + 16))(SkipSelfWalker, a2);
      ++*(_DWORD *)(a5 + 4);
    }
    if (*((void *)this + 12) == v11) {
      return 0;
    }
    uint64_t v25 = *(void *)(v11 + 64);
    uint64_t v27 = *(void *)(a3 + 56);
    uint64_t v26 = *(void *)(a3 + 64);
    if (v26 == v27)
    {
      uint64_t v28 = *(unsigned int *)(a3 + 76);
      uint64_t v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v25)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_53;
          }
        }
        uint64_t v29 = (void *)(v26 + v30);
      }
LABEL_53:
      uint64_t v27 = *(void *)(a3 + 64);
    }
    else
    {
      uint64_t v32 = *(unsigned int *)(a3 + 72);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v25 >> 4) ^ (v25 >> 9));
      uint64_t v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        uint64_t v36 = 0;
LABEL_67:
        if (v36) {
          uint64_t v29 = v36;
        }
        if (*v29 != v25) {
          uint64_t v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        uint64_t v36 = 0;
        int v37 = 1;
        while (v35 != v25)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            uint64_t v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          uint64_t v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_67;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v48 = 72;
    if (v38) {
      uint64_t v48 = 76;
    }
    return v29 != (void *)(v26 + 8 * *(unsigned int *)(a3 + v48));
  }
}

uint64_t sub_1CCDA6B34(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  if (a3 == a2) {
    return 1;
  }
  uint64_t v4 = *(void *)(a4 + 48);
  uint64_t v5 = *(unsigned int *)(a4 + 64);
  unsigned int v6 = v5 - 1;
  while (1)
  {
    if (v5)
    {
      LODWORD(v7) = ((*a2 >> 4) ^ (*a2 >> 9)) & v6;
      uint64_t v8 = (uint64_t *)(v4 + 16 * v7);
      uint64_t v9 = *v8;
      if (*a2 != *v8)
      {
        int v10 = 1;
        do
        {
          if (v9 == -4096) {
            goto LABEL_22;
          }
          int v11 = v7 + v10++;
          uint64_t v7 = v11 & v6;
          uint64_t v9 = *(void *)(v4 + 16 * v7);
        }
        while (*a2 != v9);
        uint64_t v8 = (uint64_t *)(v4 + 16 * v7);
      }
      if (v8 != (uint64_t *)(v4 + 16 * v5))
      {
        uint64_t v12 = v8[1];
        if (v12)
        {
          uint64_t v13 = *(void *)(v12 + 8);
          if (v13 != v12) {
            break;
          }
        }
      }
    }
LABEL_22:
    if (++a2 == a3) {
      return 1;
    }
  }
  int v14 = 0;
  while (1)
  {
    uint64_t v15 = v13 - 32;
    if (!v13) {
      uint64_t v15 = 0;
    }
    if (*(unsigned char *)(v15 + 16) == 27) {
      goto LABEL_21;
    }
    if (*(void *)(v15 + 72) != a1 || v14 == 1) {
      return 0;
    }
    ++v14;
LABEL_21:
    uint64_t v13 = *(void *)(v13 + 8);
    if (v13 == v12) {
      goto LABEL_22;
    }
  }
}

void llvm::promoteLoopAccessesToScalars()
{
}

uint64_t sub_1CCDA7E94(llvm *a1, uint64_t a2, llvm::Instruction *a3)
{
  uint64_t v3 = *(void *)(a2 + 40);
  if (v3 == a2 + 40)
  {
    uint64_t v5 = 0;
  }
  else
  {
    if (v3) {
      uint64_t v4 = v3 - 24;
    }
    else {
      uint64_t v4 = 0;
    }
    if (*(unsigned __int8 *)(v4 + 16) - 29 >= 0xB) {
      uint64_t v5 = 0;
    }
    else {
      uint64_t v5 = v4;
    }
  }
  return llvm::PointerMayBeCapturedBefore(a1, (const llvm::Value *)1, 1, v5, a3, 0, 0, 0, vars0) ^ 1;
}

void *sub_1CCDA7EF8(void *a1)
{
  *a1 = &unk_1F263E7B8;
  int v2 = (unsigned __int8 *)a1[10];
  if (v2)
  {
    int v3 = *v2;
    if ((v3 - 4) > 0x1E)
    {
      if ((v3 - 3) >= 0xFFFFFFFE) {
        uint64_t v5 = a1[10];
      }
      else {
        uint64_t v5 = 0;
      }
      if ((v3 - 3) >= 0xFFFFFFFE)
      {
        unint64_t v6 = v5 + 8;
LABEL_11:
        uint64_t v8 = a1 + 10;
        sub_1CC5FA668(v6 + 16, &v8);
        return a1;
      }
      if (v3 == 3) {
        *((void *)v2 + 1) = 0;
      }
    }
    else if ((v2[1] & 0x7F) == 2 || *((_DWORD *)v2 + 3))
    {
      uint64_t v7 = *((void *)v2 + 2);
      if ((v7 & 4) != 0)
      {
        unint64_t v6 = v7 & 0xFFFFFFFFFFFFFFF8;
        if (v6) {
          goto LABEL_11;
        }
      }
    }
  }
  return a1;
}

void sub_1CCDA7FC0()
{
}

void sub_1CCDA8014(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCDA804C(uint64_t a1, llvm *a2)
{
  uint64_t v3 = (uint64_t)a2 + 112;
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, v3, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::TargetLibraryInfoWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::MemorySSAWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, v3, (uint64_t)&llvm::MemorySSAWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
  llvm::getLoopAnalysisUsage(a2, v4);
  llvm::LazyBlockFrequencyInfoPass::getLazyBFIAnalysisUsage(a2, v5);
  sub_1CB843600((uint64_t)a2, v3, (uint64_t)llvm::LazyBlockFrequencyInfoPass::ID);

  sub_1CB843600((uint64_t)a2, v3, (uint64_t)&llvm::LazyBranchProbabilityInfoPass::ID);
}

uint64_t sub_1CCDA8134(llvm::LoopPass *a1, const llvm::Loop *a2)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  if ((llvm::LoopPass::skipLoop(a1, a2) & 1) == 0)
  {
    uint64_t v4 = *(llvm::Module **)(*(void *)(**((void **)a2 + 4) + 56) + 40);
    *(void *)&long long v52 = "agx.reduce.reg.pressure";
    LOWORD(v54) = 259;
    uint64_t NamedMetadata = llvm::Module::getNamedMetadata(v4, (const char **)&v52);
    if (!NamedMetadata) {
      goto LABEL_7;
    }
    uint64_t v6 = *(void *)(*(void *)(***(void ***)(NamedMetadata + 48)
                               - 8 * *(unsigned int *)(***(void ***)(NamedMetadata + 48) + 8))
                   + 128);
    uint64_t v7 = (void *)(v6 + 24);
    if (*(_DWORD *)(v6 + 32) >= 0x41u) {
      uint64_t v7 = (void *)*v7;
    }
    if (!*v7)
    {
LABEL_7:
      uint64_t v8 = (uint64_t *)*((void *)a1 + 1);
      uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass((llvm::PMDataManager *)v8[3], llvm::ScalarEvolutionWrapperPass::ID, 1);
      if (AnalysisPass)
      {
        (*(void (**)(uint64_t, char *))(*(void *)AnalysisPass + 96))(AnalysisPass, llvm::ScalarEvolutionWrapperPass::ID);
        uint64_t v8 = (uint64_t *)*((void *)a1 + 1);
      }
      uint64_t v10 = *v8;
      uint64_t v11 = v8[1];
      if (*v8 == v11)
      {
LABEL_12:
        uint64_t v12 = 0;
      }
      else
      {
        while (*(_UNKNOWN **)v10 != &llvm::MemorySSAWrapperPass::ID)
        {
          v10 += 16;
          if (v10 == v11) {
            goto LABEL_12;
          }
        }
        uint64_t v12 = *(void *)(v10 + 8);
      }
      (*(void (**)(uint64_t, void *))(*(void *)v12 + 96))(v12, &llvm::MemorySSAWrapperPass::ID);
      llvm::Function::getEntryCount(*(uint64_t ****)(**((void **)a2 + 4) + 56), 0, (uint64_t)&v52);
      if ((_BYTE)v53)
      {
        int v33 = (uint64_t *)*((void *)a1 + 1);
        uint64_t v34 = *v33;
        uint64_t v35 = v33[1];
        if (v34 == v35)
        {
LABEL_40:
          uint64_t v36 = 0;
        }
        else
        {
          while (*(char **)v34 != llvm::LazyBlockFrequencyInfoPass::ID)
          {
            v34 += 16;
            if (v34 == v35) {
              goto LABEL_40;
            }
          }
          uint64_t v36 = *(void *)(v34 + 8);
        }
        uint64_t v37 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v36 + 96))(v36, llvm::LazyBlockFrequencyInfoPass::ID);
        sub_1CD499004((llvm::BlockFrequencyInfo *)(v37 + 32));
      }
      llvm::OptimizationRemarkEmitter::OptimizationRemarkEmitter(v40, *(const llvm::Function **)(**((void **)a2 + 4) + 56));
      uint64_t v13 = (uint64_t *)*((void *)a1 + 1);
      uint64_t v14 = *v13;
      uint64_t v15 = v13[1];
      if (v14 == v15)
      {
LABEL_18:
        uint64_t v16 = 0;
      }
      else
      {
        while (*(char **)v14 != llvm::AAResultsWrapperPass::ID)
        {
          v14 += 16;
          if (v14 == v15) {
            goto LABEL_18;
          }
        }
        uint64_t v16 = *(void *)(v14 + 8);
      }
      (*(void (**)(uint64_t, char *))(*(void *)v16 + 96))(v16, llvm::AAResultsWrapperPass::ID);
      uint64_t v17 = (uint64_t *)*((void *)a1 + 1);
      uint64_t v18 = *v17;
      uint64_t v19 = v17[1];
      if (v18 == v19)
      {
LABEL_23:
        uint64_t v20 = 0;
      }
      else
      {
        while (*(_UNKNOWN **)v18 != &llvm::LoopInfoWrapperPass::ID)
        {
          v18 += 16;
          if (v18 == v19) {
            goto LABEL_23;
          }
        }
        uint64_t v20 = *(void *)(v18 + 8);
      }
      (*(void (**)(uint64_t, void *))(*(void *)v20 + 96))(v20, &llvm::LoopInfoWrapperPass::ID);
      uint64_t v21 = (uint64_t *)*((void *)a1 + 1);
      uint64_t v22 = *v21;
      uint64_t v23 = v21[1];
      if (v22 == v23)
      {
LABEL_28:
        uint64_t v24 = 0;
      }
      else
      {
        while (*(_UNKNOWN **)v22 != &llvm::DominatorTreeWrapperPass::ID)
        {
          v22 += 16;
          if (v22 == v23) {
            goto LABEL_28;
          }
        }
        uint64_t v24 = *(void *)(v22 + 8);
      }
      (*(void (**)(uint64_t, void *))(*(void *)v24 + 96))(v24, &llvm::DominatorTreeWrapperPass::ID);
      uint64_t v25 = (uint64_t *)*((void *)a1 + 1);
      uint64_t v26 = *v25;
      uint64_t v27 = v25[1];
      if (v26 == v27)
      {
LABEL_33:
        uint64_t v28 = 0;
      }
      else
      {
        while (*(char **)v26 != llvm::TargetLibraryInfoWrapperPass::ID)
        {
          v26 += 16;
          if (v26 == v27) {
            goto LABEL_33;
          }
        }
        uint64_t v28 = *(void *)(v26 + 8);
      }
      uint64_t v29 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v28 + 96))(v28, llvm::TargetLibraryInfoWrapperPass::ID);
      uint64_t v30 = *(void *)(**((void **)a2 + 4) + 56);
      v40[3] = 0;
      v40[4] = 0;
      int v41 = 0;
      uint64_t v42 = 0;
      uint64_t v43 = 0;
      int v44 = 0;
      uint64_t v45 = 0;
      uint64_t v46 = 0;
      int v47 = 0;
      uint64_t v31 = v29 + 32;
      if (!*(unsigned char *)(v29 + 232))
      {
        uint64_t v38 = *(void *)(v30 + 40) + 216;
        __int16 v49 = 260;
        v48[0] = v38;
        llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v48);
        uint64_t v59 = 0;
        uint64_t v60 = 0;
        int v61 = 0;
        long long v62 = 0u;
        long long v63 = 0u;
        long long v64 = 0u;
        *(void *)&long long v39 = -1;
        *((void *)&v39 + 1) = -1;
        long long v52 = v39;
        long long v53 = v39;
        long long v54 = v39;
        long long v55 = v39;
        long long v56 = v39;
        long long v57 = v39;
        *(_OWORD *)uint64_t v58 = v39;
        *(void *)&v58[13] = -1;
        sub_1CC153974((uint64_t)&v52, (int *)__p);
        sub_1CD4D04B8(v31, (uint64_t)&v52);
        sub_1CD4CFA4C((uint64_t *)&v52);
        if (v51 < 0) {
          operator delete(__p[0]);
        }
      }
      sub_1CC1569E8(&v52, v31);
    }
  }
  return 0;
}

uint64_t sub_1CCDA88F8(uint64_t result, void *a2, void *a3, uint64_t (*a4)(uint64_t, void), uint64_t a5)
{
  if (a3 != a2)
  {
    uint64_t v8 = a2;
    uint64_t v9 = result;
    do
    {
      uint64_t v10 = *(void *)(v9 + 48);
      uint64_t v11 = *(unsigned int *)(v9 + 64);
      if (v11)
      {
        LODWORD(v12) = ((*v8 >> 4) ^ (*v8 >> 9)) & (v11 - 1);
        uint64_t v13 = (uint64_t *)(v10 + 16 * v12);
        uint64_t v14 = *v13;
        if (*v8 == *v13) {
          goto LABEL_10;
        }
        int v15 = 1;
        while (v14 != -4096)
        {
          int v16 = v12 + v15++;
          uint64_t v12 = v16 & (v11 - 1);
          uint64_t v14 = *(void *)(v10 + 16 * v12);
          if (*v8 == v14)
          {
            uint64_t v13 = (uint64_t *)(v10 + 16 * v12);
            goto LABEL_10;
          }
        }
      }
      uint64_t v13 = (uint64_t *)(v10 + 16 * v11);
LABEL_10:
      if (v13 != (uint64_t *)(v10 + 16 * v11))
      {
        uint64_t v17 = v13[1];
        if (v17)
        {
          for (uint64_t i = *(void *)(v17 + 8); i != v17; uint64_t i = *(void *)(i + 8))
          {
            if (i)
            {
              if (*(unsigned __int8 *)(i - 16) - 27 >= 0xFFFFFFFE) {
                uint64_t result = a4(a5, *(void *)(i + 40));
              }
            }
          }
        }
      }
      ++v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t **sub_1CCDA8A10(uint64_t **result, unsigned __int8 *a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *result;
  int v5 = a2[16];
  if (a2 && v5 == 61)
  {
    uint64_t result = (uint64_t **)llvm::Loop::isLoopInvariant(*v4, *((void *)a2 - 4));
    if ((result & 1) == 0) {
      return result;
    }
  }
  else
  {
    if (v5 != 60) {
      return result;
    }
    uint64_t result = (uint64_t **)llvm::Loop::isLoopInvariant(*v4, *((void *)a2 - 4));
    if (!result) {
      return result;
    }
  }
  uint64_t v6 = v3[1];
  uint64_t v7 = v6[1];
  uint64_t v8 = *((unsigned int *)v6 + 5);
  if (v7 != *v6)
  {
    unsigned int v12 = *((_DWORD *)v6 + 4);
    goto LABEL_19;
  }
  if (v8)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 8 * v8;
    uint64_t v11 = (unsigned __int8 **)v6[1];
    while (*v11 != a2)
    {
      if (*v11 == (unsigned __int8 *)-2) {
        uint64_t v9 = v11;
      }
      ++v11;
      v10 -= 8;
      if (!v10)
      {
        if (!v9) {
          goto LABEL_15;
        }
        *uint64_t v9 = a2;
        --*((_DWORD *)v6 + 6);
        goto LABEL_40;
      }
    }
    goto LABEL_40;
  }
LABEL_15:
  unsigned int v12 = *((_DWORD *)v6 + 4);
  if (v8 >= v12)
  {
LABEL_19:
    if (3 * v12 <= 4 * ((int)v8 - *((_DWORD *)v6 + 6)))
    {
      if (v12 >= 0x40) {
        v12 *= 2;
      }
      else {
        unsigned int v12 = 128;
      }
    }
    else if (v12 - v8 >= v12 >> 3)
    {
      goto LABEL_21;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v3[1], v12);
    unsigned int v12 = *((_DWORD *)v6 + 4);
    uint64_t v7 = v6[1];
LABEL_21:
    unsigned int v13 = v12 - 1;
    unsigned int v14 = (v12 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    int v15 = (unsigned __int8 **)(v7 + 8 * v14);
    int v16 = *v15;
    if (*v15 == (unsigned __int8 *)-1)
    {
      uint64_t v17 = 0;
LABEL_33:
      if (v17) {
        uint64_t v21 = v17;
      }
      else {
        uint64_t v21 = v15;
      }
      if (*v21 != a2)
      {
        if (*v21 == (unsigned __int8 *)-2) {
          --*((_DWORD *)v6 + 6);
        }
        else {
          ++*((_DWORD *)v6 + 5);
        }
        *uint64_t v21 = a2;
      }
    }
    else
    {
      uint64_t v17 = 0;
      int v18 = 1;
      while (v16 != a2)
      {
        if (v17) {
          BOOL v19 = 0;
        }
        else {
          BOOL v19 = v16 == (unsigned __int8 *)-2;
        }
        if (v19) {
          uint64_t v17 = v15;
        }
        unsigned int v20 = v14 + v18++;
        unsigned int v14 = v20 & v13;
        int v15 = (unsigned __int8 **)(v7 + 8 * (v20 & v13));
        int v16 = *v15;
        if (*v15 == (unsigned __int8 *)-1) {
          goto LABEL_33;
        }
      }
    }
    goto LABEL_40;
  }
  *((_DWORD *)v6 + 5) = v8 + 1;
  *(void *)(v7 + 8 * v8) = a2;
LABEL_40:
  uint64_t v22 = (llvm::AliasSetTracker *)v3[2];

  return (uint64_t **)llvm::AliasSetTracker::add(v22, (llvm::Instruction *)a2);
}

uint64_t **sub_1CCDA8C04(uint64_t **result, llvm::Instruction *a2)
{
  uint64_t v3 = *result;
  uint64_t v5 = **result;
  uint64_t v4 = (*result)[1];
  if (v4 == v5)
  {
    uint64_t v6 = *((unsigned int *)v3 + 5);
    uint64_t v7 = (llvm::Instruction **)(v4 + 8 * v6);
    if (v6)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 8 * v6;
      while (*(llvm::Instruction **)(v4 + v8) != a2)
      {
        v8 += 8;
        if (v9 == v8) {
          goto LABEL_19;
        }
      }
      uint64_t v7 = (llvm::Instruction **)(v4 + v8);
    }
LABEL_19:
    uint64_t v5 = (*result)[1];
  }
  else
  {
    uint64_t v10 = *((unsigned int *)v3 + 4);
    int v11 = v10 - 1;
    unsigned int v12 = (v10 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v7 = (llvm::Instruction **)(v4 + 8 * v12);
    unsigned int v13 = *v7;
    if (*v7 == (llvm::Instruction *)-1)
    {
      unsigned int v14 = 0;
LABEL_38:
      if (v14) {
        uint64_t v7 = v14;
      }
      if (*v7 != a2) {
        uint64_t v7 = (llvm::Instruction **)(v4 + 8 * v10);
      }
    }
    else
    {
      unsigned int v14 = 0;
      int v15 = 1;
      while (v13 != a2)
      {
        if (v14) {
          BOOL v16 = 0;
        }
        else {
          BOOL v16 = v13 == (llvm::Instruction *)-2;
        }
        if (v16) {
          unsigned int v14 = v7;
        }
        unsigned int v17 = v12 + v15++;
        unsigned int v12 = v17 & v11;
        uint64_t v7 = (llvm::Instruction **)(v4 + 8 * (v17 & v11));
        unsigned int v13 = *v7;
        if (*v7 == (llvm::Instruction *)-1) {
          goto LABEL_38;
        }
      }
    }
  }
  BOOL v16 = v4 == v5;
  uint64_t v18 = 16;
  if (v16) {
    uint64_t v18 = 20;
  }
  if (v7 == (llvm::Instruction **)(v4 + 8 * *(unsigned int *)((char *)v3 + v18)))
  {
    BOOL v19 = result[1];
    unsigned int v20 = (llvm::AliasSet **)*v19;
    uint64_t v21 = *((unsigned int *)v19 + 2);
    if (!v21) {
      goto LABEL_34;
    }
    uint64_t v22 = (llvm::AAResults **)result[2];
    uint64_t v23 = &v20[v21];
    uint64_t v24 = 8 * v21 - 8;
    uint64_t v25 = (llvm::AliasSet **)*v19;
    do
    {
      uint64_t v26 = *v25++;
      uint64_t result = (uint64_t **)llvm::AliasSet::aliasesUnknownInst(v26, a2, *v22);
      if (result) {
        break;
      }
      v24 -= 8;
      unsigned int v20 = v25;
    }
    while (v25 != v23);
    if (v25 == v23)
    {
LABEL_34:
      uint64_t v23 = v20;
    }
    else
    {
      uint64_t v27 = 1;
      uint64_t v23 = v20;
      do
      {
        uint64_t result = (uint64_t **)llvm::AliasSet::aliasesUnknownInst(v20[v27], a2, *v22);
        if ((result & 1) == 0) {
          *v23++ = v20[v27];
        }
        ++v27;
        v24 -= 8;
      }
      while (v24);
    }
    *((_DWORD *)v19 + 2) = ((unint64_t)v23 - *v19) >> 3;
  }
  return result;
}

void sub_1CCDA8DC4(char **a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *((unsigned int *)a1 + 3);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  uint64_t v6 = (char *)malloc_type_malloc(152 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v7 = v6;
  uint64_t v8 = *a1;
  unsigned int v9 = *((_DWORD *)a1 + 2);
  if (v9)
  {
    uint64_t v10 = 152 * v9;
    do
    {
      uint64_t v11 = sub_1CCDA8F1C((uint64_t)v6, (uint64_t)v8);
      v8 += 152;
      uint64_t v6 = (char *)(v11 + 152);
      v10 -= 152;
    }
    while (v10);
    uint64_t v8 = *a1;
    unsigned int v12 = *((_DWORD *)a1 + 2);
    if (v12)
    {
      uint64_t v13 = 152 * v12;
      do
      {
        unsigned int v14 = &v8[v13];
        int v15 = *(char **)&v8[v13 - 80];
        if (&v8[v13 - 64] != v15)
        {
          free(v15);
          unsigned int v14 = &v8[v13];
        }
        if ((*(v14 - 152) & 1) == 0) {
          MEMORY[0x1D25D9CD0](*(void *)&v8[v13 - 144], 8);
        }
        v13 -= 152;
      }
      while (v13);
      uint64_t v8 = *a1;
    }
  }
  if (v8 != (char *)(a1 + 2)) {
    free(v8);
  }
  *a1 = v7;
  *((_DWORD *)a1 + 3) = v5;
}

uint64_t sub_1CCDA8F1C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 1;
  int64x2_t v4 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  *(int64x2_t *)(a1 + 8) = v4;
  *(int64x2_t *)(a1 + 24) = v4;
  *(int64x2_t *)(a1 + 40) = v4;
  *(int64x2_t *)(a1 + 56) = v4;
  sub_1CCDA9018((unsigned int *)a1, (unsigned int *)a2);
  *(void *)(a1 + 72) = a1 + 88;
  uint64_t v5 = (void **)(a1 + 72);
  *(void *)(a1 + 80) = 0x800000000;
  unsigned int v6 = *(_DWORD *)(a2 + 80);
  if (v6 && v5 != (void **)(a2 + 72))
  {
    uint64_t v7 = *(void *)(a2 + 72);
    if (v7 == a2 + 88)
    {
      if (v6 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(*v5, *(const void **)(a2 + 72), 8 * *(unsigned int *)(a2 + 80));
      *(_DWORD *)(a1 + 80) = v6;
    }
    else
    {
      *(void *)(a1 + 72) = v7;
      int v9 = *(_DWORD *)(a2 + 84);
      *(_DWORD *)(a1 + 80) = v6;
      *(_DWORD *)(a1 + 84) = v9;
      *(void *)(a2 + 72) = a2 + 88;
      *(_DWORD *)(a2 + 84) = 0;
    }
    *(_DWORD *)(a2 + 80) = 0;
  }
  return a1;
}

unsigned int *sub_1CCDA9018(unsigned int *result, unsigned int *a2)
{
  unsigned int v2 = *a2;
  *a2 = *result & 0xFFFFFFFE | *a2 & 1;
  unsigned int v3 = result[1];
  void *result = v2 & 0xFFFFFFFE | *result & 1;
  result[1] = a2[1];
  a2[1] = v3;
  unsigned int v4 = *a2;
  if (*result)
  {
    if (v4)
    {
      uint64_t v5 = 0;
      unsigned int v6 = (int *)(result + 2);
      uint64_t v7 = (int *)(a2 + 2);
      do
      {
        uint64_t v8 = *(void *)&v6[v5];
        *(void *)&v6[v5] = *(void *)&v7[v5];
        *(void *)&v7[v5] = v8;
        v5 += 2;
      }
      while (v5 != 16);
      return result;
    }
    int v9 = a2;
  }
  else
  {
    if ((v4 & 1) == 0)
    {
      uint64_t v11 = *((void *)result + 1);
      *((void *)result + 1) = *((void *)a2 + 1);
      *((void *)a2 + 1) = v11;
      LODWORD(v11) = result[4];
      result[4] = a2[4];
      a2[4] = v11;
      return result;
    }
    unsigned int v4 = *result;
    int v9 = result;
    uint64_t result = a2;
  }
  long long v12 = *(_OWORD *)(v9 + 2);
  *int v9 = v4 | 1;
  for (uint64_t i = 2; i != 18; i += 2)
    *(void *)&v9[i] = *(void *)&result[i];
  *result &= ~1u;
  *(_OWORD *)(result + 2) = v12;
  return result;
}

char **sub_1CCDA9104(char **a1)
{
  unsigned int v2 = *a1;
  unsigned int v3 = *((_DWORD *)a1 + 2);
  if (v3)
  {
    uint64_t v5 = 152 * v3;
    do
    {
      unsigned int v6 = *(char **)&v2[v5 - 80];
      if (&v2[v5 - 64] != v6) {
        free(v6);
      }
      if ((v2[v5 - 152] & 1) == 0) {
        MEMORY[0x1D25D9CD0](*(void *)&v2[v5 - 144], 8);
      }
      v5 -= 152;
    }
    while (v5);
    unsigned int v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CCDA91A4(void *a1, uint64_t ***a2)
{
  BOOL v19 = a2;
  uint64_t v20 = 0;
  unsigned int v3 = (uint64_t *)(*a1 + 32);
  v17[0] = a2;
  if (!sub_1CD3C8538(v3, v17, &v20))
  {
    if ((*((unsigned char *)a2 + 23) & 0x10) != 0)
    {
      uint64_t v4 = ***a2;
      uint64_t v5 = *(void *)(v4 + 152);
      uint64_t v6 = *(unsigned int *)(v4 + 168);
      if (v6)
      {
        LODWORD(v7) = (v6 - 1) & ((a2 >> 4) ^ (a2 >> 9));
        uint64_t v8 = (uint64_t ****)(v5 + 16 * v7);
        int v9 = *v8;
        if (*v8 != a2)
        {
          int v10 = 1;
          do
          {
            if (v9 == (uint64_t ***)-4096) {
              goto LABEL_10;
            }
            int v11 = v7 + v10++;
            uint64_t v7 = v11 & (v6 - 1);
            int v9 = *(uint64_t ****)(v5 + 16 * v7);
          }
          while (v9 != a2);
          uint64_t v8 = (uint64_t ****)(v5 + 16 * v7);
        }
      }
      else
      {
LABEL_10:
        uint64_t v8 = (uint64_t ****)(v5 + 16 * v6);
      }
      long long v12 = v8[1];
      int v15 = *v12;
      uint64_t v13 = (char *)(v12 + 2);
      unsigned int v14 = v15;
    }
    else
    {
      unsigned int v14 = 0;
      uint64_t v13 = &byte_1CFBCE98E;
    }
    __int16 v18 = 773;
    v17[0] = v13;
    v17[1] = v14;
    v17[2] = ".licm";
    operator new();
  }
  return sub_1CC025000(v3, &v19)[1];
}

void *sub_1CCDA93B0(void *result, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    uint64_t v15 = v3;
    uint64_t v16 = v4;
    uint64_t v6 = a2;
    uint64_t v7 = (uint64_t)result;
    do
    {
      uint64_t v13 = *(void *)(*(void *)(v6 + 24) + 40);
      uint64_t result = sub_1CCDA94A0(v7, &v13, (uint64_t)v14);
      if (v14[16])
      {
        unint64_t v8 = *(unsigned int *)(v7 + 80);
        if (v8 >= *(unsigned int *)(v7 + 84)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v7 + 72) + 8 * v8) = *(void *)(*(void *)(v6 + 24) + 40);
        ++*(_DWORD *)(v7 + 80);
      }
      do
      {
        uint64_t v6 = *(void *)(v6 + 8);
        if (!v6) {
          break;
        }
        uint64_t v9 = *(void *)(v6 + 24);
        unsigned int v10 = *(unsigned __int8 *)(v9 + 16);
        BOOL v11 = v9 && v10 >= 0x1C;
      }
      while (!v11 || v10 - 29 > 0xA);
    }
    while (v6 != a3);
  }
  return result;
}

void *sub_1CCDA94A0@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v7 = a1 + 8;
  int v6 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    int v8 = 8;
    uint64_t v9 = a1 + 8;
  }
  else
  {
    int v8 = *(_DWORD *)(a1 + 16);
    if (!v8)
    {
      BOOL v19 = 0;
      goto LABEL_17;
    }
    uint64_t v9 = *(void *)(a1 + 8);
  }
  int v10 = v8 - 1;
  unsigned int v11 = ((*a2 >> 4) ^ (*a2 >> 9)) & v10;
  uint64_t result = (void *)(v9 + 8 * v11);
  uint64_t v13 = *result;
  if (*a2 == *result)
  {
LABEL_12:
    if (v6)
    {
      uint64_t v18 = 8;
    }
    else
    {
      uint64_t v7 = *(void *)(a1 + 8);
      uint64_t v18 = *(unsigned int *)(a1 + 16);
    }
    char v22 = 0;
    uint64_t v21 = v7 + 8 * v18;
    goto LABEL_20;
  }
  unsigned int v14 = 0;
  int v15 = 1;
  while (v13 != -4096)
  {
    if (v14) {
      BOOL v16 = 0;
    }
    else {
      BOOL v16 = v13 == -8192;
    }
    if (v16) {
      unsigned int v14 = result;
    }
    unsigned int v17 = v11 + v15++;
    unsigned int v11 = v17 & v10;
    uint64_t result = (void *)(v9 + 8 * v11);
    uint64_t v13 = *result;
    if (*a2 == *result) {
      goto LABEL_12;
    }
  }
  if (v14) {
    BOOL v19 = v14;
  }
  else {
    BOOL v19 = result;
  }
LABEL_17:
  uint64_t result = sub_1CC27F5FC(a1, (uint64_t)a2, a2, v19);
  void *result = *a2;
  if (*(unsigned char *)a1)
  {
    uint64_t v20 = 8;
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 8);
    uint64_t v20 = *(unsigned int *)(a1 + 16);
  }
  uint64_t v21 = v7 + 8 * v20;
  char v22 = 1;
LABEL_20:
  *(void *)a3 = result;
  *(void *)(a3 + 8) = v21;
  *(unsigned char *)(a3 + 16) = v22;
  return result;
}

void sub_1CCDA95C4(void *a1)
{
  *a1 = &unk_1F263E7B8;
  int v1 = (unsigned __int8 *)a1[10];
  if (!v1) {
    goto LABEL_5;
  }
  int v2 = *v1;
  if ((v2 - 4) > 0x1E)
  {
    if ((v2 - 3) >= 0xFFFFFFFE) {
      uint64_t v3 = a1[10];
    }
    else {
      uint64_t v3 = 0;
    }
    if ((v2 - 3) >= 0xFFFFFFFE)
    {
      unint64_t v4 = v3 + 8;
LABEL_13:
      int v6 = a1 + 10;
      sub_1CC5FA668(v4 + 16, &v6);
      goto LABEL_5;
    }
    if (v2 == 3) {
      *((void *)v1 + 1) = 0;
    }
  }
  else if ((v1[1] & 0x7F) == 2 || *((_DWORD *)v1 + 3))
  {
    uint64_t v5 = *((void *)v1 + 2);
    if ((v5 & 4) != 0)
    {
      unint64_t v4 = v5 & 0xFFFFFFFFFFFFFFF8;
      if (v4) {
        goto LABEL_13;
      }
    }
  }
LABEL_5:

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CCDA96AC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 - 32);
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = v3 + 8;
  if (*(unsigned char *)v3)
  {
    int v5 = 8;
  }
  else
  {
    int v5 = *(_DWORD *)(v3 + 16);
    if (!v5) {
      return 0;
    }
    uint64_t v4 = *(void *)(v3 + 8);
  }
  int v6 = v5 - 1;
  unsigned int v7 = v6 & ((v2 >> 4) ^ (v2 >> 9));
  uint64_t v8 = *(void *)(v4 + 8 * v7);
  if (v8 == v2) {
    return 1;
  }
  int v10 = 1;
  do
  {
    BOOL result = v8 != -4096;
    if (v8 == -4096) {
      break;
    }
    unsigned int v11 = v7 + v10++;
    unsigned int v7 = v11 & v6;
    uint64_t v8 = *(void *)(v4 + 8 * v7);
  }
  while (v8 != v2);
  return result;
}

uint64_t sub_1CCDA972C(uint64_t result)
{
  if (*(unsigned char *)(result + 136))
  {
    uint64_t v1 = result;
    if (*(_DWORD *)(*(void *)(result + 32) + 8))
    {
      uint64_t v2 = (void *)(result + 96);
      uint64_t v3 = ***(llvm::BasicBlock ****)(result + 32);
      ValueInMiddleOfBlocuint64_t k = llvm::SSAUpdater::GetValueInMiddleOfBlock(*(llvm::UndefValue ***)(result + 8), v3);
      int v5 = (llvm::Type **)sub_1CCDA9AB0(v1, ValueInMiddleOfBlock, v3);
      int v6 = sub_1CCDA9AB0(v1, *(const llvm::Value **)(v1 + 16), v3);
      unsigned int v7 = ***(llvm::Instruction ****)(v1 + 40);
      uint64_t v8 = (char *)operator new(0x80uLL);
      *((_DWORD *)v8 + 21) = *((_DWORD *)v8 + 21) & 0x38000000 | 2;
      uint64_t v9 = (uint64_t ***)(v8 + 64);
      *(void *)uint64_t v8 = 0;
      *((void *)v8 + 1) = 0;
      *((void *)v8 + 2) = 0;
      *((void *)v8 + 3) = v8 + 64;
      *((void *)v8 + 4) = 0;
      *((void *)v8 + 5) = 0;
      *((void *)v8 + 6) = 0;
      *((void *)v8 + 7) = v8 + 64;
      llvm::StoreInst::StoreInst((llvm::StoreInst *)(v8 + 64), v5, v6, 0, v7);
      if (*(unsigned char *)(v1 + 89)) {
        __int16 v10 = *((_WORD *)v8 + 41) & 0xFC01 | 0x80;
      }
      else {
        __int16 v10 = *((_WORD *)v8 + 41);
      }
      *((_WORD *)v8 + 41) = v10 & 0xFF81 | (2 * *(unsigned __int8 *)(v1 + 88));
      unsigned int v11 = *(unsigned __int8 **)(v1 + 80);
      char v22 = v11;
      if (v11) {
        llvm::MetadataTracking::track((uint64_t)&v22, v11, 2);
      }
      long long v12 = (unsigned __int8 *)*((void *)v8 + 14);
      if (!v12)
      {
LABEL_9:
        uint64_t v13 = v22;
        *((void *)v8 + 14) = v22;
        if (v13)
        {
          llvm::MetadataTracking::retrack((uint64_t)&v22, v13, (uint64_t)(v8 + 112));
          char v22 = 0;
        }
        if (*v2 || *(void *)(v1 + 104) || *(void *)(v1 + 112) || *(void *)(v1 + 120)) {
          llvm::Instruction::setAAMetadata(v9, (llvm::MDNode **)(v1 + 96));
        }
        unsigned int v14 = ***(const llvm::BasicBlock *****)(v1 + 48);
        int v15 = *(uint64_t ***)(v1 + 64);
        if (v14)
        {
          MemoryAccessAfter = llvm::MemorySSAUpdater::createMemoryAccessAfter(*(uint64_t ***)(v1 + 64), (llvm::Instruction *)v9, 0, v14);
        }
        else
        {
          BOOL v16 = (llvm::BasicBlock *)*((void *)v8 + 13);
          MemoryAccessAfter = llvm::MemorySSA::createDefinedAccess(*v15, (uint64_t)v9, 0, 0);
          llvm::MemorySSA::insertIntoListsForBlock((uint64_t)*v15, (uint64_t)MemoryAccessAfter, v16, 0);
        }
        ***(void ***)(v1 + 48) = MemoryAccessAfter;
        llvm::MemorySSAUpdater::insertDef(*(llvm::MemorySSAUpdater **)(v1 + 64), (llvm::MemoryDef *)MemoryAccessAfter);
      }
      int v18 = *v12;
      if ((v18 - 4) > 0x1E)
      {
        if ((v18 - 3) >= 0xFFFFFFFE) {
          uint64_t v21 = *((void *)v8 + 14);
        }
        else {
          uint64_t v21 = 0;
        }
        if ((v18 - 3) < 0xFFFFFFFE)
        {
          if (v18 == 3) {
            *((void *)v12 + 1) = 0;
          }
          goto LABEL_9;
        }
        unint64_t v20 = v21 + 8;
      }
      else
      {
        if ((v12[1] & 0x7F) != 2 && !*((_DWORD *)v12 + 3)) {
          goto LABEL_9;
        }
        uint64_t v19 = *((void *)v12 + 2);
        if ((v19 & 4) == 0) {
          goto LABEL_9;
        }
        unint64_t v20 = v19 & 0xFFFFFFFFFFFFFFF8;
        if (!v20) {
          goto LABEL_9;
        }
      }
      uint64_t v23 = v8 + 112;
      sub_1CC5FA668(v20 + 16, &v23);
      goto LABEL_9;
    }
  }
  return result;
}

void sub_1CCDA99BC(uint64_t a1, const llvm::Instruction *a2)
{
  uint64_t v4 = *(int32x2_t **)(a1 + 128);
  llvm::InstructionPrecedenceTracking::removeInstruction(v4 + 5, a2);
  llvm::InstructionPrecedenceTracking::removeInstruction(v4 + 9, a2);
  int v5 = *(int32x2_t ***)(a1 + 64);
  __int32 v6 = (*v5)[5].i32[0];
  if (v6)
  {
    int32x2_t v7 = (*v5)[3];
    __int32 v8 = v6 - 1;
    uint64_t v9 = (v6 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    __int16 v10 = *(const llvm::Instruction **)(*(void *)&v7 + 16 * v9);
    if (v10 == a2)
    {
LABEL_6:
      uint64_t v13 = *(llvm::MemoryAccess **)(*(void *)&v7 + 16 * v9 + 8);
      if (v13)
      {
        llvm::MemorySSAUpdater::removeMemoryAccess(v5, v13, 0);
      }
    }
    else
    {
      int v11 = 1;
      while (v10 != (const llvm::Instruction *)-4096)
      {
        int v12 = v9 + v11++;
        uint64_t v9 = v12 & v8;
        __int16 v10 = *(const llvm::Instruction **)(*(void *)&v7 + 16 * v9);
        if (v10 == a2) {
          goto LABEL_6;
        }
      }
    }
  }
}

BOOL sub_1CCDA9A8C(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 16) != 61 || *(unsigned char *)(a1 + 136) != 0;
}

llvm::Value *sub_1CCDA9AB0(uint64_t a1, const llvm::Value *a2, const llvm::BasicBlock *a3)
{
  uint64_t v4 = a2;
  if (!llvm::LoopInfo::wouldBeOutOfLoopUseRequiringLCSSA(*(llvm::LoopInfo **)(a1 + 72), a2, a3)) {
    return v4;
  }
  __int32 v6 = *(uint64_t ***)v4;
  int v7 = sub_1CC0A181C(*(void *)(a1 + 56), (uint64_t)a3);
  if ((*((unsigned char *)v4 + 23) & 0x10) != 0)
  {
    uint64_t v8 = ***(void ***)v4;
    uint64_t v9 = *(void *)(v8 + 152);
    uint64_t v10 = *(unsigned int *)(v8 + 168);
    if (v10)
    {
      LODWORD(v11) = (v10 - 1) & ((v4 >> 4) ^ (v4 >> 9));
      int v12 = (const llvm::Value **)(v9 + 16 * v11);
      uint64_t v13 = *v12;
      if (*v12 == v4)
      {
LABEL_10:
        BOOL v16 = v12[1];
        uint64_t v19 = *(const char **)v16;
        unsigned int v17 = (char *)v16 + 16;
        int v18 = v19;
        goto LABEL_11;
      }
      int v14 = 1;
      while (v13 != (const llvm::Value *)-4096)
      {
        int v15 = v11 + v14++;
        uint64_t v11 = v15 & (v10 - 1);
        uint64_t v13 = *(const llvm::Value **)(v9 + 16 * v11);
        if (v13 == v4)
        {
          int v12 = (const llvm::Value **)(v9 + 16 * v11);
          goto LABEL_10;
        }
      }
    }
    int v12 = (const llvm::Value **)(v9 + 16 * v10);
    goto LABEL_10;
  }
  int v18 = 0;
  unsigned int v17 = &byte_1CFBCE98E;
LABEL_11:
  __int16 v78 = 773;
  v77[0] = v17;
  v77[1] = v18;
  v77[2] = ".lcssa";
  unint64_t v20 = (uint64_t *)*((void *)a3 + 6);
  uint64_t v21 = operator new(0x48uLL);
  char v22 = v21;
  v21[1] = v6;
  uint64_t v23 = (llvm::Value *)(v21 + 1);
  *uint64_t v21 = 0;
  v21[2] = 0;
  v21[3] = 0x4000000000000053;
  *((_OWORD *)v21 + 2) = 0u;
  uint64_t v24 = (char *)(v21 + 4);
  *((_OWORD *)v21 + 3) = 0u;
  *((_DWORD *)v21 + 16) = 0;
  if (v20)
  {
    uint64_t v56 = v20[2];
    v21[6] = v56;
    *(_WORD *)(v56 + 18) &= ~0x8000u;
    if ((*((unsigned char *)v21 + 31) & 0x10) != 0)
    {
      uint64_t v66 = *(void *)(v56 + 56);
      if (v66)
      {
        unsigned int v67 = *(llvm::ValueSymbolTable **)(v66 + 104);
        if (v67) {
          llvm::ValueSymbolTable::reinsertValue(v67, v23);
        }
      }
    }
    uint64_t v57 = *v20;
    v22[4] = *v20;
    v22[5] = v20;
    *(void *)(v57 + 8) = v24;
    *unint64_t v20 = (uint64_t)v24;
  }
  *((_DWORD *)v22 + 17) = v7;
  llvm::Value::setNameImpl(v23, v77);
  if (*((unsigned char *)v22 + 24)) {
    goto LABEL_13;
  }
  if ((*((unsigned char *)v22 + 31) & 0x10) == 0) {
    goto LABEL_73;
  }
  uint64_t v58 = ***(void ***)v23;
  uint64_t v59 = *(void *)(v58 + 152);
  uint64_t v60 = *(unsigned int *)(v58 + 168);
  if (!v60) {
    goto LABEL_65;
  }
  LODWORD(v61) = (v60 - 1) & ((v23 >> 4) ^ (v23 >> 9));
  long long v62 = (llvm::Value **)(v59 + 16 * v61);
  long long v63 = *v62;
  if (*v62 != v23)
  {
    int v64 = 1;
    while (v63 != (llvm::Value *)-4096)
    {
      int v65 = v61 + v64++;
      uint64_t v61 = v65 & (v60 - 1);
      long long v63 = *(llvm::Value **)(v59 + 16 * v61);
      if (v63 == v23)
      {
        long long v62 = (llvm::Value **)(v59 + 16 * v61);
        goto LABEL_66;
      }
    }
LABEL_65:
    long long v62 = (llvm::Value **)(v59 + 16 * v60);
  }
LABEL_66:
  uint64_t v68 = v62[1];
  unint64_t v71 = *(void *)v68;
  uint64_t v69 = (char *)v68 + 16;
  unint64_t v70 = v71;
  if (v71 < 5 || (*(_DWORD *)v69 == *(_DWORD *)"llvm." ? (BOOL v72 = v69[4] == aLlvm_1[4]) : (BOOL v72 = 0), !v72))
  {
LABEL_73:
    int v73 = 0;
    *((_DWORD *)v22 + 10) &= ~0x2000u;
    goto LABEL_74;
  }
  *((_DWORD *)v22 + 10) |= 0x2000u;
  int v73 = llvm::Function::lookupIntrinsicID(v69, v70);
LABEL_74:
  *((_DWORD *)v22 + 11) = v73;
LABEL_13:
  uint64_t v25 = *((unsigned int *)v22 + 17);
  uint64_t v26 = operator new(40 * v25);
  *char v22 = v26;
  if (v25)
  {
    uint64_t v27 = &v26[4 * v25];
    do
    {
      *uint64_t v26 = 0;
      v26[1] = 0;
      v26[2] = 0;
      v26[3] = v23;
      v26 += 4;
    }
    while (v26 != v27);
  }
  uint64_t v28 = *(void *)(a1 + 56);
  uint64_t v29 = (uint64_t *)sub_1CC0A1594(v28, (uint64_t)a3);
  int v30 = sub_1CC0A181C(v28, (uint64_t)a3);
  if (v30)
  {
    uint64_t v31 = &v29[v30];
    uint64_t v32 = (char **)((char *)v4 + 8);
    LODWORD(v33) = *((_DWORD *)v22 + 17);
    unsigned int v74 = v31;
    uint64_t v75 = v23;
    do
    {
      uint64_t v34 = *v29;
      int v35 = *((_DWORD *)v22 + 7);
      if ((v35 & 0x7FFFFFF) == v33)
      {
        unsigned int v45 = v33 + (v33 >> 1);
        if (v45 <= 2) {
          uint64_t v46 = 2;
        }
        else {
          uint64_t v46 = v45;
        }
        *((_DWORD *)v22 + 17) = v46;
        if ((v35 & 0x40000000) != 0) {
          int v47 = (uint64_t *)*v22;
        }
        else {
          int v47 = (uint64_t *)((char *)v23 - 32 * v33);
        }
        uint64_t __p = v47;
        uint64_t v48 = operator new(40 * v46);
        *char v22 = v48;
        __int16 v49 = v48;
        do
        {
          void *v49 = 0;
          v49[1] = 0;
          v49[2] = 0;
          v49[3] = v23;
          v49 += 4;
        }
        while (v49 != &v48[4 * v46]);
        int v50 = *((_DWORD *)v22 + 7);
        if ((v50 & 0x40000000) != 0) {
          uint64_t v51 = (uint64_t)v48;
        }
        else {
          uint64_t v51 = (uint64_t)v23 - 32 * (v50 & 0x7FFFFFF);
        }
        sub_1CC5E4108((uint64_t)v77, __p, &__p[4 * v33], v51);
        if (v33)
        {
          memmove((void *)(v51 + 32 * v46), &__p[4 * v33], 8 * v33);
          uint64_t v52 = 4 * v33;
          do
          {
            long long v53 = &__p[v52];
            if (__p[v52 - 4])
            {
              *(void *)*(v53 - 2) = *(v53 - 3);
              uint64_t v54 = *(v53 - 3);
              if (v54) {
                *(void *)(v54 + 16) = *(v53 - 2);
              }
            }
            v52 -= 4;
          }
          while (v52 * 8);
        }
        operator delete(__p);
        int v35 = *((_DWORD *)v22 + 7);
        uint64_t v31 = v74;
        uint64_t v23 = v75;
      }
      uint64_t v36 = (v35 + 1) & 0x7FFFFFF;
      *((_DWORD *)v22 + 7) = v35 & 0xF8000000 | (v35 + 1) & 0x7FFFFFF;
      if ((v35 & 0x40000000) != 0) {
        uint64_t v37 = (char *)*v22;
      }
      else {
        uint64_t v37 = (char *)v23 - 32 * v36;
      }
      uint64_t v38 = (v36 - 1);
      long long v39 = &v37[32 * v38];
      if (*(void *)v39)
      {
        **((void **)v39 + 2) = *((void *)v39 + 1);
        uint64_t v44 = *((void *)v39 + 1);
        if (v44) {
          *(void *)(v44 + 16) = *((void *)v39 + 2);
        }
      }
      *(void *)long long v39 = v4;
      uint64_t v40 = *((void *)v4 + 1);
      *((void *)v39 + 1) = v40;
      if (v40) {
        *(void *)(v40 + 16) = v39 + 8;
      }
      *(void *)&v37[32 * v38 + 16] = v32;
      void *v32 = v39;
      int v41 = *((_DWORD *)v22 + 7);
      uint64_t v42 = v41 & 0x7FFFFFF;
      if ((v41 & 0x40000000) != 0) {
        uint64_t v43 = (char *)*v22;
      }
      else {
        uint64_t v43 = (char *)v23 - 32 * v42;
      }
      uint64_t v33 = *((unsigned int *)v22 + 17);
      *(void *)&v43[32 * v33 + 8 * (v42 - 1)] = v34;
      ++v29;
    }
    while (v29 != v31);
  }
  return v23;
}

uint64_t sub_1CCDA9F54(uint64_t a1, llvm::MemorySSA *this, uint64_t a3)
{
  uint64_t v3 = *((unsigned int *)this + 22);
  if (!v3) {
    return 0;
  }
  uint64_t v6 = *((void *)this + 9);
  LODWORD(v7) = (v3 - 1) & ((a1 >> 4) ^ (a1 >> 9));
  uint64_t v8 = (uint64_t *)(v6 + 16 * v7);
  uint64_t v9 = *v8;
  if (*v8 != a1)
  {
    int v10 = 1;
    while (v9 != -4096)
    {
      int v11 = v7 + v10++;
      uint64_t v7 = v11 & (v3 - 1);
      uint64_t v9 = *(void *)(v6 + 16 * v7);
      if (v9 == a1)
      {
        uint64_t v8 = (uint64_t *)(v6 + 16 * v7);
        goto LABEL_7;
      }
    }
    return 0;
  }
LABEL_7:
  if (v8 == (uint64_t *)(v6 + 16 * v3)) {
    return 0;
  }
  uint64_t v12 = v8[1];
  if (!v12) {
    return 0;
  }
  uint64_t v13 = *(void *)(v12 + 8);
  if (v13 == v12) {
    return 0;
  }
  while (1)
  {
    uint64_t v14 = v13 - 48;
    if (!v13) {
      uint64_t v14 = 0;
    }
    int v15 = *(unsigned __int8 *)(v14 + 16);
    uint64_t v16 = v15 == 26 ? v14 : 0;
    if (v13
      && v15 == 26
      && (*(void *)(a3 + 64) != *(void *)(v16 + 64) || !llvm::MemorySSA::locallyDominates(this, v16, a3)))
    {
      break;
    }
    uint64_t result = 0;
    uint64_t v13 = *(void *)(v13 + 8);
    if (v13 == v12) {
      return result;
    }
  }
  return 1;
}

void *sub_1CCDAA058@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int v17 = 0;
  uint64_t result = (void *)sub_1CCD7A118(a1, a2, &v17);
  uint64_t v9 = v17;
  if (result)
  {
    uint64_t v15 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v16 = 4;
    }
    else
    {
      uint64_t v15 = *(void *)(a1 + 8);
      uint64_t v16 = *(unsigned int *)(a1 + 16);
    }
    char v14 = 0;
    uint64_t v13 = v15 + 16 * v16;
  }
  else
  {
    uint64_t result = sub_1CCDAA11C((_DWORD *)a1, (uint64_t)a2, a2, v17);
    uint64_t v9 = result;
    uint64_t v10 = *a3;
    void *result = *a2;
    result[1] = v10;
    uint64_t v11 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v12 = 4;
    }
    else
    {
      uint64_t v11 = *(void *)(a1 + 8);
      uint64_t v12 = *(unsigned int *)(a1 + 16);
    }
    uint64_t v13 = v11 + 16 * v12;
    char v14 = 1;
  }
  *(void *)a4 = v9;
  *(void *)(a4 + 8) = v13;
  *(unsigned char *)(a4 + 16) = v14;
  return result;
}

void *sub_1CCDAA11C(_DWORD *a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *a1 >> 1;
  if (*a1) {
    unsigned int v7 = 4;
  }
  else {
    unsigned int v7 = a1[4];
  }
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - a1[1] > v7 >> 3)
  {
    goto LABEL_5;
  }
  sub_1CCDAA1E0((uint64_t)a1, v7);
  uint64_t v9 = 0;
  sub_1CCD7A118((uint64_t)a1, a3, &v9);
  a4 = v9;
LABEL_5:
  *a1 += 2;
  if (*a4 != -4096) {
    --a1[1];
  }
  return a4;
}

uint64_t sub_1CCDAA1E0(uint64_t a1, unsigned int a2)
{
  v14[8] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v11 = *(void **)(a1 + 8);
    uint64_t v12 = *(unsigned int *)(a1 + 16);
    if (a2 <= 4)
    {
      *(_DWORD *)a1 |= 1u;
    }
    else
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    sub_1CCDAA36C(a1, v11, &v11[2 * v12]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v6 = 0;
  unsigned int v7 = v14;
  do
  {
    uint64_t v8 = *(void *)(a1 + v6 + 8);
    if ((v8 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *unsigned int v7 = v8;
      v7[1] = *(void *)(a1 + v6 + 16);
      v7 += 2;
    }
    v6 += 16;
  }
  while (v6 != 64);
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v9 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v9;
  }
  return sub_1CCDAA36C(a1, v14, v7);
}

uint64_t sub_1CCDAA36C(uint64_t result, void *a2, void *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 72);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_9;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[2 * v7];
  }
  do
  {
    void *v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_9:
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v12 = 0;
      uint64_t result = sub_1CCD7A118((uint64_t)v5, a2, &v12);
      uint64_t v10 = v12;
      uint64_t v11 = a2[1];
      void *v12 = *a2;
      v10[1] = v11;
      *v5 += 2;
    }
    a2 += 2;
  }
  return result;
}

uint64_t sub_1CCDAA42C()
{
  int v3 = 1;
  LOBYTE(v2) = 0;
  unint64_t v4 = &v2;
  v1.n128_u64[0] = (unint64_t)"Disable memory promotion in LICM pass";
  v1.n128_u64[1] = 37;
  sub_1CC025F34((llvm::cl::Option *)&unk_1EBCF31A0, "disable-licm-promotion", &v3, (unsigned char **)&v4, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF31A0, &dword_1CB82C000);
  int v3 = 1;
  LOBYTE(v2) = 0;
  unint64_t v4 = &v2;
  v1.n128_u64[0] = (unint64_t)"Enable control flow (and PHI) hoisting in LICM";
  v1.n128_u64[1] = 46;
  sub_1CC025F34((llvm::cl::Option *)&unk_1EBCF3260, "licm-control-flow-hoisting", &v3, (unsigned char **)&v4, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF3260, &dword_1CB82C000);
  int v2 = 4;
  int v3 = 1;
  unint64_t v4 = &v2;
  v1.n128_u64[0] = (unint64_t)"Relative coldness Threshold of hoisting/sinking destination block for LICM to be co"
                                     "nsidered beneficial";
  v1.n128_u64[1] = 102;
  sub_1CD45A86C((uint64_t)&unk_1EBCF3320, "licm-coldness-threshold", &v3, &v4, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF3320, &dword_1CB82C000);
  int v2 = 8;
  int v3 = 1;
  unint64_t v4 = &v2;
  v1.n128_u64[0] = (unint64_t)"Max num uses visited for identifying load invariance in loop using invariant start (default = 8)";
  v1.n128_u64[1] = 96;
  sub_1CD45A86C((uint64_t)&unk_1EBCF33E0, "licm-max-num-uses-traversed", &v3, &v4, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF33E0, &dword_1CB82C000);
  int v2 = 1;
  int v3 = 100;
  unint64_t v4 = &v3;
  v1.n128_u64[0] = (unint64_t)"Enable imprecision in LICM in pathological cases, in exchange for faster compile. C"
                                     "aps the MemorySSA clobbering calls.";
  v1.n128_u64[1] = 118;
  sub_1CBF7A9F8((uint64_t)&llvm::SetLicmMssaOptCap, "licm-mssa-optimization-cap", &v4, &v2, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &llvm::SetLicmMssaOptCap, &dword_1CB82C000);
  int v2 = 1;
  int v3 = 250;
  unint64_t v4 = &v3;
  v1.n128_u64[0] = (unint64_t)"[LICM & MemorySSA] When MSSA in LICM is disabled, this has no effect. When MSSA in "
                                     "LICM is enabled, then this is the maximum number of accesses allowed to be present "
                                     "in a loop in order to enable memory promotion.";
  v1.n128_u64[1] = 212;
  sub_1CBF7A9F8((uint64_t)&llvm::SetLicmMssaNoAccForPromotionCap, "licm-mssa-max-acc-promotion", &v4, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &llvm::SetLicmMssaNoAccForPromotionCap, &dword_1CB82C000);
}

void llvm::LoopBoundSplitPass::run(llvm::Loop *this@<X1>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(*(void *)(**((void **)this + 4) + 56) + 112);
  if ((!v3 || (*(unsigned char *)(v3 + 17) & 4) == 0 && (*(char *)(v3 + 13) & 0x80000000) == 0)
    && *((void *)this + 1) == *((void *)this + 2))
  {
    llvm::Loop::isLoopSimplifyForm(this);
  }
  *(void *)(a2 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a2 = a2 + 32;
  *(void *)(a2 + 8) = a2 + 32;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 48) = a2 + 80;
  *(void *)(a2 + 56) = a2 + 80;
  *(void *)(a2 + 64) = 2;
  *(_DWORD *)(a2 + 72) = 0;
  *(void *)(a2 + 16) = 0x100000002;
}

BOOL sub_1CCDAC9AC(BOOL result)
{
  if (result)
  {
    uint64_t v1 = result;
    if ((*(_DWORD *)(result + 20) & 0x7FFFFFF) != 3) {
      return 0;
    }
    uint64_t result = 0;
    uint64_t v2 = *(void *)(v1 - 96);
    if (!v2 || *(unsigned char *)(v2 + 16) != 81) {
      return result;
    }
    uint64_t v3 = *(void *)(v2 - 64);
    if (!v3) {
      return 0;
    }
    if (!*(void *)(v2 - 32)) {
      return 0;
    }
    uint64_t v4 = *(void *)(v1 - 32);
    if (!v4) {
      return 0;
    }
    uint64_t v5 = *(void *)(v1 - 64);
    if (!v5) {
      return 0;
    }
    return (*(_DWORD *)(*(void *)v3 + 8) & 0xFD) == 0xD && v4 != v5;
  }
  return result;
}

BOOL sub_1CCDACA24(const llvm::BasicBlock ***a1, llvm::ScalarEvolution *this, uint64_t a3, uint64_t a4, int a5)
{
  v67[2] = *MEMORY[0x1E4F143B8];
  *(void *)(a4 + 8) = a3;
  if (!a3) {
    goto LABEL_39;
  }
  unint64_t v9 = *(void *)(a3 - 64);
  if (!v9) {
    goto LABEL_39;
  }
  *(void *)(a4 + 24) = v9;
  unint64_t v10 = *(void *)(a3 - 32);
  if (!v10) {
    goto LABEL_39;
  }
  *(void *)(a4 + 40) = v10;
  *(_DWORD *)(a4 + 16) = *(_WORD *)(a3 + 18) & 0x3F;
  uint64_t v11 = *((void *)this + 13);
  unsigned int v12 = *((_DWORD *)this + 30);
  if (!v12) {
    goto LABEL_10;
  }
  unsigned int v13 = (v12 - 1) & ((v9 >> 4) ^ (v9 >> 9));
  uint64_t v14 = v11 + 48 * v13;
  uint64_t v15 = *(void *)(v14 + 24);
  if (v15 != v9)
  {
    int v16 = 1;
    while (v15 != -4096)
    {
      unsigned int v17 = v13 + v16++;
      unsigned int v13 = v17 & (v12 - 1);
      uint64_t v14 = v11 + 48 * v13;
      uint64_t v15 = *(void *)(v14 + 24);
      if (v15 == v9) {
        goto LABEL_11;
      }
    }
LABEL_10:
    uint64_t v14 = v11 + 48 * v12;
  }
LABEL_11:
  if (v14 == v11 + 48 * v12 || (uint64_t SCEVIter = *(void *)(v14 + 40)) == 0)
  {
    uint64_t SCEVIter = llvm::ScalarEvolution::createSCEVIter(this, v9);
    unint64_t v10 = *(void *)(a4 + 40);
    uint64_t v11 = *((void *)this + 13);
    unsigned int v12 = *((_DWORD *)this + 30);
    if (!v12) {
      goto LABEL_20;
    }
  }
  else if (!v12)
  {
    goto LABEL_20;
  }
  unsigned int v19 = ((v10 >> 4) ^ (v10 >> 9)) & (v12 - 1);
  uint64_t v20 = v11 + 48 * v19;
  uint64_t v21 = *(void *)(v20 + 24);
  if (v21 == v10) {
    goto LABEL_21;
  }
  int v22 = 1;
  while (v21 != -4096)
  {
    unsigned int v23 = v19 + v22++;
    unsigned int v19 = v23 & (v12 - 1);
    uint64_t v20 = v11 + 48 * v19;
    uint64_t v21 = *(void *)(v20 + 24);
    if (v21 == v10) {
      goto LABEL_21;
    }
  }
LABEL_20:
  uint64_t v20 = v11 + 48 * v12;
LABEL_21:
  if (v20 == v11 + 48 * v12 || (uint64_t v24 = *(void *)(v20 + 40)) == 0) {
    uint64_t v24 = llvm::ScalarEvolution::createSCEVIter(this, v10);
  }
  int v25 = *(unsigned __int16 *)(SCEVIter + 24);
  if (SCEVIter) {
    BOOL v26 = v25 == 7;
  }
  else {
    BOOL v26 = 0;
  }
  uint64_t v27 = *(void *)(a4 + 24);
  if (!v26 && (v24 ? (BOOL v28 = *(unsigned __int16 *)(v24 + 24) == 7) : (BOOL v28 = 0), v28))
  {
    uint64_t v29 = *(void *)(a4 + 40);
    *(void *)(a4 + 24) = v29;
    *(void *)(a4 + 40) = v27;
    *(_DWORD *)(a4 + 16) = dword_1CFB2CE98[*(int *)(a4 + 16)];
    uint64_t v30 = SCEVIter;
    uint64_t v27 = v29;
  }
  else
  {
    if (v25 != 7)
    {
      *(void *)(a4 + 48) = 0;
      *(void *)(a4 + 56) = v24;
      *(void *)(a4 + 32) = v27;
      goto LABEL_39;
    }
    uint64_t v30 = v24;
    uint64_t v24 = SCEVIter;
  }
  *(void *)(a4 + 48) = v24;
  *(void *)(a4 + 56) = v30;
  *(void *)(a4 + 32) = v27;
  if (*(unsigned char *)(v27 + 16) == 83) {
    llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopLatch();
  }
LABEL_39:
  uint64_t v31 = (uint64_t *)(a4 + 56);
  BOOL result = llvm::ScalarEvolution::isAvailableAtLoopEntry(this, *(const llvm::SCEV **)(a4 + 56), a1);
  if (!result) {
    return result;
  }
  uint64_t v34 = *(void *)(a4 + 48);
  if (!v34) {
    return 0;
  }
  if (*(void *)(v34 + 40) != 2) {
    return 0;
  }
  uint64_t v35 = *(void *)(*(void *)(v34 + 32) + 8);
  if (*(_WORD *)(v35 + 24)) {
    return 0;
  }
  uint64_t v36 = *(void *)(v35 + 32);
  uint64_t v37 = *(unsigned int *)(v36 + 32);
  unsigned int v38 = v37 - 1;
  if (v37 <= 0x40)
  {
    uint64_t v39 = *(void *)(v36 + 24);
    if (v39) {
      BOOL v40 = (v39 & (1 << v38)) == 0;
    }
    else {
      BOOL v40 = 0;
    }
    if (!v40) {
      return 0;
    }
LABEL_59:
    if (!a5)
    {
      int v48 = *(_DWORD *)(a4 + 16);
      BOOL result = 1;
      switch(v48)
      {
        case '$':
        case '(':
          return result;
        case '%':
        case ')':
          __int16 v49 = (uint64_t *)(a4 + 56);
          while (2)
          {
            uint64_t v50 = *v49;
            switch(*(_WORD *)(v50 + 24))
            {
              case 1:
              case 2:
              case 3:
              case 0xD:
                uint64_t v51 = (llvm::Type **)(v50 + 40);
                break;
              case 4:
                uint64_t v51 = (llvm::Type **)(v50 + 48);
                break;
              case 5:
              case 7:
              case 8:
              case 9:
              case 0xA:
              case 0xB:
              case 0xC:
                __int16 v49 = *(uint64_t **)(v50 + 32);
                continue;
              case 6:
                __int16 v49 = (uint64_t *)(v50 + 40);
                continue;
              case 0xE:
                uint64_t v51 = *(llvm::Type ***)(v50 - 8);
                break;
              default:
                uint64_t v51 = *(llvm::Type ***)(v50 + 32);
                break;
            }
            break;
          }
          uint64_t v52 = *v51;
          unint64_t v53 = *((unsigned int *)*v51 + 2);
          if (v52) {
            BOOL v54 = v53 == 13;
          }
          else {
            BOOL v54 = 0;
          }
          if (!v54) {
            return 0;
          }
          unsigned int v65 = v53 >> 8;
          uint64_t v55 = (v53 >> 8) + 63;
          if ((v48 - 38) > 3)
          {
            if (v53 >> 8 > 0x40) {
              operator new[]();
            }
            if (v53 <= 0xFF) {
              unint64_t v57 = 0;
            }
            else {
              unint64_t v57 = 0xFFFFFFFFFFFFFFFFLL >> ~(_BYTE)v55;
            }
            uint64_t v64 = v57;
          }
          else
          {
            if (v53 >> 8 > 0x40) {
              operator new[]();
            }
            unint64_t v56 = 0xFFFFFFFFFFFFFFFFLL >> ~(_BYTE)v55;
            if (v53 <= 0xFF) {
              unint64_t v56 = 0;
            }
            uint64_t v64 = v56 & ~(1 << (BYTE1(v53) - 1));
          }
          uint64_t v58 = (llvm::ConstantInt *)llvm::ConstantInt::get(***(llvm::ConstantInt ****)this, (llvm::LLVMContext *)&v64, v33);
          unint64_t Constant = (const llvm::SCEV *)llvm::ScalarEvolution::getConstant(this, v58);
          if ((*(_DWORD *)(a4 + 16) - 38) >= 4) {
            unsigned int v60 = 36;
          }
          else {
            unsigned int v60 = 40;
          }
          if (llvm::ScalarEvolution::isKnownPredicate(this, v60, *(const llvm::SCEV **)(a4 + 56), Constant))
          {
            uint64_t v61 = *v31;
            unint64_t v62 = llvm::ScalarEvolution::getConstant(this, v52, 1uLL, 0);
            v66[0] = v67;
            v67[0] = v61;
            v67[1] = v62;
            v66[1] = (void *)0x200000002;
            uint64_t AddExpr = llvm::ScalarEvolution::getAddExpr((uint64_t)this, (unint64_t **)v66, 0, 0);
            if (v66[0] != v67) {
              free(v66[0]);
            }
            *(void *)(a4 + 56) = AddExpr;
            *(_DWORD *)(a4 + 16) = v60;
            if (v65 >= 0x41)
            {
              if (v64) {
                MEMORY[0x1D25D9CB0](v64, 0x1000C8000313F17);
              }
            }
            return 1;
          }
          if (v65 >= 0x41 && v64) {
            MEMORY[0x1D25D9CB0](v64, 0x1000C8000313F17);
          }
          break;
        default:
          return 0;
      }
      return 0;
    }
    uint64_t ExitCount = llvm::ScalarEvolution::getExitCount(this, (const llvm::Loop *)a1, *(void *)(*(void *)(a4 + 8) + 40), 0);
    BOOL result = 0;
    if (*(_WORD *)(ExitCount + 24) != 15)
    {
      uint64_t *v31 = ExitCount;
      return 1;
    }
    return result;
  }
  uint64_t v41 = *(void *)(v36 + 24);
  if ((*(void *)(v41 + 8 * (v38 >> 6)) >> v38)) {
    return 0;
  }
  int v42 = 0;
  int64_t v43 = (unint64_t)(v37 + 63) >> 6;
  do
  {
    if (v43-- < 1) {
      break;
    }
    unint64_t v45 = *(void *)(v41 + 8 * v43);
    v42 += __clz(v45);
  }
  while (!v45);
  BOOL result = 0;
  int v46 = v37 | 0xFFFFFFC0;
  if ((v37 & 0x3F) == 0) {
    int v46 = 0;
  }
  if (v42 + v46 != v37) {
    goto LABEL_59;
  }
  return result;
}

void llvm::LoopSinkPass::run()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

void sub_1CCDAD424()
{
}

void sub_1CCDAEB14(llvm *a1, llvm::PassRegistry *a2)
{
  llvm::initializeLoopPassPass(a1, a2);
  llvm::initializeBlockFrequencyInfoWrapperPassPass(a1, v3);
  llvm::initializeMemorySSAWrapperPassPass(a1, v4);
  operator new();
}

uint64_t sub_1CCDAEBC0(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF34A0;
  *(_DWORD *)(a1 + 24) = 1;
  *(void *)a1 = &unk_1F263E808;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF34A8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCDAEB14;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCF34A8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t *sub_1CCDAEC70(uint64_t *result, uint64_t *a2, uint64_t **a3, unint64_t a4, uint64_t *a5, uint64_t a6)
{
  if (a4 >= 2)
  {
    uint64_t v7 = a2;
    uint64_t v8 = result;
    if (a4 == 2)
    {
      uint64_t v9 = *result;
      uint64_t v10 = **a3;
      if (!v10 || (BOOL result = (uint64_t *)sub_1CBF7A45C(**a3, *(a2 - 1)), result == -1)) {
        unint64_t v11 = 0;
      }
      else {
        unint64_t v11 = *(void *)(*(void *)(v10 + 8) + 24 * result + 16);
      }
      uint64_t v12 = **a3;
      if (!v12 || (BOOL result = (uint64_t *)sub_1CBF7A45C(v12, v9), result == -1)) {
        unint64_t v13 = 0;
      }
      else {
        unint64_t v13 = *(void *)(*(void *)(v12 + 8) + 24 * result + 16);
      }
      if (v11 < v13)
      {
        uint64_t v14 = *v8;
        uint64_t *v8 = *(v7 - 1);
        *(v7 - 1) = v14;
      }
    }
    else if ((uint64_t)a4 > 128)
    {
      uint64_t v33 = a5;
      unint64_t v34 = a4 >> 1;
      uint64_t v35 = &result[a4 >> 1];
      unint64_t v36 = a4 >> 1;
      if ((uint64_t)a4 <= a6)
      {
        sub_1CCDAF098(result, v35, a3, v36, a5);
        uint64_t v37 = &v33[v34];
        BOOL result = sub_1CCDAF098(&v8[a4 >> 1], v7, a3, a4 - (a4 >> 1), v37);
        unsigned int v38 = &v33[a4];
        uint64_t v39 = v37;
        while (v39 != v38)
        {
          BOOL v40 = v39;
          uint64_t v41 = *v33;
          uint64_t v42 = **a3;
          if (!v42 || (BOOL result = (uint64_t *)sub_1CBF7A45C(**a3, *v39), result == -1)) {
            unint64_t v43 = 0;
          }
          else {
            unint64_t v43 = *(void *)(*(void *)(v42 + 8) + 24 * result + 16);
          }
          uint64_t v44 = **a3;
          if (!v44 || (BOOL result = (uint64_t *)sub_1CBF7A45C(**a3, v41), result == -1)) {
            unint64_t v45 = 0;
          }
          else {
            unint64_t v45 = *(void *)(*(void *)(v44 + 8) + 24 * result + 16);
          }
          if (v43 < v45) {
            int v46 = v40;
          }
          else {
            int v46 = v33;
          }
          v33 += v43 >= v45;
          uint64_t v39 = &v40[v43 < v45];
          *v8++ = *v46;
          if (v33 == v37)
          {
            if (v39 != v38)
            {
              uint64_t v48 = 0;
              if (v43 < v45) {
                char v49 = 1;
              }
              else {
                char v49 = 2;
              }
              uint64_t v50 = &v40[v49 & 1];
              do
              {
                v8[v48] = v50[v48];
                ++v48;
              }
              while (&v50[v48] != v38);
            }
            return result;
          }
        }
        if (v33 != v37)
        {
          uint64_t v47 = 0;
          do
          {
            v8[v47] = v33[v47];
            ++v47;
          }
          while (&v33[v47] != v37);
        }
      }
      else
      {
        sub_1CCDAEC70(result, v35, a3, v36, a5, a6);
        sub_1CCDAEC70(&v8[a4 >> 1], v7, a3, a4 - (a4 >> 1), v33, a6);
        return sub_1CCDAF460(v8, &v8[a4 >> 1], v7, a3, a4 >> 1, a4 - (a4 >> 1), v33, a6);
      }
    }
    else if (result != a2)
    {
      int v16 = result + 1;
      if (result + 1 != a2)
      {
        uint64_t v17 = 0;
        int v18 = result;
        do
        {
          uint64_t v19 = *v18;
          int v18 = v16;
          uint64_t v20 = **a3;
          if (!v20 || (BOOL result = (uint64_t *)sub_1CBF7A45C(**a3, *v16), result == -1)) {
            unint64_t v21 = 0;
          }
          else {
            unint64_t v21 = *(void *)(*(void *)(v20 + 8) + 24 * result + 16);
          }
          uint64_t v22 = **a3;
          if (!v22 || (BOOL result = (uint64_t *)sub_1CBF7A45C(**a3, v19), result == -1)) {
            unint64_t v23 = 0;
          }
          else {
            unint64_t v23 = *(void *)(*(void *)(v22 + 8) + 24 * result + 16);
          }
          if (v21 < v23)
          {
            uint64_t v24 = *v18;
            uint64_t v25 = v17;
            while (1)
            {
              *(uint64_t *)((char *)v8 + v25 + 8) = *(uint64_t *)((char *)v8 + v25);
              if (!v25) {
                break;
              }
              uint64_t v26 = *(uint64_t *)((char *)v8 + v25 - 8);
              uint64_t v27 = **a3;
              if (!v27 || (BOOL result = (uint64_t *)sub_1CBF7A45C(**a3, v24), result == -1)) {
                unint64_t v28 = 0;
              }
              else {
                unint64_t v28 = *(void *)(*(void *)(v27 + 8) + 24 * result + 16);
              }
              uint64_t v29 = **a3;
              if (!v29 || (BOOL result = (uint64_t *)sub_1CBF7A45C(**a3, v26), result == -1)) {
                unint64_t v30 = 0;
              }
              else {
                unint64_t v30 = *(void *)(*(void *)(v29 + 8) + 24 * result + 16);
              }
              v25 -= 8;
              if (v28 >= v30)
              {
                uint64_t v31 = (uint64_t *)((char *)v8 + v25 + 8);
                goto LABEL_36;
              }
            }
            uint64_t v31 = v8;
LABEL_36:
            uint64_t *v31 = v24;
            uint64_t v7 = a2;
          }
          int v16 = v18 + 1;
          v17 += 8;
        }
        while (v18 + 1 != v7);
      }
    }
  }
  return result;
}

uint64_t *sub_1CCDAF098(uint64_t *result, uint64_t *a2, uint64_t **a3, unint64_t a4, uint64_t *a5)
{
  if (a4)
  {
    uint64_t v5 = a5;
    uint64_t v7 = result;
    if (a4 == 1)
    {
LABEL_16:
      *uint64_t v5 = *v7;
      return result;
    }
    if (a4 == 2)
    {
      uint64_t v10 = *result;
      unint64_t v11 = **a3;
      if (v11)
      {
        BOOL result = (uint64_t *)sub_1CBF7A45C(**a3, *(a2 - 1));
        if (result == -1) {
          unint64_t v11 = 0;
        }
        else {
          unint64_t v11 = *(void *)(*(void *)(v11 + 8) + 24 * result + 16);
        }
      }
      uint64_t v12 = **a3;
      if (!v12 || (BOOL result = (uint64_t *)sub_1CBF7A45C(v12, v10), result == -1)) {
        unint64_t v13 = 0;
      }
      else {
        unint64_t v13 = *(void *)(*(void *)(v12 + 8) + 24 * result + 16);
      }
      BOOL v14 = v11 >= v13;
      if (v11 >= v13) {
        uint64_t v15 = v7;
      }
      else {
        uint64_t v15 = a2 - 1;
      }
      *v5++ = *v15;
      if (v14) {
        uint64_t v7 = a2 - 1;
      }
      goto LABEL_16;
    }
    if ((uint64_t)a4 > 8)
    {
      uint64_t v32 = &result[a4 >> 1];
      sub_1CCDAEC70(result, v32, a3, a4 >> 1, a5, a4 >> 1);
      BOOL result = (uint64_t *)sub_1CCDAEC70(&v7[a4 >> 1], a2, a3, a4 - (a4 >> 1), &v5[a4 >> 1], a4 - (a4 >> 1));
      uint64_t v33 = &v7[a4 >> 1];
      while (v33 != a2)
      {
        unint64_t v34 = v33;
        uint64_t v35 = *v7;
        uint64_t v36 = **a3;
        if (!v36 || (BOOL result = (uint64_t *)sub_1CBF7A45C(**a3, *v33), result == -1)) {
          unint64_t v37 = 0;
        }
        else {
          unint64_t v37 = *(void *)(*(void *)(v36 + 8) + 24 * result + 16);
        }
        uint64_t v38 = **a3;
        if (!v38 || (BOOL result = (uint64_t *)sub_1CBF7A45C(**a3, v35), result == -1)) {
          unint64_t v39 = 0;
        }
        else {
          unint64_t v39 = *(void *)(*(void *)(v38 + 8) + 24 * result + 16);
        }
        if (v37 >= v39) {
          BOOL v40 = v7;
        }
        else {
          BOOL v40 = v34;
        }
        uint64_t v33 = &v34[v37 < v39];
        v7 += v37 >= v39;
        *v5++ = *v40;
        if (v7 == v32)
        {
          if (v33 != a2)
          {
            uint64_t v42 = 0;
            unint64_t v43 = &v34[v37 < v39];
            do
            {
              v5[v42] = v43[v42];
              ++v42;
            }
            while (&v43[v42] != a2);
          }
          return result;
        }
      }
      if (v7 != v32)
      {
        uint64_t v41 = 0;
        do
        {
          v5[v41] = v7[v41];
          ++v41;
        }
        while (&v7[v41] != v32);
      }
    }
    else if (result != a2)
    {
      int v16 = result + 1;
      *a5 = *result;
      if (result + 1 != a2)
      {
        uint64_t v17 = 0;
        unint64_t v45 = a5;
        do
        {
          int v18 = v45;
          uint64_t v19 = *v45++;
          uint64_t v20 = **a3;
          if (!v20 || (BOOL result = (uint64_t *)sub_1CBF7A45C(**a3, *v16), result == -1)) {
            unint64_t v21 = 0;
          }
          else {
            unint64_t v21 = *(void *)(*(void *)(v20 + 8) + 24 * result + 16);
          }
          uint64_t v22 = **a3;
          if (!v22 || (BOOL result = (uint64_t *)sub_1CBF7A45C(**a3, v19), result == -1)) {
            unint64_t v23 = 0;
          }
          else {
            unint64_t v23 = *(void *)(*(void *)(v22 + 8) + 24 * result + 16);
          }
          uint64_t v24 = v45;
          if (v21 < v23)
          {
            v18[1] = *v18;
            uint64_t v24 = v5;
            if (v18 != v5)
            {
              uint64_t v25 = v17;
              while (1)
              {
                uint64_t v26 = *(uint64_t *)((char *)v5 + v25 - 8);
                uint64_t v27 = **a3;
                if (!v27 || (BOOL result = (uint64_t *)sub_1CBF7A45C(**a3, *v16), result == -1)) {
                  unint64_t v28 = 0;
                }
                else {
                  unint64_t v28 = *(void *)(*(void *)(v27 + 8) + 24 * result + 16);
                }
                uint64_t v29 = **a3;
                if (!v29 || (BOOL result = (uint64_t *)sub_1CBF7A45C(**a3, v26), result == -1)) {
                  unint64_t v30 = 0;
                }
                else {
                  unint64_t v30 = *(void *)(*(void *)(v29 + 8) + 24 * result + 16);
                }
                if (v28 >= v30) {
                  break;
                }
                *(uint64_t *)((char *)v5 + v25) = *(uint64_t *)((char *)v5 + v25 - 8);
                v25 -= 8;
                if (!v25)
                {
                  uint64_t v24 = v5;
                  goto LABEL_43;
                }
              }
              uint64_t v24 = (uint64_t *)((char *)v5 + v25);
            }
          }
LABEL_43:
          uint64_t v31 = *v16++;
          uint64_t *v24 = v31;
          v17 += 8;
        }
        while (v16 != a2);
      }
    }
  }
  return result;
}

uint64_t *sub_1CCDAF460(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t **a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8)
{
  if (!a6) {
    return result;
  }
  uint64_t v9 = a7;
  uint64_t v10 = a6;
  uint64_t v12 = a4;
  unint64_t v13 = result;
  while (a5 > a8 && v10 > a8)
  {
    if (!a5) {
      return result;
    }
    while (1)
    {
      uint64_t v14 = *v13;
      uint64_t v15 = **v12;
      if (!v15)
      {
        int v16 = a2;
LABEL_17:
        unint64_t v17 = 0;
        goto LABEL_9;
      }
      int v16 = a2;
      BOOL result = (uint64_t *)sub_1CBF7A45C(**v12, *a2);
      if (result == -1) {
        goto LABEL_17;
      }
      unint64_t v17 = *(void *)(*(void *)(v15 + 8) + 24 * result + 16);
LABEL_9:
      uint64_t v18 = **v12;
      if (!v18 || (BOOL result = (uint64_t *)sub_1CBF7A45C(**v12, v14), result == -1)) {
        unint64_t v19 = 0;
      }
      else {
        unint64_t v19 = *(void *)(*(void *)(v18 + 8) + 24 * result + 16);
      }
      if (v17 < v19) {
        break;
      }
      ++v13;
      --a5;
      a2 = v16;
      if (!a5) {
        return result;
      }
    }
    uint64_t v20 = v16;
    uint64_t v83 = v10;
    if (a5 >= v10)
    {
      if (a5 == 1)
      {
        uint64_t v76 = *v13;
        *unint64_t v13 = *v16;
        *int v16 = v76;
        return result;
      }
      if (a5 >= 0) {
        uint64_t v34 = a5;
      }
      else {
        uint64_t v34 = a5 + 1;
      }
      unint64_t v24 = v34 >> 1;
      uint64_t v25 = &v13[v34 >> 1];
      unint64_t v23 = a3;
      unint64_t v22 = a3 - v16;
      if (a3 == v20) {
        goto LABEL_59;
      }
      uint64_t v78 = v34 >> 1;
      uint64_t v80 = a8;
      uint64_t v87 = *v12;
      BOOL v82 = v20;
      unint64_t v23 = v20;
      while (2)
      {
        unint64_t v35 = v22 >> 1;
        uint64_t v36 = &v23[v22 >> 1];
        uint64_t v37 = *v87;
        if (*v87)
        {
          unint64_t v38 = v22;
          uint64_t v39 = *v25;
          unsigned int v40 = sub_1CBF7A45C(*v87, *v36);
          if (v40 == -1) {
            unint64_t v41 = 0;
          }
          else {
            unint64_t v41 = *(void *)(*(void *)(v37 + 8) + 24 * v40 + 16);
          }
          uint64_t v42 = *v87;
          if (*v87)
          {
            unsigned int v43 = sub_1CBF7A45C(*v87, v39);
            if (v43 != -1)
            {
              unint64_t v44 = *(void *)(*(void *)(v42 + 8) + 24 * v43 + 16);
              goto LABEL_49;
            }
          }
        }
        else
        {
          unint64_t v38 = v22;
          unint64_t v41 = 0;
        }
        unint64_t v44 = 0;
LABEL_49:
        BOOL v45 = v41 >= v44;
        if (v41 >= v44) {
          unint64_t v22 = v35;
        }
        else {
          unint64_t v22 = v38 + ~v35;
        }
        if (!v45) {
          unint64_t v23 = v36 + 1;
        }
        if (!v22)
        {
          a8 = v80;
          uint64_t v20 = v82;
          unint64_t v22 = v23 - v82;
          uint64_t v12 = a4;
          unint64_t v24 = v78;
          goto LABEL_59;
        }
        continue;
      }
    }
    if (v10 >= 0) {
      uint64_t v21 = v10;
    }
    else {
      uint64_t v21 = v10 + 1;
    }
    unint64_t v22 = v21 >> 1;
    unint64_t v23 = &v20[v21 >> 1];
    unint64_t v24 = v20 - v13;
    if (v20 == v13)
    {
      unint64_t v13 = v20;
LABEL_65:
      uint64_t v25 = v20;
      int v46 = v23;
      goto LABEL_71;
    }
    uint64_t v86 = v21 >> 1;
    uint64_t v79 = a8;
    unsigned int v81 = v20;
    uint64_t v25 = v13;
    do
    {
      uint64_t v26 = &v25[v24 >> 1];
      uint64_t v27 = *v26;
      uint64_t v28 = **v12;
      if (!v28 || (unsigned int v29 = sub_1CBF7A45C(**v12, *v23), v29 == -1)) {
        unint64_t v30 = 0;
      }
      else {
        unint64_t v30 = *(void *)(*(void *)(v28 + 8) + 24 * v29 + 16);
      }
      uint64_t v31 = **a4;
      if (!v31 || (unsigned int v32 = sub_1CBF7A45C(**a4, v27), v32 == -1)) {
        unint64_t v33 = 0;
      }
      else {
        unint64_t v33 = *(void *)(*(void *)(v31 + 8) + 24 * v32 + 16);
      }
      if (v30 < v33)
      {
        v24 >>= 1;
      }
      else
      {
        uint64_t v25 = v26 + 1;
        v24 += ~(v24 >> 1);
      }
      uint64_t v12 = a4;
    }
    while (v24);
    unint64_t v24 = v25 - v13;
    a8 = v79;
    uint64_t v20 = v81;
    unint64_t v22 = v86;
LABEL_59:
    if (v25 == v20) {
      goto LABEL_65;
    }
    if (v20 == v23)
    {
      unint64_t v23 = v20;
      int v46 = v25;
    }
    else if (v25 + 1 == v20)
    {
      uint64_t v47 = *v25;
      int64_t v48 = (char *)v23 - (char *)v20;
      memmove(v25, v20, (char *)v23 - (char *)v20);
      int v46 = (uint64_t *)((char *)v25 + v48);
      *int v46 = v47;
    }
    else if (v20 + 1 == v23)
    {
      uint64_t v49 = *(v23 - 1);
      int v46 = v25 + 1;
      if (v23 - 1 != v25) {
        memmove(v25 + 1, v25, (char *)(v23 - 1) - (char *)v25);
      }
      uint64_t *v25 = v49;
    }
    else
    {
      int v46 = sub_1CC057214(v25, v20, v23);
    }
LABEL_71:
    a5 -= v24;
    unint64_t v50 = v83 - v22;
    if ((uint64_t)(v22 + v24) >= (uint64_t)(v83 - v22 + a5))
    {
      BOOL result = (uint64_t *)sub_1CCDAF460(v46, v23, a3, v12, a5, v83 - v22, a7, a8);
      unint64_t v23 = v25;
      uint64_t v9 = a7;
      unint64_t v50 = v22;
      a5 = v24;
      a3 = v46;
    }
    else
    {
      uint64_t v51 = v25;
      uint64_t v9 = a7;
      BOOL result = (uint64_t *)sub_1CCDAF460(v13, v51, v46, v12, v24, v22, a7, a8);
      unint64_t v13 = v46;
    }
    a2 = v23;
    uint64_t v10 = v50;
    if (!v50) {
      return result;
    }
  }
  if (a5 <= v10)
  {
    if (v13 == a2) {
      return result;
    }
    uint64_t v64 = 0;
    do
    {
      v9[v64] = v13[v64];
      ++v64;
    }
    while (&v13[v64] != a2);
    if (!(v64 * 8)) {
      return result;
    }
    unsigned int v65 = v9;
    while (1)
    {
      if (a2 == a3)
      {
        return (uint64_t *)memmove(v13, v65, (char *)v9 - (char *)v65 + v64 * 8);
      }
      uint64_t v66 = *v65;
      uint64_t v67 = **v12;
      if (v67)
      {
        uint64_t v68 = a2;
        BOOL result = (uint64_t *)sub_1CBF7A45C(**v12, *a2);
        if (result != -1)
        {
          unint64_t v69 = *(void *)(*(void *)(v67 + 8) + 24 * result + 16);
          goto LABEL_111;
        }
      }
      else
      {
        uint64_t v68 = a2;
      }
      unint64_t v69 = 0;
LABEL_111:
      uint64_t v70 = **v12;
      if (!v70 || (BOOL result = (uint64_t *)sub_1CBF7A45C(**v12, v66), result == -1)) {
        unint64_t v71 = 0;
      }
      else {
        unint64_t v71 = *(void *)(*(void *)(v70 + 8) + 24 * result + 16);
      }
      BOOL v72 = v69 >= v71;
      BOOL v73 = v69 < v71;
      unsigned int v74 = v72;
      if (v72) {
        uint64_t v75 = v65;
      }
      else {
        uint64_t v75 = v68;
      }
      v65 += v74;
      a2 = &v68[v73];
      *v13++ = *v75;
      if (&v9[v64] == v65) {
        return result;
      }
    }
  }
  if (a2 == a3) {
    return result;
  }
  uint64_t v52 = 0;
  do
  {
    v9[v52] = a2[v52];
    ++v52;
  }
  while (&a2[v52] != a3);
  if (!(v52 * 8)) {
    return result;
  }
  unint64_t v53 = &v9[v52];
  BOOL v54 = a3 - 1;
  while (a2 != v13)
  {
    uint64_t v55 = a2;
    unint64_t v57 = a2 - 1;
    uint64_t v56 = *(a2 - 1);
    uint64_t v58 = **v12;
    if (!v58 || (BOOL result = (uint64_t *)sub_1CBF7A45C(**v12, *(v53 - 1)), result == -1)) {
      unint64_t v59 = 0;
    }
    else {
      unint64_t v59 = *(void *)(*(void *)(v58 + 8) + 24 * result + 16);
    }
    uint64_t v60 = **v12;
    if (!v60 || (BOOL result = (uint64_t *)sub_1CBF7A45C(**v12, v56), result == -1)) {
      unint64_t v61 = 0;
    }
    else {
      unint64_t v61 = *(void *)(*(void *)(v60 + 8) + 24 * result + 16);
    }
    BOOL v62 = v59 >= v61;
    if (v59 >= v61) {
      long long v63 = v53;
    }
    else {
      long long v63 = v55;
    }
    if (v62) {
      a2 = v55;
    }
    else {
      a2 = v57;
    }
    if (v62) {
      --v53;
    }
    *v54-- = *(v63 - 1);
    uint64_t v9 = a7;
    if (v53 == a7) {
      return result;
    }
  }
  if (v53 != v9)
  {
    uint64_t v77 = 0;
    do
    {
      v54[v77] = v53[v77 - 1];
      --v77;
    }
    while (&v53[v77] != v9);
  }
  return result;
}

unint64_t sub_1CCDAFAEC(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  unsigned int v5 = *(_DWORD *)(a1 + 20);
  if (v4 == *(void *)a1) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = *(unsigned int *)(a1 + 16);
  }
  if (v6)
  {
    uint64_t v7 = 8 * v6;
    uint64_t v8 = *(uint64_t **)(a1 + 8);
    while ((unint64_t)*v8 >= 0xFFFFFFFFFFFFFFFELL)
    {
      ++v8;
      v7 -= 8;
      if (!v7) {
        goto LABEL_23;
      }
    }
  }
  else
  {
    uint64_t v8 = *(uint64_t **)(a1 + 8);
  }
  uint64_t v9 = (void *)(v4 + 8 * v6);
  if (v8 == v9)
  {
LABEL_23:
    unint64_t v10 = 0;
  }
  else
  {
    unint64_t v10 = 0;
LABEL_12:
    uint64_t v11 = *a2;
    if (!*a2 || (unsigned int v12 = sub_1CBF7A45C(*a2, *v8), v12 == -1)) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = *(void *)(*(void *)(v11 + 8) + 24 * v12 + 16);
    }
    BOOL v14 = __CFADD__(v13, v10);
    unint64_t v15 = v13 + v10;
    if (v14) {
      unint64_t v10 = -1;
    }
    else {
      unint64_t v10 = v15;
    }
    int v16 = (unint64_t *)(v8 + 1);
    while (v16 != v9)
    {
      unint64_t v17 = *v16++;
      if (v17 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        uint64_t v8 = (uint64_t *)(v16 - 1);
        goto LABEL_12;
      }
    }
    unsigned int v5 = *(_DWORD *)(a1 + 20);
  }
  if (v5 - *(_DWORD *)(a1 + 24) > 1)
  {
    int v19 = (unint64_t)(((((unint64_t)dword_1EBCF3530 << 31) | 0x30)
                            * (unsigned __int128)0xA3D70A3D70A3D70BLL) >> 64) >> 6;
    return llvm::BranchProbability::scaleByInverse((llvm::BranchProbability *)&v19, v10);
  }
  return v10;
}

uint64_t sub_1CCDAFC34(uint64_t result, uint64_t *a2, uint64_t *a3, uint64_t a4, char a5)
{
  uint64_t v118 = (uint64_t *)result;
  while (2)
  {
    int v111 = a2 - 2;
    unsigned int v113 = a2 - 1;
    uint64_t v110 = a2 - 3;
    uint64_t v11 = v118;
    BOOL v116 = a2;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unsigned int v12 = v11;
          uint64_t v13 = (char *)a2 - (char *)v11;
          uint64_t v14 = a2 - v11;
          uint64_t v118 = v12;
          if (v6 || !v5)
          {
            switch(v14)
            {
              case 0:
              case 1:
                return result;
              case 2:
                uint64_t v107 = *v12;
                int v108 = *(_DWORD *)(sub_1CD76F0C4(*a3, *(a2 - 1)) + 8);
                BOOL result = sub_1CD76F0C4(*a3, v107);
                if (v108 < *(_DWORD *)(result + 8))
                {
                  uint64_t v109 = *v12;
                  uint64_t *v12 = *(v116 - 1);
                  *(v116 - 1) = v109;
                }
                break;
              case 3:
                BOOL result = sub_1CCDB077C(v12, v12 + 1, v113, a3);
                break;
              case 4:
                BOOL result = sub_1CCDB0AE8(v12, v12 + 1, v12 + 2, v113, a3);
                break;
              case 5:
                BOOL result = sub_1CCDB0634(v12, v12 + 1, v12 + 2, v12 + 3, v113, a3);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v13 <= 191)
          {
            BOOL v54 = v12 + 1;
            BOOL v56 = v12 == a2 || v54 == a2;
            if (a5)
            {
              if (!v56)
              {
                uint64_t v57 = 0;
                do
                {
                  uint64_t v59 = *v12;
                  uint64_t v58 = v12[1];
                  unsigned int v12 = v54;
                  int v60 = *(_DWORD *)(sub_1CD76F0C4(*a3, v58) + 8);
                  BOOL result = sub_1CD76F0C4(*a3, v59);
                  unint64_t v61 = v116;
                  if (v60 < *(_DWORD *)(result + 8))
                  {
                    uint64_t v62 = *v12;
                    uint64_t v63 = v57;
                    while (1)
                    {
                      *(uint64_t *)((char *)v118 + v63 + 8) = *(uint64_t *)((char *)v118 + v63);
                      if (!v63) {
                        break;
                      }
                      uint64_t v64 = *(uint64_t *)((char *)v118 + v63 - 8);
                      int v65 = *(_DWORD *)(sub_1CD76F0C4(*a3, v62) + 8);
                      BOOL result = sub_1CD76F0C4(*a3, v64);
                      v63 -= 8;
                      unint64_t v61 = v116;
                      if (v65 >= *(_DWORD *)(result + 8))
                      {
                        uint64_t v66 = (uint64_t *)((char *)v118 + v63 + 8);
                        goto LABEL_77;
                      }
                    }
                    uint64_t v66 = v118;
LABEL_77:
                    *uint64_t v66 = v62;
                  }
                  BOOL v54 = v12 + 1;
                  v57 += 8;
                }
                while (v12 + 1 != v61);
              }
            }
            else if (!v56)
            {
              do
              {
                uint64_t v98 = *v118;
                int v99 = v54;
                int v100 = *(_DWORD *)(sub_1CD76F0C4(*a3, v118[1]) + 8);
                BOOL result = sub_1CD76F0C4(*a3, v98);
                if (v100 < *(_DWORD *)(result + 8))
                {
                  uint64_t v101 = *v99;
                  int v102 = v99;
                  do
                  {
                    __int32 v103 = v102;
                    uint64_t v104 = *--v102;
                    *__int32 v103 = v104;
                    uint64_t v105 = *(v103 - 2);
                    int v106 = *(_DWORD *)(sub_1CD76F0C4(*a3, v101) + 8);
                    BOOL result = sub_1CD76F0C4(*a3, v105);
                  }
                  while (v106 < *(_DWORD *)(result + 8));
                  *int v102 = v101;
                }
                uint64_t v118 = v99;
                BOOL v54 = v99 + 1;
              }
              while (v99 + 1 != v116);
            }
            return result;
          }
          if (!a4)
          {
            if (v12 != a2)
            {
              int64_t v67 = (unint64_t)(v14 - 2) >> 1;
              int64_t v68 = v67;
              do
              {
                int64_t v69 = v68;
                if (v67 >= v68)
                {
                  uint64_t v70 = (2 * v68) | 1;
                  unint64_t v71 = &v118[v70];
                  if (2 * v68 + 2 < v14)
                  {
                    uint64_t v72 = v71[1];
                    int v73 = *(_DWORD *)(sub_1CD76F0C4(*a3, *v71) + 8);
                    if (v73 < *(_DWORD *)(sub_1CD76F0C4(*a3, v72) + 8))
                    {
                      ++v71;
                      uint64_t v70 = 2 * v69 + 2;
                    }
                  }
                  unsigned int v74 = &v118[v69];
                  uint64_t v75 = *v74;
                  int v76 = *(_DWORD *)(sub_1CD76F0C4(*a3, *v71) + 8);
                  BOOL result = sub_1CD76F0C4(*a3, v75);
                  BOOL v77 = v76 < *(_DWORD *)(result + 8);
                  a2 = v116;
                  if (!v77)
                  {
                    uint64_t v114 = *v74;
                    do
                    {
                      uint64_t v78 = v71;
                      uint64_t *v74 = *v71;
                      if (v67 < v70) {
                        break;
                      }
                      uint64_t v79 = (2 * v70) | 1;
                      unint64_t v71 = &v118[v79];
                      uint64_t v80 = 2 * v70 + 2;
                      if (v80 < v14)
                      {
                        uint64_t v112 = v71[1];
                        int v81 = *(_DWORD *)(sub_1CD76F0C4(*a3, *v71) + 8);
                        if (v81 < *(_DWORD *)(sub_1CD76F0C4(*a3, v112) + 8))
                        {
                          ++v71;
                          uint64_t v79 = v80;
                        }
                      }
                      int v82 = *(_DWORD *)(sub_1CD76F0C4(*a3, *v71) + 8);
                      BOOL result = sub_1CD76F0C4(*a3, v114);
                      unsigned int v74 = v78;
                      uint64_t v70 = v79;
                      BOOL v77 = v82 < *(_DWORD *)(result + 8);
                      a2 = v116;
                    }
                    while (!v77);
                    *uint64_t v78 = v114;
                  }
                }
                int64_t v68 = v69 - 1;
              }
              while (v69);
              do
              {
                uint64_t v83 = 0;
                uint64_t v84 = v118;
                uint64_t v115 = *v118;
                uint64_t v117 = a2;
                do
                {
                  unsigned int v85 = &v84[v83 + 1];
                  uint64_t v86 = (2 * v83) | 1;
                  uint64_t v87 = 2 * v83 + 2;
                  if (v87 < v14)
                  {
                    uint64_t v88 = v84[v83 + 2];
                    int v89 = *(_DWORD *)(sub_1CD76F0C4(*a3, *v85) + 8);
                    BOOL result = sub_1CD76F0C4(*a3, v88);
                    if (v89 < *(_DWORD *)(result + 8))
                    {
                      ++v85;
                      uint64_t v86 = v87;
                    }
                  }
                  uint64_t *v84 = *v85;
                  uint64_t v84 = v85;
                  uint64_t v83 = v86;
                }
                while (v86 <= (uint64_t)((unint64_t)(v14 - 2) >> 1));
                a2 = v117 - 1;
                if (v85 == v117 - 1)
                {
                  *unsigned int v85 = v115;
                }
                else
                {
                  *unsigned int v85 = *a2;
                  *a2 = v115;
                  uint64_t v90 = (char *)v85 - (char *)v118 + 8;
                  if (v90 >= 9)
                  {
                    unint64_t v91 = (((unint64_t)v90 >> 3) - 2) >> 1;
                    uint64_t v92 = &v118[v91];
                    uint64_t v93 = *v85;
                    int v94 = *(_DWORD *)(sub_1CD76F0C4(*a3, *v92) + 8);
                    BOOL result = sub_1CD76F0C4(*a3, v93);
                    if (v94 < *(_DWORD *)(result + 8))
                    {
                      uint64_t v95 = *v85;
                      do
                      {
                        uint64_t v96 = v92;
                        *unsigned int v85 = *v92;
                        if (!v91) {
                          break;
                        }
                        unint64_t v91 = (v91 - 1) >> 1;
                        uint64_t v92 = &v118[v91];
                        int v97 = *(_DWORD *)(sub_1CD76F0C4(*a3, *v92) + 8);
                        BOOL result = sub_1CD76F0C4(*a3, v95);
                        unsigned int v85 = v96;
                      }
                      while (v97 < *(_DWORD *)(result + 8));
                      uint64_t *v96 = v95;
                    }
                  }
                }
                BOOL v77 = v14-- <= 2;
              }
              while (!v77);
            }
            return result;
          }
          unint64_t v15 = (unint64_t)v14 >> 1;
          int v16 = &v12[(unint64_t)v14 >> 1];
          if ((unint64_t)v13 < 0x401)
          {
            sub_1CCDB077C(v16, v12, v113, a3);
          }
          else
          {
            sub_1CCDB077C(v12, v16, v113, a3);
            sub_1CCDB077C(v12 + 1, v16 - 1, v111, a3);
            sub_1CCDB077C(v12 + 2, &v12[v15 + 1], v110, a3);
            sub_1CCDB077C(v16 - 1, v16, &v12[v15 + 1], a3);
            uint64_t v17 = *v12;
            uint64_t *v12 = *v16;
            *int v16 = v17;
          }
          --a4;
          a2 = v116;
          if (a5) {
            break;
          }
          uint64_t v35 = *v12;
          int v36 = *(_DWORD *)(sub_1CD76F0C4(*a3, *(v12 - 1)) + 8);
          if (v36 < *(_DWORD *)(sub_1CD76F0C4(*a3, v35) + 8)) {
            break;
          }
          uint64_t v37 = *v12;
          uint64_t v38 = *v113;
          int v39 = *(_DWORD *)(sub_1CD76F0C4(*a3, *v12) + 8);
          BOOL result = sub_1CD76F0C4(*a3, v38);
          if (v39 >= *(_DWORD *)(result + 8))
          {
            uint64_t v51 = v12 + 1;
            do
            {
              uint64_t v11 = v51;
              if (v51 >= v116) {
                break;
              }
              ++v51;
              uint64_t v52 = *v11;
              int v53 = *(_DWORD *)(sub_1CD76F0C4(*a3, v37) + 8);
              BOOL result = sub_1CD76F0C4(*a3, v52);
            }
            while (v53 >= *(_DWORD *)(result + 8));
          }
          else
          {
            uint64_t v11 = v12;
            do
            {
              uint64_t v40 = v11[1];
              ++v11;
              int v41 = *(_DWORD *)(sub_1CD76F0C4(*a3, v37) + 8);
              BOOL result = sub_1CD76F0C4(*a3, v40);
            }
            while (v41 >= *(_DWORD *)(result + 8));
          }
          uint64_t v42 = v116;
          if (v11 < v116)
          {
            uint64_t v42 = v116;
            do
            {
              uint64_t v43 = *--v42;
              int v44 = *(_DWORD *)(sub_1CD76F0C4(*a3, v37) + 8);
              BOOL result = sub_1CD76F0C4(*a3, v43);
            }
            while (v44 < *(_DWORD *)(result + 8));
          }
          while (v11 < v42)
          {
            uint64_t v45 = *v11;
            *uint64_t v11 = *v42;
            uint64_t *v42 = v45;
            do
            {
              uint64_t v46 = v11[1];
              ++v11;
              int v47 = *(_DWORD *)(sub_1CD76F0C4(*a3, v37) + 8);
            }
            while (v47 >= *(_DWORD *)(sub_1CD76F0C4(*a3, v46) + 8));
            do
            {
              uint64_t v48 = *--v42;
              int v49 = *(_DWORD *)(sub_1CD76F0C4(*a3, v37) + 8);
              BOOL result = sub_1CD76F0C4(*a3, v48);
            }
            while (v49 < *(_DWORD *)(result + 8));
          }
          unint64_t v50 = v11 - 1;
          BOOL v5 = v11 - 1 >= v12;
          BOOL v6 = v11 - 1 == v12;
          if (v11 - 1 != v12) {
            uint64_t *v12 = *v50;
          }
          a5 = 0;
          *unint64_t v50 = v37;
        }
        uint64_t v18 = 0;
        uint64_t v19 = *v12;
        do
          int v20 = *(_DWORD *)(sub_1CD76F0C4(*a3, v12[++v18]) + 8);
        while (v20 < *(_DWORD *)(sub_1CD76F0C4(*a3, v19) + 8));
        uint64_t v21 = &v12[v18];
        unint64_t v22 = v116;
        if (v18 == 1)
        {
          unint64_t v22 = v116;
          do
          {
            if (v21 >= v22) {
              break;
            }
            uint64_t v33 = *--v22;
            int v34 = *(_DWORD *)(sub_1CD76F0C4(*a3, v33) + 8);
          }
          while (v34 >= *(_DWORD *)(sub_1CD76F0C4(*a3, v19) + 8));
        }
        else
        {
          do
          {
            uint64_t v23 = *--v22;
            int v24 = *(_DWORD *)(sub_1CD76F0C4(*a3, v23) + 8);
          }
          while (v24 >= *(_DWORD *)(sub_1CD76F0C4(*a3, v19) + 8));
        }
        uint64_t v11 = v21;
        if (v21 < v22)
        {
          uint64_t v25 = v22;
          do
          {
            uint64_t v26 = *v11;
            *uint64_t v11 = *v25;
            uint64_t *v25 = v26;
            do
            {
              uint64_t v27 = v11[1];
              ++v11;
              int v28 = *(_DWORD *)(sub_1CD76F0C4(*a3, v27) + 8);
            }
            while (v28 < *(_DWORD *)(sub_1CD76F0C4(*a3, v19) + 8));
            do
            {
              uint64_t v29 = *--v25;
              int v30 = *(_DWORD *)(sub_1CD76F0C4(*a3, v29) + 8);
            }
            while (v30 >= *(_DWORD *)(sub_1CD76F0C4(*a3, v19) + 8));
          }
          while (v11 < v25);
        }
        uint64_t v31 = v11 - 1;
        if (v11 - 1 != v118) {
          *uint64_t v118 = *v31;
        }
        uint64_t *v31 = v19;
        if (v21 >= v22) {
          break;
        }
LABEL_26:
        BOOL result = sub_1CCDAFC34(v118, v11 - 1, a3, a4, a5 & 1);
        a5 = 0;
      }
      BOOL v32 = sub_1CCDB08CC(v118, v11 - 1, a3);
      BOOL result = sub_1CCDB08CC(v11, v116, a3);
      if (result) {
        break;
      }
      if (!v32) {
        goto LABEL_26;
      }
    }
    a2 = v11 - 1;
    if (!v32) {
      continue;
    }
    return result;
  }
}

uint64_t sub_1CCDB0634(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  sub_1CCDB0AE8(a1, a2, a3, a4, a6);
  uint64_t v12 = *a4;
  int v13 = *(_DWORD *)(sub_1CD76F0C4(*a6, *a5) + 8);
  uint64_t result = sub_1CD76F0C4(*a6, v12);
  if (v13 < *(_DWORD *)(result + 8))
  {
    uint64_t v15 = *a4;
    *a4 = *a5;
    *a5 = v15;
    uint64_t v16 = *a3;
    int v17 = *(_DWORD *)(sub_1CD76F0C4(*a6, *a4) + 8);
    uint64_t result = sub_1CD76F0C4(*a6, v16);
    if (v17 < *(_DWORD *)(result + 8))
    {
      uint64_t v18 = *a3;
      *a3 = *a4;
      *a4 = v18;
      uint64_t v19 = *a2;
      int v20 = *(_DWORD *)(sub_1CD76F0C4(*a6, *a3) + 8);
      uint64_t result = sub_1CD76F0C4(*a6, v19);
      if (v20 < *(_DWORD *)(result + 8))
      {
        uint64_t v21 = *a2;
        *a2 = *a3;
        *a3 = v21;
        uint64_t v22 = *a1;
        int v23 = *(_DWORD *)(sub_1CD76F0C4(*a6, *a2) + 8);
        uint64_t result = sub_1CD76F0C4(*a6, v22);
        if (v23 < *(_DWORD *)(result + 8))
        {
          uint64_t v24 = *a1;
          *a1 = *a2;
          *a2 = v24;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1CCDB077C(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8 = *a1;
  int v9 = *(_DWORD *)(sub_1CD76F0C4(*a4, *a2) + 8);
  int v10 = *(_DWORD *)(sub_1CD76F0C4(*a4, v8) + 8);
  uint64_t v11 = *a2;
  int v12 = *(_DWORD *)(sub_1CD76F0C4(*a4, *a3) + 8);
  uint64_t result = sub_1CD76F0C4(*a4, v11);
  int v14 = *(_DWORD *)(result + 8);
  if (v9 >= v10)
  {
    if (v12 < v14)
    {
      uint64_t v18 = *a2;
      *a2 = *a3;
      *a3 = v18;
      uint64_t v19 = *a1;
      int v20 = *(_DWORD *)(sub_1CD76F0C4(*a4, *a2) + 8);
      uint64_t result = sub_1CD76F0C4(*a4, v19);
      if (v20 < *(_DWORD *)(result + 8))
      {
        uint64_t v21 = *a1;
        *a1 = *a2;
        *a2 = v21;
      }
    }
  }
  else
  {
    uint64_t v15 = *a1;
    if (v12 >= v14)
    {
      *a1 = *a2;
      *a2 = v15;
      int v16 = *(_DWORD *)(sub_1CD76F0C4(*a4, *a3) + 8);
      uint64_t result = sub_1CD76F0C4(*a4, v15);
      if (v16 < *(_DWORD *)(result + 8))
      {
        uint64_t v17 = *a2;
        *a2 = *a3;
        *a3 = v17;
      }
    }
    else
    {
      *a1 = *a3;
      *a3 = v15;
    }
  }
  return result;
}

BOOL sub_1CCDB08CC(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v19 = *a1;
      int v20 = *(_DWORD *)(sub_1CD76F0C4(*a3, *(a2 - 1)) + 8);
      if (v20 < *(_DWORD *)(sub_1CD76F0C4(*a3, v19) + 8))
      {
        uint64_t v21 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v21;
      }
      return 1;
    case 3:
      sub_1CCDB077C(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      sub_1CCDB0AE8(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      sub_1CCDB0634(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      uint64_t v8 = a1 + 2;
      sub_1CCDB077C(a1, a1 + 1, a1 + 2, a3);
      int v9 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    uint64_t v12 = *v8;
    int v13 = *(_DWORD *)(sub_1CD76F0C4(*a3, *v9) + 8);
    if (v13 < *(_DWORD *)(sub_1CD76F0C4(*a3, v12) + 8))
    {
      uint64_t v14 = *v9;
      uint64_t v15 = v10;
      while (1)
      {
        *(uint64_t *)((char *)a1 + v15 + 24) = *(uint64_t *)((char *)a1 + v15 + 16);
        if (v15 == -16) {
          break;
        }
        uint64_t v16 = *(uint64_t *)((char *)a1 + v15 + 8);
        int v17 = *(_DWORD *)(sub_1CD76F0C4(*a3, v14) + 8);
        v15 -= 8;
        if (v17 >= *(_DWORD *)(sub_1CD76F0C4(*a3, v16) + 8))
        {
          uint64_t v18 = (uint64_t *)((char *)a1 + v15 + 24);
          goto LABEL_11;
        }
      }
      uint64_t v18 = a1;
LABEL_11:
      *uint64_t v18 = v14;
      if (++v11 == 8) {
        return v9 + 1 == a2;
      }
    }
    uint64_t v8 = v9;
    v10 += 8;
    BOOL result = 1;
    if (++v9 == a2) {
      return result;
    }
  }
}

uint64_t sub_1CCDB0AE8(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  sub_1CCDB077C(a1, a2, a3, a5);
  uint64_t v10 = *a3;
  int v11 = *(_DWORD *)(sub_1CD76F0C4(*a5, *a4) + 8);
  uint64_t result = sub_1CD76F0C4(*a5, v10);
  if (v11 < *(_DWORD *)(result + 8))
  {
    uint64_t v13 = *a3;
    *a3 = *a4;
    *a4 = v13;
    uint64_t v14 = *a2;
    int v15 = *(_DWORD *)(sub_1CD76F0C4(*a5, *a3) + 8);
    uint64_t result = sub_1CD76F0C4(*a5, v14);
    if (v15 < *(_DWORD *)(result + 8))
    {
      uint64_t v16 = *a2;
      *a2 = *a3;
      *a3 = v16;
      uint64_t v17 = *a1;
      int v18 = *(_DWORD *)(sub_1CD76F0C4(*a5, *a2) + 8);
      uint64_t result = sub_1CD76F0C4(*a5, v17);
      if (v18 < *(_DWORD *)(result + 8))
      {
        uint64_t v19 = *a1;
        *a1 = *a2;
        *a2 = v19;
      }
    }
  }
  return result;
}

BOOL sub_1CCDB0BF0(void *a1, uint64_t a2)
{
  return *(void *)(*(void *)(a2 + 24) + 40) == *a1;
}

void sub_1CCDB0C08()
{
}

void sub_1CCDB0C48(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCDB0C80(llvm::PassRegistry *a1, llvm *a2)
{
  uint64_t v3 = (uint64_t)a2 + 112;
  v6[0] = &unk_1F2617E40;
  v6[1] = (char *)a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v6);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::BlockFrequencyInfoWrapperPass::ID);
  llvm::getLoopAnalysisUsage(a2, v5);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::MemorySSAWrapperPass::ID);

  sub_1CB843600((uint64_t)a2, v3, (uint64_t)&llvm::MemorySSAWrapperPass::ID);
}

uint64_t sub_1CCDB0D30(llvm::LoopPass *a1, const llvm::Loop *a2)
{
  if ((llvm::LoopPass::skipLoop(a1, a2) & 1) == 0) {
    llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopPredecessor();
  }
  return 0;
}

uint64_t sub_1CCDB112C()
{
  int v4 = 1;
  int v2 = 90;
  uint64_t v3 = &v2;
  *(void *)&long long v1 = "Do not sink instructions that require cloning unless they execute less than this percent of the time.";
  *((void *)&v1 + 1) = 101;
  sub_1CD45A86C((uint64_t)&unk_1EBCF34B0, "sink-freq-percent-threshold", &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF34B0, &dword_1CB82C000);
  int v4 = 1;
  int v2 = 30;
  uint64_t v3 = &v2;
  *(void *)&long long v1 = "Do not sink instructions that have too many uses.";
  *((void *)&v1 + 1) = 49;
  sub_1CD45A86C((uint64_t)&unk_1EBCF3570, "max-uses-for-sinking", &v4, &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF3570, &dword_1CB82C000);
}

void llvm::LoopDeletionPass::run(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(llvm::Value ***)(a2 + 32);
  if (v3 && (*((unsigned char *)v3 + 23) & 0x10) != 0)
  {
    Name = llvm::Value::getName(v3);
    if (v7 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    size_t v4 = v7;
    if (v7 >= 0x17)
    {
      uint64_t v8 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v7 | 7) != 0x17) {
        uint64_t v8 = v7 | 7;
      }
      uint64_t v9 = v8 + 1;
      BOOL v5 = operator new(v8 + 1);
      __dst[1] = v4;
      unint64_t v13 = v9 | 0x8000000000000000;
      __dst[0] = v5;
    }
    else
    {
      HIBYTE(v13) = v7;
      BOOL v5 = __dst;
      if (!v7)
      {
LABEL_5:
        *((unsigned char *)v5 + v4) = 0;
        llvm::OptimizationRemarkEmitter::OptimizationRemarkEmitter(&v11, *(const llvm::Function **)(**(void **)(a2 + 32) + 56));
        sub_1CCDB1484();
      }
    }
    uint64_t v6 = Name;
  }
  else
  {
    size_t v4 = 14;
    HIBYTE(v13) = 14;
    BOOL v5 = __dst;
    uint64_t v6 = "<unnamed loop>";
  }
  memmove(v5, v6, v4);
  goto LABEL_5;
}

void sub_1CCDB1484()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopPredecessor();
}

void sub_1CCDB21EC()
{
}

void sub_1CCDB4604(llvm *a1, llvm::PassRegistry *a2)
{
}

uint64_t sub_1CCDB46A4(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF36F0;
  *(_DWORD *)(a1 + 24) = 1;
  *(void *)a1 = &unk_1F263E8B8;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF36F8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCDB4604;
    v5[1] = &PassRegistry;
    size_t v4 = v5;
    std::__call_once(&qword_1EBCF36F8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

const llvm::detail::DoubleAPFloat *sub_1CCDB4754(unsigned __int8 *a1, uint64_t a2, const llvm::DataLayout *a3)
{
  uint64_t v3 = (const llvm::detail::DoubleAPFloat *)a1;
  uint64_t v17 = a1;
  if (a1[16] >= 0x1Cu)
  {
    int v18 = a1;
    uint64_t v19 = 0;
    if (!sub_1CBA0E618(a2, &v18, &v19) || v19 == *(void *)a2 + 16 * *(unsigned int *)(a2 + 16))
    {
      unsigned int v6 = *((unsigned __int8 *)v3 + 16);
      if (v6 >= 0x1C && v6 - 59 >= 0xFFFFFFEE)
      {
        uint64_t v11 = (llvm *)sub_1CCDB4754(*((void *)v3 - 8), a2, a3);
        uint64_t v12 = (llvm::Constant *)sub_1CCDB4754(*((void *)v3 - 4), a2, a3);
        uint64_t v10 = sub_1CC03A350(*((unsigned __int8 *)v3 + 16) - 28, v11, v12, a3, (llvm::DSOLocalEquivalent **)3);
      }
      else if (v6 == 85)
      {
        unint64_t v13 = (llvm::Constant *)sub_1CCDB4754(*((void *)v3 - 12), a2, a3);
        uint64_t v10 = 0;
        if (v13 && *((unsigned char *)v13 + 16) == 16)
        {
          BOOL isAllOnesValue = llvm::Constant::isAllOnesValue(v13);
          uint64_t v15 = -32;
          if (isAllOnesValue) {
            uint64_t v15 = -64;
          }
          uint64_t v10 = (const llvm::detail::DoubleAPFloat *)sub_1CCDB4754(*(void *)((char *)v3 + v15), a2, a3);
        }
      }
      else if (v6 == 81)
      {
        uint64_t v8 = (unsigned __int8 *)sub_1CCDB4754(*((void *)v3 - 8), a2, a3);
        uint64_t v9 = (unsigned __int8 *)sub_1CCDB4754(*((void *)v3 - 4), a2, a3);
        uint64_t v10 = sub_1CC02F0F0(*((_WORD *)v3 + 9) & 0x3F, v8, v9, (uint64_t)a3, (llvm::SmallPtrSetImplBase *)3);
      }
      else
      {
        uint64_t v10 = 0;
      }
      if (v10) {
        uint64_t v3 = v10;
      }
      sub_1CC27AF70((uint64_t *)a2, &v17)[1] = v3;
    }
    else
    {
      return *(const llvm::detail::DoubleAPFloat **)(v19 + 8);
    }
  }
  return v3;
}

uint64_t sub_1CCDB48F4@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CCDB497C((uint64_t *)a1, a2, &v10);
  unint64_t v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CCDB4B6C(a1, (uint64_t)a2, a2, v10);
    unint64_t v7 = (void *)result;
    *(_OWORD *)uint64_t result = *(_OWORD *)a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 16 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CCDB497C(uint64_t *a1, _DWORD *a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v6 = *a1;
    int v7 = (*a2 >> 4) ^ (*a2 >> 9);
    int v23 = (a2[2] >> 4) ^ (a2[2] >> 9);
    int v24 = v7;
    int v8 = sub_1CCDB4A74(&v24, &v23);
    int v9 = v4 - 1;
    unsigned int v10 = (v4 - 1) & v8;
    uint64_t v11 = *((void *)a2 + 1);
    uint64_t v12 = (void *)(v6 + 16 * v10);
    uint64_t v13 = *v12;
    uint64_t v14 = v12[1];
    if (*(void *)a2 == *v12 && v11 == v14)
    {
LABEL_22:
      uint64_t result = 1;
    }
    else
    {
      uint64_t v16 = 0;
      int v17 = 1;
      while (v13 != -4096 || v14 != -4096)
      {
        if (v16) {
          BOOL v18 = 0;
        }
        else {
          BOOL v18 = v14 == -8192;
        }
        if (v18 && v13 == -8192) {
          uint64_t v16 = v12;
        }
        unsigned int v20 = v10 + v17++;
        unsigned int v10 = v20 & v9;
        uint64_t v12 = (void *)(v6 + 16 * (v20 & v9));
        uint64_t v13 = *v12;
        uint64_t v14 = v12[1];
        if (*(void *)a2 == *v12 && v11 == v14) {
          goto LABEL_22;
        }
      }
      uint64_t result = 0;
      if (v16) {
        uint64_t v12 = v16;
      }
    }
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t result = 0;
  }
  *a3 = v12;
  return result;
}

unint64_t sub_1CCDB4A74(int *a1, int *a2)
{
  int v2 = a2;
  uint64_t v3 = a1;
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = 0;
  memset(v11, 0, sizeof(v11));
  memset(v10, 0, sizeof(v10));
  int v4 = &unk_1EBCBE000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
  {
    int v6 = __cxa_guard_acquire(&qword_1EBCBE588);
    int v4 = &unk_1EBCBE000;
    uint64_t v3 = a1;
    int v2 = a2;
    if (v6)
    {
      unint64_t v7 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v7 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v7;
      __cxa_guard_release(&qword_1EBCBE588);
      int v4 = (void *)&unk_1EBCBE000;
      uint64_t v3 = a1;
      int v2 = a2;
    }
  }
  uint64_t v13 = v4[176];
  return sub_1CC36B194((char *)v10, 0, v10, (char *)v11, v3, v2);
}

void *sub_1CCDB4B6C(uint64_t a1, uint64_t a2, _DWORD *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_7;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
  {
LABEL_7:
    sub_1CCDB4C2C(a1, v7);
    int v9 = 0;
    sub_1CCDB497C((uint64_t *)a1, a3, &v9);
    a4 = v9;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096 || a4[1] != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void sub_1CCDB4C2C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  int v9 = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = v9;
  if (v4)
  {
    sub_1CCDB4D10(a1, v4, v4 + 16 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    memset_pattern16(v9, &unk_1CFAC3070, 16 * v10);
  }
}

void sub_1CCDB4D10(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6) {
    memset_pattern16(*(void **)a1, &unk_1CFAC3070, 16 * v6);
  }
  while (a2 != a3)
  {
    uint64_t v7 = *(void *)(a2 + 8);
    if ((*(void *)a2 != -4096 || v7 != -4096) && (*(void *)a2 != -8192 || v7 != -8192))
    {
      unsigned int v8 = 0;
      sub_1CCDB497C((uint64_t *)a1, (_DWORD *)a2, &v8);
      _OWORD *v8 = *(_OWORD *)a2;
      ++*(_DWORD *)(a1 + 8);
    }
    a2 += 16;
  }
}

void sub_1CCDB4DC8()
{
}

void sub_1CCDB4E08(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCDB4E40(uint64_t a1, llvm *a2)
{
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::MemorySSAWrapperPass::ID);

  llvm::getLoopAnalysisUsage(a2, v3);
}

uint64_t sub_1CCDB4E88(llvm::LoopPass *a1, const llvm::Loop *a2)
{
  if ((llvm::LoopPass::skipLoop(a1, a2) & 1) == 0)
  {
    uint64_t v4 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1];
    if (v5 == v6)
    {
LABEL_6:
      uint64_t v7 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v5 != &llvm::DominatorTreeWrapperPass::ID)
      {
        v5 += 16;
        if (v5 == v6) {
          goto LABEL_6;
        }
      }
      uint64_t v7 = *(void *)(v5 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::DominatorTreeWrapperPass::ID);
    unsigned int v8 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v9 = *v8;
    uint64_t v10 = v8[1];
    if (v9 == v10)
    {
LABEL_11:
      uint64_t v11 = 0;
    }
    else
    {
      while (*(char **)v9 != llvm::ScalarEvolutionWrapperPass::ID)
      {
        v9 += 16;
        if (v9 == v10) {
          goto LABEL_11;
        }
      }
      uint64_t v11 = *(void *)(v9 + 8);
    }
    (*(void (**)(uint64_t, char *))(*(void *)v11 + 96))(v11, llvm::ScalarEvolutionWrapperPass::ID);
    uint64_t v12 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v13 = *v12;
    uint64_t v14 = v12[1];
    if (v13 == v14)
    {
LABEL_16:
      uint64_t v15 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v13 != &llvm::LoopInfoWrapperPass::ID)
      {
        v13 += 16;
        if (v13 == v14) {
          goto LABEL_16;
        }
      }
      uint64_t v15 = *(void *)(v13 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v15 + 96))(v15, &llvm::LoopInfoWrapperPass::ID);
    uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*((void *)a1 + 1) + 24), &llvm::MemorySSAWrapperPass::ID, 1);
    if (AnalysisPass) {
      (*(void (**)(uint64_t, void *))(*(void *)AnalysisPass + 96))(AnalysisPass, &llvm::MemorySSAWrapperPass::ID);
    }
    llvm::OptimizationRemarkEmitter::OptimizationRemarkEmitter(&v18, *(const llvm::Function **)(**((void **)a2 + 4) + 56));
    sub_1CCDB1484();
  }
  return 0;
}

uint64_t sub_1CCDB5150()
{
  int v4 = 1;
  char v2 = 1;
  uint64_t v3 = &v2;
  v1.n128_u64[0] = (unint64_t)"Break backedge through symbolic execution of 1st iteration attempting to prove that"
                                     " the backedge is never taken";
  v1.n128_u64[1] = 111;
  sub_1CD76F1D0(&v4, &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCF3630, &dword_1CB82C000);
}

void sub_1CCDB51C4(llvm *a1)
{
  llvm::initializeAssumptionCacheTrackerPass((uint64_t)a1);
  llvm::initializeTargetTransformInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeLoopInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeLoopSimplifyPass(a1, v2);
  llvm::initializeOptimizationRemarkEmitterWrapperPassPass(a1, v3);
  llvm::initializeScalarEvolutionWrapperPassPass(a1, v4);
  operator new();
}

void llvm::createLoopDataPrefetchPass(llvm *this)
{
}

uint64_t sub_1CCDB52C4(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF3700;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263E968;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF3708, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCDB51C4;
    v5[1] = &PassRegistry;
    int v4 = v5;
    std::__call_once(&qword_1EBCF3708, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CCDB5374(uint64_t a1)
{
  v219[34] = *MEMORY[0x1E4F143B8];
  char v2 = &unk_1EBCF3000;
  if (word_1EBCF37D8)
  {
    if (!dword_1EBCF3850) {
      goto LABEL_266;
    }
  }
  else if (!(*(unsigned int (**)(void))(***(void ***)(a1 + 32) + 784))(**(void **)(a1 + 32)))
  {
    goto LABEL_266;
  }
  uint64_t v3 = *(void *)(a1 + 16);
  int v4 = *(uint64_t **)(v3 + 24);
  uint64_t v124 = *(uint64_t **)(v3 + 32);
  if (v4 != v124)
  {
    int v5 = 0;
    while (1)
    {
      uint64_t v125 = v4;
      uint64_t v162 = *v4;
      sub_1CC076464(&v162, (uint64_t)&v149);
      uint64_t v6 = v145;
      int v140 = v145;
      uint64_t v7 = v150;
      if (v150 == v149)
      {
        unsigned int v141 = v145;
        unsigned int v8 = v150;
      }
      else
      {
        unsigned int v121 = v151;
        uint64_t v6 = malloc_type_malloc(8 * v151, 0x4065EBACuLL);
        if (!v6 && (v121 || (uint64_t v6 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
LABEL_265:
        }
          llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
        unsigned int v141 = v6;
        unsigned int v8 = v149;
        uint64_t v7 = v150;
      }
      unsigned int v9 = v152;
      unsigned int v142 = v151;
      if (v7 == v8) {
        unsigned int v10 = v152;
      }
      else {
        unsigned int v10 = v151;
      }
      if (v10)
      {
        memmove(v6, v7, 8 * v10);
        unsigned int v9 = v152;
      }
      unsigned int v143 = v9;
      int v144 = v153;
      uint64_t v147 = 0;
      uint64_t v148 = 0;
      uint64_t __p = 0;
      sub_1CBF340A8(&__p, v154, v155, 0xAAAAAAAAAAAAAAABLL * ((v155 - (unsigned char *)v154) >> 3));
      uint64_t v11 = v136;
      uint64_t v12 = __src;
      if (__src == v156)
      {
        int v135 = v136;
        uint64_t v13 = __src;
      }
      else
      {
        unsigned int v122 = v158;
        uint64_t v11 = malloc_type_malloc(8 * v158, 0x4065EBACuLL);
        if (!v11)
        {
          if (v122) {
            goto LABEL_265;
          }
          uint64_t v11 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
          if (!v11) {
            goto LABEL_265;
          }
        }
        int v135 = v11;
        uint64_t v13 = v156;
        uint64_t v12 = __src;
      }
      if (v12 == v13) {
        unsigned int v14 = v159;
      }
      else {
        unsigned int v14 = v158;
      }
      if (v14) {
        memmove(v11, v12, 8 * v14);
      }
      BOOL v138 = 0;
      uint64_t v139 = 0;
      int v137 = 0;
      sub_1CBF340A8(&v137, v160, v161, 0xAAAAAAAAAAAAAAABLL * ((v161 - (unsigned char *)v160) >> 3));
      while (1)
      {
        if (v147 - (unsigned char *)__p != v138 - v137) {
          goto LABEL_36;
        }
        if (__p == v147) {
          break;
        }
        uint64_t v15 = v137 + 8;
        uint64_t v16 = (char *)__p + 8;
        while (1)
        {
          int v17 = v16 - 8;
          if (*((void *)v16 - 1) != *((void *)v15 - 1)) {
            break;
          }
          int v18 = v15[8];
          if (v16[8]) {
            BOOL v19 = v18 == 0;
          }
          else {
            BOOL v19 = 1;
          }
          if (v19)
          {
            if ((v16[8] == 0) == (v18 != 0)) {
              break;
            }
          }
          else if (*(void *)v16 != *(void *)v15)
          {
            break;
          }
          v15 += 24;
          v16 += 24;
          if (v17 + 24 == v147) {
            goto LABEL_238;
          }
        }
LABEL_36:
        unsigned int v20 = (const llvm::Loop *)*((void *)v147 - 3);
        if (*((void *)v20 + 1) != *((void *)v20 + 2))
        {
          int v21 = 0;
          goto LABEL_74;
        }
        int v127 = v5;
        uint64_t v171 = v175;
        int v172 = v175;
        uint64_t v173 = 32;
        int v174 = 0;
        llvm::CodeMetrics::collectEphemeralValues((uint64_t)v20, *(llvm::AssumptionCache **)a1, (llvm::SmallPtrSetImplBase *)&v171);
        char v164 = 0;
        int v163 = 0;
        int v168 = 0;
        uint64_t v166 = 0;
        uint64_t v167 = 0;
        uint64_t v165 = 0;
        uint64_t v169 = 0;
        uint64_t v170 = 0;
        uint64_t v22 = (llvm::BasicBlock **)*((void *)v20 + 4);
        int v23 = (llvm::BasicBlock **)*((void *)v20 + 5);
        if (v23 == v22)
        {
          unsigned int v31 = 0;
          LOBYTE(v24) = 0;
        }
        else
        {
          int v24 = 0;
          do
          {
            uint64_t v25 = *v22;
            uint64_t v26 = (uint64_t)*v22 + 40;
            for (uint64_t i = *((void *)*v22 + 6); i != v26; uint64_t i = *(void *)(i + 8))
            {
              uint64_t v28 = i - 24;
              if (!i) {
                uint64_t v28 = 0;
              }
              int v29 = *(unsigned __int8 *)(v28 + 16);
              if (v29 == 84 || v29 == 33)
              {
                uint64_t v30 = *(void *)(v28 - 32);
                if (v30 && !*(unsigned char *)(v30 + 16) && *(void *)(v30 + 24) == *(void *)(v28 + 72))
                {
                  if (*(_DWORD *)(v30 + 36) == 240) {
                    goto LABEL_71;
                  }
                  v24 |= (*(uint64_t (**)(void))(***(void ***)(a1 + 32) + 176))(**(void **)(a1 + 32));
                }
                else
                {
                  int v24 = 1;
                }
              }
            }
            llvm::CodeMetrics::analyzeBasicBlock((uint64_t)&v163, v25, *(void **)(a1 + 32), (uint64_t *)&v171, 0);
            ++v22;
          }
          while (v22 != v23);
          unsigned int v31 = v165;
        }
        if (v31 <= 1) {
          unsigned int v32 = 1;
        }
        else {
          unsigned int v32 = v31;
        }
        if (v2[1004]) {
          unsigned int v33 = dword_1EBCF3850;
        }
        else {
          unsigned int v33 = (*(uint64_t (**)(void))(***(void ***)(a1 + 32) + 784))(**(void **)(a1 + 32));
        }
        LODWORD(v34) = v33 / v32;
        if (v32 > v33) {
          uint64_t v34 = 1;
        }
        else {
          uint64_t v34 = v34;
        }
        unint64_t v130 = v34;
        if (word_1EBCF3958) {
          unsigned int v35 = dword_1EBCF39D0;
        }
        else {
          unsigned int v35 = (*(uint64_t (**)(void))(***(void ***)(a1 + 32) + 800))(**(void **)(a1 + 32));
        }
        if (v130 <= v35)
        {
          unsigned int SmallConstantMaxTripCount = llvm::ScalarEvolution::getSmallConstantMaxTripCount(*(const llvm::Loop ***)(a1 + 24), v20);
          if (!SmallConstantMaxTripCount || SmallConstantMaxTripCount >= (int)v130 + 1)
          {
            int v196 = v198;
            uint64_t v197 = 0x1000000000;
            uint64_t v37 = (void *)*((void *)v20 + 4);
            unsigned int v128 = (void *)*((void *)v20 + 5);
            uint64_t v38 = &unk_1EBCF3000;
            if (v128 == v37)
            {
              unsigned int v126 = 0;
              uint64_t v39 = 0;
              goto LABEL_134;
            }
            size_t __n = (size_t)v20;
            uint64_t v39 = 0;
            unsigned int v126 = 0;
            while (1)
            {
              uint64_t v131 = v37;
              uint64_t v40 = *v37;
              uint64_t v41 = v40 + 40;
              for (uint64_t j = *(void *)(v40 + 48); j != v41; uint64_t j = *(void *)(j + 8))
              {
                if (j) {
                  uint64_t v43 = j - 24;
                }
                else {
                  uint64_t v43 = 0;
                }
                int v44 = *(unsigned __int8 *)(v43 + 16);
                if (!j || (uint64_t v45 = j - 24, v44 != 60))
                {
                  if (v44 == 61) {
                    uint64_t v45 = v43;
                  }
                  else {
                    uint64_t v45 = 0;
                  }
                  if (!j || v44 != 61) {
                    continue;
                  }
                  if (v38[908])
                  {
                    if (!byte_1EBCF3790) {
                      continue;
                    }
                  }
                  else if (!(*(unsigned int (**)(void))(***(void ***)(a1 + 32) + 808))(**(void **)(a1 + 32)))
                  {
                    continue;
                  }
                }
                unint64_t v46 = *(void *)(v45 - 32);
                unsigned int v47 = *(_DWORD *)(*(void *)v46 + 8);
                if ((v47 & 0xFE) == 0x12) {
                  unsigned int v47 = *(_DWORD *)(**(void **)(*(void *)v46 + 16) + 8);
                }
                if (v47 <= 0xFF)
                {
                  uint64_t v39 = (v39 + 1);
                  if (!llvm::Loop::isLoopInvariant(__n, *(void *)(v45 - 32)))
                  {
                    uint64_t v48 = *(void *)(a1 + 24);
                    uint64_t v49 = *(void *)(v48 + 104);
                    unsigned int v50 = *(_DWORD *)(v48 + 120);
                    if (!v50) {
                      goto LABEL_102;
                    }
                    unsigned int v51 = (v50 - 1) & ((v46 >> 4) ^ (v46 >> 9));
                    uint64_t v52 = v49 + 48 * v51;
                    uint64_t v53 = *(void *)(v52 + 24);
                    if (v53 != v46)
                    {
                      int v54 = 1;
                      while (v53 != -4096)
                      {
                        unsigned int v55 = v51 + v54++;
                        unsigned int v51 = v55 & (v50 - 1);
                        uint64_t v52 = v49 + 48 * v51;
                        uint64_t v53 = *(void *)(v52 + 24);
                        if (v53 == v46) {
                          goto LABEL_103;
                        }
                      }
LABEL_102:
                      uint64_t v52 = v49 + 48 * v50;
                    }
LABEL_103:
                    if (v52 == v49 + 48 * v50 || (uint64_t SCEVIter = *(unsigned __int16 **)(v52 + 40)) == 0) {
                      uint64_t SCEVIter = (unsigned __int16 *)llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)v48, v46);
                    }
                    if (SCEVIter) {
                      BOOL v57 = SCEVIter[12] == 7;
                    }
                    else {
                      BOOL v57 = 0;
                    }
                    if (v57)
                    {
                      ++v126;
                      if (v197)
                      {
                        uint64_t v58 = (const llvm::APInt **)v196;
                        uint64_t v59 = 32 * v197;
                        while (1)
                        {
                          unint64_t MinusSCEV = llvm::ScalarEvolution::getMinusSCEV(*(llvm::ScalarEvolution **)(a1 + 24), (llvm::SCEV *)SCEVIter, *v58, 0, 0);
                          if (MinusSCEV && *(_WORD *)(MinusSCEV + 24) == 0)
                          {
                            uint64_t v62 = *(void *)(MinusSCEV + 32);
                            unsigned int v63 = *(_DWORD *)(v62 + 32);
                            uint64_t v64 = v63 > 0x40
                                ? **(void **)(v62 + 24)
                                : (uint64_t)(*(void *)(v62 + 24) << -(char)v63) >> -(char)v63;
                            unint64_t v65 = v64 >= 0 ? v64 : -v64;
                            if (v65 < (*(unsigned int (**)(void))(***(void ***)(a1 + 32) + 760))(**(void **)(a1 + 32))) {
                              break;
                            }
                          }
                          v58 += 4;
                          v59 -= 32;
                          if (!v59) {
                            goto LABEL_126;
                          }
                        }
                        sub_1CD76F54C((uint64_t)v58, j - 24, *(void *)(a1 + 8), v65);
                      }
                      else
                      {
LABEL_126:
                        unint64_t v192 = SCEVIter;
                        uint64_t v193 = 0;
                        LOBYTE(v194) = 0;
                        uint64_t v195 = 0;
                        sub_1CD76F54C((uint64_t)&v192, j - 24, 0, 0);
                        uint64_t v66 = (_OWORD *)sub_1CD57FBCC((uint64_t)&v196, (unint64_t)&v192);
                        int64_t v67 = (char *)v196 + 32 * v197;
                        long long v68 = v66[1];
                        *int64_t v67 = *v66;
                        v67[1] = v68;
                        LODWORD(v197) = v197 + 1;
                      }
                      uint64_t v38 = (_WORD *)&unk_1EBCF3000;
                    }
                    continue;
                  }
                }
              }
              uint64_t v37 = v131 + 1;
              if (v131 + 1 == v128)
              {
LABEL_134:
                if (word_1EBCF3898) {
                  unsigned int v69 = dword_1EBCF3910;
                }
                else {
                  unsigned int v69 = (*(uint64_t (**)(void, uint64_t, void, void, void))(***(void ***)(a1 + 32)
                }
                                                                                           + 792))(**(void **)(a1 + 32), v39, v126, v197, v24 & 1);
                uint64_t v70 = (char *)v196;
                if (!v197)
                {
                  int v21 = 0;
LABEL_235:
                  int v5 = v127;
                  if (v70 != v198) {
                    free(v70);
                  }
                  char v2 = (_WORD *)&unk_1EBCF3000;
                  goto LABEL_72;
                }
                int v21 = 0;
                unint64_t v71 = (char *)v196 + 32 * v197;
                while (2)
                {
                  uint64_t v72 = *(llvm::ScalarEvolution **)(a1 + 24);
                  if (v69 >= 2)
                  {
                    uint64_t v76 = *(void *)v70;
                    uint64_t v77 = *(void *)(*(void *)v70 + 40);
                    if (v77 == 2)
                    {
                      uint64_t v78 = *(void *)(*(void *)(v76 + 32) + 8);
                    }
                    else
                    {
                      uint64_t v118 = *(void *)(v76 + 32);
                      unint64_t v192 = &v194;
                      uint64_t v193 = 0x300000000;
                      unint64_t v119 = 8 * v77 - 8;
                      if (v119 >= 0x19) {
                        llvm::SmallVectorBase<unsigned int>::grow_pod();
                      }
                      int v120 = 0;
                      if (v77 != 1)
                      {
                        memcpy(v192, (const void *)(v118 + 8), 8 * v77 - 8);
                        int v120 = v193;
                      }
                      LODWORD(v193) = v120 + (v119 >> 3);
                      uint64_t v78 = sub_1CD478318(v72, (uint64_t)&v192, *(const llvm::Loop **)(v76 + 48), 0);
                      if (v192 != &v194) {
                        free(v192);
                      }
                    }
                    if (v78) {
                      BOOL v79 = *(unsigned __int16 *)(v78 + 24) == 0;
                    }
                    else {
                      BOOL v79 = 0;
                    }
                    if (v79)
                    {
                      uint64_t v80 = *(void *)(v78 + 32);
                      unsigned int v81 = *(_DWORD *)(v80 + 32);
                      if (v81 > 0x40) {
                        uint64_t v82 = **(void **)(v80 + 24);
                      }
                      else {
                        uint64_t v82 = (uint64_t)(*(void *)(v80 + 24) << -(char)v81) >> -(char)v81;
                      }
                      if (v82 < 0) {
                        uint64_t v82 = -v82;
                      }
                      if (v69 <= v82)
                      {
                        uint64_t v72 = *(llvm::ScalarEvolution **)(a1 + 24);
                        goto LABEL_140;
                      }
                    }
                  }
                  else
                  {
LABEL_140:
                    unint64_t v73 = *(void *)v70;
                    unsigned int v74 = *(uint64_t **)(*(void *)v70 + 32);
                    while (2)
                    {
                      uint64_t v75 = *v74;
                      switch(*(_WORD *)(v75 + 24))
                      {
                        case 1:
                        case 2:
                        case 3:
                        case 0xD:
                          uint64_t v83 = (llvm::Type **)(v75 + 40);
                          break;
                        case 4:
                          uint64_t v83 = (llvm::Type **)(v75 + 48);
                          break;
                        case 5:
                        case 7:
                        case 8:
                        case 9:
                        case 0xA:
                        case 0xB:
                        case 0xC:
                          unsigned int v74 = *(uint64_t **)(v75 + 32);
                          continue;
                        case 6:
                          unsigned int v74 = (uint64_t *)(v75 + 40);
                          continue;
                        case 0xE:
                          uint64_t v83 = *(llvm::Type ***)(v75 - 8);
                          break;
                        default:
                          uint64_t v83 = *(llvm::Type ***)(v75 + 32);
                          break;
                      }
                      break;
                    }
                    unint64_t Constant = llvm::ScalarEvolution::getConstant(v72, *v83, v130, 0);
                    unint64_t v85 = *(void *)v70;
                    uint64_t v86 = *(void *)(*(void *)v70 + 40);
                    if (v86 == 2)
                    {
                      uint64_t v87 = *(void *)(*(void *)(v85 + 32) + 8);
                    }
                    else
                    {
                      BOOL v116 = *(llvm::ScalarEvolution **)(a1 + 24);
                      uint64_t v129 = *(void *)(v85 + 32);
                      unint64_t v192 = &v194;
                      uint64_t v193 = 0x300000000;
                      unsigned int v132 = v116;
                      unint64_t __na = 8 * v86 - 8;
                      if (__na >= 0x19) {
                        llvm::SmallVectorBase<unsigned int>::grow_pod();
                      }
                      int v117 = 0;
                      if (v86 != 1)
                      {
                        memcpy(v192, (const void *)(v129 + 8), __na);
                        int v117 = v193;
                      }
                      LODWORD(v193) = v117 + (__na >> 3);
                      uint64_t v87 = sub_1CD478318(v132, (uint64_t)&v192, *(const llvm::Loop **)(v85 + 48), 0);
                      if (v192 != &v194) {
                        free(v192);
                      }
                    }
                    unint64_t v192 = &v194;
                    unint64_t v194 = Constant;
                    uint64_t v195 = v87;
                    uint64_t v193 = 0x200000002;
                    uint64_t MulExpr = llvm::ScalarEvolution::getMulExpr((uint64_t)v72, (uint64_t)&v192, 0, 0);
                    if (v192 != &v194) {
                      free(v192);
                    }
                    unint64_t v192 = &v194;
                    unint64_t v194 = v73;
                    uint64_t v195 = MulExpr;
                    uint64_t v193 = 0x200000002;
                    uint64_t AddExpr = (llvm::Instruction **)llvm::ScalarEvolution::getAddExpr((uint64_t)v72, (unint64_t **)&v192, 0, 0);
                    if (v192 != &v194) {
                      free(v192);
                    }
                    if (llvm::isSafeToExpand((llvm *)AddExpr, *(const llvm::SCEV **)(a1 + 24), (llvm::ScalarEvolution *)1))
                    {
                      uint64_t v90 = *(uint64_t ****)(*((void *)v70 + 1) + 40);
                      unint64_t v91 = (llvm::Type *)llvm::PointerType::get((llvm::PointerType *)(***v90 + 1912), 0);
                      sub_1CC2B6C4C((uint64_t)&v192, *(uint64_t ****)(a1 + 24), (uint64_t)(v90[7][5] + 34), (uint64_t)"prefaddr", 1);
                      uint64_t v92 = llvm::SCEVExpander::expandCodeForImpl((llvm::SCEVExpander *)&v192, AddExpr, v91, *((llvm::Instruction **)v70 + 1));
                      uint64_t v93 = 0;
                      int v94 = (uint64_t **)*((void *)v70 + 1);
                      uint64_t v95 = **v94;
                      v177[0] = v178;
                      v177[1] = (void *)0x200000000;
                      uint64_t v181 = v95;
                      unsigned int v182 = &v190;
                      uint64_t v183 = &v191;
                      uint64_t v184 = 0;
                      int v185 = 0;
                      __int16 v186 = 512;
                      char v187 = 7;
                      int v179 = 0;
                      uint64_t v180 = 0;
                      uint64_t v188 = 0;
                      uint64_t v189 = 0;
                      uint64_t v190 = &unk_1F2616E88;
                      int v191 = &unk_1F2617008;
                      int v179 = v94[5];
                      uint64_t v180 = v94 + 3;
                      uint64_t v96 = (unsigned __int8 *)v94[6];
                      int v199 = v96;
                      if (v96)
                      {
                        llvm::MetadataTracking::track((uint64_t)&v199, v96, 2);
                        uint64_t v93 = (uint64_t)v199;
                      }
                      sub_1CB8461A4((uint64_t)v177, 0, v93);
                      if (v199)
                      {
                        int v106 = *v199;
                        if ((v106 - 4) > 0x1E)
                        {
                          if ((v106 - 3) >= 0xFFFFFFFE) {
                            uint64_t v115 = v199;
                          }
                          else {
                            uint64_t v115 = 0;
                          }
                          if ((v106 - 3) < 0xFFFFFFFE)
                          {
                            if (v106 == 3) {
                              *((void *)v199 + 1) = 0;
                            }
                            goto LABEL_166;
                          }
                          unint64_t v108 = (unint64_t)(v115 + 8);
                        }
                        else
                        {
                          if ((v199[1] & 0x7F) != 2 && !*((_DWORD *)v199 + 3)) {
                            goto LABEL_166;
                          }
                          uint64_t v107 = *((void *)v199 + 2);
                          if ((v107 & 4) == 0) {
                            goto LABEL_166;
                          }
                          unint64_t v108 = v107 & 0xFFFFFFFFFFFFFFF8;
                          if (!v108) {
                            goto LABEL_166;
                          }
                        }
                        int v209 = &v199;
                        sub_1CC5FA668(v108 + 16, &v209);
                      }
LABEL_166:
                      int v97 = (uint64_t **)v90[7][5];
                      uint64_t v98 = ***v90;
                      int v209 = *(unsigned __int8 ***)v92;
                      uint64_t Declaration = llvm::Intrinsic::getDeclaration(v97, 240, (uint64_t)&v209, 1);
                      int v100 = (uint64_t **)Declaration;
                      if (Declaration) {
                        uint64_t v101 = *(uint64_t ***)(Declaration + 24);
                      }
                      else {
                        uint64_t v101 = 0;
                      }
                      int v102 = (llvm::ConstantInt *)(v98 + 1960);
                      int v199 = (unsigned __int8 *)v92;
                      uint64_t v200 = llvm::ConstantInt::get(v102, v70[16], 0);
                      *(void *)&long long v201 = llvm::ConstantInt::get(v102, 3uLL, 0);
                      *((void *)&v201 + 1) = llvm::ConstantInt::get(v102, 1uLL, 0);
                      LOWORD(v213) = 257;
                      sub_1CB845BAC((uint64_t *)v177, v101, v100, (uint64_t *)&v199, 4, (uint64_t)&v209, 0);
                      __int32 v103 = *(uint64_t ****)(a1 + 40);
                      uint64_t v104 = *(void *)***v103;
                      if (*(void *)(v104 + 128)
                        || (*(unsigned int (**)(void))(**(void **)(v104 + 72) + 48))(*(void *)(v104 + 72)))
                      {
                        llvm::OptimizationRemark::OptimizationRemark((uint64_t)&v209, (uint64_t)"loop-data-prefetch", (uint64_t)"Prefetched", 10, *((void *)v70 + 3));
                        v176[0] = "prefetched memory access";
                        v176[1] = 24;
                        sub_1CC59ADEC((uint64_t *)&v217, (uint64_t)v176);
                        LODWORD(v200) = v210;
                        BYTE4(v200) = v211;
                        long long v201 = v212;
                        uint64_t v202 = v213;
                        long long v203 = v214;
                        long long v204 = v215;
                        uint64_t v205 = v216;
                        int v199 = (unsigned __int8 *)&unk_1F2616800;
                        uint64_t v206 = v208;
                        uint64_t v207 = 0x400000000;
                        if (v218)
                        {
                          sub_1CD494D68((uint64_t)&v206, (uint64_t)&v217);
                          uint64_t v105 = v218;
                        }
                        else
                        {
                          uint64_t v105 = 0;
                        }
                        v208[32] = v219[32];
                        v208[33] = v219[33];
                        int v199 = (unsigned __int8 *)&unk_1F2616570;
                        int v209 = (unsigned __int8 **)&unk_1F2616800;
                        uint64_t v109 = (char *)v217;
                        if (v105)
                        {
                          uint64_t v110 = v105 << 6;
                          do
                          {
                            int v111 = (void **)&v109[v110];
                            if (v109[v110 - 17] < 0) {
                              operator delete(*(v111 - 5));
                            }
                            if (*((char *)v111 - 41) < 0) {
                              operator delete(*(v111 - 8));
                            }
                            v110 -= 64;
                          }
                          while (v110);
                          uint64_t v109 = (char *)v217;
                        }
                        if (v109 != (char *)v219) {
                          free(v109);
                        }
                        llvm::OptimizationRemarkEmitter::emit(v103, (llvm::DiagnosticInfoOptimizationBase *)&v199);
                        int v199 = (unsigned __int8 *)&unk_1F2616800;
                        uint64_t v112 = (char *)v206;
                        if (v207)
                        {
                          unint64_t v113 = (unint64_t)v207 << 6;
                          do
                          {
                            uint64_t v114 = (void **)&v112[v113];
                            if (v112[v113 - 17] < 0) {
                              operator delete(*(v114 - 5));
                            }
                            if (*((char *)v114 - 41) < 0) {
                              operator delete(*(v114 - 8));
                            }
                            v113 -= 64;
                          }
                          while (v113);
                          uint64_t v112 = (char *)v206;
                        }
                        if (v112 != (char *)v208) {
                          free(v112);
                        }
                      }
                      if (v177[0] != v178) {
                        free(v177[0]);
                      }
                      sub_1CC2B7040((uint64_t)&v192);
                      int v21 = 1;
                    }
                  }
                  v70 += 32;
                  if (v70 == v71)
                  {
                    uint64_t v70 = (char *)v196;
                    goto LABEL_235;
                  }
                  continue;
                }
              }
            }
          }
        }
LABEL_71:
        int v21 = 0;
        int v5 = v127;
LABEL_72:
        MEMORY[0x1D25D9CD0](v166, 8);
        if (v172 != v171) {
          free(v172);
        }
LABEL_74:
        v5 |= v21;
        sub_1CC078F58((llvm::SmallPtrSetImplBase *)&v140);
      }
LABEL_238:
      if (v137)
      {
        BOOL v138 = v137;
        operator delete(v137);
      }
      if (v135 != v136) {
        free(v135);
      }
      if (__p)
      {
        uint64_t v147 = (char *)__p;
        operator delete(__p);
      }
      if (v141 != v140) {
        free(v141);
      }
      if (v160)
      {
        int v161 = v160;
        operator delete(v160);
      }
      if (__src != v156) {
        free(__src);
      }
      if (v154)
      {
        unsigned int v155 = v154;
        operator delete(v154);
      }
      if (v150 != v149) {
        free(v150);
      }
      int v4 = v125 + 1;
      if (v125 + 1 == v124) {
        return v5 & 1;
      }
    }
  }
LABEL_266:
  LOBYTE(v5) = 0;
  return v5 & 1;
}

void sub_1CCDB6600()
{
}

void sub_1CCDB6640(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCDB6678(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)llvm::AssumptionCacheTracker::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&unk_1EA61F34C);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&unk_1EA61F34C);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::OptimizationRemarkEmitterWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::ScalarEvolutionWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)llvm::ScalarEvolutionWrapperPass::ID);

  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
}

uint64_t sub_1CCDB6788(llvm::FunctionPass *a1, llvm::LLVMContextImpl ****a2)
{
  if (llvm::FunctionPass::skipFunction(a1, a2)) {
    return 0;
  }
  int v5 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v6 = *v5;
  uint64_t v7 = v5[1];
  if (v6 == v7)
  {
LABEL_6:
    uint64_t v8 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v6 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v6 += 16;
      if (v6 == v7) {
        goto LABEL_6;
      }
    }
    uint64_t v8 = *(void *)(v6 + 8);
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v8 + 96))(v8, &llvm::DominatorTreeWrapperPass::ID);
  unsigned int v10 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v11 = *v10;
  uint64_t v12 = v10[1];
  if (v11 == v12)
  {
LABEL_11:
    uint64_t v13 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v11 != &llvm::LoopInfoWrapperPass::ID)
    {
      v11 += 16;
      if (v11 == v12) {
        goto LABEL_11;
      }
    }
    uint64_t v13 = *(void *)(v11 + 8);
  }
  uint64_t v14 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v13 + 96))(v13, &llvm::LoopInfoWrapperPass::ID);
  uint64_t v15 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v16 = *v15;
  uint64_t v17 = v15[1];
  if (v16 == v17)
  {
LABEL_16:
    uint64_t v18 = 0;
  }
  else
  {
    while (*(char **)v16 != llvm::ScalarEvolutionWrapperPass::ID)
    {
      v16 += 16;
      if (v16 == v17) {
        goto LABEL_16;
      }
    }
    uint64_t v18 = *(void *)(v16 + 8);
  }
  uint64_t v19 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v18 + 96))(v18, llvm::ScalarEvolutionWrapperPass::ID);
  unsigned int v20 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v21 = *v20;
  uint64_t v22 = v20[1];
  if (v21 == v22)
  {
LABEL_21:
    uint64_t v23 = 0;
  }
  else
  {
    while (*(char **)v21 != llvm::AssumptionCacheTracker::ID)
    {
      v21 += 16;
      if (v21 == v22) {
        goto LABEL_21;
      }
    }
    uint64_t v23 = *(void *)(v21 + 8);
  }
  uint64_t v24 = v9 + 32;
  uint64_t v25 = v14 + 32;
  uint64_t v26 = *(void *)(v19 + 32);
  uint64_t v27 = (llvm::AssumptionCacheTracker *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v23 + 96))(v23, llvm::AssumptionCacheTracker::ID);
  uint64_t AssumptionCache = llvm::AssumptionCacheTracker::getAssumptionCache(v27, (llvm::Function *)a2);
  int v29 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v30 = *v29;
  uint64_t v31 = v29[1];
  if (v30 == v31)
  {
LABEL_26:
    uint64_t v32 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v30 != &llvm::OptimizationRemarkEmitterWrapperPass::ID)
    {
      v30 += 16;
      if (v30 == v31) {
        goto LABEL_26;
      }
    }
    uint64_t v32 = *(void *)(v30 + 8);
  }
  uint64_t v33 = *(void *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v32 + 96))(v32, &llvm::OptimizationRemarkEmitterWrapperPass::ID)+ 32);
  uint64_t v34 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v35 = *v34;
  uint64_t v36 = v34[1];
  if (v35 == v36)
  {
LABEL_31:
    uint64_t v37 = 0;
  }
  else
  {
    while (*(char **)v35 != llvm::TargetTransformInfoWrapperPass::ID)
    {
      v35 += 16;
      if (v35 == v36) {
        goto LABEL_31;
      }
    }
    uint64_t v37 = *(void *)(v35 + 8);
  }
  uint64_t v38 = (llvm::TargetTransformInfoWrapperPass *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v37 + 96))(v37, llvm::TargetTransformInfoWrapperPass::ID);
  v39[0] = AssumptionCache;
  v39[1] = v24;
  v39[2] = v25;
  v39[3] = v26;
  v39[4] = llvm::TargetTransformInfoWrapperPass::getTTI(v38, (const Function *)a2);
  v39[5] = v33;
  return sub_1CCDB5374((uint64_t)v39);
}

uint64_t sub_1CCDB6A90()
{
  int v3 = 1;
  char v1 = 0;
  char v2 = &v1;
  v4.n128_u64[0] = (unint64_t)"Prefetch write addresses";
  v4.n128_u64[1] = 24;
  sub_1CC025F34((llvm::cl::Option *)&unk_1EBCF3710, "loop-prefetch-writes", &v3, &v2, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF3710, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Number of instructions to prefetch ahead";
  v4.n128_u64[1] = 40;
  LODWORD(v2) = 1;
  sub_1CD76F610((long long *)&v4, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCF37D0, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Min stride to add prefetches";
  v4.n128_u64[1] = 28;
  LODWORD(v2) = 1;
  sub_1CD76F71C((long long *)&v4, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCF3890, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Max number of iterations to prefetch ahead";
  v4.n128_u64[1] = 42;
  LODWORD(v2) = 1;
  sub_1CD76F828((long long *)&v4, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCF3950, &dword_1CB82C000);
}

uint64_t sub_1CCDB6BC8(uint64_t a1, uint64_t a2)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  unsigned int v23 = 0;
  char v2 = *(void ***)(a2 + 24);
  int v3 = *(void ***)(a2 + 32);
  if (v2 == v3) {
    return 0;
  }
  do
  {
    uint64_t v25 = *v2;
    sub_1CC076464((uint64_t *)&v25, (uint64_t)&v44);
    uint64_t v35 = v40;
    __n128 v4 = __src;
    if (__src == v44)
    {
      uint64_t v36 = v40;
      int v5 = v40;
      uint64_t v6 = __src;
    }
    else
    {
      unsigned int v20 = v46;
      int v5 = malloc_type_malloc(8 * v46, 0x4065EBACuLL);
      if (!v5 && (v20 || (int v5 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
LABEL_63:
      }
        llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
      uint64_t v36 = v5;
      uint64_t v6 = v44;
      __n128 v4 = __src;
    }
    unsigned int v7 = v47;
    unsigned int v37 = v46;
    if (v4 == v6) {
      unsigned int v8 = v47;
    }
    else {
      unsigned int v8 = v46;
    }
    if (v8)
    {
      memmove(v5, v4, 8 * v8);
      unsigned int v7 = v47;
    }
    unsigned int v38 = v7;
    LODWORD(v39) = v48;
    uint64_t v42 = 0;
    uint64_t v43 = 0;
    uint64_t v41 = 0;
    sub_1CBF340A8(&v41, v49, v50, 0xAAAAAAAAAAAAAAABLL * ((v50 - (unsigned char *)v49) >> 3));
    uint64_t v26 = v31;
    uint64_t v9 = v52;
    if (v52 == v51)
    {
      uint64_t v27 = v31;
      unsigned int v10 = v31;
      uint64_t v11 = v52;
    }
    else
    {
      unsigned int v21 = v53;
      unsigned int v10 = malloc_type_malloc(8 * v53, 0x4065EBACuLL);
      if (!v10)
      {
        if (v21) {
          goto LABEL_63;
        }
        unsigned int v10 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
        if (!v10) {
          goto LABEL_63;
        }
      }
      uint64_t v27 = v10;
      uint64_t v11 = v51;
      uint64_t v9 = v52;
    }
    unsigned int v12 = v54;
    unsigned int v28 = v53;
    if (v9 == v11) {
      unsigned int v13 = v54;
    }
    else {
      unsigned int v13 = v53;
    }
    if (v13)
    {
      memmove(v10, v9, 8 * v13);
      unsigned int v12 = v54;
    }
    unsigned int v29 = v12;
    int v30 = v55;
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    uint64_t __p = 0;
    sub_1CBF340A8(&__p, v56, v57, 0xAAAAAAAAAAAAAAABLL * ((v57 - (unsigned char *)v56) >> 3));
    while (1)
    {
      if (v42 - (unsigned char *)v41 != v33 - (unsigned char *)__p) {
        goto LABEL_31;
      }
      if (v41 == v42) {
        break;
      }
      uint64_t v14 = (char *)__p + 8;
      uint64_t v15 = (char *)v41 + 8;
      while (1)
      {
        uint64_t v16 = v15 - 8;
        if (*((void *)v15 - 1) != *((void *)v14 - 1)) {
          break;
        }
        int v17 = v14[8];
        if (v15[8]) {
          BOOL v18 = v17 == 0;
        }
        else {
          BOOL v18 = 1;
        }
        if (v18)
        {
          if ((v15[8] == 0) == (v17 != 0)) {
            break;
          }
        }
        else if (*(void *)v15 != *(void *)v14)
        {
          break;
        }
        v14 += 24;
        v15 += 24;
        if (v16 + 24 == v42) {
          goto LABEL_36;
        }
      }
LABEL_31:
      uint64_t v19 = (llvm::Loop *)*((void *)v42 - 3);
      if (*((void *)v19 + 1) == *((void *)v19 + 2))
      {
        if (v23 >= 8uLL) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        v24[v23++] = v19;
      }
      sub_1CC078F58((llvm::SmallPtrSetImplBase *)&v35);
    }
LABEL_36:
    if (__p)
    {
      uint64_t v33 = __p;
      operator delete(__p);
    }
    if (v27 != v26) {
      free(v27);
    }
    if (v41)
    {
      uint64_t v42 = (char *)v41;
      operator delete(v41);
    }
    if (v36 != v35) {
      free(v36);
    }
    if (v56)
    {
      BOOL v57 = v56;
      operator delete(v56);
    }
    if (v52 != v51) {
      free(v52);
    }
    if (v49)
    {
      unsigned int v50 = v49;
      operator delete(v49);
    }
    if (__src != v44) {
      free(__src);
    }
    ++v2;
  }
  while (v2 != v3);
  if (v23) {
    llvm::findStringMetadataForLoop(v24[0]);
  }
  return 0;
}

void sub_1CCDB98AC(llvm *a1)
{
  llvm::initializeLoopInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeLoopAccessLegacyAnalysisPass(a1, v2);
  llvm::initializeDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializeScalarEvolutionWrapperPassPass(a1, v3);
  llvm::initializeOptimizationRemarkEmitterWrapperPassPass(a1, v4);
  llvm::initializeTargetTransformInfoWrapperPassPass((uint64_t)a1);
  operator new();
}

uint64_t sub_1CCDB9974(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF3A10;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263EA08;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF3A18, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCDB98AC;
    v5[1] = &PassRegistry;
    __n128 v4 = v5;
    std::__call_once(&qword_1EBCF3A18, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CCDB9A24(uint64_t a1)
{
  uint64_t v2 = *****(void *****)(a1 + 48);
  if (!*(void *)(v2 + 128)
    && !(*(unsigned int (**)(void))(**(void **)(v2 + 72) + 48))(*(void *)(v2 + 72)))
  {
    llvm::Loop::getStartLoc(*(llvm::Loop **)a1);
  }
  llvm::Loop::getStartLoc(*(llvm::Loop **)a1);
}

uint64_t sub_1CCDBA12C(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(void *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 96) = a4;
  *(void *)(a1 + 104) = a3;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = a1 + 136;
  *(void *)(a1 + 128) = 0x800000000;
  *(_DWORD *)(a1 + 216) = 128;
  uint64_t v6 = (char *)operator new(0x2000uLL, (std::align_val_t)8uLL);
  *(void *)(a1 + 200) = v6;
  *(void *)(a1 + 208) = 0;
  uint64_t v7 = *(unsigned int *)(a1 + 216);
  if (v7)
  {
    uint64_t v8 = v7 << 6;
    uint64_t v9 = v6 + 16;
    do
    {
      *(v9 - 1) = 2;
      *uint64_t v9 = 0;
      v9[1] = -4096;
      *(v9 - 2) = &unk_1F2615EC8;
      void v9[2] = 0;
      v9 += 8;
      v6 += 64;
      v8 -= 64;
    }
    while (v8);
  }
  *(unsigned char *)(a1 + 224) = 0;
  *(unsigned char *)(a1 + 248) = 0;
  uint64_t v10 = *(void *)(a1 + 8);
  uint64_t v11 = *(unsigned int *)(a1 + 20);
  if (v10 != *(void *)a1)
  {
    unsigned int v15 = *(_DWORD *)(a1 + 16);
    goto LABEL_15;
  }
  if (!v11)
  {
LABEL_12:
    unsigned int v15 = *(_DWORD *)(a1 + 16);
    if (v11 < v15)
    {
      *(_DWORD *)(a1 + 20) = v11 + 1;
      *(void *)(v10 + 8 * v11) = a2;
      return a1;
    }
LABEL_15:
    if (3 * v15 <= 4 * ((int)v11 - *(_DWORD *)(a1 + 24)))
    {
      if (v15 >= 0x40) {
        v15 *= 2;
      }
      else {
        unsigned int v15 = 128;
      }
    }
    else if (v15 - v11 >= v15 >> 3)
    {
      goto LABEL_17;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a1, v15);
    unsigned int v15 = *(_DWORD *)(a1 + 16);
    uint64_t v10 = *(void *)(a1 + 8);
LABEL_17:
    unsigned int v16 = v15 - 1;
    unsigned int v17 = (v15 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    BOOL v18 = (void *)(v10 + 8 * v17);
    uint64_t v19 = *v18;
    if (*v18 == -1)
    {
      unsigned int v20 = 0;
LABEL_29:
      if (v20) {
        uint64_t v24 = v20;
      }
      else {
        uint64_t v24 = v18;
      }
      if (*v24 != a2)
      {
        if (*v24 == -2) {
          --*(_DWORD *)(a1 + 24);
        }
        else {
          ++*(_DWORD *)(a1 + 20);
        }
        void *v24 = a2;
      }
    }
    else
    {
      unsigned int v20 = 0;
      int v21 = 1;
      while (v19 != a2)
      {
        if (v20) {
          BOOL v22 = 0;
        }
        else {
          BOOL v22 = v19 == -2;
        }
        if (v22) {
          unsigned int v20 = v18;
        }
        unsigned int v23 = v17 + v21++;
        unsigned int v17 = v23 & v16;
        BOOL v18 = (void *)(v10 + 8 * (v23 & v16));
        uint64_t v19 = *v18;
        if (*v18 == -1) {
          goto LABEL_29;
        }
      }
    }
    return a1;
  }
  unsigned int v12 = 0;
  uint64_t v13 = 8 * v11;
  uint64_t v14 = *(void **)(a1 + 8);
  while (*v14 != a2)
  {
    if (*v14 == -2) {
      unsigned int v12 = v14;
    }
    ++v14;
    v13 -= 8;
    if (!v13)
    {
      if (!v12) {
        goto LABEL_12;
      }
      void *v12 = a2;
      --*(_DWORD *)(a1 + 24);
      return a1;
    }
  }
  return a1;
}

void *sub_1CCDBA4D8(uint64_t a1, llvm::SmallPtrSetImplBase *this)
{
  __n128 v4 = *(unint64_t **)(a1 + 8);
  uint64_t v5 = 16;
  if (v4 == *(unint64_t **)a1) {
    uint64_t v5 = 20;
  }
  uint64_t v6 = *(unsigned int *)(a1 + v5);
  uint64_t v7 = &v4[v6];
  if (v6)
  {
    uint64_t v8 = 8 * v6;
    while (*v4 >= 0xFFFFFFFFFFFFFFFELL)
    {
      ++v4;
      v8 -= 8;
      if (!v8)
      {
        __n128 v4 = v7;
        break;
      }
    }
  }
  sub_1CC002B9C(this, v4, v7, v7);
  uint64_t result = *(void **)(a1 + 8);
  if (result != *(void **)a1)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10 >= 0x21 && 4 * (*(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 24)) < v10)
    {
      uint64_t result = llvm::SmallPtrSetImplBase::shrink_and_clear((void **)a1);
      goto LABEL_10;
    }
    uint64_t result = memset(result, 255, 8 * v10);
  }
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
LABEL_10:
  *((unsigned char *)this + 96) |= *(unsigned char *)(a1 + 96);
  return result;
}

void sub_1CCDBA5A8(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 216);
  if (*(unsigned char *)(a1 + 264))
  {
    sub_1CC009394(a1 + 240);
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 240), 8);
    *(unsigned char *)(a1 + 264) = 0;
  }
  sub_1CC4D021C(v2);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 216), 8);
  int v3 = *(void **)(a1 + 136);
  if (v3 != (void *)(a1 + 152)) {
    free(v3);
  }
  __n128 v4 = *(void **)(a1 + 24);
  if (v4 != *(void **)(a1 + 16)) {
    free(v4);
  }

  operator delete((void *)a1);
}

void *sub_1CCDBA63C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  __n128 v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      uint64_t v11 = 16 * v10;
      do
      {
        void *result = -4096;
        result += 2;
        v11 -= 16;
      }
      while (v11);
    }
    if (v3)
    {
      int v12 = 0;
      int v13 = v10 - 1;
      uint64_t v14 = v4;
      do
      {
        uint64_t v15 = *v14;
        if ((*v14 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          unsigned int v16 = ((v15 >> 4) ^ (v15 >> 9)) & v13;
          unsigned int v17 = (void *)(*(void *)a1 + 16 * v16);
          uint64_t v18 = *v17;
          if (v15 != *v17)
          {
            uint64_t v19 = 0;
            int v20 = 1;
            while (v18 != -4096)
            {
              if (v19) {
                BOOL v21 = 0;
              }
              else {
                BOOL v21 = v18 == -8192;
              }
              if (v21) {
                uint64_t v19 = v17;
              }
              unsigned int v22 = v16 + v20++;
              unsigned int v16 = v22 & v13;
              unsigned int v17 = (void *)(*(void *)a1 + 16 * (v22 & v13));
              uint64_t v18 = *v17;
              if (v15 == *v17) {
                goto LABEL_12;
              }
            }
            if (v19) {
              unsigned int v17 = v19;
            }
          }
LABEL_12:
          *unsigned int v17 = v15;
          v17[1] = v14[1];
          *(_DWORD *)(a1 + 8) = ++v12;
        }
        v14 += 2;
      }
      while (v14 != &v4[2 * v3]);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v23 = *(unsigned int *)(a1 + 16);
  if (v23)
  {
    uint64_t v24 = 16 * v23;
    do
    {
      void *result = -4096;
      result += 2;
      v24 -= 16;
    }
    while (v24);
  }
  return result;
}

uint64_t **sub_1CCDBA7CC(uint64_t **a1, uint64_t *a2)
{
  unint64_t v5 = a1 + 1;
  __n128 v4 = a1[1];
  if (v4)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v6 = (uint64_t **)v4;
        unint64_t v7 = v4[6];
        if (v7 <= (unint64_t)a2) {
          break;
        }
        __n128 v4 = *v6;
        unint64_t v5 = v6;
        if (!*v6) {
          goto LABEL_9;
        }
      }
      if (v7 >= (unint64_t)a2) {
        break;
      }
      __n128 v4 = v6[1];
      if (!v4)
      {
        unint64_t v5 = v6 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    unint64_t v6 = a1 + 1;
LABEL_9:
    unsigned int v8 = (uint64_t *)v6;
    unint64_t v6 = (uint64_t **)operator new(0x38uLL);
    v6[4] = (uint64_t *)(v6 + 4);
    v6[5] = (uint64_t *)1;
    v6[6] = a2;
    *unint64_t v6 = 0;
    v6[1] = 0;
    void v6[2] = v8;
    *unint64_t v5 = (uint64_t *)v6;
    uint64_t v9 = (uint64_t *)**a1;
    uint64_t v10 = (uint64_t *)v6;
    if (v9)
    {
      *a1 = v9;
      uint64_t v10 = *v5;
    }
    sub_1CB8358B8(a1[1], v10);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v6;
}

uint64_t *sub_1CCDBA8A0(uint64_t *result, _OWORD *a2)
{
  uint64_t v2 = *result;
  unsigned int v3 = *(_DWORD *)(*result + 8);
  if (v3 >= *(_DWORD *)(*result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_OWORD *)(*(void *)v2 + 16 * v3) = *a2;
  ++*(_DWORD *)(v2 + 8);
  return result;
}

llvm::MDNode *sub_1CCDBA918(unsigned int *a1, uint64_t a2)
{
  v8[4] = *MEMORY[0x1E4F143B8];
  v8[0] = "llvm.loop.distribute.followup_all";
  v8[1] = 33;
  unsigned int v3 = "llvm.loop.distribute.followup_sequential";
  if (!*(unsigned char *)(a2 + 96)) {
    unsigned int v3 = "llvm.loop.distribute.followup_coincident";
  }
  void v8[2] = v3;
  v8[3] = 40;
  uint64_t result = llvm::makeFollowupLoopID(a1, (uint64_t)v8, 2, "", 0);
  if (v5)
  {
    unint64_t v6 = result;
    unint64_t v7 = *(llvm::Loop **)(a2 + 112);
    if (!v7) {
      unint64_t v7 = *(llvm::Loop **)(a2 + 104);
    }
    llvm::Loop::setLoopID(v7, v6);
  }
  return result;
}

void sub_1CCDBA9D8()
{
}

void sub_1CCDBAA18(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCDBAA50(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::ScalarEvolutionWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LoopAccessLegacyAnalysis::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::OptimizationRemarkEmitterWrapperPass::ID);

  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);
}

uint64_t sub_1CCDBAB38(llvm::FunctionPass *a1, llvm::LLVMContextImpl ****a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (llvm::FunctionPass::skipFunction(a1, a2)) {
    return 0;
  }
  char v5 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v6 = *v5;
  uint64_t v7 = v5[1];
  if (v6 == v7)
  {
LABEL_6:
    uint64_t v8 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v6 != &llvm::LoopInfoWrapperPass::ID)
    {
      v6 += 16;
      if (v6 == v7) {
        goto LABEL_6;
      }
    }
    uint64_t v8 = *(void *)(v6 + 8);
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v8 + 96))(v8, &llvm::LoopInfoWrapperPass::ID);
  uint64_t v10 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v11 = *v10;
  uint64_t v12 = v10[1];
  if (v11 == v12)
  {
LABEL_11:
    uint64_t v13 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v11 != &llvm::LoopAccessLegacyAnalysis::ID)
    {
      v11 += 16;
      if (v11 == v12) {
        goto LABEL_11;
      }
    }
    uint64_t v13 = *(void *)(v11 + 8);
  }
  uint64_t v33 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v13 + 96))(v13, &llvm::LoopAccessLegacyAnalysis::ID);
  uint64_t v14 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v15 = *v14;
  uint64_t v16 = v14[1];
  if (v15 == v16)
  {
LABEL_16:
    uint64_t v17 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v15 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v15 += 16;
      if (v15 == v16) {
        goto LABEL_16;
      }
    }
    uint64_t v17 = *(void *)(v15 + 8);
  }
  (*(void (**)(uint64_t, void *))(*(void *)v17 + 96))(v17, &llvm::DominatorTreeWrapperPass::ID);
  uint64_t v18 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v19 = *v18;
  uint64_t v20 = v18[1];
  if (v19 == v20)
  {
LABEL_21:
    uint64_t v21 = 0;
  }
  else
  {
    while (*(char **)v19 != llvm::ScalarEvolutionWrapperPass::ID)
    {
      v19 += 16;
      if (v19 == v20) {
        goto LABEL_21;
      }
    }
    uint64_t v21 = *(void *)(v19 + 8);
  }
  uint64_t v22 = v9 + 32;
  (*(void (**)(uint64_t, char *))(*(void *)v21 + 96))(v21, llvm::ScalarEvolutionWrapperPass::ID);
  uint64_t v23 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v24 = *v23;
  uint64_t v25 = v23[1];
  if (v24 == v25)
  {
LABEL_26:
    uint64_t v26 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v24 != &llvm::OptimizationRemarkEmitterWrapperPass::ID)
    {
      v24 += 16;
      if (v24 == v25) {
        goto LABEL_26;
      }
    }
    uint64_t v26 = *(void *)(v24 + 8);
  }
  (*(void (**)(uint64_t, void *))(*(void *)v26 + 96))(v26, &llvm::OptimizationRemarkEmitterWrapperPass::ID);
  uint64_t v27 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v28 = *v27;
  uint64_t v29 = v27[1];
  if (v28 == v29)
  {
LABEL_31:
    uint64_t v30 = 0;
  }
  else
  {
    while (*(char **)v28 != llvm::TargetTransformInfoWrapperPass::ID)
    {
      v28 += 16;
      if (v28 == v29) {
        goto LABEL_31;
      }
    }
    uint64_t v30 = *(void *)(v28 + 8);
  }
  uint64_t v31 = (llvm::TargetTransformInfoWrapperPass *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v30 + 96))(v30, llvm::TargetTransformInfoWrapperPass::ID);
  llvm::TargetTransformInfoWrapperPass::getTTI(v31, (const Function *)a2);
  v34[0] = &unk_1F263EAA8;
  v34[1] = &v33;
  uint64_t v35 = v34;
  uint64_t v4 = sub_1CCDB6BC8((uint64_t)a2, v22);
  if (v35 == v34)
  {
    (*(void (**)(void *))(v34[0] + 32))(v34);
  }
  else if (v35)
  {
    (*(void (**)(void *))(*v35 + 40))(v35);
  }
  return v4;
}

void sub_1CCDBAEF8()
{
}

void *sub_1CCDBAF0C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1F263EAA8;
  result[1] = v3;
  return result;
}

uint64_t sub_1CCDBAF54(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F263EAA8;
  a2[1] = v2;
  return result;
}

uint64_t sub_1CCDBAF80(uint64_t a1, llvm::Loop *a2)
{
  return llvm::LoopAccessLegacyAnalysis::getInfo(**(llvm::LoopAccessLegacyAnalysis ***)(a1 + 8), a2);
}

void sub_1CCDBAF90()
{
}

__n128 sub_1CCDBAFA4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x48uLL);
  *(void *)uint64_t v2 = &unk_1F263EAF0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(v2 + 40) = *(_OWORD *)(a1 + 40);
  __n128 result = *(__n128 *)(a1 + 56);
  *(__n128 *)(v2 + 56) = result;
  return result;
}

__n128 sub_1CCDBB008(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F263EAF0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1CCDBB050()
{
}

uint64_t sub_1CCDBB0A4()
{
  int v4 = 1;
  v3.n128_u64[0] = (unint64_t)"Turn on DominatorTree and LoopInfo verification after Loop Distribution";
  v3.n128_u64[1] = 71;
  LOBYTE(v1) = 0;
  uint64_t v2 = &v1;
  sub_1CD413E90((llvm::cl::Option *)&unk_1EBCF3A20, "loop-distribute-verify", &v4, &v3, (unsigned char **)&v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF3A20, &dword_1CB82C000);
  int v4 = 1;
  v3.n128_u64[0] = (unint64_t)"Whether to distribute into a loop that may not be if-convertible by the loop vectorizer";
  v3.n128_u64[1] = 87;
  LOBYTE(v1) = 0;
  uint64_t v2 = &v1;
  sub_1CD413E90((llvm::cl::Option *)&unk_1EBCF3AE0, "loop-distribute-non-if-convertible", &v4, &v3, (unsigned char **)&v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF3AE0, &dword_1CB82C000);
  int v4 = 8;
  int v1 = 1;
  uint64_t v2 = &v4;
  v3.n128_u64[0] = (unint64_t)"The maximum number of SCEV checks allowed for Loop Distribution";
  v3.n128_u64[1] = 63;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF3BA0, "loop-distribute-scev-check-threshold", &v2, &v1, &v3);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF3BA0, &dword_1CB82C000);
  int v4 = 128;
  int v1 = 1;
  uint64_t v2 = &v4;
  v3.n128_u64[0] = (unint64_t)"The maximum number of SCEV checks allowed for Loop Distribution for loop marked wit"
                                     "h #pragma loop distribute(enable)";
  v3.n128_u64[1] = 116;
  sub_1CD76FDDC(&v2, &v1, (long long *)&v3);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCF3C60, &dword_1CB82C000);
  int v4 = 1;
  v3.n128_u64[0] = (unint64_t)"Enable the new, experimental LoopDistribution Pass";
  v3.n128_u64[1] = 50;
  LOBYTE(v1) = 0;
  uint64_t v2 = &v1;
  sub_1CD413E90((llvm::cl::Option *)&unk_1EBCF3D20, "enable-loop-distribute", &v4, &v3, (unsigned char **)&v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF3D20, &dword_1CB82C000);
  int v4 = 1;
  v3.n128_u64[0] = (unint64_t)"Only distribute loops with a large number of memory ops and backwards dependences with distance 1.";
  v3.n128_u64[1] = 98;
  LOBYTE(v1) = 0;
  uint64_t v2 = &v1;
  sub_1CD413E90((llvm::cl::Option *)&unk_1EBCF3DE0, "loop-distribute-mem", &v4, &v3, (unsigned char **)&v2);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF3DE0, &dword_1CB82C000);
}

llvm::raw_ostream *sub_1CCDBB2DC(llvm *a1)
{
  uint64_t v2 = llvm::dbgs(a1);
  __n128 v3 = (void *)*((void *)v2 + 4);
  if (*((void *)v2 + 3) - (void)v3 > 0xDuLL)
  {
    qmemcpy(v3, "\tGuardBranch: ", 14);
    *((void *)v2 + 4) += 14;
  }
  else
  {
    uint64_t v2 = llvm::raw_ostream::write(v2, "\tGuardBranch: ", 0xEuLL);
  }
  uint64_t v4 = *((void *)a1 + 43);
  char v5 = llvm::dbgs(v2);
  if (v4)
  {
    llvm::Value::print(*((llvm::Value **)a1 + 43), v5, 0);
  }
  else
  {
    uint64_t v6 = (_DWORD *)*((void *)v5 + 4);
    if (*((void *)v5 + 3) - (void)v6 > 6uLL)
    {
      *(_DWORD *)((char *)v6 + 3) = 1920233580;
      *uint64_t v6 = 1819047278;
      *((void *)v5 + 4) += 7;
    }
    else
    {
      char v5 = llvm::raw_ostream::write(v5, "nullptr", 7uLL);
    }
  }
  __n128 result = llvm::dbgs(v5);
  uint64_t v8 = result;
  uint64_t v9 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v9)
  {
    __n128 result = llvm::raw_ostream::write(result, "\n", 1uLL);
  }
  else
  {
    *uint64_t v9 = 10;
    ++*((void *)result + 4);
  }
  uint64_t v10 = (uint64_t ***)*((void *)a1 + 43);
  if (!v10)
  {
    __n128 result = (llvm::raw_ostream *)*((void *)v8 + 4);
    uint64_t v19 = "nullptr";
    size_t v20 = 7;
    if (*((void *)v8 + 3) - (void)result <= 6uLL)
    {
LABEL_21:
      __n128 result = llvm::raw_ostream::write(v8, v19, v20);
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  if ((*((unsigned char *)v10 + 23) & 0x10) == 0) {
    goto LABEL_24;
  }
  uint64_t v11 = ***v10;
  uint64_t v12 = *(void *)(v11 + 152);
  uint64_t v13 = *(unsigned int *)(v11 + 168);
  if (v13)
  {
    LODWORD(v14) = (v13 - 1) & ((v10 >> 4) ^ (v10 >> 9));
    uint64_t v15 = (uint64_t ****)(v12 + 16 * v14);
    uint64_t v16 = *v15;
    if (*v15 == v10) {
      goto LABEL_20;
    }
    int v17 = 1;
    while (v16 != (uint64_t ***)-4096)
    {
      int v18 = v14 + v17++;
      uint64_t v14 = v18 & (v13 - 1);
      uint64_t v16 = *(uint64_t ****)(v12 + 16 * v14);
      if (v16 == v10)
      {
        uint64_t v15 = (uint64_t ****)(v12 + 16 * v14);
        goto LABEL_20;
      }
    }
  }
  uint64_t v15 = (uint64_t ****)(v12 + 16 * v13);
LABEL_20:
  uint64_t v21 = v15[1];
  size_t v22 = (size_t)*v21;
  uint64_t v19 = (const char *)(v21 + 2);
  size_t v20 = v22;
  __n128 result = (llvm::raw_ostream *)*((void *)v8 + 4);
  if (v22 > *((void *)v8 + 3) - (void)result) {
    goto LABEL_21;
  }
  if (v20)
  {
LABEL_23:
    __n128 result = (llvm::raw_ostream *)memcpy(result, v19, v20);
    *((void *)v8 + 4) += v20;
  }
LABEL_24:
  uint64_t v23 = (unsigned char *)*((void *)v8 + 4);
  if (*((unsigned char **)v8 + 3) == v23)
  {
    __n128 result = llvm::raw_ostream::write(v8, "\n", 1uLL);
    uint64_t v24 = *((void *)v8 + 4);
  }
  else
  {
    *uint64_t v23 = 10;
    uint64_t v24 = *((void *)v8 + 4) + 1;
    *((void *)v8 + 4) = v24;
  }
  if ((unint64_t)(*((void *)v8 + 3) - v24) > 0xB)
  {
    *(_DWORD *)(v24 + 8) = 540701285;
    *(void *)uint64_t v24 = *(void *)"\tPreheader: ";
    *((void *)v8 + 4) += 12;
  }
  else
  {
    __n128 result = llvm::raw_ostream::write(v8, "\tPreheader: ", 0xCuLL);
  }
  uint64_t v25 = *(uint64_t ****)a1;
  if (!*(void *)a1)
  {
    __n128 result = (llvm::raw_ostream *)*((void *)v8 + 4);
    uint64_t v34 = "nullptr";
    size_t v35 = 7;
    if (*((void *)v8 + 3) - (void)result <= 6uLL)
    {
LABEL_40:
      __n128 result = llvm::raw_ostream::write(v8, v34, v35);
      goto LABEL_43;
    }
    goto LABEL_42;
  }
  if ((*((unsigned char *)v25 + 23) & 0x10) == 0) {
    goto LABEL_43;
  }
  uint64_t v26 = ***v25;
  uint64_t v27 = *(void *)(v26 + 152);
  uint64_t v28 = *(unsigned int *)(v26 + 168);
  if (v28)
  {
    LODWORD(v29) = (v28 - 1) & ((v25 >> 4) ^ (v25 >> 9));
    uint64_t v30 = (uint64_t ****)(v27 + 16 * v29);
    uint64_t v31 = *v30;
    if (*v30 == v25) {
      goto LABEL_39;
    }
    int v32 = 1;
    while (v31 != (uint64_t ***)-4096)
    {
      int v33 = v29 + v32++;
      uint64_t v29 = v33 & (v28 - 1);
      uint64_t v31 = *(uint64_t ****)(v27 + 16 * v29);
      if (v31 == v25)
      {
        uint64_t v30 = (uint64_t ****)(v27 + 16 * v29);
        goto LABEL_39;
      }
    }
  }
  uint64_t v30 = (uint64_t ****)(v27 + 16 * v28);
LABEL_39:
  uint64_t v36 = v30[1];
  size_t v37 = (size_t)*v36;
  uint64_t v34 = (const char *)(v36 + 2);
  size_t v35 = v37;
  __n128 result = (llvm::raw_ostream *)*((void *)v8 + 4);
  if (v37 > *((void *)v8 + 3) - (void)result) {
    goto LABEL_40;
  }
  if (v35)
  {
LABEL_42:
    __n128 result = (llvm::raw_ostream *)memcpy(result, v34, v35);
    *((void *)v8 + 4) += v35;
  }
LABEL_43:
  unsigned int v38 = (unsigned char *)*((void *)v8 + 4);
  if (*((unsigned char **)v8 + 3) == v38)
  {
    __n128 result = llvm::raw_ostream::write(v8, "\n", 1uLL);
    uint64_t v39 = *((void *)v8 + 4);
  }
  else
  {
    *unsigned int v38 = 10;
    uint64_t v39 = *((void *)v8 + 4) + 1;
    *((void *)v8 + 4) = v39;
  }
  if ((unint64_t)(*((void *)v8 + 3) - v39) > 8)
  {
    *(unsigned char *)(v39 + 8) = 32;
    *(void *)uint64_t v39 = *(void *)"\tHeader: ";
    *((void *)v8 + 4) += 9;
  }
  else
  {
    __n128 result = llvm::raw_ostream::write(v8, "\tHeader: ", 9uLL);
  }
  uint64_t v40 = (uint64_t ***)*((void *)a1 + 1);
  if (!v40)
  {
    __n128 result = (llvm::raw_ostream *)*((void *)v8 + 4);
    uint64_t v49 = "nullptr";
    size_t v50 = 7;
    if (*((void *)v8 + 3) - (void)result <= 6uLL)
    {
LABEL_59:
      __n128 result = llvm::raw_ostream::write(v8, v49, v50);
      goto LABEL_62;
    }
    goto LABEL_61;
  }
  if ((*((unsigned char *)v40 + 23) & 0x10) == 0) {
    goto LABEL_62;
  }
  uint64_t v41 = ***v40;
  uint64_t v42 = *(void *)(v41 + 152);
  uint64_t v43 = *(unsigned int *)(v41 + 168);
  if (v43)
  {
    LODWORD(v44) = (v43 - 1) & ((v40 >> 4) ^ (v40 >> 9));
    uint64_t v45 = (uint64_t ****)(v42 + 16 * v44);
    unsigned int v46 = *v45;
    if (*v45 == v40) {
      goto LABEL_58;
    }
    int v47 = 1;
    while (v46 != (uint64_t ***)-4096)
    {
      int v48 = v44 + v47++;
      uint64_t v44 = v48 & (v43 - 1);
      unsigned int v46 = *(uint64_t ****)(v42 + 16 * v44);
      if (v46 == v40)
      {
        uint64_t v45 = (uint64_t ****)(v42 + 16 * v44);
        goto LABEL_58;
      }
    }
  }
  uint64_t v45 = (uint64_t ****)(v42 + 16 * v43);
LABEL_58:
  unsigned int v51 = v45[1];
  size_t v52 = (size_t)*v51;
  uint64_t v49 = (const char *)(v51 + 2);
  size_t v50 = v52;
  __n128 result = (llvm::raw_ostream *)*((void *)v8 + 4);
  if (v52 > *((void *)v8 + 3) - (void)result) {
    goto LABEL_59;
  }
  if (v50)
  {
LABEL_61:
    __n128 result = (llvm::raw_ostream *)memcpy(result, v49, v50);
    *((void *)v8 + 4) += v50;
  }
LABEL_62:
  unsigned int v53 = (unsigned char *)*((void *)v8 + 4);
  if (*((unsigned char **)v8 + 3) == v53)
  {
    __n128 result = llvm::raw_ostream::write(v8, "\n", 1uLL);
    uint64_t v54 = *((void *)v8 + 4);
  }
  else
  {
    unsigned char *v53 = 10;
    uint64_t v54 = *((void *)v8 + 4) + 1;
    *((void *)v8 + 4) = v54;
  }
  if ((unint64_t)(*((void *)v8 + 3) - v54) > 0xB)
  {
    *(_DWORD *)(v54 + 8) = 540688962;
    *(void *)uint64_t v54 = *(void *)"\tExitingBB: ";
    *((void *)v8 + 4) += 12;
  }
  else
  {
    __n128 result = llvm::raw_ostream::write(v8, "\tExitingBB: ", 0xCuLL);
  }
  int v55 = (uint64_t ***)*((void *)a1 + 2);
  if (!v55)
  {
    __n128 result = (llvm::raw_ostream *)*((void *)v8 + 4);
    uint64_t v64 = "nullptr";
    size_t v65 = 7;
    if (*((void *)v8 + 3) - (void)result <= 6uLL)
    {
LABEL_78:
      __n128 result = llvm::raw_ostream::write(v8, v64, v65);
      goto LABEL_81;
    }
    goto LABEL_80;
  }
  if ((*((unsigned char *)v55 + 23) & 0x10) == 0) {
    goto LABEL_81;
  }
  uint64_t v56 = ***v55;
  uint64_t v57 = *(void *)(v56 + 152);
  uint64_t v58 = *(unsigned int *)(v56 + 168);
  if (v58)
  {
    LODWORD(v59) = (v58 - 1) & ((v55 >> 4) ^ (v55 >> 9));
    int v60 = (uint64_t ****)(v57 + 16 * v59);
    unint64_t v61 = *v60;
    if (*v60 == v55) {
      goto LABEL_77;
    }
    int v62 = 1;
    while (v61 != (uint64_t ***)-4096)
    {
      int v63 = v59 + v62++;
      uint64_t v59 = v63 & (v58 - 1);
      unint64_t v61 = *(uint64_t ****)(v57 + 16 * v59);
      if (v61 == v55)
      {
        int v60 = (uint64_t ****)(v57 + 16 * v59);
        goto LABEL_77;
      }
    }
  }
  int v60 = (uint64_t ****)(v57 + 16 * v58);
LABEL_77:
  uint64_t v66 = v60[1];
  size_t v67 = (size_t)*v66;
  uint64_t v64 = (const char *)(v66 + 2);
  size_t v65 = v67;
  __n128 result = (llvm::raw_ostream *)*((void *)v8 + 4);
  if (v67 > *((void *)v8 + 3) - (void)result) {
    goto LABEL_78;
  }
  if (v65)
  {
LABEL_80:
    __n128 result = (llvm::raw_ostream *)memcpy(result, v64, v65);
    *((void *)v8 + 4) += v65;
  }
LABEL_81:
  long long v68 = (unsigned char *)*((void *)v8 + 4);
  if (*((unsigned char **)v8 + 3) == v68)
  {
    __n128 result = llvm::raw_ostream::write(v8, "\n", 1uLL);
    uint64_t v69 = *((void *)v8 + 4);
  }
  else
  {
    *long long v68 = 10;
    uint64_t v69 = *((void *)v8 + 4) + 1;
    *((void *)v8 + 4) = v69;
  }
  if ((unint64_t)(*((void *)v8 + 3) - v69) > 8)
  {
    *(unsigned char *)(v69 + 8) = 32;
    *(void *)uint64_t v69 = *(void *)"\tExitBB: ";
    *((void *)v8 + 4) += 9;
  }
  else
  {
    __n128 result = llvm::raw_ostream::write(v8, "\tExitBB: ", 9uLL);
  }
  uint64_t v70 = (uint64_t ***)*((void *)a1 + 3);
  if (!v70)
  {
    __n128 result = (llvm::raw_ostream *)*((void *)v8 + 4);
    BOOL v79 = "nullptr";
    size_t v80 = 7;
    if (*((void *)v8 + 3) - (void)result <= 6uLL)
    {
LABEL_97:
      __n128 result = llvm::raw_ostream::write(v8, v79, v80);
      goto LABEL_100;
    }
    goto LABEL_99;
  }
  if ((*((unsigned char *)v70 + 23) & 0x10) == 0) {
    goto LABEL_100;
  }
  uint64_t v71 = ***v70;
  uint64_t v72 = *(void *)(v71 + 152);
  uint64_t v73 = *(unsigned int *)(v71 + 168);
  if (v73)
  {
    LODWORD(v74) = (v73 - 1) & ((v70 >> 4) ^ (v70 >> 9));
    uint64_t v75 = (uint64_t ****)(v72 + 16 * v74);
    uint64_t v76 = *v75;
    if (*v75 == v70) {
      goto LABEL_96;
    }
    int v77 = 1;
    while (v76 != (uint64_t ***)-4096)
    {
      int v78 = v74 + v77++;
      uint64_t v74 = v78 & (v73 - 1);
      uint64_t v76 = *(uint64_t ****)(v72 + 16 * v74);
      if (v76 == v70)
      {
        uint64_t v75 = (uint64_t ****)(v72 + 16 * v74);
        goto LABEL_96;
      }
    }
  }
  uint64_t v75 = (uint64_t ****)(v72 + 16 * v73);
LABEL_96:
  unsigned int v81 = v75[1];
  size_t v82 = (size_t)*v81;
  BOOL v79 = (const char *)(v81 + 2);
  size_t v80 = v82;
  __n128 result = (llvm::raw_ostream *)*((void *)v8 + 4);
  if (v82 > *((void *)v8 + 3) - (void)result) {
    goto LABEL_97;
  }
  if (v80)
  {
LABEL_99:
    __n128 result = (llvm::raw_ostream *)memcpy(result, v79, v80);
    *((void *)v8 + 4) += v80;
  }
LABEL_100:
  uint64_t v83 = (unsigned char *)*((void *)v8 + 4);
  if (*((unsigned char **)v8 + 3) == v83)
  {
    __n128 result = llvm::raw_ostream::write(v8, "\n", 1uLL);
    uint64_t v84 = (void *)*((void *)v8 + 4);
  }
  else
  {
    *uint64_t v83 = 10;
    uint64_t v84 = (void *)(*((void *)v8 + 4) + 1);
    *((void *)v8 + 4) = v84;
  }
  if (*((void *)v8 + 3) - (void)v84 > 7uLL)
  {
    void *v84 = 0x203A686374614C09;
    *((void *)v8 + 4) += 8;
  }
  else
  {
    __n128 result = llvm::raw_ostream::write(v8, "\tLatch: ", 8uLL);
  }
  unint64_t v85 = (uint64_t ***)*((void *)a1 + 4);
  if (!v85)
  {
    __n128 result = (llvm::raw_ostream *)*((void *)v8 + 4);
    int v94 = "nullptr";
    size_t v95 = 7;
    if (*((void *)v8 + 3) - (void)result <= 6uLL)
    {
LABEL_116:
      __n128 result = llvm::raw_ostream::write(v8, v94, v95);
      goto LABEL_119;
    }
    goto LABEL_118;
  }
  if ((*((unsigned char *)v85 + 23) & 0x10) == 0) {
    goto LABEL_119;
  }
  uint64_t v86 = ***v85;
  uint64_t v87 = *(void *)(v86 + 152);
  uint64_t v88 = *(unsigned int *)(v86 + 168);
  if (v88)
  {
    LODWORD(v89) = (v88 - 1) & ((v85 >> 4) ^ (v85 >> 9));
    uint64_t v90 = (uint64_t ****)(v87 + 16 * v89);
    unint64_t v91 = *v90;
    if (*v90 == v85) {
      goto LABEL_115;
    }
    int v92 = 1;
    while (v91 != (uint64_t ***)-4096)
    {
      int v93 = v89 + v92++;
      uint64_t v89 = v93 & (v88 - 1);
      unint64_t v91 = *(uint64_t ****)(v87 + 16 * v89);
      if (v91 == v85)
      {
        uint64_t v90 = (uint64_t ****)(v87 + 16 * v89);
        goto LABEL_115;
      }
    }
  }
  uint64_t v90 = (uint64_t ****)(v87 + 16 * v88);
LABEL_115:
  uint64_t v96 = v90[1];
  size_t v97 = (size_t)*v96;
  int v94 = (const char *)(v96 + 2);
  size_t v95 = v97;
  __n128 result = (llvm::raw_ostream *)*((void *)v8 + 4);
  if (v97 > *((void *)v8 + 3) - (void)result) {
    goto LABEL_116;
  }
  if (v95)
  {
LABEL_118:
    __n128 result = (llvm::raw_ostream *)memcpy(result, v94, v95);
    *((void *)v8 + 4) += v95;
  }
LABEL_119:
  uint64_t v98 = (unsigned char *)*((void *)v8 + 4);
  if (*((unsigned char **)v8 + 3) == v98)
  {
    __n128 result = llvm::raw_ostream::write(v8, "\n", 1uLL);
    int v99 = (void *)*((void *)v8 + 4);
  }
  else
  {
    *uint64_t v98 = 10;
    int v99 = (void *)(*((void *)v8 + 4) + 1);
    *((void *)v8 + 4) = v99;
  }
  if (*((void *)v8 + 3) - (void)v99 > 0xCuLL)
  {
    qmemcpy(v99, "\tEntryBlock: ", 13);
    *((void *)v8 + 4) += 13;
  }
  else
  {
    __n128 result = llvm::raw_ostream::write(v8, "\tEntryBlock: ", 0xDuLL);
  }
  uint64_t v100 = *((void *)a1 + 43);
  if (v100) {
    uint64_t v101 = (uint64_t ****)(v100 + 40);
  }
  else {
    uint64_t v101 = (uint64_t ****)a1;
  }
  int v102 = *v101;
  if (!v102)
  {
    __n128 result = (llvm::raw_ostream *)*((void *)v8 + 4);
    int v111 = "nullptr";
    size_t v112 = 7;
    if (*((void *)v8 + 3) - (void)result <= 6uLL)
    {
LABEL_138:
      __n128 result = llvm::raw_ostream::write(v8, v111, v112);
      goto LABEL_141;
    }
    goto LABEL_140;
  }
  if ((*((unsigned char *)v102 + 23) & 0x10) == 0) {
    goto LABEL_141;
  }
  uint64_t v103 = ***v102;
  uint64_t v104 = *(void *)(v103 + 152);
  uint64_t v105 = *(unsigned int *)(v103 + 168);
  if (v105)
  {
    LODWORD(v106) = (v105 - 1) & ((v102 >> 4) ^ (v102 >> 9));
    uint64_t v107 = (uint64_t ****)(v104 + 16 * v106);
    unint64_t v108 = *v107;
    if (*v107 == v102) {
      goto LABEL_137;
    }
    int v109 = 1;
    while (v108 != (uint64_t ***)-4096)
    {
      int v110 = v106 + v109++;
      uint64_t v106 = v110 & (v105 - 1);
      unint64_t v108 = *(uint64_t ****)(v104 + 16 * v106);
      if (v108 == v102)
      {
        uint64_t v107 = (uint64_t ****)(v104 + 16 * v106);
        goto LABEL_137;
      }
    }
  }
  uint64_t v107 = (uint64_t ****)(v104 + 16 * v105);
LABEL_137:
  unint64_t v113 = v107[1];
  size_t v114 = (size_t)*v113;
  int v111 = (const char *)(v113 + 2);
  size_t v112 = v114;
  __n128 result = (llvm::raw_ostream *)*((void *)v8 + 4);
  if (v114 > *((void *)v8 + 3) - (void)result) {
    goto LABEL_138;
  }
  if (v112)
  {
LABEL_140:
    __n128 result = (llvm::raw_ostream *)memcpy(result, v111, v112);
    *((void *)v8 + 4) += v112;
  }
LABEL_141:
  uint64_t v115 = (unsigned char *)*((void *)v8 + 4);
  if (*((unsigned char **)v8 + 3) == v115)
  {
    return llvm::raw_ostream::write(v8, "\n", 1uLL);
  }
  else
  {
    unsigned char *v115 = 10;
    ++*((void *)v8 + 4);
  }
  return result;
}

uint64_t sub_1CCDBBD98(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  v22[4] = *MEMORY[0x1E4F143B8];
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x400000000;
  *(void *)(a1 + 112) = a1 + 144;
  *(void *)(a1 + 120) = a1 + 144;
  *(void *)(a1 + 128) = 8;
  *(_DWORD *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 208) = 1;
  *(void *)(a1 + 216) = a1 + 232;
  uint64_t v16 = a1 + 216;
  *(void *)(a1 + 224) = 0x400000000;
  uint64_t v18 = *(void *)(a2 + 24);
  uint64_t v17 = *(void *)(a2 + 32);
  if (v18 != v17)
  {
    uint64_t v20 = a8;
    v21[0] = v22;
    v21[1] = (void *)0x400000000;
    sub_1CC08BDA8((uint64_t)v21, v17, v17, v18, v18);
    sub_1CD770550(v16, (uint64_t)v21);
    if (v21[0] != v22) {
      free(v21[0]);
    }
    a8 = v20;
  }
  *(void *)(a1 + 424) = a1 + 440;
  *(void *)(a1 + 432) = 0x1000000000;
  *(void *)(a1 + 704) = 0;
  *(void *)(a1 + 696) = 0;
  *(void *)(a1 + 712) = a3;
  *(void *)(a1 + 720) = a6;
  *(unsigned char *)(a1 + 728) = 1;
  *(void *)(a1 + 736) = a1 + 768;
  *(void *)(a1 + 744) = a1 + 768;
  *(void *)(a1 + 752) = 8;
  *(_DWORD *)(a1 + 760) = 0;
  *(void *)(a1 + 832) = 0;
  *(void *)(a1 + 848) = 0;
  *(void *)(a1 + 840) = 0;
  *(_WORD *)(a1 + 856) = 0;
  *(void *)(a1 + 864) = a2;
  *(void *)(a1 + 872) = a3;
  *(void *)(a1 + 880) = a4;
  *(void *)(a1 + 888) = a5;
  *(void *)(a1 + 896) = a6;
  *(void *)(a1 + 904) = a7;
  *(void *)(a1 + 912) = a8;
  *(void *)(a1 + 920) = a9;
  return a1;
}

uint64_t sub_1CCDBBF3C(uint64_t a1)
{
  v214[16] = *MEMORY[0x1E4F143B8];
  int v1 = (unsigned int *)(a1 + 132);
  unsigned int v2 = *(_DWORD *)(a1 + 224);
  if (v2 != *(_DWORD *)(a1 + 132) - *(_DWORD *)(a1 + 136))
  {
    uint64_t v5 = a1;
    int v3 = 0;
    uint64_t v181 = (void **)(a1 + 112);
    unsigned int v182 = (uint64_t ***)(a1 + 216);
    uint64_t v188 = (unsigned int *)(a1 + 128);
    uint64_t v183 = (unsigned int *)(a1 + 132);
    while (1)
    {
      if (v2)
      {
        uint64_t v185 = (uint64_t)&(*v182)[6 * v2];
        uint64_t v6 = *v182;
        do
        {
          int v7 = *((_DWORD *)v6 + 2);
          if (v7 != 1)
          {
            __int16 v186 = v6;
            int v184 = v3;
            if (v7)
            {
              uint64_t v8 = **v6;
              uint64_t v9 = *(void *)(v5 + 888);
              uint64_t v10 = *(void **)(v5 + 920);
              LODWORD(v199) = 0;
              WORD2(v199) = 1;
              BYTE6(v199) = 1;
              (*(void (**)(void, uint64_t, uint64_t, long long *))(*(void *)*v10 + 192))(*v10, v8, v9, &v199);
              sub_1CCDC0434();
            }
            unsigned int v11 = *(_DWORD *)(v5 + 8);
            if (v11)
            {
              uint64_t v12 = *(llvm::Instruction **)v5;
              uint64_t v187 = *(void *)v5 + 24 * v11;
              uint64_t v13 = &unk_1EBCF3000;
              while (1)
              {
                uint64_t v189 = v12;
                if (*((void *)v12 + 2) >= 2uLL)
                {
                  uint64_t v15 = (void *)((char *)v12 + 8);
                  uint64_t v14 = *(void **)v12;
                  if (*(llvm::Instruction **)v12 != (llvm::Instruction *)((char *)v12 + 8)) {
                    break;
                  }
                }
LABEL_243:
                uint64_t v12 = (llvm::Instruction *)((char *)v189 + 24);
                if ((llvm::Instruction *)((char *)v189 + 24) == (llvm::Instruction *)v187) {
                  goto LABEL_244;
                }
              }
              int v196 = (void *)((char *)v12 + 8);
              while (1)
              {
                uint64_t v16 = (void *)v14[1];
                uint64_t v17 = v16;
                uint64_t v18 = v14;
                if (v16)
                {
                  do
                  {
                    uint64_t v19 = v17;
                    uint64_t v17 = (void *)*v17;
                  }
                  while (v17);
                }
                else
                {
                  do
                  {
                    uint64_t v19 = (void *)v18[2];
                    BOOL v41 = *v19 == (void)v18;
                    uint64_t v18 = v19;
                  }
                  while (!v41);
                }
                if (v19 != v15) {
                  break;
                }
LABEL_237:
                if (v16)
                {
                  do
                  {
                    unsigned int v151 = v16;
                    uint64_t v16 = (void *)*v16;
                  }
                  while (v16);
                }
                else
                {
                  do
                  {
                    unsigned int v151 = (void *)v14[2];
                    BOOL v41 = *v151 == (void)v14;
                    uint64_t v14 = v151;
                  }
                  while (!v41);
                }
                uint64_t v14 = v151;
                if (v151 == v15) {
                  goto LABEL_243;
                }
              }
LABEL_22:
              uint64_t v20 = *(llvm::ScalarEvolution **)(v5 + 888);
              uint64_t v21 = (const llvm::Loop *)v14[9];
              BackedgeTakenInfo = llvm::ScalarEvolution::getBackedgeTakenInfo(v20, v21);
              uint64_t Exact = llvm::ScalarEvolution::BackedgeTakenInfo::getExact((uint64_t)BackedgeTakenInfo, (uint64_t)v21, (uint64_t)v20);
              if (*(_WORD *)(Exact + 24) == 15
                || (uint64_t v25 = Exact,
                    uint64_t v26 = *(llvm::ScalarEvolution **)(v5 + 888),
                    uint64_t v27 = (const llvm::Loop *)v19[9],
                    uint64_t v28 = llvm::ScalarEvolution::getBackedgeTakenInfo(v26, v27),
                    uint64_t v29 = llvm::ScalarEvolution::BackedgeTakenInfo::getExact((uint64_t)v28, (uint64_t)v27, (uint64_t)v26),
                    *(_WORD *)(v29 + 24) == 15))
              {
LABEL_24:
                LOBYTE(v199) = 0;
                BYTE4(v199) = 0;
                BYTE8(v199) = 0;
              }
              else if (v25 == v29)
              {
                LOBYTE(v199) = 1;
                DWORD1(v199) = 0;
                BYTE8(v199) = 1;
              }
              else
              {
                int SmallConstantTripCount = llvm::ScalarEvolution::getSmallConstantTripCount(*(llvm::ScalarEvolution **)(v5 + 888), (const llvm::Loop *)v14[9]);
                int v99 = llvm::ScalarEvolution::getSmallConstantTripCount(*(llvm::ScalarEvolution **)(v5 + 888), (const llvm::Loop *)v19[9]);
                if (!SmallConstantTripCount || !v99) {
                  goto LABEL_24;
                }
                unsigned int v100 = (SmallConstantTripCount - v99) & 0xFFFFFF00;
                LOBYTE(v199) = 0;
                if (SmallConstantTripCount - v99 <= 0) {
                  unsigned int v100 = 0;
                }
                *(void *)((char *)&v199 + 4) = v100 & 0xFFFFFF00 | ((SmallConstantTripCount - v99) & ~((SmallConstantTripCount - v99) >> 31)) | ((unint64_t)(SmallConstantTripCount - v99 > 0) << 32);
              }
              int v30 = BYTE8(v199);
              uint64_t v31 = (llvm::Loop *)DWORD1(v199);
              if (!*((unsigned char *)v14 + 392) || (v199 & 1) != 0)
              {
                if ((v199 & 1) == 0) {
                  goto LABEL_59;
                }
              }
              else if (!BYTE8(v199) || v13[972] < DWORD1(v199))
              {
                goto LABEL_59;
              }
              int v32 = (long long *)(v14 + 4);
              int v33 = (llvm **)(v19 + 4);
              uint64_t v34 = v14[47];
              if (v34)
              {
                if (*((unsigned char *)v14 + 393) || (uint64_t v35 = *(void *)(v34 - 32), v35 == *(void *)v32)) {
                  uint64_t v35 = *(void *)(v34 - 64);
                }
                uint64_t v36 = v19[47];
                size_t v37 = (void *)(v36 + 40);
                if (!v36) {
                  size_t v37 = v19 + 4;
                }
                if (v35 != *v37)
                {
LABEL_58:
                  uint64_t v15 = v196;
                  goto LABEL_59;
                }
                if (v36)
                {
                  uint64_t v38 = *(void *)(v34 - 96);
                  if (!v38) {
                    goto LABEL_51;
                  }
                  if (*(unsigned __int8 *)(v38 + 16) < 0x1Cu) {
                    goto LABEL_51;
                  }
                  uint64_t v39 = *(void *)(v36 - 96);
                  if (!v39 || *(unsigned __int8 *)(v39 + 16) < 0x1Cu) {
                    goto LABEL_51;
                  }
                  if (llvm::Instruction::isIdenticalToWhenDefined(*(llvm::Instruction **)(v34 - 96), *(const llvm::Instruction **)(v36 - 96))&& (*(unsigned __int8 *)(v39 + 17) ^ *(unsigned __int8 *)(v38 + 17)) <= 1)
                  {
                    uint64_t v34 = v14[47];
                    uint64_t v36 = v19[47];
                    int v32 = (long long *)(v14 + 4);
                    uint64_t v5 = a1;
LABEL_51:
                    BOOL v41 = *(void *)(v34 - 32) == *(void *)v32;
                    uint64_t v40 = -64;
                    if (v41) {
                      uint64_t v40 = -32;
                    }
                    BOOL v41 = *(llvm **)(v36 + v40) != *v33 && v30 == 0;
                    if (v41) {
                      goto LABEL_58;
                    }
                  }
                  else
                  {
                    int v32 = (long long *)(v14 + 4);
                    uint64_t v5 = a1;
                    if (!v30) {
                      goto LABEL_58;
                    }
                  }
                }
              }
              else if (v19[47] || v14[7] != v19[4])
              {
                goto LABEL_58;
              }
              uint64_t v44 = (llvm::Instruction **)v5;
              uint64_t v45 = v32;
              uint64_t v46 = *(void *)(*(void *)v32 + 40);
              if (v46) {
                int v47 = (unsigned __int8 *)(v46 - 24);
              }
              else {
                int v47 = 0;
              }
              if (v47[16] - 29 >= 0xB) {
                int v48 = 0;
              }
              else {
                int v48 = (llvm::BasicBlock *)v47;
              }
              if (!llvm::isSafeToMoveBefore(*v33, v48, v44[109], v44[112], v44[110], v24)) {
                goto LABEL_160;
              }
              if (v14[47])
              {
                uint64_t v101 = (llvm *)v14[7];
                FirstNonPHIOrDbg = llvm::BasicBlock::getFirstNonPHIOrDbg((llvm::BasicBlock *)v19[7], 1);
                if (!llvm::isSafeToMoveBefore(v101, (llvm::BasicBlock *)FirstNonPHIOrDbg, *(llvm::Instruction **)(a1 + 872), *(llvm::DominatorTree **)(a1 + 896), *(const llvm::PostDominatorTree **)(a1 + 880), v103))goto LABEL_160; {
                uint64_t v105 = *(void *)(*(void *)(v14[47] + 40) + 40);
                }
                uint64_t v106 = v105 ? v105 - 24 : 0;
                uint64_t v107 = *(unsigned __int8 *)(v106 + 16) - 29 >= 0xB ? 0 : (llvm::BasicBlock *)v106;
                if (!llvm::isSafeToMoveBefore(*(llvm **)(v19[47] + 40), v107, *(llvm::Instruction **)(a1 + 872), *(llvm::DominatorTree **)(a1 + 896), *(const llvm::PostDominatorTree **)(a1 + 880), v104))goto LABEL_160; {
              }
                }
              size_t v50 = (llvm::Instruction **)v14[28];
              uint64_t v190 = (const void **)(v14 + 28);
              uint64_t v51 = *((unsigned int *)v14 + 58);
              size_t v52 = v45;
              if (v51)
              {
                unint64_t v192 = &v50[v51];
                do
                {
                  unsigned int v53 = *v50;
                  uint64_t v54 = *((unsigned int *)v19 + 58);
                  if (v54)
                  {
                    int v55 = (llvm::Instruction **)v19[28];
                    uint64_t v56 = 8 * v54;
                    do
                    {
                      if ((sub_1CCDC0D80(a1, (uint64_t)v52, (uint64_t)(v19 + 4), v53, *v55, dword_1EBCF3FF0) & 1) == 0) {
                        goto LABEL_159;
                      }
                      ++v55;
                      v56 -= 8;
                      size_t v52 = v45;
                    }
                    while (v56);
                  }
                  uint64_t v57 = *((unsigned int *)v19 + 22);
                  if (v57)
                  {
                    uint64_t v58 = (llvm::Instruction **)v19[10];
                    uint64_t v59 = 8 * v57;
                    do
                    {
                      if ((sub_1CCDC0D80(a1, (uint64_t)v52, (uint64_t)(v19 + 4), v53, *v58, dword_1EBCF3FF0) & 1) == 0) {
                        goto LABEL_159;
                      }
                      ++v58;
                      v59 -= 8;
                      size_t v52 = v45;
                    }
                    while (v59);
                  }
                  ++v50;
                }
                while (v50 != v192);
              }
              uint64_t v60 = *((unsigned int *)v19 + 58);
              if (v60)
              {
                unint64_t v61 = (llvm::Instruction **)v19[28];
                uint64_t v193 = &v61[v60];
                while (1)
                {
                  int v62 = *v61;
                  uint64_t v63 = *((unsigned int *)v14 + 58);
                  if (v63) {
                    break;
                  }
LABEL_92:
                  uint64_t v66 = *((unsigned int *)v14 + 22);
                  if (v66)
                  {
                    size_t v67 = (llvm::Instruction **)v14[10];
                    uint64_t v68 = 8 * v66;
                    while ((sub_1CCDC0D80(a1, (uint64_t)v52, (uint64_t)(v19 + 4), *v67, v62, dword_1EBCF3FF0) & 1) != 0)
                    {
                      ++v67;
                      v68 -= 8;
                      size_t v52 = v45;
                      if (!v68) {
                        goto LABEL_96;
                      }
                    }
                    goto LABEL_159;
                  }
LABEL_96:
                  if (++v61 == v193) {
                    goto LABEL_97;
                  }
                }
                uint64_t v64 = (llvm::Instruction **)v14[28];
                uint64_t v65 = 8 * v63;
                while ((sub_1CCDC0D80(a1, (uint64_t)v52, (uint64_t)(v19 + 4), *v64, v62, dword_1EBCF3FF0) & 1) != 0)
                {
                  ++v64;
                  v65 -= 8;
                  size_t v52 = v45;
                  if (!v65) {
                    goto LABEL_92;
                  }
                }
LABEL_159:
                uint64_t v13 = (_DWORD *)&unk_1EBCF3000;
                goto LABEL_160;
              }
LABEL_97:
              uint64_t v69 = v19[9];
              uint64_t v70 = *(void *)(v69 + 32);
              uint64_t v71 = *(void *)(v69 + 40);
              uint64_t v13 = (_DWORD *)&unk_1EBCF3000;
              if (v71 == v70)
              {
LABEL_143:
                long long v94 = v52[1];
                long long v199 = *v52;
                *(_OWORD *)uint64_t v200 = v94;
                *(_OWORD *)long long v201 = v52[2];
                uint64_t v202 = v204;
                uint64_t v203 = 0x1000000000;
                unsigned int v95 = *((_DWORD *)v14 + 22);
                if (v95 && &v199 != v52)
                {
                  if (v95 >= 0x11) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  memcpy(v204, (const void *)v14[10], 8 * *((unsigned int *)v14 + 22));
                  LODWORD(v203) = v95;
                  size_t v52 = v45;
                }
                uint64_t v205 = v207;
                uint64_t v206 = 0x1000000000;
                unsigned int v96 = *((_DWORD *)v14 + 58);
                if (v96 && &v205 != (void **)v190)
                {
                  if (v96 >= 0x11) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  memcpy(v207, *v190, 8 * *((unsigned int *)v14 + 58));
                  LODWORD(v206) = v96;
                  size_t v52 = v45;
                }
                long long v97 = *((_OWORD *)v14 + 24);
                v207[8] = *((_OWORD *)v14 + 23);
                v207[9] = v97;
                v207[10] = *((_OWORD *)v14 + 25);
                uint64_t v208 = v14[52];
                if (v30 && v31) {
                  llvm::peelLoop(v201[1], v31, *(llvm::LoopInfo **)(a1 + 864), *(llvm::LoopInfo **)(a1 + 888), *(llvm::ScalarEvolution **)(a1 + 872), *(llvm::DominatorTree **)(a1 + 912), (llvm::AssumptionCache *)1);
                }
                unint64_t v194 = v52;
                llvm::moveInstructionsToTheEnd(*v33, *(llvm::BasicBlock **)v52, *(llvm::BasicBlock **)(a1 + 872), *(llvm::DominatorTree **)(a1 + 896), *(const llvm::PostDominatorTree **)(a1 + 880), v49);
                uint64_t v108 = *((void *)v194 + 43);
                if (!v108)
                {
                  int v209 = &v211;
                  uint64_t v210 = 0x800000000;
                  if (*((void *)v194 + 2) != *((void *)v194 + 4)
                    && *(void *)(*((void *)v194 + 1) + 40) != *((void *)v194 + 1) + 40)
                  {
                    uint64_t v109 = *(void *)(*((void *)v194 + 1) + 48);
                    uint64_t v110 = v109 - 24;
                    uint64_t v111 = v109 ? v109 - 24 : 0;
                    if (v109 && *(unsigned char *)(v111 + 16) == 83)
                    {
                      unsigned int v112 = 0;
                      do
                      {
                        if (v112 >= HIDWORD(v210)) {
                          llvm::SmallVectorBase<unsigned int>::grow_pod();
                        }
                        *((void *)v209 + v112) = v110;
                        unsigned int v112 = v210 + 1;
                        LODWORD(v210) = v210 + 1;
                        uint64_t v113 = *(void *)(v110 + 32);
                        uint64_t v110 = v113 - 24;
                        if (v113) {
                          uint64_t v114 = v113 - 24;
                        }
                        else {
                          uint64_t v114 = 0;
                        }
                      }
                      while (v113 && *(unsigned char *)(v114 + 16) == 83);
                    }
                  }
                  llvm::BasicBlock::replaceSuccessorsPhiUsesWith((llvm::BasicBlock *)v19[4], (llvm::BasicBlock *)v19[4], *(llvm::BasicBlock **)v194);
                  llvm::BasicBlock::replaceSuccessorsPhiUsesWith(*((llvm::BasicBlock **)v194 + 4), *((llvm::BasicBlock **)v194 + 4), (llvm::BasicBlock *)v19[8]);
                  long long v212 = v214;
                  uint64_t v213 = 0x800000000;
                  if (*((unsigned char *)v194 + 361))
                  {
                    v214[1] = (unint64_t)*v33 | 4;
                    uint64_t v116 = *((void *)v194 + 2);
                    uint64_t v115 = (llvm::Value *)*((void *)v194 + 3);
                    v214[0] = v115;
                    LODWORD(v213) = 1;
                    uint64_t v117 = *(void *)(v116 + 40);
                    if (v117 == v116 + 40)
                    {
                      unint64_t v119 = 0;
                    }
                    else
                    {
                      if (v117) {
                        uint64_t v118 = (unsigned __int8 *)(v117 - 24);
                      }
                      else {
                        uint64_t v118 = 0;
                      }
                      if (v118[16] - 29 >= 0xB) {
                        unint64_t v119 = 0;
                      }
                      else {
                        unint64_t v119 = (llvm::User *)v118;
                      }
                    }
                    llvm::User::replaceUsesOfWith(v119, v115, (llvm::Value *)v19[5]);
                    uint64_t v124 = *((void *)v194 + 2);
                    uint64_t v125 = *((void *)v194 + 3) | 4;
                    int v126 = v213;
                    if (v213 >= HIDWORD(v213))
                    {
                      sub_1CD4C2394((uint64_t)&v212, v124, v125);
                    }
                    else
                    {
                      int v127 = (uint64_t *)((char *)v212 + 16 * v213);
                      *int v127 = v124;
                      v127[1] = v125;
                      LODWORD(v213) = v126 + 1;
                    }
                    llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                  }
                  uint64_t v120 = *((void *)v194 + 2);
                  uint64_t v121 = *(void *)(v120 + 40);
                  if (v121 == v120 + 40)
                  {
                    int v123 = 0;
                  }
                  else
                  {
                    if (v121) {
                      unsigned int v122 = (unsigned __int8 *)(v121 - 24);
                    }
                    else {
                      unsigned int v122 = 0;
                    }
                    if (v122[16] - 29 >= 0xB) {
                      int v123 = 0;
                    }
                    else {
                      int v123 = (llvm::User *)v122;
                    }
                  }
                  llvm::User::replaceUsesOfWith(v123, (llvm::Value *)v19[4], (llvm::Value *)v19[5]);
                  unsigned int v128 = v194;
                  uint64_t v129 = *((void *)v194 + 2);
                  uint64_t v130 = v19[4] | 4;
                  uint64_t v131 = v213;
                  unint64_t v132 = HIDWORD(v213);
                  if (v213 >= (unint64_t)HIDWORD(v213))
                  {
                    sub_1CD4C2394((uint64_t)&v212, v129, v130);
                    unsigned int v128 = v194;
                    unint64_t v134 = v213;
                    unint64_t v132 = HIDWORD(v213);
                  }
                  else
                  {
                    uint64_t v133 = (uint64_t *)((char *)v212 + 16 * v213);
                    uint64_t *v133 = v129;
                    v133[1] = v130;
                    unint64_t v134 = v131 + 1;
                    LODWORD(v213) = v134;
                  }
                  uint64_t v135 = *((void *)v128 + 2);
                  unint64_t v136 = v19[5] & 0xFFFFFFFFFFFFFFFBLL;
                  if (v134 >= v132)
                  {
                    sub_1CD4C2394((uint64_t)&v212, v135, v136);
                  }
                  else
                  {
                    int v137 = (uint64_t *)((char *)v212 + 16 * v134);
                    *int v137 = v135;
                    v137[1] = v136;
                    LODWORD(v213) = v134 + 1;
                  }
                  llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                }
                if (*((unsigned char *)v194 + 361) || (BOOL v138 = *(llvm::Value **)(v108 - 32), v138 == *(llvm::Value **)v194)) {
                  BOOL v138 = *(llvm::Value **)(v108 - 64);
                }
                int v191 = v138;
                uint64_t v139 = v19[47];
                if (*((unsigned char *)v19 + 393) || (int v140 = *(llvm::Value **)(v139 - 32), v140 == *v33)) {
                  int v140 = *(llvm::Value **)(v139 - 64);
                }
                unsigned int v141 = *(llvm::BasicBlock **)(v108 + 40);
                unsigned int v142 = *(llvm **)(v139 + 40);
                Uniqueuint64_t Successor = (llvm *)llvm::BasicBlock::getUniqueSuccessor(*((llvm::BasicBlock **)v194 + 3));
                int v145 = UniqueSuccessor;
                if (!*((unsigned char *)v194 + 361)) {
                  Uniqueuint64_t Successor = (llvm *)*((void *)v194 + 3);
                }
                llvm::moveInstructionsToTheBeginning(UniqueSuccessor, (llvm::BasicBlock *)v19[7], *(llvm::BasicBlock **)(a1 + 872), *(llvm::DominatorTree **)(a1 + 896), *(const llvm::PostDominatorTree **)(a1 + 880), v144);
                llvm::moveInstructionsToTheEnd(v142, v141, *(llvm::BasicBlock **)(a1 + 872), *(llvm::DominatorTree **)(a1 + 896), *(const llvm::PostDominatorTree **)(a1 + 880), v146);
                long long v212 = v214;
                uint64_t v213 = 0x800000000;
                llvm::BasicBlock::replacePhiUsesWith((uint64_t)v140, v142, v141);
                llvm::User::replaceUsesOfWith(*((llvm::User **)v194 + 43), v191, v140);
                uint64_t v147 = (llvm *)*((void *)v194 + 3);
                if (*((unsigned char *)v194 + 361)) {
                  uint64_t v147 = v145;
                }
                uint64_t v148 = (llvm *)*((void *)v147 + 5);
                if (v148 == (llvm *)((char *)v147 + 40))
                {
                  unsigned int v150 = 0;
                }
                else
                {
                  if (v148) {
                    int v149 = (unsigned __int8 *)v148 - 24;
                  }
                  else {
                    int v149 = 0;
                  }
                  if (v149[16] - 29 >= 0xB) {
                    unsigned int v150 = 0;
                  }
                  else {
                    unsigned int v150 = (llvm::User *)v149;
                  }
                }
                llvm::User::replaceUsesOfWith(v150, v142, (llvm::Value *)v19[5]);
                llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
              }
              while (1)
              {
                for (uint64_t i = *(void *)(*(void *)v70 + 48); i != *(void *)v70 + 40; uint64_t i = *(void *)(i + 8))
                {
                  uint64_t v73 = i - 24;
                  if (!i) {
                    uint64_t v73 = 0;
                  }
                  int v74 = *(_DWORD *)(v73 + 20);
                  if ((v74 & 0x40000000) != 0)
                  {
                    uint64_t v76 = *(void *)(v73 - 8);
                    uint64_t v75 = v74 & 0x7FFFFFF;
                    if (v75)
                    {
LABEL_106:
                      uint64_t v77 = v76 + 32 * v75;
                      while (1)
                      {
                        if (*(void *)v76 && *(unsigned __int8 *)(*(void *)v76 + 16) >= 0x1Cu)
                        {
                          uint64_t v79 = v14[9];
                          size_t v80 = *(llvm::DependenceInfo **)(*(void *)v76 + 40);
                          uint64_t v82 = *(void *)(v79 + 56);
                          uint64_t v81 = *(void *)(v79 + 64);
                          if (v81 == v82)
                          {
                            uint64_t v83 = *(unsigned int *)(v79 + 76);
                            uint64_t v84 = (llvm::DependenceInfo **)(v81 + 8 * v83);
                            if (v83)
                            {
                              uint64_t v85 = 0;
                              while (*(llvm::DependenceInfo **)(v81 + v85) != v80)
                              {
                                v85 += 8;
                                if (8 * v83 == v85) {
                                  goto LABEL_130;
                                }
                              }
                              uint64_t v84 = (llvm::DependenceInfo **)(v81 + v85);
                            }
LABEL_130:
                            uint64_t v82 = *(void *)(v79 + 64);
                          }
                          else
                          {
                            uint64_t v86 = *(unsigned int *)(v79 + 72);
                            int v87 = v86 - 1;
                            unsigned int v88 = (v86 - 1) & ((v80 >> 4) ^ (v80 >> 9));
                            uint64_t v84 = (llvm::DependenceInfo **)(v81 + 8 * v88);
                            uint64_t v49 = *v84;
                            if (*v84 == (llvm::DependenceInfo *)-1)
                            {
                              uint64_t v89 = 0;
LABEL_137:
                              if (v89) {
                                uint64_t v84 = v89;
                              }
                              if (*v84 != v80) {
                                uint64_t v84 = (llvm::DependenceInfo **)(v81 + 8 * v86);
                              }
                            }
                            else
                            {
                              uint64_t v89 = 0;
                              int v90 = 1;
                              while (v49 != v80)
                              {
                                if (v89) {
                                  BOOL v91 = 0;
                                }
                                else {
                                  BOOL v91 = v49 == (llvm::DependenceInfo *)-2;
                                }
                                if (v91) {
                                  uint64_t v89 = v84;
                                }
                                unsigned int v92 = v88 + v90++;
                                unsigned int v88 = v92 & v87;
                                uint64_t v84 = (llvm::DependenceInfo **)(v81 + 8 * (v92 & v87));
                                uint64_t v49 = *v84;
                                if (*v84 == (llvm::DependenceInfo *)-1) {
                                  goto LABEL_137;
                                }
                              }
                            }
                          }
                          BOOL v41 = v81 == v82;
                          uint64_t v93 = 72;
                          if (v41) {
                            uint64_t v93 = 76;
                          }
                          if (v84 != (llvm::DependenceInfo **)(v81 + 8 * *(unsigned int *)(v79 + v93))) {
                            break;
                          }
                        }
                        v76 += 32;
                        if (v76 == v77) {
                          goto LABEL_141;
                        }
                      }
LABEL_160:
                      uint64_t v5 = a1;
                      uint64_t v15 = v196;
LABEL_59:
                      uint64_t v42 = (void *)v19[1];
                      if (v42)
                      {
                        do
                        {
                          uint64_t v43 = v42;
                          uint64_t v42 = (void *)*v42;
                        }
                        while (v42);
                      }
                      else
                      {
                        do
                        {
                          uint64_t v43 = (void *)v19[2];
                          BOOL v41 = *v43 == (void)v19;
                          uint64_t v19 = v43;
                        }
                        while (!v41);
                      }
                      uint64_t v19 = v43;
                      if (v43 == v15)
                      {
                        uint64_t v16 = (void *)v14[1];
                        goto LABEL_237;
                      }
                      goto LABEL_22;
                    }
                  }
                  else
                  {
                    uint64_t v75 = v74 & 0x7FFFFFF;
                    uint64_t v76 = v73 - 32 * v75;
                    if (v75) {
                      goto LABEL_106;
                    }
                  }
LABEL_141:
                  ;
                }
                v70 += 8;
                if (v70 == v71) {
                  goto LABEL_143;
                }
              }
            }
LABEL_244:
            int v3 = v184;
            int v1 = v183;
            uint64_t v6 = v186;
          }
          v6 += 6;
        }
        while (v6 != (uint64_t **)v185);
        uint64_t v152 = *(void *)(v5 + 216);
        unsigned int v153 = *(_DWORD *)(v5 + 224);
        *(void *)&long long v199 = v200;
        *((void *)&v199 + 1) = 0x400000000;
        if (v153)
        {
          uint64_t v154 = v152 + 48 * v153;
          do
          {
            uint64_t v155 = *(unsigned int *)(v152 + 8);
            if (v155)
            {
              uint64_t v156 = *(uint64_t **)v152;
              uint64_t v157 = *(void *)v152 + 8 * v155;
              do
              {
                uint64_t v158 = *v156;
                uint64_t v160 = *(void *)(v5 + 112);
                uint64_t v159 = *(void *)(v5 + 120);
                if (v159 == v160)
                {
                  uint64_t v161 = *v1;
                  uint64_t v162 = (void *)(v159 + 8 * v161);
                  if (v161)
                  {
                    uint64_t v163 = 0;
                    uint64_t v164 = 8 * v161;
                    while (*(void *)(v159 + v163) != v158)
                    {
                      v163 += 8;
                      if (v164 == v163) {
                        goto LABEL_268;
                      }
                    }
                    uint64_t v162 = (void *)(v159 + v163);
                  }
LABEL_268:
                  uint64_t v160 = *(void *)(v5 + 120);
                }
                else
                {
                  uint64_t v165 = *v188;
                  int v166 = v165 - 1;
                  unsigned int v167 = (v165 - 1) & ((v158 >> 4) ^ (v158 >> 9));
                  uint64_t v162 = (void *)(v159 + 8 * v167);
                  uint64_t v168 = *v162;
                  if (*v162 == -1)
                  {
                    uint64_t v169 = 0;
LABEL_276:
                    if (v169) {
                      uint64_t v162 = v169;
                    }
                    if (*v162 != v158) {
                      uint64_t v162 = (void *)(v159 + 8 * v165);
                    }
                  }
                  else
                  {
                    uint64_t v169 = 0;
                    int v170 = 1;
                    while (v168 != v158)
                    {
                      if (v169) {
                        BOOL v171 = 0;
                      }
                      else {
                        BOOL v171 = v168 == -2;
                      }
                      if (v171) {
                        uint64_t v169 = v162;
                      }
                      unsigned int v172 = v167 + v170++;
                      unsigned int v167 = v172 & v166;
                      uint64_t v162 = (void *)(v159 + 8 * (v172 & v166));
                      uint64_t v168 = *v162;
                      if (*v162 == -1) {
                        goto LABEL_276;
                      }
                    }
                  }
                }
                BOOL v41 = v159 == v160;
                uint64_t v173 = v188;
                if (v41) {
                  uint64_t v173 = v1;
                }
                if (v162 == (void *)(v159 + 8 * *v173))
                {
                  int v174 = *(char **)(v158 + 8);
                  uint64_t v175 = *(char **)(v158 + 16);
                  if (v174 != v175)
                  {
                    v197[0] = v198;
                    v197[1] = (void *)0x400000000;
                    sub_1CBAACC38((uint64_t)v197, v174, v175);
                    sub_1CD770550((uint64_t)&v199, (uint64_t)v197);
                    if (v197[0] != v198) {
                      free(v197[0]);
                    }
                  }
                }
                ++v156;
              }
              while (v156 != (uint64_t *)v157);
            }
            v152 += 48;
          }
          while (v152 != v154);
        }
      }
      else
      {
        *(void *)&long long v199 = v200;
        *((void *)&v199 + 1) = 0x400000000;
      }
      sub_1CD770694((uint64_t)v182, (uint64_t)&v199);
      uint64_t v176 = *(void **)(v5 + 120);
      if (v176 != *(void **)(v5 + 112))
      {
        uint64_t v180 = *(unsigned int *)(v5 + 128);
        if (v180 >= 0x21 && 4 * (*(_DWORD *)(v5 + 132) - *(_DWORD *)(v5 + 136)) < v180)
        {
          llvm::SmallPtrSetImplBase::shrink_and_clear(v181);
          goto LABEL_285;
        }
        memset(v176, 255, 8 * v180);
      }
      *(void *)int v1 = 0;
LABEL_285:
      ++*(_DWORD *)(v5 + 208);
      sub_1CD48219C((char **)&v199);
      uint64_t v177 = *(unsigned int *)(v5 + 8);
      if (v177)
      {
        uint64_t v178 = *(void *)v5 - 16;
        uint64_t v179 = 24 * v177;
        do
        {
          sub_1CCDC0C58(*(void **)(v178 + v179));
          v179 -= 24;
        }
        while (v179);
      }
      *(_DWORD *)(v5 + 8) = 0;
      unsigned int v2 = *(_DWORD *)(v5 + 224);
      if (v2 == *(_DWORD *)(v5 + 132) - *(_DWORD *)(v5 + 136)) {
        return v3 & 1;
      }
    }
  }
  LOBYTE(v3) = 0;
  return v3 & 1;
}

char **sub_1CCDC01EC(char **a1)
{
  sub_1CC2930C0((uint64_t)(a1 + 53));
  sub_1CD48219C(a1 + 27);
  unsigned int v2 = a1[15];
  if (v2 != a1[14]) {
    free(v2);
  }
  int v3 = *a1;
  uint64_t v4 = *((unsigned int *)a1 + 2);
  if (v4)
  {
    uint64_t v5 = v3 - 16;
    uint64_t v6 = 24 * v4;
    do
    {
      sub_1CCDC0C58(*(void **)&v5[v6]);
      v6 -= 24;
    }
    while (v6);
    int v3 = *a1;
  }
  if (v3 != (char *)(a1 + 2)) {
    free(v3);
  }
  return a1;
}

void sub_1CCDC0274(llvm *a1)
{
  llvm::initializePostDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializeScalarEvolutionWrapperPassPass(a1, v2);
  llvm::initializeDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializeDependenceAnalysisWrapperPassPass(a1, v3);
  llvm::initializeLoopInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeOptimizationRemarkEmitterWrapperPassPass(a1, v4);
  llvm::initializeAssumptionCacheTrackerPass((uint64_t)a1);
  llvm::initializeTargetTransformInfoWrapperPassPass((uint64_t)a1);
  operator new();
}

void llvm::createLoopFusePass(llvm *this)
{
}

uint64_t sub_1CCDC0384(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF3EA0;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263EC30;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF3EA8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCDC0274;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCF3EA8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CCDC0434()
{
}

uint64_t *sub_1CCDC0914(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (uint64_t **)sub_1CCDC0AE0(a1, &v18);
  uint64_t v5 = *v4;
  if (!*v4)
  {
    uint64_t v6 = v4;
    int v7 = (uint64_t *)operator new(0x1A8uLL);
    uint64_t v5 = v7;
    v16[0] = v7;
    v16[1] = a1 + 8;
    long long v8 = *(_OWORD *)(a2 + 16);
    *((_OWORD *)v7 + 2) = *(_OWORD *)a2;
    *((_OWORD *)v7 + 3) = v8;
    *((_OWORD *)v7 + 4) = *(_OWORD *)(a2 + 32);
    v7[10] = (uint64_t)(v7 + 12);
    v7[11] = 0x1000000000;
    unsigned int v9 = *(_DWORD *)(a2 + 56);
    if (v9 && v7 + 4 != (uint64_t *)a2)
    {
      if (v9 >= 0x11) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v7 + 12, *(const void **)(a2 + 48), 8 * *(unsigned int *)(a2 + 56));
      *((_DWORD *)v5 + 22) = v9;
    }
    v5[28] = (uint64_t)(v5 + 30);
    v5[29] = 0x1000000000;
    unsigned int v10 = *(_DWORD *)(a2 + 200);
    if (v10 && v5 + 28 != (uint64_t *)(a2 + 192))
    {
      if (v10 >= 0x11) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v5 + 30, *(const void **)(a2 + 192), 8 * *(unsigned int *)(a2 + 200));
      *((_DWORD *)v5 + 58) = v10;
    }
    long long v11 = *(_OWORD *)(a2 + 352);
    *((_OWORD *)v5 + 23) = *(_OWORD *)(a2 + 336);
    *((_OWORD *)v5 + 24) = v11;
    *((_OWORD *)v5 + 25) = *(_OWORD *)(a2 + 368);
    v5[52] = *(void *)(a2 + 384);
    char v17 = 1;
    uint64_t v12 = v18;
    *uint64_t v5 = 0;
    v5[1] = 0;
    void v5[2] = v12;
    *uint64_t v6 = v5;
    uint64_t v13 = **(void **)a1;
    uint64_t v14 = v5;
    if (v13)
    {
      *(void *)a1 = v13;
      uint64_t v14 = *v6;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v14);
    ++*(void *)(a1 + 16);
    v16[0] = 0;
    sub_1CCDC0B74((uint64_t)v16);
  }
  return v5;
}

uint64_t sub_1CCDC0AE0(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 8)) {
    sub_1CCDC0BDC();
  }
  *a2 = a1 + 8;
  return a1 + 8;
}

uint64_t sub_1CCDC0B74(uint64_t a1)
{
  unsigned int v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      int v3 = (void *)v2[28];
      if (v3 != v2 + 30) {
        free(v3);
      }
      uint64_t v4 = (void *)v2[10];
      if (v4 != v2 + 12) {
        free(v4);
      }
    }
    operator delete(v2);
  }
  return a1;
}

void sub_1CCDC0BDC()
{
}

void sub_1CCDC0C58(void *a1)
{
  if (a1)
  {
    sub_1CCDC0C58(*a1);
    sub_1CCDC0C58(a1[1]);
    unsigned int v2 = (void *)a1[28];
    if (v2 != a1 + 30) {
      free(v2);
    }
    int v3 = (void *)a1[10];
    if (v3 != a1 + 12) {
      free(v3);
    }
    operator delete(a1);
  }
}

void sub_1CCDC0CCC(uint64_t **a1, uint64_t *a2)
{
  int v3 = (uint64_t *)a2[1];
  if (v3)
  {
    do
    {
      uint64_t v4 = v3;
      int v3 = (uint64_t *)*v3;
    }
    while (v3);
  }
  else
  {
    uint64_t v5 = a2;
    do
    {
      uint64_t v4 = (uint64_t *)v5[2];
      BOOL v6 = *v4 == (void)v5;
      uint64_t v5 = v4;
    }
    while (!v6);
  }
  if (*a1 == a2) {
    *a1 = v4;
  }
  int v7 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  sub_1CB91F7C8(v7, a2);
  long long v8 = (uint64_t *)a2[28];
  if (v8 != a2 + 30) {
    free(v8);
  }
  unsigned int v9 = (uint64_t *)a2[10];
  if (v9 != a2 + 12) {
    free(v9);
  }

  operator delete(a2);
}

uint64_t sub_1CCDC0D80(uint64_t a1, uint64_t a2, uint64_t a3, llvm::Instruction *a4, llvm::Instruction *a5, int a6)
{
  LODWORD(isKnownPredicate) = a6;
  v50[8] = *MEMORY[0x1E4F143B8];
  while (isKnownPredicate == 2)
  {
    uint64_t isKnownPredicate = 1;
    if (sub_1CCDC0D80(a1, a2, a3, a4, a5, 0)) {
      return isKnownPredicate;
    }
  }
  if (isKnownPredicate == 1)
  {
    llvm::DependenceInfo::depends(*(void *)(a1 + 880), a4, a5, 1, &v42);
    uint64_t v12 = v42;
    uint64_t isKnownPredicate = v42 == 0;
    if (v42)
    {
      uint64_t v42 = 0;
      (*(void (**)(char *))(*(void *)v12 + 8))(v12);
    }
  }
  else
  {
    if ((*((unsigned char *)a4 + 16) & 0xFE) == 0x3C) {
      uint64_t v13 = (llvm::Value *)*((void *)a4 - 4);
    }
    else {
      uint64_t v13 = 0;
    }
    if ((*((unsigned char *)a5 + 16) & 0xFE) == 0x3C)
    {
      uint64_t isKnownPredicate = 0;
      if (v13)
      {
        uint64_t v14 = (llvm::Value *)*((void *)a5 - 4);
        if (v14)
        {
          uint64_t v15 = *(const llvm::Loop **)(a2 + 40);
          uint64_t v16 = *(const llvm::Loop **)(a3 + 40);
          SCEVAtScope = llvm::ScalarEvolution::getSCEVAtScope(*(llvm::ScalarEvolution **)(a1 + 888), v13, v15);
          uint64_t v18 = llvm::ScalarEvolution::getSCEVAtScope(*(llvm::ScalarEvolution **)(a1 + 888), v14, v16);
          uint64_t v19 = *(void *)(a1 + 888);
          uint64_t v33 = 0;
          uint64_t v34 = 0;
          uint64_t v32 = v19;
          int v35 = 0;
          __int16 v36 = 257;
          size_t v37 = v15;
          uint64_t v38 = v16;
          uint64_t v20 = sub_1CCDC10D4((uint64_t)&v32, (uint64_t)SCEVAtScope);
          if (!(_BYTE)v36) {
            goto LABEL_38;
          }
          uint64_t v21 = (const llvm::SCEV *)v20;
          uint64_t v31 = **((void **)v15 + 4);
          char v39 = 0;
          uint64_t v40 = a1;
          BOOL v41 = &v31;
          uint64_t v42 = &v39;
          uint64_t v43 = v45;
          uint64_t v44 = 0x800000000;
          uint64_t v46 = v50;
          int v47 = v50;
          uint64_t v48 = 8;
          int v49 = 0;
          sub_1CCDC1B84((uint64_t)&v42, (uint64_t)v18);
          unsigned int v22 = v44;
          while (v22)
          {
            if (*v42) {
              break;
            }
            uint64_t v23 = *((void *)v43 + --v22);
            LODWORD(v44) = v22;
            switch(*(_WORD *)(v23 + 24))
            {
              case 1:
              case 2:
              case 3:
              case 0xD:
                uint64_t v29 = (uint64_t *)(v23 + 32);
                goto LABEL_27;
              case 4:
              case 5:
              case 7:
              case 8:
              case 9:
              case 0xA:
              case 0xB:
              case 0xC:
                uint64_t v24 = *(void *)(v23 + 40);
                if (v24)
                {
                  uint64_t v25 = *(uint64_t **)(v23 + 32);
                  uint64_t v26 = 8 * v24 - 8;
                  do
                  {
                    uint64_t v27 = *v25++;
                    sub_1CCDC1B84((uint64_t)&v42, v27);
                    if (*v42) {
                      BOOL v28 = 1;
                    }
                    else {
                      BOOL v28 = v26 == 0;
                    }
                    v26 -= 8;
                  }
                  while (!v28);
                }
                goto LABEL_28;
              case 6:
                sub_1CCDC1B84((uint64_t)&v42, *(void *)(v23 + 32));
                uint64_t v29 = (uint64_t *)(v23 + 40);
LABEL_27:
                sub_1CCDC1B84((uint64_t)&v42, *v29);
LABEL_28:
                unsigned int v22 = v44;
                break;
              default:
                break;
            }
          }
          if (v47 != v46) {
            free(v47);
          }
          if (v43 != v45) {
            free(v43);
          }
          if (!v39) {
            uint64_t isKnownPredicate = llvm::ScalarEvolution::isKnownPredicate(*(llvm::ScalarEvolution **)(a1 + 888), 0x27u, v21, v18);
          }
          else {
LABEL_38:
          }
            uint64_t isKnownPredicate = 0;
          MEMORY[0x1D25D9CD0](v33, 8);
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return isKnownPredicate;
}

uint64_t sub_1CCDC10D4(uint64_t a1, uint64_t a2)
{
  v104[3] = *MEMORY[0x1E4F143B8];
  uint64_t v98 = a2;
  uint64_t v5 = a1 + 8;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v6 = *(unsigned int *)(a1 + 24);
  if (v6)
  {
    LODWORD(v7) = (v6 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    long long v8 = (void *)(v4 + 16 * v7);
    uint64_t v9 = *v8;
    if (*v8 == a2) {
      goto LABEL_8;
    }
    int v10 = 1;
    while (v9 != -4096)
    {
      int v11 = v7 + v10++;
      uint64_t v7 = v11 & (v6 - 1);
      uint64_t v9 = *(void *)(v4 + 16 * v7);
      if (v9 == a2)
      {
        long long v8 = (void *)(v4 + 16 * v7);
        goto LABEL_8;
      }
    }
  }
  long long v8 = (void *)(v4 + 16 * v6);
LABEL_8:
  if (v8 == (void *)(v4 + 16 * v6))
  {
    uint64_t v12 = a2;
    switch(*(_WORD *)(a2 + 24))
    {
      case 1:
        uint64_t v13 = (const llvm::SCEV *)sub_1CCDC10D4(a1, *(void *)(a2 + 32));
        uint64_t v12 = a2;
        if (v13 != *(const llvm::SCEV **)(a2 + 32))
        {
          uint64_t TruncateExpr = llvm::ScalarEvolution::getTruncateExpr(*(llvm::ScalarEvolution **)a1, v13, *(llvm::Type **)(a2 + 40), 0);
          goto LABEL_73;
        }
        goto LABEL_108;
      case 2:
        uint64_t v29 = (llvm::detail::IEEEFloat **)sub_1CCDC10D4(a1, *(void *)(a2 + 32));
        uint64_t v12 = a2;
        if (v29 != *(llvm::detail::IEEEFloat ***)(a2 + 32))
        {
          uint64_t TruncateExpr = llvm::ScalarEvolution::getZeroExtendExpr(*(llvm::ScalarEvolution **)a1, v29, *(uint64_t ***)(a2 + 40), 0);
          goto LABEL_73;
        }
        goto LABEL_108;
      case 3:
        uint64_t v51 = (llvm::detail::IEEEFloat **)sub_1CCDC10D4(a1, *(void *)(a2 + 32));
        uint64_t v12 = a2;
        if (v51 != *(llvm::detail::IEEEFloat ***)(a2 + 32))
        {
          uint64_t TruncateExpr = llvm::ScalarEvolution::getSignExtendExpr(*(llvm::ScalarEvolution **)a1, v51, *(uint64_t ***)(a2 + 40), 0);
          goto LABEL_73;
        }
        goto LABEL_108;
      case 4:
        uint64_t v15 = v104;
        int v102 = v104;
        uint64_t v103 = 0x200000000;
        uint64_t v58 = *(void *)(a2 + 40);
        uint64_t v12 = a2;
        if (v58)
        {
          char v59 = 0;
          uint64_t v60 = *(void **)(a2 + 32);
          uint64_t v61 = 8 * v58;
          do
          {
            uint64_t v62 = *v60;
            uint64_t v63 = sub_1CCDC10D4(a1, *v60);
            if (v103 >= (unint64_t)HIDWORD(v103)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v102 + v103) = v63;
            LODWORD(v103) = v103 + 1;
            unsigned int v22 = v102;
            v59 |= v62 != *((void *)v102 + v103 - 1);
            ++v60;
            v61 -= 8;
          }
          while (v61);
          uint64_t v12 = a2;
          if (v59)
          {
            uint64_t AddExpr = llvm::ScalarEvolution::getAddExpr(*(void *)a1, (unint64_t **)&v102, 0, 0);
            goto LABEL_89;
          }
          goto LABEL_106;
        }
        goto LABEL_108;
      case 5:
        uint64_t v15 = v104;
        int v102 = v104;
        uint64_t v103 = 0x200000000;
        uint64_t v45 = *(void *)(a2 + 40);
        uint64_t v12 = a2;
        if (v45)
        {
          char v46 = 0;
          int v47 = *(void **)(a2 + 32);
          uint64_t v48 = 8 * v45;
          do
          {
            uint64_t v49 = *v47;
            uint64_t v50 = sub_1CCDC10D4(a1, *v47);
            if (v103 >= (unint64_t)HIDWORD(v103)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v102 + v103) = v50;
            LODWORD(v103) = v103 + 1;
            unsigned int v22 = v102;
            v46 |= v49 != *((void *)v102 + v103 - 1);
            ++v47;
            v48 -= 8;
          }
          while (v48);
          uint64_t v12 = a2;
          if (v46)
          {
            uint64_t AddExpr = llvm::ScalarEvolution::getMulExpr(*(void *)a1, (uint64_t)&v102, 0, 0);
            goto LABEL_89;
          }
          goto LABEL_106;
        }
        goto LABEL_108;
      case 6:
        uint64_t v70 = (const llvm::SCEV *)sub_1CCDC10D4(a1, *(void *)(a2 + 32));
        unint64_t v71 = sub_1CCDC10D4(a1, *(void *)(a2 + 40));
        if (v70 != *(const llvm::SCEV **)(a2 + 32) || (uint64_t v12 = a2, v71 != *(void *)(a2 + 40)))
        {
          uint64_t TruncateExpr = llvm::ScalarEvolution::getUDivExpr(*(llvm::ScalarEvolution **)a1, v70, v71);
          goto LABEL_73;
        }
        goto LABEL_108;
      case 7:
        __int16 v36 = *(void **)(a2 + 48);
        uint64_t v15 = v101;
        int v99 = v101;
        uint64_t v100 = 0x200000000;
        size_t v37 = *(void **)(a1 + 40);
        if (v36 == v37)
        {
          unint64_t v75 = *(void *)(a2 + 40);
          if (v75 >= 3) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          if (v75)
          {
            memcpy(v101, *(const void **)(a2 + 32), 8 * v75);
            int v83 = v100;
          }
          else
          {
            int v83 = 0;
          }
          LODWORD(v100) = v83 + v75;
          size_t v80 = *(llvm::ScalarEvolution **)a1;
          uint64_t v82 = *(const llvm::Loop **)(a1 + 48);
          uint64_t v81 = *(_WORD *)(a2 + 28) & 7;
        }
        else
        {
          uint64_t v38 = v36;
          while (v38)
          {
            uint64_t v38 = (void *)*v38;
            if (v38 == v37)
            {
              char v39 = *(llvm::ScalarEvolution **)a1;
              uint64_t v40 = *(void *)(a2 + 40);
              if (v40 == 2)
              {
                BOOL v41 = *(const llvm::SCEV **)(*(void *)(a2 + 32) + 8);
              }
              else
              {
                uint64_t v95 = *(void *)(a2 + 32);
                int v102 = v104;
                uint64_t v103 = 0x300000000;
                unint64_t v96 = 8 * v40 - 8;
                if (v96 >= 0x19) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                int v97 = 0;
                if (v40 != 1)
                {
                  memcpy(v102, (const void *)(v95 + 8), 8 * v40 - 8);
                  int v97 = v103;
                }
                LODWORD(v103) = v97 + (v96 >> 3);
                BOOL v41 = (const llvm::SCEV *)sub_1CD478318(v39, (uint64_t)&v102, *(const llvm::Loop **)(a2 + 48), 0);
                if (v102 != v104) {
                  free(v102);
                }
              }
              BOOL isKnownPositive = llvm::ScalarEvolution::isKnownPositive(v39, v41);
              if (*(unsigned char *)(a1 + 33) && isKnownPositive && *(void *)(a2 + 40) == 2)
              {
                uint64_t AddRecExpr = sub_1CCDC10D4(a1, **(void **)(a2 + 32));
                goto LABEL_104;
              }
              *(unsigned char *)(a1 + 32) = 0;
              uint64_t v12 = a2;
LABEL_105:
              unsigned int v22 = v99;
              goto LABEL_106;
            }
          }
          uint64_t v76 = *(void *)(a2 + 40);
          if (v76)
          {
            uint64_t v77 = *(void **)(a2 + 32);
            uint64_t v78 = 8 * v76;
            do
            {
              uint64_t v79 = sub_1CCDC10D4(a1, *v77);
              if (v100 >= (unint64_t)HIDWORD(v100)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v99 + v100) = v79;
              LODWORD(v100) = v100 + 1;
              ++v77;
              v78 -= 8;
            }
            while (v78);
          }
          size_t v80 = *(llvm::ScalarEvolution **)a1;
          uint64_t v81 = *(_WORD *)(a2 + 28) & 7;
          uint64_t v82 = (const llvm::Loop *)v36;
        }
        uint64_t AddRecExpr = llvm::ScalarEvolution::getAddRecExpr(v80, (uint64_t **)&v99, v82, v81);
LABEL_104:
        uint64_t v12 = AddRecExpr;
        goto LABEL_105;
      case 8:
        uint64_t v15 = v104;
        int v102 = v104;
        uint64_t v103 = 0x200000000;
        uint64_t v64 = *(void *)(a2 + 40);
        uint64_t v12 = a2;
        if (!v64) {
          goto LABEL_108;
        }
        char v65 = 0;
        uint64_t v66 = *(void **)(a2 + 32);
        uint64_t v67 = 8 * v64;
        do
        {
          uint64_t v68 = *v66;
          uint64_t v69 = sub_1CCDC10D4(a1, *v66);
          if (v103 >= (unint64_t)HIDWORD(v103)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v102 + v103) = v69;
          LODWORD(v103) = v103 + 1;
          unsigned int v22 = v102;
          v65 |= v68 != *((void *)v102 + v103 - 1);
          ++v66;
          v67 -= 8;
        }
        while (v67);
        uint64_t v12 = a2;
        if ((v65 & 1) == 0) {
          goto LABEL_106;
        }
        uint64_t v73 = *(llvm::ScalarEvolution **)a1;
        uint64_t v74 = 8;
        goto LABEL_88;
      case 9:
        uint64_t v15 = v104;
        int v102 = v104;
        uint64_t v103 = 0x200000000;
        uint64_t v23 = *(void *)(a2 + 40);
        uint64_t v12 = a2;
        if (!v23) {
          goto LABEL_108;
        }
        char v24 = 0;
        uint64_t v25 = *(void **)(a2 + 32);
        uint64_t v26 = 8 * v23;
        do
        {
          uint64_t v27 = *v25;
          uint64_t v28 = sub_1CCDC10D4(a1, *v25);
          if (v103 >= (unint64_t)HIDWORD(v103)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v102 + v103) = v28;
          LODWORD(v103) = v103 + 1;
          unsigned int v22 = v102;
          v24 |= v27 != *((void *)v102 + v103 - 1);
          ++v25;
          v26 -= 8;
        }
        while (v26);
        uint64_t v12 = a2;
        if ((v24 & 1) == 0) {
          goto LABEL_106;
        }
        uint64_t v73 = *(llvm::ScalarEvolution **)a1;
        uint64_t v74 = 9;
        goto LABEL_88;
      case 0xA:
        uint64_t v15 = v104;
        int v102 = v104;
        uint64_t v103 = 0x200000000;
        uint64_t v30 = *(void *)(a2 + 40);
        uint64_t v12 = a2;
        if (!v30) {
          goto LABEL_108;
        }
        char v31 = 0;
        uint64_t v32 = *(void **)(a2 + 32);
        uint64_t v33 = 8 * v30;
        do
        {
          uint64_t v34 = *v32;
          uint64_t v35 = sub_1CCDC10D4(a1, *v32);
          if (v103 >= (unint64_t)HIDWORD(v103)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v102 + v103) = v35;
          LODWORD(v103) = v103 + 1;
          unsigned int v22 = v102;
          v31 |= v34 != *((void *)v102 + v103 - 1);
          ++v32;
          v33 -= 8;
        }
        while (v33);
        uint64_t v12 = a2;
        if ((v31 & 1) == 0) {
          goto LABEL_106;
        }
        uint64_t v73 = *(llvm::ScalarEvolution **)a1;
        uint64_t v74 = 10;
        goto LABEL_88;
      case 0xB:
        uint64_t v15 = v104;
        int v102 = v104;
        uint64_t v103 = 0x200000000;
        uint64_t v52 = *(void *)(a2 + 40);
        uint64_t v12 = a2;
        if (!v52) {
          goto LABEL_108;
        }
        char v53 = 0;
        uint64_t v54 = *(void **)(a2 + 32);
        uint64_t v55 = 8 * v52;
        do
        {
          uint64_t v56 = *v54;
          uint64_t v57 = sub_1CCDC10D4(a1, *v54);
          if (v103 >= (unint64_t)HIDWORD(v103)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v102 + v103) = v57;
          LODWORD(v103) = v103 + 1;
          unsigned int v22 = v102;
          v53 |= v56 != *((void *)v102 + v103 - 1);
          ++v54;
          v55 -= 8;
        }
        while (v55);
        uint64_t v12 = a2;
        if ((v53 & 1) == 0) {
          goto LABEL_106;
        }
        uint64_t v73 = *(llvm::ScalarEvolution **)a1;
        uint64_t v74 = 11;
LABEL_88:
        uint64_t AddExpr = llvm::ScalarEvolution::getMinMaxExpr((uint64_t)v73, v74, (uint64_t **)&v102);
        goto LABEL_89;
      case 0xC:
        uint64_t v15 = v104;
        int v102 = v104;
        uint64_t v103 = 0x200000000;
        uint64_t v16 = *(void *)(a2 + 40);
        uint64_t v12 = a2;
        if (!v16) {
          goto LABEL_108;
        }
        char v17 = 0;
        uint64_t v18 = *(void **)(a2 + 32);
        uint64_t v19 = 8 * v16;
        do
        {
          uint64_t v20 = *v18;
          uint64_t v21 = sub_1CCDC10D4(a1, *v18);
          if (v103 >= (unint64_t)HIDWORD(v103)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v102 + v103) = v21;
          LODWORD(v103) = v103 + 1;
          unsigned int v22 = v102;
          v17 |= v20 != *((void *)v102 + v103 - 1);
          ++v18;
          v19 -= 8;
        }
        while (v19);
        uint64_t v12 = a2;
        if ((v17 & 1) == 0) {
          goto LABEL_106;
        }
        uint64_t AddExpr = llvm::ScalarEvolution::getSequentialMinMaxExpr(*(void *)a1, 12, (unsigned int *)&v102);
LABEL_89:
        uint64_t v12 = AddExpr;
        unsigned int v22 = v102;
LABEL_106:
        if (v22 != v15) {
          free(v22);
        }
LABEL_108:
        int v84 = *(_DWORD *)(a1 + 24);
        if (v84)
        {
          uint64_t v85 = *(void *)(a1 + 8);
          int v86 = v84 - 1;
          unsigned int v87 = v86 & ((a2 >> 4) ^ (a2 >> 9));
          long long v8 = (void *)(v85 + 16 * v87);
          uint64_t v88 = *v8;
          if (*v8 == a2) {
            return v8[1];
          }
          uint64_t v89 = 0;
          int v90 = 1;
          while (v88 != -4096)
          {
            if (v89) {
              BOOL v91 = 0;
            }
            else {
              BOOL v91 = v88 == -8192;
            }
            if (v91) {
              uint64_t v89 = v8;
            }
            unsigned int v92 = v87 + v90++;
            unsigned int v87 = v92 & v86;
            long long v8 = (void *)(v85 + 16 * v87);
            uint64_t v88 = *v8;
            if (*v8 == a2) {
              return v8[1];
            }
          }
          if (v89) {
            uint64_t v93 = v89;
          }
          else {
            uint64_t v93 = v8;
          }
        }
        else
        {
          uint64_t v93 = 0;
        }
        long long v8 = sub_1CC131DD4(v5, (uint64_t)&v98, &v98, v93);
        void *v8 = v98;
        v8[1] = v12;
        return v8[1];
      case 0xD:
        uint64_t v44 = (const llvm::SCEV *)sub_1CCDC10D4(a1, *(void *)(a2 + 32));
        uint64_t v12 = a2;
        if (v44 != *(const llvm::SCEV **)(a2 + 32))
        {
          uint64_t TruncateExpr = (uint64_t)llvm::ScalarEvolution::getPtrToIntExpr(*(llvm::ScalarEvolution **)a1, v44, *(llvm::Type **)(a2 + 40));
LABEL_73:
          uint64_t v12 = TruncateExpr;
        }
        goto LABEL_108;
      default:
        goto LABEL_108;
    }
  }
  return v8[1];
}

void sub_1CCDC1B84(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *(void **)(a1 + 88);
  uint64_t v5 = *(void **)(a1 + 96);
  uint64_t v4 = (unsigned int *)(a1 + 88);
  uint64_t v7 = v4[5];
  if (v5 == v6)
  {
    if (v7)
    {
      long long v8 = 0;
      uint64_t v9 = 8 * v7;
      int v10 = v5;
      while (*v10 != a2)
      {
        if (*v10 == -2) {
          long long v8 = v10;
        }
        ++v10;
        v9 -= 8;
        if (!v9)
        {
          if (!v8) {
            goto LABEL_9;
          }
          void *v8 = a2;
          --*(_DWORD *)(a1 + 112);
          if (a2) {
            goto LABEL_34;
          }
          goto LABEL_36;
        }
      }
      return;
    }
LABEL_9:
    unsigned int v11 = *(_DWORD *)(a1 + 104);
    if (v7 < v11)
    {
      *(_DWORD *)(a1 + 108) = v7 + 1;
      v5[v7] = a2;
      if (!a2)
      {
LABEL_36:
        unsigned int v21 = *(_DWORD *)(a1 + 16);
        if (v21 >= *(_DWORD *)(a1 + 20)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 8) + 8 * v21) = a2;
        ++*(_DWORD *)(a1 + 16);
        return;
      }
LABEL_34:
      if (*(_WORD *)(a2 + 24) == 7) {
        llvm::DominatorTreeBase<llvm::BasicBlock,false>::dominates();
      }
      goto LABEL_36;
    }
  }
  else
  {
    unsigned int v11 = *(_DWORD *)(a1 + 104);
  }
  if (3 * v11 <= 4 * ((int)v7 - *(_DWORD *)(a1 + 112)))
  {
    if (v11 >= 0x40) {
      v11 *= 2;
    }
    else {
      unsigned int v11 = 128;
    }
  }
  else if (v11 - v7 >= v11 >> 3)
  {
    goto LABEL_15;
  }
  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v4, v11);
  unsigned int v11 = *(_DWORD *)(a1 + 104);
  uint64_t v5 = *(void **)(a1 + 96);
LABEL_15:
  unsigned int v12 = v11 - 1;
  unsigned int v13 = (v11 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v14 = &v5[v13];
  uint64_t v15 = *v14;
  if (*v14 != -1)
  {
    uint64_t v16 = 0;
    int v17 = 1;
    while (v15 != a2)
    {
      if (v16) {
        BOOL v18 = 0;
      }
      else {
        BOOL v18 = v15 == -2;
      }
      if (v18) {
        uint64_t v16 = v14;
      }
      unsigned int v19 = v13 + v17++;
      unsigned int v13 = v19 & v12;
      uint64_t v14 = &v5[v19 & v12];
      uint64_t v15 = *v14;
      if (*v14 == -1) {
        goto LABEL_27;
      }
    }
    return;
  }
  uint64_t v16 = 0;
LABEL_27:
  if (v16) {
    uint64_t v20 = v16;
  }
  else {
    uint64_t v20 = v14;
  }
  if (*v20 != a2)
  {
    if (*v20 == -2) {
      --*(_DWORD *)(a1 + 112);
    }
    else {
      ++*(_DWORD *)(a1 + 108);
    }
    *uint64_t v20 = a2;
    if (!a2) {
      goto LABEL_36;
    }
    goto LABEL_34;
  }
}

uint64_t sub_1CCDC1DAC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t result = a1 + 40;
  uint64_t v2 = v3;
  if (v3 != result)
  {
    uint64_t v4 = v2 ? v2 - 24 : 0;
    unsigned int v5 = *(unsigned __int8 *)(v4 + 16) - 40;
    uint64_t v6 = v5 >= 0xFFFFFFF5 ? v4 : 0;
    if (v2)
    {
      if (*(unsigned char *)(v6 + 16) == 30 && v5 >= 0xFFFFFFF5)
      {
        uint64_t v8 = *(void *)(v6 - 32);
        uint64_t v9 = (char *)operator new(0x60uLL);
        *((_DWORD *)v9 + 13) = *((_DWORD *)v9 + 13) & 0x38000000 | 1;
        *(void *)uint64_t v9 = 0;
        *((void *)v9 + 2) = 0;
        *((void *)v9 + 1) = 0;
        *((void *)v9 + 4) = ***(void ***)v8 + 1576;
        *((void *)v9 + 3) = v9 + 32;
        *((void *)v9 + 5) = 0;
        v9[48] = 30;
        v9[49] = 0;
        *((_WORD *)v9 + 25) = 0;
        *((_DWORD *)v9 + 13) = 1;
        *(_OWORD *)(v9 + 56) = 0u;
        *(_OWORD *)(v9 + 72) = 0u;
        *((_DWORD *)v9 + 22) = 0;
        int v10 = (void *)(v8 + 8);
        uint64_t v11 = *(void *)(v8 + 8);
        *(void *)uint64_t v9 = v8;
        *((void *)v9 + 1) = v11;
        if (v11) {
          *(void *)(v11 + 16) = v9 + 8;
        }
        *((void *)v9 + 2) = v10;
        *int v10 = v9;
        unsigned int v12 = (uint64_t *)(v6 + 24);
        llvm::ReplaceInstWithInst(*(void *)(v6 + 40) + 40, &v12, (llvm::Value *)(v9 + 32));
      }
    }
  }
  return result;
}

llvm *sub_1CCDC1EB8(llvm::DomTreeUpdater **a1, uint64_t a2, llvm::BasicBlock *a3, uint64_t a4, uint64_t a5, llvm::DependenceInfo *a6)
{
  llvm::moveInstructionsToTheBeginning(*(llvm **)(a2 + 32), a3, a1[109], a1[112], a1[110], a6);
  uint64_t result = (llvm *)llvm::BasicBlock::getUniqueSuccessor(*(llvm::BasicBlock **)(a2 + 32));
  if (result)
  {
    llvm::MergeBlockIntoPredecessor(result, (unint64_t)(a1 + 53), a1[108], 0, 0, 0);
    return (llvm *)llvm::DomTreeUpdater::flush((llvm::DomTreeUpdater *)(a1 + 53));
  }
  return result;
}

void sub_1CCDC1F40()
{
}

void sub_1CCDC1F80(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCDC1FB8(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)&unk_1EA61F34C);
  sub_1CB843600(a2, a2, (uint64_t)llvm::ScalarEvolutionWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::PostDominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::OptimizationRemarkEmitterWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DependenceAnalysisWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::AssumptionCacheTracker::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)llvm::ScalarEvolutionWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);

  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::PostDominatorTreeWrapperPass::ID);
}

uint64_t sub_1CCDC20F8(llvm::FunctionPass *a1, llvm::LLVMContextImpl ****a2)
{
  v61[63] = *MEMORY[0x1E4F143B8];
  if (llvm::FunctionPass::skipFunction(a1, a2)) {
    return 0;
  }
  uint64_t v6 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v7 = *v6;
  uint64_t v8 = v6[1];
  if (v7 == v8)
  {
LABEL_7:
    uint64_t v9 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v7 != &llvm::LoopInfoWrapperPass::ID)
    {
      v7 += 16;
      if (v7 == v8) {
        goto LABEL_7;
      }
    }
    uint64_t v9 = *(void *)(v7 + 8);
  }
  uint64_t v10 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v9 + 96))(v9, &llvm::LoopInfoWrapperPass::ID);
  uint64_t v11 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v12 = *v11;
  uint64_t v13 = v11[1];
  if (v12 == v13)
  {
LABEL_12:
    uint64_t v14 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v12 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v12 += 16;
      if (v12 == v13) {
        goto LABEL_12;
      }
    }
    uint64_t v14 = *(void *)(v12 + 8);
  }
  uint64_t v15 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v14 + 96))(v14, &llvm::DominatorTreeWrapperPass::ID);
  uint64_t v16 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v17 = *v16;
  uint64_t v18 = v16[1];
  if (v17 == v18)
  {
LABEL_17:
    uint64_t v19 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v17 != &llvm::DependenceAnalysisWrapperPass::ID)
    {
      v17 += 16;
      if (v17 == v18) {
        goto LABEL_17;
      }
    }
    uint64_t v19 = *(void *)(v17 + 8);
  }
  uint64_t v20 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v19 + 96))(v19, &llvm::DependenceAnalysisWrapperPass::ID);
  unsigned int v21 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v22 = *v21;
  uint64_t v23 = v21[1];
  if (v22 == v23)
  {
LABEL_22:
    uint64_t v24 = 0;
  }
  else
  {
    while (*(char **)v22 != llvm::ScalarEvolutionWrapperPass::ID)
    {
      v22 += 16;
      if (v22 == v23) {
        goto LABEL_22;
      }
    }
    uint64_t v24 = *(void *)(v22 + 8);
  }
  uint64_t v25 = *(void *)(v20 + 32);
  uint64_t v26 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v24 + 96))(v24, llvm::ScalarEvolutionWrapperPass::ID);
  uint64_t v27 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v28 = *v27;
  uint64_t v29 = v27[1];
  if (v28 == v29)
  {
LABEL_27:
    uint64_t v30 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v28 != &llvm::PostDominatorTreeWrapperPass::ID)
    {
      v28 += 16;
      if (v28 == v29) {
        goto LABEL_27;
      }
    }
    uint64_t v30 = *(void *)(v28 + 8);
  }
  uint64_t v31 = *(void *)(v26 + 32);
  uint64_t v32 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v30 + 96))(v30, &llvm::PostDominatorTreeWrapperPass::ID);
  uint64_t v33 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v34 = *v33;
  uint64_t v35 = v33[1];
  if (v34 == v35)
  {
LABEL_32:
    uint64_t v36 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v34 != &llvm::OptimizationRemarkEmitterWrapperPass::ID)
    {
      v34 += 16;
      if (v34 == v35) {
        goto LABEL_32;
      }
    }
    uint64_t v36 = *(void *)(v34 + 8);
  }
  uint64_t v37 = v10 + 32;
  uint64_t v38 = v15 + 32;
  uint64_t v39 = v32 + 32;
  uint64_t v40 = *(void *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v36 + 96))(v36, &llvm::OptimizationRemarkEmitterWrapperPass::ID)+ 32);
  BOOL v41 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v42 = *v41;
  uint64_t v43 = v41[1];
  if (v42 == v43)
  {
LABEL_37:
    uint64_t v44 = 0;
  }
  else
  {
    while (*(char **)v42 != llvm::AssumptionCacheTracker::ID)
    {
      v42 += 16;
      if (v42 == v43) {
        goto LABEL_37;
      }
    }
    uint64_t v44 = *(void *)(v42 + 8);
  }
  uint64_t v45 = (llvm::AssumptionCacheTracker *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v44 + 96))(v44, llvm::AssumptionCacheTracker::ID);
  uint64_t AssumptionCache = llvm::AssumptionCacheTracker::getAssumptionCache(v45, (llvm::Function *)a2);
  int v47 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v48 = *v47;
  uint64_t v49 = v47[1];
  if (v48 == v49)
  {
LABEL_42:
    uint64_t v50 = 0;
  }
  else
  {
    while (*(char **)v48 != llvm::TargetTransformInfoWrapperPass::ID)
    {
      v48 += 16;
      if (v48 == v49) {
        goto LABEL_42;
      }
    }
    uint64_t v50 = *(void *)(v48 + 8);
  }
  uint64_t v51 = (llvm::TargetTransformInfoWrapperPass *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v50 + 96))(v50, llvm::TargetTransformInfoWrapperPass::ID);
  TTI = llvm::TargetTransformInfoWrapperPass::getTTI(v51, (const Function *)a2);
  sub_1CCDBBD98((uint64_t)&v56, v37, v38, v25, v31, v39, v40, AssumptionCache, (uint64_t)TTI);
  uint64_t v4 = sub_1CCDBBF3C((uint64_t)&v56);
  sub_1CC2930C0((uint64_t)v61);
  sub_1CD48219C(&v60);
  if (v59 != (void *)v58[12]) {
    free(v59);
  }
  char v53 = v56;
  if (v57)
  {
    uint64_t v54 = (char *)v56 - 16;
    uint64_t v55 = 24 * v57;
    do
    {
      sub_1CCDC0C58(*(void **)&v54[v55]);
      v55 -= 24;
    }
    while (v55);
    char v53 = v56;
  }
  if (v53 != v58) {
    free(v53);
  }
  return v4;
}

uint64_t sub_1CCDC259C()
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v4 = "Which dependence analysis should loop fusion use?";
  *((void *)&v4 + 1) = 49;
  *(void *)&long long v6 = v7;
  v7[0] = "scev";
  v7[1] = 4;
  int v8 = 0;
  uint64_t v9 = "Use the scalar evolution interface";
  uint64_t v10 = 34;
  uint64_t v11 = "da";
  uint64_t v12 = 2;
  int v13 = 1;
  uint64_t v14 = "Use the dependence analysis interface";
  uint64_t v15 = 37;
  uint64_t v16 = "all";
  uint64_t v17 = 3;
  int v18 = 2;
  uint64_t v19 = "Use all available analyses";
  uint64_t v20 = 26;
  *((void *)&v6 + 1) = 0x400000003;
  int v5 = 1;
  int v1 = 1;
  int v2 = 2;
  uint64_t v3 = &v2;
  sub_1CD770850(&v4, (uint64_t)&v6, &v5, &v3, &v1);
  if ((void *)v6 != v7) {
    free((void *)v6);
  }
  __cxa_atexit((void (*)(void *))sub_1CD76FF04, &qword_1EBCF3F70, &dword_1CB82C000);
  LODWORD(v3) = 0;
  *(void *)&long long v4 = &v3;
  int v5 = 1;
  *(void *)&long long v6 = "Max number of iterations to be peeled from a loop, such that fusion can take place";
  *((void *)&v6 + 1) = 82;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF3EB0, "loop-fusion-peel-max-count", (int **)&v4, &v5, &v6);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF3EB0, &dword_1CB82C000);
}

uint64_t sub_1CCDC2750(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = a2;
  *(void *)(result + 16) = a3;
  *(void *)(result + 24) = a4;
  *(void *)(result + 32) = a5;
  *(void *)(result + 40) = a6;
  *(void *)(result + 48) = a7;
  *(void *)(result + 56) = a9;
  *(void *)(result + 64) = a10;
  *(void *)(result + 80) = 0;
  *(void *)(result + 88) = 0;
  *(void *)(result + 96) = 0;
  *(_DWORD *)(result + 104) = 0;
  *(_OWORD *)(result + 112) = 0u;
  *(_OWORD *)(result + 128) = 0u;
  *(_OWORD *)(result + 140) = 0u;
  *(void *)(result + 160) = 0;
  *(void *)(result + 168) = 0;
  *(void *)(result + 176) = 0;
  *(void *)(result + 184) = result + 200;
  *(void *)(result + 192) = 0x800000000;
  if (a8) {
    operator new();
  }
  return result;
}

void sub_1CCDC289C(void *a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *a1 = a2;
  llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopPredecessor();
}

void *sub_1CCDC4CF0(void *a1)
{
  uint64_t v2 = (void *)a1[23];
  if (v2 != a1 + 25) {
    free(v2);
  }
  sub_1CD719F1C((uint64_t)(a1 + 17));
  sub_1CD719F1C((uint64_t)(a1 + 11));
  uint64_t v3 = a1[10];
  a1[10] = 0;
  if (v3)
  {
    sub_1CD3C5048(v3 + 584, *(void **)(v3 + 592));
    long long v4 = *(void **)(v3 + 504);
    if (v4 != (void *)(v3 + 520)) {
      free(v4);
    }
    int v5 = *(void **)(v3 + 416);
    if (v5 != *(void **)(v3 + 408)) {
      free(v5);
    }
    sub_1CC0BD0FC((char **)(v3 + 8));
    MEMORY[0x1D25D9CE0](v3, 0x10E0C40B8556DDDLL);
  }
  return a1;
}

void sub_1CCDC4D9C(llvm *a1, llvm::PassRegistry *a2)
{
}

uint64_t sub_1CCDC4E4C(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF41C8;
  *(_DWORD *)(a1 + 24) = 1;
  *(void *)a1 = &unk_1F263ED18;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF41D0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCDC4D9C;
    v5[1] = &PassRegistry;
    long long v4 = v5;
    std::__call_once(&qword_1EBCF41D0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CCDC4EFC()
{
}

void sub_1CCDC4F3C(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCDC4F74(uint64_t a1, llvm *a2)
{
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::TargetLibraryInfoWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::MemorySSAWrapperPass::ID);

  llvm::getLoopAnalysisUsage(a2, v3);
}

uint64_t sub_1CCDC4FE0(llvm::LoopPass *a1, const llvm::Loop *a2)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if (!llvm::DisableLIRP::All && (llvm::LoopPass::skipLoop(a1, a2) & 1) == 0)
  {
    int v5 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v6 = *v5;
    uint64_t v7 = v5[1];
    if (v6 == v7)
    {
LABEL_7:
      uint64_t v8 = 0;
    }
    else
    {
      while (*(char **)v6 != llvm::AAResultsWrapperPass::ID)
      {
        v6 += 16;
        if (v6 == v7) {
          goto LABEL_7;
        }
      }
      uint64_t v8 = *(void *)(v6 + 8);
    }
    (*(void (**)(uint64_t, char *))(*(void *)v8 + 96))(v8, llvm::AAResultsWrapperPass::ID);
    uint64_t v9 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v10 = *v9;
    uint64_t v11 = v9[1];
    if (v10 == v11)
    {
LABEL_12:
      uint64_t v12 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v10 != &llvm::DominatorTreeWrapperPass::ID)
      {
        v10 += 16;
        if (v10 == v11) {
          goto LABEL_12;
        }
      }
      uint64_t v12 = *(void *)(v10 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v12 + 96))(v12, &llvm::DominatorTreeWrapperPass::ID);
    int v13 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v14 = *v13;
    uint64_t v15 = v13[1];
    if (v14 == v15)
    {
LABEL_17:
      uint64_t v16 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v14 != &llvm::LoopInfoWrapperPass::ID)
      {
        v14 += 16;
        if (v14 == v15) {
          goto LABEL_17;
        }
      }
      uint64_t v16 = *(void *)(v14 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v16 + 96))(v16, &llvm::LoopInfoWrapperPass::ID);
    uint64_t v17 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v18 = *v17;
    uint64_t v19 = v17[1];
    if (v18 == v19)
    {
LABEL_22:
      uint64_t v20 = 0;
    }
    else
    {
      while (*(char **)v18 != llvm::ScalarEvolutionWrapperPass::ID)
      {
        v18 += 16;
        if (v18 == v19) {
          goto LABEL_22;
        }
      }
      uint64_t v20 = *(void *)(v18 + 8);
    }
    (*(void (**)(uint64_t, char *))(*(void *)v20 + 96))(v20, llvm::ScalarEvolutionWrapperPass::ID);
    uint64_t v21 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v22 = *v21;
    uint64_t v23 = v21[1];
    if (v22 == v23)
    {
LABEL_27:
      uint64_t v24 = 0;
    }
    else
    {
      while (*(char **)v22 != llvm::TargetLibraryInfoWrapperPass::ID)
      {
        v22 += 16;
        if (v22 == v23) {
          goto LABEL_27;
        }
      }
      uint64_t v24 = *(void *)(v22 + 8);
    }
    uint64_t v25 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v24 + 96))(v24, llvm::TargetLibraryInfoWrapperPass::ID);
    uint64_t v26 = v25 + 32;
    if (!*(unsigned char *)(v25 + 232))
    {
      uint64_t v27 = *(void *)(*(void *)(**((void **)a2 + 4) + 56) + 40) + 216;
      __int16 v30 = 260;
      v29[0] = v27;
      llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v29);
      uint64_t v40 = 0;
      uint64_t v41 = 0;
      int v42 = 0;
      long long v43 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      *(void *)&long long v28 = -1;
      *((void *)&v28 + 1) = -1;
      *(_OWORD *)__src = v28;
      long long v34 = v28;
      long long v35 = v28;
      long long v36 = v28;
      long long v37 = v28;
      long long v38 = v28;
      *(_OWORD *)uint64_t v39 = v28;
      *(void *)&v39[13] = -1;
      sub_1CC153974((uint64_t)__src, (int *)__p);
      sub_1CD4D04B8(v26, (uint64_t)__src);
      sub_1CD4CFA4C((uint64_t *)__src);
      if (v32 < 0) {
        operator delete(__p[0]);
      }
    }
    sub_1CC1569E8(__src, v26);
  }
  return 0;
}

void sub_1CCDC56CC(uint64_t a1)
{
  uint64_t v1 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned int (**)(void, uint64_t))(***(void ***)(a1 + 48) + 608))(**(void **)(a1 + 48), 32) == 2)llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getNumBackEdges(); {
  llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getNumBackEdges();
  }
}

uint64_t sub_1CCDCC270(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  v203[9] = *MEMORY[0x1E4F143B8];
  v195[0] = 0;
  v195[1] = 0;
  int v196 = 0;
  uint64_t v198 = 0;
  uint64_t v199 = 0;
  uint64_t v197 = 0;
  v190[0] = 0;
  v190[1] = 0;
  int v191 = 0;
  uint64_t v193 = 0;
  uint64_t v194 = 0;
  uint64_t v192 = 0;
  uint64_t v4 = 1;
  v203[0] = 1;
  do
  {
    v203[v4] = -4096;
    v4 += 2;
  }
  while (v4 != 9);
  uint64_t v200 = v202;
  uint64_t v201 = 0x1000000000;
  unint64_t v5 = *(unsigned int *)(a2 + 8);
  if (!v5) {
    goto LABEL_262;
  }
  uint64_t v6 = 0;
  int v7 = -1;
  unint64_t v166 = *(unsigned int *)(a2 + 8);
  do
  {
    uint64_t v8 = *(void *)(*(void *)a2 + 8 * v6);
    unint64_t v9 = *(void *)(v8 - 32);
    uint64_t v10 = *(void *)(a1 + 32);
    uint64_t v11 = *(void *)(v10 + 104);
    unsigned int v12 = *(_DWORD *)(v10 + 120);
    if (!v12) {
      goto LABEL_11;
    }
    unsigned int v13 = v12 - 1;
    unsigned int v14 = (v12 - 1) & ((v9 >> 4) ^ (v9 >> 9));
    uint64_t v15 = v11 + 48 * v14;
    uint64_t v16 = *(void *)(v15 + 24);
    if (v16 != v9)
    {
      int v17 = 1;
      while (v16 != -4096)
      {
        unsigned int v18 = v14 + v17++;
        unsigned int v14 = v18 & v13;
        uint64_t v15 = v11 + 48 * (v18 & v13);
        uint64_t v16 = *(void *)(v15 + 24);
        if (v16 == v9) {
          goto LABEL_12;
        }
      }
LABEL_11:
      uint64_t v15 = v11 + 48 * v12;
    }
LABEL_12:
    uint64_t v19 = *(llvm **)(v8 - 64);
    if (v15 == v11 + 48 * v12 || (uint64_t SCEVIter = *(void *)(v15 + 40)) == 0) {
      uint64_t SCEVIter = llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)v10, v9);
    }
    uint64_t v21 = *(void *)(*(void *)(*(void *)(SCEVIter + 32) + 8) + 32);
    uint64_t v22 = *(unsigned int *)(v21 + 32);
    if (v22 > 0x40) {
      operator new[]();
    }
    unint64_t v23 = *(void *)(v21 + 24);
    uint64_t v24 = sub_1CB83544C(*(void *)(a1 + 56), **(void **)(*(void *)(*(void *)a2 + 8 * v6) - 64));
    uint64_t v26 = v24;
    if (v25 == 1) {
    unint64_t v27 = ((unint64_t)(v26 + 7) >> 3);
    }
    int v167 = v7;
    if (v23 == v27)
    {
LABEL_93:
      sub_1CC37AF14(v195, (uint64_t *)(*(void *)a2 + 8 * v6));
      goto LABEL_94;
    }
    unsigned int v189 = v22;
    unint64_t v28 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v22;
    if (!v22) {
      unint64_t v28 = 0;
    }
    uint64_t v188 = (void *)(v28 & ~v23);
    llvm::APInt::operator++((uint64_t)&v188);
    uint64_t v30 = v189;
    unsigned int v189 = 0;
    if (v30 < 0x41)
    {
      BOOL v31 = v188 == (void *)v27;
LABEL_25:
      if (v31) {
        goto LABEL_93;
      }
      goto LABEL_41;
    }
    int v32 = 0;
    int64_t v33 = (unint64_t)(v30 + 63) >> 6;
    do
    {
      BOOL v34 = v33-- < 1;
      if (v34) {
        break;
      }
      unint64_t v35 = v188[v33];
      v32 += __clz(v35);
    }
    while (!v35);
    int v36 = v30 | 0xFFFFFFC0;
    if ((v30 & 0x3F) == 0) {
      int v36 = 0;
    }
    if ((v30 - v32 - v36) >= 0x41)
    {
      if (!v188) {
        goto LABEL_41;
      }
      BOOL v37 = 0;
    }
    else
    {
      BOOL v31 = *v188 == v27;
      BOOL v37 = v31;
      if (!v188) {
        goto LABEL_25;
      }
    }
    MEMORY[0x1D25D9CB0](v188, 0x1000C8000313F17);
    if (v189 >= 0x41 && v188)
    {
      MEMORY[0x1D25D9CB0](v188, 0x1000C8000313F17);
      if (v37) {
        goto LABEL_93;
      }
    }
    else if (v37)
    {
      goto LABEL_93;
    }
LABEL_41:
    long long v38 = *(llvm::Value **)(a1 + 56);
    if (a4 == 1)
    {
      uint64_t v163 = llvm::isBytewiseValue(v19, v38, v29);
      uint64_t v40 = 0;
    }
    else
    {
      uint64_t v40 = sub_1CCDCD43C(v19, v38);
      uint64_t v163 = 0;
    }
    unsigned int v41 = 0;
    LODWORD(v201) = 0;
    int v42 = v6 + 1;
    if (v6 + 1 < v5)
    {
      unsigned int v41 = 0;
      do
      {
        if (v41 >= HIDWORD(v201)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v200 + v41) = v42;
        unsigned int v41 = v201 + 1;
        LODWORD(v201) = v201 + 1;
        ++v42;
      }
      while (v5 != v42);
    }
    int v43 = v7;
    if (v6)
    {
      do
      {
        if (v41 >= HIDWORD(v201)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v200 + v41) = v43;
        unsigned int v41 = v201 + 1;
        LODWORD(v201) = v201 + 1;
        --v43;
      }
      while (v43 != -1);
    }
    uint64_t v164 = v40;
    if (v41)
    {
      long long v44 = (unsigned int *)v200;
      long long v45 = (unsigned int *)((char *)v200 + 4 * v41);
      size_t __n = ((unint64_t)(v22 + 63) >> 3) & 0x3FFFFFF8;
      while (1)
      {
        unint64_t v46 = *(void *)(*(void *)(*(void *)a2 + 8 * *v44) - 32);
        uint64_t v47 = *(void *)(a1 + 32);
        uint64_t v48 = *(void *)(v47 + 104);
        unsigned int v49 = *(_DWORD *)(v47 + 120);
        if (!v49) {
          goto LABEL_63;
        }
        unsigned int v50 = (v49 - 1) & ((v46 >> 4) ^ (v46 >> 9));
        uint64_t v51 = v48 + 48 * v50;
        uint64_t v52 = *(void *)(v51 + 24);
        if (v52 != v46) {
          break;
        }
LABEL_64:
        if (v51 == v48 + 48 * v49 || (uint64_t v55 = *(void *)(v51 + 40)) == 0) {
          uint64_t v55 = llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)v47, v46);
        }
        uint64_t v56 = *(void *)(*(void *)(*(void *)(v55 + 32) + 8) + 32);
        if (*(_DWORD *)(v56 + 32) > 0x40u) {
          operator new[]();
        }
        if (v23 == *(void *)(v56 + 24))
        {
          uint64_t v58 = *(llvm **)(*(void *)(*(void *)a2 + 8 * *v44) - 64);
          char v59 = *(llvm::Value **)(a1 + 56);
          if (a4 == 1)
          {
            uint64_t v60 = llvm::isBytewiseValue(v58, v59, v39);
            uint64_t v162 = 0;
          }
          else
          {
            uint64_t v162 = sub_1CCDCD43C(v58, v59);
            uint64_t v60 = 0;
          }
          if (!llvm::isConsecutiveAccess(*(llvm **)(*(void *)a2 + 8 * v6), *(llvm::Value **)(*(void *)a2 + 8 * *v44), *(llvm::Value **)(a1 + 56), *(const llvm::DataLayout **)(a1 + 32), 0))
          {
            int v57 = 0;
            goto LABEL_71;
          }
          if (a4 == 1)
          {
            uint64_t v61 = v163;
            if (*((unsigned __int8 *)v163 + 16) - 11 < 2) {
              uint64_t v61 = v60;
            }
            if (v61 == v60)
            {
              uint64_t v163 = v60;
LABEL_91:
              sub_1CC37AF14(v190, (uint64_t *)(*(void *)a2 + 8 * *v44));
              sub_1CC37AF14(v195, (uint64_t *)(*(void *)a2 + 8 * v6));
              uint64_t v63 = *(void *)(*(void *)a2 + 8 * *v44);
              sub_1CD68C958(v203, (uint64_t *)(*(void *)a2 + 8 * v6))[1] = v63;
              int v57 = 11;
              goto LABEL_71;
            }
            uint64_t v163 = v61;
          }
          else
          {
            uint64_t v62 = v164;
            if (*((unsigned __int8 *)v164 + 16) - 11 < 2) {
              uint64_t v62 = v162;
            }
            if (v62 == v162)
            {
              uint64_t v164 = v162;
              goto LABEL_91;
            }
            uint64_t v164 = v62;
          }
        }
        int v57 = 12;
LABEL_71:
        if ((v57 == 12 || !v57) && ++v44 != v45) {
          continue;
        }
        goto LABEL_94;
      }
      int v53 = 1;
      while (v52 != -4096)
      {
        unsigned int v54 = v50 + v53++;
        unsigned int v50 = v54 & (v49 - 1);
        uint64_t v51 = v48 + 48 * v50;
        uint64_t v52 = *(void *)(v51 + 24);
        if (v52 == v46) {
          goto LABEL_64;
        }
      }
LABEL_63:
      uint64_t v51 = v48 + 48 * v49;
      goto LABEL_64;
    }
LABEL_94:
    ++v6;
    int v7 = v167 + 1;
    unint64_t v5 = v166;
  }
  while (v6 != v166);
  char v65 = v197;
  uint64_t v64 = v198;
  uint64_t v183 = v187;
  int v184 = v187;
  uint64_t v185 = 16;
  int v186 = 0;
  if (v197 == v198) {
    goto LABEL_262;
  }
  uint64_t v168 = v198;
  do
  {
    uint64_t v66 = *v65;
    uint64_t v182 = *v65;
    uint64_t v67 = v190[0];
    int v68 = v191;
    if (v191)
    {
      unsigned int v69 = ((v66 >> 4) ^ (v66 >> 9)) & (v191 - 1);
      uint64_t v70 = *(void *)(v190[0] + 8 * v69);
      if (v66 == v70) {
        goto LABEL_253;
      }
      int v71 = 1;
      while (v70 != -4096)
      {
        unsigned int v72 = v69 + v71++;
        unsigned int v69 = v72 & (v191 - 1);
        uint64_t v70 = *(void *)(v190[0] + 8 * v69);
        if (v66 == v70) {
          goto LABEL_253;
        }
      }
    }
    LODWORD(v73) = 0;
    uint64_t v177 = v181;
    uint64_t v178 = v181;
    uint64_t v179 = 8;
    int v74 = v191 - 1;
    uint64_t v75 = v66;
    int v180 = 0;
    if (v191)
    {
LABEL_104:
      unsigned int v76 = ((v75 >> 4) ^ (v75 >> 9)) & v74;
      uint64_t v77 = *(void *)(v67 + 8 * v76);
      if (v75 != v77)
      {
        int v78 = 1;
        while (v77 != -4096)
        {
          unsigned int v79 = v76 + v78++;
          unsigned int v76 = v79 & v74;
          uint64_t v77 = *(void *)(v67 + 8 * v76);
          if (v75 == v77) {
            goto LABEL_111;
          }
        }
        goto LABEL_109;
      }
      goto LABEL_111;
    }
LABEL_109:
    while (v196)
    {
      unsigned int v80 = (v196 - 1) & ((v75 >> 4) ^ (v75 >> 9));
      uint64_t v81 = *(void *)(v195[0] + 8 * v80);
      if (v75 != v81)
      {
        int v111 = 1;
        while (v81 != -4096)
        {
          unsigned int v112 = v80 + v111++;
          unsigned int v80 = v112 & (v196 - 1);
          uint64_t v81 = *(void *)(v195[0] + 8 * v80);
          if (v75 == v81) {
            goto LABEL_111;
          }
        }
        break;
      }
LABEL_111:
      uint64_t v82 = v183;
      if (v184 == v183)
      {
        int v83 = HIDWORD(v185);
        int v84 = &v184[8 * HIDWORD(v185)];
        if (HIDWORD(v185))
        {
          uint64_t v85 = 0;
          while (*(void *)&v184[v85] != v75)
          {
            v85 += 8;
            if (8 * HIDWORD(v185) == v85) {
              goto LABEL_130;
            }
          }
          int v84 = &v184[v85];
        }
LABEL_130:
        uint64_t v82 = v184;
      }
      else
      {
        int v86 = v185 - 1;
        unsigned int v87 = (v185 - 1) & ((v75 >> 4) ^ (v75 >> 9));
        int v84 = &v184[8 * v87];
        uint64_t v88 = *(void *)v84;
        if (*(void *)v84 == -1)
        {
          uint64_t v89 = 0;
LABEL_172:
          if (v89) {
            int v84 = v89;
          }
          int v83 = HIDWORD(v185);
          if (*(void *)v84 != v75) {
            int v84 = &v184[8 * v185];
          }
        }
        else
        {
          uint64_t v89 = 0;
          int v90 = 1;
          while (v88 != v75)
          {
            if (v89) {
              BOOL v91 = 0;
            }
            else {
              BOOL v91 = v88 == -2;
            }
            if (v91) {
              uint64_t v89 = v84;
            }
            unsigned int v92 = v87 + v90++;
            unsigned int v87 = v92 & v86;
            int v84 = &v184[8 * (v92 & v86)];
            uint64_t v88 = *(void *)v84;
            if (*(void *)v84 == -1) {
              goto LABEL_172;
            }
          }
          int v83 = HIDWORD(v185);
        }
      }
      if (v184 == v82) {
        int v93 = v83;
      }
      else {
        int v93 = v185;
      }
      if (v84 != &v184[8 * v93]) {
        break;
      }
      long long v94 = v178;
      uint64_t v95 = HIDWORD(v179);
      if (v178 != v177)
      {
        unsigned int v99 = v179;
LABEL_146:
        if (3 * v99 <= 4 * (HIDWORD(v179) - v180))
        {
          if (v99 >= 0x40) {
            v99 *= 2;
          }
          else {
            unsigned int v99 = 128;
          }
        }
        else if (v99 - HIDWORD(v179) >= v99 >> 3)
        {
          goto LABEL_148;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v177, v99);
        unsigned int v99 = v179;
        long long v94 = v178;
LABEL_148:
        unsigned int v100 = v99 - 1;
        unsigned int v101 = (v99 - 1) & ((v75 >> 4) ^ (v75 >> 9));
        int v102 = &v94[8 * v101];
        uint64_t v103 = *(void *)v102;
        if (*(void *)v102 == -1)
        {
          uint64_t v104 = 0;
LABEL_160:
          if (v104) {
            uint64_t v108 = v104;
          }
          else {
            uint64_t v108 = (uint64_t *)v102;
          }
          if (*v108 != v75)
          {
            if (*v108 == -2) {
              --v180;
            }
            else {
              ++HIDWORD(v179);
            }
            uint64_t *v108 = v75;
          }
        }
        else
        {
          uint64_t v104 = 0;
          int v105 = 1;
          while (v103 != v75)
          {
            if (v104) {
              BOOL v106 = 0;
            }
            else {
              BOOL v106 = v103 == -2;
            }
            if (v106) {
              uint64_t v104 = (uint64_t *)v102;
            }
            unsigned int v107 = v101 + v105++;
            unsigned int v101 = v107 & v100;
            int v102 = &v94[8 * (v107 & v100)];
            uint64_t v103 = *(void *)v102;
            if (*(void *)v102 == -1) {
              goto LABEL_160;
            }
          }
        }
        goto LABEL_167;
      }
      if (HIDWORD(v179))
      {
        unint64_t v96 = 0;
        uint64_t v97 = 8 * HIDWORD(v179);
        uint64_t v98 = (uint64_t *)v178;
        while (*v98 != v75)
        {
          if (*v98 == -2) {
            unint64_t v96 = v98;
          }
          ++v98;
          v97 -= 8;
          if (!v97)
          {
            if (!v96) {
              goto LABEL_143;
            }
            uint64_t *v96 = v75;
            --v180;
            goto LABEL_167;
          }
        }
        goto LABEL_167;
      }
LABEL_143:
      unsigned int v99 = v179;
      if (HIDWORD(v179) >= v179) {
        goto LABEL_146;
      }
      ++HIDWORD(v179);
      *(void *)&v178[8 * v95] = v75;
LABEL_167:
      uint64_t v110 = sub_1CB83544C(*(void *)(a1 + 56), **(void **)(v75 - 64));
      if (v109 == 1) {
      LODWORD(v73) = v73 + ((unint64_t)(v110 + 7) >> 3);
      }
      uint64_t v75 = sub_1CD68C958(v203, &v182)[1];
      uint64_t v182 = v75;
      if (v68) {
        goto LABEL_104;
      }
    }
    BOOL v171 = *(llvm **)(v66 - 64);
    uint64_t v113 = *(uint64_t **)(v66 - 32);
    uint64_t v114 = *(void *)(a1 + 32);
    uint64_t v115 = *(void *)(v114 + 104);
    unsigned int v116 = *(_DWORD *)(v114 + 120);
    if (!v116) {
      goto LABEL_193;
    }
    unsigned int v117 = (v116 - 1) & ((v113 >> 4) ^ (v113 >> 9));
    uint64_t v118 = v115 + 48 * v117;
    unint64_t v119 = *(uint64_t **)(v118 + 24);
    if (v119 != v113)
    {
      int v120 = 1;
      while (v119 != (uint64_t *)-4096)
      {
        unsigned int v121 = v117 + v120++;
        unsigned int v117 = v121 & (v116 - 1);
        uint64_t v118 = v115 + 48 * v117;
        unint64_t v119 = *(uint64_t **)(v118 + 24);
        if (v119 == v113) {
          goto LABEL_194;
        }
      }
LABEL_193:
      uint64_t v118 = v115 + 48 * v116;
    }
LABEL_194:
    if (v118 == v115 + 48 * v116 || (uint64_t v122 = *(void *)(v118 + 40)) == 0) {
      uint64_t v122 = llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)v114, *(void *)(v66 - 32));
    }
    uint64_t v123 = *(void *)(*(void *)(*(void *)(v122 + 32) + 8) + 32);
    unsigned int v124 = *(_DWORD *)(v123 + 32);
    unint64_t v125 = v73;
    if (v124 >= 0x41) {
      operator new[]();
    }
    uint64_t v126 = *(void *)(v123 + 24);
    if (v126 == v73)
    {
      unsigned int v174 = v124;
      uint64_t v73 = v73;
      goto LABEL_222;
    }
    unsigned int v176 = v124;
    uint64_t v127 = v126;
    unint64_t v128 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v124;
    if (!v124) {
      unint64_t v128 = 0;
    }
    uint64_t v175 = (void *)(v128 & ~v126);
    llvm::APInt::operator++((uint64_t)&v175);
    uint64_t v129 = v176;
    unsigned int v176 = 0;
    if (v129 >= 0x41)
    {
      int v131 = 0;
      int64_t v132 = (unint64_t)(v129 + 63) >> 6;
      do
      {
        BOOL v34 = v132-- < 1;
        if (v34) {
          break;
        }
        unint64_t v133 = v175[v132];
        v131 += __clz(v133);
      }
      while (!v133);
      int v134 = v129 | 0xFFFFFFC0;
      if ((v129 & 0x3F) == 0) {
        int v134 = 0;
      }
      if ((v129 - v131 - v134) >= 0x41)
      {
        if (!v175) {
          goto LABEL_251;
        }
        BOOL v135 = 1;
      }
      else
      {
        BOOL v130 = *v175 == v73;
        BOOL v135 = *v175 != v73;
        if (!v175) {
          goto LABEL_205;
        }
      }
      MEMORY[0x1D25D9CB0](v175, 0x1000C8000313F17);
      if (v176 >= 0x41 && v175) {
        MEMORY[0x1D25D9CB0](v175, 0x1000C8000313F17);
      }
      if (!v135)
      {
LABEL_221:
        unsigned int v174 = v124;
        uint64_t v73 = v127;
LABEL_222:
        if (v124) {
          unint64_t v136 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v124;
        }
        else {
          unint64_t v136 = 0;
        }
        uint64_t v173 = (void *)(v136 & ~v73);
        llvm::APInt::operator++((uint64_t)&v173);
        uint64_t v137 = v174;
        unsigned int v174 = 0;
        if (v137 >= 0x41)
        {
          int v139 = 0;
          int64_t v140 = (unint64_t)(v137 + 63) >> 6;
          do
          {
            BOOL v34 = v140-- < 1;
            if (v34) {
              break;
            }
            unint64_t v141 = v173[v140];
            v139 += __clz(v141);
          }
          while (!v141);
          char v138 = 0;
          int v142 = v137 | 0xFFFFFFC0;
          if ((v137 & 0x3F) == 0) {
            int v142 = 0;
          }
          if ((v137 - v139 - v142) <= 0x40) {
            char v138 = *v173 == v125;
          }
          if (v173)
          {
            MEMORY[0x1D25D9CB0](v173, 0x1000C8000313F17);
            if (v174 >= 0x41)
            {
              if (v173) {
                MEMORY[0x1D25D9CB0](v173, 0x1000C8000313F17);
              }
            }
          }
        }
        else
        {
          char v138 = v173 == (void *)v125;
        }
        uint64_t v143 = *(void *)(a1 + 56);
        uint64_t v144 = *v113;
        unsigned int v145 = *(_DWORD *)(*v113 + 8);
        if ((v145 & 0xFE) == 0x12) {
          unsigned int v145 = *(_DWORD *)(**(void **)(v144 + 16) + 8);
        }
        uint64_t v146 = *(void *)(v143 + 232);
        if (v145 < 0x100) {
          goto LABEL_248;
        }
        unsigned int v147 = v145 >> 8;
        unint64_t v148 = *(unsigned int *)(v143 + 240);
        uint64_t v149 = *(void *)(v143 + 232);
        if (v148)
        {
          uint64_t v149 = v146;
          unint64_t v150 = v148;
          do
          {
            unint64_t v151 = v150 >> 1;
            uint64_t v152 = v149 + 16 * (v150 >> 1);
            unsigned int v153 = *(_DWORD *)(v152 + 8);
            uint64_t v154 = v152 + 16;
            v150 += ~(v150 >> 1);
            if (v153 < v147) {
              uint64_t v149 = v154;
            }
            else {
              unint64_t v150 = v151;
            }
          }
          while (v150);
        }
        if (v149 == v146 + 16 * v148 || *(_DWORD *)(v149 + 8) != v147) {
LABEL_248:
        }
          uint64_t v149 = v146;
        uint64_t v155 = (uint64_t **)llvm::IntegerType::get(*(llvm::IntegerType **)v144, (llvm::LLVMContext *)*(unsigned int *)(v149 + 12));
        uint64_t v156 = (llvm::Type *)v155;
        if ((*(_DWORD *)(v144 + 8) & 0xFE) == 0x12)
        {
          uint64_t v158 = (llvm::Type *)*(unsigned int *)(v144 + 32);
          if (*(_DWORD *)(v144 + 8) == 19) {
            llvm::ScalableVectorType::get(v155, v158);
          }
          else {
            llvm::FixedVectorType::get((llvm::FixedVectorType *)v155, v158);
          }
          uint64_t v156 = v159;
        }
        unint64_t Constant = (const llvm::DataLayout *)llvm::ScalarEvolution::getConstant(*(llvm::ScalarEvolution **)(a1 + 32), v156, v125, 0);
        sub_1CCDCD738(a1, (int)v113, Constant, __n & 0xFFFF0000 | ((unint64_t)*(unsigned __int16 *)(v66 + 18) >> 1) & 0x3F | 0x100, v171, v66, (int)&v177, v122, a3, v138, 0);
      }
    }
    else
    {
      BOOL v130 = v175 == (void *)v73;
LABEL_205:
      if (v130) {
        goto LABEL_221;
      }
    }
LABEL_251:
    uint64_t v64 = v168;
    if (v178 != v177) {
      free(v178);
    }
LABEL_253:
    ++v65;
  }
  while (v65 != v64);
  if (v184 != v183) {
    free(v184);
  }
LABEL_262:
  if (v200 != v202) {
    free(v200);
  }
  if ((v203[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v203[1], 8);
  }
  sub_1CD456CB4(v190);
  sub_1CD456CB4(v195);
  return 0;
}

llvm::Value *sub_1CCDCD43C(llvm::Value *a1, unsigned char *a2)
{
  uint64_t result = 0;
  if (a1 && *((unsigned __int8 *)a1 + 16) <= 0x14u)
  {
    unint64_t v6 = sub_1CB83544C((uint64_t)a2, *(void *)a1);
    if (v5 == 1)
    {
      unint64_t v13 = v6;
      unint64_t v6 = v13;
    }
    uint64_t result = 0;
    if (v6)
    {
      if ((v6 & 7) == 0)
      {
        uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
        v7.i16[0] = vaddlv_u8(v7);
        if (v7.u32[0] <= 1uLL)
        {
          if (*a2 || v6 > 0x87)
          {
            return 0;
          }
          else
          {
            unint64_t v8 = v6 >> 3;
            if (v8 != 16)
            {
              unint64_t v9 = 0x10 / v8;
              uint64_t v10 = llvm::ArrayType::get(*(llvm::ArrayType **)a1, (llvm::Type *)(0x10 / v8));
              uint64_t v11 = (llvm::Type *)operator new(8 * v9);
              unsigned int v12 = (llvm::Value **)v11;
              do
                *v12++ = a1;
              while (v12 != (llvm::Value **)((char *)v11 + 8 * v9));
              a1 = llvm::ConstantArray::get(v10, v11, v9);
              operator delete(v11);
            }
            return a1;
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_1CCDCD550(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = (void *)a1[1];
  if ((unint64_t)v3 >= a1[2])
  {
    uint64_t result = sub_1CCDCD5C4(a1, a2);
  }
  else
  {
    *uint64_t v3 = *(void *)a2;
    v3[1] = v3 + 3;
    v3[2] = 0x800000000;
    if (*(_DWORD *)(a2 + 16)) {
      sub_1CD41C56C((uint64_t)(v3 + 1), a2 + 8);
    }
    uint64_t result = (uint64_t)(v3 + 11);
  }
  a1[1] = result;
  return result;
}

uint64_t sub_1CCDCD5C4(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) > 0x2E8BA2E8BA2E8BALL) {
    abort();
  }
  if (0x5D1745D1745D1746 * ((a1[2] - *a1) >> 3) > v3) {
    unint64_t v3 = 0x5D1745D1745D1746 * ((a1[2] - *a1) >> 3);
  }
  if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((a1[2] - *a1) >> 3)) >= 0x1745D1745D1745DLL) {
    unint64_t v5 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v5 = v3;
  }
  uint64_t v19 = a1 + 2;
  if (v5 > 0x2E8BA2E8BA2E8BALL) {
    sub_1CB833614();
  }
  uint64_t v7 = 88 * v5;
  unint64_t v8 = (char *)operator new(88 * v5);
  unint64_t v9 = &v8[88 * v2];
  uint64_t __p = v8;
  uint64_t v16 = v9;
  unsigned int v18 = &v8[v7];
  *(void *)unint64_t v9 = *(void *)a2;
  *((void *)v9 + 1) = v9 + 24;
  *((void *)v9 + 2) = 0x800000000;
  if (*(_DWORD *)(a2 + 16)) {
    sub_1CD41C56C((uint64_t)(v9 + 8), a2 + 8);
  }
  int v17 = v9 + 88;
  sub_1CD771130(a1, &__p);
  uint64_t v10 = a1[1];
  uint64_t v11 = v16;
LABEL_11:
  for (uint64_t i = v17; i != v11; i -= 88)
  {
    int v17 = i - 88;
    unint64_t v13 = (char *)*((void *)i - 10);
    if (v13 != i - 64)
    {
      free(v13);
      goto LABEL_11;
    }
  }
  if (__p) {
    operator delete(__p);
  }
  return v10;
}

void sub_1CCDCD738(uint64_t a1, int a2, const llvm::DataLayout *a3, int a4, llvm *this, int a6, int a7, int a8, uint64_t a9, char a10, char a11)
{
  if (!llvm::isBytewiseValue(this, *(llvm::Value **)(a1 + 56), a3)) {
    sub_1CCDCD43C(this, *(unsigned char **)(a1 + 56));
  }
  llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopPredecessor();
}

unint64_t sub_1CCDCE6B8(llvm::SCEV *a1, llvm::detail::IEEEFloat **a2, llvm::Type *a3, llvm::detail::IEEEFloat **a4, llvm::ScalarEvolution *this)
{
  v12[2] = *MEMORY[0x1E4F143B8];
  TruncateOrZeroExtend = (const llvm::APInt *)llvm::ScalarEvolution::getTruncateOrZeroExtend(this, a2, a3, 0);
  if (!llvm::SCEV::isOne((llvm::SCEV *)a4))
  {
    v11[0] = v12;
    v12[0] = TruncateOrZeroExtend;
    v12[1] = llvm::ScalarEvolution::getTruncateOrZeroExtend(this, a4, a3, 0);
    v11[1] = (void *)0x200000002;
    TruncateOrZeroExtend = (const llvm::APInt *)llvm::ScalarEvolution::getMulExpr((uint64_t)this, (uint64_t)v11, 2, 0);
    if (v11[0] != v12) {
      free(v11[0]);
    }
  }
  return llvm::ScalarEvolution::getMinusSCEV(this, a1, TruncateOrZeroExtend, 0, 0);
}

uint64_t sub_1CCDCE7B0(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (*(_WORD *)(a4 + 24)) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = a4;
  }
  if (*(_WORD *)(a5 + 24)) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = a5;
  }
  if (v8) {
    BOOL v10 = v9 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10)
  {
    unint64_t v11 = -2;
  }
  else
  {
    uint64_t v12 = *(void *)(v8 + 32);
    unint64_t v13 = (void *)(v12 + 24);
    if (*(_DWORD *)(v12 + 32) >= 0x41u) {
      unint64_t v13 = (void *)*v13;
    }
    uint64_t v14 = *v13 + 1;
    uint64_t v15 = *(void *)(v9 + 32);
    uint64_t v16 = (void *)(v15 + 24);
    if (*(_DWORD *)(v15 + 32) >= 0x41u) {
      uint64_t v16 = (void *)*v16;
    }
    unint64_t v11 = *v16 * v14;
    if (v11 > 0x7FFFFFFFFFFFFFFBLL) {
      unint64_t v11 = -2;
    }
  }
  unint64_t v45 = v11;
  uint64_t v17 = *(void *)(a3 + 32);
  uint64_t v42 = *(void *)(a3 + 40);
  if (v42 != v17)
  {
    int v44 = a2 & 3;
    long long v18 = xmmword_1CFAC3060;
    while (2)
    {
      uint64_t v43 = v17;
      uint64_t v19 = *(void *)v17 + 40;
      for (uint64_t i = *(void *)(*(void *)v17 + 48); i != v19; uint64_t i = *(void *)(i + 8))
      {
        if (i) {
          uint64_t v21 = (llvm::Instruction *)(i - 24);
        }
        else {
          uint64_t v21 = 0;
        }
        uint64_t v23 = *a7;
        uint64_t v22 = a7[1];
        if (v22 == *a7)
        {
          uint64_t v24 = *((unsigned int *)a7 + 5);
          uint64_t v25 = (llvm::Instruction **)(v22 + 8 * v24);
          if (v24)
          {
            uint64_t v26 = 0;
            while (*(llvm::Instruction **)(v22 + v26) != v21)
            {
              v26 += 8;
              if (8 * v24 == v26) {
                goto LABEL_45;
              }
            }
            uint64_t v25 = (llvm::Instruction **)(v22 + v26);
          }
LABEL_45:
          uint64_t v23 = a7[1];
        }
        else
        {
          uint64_t v27 = *((unsigned int *)a7 + 4);
          int v28 = v27 - 1;
          unsigned int v29 = (v27 - 1) & ((v21 >> 4) ^ (v21 >> 9));
          uint64_t v25 = (llvm::Instruction **)(v22 + 8 * v29);
          uint64_t v30 = *v25;
          if (*v25 == (llvm::Instruction *)-1)
          {
            BOOL v31 = 0;
LABEL_63:
            if (v31) {
              uint64_t v25 = v31;
            }
            LODWORD(v24) = *((_DWORD *)a7 + 5);
            uint64_t v40 = (llvm::Instruction **)(v22 + 8 * v27);
            if (*v25 != v21) {
              uint64_t v25 = v40;
            }
          }
          else
          {
            BOOL v31 = 0;
            int v32 = 1;
            while (v30 != v21)
            {
              if (v31) {
                BOOL v33 = 0;
              }
              else {
                BOOL v33 = v30 == (llvm::Instruction *)-2;
              }
              if (v33) {
                BOOL v31 = v25;
              }
              unsigned int v34 = v29 + v32++;
              unsigned int v29 = v34 & v28;
              uint64_t v25 = (llvm::Instruction **)(v22 + 8 * (v34 & v28));
              uint64_t v30 = *v25;
              if (*v25 == (llvm::Instruction *)-1) {
                goto LABEL_63;
              }
            }
            LODWORD(v24) = *((_DWORD *)a7 + 5);
          }
        }
        if (v22 == v23) {
          unsigned int v35 = v24;
        }
        else {
          unsigned int v35 = *((_DWORD *)a7 + 4);
        }
        if (v25 == (llvm::Instruction **)(v22 + 8 * v35))
        {
          *(void *)&v48[0] = a1;
          *((void *)&v48[0] + 1) = v45;
          memset(&v48[1], 0, 32);
          char v49 = 1;
          uint64_t v36 = 1;
          v50[0] = 1;
          do
          {
            BOOL v37 = &v50[v36];
            *(_OWORD *)BOOL v37 = v18;
            *((_OWORD *)v37 + 1) = v18;
            v36 += 5;
          }
          while (v37 + 5 != v51);
          v51[0] = &v55;
          v51[1] = 0;
          uint64_t v52 = v54;
          uint64_t v53 = 0x400000000;
          uint64_t v55 = &unk_1F2600DB8;
          uint64_t v38 = 63;
          uint64_t v56 = 1;
          do
          {
            v50[v38] = -4096;
            v38 += 2;
          }
          while (v38 != 79);
          int ModRefInfo = llvm::AAResults::getModRefInfo(a6, v21, v48, (uint64_t)v50);
          if ((v56 & 1) == 0) {
            MEMORY[0x1D25D9CD0](v57, 8);
          }
          long long v18 = xmmword_1CFAC3060;
          if (v52 != v54)
          {
            free(v52);
            long long v18 = xmmword_1CFAC3060;
          }
          if ((v50[0] & 1) == 0)
          {
            MEMORY[0x1D25D9CD0](v50[1], 8);
            long long v18 = xmmword_1CFAC3060;
          }
          if ((v44 & ModRefInfo) != 0) {
            return 1;
          }
        }
      }
      uint64_t v17 = v43 + 8;
      if (v43 + 8 != v42) {
        continue;
      }
      break;
    }
  }
  return 0;
}

uint64_t sub_1CCDCEB20(llvm::detail::IEEEFloat **a1, llvm::Type *a2, llvm::detail::IEEEFloat **a3, uint64_t a4, uint64_t a5, llvm::ScalarEvolution *a6)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a1;
  while (2)
  {
    switch(*((_WORD *)v12 + 12))
    {
      case 1:
      case 2:
      case 3:
      case 0xD:
        uint64_t v14 = (uint64_t *)(v12 + 5);
        goto LABEL_9;
      case 4:
        uint64_t v14 = (uint64_t *)(v12 + 6);
        goto LABEL_9;
      case 5:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
        unint64_t v13 = (llvm::detail::IEEEFloat ***)v12[4];
        goto LABEL_4;
      case 6:
        unint64_t v13 = (llvm::detail::IEEEFloat ***)(v12 + 5);
LABEL_4:
        uint64_t v12 = *v13;
        continue;
      case 0xE:
        uint64_t v14 = (uint64_t *)*(v12 - 1);
        goto LABEL_9;
      default:
        uint64_t v14 = (uint64_t *)v12[4];
LABEL_9:
        unint64_t v16 = sub_1CB83544C(a5, *v14);
        if (v15 == 1) {
        unint64_t v18 = sub_1CB83544C(a5, (uint64_t)a2);
        }
        if (v17 == 1) {
        if (v16 >= v18)
        }
        {
LABEL_28:
          p_TruncateOrZeroExtend = &TruncateOrZeroExtend;
          TruncateOrZeroExtend = llvm::ScalarEvolution::getTruncateOrZeroExtend(a6, a1, a2, 0);
          unint64_t Constant = llvm::ScalarEvolution::getConstant(a6, a2, 1uLL, 0);
          uint64_t v34 = 0x200000002;
          unint64_t AddExpr = llvm::ScalarEvolution::getAddExpr((uint64_t)a6, (unint64_t **)&p_TruncateOrZeroExtend, 2, 0);
          if (p_TruncateOrZeroExtend != &TruncateOrZeroExtend) {
            free(p_TruncateOrZeroExtend);
          }
        }
        else
        {
          uint64_t v19 = a1;
          while (2)
          {
            switch(*((_WORD *)v19 + 12))
            {
              case 1:
              case 2:
              case 3:
              case 0xD:
                uint64_t v21 = v19 + 5;
                goto LABEL_22;
              case 4:
                uint64_t v21 = v19 + 6;
                goto LABEL_22;
              case 5:
              case 7:
              case 8:
              case 9:
              case 0xA:
              case 0xB:
              case 0xC:
                uint64_t v20 = (llvm::detail::IEEEFloat ***)v19[4];
                goto LABEL_17;
              case 6:
                uint64_t v20 = (llvm::detail::IEEEFloat ***)(v19 + 5);
LABEL_17:
                uint64_t v19 = *v20;
                continue;
              case 0xE:
                uint64_t v21 = (llvm::Type **)*(v19 - 1);
                goto LABEL_22;
              default:
                uint64_t v21 = (llvm::Type **)v19[4];
LABEL_22:
                unint64_t v22 = llvm::ScalarEvolution::getConstant(a6, *v21, 1uLL, 0);
                unint64_t NegativeSCEV = llvm::ScalarEvolution::getNegativeSCEV(a6, v22, 0);
                if (!llvm::ScalarEvolution::isLoopEntryGuardedByCond((uint64_t)a6, a4, 33, (uint64_t)a1, NegativeSCEV))goto LABEL_28; {
                uint64_t v24 = a1;
                }
                while (2)
                {
                  switch(*((_WORD *)v24 + 12))
                  {
                    case 1:
                    case 2:
                    case 3:
                    case 0xD:
                      uint64_t v27 = v24 + 5;
                      goto LABEL_33;
                    case 4:
                      uint64_t v27 = v24 + 6;
                      goto LABEL_33;
                    case 5:
                    case 7:
                    case 8:
                    case 9:
                    case 0xA:
                    case 0xB:
                    case 0xC:
                      uint64_t v25 = (llvm::detail::IEEEFloat ***)v24[4];
                      goto LABEL_26;
                    case 6:
                      uint64_t v25 = (llvm::detail::IEEEFloat ***)(v24 + 5);
LABEL_26:
                      uint64_t v24 = *v25;
                      continue;
                    case 0xE:
                      uint64_t v27 = (llvm::Type **)*(v24 - 1);
                      goto LABEL_33;
                    default:
                      uint64_t v27 = (llvm::Type **)v24[4];
LABEL_33:
                      unint64_t v28 = llvm::ScalarEvolution::getConstant(a6, *v27, 1uLL, 0);
                      p_TruncateOrZeroExtend = &TruncateOrZeroExtend;
                      TruncateOrZeroExtend = a1;
                      unint64_t Constant = v28;
                      uint64_t v34 = 0x200000002;
                      unsigned int v29 = (llvm::detail::IEEEFloat **)llvm::ScalarEvolution::getAddExpr((uint64_t)a6, (unint64_t **)&p_TruncateOrZeroExtend, 2, 0);
                      if (p_TruncateOrZeroExtend != &TruncateOrZeroExtend) {
                        free(p_TruncateOrZeroExtend);
                      }
                      unint64_t AddExpr = llvm::ScalarEvolution::getZeroExtendExpr(a6, v29, (uint64_t **)a2, 0);
                      break;
                  }
                  break;
                }
                break;
            }
            break;
          }
        }
        uint64_t v30 = llvm::ScalarEvolution::getTruncateOrZeroExtend(a6, a3, a2, 0);
        p_TruncateOrZeroExtend = &TruncateOrZeroExtend;
        TruncateOrZeroExtend = (llvm::detail::IEEEFloat **)AddExpr;
        unint64_t Constant = (unint64_t)v30;
        uint64_t v34 = 0x200000002;
        uint64_t MulExpr = llvm::ScalarEvolution::getMulExpr((uint64_t)a6, (uint64_t)&p_TruncateOrZeroExtend, 2, 0);
        if (p_TruncateOrZeroExtend != &TruncateOrZeroExtend) {
          free(p_TruncateOrZeroExtend);
        }
        return MulExpr;
    }
  }
}

BOOL sub_1CCDCEF28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  BOOL v7 = sub_1CC706D94(a7);
  if (!v7) {
    llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopPredecessor();
  }
  return !v7;
}

llvm::GlobalValue *sub_1CCDD0BE0(llvm::GlobalValue *this, uint64_t *a2, llvm::DataLayout *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unsigned int v8 = *(_DWORD *)(*(void *)this + 8);
  if ((v8 & 0xFE) == 0x12) {
    unsigned int v8 = *(_DWORD *)(**(void **)(*(void *)this + 16) + 8);
  }
  if (v8 < 0x100) {
    goto LABEL_12;
  }
  unsigned int v9 = v8 >> 8;
  uint64_t v10 = *((unsigned int *)a3 + 60);
  uint64_t v11 = *((void *)a3 + 29);
  if (v10)
  {
    uint64_t v11 = *((void *)a3 + 29);
    unint64_t v12 = *((unsigned int *)a3 + 60);
    do
    {
      unint64_t v13 = v12 >> 1;
      uint64_t v14 = v11 + 16 * (v12 >> 1);
      unsigned int v15 = *(_DWORD *)(v14 + 8);
      uint64_t v16 = v14 + 16;
      v12 += ~(v12 >> 1);
      if (v15 < v9) {
        uint64_t v11 = v16;
      }
      else {
        unint64_t v12 = v13;
      }
    }
    while (v12);
  }
  if (v11 == *((void *)a3 + 29) + 16 * v10 || *(_DWORD *)(v11 + 8) != v9) {
LABEL_12:
  }
    uint64_t v11 = *((void *)a3 + 29);
  unsigned int v20 = *(_DWORD *)(v11 + 12);
  if (v20 > 0x40) {
    llvm::APInt::initSlowCase((llvm::APInt *)&v19);
  }
  uint64_t v19 = 0;
  uint64_t v17 = llvm::Value::stripAndAccumulateConstantOffsets(this, a3, (llvm::APInt *)&v19, 1, 0, 0, a7);
  if (v20 > 0x40)
  {
    *a2 = *v19;
    MEMORY[0x1D25D9CB0]();
  }
  else
  {
    *a2 = (uint64_t)((void)v19 << -(uint64_t)v20) >> -(uint64_t)v20;
  }
  return v17;
}

uint64_t sub_1CCDD0D38(uint64_t a1, uint64_t a2)
{
  if (!a1 || (*(_DWORD *)(a1 + 20) & 0x7FFFFFF) != 3) {
    return 0;
  }
  uint64_t v2 = 0;
  uint64_t v3 = *(void *)(a1 - 96);
  if (v3 && *(unsigned char *)(v3 + 16) == 81)
  {
    uint64_t v4 = *(void *)(v3 - 32);
    if (v4) {
      BOOL v5 = *(unsigned char *)(v4 + 16) == 16;
    }
    else {
      BOOL v5 = 0;
    }
    if (!v5) {
      return 0;
    }
    uint64_t v6 = *(unsigned int *)(v4 + 32);
    if (v6 > 0x40)
    {
      int v7 = 0;
      int64_t v8 = (unint64_t)(v6 + 63) >> 6;
      do
      {
        if (v8-- < 1) {
          break;
        }
        unint64_t v10 = *(void *)(*(void *)(v4 + 24) + 8 * v8);
        v7 += __clz(v10);
      }
      while (!v10);
      int v11 = v6 | 0xFFFFFFC0;
      if ((v6 & 0x3F) == 0) {
        int v11 = 0;
      }
      if (v7 + v11 != v6) {
        return 0;
      }
LABEL_19:
      int v12 = *(_WORD *)(v3 + 18) & 0x3F;
      if (v12 == 33 && *(void *)(a1 - 32) == a2) {
        return *(void *)(v3 - 64);
      }
      if (v12 == 32 && *(void *)(a1 - 64) == a2) {
        return *(void *)(v3 - 64);
      }
      return 0;
    }
    if (!*(void *)(v4 + 24)) {
      goto LABEL_19;
    }
    return 0;
  }
  return v2;
}

uint64_t sub_1CCDD0E0C(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (!result || *(unsigned char *)(result + 16) != 83 || *(void *)(result + 40) != a3) {
    return 0;
  }
  int v3 = *(_DWORD *)(result + 20);
  uint64_t v4 = (v3 & 0x40000000) != 0 ? *(void **)(result - 8) : (void *)(result - 32 * (v3 & 0x7FFFFFF));
  if (*v4 != a2 && v4[4] != a2) {
    return 0;
  }
  return result;
}

uint64_t sub_1CCDD0E64(long long *a1, long long *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  long long v11 = *a1;
  sub_1CC53A1FC((uint64_t)v12, (uint64_t)(a1 + 1));
  long long v8 = *a2;
  sub_1CC53A1FC((uint64_t)v9, (uint64_t)(a2 + 1));
  uint64_t v3 = v11;
  uint64_t v4 = v8;
  if ((void)v11 == (void)v8)
  {
    uint64_t v5 = 0;
LABEL_11:
    if (v10 == v9)
    {
      (*(void (**)(void *))(v9[0] + 32))(v9);
    }
    else if (v10)
    {
      (*(void (**)(void))(*v10 + 40))();
    }
    if (v13 == v12)
    {
      (*(void (**)(void *))(v12[0] + 32))(v12);
    }
    else if (v13)
    {
      (*(void (**)(void))(*v13 + 40))();
    }
    return v5;
  }
  else
  {
    uint64_t v5 = 0;
    while (1)
    {
      uint64_t v3 = *(void *)(v3 + 8);
      *(void *)&long long v11 = v3;
      if (v3 != *((void *)&v11 + 1)) {
        break;
      }
LABEL_8:
      ++v5;
      if (v3 == v4) {
        goto LABEL_11;
      }
    }
    while (v13)
    {
      char v6 = (*(uint64_t (**)(void))(*v13 + 48))();
      uint64_t v3 = v11;
      if ((v6 & 1) == 0)
      {
        uint64_t v3 = *(void *)(v11 + 8);
        *(void *)&long long v11 = v3;
        if (v3 != *((void *)&v11 + 1)) {
          continue;
        }
      }
      uint64_t v4 = v8;
      goto LABEL_8;
    }
    sub_1CB920400();
    return sub_1CCDD1054();
  }
}

uint64_t sub_1CCDD1054(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  **(void **)a1 = a2;
  uint64_t result = llvm::Loop::isLoopInvariant(*(void *)(a1 + 24), a2);
  if (!result) {
    return result;
  }
  uint64_t v5 = a1 + 8;
  int v6 = *(unsigned __int8 *)(a2 + 16);
  if (v6 == 5)
  {
    if (*(_WORD *)(a2 + 18) != 25) {
      return 0;
    }
    uint64_t result = sub_1CBF5270C(v5, *(llvm::Constant **)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF)));
    if (!result) {
      return result;
    }
    uint64_t v7 = *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 32);
    if (!v7) {
      return 0;
    }
LABEL_12:
    **(void **)(a1 + 16) = v7;
    return 1;
  }
  if (v6 == 53)
  {
    uint64_t result = sub_1CBF5250C(v5, *(llvm::Constant **)(a2 - 64));
    if (!result) {
      return result;
    }
    uint64_t v7 = *(void *)(a2 - 32);
    if (v7) {
      goto LABEL_12;
    }
  }
  return 0;
}

uint64_t sub_1CCDD1118()
{
  v5.n128_u64[0] = (unint64_t)"Options to disable Loop Idiom Recognize Pass.";
  v5.n128_u64[1] = 45;
  char v2 = 0;
  uint64_t v3 = &v2;
  uint64_t v4 = &llvm::DisableLIRP::All;
  int v1 = 2;
  sub_1CD771344((long long *)&v5, &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CC086C1C, &qword_1EBCF41D8, &dword_1CB82C000);
  v5.n128_u64[0] = (unint64_t)"Proceed with loop idiom recognize pass, but do not convert loop(s) to memset.";
  v5.n128_u64[1] = 77;
  uint64_t v3 = &v2;
  uint64_t v4 = &llvm::DisableLIRP::Memset;
  char v2 = 0;
  int v1 = 2;
  sub_1CD7714EC((llvm::cl::Option *)&unk_1EBCF4298, "disable-loop-idiom-memset", &v5, &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CC086C1C, &unk_1EBCF4298, &dword_1CB82C000);
  v5.n128_u64[0] = (unint64_t)"Proceed with loop idiom recognize pass, but do not convert loop(s) to memcpy.";
  v5.n128_u64[1] = 77;
  uint64_t v3 = &v2;
  uint64_t v4 = &llvm::DisableLIRP::Memcpy;
  char v2 = 0;
  int v1 = 2;
  sub_1CD7714EC((llvm::cl::Option *)&unk_1EBCF4358, "disable-loop-idiom-memcpy", &v5, &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CC086C1C, &unk_1EBCF4358, &dword_1CB82C000);
  v5.n128_u64[0] = (unint64_t)"Use loop idiom recognition code size heuristics when compilingwith -Os/-Oz";
  v5.n128_u64[1] = 74;
  LOBYTE(v1) = 1;
  uint64_t v4 = (char *)&v1;
  LODWORD(v3) = 1;
  sub_1CD4130FC((llvm::cl::Option *)&unk_1EBCF4418, "use-lir-code-size-heurs", &v5, &v4, &v3);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF4418, &dword_1CB82C000);
}

void llvm::LoopInstSimplifyPass::run(uint64_t a1@<X1>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  LOBYTE(v20) = 0;
  char v33 = 0;
  uint64_t v6 = *(void *)(a2 + 72);
  if (v6)
  {
    v8[0] = (char *)&v9;
    v8[1] = (char *)0x1000000000;
    unint64_t v10 = v14;
    long long v11 = v14;
    unsigned int v15 = v17;
    uint64_t v16 = 0x800000000;
    v19[1] = 0;
    v19[0] = 0;
    unint64_t v18 = v19;
    uint64_t v20 = v6;
    v21[0] = (char *)&v22;
    v21[1] = (char *)0x1000000000;
    uint64_t v23 = v27;
    uint64_t v24 = v27;
    uint64_t v25 = 8;
    int v26 = 0;
    uint64_t v12 = 8;
    int v13 = 0;
    unint64_t v28 = v30;
    uint64_t v29 = 0x800000000;
    v32[1] = 0;
    v32[0] = 0;
    BOOL v31 = v32;
    char v33 = 1;
    sub_1CD3C5048((uint64_t)&v18, 0);
    if (v15 != v17) {
      free(v15);
    }
    if (v11 != v10) {
      free(v11);
    }
    sub_1CC0BD0FC(v8);
    if (v33) {
      uint64_t v7 = (int32x2_t **)&v20;
    }
    else {
      uint64_t v7 = 0;
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  if (sub_1CCDD1520(a1, *(void *)(a2 + 16), *(llvm::LoopInfo **)(a2 + 24), *(void *)(a2 + 8), *(uint64_t **)(a2 + 40), v7))
  {
    llvm::getLoopPassPreservedAnalyses(a3);
    sub_1CBF541A4((llvm::SmallPtrSetImplBase *)a3, (uint64_t)&llvm::CFGAnalyses::SetKey);
    if (*(void *)(a2 + 72)) {
      sub_1CBFA65B8((llvm::SmallPtrSetImplBase *)a3, (uint64_t)&llvm::MemorySSAAnalysis::Key);
    }
  }
  else
  {
    *(void *)(a3 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
    *(void *)a3 = a3 + 32;
    *(void *)(a3 + 8) = a3 + 32;
    *(_DWORD *)(a3 + 24) = 0;
    *(void *)(a3 + 48) = a3 + 80;
    *(void *)(a3 + 56) = a3 + 80;
    *(void *)(a3 + 64) = 2;
    *(_DWORD *)(a3 + 72) = 0;
    *(void *)(a3 + 16) = 0x100000002;
  }
  if (v33)
  {
    sub_1CD3C5048((uint64_t)&v31, v32[0]);
    if (v28 != v30) {
      free(v28);
    }
    if (v24 != v23) {
      free(v24);
    }
    sub_1CC0BD0FC(v21);
  }
}

uint64_t sub_1CCDD1520(uint64_t a1, uint64_t a2, llvm::LoopInfo *a3, uint64_t a4, uint64_t *a5, int32x2_t **a6)
{
  v256[8] = *MEMORY[0x1E4F143B8];
  uint64_t v218 = *(void *)(*(void *)(**(void **)(a1 + 32) + 56) + 40) + 272;
  uint64_t v243 = v247;
  unsigned int v244 = v247;
  uint64_t v245 = 8;
  int v246 = 0;
  uint64_t v238 = v242;
  v239 = v242;
  uint64_t v240 = 8;
  int v241 = 0;
  uint64_t v233 = v237;
  uint64_t v234 = v237;
  uint64_t v235 = 4;
  int v236 = 0;
  unsigned int v251 = (char *)&v253;
  uint64_t v252 = 0x800000000;
  sub_1CBFCBAB0((uint64_t)v229, a1);
  long long v212 = a3;
  llvm::LoopBlocksDFS::perform((llvm::LoopBlocksDFS *)v229, a3);
  if (a6) {
    long long v214 = *a6;
  }
  else {
    long long v214 = 0;
  }
  char v217 = 0;
  int v13 = (unsigned int *)&v243;
  uint64_t v14 = (unsigned int *)&v238;
  long long v215 = a5;
  uint64_t v216 = a6;
  while (1)
  {
    unsigned int v15 = v14;
    uint64_t v16 = v232;
    uint64_t v211 = __p;
    uint64_t v222 = (llvm::SmallPtrSetImplBase *)v13;
    if (v232 != __p)
    {
      uint64_t v223 = v13 + 5;
      uint64_t v224 = v13 + 4;
      while (1)
      {
        unint64_t v18 = (char *)(v16 - 1);
        uint64_t v17 = *(v16 - 1);
        uint64_t v213 = v18;
        uint64_t v19 = v17 + 40;
        uint64_t v20 = *(void *)(v17 + 48);
        if (v20 != v17 + 40) {
          break;
        }
LABEL_348:
        uint64_t v16 = v213;
        if (v213 == v211) {
          goto LABEL_349;
        }
      }
      uint64_t v221 = v17 + 40;
      while (1)
      {
        if (v20) {
          uint64_t v21 = v20 - 24;
        }
        else {
          uint64_t v21 = 0;
        }
        if (!v20 || *(unsigned char *)(v21 + 16) != 83) {
          goto LABEL_46;
        }
        uint64_t v22 = v234;
        uint64_t v23 = HIDWORD(v235);
        if (v234 != v233)
        {
          unsigned int v27 = v235;
          goto LABEL_25;
        }
        if (!HIDWORD(v235)) {
          break;
        }
        uint64_t v24 = 0;
        uint64_t v25 = 8 * HIDWORD(v235);
        int v26 = (uint64_t *)v234;
        while (*v26 != v21)
        {
          if (*v26 == -2) {
            uint64_t v24 = v26;
          }
          ++v26;
          v25 -= 8;
          if (!v25)
          {
            if (!v24) {
              goto LABEL_22;
            }
            uint64_t *v24 = v21;
            --v236;
            break;
          }
        }
LABEL_46:
        if (*(void *)(v21 + 8))
        {
          uint64_t v37 = v13[5];
          unsigned int v38 = v13[6];
          if (v37 != v38)
          {
            uint64_t v40 = *(unsigned char **)v13;
            uint64_t v39 = (unsigned char *)*((void *)v13 + 1);
            if (v39 == *(unsigned char **)v13)
            {
              unsigned int v41 = &v39[8 * v37];
              if (v37)
              {
                uint64_t v42 = 0;
                while (*(void *)&v39[v42] != v21)
                {
                  v42 += 8;
                  if (8 * v37 == v42) {
                    goto LABEL_91;
                  }
                }
                unsigned int v41 = &v39[v42];
              }
LABEL_91:
              uint64_t v40 = (unsigned char *)*((void *)v13 + 1);
            }
            else
            {
              uint64_t v61 = *v224;
              int v62 = v61 - 1;
              unsigned int v63 = (v61 - 1) & ((v21 >> 4) ^ (v21 >> 9));
              unsigned int v41 = &v39[8 * v63];
              uint64_t v64 = *v41;
              if (*v41 == -1)
              {
                char v65 = 0;
LABEL_301:
                if (v65) {
                  unsigned int v41 = v65;
                }
                if (*v41 != v21) {
                  unsigned int v41 = &v39[8 * v61];
                }
              }
              else
              {
                char v65 = 0;
                int v66 = 1;
                while (v64 != v21)
                {
                  if (v65) {
                    BOOL v67 = 0;
                  }
                  else {
                    BOOL v67 = v64 == -2;
                  }
                  if (v67) {
                    char v65 = v41;
                  }
                  unsigned int v68 = v63 + v66++;
                  unsigned int v63 = v68 & v62;
                  unsigned int v41 = &v39[8 * (v68 & v62)];
                  uint64_t v64 = *v41;
                  if (*v41 == -1) {
                    goto LABEL_301;
                  }
                }
              }
            }
            BOOL v34 = v39 == v40;
            unsigned int v69 = v223;
            if (!v34) {
              unsigned int v69 = v224;
            }
            if (v41 == (void *)&v39[8 * *v69]) {
              goto LABEL_318;
            }
          }
          v225[0] = v218;
          v225[1] = a5;
          v225[2] = a2;
          v225[3] = a4;
          __int16 v226 = 257;
          int v227 = *(_DWORD *)&v247[66];
          __int16 v228 = v248;
          v225[4] = v21;
          int v70 = *(_DWORD *)(v21 + 20);
          if ((v70 & 0x40000000) != 0)
          {
            unsigned int v72 = *(uint64_t **)(v21 - 8);
            unint64_t v71 = v70 & 0x7FFFFFF;
          }
          else
          {
            unint64_t v71 = v70 & 0x7FFFFFF;
            unsigned int v72 = (uint64_t *)(v21 - 32 * v71);
          }
          unint64_t v254 = (unint64_t)v256;
          uint64_t v255 = 0x800000000;
          if (v71 >= 9) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          if (v71)
          {
            uint64_t v73 = 32 * v71;
            int v74 = v256;
            do
            {
              uint64_t v75 = *v72;
              v72 += 4;
              *v74++ = v75;
              v73 -= 32;
            }
            while (v73);
            unsigned int v76 = (void *)v254;
          }
          else
          {
            unsigned int v76 = v256;
          }
          LODWORD(v255) = v71;
          uint64_t v77 = llvm::SimplifyInstructionWithOperands((llvm *)v21, (uint64_t)v76, v71, (uint64_t)v225, v10, v11, v12);
          if ((void *)v254 == v256)
          {
            if (!v77) {
              goto LABEL_316;
            }
          }
          else
          {
            free((void *)v254);
            if (!v77)
            {
LABEL_316:
              int v13 = (unsigned int *)v222;
              goto LABEL_317;
            }
          }
          int v13 = (unsigned int *)v222;
          if (*((unsigned __int8 *)v77 + 16) >= 0x1Cu)
          {
            uint64_t v149 = *((void *)v77 + 5);
            uint64_t v150 = *(void *)(v21 + 40);
            if (v149 != v150)
            {
              int v151 = *((_DWORD *)v212 + 4);
              if (v151)
              {
                uint64_t v152 = *(void *)v212;
                unsigned int v153 = v151 - 1;
                LODWORD(v154) = v153 & ((v149 >> 4) ^ (v149 >> 9));
                uint64_t v155 = (uint64_t *)(*(void *)v212 + 16 * v154);
                uint64_t v156 = *v155;
                if (v149 == *v155)
                {
                  uint64_t v159 = (void *)v155[1];
                  if (v159)
                  {
LABEL_310:
                    uint64_t v178 = v153 & ((v150 >> 4) ^ (v150 >> 9));
                    uint64_t v179 = *(void *)(v152 + 16 * v178);
                    if (v150 == v179)
                    {
LABEL_314:
                      uint64_t v182 = *(void **)(v152 + 16 * v178 + 8);
                      goto LABEL_322;
                    }
                    int v180 = 1;
                    while (v179 != -4096)
                    {
                      int v181 = v178 + v180++;
                      uint64_t v178 = v181 & v153;
                      uint64_t v179 = *(void *)(v152 + 16 * v178);
                      if (v150 == v179) {
                        goto LABEL_314;
                      }
                    }
                    uint64_t v182 = 0;
LABEL_322:
                    while (v182 != v159)
                    {
                      if (!v182) {
                        goto LABEL_317;
                      }
                      uint64_t v182 = (void *)*v182;
                    }
                  }
                }
                else
                {
                  int v157 = 1;
                  while (v156 != -4096)
                  {
                    int v158 = v154 + v157++;
                    uint64_t v154 = v158 & v153;
                    uint64_t v156 = *(void *)(v152 + 16 * v154);
                    if (v149 == v156)
                    {
                      uint64_t v159 = *(void **)(v152 + 16 * v154 + 8);
                      if (v159) {
                        goto LABEL_310;
                      }
                      break;
                    }
                  }
                }
              }
            }
          }
          uint64_t v78 = *(void *)(v21 + 8);
          if (v78)
          {
            unsigned int v79 = (void *)((char *)v77 + 8);
            do
            {
              uint64_t v80 = v78;
              uint64_t v81 = v78 + 8;
              uint64_t v78 = *(void *)(v78 + 8);
              uint64_t v82 = *(void *)(v80 + 24);
              if (*(void *)v80)
              {
                **(void **)(v80 + 16) = v78;
                uint64_t v83 = *(void *)(v80 + 8);
                if (v83) {
                  *(void *)(v83 + 16) = *(void *)(v80 + 16);
                }
              }
              *(void *)uint64_t v80 = v77;
              uint64_t v84 = *((void *)v77 + 1);
              *(void *)(v80 + 8) = v84;
              if (v84) {
                *(void *)(v84 + 16) = v81;
              }
              *(void *)(v80 + 16) = v79;
              void *v79 = v80;
              if (*(unsigned char *)(v82 + 16) != 83 || v82 == 0) {
                goto LABEL_188;
              }
              int v86 = v233;
              if (v234 == v233)
              {
                int v87 = HIDWORD(v235);
                uint64_t v88 = &v234[8 * HIDWORD(v235)];
                if (HIDWORD(v235))
                {
                  uint64_t v89 = 0;
                  while (*(void *)&v234[v89] != v82)
                  {
                    v89 += 8;
                    if (8 * HIDWORD(v235) == v89) {
                      goto LABEL_136;
                    }
                  }
                  uint64_t v88 = &v234[v89];
                }
LABEL_136:
                int v86 = v234;
              }
              else
              {
                int v90 = v235 - 1;
                unsigned int v91 = (v235 - 1) & ((v82 >> 4) ^ (v82 >> 9));
                uint64_t v88 = &v234[8 * v91];
                uint64_t v92 = *(void *)v88;
                if (*(void *)v88 == -1)
                {
                  int v93 = 0;
LABEL_222:
                  if (v93) {
                    uint64_t v88 = v93;
                  }
                  int v87 = HIDWORD(v235);
                  if (*(void *)v88 != v82) {
                    uint64_t v88 = &v234[8 * v235];
                  }
                }
                else
                {
                  int v93 = 0;
                  int v94 = 1;
                  while (v92 != v82)
                  {
                    if (v93) {
                      BOOL v95 = 0;
                    }
                    else {
                      BOOL v95 = v92 == -2;
                    }
                    if (v95) {
                      int v93 = v88;
                    }
                    unsigned int v96 = v91 + v94++;
                    unsigned int v91 = v96 & v90;
                    uint64_t v88 = &v234[8 * (v96 & v90)];
                    uint64_t v92 = *(void *)v88;
                    if (*(void *)v88 == -1) {
                      goto LABEL_222;
                    }
                  }
                  int v87 = HIDWORD(v235);
                }
              }
              int v97 = v234 == v86 ? v87 : v235;
              if (v88 == &v234[8 * v97])
              {
LABEL_188:
                if (v37 == v38) {
                  continue;
                }
                uint64_t v104 = *(void *)(v82 + 40);
                uint64_t v106 = *(void *)(a1 + 56);
                uint64_t v105 = *(void *)(a1 + 64);
                if (v105 == v106)
                {
                  uint64_t v107 = *(unsigned int *)(a1 + 76);
                  uint64_t v108 = (void *)(v105 + 8 * v107);
                  if (v107)
                  {
                    uint64_t v109 = 0;
                    while (*(void *)(v105 + v109) != v104)
                    {
                      v109 += 8;
                      if (8 * v107 == v109) {
                        goto LABEL_185;
                      }
                    }
                    uint64_t v108 = (void *)(v105 + v109);
                  }
LABEL_185:
                  uint64_t v106 = *(void *)(a1 + 64);
                }
                else
                {
                  uint64_t v110 = *(unsigned int *)(a1 + 72);
                  int v111 = v110 - 1;
                  unsigned int v112 = (v110 - 1) & ((v104 >> 4) ^ (v104 >> 9));
                  uint64_t v108 = (void *)(v105 + 8 * v112);
                  uint64_t v113 = *v108;
                  if (*v108 == -1)
                  {
                    uint64_t v114 = 0;
LABEL_238:
                    if (v114) {
                      uint64_t v108 = v114;
                    }
                    LODWORD(v107) = *(_DWORD *)(a1 + 76);
                    if (*v108 != v104) {
                      uint64_t v108 = (void *)(v105 + 8 * v110);
                    }
                  }
                  else
                  {
                    uint64_t v114 = 0;
                    int v115 = 1;
                    while (v113 != v104)
                    {
                      if (v114) {
                        BOOL v116 = 0;
                      }
                      else {
                        BOOL v116 = v113 == -2;
                      }
                      if (v116) {
                        uint64_t v114 = v108;
                      }
                      unsigned int v117 = v112 + v115++;
                      unsigned int v112 = v117 & v111;
                      uint64_t v108 = (void *)(v105 + 8 * (v117 & v111));
                      uint64_t v113 = *v108;
                      if (*v108 == -1) {
                        goto LABEL_238;
                      }
                    }
                    LODWORD(v107) = *(_DWORD *)(a1 + 76);
                  }
                }
                unsigned int v126 = *(_DWORD *)(a1 + 72);
                if (v105 == v106) {
                  unsigned int v126 = v107;
                }
                if (v108 == (void *)(v105 + 8 * v126)) {
                  continue;
                }
                uint64_t v98 = (unsigned char *)*((void *)v13 + 1);
                uint64_t v99 = v13[5];
                if (v98 != *(unsigned char **)v13)
                {
                  unsigned int v130 = *v224;
LABEL_201:
                  if (3 * v130 <= 4 * (v99 - v13[6]))
                  {
                    if (v130 >= 0x40) {
                      v130 *= 2;
                    }
                    else {
                      unsigned int v130 = 128;
                    }
                  }
                  else if (v130 - v99 >= v130 >> 3)
                  {
                    goto LABEL_203;
                  }
                  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v13, v130);
                  int v13 = (unsigned int *)v222;
                  unsigned int v130 = *((_DWORD *)v222 + 4);
                  uint64_t v98 = (unsigned char *)*((void *)v222 + 1);
LABEL_203:
                  unsigned int v131 = v130 - 1;
                  unsigned int v132 = (v130 - 1) & ((v82 >> 4) ^ (v82 >> 9));
                  unint64_t v133 = &v98[8 * v132];
                  uint64_t v134 = *v133;
                  if (*v133 != -1)
                  {
                    BOOL v135 = 0;
                    int v136 = 1;
                    while (v134 != v82)
                    {
                      if (v135) {
                        BOOL v137 = 0;
                      }
                      else {
                        BOOL v137 = v134 == -2;
                      }
                      if (v137) {
                        BOOL v135 = v133;
                      }
                      unsigned int v138 = v132 + v136++;
                      unsigned int v132 = v138 & v131;
                      unint64_t v133 = &v98[8 * (v138 & v131)];
                      uint64_t v134 = *v133;
                      if (*v133 == -1) {
                        goto LABEL_228;
                      }
                    }
                    continue;
                  }
                  BOOL v135 = 0;
LABEL_228:
                  if (v135) {
                    int v139 = v135;
                  }
                  else {
                    int v139 = v133;
                  }
                  if (*v139 == v82) {
                    continue;
                  }
                  if (*v139 == -2) {
                    --v13[6];
                  }
                  else {
                    ++*v223;
                  }
LABEL_234:
                  void *v139 = v82;
                  continue;
                }
                if (v99)
                {
                  uint64_t v127 = 0;
                  uint64_t v128 = 8 * v99;
                  uint64_t v129 = (void *)*((void *)v13 + 1);
                  while (*v129 != v82)
                  {
                    if (*v129 == -2) {
                      uint64_t v127 = v129;
                    }
                    ++v129;
                    v128 -= 8;
                    if (!v128)
                    {
                      if (!v127) {
                        goto LABEL_197;
                      }
                      *uint64_t v127 = v82;
                      --v13[6];
                      goto LABEL_235;
                    }
                  }
                  continue;
                }
LABEL_197:
                unsigned int v130 = *v224;
                if (v99 >= *v224) {
                  goto LABEL_201;
                }
                unsigned int *v223 = v99 + 1;
              }
              else
              {
                uint64_t v98 = (unsigned char *)v15[1];
                uint64_t v99 = *((unsigned int *)v15 + 5);
                if (v98 != (unsigned char *)*v15)
                {
                  unsigned int v103 = *((_DWORD *)v15 + 4);
LABEL_170:
                  if (3 * v103 <= 4 * ((int)v99 - *((_DWORD *)v15 + 6)))
                  {
                    if (v103 >= 0x40) {
                      v103 *= 2;
                    }
                    else {
                      unsigned int v103 = 128;
                    }
                  }
                  else if (v103 - v99 >= v103 >> 3)
                  {
LABEL_172:
                    unsigned int v118 = v103 - 1;
                    unsigned int v119 = (v103 - 1) & ((v82 >> 4) ^ (v82 >> 9));
                    int v120 = &v98[8 * v119];
                    uint64_t v121 = *v120;
                    if (*v120 != -1)
                    {
                      uint64_t v122 = 0;
                      int v123 = 1;
                      while (v121 != v82)
                      {
                        if (v122) {
                          BOOL v124 = 0;
                        }
                        else {
                          BOOL v124 = v121 == -2;
                        }
                        if (v124) {
                          uint64_t v122 = v120;
                        }
                        unsigned int v125 = v119 + v123++;
                        unsigned int v119 = v125 & v118;
                        int v120 = &v98[8 * (v125 & v118)];
                        uint64_t v121 = *v120;
                        if (*v120 == -1) {
                          goto LABEL_215;
                        }
                      }
                      continue;
                    }
                    uint64_t v122 = 0;
LABEL_215:
                    if (v122) {
                      int v139 = v122;
                    }
                    else {
                      int v139 = v120;
                    }
                    if (*v139 == v82) {
                      continue;
                    }
                    if (*v139 == -2) {
                      --*((_DWORD *)v15 + 6);
                    }
                    else {
                      ++*((_DWORD *)v15 + 5);
                    }
                    goto LABEL_234;
                  }
                  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v15, v103);
                  int v13 = (unsigned int *)v222;
                  unsigned int v103 = *((_DWORD *)v15 + 4);
                  uint64_t v98 = (unsigned char *)v15[1];
                  goto LABEL_172;
                }
                if (v99)
                {
                  unsigned int v100 = 0;
                  uint64_t v101 = 8 * v99;
                  int v102 = (void *)v15[1];
                  while (*v102 != v82)
                  {
                    if (*v102 == -2) {
                      unsigned int v100 = v102;
                    }
                    ++v102;
                    v101 -= 8;
                    if (!v101)
                    {
                      if (!v100) {
                        goto LABEL_149;
                      }
                      *unsigned int v100 = v82;
                      --*((_DWORD *)v15 + 6);
                      goto LABEL_235;
                    }
                  }
                  continue;
                }
LABEL_149:
                unsigned int v103 = *((_DWORD *)v15 + 4);
                if (v99 >= v103) {
                  goto LABEL_170;
                }
                *((_DWORD *)v15 + 5) = v99 + 1;
              }
              *(void *)&v98[8 * v99] = v82;
LABEL_235:
              ;
            }
            while (v78);
          }
          a5 = v215;
          a6 = v216;
          if (v216)
          {
            if (*((unsigned __int8 *)v77 + 16) >= 0x1Cu)
            {
              __int32 v140 = v214[5].i32[0];
              if (v140)
              {
                int32x2_t v141 = v214[3];
                __int32 v142 = v140 - 1;
                LODWORD(v143) = v142 & ((v21 >> 4) ^ (v21 >> 9));
                uint64_t v144 = (uint64_t *)(*(void *)&v141 + 16 * v143);
                uint64_t v145 = *v144;
                if (v21 == *v144)
                {
                  unint64_t v148 = (llvm::ValueAsMetadata *)v144[1];
                  if (v148)
                  {
LABEL_327:
                    uint64_t v183 = v142 & ((v77 >> 4) ^ (v77 >> 9));
                    int v184 = *(llvm::UndefValue **)(*(void *)&v141 + 16 * v183);
                    if (v77 == v184)
                    {
LABEL_331:
                      uint64_t v187 = *(llvm::Value **)(*(void *)&v141 + 16 * v183 + 8);
                      if (v187)
                      {
                        llvm::Value::doRAUW(v148, v187, (llvm::Value *)1);
                        int v13 = (unsigned int *)v222;
                      }
                    }
                    else
                    {
                      int v185 = 1;
                      while (v184 != (llvm::UndefValue *)-4096)
                      {
                        int v186 = v183 + v185++;
                        uint64_t v183 = v186 & v142;
                        int v184 = *(llvm::UndefValue **)(*(void *)&v141 + 16 * v183);
                        if (v77 == v184) {
                          goto LABEL_331;
                        }
                      }
                    }
                  }
                }
                else
                {
                  int v146 = 1;
                  while (v145 != -4096)
                  {
                    int v147 = v143 + v146++;
                    uint64_t v143 = v147 & v142;
                    uint64_t v145 = *(void *)(*(void *)&v141 + 16 * v143);
                    if (v21 == v145)
                    {
                      unint64_t v148 = *(llvm::ValueAsMetadata **)(*(void *)&v141 + 16 * v143 + 8);
                      if (!v148) {
                        break;
                      }
                      goto LABEL_327;
                    }
                  }
                }
              }
            }
          }
          if (*(void *)(v21 + 8))
          {
            char v217 = 1;
LABEL_317:
            uint64_t v19 = v221;
            goto LABEL_318;
          }
          uint64_t v19 = v221;
          if (llvm::wouldInstructionBeTriviallyDead(v21, v215))
          {
            unint64_t v254 = 6;
            uint64_t v255 = 0;
            v256[0] = v21;
            if (v21 != -8192 && v21 != -4096 && v21) {
              llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v254);
            }
            uint64_t v160 = v251;
            if (v252 >= HIDWORD(v252))
            {
              unint64_t v189 = v252 + 1;
              if (v251 <= (char *)&v254 && &v251[24 * v252] > (char *)&v254)
              {
                uint64_t v191 = (char *)&v254 - v251;
                sub_1CC261F80((unsigned int *)&v251, v189);
                uint64_t v160 = v251;
                uint64_t v161 = &v251[v191];
              }
              else
              {
                sub_1CC261F80((unsigned int *)&v251, v189);
                uint64_t v161 = (char *)&v254;
                uint64_t v160 = v251;
              }
            }
            else
            {
              uint64_t v161 = (char *)&v254;
            }
            int v13 = (unsigned int *)v222;
            int v162 = v252;
            uint64_t v163 = (unint64_t *)&v160[24 * v252];
            unint64_t *v163 = 6;
            v163[1] = 0;
            unint64_t v164 = *((void *)v161 + 2);
            v163[2] = v164;
            if (v164 != -8192 && v164 != -4096)
            {
              if (v164)
              {
                unint64_t v165 = *(void *)v161 & 0xFFFFFFFFFFFFFFF8;
                v163[1] = *(void *)v165;
                *(void *)unint64_t v165 = v163;
                unint64_t *v163 = v165 | 6;
                unint64_t v166 = (unint64_t *)v163[1];
                if (v166) {
                  *unint64_t v166 = *v166 & 7 | (unint64_t)(v163 + 1);
                }
              }
            }
            LODWORD(v252) = v162 + 1;
            if (v256[0] != -8192 && v256[0] != -4096 && v256[0])
            {
              unint64_t v167 = v254 & 0xFFFFFFFFFFFFFFF8;
              *(void *)(v254 & 0xFFFFFFFFFFFFFFF8) = v255;
              if (v255)
              {
                *(void *)uint64_t v255 = *(void *)v255 & 7 | v167;
              }
              else
              {
                uint64_t v168 = v256[0];
                uint64_t v169 = ***(int32x2_t ****)v256[0];
                unint64_t v170 = (unint64_t)v169[303];
                if (v170 <= v167)
                {
                  uint64_t v171 = v169[305].u32[0];
                  if (v170 + 16 * v171 > v167)
                  {
                    unsigned int v172 = v171 - 1;
                    LODWORD(v173) = v172 & ((LODWORD(v256[0]) >> 4) ^ (LODWORD(v256[0]) >> 9));
                    unsigned int v174 = (uint64_t *)(v170 + 16 * v173);
                    uint64_t v175 = *v174;
                    if (v256[0] == *v174)
                    {
LABEL_298:
                      uint64_t *v174 = -8192;
                      v169[304] = vadd_s32(v169[304], (int32x2_t)0x1FFFFFFFFLL);
                      uint64_t v168 = v256[0];
                    }
                    else
                    {
                      int v176 = 1;
                      while (v175 != -4096)
                      {
                        int v177 = v173 + v176++;
                        uint64_t v173 = v177 & v172;
                        uint64_t v175 = *(void *)(v170 + 16 * v173);
                        if (v256[0] == v175)
                        {
                          unsigned int v174 = (uint64_t *)(v170 + 16 * v173);
                          goto LABEL_298;
                        }
                      }
                    }
                    *(unsigned char *)(v168 + 17) &= ~1u;
                  }
                }
              }
            }
            char v217 = 1;
            goto LABEL_318;
          }
          char v217 = 1;
        }
        else if (llvm::wouldInstructionBeTriviallyDead(v21, a5))
        {
          unint64_t v254 = 6;
          uint64_t v255 = 0;
          v256[0] = v21;
          int v13 = (unsigned int *)v222;
          if (v21 != -8192 && v21 != -4096 && v21)
          {
            llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v254);
            int v13 = (unsigned int *)v222;
          }
          uint64_t v43 = v251;
          if (v252 >= HIDWORD(v252))
          {
            unint64_t v188 = v252 + 1;
            if (v251 <= (char *)&v254 && &v251[24 * v252] > (char *)&v254)
            {
              uint64_t v190 = (char *)&v254 - v251;
              sub_1CC261F80((unsigned int *)&v251, v188);
              uint64_t v43 = v251;
              int v44 = &v251[v190];
            }
            else
            {
              sub_1CC261F80((unsigned int *)&v251, v188);
              int v44 = (char *)&v254;
              uint64_t v43 = v251;
            }
            int v13 = (unsigned int *)v222;
          }
          else
          {
            int v44 = (char *)&v254;
          }
          int v45 = v252;
          unint64_t v46 = (unint64_t *)&v43[24 * v252];
          *unint64_t v46 = 6;
          v46[1] = 0;
          unint64_t v47 = *((void *)v44 + 2);
          v46[2] = v47;
          if (v47 != -8192 && v47 != -4096)
          {
            if (v47)
            {
              unint64_t v48 = *(void *)v44 & 0xFFFFFFFFFFFFFFF8;
              v46[1] = *(void *)v48;
              *(void *)unint64_t v48 = v46;
              *unint64_t v46 = v48 | 6;
              char v49 = (unint64_t *)v46[1];
              if (v49) {
                unint64_t *v49 = *v49 & 7 | (unint64_t)(v46 + 1);
              }
            }
          }
          LODWORD(v252) = v45 + 1;
          if (v256[0] != -8192 && v256[0] != -4096 && v256[0])
          {
            unint64_t v50 = v254 & 0xFFFFFFFFFFFFFFF8;
            *(void *)(v254 & 0xFFFFFFFFFFFFFFF8) = v255;
            if (v255)
            {
              *(void *)uint64_t v255 = *(void *)v255 & 7 | v50;
            }
            else
            {
              uint64_t v51 = v256[0];
              uint64_t v52 = ***(int32x2_t ****)v256[0];
              unint64_t v53 = (unint64_t)v52[303];
              if (v53 <= v50)
              {
                uint64_t v54 = v52[305].u32[0];
                if (v53 + 16 * v54 > v50)
                {
                  unsigned int v55 = v54 - 1;
                  LODWORD(v56) = v55 & ((LODWORD(v256[0]) >> 4) ^ (LODWORD(v256[0]) >> 9));
                  uint64_t v57 = (uint64_t *)(v53 + 16 * v56);
                  uint64_t v58 = *v57;
                  if (v256[0] == *v57)
                  {
LABEL_77:
                    *uint64_t v57 = -8192;
                    v52[304] = vadd_s32(v52[304], (int32x2_t)0x1FFFFFFFFLL);
                    uint64_t v51 = v256[0];
                  }
                  else
                  {
                    int v59 = 1;
                    while (v58 != -4096)
                    {
                      int v60 = v56 + v59++;
                      uint64_t v56 = v60 & v55;
                      uint64_t v58 = *(void *)(v53 + 16 * v56);
                      if (v256[0] == v58)
                      {
                        uint64_t v57 = (uint64_t *)(v53 + 16 * v56);
                        goto LABEL_77;
                      }
                    }
                  }
                  *(unsigned char *)(v51 + 17) &= ~1u;
                }
              }
            }
          }
          goto LABEL_318;
        }
        int v13 = (unsigned int *)v222;
LABEL_318:
        uint64_t v20 = *(void *)(v20 + 8);
        if (v20 == v19) {
          goto LABEL_348;
        }
      }
LABEL_22:
      unsigned int v27 = v235;
      if (HIDWORD(v235) < v235)
      {
        ++HIDWORD(v235);
        *(void *)&v234[8 * v23] = v21;
        goto LABEL_46;
      }
LABEL_25:
      if (3 * v27 <= 4 * (HIDWORD(v235) - v236))
      {
        if (v27 >= 0x40) {
          v27 *= 2;
        }
        else {
          unsigned int v27 = 128;
        }
      }
      else if (v27 - HIDWORD(v235) >= v27 >> 3)
      {
        goto LABEL_27;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v233, v27);
      int v13 = (unsigned int *)v222;
      unsigned int v27 = v235;
      uint64_t v22 = v234;
LABEL_27:
      unsigned int v28 = v27 - 1;
      unsigned int v29 = (v27 - 1) & ((v21 >> 4) ^ (v21 >> 9));
      uint64_t v30 = &v22[8 * v29];
      uint64_t v31 = *(void *)v30;
      if (*(void *)v30 == -1)
      {
        int v32 = 0;
LABEL_39:
        if (v32) {
          uint64_t v36 = v32;
        }
        else {
          uint64_t v36 = (uint64_t *)v30;
        }
        if (*v36 != v21)
        {
          if (*v36 == -2) {
            --v236;
          }
          else {
            ++HIDWORD(v235);
          }
          *uint64_t v36 = v21;
        }
      }
      else
      {
        int v32 = 0;
        int v33 = 1;
        while (v31 != v21)
        {
          if (v32) {
            BOOL v34 = 0;
          }
          else {
            BOOL v34 = v31 == -2;
          }
          if (v34) {
            int v32 = (uint64_t *)v30;
          }
          unsigned int v35 = v29 + v33++;
          unsigned int v29 = v35 & v28;
          uint64_t v30 = &v22[8 * (v35 & v28)];
          uint64_t v31 = *(void *)v30;
          if (*(void *)v30 == -1) {
            goto LABEL_39;
          }
        }
      }
      goto LABEL_46;
    }
LABEL_349:
    if (v252)
    {
      unsigned int v250 = 0;
      llvm::RecursivelyDeleteTriviallyDeadInstructions((unsigned int *)&v251, a5, a6, (uint64_t)v249);
      if (v250 == v249)
      {
        (*(void (**)(void *))(v249[0] + 32))(v249);
      }
      else if (v250)
      {
        (*(void (**)(void))(*v250 + 40))();
      }
      char v217 = 1;
      int v13 = (unsigned int *)v222;
    }
    if (*((_DWORD *)v15 + 5) == *((_DWORD *)v15 + 6)) {
      break;
    }
    uint64_t v192 = (unsigned char *)*((void *)v13 + 1);
    if (v192 == *(unsigned char **)v13) {
      goto LABEL_357;
    }
    uint64_t v209 = v13[4];
    if (v209 < 0x21 || 4 * (v13[5] - v13[6]) >= v209)
    {
      memset(v192, 255, 8 * v209);
      int v13 = (unsigned int *)v222;
LABEL_357:
      v13[5] = 0;
      v13[6] = 0;
      goto LABEL_358;
    }
    llvm::SmallPtrSetImplBase::shrink_and_clear((void **)v13);
    int v13 = (unsigned int *)v222;
LABEL_358:
    if (v234 == v233) {
      goto LABEL_359;
    }
    if (v235 < 0x21 || 4 * (HIDWORD(v235) - v236) >= v235)
    {
      memset(v234, 255, 8 * v235);
      int v13 = (unsigned int *)v222;
LABEL_359:
      HIDWORD(v235) = 0;
      int v236 = 0;
      goto LABEL_360;
    }
    llvm::SmallPtrSetImplBase::shrink_and_clear((void **)&v233);
    int v13 = (unsigned int *)v222;
LABEL_360:
    if (v252)
    {
      uint64_t v193 = v251;
      uint64_t v194 = &v251[24 * v252];
      do
      {
        uint64_t v195 = *((void *)v194 - 1);
        if (v195 != -8192 && v195 != -4096 && v195 != 0)
        {
          unint64_t v197 = *((void *)v194 - 3) & 0xFFFFFFFFFFFFFFF8;
          *(void *)unint64_t v197 = *((void *)v194 - 2);
          uint64_t v198 = (unint64_t *)*((void *)v194 - 2);
          if (v198)
          {
            unint64_t *v198 = *v198 & 7 | v197;
          }
          else
          {
            uint64_t v199 = *((void *)v194 - 1);
            uint64_t v200 = ***(int32x2_t ****)v199;
            unint64_t v201 = (unint64_t)v200[303];
            if (v201 <= v197)
            {
              uint64_t v202 = v200[305].u32[0];
              if (v201 + 16 * v202 > v197)
              {
                unsigned int v203 = v202 - 1;
                LODWORD(v204) = v203 & ((v199 >> 4) ^ (v199 >> 9));
                uint64_t v205 = (uint64_t *)(v201 + 16 * v204);
                uint64_t v206 = *v205;
                if (v199 == *v205)
                {
LABEL_378:
                  *uint64_t v205 = -8192;
                  v200[304] = vadd_s32(v200[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v199 = *((void *)v194 - 1);
                }
                else
                {
                  int v207 = 1;
                  while (v206 != -4096)
                  {
                    int v208 = v204 + v207++;
                    uint64_t v204 = v208 & v203;
                    uint64_t v206 = *(void *)(v201 + 16 * v204);
                    if (v199 == v206)
                    {
                      uint64_t v205 = (uint64_t *)(v201 + 16 * v204);
                      goto LABEL_378;
                    }
                  }
                }
                *(unsigned char *)(v199 + 17) &= ~1u;
              }
            }
          }
        }
        v194 -= 24;
      }
      while (v194 != v193);
    }
    LODWORD(v252) = 0;
    uint64_t v14 = v13;
    int v13 = (unsigned int *)v15;
  }
  if (__p)
  {
    int v232 = __p;
    operator delete(__p);
  }
  MEMORY[0x1D25D9CD0](v230, 8);
  sub_1CC45E8E8(&v251);
  if (v234 != v233) {
    free(v234);
  }
  if (v239 != v238) {
    free(v239);
  }
  if (v244 != v243) {
    free(v244);
  }
  return v217 & 1;
}

void sub_1CCDD2874(llvm *a1)
{
  llvm::initializeAssumptionCacheTrackerPass((uint64_t)a1);
  llvm::initializeLoopPassPass(a1, v2);
  llvm::initializeMemorySSAWrapperPassPass(a1, v3);
  llvm::initializeTargetLibraryInfoWrapperPassPass((uint64_t)a1);
  operator new();
}

uint64_t sub_1CCDD292C(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF44D8;
  *(_DWORD *)(a1 + 24) = 1;
  *(void *)a1 = &unk_1F263EDC8;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF44E0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCDD2874;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCF44E0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CCDD29DC()
{
}

void sub_1CCDD2A1C(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCDD2A54(uint64_t a1, llvm *a2)
{
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::AssumptionCacheTracker::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::TargetLibraryInfoWrapperPass::ID);
  v6[0] = &unk_1F2617E40;
  v6[1] = (char *)a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v3);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v6);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::MemorySSAWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::MemorySSAWrapperPass::ID);

  llvm::getLoopAnalysisUsage(a2, v5);
}

uint64_t sub_1CCDD2B28(llvm::LoopPass *a1, const llvm::Loop *a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if ((llvm::LoopPass::skipLoop(a1, a2) & 1) == 0)
  {
    uint64_t v4 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1];
    if (v5 == v6)
    {
LABEL_6:
      uint64_t v7 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v5 != &llvm::DominatorTreeWrapperPass::ID)
      {
        v5 += 16;
        if (v5 == v6) {
          goto LABEL_6;
        }
      }
      uint64_t v7 = *(void *)(v5 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::DominatorTreeWrapperPass::ID);
    long long v8 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v9 = *v8;
    uint64_t v10 = v8[1];
    if (v9 == v10)
    {
LABEL_11:
      uint64_t v11 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v9 != &llvm::LoopInfoWrapperPass::ID)
      {
        v9 += 16;
        if (v9 == v10) {
          goto LABEL_11;
        }
      }
      uint64_t v11 = *(void *)(v9 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v11 + 96))(v11, &llvm::LoopInfoWrapperPass::ID);
    uint64_t v12 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v13 = *v12;
    uint64_t v14 = v12[1];
    if (v13 == v14)
    {
LABEL_16:
      uint64_t v15 = 0;
    }
    else
    {
      while (*(char **)v13 != llvm::AssumptionCacheTracker::ID)
      {
        v13 += 16;
        if (v13 == v14) {
          goto LABEL_16;
        }
      }
      uint64_t v15 = *(void *)(v13 + 8);
    }
    uint64_t v16 = (llvm::AssumptionCacheTracker *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v15 + 96))(v15, llvm::AssumptionCacheTracker::ID);
    llvm::AssumptionCacheTracker::getAssumptionCache(v16, *(llvm::Function **)(**((void **)a2 + 4) + 56));
    uint64_t v17 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v18 = *v17;
    uint64_t v19 = v17[1];
    if (v18 == v19)
    {
LABEL_21:
      uint64_t v20 = 0;
    }
    else
    {
      while (*(char **)v18 != llvm::TargetLibraryInfoWrapperPass::ID)
      {
        v18 += 16;
        if (v18 == v19) {
          goto LABEL_21;
        }
      }
      uint64_t v20 = *(void *)(v18 + 8);
    }
    uint64_t v21 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v20 + 96))(v20, llvm::TargetLibraryInfoWrapperPass::ID);
    uint64_t v22 = v21 + 32;
    if (!*(unsigned char *)(v21 + 232))
    {
      uint64_t v24 = *(void *)(*(void *)(**((void **)a2 + 4) + 56) + 40) + 216;
      __int16 v27 = 260;
      v26[0] = v24;
      llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v26);
      uint64_t v37 = 0;
      uint64_t v38 = 0;
      int v39 = 0;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      *(void *)&long long v25 = -1;
      *((void *)&v25 + 1) = -1;
      *(_OWORD *)__src = v25;
      long long v31 = v25;
      long long v32 = v25;
      long long v33 = v25;
      long long v34 = v25;
      long long v35 = v25;
      *(_OWORD *)uint64_t v36 = v25;
      *(void *)&v36[13] = -1;
      sub_1CC153974((uint64_t)__src, (int *)__p);
      sub_1CD4D04B8(v22, (uint64_t)__src);
      sub_1CD4CFA4C((uint64_t *)__src);
      if (v29 < 0) {
        operator delete(__p[0]);
      }
    }
    sub_1CC1569E8(__src, v22);
  }
  return 0;
}

void sub_1CCDD3104(llvm *a1, llvm::PassRegistry *a2)
{
  llvm::initializeLoopPassPass(a1, a2);
  llvm::initializeDependenceAnalysisWrapperPassPass(a1, v3);
  llvm::initializeOptimizationRemarkEmitterWrapperPassPass(a1, v4);
  operator new();
}

uint64_t sub_1CCDD31B4(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF45A8;
  *(_DWORD *)(a1 + 24) = 1;
  *(void *)a1 = &unk_1F263EE78;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF45B0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCDD3104;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCF45B0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CCDD3264()
{
}

void sub_1CCDD32A4(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCDD32DC(uint64_t a1, llvm *a2)
{
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::DependenceAnalysisWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::OptimizationRemarkEmitterWrapperPass::ID);

  llvm::getLoopAnalysisUsage(a2, v3);
}

uint64_t sub_1CCDD3334(llvm::LoopPass *a1, const llvm::Loop *a2)
{
  char v2 = a2;
  v42[8] = *MEMORY[0x1E4F143B8];
  if (llvm::LoopPass::skipLoop(a1, a2)) {
    return 0;
  }
  uint64_t v4 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_5:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(char **)v5 != llvm::ScalarEvolutionWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_5;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v7 + 96))(v7, llvm::ScalarEvolutionWrapperPass::ID);
  uint64_t v9 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v10 = *v9;
  uint64_t v11 = v9[1];
  if (v10 == v11)
  {
LABEL_10:
    uint64_t v12 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v10 != &llvm::LoopInfoWrapperPass::ID)
    {
      v10 += 16;
      if (v10 == v11) {
        goto LABEL_10;
      }
    }
    uint64_t v12 = *(void *)(v10 + 8);
  }
  uint64_t v13 = *(llvm::ScalarEvolution **)(v8 + 32);
  uint64_t v14 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v12 + 96))(v12, &llvm::LoopInfoWrapperPass::ID);
  uint64_t v15 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v16 = *v15;
  uint64_t v17 = v15[1];
  if (v16 == v17)
  {
LABEL_15:
    uint64_t v18 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v16 != &llvm::DependenceAnalysisWrapperPass::ID)
    {
      v16 += 16;
      if (v16 == v17) {
        goto LABEL_15;
      }
    }
    uint64_t v18 = *(void *)(v16 + 8);
  }
  uint64_t v19 = (llvm::ScalarEvolution *)(v14 + 32);
  uint64_t v20 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v18 + 96))(v18, &llvm::DependenceAnalysisWrapperPass::ID);
  uint64_t v21 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v22 = *v21;
  uint64_t v23 = v21[1];
  if (v22 == v23)
  {
LABEL_20:
    uint64_t v24 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v22 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v22 += 16;
      if (v22 == v23) {
        goto LABEL_20;
      }
    }
    uint64_t v24 = *(void *)(v22 + 8);
  }
  long long v25 = *(llvm::ScalarEvolution **)(v20 + 32);
  int v26 = (llvm::ScalarEvolution *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v24 + 96))(v24, &llvm::DominatorTreeWrapperPass::ID)+ 32);
  __int16 v27 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v28 = *v27;
  uint64_t v29 = v27[1];
  if (v28 == v29)
  {
LABEL_25:
    uint64_t v30 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v28 != &llvm::OptimizationRemarkEmitterWrapperPass::ID)
    {
      v28 += 16;
      if (v28 == v29) {
        goto LABEL_25;
      }
    }
    uint64_t v30 = *(void *)(v28 + 8);
  }
  long long v31 = *(llvm::ScalarEvolution **)((*(uint64_t (**)(uint64_t, void *))(*(void *)v30 + 96))(v30, &llvm::OptimizationRemarkEmitterWrapperPass::ID)+ 32);
  v39[0] = v13;
  v39[1] = v19;
  v39[2] = v25;
  v39[3] = v26;
  v39[4] = v31;
  if (*(void *)v2) {
    return 0;
  }
  long long v40 = v42;
  uint64_t v41 = 0x800000000;
  uint64_t v34 = *((void *)v2 + 1);
  uint64_t v35 = *((void *)v2 + 2);
  uint64_t v36 = (const llvm::Loop ***)((char *)v2 + 8);
  if (v34 == v35)
  {
    unsigned int v37 = 0;
  }
  else
  {
    unsigned int v37 = 0;
    do
    {
      if (v35 - v34 != 8)
      {
        int v38 = 0;
        goto LABEL_41;
      }
      if (v37 >= HIDWORD(v41)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v40 + v37) = v2;
      unsigned int v37 = v41 + 1;
      LODWORD(v41) = v41 + 1;
      char v2 = **v36;
      uint64_t v36 = (const llvm::Loop ***)((char *)v2 + 8);
      uint64_t v34 = *((void *)v2 + 1);
      uint64_t v35 = *((void *)v2 + 2);
    }
    while (v34 != v35);
    if (v37 >= HIDWORD(v41)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
  }
  *((void *)v40 + v37) = v2;
  int v38 = v41 + 1;
LABEL_41:
  LODWORD(v41) = v38;
  uint64_t v32 = sub_1CCDD36F0(v39, (uint64_t)&v40);
  if (v40 != v42) {
    free(v40);
  }
  return v32;
}

uint64_t sub_1CCDD36F0(llvm::ScalarEvolution **a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)(a2 + 8) - 11) >= 0xFFFFFFF7)
  {
    uint64_t v3 = **(const llvm::Loop ***)a2;
    uint64_t v4 = *a1;
    BackedgeTakenInfo = llvm::ScalarEvolution::getBackedgeTakenInfo(*a1, v3);
    if (*(_WORD *)(llvm::ScalarEvolution::BackedgeTakenInfo::getExact((uint64_t)BackedgeTakenInfo, (uint64_t)v3, (uint64_t)v4)+ 24) != 15)llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getNumBackEdges(); {
  }
    }
  return 0;
}

uint64_t sub_1CCDD40EC(uint64_t a1, llvm::Loop *this, void *a3, int a4, unsigned int a5, void *a6)
{
  v115[34] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(llvm::ScalarEvolution **)a1;
  uint64_t v7 = *(uint64_t ****)(a1 + 32);
  v69[3] = a3;
  int v70 = this;
  unint64_t v71 = v6;
  unsigned int v72 = v7;
  uint64_t v73 = v77;
  int v74 = v77;
  uint64_t v75 = 4;
  int v76 = 0;
  uint64_t v78 = v80;
  uint64_t v79 = 0x800000000;
  uint64_t v8 = -1431655765 * ((a6[1] - *a6) >> 3);
  if (v8)
  {
    uint64_t v9 = 0;
    while (1)
    {
      uint64_t v10 = *(unsigned __int8 **)(*a6 + 24 * v9);
      int v11 = v10[a4];
      if (v11 == 42) {
        break;
      }
      int v12 = v10[a5];
      if (v12 == 42) {
        break;
      }
      unsigned int v13 = 0;
      do
      {
        int v14 = v10[v13];
        if (v14 == 60) {
          break;
        }
        if (v14 == 62) {
          goto LABEL_22;
        }
        ++v13;
      }
      while (v13 <= a5);
      if (v11 != v12)
      {
        if ((v11 - 60) > 0x17) {
          break;
        }
        if (((1 << (v11 - 60)) & 0x802003) == 0)
        {
          if (v11 != 62 || !a5) {
            break;
          }
          uint64_t v15 = a5;
          while (1)
          {
            int v16 = *v10++;
            int v17 = (1 << (v16 - 61)) & 0x401001;
            if ((v16 - 61) > 0x16 || v17 == 0) {
              break;
            }
            if (!--v15) {
              goto LABEL_22;
            }
          }
        }
      }
      if (++v9 == v8) {
        goto LABEL_29;
      }
    }
LABEL_22:
    uint64_t v19 = *(void *)***v7;
    if (!*(void *)(v19 + 128))
    {
      if (!(*(unsigned int (**)(void))(**(void **)(v19 + 72) + 48))(*(void *)(v19 + 72))) {
        goto LABEL_24;
      }
      this = v70;
    }
    llvm::Loop::getStartLoc(this);
  }
LABEL_29:
  uint64_t v22 = (llvm::BasicBlock **)a3[4];
  uint64_t v21 = (llvm::BasicBlock **)a3[5];
  uint64_t v23 = this;
  if (v21 != v22)
  {
    while (1)
    {
      llvm::BasicBlock::instructionsWithoutDebug(*v22, 1, (uint64_t)&v84);
      long long v90 = v84;
      if (v86)
      {
        if (v86 == &v85)
        {
          uint64_t v92 = &v91;
          (*(void (**)(uint64_t *, uint64_t *))(v85 + 24))(&v85, &v91);
        }
        else
        {
          uint64_t v92 = (uint64_t *)(*(uint64_t (**)(void))(*v86 + 16))();
        }
      }
      else
      {
        uint64_t v92 = 0;
      }
      long long v81 = v87;
      if (v89)
      {
        if (v89 == v88)
        {
          uint64_t v83 = &v82;
          (*((void (**)(uint64_t ***, llvm::ScalarEvolution **))v88[0] + 3))(v88, &v82);
        }
        else
        {
          uint64_t v83 = (llvm::ScalarEvolution **)((uint64_t (*)(void))(*v89)[2])();
        }
      }
      else
      {
        uint64_t v83 = 0;
      }
      uint64_t v24 = v90;
LABEL_41:
      if (v24 == (void)v81)
      {
        char v34 = 1;
      }
      else
      {
        uint64_t v25 = v24 - 24;
        if (!v24) {
          uint64_t v25 = 0;
        }
        int v26 = *(unsigned __int8 *)(v25 + 16);
        if (v26 == 84) {
          __int16 v27 = (uint64_t *)v25;
        }
        else {
          __int16 v27 = 0;
        }
        if (!v24
          || v26 != 84
          || (uint64_t v28 = v27[8]) != 0 && ((*(unsigned char *)(v28 + 20) & 4) != 0 || (*(unsigned char *)(v28 + 17) & 0x10) != 0)
          || ((LODWORD(v93) = 7, !sub_1CC5CB59C((uint64_t)v27, (__int32 *)&v93, 1uLL))
           || (uint64_t v31 = *(v27 - 4)) != 0
           && !*(unsigned char *)(v31 + 16)
           && *(void *)(v31 + 24) == v27[9]
           && *(_DWORD *)(v31 + 36) == 7)
          && ((llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)v27, 66) & 1) != 0
           || (llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)v27, 44) & 1) != 0))
        {
          uint64_t v29 = *((void *)&v90 + 1);
          uint64_t v24 = *(void *)(v90 + 8);
          *(void *)&long long v90 = v24;
          while (1)
          {
            if (v24 == v29) {
              goto LABEL_41;
            }
            if (!v92) {
              break;
            }
            char v30 = (*(uint64_t (**)(void))(*v92 + 48))();
            uint64_t v24 = v90;
            if (v30) {
              goto LABEL_41;
            }
            uint64_t v24 = *(void *)(v90 + 8);
            *(void *)&long long v90 = v24;
            uint64_t v29 = *((void *)&v90 + 1);
          }
          sub_1CB920400();
          if (v100 != &v102) {
            free(v100);
          }
          if ((void)v81)
          {
            int v58 = *(unsigned __int8 *)v81;
            if ((v58 - 4) > 0x1E)
            {
              if ((v58 - 3) >= 0xFFFFFFFE) {
                uint64_t v62 = v81;
              }
              else {
                uint64_t v62 = 0;
              }
              if ((v58 - 3) >= 0xFFFFFFFE)
              {
                unint64_t v63 = v62 + 8;
                goto LABEL_170;
              }
              if (v58 == 3) {
                *(void *)(v81 + 8) = 0;
              }
            }
            else if ((*(unsigned char *)(v81 + 1) & 0x7F) == 2 || *(_DWORD *)(v81 + 12))
            {
              uint64_t v64 = *(void *)(v81 + 16);
              if ((v64 & 4) != 0)
              {
                unint64_t v63 = v64 & 0xFFFFFFFFFFFFFFF8;
                if (v63)
                {
LABEL_170:
                  *(void *)&long long v90 = &v81;
                  sub_1CC5FA668(v63 + 16, &v90);
                }
              }
            }
          }
          llvm::OptimizationRemarkEmitter::emit(v88, (llvm::DiagnosticInfoOptimizationBase *)&v105);
          uint64_t v105 = v27;
          int v59 = (char *)v113;
          if (v114)
          {
            unint64_t v60 = (unint64_t)v114 << 6;
            do
            {
              uint64_t v61 = (void **)&v59[v60];
              if (v59[v60 - 17] < 0) {
                operator delete(*(v61 - 5));
              }
              if (*((char *)v61 - 41) < 0) {
                operator delete(*(v61 - 8));
              }
              v60 -= 64;
            }
            while (v60);
            int v59 = (char *)v113;
          }
          if (v59 != (char *)7) {
            free(v59);
          }
          goto LABEL_24;
        }
        uint64_t v32 = v72;
        uint64_t v33 = *(void *)***v72;
        if (*(void *)(v33 + 128)
          || (*(unsigned int (**)(void))(**(void **)(v33 + 72) + 48))(*(void *)(v33 + 72)))
        {
          llvm::DiagnosticLocation::DiagnosticLocation(&v68, (const llvm::DebugLoc *)(v27 + 6));
          llvm::OptimizationRemarkMissed::OptimizationRemarkMissed((uint64_t)&v93, (uint64_t)"loop-interchange", (uint64_t)"CallInst", 8, &v68, v27[5]);
          v69[0] = "Cannot interchange loops due to call instruction.";
          v69[1] = (void *)49;
          sub_1CC59ADEC((uint64_t *)&v100, (uint64_t)v69);
          int v106 = (int)v94;
          char v107 = BYTE4(v94);
          long long v108 = v95;
          uint64_t v109 = v96;
          long long v110 = v97;
          long long v111 = v98;
          uint64_t v112 = v99;
          uint64_t v105 = &unk_1F2616800;
          uint64_t v113 = v115;
          uint64_t v114 = 0x400000000;
          if (v101)
          {
            sub_1CD494D68((uint64_t)&v113, (uint64_t)&v100);
            uint64_t v35 = v101;
          }
          else
          {
            uint64_t v35 = 0;
          }
          v115[32] = v103;
          v115[33] = v104;
          uint64_t v105 = &unk_1F26165A8;
          int v93 = &unk_1F2616800;
          uint64_t v36 = (char *)v100;
          if (v35)
          {
            uint64_t v37 = v35 << 6;
            char v65 = (char *)v100;
            do
            {
              int v38 = (void **)&v36[v37];
              if (v36[v37 - 17] < 0)
              {
                int v66 = &v36[v37];
                operator delete(*(v38 - 5));
                uint64_t v36 = v65;
                int v38 = (void **)v66;
              }
              if (*((char *)v38 - 41) < 0)
              {
                operator delete(*(v38 - 8));
                uint64_t v36 = v65;
              }
              v37 -= 64;
            }
            while (v37);
            uint64_t v36 = (char *)v100;
          }
          if (v36 != (char *)&v102) {
            free(v36);
          }
          llvm::OptimizationRemarkEmitter::emit(v32, (llvm::DiagnosticInfoOptimizationBase *)&v105);
          uint64_t v105 = &unk_1F2616800;
          int v39 = (char *)v113;
          if (v114)
          {
            unint64_t v40 = (unint64_t)v114 << 6;
            BOOL v67 = (char *)v113;
            do
            {
              uint64_t v41 = (void **)&v39[v40];
              if (v39[v40 - 17] < 0)
              {
                operator delete(*(v41 - 5));
                int v39 = v67;
              }
              if (*((char *)v41 - 41) < 0)
              {
                operator delete(*(v41 - 8));
                int v39 = v67;
              }
              v40 -= 64;
            }
            while (v40);
            int v39 = (char *)v113;
          }
          if (v39 != (char *)v115) {
            free(v39);
          }
        }
        char v34 = 0;
      }
      if (v83 == &v82)
      {
        (*((void (**)(llvm::ScalarEvolution **))v82 + 4))(&v82);
      }
      else if (v83)
      {
        (*((void (**)(void))*v83 + 5))();
      }
      if (v92 == &v91)
      {
        (*(void (**)(uint64_t *))(v91 + 32))(&v91);
      }
      else if (v92)
      {
        (*(void (**)(void))(*v92 + 40))();
      }
      if (v89 == v88)
      {
        (*((void (**)(uint64_t ***))v88[0] + 4))(v88);
      }
      else if (v89)
      {
        ((void (*)(void))(*v89)[5])();
      }
      if (v86 == &v85)
      {
        (*(void (**)(uint64_t *))(v85 + 32))(&v85);
      }
      else if (v86)
      {
        (*(void (**)(void))(*v86 + 40))();
      }
      if ((v34 & 1) == 0) {
        goto LABEL_24;
      }
      if (++v22 == v21)
      {
        uint64_t v23 = v70;
        break;
      }
    }
  }
  if (*(void *)(**((void **)v23 + 4) + 40) != **((void **)v23 + 4) + 40)
  {
    uint64_t v42 = *(void *)(**((void **)v23 + 4) + 48);
    unint64_t v43 = v42 - 24;
    uint64_t v44 = v42 ? v42 - 24 : 0;
    if (v42 && *(unsigned char *)(v44 + 16) == 83)
    {
      do
      {
        int v94 = 0;
        *(void *)&long long v95 = 0;
        DWORD2(v95) = 0;
        long long v97 = 0uLL;
        uint64_t v96 = 0;
        int v93 = (void *)6;
        *(void *)&long long v98 = &v99;
        *((void *)&v98 + 1) = 0x200000000;
        if (llvm::InductionDescriptor::isInductionPHI(v43, (uint64_t)v23, (uint64_t)v71, (uint64_t)&v93, 0))
        {
          if (v79 >= (unint64_t)HIDWORD(v79)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v78 + v79) = v43;
          LODWORD(v79) = v79 + 1;
        }
        if ((uint64_t *)v98 != &v99) {
          free((void *)v98);
        }
        if ((void)v95 && (void)v95 != -8192 && (void)v95 != -4096)
        {
          unint64_t v45 = (unint64_t)v93 & 0xFFFFFFFFFFFFFFF8;
          *(void *)((unint64_t)v93 & 0xFFFFFFFFFFFFFFF8) = v94;
          if (v94)
          {
            *(void *)int v94 = *(void *)v94 & 7 | v45;
          }
          else
          {
            uint64_t v46 = v95;
            unint64_t v47 = ***(int32x2_t ****)v95;
            unint64_t v48 = (unint64_t)v47[303];
            if (v48 <= v45)
            {
              uint64_t v49 = v47[305].u32[0];
              if (v48 + 16 * v49 > v45)
              {
                unsigned int v50 = v49 - 1;
                LODWORD(v51) = v50 & ((v95 >> 4) ^ (v95 >> 9));
                uint64_t v52 = (uint64_t *)(v48 + 16 * v51);
                uint64_t v53 = *v52;
                if ((void)v95 == *v52)
                {
LABEL_132:
                  *uint64_t v52 = -8192;
                  v47[304] = vadd_s32(v47[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v46 = v95;
                }
                else
                {
                  int v54 = 1;
                  while (v53 != -4096)
                  {
                    int v55 = v51 + v54++;
                    uint64_t v51 = v55 & v50;
                    uint64_t v53 = *(void *)(v48 + 16 * v51);
                    if ((void)v95 == v53)
                    {
                      uint64_t v52 = (uint64_t *)(v48 + 16 * v51);
                      goto LABEL_132;
                    }
                  }
                }
                *(unsigned char *)(v46 + 17) &= ~1u;
              }
            }
          }
        }
        uint64_t v56 = *(void *)(v43 + 32);
        unint64_t v43 = v56 - 24;
        if (v56) {
          uint64_t v57 = v56 - 24;
        }
        else {
          uint64_t v57 = 0;
        }
      }
      while (v56 && *(unsigned char *)(v57 + 16) == 83);
    }
  }
  if (v79)
  {
    if (*((void *)v70 + 1) != *((void *)v70 + 2)) {
      llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopLatch();
    }
    llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopLatch();
  }
LABEL_24:
  if (v78 != v80) {
    free(v78);
  }
  if (v74 != v73) {
    free(v74);
  }
  return 0;
}

void sub_1CCDDA374()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopLatch();
}

uint64_t sub_1CCDDAC84(uint64_t result)
{
  if (result)
  {
    do
    {
      if (*(unsigned char *)(result + 16) != 83) {
        break;
      }
      int v1 = *(_DWORD *)(result + 20);
      if ((v1 & 0x7FFFFFF) != 1) {
        break;
      }
      char v2 = (v1 & 0x40000000) != 0 ? *(uint64_t **)(result - 8) : (uint64_t *)(result - 32);
      uint64_t result = *v2;
    }
    while (*v2);
  }
  return result;
}

void sub_1CCDDACC4()
{
}

__n128 sub_1CCDDACD8(uint64_t a1)
{
  char v2 = (char *)operator new(0x18uLL);
  *(void *)char v2 = &unk_1F263EF28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1CCDDAD24(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F263EF28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1CCDDAD54(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void **)(v4 + 96);
  uint64_t v6 = *(unsigned int *)(v4 + 104);
  if (v6)
  {
    uint64_t v7 = 8 * v6;
    uint64_t v8 = v5;
    while (*v8 != v3)
    {
      ++v8;
      v7 -= 8;
      if (!v7)
      {
        uint64_t v8 = &v5[v6];
        break;
      }
    }
  }
  else
  {
    uint64_t v8 = v5;
  }
  if (v6 != v8 - v5) {
    return 1;
  }
  unsigned int v9 = *(unsigned __int8 *)(v3 + 16);
  if (v9 < 0x15) {
    return 1;
  }
  if (v9 < 0x1C) {
    return 0;
  }
  if (v9 - 66 <= 0xC)
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v12 = *(_DWORD *)(v3 + 20);
    if ((v12 & 0x40000000) != 0) {
      unsigned int v13 = *(uint64_t **)(v3 - 8);
    }
    else {
      unsigned int v13 = (uint64_t *)(v3 - 32 * (v12 & 0x7FFFFFF));
    }
    uint64_t v17 = *v13;
    goto LABEL_21;
  }
  if (v9 - 41 > 0x11) {
    return 0;
  }
  uint64_t v14 = *(void *)(a1 + 16);
  int v15 = *(_DWORD *)(v3 + 20);
  if ((v15 & 0x40000000) != 0) {
    int v16 = *(uint64_t **)(v3 - 8);
  }
  else {
    int v16 = (uint64_t *)(v3 - 32 * (v15 & 0x7FFFFFF));
  }
  uint64_t v22 = *v16;
  uint64_t v19 = *(void *)(v14 + 24);
  if (!v19)
  {
LABEL_30:
    sub_1CB920400();
    return sub_1CCDDAEDC();
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v19 + 48))(v19, &v22);
  if (result)
  {
    uint64_t v11 = *(void *)(a1 + 16);
    int v20 = *(_DWORD *)(v3 + 20);
    if ((v20 & 0x40000000) != 0) {
      uint64_t v21 = *(void *)(v3 - 8);
    }
    else {
      uint64_t v21 = v3 - 32 * (v20 & 0x7FFFFFF);
    }
    uint64_t v17 = *(void *)(v21 + 32);
LABEL_21:
    uint64_t v22 = v17;
    uint64_t v18 = *(void *)(v11 + 24);
    if (v18) {
      return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v18 + 48))(v18, &v22);
    }
    goto LABEL_30;
  }
  return result;
}

void sub_1CCDDAEDC(unsigned int **a1)
{
  int v1 = a1[1];
  unsigned int v2 = **a1;
  if (v1[12] > v2)
  {
    uint64_t v4 = a1[2];
    while (1)
    {
      uint64_t v5 = llvm::Instruction::clone(*(llvm::Instruction **)(*((void *)v1 + 5) + 8 * v2));
      uint64_t v6 = v5;
      uint64_t v7 = a1[4];
      uint64_t v8 = v7 + 10;
      for (uint64_t i = *((void *)v7 + 6); (unsigned int *)i != v8; uint64_t i = *(void *)(i + 8))
      {
        uint64_t v10 = i - 24;
        if (i) {
          uint64_t v11 = i - 24;
        }
        else {
          uint64_t v11 = 0;
        }
        if (*(unsigned char *)(v11 + 16) != 83) {
          goto LABEL_11;
        }
      }
      uint64_t v10 = 0;
LABEL_11:
      uint64_t v12 = *(void *)(v10 + 40);
      v5[5] = v12;
      *(_WORD *)(v12 + 18) &= ~0x8000u;
      if ((*((unsigned char *)v5 + 23) & 0x10) != 0)
      {
        uint64_t v66 = *(void *)(v12 + 56);
        if (v66)
        {
          BOOL v67 = *(llvm::ValueSymbolTable **)(v66 + 104);
          if (v67) {
            llvm::ValueSymbolTable::reinsertValue(v67, (llvm::Value *)v6);
          }
        }
      }
      uint64_t v14 = *(void *)(v10 + 24);
      unsigned int v13 = (void *)(v10 + 24);
      v6[3] = v14;
      v6[4] = v13;
      *(void *)(v14 + 8) = v6 + 3;
      *unsigned int v13 = v6 + 3;
      int v15 = *a1;
      int v1 = a1[1];
      uint64_t v16 = **a1;
      uint64_t v17 = *(void *)(*((void *)v1 + 5) + 8 * v16);
      uint64_t v18 = *(void *)(v17 + 8);
      if (v18)
      {
        uint64_t v19 = v6 + 1;
        do
        {
          uint64_t v20 = *(void *)(v18 + 8);
          uint64_t v21 = *(void *)(v18 + 24);
          uint64_t v22 = *((void *)v4 + 1);
          uint64_t v23 = *(unsigned int **)(v21 + 40);
          uint64_t v25 = *(void *)(v22 + 56);
          uint64_t v24 = *(void *)(v22 + 64);
          if (v24 == v25)
          {
            uint64_t v26 = *(unsigned int *)(v22 + 76);
            __int16 v27 = (unsigned int **)(v24 + 8 * v26);
            if (v26)
            {
              uint64_t v28 = 0;
              uint64_t v29 = 8 * v26;
              while (*(unsigned int **)(v24 + v28) != v23)
              {
                v28 += 8;
                if (v29 == v28) {
                  goto LABEL_32;
                }
              }
              __int16 v27 = (unsigned int **)(v24 + v28);
            }
LABEL_32:
            uint64_t v25 = *(void *)(v22 + 64);
          }
          else
          {
            uint64_t v30 = *(unsigned int *)(v22 + 72);
            int v31 = v30 - 1;
            unsigned int v32 = (v30 - 1) & ((v23 >> 4) ^ (v23 >> 9));
            __int16 v27 = (unsigned int **)(v24 + 8 * v32);
            uint64_t v33 = *v27;
            if (*v27 == (unsigned int *)-1)
            {
              char v34 = 0;
LABEL_54:
              if (v34) {
                __int16 v27 = v34;
              }
              if (*v27 != v23) {
                __int16 v27 = (unsigned int **)(v24 + 8 * v30);
              }
            }
            else
            {
              char v34 = 0;
              int v35 = 1;
              while (v33 != v23)
              {
                if (v34) {
                  BOOL v36 = 0;
                }
                else {
                  BOOL v36 = v33 == (unsigned int *)-2;
                }
                if (v36) {
                  char v34 = v27;
                }
                unsigned int v37 = v32 + v35++;
                unsigned int v32 = v37 & v31;
                __int16 v27 = (unsigned int **)(v24 + 8 * (v37 & v31));
                uint64_t v33 = *v27;
                if (*v27 == (unsigned int *)-1) {
                  goto LABEL_54;
                }
              }
            }
          }
          if (v24 == v25) {
            uint64_t v38 = 76;
          }
          else {
            uint64_t v38 = 72;
          }
          if (v27 == (unsigned int **)(v24 + 8 * *(unsigned int *)(v22 + v38)) || v23 == a1[4]) {
            goto LABEL_90;
          }
          int v39 = a1[3];
          unint64_t v40 = *(void **)v39;
          uint64_t v41 = v39[2];
          if (v41)
          {
            uint64_t v42 = 8 * v41;
            unint64_t v43 = v40;
            while (*v43 != v21)
            {
              ++v43;
              v42 -= 8;
              if (!v42)
              {
                unint64_t v43 = &v40[v41];
                break;
              }
            }
          }
          else
          {
            unint64_t v43 = v40;
          }
          if (v41 != v43 - v40)
          {
LABEL_90:
            if (*(void *)v18)
            {
              **(void **)(v18 + 16) = v20;
              uint64_t v44 = *(void *)(v18 + 8);
              if (v44) {
                *(void *)(v44 + 16) = *(void *)(v18 + 16);
              }
            }
            *(void *)uint64_t v18 = v6;
            uint64_t v45 = v6[1];
            *(void *)(v18 + 8) = v45;
            if (v45) {
              *(void *)(v45 + 16) = v18 + 8;
            }
            *(void *)(v18 + 16) = v19;
            *uint64_t v19 = v18;
          }
          uint64_t v18 = v20;
        }
        while (v20);
        int v15 = *a1;
        int v1 = a1[1];
        uint64_t v16 = **a1;
        uint64_t v17 = *(void *)(*((void *)v1 + 5) + 8 * v16);
      }
      int v46 = *(_DWORD *)(v17 + 20);
      if ((v46 & 0x40000000) != 0)
      {
        unint64_t v48 = *(uint64_t **)(v17 - 8);
        uint64_t v47 = v46 & 0x7FFFFFF;
      }
      else
      {
        uint64_t v47 = v46 & 0x7FFFFFF;
        unint64_t v48 = (uint64_t *)(v17 - 32 * v47);
      }
      uint64_t v49 = &v48[4 * v47];
      if (v47) {
        break;
      }
LABEL_83:
      unsigned int v2 = v16 + 1;
      *int v15 = v16 + 1;
      if (v1[12] <= (int)v16 + 1) {
        return;
      }
    }
    while (1)
    {
      uint64_t v50 = *v48;
      if (*(unsigned __int8 *)(*v48 + 16) <= 0x1Bu) {
        uint64_t v50 = 0;
      }
      uint64_t v68 = v50;
      if (v50) {
        break;
      }
LABEL_81:
      v48 += 4;
      if (v48 == v49)
      {
        int v15 = *a1;
        int v1 = a1[1];
        LODWORD(v16) = **a1;
        goto LABEL_83;
      }
    }
    uint64_t v51 = (uint64_t *)*((void *)v4 + 3);
    int v52 = *((_DWORD *)v51 + 4);
    if (v52)
    {
      uint64_t v53 = *(void *)(v50 + 40);
      uint64_t v54 = *v51;
      unsigned int v55 = v52 - 1;
      uint64_t v56 = ((v53 >> 4) ^ (v53 >> 9)) & (v52 - 1);
      uint64_t v57 = *(void *)(v54 + 16 * v56);
      if (v53 == v57)
      {
LABEL_70:
        uint64_t v60 = *(void *)(v54 + 16 * v56 + 8);
        goto LABEL_72;
      }
      int v58 = 1;
      while (v57 != -4096)
      {
        int v59 = v56 + v58++;
        uint64_t v56 = v59 & v55;
        uint64_t v57 = *(void *)(v54 + 16 * v56);
        if (v53 == v57) {
          goto LABEL_70;
        }
      }
    }
    uint64_t v60 = 0;
LABEL_72:
    if (v60 == *((void *)v4 + 1))
    {
      uint64_t v61 = a1[3];
      uint64_t v62 = *(void **)v61;
      uint64_t v63 = v61[2];
      if (v63)
      {
        uint64_t v64 = 8 * v63;
        char v65 = v62;
        while (*v65 != v50)
        {
          ++v65;
          v64 -= 8;
          if (!v64)
          {
            char v65 = &v62[v63];
            break;
          }
        }
      }
      else
      {
        char v65 = v62;
      }
      if (v63 == v65 - v62) {
        sub_1CD6433E0((uint64_t)a1[1], &v68);
      }
    }
    goto LABEL_81;
  }
}

void sub_1CCDDB2D0(uint64_t a1, unint64_t a2, uint64_t a3, char **a4)
{
  int v7 = *(_DWORD *)(a1 + 20);
  if ((v7 & 0x40000000) != 0)
  {
    uint64_t v9 = *(void *)(a1 - 8);
    uint64_t v8 = v7 & 0x7FFFFFF;
    if ((*(_DWORD *)(a1 + 20) & 0x7FFFFFF) == 0) {
      return;
    }
  }
  else
  {
    uint64_t v8 = v7 & 0x7FFFFFF;
    uint64_t v9 = a1 - 32 * v8;
    if ((v7 & 0x7FFFFFF) == 0) {
      return;
    }
  }
  char v10 = 0;
  uint64_t v11 = (void *)(a3 + 8);
  uint64_t v12 = 32 * v8;
  unsigned int v13 = (void **)(v9 + 8);
  do
  {
    uint64_t v14 = v13 - 1;
    if (*(v13 - 1) == (void *)a2)
    {
      if (a2)
      {
        *v13[1] = *v13;
        if (*v13) {
          (*v13)[2] = v13[1];
        }
      }
      *uint64_t v14 = a3;
      if (a3)
      {
        int v15 = (void *)*v11;
        *unsigned int v13 = (void *)*v11;
        if (v15) {
          v15[2] = v13;
        }
        v13[1] = v11;
        *uint64_t v11 = v14;
      }
      char v10 = 1;
    }
    v13 += 4;
    v12 -= 32;
  }
  while (v12);
  if (v10)
  {
    uint64_t v16 = *(void *)(a1 + 40);
    unint64_t v17 = a3 & 0xFFFFFFFFFFFFFFFBLL;
    uint64_t v19 = a4[1];
    unint64_t v18 = (unint64_t)a4[2];
    if ((unint64_t)v19 >= v18)
    {
      uint64_t v21 = *a4;
      uint64_t v22 = (v19 - *a4) >> 4;
      unint64_t v23 = v22 + 1;
      if ((unint64_t)(v22 + 1) >> 60) {
        goto LABEL_54;
      }
      uint64_t v24 = v18 - (void)v21;
      if (v24 >> 3 > v23) {
        unint64_t v23 = v24 >> 3;
      }
      if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v25 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v25 = v23;
      }
      if (v25)
      {
        if (v25 >> 60) {
          goto LABEL_55;
        }
        uint64_t v26 = (char *)operator new(16 * v25);
      }
      else
      {
        uint64_t v26 = 0;
      }
      __int16 v27 = &v26[16 * v22];
      *(void *)__int16 v27 = v16;
      *((void *)v27 + 1) = v17;
      uint64_t v20 = v27 + 16;
      if (v19 != v21)
      {
        do
        {
          *((_OWORD *)v27 - 1) = *((_OWORD *)v19 - 1);
          v27 -= 16;
          v19 -= 16;
        }
        while (v19 != v21);
        uint64_t v19 = *a4;
      }
      *a4 = v27;
      a4[1] = v20;
      a4[2] = &v26[16 * v25];
      if (v19) {
        operator delete(v19);
      }
    }
    else
    {
      *(void *)uint64_t v19 = v16;
      *((void *)v19 + 1) = v17;
      uint64_t v20 = v19 + 16;
    }
    a4[1] = v20;
    uint64_t v28 = *(void *)(a1 + 40);
    uint64_t v29 = a2 | 4;
    unint64_t v30 = (unint64_t)a4[2];
    if ((unint64_t)v20 < v30)
    {
      *(void *)uint64_t v20 = v28;
      *((void *)v20 + 1) = v29;
      int v31 = v20 + 16;
      goto LABEL_52;
    }
    unsigned int v32 = *a4;
    uint64_t v33 = (v20 - *a4) >> 4;
    unint64_t v34 = v33 + 1;
    if (!((unint64_t)(v33 + 1) >> 60))
    {
      uint64_t v35 = v30 - (void)v32;
      if (v35 >> 3 > v34) {
        unint64_t v34 = v35 >> 3;
      }
      if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v36 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v36 = v34;
      }
      if (!v36)
      {
        unsigned int v37 = 0;
        goto LABEL_46;
      }
      if (!(v36 >> 60))
      {
        unsigned int v37 = (char *)operator new(16 * v36);
LABEL_46:
        uint64_t v38 = &v37[16 * v33];
        int v39 = &v37[16 * v36];
        *(void *)uint64_t v38 = v28;
        *((void *)v38 + 1) = v29;
        int v31 = v38 + 16;
        if (v20 == v32)
        {
          *a4 = v38;
          a4[1] = v31;
          a4[2] = v39;
        }
        else
        {
          do
          {
            *((_OWORD *)v38 - 1) = *((_OWORD *)v20 - 1);
            v38 -= 16;
            v20 -= 16;
          }
          while (v20 != v32);
          uint64_t v20 = *a4;
          *a4 = v38;
          a4[1] = v31;
          a4[2] = v39;
          if (!v20) {
            goto LABEL_52;
          }
        }
        operator delete(v20);
LABEL_52:
        a4[1] = v31;
        return;
      }
LABEL_55:
      sub_1CB833614();
    }
LABEL_54:
    abort();
  }
}

uint64_t sub_1CCDDB548()
{
  int v3 = 0;
  uint64_t v4 = &v3;
  int v2 = 1;
  v1.n128_u64[0] = (unint64_t)"Interchange if you gain more than this number";
  v1.n128_u64[1] = 45;
  sub_1CD7719A8(&v4, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CBB1C45C, &qword_1EBCF44E8, &dword_1CB82C000);
}

uint64_t Flatten(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(unsigned int *)(a1 + 16);
  if (v1)
  {
    int v2 = *(llvm::Loop ****)(a1 + 8);
    int v3 = &v2[v1];
    do
    {
      uint64_t v4 = *v2;
      if (**v2)
      {
        v6[0] = **v2;
        v6[1] = (llvm::Loop *)v4;
        *(_OWORD *)int v7 = 0u;
        long long v8 = 0u;
        uint64_t v9 = v13;
        char v10 = v13;
        uint64_t v11 = 4;
        int v12 = 0;
        memset(&v13[32], 0, 32);
        uint64_t v14 = v18;
        int v15 = v18;
        uint64_t v16 = 4;
        int v17 = 0;
        v18[32] = 0;
        uint64_t v19 = 0;
        uint64_t v20 = 0;
        sub_1CCDDC9DC((uint64_t)v6);
      }
      ++v2;
    }
    while (v2 != v3);
  }
  return 0;
}

void sub_1CCDDC884(uint64_t a1)
{
}

uint64_t sub_1CCDDC92C(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF45B8;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263EF70;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF45C0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCDDC884;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCF45C0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CCDDC9DC(uint64_t a1)
{
}

void sub_1CCDDD920(llvm::Loop *a1)
{
}

uint64_t sub_1CCDDE72C(uint64_t a1, void *a2, uint64_t a3)
{
  int v4 = *(unsigned __int8 *)(a3 + 16);
  if (v4 == 41)
  {
    uint64_t v5 = *(void *)(a3 - 64);
    uint64_t v6 = *(void *)(a3 - 32);
    if (v5 == a1 && v6)
    {
      *a2 = v6;
    }
    else
    {
      if (v5) {
        BOOL v7 = v6 == a1;
      }
      else {
        BOOL v7 = 0;
      }
      if (!v7) {
        return 0;
      }
      *a2 = v5;
    }
    return 1;
  }
  else
  {
    if (v4 == 5)
    {
      if (*(_WORD *)(a3 + 18) == 13
        && ((uint64_t v9 = (uint64_t *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF)), v10 = *v9, v11 = v9[4], v10 == a1) && v11
         || (v10 ? (v12 = v11 == a1) : (v12 = 0), uint64_t v11 = v10, v12)))
      {
        *a2 = v11;
        char v3 = 1;
      }
      else
      {
        char v3 = 0;
      }
    }
    return (v4 == 5) & v3;
  }
}

uint64_t sub_1CCDDE7D8(uint64_t a1, void *a2, uint64_t a3)
{
  int v4 = *(unsigned __int8 *)(a3 + 16);
  if (v4 == 45)
  {
    uint64_t v5 = *(void *)(a3 - 64);
    uint64_t v6 = *(void *)(a3 - 32);
    if (v5 == a1 && v6)
    {
      *a2 = v6;
    }
    else
    {
      if (v5) {
        BOOL v7 = v6 == a1;
      }
      else {
        BOOL v7 = 0;
      }
      if (!v7) {
        return 0;
      }
      *a2 = v5;
    }
    return 1;
  }
  else
  {
    if (v4 == 5)
    {
      if (*(_WORD *)(a3 + 18) == 17
        && ((uint64_t v9 = (uint64_t *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF)), v10 = *v9, v11 = v9[4], v10 == a1) && v11
         || (v10 ? (v12 = v11 == a1) : (v12 = 0), uint64_t v11 = v10, v12)))
      {
        *a2 = v11;
        char v3 = 1;
      }
      else
      {
        char v3 = 0;
      }
    }
    return (v4 == 5) & v3;
  }
}

uint64_t sub_1CCDDE884@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W8>)
{
  int v5 = *(unsigned __int8 *)(a2 + 16);
  if (v5 == 41)
  {
    int v6 = sub_1CC062B54((void *)a1, *(void *)(a2 - 64));
    uint64_t v7 = *(void *)(a2 - 32);
    if (v6 && v7)
    {
      **(void **)(a1 + 8) = v7;
    }
    else
    {
      uint64_t result = sub_1CC062B54((void *)a1, v7);
      if (!result) {
        return result;
      }
      uint64_t v9 = *(void *)(a2 - 64);
      if (!v9) {
        return 0;
      }
      **(void **)(a1 + 8) = v9;
    }
    return 1;
  }
  else
  {
    if (v5 == 5)
    {
      if (*(_WORD *)(a2 + 18) == 13
        && ((uint64_t v10 = (uint64_t *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF)),
             uint64_t v11 = *v10,
             int v12 = sub_1CD771F88((void *)a1, *v10),
             uint64_t v13 = v10[4],
             v12)
         && v13
         || ((v14 = sub_1CD771F88((void *)a1, v13), v11) ? (v15 = v14 == 0) : (v15 = 1), uint64_t v13 = v11, !v15)))
      {
        **(void **)(a1 + 8) = v13;
        a3 = 1;
      }
      else
      {
        a3 = 0;
      }
    }
    return (v5 == 5) & a3;
  }
}

uint64_t sub_1CCDDE984@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W8>)
{
  int v5 = *(unsigned __int8 *)(a2 + 16);
  if (v5 == 45)
  {
    int v6 = sub_1CC062B54((void *)a1, *(void *)(a2 - 64));
    uint64_t v7 = *(void *)(a2 - 32);
    if (v6 && v7)
    {
      **(void **)(a1 + 8) = v7;
    }
    else
    {
      uint64_t result = sub_1CC062B54((void *)a1, v7);
      if (!result) {
        return result;
      }
      uint64_t v9 = *(void *)(a2 - 64);
      if (!v9) {
        return 0;
      }
      **(void **)(a1 + 8) = v9;
    }
    return 1;
  }
  else
  {
    if (v5 == 5)
    {
      if (*(_WORD *)(a2 + 18) == 17
        && ((uint64_t v10 = (uint64_t *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF)),
             uint64_t v11 = *v10,
             int v12 = sub_1CD771F88((void *)a1, *v10),
             uint64_t v13 = v10[4],
             v12)
         && v13
         || ((v14 = sub_1CD771F88((void *)a1, v13), v11) ? (v15 = v14 == 0) : (v15 = 1), uint64_t v13 = v11, !v15)))
      {
        **(void **)(a1 + 8) = v13;
        a3 = 1;
      }
      else
      {
        a3 = 0;
      }
    }
    return (v5 == 5) & a3;
  }
}

char **sub_1CCDDEA84(char **a1)
{
  int v2 = *a1;
  int v3 = *((_DWORD *)a1 + 2);
  if (v3)
  {
    int v4 = &v2[24 * v3];
    do
    {
      uint64_t v5 = *((void *)v4 - 1);
      if (v5 != -8192 && v5 != -4096 && v5 != 0)
      {
        unint64_t v7 = *((void *)v4 - 3) & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v7 = *((void *)v4 - 2);
        long long v8 = (unint64_t *)*((void *)v4 - 2);
        if (v8)
        {
          unint64_t *v8 = *v8 & 7 | v7;
        }
        else
        {
          uint64_t v9 = *((void *)v4 - 1);
          uint64_t v10 = ***(int32x2_t ****)v9;
          unint64_t v11 = (unint64_t)v10[303];
          if (v11 <= v7)
          {
            uint64_t v12 = v10[305].u32[0];
            if (v11 + 16 * v12 > v7)
            {
              unsigned int v13 = v12 - 1;
              LODWORD(v14) = v13 & ((v9 >> 4) ^ (v9 >> 9));
              BOOL v15 = (uint64_t *)(v11 + 16 * v14);
              uint64_t v16 = *v15;
              if (v9 == *v15)
              {
LABEL_19:
                *BOOL v15 = -8192;
                v10[304] = vadd_s32(v10[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v9 = *((void *)v4 - 1);
              }
              else
              {
                int v17 = 1;
                while (v16 != -4096)
                {
                  int v18 = v14 + v17++;
                  uint64_t v14 = v18 & v13;
                  uint64_t v16 = *(void *)(v11 + 16 * v14);
                  if (v9 == v16)
                  {
                    BOOL v15 = (uint64_t *)(v11 + 16 * v14);
                    goto LABEL_19;
                  }
                }
              }
              *(unsigned char *)(v9 + 17) &= ~1u;
            }
          }
        }
      }
      v4 -= 24;
    }
    while (v4 != v2);
    int v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

void sub_1CCDDEBD0()
{
}

void sub_1CCDDEC10(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCDDEC48(int a1, llvm *this)
{
  llvm::getLoopAnalysisUsage(this, this);
  sub_1CB843600((uint64_t)this, (uint64_t)this, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
  sub_1CB843600((uint64_t)this, (uint64_t)this + 112, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
  sub_1CB843600((uint64_t)this, (uint64_t)this, (uint64_t)llvm::AssumptionCacheTracker::ID);
  sub_1CB843600((uint64_t)this, (uint64_t)this + 112, (uint64_t)llvm::AssumptionCacheTracker::ID);

  sub_1CB843600((uint64_t)this, (uint64_t)this + 112, (uint64_t)&llvm::MemorySSAWrapperPass::ID);
}

uint64_t sub_1CCDDECEC(uint64_t a1, Function *a2)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  int v4 = *(uint64_t **)(a1 + 8);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_4:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(char **)v5 != llvm::ScalarEvolutionWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_4;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  (*(void (**)(uint64_t, char *))(*(void *)v7 + 96))(v7, llvm::ScalarEvolutionWrapperPass::ID);
  long long v8 = *(uint64_t **)(a1 + 8);
  uint64_t v9 = *v8;
  uint64_t v10 = v8[1];
  if (v9 == v10)
  {
LABEL_9:
    uint64_t v11 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v9 != &llvm::LoopInfoWrapperPass::ID)
    {
      v9 += 16;
      if (v9 == v10) {
        goto LABEL_9;
      }
    }
    uint64_t v11 = *(void *)(v9 + 8);
  }
  uint64_t v12 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v11 + 96))(v11, &llvm::LoopInfoWrapperPass::ID);
  unsigned int v13 = *(uint64_t **)(a1 + 8);
  uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass((llvm::PMDataManager *)v13[3], &llvm::DominatorTreeWrapperPass::ID, 1);
  if (AnalysisPass)
  {
    (*(void (**)(uint64_t, void *))(*(void *)AnalysisPass + 96))(AnalysisPass, &llvm::DominatorTreeWrapperPass::ID);
    unsigned int v13 = *(uint64_t **)(a1 + 8);
  }
  uint64_t v15 = *v13;
  uint64_t v16 = v13[1];
  if (*v13 == v16)
  {
LABEL_16:
    uint64_t v17 = 0;
  }
  else
  {
    while (*(char **)v15 != llvm::TargetTransformInfoWrapperPass::ID)
    {
      v15 += 16;
      if (v15 == v16) {
        goto LABEL_16;
      }
    }
    uint64_t v17 = *(void *)(v15 + 8);
  }
  int v18 = (llvm::TargetTransformInfoWrapperPass *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v17 + 96))(v17, llvm::TargetTransformInfoWrapperPass::ID);
  llvm::TargetTransformInfoWrapperPass::getTTI(v18, a2);
  uint64_t v19 = *(uint64_t **)(a1 + 8);
  uint64_t v20 = *v19;
  uint64_t v21 = v19[1];
  if (v20 == v21)
  {
LABEL_21:
    uint64_t v22 = 0;
  }
  else
  {
    while (*(char **)v20 != llvm::AssumptionCacheTracker::ID)
    {
      v20 += 16;
      if (v20 == v21) {
        goto LABEL_21;
      }
    }
    uint64_t v22 = *(void *)(v20 + 8);
  }
  unint64_t v23 = (llvm::AssumptionCacheTracker *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v22 + 96))(v22, llvm::AssumptionCacheTracker::ID);
  llvm::AssumptionCacheTracker::getAssumptionCache(v23, (llvm::Function *)a2);
  uint64_t v24 = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*(void *)(a1 + 8) + 24), &llvm::MemorySSAWrapperPass::ID, 1);
  if (v24)
  {
    uint64_t v25 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v24 + 96))(v24, &llvm::MemorySSAWrapperPass::ID);
    LOBYTE(v40) = 0;
    char v53 = 0;
    if (v25)
    {
      uint64_t v27 = *(void *)(v25 + 32);
      v28[0] = (char *)&v29;
      v28[1] = (char *)0x1000000000;
      unint64_t v30 = v34;
      int v31 = v34;
      uint64_t v35 = v37;
      uint64_t v36 = 0x800000000;
      v39[1] = 0;
      v39[0] = 0;
      uint64_t v38 = v39;
      uint64_t v40 = v27;
      v41[0] = (char *)&v42;
      v41[1] = (char *)0x1000000000;
      unint64_t v43 = v47;
      uint64_t v44 = v47;
      uint64_t v45 = 8;
      int v46 = 0;
      uint64_t v32 = 8;
      int v33 = 0;
      unint64_t v48 = v50;
      uint64_t v49 = 0x800000000;
      v52[1] = 0;
      v52[0] = 0;
      uint64_t v51 = v52;
      char v53 = 1;
      sub_1CD3C5048((uint64_t)&v38, 0);
      if (v35 != v37) {
        free(v35);
      }
      if (v31 != v30) {
        free(v31);
      }
      sub_1CC0BD0FC(v28);
    }
  }
  else
  {
    LOBYTE(v40) = 0;
    char v53 = 0;
  }
  if (*(void *)(v12 + 56) != *(void *)(v12 + 64)) {
    operator new();
  }
  if (v53)
  {
    sub_1CD3C5048((uint64_t)&v51, v52[0]);
    if (v48 != v50) {
      free(v48);
    }
    if (v44 != v43) {
      free(v44);
    }
    sub_1CC0BD0FC(v41);
    char v53 = 0;
  }
  return 0;
}

uint64_t sub_1CCDDF1D4(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = a1 + 24;
  uint64_t v4 = a1 + 8;
  *(void *)(a1 + 16) = 0x1000000000;
  if (*(_DWORD *)(a2 + 16)) {
    sub_1CD72D390(v4, a2 + 8);
  }
  uint64_t v5 = (void *)(a1 + 440);
  *(void *)(a1 + 408) = a1 + 440;
  uint64_t v7 = *(void *)(a2 + 408);
  uint64_t v6 = *(void *)(a2 + 416);
  if (v6 == v7)
  {
    *(void *)(a1 + 416) = v5;
    uint64_t v8 = *(unsigned int *)(a2 + 428);
    if (v8) {
      memmove(v5, *(const void **)(a2 + 416), 8 * v8);
    }
  }
  else
  {
    *(void *)(a1 + 416) = v6;
    *(void *)(a2 + 416) = v7;
  }
  *(void *)(a1 + 424) = *(void *)(a2 + 424);
  *(_DWORD *)(a1 + 432) = *(_DWORD *)(a2 + 432);
  *(void *)(a2 + 424) = 8;
  *(_DWORD *)(a2 + 432) = 0;
  *(void *)(a1 + 504) = a1 + 520;
  *(void *)(a1 + 512) = 0x800000000;
  if (*(_DWORD *)(a2 + 512)) {
    sub_1CD72A1EC(a1 + 504, a2 + 504);
  }
  *(void *)(a1 + 584) = *(void *)(a2 + 584);
  uint64_t v9 = a1 + 592;
  uint64_t v10 = *(void *)(a2 + 592);
  *(void *)(a1 + 592) = v10;
  uint64_t v11 = *(void *)(a2 + 600);
  *(void *)(a1 + 600) = v11;
  if (v11)
  {
    *(void *)(v10 + 16) = v9;
    *(void *)(a2 + 584) = a2 + 592;
    *(void *)(a2 + 592) = 0;
    *(void *)(a2 + 600) = 0;
  }
  else
  {
    *(void *)(a1 + 584) = v9;
  }
  return a1;
}

uint64_t sub_1CCDDF2E8()
{
  int v4 = 1;
  int v1 = 2;
  v2.n128_u64[0] = (unint64_t)"Limit on the cost of instructions that can be repeated due to loop flattening";
  v2.n128_u64[1] = 77;
  int v3 = &v1;
  sub_1CD45A86C((uint64_t)&unk_1EBCF45C8, "loop-flatten-cost-threshold", &v4, &v3, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF45C8, &dword_1CB82C000);
  int v4 = 1;
  LOBYTE(v1) = 0;
  v2.n128_u64[0] = (unint64_t)"Assume that the product of the two iteration trip counts will never overflow";
  v2.n128_u64[1] = 76;
  int v3 = &v1;
  sub_1CD771FF4(&v4, (char **)&v3, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCF4688, &dword_1CB82C000);
  int v4 = 1;
  LOBYTE(v1) = 1;
  v2.n128_u64[0] = (unint64_t)"Widen the loop induction variables, if possible, so overflow checks won't reject flattening";
  v2.n128_u64[1] = 91;
  int v3 = &v1;
  sub_1CC025F34((llvm::cl::Option *)&unk_1EBCF4748, "loop-flatten-widen-iv", &v4, (unsigned char **)&v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF4748, &dword_1CB82C000);
}

void sub_1CCDDF424(llvm *a1)
{
  llvm::initializeLoopInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeLoopAccessLegacyAnalysisPass(a1, v2);
  llvm::initializeDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializeScalarEvolutionWrapperPassPass(a1, v3);
  llvm::initializeLoopSimplifyPass(a1, v4);
  llvm::initializeProfileSummaryInfoWrapperPassPass(a1, v5);
  llvm::initializeLazyBlockFrequencyInfoPassPass(a1, v6);
  operator new();
}

uint64_t sub_1CCDDF4F4(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF4808;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263F010;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF4810, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCDDF424;
    v5[1] = &PassRegistry;
    int v4 = v5;
    std::__call_once(&qword_1EBCF4810, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void llvm::LoopLoadEliminationPass::run()
{
}

uint64_t sub_1CCDDF794(llvm::DominatorTree *a1, llvm::Loop *a2, uint64_t a3, uint64_t a4, llvm::LoopInfo *a5, llvm::ScalarEvolution *a6)
{
  v68[10] = *MEMORY[0x1E4F143B8];
  int v52 = v54;
  uint64_t v53 = 0x800000000;
  uint64_t v6 = (uint64_t *)*((void *)a1 + 3);
  int v31 = (uint64_t *)*((void *)a1 + 4);
  if (v6 == v31)
  {
    char v9 = 0;
    return v9 & 1;
  }
  char v9 = 0;
  do
  {
    v68[0] = *v6;
    sub_1CC076464(v68, (uint64_t)&v55);
    unint64_t v34 = (llvm::Loop *)&v39;
    uint64_t v10 = __src;
    if (__src == v55)
    {
      uint64_t v35 = (llvm::Loop *)&v39;
      uint64_t v11 = (llvm::Loop *)&v39;
      uint64_t v12 = __src;
    }
    else
    {
      unsigned int v28 = v57[0];
      uint64_t v11 = (llvm::Loop *)malloc_type_malloc(8 * v57[0], 0x4065EBACuLL);
      if (!v11 && (v28 || (uint64_t v11 = (llvm::Loop *)malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
LABEL_64:
      }
        llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
      uint64_t v35 = v11;
      uint64_t v12 = v55;
      uint64_t v10 = __src;
    }
    unsigned int v13 = v57[1];
    unsigned int v36 = v57[0];
    if (v10 == v12) {
      unsigned int v14 = v57[1];
    }
    else {
      unsigned int v14 = v57[0];
    }
    if (v14)
    {
      memmove(v11, v10, 8 * v14);
      unsigned int v13 = v57[1];
    }
    unsigned int v37 = v13;
    int v38 = v58;
    uint64_t v41 = 0;
    uint64_t v42 = 0;
    uint64_t v40 = 0;
    sub_1CBF340A8(&v40, v59, v60, 0xAAAAAAAAAAAAAAABLL * ((v60 - (unsigned char *)v59) >> 3));
    unint64_t v43 = v48;
    uint64_t v15 = v62;
    if (v62 == v61)
    {
      uint64_t v44 = v48;
      uint64_t v16 = v48;
      uint64_t v17 = v62;
    }
    else
    {
      unsigned int v29 = v63;
      uint64_t v16 = malloc_type_malloc(8 * v63, 0x4065EBACuLL);
      if (!v16)
      {
        if (v29) {
          goto LABEL_64;
        }
        uint64_t v16 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
        if (!v16) {
          goto LABEL_64;
        }
      }
      uint64_t v44 = v16;
      uint64_t v17 = v61;
      uint64_t v15 = v62;
    }
    unsigned int v18 = v64;
    unsigned int v45 = v63;
    if (v15 == v17) {
      unsigned int v19 = v64;
    }
    else {
      unsigned int v19 = v63;
    }
    if (v19)
    {
      memmove(v16, v15, 8 * v19);
      unsigned int v18 = v64;
    }
    unsigned int v46 = v18;
    int v47 = v65;
    uint64_t v50 = 0;
    uint64_t v51 = 0;
    uint64_t __p = 0;
    sub_1CBF340A8(&__p, v66, v67, 0xAAAAAAAAAAAAAAABLL * ((v67 - (unsigned char *)v66) >> 3));
    while (1)
    {
      if (v41 - (unsigned char *)v40 != v50 - (unsigned char *)__p) {
        goto LABEL_32;
      }
      if (v40 == v41) {
        break;
      }
      uint64_t v21 = (char *)__p + 8;
      uint64_t v22 = (char *)v40 + 8;
      while (1)
      {
        unint64_t v23 = v22 - 8;
        if (*((void *)v22 - 1) != *((void *)v21 - 1)) {
          break;
        }
        int v24 = v21[8];
        if (v22[8]) {
          BOOL v25 = v24 == 0;
        }
        else {
          BOOL v25 = 1;
        }
        if (v25)
        {
          if ((v22[8] == 0) == (v24 != 0)) {
            break;
          }
        }
        else if (*(void *)v22 != *(void *)v21)
        {
          break;
        }
        v21 += 24;
        v22 += 24;
        if (v23 + 24 == v41) {
          goto LABEL_37;
        }
      }
LABEL_32:
      uint64_t v26 = (llvm *)*((void *)v41 - 3);
      char v27 = llvm::simplifyLoop(v26, a2, a1, a5, a6, 0, 0, v20);
      if (*((void *)v26 + 1) == *((void *)v26 + 2))
      {
        if (v53 >= (unint64_t)HIDWORD(v53)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v52 + v53) = v26;
        LODWORD(v53) = v53 + 1;
      }
      v9 |= v27;
      sub_1CC078F58((llvm::SmallPtrSetImplBase *)&v34);
    }
LABEL_37:
    if (__p)
    {
      uint64_t v50 = __p;
      operator delete(__p);
    }
    if (v44 != v43) {
      free(v44);
    }
    if (v40)
    {
      uint64_t v41 = (char *)v40;
      operator delete(v40);
    }
    if (v35 != v34) {
      free(v35);
    }
    if (v66)
    {
      BOOL v67 = v66;
      operator delete(v66);
    }
    if (v62 != v61) {
      free(v62);
    }
    if (v59)
    {
      uint64_t v60 = v59;
      operator delete(v59);
    }
    if (__src != v55) {
      free(__src);
    }
    ++v6;
  }
  while (v6 != v31);
  if (v53) {
    llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopLatch();
  }
  if (v52 != v54) {
    free(v52);
  }
  return v9 & 1;
}

void sub_1CCDE1C5C()
{
}

void sub_1CCDE1C9C(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

llvm::AnalysisUsage *sub_1CCDE1CD4(uint64_t a1, llvm::LazyBlockFrequencyInfoPass *a2)
{
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)&unk_1EA61F34C);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::LoopAccessLegacyAnalysis::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::ScalarEvolutionWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::ProfileSummaryInfoWrapperPass::ID);

  return llvm::LazyBlockFrequencyInfoPass::getLazyBFIAnalysisUsage(a2, v3);
}

uint64_t sub_1CCDE1DC4(llvm::FunctionPass *a1, llvm::LLVMContextImpl ****a2)
{
  if (llvm::FunctionPass::skipFunction(a1, a2)) {
    return 0;
  }
  int v4 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_6:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::LoopInfoWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_6;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::LoopInfoWrapperPass::ID);
  char v9 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v10 = *v9;
  uint64_t v11 = v9[1];
  if (v10 == v11)
  {
LABEL_11:
    uint64_t v12 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v10 != &llvm::LoopAccessLegacyAnalysis::ID)
    {
      v10 += 16;
      if (v10 == v11) {
        goto LABEL_11;
      }
    }
    uint64_t v12 = *(void *)(v10 + 8);
  }
  (*(void (**)(uint64_t, void *))(*(void *)v12 + 96))(v12, &llvm::LoopAccessLegacyAnalysis::ID);
  unsigned int v13 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v14 = *v13;
  uint64_t v15 = v13[1];
  if (v14 == v15)
  {
LABEL_16:
    uint64_t v16 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v14 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v14 += 16;
      if (v14 == v15) {
        goto LABEL_16;
      }
    }
    uint64_t v16 = *(void *)(v14 + 8);
  }
  uint64_t v17 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v16 + 96))(v16, &llvm::DominatorTreeWrapperPass::ID);
  unsigned int v18 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v19 = *v18;
  uint64_t v20 = v18[1];
  if (v19 == v20)
  {
LABEL_21:
    uint64_t v21 = 0;
  }
  else
  {
    while (*(char **)v19 != llvm::ProfileSummaryInfoWrapperPass::ID)
    {
      v19 += 16;
      if (v19 == v20) {
        goto LABEL_21;
      }
    }
    uint64_t v21 = *(void *)(v19 + 8);
  }
  uint64_t v22 = (llvm::DominatorTree *)(v8 + 32);
  unint64_t v23 = (llvm::Loop *)(v17 + 32);
  uint64_t v24 = *(void *)((*(uint64_t (**)(uint64_t, char *))(*(void *)v21 + 96))(v21, llvm::ProfileSummaryInfoWrapperPass::ID)+ 32);
  if (*(void *)(v24 + 8))
  {
    int v31 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v32 = *v31;
    uint64_t v33 = v31[1];
    if (v32 == v33)
    {
LABEL_35:
      uint64_t v34 = 0;
    }
    else
    {
      while (*(char **)v32 != llvm::LazyBlockFrequencyInfoPass::ID)
      {
        v32 += 16;
        if (v32 == v33) {
          goto LABEL_35;
        }
      }
      uint64_t v34 = *(void *)(v32 + 8);
    }
    uint64_t v35 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v34 + 96))(v34, llvm::LazyBlockFrequencyInfoPass::ID);
    BOOL v25 = sub_1CD499004((llvm::BlockFrequencyInfo *)(v35 + 32));
  }
  else
  {
    BOOL v25 = 0;
  }
  uint64_t v26 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v27 = *v26;
  uint64_t v28 = v26[1];
  if (v27 == v28)
  {
LABEL_28:
    uint64_t v29 = 0;
  }
  else
  {
    while (*(char **)v27 != llvm::ScalarEvolutionWrapperPass::ID)
    {
      v27 += 16;
      if (v27 == v28) {
        goto LABEL_28;
      }
    }
    uint64_t v29 = *(void *)(v27 + 8);
  }
  uint64_t v30 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v29 + 96))(v29, llvm::ScalarEvolutionWrapperPass::ID);
  return sub_1CCDDF794(v22, v23, (uint64_t)v25, v24, *(llvm::LoopInfo **)(v30 + 32), 0);
}

uint64_t sub_1CCDE20E4(llvm::LoopAccessLegacyAnalysis **a1, llvm::Loop *a2)
{
  return llvm::LoopAccessLegacyAnalysis::getInfo(*a1, a2);
}

BOOL sub_1CCDE20EC(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *a1;
  uint64_t v7 = *(llvm::Value **)(*a1 - 32);
  if (!*a1 || *(unsigned char *)(v6 + 16) != 60) {
    uint64_t v6 = *(void *)(v6 - 64);
  }
  uint64_t v8 = *(llvm::Value **)(a1[1] - 32);
  char v9 = *(llvm::Type **)v6;
  v30[0] = 0;
  v30[1] = 0;
  int v31 = 0;
  if (llvm::getPtrStride((int8x16_t *)a2, v9, v7, a3, (uint64_t)v30, 0, 1) == 1)
  {
    v28[0] = 0;
    v28[1] = 0;
    int v29 = 0;
    uint64_t PtrStride = llvm::getPtrStride((int8x16_t *)a2, v9, v8, a3, (uint64_t)v28, 0, 1);
    MEMORY[0x1D25D9CD0](v28[0], 8);
    MEMORY[0x1D25D9CD0](v30[0], 8);
    BOOL result = 0;
    if (PtrStride != 1) {
      return result;
    }
    uint64_t v12 = (llvm::DataLayout *)(*(void *)(*(void *)(*(void *)(*a1 + 40) + 56) + 40) + 272);
    uint64_t v13 = sub_1CB83544C((uint64_t)v12, (uint64_t)v9);
    BOOL v15 = v14 == 1;
    char Alignment = llvm::DataLayout::getAlignment(v12, v9, 1);
    if (v15) {
    SCEV = (const llvm::APInt *)llvm::PredicatedScalarEvolution::getSCEV((int8x16_t *)a2, v7);
    }
    uint64_t v19 = (llvm::SCEV *)llvm::PredicatedScalarEvolution::getSCEV((int8x16_t *)a2, v8);
    uint64_t v20 = *(void *)(llvm::ScalarEvolution::getMinusSCEV(*(llvm::ScalarEvolution **)(a2 + 88), v19, SCEV, 0, 0) + 32);
    uint64_t v21 = (void *)(v20 + 24);
    uint64_t v22 = *(unsigned int *)(v20 + 32);
    if (v22 < 0x41) {
      return *v21 == (-(1 << Alignment) & ((1 << Alignment)
    }
                                         - 1
                                         + ((unint64_t)(v13 + 7) >> 3)));
    int v23 = 0;
    int64_t v24 = (unint64_t)(v22 + 63) >> 6;
    do
    {
      if (v24-- < 1) {
        break;
      }
      unint64_t v26 = *(void *)(*v21 + 8 * v24);
      v23 += __clz(v26);
    }
    while (!v26);
    BOOL result = 0;
    int v27 = v22 | 0xFFFFFFC0;
    if ((v22 & 0x3F) == 0) {
      int v27 = 0;
    }
    if ((v22 - v23 - v27) <= 0x40)
    {
      uint64_t v21 = (void *)*v21;
      return *v21 == (-(1 << Alignment) & ((1 << Alignment)
                                         - 1
                                         + ((unint64_t)(v13 + 7) >> 3)));
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](v30[0], 8);
    return 0;
  }
  return result;
}

void *sub_1CCDE2304(_DWORD *a1, uint64_t *a2)
{
  int v3 = a1[4];
  if (!v3)
  {
    uint64_t v12 = 0;
LABEL_15:
    uint64_t v6 = sub_1CBF569E0(a1, (uint64_t)a2, a2, v12);
    *uint64_t v6 = *a2;
    *((_DWORD *)v6 + 2) = 0;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
  uint64_t v6 = (void *)(*(void *)a1 + 16 * v5);
  uint64_t v7 = *v6;
  if (*a2 != *v6)
  {
    uint64_t v8 = 0;
    int v9 = 1;
    while (v7 != -4096)
    {
      if (v8) {
        BOOL v10 = 0;
      }
      else {
        BOOL v10 = v7 == -8192;
      }
      if (v10) {
        uint64_t v8 = v6;
      }
      unsigned int v11 = v5 + v9++;
      unsigned int v5 = v11 & v4;
      uint64_t v6 = (void *)(*(void *)a1 + 16 * (v11 & v4));
      uint64_t v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v8) {
      uint64_t v12 = v8;
    }
    else {
      uint64_t v12 = v6;
    }
    goto LABEL_15;
  }
  return v6;
}

llvm::SmallPtrSetImplBase *sub_1CCDE23C4(uint64_t *a1, uint64_t *a2, llvm::SmallPtrSetImplBase *this)
{
  if (a1 != a2)
  {
    for (uint64_t i = a1; i != a2; ++i)
    {
      uint64_t v6 = *i;
      if (*i && *(unsigned char *)(v6 + 16) == 61)
      {
        uint64_t v7 = *(void *)(v6 - 32);
        uint64_t v8 = *((void *)this + 1);
        uint64_t v9 = *((unsigned int *)this + 5);
        if (v8 != *(void *)this)
        {
          unsigned int v13 = *((_DWORD *)this + 4);
LABEL_16:
          if (3 * v13 <= 4 * ((int)v9 - *((_DWORD *)this + 6)))
          {
            if (v13 >= 0x40) {
              v13 *= 2;
            }
            else {
              unsigned int v13 = 128;
            }
          }
          else if (v13 - v9 >= v13 >> 3)
          {
            goto LABEL_18;
          }
          llvm::SmallPtrSetImplBase::Grow(this, v13);
          unsigned int v13 = *((_DWORD *)this + 4);
          uint64_t v8 = *((void *)this + 1);
LABEL_18:
          unsigned int v14 = v13 - 1;
          unsigned int v15 = (v13 - 1) & ((v7 >> 4) ^ (v7 >> 9));
          uint64_t v16 = (void *)(v8 + 8 * v15);
          uint64_t v17 = *v16;
          if (*v16 == -1)
          {
            unsigned int v18 = 0;
LABEL_30:
            if (v18) {
              uint64_t v22 = v18;
            }
            else {
              uint64_t v22 = v16;
            }
            if (*v22 != v7)
            {
              if (*v22 == -2) {
                --*((_DWORD *)this + 6);
              }
              else {
                ++*((_DWORD *)this + 5);
              }
              *uint64_t v22 = v7;
            }
          }
          else
          {
            unsigned int v18 = 0;
            int v19 = 1;
            while (v17 != v7)
            {
              if (v18) {
                BOOL v20 = 0;
              }
              else {
                BOOL v20 = v17 == -2;
              }
              if (v20) {
                unsigned int v18 = v16;
              }
              unsigned int v21 = v15 + v19++;
              unsigned int v15 = v21 & v14;
              uint64_t v16 = (void *)(v8 + 8 * (v21 & v14));
              uint64_t v17 = *v16;
              if (*v16 == -1) {
                goto LABEL_30;
              }
            }
          }
          continue;
        }
        if (v9)
        {
          BOOL v10 = 0;
          uint64_t v11 = 8 * v9;
          uint64_t v12 = (void *)*((void *)this + 1);
          while (*v12 != v7)
          {
            if (*v12 == -2) {
              BOOL v10 = v12;
            }
            ++v12;
            v11 -= 8;
            if (!v11)
            {
              if (!v10) {
                goto LABEL_13;
              }
              *BOOL v10 = v7;
              --*((_DWORD *)this + 6);
              goto LABEL_37;
            }
          }
          continue;
        }
LABEL_13:
        unsigned int v13 = *((_DWORD *)this + 4);
        if (v9 >= v13) {
          goto LABEL_16;
        }
        *((_DWORD *)this + 5) = v9 + 1;
        *(void *)(v8 + 8 * v9) = v7;
      }
LABEL_37:
      ;
    }
  }
  return this;
}

void sub_1CCDE258C()
{
}

uint64_t sub_1CCDE25E0()
{
  int v2 = 1;
  int v3 = 1;
  *(void *)&long long v1 = "Max number of memchecks allowed per eliminated load on average";
  *((void *)&v1 + 1) = 62;
  int v4 = &v2;
  sub_1CD413D64((uint64_t)&unk_1EBCF4818, "runtime-check-per-loop-load-elim", &v3, &v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF4818, &dword_1CB82C000);
  int v2 = 1;
  int v3 = 8;
  int v4 = &v3;
  *(void *)&long long v1 = "The maximum number of SCEV checks allowed for Loop Load Elimination";
  *((void *)&v1 + 1) = 67;
  sub_1CD77229C(&v4, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCF48D8, &dword_1CB82C000);
}

void llvm::PassManager<llvm::Loop,llvm::AnalysisManager<llvm::Loop,llvm::LoopStandardAnalysisResults &>,llvm::LoopStandardAnalysisResults &,llvm::LPMUpdater &>::run(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  if (!*a2 && *(void *)(a1 + 96) != *(void *)(a1 + 104)) {
    llvm::PassManager<llvm::Loop,llvm::AnalysisManager<llvm::Loop,llvm::LoopStandardAnalysisResults &>,llvm::LoopStandardAnalysisResults &,llvm::LPMUpdater &>::runWithLoopNestPasses(a3);
  }
  llvm::PassManager<llvm::Loop,llvm::AnalysisManager<llvm::Loop,llvm::LoopStandardAnalysisResults &>,llvm::LoopStandardAnalysisResults &,llvm::LPMUpdater &>::runWithoutLoopNestPasses(a3);
}

void llvm::PassManager<llvm::Loop,llvm::AnalysisManager<llvm::Loop,llvm::LoopStandardAnalysisResults &>,llvm::LoopStandardAnalysisResults &,llvm::LPMUpdater &>::runWithoutLoopNestPasses(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v2 = a1 + 80;
  *(void *)(a1 + 48) = v2;
  *(void *)(a1 + 56) = v2;
  *(void *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 16) = 0x100000002;
  llvm::AnalysisManager<llvm::Loop,llvm::LoopStandardAnalysisResults &>::getResultImpl();
}

void sub_1CCDE287C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  if (sub_1CCDE3D88(a7, *a3))
  {
    std::string __dst = v54;
    uint64_t v51 = v54;
    uint64_t v52 = 2;
    int v53 = 0;
    unsigned int v55 = v59;
    uint64_t v56 = v59;
    uint64_t v57 = 2;
    int v58 = 0;
    (*(void (**)(void))(*(void *)*a3 + 32))();
    uint64_t v12 = **(uint64_t *****)(a2 + 32);
    if (v12)
    {
      if ((*((unsigned char *)v12 + 23) & 0x10) != 0)
      {
        uint64_t v13 = ***v12;
        uint64_t v14 = *(void *)(v13 + 152);
        int v15 = *(_DWORD *)(v13 + 168);
        if (v15)
        {
          unsigned int v16 = (v15 - 1) & ((v12 >> 4) ^ (v12 >> 9));
          uint64_t v17 = *(uint64_t ****)(v14 + 16 * v16);
          if (v17 != v12)
          {
            int v18 = 1;
            do
            {
              if (v17 == (uint64_t ***)-4096) {
                break;
              }
              unsigned int v19 = v16 + v18++;
              unsigned int v16 = v19 & (v15 - 1);
              uint64_t v17 = *(uint64_t ****)(v14 + 16 * v16);
            }
            while (v17 != v12);
          }
        }
      }
    }
    BOOL v25 = (uint64_t *)off_1EC7DFC00();
    if (*v25)
    {
      if (v22) {
        unint64_t v26 = "<unnamed loop>";
      }
      else {
        unint64_t v26 = v24;
      }
      if (v22) {
        uint64_t v27 = 14;
      }
      else {
        uint64_t v27 = v23;
      }
      llvm::timeTraceProfilerBegin(v21, v20, (uint64_t)v26, v27);
    }
    (*(void (**)(void **__return_ptr))(*(void *)*a3 + 16))(&v42);
    if (v51 != __dst) {
      free(v51);
    }
    if (v43 == v42)
    {
      uint64_t v51 = __dst;
      if (HIDWORD(v44)) {
        memmove(__dst, v43, 8 * HIDWORD(v44));
      }
    }
    else
    {
      uint64_t v51 = v43;
      unint64_t v43 = v42;
    }
    uint64_t v52 = v44;
    int v53 = v45;
    uint64_t v44 = 2;
    int v45 = 0;
    if (v56 != v55) {
      free(v56);
    }
    uint64_t v28 = v46;
    int v29 = v47;
    if (v47 == v46)
    {
      uint64_t v56 = v55;
      if (HIDWORD(v48))
      {
        memmove(v55, v47, 8 * HIDWORD(v48));
        int v29 = v46;
        uint64_t v28 = v47;
      }
      else
      {
        uint64_t v28 = v47;
      }
    }
    else
    {
      uint64_t v56 = v47;
      int v47 = v46;
      int v29 = v46;
    }
    uint64_t v57 = v48;
    int v58 = v49;
    uint64_t v48 = 2;
    int v49 = 0;
    if (v28 != v29) {
      free(v28);
    }
    if (v43 != v42) {
      free(v43);
    }
    if (*v25) {
      sub_1CD84B62C(*v25);
    }
    uint64_t v30 = *a3;
    uint64_t v31 = *a7;
    if (*(unsigned char *)(a6 + 24)) {
      sub_1CCDE4158(v31, v30, (uint64_t)&__dst);
    }
    else {
      sub_1CCDE4200(v31, v30);
    }
    uint64_t v32 = (void *)(a1 + 32);
    *(void *)a1 = a1 + 32;
    uint64_t v34 = __dst;
    uint64_t v33 = v51;
    if (v51 == __dst)
    {
      *(void *)(a1 + 8) = v32;
      int v35 = HIDWORD(v52);
      if (HIDWORD(v52)) {
        memmove(v32, v33, 8 * HIDWORD(v52));
      }
    }
    else
    {
      *(void *)(a1 + 8) = v51;
      uint64_t v51 = v34;
      uint64_t v33 = v34;
      int v35 = HIDWORD(v52);
    }
    int v36 = v53;
    *(_DWORD *)(a1 + 16) = v52;
    *(_DWORD *)(a1 + 20) = v35;
    *(_DWORD *)(a1 + 24) = v36;
    uint64_t v52 = 2;
    int v53 = 0;
    unsigned int v37 = (void *)(a1 + 80);
    *(void *)(a1 + 48) = a1 + 80;
    uint64_t v39 = v55;
    int v38 = v56;
    if (v56 == v55)
    {
      *(void *)(a1 + 56) = v37;
      int v40 = HIDWORD(v57);
      if (HIDWORD(v57)) {
        memmove(v37, v38, 8 * HIDWORD(v57));
      }
    }
    else
    {
      *(void *)(a1 + 56) = v56;
      uint64_t v56 = v39;
      int v38 = v39;
      int v40 = HIDWORD(v57);
    }
    int v41 = v58;
    *(_DWORD *)(a1 + 64) = v57;
    *(_DWORD *)(a1 + 68) = v40;
    *(_DWORD *)(a1 + 72) = v41;
    uint64_t v57 = 2;
    int v58 = 0;
    *(unsigned char *)(a1 + 96) = 1;
    if (v38 != v39)
    {
      free(v38);
      uint64_t v34 = __dst;
      uint64_t v33 = v51;
    }
    if (v33 != v34) {
      free(v33);
    }
  }
  else
  {
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 96) = 0;
  }
}

void sub_1CCDE2C60(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  if (*a7)
  {
    uint64_t v11 = *a3;
    char v12 = (*(uint64_t (**)(void))(*(void *)*a3 + 40))(*a3);
    uint64_t v13 = *a7;
    if ((v12 & 1) == 0 && *(_DWORD *)(v13 + 8))
    {
      (*(void (**)(uint64_t))(*(void *)v11 + 32))(v11);
      std::string __dst = 0;
      operator new();
    }
    if (*(_DWORD *)(v13 + 296))
    {
      (*(void (**)(uint64_t))(*(void *)v11 + 32))(v11);
      int v53 = 0;
      operator new();
    }
  }
  std::string __dst = v65;
  uint64_t v62 = v65;
  uint64_t v63 = 2;
  int v64 = 0;
  uint64_t v66 = v70;
  BOOL v67 = v70;
  uint64_t v68 = 2;
  int v69 = 0;
  (*(void (**)(void))(*(void *)*a3 + 32))();
  uint64_t v14 = **(uint64_t *****)(**(void **)(a2 + 8) + 32);
  if (v14 && (*((unsigned char *)v14 + 23) & 0x10) != 0)
  {
    uint64_t v16 = ***v14;
    uint64_t v17 = *(void *)(v16 + 152);
    int v18 = *(_DWORD *)(v16 + 168);
    uint64_t v15 = a6;
    if (v18)
    {
      unsigned int v19 = (v18 - 1) & ((v14 >> 4) ^ (v14 >> 9));
      uint64_t v20 = *(uint64_t ****)(v17 + 16 * v19);
      if (v20 != v14)
      {
        int v21 = 1;
        do
        {
          if (v20 == (uint64_t ***)-4096) {
            break;
          }
          unsigned int v22 = v19 + v21++;
          unsigned int v19 = v22 & (v18 - 1);
          uint64_t v20 = *(uint64_t ****)(v17 + 16 * v19);
        }
        while (v20 != v14);
      }
    }
  }
  else
  {
    uint64_t v15 = a6;
  }
  uint64_t v28 = (uint64_t *)off_1EC7DFC00();
  if (*v28)
  {
    if (v25) {
      int v29 = "<unnamed loop>";
    }
    else {
      int v29 = v27;
    }
    if (v25) {
      uint64_t v30 = 14;
    }
    else {
      uint64_t v30 = v26;
    }
    llvm::timeTraceProfilerBegin(v24, v23, (uint64_t)v29, v30);
  }
  (*(void (**)(void **__return_ptr))(*(void *)*a3 + 16))(&v53);
  if (v62 != __dst) {
    free(v62);
  }
  if (v54 == v53)
  {
    uint64_t v62 = __dst;
    if (HIDWORD(v55)) {
      memmove(__dst, v54, 8 * HIDWORD(v55));
    }
  }
  else
  {
    uint64_t v62 = v54;
    uint64_t v54 = v53;
  }
  uint64_t v63 = v55;
  int v64 = v56;
  uint64_t v55 = 2;
  int v56 = 0;
  if (v67 != v66) {
    free(v67);
  }
  uint64_t v31 = v57;
  uint64_t v32 = v58;
  if (v58 == v57)
  {
    BOOL v67 = v66;
    if (HIDWORD(v59))
    {
      memmove(v66, v58, 8 * HIDWORD(v59));
      uint64_t v32 = v57;
      uint64_t v31 = v58;
    }
    else
    {
      uint64_t v31 = v58;
    }
  }
  else
  {
    BOOL v67 = v58;
    int v58 = v57;
    uint64_t v32 = v57;
  }
  uint64_t v68 = v59;
  int v69 = v60;
  uint64_t v59 = 2;
  int v60 = 0;
  if (v31 != v32) {
    free(v31);
  }
  if (v54 != v53) {
    free(v54);
  }
  if (*v28) {
    sub_1CD84B62C(*v28);
  }
  uint64_t v33 = *a3;
  uint64_t v34 = *a7;
  if (*(unsigned char *)(v15 + 24))
  {
    if (v34)
    {
      uint64_t v35 = *(unsigned int *)(v34 + 584);
      if (v35)
      {
        int v36 = *(void **)(v34 + 576);
        uint64_t v37 = 32 * v35;
        do
        {
          uint64_t v39 = (*(uint64_t (**)(uint64_t))(*(void *)v33 + 32))(v33);
          uint64_t v40 = v36[3];
          int v41 = v36;
          if ((v40 & 2) == 0) {
            int v41 = (void *)*v36;
          }
          (*(void (**)(void *, uint64_t, uint64_t, void **))(v40 & 0xFFFFFFFFFFFFFFF8))(v41, v39, v38, &__dst);
          v36 += 4;
          v37 -= 32;
        }
        while (v37);
      }
    }
  }
  else if (v34 && *(_DWORD *)(v34 + 440))
  {
    (*(void (**)(uint64_t))(*(void *)v33 + 32))(v33);
    int v53 = 0;
    operator new();
  }
  uint64_t v42 = (void *)(a1 + 32);
  *(void *)a1 = a1 + 32;
  uint64_t v44 = __dst;
  unint64_t v43 = v62;
  if (v62 == __dst)
  {
    *(void *)(a1 + 8) = v42;
    int v45 = HIDWORD(v63);
    if (HIDWORD(v63)) {
      memmove(v42, v43, 8 * HIDWORD(v63));
    }
  }
  else
  {
    *(void *)(a1 + 8) = v62;
    uint64_t v62 = v44;
    unint64_t v43 = v44;
    int v45 = HIDWORD(v63);
  }
  int v46 = v64;
  *(_DWORD *)(a1 + 16) = v63;
  *(_DWORD *)(a1 + 20) = v45;
  *(_DWORD *)(a1 + 24) = v46;
  uint64_t v63 = 2;
  int v64 = 0;
  int v47 = (void *)(a1 + 80);
  *(void *)(a1 + 48) = a1 + 80;
  int v49 = v66;
  uint64_t v48 = v67;
  if (v67 == v66)
  {
    *(void *)(a1 + 56) = v47;
    int v50 = HIDWORD(v68);
    if (HIDWORD(v68)) {
      memmove(v47, v48, 8 * HIDWORD(v68));
    }
  }
  else
  {
    *(void *)(a1 + 56) = v67;
    BOOL v67 = v49;
    uint64_t v48 = v49;
    int v50 = HIDWORD(v68);
  }
  int v51 = v69;
  *(_DWORD *)(a1 + 64) = v68;
  *(_DWORD *)(a1 + 68) = v50;
  *(_DWORD *)(a1 + 72) = v51;
  uint64_t v68 = 2;
  int v69 = 0;
  *(unsigned char *)(a1 + 96) = 1;
  if (v48 != v49)
  {
    free(v48);
    uint64_t v44 = __dst;
    unint64_t v43 = v62;
  }
  if (v43 != v44) {
    free(v43);
  }
}

void llvm::FunctionToLoopPassAdaptor::run()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

uint64_t sub_1CCDE3D88(uint64_t *a1, uint64_t a2)
{
  if (*a1)
  {
    char v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
    uint64_t v5 = *a1;
    if ((v4 & 1) == 0 && *(_DWORD *)(v5 + 8))
    {
      (*(void (**)(uint64_t))(*(void *)a2 + 32))(a2);
      operator new();
    }
    if (*(_DWORD *)(v5 + 296))
    {
      (*(void (**)(uint64_t))(*(void *)a2 + 32))(a2);
      operator new();
    }
  }
  return 1;
}

uint64_t sub_1CCDE4158(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    uint64_t v3 = *(unsigned int *)(result + 584);
    if (v3)
    {
      uint64_t v6 = *(void **)(result + 576);
      uint64_t v7 = 32 * v3;
      do
      {
        uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
        uint64_t v10 = v6[3];
        uint64_t v11 = v6;
        if ((v10 & 2) == 0) {
          uint64_t v11 = (void *)*v6;
        }
        BOOL result = (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(v10 & 0xFFFFFFFFFFFFFFF8))(v11, v9, v8, a3);
        v6 += 4;
        v7 -= 32;
      }
      while (v7);
    }
  }
  return result;
}

uint64_t sub_1CCDE4200(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (*(_DWORD *)(result + 440))
    {
      (*(void (**)(uint64_t))(*(void *)a2 + 32))(a2);
      uint64_t v2 = 0;
      operator new();
    }
  }
  return result;
}

llvm::PrintLoopPass *llvm::PrintLoopPass::PrintLoopPass(llvm::PrintLoopPass *this)
{
  *(void *)this = llvm::dbgs(this);
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  return this;
}

{
  *(void *)this = llvm::dbgs(this);
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  return this;
}

void *llvm::PrintLoopPass::PrintLoopPass(void *a1, uint64_t a2, long long *a3)
{
  *a1 = a2;
  uint64_t v4 = (uint64_t)(a1 + 1);
  if (*((char *)a3 + 23) < 0)
  {
    sub_1CB8BDF7C(v4, *(const void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v5 = *a3;
    *(void *)(v4 + 16) = *((void *)a3 + 2);
    *(_OWORD *)uint64_t v4 = v5;
  }
  return a1;
}

{
  uint64_t v4;
  long long v5;

  *a1 = a2;
  uint64_t v4 = (uint64_t)(a1 + 1);
  if (*((char *)a3 + 23) < 0)
  {
    sub_1CB8BDF7C(v4, *(const void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v5 = *a3;
    *(void *)(v4 + 16) = *((void *)a3 + 2);
    *(_OWORD *)uint64_t v4 = v5;
  }
  return a1;
}

void sub_1CCDE4410(llvm *a1, llvm::PassRegistry *a2)
{
  llvm::initializeBranchProbabilityInfoWrapperPassPass(a1, a2);
  llvm::initializeLoopPassPass(a1, v3);
  operator new();
}

uint64_t sub_1CCDE44B4(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF4998;
  *(_DWORD *)(a1 + 24) = 1;
  *(void *)a1 = &unk_1F263F0B0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF49A0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCDE4410;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCF49A0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CCDE4564(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 40) = a2;
  uint64_t v31 = *(llvm::Instruction **)(*(void *)(**(void **)(a2 + 32) + 56) + 40);
  uint64_t v2 = (uint64_t *)*((void *)v31 + 14);
  unsigned int v3 = *((_DWORD *)v2 + 8);
  if (v3 <= 1) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = v3;
  }
  if (v3 <= 0x16) {
    size_t v5 = v4;
  }
  else {
    size_t v5 = 23;
  }
  uint64_t v6 = (llvm::Instruction *)*((unsigned int *)v2 + 2);
  uint64_t v33 = v6;
  if (!v6) {
    goto LABEL_20;
  }
  uint64_t v7 = 0;
  int v8 = 0;
  do
    int v8 = 33 * v8 + aLlvmExperiment_45[v7++];
  while (v5 != v7);
  int v9 = v6 - 1;
  uint64_t v10 = *v2;
  uint64_t v11 = *v2 + 8 * (void)v6 + 8;
  int v12 = 1;
  int v13 = v8;
  while (1)
  {
    uint64_t v14 = v13 & v9;
    uint64_t v15 = *(void **)(v10 + 8 * v14);
    if (v15 != (void *)-8)
    {
      if (!v15) {
        goto LABEL_21;
      }
      if (*(_DWORD *)(v11 + 4 * v14) == v8
        && v5 == *v15
        && !memcmp("llvm.experimental.guard", (char *)v15 + *((unsigned int *)v2 + 5), v5))
      {
        break;
      }
    }
    int v13 = v12 + v14;
    ++v12;
  }
  if (v14 == -1)
  {
LABEL_21:
    BOOL v17 = 0;
    uint64_t v6 = v33;
    goto LABEL_22;
  }
  uint64_t v6 = v33;
  if ((llvm::Instruction *)(int)v14 == v33
    || (uint64_t v16 = *(void *)(*(void *)(v10 + 8 * (int)v14) + 8)) == 0
    || *(unsigned char *)(v16 + 16))
  {
LABEL_20:
    BOOL v17 = 0;
  }
  else
  {
    BOOL v17 = *(void *)(v16 + 8) != 0;
  }
LABEL_22:
  if (v3 <= 1) {
    uint64_t v18 = 1;
  }
  else {
    uint64_t v18 = v3;
  }
  if (v3 <= 0x24) {
    size_t v19 = v18;
  }
  else {
    size_t v19 = 37;
  }
  if (!v6) {
    goto LABEL_41;
  }
  uint64_t v20 = 0;
  int v21 = 0;
  do
    int v21 = 33 * v21 + aLlvmExperiment_58[v20++];
  while (v19 != v20);
  int v22 = v6 - 1;
  uint64_t v23 = *v2;
  uint64_t v24 = *v2 + 8 * (void)v6 + 8;
  int v25 = 1;
  int v26 = v21;
  while (1)
  {
    uint64_t v27 = v26 & v22;
    uint64_t v28 = *(void **)(v23 + 8 * v27);
    if (v28 != (void *)-8)
    {
      if (!v28) {
        goto LABEL_42;
      }
      if (*(_DWORD *)(v24 + 4 * v27) == v21
        && v19 == *v28
        && !memcmp("llvm.experimental.widenable.condition", (char *)v28 + *((unsigned int *)v2 + 5), v19))
      {
        break;
      }
    }
    int v26 = v25 + v27;
    ++v25;
  }
  if (v27 != -1
    && (llvm::Instruction *)(int)v27 != v33
    && (uint64_t v29 = *(void *)(*(void *)(v23 + 8 * (int)v27) + 8)) != 0)
  {
    LODWORD(v28) = 0;
    if (byte_1EBCF4D28 && !*(unsigned char *)(v29 + 16)) {
      LODWORD(v28) = *(void *)(v29 + 8) != 0;
    }
  }
  else
  {
LABEL_41:
    LODWORD(v28) = 0;
  }
LABEL_42:
  if ((v17 | v28) == 1)
  {
    *(void *)(a1 + 48) = (char *)v31 + 272;
    llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopPredecessor();
  }
  return 0;
}

void sub_1CCDE6AD4()
{
}

void sub_1CCDE6B14(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCDE6B4C(uint64_t a1, llvm *a2)
{
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::BranchProbabilityInfoWrapperPass::ID);
  llvm::getLoopAnalysisUsage(a2, v3);

  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::MemorySSAWrapperPass::ID);
}

uint64_t sub_1CCDE6BA4(llvm::LoopPass *a1, const llvm::Loop *a2)
{
  if (llvm::LoopPass::skipLoop(a1, a2)) {
    return 0;
  }
  size_t v5 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v6 = *v5;
  uint64_t v7 = v5[1];
  if (v6 == v7)
  {
LABEL_6:
    uint64_t v8 = 0;
  }
  else
  {
    while (*(char **)v6 != llvm::ScalarEvolutionWrapperPass::ID)
    {
      v6 += 16;
      if (v6 == v7) {
        goto LABEL_6;
      }
    }
    uint64_t v8 = *(void *)(v6 + 8);
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v8 + 96))(v8, llvm::ScalarEvolutionWrapperPass::ID);
  uint64_t v10 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v11 = *v10;
  uint64_t v12 = v10[1];
  if (v11 == v12)
  {
LABEL_11:
    uint64_t v13 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v11 != &llvm::LoopInfoWrapperPass::ID)
    {
      v11 += 16;
      if (v11 == v12) {
        goto LABEL_11;
      }
    }
    uint64_t v13 = *(void *)(v11 + 8);
  }
  uint64_t v14 = *(void *)(v9 + 32);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v13 + 96))(v13, &llvm::LoopInfoWrapperPass::ID);
  uint64_t v16 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v17 = *v16;
  uint64_t v18 = v16[1];
  if (v17 == v18)
  {
LABEL_16:
    uint64_t v19 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v17 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v17 += 16;
      if (v17 == v18) {
        goto LABEL_16;
      }
    }
    uint64_t v19 = *(void *)(v17 + 8);
  }
  uint64_t v20 = v15 + 32;
  uint64_t v21 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v19 + 96))(v19, &llvm::DominatorTreeWrapperPass::ID)
      + 32;
  uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*((void *)a1 + 1) + 24), &llvm::MemorySSAWrapperPass::ID, 1);
  if (AnalysisPass
    && (*(uint64_t (**)(uint64_t, void *))(*(void *)AnalysisPass + 96))(AnalysisPass, &llvm::MemorySSAWrapperPass::ID))
  {
    operator new();
  }
  uint64_t v23 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v24 = *v23;
  uint64_t v25 = v23[1];
  if (v24 == v25)
  {
LABEL_24:
    uint64_t v26 = 0;
  }
  else
  {
    while (*(char **)v24 != llvm::AAResultsWrapperPass::ID)
    {
      v24 += 16;
      if (v24 == v25) {
        goto LABEL_24;
      }
    }
    uint64_t v26 = *(void *)(v24 + 8);
  }
  v28[0] = *(void *)((*(uint64_t (**)(uint64_t, char *))(*(void *)v26 + 96))(v26, llvm::AAResultsWrapperPass::ID)+ 32);
  v28[1] = v21;
  void v28[2] = v14;
  v28[3] = v20;
  v28[4] = 0;
  return sub_1CCDE4564((uint64_t)v28, (uint64_t)a2);
}

uint64_t sub_1CCDE6EF0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = *(void *)(a3 - 64);
  uint64_t result = *(void *)(a2 + 16);
  uint64_t v7 = *(void *)(result + 104);
  unsigned int v8 = *(_DWORD *)(result + 120);
  if (!v8)
  {
LABEL_7:
    uint64_t v11 = v7 + 48 * v8;
    goto LABEL_8;
  }
  unsigned int v9 = v8 - 1;
  unsigned int v10 = (v8 - 1) & ((v5 >> 4) ^ (v5 >> 9));
  uint64_t v11 = v7 + 48 * v10;
  uint64_t v12 = *(void *)(v11 + 24);
  if (v12 != v5)
  {
    int v13 = 1;
    while (v12 != -4096)
    {
      unsigned int v14 = v10 + v13++;
      unsigned int v10 = v14 & v9;
      uint64_t v11 = v7 + 48 * (v14 & v9);
      uint64_t v12 = *(void *)(v11 + 24);
      if (v12 == v5) {
        goto LABEL_8;
      }
    }
    goto LABEL_7;
  }
LABEL_8:
  __int16 v15 = *(_WORD *)(a3 + 18);
  unint64_t v16 = *(void *)(a3 - 32);
  if (v11 == v7 + 48 * v8 || (uint64_t v17 = *(const llvm::SCEV **)(v11 + 40)) == 0)
  {
    uint64_t result = llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)result, v5);
    uint64_t v17 = (const llvm::SCEV *)result;
  }
  if (*((_WORD *)v17 + 12) == 15) {
    goto LABEL_47;
  }
  uint64_t result = *(void *)(a2 + 16);
  uint64_t v18 = *(void *)(result + 104);
  unsigned int v19 = *(_DWORD *)(result + 120);
  if (!v19) {
    goto LABEL_18;
  }
  unsigned int v20 = (v19 - 1) & ((v16 >> 4) ^ (v16 >> 9));
  uint64_t v21 = v18 + 48 * v20;
  uint64_t v22 = *(void *)(v21 + 24);
  if (v22 != v16)
  {
    int v23 = 1;
    while (v22 != -4096)
    {
      unsigned int v24 = v20 + v23++;
      unsigned int v20 = v24 & (v19 - 1);
      uint64_t v21 = v18 + 48 * v20;
      uint64_t v22 = *(void *)(v21 + 24);
      if (v22 == v16) {
        goto LABEL_19;
      }
    }
LABEL_18:
    uint64_t v21 = v18 + 48 * v19;
  }
LABEL_19:
  if (v21 == v18 + 48 * v19 || (uint64_t v25 = *(const llvm::SCEV **)(v21 + 40)) == 0)
  {
    uint64_t result = llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)result, v16);
    uint64_t v25 = (const llvm::SCEV *)result;
  }
  if (*((_WORD *)v25 + 12) != 15)
  {
    int v26 = v15 & 0x3F;
    uint64_t result = llvm::ScalarEvolution::getLoopDisposition(*(llvm::ScalarEvolution **)(a2 + 16), v17, *(const llvm::Loop **)(a2 + 40));
    if (result == 1)
    {
      uint64_t v27 = v17;
      switch(v15 & 0x3F)
      {
        case 2:
          int v26 = 4;
          goto LABEL_44;
        case 3:
          int v26 = 5;
          goto LABEL_44;
        case 4:
          int v26 = 2;
          goto LABEL_44;
        case 5:
          int v26 = 3;
          goto LABEL_44;
        case 0xA:
          int v26 = 12;
          goto LABEL_44;
        case 0xB:
          int v26 = 13;
          goto LABEL_44;
        case 0xC:
          int v26 = 10;
          goto LABEL_44;
        case 0xD:
          int v26 = 11;
          goto LABEL_44;
        case 0x10:
        case 0x11:
        case 0x12:
        case 0x13:
        case 0x14:
        case 0x15:
        case 0x16:
        case 0x17:
        case 0x18:
        case 0x19:
        case 0x1A:
        case 0x1B:
        case 0x1C:
        case 0x1D:
        case 0x1E:
        case 0x1F:
          __break(1u);
          JUMPOUT(0x1CCDE7170);
        case 0x22:
          int v26 = 36;
          goto LABEL_44;
        case 0x23:
          int v26 = 37;
          goto LABEL_44;
        case 0x24:
          int v26 = 34;
          goto LABEL_44;
        case 0x25:
          int v26 = 35;
          goto LABEL_44;
        case 0x26:
          int v26 = 40;
          goto LABEL_44;
        case 0x27:
          int v26 = 41;
          goto LABEL_44;
        case 0x28:
          int v26 = 38;
          goto LABEL_44;
        case 0x29:
          int v26 = 39;
LABEL_44:
          uint64_t v27 = v17;
          if (v25) {
            goto LABEL_45;
          }
          goto LABEL_47;
        default:
          goto LABEL_27;
      }
    }
    uint64_t v27 = v25;
    uint64_t v25 = v17;
LABEL_27:
    if (v25)
    {
LABEL_45:
      if (*((_WORD *)v25 + 12) == 7 && *((void *)v25 + 6) == *(void *)(a2 + 40))
      {
        *(_DWORD *)a1 = v26;
        char v28 = 1;
        *(void *)(a1 + 8) = v25;
        *(void *)(a1 + 16) = v27;
        goto LABEL_48;
      }
    }
  }
LABEL_47:
  char v28 = 0;
  *(unsigned char *)a1 = 0;
LABEL_48:
  *(unsigned char *)(a1 + 24) = v28;
  return result;
}

uint64_t sub_1CCDE7218(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4 == a1 + 40)
  {
    uint64_t v6 = 0;
  }
  else
  {
    if (v4) {
      uint64_t v5 = v4 - 24;
    }
    else {
      uint64_t v5 = 0;
    }
    if (*(unsigned __int8 *)(v5 + 16) - 29 >= 0xB) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = v5;
    }
  }
  unint64_t v7 = *(void *)(v6 + 48);
  unsigned int v8 = *(_DWORD *)(v6 + 20);
  if (v7)
  {
    if ((v8 & 0x20000000) == 0) {
      goto LABEL_32;
    }
  }
  else if ((v8 & 0x20000000) == 0)
  {
    unint64_t v7 = *(unsigned __int8 *)(v6 + 16);
    if (v7 != 30)
    {
      unsigned int v9 = 0;
      switch(*(unsigned char *)(v6 + 16))
      {
        case 0x1E:
LABEL_100:
          __break(1u);
          goto LABEL_101;
        case 0x1F:
          unsigned int v9 = (v8 >> 1) & 0x3FFFFFF;
          return ((v9 >> 1) | 0x80000000) / v9;
        case 0x20:
        case 0x26:
          unsigned int v9 = (v8 & 0x7FFFFFF) - 1;
          return ((v9 >> 1) | 0x80000000) / v9;
        case 0x21:
          unsigned int v9 = 2;
          return ((v9 >> 1) | 0x80000000) / v9;
        case 0x24:
          unsigned int v9 = *(_WORD *)(v6 + 18) & 1;
          return ((v9 >> 1) | 0x80000000) / v9;
        case 0x25:
          unsigned int v9 = 1;
          return ((v9 >> 1) | 0x80000000) / v9;
        case 0x27:
          unsigned int v9 = *(_DWORD *)(v6 + 80) + 1;
          goto LABEL_81;
        default:
          return ((v9 >> 1) | 0x80000000) / v9;
      }
    }
    if ((v8 & 0x7FFFFFF) == 3) {
      unsigned int v9 = 2;
    }
    else {
      unsigned int v9 = 1;
    }
    return ((v9 >> 1) | 0x80000000) / v9;
  }
  uint64_t v10 = ***(void ***)v6;
  uint64_t v52 = v6;
  int v11 = *(_DWORD *)(v10 + 2496);
  if (v11)
  {
    uint64_t v12 = *(void *)(v10 + 2480);
    int v13 = v11 - 1;
    unsigned int v14 = v13 & ((v6 >> 4) ^ (v6 >> 9));
    __int16 v15 = (void *)(v12 + 40 * v14);
    uint64_t v16 = *v15;
    if (*v15 == v6) {
      goto LABEL_27;
    }
    uint64_t v17 = 0;
    int v18 = 1;
    while (v16 != -4096)
    {
      if (v17) {
        BOOL v19 = 0;
      }
      else {
        BOOL v19 = v16 == -8192;
      }
      if (v19) {
        uint64_t v17 = v15;
      }
      unsigned int v20 = v14 + v18++;
      unsigned int v14 = v20 & v13;
      __int16 v15 = (void *)(v12 + 40 * v14);
      uint64_t v16 = *v15;
      if (*v15 == v6) {
        goto LABEL_27;
      }
    }
    if (v17) {
      uint64_t v48 = v17;
    }
    else {
      uint64_t v48 = v15;
    }
  }
  else
  {
    uint64_t v48 = 0;
  }
  __int16 v15 = sub_1CC609054(v10 + 2480, (uint64_t)&v52, &v52, v48);
  uint64_t v49 = v52;
  v15[3] = 0;
  v15[4] = 0;
  *__int16 v15 = v49;
  v15[1] = v15 + 3;
  v15[2] = 0x100000000;
LABEL_27:
  unint64_t v7 = *((unsigned int *)v15 + 4);
  if (!v7)
  {
LABEL_32:
    unint64_t v2 = 0;
    goto LABEL_33;
  }
  uint64_t v21 = (void *)(v15[1] + 8);
  v7 *= 16;
  while (*((_DWORD *)v21 - 2) != 2)
  {
    unint64_t v2 = 0;
    v21 += 2;
    v7 -= 16;
    if (!v7) {
      goto LABEL_33;
    }
  }
  unint64_t v2 = *v21;
LABEL_33:
  int v22 = *(unsigned __int8 *)(v6 + 16);
  if (v22 != 30)
  {
    unsigned int v9 = 0;
    switch(*(unsigned char *)(v6 + 16))
    {
      case 0x1E:
        goto LABEL_100;
      case 0x1F:
        unsigned int v9 = (*(_DWORD *)(v6 + 20) >> 1) & 0x3FFFFFF;
        goto LABEL_37;
      case 0x20:
      case 0x26:
        unsigned int v9 = (*(_DWORD *)(v6 + 20) & 0x7FFFFFF) - 1;
        goto LABEL_37;
      case 0x21:
        unsigned int v9 = 2;
        goto LABEL_37;
      case 0x24:
        unsigned int v9 = *(_WORD *)(v6 + 18) & 1;
        goto LABEL_37;
      case 0x25:
        unsigned int v9 = 1;
        goto LABEL_37;
      case 0x27:
        unsigned int v9 = *(_DWORD *)(v6 + 80) + 1;
        goto LABEL_37;
      default:
        goto LABEL_37;
    }
  }
  if ((*(_DWORD *)(v6 + 20) & 0x7FFFFFF) == 3) {
    unsigned int v9 = 2;
  }
  else {
    unsigned int v9 = 1;
  }
LABEL_37:
  if (!v2) {
    goto LABEL_81;
  }
  unint64_t v7 = *(unsigned int *)(v2 + 8);
  int v23 = (uint64_t *)(v2 - 8 * v7);
  uint64_t v24 = *v23;
  if (!*v23) {
    goto LABEL_81;
  }
  if (!*(unsigned char *)v24)
  {
    uint64_t v42 = *(void **)(v24 + 8);
    if (*v42 != 14) {
      goto LABEL_81;
    }
    uint64_t v43 = v42[3];
    uint64_t v44 = *(void *)((char *)v42 + 30);
    if (v43 != 0x775F68636E617262 || v44 != 0x737468676965775FLL) {
      goto LABEL_81;
    }
  }
  if (v22 != 30)
  {
    unint64_t v2 = 0;
    switch(*(unsigned char *)(v6 + 16))
    {
      case 0x1E:
        goto LABEL_100;
      case 0x1F:
        LODWORD(v2) = (*(_DWORD *)(v6 + 20) >> 1) & 0x3FFFFFF;
        goto LABEL_44;
      case 0x20:
      case 0x26:
        LODWORD(v2) = (*(_DWORD *)(v6 + 20) & 0x7FFFFFF) - 1;
        goto LABEL_44;
      case 0x21:
        LODWORD(v2) = 2;
        goto LABEL_44;
      case 0x24:
        LODWORD(v2) = *(_WORD *)(v6 + 18) & 1;
        goto LABEL_44;
      case 0x25:
        LODWORD(v2) = 1;
        goto LABEL_44;
      case 0x27:
        LODWORD(v2) = *(_DWORD *)(v6 + 80) + 1;
        goto LABEL_44;
      default:
        goto LABEL_44;
    }
  }
  LODWORD(v2) = (*(_DWORD *)(v6 + 20) & 0x7FFFFFF) == 3 ? 2 : 1;
LABEL_44:
  if (v7 != v2 + 1)
  {
LABEL_81:
    if (v9 == 0x80000000) {
      return 1;
    }
    return ((v9 >> 1) | 0x80000000) / v9;
  }
  if (!v9)
  {
    LODWORD(result) = 0;
    unint64_t v7 = 0;
    return (((unint64_t)result << 31) | (v7 >> 1)) / v7;
  }
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  unint64_t v7 = 0;
  unint64_t v2 = 0;
  uint64_t v27 = 2 * v9;
  char v28 = v23 + 1;
  unsigned int v29 = -1;
  uint64_t v30 = (uint64_t *)(v6 - 32);
  do
  {
    uint64_t v31 = *(void *)(*v28 + 128);
    uint64_t v32 = (void *)(v31 + 24);
    if (*(_DWORD *)(v31 + 32) >= 0x41u) {
      uint64_t v32 = (void *)*v32;
    }
    ++v26;
    uint64_t v33 = (void *)*v32;
    uint64_t v34 = v30;
    if (v22 != 30)
    {
      uint64_t v34 = (uint64_t *)(v6 - 32);
      switch(*(unsigned char *)(v6 + 16))
      {
        case ' ':
        case '&':
          int v39 = *(_DWORD *)(v6 + 20);
          if ((v39 & 0x40000000) != 0) {
            uint64_t v40 = *(void *)(v6 - 8);
          }
          else {
            uint64_t v40 = v6 - 32 * (v39 & 0x7FFFFFF);
          }
          uint64_t v34 = (uint64_t *)(v40 + 32 * v26);
          break;
        case '!':
          if (v25) {
            uint64_t v41 = -64;
          }
          else {
            uint64_t v41 = -96;
          }
          uint64_t v34 = (uint64_t *)(v6 + v41);
          break;
        case '""':
        case '#':
          goto LABEL_100;
        case '$':
          if ((*(_WORD *)(v6 + 18) & 1) == 0)
          {
            uint64_t v35 = 0;
            goto LABEL_51;
          }
          uint64_t v34 = (uint64_t *)(v6 + 32 - 32 * (*(_DWORD *)(v6 + 20) & 0x7FFFFFF));
          break;
        case '%':
          break;
        case '\'':
          if (v25) {
            uint64_t v34 = (uint64_t *)(v6 - 32 - 32 * *(unsigned int *)(v6 + 80) + 32 * v29);
          }
          else {
            uint64_t v34 = (uint64_t *)(v6 - 64 - 32 * *(unsigned int *)(v6 + 80));
          }
          break;
        default:
          int v37 = *(_DWORD *)(v6 + 20);
          if ((v37 & 0x40000000) != 0) {
            uint64_t v38 = *(void *)(v6 - 8);
          }
          else {
            uint64_t v38 = v6 - 32 * (v37 & 0x7FFFFFF);
          }
          uint64_t v34 = (uint64_t *)(v38 + 32 * (v25 & 0xFFFFFFFE) + 32);
          break;
      }
    }
    uint64_t v35 = *v34;
LABEL_51:
    if (v35 == a2) {
      int v36 = v33;
    }
    else {
      int v36 = 0;
    }
    v2 += (unint64_t)v36;
    v7 += (unint64_t)v33;
    v30 -= 4;
    v25 += 2;
    ++v29;
    ++v28;
  }
  while (v27 != v25);
  unint64_t v47 = HIDWORD(v7);
  if (HIDWORD(v7))
  {
LABEL_101:
    LOBYTE(v47) = 0;
    unint64_t v50 = v7;
    do
    {
      unint64_t v7 = v50 >> 1;
      LOBYTE(v47) = v47 + 1;
      unint64_t v51 = v50 >> 33;
      v50 >>= 1;
    }
    while (v51);
  }
  uint64_t result = v2 >> v47;
  if (v7 != 0x80000000) {
    return (((unint64_t)result << 31) | (v7 >> 1)) / v7;
  }
  return result;
}

uint64_t sub_1CCDE7808(uint64_t a1, uint64_t a2, uint64_t a3, llvm::SCEVExpander *a4, const llvm::BasicBlock **a5)
{
  unsigned int v115 = 0;
  uint64_t v116 = 0;
  v150[1] = *MEMORY[0x1E4F143B8];
  uint64_t v128 = v131;
  unsigned int v130 = 4;
  v131[0] = a3;
  unsigned int v117 = v121;
  unsigned int v118 = v121;
  uint64_t v119 = 4;
  int v120 = 0;
  unsigned int v7 = 1;
  do
  {
    while (1)
    {
      uint64_t v8 = *((void *)v128 + v7 - 1);
      unsigned int v129 = v7 - 1;
      unsigned int v9 = v118;
      uint64_t v10 = HIDWORD(v119);
      if (v118 == v117)
      {
        if (HIDWORD(v119))
        {
          int v11 = 0;
          uint64_t v12 = 8 * HIDWORD(v119);
          int v13 = (uint64_t *)v118;
          do
          {
            if (*v13 == v8) {
              goto LABEL_125;
            }
            if (*v13 == -2) {
              int v11 = v13;
            }
            ++v13;
            v12 -= 8;
          }
          while (v12);
          if (v11)
          {
            *int v11 = v8;
            --v120;
            goto LABEL_34;
          }
        }
        unsigned int v14 = v119;
        if (HIDWORD(v119) < v119)
        {
          ++HIDWORD(v119);
          *(void *)&v118[8 * v10] = v8;
          goto LABEL_34;
        }
      }
      else
      {
        unsigned int v14 = v119;
      }
      if (3 * v14 <= 4 * (HIDWORD(v119) - v120))
      {
        if (v14 >= 0x40) {
          v14 *= 2;
        }
        else {
          unsigned int v14 = 128;
        }
LABEL_98:
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v117, v14);
        unsigned int v14 = v119;
        unsigned int v9 = v118;
        goto LABEL_15;
      }
      if (v14 - HIDWORD(v119) < v14 >> 3) {
        goto LABEL_98;
      }
LABEL_15:
      unsigned int v15 = v14 - 1;
      unsigned int v16 = (v14 - 1) & ((v8 >> 4) ^ (v8 >> 9));
      uint64_t v17 = &v9[8 * v16];
      uint64_t v18 = *(void *)v17;
      if (*(void *)v17 != -1)
      {
        BOOL v19 = 0;
        int v20 = 1;
        while (v18 != v8)
        {
          if (v19) {
            BOOL v21 = 0;
          }
          else {
            BOOL v21 = v18 == -2;
          }
          if (v21) {
            BOOL v19 = (uint64_t *)v17;
          }
          unsigned int v22 = v16 + v20++;
          unsigned int v16 = v22 & v15;
          uint64_t v17 = &v9[8 * (v22 & v15)];
          uint64_t v18 = *(void *)v17;
          if (*(void *)v17 == -1) {
            goto LABEL_27;
          }
        }
        goto LABEL_125;
      }
      BOOL v19 = 0;
LABEL_27:
      if (v19) {
        int v23 = v19;
      }
      else {
        int v23 = (uint64_t *)v17;
      }
      if (*v23 == v8) {
        goto LABEL_125;
      }
      if (*v23 == -2) {
        --v120;
      }
      else {
        ++HIDWORD(v119);
      }
      *int v23 = v8;
LABEL_34:
      unsigned int v24 = *(unsigned __int8 *)(v8 + 16);
      if (v24 <= 0x50) {
        break;
      }
      if (v24 == 81)
      {
        sub_1CCDE6EF0((uint64_t)&v122, a1, v8);
        if (!v125) {
          goto LABEL_123;
        }
        if (v122 != 36) {
          goto LABEL_123;
        }
        uint64_t v30 = v123;
        if (*(void *)(v123 + 40) != 2) {
          goto LABEL_123;
        }
        uint64_t v31 = *(void **)(v123 + 32);
        uint64_t v32 = (llvm::SCEV *)v31[1];
        if (!llvm::SCEV::isOne(v32) && (!llvm::SCEV::isAllOnesValue(v32) || byte_1EBCF4AE8 == 0)) {
          goto LABEL_123;
        }
        while (2)
        {
          uint64_t v34 = *v31;
          switch(*(_WORD *)(*v31 + 24))
          {
            case 1:
            case 2:
            case 3:
            case 0xD:
              uint64_t v35 = (llvm::Type **)(v34 + 40);
              break;
            case 4:
              uint64_t v35 = (llvm::Type **)(v34 + 48);
              break;
            case 5:
            case 7:
            case 8:
            case 9:
            case 0xA:
            case 0xB:
            case 0xC:
              uint64_t v31 = *(void **)(v34 + 32);
              continue;
            case 6:
              uint64_t v31 = (void *)(v34 + 40);
              continue;
            case 0xE:
              uint64_t v35 = *(llvm::Type ***)(v34 - 8);
              break;
            default:
              uint64_t v35 = *(llvm::Type ***)(v34 + 32);
              break;
          }
          break;
        }
        int v36 = *v35;
        uint64_t v37 = *(void *)(a1 + 48);
        uint64_t v38 = *(llvm::ScalarEvolution **)(a1 + 16);
        uint64_t v39 = *(void *)(a1 + 64);
        uint64_t v40 = *(void *)(a1 + 72);
        uint64_t v112 = v39;
        uint64_t v114 = *(llvm::SCEV **)(a1 + 80);
        uint64_t v41 = *(uint64_t **)(v40 + 32);
        while (2)
        {
          uint64_t v42 = *v41;
          switch(*(_WORD *)(v42 + 24))
          {
            case 1:
            case 2:
            case 3:
            case 0xD:
              uint64_t v43 = (uint64_t *)(v42 + 40);
              break;
            case 4:
              uint64_t v43 = (uint64_t *)(v42 + 48);
              break;
            case 5:
            case 7:
            case 8:
            case 9:
            case 0xA:
            case 0xB:
            case 0xC:
              uint64_t v41 = *(uint64_t **)(v42 + 32);
              continue;
            case 6:
              uint64_t v41 = (uint64_t *)(v42 + 40);
              continue;
            case 0xE:
              uint64_t v43 = *(uint64_t **)(v42 - 8);
              break;
            default:
              uint64_t v43 = *(uint64_t **)(v42 + 32);
              break;
          }
          break;
        }
        if ((llvm::Type *)*v43 != v36)
        {
          long long v110 = *(llvm::ScalarEvolution **)(a1 + 16);
          unint64_t v44 = sub_1CB83544C(v37, *v43);
          if (v44 < sub_1CB83544C(v37, (uint64_t)v36) || byte_1EBCF4A28 == 0) {
            goto LABEL_123;
          }
          int v46 = *((_WORD *)v114 + 12) ? 0 : v114;
          uint64_t v47 = *(_WORD *)(**(void **)(v40 + 32) + 24) ? 0 : **(void **)(v40 + 32);
          uint64_t v109 = v46;
          BOOL v48 = !v46 || v47 == 0;
          if (v48 || (llvm::ScalarEvolution::getMonotonicPredicateTypeImpl(v110, v40, v39) & 0xFF00000000) == 0) {
            goto LABEL_123;
          }
          unint64_t v49 = sub_1CB83544C(v37, (uint64_t)v36);
          uint64_t v50 = *(void *)(v47 + 32);
          uint64_t v51 = *(unsigned int *)(v50 + 32);
          if (v51 > 0x40)
          {
            int v53 = 0;
            int64_t v54 = (unint64_t)(v51 + 63) >> 6;
            do
            {
              BOOL v55 = v54-- < 1;
              if (v55) {
                break;
              }
              unint64_t v56 = *(void *)(*(void *)(v50 + 24) + 8 * v54);
              v53 += __clz(v56);
            }
            while (!v56);
            int v57 = v51 | 0xFFFFFFC0;
            if ((v51 & 0x3F) == 0) {
              int v57 = 0;
            }
            int v52 = v53 + v57;
          }
          else
          {
            int v52 = v51 + __clz(*(void *)(v50 + 24)) - 64;
          }
          if (v49 <= (v51 - v52)) {
            goto LABEL_123;
          }
          uint64_t v58 = *((void *)v109 + 4);
          uint64_t v59 = *(unsigned int *)(v58 + 32);
          if (v59 > 0x40)
          {
            int v61 = 0;
            int64_t v62 = (unint64_t)(v59 + 63) >> 6;
            do
            {
              BOOL v55 = v62-- < 1;
              if (v55) {
                break;
              }
              unint64_t v63 = *(void *)(*(void *)(v58 + 24) + 8 * v62);
              v61 += __clz(v63);
            }
            while (!v63);
            int v64 = v59 | 0xFFFFFFC0;
            if ((v59 & 0x3F) == 0) {
              int v64 = 0;
            }
            int v60 = v61 + v64;
          }
          else
          {
            int v60 = v59 + __clz(*(void *)(v58 + 24)) - 64;
          }
          if (v49 <= (v59 - v60)
            || (uint64_t TruncateExpr = llvm::ScalarEvolution::getTruncateExpr(v110, (const llvm::SCEV *)v40, v36, 0)) == 0
            || (uint64_t v40 = TruncateExpr, *(_WORD *)(TruncateExpr + 24) != 7))
          {
LABEL_123:
            unint64_t v68 = *(unsigned int *)(a2 + 8);
            if (v68 >= *(unsigned int *)(a2 + 12)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)a2 + 8 * v68) = v8;
            ++*(_DWORD *)(a2 + 8);
            goto LABEL_125;
          }
          uint64_t v114 = (llvm::SCEV *)llvm::ScalarEvolution::getTruncateExpr(v110, v114, v36, 0);
          uint64_t v38 = *(llvm::ScalarEvolution **)(a1 + 16);
        }
        uint64_t v66 = *(void *)(v40 + 40);
        if (v66 == 2)
        {
          uint64_t v67 = *(void *)(*(void *)(v40 + 32) + 8);
        }
        else
        {
          uint64_t v104 = *(void *)(v40 + 32);
          BOOL v135 = v137;
          uint64_t v136 = 0x300000000;
          unint64_t v105 = 8 * v66 - 8;
          if (v105 >= 0x19) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          int v106 = 0;
          if (v66 != 1)
          {
            memcpy(v135, (const void *)(v104 + 8), 8 * v66 - 8);
            int v106 = v136;
          }
          LODWORD(v136) = v106 + (v105 >> 3);
          uint64_t v67 = sub_1CD478318(v38, (uint64_t)&v135, *(const llvm::Loop **)(v40 + 48), 0);
          if (v135 != v137) {
            free(v135);
          }
        }
        if (v32 != (llvm::SCEV *)v67) {
          goto LABEL_123;
        }
        BOOL isOne = llvm::SCEV::isOne(v32);
        int v70 = v124;
        unint64_t v71 = **(const llvm::APInt ***)(v30 + 32);
        unsigned int v72 = v71;
        while (2)
        {
          switch(*((_WORD *)v72 + 12))
          {
            case 1:
            case 2:
            case 3:
            case 0xD:
              int v74 = (llvm::Type **)((char *)v72 + 40);
              goto LABEL_135;
            case 4:
              int v74 = (llvm::Type **)((char *)v72 + 48);
              goto LABEL_135;
            case 5:
            case 7:
            case 8:
            case 9:
            case 0xA:
            case 0xB:
            case 0xC:
              uint64_t v73 = (const llvm::APInt **)*((void *)v72 + 4);
              goto LABEL_130;
            case 6:
              uint64_t v73 = (const llvm::APInt **)((char *)v72 + 40);
LABEL_130:
              unsigned int v72 = *v73;
              continue;
            case 0xE:
              int v74 = (llvm::Type **)*((void *)v72 - 1);
              goto LABEL_135;
            default:
              int v74 = (llvm::Type **)*((void *)v72 + 4);
LABEL_135:
              uint64_t v75 = *v74;
              int v76 = **(const llvm::SCEV ***)(v40 + 32);
              int v77 = sub_1CCDE8598(a1, **(const llvm::SCEV ***)(v30 + 32));
              if (isOne)
              {
                if (!v77
                  || !sub_1CCDE8598(a1, v70)
                  || !sub_1CCDE8598(a1, v76)
                  || !sub_1CCDE8598(a1, v114)
                  || !llvm::isSafeToExpandAt(v76, a5, *(const llvm::Instruction **)(a1 + 16), v78)
                  || !llvm::isSafeToExpandAt(v114, a5, *(const llvm::Instruction **)(a1 + 16), v79))
                {
                  goto LABEL_123;
                }
                uint64_t v80 = *(llvm::ScalarEvolution **)(a1 + 16);
                unint64_t MinusSCEV = llvm::ScalarEvolution::getMinusSCEV(v80, v70, v71, 0, 0);
                uint64_t v82 = *(llvm::ScalarEvolution **)(a1 + 16);
                unint64_t Constant = (const llvm::APInt *)llvm::ScalarEvolution::getConstant(v82, v75, 1uLL, 0);
                unint64_t v84 = llvm::ScalarEvolution::getMinusSCEV(v82, v76, Constant, 0, 0);
                BOOL v135 = v137;
                v137[0] = MinusSCEV;
                v137[1] = v84;
                uint64_t v136 = 0x200000002;
                unint64_t AddExpr = (const llvm::SCEV *)llvm::ScalarEvolution::getAddExpr((uint64_t)v80, (unint64_t **)&v135, 0, 0);
                if (v135 != v137) {
                  free(v135);
                }
                uint64_t FlippedStrictnessPredicate = llvm::CmpInst::getFlippedStrictnessPredicate(v112);
                uint64_t v87 = (uint64_t)a5;
                uint64_t v88 = sub_1CCDE8754(a1, a4, (uint64_t)a5, FlippedStrictnessPredicate, v114, AddExpr);
                uint64_t v89 = sub_1CCDE8754(a1, a4, (uint64_t)a5, 36, v71, v70);
                unsigned int v132 = v89;
                unint64_t v133 = v88;
              }
              else
              {
                if (!v77
                  || !sub_1CCDE8598(a1, v70)
                  || !sub_1CCDE8598(a1, v76)
                  || !sub_1CCDE8598(a1, v114)
                  || !llvm::isSafeToExpandAt(v76, a5, *(const llvm::Instruction **)(a1 + 16), v90)
                  || !llvm::isSafeToExpandAt(v114, a5, *(const llvm::Instruction **)(a1 + 16), v91)
                  || v30 != llvm::SCEVAddRecExpr::getPostIncExpr((llvm::SCEVAddRecExpr *)v40, *(llvm::ScalarEvolution **)(a1 + 16)))
                {
                  goto LABEL_123;
                }
                uint64_t v92 = llvm::CmpInst::getFlippedStrictnessPredicate(v112);
                uint64_t v87 = (uint64_t)a5;
                uint64_t v89 = sub_1CCDE8754(a1, a4, (uint64_t)a5, 36, v71, v70);
                int v93 = (const llvm::SCEV *)llvm::ScalarEvolution::getConstant(*(llvm::ScalarEvolution **)(a1 + 16), v75, 1uLL, 0);
                uint64_t v88 = sub_1CCDE8754(a1, a4, (uint64_t)a5, v92, v114, v93);
                unsigned int v132 = v89;
                unint64_t v133 = v88;
              }
              uint64_t v94 = sub_1CCDE850C(a1, v87, (uint64_t *)&v132, 2);
              uint64_t v95 = 0;
              uint64_t v96 = **(void **)v94;
              BOOL v135 = v137;
              uint64_t v136 = 0x200000000;
              uint64_t v140 = v96;
              int32x2_t v141 = &v149;
              __int32 v142 = v150;
              uint64_t v143 = 0;
              int v144 = 0;
              __int16 v145 = 512;
              char v146 = 7;
              uint64_t v138 = 0;
              uint64_t v139 = 0;
              uint64_t v147 = 0;
              uint64_t v148 = 0;
              uint64_t v149 = &unk_1F2616E88;
              v150[0] = &unk_1F2617008;
              uint64_t v138 = *(void *)(v94 + 40);
              uint64_t v139 = v94 + 24;
              long long v97 = *(unsigned __int8 **)(v94 + 48);
              unsigned int v126 = v97;
              if (v97)
              {
                llvm::MetadataTracking::track((uint64_t)&v126, v97, 2);
                uint64_t v95 = (uint64_t)v126;
              }
              sub_1CB8461A4((uint64_t)&v135, 0, v95);
              if (!v126) {
                goto LABEL_156;
              }
              int v100 = *v126;
              if ((v100 - 4) > 0x1E)
              {
                if ((v100 - 3) >= 0xFFFFFFFE) {
                  uint64_t v103 = v126;
                }
                else {
                  uint64_t v103 = 0;
                }
                if ((v100 - 3) >= 0xFFFFFFFE)
                {
                  unint64_t v102 = (unint64_t)(v103 + 8);
LABEL_175:
                  uint64_t v127 = &v126;
                  sub_1CC5FA668(v102 + 16, &v127);
                  goto LABEL_156;
                }
                if (v100 == 3) {
                  *((void *)v126 + 1) = 0;
                }
              }
              else if ((v126[1] & 0x7F) == 2 || *((_DWORD *)v126 + 3))
              {
                uint64_t v101 = *((void *)v126 + 2);
                if ((v101 & 4) != 0)
                {
                  unint64_t v102 = v101 & 0xFFFFFFFFFFFFFFF8;
                  if (v102) {
                    goto LABEL_175;
                  }
                }
              }
LABEL_156:
              __int16 v134 = 257;
              long long v98 = sub_1CBF52474((uint64_t)&v135, v89, (uint64_t)v88, (uint64_t)&v132);
              if (v135 != v137) {
                free(v135);
              }
              unint64_t v99 = *(unsigned int *)(a2 + 8);
              if (v99 >= *(unsigned int *)(a2 + 12)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)(*(void *)a2 + 8 * v99) = v98;
              ++*(_DWORD *)(a2 + 8);
              ++v115;
              break;
          }
          break;
        }
      }
      else
      {
        if (v24 != 84) {
          goto LABEL_123;
        }
        uint64_t v27 = *(void *)(v8 - 32);
        if (!v27
          || *(unsigned char *)(v27 + 16)
          || *(void *)(v27 + 24) != *(void *)(v8 + 72)
          || *(_DWORD *)(v27 + 36) != 138)
        {
          goto LABEL_123;
        }
        uint64_t v116 = v8;
      }
LABEL_125:
      unsigned int v7 = v129;
      if (!v129) {
        goto LABEL_186;
      }
    }
    if (v24 == 5)
    {
      if (*(_WORD *)(v8 + 18) != 28) {
        goto LABEL_123;
      }
      char v28 = (uint64_t *)(v8 - 32 * (*(_DWORD *)(v8 + 20) & 0x7FFFFFF));
      uint64_t v25 = *v28;
      if (!*v28) {
        goto LABEL_123;
      }
      uint64_t v26 = v28[4];
      if (!v26) {
        goto LABEL_123;
      }
    }
    else
    {
      if (v24 != 56) {
        goto LABEL_123;
      }
      uint64_t v25 = *(void *)(v8 - 64);
      if (!v25) {
        goto LABEL_123;
      }
      uint64_t v26 = *(void *)(v8 - 32);
      if (!v26) {
        goto LABEL_123;
      }
    }
    if (v129 >= (unint64_t)v130) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v128 + v129) = v25;
    unsigned int v29 = v129 + 1;
    unsigned int v129 = v29;
    if (v29 >= v130) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v128 + v29) = v26;
    unsigned int v7 = v129 + 1;
    unsigned int v129 = v7;
  }
  while (v7);
LABEL_186:
  if (v116)
  {
    unsigned int v107 = *(_DWORD *)(a2 + 8);
    if (v107 >= *(_DWORD *)(a2 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)a2 + 8 * v107) = v116;
    ++*(_DWORD *)(a2 + 8);
  }
  if (v118 != v117) {
    free(v118);
  }
  if (v128 != v131) {
    free(v128);
  }
  return v115;
}

uint64_t sub_1CCDE850C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v7 = 8 * a4;
    while (llvm::Loop::isLoopInvariant(*(void *)(a1 + 40), *a3))
    {
      ++a3;
      v7 -= 8;
      if (!v7) {
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    uint64_t v8 = *(void *)(a1 + 56);
    uint64_t v9 = *(void *)(v8 + 40);
    if (v9 == v8 + 40)
    {
      return 0;
    }
    else
    {
      if (v9) {
        uint64_t v10 = v9 - 24;
      }
      else {
        uint64_t v10 = 0;
      }
      if (*(unsigned __int8 *)(v10 + 16) - 29 >= 0xB) {
        return 0;
      }
      else {
        return v10;
      }
    }
  }
  return a2;
}

uint64_t sub_1CCDE8598(uint64_t a1, const llvm::SCEV *a2)
{
  uint64_t result = llvm::ScalarEvolution::getLoopDisposition(*(llvm::ScalarEvolution **)(a1 + 16), a2, *(const llvm::Loop **)(a1 + 40));
  if (result != 1)
  {
    uint64_t result = 0;
    if (a2)
    {
      if (*((_WORD *)a2 + 12) == 14)
      {
        uint64_t v5 = *((void *)a2 - 1);
        if (!v5
          || *(unsigned char *)(v5 + 16) != 60
          || (*(_WORD *)(v5 + 18) & 0x301) != 0
          || !llvm::Loop::hasLoopInvariantOperands(*(void *)(a1 + 40), v5))
        {
          return 0;
        }
        uint64_t v6 = *(void *)a1;
        v23[0] = *(void *)(v5 - 32);
        v23[1] = -1;
        long long v24 = 0u;
        long long v25 = 0u;
        if (llvm::AAResults::pointsToConstantMemory(v6, (uint64_t)v23, 0)) {
          return 1;
        }
        if ((*(unsigned char *)(v5 + 23) & 0x20) == 0) {
          return 0;
        }
        uint64_t v7 = ***(void ***)v5;
        v23[0] = v5;
        int v8 = *(_DWORD *)(v7 + 2496);
        if (v8)
        {
          uint64_t v9 = *(void *)(v7 + 2480);
          int v10 = v8 - 1;
          unsigned int v11 = v10 & ((v5 >> 4) ^ (v5 >> 9));
          uint64_t v12 = (void *)(v9 + 40 * v11);
          uint64_t v13 = *v12;
          if (*v12 == v5)
          {
LABEL_21:
            uint64_t v18 = *((unsigned int *)v12 + 4);
            if (v18)
            {
              BOOL v19 = (void *)(v12[1] + 8);
              uint64_t v20 = 16 * v18;
              while (*((_DWORD *)v19 - 2) != 6)
              {
                v19 += 2;
                v20 -= 16;
                if (!v20) {
                  return 0;
                }
              }
              if (*v19) {
                return 1;
              }
            }
            return 0;
          }
          unsigned int v14 = 0;
          int v15 = 1;
          while (v13 != -4096)
          {
            if (v14) {
              BOOL v16 = 0;
            }
            else {
              BOOL v16 = v13 == -8192;
            }
            if (v16) {
              unsigned int v14 = v12;
            }
            unsigned int v17 = v11 + v15++;
            unsigned int v11 = v17 & v10;
            uint64_t v12 = (void *)(v9 + 40 * v11);
            uint64_t v13 = *v12;
            if (*v12 == v5) {
              goto LABEL_21;
            }
          }
          if (v14) {
            BOOL v21 = v14;
          }
          else {
            BOOL v21 = v12;
          }
        }
        else
        {
          BOOL v21 = 0;
        }
        uint64_t v12 = sub_1CC609054(v7 + 2480, (uint64_t)v23, v23, v21);
        uint64_t v22 = v23[0];
        void v12[3] = 0;
        v12[4] = 0;
        void *v12 = v22;
        v12[1] = v12 + 3;
        v12[2] = 0x100000000;
        goto LABEL_21;
      }
    }
  }
  return result;
}

void *sub_1CCDE8754(uint64_t a1, llvm::SCEVExpander *a2, uint64_t a3, uint64_t a4, llvm::SCEV *a5, const llvm::SCEV *a6)
{
  v69[1] = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a5;
  while (2)
  {
    switch(*((_WORD *)v13 + 12))
    {
      case 1:
      case 2:
      case 3:
      case 0xD:
        int v15 = (llvm::Type **)((char *)v13 + 40);
        goto LABEL_9;
      case 4:
        int v15 = (llvm::Type **)((char *)v13 + 48);
        goto LABEL_9;
      case 5:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
        unsigned int v14 = (llvm::SCEV **)*((void *)v13 + 4);
        goto LABEL_4;
      case 6:
        unsigned int v14 = (llvm::SCEV **)((char *)v13 + 40);
LABEL_4:
        uint64_t v13 = *v14;
        continue;
      case 0xE:
        int v15 = (llvm::Type **)*((void *)v13 - 1);
        goto LABEL_9;
      default:
        int v15 = (llvm::Type **)*((void *)v13 + 4);
LABEL_9:
        BOOL v16 = *v15;
        if (llvm::ScalarEvolution::getLoopDisposition(*(llvm::ScalarEvolution **)(a1 + 16), a5, *(const llvm::Loop **)(a1 + 40)) != 1|| llvm::ScalarEvolution::getLoopDisposition(*(llvm::ScalarEvolution **)(a1 + 16), a6, *(const llvm::Loop **)(a1 + 40)) != 1)
        {
          goto LABEL_28;
        }
        uint64_t v17 = 0;
        uint64_t v18 = **(uint64_t ***)a3;
        int64_t v54 = v56;
        uint64_t v55 = 0x200000000;
        uint64_t v59 = v18;
        int v60 = &v68;
        int v61 = v69;
        uint64_t v62 = 0;
        int v63 = 0;
        __int16 v64 = 512;
        char v65 = 7;
        uint64_t v66 = 0;
        uint64_t v67 = 0;
        unint64_t v68 = &unk_1F2616E88;
        v69[0] = &unk_1F2617008;
        BOOL v19 = *(unsigned __int8 **)(a3 + 48);
        uint64_t v57 = *(void *)(a3 + 40);
        uint64_t v58 = a3 + 24;
        uint64_t v50 = v19;
        if (v19)
        {
          llvm::MetadataTracking::track((uint64_t)&v50, v19, 2);
          uint64_t v17 = (uint64_t)v50;
        }
        sub_1CB8461A4((uint64_t)&v54, 0, v17);
        if (!v50) {
          goto LABEL_14;
        }
        int v40 = *v50;
        if ((v40 - 4) > 0x1E)
        {
          if ((v40 - 3) >= 0xFFFFFFFE) {
            unint64_t v44 = v50;
          }
          else {
            unint64_t v44 = 0;
          }
          if ((v40 - 3) >= 0xFFFFFFFE)
          {
            unint64_t v42 = (unint64_t)(v44 + 8);
LABEL_60:
            uint64_t v51 = &v50;
            sub_1CC5FA668(v42 + 16, &v51);
            goto LABEL_14;
          }
          if (v40 == 3) {
            *((void *)v50 + 1) = 0;
          }
        }
        else if ((v50[1] & 0x7F) == 2 || *((_DWORD *)v50 + 3))
        {
          uint64_t v41 = *((void *)v50 + 2);
          if ((v41 & 4) != 0)
          {
            unint64_t v42 = v41 & 0xFFFFFFFFFFFFFFF8;
            if (v42) {
              goto LABEL_60;
            }
          }
        }
LABEL_14:
        if (llvm::ScalarEvolution::isLoopEntryGuardedByCond(*(void *)(a1 + 16), *(void *)(a1 + 40), a4, (uint64_t)a5, (uint64_t)a6))
        {
          uint64_t v21 = *v59;
          uint64_t v6 = *(void **)(*v59 + 1560);
          if (!v6)
          {
            uint64_t v22 = *(llvm::ConstantInt **)(v21 + 1888);
            uint64_t v47 = *v59;
            unint64_t v23 = *(unsigned int *)(v21 + 1896);
            LODWORD(v52) = v23 >> 8;
            if (v23 >> 8 > 0x40) {
              operator new[]();
            }
            if (v23 <= 0xFF) {
              LOBYTE(v24) = 0;
            }
            else {
              unint64_t v24 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v23) + 63);
            }
            uint64_t v51 = (void *)(v24 & 1);
            uint64_t v6 = llvm::ConstantInt::get(v22, (llvm::LLVMContext *)&v51, v20);
            if (v52 >= 0x41 && v51) {
              MEMORY[0x1D25D9CB0](v51, 0x1000C8000313F17);
            }
            int v25 = 0;
            *(void *)(v47 + 1560) = v6;
            goto LABEL_26;
          }
LABEL_24:
          int v25 = 0;
          goto LABEL_26;
        }
        if (!llvm::ScalarEvolution::isLoopEntryGuardedByCond(*(void *)(a1 + 16), *(void *)(a1 + 40), dword_1CFB2CF94[(int)a4], (uint64_t)a5, (uint64_t)a6))
        {
          int v25 = 1;
          goto LABEL_26;
        }
        uint64_t v27 = *v59;
        uint64_t v6 = *(void **)(*v59 + 1568);
        if (v6) {
          goto LABEL_24;
        }
        int v45 = *(llvm::ConstantInt **)(v27 + 1888);
        uint64_t v48 = *v59;
        unsigned int v46 = *(_DWORD *)(v27 + 1896);
        LODWORD(v52) = v46 >> 8;
        if (v46 >> 8 > 0x40) {
          operator new[]();
        }
        uint64_t v51 = 0;
        uint64_t v6 = llvm::ConstantInt::get(v45, (llvm::LLVMContext *)&v51, v26);
        if (v52 >= 0x41 && v51) {
          MEMORY[0x1D25D9CB0](v51, 0x1000C8000313F17);
        }
        int v25 = 0;
        *(void *)(v48 + 1568) = v6;
LABEL_26:
        if (v54 == v56)
        {
          if (!v25) {
            return v6;
          }
        }
        else
        {
          free(v54);
          if (!v25) {
            return v6;
          }
        }
LABEL_28:
        int64_t v54 = a5;
        char v28 = (llvm::Instruction *)sub_1CCDE8E2C(a1, a3, (const llvm::SCEV **)&v54, 1);
        unsigned int v29 = llvm::SCEVExpander::expandCodeForImpl(a2, (llvm::Instruction **)a5, v16, v28);
        int64_t v54 = a6;
        uint64_t v30 = (llvm::Instruction *)sub_1CCDE8E2C(a1, a3, (const llvm::SCEV **)&v54, 1);
        uint64_t v31 = llvm::SCEVExpander::expandCodeForImpl(a2, (llvm::Instruction **)a6, v16, v30);
        uint64_t v51 = v29;
        int v52 = v31;
        uint64_t v32 = sub_1CCDE850C(a1, a3, (uint64_t *)&v51, 2);
        uint64_t v33 = 0;
        uint64_t v34 = **(uint64_t ***)v32;
        int64_t v54 = v56;
        uint64_t v55 = 0x200000000;
        uint64_t v59 = v34;
        int v60 = &v68;
        int v61 = v69;
        uint64_t v62 = 0;
        int v63 = 0;
        __int16 v64 = 512;
        char v65 = 7;
        uint64_t v66 = 0;
        uint64_t v67 = 0;
        unint64_t v68 = &unk_1F2616E88;
        v69[0] = &unk_1F2617008;
        uint64_t v57 = *(void *)(v32 + 40);
        uint64_t v58 = v32 + 24;
        uint64_t v35 = *(unsigned __int8 **)(v32 + 48);
        unint64_t v49 = v35;
        if (v35)
        {
          llvm::MetadataTracking::track((uint64_t)&v49, v35, 2);
          uint64_t v33 = (uint64_t)v49;
        }
        sub_1CB8461A4((uint64_t)&v54, 0, v33);
        if (v49)
        {
          int v37 = *v49;
          if ((v37 - 4) > 0x1E)
          {
            if ((v37 - 3) >= 0xFFFFFFFE) {
              uint64_t v43 = v49;
            }
            else {
              uint64_t v43 = 0;
            }
            if ((v37 - 3) < 0xFFFFFFFE)
            {
              if (v37 == 3) {
                *((void *)v49 + 1) = 0;
              }
              goto LABEL_31;
            }
            unint64_t v39 = (unint64_t)(v43 + 8);
          }
          else
          {
            if ((v49[1] & 0x7F) != 2 && !*((_DWORD *)v49 + 3)) {
              goto LABEL_31;
            }
            uint64_t v38 = *((void *)v49 + 2);
            if ((v38 & 4) == 0) {
              goto LABEL_31;
            }
            unint64_t v39 = v38 & 0xFFFFFFFFFFFFFFF8;
            if (!v39) {
              goto LABEL_31;
            }
          }
          uint64_t v50 = (unsigned __int8 *)&v49;
          sub_1CC5FA668(v39 + 16, &v50);
        }
LABEL_31:
        __int16 v53 = 257;
        uint64_t v6 = sub_1CB845F20((uint64_t)&v54, a4, v29, (uint64_t)v31, (uint64_t)&v51);
        if (v54 != v56) {
          free(v54);
        }
        return v6;
    }
  }
}

uint64_t sub_1CCDE8E2C(uint64_t a1, uint64_t a2, const llvm::SCEV **a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v7 = 8 * a4;
    while (1)
    {
      int v8 = *a3;
      if (llvm::ScalarEvolution::getLoopDisposition(*(llvm::ScalarEvolution **)(a1 + 16), *a3, *(const llvm::Loop **)(a1 + 40)) != 1)break; {
      uint64_t v10 = *(void *)(a1 + 56);
      }
      uint64_t v11 = *(void *)(v10 + 40);
      if (v11 == v10 + 40)
      {
        uint64_t v13 = 0;
      }
      else
      {
        uint64_t v12 = v11 ? v11 - 24 : 0;
        uint64_t v13 = *(unsigned __int8 *)(v12 + 16) - 29 >= 0xB ? 0 : (const llvm::BasicBlock **)v12;
      }
      if (!llvm::isSafeToExpandAt(v8, v13, *(const llvm::Instruction **)(a1 + 16), v9)) {
        break;
      }
      ++a3;
      v7 -= 8;
      if (!v7) {
        goto LABEL_14;
      }
    }
  }
  else
  {
LABEL_14:
    uint64_t v14 = *(void *)(a1 + 56);
    uint64_t v15 = *(void *)(v14 + 40);
    if (v15 == v14 + 40)
    {
      return 0;
    }
    else
    {
      if (v15) {
        uint64_t v16 = v15 - 24;
      }
      else {
        uint64_t v16 = 0;
      }
      if (*(unsigned __int8 *)(v16 + 16) - 29 >= 0xB) {
        return 0;
      }
      else {
        return v16;
      }
    }
  }
  return a2;
}

uint64_t sub_1CCDE8F10()
{
  LODWORD(v3) = 1;
  LOBYTE(v1) = 1;
  v4.n128_u64[0] = (unint64_t)&v1;
  sub_1CD772CBC(&v3, (char **)&v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCF49A8, &dword_1CB82C000);
  LODWORD(v3) = 1;
  LOBYTE(v1) = 1;
  v4.n128_u64[0] = (unint64_t)&v1;
  sub_1CD772DDC(&v3, (char **)&v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCF4A68, &dword_1CB82C000);
  LODWORD(v3) = 1;
  LOBYTE(v1) = 0;
  v4.n128_u64[0] = (unint64_t)&v1;
  sub_1CD772EFC(&v3, (char **)&v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCF4B28, &dword_1CB82C000);
  int v2 = 1;
  uint64_t v1 = 0x4000000000000000;
  unsigned int v3 = (double *)&v1;
  v4.n128_u64[0] = (unint64_t)"scale factor for the latch probability. Value should be greater than 1. Lower values are ignored";
  v4.n128_u64[1] = 96;
  sub_1CD77301C(&v2, &v3, &v4);
  __cxa_atexit((void (*)(void *))sub_1CC08F43C, &qword_1EBCF4BE8, &dword_1CB82C000);
  LODWORD(v1) = 1;
  v4.n128_u64[0] = (unint64_t)"Whether or not we should predicate guards expressed as widenable branches to deoptimize blocks";
  v4.n128_u64[1] = 94;
  LOBYTE(v2) = 1;
  unsigned int v3 = (double *)&v2;
  sub_1CD773194(&v1, &v4, (char **)&v3);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCF4CA8, &dword_1CB82C000);
}

void sub_1CCDE9070(llvm *a1, llvm::PassRegistry *a2)
{
}

uint64_t sub_1CCDE9118(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF4E28;
  *(_DWORD *)(a1 + 24) = 1;
  *(void *)a1 = &unk_1F263F160;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF4E30, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCDE9070;
    v5[1] = &PassRegistry;
    __n128 v4 = v5;
    std::__call_once(&qword_1EBCF4E30, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CCDE91C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = MEMORY[0x1F4188790](a1, a2, a3, a4);
  v869[92] = *MEMORY[0x1E4F143B8];
  if (((*((void *)v5 + 5) - *((void *)v5 + 4)) & 0x7FFFFFFF0) != 0) {
    return 0;
  }
  uint64_t v8 = (uint64_t)v5;
  uint64_t v9 = v4;
  if (!llvm::ScalarEvolution::hasLoopInvariantBackedgeTakenCount(*(llvm::ScalarEvolution **)(v4 + 16), v5)) {
    return 0;
  }
  uint64_t v10 = *(llvm::ScalarEvolution **)(v9 + 16);
  BackedgeTakenInfo = llvm::ScalarEvolution::getBackedgeTakenInfo(v10, (const llvm::Loop *)v8);
  uint64_t Exact = llvm::ScalarEvolution::BackedgeTakenInfo::getExact((uint64_t)BackedgeTakenInfo, v8, (uint64_t)v10);
  v825 = v827;
  uint64_t v826 = 0x1000000000;
  uint64_t v789 = v9 + 48;
  sub_1CD3C7F68((_DWORD *)(v9 + 48));
  *(void *)(v9 + 72) = 0;
  uint64_t v13 = **(void **)(v8 + 32);
  uint64_t v14 = v13 + 40;
  uint64_t v15 = *(void *)(v13 + 48);
  if (v15 != v13 + 40)
  {
    uint64_t v16 = *(void *)(v13 + 48);
    while (1)
    {
      uint64_t v17 = v16 - 24;
      if (!v16) {
        uint64_t v17 = 0;
      }
      if (*(unsigned char *)(v17 + 16) != 83) {
        break;
      }
      uint64_t v16 = *(void *)(v16 + 8);
      if (v16 == v14)
      {
        uint64_t v16 = v14;
        goto LABEL_17;
      }
    }
    unsigned int v18 = *(unsigned __int8 *)(v16 - 8) - 38;
    BOOL v103 = v18 > 0x38;
    uint64_t v19 = (1 << v18) & 0x100060000000001;
    BOOL v20 = v103 || v19 == 0;
    if (!v20) {
      uint64_t v16 = *(void *)(v16 + 8);
    }
LABEL_17:
    if (v15 != v16)
    {
      while (1)
      {
        unint64_t v21 = v15 ? v15 - 24 : 0;
        if (*(unsigned char *)(v21 + 16) == 83 && (*(unsigned __int8 *)(*(void *)v21 + 8) | 2) == 0xF) {
          break;
        }
LABEL_44:
        uint64_t v15 = *(void *)(v15 + 8);
        if (v15 == v16) {
          goto LABEL_93;
        }
      }
      uint64_t v22 = *(void *)(v9 + 16);
      uint64_t v23 = *(void *)(v22 + 104);
      unsigned int v24 = *(_DWORD *)(v22 + 120);
      if (v24)
      {
        unsigned int v25 = (v24 - 1) & ((v21 >> 4) ^ (v21 >> 9));
        uint64_t v26 = v23 + 48 * v25;
        uint64_t v27 = *(void *)(v26 + 24);
        if (v27 == v21)
        {
LABEL_30:
          if (v26 == v23 + 48 * v24 || (uint64_t SCEVIter = *(void *)(v26 + 40)) == 0) {
            uint64_t SCEVIter = llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)v22, v21);
          }
          if (SCEVIter) {
            BOOL v31 = *(unsigned __int16 *)(SCEVIter + 24) == 7;
          }
          else {
            BOOL v31 = 0;
          }
          if (v31 && *(void *)(SCEVIter + 48) == v8 && *(void *)(SCEVIter + 40) == 2)
          {
            uint64_t v32 = *(void *)(*(void *)(SCEVIter + 32) + 8);
            if (v32 && *(_WORD *)(v32 + 24) == 0)
            {
              uint64_t v34 = *(void *)(v32 + 32);
              unsigned int v35 = *(_DWORD *)(v34 + 32);
              uint64_t v785 = v9;
              uint64_t v783 = Exact;
              if (v35 > 0x40) {
                uint64_t v36 = **(void **)(v34 + 24);
              }
              else {
                uint64_t v36 = (uint64_t)(*(void *)(v34 + 24) << -(char)v35) >> -(char)v35;
              }
              unint64_t v828 = v21;
              sub_1CD45F378(v789, (uint64_t *)&v828)[1] = v36;
              uint64_t v37 = *(void *)(v21 + 8);
              if (v37)
              {
                int v38 = 1;
                uint64_t v39 = *(void *)(v21 + 8);
                do
                {
                  uint64_t v39 = *(void *)(v39 + 8);
                  --v38;
                }
                while (v39);
                if (-v38 == 1 || v38 == 0)
                {
                  while (1)
                  {
                    uint64_t v40 = *(void *)(v37 + 24);
                    uint64_t v41 = *(void *)(v40 + 8);
                    if (!v41) {
                      break;
                    }
                    int v42 = 1;
                    uint64_t v43 = *(void *)(v40 + 8);
                    do
                    {
                      uint64_t v43 = *(void *)(v43 + 8);
                      --v42;
                    }
                    while (v43);
                    BOOL v44 = sub_1CCDEE28C(*(void *)(v37 + 24));
                    if (-v42 != 1 && v42 != 0) {
                      break;
                    }
                    char v45 = v42 != -1 || v44;
                    if (v38) {
                      char v45 = 0;
                    }
                    BOOL v46 = v42 && v38 == -1;
                    if (v46 || (v45 & 1) != 0) {
                      break;
                    }
                    if (v40)
                    {
                      unsigned int v47 = *(unsigned __int8 *)(v40 + 16);
                      if (v47 >= 0x1C && v47 - 59 >= 0xFFFFFFEE)
                      {
                        if (v47 == 41)
                        {
                          while (1)
                          {
                            uint64_t v48 = *(void *)(v41 + 24);
                            int v49 = *(unsigned __int8 *)(v48 + 16);
                            if (v48 && v49 == 83)
                            {
                              if (v48 != v21) {
                                goto LABEL_54;
                              }
                            }
                            else
                            {
                              if ((*(unsigned char *)(v40 + 17) & 4) != 0)
                              {
                                uint64_t v50 = *(void *)(v48 + 8);
                                if (v50)
                                {
                                  if (v49 == 68 && *(void *)(v50 + 8) == 0) {
                                    uint64_t v48 = *(void *)(v50 + 24);
                                  }
                                }
                              }
                              if (!sub_1CCDEE28C(v48)) {
                                goto LABEL_54;
                              }
                            }
                            uint64_t v41 = *(void *)(v41 + 8);
                            if (!v41) {
                              goto LABEL_90;
                            }
                          }
                        }
                        break;
                      }
                    }
                    if (!v44) {
                      break;
                    }
LABEL_90:
                    uint64_t v37 = *(void *)(v37 + 8);
                    if (!v37)
                    {
                      uint64_t v9 = v785;
                      *(void *)(v785 + 72) = v21;
                      uint64_t Exact = v783;
                      goto LABEL_44;
                    }
                  }
                }
              }
LABEL_54:
              if (v826 >= (unint64_t)HIDWORD(v826)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              uint64_t v9 = v785;
              uint64_t Exact = v783;
              *((void *)v825 + v826) = v21;
              LODWORD(v826) = v826 + 1;
            }
          }
          goto LABEL_44;
        }
        int v28 = 1;
        while (v27 != -4096)
        {
          unsigned int v29 = v25 + v28++;
          unsigned int v25 = v29 & (v24 - 1);
          uint64_t v26 = v23 + 48 * v25;
          uint64_t v27 = *(void *)(v26 + 24);
          if (v27 == v21) {
            goto LABEL_30;
          }
        }
      }
      uint64_t v26 = v23 + 48 * v24;
      goto LABEL_30;
    }
  }
LABEL_93:
  unsigned int v52 = v826;
  if (v826)
  {
    uint64_t v784 = Exact;
    uint64_t v786 = v9;
    v816 = v818;
    uint64_t v817 = 0x1000000000;
    long long v819 = 0u;
    int v820 = 0;
    long long v821 = 0u;
    int v822 = 0;
    long long v823 = 0u;
    unsigned int v824 = 0;
    uint64_t v53 = **(void **)(v8 + 32);
    uint64_t v54 = v53 + 40;
    uint64_t v55 = *(void *)(v53 + 48);
    if (v55 == v53 + 40)
    {
      uint64_t v121 = (uint64_t *)v825;
      int v122 = (uint64_t *)((char *)v825 + 8 * v826);
    }
    else
    {
      uint64_t v56 = *(void *)(v53 + 48);
      while (1)
      {
        uint64_t v57 = v56 - 24;
        if (!v56) {
          uint64_t v57 = 0;
        }
        if (*(unsigned char *)(v57 + 16) != 83) {
          break;
        }
        uint64_t v56 = *(void *)(v56 + 8);
        if (v56 == v54)
        {
          uint64_t v56 = v54;
          goto LABEL_106;
        }
      }
      unsigned int v58 = *(unsigned __int8 *)(v56 - 8) - 38;
      BOOL v103 = v58 > 0x38;
      uint64_t v59 = (1 << v58) & 0x100060000000001;
      if (!v103 && v59 != 0) {
        uint64_t v56 = *(void *)(v56 + 8);
      }
LABEL_106:
      if (v55 != v56)
      {
        int v61 = &v829;
        uint64_t v62 = (unsigned int *)(v8 + 76);
        int v63 = (unsigned int *)(v8 + 72);
        do
        {
          if (v55) {
            __int16 v64 = (unsigned char *)(v55 - 24);
          }
          else {
            __int16 v64 = 0;
          }
          if (v64[16] == 83)
          {
            if ((*(_DWORD *)(*(void *)v64 + 8) & 0xFE) == 0x12
              || ((unsigned int v65 = *(_DWORD *)(*(void *)v64 + 8),
                   BOOL v103 = v65 > 0x15,
                   int v66 = (1 << v65) & 0x20AC7F,
                   !v103)
                ? (BOOL v67 = v66 == 0)
                : (BOOL v67 = 1),
                  !v67))
            {
              LOBYTE(v828) = 0;
              v829 = &v831;
              v830 = (llvm::ScalarEvolution *)0x1000000000;
              sub_1CB91FBE0((uint64_t)v61, 1uLL, (uint64_t)v64);
              uint64_t v68 = *(void *)(*(void *)v829 + 8);
              if (v68)
              {
                do
                {
                  uint64_t v69 = *(void *)(v68 + 24);
                  uint64_t v70 = *(void *)(v69 + 8);
                  if (!v70 || *(void *)(v70 + 8)) {
                    break;
                  }
                  if (*(unsigned __int8 *)(v69 + 16) - 41 > 0x11) {
                    goto LABEL_170;
                  }
                  unint64_t v71 = v830;
                  unsigned int v72 = (const llvm::Instruction *)*((void *)v829 + v830 - 1);
                  if (*((unsigned char *)v72 + 16) != 83)
                  {
                    if (!llvm::Instruction::isSameOperationAs((llvm::Instruction *)v69, v72, 0)) {
                      goto LABEL_170;
                    }
                    unint64_t v71 = v830;
                  }
                  if (v71 >= HIDWORD(v830)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((void *)v829 + v71) = v69;
                  unsigned int v73 = v830 + 1;
                  LODWORD(v830) = v830 + 1;
                  uint64_t v68 = *(void *)(v69 + 8);
                  if (!v68) {
                    goto LABEL_130;
                  }
                }
                while (!*(void *)(v68 + 8));
                unsigned int v73 = v830;
LABEL_130:
                if (v73 >= 2)
                {
                  if (llvm::Instruction::isSameOperationAs((llvm::Instruction *)v69, *((const llvm::Instruction **)v829 + v73 - 1), 0))
                  {
                    uint64_t v74 = *(void *)(v69 + 8);
                    if (v74)
                    {
                      uint64_t v76 = *(void *)(v8 + 56);
                      uint64_t v75 = *(void *)(v8 + 64);
                      if (v75 == v76) {
                        int v77 = v62;
                      }
                      else {
                        int v77 = v63;
                      }
                      uint64_t v78 = *(void *)(v8 + 64);
                      while (1)
                      {
                        uint64_t v79 = *(void *)(v74 + 24);
                        uint64_t v80 = *(void *)(v79 + 40);
                        if (v78 == v76)
                        {
                          uint64_t v81 = *v62;
                          uint64_t v82 = (void *)(v76 + 8 * v81);
                          if (v81)
                          {
                            uint64_t v83 = 0;
                            uint64_t v84 = 8 * v81;
                            while (*(void *)(v76 + v83) != v80)
                            {
                              v83 += 8;
                              if (v84 == v83) {
                                goto LABEL_155;
                              }
                            }
                            uint64_t v82 = (void *)(v76 + v83);
                          }
LABEL_155:
                          uint64_t v78 = *(void *)(v8 + 56);
                        }
                        else
                        {
                          int v85 = *v63 - 1;
                          unsigned int v86 = v85 & ((v80 >> 4) ^ (v80 >> 9));
                          uint64_t v82 = (void *)(v75 + 8 * v86);
                          uint64_t v87 = *v82;
                          if (*v82 == -1)
                          {
                            uint64_t v88 = 0;
LABEL_157:
                            if (v88) {
                              uint64_t v82 = v88;
                            }
                            if (*v82 != v80) {
                              uint64_t v82 = (void *)(v75 + 8 * *v77);
                            }
                          }
                          else
                          {
                            uint64_t v88 = 0;
                            int v89 = 1;
                            while (v87 != v80)
                            {
                              if (v88) {
                                BOOL v90 = 0;
                              }
                              else {
                                BOOL v90 = v87 == -2;
                              }
                              if (v90) {
                                uint64_t v88 = v82;
                              }
                              unsigned int v91 = v86 + v89++;
                              unsigned int v86 = v91 & v85;
                              uint64_t v82 = (void *)(v75 + 8 * (v91 & v85));
                              uint64_t v87 = *v82;
                              if (*v82 == -1) {
                                goto LABEL_157;
                              }
                            }
                          }
                          uint64_t v78 = *(void *)(v8 + 64);
                        }
                        uint64_t v92 = v78 == v76 ? v62 : v63;
                        if (v82 != (void *)(v78 + 8 * *v92) && v79 != *(void *)v829) {
                          break;
                        }
                        uint64_t v74 = *(void *)(v74 + 8);
                        if (!v74)
                        {
                          if (v830 >= (unint64_t)HIDWORD(v830)) {
                            llvm::SmallVectorBase<unsigned int>::grow_pod();
                          }
                          *((void *)v829 + v830) = v69;
                          LODWORD(v830) = v830 + 1;
                          char v93 = 1;
                          LOBYTE(v828) = 1;
                          goto LABEL_171;
                        }
                      }
                    }
                  }
                }
              }
LABEL_170:
              char v93 = v828;
              if ((_BYTE)v828)
              {
LABEL_171:
                uint64_t v94 = v63;
                int v95 = v817;
                uint64_t v96 = (char *)v816;
                if (v817 >= HIDWORD(v817))
                {
                  unint64_t v102 = v817 + 1;
                  BOOL v103 = v816 <= &v828 && (char *)v816 + 152 * v817 > (char *)&v828;
                  int v104 = v103;
                  unint64_t v105 = 0x86BCA1AF286BCA1BLL * (((char *)&v828 - (unsigned char *)v816) >> 3);
                  int v790 = v104;
                  if (v104 != 1) {
                    unint64_t v105 = -1;
                  }
                  v792 = v61;
                  unint64_t v793 = v105;
                  if (v817 == -1) {
                    sub_1CD0A88F0(v102);
                  }
                  if (HIDWORD(v817) == -1) {
                    sub_1CD0A89A8(0xFFFFFFFFuLL);
                  }
                  unint64_t v106 = (2 * HIDWORD(v817)) | 1;
                  if (v106 <= v102) {
                    unint64_t v106 = v817 + 1;
                  }
                  uint64_t v107 = 0xFFFFFFFFLL;
                  if (v106 < 0xFFFFFFFF) {
                    uint64_t v107 = v106;
                  }
                  int v791 = v107;
                  long long v108 = (char *)malloc_type_malloc(152 * v107, 0x4065EBACuLL);
                  if (!v108) {
                    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
                  }
                  uint64_t v96 = v108;
                  v795 = v816;
                  if (v817)
                  {
                    uint64_t v109 = 0;
                    uint64_t v794 = 152 * v817;
                    do
                    {
                      long long v110 = &v96[v109];
                      long long v111 = &v795[v109];
                      char *v110 = v795[v109];
                      uint64_t v112 = &v96[v109 + 24];
                      *(void *)&v96[v109 + 8] = v112;
                      *((void *)v110 + 2) = 0x1000000000;
                      uint64_t v113 = *(unsigned int *)&v795[v109 + 16];
                      if (v113) {
                        BOOL v114 = v111 == v110;
                      }
                      else {
                        BOOL v114 = 1;
                      }
                      if (!v114)
                      {
                        unsigned int v115 = (const void *)*((void *)v111 + 1);
                        uint64_t v116 = &v795[v109];
                        unsigned int v117 = v111 + 24;
                        if (v117 == v115)
                        {
                          if (v113 >= 0x11) {
                            llvm::SmallVectorBase<unsigned int>::grow_pod();
                          }
                          int v118 = *(_DWORD *)&v795[v109 + 16];
                          memcpy(v112, v115, 8 * v113);
                          *((_DWORD *)v110 + 4) = v118;
                        }
                        else
                        {
                          *(void *)&v96[v109 + 8] = v115;
                          *((_DWORD *)v110 + 4) = v113;
                          *((_DWORD *)v110 + 5) = *(_DWORD *)&v795[v109 + 20];
                          *((void *)v116 + 1) = v117;
                          *(_DWORD *)&v795[v109 + 20] = 0;
                        }
                        *((_DWORD *)v116 + 4) = 0;
                      }
                      v109 += 152;
                    }
                    while (v794 != v109);
                    v795 = v816;
                    if (v817)
                    {
                      uint64_t v119 = 152 * v817;
                      do
                      {
                        int v120 = *(char **)&v795[v119 - 144];
                        if (&v795[v119 - 128] != v120) {
                          free(v120);
                        }
                        v119 -= 152;
                      }
                      while (v119);
                      v795 = v816;
                    }
                  }
                  if (v795 != v818) {
                    free(v795);
                  }
                  v816 = v96;
                  int v61 = v792;
                  HIDWORD(v817) = v791;
                  if (v790) {
                    long long v97 = (uint64_t *)&v96[152 * v793];
                  }
                  else {
                    long long v97 = (uint64_t *)&v828;
                  }
                  if (v790) {
                    long long v98 = (llvm::ScalarEvolution **)&v96[152 * v793 + 16];
                  }
                  else {
                    long long v98 = &v830;
                  }
                  int v95 = v817;
                  char v93 = *(unsigned char *)v97;
                }
                else
                {
                  long long v97 = (uint64_t *)&v828;
                  long long v98 = &v830;
                }
                unint64_t v99 = &v96[152 * v95];
                *unint64_t v99 = v93;
                *((void *)v99 + 2) = 0x1000000000;
                *((void *)v99 + 1) = v99 + 24;
                int v100 = v99 + 8;
                if (*(_DWORD *)v98 && v100 != (char *)(v97 + 1))
                {
                  unsigned int v101 = *((_DWORD *)v97 + 4);
                  if (v101)
                  {
                    if (v101 >= 0x11)
                    {
                      *((_DWORD *)v100 + 2) = 0;
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    if (*((_DWORD *)v97 + 4)) {
                      memcpy(*(void **)v100, (const void *)v97[1], 8 * *((unsigned int *)v97 + 4));
                    }
                  }
                  *((_DWORD *)v100 + 2) = v101;
                }
                LODWORD(v817) = v817 + 1;
                int v63 = v94;
                uint64_t v62 = (unsigned int *)(v8 + 76);
              }
              if (v829 != &v831) {
                free(v829);
              }
            }
          }
          uint64_t v55 = *(void *)(v55 + 8);
        }
        while (v55 != v56);
        unsigned int v52 = v826;
      }
      if (!v52)
      {
LABEL_1557:
        uint64_t v6 = 0;
LABEL_1558:
        MEMORY[0x1D25D9CD0](v823, 4);
        MEMORY[0x1D25D9CD0](v821, 8);
        MEMORY[0x1D25D9CD0](v819, 8);
        v777 = (char *)v816;
        if (v817)
        {
          uint64_t v778 = 152 * v817;
          do
          {
            v779 = *(char **)&v777[v778 - 144];
            if (&v777[v778 - 128] != v779) {
              free(v779);
            }
            v778 -= 152;
          }
          while (v778);
          v777 = (char *)v816;
        }
        if (v777 != v818) {
          free(v777);
        }
        goto LABEL_1567;
      }
      uint64_t v121 = (uint64_t *)v825;
      int v122 = (uint64_t *)((char *)v825 + 8 * v52);
    }
    uint64_t v123 = v835;
    uint64_t v124 = v786;
    while (1)
    {
      uint64_t v125 = *v121;
      uint64_t v127 = *(void *)(v124 + 8);
      unsigned int v126 = *(llvm::ScalarEvolution **)(v124 + 16);
      uint64_t v128 = *(llvm::AAResults **)v124;
      char v129 = *(unsigned char *)(v124 + 40);
      uint64_t v130 = *(void *)(v124 + 72);
      unint64_t v828 = v124;
      v829 = (void *)v8;
      v830 = v126;
      v831 = v128;
      long long v832 = *(_OWORD *)(v124 + 24);
      uint64_t v833 = v127;
      char v834 = v129;
      v835[0] = v125;
      v837 = v839;
      uint64_t v838 = 0x1000000000;
      v840 = v842;
      uint64_t v841 = 0x1000000000;
      v843[0] = 0;
      v843[1] = 0;
      int v844 = 0;
      v845 = 0;
      v846 = 0;
      uint64_t v847 = 0;
      uint64_t v848 = v789;
      uint64_t v849 = v130;
      uint64_t v132 = sub_1CD45F378(v789, v123)[1];
      v835[1] = v132;
      if (v132 < 0) {
        uint64_t v132 = -v132;
      }
      uint64_t v133 = v835[0];
      if (v132 == 1)
      {
        __int16 v134 = v123;
        uint64_t v135 = *(void *)(v835[0] + 8);
        if (v135)
        {
          do
          {
            uint64_t v136 = *(void *)(v135 + 24);
            if (sub_1CCDEE31C(v136, v835[0]))
            {
              if (v841 >= (unint64_t)HIDWORD(v841)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v840 + v841) = v136;
              LODWORD(v841) = v841 + 1;
            }
            uint64_t v135 = *(void *)(v135 + 8);
          }
          while (v135);
          uint64_t v133 = v835[0];
        }
        v865 = v869;
        v866 = v869;
        uint64_t v867 = 16;
        int v868 = 0;
        sub_1CCDEE384((uint64_t)&v828, v133, (uint64_t)&v865, v131);
        if (v866 != v865) {
          free(v866);
        }
        uint64_t v123 = v134;
        if (v841 >= (unint64_t)HIDWORD(v841)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v840 + v841) = v835[0];
        LODWORD(v841) = v841 + 1;
      }
      else
      {
        v860 = v864;
        v861 = v864;
        uint64_t v862 = 16;
        int v863 = 0;
        int v137 = sub_1CCDEE75C((uint64_t)&v828, v835[0], (uint64_t)&v860, v131);
        if (v861 != v860) {
          free(v861);
        }
        if (!v137) {
          goto LABEL_253;
        }
      }
      if (!v838) {
        goto LABEL_253;
      }
      uint64_t v139 = 312 * v838;
      uint64_t v140 = (unsigned int *)((char *)v837 + 16);
      do
      {
        uint64_t v141 = *v140;
        if (!v141 || v141 != *((_DWORD *)v837 + 4)) {
          goto LABEL_253;
        }
        v140 += 78;
        v139 -= 312;
      }
      while (v139);
      unint64_t v142 = v141 + 1;
      unint64_t v836 = v141 + 1;
      if (v141 > 0x1F)
      {
LABEL_253:
        int v138 = 0;
        goto LABEL_254;
      }
      v780 = v123;
      v781 = (char *)v122;
      v782 = v121;
      v860 = v864;
      v861 = v864;
      uint64_t v862 = 16;
      int v863 = 0;
      v855 = v859;
      v856 = v859;
      uint64_t v857 = 16;
      int v858 = 0;
      v850 = v854;
      v851 = v854;
      uint64_t v852 = 16;
      LODWORD(v853) = 0;
      sub_1CD3C7F68(&v819);
      sub_1CD3C7F68(&v821);
      sub_1CD4224C4((uint64_t)&v823);
      uint64_t v143 = v817;
      if (v817) {
        break;
      }
LABEL_267:
      uint64_t v144 = **((void **)v829 + 4);
      uint64_t v145 = v144 + 40;
      for (uint64_t i = *(void *)(v144 + 48); i != v145; uint64_t i = *(void *)(i + 8))
      {
        uint64_t v147 = (void *)(i - 24);
        if (!i) {
          uint64_t v147 = 0;
        }
        v865 = v147;
        uint64_t v148 = sub_1CD77346C((uint64_t)v843, (uint64_t *)&v865);
        uint64_t v149 = v148;
        uint64_t v150 = *(unsigned int *)(v148 + 8);
        if ((*(_DWORD *)(v148 + 64) & 0x3F) != 0) {
          *(void *)(*(void *)v148 + 8 * v150 - 8) &= ~(-1 << (*(_DWORD *)(v148 + 64) & 0x3F));
        }
        *(_DWORD *)(v148 + 64) = 34;
        if (v150)
        {
          if (v150 != 1)
          {
            LODWORD(v150) = 1;
            *(_DWORD *)(v148 + 8) = 1;
          }
          char v151 = 34;
LABEL_276:
          *(void *)(*(void *)v149 + 8 * v150 - 8) &= ~(-1 << v151);
          continue;
        }
        if (!*(_DWORD *)(v148 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        bzero((void *)(*(void *)v148 + 8 * v150), 8 - 8 * v150);
        LODWORD(v150) = 1;
        *(_DWORD *)(v149 + 8) = 1;
        char v151 = *(_DWORD *)(v149 + 64) & 0x3F;
        if (v151) {
          goto LABEL_276;
        }
      }
      uint64_t v152 = v869;
      v865 = v869;
      v866 = v869;
      uint64_t v867 = 16;
      int v868 = 0;
      if (v838)
      {
        unsigned int v153 = 0;
        int v229 = (char *)v837;
        uint64_t v230 = (char *)v837 + 312 * v838;
        unsigned int v154 = 16;
        uint64_t v155 = v869;
        while (1)
        {
          uint64_t v231 = *((unsigned int *)v229 + 4);
          if (v231)
          {
            int v232 = (uint64_t *)*((void *)v229 + 1);
            uint64_t v233 = &v232[v231];
            while (2)
            {
              uint64_t v234 = *v232;
              if (v152 == v155)
              {
                if (v153)
                {
                  uint64_t v235 = 0;
                  uint64_t v236 = 8 * v153;
                  int v237 = v155;
                  while (*v237 != v234)
                  {
                    if (*v237 == -2) {
                      uint64_t v235 = v237;
                    }
                    ++v237;
                    v236 -= 8;
                    if (!v236)
                    {
                      if (!v235) {
                        goto LABEL_462;
                      }
                      *uint64_t v235 = v234;
                      --v868;
                      goto LABEL_484;
                    }
                  }
                  goto LABEL_484;
                }
LABEL_462:
                if (v154 > v153)
                {
                  HIDWORD(v867) = v153 + 1;
                  v155[v153] = v234;
                  goto LABEL_484;
                }
              }
              if (3 * v154 <= 4 * (v153 - v868))
              {
                if (v154 >= 0x40) {
                  v154 *= 2;
                }
                else {
                  unsigned int v154 = 128;
                }
              }
              else if (v154 - v153 >= v154 >> 3)
              {
                goto LABEL_466;
              }
              llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v865, v154);
              unsigned int v154 = v867;
              uint64_t v152 = v866;
LABEL_466:
              unsigned int v238 = v154 - 1;
              unsigned int v239 = (v154 - 1) & ((v234 >> 4) ^ (v234 >> 9));
              uint64_t v240 = &v152[v239];
              uint64_t v241 = *v240;
              if (*v240 == -1)
              {
                int v242 = 0;
LABEL_478:
                if (v242) {
                  uint64_t v240 = v242;
                }
                if (*v240 != v234)
                {
                  if (*v240 == -2) {
                    --v868;
                  }
                  else {
                    ++HIDWORD(v867);
                  }
                  *uint64_t v240 = v234;
                }
              }
              else
              {
                int v242 = 0;
                int v243 = 1;
                while (v241 != v234)
                {
                  if (v242) {
                    BOOL v244 = 0;
                  }
                  else {
                    BOOL v244 = v241 == -2;
                  }
                  if (v244) {
                    int v242 = v240;
                  }
                  unsigned int v245 = v239 + v243++;
                  unsigned int v239 = v245 & v238;
                  uint64_t v240 = &v152[v245 & v238];
                  uint64_t v241 = *v240;
                  if (*v240 == -1) {
                    goto LABEL_478;
                  }
                }
              }
LABEL_484:
              uint64_t v152 = v866;
              uint64_t v155 = v865;
              unsigned int v153 = HIDWORD(v867);
              unsigned int v154 = v867;
              if (++v232 == v233) {
                break;
              }
              continue;
            }
          }
          int v246 = (unint64_t *)*((void *)v229 + 20);
          if (v246 == *((unint64_t **)v229 + 19)) {
            uint64_t v247 = 172;
          }
          else {
            uint64_t v247 = 168;
          }
          uint64_t v248 = *(unsigned int *)&v229[v247];
          unsigned int v249 = &v246[v248];
          if (v248)
          {
            uint64_t v250 = 8 * v248;
            while (*v246 >= 0xFFFFFFFFFFFFFFFELL)
            {
              ++v246;
              v250 -= 8;
              if (!v250)
              {
                int v246 = v249;
                break;
              }
            }
          }
          sub_1CC002B9C((llvm::SmallPtrSetImplBase *)&v865, v246, v249, v249);
          uint64_t v251 = *(void *)v229;
          uint64_t v252 = (char *)v866;
          uint64_t v253 = HIDWORD(v867);
          if (v866 != v865) {
            break;
          }
          if (HIDWORD(v867))
          {
            unint64_t v254 = 0;
            uint64_t v255 = 8 * HIDWORD(v867);
            long long v256 = v866;
            while (*v256 != v251)
            {
              if (*v256 == -2) {
                unint64_t v254 = v256;
              }
              ++v256;
              v255 -= 8;
              if (!v255)
              {
                if (!v254) {
                  goto LABEL_508;
                }
                void *v254 = v251;
                --v868;
                goto LABEL_532;
              }
            }
            goto LABEL_532;
          }
LABEL_508:
          unsigned int v257 = v867;
          if (HIDWORD(v867) >= v867) {
            goto LABEL_511;
          }
          ++HIDWORD(v867);
          *((void *)v866 + v253) = v251;
LABEL_532:
          uint64_t v152 = v866;
          uint64_t v155 = v865;
          unsigned int v153 = HIDWORD(v867);
          unsigned int v154 = v867;
          v229 += 312;
          if (v229 == v230) {
            goto LABEL_284;
          }
        }
        unsigned int v257 = v867;
LABEL_511:
        if (3 * v257 <= 4 * (HIDWORD(v867) - v868))
        {
          if (v257 >= 0x40) {
            v257 *= 2;
          }
          else {
            unsigned int v257 = 128;
          }
        }
        else if (v257 - HIDWORD(v867) >= v257 >> 3)
        {
          goto LABEL_513;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v865, v257);
        unsigned int v257 = v867;
        uint64_t v252 = (char *)v866;
LABEL_513:
        unsigned int v258 = v257 - 1;
        unsigned int v259 = (v257 - 1) & ((v251 >> 4) ^ (v251 >> 9));
        int v260 = &v252[8 * v259];
        uint64_t v261 = *(void *)v260;
        if (*(void *)v260 == -1)
        {
          __int16 v262 = 0;
LABEL_525:
          if (v262) {
            unsigned int v266 = v262;
          }
          else {
            unsigned int v266 = v260;
          }
          if (*(void *)v266 != v251)
          {
            if (*(void *)v266 == -2) {
              --v868;
            }
            else {
              ++HIDWORD(v867);
            }
            *(void *)unsigned int v266 = v251;
          }
        }
        else
        {
          __int16 v262 = 0;
          int v263 = 1;
          while (v261 != v251)
          {
            if (v262) {
              BOOL v264 = 0;
            }
            else {
              BOOL v264 = v261 == -2;
            }
            if (v264) {
              __int16 v262 = v260;
            }
            unsigned int v265 = v259 + v263++;
            unsigned int v259 = v265 & v258;
            int v260 = &v252[8 * (v265 & v258)];
            uint64_t v261 = *(void *)v260;
            if (*(void *)v260 == -1) {
              goto LABEL_525;
            }
          }
        }
        goto LABEL_532;
      }
      unsigned int v153 = 0;
      unsigned int v154 = 16;
      uint64_t v155 = v869;
LABEL_284:
      if (v841)
      {
        v267 = (uint64_t *)v840;
        unint64_t v268 = (char *)v840 + 8 * v841;
        while (1)
        {
          uint64_t v269 = *v267;
          if (v152 != v155) {
            break;
          }
          if (v153)
          {
            int v270 = 0;
            uint64_t v271 = 8 * v153;
            v272 = v155;
            while (*v272 != v269)
            {
              if (*v272 == -2) {
                int v270 = v272;
              }
              ++v272;
              v271 -= 8;
              if (!v271)
              {
                if (!v270) {
                  goto LABEL_549;
                }
                *int v270 = v269;
                --v868;
                goto LABEL_571;
              }
            }
            goto LABEL_571;
          }
LABEL_549:
          if (v154 <= v153) {
            break;
          }
          HIDWORD(v867) = v153 + 1;
          v155[v153] = v269;
LABEL_571:
          uint64_t v152 = v866;
          uint64_t v155 = v865;
          unsigned int v153 = HIDWORD(v867);
          unsigned int v154 = v867;
          if (++v267 == (uint64_t *)v268) {
            goto LABEL_285;
          }
        }
        if (3 * v154 <= 4 * (v153 - v868))
        {
          if (v154 >= 0x40) {
            v154 *= 2;
          }
          else {
            unsigned int v154 = 128;
          }
        }
        else if (v154 - v153 >= v154 >> 3)
        {
          goto LABEL_553;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v865, v154);
        unsigned int v154 = v867;
        uint64_t v152 = v866;
LABEL_553:
        unsigned int v273 = v154 - 1;
        unsigned int v274 = (v154 - 1) & ((v269 >> 4) ^ (v269 >> 9));
        uint64_t v275 = &v152[v274];
        uint64_t v276 = *v275;
        if (*v275 == -1)
        {
          uint64_t v277 = 0;
LABEL_565:
          if (v277) {
            uint64_t v275 = v277;
          }
          if (*v275 != v269)
          {
            if (*v275 == -2) {
              --v868;
            }
            else {
              ++HIDWORD(v867);
            }
            *uint64_t v275 = v269;
          }
        }
        else
        {
          uint64_t v277 = 0;
          int v278 = 1;
          while (v276 != v269)
          {
            if (v277) {
              BOOL v279 = 0;
            }
            else {
              BOOL v279 = v276 == -2;
            }
            if (v279) {
              uint64_t v277 = v275;
            }
            unsigned int v280 = v274 + v278++;
            unsigned int v274 = v280 & v273;
            uint64_t v275 = &v152[v280 & v273];
            uint64_t v276 = *v275;
            if (*v275 == -1) {
              goto LABEL_565;
            }
          }
        }
        goto LABEL_571;
      }
LABEL_285:
      if (!v838) {
        goto LABEL_286;
      }
      unsigned int v281 = (char *)v837;
      v797 = (char *)v837 + 312 * v838;
      do
      {
        v803 = 0;
        uint64_t v804 = 0;
        LODWORD(v805) = 0;
        sub_1CCDEFF20((uint64_t)&v828, *(void *)v281, (uint64_t *)&v865, (uint64_t *)&v860, (uint64_t)&v803);
        unsigned int v282 = (llvm::AAResults *)((char *)v803 + 8 * v805);
        if (v804)
        {
          if (v805)
          {
            uint64_t v283 = 8 * v805;
            uint64_t v284 = v803;
            while ((*(void *)v284 | 0x1000) == 0xFFFFFFFFFFFFF000)
            {
              uint64_t v284 = (llvm::AAResults *)((char *)v284 + 8);
              v283 -= 8;
              if (!v283) {
                goto LABEL_585;
              }
            }
          }
          else
          {
            uint64_t v284 = v803;
          }
        }
        else
        {
LABEL_585:
          uint64_t v284 = (llvm::AAResults *)((char *)v803 + 8 * v805);
        }
        uint64_t v285 = (llvm::AAResults *)((char *)v803 + 8 * v805);
LABEL_588:
        while (v284 != v285)
        {
          v813 = 0;
          int v286 = (llvm::AAResults *)((char *)v284 + 8);
          v813 = *(uint64_t **)v284;
          BOOL v287 = (void **)sub_1CD77346C((uint64_t)v843, (uint64_t *)&v813);
          **v287 |= 1uLL;
          uint64_t v284 = v282;
          if (v286 != v282)
          {
            uint64_t v284 = v286;
            while ((*(void *)v284 | 0x1000) == 0xFFFFFFFFFFFFF000)
            {
              uint64_t v284 = (llvm::AAResults *)((char *)v284 + 8);
              if (v284 == v282)
              {
                uint64_t v284 = v282;
                goto LABEL_588;
              }
            }
          }
        }
        uint64_t v288 = *((unsigned int *)v281 + 4);
        if (v288)
        {
          v289 = (uint64_t *)*((void *)v281 + 1);
          v290 = &v289[v288];
          unsigned int v291 = 1;
          while (1)
          {
            uint64_t v292 = *v289;
            v813 = 0;
            uint64_t v814 = 0;
            unsigned int v815 = 0;
            sub_1CCDEFF20((uint64_t)&v828, v292, (uint64_t *)&v865, (uint64_t *)&v860, (uint64_t)&v813);
            if (v814 != v804) {
              break;
            }
            int v293 = v813;
            int v294 = &v813[v815];
            if (v814)
            {
              if (v815)
              {
                uint64_t v295 = 8 * v815;
                int v296 = v813;
                while ((*v296 | 0x1000) == 0xFFFFFFFFFFFFF000)
                {
                  ++v296;
                  v295 -= 8;
                  if (!v295) {
                    goto LABEL_602;
                  }
                }
              }
              else
              {
                int v296 = v813;
              }
            }
            else
            {
LABEL_602:
              int v296 = &v813[v815];
            }
            v297 = &v813[v815];
            if (v296 != v297)
            {
              do
              {
                v801[0] = 0;
                uint64_t v298 = v296 + 1;
                v801[0] = *v296;
                unsigned int v299 = (void *)sub_1CD77346C((uint64_t)v843, v801);
                *(void *)(*v299 + 8 * (v291 >> 6)) |= 1 << v291;
                int v296 = v294;
                if (v298 != v294)
                {
                  int v296 = v298;
                  while ((*v296 | 0x1000) == 0xFFFFFFFFFFFFF000)
                  {
                    if (++v296 == v294)
                    {
                      int v296 = v294;
                      break;
                    }
                  }
                }
              }
              while (v296 != v297);
              int v293 = v813;
            }
            MEMORY[0x1D25D9CD0](v293, 8);
            ++v291;
            if (++v289 == v290) {
              goto LABEL_613;
            }
          }
          MEMORY[0x1D25D9CD0](v813, 8);
          MEMORY[0x1D25D9CD0](v803, 8);
          int v138 = 0;
          goto LABEL_735;
        }
LABEL_613:
        uint64_t v300 = *((void *)v281 + 20);
        uint64_t v301 = 172;
        if (v300 != *((void *)v281 + 19)) {
          uint64_t v301 = 168;
        }
        uint64_t v302 = *(unsigned int *)&v281[v301];
        if (v302)
        {
          uint64_t v303 = 8 * v302;
          int v304 = (unint64_t *)*((void *)v281 + 20);
          while (*v304 >= 0xFFFFFFFFFFFFFFFELL)
          {
            ++v304;
            v303 -= 8;
            if (!v303) {
              goto LABEL_626;
            }
          }
        }
        else
        {
          int v304 = (unint64_t *)*((void *)v281 + 20);
        }
        unsigned int v305 = (unint64_t *)(v300 + 8 * v302);
        if (v304 != v305)
        {
LABEL_622:
          v813 = 0;
          int v307 = (uint64_t *)*v304;
          v306 = v304 + 1;
          v813 = v307;
          BOOL v308 = (void **)sub_1CD77346C((uint64_t)v843, (uint64_t *)&v813);
          **v308 |= 0x200000000uLL;
          while (v306 != v305)
          {
            unint64_t v309 = *v306++;
            if (v309 <= 0xFFFFFFFFFFFFFFFDLL)
            {
              int v304 = v306 - 1;
              goto LABEL_622;
            }
          }
        }
LABEL_626:
        MEMORY[0x1D25D9CD0](v803, 8);
        v281 += 312;
      }
      while (v281 != v797);
      uint64_t v152 = v866;
      uint64_t v155 = v865;
LABEL_286:
      if (v152 == v155)
      {
LABEL_287:
        int v868 = 0;
        HIDWORD(v867) = 0;
      }
      else
      {
        if (v867 < 0x21 || 4 * (HIDWORD(v867) - v868) >= v867)
        {
          memset(v152, 255, 8 * v867);
          goto LABEL_287;
        }
        llvm::SmallPtrSetImplBase::shrink_and_clear(&v865);
      }
      if (v838)
      {
        uint64_t v310 = (char *)v837;
        int v311 = (char *)v837 + 312 * v838;
        while (1)
        {
          uint64_t v312 = *((unsigned int *)v310 + 4);
          if (v312)
          {
            int v313 = (uint64_t *)*((void *)v310 + 1);
            v314 = &v313[v312];
            uint64_t v315 = v866;
            while (1)
            {
              uint64_t v316 = *v313;
              uint64_t v317 = HIDWORD(v867);
              if (v315 != v865) {
                break;
              }
              if (HIDWORD(v867))
              {
                unint64_t v318 = 0;
                uint64_t v319 = 8 * HIDWORD(v867);
                BOOL v320 = v315;
                while (*v320 != v316)
                {
                  if (*v320 == -2) {
                    unint64_t v318 = v320;
                  }
                  ++v320;
                  v319 -= 8;
                  if (!v319)
                  {
                    if (!v318) {
                      goto LABEL_640;
                    }
                    *unint64_t v318 = v316;
                    --v868;
                    goto LABEL_664;
                  }
                }
                goto LABEL_664;
              }
LABEL_640:
              unsigned int v321 = v867;
              if (HIDWORD(v867) >= v867) {
                goto LABEL_643;
              }
              ++HIDWORD(v867);
              v315[v317] = v316;
LABEL_664:
              uint64_t v315 = v866;
              if (++v313 == v314) {
                goto LABEL_672;
              }
            }
            unsigned int v321 = v867;
LABEL_643:
            if (3 * v321 <= 4 * (HIDWORD(v867) - v868))
            {
              if (v321 >= 0x40) {
                v321 *= 2;
              }
              else {
                unsigned int v321 = 128;
              }
            }
            else if (v321 - HIDWORD(v867) >= v321 >> 3)
            {
              goto LABEL_645;
            }
            llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v865, v321);
            unsigned int v321 = v867;
            uint64_t v315 = v866;
LABEL_645:
            unsigned int v322 = v321 - 1;
            unsigned int v323 = (v321 - 1) & ((v316 >> 4) ^ (v316 >> 9));
            uint64_t v324 = &v315[v323];
            uint64_t v325 = *v324;
            if (*v324 == -1)
            {
              uint64_t v326 = 0;
LABEL_657:
              if (v326) {
                int v330 = v326;
              }
              else {
                int v330 = v324;
              }
              if (*v330 != v316)
              {
                if (*v330 == -2) {
                  --v868;
                }
                else {
                  ++HIDWORD(v867);
                }
                *int v330 = v316;
              }
            }
            else
            {
              uint64_t v326 = 0;
              int v327 = 1;
              while (v325 != v316)
              {
                if (v326) {
                  BOOL v328 = 0;
                }
                else {
                  BOOL v328 = v325 == -2;
                }
                if (v328) {
                  uint64_t v326 = v324;
                }
                unsigned int v329 = v323 + v327++;
                unsigned int v323 = v329 & v322;
                uint64_t v324 = &v315[v329 & v322];
                uint64_t v325 = *v324;
                if (*v324 == -1) {
                  goto LABEL_657;
                }
              }
            }
            goto LABEL_664;
          }
LABEL_672:
          int v331 = (unint64_t *)*((void *)v310 + 20);
          if (v331 == *((unint64_t **)v310 + 19)) {
            uint64_t v332 = 172;
          }
          else {
            uint64_t v332 = 168;
          }
          uint64_t v333 = *(unsigned int *)&v310[v332];
          uint64_t v334 = &v331[v333];
          if (v333)
          {
            uint64_t v335 = 8 * v333;
            while (*v331 >= 0xFFFFFFFFFFFFFFFELL)
            {
              ++v331;
              v335 -= 8;
              if (!v335)
              {
                int v331 = v334;
                break;
              }
            }
          }
          sub_1CC002B9C((llvm::SmallPtrSetImplBase *)&v865, v331, v334, v334);
          uint64_t v336 = *(void *)v310;
          uint64_t v337 = (char *)v866;
          uint64_t v338 = HIDWORD(v867);
          if (v866 != v865) {
            break;
          }
          if (HIDWORD(v867))
          {
            v339 = 0;
            uint64_t v340 = 8 * HIDWORD(v867);
            BOOL v341 = v866;
            while (*v341 != v336)
            {
              if (*v341 == -2) {
                v339 = v341;
              }
              ++v341;
              v340 -= 8;
              if (!v340)
              {
                if (!v339) {
                  goto LABEL_688;
                }
                void *v339 = v336;
                --v868;
                goto LABEL_712;
              }
            }
            goto LABEL_712;
          }
LABEL_688:
          unsigned int v342 = v867;
          if (HIDWORD(v867) >= v867) {
            goto LABEL_691;
          }
          ++HIDWORD(v867);
          *((void *)v866 + v338) = v336;
LABEL_712:
          v310 += 312;
          if (v310 == v311) {
            goto LABEL_289;
          }
        }
        unsigned int v342 = v867;
LABEL_691:
        if (3 * v342 <= 4 * (HIDWORD(v867) - v868))
        {
          if (v342 >= 0x40) {
            v342 *= 2;
          }
          else {
            unsigned int v342 = 128;
          }
        }
        else if (v342 - HIDWORD(v867) >= v342 >> 3)
        {
          goto LABEL_693;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v865, v342);
        unsigned int v342 = v867;
        uint64_t v337 = (char *)v866;
LABEL_693:
        unsigned int v343 = v342 - 1;
        unsigned int v344 = (v342 - 1) & ((v336 >> 4) ^ (v336 >> 9));
        uint64_t v345 = &v337[8 * v344];
        uint64_t v346 = *(void *)v345;
        if (*(void *)v345 == -1)
        {
          uint64_t v347 = 0;
LABEL_705:
          if (v347) {
            uint64_t v351 = v347;
          }
          else {
            uint64_t v351 = v345;
          }
          if (*(void *)v351 != v336)
          {
            if (*(void *)v351 == -2) {
              --v868;
            }
            else {
              ++HIDWORD(v867);
            }
            *(void *)uint64_t v351 = v336;
          }
        }
        else
        {
          uint64_t v347 = 0;
          int v348 = 1;
          while (v346 != v336)
          {
            if (v347) {
              BOOL v349 = 0;
            }
            else {
              BOOL v349 = v346 == -2;
            }
            if (v349) {
              uint64_t v347 = v345;
            }
            unsigned int v350 = v344 + v348++;
            unsigned int v344 = v350 & v343;
            uint64_t v345 = &v337[8 * (v350 & v343)];
            uint64_t v346 = *(void *)v345;
            if (*(void *)v345 == -1) {
              goto LABEL_705;
            }
          }
        }
        goto LABEL_712;
      }
LABEL_289:
      v803 = 0;
      uint64_t v804 = 0;
      LODWORD(v805) = 0;
      if (!v841)
      {
        uint64_t v156 = 0;
        int v157 = 0;
        goto LABEL_723;
      }
      uint64_t v352 = (uint64_t *)v840;
      uint64_t v353 = 8 * v841;
      do
      {
        uint64_t v354 = *v352++;
        sub_1CCDEFF20((uint64_t)&v828, v354, (uint64_t *)&v865, (uint64_t *)&v860, (uint64_t)&v803);
        v353 -= 8;
      }
      while (v353);
      int v157 = v803;
      uint64_t v156 = v805;
      if (v804)
      {
        uint64_t v356 = (uint64_t **)((char *)v803 + 8 * v805);
        if (v805)
        {
          uint64_t v634 = 0;
          while ((*(void *)((char *)v803 + v634) | 0x1000) == 0xFFFFFFFFFFFFF000)
          {
            v634 += 8;
            if (8 * v805 == v634)
            {
              v355 = (uint64_t **)((char *)v803 + 8 * v805);
              goto LABEL_724;
            }
          }
          v355 = (uint64_t **)((char *)v803 + v634);
        }
        else
        {
          v355 = (uint64_t **)v803;
        }
      }
      else
      {
LABEL_723:
        v355 = (uint64_t **)((char *)v157 + 8 * v156);
        uint64_t v356 = v355;
      }
LABEL_724:
      int v357 = (uint64_t **)((char *)v157 + 8 * v156);
      while (1)
      {
LABEL_725:
        if (v355 == v357)
        {
          int v138 = 1;
          goto LABEL_734;
        }
        v813 = 0;
        v813 = *v355;
        if (llvm::Instruction::mayHaveSideEffects((llvm::Instruction *)v813)) {
          break;
        }
        int v358 = (void **)sub_1CD77346C((uint64_t)v843, (uint64_t *)&v813);
        **v358 |= 0x200000000uLL;
        uint64_t v359 = v355 + 1;
        v355 = v356;
        if (v359 != v356)
        {
          v355 = v359;
          while (((unint64_t)*v355 | 0x1000) == 0xFFFFFFFFFFFFF000)
          {
            if (++v355 == v356)
            {
              v355 = v356;
              goto LABEL_725;
            }
          }
        }
      }
      int v138 = 0;
LABEL_734:
      MEMORY[0x1D25D9CD0](v803, 8);
LABEL_735:
      if (v866 != v865) {
        free(v866);
      }
      if (v138)
      {
        if (v851 == v850) {
          uint64_t v360 = (uint64_t *)((char *)&v852 + 4);
        }
        else {
          uint64_t v360 = &v852;
        }
        uint64_t v361 = *(unsigned int *)v360;
        if (v361)
        {
          uint64_t v362 = 8 * v361;
          v363 = (unint64_t *)v851;
          while (*v363 >= 0xFFFFFFFFFFFFFFFELL)
          {
            ++v363;
            v362 -= 8;
            if (!v362) {
              goto LABEL_752;
            }
          }
        }
        else
        {
          v363 = (unint64_t *)v851;
        }
        uint64_t v364 = (unint64_t *)((char *)v851 + 8 * v361);
        if (v363 != v364)
        {
          while (1)
          {
            v865 = 0;
            uint64_t v366 = (void *)*v363;
            uint64_t v365 = v363 + 1;
            v865 = v366;
            uint64_t v367 = (void **)sub_1CD77346C((uint64_t)v843, (uint64_t *)&v865);
            **v367 |= 0x200000000uLL;
            do
            {
              if (v365 == v364) {
                goto LABEL_752;
              }
              unint64_t v368 = *v365++;
            }
            while (v368 > 0xFFFFFFFFFFFFFFFDLL);
            v363 = v365 - 1;
          }
        }
LABEL_752:
        if (v849) {
          BOOL v369 = v849 == v835[0];
        }
        else {
          BOOL v369 = 1;
        }
        if (!v369)
        {
          uint64_t v370 = *(void *)(v849 + 8);
          if (v370)
          {
            unsigned int v371 = (void *)(**((void **)v829 + 4) + 40);
            do
            {
              if (*(unsigned __int8 *)(*(void *)(v370 + 24) + 16) <= 0x1Bu) {
                char v372 = 0;
              }
              else {
                char v372 = *(void **)(v370 + 24);
              }
              v865 = v372;
              uint64_t v373 = (void **)sub_1CD77346C((uint64_t)v843, (uint64_t *)&v865);
              **v373 |= 0x200000000uLL;
              for (uint64_t j = v372[1]; j; uint64_t j = *(void *)(j + 8))
              {
                uint64_t v375 = *(void *)(j + 24);
                if (*(unsigned __int8 *)(v375 + 16) <= 0x1Bu) {
                  uint64_t v376 = 0;
                }
                else {
                  uint64_t v376 = *(void *)(j + 24);
                }
                v803 = (llvm::AAResults *)v376;
                v377 = (void **)sub_1CD77346C((uint64_t)v843, (uint64_t *)&v803);
                **v377 |= 0x200000000uLL;
                uint64_t v378 = v375;
                if (*(unsigned char *)(v376 + 16) == 68)
                {
                  if (*(unsigned __int8 *)(*(void *)(*(void *)(v376 + 8) + 24) + 16) <= 0x1Bu) {
                    uint64_t v378 = 0;
                  }
                  else {
                    uint64_t v378 = *(void *)(*(void *)(v376 + 8) + 24);
                  }
                  v803 = (llvm::AAResults *)v378;
                  int v379 = (void **)sub_1CD77346C((uint64_t)v843, (uint64_t *)&v803);
                  **v379 |= 0x200000000uLL;
                }
                uint64_t v380 = *(void *)(v375 + 8);
                if (v380 && !*(void *)(v380 + 8))
                {
                  uint64_t v381 = 0;
                  uint64_t v382 = *(void *)(*(void *)(v378 + 8) + 24);
                  if (*(unsigned char *)(v382 + 16) != 30) {
                    uint64_t v382 = 0;
                  }
                  v813 = (uint64_t *)v382;
                  uint64_t v383 = (void *)*v371;
                  if ((void *)*v371 != v371)
                  {
                    uint64_t v381 = v383 - 3;
                    if (!v383) {
                      uint64_t v381 = 0;
                    }
                    if (*((unsigned __int8 *)v381 + 16) - 29 >= 0xB) {
                      uint64_t v381 = 0;
                    }
                  }
                  if ((void *)v382 == v381)
                  {
                    v384 = (void **)sub_1CD77346C((uint64_t)v843, (uint64_t *)&v813);
                    **v384 |= 0x200000000uLL;
                  }
                }
              }
              uint64_t v370 = *(void *)(v370 + 8);
            }
            while (v370);
          }
        }
        uint64_t v385 = v845;
        uint64_t v386 = v846;
        while (v385 != v386)
        {
          uint64_t v387 = *((unsigned int *)v385 + 4);
          if (!v387) {
            goto LABEL_797;
          }
          int v388 = 0;
          uint64_t v389 = (int8x8_t *)v385[1];
          uint64_t v390 = 8 * v387;
          do
          {
            int8x8_t v391 = *v389++;
            uint8x8_t v392 = (uint8x8_t)vcnt_s8(v391);
            v392.i16[0] = vaddlv_u8(v392);
            v388 += v392.i32[0];
            v390 -= 8;
          }
          while (v390);
          if (v388 != 1)
          {
LABEL_797:
            uint64_t v393 = *v385;
            if (!sub_1CBF63B28(*v385))
            {
              if (*(unsigned char *)(v393 + 16) != 84
                || (uint64_t v394 = *(void *)(v393 - 32)) == 0
                || *(unsigned char *)(v394 + 16)
                || *(void *)(v394 + 24) != *(void *)(v393 + 72)
                || (*(unsigned char *)(v394 + 33) & 0x20) == 0
                || (int v395 = *(_DWORD *)(v394 + 36), v395 != 4) && v395 != 316 && v395 != 245)
              {
                int v138 = 0;
                goto LABEL_1338;
              }
            }
          }
          v385 += 10;
        }
        if (v836 < 2)
        {
          int v138 = 1;
          goto LABEL_1338;
        }
        unint64_t v396 = 1;
        while (2)
        {
          int v397 = v845;
          v803 = v831;
          uint64_t v804 = (uint64_t)&v804;
          v805 = (llvm::AliasSet *)&v804;
          int v809 = 0;
          uint64_t v810 = 0;
          uint64_t v806 = 0;
          uint64_t v807 = 0;
          int v808 = 0;
          v801[0] = 0;
          v801[1] = 0;
          int v802 = 0;
          v865 = v869;
          v866 = v869;
          uint64_t v867 = 16;
          int v868 = 0;
          v398 = v845;
          uint64_t v399 = v846;
          if (v845 != v846)
          {
            v398 = v845;
            while ((*(unsigned char *)v398[1] & 1) == 0)
            {
              v398 += 10;
              if (v398 == v846)
              {
                v398 = v846;
                break;
              }
            }
          }
          int v400 = sub_1CCDEFC5C(v396, v845, v846, (uint64_t *)&v865, 0);
          int v138 = 1;
          if (v398 != v399)
          {
            uint64_t v401 = v400;
            if (v399 != v400)
            {
              uint64_t v402 = 0;
              unint64_t v796 = (v396 - 1);
              uint64_t v403 = 16;
              while (1)
              {
                uint64_t v404 = *v398;
                uint64_t v405 = *v401;
                if (!v838) {
                  break;
                }
                uint64_t v406 = v402;
                v407 = (uint64_t *)v837;
                uint64_t v408 = 312 * v838;
                while (1)
                {
                  uint64_t v409 = *v407;
                  if (*v407 == v404) {
                    break;
                  }
                  v407 += 39;
                  v408 -= 312;
                  if (!v408) {
                    goto LABEL_880;
                  }
                }
                v410 = (char *)v866;
                uint64_t v411 = HIDWORD(v867);
                if (v866 != v865) {
                  goto LABEL_825;
                }
                if (HIDWORD(v867))
                {
                  int v412 = 0;
                  uint64_t v413 = 8 * HIDWORD(v867);
                  int v414 = (uint64_t *)v866;
                  while (*v414 != v404)
                  {
                    if (*v414 == -2) {
                      int v412 = v414;
                    }
                    ++v414;
                    v413 -= 8;
                    if (!v413)
                    {
                      if (!v412) {
                        goto LABEL_823;
                      }
                      *int v412 = v404;
                      --v868;
                      goto LABEL_846;
                    }
                  }
                  goto LABEL_846;
                }
LABEL_823:
                if (HIDWORD(v867) >= v403)
                {
LABEL_825:
                  if (3 * (int)v403 <= (4 * (HIDWORD(v867) - v868)))
                  {
                    if (v403 >= 0x40) {
                      LODWORD(v403) = 2 * v403;
                    }
                    else {
                      LODWORD(v403) = 128;
                    }
                  }
                  else if ((int)v403 - HIDWORD(v867) >= v403 >> 3)
                  {
                    goto LABEL_827;
                  }
                  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v865, v403);
                  uint64_t v403 = v867;
                  v410 = (char *)v866;
LABEL_827:
                  int v415 = v403 - 1;
                  unsigned int v416 = (v403 - 1) & ((v404 >> 4) ^ (v404 >> 9));
                  v417 = &v410[8 * v416];
                  uint64_t v418 = *(void *)v417;
                  if (*(void *)v417 == -1)
                  {
                    int v419 = 0;
LABEL_839:
                    if (v419) {
                      v423 = v419;
                    }
                    else {
                      v423 = (uint64_t *)v417;
                    }
                    if (*v423 != v404)
                    {
                      if (*v423 == -2) {
                        --v868;
                      }
                      else {
                        ++HIDWORD(v867);
                      }
                      uint64_t *v423 = v404;
                    }
                  }
                  else
                  {
                    int v419 = 0;
                    int v420 = 1;
                    while (v418 != v404)
                    {
                      if (v419) {
                        BOOL v421 = 0;
                      }
                      else {
                        BOOL v421 = v418 == -2;
                      }
                      if (v421) {
                        int v419 = (uint64_t *)v417;
                      }
                      unsigned int v422 = v416 + v420++;
                      unsigned int v416 = v422 & v415;
                      v417 = &v410[8 * (v422 & v415)];
                      uint64_t v418 = *(void *)v417;
                      if (*(void *)v417 == -1) {
                        goto LABEL_839;
                      }
                    }
                  }
                  goto LABEL_846;
                }
                ++HIDWORD(v867);
                *((void *)v866 + v411) = v404;
LABEL_846:
                v398 = v845;
                uint64_t v399 = v846;
                if (v845 == v846)
                {
                  uint64_t v399 = v845;
                }
                else
                {
                  uint64_t v403 = v867;
                  int v424 = v867 - 1;
                  if (v866 == v865) {
                    unsigned int v425 = HIDWORD(v867);
                  }
                  else {
                    unsigned int v425 = v867;
                  }
                  uint64_t v426 = (char *)v866 + 8 * v425;
                  while (1)
                  {
                    if (*(unsigned char *)v398[1])
                    {
                      uint64_t v427 = *v398;
                      if (v866 == v865)
                      {
                        uint64_t v428 = (char *)v865 + 8 * HIDWORD(v867);
                        if (HIDWORD(v867))
                        {
                          uint64_t v428 = (char *)v866;
                          while (*(void *)v428 != v427)
                          {
                            v428 += 8;
                            if (v428 == (char *)v865 + 8 * HIDWORD(v867))
                            {
                              uint64_t v428 = (char *)v865 + 8 * HIDWORD(v867);
                              break;
                            }
                          }
                        }
                      }
                      else
                      {
                        unsigned int v429 = ((v427 >> 4) ^ (v427 >> 9)) & v424;
                        uint64_t v428 = (char *)v866 + 8 * v429;
                        uint64_t v430 = *(void *)v428;
                        if (*(void *)v428 == -1)
                        {
                          v431 = 0;
LABEL_871:
                          if (v431) {
                            uint64_t v428 = v431;
                          }
                          uint64_t v435 = *(void *)v428;
                        }
                        else
                        {
                          v431 = 0;
                          int v432 = 1;
                          while (v430 != v427)
                          {
                            if (v431) {
                              BOOL v433 = 0;
                            }
                            else {
                              BOOL v433 = v430 == -2;
                            }
                            if (v433) {
                              v431 = v428;
                            }
                            unsigned int v434 = v429 + v432++;
                            unsigned int v429 = v434 & v424;
                            uint64_t v428 = (char *)v866 + 8 * (v434 & v424);
                            uint64_t v430 = *(void *)v428;
                            if (*(void *)v428 == -1) {
                              goto LABEL_871;
                            }
                          }
                          uint64_t v435 = *v398;
                        }
                        if (v435 != v427) {
                          uint64_t v428 = v426;
                        }
                      }
                      if (v428 == v426) {
                        break;
                      }
                    }
                    v398 += 10;
                    if (v398 == v846)
                    {
                      v398 = v846;
                      break;
                    }
                  }
                }
LABEL_880:
                if (v838)
                {
                  unsigned int v436 = v837;
                  while (1)
                  {
                    uint64_t v437 = v436[1];
                    uint64_t v438 = *((unsigned int *)v436 + 4);
                    if (v438)
                    {
                      uint64_t v439 = 8 * v438;
                      uint64_t v440 = (void *)v436[1];
                      while (*v440 != v405)
                      {
                        ++v440;
                        v439 -= 8;
                        if (!v439)
                        {
                          uint64_t v440 = (void *)(v437 + 8 * v438);
                          break;
                        }
                      }
                    }
                    else
                    {
                      uint64_t v440 = (void *)v436[1];
                    }
                    if (v438 != ((uint64_t)v440 - v437) >> 3) {
                      break;
                    }
                    v436 += 39;
                    if (v436 == (void *)((char *)v837 + 312 * v838)) {
                      goto LABEL_890;
                    }
                  }
                  __int16 v480 = (char *)v866;
                  uint64_t v481 = HIDWORD(v867);
                  if (v866 == v865)
                  {
                    uint64_t v402 = v406;
                    if (HIDWORD(v867))
                    {
                      uint64_t v482 = v403;
                      uint64_t v483 = 0;
                      uint64_t v484 = 8 * HIDWORD(v867);
                      uint64_t v485 = (uint64_t *)v866;
                      while (*v485 != v405)
                      {
                        if (*v485 == -2) {
                          uint64_t v483 = v485;
                        }
                        ++v485;
                        v484 -= 8;
                        if (!v484)
                        {
                          if (!v483) {
                            goto LABEL_961;
                          }
                          *uint64_t v483 = v405;
                          --v868;
                          goto LABEL_1275;
                        }
                      }
                      goto LABEL_1275;
                    }
LABEL_961:
                    uint64_t v486 = v867;
                    if (HIDWORD(v867) < v867)
                    {
                      uint64_t v482 = v867;
                      ++HIDWORD(v867);
                      *((void *)v866 + v481) = v405;
                      goto LABEL_1275;
                    }
                  }
                  else
                  {
                    uint64_t v486 = v867;
                    uint64_t v402 = v406;
                  }
                  if (3 * (int)v486 <= (4 * (HIDWORD(v867) - v868)))
                  {
                    if (v486 >= 0x40) {
                      LODWORD(v486) = 2 * v486;
                    }
                    else {
                      LODWORD(v486) = 128;
                    }
                  }
                  else if ((int)v486 - HIDWORD(v867) >= v486 >> 3)
                  {
LABEL_976:
                    int v490 = v486 - 1;
                    unsigned int v491 = (v486 - 1) & ((v405 >> 4) ^ (v405 >> 9));
                    BOOL v492 = &v480[8 * v491];
                    uint64_t v493 = *(void *)v492;
                    if (*(void *)v492 == -1)
                    {
                      uint64_t v494 = 0;
LABEL_1060:
                      if (v494) {
                        uint64_t v529 = v494;
                      }
                      else {
                        uint64_t v529 = (uint64_t *)v492;
                      }
                      if (*v529 != v405)
                      {
                        if (*v529 == -2) {
                          --v868;
                        }
                        else {
                          ++HIDWORD(v867);
                        }
                        uint64_t v482 = v486;
                        *uint64_t v529 = v405;
                        goto LABEL_1275;
                      }
                    }
                    else
                    {
                      uint64_t v494 = 0;
                      int v495 = 1;
                      while (v493 != v405)
                      {
                        if (v494) {
                          BOOL v496 = 0;
                        }
                        else {
                          BOOL v496 = v493 == -2;
                        }
                        if (v496) {
                          uint64_t v494 = (uint64_t *)v492;
                        }
                        unsigned int v497 = v491 + v495++;
                        unsigned int v491 = v497 & v490;
                        BOOL v492 = &v480[8 * (v497 & v490)];
                        uint64_t v493 = *(void *)v492;
                        if (*(void *)v492 == -1) {
                          goto LABEL_1060;
                        }
                      }
                    }
                    uint64_t v482 = v486;
LABEL_1275:
                    uint64_t v399 = v846;
                    int v397 = v401;
                    uint64_t v401 = sub_1CCDEFC5C(v396, v845, v846, (uint64_t *)&v865, 0);
                    uint64_t v403 = v482;
                    goto LABEL_1276;
                  }
                  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v865, v486);
                  uint64_t v486 = v867;
                  __int16 v480 = (char *)v866;
                  goto LABEL_976;
                }
LABEL_890:
                BOOL v20 = v409 == v404;
                uint64_t v402 = v406;
                if (!v20) {
                  break;
                }
LABEL_1276:
                if (v398 == v399 || v401 == v399)
                {
                  int v138 = 1;
                  goto LABEL_1332;
                }
              }
              if (llvm::Instruction::isSameOperationAs((llvm::Instruction *)v404, (const llvm::Instruction *)v405, 0))
              {
                int v441 = v401;
                goto LABEL_893;
              }
              v813 = v401;
              if (v401 == v846) {
                goto LABEL_1329;
              }
              int v476 = dword_1EBCF4DE8;
              __int16 v477 = v401;
              while (1)
              {
                char isSameOperationAs = llvm::Instruction::isSameOperationAs((llvm::Instruction *)v404, (const llvm::Instruction *)*v477, 0);
                int v441 = v813;
                if ((isSameOperationAs & 1) != 0 || !v476) {
                  break;
                }
                --v476;
                v813 += 10;
                __int16 v479 = v846;
                __int16 v477 = sub_1CCDEFC5C(v396, v845, v846, (uint64_t *)&v865, &v813);
                v813 = v477;
                if (v479 == v477) {
                  goto LABEL_1329;
                }
              }
              if (v813 == v401 || v813 == v846)
              {
LABEL_1329:
                int v138 = 0;
                goto LABEL_1332;
              }
              uint64_t v405 = *v813;
              uint64_t v488 = *(void *)(*v813 + 8);
              if (!v488) {
                goto LABEL_893;
              }
              do
              {
                v489 = v401;
                do
                {
                  if (*(void *)(v488 + 24) == *v489) {
                    goto LABEL_1329;
                  }
                  v489 += 10;
                }
                while (v489 != v813);
                uint64_t v488 = *(void *)(v488 + 8);
              }
              while (v488);
LABEL_893:
              while (2)
              {
                if (v397 < v441)
                {
                  int v442 = *((_DWORD *)v397 + 18);
                  if (v442)
                  {
                    uint64_t v443 = 0;
                    int v444 = -v442;
                    int v445 = v442 - 1;
                    v446 = (uint64_t *)v397[1];
                    unint64_t v447 = 0xFFFFFFFFFFFFFFFFLL >> v444;
                    uint64_t v448 = v445 & 0xFFFFFFC0;
                    while (1)
                    {
                      uint64_t v450 = *v446++;
                      uint64_t v449 = v450;
                      unint64_t v451 = v448 == v443 ? v447 : -1;
                      unint64_t v452 = v451 & v449;
                      if (v452) {
                        break;
                      }
                      v443 += 64;
                      if (v448 + 64 == v443) {
                        goto LABEL_901;
                      }
                    }
                    int v453 = __clz(__rbit64(v452)) + v443;
                  }
                  else
                  {
LABEL_901:
                    int v453 = -1;
                  }
                  if (v453 < (int)v396) {
                    goto LABEL_921;
                  }
                  uint64_t v454 = *v397;
                  int v455 = *(unsigned __int8 *)(*v397 + 16);
                  uint64_t v456 = (v455 - 33);
                  if (v456 > 0x37) {
                    goto LABEL_918;
                  }
                  if (((1 << (v455 - 33)) & 0x8000000000041) != 0)
                  {
                    uint64_t v457 = *(void *)(v454 + 64);
                    if (v457 && (*(unsigned char *)(v457 + 17) & 0x30) != 0) {
                      goto LABEL_917;
                    }
                    int v458 = *(_DWORD *)(v454 + 20);
                    if (v458 < 0
                      && (uint64_t v459 = v454 - 32 * (v458 & 0x7FFFFFF),
                          uint64_t v462 = *(void *)(v459 - 8),
                          uint64_t v460 = v459 - 8,
                          (uint64_t v461 = v462) != 0))
                    {
                      uint64_t v463 = -v461;
                      while (1)
                      {
                        unsigned int v464 = *(_DWORD *)(*(void *)(v460 + v463) + 8);
                        BOOL v103 = v464 > 7;
                        int v465 = (1 << v464) & 0x83;
                        if (v103 || v465 == 0) {
                          break;
                        }
                        v463 += 16;
                        if (!v463) {
                          goto LABEL_912;
                        }
                      }
                    }
                    else
                    {
LABEL_912:
                      if ((llvm::CallBase::hasFnAttrOnCalledFunction(*v397, 45) & 1) != 0
                        || (llvm::CallBase::hasFnAttrOnCalledFunction(v454, 44) & 1) != 0)
                      {
                        goto LABEL_917;
                      }
                    }
LABEL_916:
                    llvm::AliasSetTracker::add((llvm::AliasSetTracker *)&v803, (llvm::Instruction *)v454);
                  }
                  else
                  {
                    if (v456 != 27)
                    {
                      if (((1 << (v455 - 33)) & 0x808001D0000010) != 0) {
                        goto LABEL_916;
                      }
LABEL_918:
                      if (v455 != 83 && (sub_1CCDEFDB0(v454) & 1) == 0) {
                        LODWORD(v402) = llvm::isSafeToSpeculativelyExecute(v454, 0, 0, 0) ^ 1 | v402;
                      }
LABEL_921:
                      v397 += 10;
                      continue;
                    }
                    if ((*(_WORD *)(v454 + 18) & 0x301) != 0) {
                      goto LABEL_916;
                    }
                  }
LABEL_917:
                  int v455 = *(unsigned __int8 *)(v454 + 16);
                  goto LABEL_918;
                }
                break;
              }
              uint64_t v467 = *((unsigned int *)v441 + 4);
              if (!v467) {
                goto LABEL_1576;
              }
              unsigned int v468 = 0;
              int v469 = (int8x8_t *)v441[1];
              uint64_t v470 = 8 * v467;
              do
              {
                int8x8_t v471 = *v469++;
                uint8x8_t v472 = (uint8x8_t)vcnt_s8(v471);
                v472.i16[0] = vaddlv_u8(v472);
                v468 += v472.i32[0];
                v470 -= 8;
              }
              while (v470);
              if (v468 <= 1)
              {
LABEL_1576:
                uint64_t v473 = *(unsigned __int8 *)(v405 + 16) - 33;
                if (v473 <= 0x37)
                {
                  if (((1 << (*(unsigned char *)(v405 + 16) - 33)) & 0x8000000000041) != 0)
                  {
                    uint64_t v498 = *(void *)(v405 + 64);
                    if (!v498 || (*(unsigned char *)(v498 + 20) & 4) == 0 && (*(unsigned char *)(v498 + 17) & 0x10) == 0)
                    {
                      LODWORD(v813) = 7;
                      if (sub_1CC5CB59C(v405, (__int32 *)&v813, 1uLL))
                      {
                        uint64_t v625 = *(void *)(v405 - 32);
                        if (!v625
                          || *(unsigned char *)(v625 + 16)
                          || *(void *)(v625 + 24) != *(void *)(v405 + 72)
                          || *(_DWORD *)(v625 + 36) != 7)
                        {
                          goto LABEL_1324;
                        }
                      }
                      if ((llvm::CallBase::hasFnAttrOnCalledFunction(v405, 66) & 1) == 0
                        && llvm::CallBase::hasFnAttrOnCalledFunction(v405, 44) != 1)
                      {
                        goto LABEL_1324;
                      }
                    }
                  }
                  else
                  {
                    if (((1 << (*(unsigned char *)(v405 + 16) - 33)) & 0x808001C8000010) == 0
                      && (v473 != 28 || (*(_WORD *)(v405 + 18) & 0x301) == 0))
                    {
                      goto LABEL_938;
                    }
LABEL_1324:
                    for (uint64_t k = v805; k != (llvm::AliasSet *)&v804; uint64_t k = (llvm::AliasSet *)*((void *)k + 1))
                    {
                      if (llvm::AliasSet::aliasesUnknownInst(k, (const llvm::Instruction *)v405, v831)) {
                        goto LABEL_1331;
                      }
                    }
                  }
                }
LABEL_938:
                if ((v402 & 1) == 0
                  || ((sub_1CCDEFDB0(v404) & 1) != 0
                   || llvm::isSafeToSpeculativelyExecute(v404, 0, 0, 0))
                  && ((sub_1CCDEFDB0(v405) & 1) != 0
                   || llvm::isSafeToSpeculativelyExecute(v405, 0, 0, 0)))
                {
                  unsigned int v787 = v402;
                  unint64_t v788 = v396;
                  BOOL v474 = sub_1CCDEFE70((uint64_t)&v816, v404, v405);
                  unint64_t v475 = v796;
                  BOOL v798 = v474;
                  if (v474)
                  {
                    switch(*(unsigned char *)(v404 + 16))
                    {
                      case ')':
                      case '-':
                        goto LABEL_1038;
                      case '*':
                      case '.':
                        if ((~*(unsigned __int8 *)(v404 + 17) & 0x12) == 0) {
                          goto LABEL_1038;
                        }
                        break;
                      case '+':
                      case ',':
                        break;
                      default:
                        if (*(unsigned __int8 *)(v404 + 16) - 56 >= 3) {
                          break;
                        }
                        goto LABEL_1038;
                    }
                  }
                  if ((*(_DWORD *)(v404 + 20) & 0x7FFFFFF) != 0)
                  {
                    unint64_t v499 = 0;
                    char v500 = 0;
                    char v501 = 0;
                    do
                    {
                      int v502 = *(_DWORD *)(v405 + 20);
                      if ((v502 & 0x40000000) != 0) {
                        uint64_t v503 = *(void *)(v405 - 8);
                      }
                      else {
                        uint64_t v503 = v405 - 32 * (v502 & 0x7FFFFFF);
                      }
                      uint64_t v504 = *(void *)(v503 + 32 * v499);
                      if (v798 && *(unsigned __int8 *)(v504 + 16) >= 0x1Cu && v504 != 0)
                      {
                        BOOL v506 = sub_1CCDEFE70((uint64_t)&v816, v405, v504);
                        unint64_t v475 = v796;
                        if (v506)
                        {
                          int v507 = *(_DWORD *)(v404 + 20);
                          goto LABEL_1032;
                        }
                      }
                      if (v802)
                      {
                        uint64_t v508 = (v802 - 1) & ((v504 >> 4) ^ (v504 >> 9));
                        uint64_t v509 = *(void *)(v801[0] + 16 * v508);
                        if (v504 == v509)
                        {
LABEL_1009:
                          if (v508 != v802)
                          {
                            unsigned int v510 = (uint64_t *)(v801[0] + 16 * v508 + 8);
LABEL_1016:
                            uint64_t v504 = *v510;
                            goto LABEL_1017;
                          }
                        }
                        else
                        {
                          int v515 = 1;
                          while (v509 != -4096)
                          {
                            int v516 = v508 + v515++;
                            uint64_t v508 = v516 & (v802 - 1);
                            uint64_t v509 = *(void *)(v801[0] + 16 * v508);
                            if (v504 == v509) {
                              goto LABEL_1009;
                            }
                          }
                        }
                      }
                      if (v838)
                      {
                        unsigned int v510 = (uint64_t *)v837;
                        uint64_t v511 = 312 * v838;
                        while (*(void *)(v510[1] + 8 * v475) != v504)
                        {
                          v510 += 39;
                          v511 -= 312;
                          if (!v511) {
                            goto LABEL_1017;
                          }
                        }
                        goto LABEL_1016;
                      }
LABEL_1017:
                      if (v501) {
                        BOOL v512 = v499 == 0;
                      }
                      else {
                        BOOL v512 = v499;
                      }
                      int v507 = *(_DWORD *)(v404 + 20);
                      if ((v507 & 0x40000000) != 0) {
                        uint64_t v513 = *(void *)(v404 - 8);
                      }
                      else {
                        uint64_t v513 = v404 - 32 * (v507 & 0x7FFFFFF);
                      }
                      if (*(void *)(v513 + 32 * v512) != v504)
                      {
                        if ((v501 & 1) != 0
                          || v500 & 1 | ((llvm::Instruction::isCommutative((llvm::Instruction *)v404) & 1) == 0)
                          || ((v507 & 0x40000000) != 0
                            ? (uint64_t v514 = *(void *)(v404 - 8))
                            : (uint64_t v514 = v404 - 32 * (v507 & 0x7FFFFFF)),
                              unint64_t v475 = v796,
                              *(void *)(v514 + 32 * (v499 == 0)) != v504))
                        {
                          int v138 = 0;
                          LODWORD(v396) = v788;
                          goto LABEL_1332;
                        }
                        char v501 = 1;
                      }
                      char v500 = 1;
LABEL_1032:
                      ++v499;
                    }
                    while (v499 < (v507 & 0x7FFFFFFu));
                  }
LABEL_1038:
                  v517 = v855;
                  if (v856 == v855)
                  {
                    unsigned int v518 = HIDWORD(v857);
                    v519 = (char *)v856 + 8 * HIDWORD(v857);
                    if (HIDWORD(v857))
                    {
                      uint64_t v520 = 0;
                      unint64_t v396 = v788;
                      uint64_t v402 = v787;
                      while (*(void *)((char *)v856 + v520) != v404)
                      {
                        v520 += 8;
                        if (8 * HIDWORD(v857) == v520) {
                          goto LABEL_1057;
                        }
                      }
                      v519 = (char *)v856 + v520;
LABEL_1057:
                      uint64_t v528 = v856;
                    }
                    else
                    {
                      uint64_t v528 = v856;
                      unint64_t v396 = v788;
                      uint64_t v402 = v787;
                    }
                  }
                  else
                  {
                    int v521 = v857 - 1;
                    unsigned int v522 = (v857 - 1) & ((v404 >> 4) ^ (v404 >> 9));
                    v519 = (char *)v856 + 8 * v522;
                    uint64_t v523 = *(void *)v519;
                    if (*(void *)v519 == -1)
                    {
                      unint64_t v524 = 0;
                      unint64_t v396 = v788;
                      uint64_t v402 = v787;
LABEL_1069:
                      if (v524) {
                        v519 = v524;
                      }
                      unsigned int v518 = HIDWORD(v857);
                      if (*(void *)v519 != v404) {
                        v519 = (char *)v856 + 8 * v857;
                      }
                    }
                    else
                    {
                      unint64_t v524 = 0;
                      int v525 = 1;
                      unint64_t v396 = v788;
                      uint64_t v402 = v787;
                      while (v523 != v404)
                      {
                        if (v524) {
                          BOOL v526 = 0;
                        }
                        else {
                          BOOL v526 = v523 == -2;
                        }
                        if (v526) {
                          unint64_t v524 = v519;
                        }
                        unsigned int v527 = v522 + v525++;
                        unsigned int v522 = v527 & v521;
                        v519 = (char *)v856 + 8 * (v527 & v521);
                        uint64_t v523 = *(void *)v519;
                        if (*(void *)v519 == -1) {
                          goto LABEL_1069;
                        }
                      }
                      unsigned int v518 = HIDWORD(v857);
                    }
                    uint64_t v528 = v855;
                  }
                  if (v856 == v528) {
                    unsigned int v530 = v518;
                  }
                  else {
                    unsigned int v530 = v857;
                  }
                  if (v519 == (char *)v856 + 8 * v530 && (uint64_t v533 = *(void *)(v404 + 8)) != 0)
                  {
                    uint64_t v535 = *((void *)v829 + 7);
                    uint64_t v534 = *((void *)v829 + 8);
                    if (v534 == v535) {
                      v536 = (char *)v829 + 76;
                    }
                    else {
                      v536 = (char *)v829 + 72;
                    }
                    uint64_t v537 = *((void *)v829 + 8);
                    while (1)
                    {
                      uint64_t v538 = *(void *)(*(void *)(v533 + 24) + 40);
                      if (v537 == v535)
                      {
                        uint64_t v539 = *((unsigned int *)v829 + 19);
                        unsigned int v540 = (void *)(v535 + 8 * v539);
                        if (v539)
                        {
                          uint64_t v541 = 0;
                          uint64_t v542 = 8 * v539;
                          while (*(void *)(v535 + v541) != v538)
                          {
                            v541 += 8;
                            if (v542 == v541) {
                              goto LABEL_1107;
                            }
                          }
                          unsigned int v540 = (void *)(v535 + v541);
                        }
LABEL_1107:
                        uint64_t v537 = *((void *)v829 + 7);
                      }
                      else
                      {
                        int v543 = *((_DWORD *)v829 + 18) - 1;
                        unsigned int v544 = v543 & ((v538 >> 4) ^ (v538 >> 9));
                        unsigned int v540 = (void *)(v534 + 8 * v544);
                        uint64_t v545 = *v540;
                        if (*v540 == -1)
                        {
                          v546 = 0;
LABEL_1109:
                          if (v546) {
                            unsigned int v540 = v546;
                          }
                          if (*v540 != v538) {
                            unsigned int v540 = (void *)(v534 + 8 * *(unsigned int *)v536);
                          }
                        }
                        else
                        {
                          v546 = 0;
                          int v547 = 1;
                          while (v545 != v538)
                          {
                            if (v546) {
                              BOOL v548 = 0;
                            }
                            else {
                              BOOL v548 = v545 == -2;
                            }
                            if (v548) {
                              v546 = v540;
                            }
                            unsigned int v549 = v544 + v547++;
                            unsigned int v544 = v549 & v543;
                            unsigned int v540 = (void *)(v534 + 8 * (v549 & v543));
                            uint64_t v545 = *v540;
                            if (*v540 == -1) {
                              goto LABEL_1109;
                            }
                          }
                        }
                        uint64_t v537 = *((void *)v829 + 8);
                      }
                      uint64_t v550 = v537 == v535 ? (char *)v829 + 76 : (char *)v829 + 72;
                      if (v540 == (void *)(v537 + 8 * *(unsigned int *)v550)) {
                        break;
                      }
                      uint64_t v533 = *(void *)(v533 + 8);
                      if (!v533)
                      {
                        uint64_t v528 = v855;
                        goto LABEL_1078;
                      }
                    }
                  }
                  else
                  {
LABEL_1078:
                    if (v856 == v528)
                    {
                      uint64_t v531 = (char *)v856 + 8 * v518;
                      if (v518)
                      {
                        uint64_t v532 = 0;
                        while (*(void *)((char *)v856 + v532) != v405)
                        {
                          v532 += 8;
                          if (8 * v518 == v532) {
                            goto LABEL_1132;
                          }
                        }
                        uint64_t v531 = (char *)v856 + v532;
                      }
LABEL_1132:
                      v517 = v856;
                    }
                    else
                    {
                      int v551 = v857 - 1;
                      unsigned int v552 = (v857 - 1) & ((v405 >> 4) ^ (v405 >> 9));
                      uint64_t v531 = (char *)v856 + 8 * v552;
                      uint64_t v553 = *(void *)v531;
                      if (*(void *)v531 == -1)
                      {
                        v554 = 0;
LABEL_1283:
                        if (v554) {
                          uint64_t v531 = v554;
                        }
                        if (*(void *)v531 != v405)
                        {
                          if (v856 == v855) {
                            unsigned int v622 = v518;
                          }
                          else {
                            unsigned int v622 = v857;
                          }
                          uint64_t v531 = (char *)v856 + 8 * v622;
                        }
                      }
                      else
                      {
                        v554 = 0;
                        int v555 = 1;
                        while (v553 != v405)
                        {
                          if (v554) {
                            BOOL v556 = 0;
                          }
                          else {
                            BOOL v556 = v553 == -2;
                          }
                          if (v556) {
                            v554 = v531;
                          }
                          unsigned int v557 = v552 + v555++;
                          unsigned int v552 = v557 & v551;
                          uint64_t v531 = (char *)v856 + 8 * (v557 & v551);
                          uint64_t v553 = *(void *)v531;
                          if (*(void *)v531 == -1) {
                            goto LABEL_1283;
                          }
                        }
                      }
                    }
                    if (v856 == v517) {
                      unsigned int v558 = v518;
                    }
                    else {
                      unsigned int v558 = v857;
                    }
                    if (v531 != (char *)v856 + 8 * v558 || (uint64_t v567 = *(void *)(v405 + 8)) == 0)
                    {
LABEL_1137:
                      uint64_t v799 = v404;
                      uint64_t v812 = v405;
                      if (v820)
                      {
                        unsigned int v559 = (v820 - 1) & ((v404 >> 4) ^ (v404 >> 9));
                        uint64_t v560 = *(void *)(v819 + 16 * v559);
                        if (v404 == v560)
                        {
LABEL_1139:
                          *((_DWORD *)sub_1CD3CDD24((uint64_t *)&v821, &v799) + 2) = 0;
                          *((_DWORD *)sub_1CD3CDD24((uint64_t *)&v821, &v812) + 2) = v396;
                          int v811 = 0;
                          int v811 = *((_DWORD *)sub_1CD3CDD24((uint64_t *)&v819, &v799) + 2);
                          sub_1CD422060((uint64_t)&v823, &v811, (uint64_t)&v813);
                        }
                        else
                        {
                          int v623 = 1;
                          while (v560 != -4096)
                          {
                            unsigned int v624 = v559 + v623++;
                            unsigned int v559 = v624 & (v820 - 1);
                            uint64_t v560 = *(void *)(v819 + 16 * v559);
                            if (v404 == v560) {
                              goto LABEL_1139;
                            }
                          }
                        }
                      }
                      uint64_t v799 = v405;
                      uint64_t v800 = v404;
                      sub_1CC27B388((uint64_t)v801, &v799, &v800, (uint64_t)&v813);
                      v561 = (char *)v866;
                      uint64_t v562 = HIDWORD(v867);
                      if (v866 == v865)
                      {
                        if (HIDWORD(v867))
                        {
                          uint64_t v563 = 0;
                          uint64_t v564 = 8 * HIDWORD(v867);
                          v565 = (uint64_t *)v866;
                          while (*v565 != v404)
                          {
                            if (*v565 == -2) {
                              uint64_t v563 = v565;
                            }
                            ++v565;
                            v564 -= 8;
                            if (!v564)
                            {
                              if (!v563) {
                                goto LABEL_1148;
                              }
                              *uint64_t v563 = v404;
                              --v868;
                              break;
                            }
                          }
LABEL_1208:
                          v594 = (char *)v866;
                          uint64_t v595 = HIDWORD(v867);
                          uint64_t v596 = v867;
                          if (v866 == v865)
                          {
                            if (HIDWORD(v867))
                            {
                              unsigned int v597 = 0;
                              uint64_t v598 = 8 * HIDWORD(v867);
                              v599 = (uint64_t *)v866;
                              while (*v599 != v405)
                              {
                                if (*v599 == -2) {
                                  unsigned int v597 = v599;
                                }
                                ++v599;
                                v598 -= 8;
                                if (!v598)
                                {
                                  if (!v597) {
                                    goto LABEL_1216;
                                  }
                                  *unsigned int v597 = v405;
                                  --v868;
                                  goto LABEL_1239;
                                }
                              }
                              goto LABEL_1239;
                            }
LABEL_1216:
                            if (v867 > HIDWORD(v867))
                            {
                              ++HIDWORD(v867);
                              *((void *)v866 + v595) = v405;
LABEL_1239:
                              v398 = v845;
                              if (v845 == v846)
                              {
                                uint64_t v482 = v596;
                              }
                              else
                              {
                                int v609 = v867 - 1;
                                if (v866 == v865) {
                                  unsigned int v610 = HIDWORD(v867);
                                }
                                else {
                                  unsigned int v610 = v867;
                                }
                                __int16 v611 = (char *)v866 + 8 * v610;
                                while (1)
                                {
                                  if (*(unsigned char *)v398[1])
                                  {
                                    uint64_t v612 = *v398;
                                    if (v866 == v865)
                                    {
                                      v613 = (char *)v865 + 8 * HIDWORD(v867);
                                      if (HIDWORD(v867))
                                      {
                                        v613 = (char *)v866;
                                        while (*(void *)v613 != v612)
                                        {
                                          v613 += 8;
                                          if (v613 == (char *)v865 + 8 * HIDWORD(v867))
                                          {
                                            v613 = (char *)v865 + 8 * HIDWORD(v867);
                                            break;
                                          }
                                        }
                                      }
                                    }
                                    else
                                    {
                                      unsigned int v614 = ((v612 >> 4) ^ (v612 >> 9)) & v609;
                                      v613 = (char *)v866 + 8 * v614;
                                      uint64_t v615 = *(void *)v613;
                                      if (*(void *)v613 == -1)
                                      {
                                        v616 = 0;
LABEL_1264:
                                        if (v616) {
                                          v613 = v616;
                                        }
                                        uint64_t v620 = *(void *)v613;
                                      }
                                      else
                                      {
                                        v616 = 0;
                                        int v617 = 1;
                                        while (v615 != v612)
                                        {
                                          if (v616) {
                                            BOOL v618 = 0;
                                          }
                                          else {
                                            BOOL v618 = v615 == -2;
                                          }
                                          if (v618) {
                                            v616 = v613;
                                          }
                                          unsigned int v619 = v614 + v617++;
                                          unsigned int v614 = v619 & v609;
                                          v613 = (char *)v866 + 8 * (v619 & v609);
                                          uint64_t v615 = *(void *)v613;
                                          if (*(void *)v613 == -1) {
                                            goto LABEL_1264;
                                          }
                                        }
                                        uint64_t v620 = *v398;
                                      }
                                      if (v620 != v612) {
                                        v613 = v611;
                                      }
                                    }
                                    if (v613 == v611) {
                                      break;
                                    }
                                  }
                                  v398 += 10;
                                  if (v398 == v846)
                                  {
                                    uint64_t v482 = v867;
                                    uint64_t v401 = v441;
                                    v398 = v846;
                                    goto LABEL_1275;
                                  }
                                }
                                uint64_t v482 = v867;
                              }
                              uint64_t v401 = v441;
                              goto LABEL_1275;
                            }
                          }
                          if (3 * (int)v867 <= (4 * (HIDWORD(v867) - v868)))
                          {
                            if (v867 >= 0x40) {
                              LODWORD(v596) = 2 * v867;
                            }
                            else {
                              LODWORD(v596) = 128;
                            }
                          }
                          else if ((int)v867 - HIDWORD(v867) >= v867 >> 3)
                          {
                            goto LABEL_1220;
                          }
                          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v865, v596);
                          uint64_t v596 = v867;
                          v594 = (char *)v866;
LABEL_1220:
                          int v600 = v596 - 1;
                          unsigned int v601 = (v596 - 1) & ((v405 >> 4) ^ (v405 >> 9));
                          int v602 = &v594[8 * v601];
                          uint64_t v603 = *(void *)v602;
                          if (*(void *)v602 == -1)
                          {
                            __int16 v604 = 0;
LABEL_1232:
                            if (v604) {
                              v608 = v604;
                            }
                            else {
                              v608 = (uint64_t *)v602;
                            }
                            if (*v608 != v405)
                            {
                              if (*v608 == -2) {
                                --v868;
                              }
                              else {
                                ++HIDWORD(v867);
                              }
                              uint64_t *v608 = v405;
                            }
                          }
                          else
                          {
                            __int16 v604 = 0;
                            int v605 = 1;
                            while (v603 != v405)
                            {
                              if (v604) {
                                BOOL v606 = 0;
                              }
                              else {
                                BOOL v606 = v603 == -2;
                              }
                              if (v606) {
                                __int16 v604 = (uint64_t *)v602;
                              }
                              unsigned int v607 = v601 + v605++;
                              unsigned int v601 = v607 & v600;
                              int v602 = &v594[8 * (v607 & v600)];
                              uint64_t v603 = *(void *)v602;
                              if (*(void *)v602 == -1) {
                                goto LABEL_1232;
                              }
                            }
                          }
                          goto LABEL_1239;
                        }
LABEL_1148:
                        unsigned int v566 = v867;
                        if (HIDWORD(v867) < v867)
                        {
                          ++HIDWORD(v867);
                          *((void *)v866 + v562) = v404;
                          goto LABEL_1208;
                        }
                      }
                      else
                      {
                        unsigned int v566 = v867;
                      }
                      if (3 * v566 <= 4 * (HIDWORD(v867) - v868))
                      {
                        if (v566 >= 0x40) {
                          v566 *= 2;
                        }
                        else {
                          unsigned int v566 = 128;
                        }
                      }
                      else if (v566 - HIDWORD(v867) >= v566 >> 3)
                      {
                        goto LABEL_1189;
                      }
                      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v865, v566);
                      unsigned int v566 = v867;
                      v561 = (char *)v866;
LABEL_1189:
                      unsigned int v585 = v566 - 1;
                      unsigned int v586 = (v566 - 1) & ((v404 >> 4) ^ (v404 >> 9));
                      v587 = &v561[8 * v586];
                      uint64_t v588 = *(void *)v587;
                      if (*(void *)v587 == -1)
                      {
                        uint64_t v589 = 0;
LABEL_1201:
                        if (v589) {
                          v593 = v589;
                        }
                        else {
                          v593 = (uint64_t *)v587;
                        }
                        if (*v593 != v404)
                        {
                          if (*v593 == -2) {
                            --v868;
                          }
                          else {
                            ++HIDWORD(v867);
                          }
                          uint64_t *v593 = v404;
                        }
                      }
                      else
                      {
                        uint64_t v589 = 0;
                        int v590 = 1;
                        while (v588 != v404)
                        {
                          if (v589) {
                            BOOL v591 = 0;
                          }
                          else {
                            BOOL v591 = v588 == -2;
                          }
                          if (v591) {
                            uint64_t v589 = (uint64_t *)v587;
                          }
                          unsigned int v592 = v586 + v590++;
                          unsigned int v586 = v592 & v585;
                          v587 = &v561[8 * (v592 & v585)];
                          uint64_t v588 = *(void *)v587;
                          if (*(void *)v587 == -1) {
                            goto LABEL_1201;
                          }
                        }
                      }
                      goto LABEL_1208;
                    }
                    uint64_t v569 = *((void *)v829 + 7);
                    uint64_t v568 = *((void *)v829 + 8);
                    if (v568 == v569) {
                      unsigned int v570 = (char *)v829 + 76;
                    }
                    else {
                      unsigned int v570 = (char *)v829 + 72;
                    }
                    uint64_t v571 = *((void *)v829 + 8);
                    while (1)
                    {
                      uint64_t v572 = *(void *)(*(void *)(v567 + 24) + 40);
                      if (v571 == v569)
                      {
                        uint64_t v573 = *((unsigned int *)v829 + 19);
                        unsigned int v574 = (void *)(v569 + 8 * v573);
                        if (v573)
                        {
                          uint64_t v575 = 0;
                          uint64_t v576 = 8 * v573;
                          while (*(void *)(v569 + v575) != v572)
                          {
                            v575 += 8;
                            if (v576 == v575) {
                              goto LABEL_1173;
                            }
                          }
                          unsigned int v574 = (void *)(v569 + v575);
                        }
LABEL_1173:
                        uint64_t v571 = *((void *)v829 + 7);
                      }
                      else
                      {
                        int v577 = *((_DWORD *)v829 + 18) - 1;
                        unsigned int v578 = v577 & ((v572 >> 4) ^ (v572 >> 9));
                        unsigned int v574 = (void *)(v568 + 8 * v578);
                        uint64_t v579 = *v574;
                        if (*v574 == -1)
                        {
                          BOOL v580 = 0;
LABEL_1175:
                          if (v580) {
                            unsigned int v574 = v580;
                          }
                          if (*v574 != v572) {
                            unsigned int v574 = (void *)(v568 + 8 * *(unsigned int *)v570);
                          }
                        }
                        else
                        {
                          BOOL v580 = 0;
                          int v581 = 1;
                          while (v579 != v572)
                          {
                            if (v580) {
                              BOOL v582 = 0;
                            }
                            else {
                              BOOL v582 = v579 == -2;
                            }
                            if (v582) {
                              BOOL v580 = v574;
                            }
                            unsigned int v583 = v578 + v581++;
                            unsigned int v578 = v583 & v577;
                            unsigned int v574 = (void *)(v568 + 8 * (v583 & v577));
                            uint64_t v579 = *v574;
                            if (*v574 == -1) {
                              goto LABEL_1175;
                            }
                          }
                        }
                        uint64_t v571 = *((void *)v829 + 8);
                      }
                      uint64_t v584 = v571 == v569 ? (char *)v829 + 76 : (char *)v829 + 72;
                      if (v574 == (void *)(v571 + 8 * *(unsigned int *)v584)) {
                        break;
                      }
                      uint64_t v567 = *(void *)(v567 + 8);
                      if (!v567) {
                        goto LABEL_1137;
                      }
                    }
                  }
                }
              }
LABEL_1331:
              int v138 = 0;
            }
          }
LABEL_1332:
          if (v866 != v865) {
            free(v866);
          }
          MEMORY[0x1D25D9CD0](v801[0], 8);
          sub_1CBF63354((uint64_t)&v803);
          if ((v138 & 1) == 0) {
            break;
          }
          unint64_t v396 = (v396 + 1);
          if (v836 <= v396) {
            break;
          }
          continue;
        }
      }
LABEL_1338:
      if (v851 != v850) {
        free(v851);
      }
      if (v856 != v855) {
        free(v856);
      }
      if (v861 != v860) {
        free(v861);
      }
      if (!v138) {
        goto LABEL_1544;
      }
      int v627 = DWORD2(v823);
      unsigned int v628 = (int *)v823;
      uint64_t v629 = v824;
      v630 = (int *)(v823 + 4 * v824);
      uint64_t v631 = v824;
      v632 = v630;
      if (DWORD2(v823))
      {
        if (v824)
        {
          uint64_t v633 = 4 * v824;
          v632 = (int *)v823;
          while ((*v632 - 0x7FFFFFFF) <= 1)
          {
            ++v632;
            v633 -= 4;
            if (!v633)
            {
              uint64_t v631 = v824;
              v632 = (int *)(v823 + 4 * v824);
              goto LABEL_1362;
            }
          }
          uint64_t v631 = v824;
        }
        else
        {
          uint64_t v631 = 0;
          v632 = (int *)v823;
        }
      }
LABEL_1362:
      v635 = (int *)(v823 + 4 * v631);
      if (v632 != v635)
      {
        v638 = v635;
        do
        {
          int v639 = *v632;
          v640 = (char *)v816 + 152 * *v632;
          uint64_t v641 = *((unsigned int *)v640 + 4);
          if (v641 != 1)
          {
            int v644 = 0;
            int v645 = 0;
            int v646 = 0;
            unint64_t v647 = (void **)(*((void *)v640 + 1) + 8);
            for (uint64_t m = 8 * v641 - 8; m; m -= 8)
            {
              v865 = 0;
              v865 = *v647;
              v649 = sub_1CD3CDD24((uint64_t *)&v821, &v865);
              int v650 = *((_DWORD *)v649 + 2);
              if (v650 != v646 && v650 != v646 + 1)
              {
                uint64_t v652 = *(void *)(*((void *)v816 + 19 * v639 + 1) + 8 * *((unsigned int *)v816 + 38 * v639 + 4) - 8);
                switch(*(unsigned char *)(v652 + 16))
                {
                  case ')':
                  case '-':
                    break;
                  case '*':
                  case '.':
                    if ((~*(unsigned __int8 *)(v652 + 17) & 0x12) == 0) {
                      break;
                    }
                    goto LABEL_1392;
                  case '+':
                  case ',':
                    goto LABEL_1392;
                  default:
                    if (*(unsigned __int8 *)(v652 + 16) - 56 < 3) {
                      break;
                    }
                    goto LABEL_1392;
                }
              }
              if (v650 != v646)
              {
                if (v644 != v645)
                {
LABEL_1392:
                  int v138 = 0;
                  goto LABEL_1544;
                }
                int v644 = 0;
              }
              ++v644;
              if (!v650) {
                ++v645;
              }
              ++v647;
              int v646 = *((_DWORD *)v649 + 2);
            }
          }
          v642 = v632 + 1;
          while (v642 != v630)
          {
            int v643 = *v642++;
            if ((v643 - 0x7FFFFFFF) >= 2)
            {
              v632 = v642 - 1;
              goto LABEL_1390;
            }
          }
          v632 = v630;
LABEL_1390:
          ;
        }
        while (v632 != v638);
        int v627 = DWORD2(v823);
        unsigned int v628 = (int *)v823;
        uint64_t v629 = v824;
      }
      v636 = &v628[v629];
      if (v627)
      {
        if (v629)
        {
          uint64_t v734 = 4 * v629;
          v637 = v628;
          while ((*v637 - 0x7FFFFFFF) <= 1)
          {
            ++v637;
            v734 -= 4;
            if (!v734) {
              goto LABEL_1364;
            }
          }
        }
        else
        {
          v637 = v628;
        }
      }
      else
      {
LABEL_1364:
        v637 = &v628[v629];
      }
      uint64_t v653 = &v628[v629];
      while (v637 != v653)
      {
        uint64_t v654 = 0;
        int v655 = *v637;
        uint64_t v656 = (*((_DWORD *)v816 + 38 * *v637 + 4) - 1);
        while (v656 != v654)
        {
          uint64_t v657 = v654 + 1;
          v865 = *(void **)(*((void *)v816 + 19 * v655 + 1) + 8 * v654 + 8);
          v658 = sub_1CD3CDD24((uint64_t *)&v821, &v865);
          uint64_t v654 = v657;
          if (*((_DWORD *)v658 + 2))
          {
            LODWORD(v656) = v657 - 2;
            break;
          }
        }
        v865 = &v867;
        v866 = (void *)0x1000000000;
        uint64_t v659 = *(void *)(*(void *)(*((void *)v816 + 19 * v655 + 1)
                                     + 8 * *((unsigned int *)v816 + 38 * v655 + 4)
                                     - 8)
                         + 8);
        if (v659)
        {
          LODWORD(v660) = 0;
          do
          {
            if (v660 >= HIDWORD(v866)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v865 + v660) = *(void *)(v659 + 24);
            uint64_t v660 = (v866 + 1);
            LODWORD(v866) = v866 + 1;
            uint64_t v659 = *(void *)(v659 + 8);
          }
          while (v659);
          unint64_t v661 = (llvm::User **)v865;
          if (v660)
          {
            uint64_t v662 = (int)v656 + 1;
            uint64_t v663 = 8 * v660;
            do
            {
              unint64_t v664 = *v661++;
              llvm::User::replaceUsesOfWith(v664, *(llvm::Value **)(*((void *)v816 + 19 * v655 + 1) + 8 * *((unsigned int *)v816 + 38 * v655 + 4) - 8), *(llvm::Value **)(*((void *)v816 + 19 * v655 + 1) + 8 * v662));
              v663 -= 8;
            }
            while (v663);
            unint64_t v661 = (llvm::User **)v865;
          }
          if (v661 != (llvm::User **)&v867) {
            free(v661);
          }
        }
        uint64_t v665 = v637 + 1;
        while (v665 != v636)
        {
          int v666 = *v665++;
          if ((v666 - 0x7FFFFFFF) >= 2)
          {
            v637 = v665 - 1;
            goto LABEL_1417;
          }
        }
        v637 = v636;
LABEL_1417:
        ;
      }
      uint64_t v667 = (void *)**((void **)v829 + 4);
      v860 = &v862;
      v861 = (void *)0x800000000;
      v855 = &v857;
      v856 = (void *)0x800000000;
      if (v838)
      {
        unsigned int v707 = (char *)v837;
        v708 = (char *)v837 + 312 * v838;
        while (1)
        {
          unint64_t v709 = *(void *)v707;
          uint64_t v710 = *((void *)v830 + 13);
          unsigned int v711 = *((_DWORD *)v830 + 30);
          if (!v711) {
            goto LABEL_1456;
          }
          unsigned int v712 = ((v709 >> 4) ^ (v709 >> 9)) & (v711 - 1);
          uint64_t v713 = v710 + 48 * v712;
          uint64_t v714 = *(void *)(v713 + 24);
          if (v714 != v709) {
            break;
          }
LABEL_1457:
          if (v713 == v710 + 48 * v711 || (v717 = *(const llvm::APInt **)(v713 + 40)) == 0) {
            v717 = (const llvm::APInt *)llvm::ScalarEvolution::createSCEVIter(v830, v709);
          }
          if (v861 >= (unint64_t)HIDWORD(v861)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v860 + v861) = **((void **)v717 + 4);
          LODWORD(v861) = v861 + 1;
          v718 = v830;
          unint64_t v719 = **((void **)v707 + 1);
          uint64_t v720 = *((void *)v830 + 13);
          unsigned int v721 = *((_DWORD *)v830 + 30);
          if (v721)
          {
            unsigned int v722 = v721 - 1;
            unsigned int v723 = ((v719 >> 4) ^ (v719 >> 9)) & (v721 - 1);
            uint64_t v724 = v720 + 48 * v723;
            uint64_t v725 = *(void *)(v724 + 24);
            if (v725 == v719) {
              goto LABEL_1468;
            }
            int v726 = 1;
            while (v725 != -4096)
            {
              unsigned int v727 = v723 + v726++;
              unsigned int v723 = v727 & v722;
              uint64_t v724 = v720 + 48 * (v727 & v722);
              uint64_t v725 = *(void *)(v724 + 24);
              if (v725 == v719) {
                goto LABEL_1468;
              }
            }
          }
          uint64_t v724 = v720 + 48 * v721;
LABEL_1468:
          if (v724 == v720 + 48 * v721 || (__int16 v728 = *(llvm::SCEV **)(v724 + 40)) == 0) {
            __int16 v728 = (llvm::SCEV *)llvm::ScalarEvolution::createSCEVIter(v830, v719);
          }
          unint64_t MinusSCEV = llvm::ScalarEvolution::getMinusSCEV(v718, v728, v717, 0, 0);
          if (v856 >= (unint64_t)HIDWORD(v856)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v855 + v856) = MinusSCEV;
          LODWORD(v856) = v856 + 1;
          v707 += 312;
          if (v707 == v708) {
            goto LABEL_1419;
          }
        }
        int v715 = 1;
        while (v714 != -4096)
        {
          unsigned int v716 = v712 + v715++;
          unsigned int v712 = v716 & (v711 - 1);
          uint64_t v713 = v710 + 48 * v712;
          uint64_t v714 = *(void *)(v713 + 24);
          if (v714 == v709) {
            goto LABEL_1457;
          }
        }
LABEL_1456:
        uint64_t v713 = v710 + 48 * v711;
        goto LABEL_1457;
      }
LABEL_1419:
      v669 = v667 + 5;
      v668 = (void *)v667[5];
      if (v668 != v667 + 5)
      {
        do
        {
          int v670 = (void *)*v668;
          v865 = v668 - 3;
          uint64_t v671 = sub_1CD77346C((uint64_t)v843, (uint64_t *)&v865);
          int v672 = *(_DWORD *)(v671 + 64);
          if (v672)
          {
            int v673 = -v672;
            unsigned int v674 = (v672 - 1) >> 6;
            v675 = *(uint64_t **)v671;
            unint64_t v676 = 0xFFFFFFFFFFFFFFFFLL >> v673;
            uint64_t v677 = v674 + 1;
            int v678 = 1;
            while (1)
            {
              uint64_t v680 = *v675++;
              uint64_t v679 = v680;
              unint64_t v681 = v677 == 1 ? v676 : -1;
              unint64_t v682 = v681 & v679;
              if (v682) {
                break;
              }
              v678 -= 64;
              if (!--v677) {
                goto LABEL_1430;
              }
            }
            if (__clz(__rbit64(v682)) - v678 <= 0x1F) {
              llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
            }
          }
LABEL_1430:
          v668 = v670;
        }
        while (v670 != v669);
      }
      uint64_t v683 = v838;
      if (v838)
      {
        uint64_t v684 = 0;
        do
        {
          v685 = (llvm::BasicBlock *)**((void **)v829 + 4);
          v686 = (llvm::Value *)*((void *)v837 + 39 * v684);
          uint64_t AddRecExpr = (llvm::Instruction **)llvm::ScalarEvolution::getAddRecExpr(v830, *((void *)v860 + v684), *((void *)v855 + v684), (const llvm::Loop *)v829, 0);
          sub_1CC2B6C4C((uint64_t)&v865, (uint64_t ***)v830, *(void *)(*((void *)v685 + 7) + 40) + 272, (uint64_t)"reroll", 1);
          v688 = *(llvm::Type **)v686;
          FirstNonPHIOrDbg = llvm::BasicBlock::getFirstNonPHIOrDbg(v685, 1);
          v690 = llvm::SCEVExpander::expandCodeForImpl((llvm::SCEVExpander *)&v865, AddRecExpr, v688, (llvm::Instruction *)FirstNonPHIOrDbg);
          uint64_t v691 = v845;
          uint64_t v692 = v846;
          if (v845 != v846)
          {
            v693 = v690;
            do
            {
              int v694 = *((_DWORD *)v691 + 18);
              if (v694)
              {
                uint64_t v695 = 0;
                int v696 = -v694;
                int v697 = v694 - 1;
                v698 = (uint64_t *)v691[1];
                unint64_t v699 = 0xFFFFFFFFFFFFFFFFLL >> v696;
                uint64_t v700 = v697 & 0xFFFFFFC0;
                while (1)
                {
                  uint64_t v702 = *v698++;
                  uint64_t v701 = v702;
                  unint64_t v703 = v700 == v695 ? v699 : -1;
                  unint64_t v704 = v703 & v701;
                  if (v704) {
                    break;
                  }
                  v695 += 64;
                  if (v700 + 64 == v695) {
                    goto LABEL_1445;
                  }
                }
                if (!(__clz(__rbit64(v704)) + v695)) {
                  llvm::User::replaceUsesOfWith((llvm::User *)*v691, v686, v693);
                }
              }
LABEL_1445:
              v691 += 10;
            }
            while (v691 != v692);
          }
          sub_1CC2B7040((uint64_t)&v865);
          ++v684;
        }
        while (v684 != v683);
      }
      v705 = (void *)*v669;
      if ((void *)*v669 == v669)
      {
        uint64_t v706 = 0;
      }
      else
      {
        if (v705) {
          v730 = (unsigned __int8 *)(v705 - 3);
        }
        else {
          v730 = 0;
        }
        if (v730[16] - 29 >= 0xB) {
          uint64_t v706 = 0;
        }
        else {
          uint64_t v706 = (llvm::Instruction *)v730;
        }
      }
      sub_1CC2B6C4C((uint64_t)&v865, (uint64_t ***)v830, *(void *)(v667[7] + 40) + 272, (uint64_t)"reroll", 1);
      uint64_t v731 = v784;
      while (2)
      {
        switch(*(_WORD *)(v731 + 24))
        {
          case 1:
          case 2:
          case 3:
          case 0xD:
            v733 = (llvm::Type **)(v731 + 40);
            goto LABEL_1494;
          case 4:
            v733 = (llvm::Type **)(v731 + 48);
            goto LABEL_1494;
          case 5:
          case 7:
          case 8:
          case 9:
          case 0xA:
          case 0xB:
          case 0xC:
            v732 = *(uint64_t **)(v731 + 32);
            goto LABEL_1485;
          case 6:
            v732 = (uint64_t *)(v731 + 40);
LABEL_1485:
            uint64_t v731 = *v732;
            continue;
          case 0xE:
            v733 = *(llvm::Type ***)(v731 - 8);
            goto LABEL_1494;
          default:
            v733 = *(llvm::Type ***)(v731 + 32);
LABEL_1494:
            unint64_t Constant = llvm::ScalarEvolution::getConstant(v830, *v733, 0, 0);
            uint64_t v736 = v784;
            while (2)
            {
              switch(*(_WORD *)(v736 + 24))
              {
                case 1:
                case 2:
                case 3:
                case 0xD:
                  uint64_t v738 = (llvm::Type **)(v736 + 40);
                  goto LABEL_1502;
                case 4:
                  uint64_t v738 = (llvm::Type **)(v736 + 48);
                  goto LABEL_1502;
                case 5:
                case 7:
                case 8:
                case 9:
                case 0xA:
                case 0xB:
                case 0xC:
                  char v737 = *(uint64_t **)(v736 + 32);
                  goto LABEL_1497;
                case 6:
                  char v737 = (uint64_t *)(v736 + 40);
LABEL_1497:
                  uint64_t v736 = *v737;
                  continue;
                case 0xE:
                  uint64_t v738 = *(llvm::Type ***)(v736 - 8);
                  goto LABEL_1502;
                default:
                  uint64_t v738 = *(llvm::Type ***)(v736 + 32);
LABEL_1502:
                  uint64_t v739 = (const llvm::APInt *)llvm::ScalarEvolution::getConstant(v830, *v738, 1uLL, 0);
                  v740 = (llvm::Instruction **)llvm::ScalarEvolution::getAddRecExpr(v830, Constant, (uint64_t)v739, (const llvm::Loop *)v829, 0);
                  uint64_t v741 = v784;
                  while (2)
                  {
                    switch(*(_WORD *)(v741 + 24))
                    {
                      case 1:
                      case 2:
                      case 3:
                      case 0xD:
                        v743 = (llvm::Type **)(v741 + 40);
                        goto LABEL_1510;
                      case 4:
                        v743 = (llvm::Type **)(v741 + 48);
                        goto LABEL_1510;
                      case 5:
                      case 7:
                      case 8:
                      case 9:
                      case 0xA:
                      case 0xB:
                      case 0xC:
                        v742 = *(uint64_t **)(v741 + 32);
                        goto LABEL_1505;
                      case 6:
                        v742 = (uint64_t *)(v741 + 40);
LABEL_1505:
                        uint64_t v741 = *v742;
                        continue;
                      case 0xE:
                        v743 = *(llvm::Type ***)(v741 - 8);
                        goto LABEL_1510;
                      default:
                        v743 = *(llvm::Type ***)(v741 + 32);
LABEL_1510:
                        v744 = *v743;
                        v745 = llvm::BasicBlock::getFirstNonPHIOrDbg((llvm::BasicBlock *)v667, 1);
                        v746 = llvm::SCEVExpander::expandCodeForImpl((llvm::SCEVExpander *)&v865, v740, v744, (llvm::Instruction *)v745);
                        v850 = &v852;
                        uint64_t v852 = v784;
                        unint64_t v853 = (unint64_t)v739;
                        v851 = (void *)0x200000002;
                        uint64_t AddExpr = llvm::ScalarEvolution::getAddExpr((uint64_t)v830, (unint64_t **)&v850, 0, 0);
                        if (v850 != &v852) {
                          free(v850);
                        }
                        v748 = v830;
                        uint64_t v749 = v784;
                        while (2)
                        {
                          switch(*(_WORD *)(v749 + 24))
                          {
                            case 1:
                            case 2:
                            case 3:
                            case 0xD:
                              v751 = (llvm::Type **)(v749 + 40);
                              goto LABEL_1520;
                            case 4:
                              v751 = (llvm::Type **)(v749 + 48);
                              goto LABEL_1520;
                            case 5:
                            case 7:
                            case 8:
                            case 9:
                            case 0xA:
                            case 0xB:
                            case 0xC:
                              v750 = *(uint64_t **)(v749 + 32);
                              goto LABEL_1515;
                            case 6:
                              v750 = (uint64_t *)(v749 + 40);
LABEL_1515:
                              uint64_t v749 = *v750;
                              continue;
                            case 0xE:
                              v751 = *(llvm::Type ***)(v749 - 8);
                              goto LABEL_1520;
                            default:
                              v751 = *(llvm::Type ***)(v749 + 32);
LABEL_1520:
                              unint64_t v752 = llvm::ScalarEvolution::getConstant(v830, *v751, v836, 0);
                              v850 = &v852;
                              uint64_t v852 = AddExpr;
                              unint64_t v853 = v752;
                              v851 = (void *)0x200000002;
                              uint64_t MulExpr = (llvm::SCEV *)llvm::ScalarEvolution::getMulExpr((uint64_t)v748, (uint64_t)&v850, 0, 0);
                              if (v850 != &v852) {
                                free(v850);
                              }
                              v754 = (llvm::Instruction **)llvm::ScalarEvolution::getMinusSCEV(v830, MulExpr, v739, 0, 0);
                              uint64_t v755 = v784;
                              while (2)
                              {
                                switch(*(_WORD *)(v755 + 24))
                                {
                                  case 1:
                                  case 2:
                                  case 3:
                                  case 0xD:
                                    v757 = (llvm::Type **)(v755 + 40);
                                    goto LABEL_1530;
                                  case 4:
                                    v757 = (llvm::Type **)(v755 + 48);
                                    goto LABEL_1530;
                                  case 5:
                                  case 7:
                                  case 8:
                                  case 9:
                                  case 0xA:
                                  case 0xB:
                                  case 0xC:
                                    v756 = *(uint64_t **)(v755 + 32);
                                    goto LABEL_1525;
                                  case 6:
                                    v756 = (uint64_t *)(v755 + 40);
LABEL_1525:
                                    uint64_t v755 = *v756;
                                    continue;
                                  case 0xE:
                                    v757 = *(llvm::Type ***)(v755 - 8);
                                    goto LABEL_1530;
                                  default:
                                    v757 = *(llvm::Type ***)(v755 + 32);
LABEL_1530:
                                    v758 = *v757;
                                    v759 = llvm::BasicBlock::getFirstNonPHIOrDbg((llvm::BasicBlock *)v667, 1);
                                    v760 = llvm::SCEVExpander::expandCodeForImpl((llvm::SCEVExpander *)&v865, v754, v758, (llvm::Instruction *)v759);
                                    v761 = (char *)operator new(0x80uLL);
                                    v762 = (llvm::Value *)(v761 + 64);
                                    *((_DWORD *)v761 + 21) = *((_DWORD *)v761 + 21) & 0x38000000 | 2;
                                    *(void *)v761 = 0;
                                    *((void *)v761 + 1) = 0;
                                    *((void *)v761 + 2) = 0;
                                    *((void *)v761 + 3) = v761 + 64;
                                    *((void *)v761 + 4) = 0;
                                    *((void *)v761 + 5) = 0;
                                    *((void *)v761 + 6) = 0;
                                    *((void *)v761 + 7) = v761 + 64;
                                    v850 = "exitcond";
                                    v854[0] = 259;
                                    v763 = *(void ***)v746;
                                    uint64_t v764 = ***(void ***)v746 + 1888;
                                    if (*(void *)v746 && (v763[1] & 0xFE) == 0x12)
                                    {
                                      v774 = (uint64_t **)(***(void ***)v746 + 1888);
                                      v775 = (llvm::Type *)*((unsigned int *)v763 + 8);
                                      if (*((_DWORD *)v763 + 2) == 19) {
                                        llvm::ScalableVectorType::get(v774, v775);
                                      }
                                      else {
                                        llvm::FixedVectorType::get((llvm::FixedVectorType *)v774, v775);
                                      }
                                      uint64_t v764 = v776;
                                    }
                                    llvm::CmpInst::CmpInst(v762, v764, 53, 32, (uint64_t)v746, (uint64_t)v760, (const char **)&v850, (uint64_t)v706, 0);
                                    if (*((void *)v706 - 12))
                                    {
                                      **((void **)v706 - 10) = *((void *)v706 - 11);
                                      uint64_t v765 = *((void *)v706 - 11);
                                      if (v765) {
                                        *(void *)(v765 + 16) = *((void *)v706 - 10);
                                      }
                                    }
                                    *((void *)v706 - 12) = v762;
                                    uint64_t v768 = *((void *)v761 + 9);
                                    v767 = v761 + 72;
                                    uint64_t v766 = v768;
                                    *((void *)v706 - 11) = v768;
                                    if (v768) {
                                      *(void *)(v766 + 16) = (char *)v706 - 88;
                                    }
                                    *((void *)v706 - 10) = v767;
                                    void *v767 = (char *)v706 - 96;
                                    if (*((void **)v706 - 8) != v667) {
                                      llvm::BranchInst::swapSuccessors(v706);
                                    }
                                    sub_1CC2B7040((uint64_t)&v865);
                                    llvm::SimplifyInstructionsInBlock(v667, (uint64_t *)v832, v769, v770, v771, v772, v773);
                                    llvm::DeleteDeadPHIs((uint64_t)v667, (uint64_t *)v832, 0);
                                    if (v855 != &v857) {
                                      free(v855);
                                    }
                                    if (v860 != &v862) {
                                      free(v860);
                                    }
                                    int v138 = 1;
                                    break;
                                }
                                break;
                              }
                              break;
                          }
                          break;
                        }
                        break;
                    }
                    break;
                  }
                  break;
              }
              break;
            }
            break;
        }
        break;
      }
LABEL_1544:
      uint64_t v124 = v786;
      int v122 = (uint64_t *)v781;
      uint64_t v121 = v782;
      uint64_t v123 = v780;
LABEL_254:
      sub_1CD77367C((uint64_t)v843);
      if (v840 != v842) {
        free(v840);
      }
      sub_1CCDEFBF8((void **)v837, (void **)v837 + 39 * v838);
      if (v837 != v839) {
        free(v837);
      }
      if (v138)
      {
        llvm::ScalarEvolution::forgetLoop(*(int32x2_t **)(v124 + 16), (const llvm::Loop *)v8);
        uint64_t v6 = 1;
        goto LABEL_1558;
      }
      if (++v121 == v122) {
        goto LABEL_1557;
      }
    }
    uint64_t v158 = 0;
    while (1)
    {
      uint64_t v159 = *((unsigned int *)v816 + 38 * v158 + 4);
      if (!((v159 - 1) % v142)) {
        break;
      }
LABEL_293:
      if (++v158 == v143) {
        goto LABEL_267;
      }
    }
    uint64_t v160 = *(void *)(*((void *)v816 + 19 * v158 + 1) + 8 * v159 - 8);
    uint64_t v161 = (char *)v856;
    uint64_t v162 = HIDWORD(v857);
    if (v856 == v855)
    {
      if (HIDWORD(v857))
      {
        uint64_t v163 = 0;
        uint64_t v164 = 8 * HIDWORD(v857);
        unint64_t v165 = v856;
        while (*v165 != v160)
        {
          if (*v165 == -2) {
            uint64_t v163 = v165;
          }
          ++v165;
          v164 -= 8;
          if (!v164)
          {
            if (!v163) {
              goto LABEL_303;
            }
            void *v163 = v160;
            --v858;
            break;
          }
        }
LABEL_327:
        uint64_t v176 = **((void **)v816 + 19 * v158 + 1);
        int v177 = (char *)v851;
        uint64_t v178 = HIDWORD(v852);
        if (v851 == v850)
        {
          if (HIDWORD(v852))
          {
            uint64_t v179 = 0;
            uint64_t v180 = 8 * HIDWORD(v852);
            int v181 = v851;
            while (*v181 != v176)
            {
              if (*v181 == -2) {
                uint64_t v179 = v181;
              }
              ++v181;
              v180 -= 8;
              if (!v180)
              {
                if (!v179) {
                  goto LABEL_335;
                }
                void *v179 = v176;
                LODWORD(v853) = v853 - 1;
                break;
              }
            }
LABEL_359:
            uint64_t v192 = **((void **)v816 + 19 * v158 + 1);
            uint64_t v193 = (char *)v861;
            uint64_t v194 = HIDWORD(v862);
            if (v861 == v860)
            {
              if (HIDWORD(v862))
              {
                uint64_t v195 = 0;
                uint64_t v196 = 8 * HIDWORD(v862);
                unint64_t v197 = v861;
                while (*v197 != v192)
                {
                  if (*v197 == -2) {
                    uint64_t v195 = v197;
                  }
                  ++v197;
                  v196 -= 8;
                  if (!v196)
                  {
                    if (!v195) {
                      goto LABEL_367;
                    }
                    *uint64_t v195 = v192;
                    --v863;
                    goto LABEL_391;
                  }
                }
                goto LABEL_391;
              }
LABEL_367:
              unsigned int v198 = v862;
              if (HIDWORD(v862) < v862)
              {
                ++HIDWORD(v862);
                *((void *)v861 + v194) = v192;
LABEL_391:
                v865 = (void *)**((void **)v816 + 19 * v158 + 1);
                *((_DWORD *)sub_1CD3CDD24((uint64_t *)&v819, &v865) + 2) = v158;
                int v208 = (char *)v816 + 152 * v158;
                uint64_t v209 = *((unsigned int *)v208 + 4);
                if (v209 == 1) {
                  goto LABEL_293;
                }
                uint64_t v210 = *((void *)v208 + 1);
                uint64_t v211 = (void **)(v210 + 8 * v209);
                long long v212 = (void **)(v210 + 8);
                while (1)
                {
                  v865 = 0;
                  uint64_t v213 = *v212;
                  v865 = *v212;
                  long long v214 = (char *)v861;
                  uint64_t v215 = HIDWORD(v862);
                  if (v861 != v860) {
                    break;
                  }
                  if (HIDWORD(v862))
                  {
                    uint64_t v216 = 0;
                    uint64_t v217 = 8 * HIDWORD(v862);
                    uint64_t v218 = v861;
                    while ((void *)*v218 != v213)
                    {
                      if (*v218 == -2) {
                        uint64_t v216 = v218;
                      }
                      ++v218;
                      v217 -= 8;
                      if (!v217)
                      {
                        if (!v216) {
                          goto LABEL_401;
                        }
                        *uint64_t v216 = v213;
                        --v863;
                        goto LABEL_425;
                      }
                    }
                    goto LABEL_425;
                  }
LABEL_401:
                  unsigned int v219 = v862;
                  if (HIDWORD(v862) >= v862) {
                    goto LABEL_404;
                  }
                  ++HIDWORD(v862);
                  *((void *)v861 + v215) = v213;
LABEL_425:
                  *((_DWORD *)sub_1CD3CDD24((uint64_t *)&v819, &v865) + 2) = v158;
                  if (++v212 == v211) {
                    goto LABEL_293;
                  }
                }
                unsigned int v219 = v862;
LABEL_404:
                if (3 * v219 <= 4 * (HIDWORD(v862) - v863))
                {
                  if (v219 >= 0x40) {
                    v219 *= 2;
                  }
                  else {
                    unsigned int v219 = 128;
                  }
                }
                else if (v219 - HIDWORD(v862) >= v219 >> 3)
                {
                  goto LABEL_406;
                }
                llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v860, v219);
                unsigned int v219 = v862;
                long long v214 = (char *)v861;
LABEL_406:
                unsigned int v220 = v219 - 1;
                unsigned int v221 = (v219 - 1) & ((v213 >> 4) ^ (v213 >> 9));
                uint64_t v222 = &v214[8 * v221];
                uint64_t v223 = *(void **)v222;
                if (*(void *)v222 == -1)
                {
                  uint64_t v224 = 0;
LABEL_418:
                  if (v224) {
                    __int16 v228 = v224;
                  }
                  else {
                    __int16 v228 = (void **)v222;
                  }
                  if (*v228 != v213)
                  {
                    if (*v228 == (void *)-2) {
                      --v863;
                    }
                    else {
                      ++HIDWORD(v862);
                    }
                    unsigned char *v228 = v213;
                  }
                }
                else
                {
                  uint64_t v224 = 0;
                  int v225 = 1;
                  while (v223 != v213)
                  {
                    if (v224) {
                      BOOL v226 = 0;
                    }
                    else {
                      BOOL v226 = v223 == (void *)-2;
                    }
                    if (v226) {
                      uint64_t v224 = (void **)v222;
                    }
                    unsigned int v227 = v221 + v225++;
                    unsigned int v221 = v227 & v220;
                    uint64_t v222 = &v214[8 * (v227 & v220)];
                    uint64_t v223 = *(void **)v222;
                    if (*(void *)v222 == -1) {
                      goto LABEL_418;
                    }
                  }
                }
                goto LABEL_425;
              }
            }
            else
            {
              unsigned int v198 = v862;
            }
            if (3 * v198 <= 4 * (HIDWORD(v862) - v863))
            {
              if (v198 >= 0x40) {
                v198 *= 2;
              }
              else {
                unsigned int v198 = 128;
              }
            }
            else if (v198 - HIDWORD(v862) >= v198 >> 3)
            {
              goto LABEL_372;
            }
            llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v860, v198);
            unsigned int v198 = v862;
            uint64_t v193 = (char *)v861;
LABEL_372:
            unsigned int v199 = v198 - 1;
            unsigned int v200 = (v198 - 1) & ((v192 >> 4) ^ (v192 >> 9));
            unint64_t v201 = &v193[8 * v200];
            uint64_t v202 = *(void *)v201;
            if (*(void *)v201 == -1)
            {
              unsigned int v203 = 0;
LABEL_384:
              if (v203) {
                int v207 = v203;
              }
              else {
                int v207 = v201;
              }
              if (*(void *)v207 != v192)
              {
                if (*(void *)v207 == -2) {
                  --v863;
                }
                else {
                  ++HIDWORD(v862);
                }
                *(void *)int v207 = v192;
              }
            }
            else
            {
              unsigned int v203 = 0;
              int v204 = 1;
              while (v202 != v192)
              {
                if (v203) {
                  BOOL v205 = 0;
                }
                else {
                  BOOL v205 = v202 == -2;
                }
                if (v205) {
                  unsigned int v203 = v201;
                }
                unsigned int v206 = v200 + v204++;
                unsigned int v200 = v206 & v199;
                unint64_t v201 = &v193[8 * (v206 & v199)];
                uint64_t v202 = *(void *)v201;
                if (*(void *)v201 == -1) {
                  goto LABEL_384;
                }
              }
            }
            goto LABEL_391;
          }
LABEL_335:
          unsigned int v182 = v852;
          if (HIDWORD(v852) < v852)
          {
            ++HIDWORD(v852);
            *((void *)v851 + v178) = v176;
            goto LABEL_359;
          }
        }
        else
        {
          unsigned int v182 = v852;
        }
        if (3 * v182 <= 4 * (HIDWORD(v852) - (int)v853))
        {
          if (v182 >= 0x40) {
            v182 *= 2;
          }
          else {
            unsigned int v182 = 128;
          }
        }
        else if (v182 - HIDWORD(v852) >= v182 >> 3)
        {
          goto LABEL_340;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v850, v182);
        unsigned int v182 = v852;
        int v177 = (char *)v851;
LABEL_340:
        unsigned int v183 = v182 - 1;
        unsigned int v184 = (v182 - 1) & ((v176 >> 4) ^ (v176 >> 9));
        int v185 = &v177[8 * v184];
        uint64_t v186 = *(void *)v185;
        if (*(void *)v185 == -1)
        {
          uint64_t v187 = 0;
LABEL_352:
          if (v187) {
            uint64_t v191 = v187;
          }
          else {
            uint64_t v191 = v185;
          }
          if (*(void *)v191 != v176)
          {
            if (*(void *)v191 == -2) {
              LODWORD(v853) = v853 - 1;
            }
            else {
              ++HIDWORD(v852);
            }
            *(void *)uint64_t v191 = v176;
          }
        }
        else
        {
          uint64_t v187 = 0;
          int v188 = 1;
          while (v186 != v176)
          {
            if (v187) {
              BOOL v189 = 0;
            }
            else {
              BOOL v189 = v186 == -2;
            }
            if (v189) {
              uint64_t v187 = v185;
            }
            unsigned int v190 = v184 + v188++;
            unsigned int v184 = v190 & v183;
            int v185 = &v177[8 * (v190 & v183)];
            uint64_t v186 = *(void *)v185;
            if (*(void *)v185 == -1) {
              goto LABEL_352;
            }
          }
        }
        goto LABEL_359;
      }
LABEL_303:
      unsigned int v166 = v857;
      if (HIDWORD(v857) < v857)
      {
        ++HIDWORD(v857);
        *((void *)v856 + v162) = v160;
        goto LABEL_327;
      }
    }
    else
    {
      unsigned int v166 = v857;
    }
    if (3 * v166 <= 4 * (HIDWORD(v857) - v858))
    {
      if (v166 >= 0x40) {
        v166 *= 2;
      }
      else {
        unsigned int v166 = 128;
      }
    }
    else if (v166 - HIDWORD(v857) >= v166 >> 3)
    {
      goto LABEL_308;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v855, v166);
    unsigned int v166 = v857;
    uint64_t v161 = (char *)v856;
LABEL_308:
    unsigned int v167 = v166 - 1;
    unsigned int v168 = (v166 - 1) & ((v160 >> 4) ^ (v160 >> 9));
    uint64_t v169 = &v161[8 * v168];
    uint64_t v170 = *(void *)v169;
    if (*(void *)v169 == -1)
    {
      uint64_t v171 = 0;
LABEL_320:
      if (v171) {
        uint64_t v175 = v171;
      }
      else {
        uint64_t v175 = v169;
      }
      if (*(void *)v175 != v160)
      {
        if (*(void *)v175 == -2) {
          --v858;
        }
        else {
          ++HIDWORD(v857);
        }
        *(void *)uint64_t v175 = v160;
      }
    }
    else
    {
      uint64_t v171 = 0;
      int v172 = 1;
      while (v170 != v160)
      {
        if (v171) {
          BOOL v173 = 0;
        }
        else {
          BOOL v173 = v170 == -2;
        }
        if (v173) {
          uint64_t v171 = v169;
        }
        unsigned int v174 = v168 + v172++;
        unsigned int v168 = v174 & v167;
        uint64_t v169 = &v161[8 * (v174 & v167)];
        uint64_t v170 = *(void *)v169;
        if (*(void *)v169 == -1) {
          goto LABEL_320;
        }
      }
    }
    goto LABEL_327;
  }
  uint64_t v6 = 0;
LABEL_1567:
  if (v825 != v827) {
    free(v825);
  }
  return v6;
}

void sub_1CCDEDC64()
{
}

void sub_1CCDEDCA4(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCDEDCDC(uint64_t a1, llvm *a2)
{
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::TargetLibraryInfoWrapperPass::ID);

  llvm::getLoopAnalysisUsage(a2, v3);
}

uint64_t sub_1CCDEDD20(llvm::LoopPass *a1, const llvm::Loop *a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if ((llvm::LoopPass::skipLoop(a1, a2) & 1) == 0)
  {
    uint64_t v4 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1];
    if (v5 == v6)
    {
LABEL_6:
      uint64_t v7 = 0;
    }
    else
    {
      while (*(char **)v5 != llvm::AAResultsWrapperPass::ID)
      {
        v5 += 16;
        if (v5 == v6) {
          goto LABEL_6;
        }
      }
      uint64_t v7 = *(void *)(v5 + 8);
    }
    (*(void (**)(uint64_t, char *))(*(void *)v7 + 96))(v7, llvm::AAResultsWrapperPass::ID);
    uint64_t v8 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v9 = *v8;
    uint64_t v10 = v8[1];
    if (v9 == v10)
    {
LABEL_11:
      uint64_t v11 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v9 != &llvm::LoopInfoWrapperPass::ID)
      {
        v9 += 16;
        if (v9 == v10) {
          goto LABEL_11;
        }
      }
      uint64_t v11 = *(void *)(v9 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v11 + 96))(v11, &llvm::LoopInfoWrapperPass::ID);
    uint64_t v12 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v13 = *v12;
    uint64_t v14 = v12[1];
    if (v13 == v14)
    {
LABEL_16:
      uint64_t v15 = 0;
    }
    else
    {
      while (*(char **)v13 != llvm::ScalarEvolutionWrapperPass::ID)
      {
        v13 += 16;
        if (v13 == v14) {
          goto LABEL_16;
        }
      }
      uint64_t v15 = *(void *)(v13 + 8);
    }
    (*(void (**)(uint64_t, char *))(*(void *)v15 + 96))(v15, llvm::ScalarEvolutionWrapperPass::ID);
    uint64_t v16 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v17 = *v16;
    uint64_t v18 = v16[1];
    if (v17 == v18)
    {
LABEL_21:
      uint64_t v19 = 0;
    }
    else
    {
      while (*(char **)v17 != llvm::TargetLibraryInfoWrapperPass::ID)
      {
        v17 += 16;
        if (v17 == v18) {
          goto LABEL_21;
        }
      }
      uint64_t v19 = *(void *)(v17 + 8);
    }
    uint64_t v20 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v19 + 96))(v19, llvm::TargetLibraryInfoWrapperPass::ID);
    uint64_t v21 = v20 + 32;
    if (!*(unsigned char *)(v20 + 232))
    {
      uint64_t v23 = *(void *)(*(void *)(**((void **)a2 + 4) + 56) + 40) + 216;
      __int16 v27 = 260;
      v26[0] = v23;
      uint64_t v24 = v20 + 32;
      llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v26);
      uint64_t v37 = 0;
      uint64_t v38 = 0;
      int v39 = 0;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      *(void *)&long long v25 = -1;
      *((void *)&v25 + 1) = -1;
      *(_OWORD *)__src = v25;
      long long v31 = v25;
      long long v32 = v25;
      long long v33 = v25;
      long long v34 = v25;
      long long v35 = v25;
      *(_OWORD *)uint64_t v36 = v25;
      *(void *)&v36[13] = -1;
      sub_1CC153974((uint64_t)__src, (int *)__p);
      sub_1CD4D04B8(v24, (uint64_t)__src);
      sub_1CD4CFA4C((uint64_t *)__src);
      if (v29 < 0) {
        operator delete(__p[0]);
      }
      uint64_t v21 = v24;
    }
    sub_1CC1569E8(__src, v21);
  }
  return 0;
}

BOOL sub_1CCDEE28C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(v1 + 40);
  if (v2 == v1 + 40)
  {
    uint64_t v3 = 0;
  }
  else
  {
    if (v2) {
      uint64_t v3 = v2 - 24;
    }
    else {
      uint64_t v3 = 0;
    }
    if (*(unsigned __int8 *)(v3 + 16) - 29 >= 0xB) {
      uint64_t v3 = 0;
    }
  }
  if (*(unsigned char *)(v3 + 16) != 30) {
    return 0;
  }
  if (*(unsigned __int8 *)(a1 + 16) - 81 > 1) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  if (!v4 || *(void *)(v4 + 8)) {
    return 0;
  }
  int v6 = *(_DWORD *)(v3 + 20);
  if ((v6 & 0x40000000) != 0) {
    uint64_t v7 = *(void **)(v3 - 8);
  }
  else {
    uint64_t v7 = (void *)(v3 - 32 * (v6 & 0x7FFFFFF));
  }
  return *v7 == a1;
}

uint64_t sub_1CCDEE31C(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a1 + 16);
  if (a1 && (v2 >= 0x1C ? (BOOL v3 = v2 - 59 >= 0xFFFFFFEE) : (BOOL v3 = 0), v3))
  {
    if (v2 != 41) {
      return 0;
    }
  }
  else if (v2 != 62)
  {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  if (!v4) {
    return 0;
  }
  do
  {
    uint64_t v5 = *(void *)(v4 + 24);
    if (*(unsigned char *)(v5 + 16) != 83) {
      uint64_t v5 = 0;
    }
    if (v5) {
      BOOL v6 = v5 == a2;
    }
    else {
      BOOL v6 = 0;
    }
    uint64_t result = v6;
    if (v6) {
      break;
    }
    uint64_t v4 = *(void *)(v4 + 8);
  }
  while (v4);
  return result;
}

void sub_1CCDEE384(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a2 + 8);
  if (!v7) {
    goto LABEL_16;
  }
  int v8 = -32;
  do
  {
    int v9 = v8;
    if (!v8) {
      break;
    }
    uint64_t v7 = *(void *)(v7 + 8);
    ++v8;
  }
  while (v7);
  if (v9)
  {
LABEL_16:
    if (*(void *)(a1 + 64) == a2) {
      goto LABEL_17;
    }
    uint64_t v10 = v65;
    int v60 = v65;
    uint64_t v11 = *(const void **)(a3 + 8);
    if (v11 == *(const void **)a3)
    {
      int v61 = v65;
      uint64_t v12 = v11;
    }
    else
    {
      uint64_t v53 = *(unsigned int *)(a3 + 16);
      uint64_t v10 = malloc_type_malloc(8 * v53, 0x4065EBACuLL);
      if (!v10 && (v53 || (uint64_t v10 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
LABEL_93:
      }
        llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
      int v61 = v10;
      uint64_t v12 = *(const void **)a3;
      uint64_t v11 = *(const void **)(a3 + 8);
    }
    unsigned int v14 = *(_DWORD *)(a3 + 16);
    unsigned int v13 = *(_DWORD *)(a3 + 20);
    unsigned int v62 = v14;
    if (v11 == v12) {
      unsigned int v15 = v13;
    }
    else {
      unsigned int v15 = v14;
    }
    if (v15)
    {
      memmove(v10, v11, 8 * v15);
      unsigned int v13 = *(_DWORD *)(a3 + 20);
    }
    int v16 = *(_DWORD *)(a3 + 24);
    unsigned int v63 = v13;
    int v64 = v16;
    char v17 = sub_1CCDEE75C(a1, a2, (uint64_t)&v60, a4);
    if (v61 != v60) {
      free(v61);
    }
    if ((v17 & 1) == 0)
    {
LABEL_17:
      uint64_t v18 = *(void *)(a3 + 8);
      uint64_t v19 = *(unsigned int *)(a3 + 20);
      if (v18 == *(void *)a3)
      {
        if (v19)
        {
          uint64_t v20 = 0;
          uint64_t v21 = 8 * v19;
          uint64_t v22 = *(uint64_t **)(a3 + 8);
          while (*v22 != a2)
          {
            if (*v22 == -2) {
              uint64_t v20 = v22;
            }
            ++v22;
            v21 -= 8;
            if (!v21)
            {
              if (!v20) {
                goto LABEL_25;
              }
              *uint64_t v20 = a2;
              --*(_DWORD *)(a3 + 24);
              goto LABEL_49;
            }
          }
          goto LABEL_49;
        }
LABEL_25:
        unsigned int v23 = *(_DWORD *)(a3 + 16);
        if (v19 < v23)
        {
          *(_DWORD *)(a3 + 20) = v19 + 1;
          *(void *)(v18 + 8 * v19) = a2;
LABEL_49:
          uint64_t v33 = *(void *)(a2 + 8);
          if (v33)
          {
            while (1)
            {
              uint64_t v34 = *(void *)(v33 + 24);
              uint64_t v35 = *(void *)(a1 + 5096);
              uint64_t v36 = *(unsigned int *)(a1 + 5104);
              if (v36)
              {
                uint64_t v37 = 8 * v36;
                uint64_t v38 = *(void **)(a1 + 5096);
                while (*v38 != v34)
                {
                  ++v38;
                  v37 -= 8;
                  if (!v37)
                  {
                    uint64_t v38 = (void *)(v35 + 8 * v36);
                    break;
                  }
                }
              }
              else
              {
                uint64_t v38 = *(void **)(a1 + 5096);
              }
              if (v36 == ((uint64_t)v38 - v35) >> 3)
              {
                unsigned int v39 = *(unsigned __int8 *)(v34 + 16);
                if (v34 && v39 >= 0x1C)
                {
                  unsigned int v41 = v39 - 41;
                  BOOL v42 = v41 > 0x1B;
                  int v43 = (1 << v41) & 0xE207015;
                  if (!v42 && v43 != 0)
                  {
                    uint64_t v54 = v59;
                    char v45 = *(const void **)(a3 + 8);
                    if (v45 == *(const void **)a3)
                    {
                      uint64_t v55 = v59;
                      BOOL v46 = v59;
                      unsigned int v47 = v45;
                    }
                    else
                    {
                      uint64_t v52 = *(unsigned int *)(a3 + 16);
                      BOOL v46 = malloc_type_malloc(8 * v52, 0x4065EBACuLL);
                      if (!v46)
                      {
                        if (v52) {
                          goto LABEL_93;
                        }
                        BOOL v46 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
                        if (!v46) {
                          goto LABEL_93;
                        }
                      }
                      uint64_t v55 = v46;
                      unsigned int v47 = *(const void **)a3;
                      char v45 = *(const void **)(a3 + 8);
                    }
                    unsigned int v49 = *(_DWORD *)(a3 + 16);
                    unsigned int v48 = *(_DWORD *)(a3 + 20);
                    unsigned int v56 = v49;
                    if (v45 == v47) {
                      unsigned int v50 = v48;
                    }
                    else {
                      unsigned int v50 = v49;
                    }
                    if (v50)
                    {
                      memmove(v46, v45, 8 * v50);
                      unsigned int v48 = *(_DWORD *)(a3 + 20);
                    }
                    int v51 = *(_DWORD *)(a3 + 24);
                    unsigned int v57 = v48;
                    int v58 = v51;
                    sub_1CCDEE384(a1, v34, &v54);
                    if (v55 != v54) {
                      free(v55);
                    }
                  }
                }
              }
              uint64_t v33 = *(void *)(v33 + 8);
              if (!v33) {
                return;
              }
            }
          }
          return;
        }
      }
      else
      {
        unsigned int v23 = *(_DWORD *)(a3 + 16);
      }
      if (3 * v23 <= 4 * ((int)v19 - *(_DWORD *)(a3 + 24)))
      {
        if (v23 >= 0x40) {
          v23 *= 2;
        }
        else {
          unsigned int v23 = 128;
        }
      }
      else if (v23 - v19 >= v23 >> 3)
      {
        goto LABEL_30;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a3, v23);
      unsigned int v23 = *(_DWORD *)(a3 + 16);
      uint64_t v18 = *(void *)(a3 + 8);
LABEL_30:
      unsigned int v24 = v23 - 1;
      unsigned int v25 = (v23 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      uint64_t v26 = (uint64_t *)(v18 + 8 * v25);
      uint64_t v27 = *v26;
      if (*v26 == -1)
      {
        int v28 = 0;
LABEL_42:
        if (v28) {
          long long v32 = v28;
        }
        else {
          long long v32 = v26;
        }
        if (*v32 != a2)
        {
          if (*v32 == -2) {
            --*(_DWORD *)(a3 + 24);
          }
          else {
            ++*(_DWORD *)(a3 + 20);
          }
          uint64_t *v32 = a2;
        }
      }
      else
      {
        int v28 = 0;
        int v29 = 1;
        while (v27 != a2)
        {
          if (v28) {
            BOOL v30 = 0;
          }
          else {
            BOOL v30 = v27 == -2;
          }
          if (v30) {
            int v28 = v26;
          }
          unsigned int v31 = v25 + v29++;
          unsigned int v25 = v31 & v24;
          uint64_t v26 = (uint64_t *)(v18 + 8 * (v31 & v24));
          uint64_t v27 = *v26;
          if (*v26 == -1) {
            goto LABEL_42;
          }
        }
      }
      goto LABEL_49;
    }
  }
}

uint64_t sub_1CCDEE75C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = MEMORY[0x1F4188790](a1, a2, a3, a4);
  uint64_t v7 = v6;
  int v8 = (uint64_t *)v5;
  uint64_t v9 = v4;
  v120[16] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)(v4 + 16);
  uint64_t v11 = *(void *)(v10 + 104);
  unsigned int v12 = *(_DWORD *)(v10 + 120);
  if (v12)
  {
    unsigned int v13 = (v12 - 1) & ((v5 >> 4) ^ (v5 >> 9));
    uint64_t v14 = v11 + 48 * v13;
    uint64_t v15 = *(void *)(v14 + 24);
    if (v15 == v5) {
      goto LABEL_8;
    }
    int v16 = 1;
    while (v15 != -4096)
    {
      unsigned int v17 = v13 + v16++;
      unsigned int v13 = v17 & (v12 - 1);
      uint64_t v14 = v11 + 48 * v13;
      uint64_t v15 = *(void *)(v14 + 24);
      if (v15 == v5) {
        goto LABEL_8;
      }
    }
  }
  uint64_t v14 = v11 + 48 * v12;
LABEL_8:
  if (v14 == v11 + 48 * v12 || (uint64_t SCEVIter = *(void *)(v14 + 40)) == 0) {
    uint64_t SCEVIter = llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)v10, v5);
  }
  if (SCEVIter) {
    BOOL v19 = *(unsigned __int16 *)(SCEVIter + 24) == 7;
  }
  else {
    BOOL v19 = 0;
  }
  if (!v19 || *(void *)(SCEVIter + 48) != *(void *)(v9 + 8)) {
    return 0;
  }
  uint64_t v107 = 0;
  uint64_t v108 = 0;
  unint64_t v106 = (uint64_t *)&v107;
  uint64_t v109 = v111;
  uint64_t v110 = 0x1000000000;
  uint64_t v22 = v8[1];
  if (!v22) {
    goto LABEL_20;
  }
  do
  {
    uint64_t v36 = *(void *)(v22 + 24);
    if (sub_1CCDEE31C(v36, *(void *)(v9 + 64)))
    {
      unint64_t v37 = *(unsigned int *)(v9 + 5104);
      if (v37 >= *(unsigned int *)(v9 + 5108)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v9 + 5096) + 8 * v37) = v36;
      ++*(_DWORD *)(v9 + 5104);
      goto LABEL_82;
    }
    unsigned int v38 = *(unsigned __int8 *)(v36 + 16);
    if (v36) {
      BOOL v39 = v38 >= 0x1C;
    }
    else {
      BOOL v39 = 0;
    }
    if (v39 && v38 - 59 >= 0xFFFFFFEE)
    {
      if ((v38 | 0x10) != 0x39) {
        goto LABEL_64;
      }
      uint64_t v41 = *(void *)(v36 - 32);
    }
    else
    {
      if (!v36 || v38 != 62) {
        goto LABEL_64;
      }
      uint64_t v41 = *(void *)(v36
                      - 32 * (*(_DWORD *)(v36 + 20) & 0x7FFFFFF)
                      + 32 * ((*(_DWORD *)(v36 + 20) & 0x7FFFFFFu) - 1));
    }
    if (*(unsigned char *)(v41 + 16) == 16)
    {
      unsigned int v42 = *(_DWORD *)(v41 + 32);
      if (v42 > 0x40) {
        uint64_t v43 = **(void **)(v41 + 24);
      }
      else {
        uint64_t v43 = (uint64_t)(*(void *)(v41 + 24) << -(char)v42) >> -(char)v42;
      }
      if (v43 >= 0) {
        uint64_t v44 = v43;
      }
      else {
        uint64_t v44 = -v43;
      }
      uint64_t v112 = (uint64_t *)v44;
      char v45 = v107;
      if (v107)
      {
        BOOL v46 = &v107;
        do
        {
          unsigned int v47 = v46;
          unsigned int v48 = v45;
          uint64_t v49 = v45[4];
          unsigned int v50 = v45 + 1;
          if (v49 >= v44)
          {
            unsigned int v50 = v48;
            BOOL v46 = v48;
          }
          char v45 = (void *)*v50;
        }
        while (v45);
        if (v46 != &v107)
        {
          if (v49 >= v44) {
            unsigned int v47 = v48;
          }
          if (v44 >= v47[4]) {
            goto LABEL_20;
          }
        }
      }
      sub_1CD65A160(&v106, v44, &v112)[5] = (uint64_t *)v36;
      goto LABEL_82;
    }
LABEL_64:
    int v23 = 0;
    if (!v36 || v38 < 0x1C) {
      goto LABEL_21;
    }
    if (v110 >= (unint64_t)HIDWORD(v110)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v109 + v110) = v36;
    LODWORD(v110) = v110 + 1;
LABEL_82:
    uint64_t v22 = *(void *)(v22 + 8);
  }
  while (v22);
  if (!v108) {
    goto LABEL_20;
  }
  if (v108 == 1)
  {
    if (!v110) {
      goto LABEL_20;
    }
LABEL_181:
    uint64_t v94 = v107;
    if (v107)
    {
      int v95 = &v107;
      do
      {
        uint64_t v96 = v95;
        long long v97 = v94;
        uint64_t v98 = v94[4];
        unint64_t v99 = v94 + 1;
        if (v98 >= 0)
        {
          unint64_t v99 = v97;
          int v95 = v97;
        }
        uint64_t v94 = (void *)*v99;
      }
      while (v94);
      if (v95 != &v107)
      {
        if (v98 >= 0) {
          uint64_t v96 = v97;
        }
        if ((uint64_t)v96[4] < 1) {
          goto LABEL_20;
        }
      }
    }
    uint64_t v112 = 0;
    sub_1CD65A160(&v106, 0, &v112)[5] = v8;
    int v100 = v110;
    char v93 = v106;
    if (!v110) {
      goto LABEL_191;
    }
  }
  else
  {
    if (v110) {
      goto LABEL_181;
    }
    char v93 = v106;
LABEL_191:
    uint64_t v101 = *(void *)(v93[5] + 8);
    if (v101)
    {
      int v100 = 0;
      do
      {
        ++v100;
        uint64_t v101 = *(void *)(v101 + 8);
      }
      while (v101);
    }
    else
    {
      int v100 = 0;
    }
  }
  int v23 = 1;
  if (v93 == (uint64_t *)&v107) {
    goto LABEL_21;
  }
  while (2)
  {
    if (!v93[4])
    {
LABEL_201:
      int v104 = (uint64_t *)v93[1];
      if (v104)
      {
        do
        {
          unint64_t v105 = v104;
          int v104 = (uint64_t *)*v104;
        }
        while (v104);
      }
      else
      {
        do
        {
          unint64_t v105 = (uint64_t *)v93[2];
          BOOL v19 = *v105 == (void)v93;
          char v93 = v105;
        }
        while (!v19);
      }
      char v93 = v105;
      if (v105 == (uint64_t *)&v107) {
        goto LABEL_21;
      }
      continue;
    }
    break;
  }
  uint64_t v102 = *(void *)(v93[5] + 8);
  if (!v100)
  {
LABEL_200:
    if (v102) {
      goto LABEL_20;
    }
    goto LABEL_201;
  }
  int v103 = v100;
  while (v102)
  {
    uint64_t v102 = *(void *)(v102 + 8);
    if (!--v103) {
      goto LABEL_200;
    }
  }
LABEL_20:
  int v23 = 0;
LABEL_21:
  if (v109 != v111) {
    free(v109);
  }
  unsigned int v24 = v107;
  if (!v23)
  {
    uint64_t v20 = 0;
    goto LABEL_178;
  }
  if (v107)
  {
    unsigned int v25 = &v107;
    do
    {
      uint64_t v26 = v25;
      uint64_t v27 = v24;
      uint64_t v28 = v24[4];
      if (v28 >= 0) {
        int v29 = (void **)v24;
      }
      else {
        int v29 = (void **)(v24 + 1);
      }
      if (v28 >= 0) {
        unsigned int v25 = v24;
      }
      unsigned int v24 = *v29;
    }
    while (*v29);
    if (v25 != &v107)
    {
      if (v28 >= 0) {
        uint64_t v26 = v27;
      }
      if ((uint64_t)v26[4] < 1) {
        goto LABEL_113;
      }
    }
  }
  uint64_t v30 = *(void *)(v7 + 8);
  uint64_t v31 = *(unsigned int *)(v7 + 20);
  if (v30 != *(void *)v7)
  {
    unsigned int v35 = *(_DWORD *)(v7 + 16);
    goto LABEL_88;
  }
  if (!v31)
  {
LABEL_44:
    unsigned int v35 = *(_DWORD *)(v7 + 16);
    if (v31 < v35)
    {
      *(_DWORD *)(v7 + 20) = v31 + 1;
      *(void *)(v30 + 8 * v31) = v8;
      goto LABEL_113;
    }
LABEL_88:
    if (3 * v35 <= 4 * ((int)v31 - *(_DWORD *)(v7 + 24)))
    {
      if (v35 >= 0x40) {
        v35 *= 2;
      }
      else {
        unsigned int v35 = 128;
      }
    }
    else if (v35 - v31 >= v35 >> 3)
    {
      goto LABEL_90;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v7, v35);
    unsigned int v35 = *(_DWORD *)(v7 + 16);
    uint64_t v30 = *(void *)(v7 + 8);
LABEL_90:
    unsigned int v51 = v35 - 1;
    unsigned int v52 = (v35 - 1) & ((v8 >> 4) ^ (v8 >> 9));
    uint64_t v53 = (uint64_t **)(v30 + 8 * v52);
    uint64_t v54 = *v53;
    if (*v53 == (uint64_t *)-1)
    {
      uint64_t v55 = 0;
LABEL_106:
      if (v55) {
        uint64_t v59 = v55;
      }
      else {
        uint64_t v59 = v53;
      }
      if (*v59 != v8)
      {
        if (*v59 == (uint64_t *)-2) {
          --*(_DWORD *)(v7 + 24);
        }
        else {
          ++*(_DWORD *)(v7 + 20);
        }
        *uint64_t v59 = v8;
      }
    }
    else
    {
      uint64_t v55 = 0;
      int v56 = 1;
      while (v54 != v8)
      {
        if (v55) {
          BOOL v57 = 0;
        }
        else {
          BOOL v57 = v54 == (uint64_t *)-2;
        }
        if (v57) {
          uint64_t v55 = v53;
        }
        unsigned int v58 = v52 + v56++;
        unsigned int v52 = v58 & v51;
        uint64_t v53 = (uint64_t **)(v30 + 8 * (v58 & v51));
        uint64_t v54 = *v53;
        if (*v53 == (uint64_t *)-1) {
          goto LABEL_106;
        }
      }
    }
    goto LABEL_113;
  }
  long long v32 = 0;
  uint64_t v33 = 8 * v31;
  uint64_t v34 = *(uint64_t ***)(v7 + 8);
  while (*v34 != v8)
  {
    if (*v34 == (uint64_t *)-2) {
      long long v32 = v34;
    }
    ++v34;
    v33 -= 8;
    if (!v33)
    {
      if (!v32) {
        goto LABEL_44;
      }
      uint64_t *v32 = v8;
      --*(_DWORD *)(v7 + 24);
      break;
    }
  }
LABEL_113:
  uint64_t v114 = 0x1000000000;
  uint64_t v116 = v120;
  unsigned int v117 = v120;
  uint64_t v118 = 16;
  int v119 = 0;
  uint64_t v113 = v115;
  uint64_t v112 = 0;
  uint64_t v109 = v111;
  uint64_t v110 = 0x1000000000;
  int v60 = v106;
  if (v106 != (uint64_t *)&v107)
  {
    do
    {
      if (v112)
      {
        uint64_t v80 = v114;
        if (v114)
        {
          uint64_t v81 = v107;
          if (!v107) {
            goto LABEL_156;
          }
          uint64_t v82 = v60[4];
          uint64_t v83 = v82 - 1;
          uint64_t v84 = &v107;
          do
          {
            int v85 = v84;
            unsigned int v86 = v81;
            uint64_t v87 = v81[4];
            uint64_t v88 = v81 + 1;
            if (v87 >= v83)
            {
              uint64_t v88 = v86;
              uint64_t v84 = v86;
            }
            uint64_t v81 = (void *)*v88;
          }
          while (v81);
          if (v84 == &v107 || (v87 >= v83 ? (int v89 = v86) : (int v89 = v85), v82 <= v89[4]))
          {
LABEL_156:
            if (!sub_1CCDEF148(v9, (uint64_t)&v112)) {
              goto LABEL_169;
            }
            sub_1CCDEF80C((uint64_t)&v109, (unint64_t)&v112);
            uint64_t v112 = (uint64_t *)v60[5];
            LODWORD(v114) = 0;
            goto LABEL_161;
          }
          uint64_t v90 = v60[5];
          if (v114 >= (unint64_t)HIDWORD(v114)) {
            goto LABEL_168;
          }
        }
        else
        {
          uint64_t v90 = v60[5];
          if (!HIDWORD(v114)) {
LABEL_168:
          }
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          uint64_t v80 = 0;
        }
        *((void *)v113 + v80) = v90;
        LODWORD(v114) = v114 + 1;
      }
      else
      {
        uint64_t v112 = (uint64_t *)v60[5];
        if (&v116 != (void **)v7) {
          llvm::SmallPtrSetImplBase::CopyFrom((llvm::SmallPtrSetImplBase *)&v116, (const llvm::SmallPtrSetImplBase *)v7);
        }
      }
LABEL_161:
      unsigned int v91 = (uint64_t *)v60[1];
      if (v91)
      {
        do
        {
          uint64_t v92 = v91;
          unsigned int v91 = (uint64_t *)*v91;
        }
        while (v91);
      }
      else
      {
        do
        {
          uint64_t v92 = (uint64_t *)v60[2];
          BOOL v19 = *v92 == (void)v60;
          int v60 = v92;
        }
        while (!v19);
      }
      int v60 = v92;
    }
    while (v92 != (uint64_t *)&v107);
  }
  if (sub_1CCDEF148(v9, (uint64_t)&v112))
  {
    sub_1CCDEF80C((uint64_t)&v109, (unint64_t)&v112);
    int v61 = (char *)v109;
    unsigned int v62 = v110;
    uint64_t v63 = *(unsigned int *)(v9 + 96);
    unint64_t v64 = v63 + v110;
    if (v64 > *(unsigned int *)(v9 + 100))
    {
      sub_1CCDEF9C4(v9 + 88, v64);
      LODWORD(v63) = *(_DWORD *)(v9 + 96);
    }
    if (v62)
    {
      uint64_t v65 = 0;
      uint64_t v66 = *(void *)(v9 + 88) + 312 * v63;
      do
      {
        BOOL v67 = (const void **)&v61[v65];
        uint64_t v68 = (const void **)(v66 + v65);
        *uint64_t v68 = *(const void **)&v61[v65];
        uint64_t v69 = (void *)(v66 + v65 + 24);
        *(void *)(v66 + v65 + 8) = v69;
        v68[2] = (const void *)0x1000000000;
        unsigned int v70 = *(_DWORD *)&v61[v65 + 16];
        if (v70) {
          BOOL v71 = v67 == v68;
        }
        else {
          BOOL v71 = 1;
        }
        if (!v71)
        {
          if (v70 >= 0x11) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy(v69, v67[1], 8 * *(unsigned int *)&v61[v65 + 16]);
          *((_DWORD *)v68 + 4) = v70;
        }
        unsigned int v72 = v68 + 23;
        v68[19] = v68 + 23;
        unsigned int v73 = v67[20];
        if (v73 == v67[19])
        {
          *(void *)(v66 + v65 + 160) = v72;
        }
        else
        {
          uint64_t v79 = *(unsigned int *)&v61[v65 + 168];
          unsigned int v72 = malloc_type_malloc(8 * v79, 0x4065EBACuLL);
          if (!v72 && (v79 || (unsigned int v72 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
            llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
          }
          *(void *)(v66 + v65 + 160) = v72;
          unsigned int v73 = v67[19];
        }
        uint64_t v74 = &v61[v65];
        uint64_t v75 = v66 + v65;
        *(_DWORD *)(v66 + v65 + 168) = *(_DWORD *)&v61[v65 + 168];
        uint64_t v76 = v67[20];
        int v77 = *(_DWORD *)&v61[v65 + 172];
        if (v76 == v73) {
          unsigned int v78 = *(_DWORD *)&v61[v65 + 172];
        }
        else {
          unsigned int v78 = *(_DWORD *)&v61[v65 + 168];
        }
        if (v78)
        {
          memmove(v72, v76, 8 * v78);
          int v77 = *((_DWORD *)v74 + 43);
        }
        *(_DWORD *)(v75 + 172) = v77;
        *(_DWORD *)(v75 + 176) = *((_DWORD *)v74 + 44);
        v65 += 312;
      }
      while (312 * v62 != v65);
      LODWORD(v63) = *(_DWORD *)(v9 + 96);
    }
    *(_DWORD *)(v9 + 96) = v63 + v62;
    uint64_t v20 = 1;
  }
  else
  {
LABEL_169:
    uint64_t v20 = 0;
  }
  sub_1CCDEFBF8((void **)v109, (void **)v109 + 39 * v110);
  if (v109 != v111) {
    free(v109);
  }
  if (v117 != v116) {
    free(v117);
  }
  if (v113 != v115) {
    free(v113);
  }
  unsigned int v24 = v107;
LABEL_178:
  sub_1CD40B1BC(v24);
  return v20;
}

llvm::ScalarEvolution *sub_1CCDEF148(uint64_t a1, uint64_t a2)
{
  v94[3] = *MEMORY[0x1E4F143B8];
  if (!*(_DWORD *)(a2 + 16)) {
    return 0;
  }
  unint64_t v4 = *(void *)a2;
  uint64_t v5 = *(void *)(v4 + 8);
  if (!v5)
  {
LABEL_37:
    uint64_t v27 = *(void *)(a1 + 16);
    uint64_t v28 = *(void *)(v27 + 104);
    unsigned int v29 = *(_DWORD *)(v27 + 120);
    if (v29)
    {
      unsigned int v30 = (v29 - 1) & ((v4 >> 4) ^ (v4 >> 9));
      uint64_t v31 = v28 + 48 * v30;
      uint64_t v32 = *(void *)(v31 + 24);
      if (v32 == v4)
      {
LABEL_44:
        if (v31 == v28 + 48 * v29 || (uint64_t SCEVIter = *(void *)(v31 + 40)) == 0) {
          uint64_t SCEVIter = llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)v27, v4);
        }
        if (SCEVIter) {
          BOOL v36 = *(unsigned __int16 *)(SCEVIter + 24) == 7;
        }
        else {
          BOOL v36 = 0;
        }
        if (!v36) {
          return 0;
        }
        uint64_t v38 = *(void *)(a1 + 16);
        unint64_t v39 = **(void **)(a2 + 8);
        uint64_t v40 = *(void *)(v38 + 104);
        unsigned int v41 = *(_DWORD *)(v38 + 120);
        if (v41)
        {
          unsigned int v42 = v41 - 1;
          unsigned int v43 = ((v39 >> 4) ^ (v39 >> 9)) & (v41 - 1);
          uint64_t v44 = v40 + 48 * v43;
          uint64_t v45 = *(void *)(v44 + 24);
          if (v45 == v39) {
            goto LABEL_59;
          }
          int v46 = 1;
          while (v45 != -4096)
          {
            unsigned int v47 = v43 + v46++;
            unsigned int v43 = v47 & v42;
            uint64_t v44 = v40 + 48 * (v47 & v42);
            uint64_t v45 = *(void *)(v44 + 24);
            if (v45 == v39) {
              goto LABEL_59;
            }
          }
        }
        uint64_t v44 = v40 + 48 * v41;
LABEL_59:
        uint64_t v48 = *(unsigned int *)(a2 + 16);
        if (v44 == v40 + 48 * v41 || (uint64_t v49 = *(llvm::SCEV **)(v44 + 40)) == 0) {
          uint64_t v49 = (llvm::SCEV *)llvm::ScalarEvolution::createSCEVIter(*(llvm::ScalarEvolution **)(a1 + 16), v39);
        }
        unint64_t MinusSCEV = llvm::ScalarEvolution::getMinusSCEV((llvm::ScalarEvolution *)v38, v49, (const llvm::APInt *)SCEVIter, 0, 0);
        int v51 = *(unsigned __int16 *)(MinusSCEV + 24);
        unint64_t v52 = MinusSCEV;
        while (2)
        {
          switch(*(_WORD *)(MinusSCEV + 24))
          {
            case 1:
            case 2:
            case 3:
            case 0xD:
              unint64_t v54 = v52 + 40;
              goto LABEL_70;
            case 4:
              unint64_t v54 = v52 + 48;
              goto LABEL_70;
            case 5:
            case 7:
            case 8:
            case 9:
            case 0xA:
            case 0xB:
            case 0xC:
              uint64_t v53 = *(unint64_t **)(v52 + 32);
              goto LABEL_65;
            case 6:
              uint64_t v53 = (unint64_t *)(v52 + 40);
LABEL_65:
              unint64_t v52 = *v53;
              continue;
            case 0xE:
              unint64_t v54 = *(void *)(v52 - 8);
              goto LABEL_70;
            default:
              unint64_t v54 = *(void *)(v52 + 32);
LABEL_70:
              if (*(unsigned char *)(*(void *)v54 + 8) == 15) {
                return 0;
              }
              uint64_t result = *(llvm::ScalarEvolution **)(a1 + 16);
              unint64_t v55 = MinusSCEV;
              while (2)
              {
                switch(v51)
                {
                  case 0:
                    BOOL v57 = *(llvm::Type ***)(v55 + 32);
                    goto LABEL_79;
                  case 1:
                  case 2:
                  case 3:
                  case 13:
                    BOOL v57 = (llvm::Type **)(v55 + 40);
                    goto LABEL_79;
                  case 4:
                    BOOL v57 = (llvm::Type **)(v55 + 48);
                    goto LABEL_79;
                  case 5:
                  case 7:
                  case 8:
                  case 9:
                  case 10:
                  case 11:
                  case 12:
                    int v56 = *(unint64_t **)(v55 + 32);
                    goto LABEL_74;
                  case 6:
                    int v56 = (unint64_t *)(v55 + 40);
LABEL_74:
                    unint64_t v55 = *v56;
                    int v51 = *(unsigned __int16 *)(*v56 + 24);
                    continue;
                  case 14:
                    BOOL v57 = *(llvm::Type ***)(v55 - 8);
LABEL_79:
                    unint64_t Constant = llvm::ScalarEvolution::getConstant(result, *v57, (v48 + 1), 0);
                    uint64_t v59 = *(void *)(a1 + 16);
                    uint64_t v60 = *(void *)(SCEVIter + 40);
                    if (v60 == 2)
                    {
                      uint64_t v61 = *(void *)(*(void *)(SCEVIter + 32) + 8);
                    }
                    else
                    {
                      unsigned int v91 = *(llvm::ScalarEvolution **)(a1 + 16);
                      uint64_t v87 = *(void *)(SCEVIter + 32);
                      uint64_t v92 = v94;
                      uint64_t v93 = 0x300000000;
                      uint64_t v88 = v60;
                      size_t v89 = 8 * v60 - 8;
                      if (v89 >= 0x19) {
                        llvm::SmallVectorBase<unsigned int>::grow_pod();
                      }
                      int v90 = 0;
                      if (v88 != 1)
                      {
                        memcpy(v92, (const void *)(v87 + 8), v89);
                        int v90 = v93;
                      }
                      LODWORD(v93) = v90 + (v89 >> 3);
                      uint64_t v61 = sub_1CD478318(v91, (uint64_t)&v92, *(const llvm::Loop **)(SCEVIter + 48), 0);
                      if (v92 != v94) {
                        free(v92);
                      }
                      uint64_t v59 = *(void *)(a1 + 16);
                    }
                    uint64_t v92 = v94;
                    v94[0] = MinusSCEV;
                    v94[1] = Constant;
                    uint64_t v93 = 0x200000002;
                    uint64_t MulExpr = llvm::ScalarEvolution::getMulExpr(v59, (uint64_t)&v92, 0, 0);
                    if (v92 != v94) {
                      free(v92);
                    }
                    if (v61 != MulExpr) {
                      return 0;
                    }
                    if (v48 < 2) {
                      return (llvm::ScalarEvolution *)1;
                    }
                    uint64_t v63 = 1;
                    break;
                  default:
                    return result;
                }
                break;
              }
              break;
          }
          break;
        }
        while (1)
        {
          uint64_t v64 = *(void *)(a1 + 16);
          uint64_t v65 = *(void *)(a2 + 8);
          unint64_t v66 = *(void *)(v65 + 8 * v63);
          uint64_t v67 = *(void *)(v64 + 104);
          unsigned int v68 = *(_DWORD *)(v64 + 120);
          if (!v68) {
            goto LABEL_92;
          }
          unsigned int v69 = v68 - 1;
          unsigned int v70 = ((v66 >> 4) ^ (v66 >> 9)) & (v68 - 1);
          uint64_t v71 = v67 + 48 * v70;
          uint64_t v72 = *(void *)(v71 + 24);
          if (v72 != v66) {
            break;
          }
LABEL_93:
          if (v71 == v67 + 48 * v68 || (uint64_t v75 = *(llvm::SCEV **)(v71 + 40)) == 0)
          {
            uint64_t v75 = (llvm::SCEV *)llvm::ScalarEvolution::createSCEVIter(*(llvm::ScalarEvolution **)(a1 + 16), v66);
            uint64_t v76 = *(void *)(a1 + 16);
            uint64_t v65 = *(void *)(a2 + 8);
            uint64_t v67 = *(void *)(v76 + 104);
            unsigned int v68 = *(_DWORD *)(v76 + 120);
          }
          else
          {
            uint64_t v76 = *(void *)(a1 + 16);
          }
          unint64_t v77 = *(void *)(v65 + 8 * v63 - 8);
          uint64_t v78 = v67 + 48 * v68;
          if (v68)
          {
            unsigned int v79 = v68 - 1;
            unsigned int v80 = ((v77 >> 4) ^ (v77 >> 9)) & v79;
            uint64_t v81 = v67 + 48 * v80;
            uint64_t v82 = *(void *)(v81 + 24);
            if (v82 == v77) {
              goto LABEL_104;
            }
            int v83 = 1;
            while (v82 != -4096)
            {
              unsigned int v84 = v80 + v83++;
              unsigned int v80 = v84 & v79;
              uint64_t v81 = v67 + 48 * v80;
              uint64_t v82 = *(void *)(v81 + 24);
              if (v82 == v77) {
                goto LABEL_104;
              }
            }
          }
          uint64_t v81 = v78;
LABEL_104:
          if (v81 == v78 || (int v85 = *(const llvm::APInt **)(v81 + 40)) == 0) {
            int v85 = (const llvm::APInt *)llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)v76, v77);
          }
          BOOL v24 = llvm::ScalarEvolution::getMinusSCEV((llvm::ScalarEvolution *)v64, v75, v85, 0, 0) == MinusSCEV;
          uint64_t result = (llvm::ScalarEvolution *)v24;
          ++v63;
          if (!v24 || v63 == v48) {
            return result;
          }
        }
        int v73 = 1;
        while (v72 != -4096)
        {
          unsigned int v74 = v70 + v73++;
          unsigned int v70 = v74 & v69;
          uint64_t v71 = v67 + 48 * (v74 & v69);
          uint64_t v72 = *(void *)(v71 + 24);
          if (v72 == v66) {
            goto LABEL_93;
          }
        }
LABEL_92:
        uint64_t v71 = v67 + 48 * v68;
        goto LABEL_93;
      }
      int v33 = 1;
      while (v32 != -4096)
      {
        unsigned int v34 = v30 + v33++;
        unsigned int v30 = v34 & (v29 - 1);
        uint64_t v31 = v28 + 48 * v30;
        uint64_t v32 = *(void *)(v31 + 24);
        if (v32 == v4) {
          goto LABEL_44;
        }
      }
    }
    uint64_t v31 = v28 + 48 * v29;
    goto LABEL_44;
  }
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = (unsigned int *)(v6 + 76);
  int v8 = (unsigned int *)(v6 + 72);
  uint64_t v11 = v6 + 56;
  uint64_t v10 = *(void *)(v6 + 56);
  uint64_t v9 = *(void *)(v11 + 8);
  if (v9 == v10) {
    unsigned int v12 = v7;
  }
  else {
    unsigned int v12 = v8;
  }
  uint64_t v13 = v9;
  while (1)
  {
    uint64_t v14 = *(void *)(*(void *)(v5 + 24) + 40);
    if (v13 == v10)
    {
      uint64_t v15 = *v7;
      int v16 = (void *)(v10 + 8 * v15);
      if (v15)
      {
        uint64_t v17 = 0;
        uint64_t v18 = 8 * v15;
        while (*(void *)(v10 + v17) != v14)
        {
          v17 += 8;
          if (v18 == v17) {
            goto LABEL_25;
          }
        }
        int v16 = (void *)(v10 + v17);
      }
LABEL_25:
      uint64_t v13 = v10;
    }
    else
    {
      int v19 = *v8 - 1;
      unsigned int v20 = v19 & ((v14 >> 4) ^ (v14 >> 9));
      int v16 = (void *)(v9 + 8 * v20);
      uint64_t v21 = *v16;
      if (*v16 == -1)
      {
        uint64_t v22 = 0;
LABEL_27:
        if (v22) {
          int v16 = v22;
        }
        if (*v16 != v14) {
          int v16 = (void *)(v9 + 8 * *v12);
        }
      }
      else
      {
        uint64_t v22 = 0;
        int v23 = 1;
        while (v21 != v14)
        {
          if (v22) {
            BOOL v24 = 0;
          }
          else {
            BOOL v24 = v21 == -2;
          }
          if (v24) {
            uint64_t v22 = v16;
          }
          unsigned int v25 = v20 + v23++;
          unsigned int v20 = v25 & v19;
          int v16 = (void *)(v9 + 8 * (v25 & v19));
          uint64_t v21 = *v16;
          if (*v16 == -1) {
            goto LABEL_27;
          }
        }
      }
      uint64_t v13 = v9;
    }
    uint64_t v26 = v13 == v10 ? v7 : v8;
    if (v16 == (void *)(v13 + 8 * *v26)) {
      return 0;
    }
    uint64_t v5 = *(void *)(v5 + 8);
    if (!v5) {
      goto LABEL_37;
    }
  }
}

void *sub_1CCDEF80C(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  unint64_t v5 = *(void *)a1;
  if (v4 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v21 = v4 + 1;
    unint64_t v22 = v5 + 312 * v4;
    if (v5 <= a2 && v22 > a2)
    {
      unint64_t v24 = a2 - v5;
      sub_1CCDEF9C4(a1, v21);
      unint64_t v5 = *(void *)a1;
      a2 = *(void *)a1 + v24;
    }
    else
    {
      sub_1CCDEF9C4(a1, v21);
      unint64_t v5 = *(void *)a1;
    }
  }
  unsigned int v6 = *(_DWORD *)(a1 + 8);
  uint64_t v7 = (void *)(v5 + 312 * v6);
  *uint64_t v7 = *(void *)a2;
  int v8 = v7 + 3;
  *(void *)(v5 + 312 * v6 + 8) = v8;
  unint64_t v9 = v5 + 312 * v6;
  *(void *)(v9 + 16) = 0x1000000000;
  uint64_t v10 = (unsigned int *)(v9 + 16);
  unsigned int v11 = *(_DWORD *)(a2 + 16);
  if (v11 && v5 + 312 * v6 != a2)
  {
    if (v11 >= 0x11) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy(v8, *(const void **)(a2 + 8), 8 * *(unsigned int *)(a2 + 16));
    *uint64_t v10 = v11;
  }
  unint64_t v12 = v5 + 312 * v6;
  uint64_t result = (void *)(v12 + 184);
  *(void *)(v12 + 152) = v12 + 184;
  unint64_t v14 = v12 + 152;
  uint64_t v15 = *(const void **)(a2 + 160);
  if (v15 == *(const void **)(a2 + 152))
  {
    *(void *)(v14 + 8) = result;
  }
  else
  {
    uint64_t v20 = *(unsigned int *)(a2 + 168);
    uint64_t result = malloc_type_malloc(8 * v20, 0x4065EBACuLL);
    if (!result && (v20 || (uint64_t result = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    *(void *)(v14 + 8) = result;
    uint64_t v15 = *(const void **)(a2 + 152);
  }
  *(_DWORD *)(v14 + 16) = *(_DWORD *)(a2 + 168);
  int v16 = *(const void **)(a2 + 160);
  int v17 = *(_DWORD *)(a2 + 172);
  if (v16 == v15) {
    unsigned int v18 = *(_DWORD *)(a2 + 172);
  }
  else {
    unsigned int v18 = *(_DWORD *)(a2 + 168);
  }
  if (v18)
  {
    uint64_t result = memmove(result, v16, 8 * v18);
    int v17 = *(_DWORD *)(a2 + 172);
  }
  int v19 = *(_DWORD *)(a2 + 176);
  *(_DWORD *)(v14 + 20) = v17;
  *(_DWORD *)(v14 + 24) = v19;
  ++*(_DWORD *)(a1 + 8);
  return result;
}

void sub_1CCDEF9C4(uint64_t a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  unsigned int v6 = (char *)malloc_type_malloc(312 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v7 = v6;
  int v8 = *(void ***)a1;
  unsigned int v9 = *(_DWORD *)(a1 + 8);
  if (v9)
  {
    unint64_t v10 = 0;
    uint64_t v11 = 312 * v9;
    do
    {
      unint64_t v12 = &v8[v10 / 8];
      uint64_t v13 = (void **)&v7[v10];
      *uint64_t v13 = v8[v10 / 8];
      unint64_t v14 = &v7[v10 + 24];
      *(void *)&v7[v10 + 8] = v14;
      v13[2] = (void *)0x1000000000;
      unsigned int v15 = v8[v10 / 8 + 2];
      if (v15) {
        BOOL v16 = v12 == v13;
      }
      else {
        BOOL v16 = 1;
      }
      if (!v16)
      {
        int v17 = (void **)v12[1];
        if (v12 + 3 == v17)
        {
          if (v15 >= 0x11) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy(v14, v17, 8 * LODWORD(v8[v10 / 8 + 2]));
          *((_DWORD *)v13 + 4) = v15;
        }
        else
        {
          *(void *)&v7[v10 + 8] = v17;
          int v24 = HIDWORD(v8[v10 / 8 + 2]);
          *((_DWORD *)v13 + 4) = v15;
          *((_DWORD *)v13 + 5) = v24;
          v12[1] = v12 + 3;
          HIDWORD(v8[v10 / 8 + 2]) = 0;
        }
        *((_DWORD *)v12 + 4) = 0;
      }
      unsigned int v18 = v13 + 23;
      v13[19] = v13 + 23;
      uint64_t v20 = v12[19];
      int v19 = v12[20];
      if (v19 == v20)
      {
        v13[20] = v18;
        uint64_t v21 = HIDWORD(v8[v10 / 8 + 21]);
        if (v21) {
          memmove(v18, v12[20], 8 * v21);
        }
      }
      else
      {
        v13[20] = v19;
        v12[20] = v20;
      }
      unint64_t v22 = &v8[v10 / 8];
      int v23 = &v7[v10];
      *((void *)v23 + 21) = v8[v10 / 8 + 21];
      *((_DWORD *)v23 + 44) = v8[v10 / 8 + 22];
      v22[21] = (void *)16;
      *((_DWORD *)v22 + 44) = 0;
      v10 += 312;
    }
    while (v11 != v10);
    int v8 = *(void ***)a1;
    unsigned int v25 = *(_DWORD *)(a1 + 8);
  }
  else
  {
    unsigned int v25 = 0;
  }
  sub_1CCDEFBF8(v8, &v8[39 * v25]);
  if (*(void *)a1 != a1 + 16) {
    free(*(void **)a1);
  }
  *(void *)a1 = v7;
  *(_DWORD *)(a1 + 12) = v5;
}

void sub_1CCDEFBF8(void **a1, void **a2)
{
  if (a2 != a1)
  {
    uint64_t v3 = a2 - 19;
    do
    {
      if (*v3 != *(v3 - 1)) {
        free(*v3);
      }
      unint64_t v4 = (void **)*(v3 - 19);
      if (v3 - 17 != v4) {
        free(v4);
      }
      uint64_t v5 = v3 - 20;
      v3 -= 39;
    }
    while (v5 != a1);
  }
}

uint64_t *sub_1CCDEFC5C(unsigned int a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t **a5)
{
  if (a5) {
    a2 = *a5;
  }
  if (a2 != a3)
  {
    uint64_t v6 = *a4;
    uint64_t v5 = a4[1];
    uint64_t v7 = *((unsigned int *)a4 + 4);
    uint64_t v8 = *((unsigned int *)a4 + 5);
    int v9 = v7 - 1;
    while (1)
    {
      if ((*(void *)(a2[1] + 8 * (a1 >> 6)) & (1 << a1)) != 0)
      {
        uint64_t v10 = *a2;
        if (v5 == v6)
        {
          if (v8)
          {
            uint64_t v11 = 0;
            while (*(void *)(v5 + v11) != v10)
            {
              v11 += 8;
              if (8 * v8 == v11)
              {
                unsigned int v12 = v8;
                goto LABEL_26;
              }
            }
            uint64_t v21 = (void *)(v5 + v11);
            unsigned int v12 = v8;
            uint64_t v22 = v5;
          }
          else
          {
            unsigned int v12 = 0;
LABEL_26:
            uint64_t v22 = v5;
            uint64_t v21 = (void *)(v5 + 8 * v8);
          }
        }
        else
        {
          unsigned int v13 = v9 & ((v10 >> 4) ^ (v10 >> 9));
          unint64_t v14 = (void *)(v5 + 8 * v13);
          uint64_t v15 = *v14;
          if (*v14 == -1)
          {
            BOOL v16 = 0;
LABEL_28:
            if (v16) {
              unint64_t v14 = v16;
            }
            uint64_t v20 = *v14;
          }
          else
          {
            BOOL v16 = 0;
            int v17 = 1;
            while (v15 != v10)
            {
              if (v16) {
                BOOL v18 = 0;
              }
              else {
                BOOL v18 = v15 == -2;
              }
              if (v18) {
                BOOL v16 = v14;
              }
              unsigned int v19 = v13 + v17++;
              unsigned int v13 = v19 & v9;
              unint64_t v14 = (void *)(v5 + 8 * (v19 & v9));
              uint64_t v15 = *v14;
              if (*v14 == -1) {
                goto LABEL_28;
              }
            }
            uint64_t v20 = *a2;
          }
          uint64_t v21 = v20 == v10 ? v14 : (void *)(v5 + 8 * v7);
          unsigned int v12 = v8;
          uint64_t v22 = v6;
        }
        if (v5 != v22) {
          unsigned int v12 = v7;
        }
        if (v21 == (void *)(v5 + 8 * v12)) {
          return a2;
        }
      }
      a2 += 10;
      if (a2 == a3) {
        return a3;
      }
    }
  }
  return a3;
}

uint64_t sub_1CCDEFDB0(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 16);
  if (a1 && v2 == 60 || a1 && v2 == 61)
  {
    return (*(_WORD *)(a1 + 18) & 0x301) == 0;
  }
  else
  {
    uint64_t result = sub_1CBFB3AB0(a1);
    if (!result) {
      return result;
    }
    uint64_t v5 = *(void *)(a1 - 32 * (*(_DWORD *)(a1 + 20) & 0x7FFFFFF) + 96);
    uint64_t v6 = *(unsigned int *)(v5 + 32);
    if (v6 > 0x40)
    {
      int v7 = 0;
      int64_t v8 = (unint64_t)(v6 + 63) >> 6;
      do
      {
        if (v8-- < 1) {
          break;
        }
        unint64_t v10 = *(void *)(*(void *)(v5 + 24) + 8 * v8);
        v7 += __clz(v10);
      }
      while (!v10);
      int v11 = v6 | 0xFFFFFFC0;
      if ((v6 & 0x3F) == 0) {
        int v11 = 0;
      }
      return v7 + v11 == v6;
    }
    else
    {
      return *(void *)(v5 + 24) == 0;
    }
  }
}

BOOL sub_1CCDEFE70(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v13 = 0;
  int v5 = sub_1CD40EA84(*(void *)(a1 + 2448), *(_DWORD *)(a1 + 2464), a2, &v13);
  uint64_t v6 = v13;
  uint64_t v7 = *(void *)(a1 + 2448);
  uint64_t v8 = *(unsigned int *)(a1 + 2464);
  if (v5) {
    BOOL v9 = v13 == v7 + 16 * v8;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9) {
    return 0;
  }
  uint64_t v13 = 0;
  int v11 = sub_1CD40EA84(v7, v8, a3, &v13);
  return v11
      && v13 != *(void *)(a1 + 2448) + 16 * *(unsigned int *)(a1 + 2464)
      && *(_DWORD *)(v6 + 8) == *(_DWORD *)(v13 + 8);
}

void sub_1CCDEFF20(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v122[16] = *MEMORY[0x1E4F143B8];
  int v120 = v122;
  uint64_t v121 = 0x1000000000;
  sub_1CB91FBE0((uint64_t)&v120, 1uLL, a2);
  unsigned int v9 = v121;
  while (v121)
  {
    uint64_t v118 = 0;
    uint64_t v10 = *((void *)v120 + v9 - 1);
    LODWORD(v121) = v9 - 1;
    uint64_t v118 = v10;
    sub_1CD50F67C(a5, &v118, (uint64_t)v119);
    if (v119[16])
    {
      uint64_t v11 = v118;
      uint64_t v13 = *a4;
      uint64_t v12 = a4[1];
      if (v12 == *a4)
      {
        uint64_t v14 = *((unsigned int *)a4 + 5);
        uint64_t v15 = (void *)(v12 + 8 * v14);
        if (v14)
        {
          uint64_t v16 = 0;
          while (*(void *)(v12 + v16) != v118)
          {
            v16 += 8;
            if (8 * v14 == v16) {
              goto LABEL_22;
            }
          }
          uint64_t v15 = (void *)(v12 + v16);
        }
LABEL_22:
        uint64_t v13 = a4[1];
      }
      else
      {
        uint64_t v17 = *((unsigned int *)a4 + 4);
        int v18 = v17 - 1;
        unsigned int v19 = (v17 - 1) & ((v118 >> 4) ^ (v118 >> 9));
        uint64_t v15 = (void *)(v12 + 8 * v19);
        uint64_t v20 = *v15;
        if (*v15 == -1)
        {
          uint64_t v21 = 0;
LABEL_206:
          if (v21) {
            uint64_t v15 = v21;
          }
          LODWORD(v14) = *((_DWORD *)a4 + 5);
          unsigned int v117 = (void *)(v12 + 8 * v17);
          if (*v15 != v118) {
            uint64_t v15 = v117;
          }
        }
        else
        {
          uint64_t v21 = 0;
          int v22 = 1;
          while (v20 != v118)
          {
            if (v21) {
              BOOL v23 = 0;
            }
            else {
              BOOL v23 = v20 == -2;
            }
            if (v23) {
              uint64_t v21 = v15;
            }
            unsigned int v24 = v19 + v22++;
            unsigned int v19 = v24 & v18;
            uint64_t v15 = (void *)(v12 + 8 * (v24 & v18));
            uint64_t v20 = *v15;
            if (*v15 == -1) {
              goto LABEL_206;
            }
          }
          LODWORD(v14) = *((_DWORD *)a4 + 5);
        }
      }
      if (v12 == v13) {
        unsigned int v25 = v14;
      }
      else {
        unsigned int v25 = *((_DWORD *)a4 + 4);
      }
      if (v15 == (void *)(v12 + 8 * v25))
      {
        uint64_t v26 = *(void *)(v118 + 8);
        if (v26)
        {
          while (1)
          {
            uint64_t v27 = *(void *)(v26 + 24);
            if (!v27 || *(unsigned char *)(v27 + 16) != 83) {
              break;
            }
            int v28 = *(_DWORD *)(v27 + 20);
            if ((v28 & 0x40000000) != 0) {
              uint64_t v29 = *(void *)(v27 - 8);
            }
            else {
              uint64_t v29 = v27 - 32 * (v28 & 0x7FFFFFF);
            }
            uint64_t v31 = *(void *)(v29
                            + 32 * *(unsigned int *)(v27 + 60)
                            + 8 * ((unint64_t)(v26 - v29) >> 5));
            uint64_t v30 = *(void *)(a1 + 8);
            if (v31 != **(void **)(v30 + 32)) {
              goto LABEL_35;
            }
LABEL_84:
            uint64_t v26 = *(void *)(v26 + 8);
            if (!v26)
            {
              uint64_t v11 = v118;
              goto LABEL_98;
            }
          }
          uint64_t v30 = *(void *)(a1 + 8);
LABEL_35:
          uint64_t v32 = *(void *)(v27 + 40);
          uint64_t v34 = *(void *)(v30 + 56);
          uint64_t v33 = *(void *)(v30 + 64);
          if (v33 == v34)
          {
            uint64_t v35 = *(unsigned int *)(v30 + 76);
            BOOL v36 = (void *)(v33 + 8 * v35);
            if (v35)
            {
              uint64_t v37 = 0;
              uint64_t v38 = 8 * v35;
              while (*(void *)(v33 + v37) != v32)
              {
                v37 += 8;
                if (v38 == v37) {
                  goto LABEL_53;
                }
              }
              BOOL v36 = (void *)(v33 + v37);
            }
LABEL_53:
            uint64_t v34 = *(void *)(v30 + 64);
          }
          else
          {
            uint64_t v39 = *(unsigned int *)(v30 + 72);
            int v40 = v39 - 1;
            unsigned int v41 = (v39 - 1) & ((v32 >> 4) ^ (v32 >> 9));
            BOOL v36 = (void *)(v33 + 8 * v41);
            uint64_t v42 = *v36;
            if (*v36 == -1)
            {
              unsigned int v43 = 0;
LABEL_87:
              if (v43) {
                BOOL v36 = v43;
              }
              if (*v36 != v32) {
                BOOL v36 = (void *)(v33 + 8 * v39);
              }
            }
            else
            {
              unsigned int v43 = 0;
              int v44 = 1;
              while (v42 != v32)
              {
                if (v43) {
                  BOOL v45 = 0;
                }
                else {
                  BOOL v45 = v42 == -2;
                }
                if (v45) {
                  unsigned int v43 = v36;
                }
                unsigned int v46 = v41 + v44++;
                unsigned int v41 = v46 & v40;
                BOOL v36 = (void *)(v33 + 8 * (v46 & v40));
                uint64_t v42 = *v36;
                if (*v36 == -1) {
                  goto LABEL_87;
                }
              }
            }
          }
          if (v33 == v34) {
            uint64_t v47 = 76;
          }
          else {
            uint64_t v47 = 72;
          }
          if (v36 != (void *)(v33 + 8 * *(unsigned int *)(v30 + v47)))
          {
            uint64_t v49 = *a3;
            uint64_t v48 = a3[1];
            if (v48 == *a3)
            {
              uint64_t v50 = *((unsigned int *)a3 + 5);
              int v51 = (void *)(v48 + 8 * v50);
              if (v50)
              {
                uint64_t v52 = 0;
                while (*(void *)(v48 + v52) != v27)
                {
                  v52 += 8;
                  if (8 * v50 == v52) {
                    goto LABEL_77;
                  }
                }
                int v51 = (void *)(v48 + v52);
              }
LABEL_77:
              uint64_t v49 = a3[1];
            }
            else
            {
              uint64_t v53 = *((unsigned int *)a3 + 4);
              int v54 = v53 - 1;
              unsigned int v55 = (v53 - 1) & ((v27 >> 4) ^ (v27 >> 9));
              int v51 = (void *)(v48 + 8 * v55);
              uint64_t v56 = *v51;
              if (*v51 == -1)
              {
                BOOL v57 = 0;
LABEL_92:
                if (v57) {
                  int v51 = v57;
                }
                LODWORD(v50) = *((_DWORD *)a3 + 5);
                unsigned int v62 = (void *)(v48 + 8 * v53);
                if (*v51 != v27) {
                  int v51 = v62;
                }
              }
              else
              {
                BOOL v57 = 0;
                int v58 = 1;
                while (v56 != v27)
                {
                  if (v57) {
                    BOOL v59 = 0;
                  }
                  else {
                    BOOL v59 = v56 == -2;
                  }
                  if (v59) {
                    BOOL v57 = v51;
                  }
                  unsigned int v60 = v55 + v58++;
                  unsigned int v55 = v60 & v54;
                  int v51 = (void *)(v48 + 8 * (v60 & v54));
                  uint64_t v56 = *v51;
                  if (*v51 == -1) {
                    goto LABEL_92;
                  }
                }
                LODWORD(v50) = *((_DWORD *)a3 + 5);
              }
            }
            if (v48 == v49) {
              unsigned int v61 = v50;
            }
            else {
              unsigned int v61 = *((_DWORD *)a3 + 4);
            }
            if (v51 == (void *)(v48 + 8 * v61))
            {
              if (v121 >= (unint64_t)HIDWORD(v121)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v120 + v121) = v27;
              LODWORD(v121) = v121 + 1;
            }
          }
          goto LABEL_84;
        }
      }
LABEL_98:
      int v63 = *(_DWORD *)(v11 + 20);
      if ((v63 & 0x40000000) != 0)
      {
        uint64_t v65 = *(uint64_t **)(v11 - 8);
        uint64_t v64 = v63 & 0x7FFFFFF;
        if (v64)
        {
LABEL_102:
          unint64_t v66 = &v65[4 * v64];
          do
          {
            uint64_t v67 = *v65;
            if (*v65) {
              BOOL v68 = *(unsigned __int8 *)(*v65 + 16) >= 0x1Cu;
            }
            else {
              BOOL v68 = 0;
            }
            if (v68)
            {
              uint64_t v69 = *(void *)(v67 + 8);
              if (v69)
              {
                if (!*(void *)(v69 + 8))
                {
                  uint64_t v70 = *(void *)(a1 + 8);
                  uint64_t v71 = *(void *)(v67 + 40);
                  uint64_t v73 = *(void *)(v70 + 56);
                  uint64_t v72 = *(void *)(v70 + 64);
                  if (v72 == v73)
                  {
                    uint64_t v74 = *(unsigned int *)(v70 + 76);
                    uint64_t v75 = (void *)(v72 + 8 * v74);
                    if (v74)
                    {
                      uint64_t v76 = 0;
                      uint64_t v77 = 8 * v74;
                      while (*(void *)(v72 + v76) != v71)
                      {
                        v76 += 8;
                        if (v77 == v76) {
                          goto LABEL_130;
                        }
                      }
                      uint64_t v75 = (void *)(v72 + v76);
                    }
LABEL_130:
                    uint64_t v73 = *(void *)(v70 + 64);
                  }
                  else
                  {
                    uint64_t v78 = *(unsigned int *)(v70 + 72);
                    int v79 = v78 - 1;
                    unsigned int v80 = (v78 - 1) & ((v71 >> 4) ^ (v71 >> 9));
                    uint64_t v75 = (void *)(v72 + 8 * v80);
                    uint64_t v81 = *v75;
                    if (*v75 == -1)
                    {
                      uint64_t v82 = 0;
LABEL_166:
                      if (v82) {
                        uint64_t v75 = v82;
                      }
                      if (*v75 != v71) {
                        uint64_t v75 = (void *)(v72 + 8 * v78);
                      }
                    }
                    else
                    {
                      uint64_t v82 = 0;
                      int v83 = 1;
                      while (v81 != v71)
                      {
                        if (v82) {
                          BOOL v84 = 0;
                        }
                        else {
                          BOOL v84 = v81 == -2;
                        }
                        if (v84) {
                          uint64_t v82 = v75;
                        }
                        unsigned int v85 = v80 + v83++;
                        unsigned int v80 = v85 & v79;
                        uint64_t v75 = (void *)(v72 + 8 * (v85 & v79));
                        uint64_t v81 = *v75;
                        if (*v75 == -1) {
                          goto LABEL_166;
                        }
                      }
                    }
                  }
                  if (v72 == v73) {
                    uint64_t v86 = 76;
                  }
                  else {
                    uint64_t v86 = 72;
                  }
                  if (v75 != (void *)(v72 + 8 * *(unsigned int *)(v70 + v86)))
                  {
                    uint64_t v88 = *a3;
                    uint64_t v87 = a3[1];
                    if (v87 == *a3)
                    {
                      uint64_t v89 = *((unsigned int *)a3 + 5);
                      int v90 = (void *)(v87 + 8 * v89);
                      if (v89)
                      {
                        uint64_t v91 = 0;
                        while (*(void *)(v87 + v91) != v67)
                        {
                          v91 += 8;
                          if (8 * v89 == v91) {
                            goto LABEL_154;
                          }
                        }
                        int v90 = (void *)(v87 + v91);
                      }
LABEL_154:
                      uint64_t v88 = a3[1];
                    }
                    else
                    {
                      uint64_t v92 = *((unsigned int *)a3 + 4);
                      int v93 = v92 - 1;
                      unsigned int v94 = (v92 - 1) & ((v67 >> 4) ^ (v67 >> 9));
                      int v90 = (void *)(v87 + 8 * v94);
                      uint64_t v95 = *v90;
                      if (*v90 == -1)
                      {
                        uint64_t v96 = 0;
LABEL_182:
                        if (v96) {
                          int v90 = v96;
                        }
                        LODWORD(v89) = *((_DWORD *)a3 + 5);
                        uint64_t v114 = (void *)(v87 + 8 * v92);
                        if (*v90 != v67) {
                          int v90 = v114;
                        }
                      }
                      else
                      {
                        uint64_t v96 = 0;
                        int v97 = 1;
                        while (v95 != v67)
                        {
                          if (v96) {
                            BOOL v98 = 0;
                          }
                          else {
                            BOOL v98 = v95 == -2;
                          }
                          if (v98) {
                            uint64_t v96 = v90;
                          }
                          unsigned int v99 = v94 + v97++;
                          unsigned int v94 = v99 & v93;
                          int v90 = (void *)(v87 + 8 * (v99 & v93));
                          uint64_t v95 = *v90;
                          if (*v90 == -1) {
                            goto LABEL_182;
                          }
                        }
                        LODWORD(v89) = *((_DWORD *)a3 + 5);
                      }
                    }
                    if (v87 == v88) {
                      unsigned int v100 = v89;
                    }
                    else {
                      unsigned int v100 = *((_DWORD *)a3 + 4);
                    }
                    if (v90 == (void *)(v87 + 8 * v100))
                    {
                      uint64_t v102 = *a4;
                      uint64_t v101 = a4[1];
                      if (v101 == *a4)
                      {
                        uint64_t v103 = *((unsigned int *)a4 + 5);
                        int v104 = (void *)(v101 + 8 * v103);
                        if (v103)
                        {
                          uint64_t v105 = 0;
                          while (*(void *)(v101 + v105) != v67)
                          {
                            v105 += 8;
                            if (8 * v103 == v105) {
                              goto LABEL_189;
                            }
                          }
                          int v104 = (void *)(v101 + v105);
                        }
LABEL_189:
                        uint64_t v102 = a4[1];
                      }
                      else
                      {
                        uint64_t v106 = *((unsigned int *)a4 + 4);
                        int v107 = v106 - 1;
                        unsigned int v108 = (v106 - 1) & ((v67 >> 4) ^ (v67 >> 9));
                        int v104 = (void *)(v101 + 8 * v108);
                        uint64_t v109 = *v104;
                        if (*v104 == -1)
                        {
                          uint64_t v110 = 0;
LABEL_197:
                          if (v110) {
                            int v104 = v110;
                          }
                          LODWORD(v103) = *((_DWORD *)a4 + 5);
                          uint64_t v116 = (void *)(v101 + 8 * v106);
                          if (*v104 != v67) {
                            int v104 = v116;
                          }
                        }
                        else
                        {
                          uint64_t v110 = 0;
                          int v111 = 1;
                          while (v109 != v67)
                          {
                            if (v110) {
                              BOOL v112 = 0;
                            }
                            else {
                              BOOL v112 = v109 == -2;
                            }
                            if (v112) {
                              uint64_t v110 = v104;
                            }
                            unsigned int v113 = v108 + v111++;
                            unsigned int v108 = v113 & v107;
                            int v104 = (void *)(v101 + 8 * (v113 & v107));
                            uint64_t v109 = *v104;
                            if (*v104 == -1) {
                              goto LABEL_197;
                            }
                          }
                          LODWORD(v103) = *((_DWORD *)a4 + 5);
                        }
                      }
                      if (v101 == v102) {
                        unsigned int v115 = v103;
                      }
                      else {
                        unsigned int v115 = *((_DWORD *)a4 + 4);
                      }
                      if (v104 == (void *)(v101 + 8 * v115))
                      {
                        if (v121 >= (unint64_t)HIDWORD(v121)) {
                          llvm::SmallVectorBase<unsigned int>::grow_pod();
                        }
                        *((void *)v120 + v121) = v67;
                        LODWORD(v121) = v121 + 1;
                      }
                    }
                  }
                }
              }
            }
            v65 += 4;
          }
          while (v65 != v66);
        }
      }
      else
      {
        uint64_t v64 = v63 & 0x7FFFFFF;
        uint64_t v65 = (uint64_t *)(v11 - 32 * v64);
        if (v64) {
          goto LABEL_102;
        }
      }
    }
    unsigned int v9 = v121;
  }
  if (v120 != v122) {
    free(v120);
  }
}

void sub_1CCDF06F4(uint64_t *a1, uint64_t a2)
{
  unint64_t v4 = a1[2];
  unint64_t v5 = a1[1];
  if (v5 >= v4)
  {
    unint64_t v11 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - *a1) >> 4);
    if (v11 + 1 > 0x333333333333333) {
      abort();
    }
    unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v4 - *a1) >> 4);
    uint64_t v13 = 2 * v12;
    if (2 * v12 <= v11 + 1) {
      uint64_t v13 = v11 + 1;
    }
    if (v12 >= 0x199999999999999) {
      unint64_t v14 = 0x333333333333333;
    }
    else {
      unint64_t v14 = v13;
    }
    int v28 = a1 + 2;
    if (v14)
    {
      if (v14 > 0x333333333333333) {
        sub_1CB833614();
      }
      uint64_t v15 = (char *)operator new(80 * v14);
    }
    else
    {
      uint64_t v15 = 0;
    }
    uint64_t v16 = &v15[80 * v11];
    uint64_t __p = v15;
    unsigned int v25 = v16;
    uint64_t v27 = &v15[80 * v14];
    *(void *)uint64_t v16 = *(void *)a2;
    *((void *)v16 + 1) = v16 + 24;
    uint64_t v17 = v16 + 8;
    *((void *)v16 + 2) = 0x600000000;
    unsigned int v18 = *(_DWORD *)(a2 + 16);
    if (v18 && v17 != (void *)(a2 + 8))
    {
      unsigned int v19 = *(const void **)(a2 + 8);
      if (v19 == (const void *)(a2 + 24))
      {
        if (v18 >= 7)
        {
          *((_DWORD *)v16 + 4) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        memcpy(v16 + 24, v19, 8 * *(unsigned int *)(a2 + 16));
        *((_DWORD *)v16 + 4) = v18;
      }
      else
      {
        *uint64_t v17 = v19;
        int v23 = *(_DWORD *)(a2 + 20);
        *((_DWORD *)v16 + 4) = v18;
        *((_DWORD *)v16 + 5) = v23;
        *(void *)(a2 + 8) = a2 + 24;
        *(_DWORD *)(a2 + 20) = 0;
      }
      *(_DWORD *)(a2 + 16) = 0;
    }
    *(_DWORD *)&v15[80 * v11 + 72] = *(_DWORD *)(a2 + 72);
    uint64_t v26 = v16 + 80;
    sub_1CD773598(a1, &__p);
    uint64_t v10 = a1[1];
    uint64_t v20 = v25;
    for (uint64_t i = v26; i != v20; i -= 80)
    {
      int v22 = (char *)*((void *)i - 9);
      if (i - 56 != v22) {
        free(v22);
      }
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else
  {
    *(void *)unint64_t v5 = *(void *)a2;
    *(void *)(v5 + 8) = v5 + 24;
    *(void *)(v5 + 16) = 0x600000000;
    unsigned int v6 = *(_DWORD *)(a2 + 16);
    if (v6) {
      BOOL v7 = v5 == a2;
    }
    else {
      BOOL v7 = 1;
    }
    if (!v7)
    {
      uint64_t v8 = *(void *)(a2 + 8);
      unsigned int v9 = (const void *)(a2 + 24);
      if (v8 == a2 + 24)
      {
        if (v6 >= 7) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        memcpy((void *)(v5 + 24), v9, 8 * *(unsigned int *)(a2 + 16));
        *(_DWORD *)(v5 + 16) = v6;
      }
      else
      {
        *(void *)(v5 + 8) = v8;
        *(_DWORD *)(v5 + 16) = v6;
        *(_DWORD *)(v5 + 20) = *(_DWORD *)(a2 + 20);
        *(void *)(a2 + 8) = v9;
        *(_DWORD *)(a2 + 20) = 0;
      }
      *(_DWORD *)(a2 + 16) = 0;
    }
    *(_DWORD *)(v5 + 72) = *(_DWORD *)(a2 + 72);
    uint64_t v10 = v5 + 80;
  }
  a1[1] = v10;
}

void sub_1CCDF09C0(void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unsigned int v6 = (char *)*((void *)v4 - 9);
        if (v4 - 56 != v6) {
          free(v6);
        }
        v4 -= 80;
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1CCDF0A50()
{
  int v3 = 400;
  unint64_t v4 = &v3;
  int v2 = 1;
  *(void *)&long long v1 = "The maximum number of failures to tolerate during fuzzy matching. (default: 400)";
  *((void *)&v1 + 1) = 80;
  sub_1CD7736C4(&v4, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCF4D68, &dword_1CB82C000);
}

unsigned char *llvm::LoopRotatePass::LoopRotatePass(unsigned char *this, char a2, char a3)
{
  *this = a2;
  this[1] = a3;
  return this;
}

{
  *this = a2;
  this[1] = a3;
  return this;
}

void llvm::LoopRotatePass::run(unsigned char *a1, llvm *this, uint64_t a3, uint64_t a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (*a1)
  {
    LOBYTE(v18) = 0;
    char v28 = 0;
    uint64_t v5 = *(void *)(a4 + 72);
    if (v5)
    {
      v6[0] = (char *)&v7;
      v6[1] = (char *)0x1000000000;
      uint64_t v8 = v12;
      unsigned int v9 = v12;
      uint64_t v13 = v15;
      uint64_t v14 = 0x800000000;
      v17[1] = 0;
      v17[0] = 0;
      uint64_t v16 = v17;
      uint64_t v18 = v5;
      unsigned int v19 = v21;
      uint64_t v20 = 0x1000000000;
      v21[48] = v23;
      v21[49] = v23;
      v21[50] = 8;
      int v22 = 0;
      uint64_t v10 = 8;
      int v11 = 0;
      unsigned int v24 = v26;
      uint64_t v25 = 0x800000000;
      v27[1] = 0;
      v27[0] = 0;
      v26[8] = v27;
      char v28 = 1;
      sub_1CD3C5048((uint64_t)&v16, 0);
      if (v13 != v15) {
        free(v13);
      }
      if (v9 != v8) {
        free(v9);
      }
      sub_1CC0BD0FC(v6);
    }
    llvm::LoopRotation(this);
  }
  llvm::hasVectorizeTransformation(this, this);
}

void sub_1CCDF0DC8(llvm *a1)
{
  llvm::initializeAssumptionCacheTrackerPass((uint64_t)a1);
  llvm::initializeLoopPassPass(a1, v2);
  llvm::initializeTargetTransformInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeMemorySSAWrapperPassPass(a1, v3);
  operator new();
}

uint64_t sub_1CCDF0E80(uint64_t a1, int a2, char a3)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF4E38;
  *(_DWORD *)(a1 + 24) = 1;
  *(void *)a1 = &unk_1F263F210;
  *(unsigned char *)(a1 + 32) = a3;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF4E40, memory_order_acquire) != -1)
  {
    v9[0] = sub_1CCDF0DC8;
    v9[1] = &PassRegistry;
    uint64_t v8 = v9;
    std::__call_once(&qword_1EBCF4E40, &v8, (void (__cdecl *)(void *))sub_1CB848390);
  }
  int v5 = dword_1EBCF4EC8;
  if (a2 != -1) {
    int v5 = a2;
  }
  *(_DWORD *)(a1 + 28) = v5;
  return a1;
}

void sub_1CCDF0F54()
{
}

void sub_1CCDF0F9C(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCDF0FD4(uint64_t a1, llvm *a2)
{
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::AssumptionCacheTracker::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::MemorySSAWrapperPass::ID);
  llvm::getLoopAnalysisUsage(a2, v3);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)llvm::LazyBlockFrequencyInfoPass::ID);

  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::LazyBranchProbabilityInfoPass::ID);
}

uint64_t sub_1CCDF106C(llvm *a1, llvm *a2)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  if ((llvm::LoopPass::skipLoop(a1, a2) & 1) == 0)
  {
    unint64_t v4 = *(Function **)(**((void **)a2 + 4) + 56);
    int v5 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v6 = *v5;
    uint64_t v7 = v5[1];
    if (v6 == v7)
    {
LABEL_6:
      uint64_t v8 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v6 != &llvm::LoopInfoWrapperPass::ID)
      {
        v6 += 16;
        if (v6 == v7) {
          goto LABEL_6;
        }
      }
      uint64_t v8 = *(void *)(v6 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v8 + 96))(v8, &llvm::LoopInfoWrapperPass::ID);
    unsigned int v9 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v10 = *v9;
    uint64_t v11 = v9[1];
    if (v10 == v11)
    {
LABEL_11:
      uint64_t v12 = 0;
    }
    else
    {
      while (*(char **)v10 != llvm::TargetTransformInfoWrapperPass::ID)
      {
        v10 += 16;
        if (v10 == v11) {
          goto LABEL_11;
        }
      }
      uint64_t v12 = *(void *)(v10 + 8);
    }
    uint64_t v13 = (llvm::TargetTransformInfoWrapperPass *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v12 + 96))(v12, llvm::TargetTransformInfoWrapperPass::ID);
    llvm::TargetTransformInfoWrapperPass::getTTI(v13, v4);
    uint64_t v14 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v15 = *v14;
    uint64_t v16 = v14[1];
    if (v15 == v16)
    {
LABEL_16:
      uint64_t v17 = 0;
    }
    else
    {
      while (*(char **)v15 != llvm::AssumptionCacheTracker::ID)
      {
        v15 += 16;
        if (v15 == v16) {
          goto LABEL_16;
        }
      }
      uint64_t v17 = *(void *)(v15 + 8);
    }
    uint64_t v18 = (llvm::AssumptionCacheTracker *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v17 + 96))(v17, llvm::AssumptionCacheTracker::ID);
    llvm::AssumptionCacheTracker::getAssumptionCache(v18, (llvm::Function *)v4);
    unsigned int v19 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v20 = *v19;
    uint64_t v21 = v19[1];
    if (v20 == v21)
    {
LABEL_21:
      uint64_t v22 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v20 != &llvm::DominatorTreeWrapperPass::ID)
      {
        v20 += 16;
        if (v20 == v21) {
          goto LABEL_21;
        }
      }
      uint64_t v22 = *(void *)(v20 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v22 + 96))(v22, &llvm::DominatorTreeWrapperPass::ID);
    int v23 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v24 = *v23;
    uint64_t v25 = v23[1];
    if (v24 == v25)
    {
LABEL_26:
      uint64_t v26 = 0;
    }
    else
    {
      while (*(char **)v24 != llvm::ScalarEvolutionWrapperPass::ID)
      {
        v24 += 16;
        if (v24 == v25) {
          goto LABEL_26;
        }
      }
      uint64_t v26 = *(void *)(v24 + 8);
    }
    (*(void (**)(uint64_t, char *))(*(void *)v26 + 96))(v26, llvm::ScalarEvolutionWrapperPass::ID);
    llvm::getBestSimplifyQuery(a1, (llvm::Pass *)v4, (uint64_t)v32);
    LOBYTE(v46) = 0;
    char v59 = 0;
    uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*((void *)a1 + 1) + 24), &llvm::MemorySSAWrapperPass::ID, 1);
    if (AnalysisPass)
    {
      uint64_t v29 = (*(uint64_t (**)(uint64_t, void *))(*(void *)AnalysisPass + 96))(AnalysisPass, &llvm::MemorySSAWrapperPass::ID);
      if (v29)
      {
        uint64_t v33 = *(void *)(v29 + 32);
        v34[0] = (char *)&v35;
        v34[1] = (char *)0x1000000000;
        BOOL v36 = v40;
        uint64_t v37 = v40;
        uint64_t v38 = 8;
        int v39 = 0;
        v41[0] = v42;
        v41[1] = (void *)0x800000000;
        uint64_t v45 = 0;
        int v44 = 0;
        unsigned int v43 = &v44;
        uint64_t v46 = v33;
        if (v59)
        {
          sub_1CD72D390((uint64_t)v47, (uint64_t)v34);
          if (v50 != __dst) {
            free(v50);
          }
          if (v37 == v36)
          {
            uint64_t v50 = __dst;
            if (HIDWORD(v38)) {
              memmove(__dst, v37, 8 * HIDWORD(v38));
            }
          }
          else
          {
            uint64_t v50 = v37;
            uint64_t v37 = v36;
          }
          uint64_t v51 = v38;
          int v52 = v39;
          uint64_t v38 = 8;
          int v39 = 0;
          sub_1CD72A1EC((uint64_t)v54, (uint64_t)v41);
          sub_1CD3C5048((uint64_t)&v56, v57);
          uint64_t v56 = v43;
          uint64_t v30 = v44;
          BOOL v57 = v44;
          uint64_t v58 = v45;
          if (v45)
          {
            v44[2] = &v57;
            uint64_t v30 = 0;
            unsigned int v43 = &v44;
            int v44 = 0;
            uint64_t v45 = 0;
          }
          else
          {
            uint64_t v56 = &v57;
          }
        }
        else
        {
          uint64_t v30 = 0;
          v47[0] = &v48;
          std::string __dst = v53;
          uint64_t v50 = v53;
          v54[0] = &v55;
          v47[1] = 0x1000000000;
          uint64_t v51 = 8;
          int v52 = 0;
          uint64_t v38 = 8;
          int v39 = 0;
          v54[1] = (void *)0x800000000;
          uint64_t v58 = 0;
          BOOL v57 = 0;
          uint64_t v56 = &v57;
          char v59 = 1;
        }
        sub_1CD3C5048((uint64_t)&v43, v30);
        if (v41[0] != v42) {
          free(v41[0]);
        }
        if (v37 != v36) {
          free(v37);
        }
        sub_1CC0BD0FC(v34);
      }
    }
    llvm::hasVectorizeTransformation(a2, v28);
  }
  return 0;
}

uint64_t sub_1CCDF1648()
{
  int v3 = 16;
  unint64_t v4 = &v3;
  int v1 = 1;
  v2.n128_u64[0] = (unint64_t)"The default maximum header size for automatic loop rotation";
  v2.n128_u64[1] = 59;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF4E48, "rotation-max-header-size", &v4, &v1, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF4E48, &dword_1CB82C000);
  LOBYTE(v1) = 0;
  unint64_t v4 = &v1;
  int v3 = 1;
  v2.n128_u64[0] = (unint64_t)"Run loop-rotation in the prepare-for-lto stage. This option should be used for testing only.";
  v2.n128_u64[1] = 92;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCF4F08, "rotation-prepare-for-lto", (unsigned char **)&v4, &v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF4F08, &dword_1CB82C000);
}

void llvm::LoopSimplifyCFGPass::run(const llvm::Loop *a1@<X1>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  LOBYTE(v21) = 0;
  char v34 = 0;
  uint64_t v6 = *(void *)(a2 + 72);
  if (v6)
  {
    uint64_t v8 = *(void *)(a2 + 72);
    v9[0] = (char *)&v10;
    v9[1] = (char *)0x1000000000;
    uint64_t v11 = v15;
    uint64_t v12 = v15;
    uint64_t v16 = v18;
    uint64_t v17 = 0x800000000;
    v20[1] = 0;
    v20[0] = 0;
    unsigned int v19 = v20;
    uint64_t v21 = v6;
    v22[0] = (char *)&v23;
    v22[1] = (char *)0x1000000000;
    uint64_t v24 = v28;
    uint64_t v25 = v28;
    uint64_t v26 = 8;
    int v27 = 0;
    uint64_t v13 = 8;
    int v14 = 0;
    uint64_t v29 = v31;
    uint64_t v30 = 0x800000000;
    v33[1] = 0;
    v33[0] = 0;
    uint64_t v32 = v33;
    char v34 = 1;
    sub_1CD3C5048((uint64_t)&v19, 0);
    if (v16 != v18) {
      free(v16);
    }
    if (v12 != v11) {
      free(v12);
    }
    sub_1CC0BD0FC(v9);
    if (v34) {
      uint64_t v7 = &v21;
    }
    else {
      uint64_t v7 = 0;
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  LOBYTE(v8) = 0;
  if (sub_1CCDF19C4(a1, *(llvm::ScalarEvolution **)(a2 + 16), *(llvm::DomTreeUpdater **)(a2 + 24), *(int32x2_t **)(a2 + 32), (unint64_t)v7, &v8))
  {
    if ((_BYTE)v8) {
      llvm::AnalysisManager<llvm::Loop,llvm::LoopStandardAnalysisResults &>::clear();
    }
    llvm::getLoopPassPreservedAnalyses(a3);
    if (*(void *)(a2 + 72)) {
      sub_1CBFA65B8((llvm::SmallPtrSetImplBase *)a3, (uint64_t)&llvm::MemorySSAAnalysis::Key);
    }
  }
  else
  {
    *(void *)(a3 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
    *(void *)a3 = a3 + 32;
    *(void *)(a3 + 8) = a3 + 32;
    *(_DWORD *)(a3 + 24) = 0;
    *(void *)(a3 + 48) = a3 + 80;
    *(void *)(a3 + 56) = a3 + 80;
    *(void *)(a3 + 64) = 2;
    *(_DWORD *)(a3 + 72) = 0;
    *(void *)(a3 + 16) = 0x100000002;
  }
  if (v34)
  {
    sub_1CD3C5048((uint64_t)&v32, v33[0]);
    if (v29 != v31) {
      free(v29);
    }
    if (v25 != v24) {
      free(v25);
    }
    sub_1CC0BD0FC(v22);
  }
}

uint64_t sub_1CCDF19C4(const llvm::Loop *a1, llvm::ScalarEvolution *a2, llvm::DomTreeUpdater *a3, int32x2_t *a4, unint64_t a5, unsigned char *a6)
{
  v48[48] = *(void **)MEMORY[0x1E4F143B8];
  if (byte_1EBCF5048) {
    llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopLatch();
  }
  if (*a6) {
    return 1;
  }
  v37[0] = (llvm::Loop *)v38;
  v37[1] = (llvm::Loop *)0x1000000000;
  v38[33] = 0;
  v38[32] = 0;
  v38[34] = a2;
  v38[35] = 0;
  char v39 = 0;
  int v40 = v44;
  unsigned int v41 = v44;
  uint64_t v42 = 8;
  int v43 = 0;
  memset(&v44[64], 0, 24);
  LOWORD(v45) = 0;
  uint64_t v7 = (char *)*((void *)a1 + 4);
  uint64_t v6 = (char *)*((void *)a1 + 5);
  unint64_t v8 = v6 - v7;
  uint64_t v9 = (v6 - v7) >> 3;
  uint64_t v10 = (char *)v48;
  uint64_t v46 = v48;
  uint64_t v47 = (void *)0x1000000000;
  if ((unint64_t)(v6 - v7) >= 0x81)
  {
    sub_1CC261F80((unsigned int *)&v46, (v6 - v7) >> 3);
    int v11 = (int)v47;
    uint64_t v10 = (char *)v46;
    int v12 = (int)v47;
  }
  else
  {
    int v11 = 0;
    int v12 = 0;
  }
  if (v6 != v7)
  {
    uint64_t v13 = (llvm::ValueHandleBase *)&v10[24 * v11];
    uint64_t v14 = 8 * v9;
    do
    {
      uint64_t v15 = *(void *)v7;
      *(void *)uint64_t v13 = 6;
      *((void *)v13 + 1) = 0;
      *((void *)v13 + 2) = v15;
      if (v15 != -8192 && v15 != -4096 && v15 != 0) {
        llvm::ValueHandleBase::AddToUseList(v13);
      }
      v7 += 8;
      uint64_t v13 = (llvm::ValueHandleBase *)((char *)v13 + 24);
      v14 -= 8;
    }
    while (v14);
    int v12 = (int)v47;
    uint64_t v10 = (char *)v46;
  }
  int v17 = v12 + (v8 >> 3);
  LODWORD(v47) = v17;
  char v18 = 0;
  if (v17)
  {
    unsigned int v19 = &v10[24 * v17];
    do
    {
      uint64_t v20 = (llvm *)*((void *)v10 + 2);
      if (v20)
      {
        uint64_t SinglePredecessor = (llvm::BasicBlock *)llvm::BasicBlock::getSinglePredecessor(*((llvm::BasicBlock **)v10 + 2));
        if (SinglePredecessor)
        {
          uint64_t v22 = SinglePredecessor;
          if (llvm::BasicBlock::getSingleSuccessor(SinglePredecessor))
          {
            int v23 = *((_DWORD *)a3 + 4);
            if (v23)
            {
              uint64_t v24 = *(void *)a3;
              unsigned int v25 = v23 - 1;
              uint64_t v26 = (v23 - 1) & ((v22 >> 4) ^ (v22 >> 9));
              int v27 = *(llvm::BasicBlock **)(*(void *)a3 + 16 * v26);
              if (v22 == v27)
              {
LABEL_26:
                if (*(const llvm::Loop **)(v24 + 16 * v26 + 8) == a1)
                {
                  llvm::MergeBlockIntoPredecessor(v20, (unint64_t)v37, a3, a5, 0, 0);
                  char v18 = 1;
                }
              }
              else
              {
                int v28 = 1;
                while (v27 != (llvm::BasicBlock *)-4096)
                {
                  int v29 = v26 + v28++;
                  uint64_t v26 = v29 & v25;
                  int v27 = *(llvm::BasicBlock **)(v24 + 16 * v26);
                  if (v22 == v27) {
                    goto LABEL_26;
                  }
                }
              }
            }
          }
        }
      }
      v10 += 24;
    }
    while (v10 != v19);
  }
  sub_1CC2621C4((char **)&v46);
  sub_1CC2930C0((uint64_t)v37);
  if (v18)
  {
    uint64_t v30 = a1;
    do
    {
      uint64_t v31 = v30;
      uint64_t v30 = *(const llvm::Loop **)v30;
    }
    while (v30);
    llvm::ScalarEvolution::forgetLoop(a4, v31);
    return 1;
  }
  return 0;
}

void sub_1CCDF56F0(llvm *a1, llvm::PassRegistry *a2)
{
  llvm::initializeLoopPassPass(a1, a2);
  llvm::initializeMemorySSAWrapperPassPass(a1, v3);
  operator new();
}

uint64_t sub_1CCDF5798(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF5088;
  *(_DWORD *)(a1 + 24) = 1;
  *(void *)a1 = &unk_1F263F2C0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF5090, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCDF56F0;
    v5[1] = &PassRegistry;
    unint64_t v4 = v5;
    std::__call_once(&qword_1EBCF5090, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CCDF5848(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1 == a1 + 40) {
    return 0;
  }
  BOOL v2 = v1 == 0;
  if (v1) {
    uint64_t v3 = v1 - 24;
  }
  else {
    uint64_t v3 = 0;
  }
  unsigned int v4 = *(unsigned __int8 *)(v3 + 16) - 40;
  BOOL v5 = __CFADD__(v4, 11);
  if (v4 < 0xFFFFFFF5) {
    uint64_t v3 = 0;
  }
  int v6 = *(unsigned __int8 *)(v3 + 16);
  if (!v5) {
    BOOL v2 = 1;
  }
  if (v6 == 30 && !v2)
  {
    if ((*(_DWORD *)(v3 + 20) & 0x7FFFFFF) != 1)
    {
      uint64_t v7 = *(void *)(v3 - 32);
      uint64_t result = *(void *)(v3 - 64);
      if (v7 != result)
      {
        uint64_t v9 = *(void *)(v3 - 96);
        if (v9) {
          BOOL v10 = *(unsigned char *)(v9 + 16) == 16;
        }
        else {
          BOOL v10 = 0;
        }
        if (!v10) {
          return 0;
        }
        uint64_t v11 = *(unsigned int *)(v9 + 32);
        if (v11 > 0x40)
        {
          int v24 = 0;
          int64_t v25 = (unint64_t)(v11 + 63) >> 6;
          do
          {
            if (v25-- < 1) {
              break;
            }
            unint64_t v27 = *(void *)(*(void *)(v9 + 24) + 8 * v25);
            v24 += __clz(v27);
          }
          while (!v27);
          int v28 = v11 | 0xFFFFFFC0;
          if ((v11 & 0x3F) == 0) {
            int v28 = 0;
          }
          if (v24 + v28 == v11) {
            return result;
          }
        }
        else if (!*(void *)(v9 + 24))
        {
          return result;
        }
      }
      return v7;
    }
    return 0;
  }
  char v12 = v6 != 31 || v2;
  if (v12) {
    return 0;
  }
  unsigned int v13 = *(_DWORD *)(v3 + 20);
  uint64_t v14 = (v13 & 0x40000000) != 0 ? *(uint64_t **)(v3 - 8) : (uint64_t *)(v3 - 32 * (v13 & 0x7FFFFFF));
  uint64_t v15 = *v14;
  int v16 = *(unsigned __int8 *)(*v14 + 16);
  if (!v15 || v16 != 16) {
    return 0;
  }
  int v18 = (v13 >> 1) & 0x3FFFFFF;
  uint64_t v19 = (v18 - 1);
  if (v18 == 1)
  {
LABEL_40:
    if ((v13 & 0x40000000) != 0) {
      uint64_t v23 = *(void *)(v3 - 8);
    }
    else {
      uint64_t v23 = v3 - 32 * (v13 & 0x7FFFFFF);
    }
    return *(void *)(v23 + 32);
  }
  uint64_t v20 = 0;
  uint64_t v21 = v3 - 32 * (v13 & 0x7FFFFFF);
  uint64_t v22 = 2 * v19;
  while ((v13 & 0x40000000) == 0)
  {
    if (*(void *)(v21 + 32 * ((v20 + 2) & 0xFFFFFFFE)) == v15) {
      goto LABEL_53;
    }
LABEL_39:
    v20 += 2;
    if (v22 == v20) {
      goto LABEL_40;
    }
  }
  if (*(void *)(*(void *)(v3 - 8) + 32 * ((v20 + 2) & 0xFFFFFFFE)) != v15) {
    goto LABEL_39;
  }
  uint64_t v21 = *(void *)(v3 - 8);
LABEL_53:
  uint64_t v29 = (v20 + 3);
  if (v20 == 0x1FFFFFFFCLL) {
    uint64_t v29 = 1;
  }
  return *(void *)(v21 + 32 * v29);
}

void sub_1CCDF59FC()
{
}

void sub_1CCDF5A3C(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCDF5A74(uint64_t a1, llvm *a2)
{
  uint64_t v3 = (uint64_t)a2 + 112;
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::MemorySSAWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, v3, (uint64_t)&llvm::DependenceAnalysisWrapperPass::ID);

  llvm::getLoopAnalysisUsage(a2, v4);
}

uint64_t sub_1CCDF5AD4(llvm::LoopPass *a1, const llvm::Loop *a2, llvm::LPPassManager *a3)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (llvm::LoopPass::skipLoop(a1, a2)) {
    return 0;
  }
  uint64_t v7 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v8 = *v7;
  uint64_t v9 = v7[1];
  if (v8 == v9)
  {
LABEL_6:
    uint64_t v10 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v8 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v8 += 16;
      if (v8 == v9) {
        goto LABEL_6;
      }
    }
    uint64_t v10 = *(void *)(v8 + 8);
  }
  uint64_t v11 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v10 + 96))(v10, &llvm::DominatorTreeWrapperPass::ID);
  char v12 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v13 = *v12;
  uint64_t v14 = v12[1];
  if (v13 == v14)
  {
LABEL_11:
    uint64_t v15 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v13 != &llvm::LoopInfoWrapperPass::ID)
    {
      v13 += 16;
      if (v13 == v14) {
        goto LABEL_11;
      }
    }
    uint64_t v15 = *(void *)(v13 + 8);
  }
  int v16 = (llvm::ScalarEvolution *)(v11 + 32);
  int v17 = (llvm::DomTreeUpdater *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v15 + 96))(v15, &llvm::LoopInfoWrapperPass::ID)+ 32);
  int v18 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v19 = *v18;
  uint64_t v20 = v18[1];
  if (v19 == v20)
  {
LABEL_16:
    uint64_t v21 = 0;
  }
  else
  {
    while (*(char **)v19 != llvm::ScalarEvolutionWrapperPass::ID)
    {
      v19 += 16;
      if (v19 == v20) {
        goto LABEL_16;
      }
    }
    uint64_t v21 = *(void *)(v19 + 8);
  }
  uint64_t v22 = *(int32x2_t **)((*(uint64_t (**)(uint64_t, char *))(*(void *)v21 + 96))(v21, llvm::ScalarEvolutionWrapperPass::ID)+ 32);
  uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*((void *)a1 + 1) + 24), &llvm::MemorySSAWrapperPass::ID, 1);
  if (AnalysisPass)
  {
    uint64_t v24 = (*(uint64_t (**)(uint64_t, void *))(*(void *)AnalysisPass + 96))(AnalysisPass, &llvm::MemorySSAWrapperPass::ID);
    LOBYTE(v40) = 0;
    char v53 = 0;
    if (v24)
    {
      uint64_t v27 = *(void *)(v24 + 32);
      v28[0] = (char *)&v29;
      v28[1] = (char *)0x1000000000;
      uint64_t v30 = v34;
      uint64_t v31 = v34;
      uint64_t v35 = v37;
      uint64_t v36 = 0x800000000;
      v39[1] = 0;
      v39[0] = 0;
      uint64_t v38 = v39;
      uint64_t v40 = v27;
      v41[0] = (char *)&v42;
      v41[1] = (char *)0x1000000000;
      int v43 = v47;
      int v44 = v47;
      uint64_t v45 = 8;
      int v46 = 0;
      uint64_t v32 = 8;
      int v33 = 0;
      uint64_t v48 = v50;
      uint64_t v49 = 0x800000000;
      v52[1] = 0;
      v52[0] = 0;
      uint64_t v51 = v52;
      char v53 = 1;
      sub_1CD3C5048((uint64_t)&v38, 0);
      if (v35 != v37) {
        free(v35);
      }
      if (v31 != v30) {
        free(v31);
      }
      sub_1CC0BD0FC(v28);
      if (v53) {
        int64_t v25 = &v40;
      }
      else {
        int64_t v25 = 0;
      }
    }
    else
    {
      int64_t v25 = 0;
    }
  }
  else
  {
    int64_t v25 = 0;
    LOBYTE(v40) = 0;
    char v53 = 0;
  }
  LOBYTE(v27) = 0;
  uint64_t v6 = sub_1CCDF19C4(a2, v16, v17, v22, (unint64_t)v25, &v27);
  if ((_BYTE)v27) {
    llvm::LPPassManager::markLoopAsDeleted(a3, a2);
  }
  if (v53)
  {
    sub_1CD3C5048((uint64_t)&v51, v52[0]);
    if (v48 != v50) {
      free(v48);
    }
    if (v44 != v43) {
      free(v44);
    }
    sub_1CC0BD0FC(v41);
    char v53 = 0;
  }
  return v6;
}

uint64_t sub_1CCDF5E90()
{
  char v1 = 1;
  BOOL v2 = &v1;
  sub_1CD773968(&v2);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, qword_1EBCF4FC8, &dword_1CB82C000);
}

llvm::raw_ostream *sub_1CCDF5EE8(llvm *a1)
{
  BOOL v2 = (llvm::raw_ostream *)llvm::errs(a1);
  uint64_t v3 = v2;
  uint64_t v4 = *((void *)v2 + 4);
  if ((unint64_t)(*((void *)v2 + 3) - v4) > 8)
  {
    *(unsigned char *)(v4 + 8) = 61;
    *(void *)uint64_t v4 = *(void *)"[NumUses=";
    *((void *)v2 + 4) += 9;
  }
  else
  {
    llvm::raw_ostream::write(v2, "[NumUses=", 9uLL);
  }
  unint64_t v5 = *(void *)a1;
  if (*(void *)a1)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)((v5 >> 1) & ~(-1 << (v5 >> 58))));
    v12.i16[0] = vaddlv_u8(v12);
    unsigned __int32 v7 = v12.i32[0];
  }
  else
  {
    uint64_t v6 = *(unsigned int *)(v5 + 8);
    if (v6)
    {
      unsigned __int32 v7 = 0;
      uint64_t v8 = *(int8x8_t **)v5;
      uint64_t v9 = 8 * v6;
      do
      {
        int8x8_t v10 = *v8++;
        uint8x8_t v11 = (uint8x8_t)vcnt_s8(v10);
        v11.i16[0] = vaddlv_u8(v11);
        v7 += v11.i32[0];
        v9 -= 8;
      }
      while (v9);
    }
    else
    {
      unsigned __int32 v7 = 0;
    }
  }
  uint64_t v13 = sub_1CD098D14(v3, v7, 0, 0, 0);
  uint64_t v14 = (unsigned char *)*((void *)v3 + 4);
  if ((unint64_t)v14 >= *((void *)v3 + 3))
  {
    uint64_t v13 = llvm::raw_ostream::write(v3, 93);
  }
  else
  {
    *((void *)v3 + 4) = v14 + 1;
    *uint64_t v14 = 93;
  }
  uint64_t result = (llvm::raw_ostream *)llvm::errs(v13);
  int v16 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v16 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v16 + 1;
    *int v16 = 10;
  }
  return result;
}

llvm::raw_ostream *sub_1CCDF6048(llvm *a1)
{
  BOOL v2 = (llvm::raw_ostream *)llvm::errs(a1);
  uint64_t v3 = sub_1CCDF60B8((uint64_t)a1, v2);
  uint64_t result = (llvm::raw_ostream *)llvm::errs(v3);
  unint64_t v5 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v5 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v5 + 1;
    *unint64_t v5 = 10;
  }
  return result;
}

llvm::Value *sub_1CCDF60B8(uint64_t a1, llvm::raw_ostream *a2)
{
  uint64_t result = *(llvm::Value **)a1;
  if (result)
  {
    uint64_t result = (llvm::Value *)llvm::Value::printAsOperand(result, a2, 0, 0);
    unint64_t v5 = (unint64_t *)(a1 + 8);
    uint64_t v6 = *(void *)(a1 + 8);
    if (v6)
    {
      uint64_t v27 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v27) > 2)
      {
        *(unsigned char *)(v27 + 2) = 32;
        *(_WORD *)uint64_t v27 = 11040;
        *((void *)a2 + 4) += 3;
      }
      else
      {
        llvm::raw_ostream::write(a2, " + ", 3uLL);
      }
      goto LABEL_3;
    }
  }
  else
  {
    unint64_t v5 = (unint64_t *)(a1 + 8);
    if (*(void *)(a1 + 8))
    {
LABEL_3:
      uint64_t result = llvm::raw_ostream::operator<<(a2, *v5);
      LOBYTE(v6) = 0;
      goto LABEL_5;
    }
    LOBYTE(v6) = 1;
  }
LABEL_5:
  uint64_t v7 = *(unsigned int *)(a1 + 40);
  if (v7)
  {
    uint64_t v8 = 8 * v7;
    uint64_t v9 = *(llvm::SCEV ***)(a1 + 32);
    do
    {
      int8x8_t v10 = *v9;
      uint64_t v11 = *((void *)a2 + 4);
      if ((v6 & 1) == 0)
      {
        if ((unint64_t)(*((void *)a2 + 3) - v11) > 2)
        {
          *(unsigned char *)(v11 + 2) = 32;
          *(_WORD *)uint64_t v11 = 11040;
          uint64_t v11 = *((void *)a2 + 4) + 3;
          *((void *)a2 + 4) = v11;
        }
        else
        {
          llvm::raw_ostream::write(a2, " + ", 3uLL);
          uint64_t v11 = *((void *)a2 + 4);
        }
      }
      if ((unint64_t)(*((void *)a2 + 3) - v11) > 3)
      {
        *(_DWORD *)uint64_t v11 = 677864818;
        *((void *)a2 + 4) += 4;
      }
      else
      {
        llvm::raw_ostream::write(a2, "reg(", 4uLL);
      }
      uint64_t result = llvm::SCEV::print(v10, a2);
      uint8x8_t v12 = (unsigned char *)*((void *)a2 + 4);
      if ((unint64_t)v12 >= *((void *)a2 + 3))
      {
        uint64_t result = llvm::raw_ostream::write(a2, 41);
      }
      else
      {
        *((void *)a2 + 4) = v12 + 1;
        unsigned char *v12 = 41;
      }
      LOBYTE(v6) = 0;
      ++v9;
      v8 -= 8;
    }
    while (v8);
    LOBYTE(v6) = 0;
    LODWORD(v7) = *(_DWORD *)(a1 + 40);
  }
  if (*(unsigned char *)(a1 + 16))
  {
    if (v7) {
      goto LABEL_33;
    }
    if ((v6 & 1) == 0)
    {
      uint64_t v13 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v13) > 2)
      {
        *(unsigned char *)(v13 + 2) = 32;
        *(_WORD *)uint64_t v13 = 11040;
        *((void *)a2 + 4) += 3;
      }
      else
      {
        uint64_t result = llvm::raw_ostream::write(a2, " + ", 3uLL);
      }
    }
    uint64_t v14 = (void *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v14 <= 0x14uLL)
    {
      uint64_t v15 = "**error: HasBaseReg**";
      int v16 = a2;
      size_t v17 = 21;
LABEL_32:
      uint64_t result = llvm::raw_ostream::write(v16, v15, v17);
      LOBYTE(v6) = 0;
      goto LABEL_33;
    }
    LOBYTE(v6) = 0;
    qmemcpy(v14, "**error: HasBaseReg**", 21);
    uint64_t v28 = *((void *)a2 + 4) + 21;
  }
  else
  {
    if (!v7) {
      goto LABEL_33;
    }
    if ((v6 & 1) == 0)
    {
      uint64_t v18 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v18) > 2)
      {
        *(unsigned char *)(v18 + 2) = 32;
        *(_WORD *)uint64_t v18 = 11040;
        *((void *)a2 + 4) += 3;
      }
      else
      {
        uint64_t result = llvm::raw_ostream::write(a2, " + ", 3uLL);
      }
    }
    uint64_t v19 = (void *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v19 <= 0x15uLL)
    {
      uint64_t v15 = "**error: !HasBaseReg**";
      int v16 = a2;
      size_t v17 = 22;
      goto LABEL_32;
    }
    LOBYTE(v6) = 0;
    qmemcpy(v19, "**error: !HasBaseReg**", 22);
    uint64_t v28 = *((void *)a2 + 4) + 22;
  }
  *((void *)a2 + 4) = v28;
LABEL_33:
  if (*(void *)(a1 + 24))
  {
    if ((v6 & 1) == 0)
    {
      uint64_t v20 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v20) > 2)
      {
        *(unsigned char *)(v20 + 2) = 32;
        *(_WORD *)uint64_t v20 = 11040;
        *((void *)a2 + 4) += 3;
      }
      else
      {
        llvm::raw_ostream::write(a2, " + ", 3uLL);
      }
    }
    llvm::raw_ostream::operator<<(a2, *(void *)(a1 + 24));
    uint64_t v21 = *((void *)a2 + 4);
    if ((unint64_t)(*((void *)a2 + 3) - v21) > 4)
    {
      *(unsigned char *)(v21 + 4) = 40;
      *(_DWORD *)uint64_t v21 = 1734701610;
      *((void *)a2 + 4) += 5;
    }
    else
    {
      llvm::raw_ostream::write(a2, "*reg(", 5uLL);
    }
    uint64_t result = *(llvm::Value **)(a1 + 80);
    if (result)
    {
      uint64_t result = llvm::SCEV::print(result, a2);
    }
    else
    {
      uint64_t v22 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v22) > 8)
      {
        *(unsigned char *)(v22 + 8) = 62;
        *(void *)uint64_t v22 = *(void *)"<unknown>";
        *((void *)a2 + 4) += 9;
      }
      else
      {
        uint64_t result = llvm::raw_ostream::write(a2, "<unknown>", 9uLL);
      }
    }
    uint64_t v23 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v23 >= *((void *)a2 + 3))
    {
      uint64_t result = llvm::raw_ostream::write(a2, 41);
      LOBYTE(v6) = 0;
    }
    else
    {
      LOBYTE(v6) = 0;
      *((void *)a2 + 4) = v23 + 1;
      *uint64_t v23 = 41;
    }
  }
  if (*(void *)(a1 + 88))
  {
    if ((v6 & 1) == 0)
    {
      uint64_t v24 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v24) > 2)
      {
        *(unsigned char *)(v24 + 2) = 32;
        *(_WORD *)uint64_t v24 = 11040;
        *((void *)a2 + 4) += 3;
      }
      else
      {
        llvm::raw_ostream::write(a2, " + ", 3uLL);
      }
    }
    int64_t v25 = (_DWORD *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v25 > 3uLL)
    {
      _DWORD *v25 = 678260073;
      *((void *)a2 + 4) += 4;
    }
    else
    {
      llvm::raw_ostream::write(a2, "imm(", 4uLL);
    }
    uint64_t result = llvm::raw_ostream::operator<<(a2, *(void *)(a1 + 88));
    uint64_t v26 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v26 >= *((void *)a2 + 3))
    {
      return llvm::raw_ostream::write(a2, 41);
    }
    else
    {
      *((void *)a2 + 4) = v26 + 1;
      *uint64_t v26 = 41;
    }
  }
  return result;
}

llvm::raw_ostream *sub_1CCDF65F0(unsigned int *a1)
{
  BOOL v2 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
  uint64_t v3 = v2;
  if (byte_1EBCF51E8)
  {
    sub_1CD098D14(v2, a1[6], 0, 0, 0);
    uint64_t v4 = *((void *)v3 + 4);
    if ((unint64_t)(*((void *)v3 + 3) - v4) > 0xB)
    {
      *(_DWORD *)(v4 + 8) = 1852795252;
      *(void *)uint64_t v4 = *(void *)" instruction";
      unint64_t v5 = (void *)(*((void *)v3 + 4) + 12);
      *((void *)v3 + 4) = v5;
    }
    else
    {
      llvm::raw_ostream::write(v3, " instruction", 0xCuLL);
      unint64_t v5 = (void *)*((void *)v3 + 4);
    }
    unsigned int v6 = a1[6];
    if (v6 == 1) {
      uint64_t v7 = " ";
    }
    else {
      uint64_t v7 = "s ";
    }
    if (v6 == 1) {
      size_t v8 = 1;
    }
    else {
      size_t v8 = 2;
    }
    if (v8 <= *((void *)v3 + 3) - (void)v5)
    {
      memcpy(v5, v7, v8);
      *((void *)v3 + 4) += v8;
    }
    else
    {
      llvm::raw_ostream::write(v3, v7, v8);
    }
  }
  sub_1CD098D14(v3, a1[7], 0, 0, 0);
  uint64_t v9 = (_DWORD *)*((void *)v3 + 4);
  if (*((void *)v3 + 3) - (void)v9 > 3uLL)
  {
    *uint64_t v9 = 1734701600;
    int8x8_t v10 = (void *)(*((void *)v3 + 4) + 4);
    *((void *)v3 + 4) = v10;
  }
  else
  {
    llvm::raw_ostream::write(v3, " reg", 4uLL);
    int8x8_t v10 = (void *)*((void *)v3 + 4);
  }
  unsigned int v11 = a1[7];
  unint64_t v12 = v11 != 1;
  if (*((void *)v3 + 3) - (void)v10 >= v12)
  {
    if (v11 != 1)
    {
      int8x8_t v10 = memcpy(v10, "s", v11 != 1);
      *((void *)v3 + 4) += v12;
    }
  }
  else
  {
    if (v11 == 1) {
      uint64_t v13 = "";
    }
    else {
      uint64_t v13 = "s";
    }
    int8x8_t v10 = llvm::raw_ostream::write(v3, v13, v11 != 1);
  }
  if (a1[8])
  {
    uint64_t v14 = *((void *)v3 + 4);
    if ((unint64_t)(*((void *)v3 + 3) - v14) > 0x12)
    {
      *(_DWORD *)(v14 + 15) = 544502639;
      *(_OWORD *)uint64_t v14 = *(_OWORD *)", with addrec cost ";
      *((void *)v3 + 4) += 19;
    }
    else
    {
      llvm::raw_ostream::write(v3, ", with addrec cost ", 0x13uLL);
    }
    int8x8_t v10 = sub_1CD098D14(v3, a1[8], 0, 0, 0);
  }
  if (a1[9])
  {
    uint64_t v15 = (_DWORD *)*((void *)v3 + 4);
    if (*((void *)v3 + 3) - (void)v15 > 6uLL)
    {
      *(_DWORD *)((char *)v15 + 3) = 544437612;
      *uint64_t v15 = 1819287596;
      *((void *)v3 + 4) += 7;
    }
    else
    {
      llvm::raw_ostream::write(v3, ", plus ", 7uLL);
    }
    sub_1CD098D14(v3, a1[9], 0, 0, 0);
    int v16 = (_DWORD *)*((void *)v3 + 4);
    if (*((void *)v3 + 3) - (void)v16 > 6uLL)
    {
      *(_DWORD *)((char *)v16 + 3) = 1819634976;
      *int v16 = 542525728;
      int8x8_t v10 = (void *)(*((void *)v3 + 4) + 7);
      *((void *)v3 + 4) = v10;
    }
    else
    {
      llvm::raw_ostream::write(v3, " IV mul", 7uLL);
      int8x8_t v10 = (void *)*((void *)v3 + 4);
    }
    unsigned int v17 = a1[9];
    unint64_t v18 = v17 != 1;
    if (*((void *)v3 + 3) - (void)v10 >= v18)
    {
      if (v17 != 1)
      {
        int8x8_t v10 = memcpy(v10, "s", v17 != 1);
        *((void *)v3 + 4) += v18;
      }
    }
    else
    {
      if (v17 == 1) {
        uint64_t v19 = "";
      }
      else {
        uint64_t v19 = "s";
      }
      int8x8_t v10 = llvm::raw_ostream::write(v3, v19, v17 != 1);
    }
  }
  if (a1[10])
  {
    uint64_t v20 = (_DWORD *)*((void *)v3 + 4);
    if (*((void *)v3 + 3) - (void)v20 > 6uLL)
    {
      *(_DWORD *)((char *)v20 + 3) = 544437612;
      *uint64_t v20 = 1819287596;
      *((void *)v3 + 4) += 7;
    }
    else
    {
      llvm::raw_ostream::write(v3, ", plus ", 7uLL);
    }
    sub_1CD098D14(v3, a1[10], 0, 0, 0);
    uint64_t v21 = *((void *)v3 + 4);
    if ((unint64_t)(*((void *)v3 + 3) - v21) > 8)
    {
      *(unsigned char *)(v21 + 8) = 100;
      *(void *)uint64_t v21 = *(void *)" base add";
      int8x8_t v10 = (void *)(*((void *)v3 + 4) + 9);
      *((void *)v3 + 4) = v10;
    }
    else
    {
      llvm::raw_ostream::write(v3, " base add", 9uLL);
      int8x8_t v10 = (void *)*((void *)v3 + 4);
    }
    unsigned int v22 = a1[10];
    unint64_t v23 = v22 != 1;
    if (*((void *)v3 + 3) - (void)v10 >= v23)
    {
      if (v22 != 1)
      {
        int8x8_t v10 = memcpy(v10, "s", v22 != 1);
        *((void *)v3 + 4) += v23;
      }
    }
    else
    {
      if (v22 == 1) {
        uint64_t v24 = "";
      }
      else {
        uint64_t v24 = "s";
      }
      int8x8_t v10 = llvm::raw_ostream::write(v3, v24, v22 != 1);
    }
  }
  if (a1[13])
  {
    int64_t v25 = (_DWORD *)*((void *)v3 + 4);
    if (*((void *)v3 + 3) - (void)v25 > 6uLL)
    {
      *(_DWORD *)((char *)v25 + 3) = 544437612;
      _DWORD *v25 = 1819287596;
      *((void *)v3 + 4) += 7;
    }
    else
    {
      llvm::raw_ostream::write(v3, ", plus ", 7uLL);
    }
    int8x8_t v10 = sub_1CD098D14(v3, a1[13], 0, 0, 0);
    uint64_t v26 = *((void *)v3 + 4);
    if ((unint64_t)(*((void *)v3 + 3) - v26) > 0xA)
    {
      *(_DWORD *)(v26 + 7) = 1953722211;
      *(void *)uint64_t v26 = *(void *)" scale cost";
      *((void *)v3 + 4) += 11;
    }
    else
    {
      int8x8_t v10 = llvm::raw_ostream::write(v3, " scale cost", 0xBuLL);
    }
  }
  if (a1[11])
  {
    uint64_t v27 = (_DWORD *)*((void *)v3 + 4);
    if (*((void *)v3 + 3) - (void)v27 > 6uLL)
    {
      *(_DWORD *)((char *)v27 + 3) = 544437612;
      *uint64_t v27 = 1819287596;
      *((void *)v3 + 4) += 7;
    }
    else
    {
      llvm::raw_ostream::write(v3, ", plus ", 7uLL);
    }
    int8x8_t v10 = sub_1CD098D14(v3, a1[11], 0, 0, 0);
    uint64_t v28 = *((void *)v3 + 4);
    if ((unint64_t)(*((void *)v3 + 3) - v28) > 8)
    {
      *(unsigned char *)(v28 + 8) = 116;
      *(void *)uint64_t v28 = *(void *)" imm cost";
      *((void *)v3 + 4) += 9;
    }
    else
    {
      int8x8_t v10 = llvm::raw_ostream::write(v3, " imm cost", 9uLL);
    }
  }
  if (a1[12])
  {
    uint64_t v29 = (_DWORD *)*((void *)v3 + 4);
    if (*((void *)v3 + 3) - (void)v29 > 6uLL)
    {
      *(_DWORD *)((char *)v29 + 3) = 544437612;
      _DWORD *v29 = 1819287596;
      *((void *)v3 + 4) += 7;
    }
    else
    {
      llvm::raw_ostream::write(v3, ", plus ", 7uLL);
    }
    int8x8_t v10 = sub_1CD098D14(v3, a1[12], 0, 0, 0);
    uint64_t v30 = *((void *)v3 + 4);
    if ((unint64_t)(*((void *)v3 + 3) - v30) > 0xA)
    {
      *(_DWORD *)(v30 + 7) = 1953722211;
      *(void *)uint64_t v30 = *(void *)" setup cost";
      *((void *)v3 + 4) += 11;
    }
    else
    {
      int8x8_t v10 = llvm::raw_ostream::write(v3, " setup cost", 0xBuLL);
    }
  }
  uint64_t result = (llvm::raw_ostream *)llvm::errs((llvm *)v10);
  uint64_t v32 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v32 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v32 + 1;
    unsigned char *v32 = 10;
  }
  return result;
}

llvm::raw_ostream *sub_1CCDF6CD0(llvm *a1)
{
  BOOL v2 = (llvm::raw_ostream *)llvm::errs(a1);
  uint64_t v3 = sub_1CCDF6D40((llvm::Value **)a1, v2);
  uint64_t result = (llvm::raw_ostream *)llvm::errs(v3);
  unint64_t v5 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v5 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v5 + 1;
    *unint64_t v5 = 10;
  }
  return result;
}

llvm::raw_ostream *sub_1CCDF6D40(llvm::Value **a1, llvm::raw_ostream *this)
{
  uint64_t v4 = *((void *)this + 4);
  if ((unint64_t)(*((void *)this + 3) - v4) > 8)
  {
    *(unsigned char *)(v4 + 8) = 61;
    *(void *)uint64_t v4 = *(void *)"UserInst=";
    *((void *)this + 4) += 9;
  }
  else
  {
    llvm::raw_ostream::write(this, "UserInst=", 9uLL);
  }
  unint64_t v5 = *a1;
  int v6 = *((unsigned __int8 *)*a1 + 16);
  if (*a1 && v6 == 61)
  {
    uint64_t v7 = *((void *)this + 4);
    if ((unint64_t)(*((void *)this + 3) - v7) > 5)
    {
      *(_WORD *)(v7 + 4) = 8293;
      *(_DWORD *)uint64_t v7 = 1919906931;
      *((void *)this + 4) += 6;
    }
    else
    {
      llvm::raw_ostream::write(this, "store ", 6uLL);
    }
    size_t v8 = (llvm::Value *)*((void *)v5 - 8);
    goto LABEL_12;
  }
  if (*(unsigned char *)(*(void *)v5 + 8) != 7)
  {
    size_t v8 = *a1;
LABEL_12:
    llvm::Value::printAsOperand(v8, this, 0, 0);
    goto LABEL_13;
  }
  OpcodeName = llvm::Instruction::getOpcodeName((llvm::Instruction *)(v6 - 28));
  size_t v10 = strlen(OpcodeName);
  unsigned int v11 = (void *)*((void *)this + 4);
  if (v10 <= *((void *)this + 3) - (void)v11)
  {
    if (v10)
    {
      memcpy(v11, OpcodeName, v10);
      *((void *)this + 4) += v10;
    }
  }
  else
  {
    llvm::raw_ostream::write(this, OpcodeName, v10);
  }
LABEL_13:
  unint64_t v12 = (void *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v12 > 0x15uLL)
  {
    qmemcpy(v12, ", OperandValToReplace=", 22);
    *((void *)this + 4) += 22;
  }
  else
  {
    llvm::raw_ostream::write(this, ", OperandValToReplace=", 0x16uLL);
  }
  uint64_t result = (llvm::raw_ostream *)llvm::Value::printAsOperand(a1[1], this, 0, 0);
  uint64_t v14 = a1[3];
  uint64_t v15 = 32;
  if (v14 == a1[2]) {
    uint64_t v15 = 36;
  }
  uint64_t v16 = *(unsigned int *)((char *)a1 + v15);
  if (v16)
  {
    uint64_t v17 = 8 * v16;
    unint64_t v18 = (unint64_t *)a1[3];
    while (*v18 >= 0xFFFFFFFFFFFFFFFELL)
    {
      ++v18;
      v17 -= 8;
      if (!v17) {
        goto LABEL_32;
      }
    }
  }
  else
  {
    unint64_t v18 = (unint64_t *)a1[3];
  }
  uint64_t v19 = (unint64_t *)((char *)v14 + 8 * v16);
  if (v18 != v19)
  {
    unint64_t v20 = *v18;
LABEL_25:
    uint64_t v21 = (void *)*((void *)this + 4);
    if (*((void *)this + 3) - (void)v21 > 0xDuLL)
    {
      qmemcpy(v21, ", PostIncLoop=", 14);
      *((void *)this + 4) += 14;
    }
    else
    {
      llvm::raw_ostream::write(this, ", PostIncLoop=", 0xEuLL);
    }
    uint64_t result = (llvm::raw_ostream *)llvm::Value::printAsOperand(**(llvm::Value ***)(v20 + 32), this, 0, 0);
    unsigned int v22 = v18 + 1;
    while (v22 != v19)
    {
      unint64_t v23 = *v22++;
      unint64_t v20 = v23;
      if (v23 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        unint64_t v18 = v22 - 1;
        goto LABEL_25;
      }
    }
  }
LABEL_32:
  if (a1[8])
  {
    uint64_t v24 = *((void *)this + 4);
    if ((unint64_t)(*((void *)this + 3) - v24) > 8)
    {
      *(unsigned char *)(v24 + 8) = 61;
      *(void *)uint64_t v24 = *(void *)", Offset=";
      *((void *)this + 4) += 9;
    }
    else
    {
      llvm::raw_ostream::write(this, ", Offset=", 9uLL);
    }
    unint64_t v25 = (unint64_t)a1[8];
    return llvm::raw_ostream::operator<<(this, v25);
  }
  return result;
}

llvm::raw_ostream *sub_1CCDF7054(llvm *a1)
{
  BOOL v2 = (llvm::raw_ostream *)llvm::errs(a1);
  uint64_t v3 = sub_1CCDF70C4(a1, v2);
  uint64_t result = (llvm::raw_ostream *)llvm::errs(v3);
  unint64_t v5 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v5 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v5 + 1;
    *unint64_t v5 = 10;
  }
  return result;
}

llvm::raw_ostream *sub_1CCDF70C4(llvm::raw_ostream *result, llvm::raw_ostream *this)
{
  uint64_t v3 = (uint64_t)result;
  uint64_t v4 = (void *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v4 > 0xDuLL)
  {
    qmemcpy(v4, "LSR Use: Kind=", 14);
    *((void *)this + 4) += 14;
  }
  else
  {
    uint64_t result = llvm::raw_ostream::write(this, "LSR Use: Kind=", 0xEuLL);
  }
  switch(*(_DWORD *)(v3 + 24))
  {
    case 0:
      uint64_t v5 = *((void *)this + 4);
      if ((unint64_t)(*((void *)this + 3) - v5) <= 4)
      {
        int v6 = "Basic";
        uint64_t v7 = this;
        size_t v8 = 5;
        goto LABEL_15;
      }
      *(unsigned char *)(v5 + 4) = 99;
      *(_DWORD *)uint64_t v5 = 1769169218;
      uint64_t v27 = *((void *)this + 4) + 5;
      goto LABEL_52;
    case 1:
      uint64_t v9 = (_DWORD *)*((void *)this + 4);
      if (*((void *)this + 3) - (void)v9 <= 6uLL)
      {
        int v6 = "Special";
        uint64_t v7 = this;
        size_t v8 = 7;
        goto LABEL_15;
      }
      *(_DWORD *)((char *)v9 + 3) = 1818323299;
      *uint64_t v9 = 1667592275;
      uint64_t v27 = *((void *)this + 4) + 7;
      goto LABEL_52;
    case 2:
      uint64_t v10 = *((void *)this + 4);
      if ((unint64_t)(*((void *)this + 3) - v10) > 0xA)
      {
        *(_DWORD *)(v10 + 7) = 543584032;
        *(void *)uint64_t v10 = *(void *)"Address of ";
        *((void *)this + 4) += 11;
      }
      else
      {
        llvm::raw_ostream::write(this, "Address of ", 0xBuLL);
      }
      unsigned int v11 = *(llvm::Type **)(v3 + 32);
      if (*((unsigned char *)v11 + 8) == 15)
      {
        unint64_t v12 = (_DWORD *)*((void *)this + 4);
        if (*((void *)this + 3) - (void)v12 > 6uLL)
        {
          *(_DWORD *)((char *)v12 + 3) = 1919251566;
          _DWORD *v12 = 1852403568;
          *((void *)this + 4) += 7;
        }
        else
        {
          llvm::raw_ostream::write(this, "pointer", 7uLL);
        }
      }
      else
      {
        llvm::Type::print(v11, this, 0, 0);
      }
      unint64_t v25 = (void *)*((void *)this + 4);
      if (*((void *)this + 3) - (void)v25 > 0xDuLL)
      {
        qmemcpy(v25, " in addrspace(", 14);
        *((void *)this + 4) += 14;
      }
      else
      {
        llvm::raw_ostream::write(this, " in addrspace(", 0xEuLL);
      }
      uint64_t result = sub_1CD098D14(this, *(unsigned int *)(v3 + 40), 0, 0, 0);
      uint64_t v26 = (unsigned char *)*((void *)this + 4);
      if ((unint64_t)v26 >= *((void *)this + 3))
      {
        uint64_t result = llvm::raw_ostream::write(this, 41);
      }
      else
      {
        *((void *)this + 4) = v26 + 1;
        *uint64_t v26 = 41;
      }
      goto LABEL_16;
    case 3:
      uint64_t v13 = (void *)*((void *)this + 4);
      if (*((void *)this + 3) - (void)v13 > 7uLL)
      {
        *uint64_t v13 = 0x6F72655A706D4349;
        uint64_t v27 = *((void *)this + 4) + 8;
LABEL_52:
        *((void *)this + 4) = v27;
      }
      else
      {
        int v6 = "ICmpZero";
        uint64_t v7 = this;
        size_t v8 = 8;
LABEL_15:
        uint64_t result = llvm::raw_ostream::write(v7, v6, v8);
      }
LABEL_16:
      uint64_t v14 = *((void *)this + 4);
      if ((unint64_t)(*((void *)this + 3) - v14) > 0xA)
      {
        *(_DWORD *)(v14 + 7) = 2067624820;
        *(void *)uint64_t v14 = *(void *)", Offsets={";
        *((void *)this + 4) += 11;
      }
      else
      {
        uint64_t result = llvm::raw_ostream::write(this, ", Offsets={", 0xBuLL);
      }
      uint64_t v15 = *(unsigned int *)(v3 + 56);
      if (v15)
      {
        char v16 = 0;
        uint64_t v17 = 72 * v15;
        unint64_t v18 = (unint64_t *)(*(void *)(v3 + 48) + 64);
        do
        {
          if (v16)
          {
            uint64_t v19 = (unsigned char *)*((void *)this + 4);
            if ((unint64_t)v19 >= *((void *)this + 3))
            {
              llvm::raw_ostream::write(this, 44);
            }
            else
            {
              *((void *)this + 4) = v19 + 1;
              *uint64_t v19 = 44;
            }
          }
          unint64_t v20 = *v18;
          v18 += 9;
          uint64_t result = llvm::raw_ostream::operator<<(this, v20);
          char v16 = 1;
          v17 -= 72;
        }
        while (v17);
      }
      uint64_t v21 = (unsigned char *)*((void *)this + 4);
      if ((unint64_t)v21 >= *((void *)this + 3))
      {
        uint64_t result = llvm::raw_ostream::write(this, 125);
      }
      else
      {
        *((void *)this + 4) = v21 + 1;
        *uint64_t v21 = 125;
      }
      if (*(unsigned char *)(v3 + 656))
      {
        unsigned int v22 = (void *)*((void *)this + 4);
        if (*((void *)this + 3) - (void)v22 > 0x18uLL)
        {
          qmemcpy(v22, ", all-fixups-outside-loop", 25);
          *((void *)this + 4) += 25;
        }
        else
        {
          uint64_t result = llvm::raw_ostream::write(this, ", all-fixups-outside-loop", 0x19uLL);
        }
      }
      if (*(void *)(v3 + 664))
      {
        unint64_t v23 = (void *)*((void *)this + 4);
        if (*((void *)this + 3) - (void)v23 > 0x14uLL)
        {
          qmemcpy(v23, ", widest fixup type: ", 21);
          *((void *)this + 4) += 21;
        }
        else
        {
          llvm::raw_ostream::write(this, ", widest fixup type: ", 0x15uLL);
        }
        uint64_t v24 = *(llvm::Type **)(v3 + 664);
        return (llvm::raw_ostream *)llvm::Type::print(v24, this, 0, 0);
      }
      return result;
    default:
      goto LABEL_16;
  }
}

llvm::raw_ostream *sub_1CCDF7564(uint64_t a1)
{
  BOOL v2 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
  uint64_t v3 = v2;
  uint64_t v4 = (void *)*((void *)v2 + 4);
  if (*((void *)v2 + 3) - (void)v4 > 0x17uLL)
  {
    qmemcpy(v4, "in formulae referencing ", 24);
    *((void *)v2 + 4) += 24;
  }
  else
  {
    llvm::raw_ostream::write(v2, "in formulae referencing ", 0x18uLL);
  }
  llvm::SCEV::print(*(llvm::SCEV **)(a1 + 16), v3);
  uint64_t v5 = (void *)*((void *)v3 + 4);
  if (*((void *)v3 + 3) - (void)v5 > 7uLL)
  {
    *uint64_t v5 = 0x20657375206E6920;
    *((void *)v3 + 4) += 8;
  }
  else
  {
    llvm::raw_ostream::write(v3, " in use ", 8uLL);
  }
  sub_1CD098D14(v3, *(void *)a1, 0, 0, 0);
  int v6 = (void *)*((void *)v3 + 4);
  if (*((void *)v3 + 3) - (void)v6 > 0xDuLL)
  {
    qmemcpy(v6, " , add offset ", 14);
    *((void *)v3 + 4) += 14;
  }
  else
  {
    llvm::raw_ostream::write(v3, " , add offset ", 0xEuLL);
  }
  uint64_t v7 = llvm::raw_ostream::operator<<(v3, *(void *)(a1 + 8));
  uint64_t result = (llvm::raw_ostream *)llvm::errs(v7);
  uint64_t v9 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v9 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v9 + 1;
    *uint64_t v9 = 10;
  }
  return result;
}

llvm::raw_ostream *sub_1CCDF76DC(uint64_t a1)
{
  BOOL v2 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
  uint64_t v3 = v2;
  if (*(_DWORD *)(a1 + 200) || *(_DWORD *)(a1 + 320))
  {
    uint64_t v4 = (void *)*((void *)v2 + 4);
    if (*((void *)v2 + 3) - (void)v4 > 0x3FuLL)
    {
      qmemcpy(v4, "LSR has identified the following interesting factors and types: ", 64);
      *((void *)v2 + 4) += 64;
    }
    else
    {
      BOOL v2 = llvm::raw_ostream::write(v2, "LSR has identified the following interesting factors and types: ", 0x40uLL);
    }
    uint64_t v5 = *(unsigned int *)(a1 + 200);
    BOOL v6 = *(_DWORD *)(a1 + 200) == 0;
    if (v5)
    {
      uint64_t v7 = *(unint64_t **)(a1 + 192);
      uint64_t v8 = 8 * v5;
      char v9 = 1;
      do
      {
        unint64_t v10 = *v7;
        unsigned int v11 = (_WORD *)*((void *)v3 + 4);
        if ((v9 & 1) == 0)
        {
          if (*((void *)v3 + 3) - (void)v11 > 1uLL)
          {
            *unsigned int v11 = 8236;
            unsigned int v11 = (_WORD *)(*((void *)v3 + 4) + 2);
            *((void *)v3 + 4) = v11;
          }
          else
          {
            llvm::raw_ostream::write(v3, ", ", 2uLL);
            unsigned int v11 = (_WORD *)*((void *)v3 + 4);
          }
        }
        if ((unint64_t)v11 >= *((void *)v3 + 3))
        {
          llvm::raw_ostream::write(v3, 42);
        }
        else
        {
          *((void *)v3 + 4) = (char *)v11 + 1;
          *(unsigned char *)unsigned int v11 = 42;
        }
        BOOL v2 = llvm::raw_ostream::operator<<(v3, v10);
        char v9 = 0;
        ++v7;
        v8 -= 8;
      }
      while (v8);
    }
    uint64_t v12 = *(unsigned int *)(a1 + 320);
    if (v12)
    {
      uint64_t v13 = *(llvm::Type ***)(a1 + 312);
      uint64_t v14 = 8 * v12;
      do
      {
        uint64_t v15 = *v13;
        char v16 = (_WORD *)*((void *)v3 + 4);
        if (!v6)
        {
          if (*((void *)v3 + 3) - (void)v16 > 1uLL)
          {
            *char v16 = 8236;
            char v16 = (_WORD *)(*((void *)v3 + 4) + 2);
            *((void *)v3 + 4) = v16;
          }
          else
          {
            llvm::raw_ostream::write(v3, ", ", 2uLL);
            char v16 = (_WORD *)*((void *)v3 + 4);
          }
        }
        if ((unint64_t)v16 >= *((void *)v3 + 3))
        {
          llvm::raw_ostream::write(v3, 40);
        }
        else
        {
          *((void *)v3 + 4) = (char *)v16 + 1;
          *(unsigned char *)char v16 = 40;
        }
        BOOL v2 = (llvm::raw_ostream *)llvm::Type::print(v15, v3, 0, 0);
        uint64_t v17 = (unsigned char *)*((void *)v3 + 4);
        if ((unint64_t)v17 >= *((void *)v3 + 3))
        {
          BOOL v2 = llvm::raw_ostream::write(v3, 41);
        }
        else
        {
          *((void *)v3 + 4) = v17 + 1;
          *uint64_t v17 = 41;
        }
        BOOL v6 = 0;
        ++v13;
        v14 -= 8;
      }
      while (v14);
    }
    unint64_t v18 = (unsigned char *)*((void *)v3 + 4);
    if ((unint64_t)v18 >= *((void *)v3 + 3))
    {
      BOOL v2 = llvm::raw_ostream::write(v3, 10);
    }
    else
    {
      *((void *)v3 + 4) = v18 + 1;
      *unint64_t v18 = 10;
    }
  }
  uint64_t v19 = (void *)*((void *)v3 + 4);
  if (*((void *)v3 + 3) - (void)v19 > 0x2BuLL)
  {
    qmemcpy(v19, "LSR is examining the following fixup sites:\n", 44);
    *((void *)v3 + 4) += 44;
  }
  else
  {
    BOOL v2 = llvm::raw_ostream::write(v3, "LSR is examining the following fixup sites:\n", 0x2CuLL);
  }
  unsigned int v20 = *(_DWORD *)(a1 + 368);
  if (v20)
  {
    uint64_t v21 = *(void *)(a1 + 360);
    uint64_t v22 = v21 + 1904 * v20;
    do
    {
      uint64_t v23 = *(unsigned int *)(v21 + 56);
      if (v23)
      {
        uint64_t v24 = *(llvm::Value ***)(v21 + 48);
        uint64_t v25 = 72 * v23;
        do
        {
          uint64_t v26 = llvm::dbgs(v2);
          uint64_t v27 = (_WORD *)*((void *)v26 + 4);
          if (*((void *)v26 + 3) - (void)v27 > 1uLL)
          {
            *uint64_t v27 = 8224;
            *((void *)v26 + 4) += 2;
          }
          else
          {
            llvm::raw_ostream::write(v26, "  ", 2uLL);
          }
          BOOL v2 = sub_1CCDF6D40(v24, v3);
          uint64_t v28 = (unsigned char *)*((void *)v3 + 4);
          if ((unint64_t)v28 >= *((void *)v3 + 3))
          {
            BOOL v2 = llvm::raw_ostream::write(v3, 10);
          }
          else
          {
            *((void *)v3 + 4) = v28 + 1;
            *uint64_t v28 = 10;
          }
          v24 += 9;
          v25 -= 72;
        }
        while (v25);
      }
      v21 += 1904;
    }
    while (v21 != v22);
  }
  uint64_t v29 = (void *)*((void *)v3 + 4);
  if (*((void *)v3 + 3) - (void)v29 > 0x24uLL)
  {
    qmemcpy(v29, "LSR is examining the following uses:\n", 37);
    *((void *)v3 + 4) += 37;
  }
  else
  {
    BOOL v2 = llvm::raw_ostream::write(v3, "LSR is examining the following uses:\n", 0x25uLL);
  }
  unsigned int v30 = *(_DWORD *)(a1 + 368);
  if (v30)
  {
    uint64_t v31 = *(void *)(a1 + 360);
    uint64_t v32 = v31 + 1904 * v30;
    do
    {
      int v33 = llvm::dbgs(v2);
      char v34 = (_WORD *)*((void *)v33 + 4);
      if (*((void *)v33 + 3) - (void)v34 > 1uLL)
      {
        *char v34 = 8224;
        *((void *)v33 + 4) += 2;
      }
      else
      {
        llvm::raw_ostream::write(v33, "  ", 2uLL);
      }
      BOOL v2 = sub_1CCDF70C4((llvm::raw_ostream *)v31, v3);
      uint64_t v35 = (unsigned char *)*((void *)v3 + 4);
      if ((unint64_t)v35 >= *((void *)v3 + 3))
      {
        BOOL v2 = llvm::raw_ostream::write(v3, 10);
      }
      else
      {
        *((void *)v3 + 4) = v35 + 1;
        *uint64_t v35 = 10;
      }
      uint64_t v36 = *(unsigned int *)(v31 + 680);
      if (v36)
      {
        uint64_t v37 = *(void *)(v31 + 672);
        uint64_t v38 = 96 * v36;
        do
        {
          char v39 = (_DWORD *)*((void *)v3 + 4);
          if (*((void *)v3 + 3) - (void)v39 > 3uLL)
          {
            _DWORD *v39 = 538976288;
            *((void *)v3 + 4) += 4;
          }
          else
          {
            llvm::raw_ostream::write(v3, "    ", 4uLL);
          }
          BOOL v2 = sub_1CCDF60B8(v37, v3);
          uint64_t v40 = (unsigned char *)*((void *)v3 + 4);
          if ((unint64_t)v40 >= *((void *)v3 + 3))
          {
            BOOL v2 = llvm::raw_ostream::write(v3, 10);
          }
          else
          {
            *((void *)v3 + 4) = v40 + 1;
            unsigned char *v40 = 10;
          }
          v37 += 96;
          v38 -= 96;
        }
        while (v38);
      }
      v31 += 1904;
    }
    while (v31 != v32);
  }
  uint64_t result = (llvm::raw_ostream *)llvm::errs(v2);
  uint64_t v42 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v42 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v42 + 1;
    unsigned char *v42 = 10;
  }
  return result;
}

void sub_1CCDF7C1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9 = MEMORY[0x1F4188790](a1, a2, a3, a4);
  uint64_t v50 = v10;
  uint64_t v51 = v11;
  uint64_t v53 = v12;
  uint64_t v54 = v13;
  uint64_t v52 = v14;
  uint64_t v16 = v15;
  uint64_t v49 = v17;
  unint64_t v18 = (llvm::Loop *)v9;
  v62[16] = *MEMORY[0x1E4F143B8];
  uint64_t v60 = (long long *)v62;
  uint64_t v61 = 0x200000000;
  v57[0] = v58;
  v57[1] = 0x200000000;
  v59[1] = 0;
  v59[0] = 0;
  v58[2] = v59;
  uint64_t v19 = *(void *)(v9 + 32);
  uint64_t v20 = *(void *)(v9 + 40);
  if (v20 == v19)
  {
LABEL_50:
    if (!a9) {
      sub_1CCDF9444((uint64_t)&v55, v18, v49, v16, v53, v52, v54, v50, v51, 0);
    }
    operator new();
  }
LABEL_2:
  uint64_t v21 = *(void *)v19 + 40;
  for (uint64_t i = *(void *)(*(void *)v19 + 48); ; uint64_t i = *(void *)(i + 8))
  {
    if (i == v21)
    {
      v19 += 8;
      if (v19 == v20) {
        goto LABEL_50;
      }
      goto LABEL_2;
    }
    if (i) {
      uint64_t v23 = (llvm::DbgVariableIntrinsic *)(i - 24);
    }
    else {
      uint64_t v23 = 0;
    }
    BOOL v24 = sub_1CC27FAEC((uint64_t)v23);
    if (!v24) {
      uint64_t v23 = 0;
    }
    if (!i) {
      continue;
    }
    if (!v24) {
      continue;
    }
    if (sub_1CD773FC0(v23)) {
      continue;
    }
    uint64_t v25 = *(unsigned __int8 **)(*((void *)v23 - 4 * (*((_DWORD *)v23 + 5) & 0x7FFFFFF)) + 24);
    if (*v25 - 4 < 0x1F) {
      continue;
    }
    unint64_t v26 = *((void *)v25 + 16);
    if (!v26 || (*(_DWORD *)(*(void *)v26 + 8) & 0xFD) != 0xD) {
      continue;
    }
    uint64_t v27 = *(void *)(v16 + 104);
    unsigned int v28 = *(_DWORD *)(v16 + 120);
    if (!v28) {
      goto LABEL_22;
    }
    unsigned int v29 = ((v26 >> 4) ^ (v26 >> 9)) & (v28 - 1);
    uint64_t v30 = v27 + 48 * v29;
    uint64_t v31 = *(void *)(v30 + 24);
    if (v31 != v26) {
      break;
    }
LABEL_23:
    if (v30 == v27 + 48 * v28 || (uint64_t SCEVIter = *(const llvm::SCEV **)(v30 + 40)) == 0) {
      uint64_t SCEVIter = (const llvm::SCEV *)llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)v16, v26);
    }
    if (*((_WORD *)SCEVIter + 12) != 14
      && (llvm::ScalarEvolution::containsUndefs((llvm::ScalarEvolution *)v16, SCEVIter) & 1) == 0)
    {
      unint64_t v35 = 0;
      *(void *)&long long v55 = v23;
      uint64_t v36 = (void *)((char *)v23 - 32 * (*((_DWORD *)v23 + 5) & 0x7FFFFFF));
      *((void *)&v55 + 1) = *(void *)(v36[8] + 24);
      *(void *)&long long v56 = *(void *)(*v36 + 24);
      uint64_t v37 = *(unsigned __int8 **)(*((void *)v23 - 4 * (*((_DWORD *)v23 + 5) & 0x7FFFFFF)) + 24);
      int v38 = *v37;
      if ((v38 - 4) >= 0x1C && (v38 - 33) >= 2)
      {
        if (v38 == 32) {
          uint64_t v37 = (unsigned __int8 *)**((void **)v37 + 3);
        }
        unint64_t v35 = *((void *)v37 + 16);
      }
      uint64_t v39 = *(void *)(v16 + 104);
      unsigned int v40 = *(_DWORD *)(v16 + 120);
      if (!v40) {
        goto LABEL_39;
      }
      unsigned int v41 = ((v35 >> 4) ^ (v35 >> 9)) & (v40 - 1);
      uint64_t v42 = v39 + 48 * v41;
      uint64_t v43 = *(void *)(v42 + 24);
      if (v43 != v35)
      {
        int v44 = 1;
        while (v43 != -4096)
        {
          unsigned int v45 = v41 + v44++;
          unsigned int v41 = v45 & (v40 - 1);
          uint64_t v42 = v39 + 48 * v41;
          uint64_t v43 = *(void *)(v42 + 24);
          if (v43 == v35) {
            goto LABEL_40;
          }
        }
LABEL_39:
        uint64_t v42 = v39 + 48 * v40;
      }
LABEL_40:
      if (v42 == v39 + 48 * v40 || (uint64_t v46 = *(void *)(v42 + 40)) == 0) {
        uint64_t v46 = llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)v16, v35);
      }
      *((void *)&v56 + 1) = v46;
      if (v61 >= HIDWORD(v61))
      {
        if (v60 <= &v55 && &v60[2 * v61] > &v55) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v47 = &v60[2 * v61];
      long long v48 = v56;
      *uint64_t v47 = v55;
      v47[1] = v48;
      LODWORD(v61) = v61 + 1;
      *(void *)&long long v55 = v23;
      sub_1CD50FA08((uint64_t)v57, (unint64_t *)&v55);
      continue;
    }
  }
  int v32 = 1;
  while (v31 != -4096)
  {
    unsigned int v33 = v29 + v32++;
    unsigned int v29 = v33 & (v28 - 1);
    uint64_t v30 = v27 + 48 * v29;
    uint64_t v31 = *(void *)(v30 + 24);
    if (v31 == v26) {
      goto LABEL_23;
    }
  }
LABEL_22:
  uint64_t v30 = v27 + 48 * v28;
  goto LABEL_23;
}

void sub_1CCDF92CC(llvm *a1)
{
  llvm::initializeTargetTransformInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializeScalarEvolutionWrapperPassPass(a1, v2);
  llvm::initializeIVUsersWrapperPassPass(a1, v3);
  llvm::initializeLoopInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeLoopSimplifyPass(a1, v4);
  operator new();
}

uint64_t sub_1CCDF9394(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF5098;
  *(_DWORD *)(a1 + 24) = 1;
  *(void *)a1 = &unk_1F263F468;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF50A0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCDF92CC;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCF50A0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CCDF9444(uint64_t a1, llvm::Loop *this, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v11 = (_DWORD *)(a1 + 31432);
  uint64_t v12 = (int64x2_t *)(a1 + 280);
  *(void *)a1 = a3;
  *(void *)(a1 + 8) = a4;
  *(void *)(a1 + 16) = a5;
  *(void *)(a1 + 24) = a6;
  *(void *)(a1 + 32) = a8;
  *(void *)(a1 + 40) = a9;
  *(void *)(a1 + 48) = a7;
  *(void *)(a1 + 56) = this;
  *(void *)(a1 + 64) = a10;
  if (word_1EBCF5530) {
    int v13 = dword_1EBCF55A8;
  }
  else {
    int v13 = (*(uint64_t (**)(void, llvm::Loop *, uint64_t))(*(void *)*a7 + 312))(*a7, this, a4);
  }
  *(void *)(a1 + 88) = a1 + 104;
  *(_DWORD *)(a1 + 72) = v13;
  *(unsigned char *)(a1 + 76) = 0;
  *(void *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 176) = 0u;
  *(void *)(a1 + 168) = a1 + 176;
  *(void *)(a1 + 96) = 0x800000000;
  *(void *)(a1 + 192) = a1 + 208;
  *(void *)(a1 + 200) = 0x800000000;
  *(void *)(a1 + 272) = 1;
  int64x2_t v14 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  int64x2_t *v12 = v14;
  v12[1] = v14;
  *(void *)(a1 + 312) = a1 + 328;
  *(void *)(a1 + 320) = 0x400000000;
  *(void *)(a1 + 360) = a1 + 376;
  *(void *)(a1 + 368) = 0x1000000000;
  *(_OWORD *)(a1 + 30840) = 0u;
  *(_DWORD *)(a1 + 30856) = 0;
  *(void *)(a1 + 30864) = a1 + 30880;
  *(void *)(a1 + 30872) = 0x1000000000;
  *(void *)(a1 + 31008) = a1 + 31024;
  *(void *)(a1 + 31016) = 0x800000000;
  *(void *)(a1 + 31408) = a1 + 31440;
  *(void *)(a1 + 31416) = a1 + 31440;
  *(void *)(a1 + 31424) = 8;
  *uint64_t v11 = 0;
  *(void *)(a1 + 31504) = a1 + 31520;
  *(void *)(a1 + 31512) = 0x200000000;
  *(_DWORD *)(a1 + 31584) = 0;
  *(_OWORD *)(a1 + 31568) = 0u;
  llvm::Loop::isLoopSimplifyForm(this);
}

uint64_t sub_1CCE064F0(uint64_t a1)
{
  v111[4] = *MEMORY[0x1E4F143B8];
  v88[1] = 0;
  v88[0] = 0;
  int v89 = 0;
  int v83 = v87;
  BOOL v84 = v87;
  uint64_t v85 = 16;
  int v86 = 0;
  uint64_t v78 = v82;
  int v79 = v82;
  uint64_t v80 = 16;
  int v81 = 0;
  uint64_t v75 = 0;
  uint64_t v76 = 0;
  unsigned int v77 = 0;
  uint64_t v68 = *(unsigned int *)(a1 + 368);
  if (v68)
  {
    uint64_t v1 = a1;
    uint64_t v2 = 0;
    uint64_t v3 = a1 + 30840;
    while (1)
    {
      uint64_t v73 = *(void *)(v1 + 360) + 1904 * v2;
      uint64_t v72 = *(unsigned int *)(v73 + 680);
      if (!v72) {
        goto LABEL_90;
      }
      char v4 = 0;
      uint64_t v5 = 0;
      uint64_t v71 = (uint64_t *)(v73 + 672);
LABEL_5:
      char v69 = v4;
      do
      {
        uint64_t v6 = *v71;
        uint64_t v7 = *(void *)(v1 + 8);
        uint64_t v8 = *(void *)(v1 + 48);
        int v9 = *(_DWORD *)(v1 + 72);
        unsigned int v100 = *(void **)(v1 + 56);
        uint64_t v101 = v7;
        uint64_t v102 = v8;
        v103[8] = v9;
        memset(v103, 0, 32);
        if (v84 == v83) {
          goto LABEL_7;
        }
        if (v85 < 0x21 || 4 * (HIDWORD(v85) - v86) >= v85)
        {
          memset(v84, 255, 8 * v85);
LABEL_7:
          int v86 = 0;
          HIDWORD(v85) = 0;
          goto LABEL_8;
        }
        llvm::SmallPtrSetImplBase::shrink_and_clear((void **)&v83);
LABEL_8:
        uint64_t v10 = (long long *)(v6 + 96 * v5);
        sub_1CCE0F2C0((uint64_t)&v100, v10, (llvm::SmallPtrSetImplBase *)&v83, (uint64_t)v88, v73, (uint64_t *)&v78);
        if (v103[1] == -1) {
          goto LABEL_82;
        }
        __base = v99;
        size_t __nel = 0x400000000;
        uint64_t v74 = v6;
        uint64_t v11 = v6 + 96 * v5;
        int64x2_t v14 = *(uint64_t **)(v11 + 32);
        uint64_t v13 = v11 + 32;
        uint64_t v12 = v14;
        uint64_t v15 = *(unsigned int *)(v13 + 8);
        if (v15)
        {
          uint64_t v16 = 8 * v15;
          do
          {
            uint64_t v17 = *v12;
            if (sub_1CCE0F194(v3, *v12, v2))
            {
              if (__nel >= (unint64_t)HIDWORD(__nel)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)__base + __nel) = v17;
              LODWORD(__nel) = __nel + 1;
            }
            ++v12;
            v16 -= 8;
          }
          while (v16);
        }
        uint64_t v18 = v74 + 96 * v5;
        uint64_t v21 = *(void *)(v18 + 80);
        uint64_t v20 = (long long *)(v18 + 80);
        uint64_t v19 = v21;
        if (v21)
        {
          BOOL v22 = sub_1CCE0F194(v3, v19, v2);
          unsigned int v23 = __nel;
          if (v22)
          {
            if (__nel >= HIDWORD(__nel)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)__base + __nel) = *(void *)v20;
            unsigned int v23 = __nel + 1;
            LODWORD(__nel) = __nel + 1;
          }
        }
        else
        {
          unsigned int v23 = __nel;
        }
        uint64_t v70 = v20;
        if (v23 >= 2)
        {
          qsort(__base, v23, 8uLL, (int (__cdecl *)(const void *, const void *))sub_1CD4783D8);
          unsigned int v23 = __nel;
        }
        uint64_t v24 = v1;
        *(void *)&long long v104 = &v105;
        *((void *)&v104 + 1) = 0x400000000;
        if (v23) {
          sub_1CD6BBEE8((uint64_t)&v104, (uint64_t)&__base);
        }
        v107[0] = v5;
        uint64_t v90 = 0;
        uint64_t v25 = v75;
        uint64_t v26 = v77;
        int v27 = sub_1CCE10CC4((uint64_t)v75, v77, (uint64_t)&v104, &v90);
        uint64_t v28 = v90;
        if ((v27 & 1) == 0)
        {
          uint64_t v91 = v90;
          int v29 = v76;
          if (4 * (int)v76 + 4 >= (3 * v26))
          {
            int v30 = 2 * v26;
          }
          else
          {
            int v30 = v26;
            if ((int)v26 + ~v76 - HIDWORD(v76) > v26 >> 3)
            {
LABEL_29:
              LODWORD(v76) = v29 + 1;
              __s2 = &v95;
              uint64_t v95 = -1;
              uint64_t v94 = 0x400000001;
              if (*(_DWORD *)(v28 + 8) != 1 || **(void **)v28 != v95) {
                --HIDWORD(v76);
              }
              sub_1CC133E7C(v28, (uint64_t)&v104);
              *(void *)(v28 + 48) = v107[0];
              goto LABEL_33;
            }
          }
          unint64_t v31 = (v30 - 1) | ((unint64_t)(v30 - 1) >> 1);
          unint64_t v32 = v31 | (v31 >> 2) | ((v31 | (v31 >> 2)) >> 4);
          int v33 = ((v32 | (v32 >> 8)) >> 16) | v32 | (v32 >> 8);
          if ((v33 + 1) > 0x40) {
            unsigned int v34 = v33 + 1;
          }
          else {
            unsigned int v34 = 64;
          }
          unsigned int v77 = v34;
          uint64_t v75 = (void **)operator new(56 * v34, (std::align_val_t)8uLL);
          if (v25)
          {
            sub_1CCE0FF18((uint64_t)&v75);
            __s2 = &v95;
            uint64_t v95 = -1;
            uint64_t v94 = 0x400000001;
            uint64_t v109 = v111;
            v111[0] = -2;
            uint64_t v110 = 0x400000001;
            if (v26)
            {
              uint64_t v64 = v75;
              int v65 = v76;
              int v63 = v77;
              uint64_t v35 = 56 * v26;
              uint64_t v36 = v25;
              do
              {
                uint64_t v66 = v35;
                uint64_t v67 = (uint64_t)v36;
                uint64_t v37 = *((unsigned int *)v36 + 2);
                if (v37 == v94 && (int v38 = *(void **)v67, !memcmp(*(const void **)v67, __s2, 8 * v37))
                  || v37 == v110 && (int v38 = *(void **)v67, !memcmp(*(const void **)v67, v109, 8 * v37)))
                {
                  uint64_t v39 = v67;
                }
                else
                {
                  uint64_t v92 = 0;
                  uint64_t v39 = v67;
                  sub_1CCE10CC4((uint64_t)v64, v63, v67, &v92);
                  uint64_t v40 = v92;
                  sub_1CC133E7C(v92, v67);
                  *(void *)(v40 + 48) = *(void *)(v67 + 48);
                  ++v65;
                  int v38 = *(void **)v67;
                }
                if ((void *)(v39 + 16) != v38) {
                  free(v38);
                }
                uint64_t v36 = (void **)(v39 + 56);
                uint64_t v35 = v66 - 56;
              }
              while (v66 != 56);
              LODWORD(v76) = v65;
              if (v109 != v111) {
                free(v109);
              }
            }
            if (__s2 != &v95) {
              free(__s2);
            }
            MEMORY[0x1D25D9CD0](v25, 8);
          }
          else
          {
            sub_1CCE0FF18((uint64_t)&v75);
          }
          sub_1CCE10CC4((uint64_t)v75, v77, (uint64_t)&v104, &v91);
          int v29 = v76;
          uint64_t v28 = v91;
          goto LABEL_29;
        }
LABEL_33:
        uint64_t v1 = v24;
        if ((long long *)v104 != &v105) {
          free((void *)v104);
        }
        if (v27)
        {
          uint64_t v41 = *(void *)(v28 + 48);
          uint64_t v42 = *v71;
          uint64_t v43 = *(void *)(v1 + 8);
          uint64_t v44 = *(void *)(v1 + 48);
          int v45 = *(_DWORD *)(v1 + 72);
          __s2 = *(void **)(v1 + 56);
          uint64_t v94 = v43;
          uint64_t v95 = v44;
          v96[8] = v45;
          memset(v96, 0, 32);
          if (v84 == v83) {
            goto LABEL_69;
          }
          if (v85 >= 0x21 && 4 * (HIDWORD(v85) - v86) < v85)
          {
            llvm::SmallPtrSetImplBase::shrink_and_clear((void **)&v83);
          }
          else
          {
            memset(v84, 255, 8 * v85);
LABEL_69:
            int v86 = 0;
            HIDWORD(v85) = 0;
          }
          uint64_t v46 = (long long *)(v42 + 96 * v41);
          sub_1CCE0F2C0((uint64_t)&__s2, v46, (llvm::SmallPtrSetImplBase *)&v83, (uint64_t)v88, v73, 0);
          if (word_1EBCF5170 && byte_1EBCF51E8 && v103[0] != v96[0])
          {
            if (v103[0] >= v96[0]) {
              goto LABEL_80;
            }
          }
          else if (!(*(unsigned int (**)(void, _DWORD *, _DWORD *))(**(void **)v102 + 272))(*(void *)v102, v103, v96))
          {
LABEL_80:
            if (__base != v99) {
              free(__base);
            }
LABEL_82:
            sub_1CCE0F7F0(v73, v10);
            char v4 = 1;
            if (v5 != --v72) {
              goto LABEL_5;
            }
            goto LABEL_89;
          }
          long long v47 = v10[1];
          long long v104 = *v10;
          long long v105 = v47;
          v106[0] = v107;
          v106[1] = (void *)0x400000000;
          if (*(_DWORD *)(v74 + 96 * v5 + 40)) {
            sub_1CC133E7C((uint64_t)v106, v13);
          }
          long long v108 = *v70;
          long long v48 = v46[1];
          *uint64_t v10 = *v46;
          v10[1] = v48;
          uint64_t v49 = v42 + 96 * v41;
          sub_1CC133E7C(v13, v49 + 32);
          *uint64_t v70 = *(_OWORD *)(v49 + 80);
          long long v50 = v105;
          *uint64_t v46 = v104;
          v46[1] = v50;
          sub_1CC133E7C(v49 + 32, (uint64_t)v106);
          *(_OWORD *)(v49 + 80) = v108;
          if (v106[0] != v107) {
            free(v106[0]);
          }
          goto LABEL_80;
        }
        if (__base != v99) {
          free(__base);
        }
        ++v5;
      }
      while (v5 != v72);
      if ((v69 & 1) == 0) {
        goto LABEL_90;
      }
LABEL_89:
      sub_1CCE0F930(v73, v2, v3);
LABEL_90:
      int v51 = v76;
      if (v76)
      {
        unsigned int v52 = v77;
        if (v77 <= 4 * (int)v76 || v77 < 0x41)
        {
          *(void *)&long long v104 = &v105;
          *(void *)&long long v105 = -1;
          *((void *)&v104 + 1) = 0x400000001;
          unsigned int v100 = &v102;
          uint64_t v102 = -2;
          uint64_t v101 = 0x400000001;
          if (v77)
          {
            uint64_t v58 = v75;
            uint64_t v59 = 56 * v77;
            do
            {
              sub_1CD6BBEE8((uint64_t)v58, (uint64_t)&v104);
              v58 += 7;
              v59 -= 56;
            }
            while (v59);
            uint64_t v76 = 0;
            if (v100 != &v102) {
              free(v100);
            }
          }
          else
          {
            uint64_t v76 = 0;
          }
          if ((long long *)v104 != &v105) {
            free((void *)v104);
          }
        }
        else
        {
          uint64_t v53 = v75;
          sub_1CCE10ED4(v75, v77);
          if (v51)
          {
            int v54 = 1 << (33 - __clz(v51 - 1));
            if (v54 <= 64) {
              int v55 = 64;
            }
            else {
              int v55 = v54;
            }
            if (v55 != v52)
            {
              MEMORY[0x1D25D9CD0](v53, 8);
              unint64_t v56 = (4 * v55 / 3u + 1) | ((unint64_t)(4 * v55 / 3u + 1) >> 1);
              unint64_t v57 = v56 | (v56 >> 2) | ((v56 | (v56 >> 2)) >> 4);
              unsigned int v77 = (((v57 | (v57 >> 8)) >> 16) | v57 | (v57 >> 8)) + 1;
              uint64_t v75 = (void **)operator new(56 * v77, (std::align_val_t)8uLL);
            }
            sub_1CCE0FF18((uint64_t)&v75);
          }
          else
          {
            MEMORY[0x1D25D9CD0](v53, 8);
            uint64_t v75 = 0;
            uint64_t v76 = 0;
            unsigned int v77 = 0;
          }
        }
      }
      if (++v2 == v68)
      {
        uint64_t v60 = v75;
        unsigned int v61 = v77;
        goto LABEL_112;
      }
    }
  }
  unsigned int v61 = 0;
  uint64_t v60 = 0;
LABEL_112:
  sub_1CCE10ED4(v60, v61);
  MEMORY[0x1D25D9CD0](v60, 8);
  if (v79 != v78) {
    free(v79);
  }
  if (v84 != v83) {
    free(v84);
  }
  return MEMORY[0x1D25D9CD0](0, 8);
}

unint64_t sub_1CCE06F34(uint64_t a1, uint64_t a2, llvm::ScalarEvolution *a3, uint64_t a4)
{
  uint64_t v5 = a1;
  v100[8] = *MEMORY[0x1E4F143B8];
  if (a1 == a2)
  {
    while (2)
    {
      switch(*(_WORD *)(v5 + 24))
      {
        case 1:
        case 2:
        case 3:
        case 0xD:
          BOOL v22 = (llvm::Type **)(v5 + 40);
          goto LABEL_33;
        case 4:
          BOOL v22 = (llvm::Type **)(v5 + 48);
          goto LABEL_33;
        case 5:
        case 7:
        case 8:
        case 9:
        case 0xA:
        case 0xB:
        case 0xC:
          uint64_t v21 = *(uint64_t **)(v5 + 32);
          goto LABEL_27;
        case 6:
          uint64_t v21 = (uint64_t *)(v5 + 40);
LABEL_27:
          uint64_t v5 = *v21;
          continue;
        case 0xE:
          BOOL v22 = *(llvm::Type ***)(v5 - 8);
          goto LABEL_33;
        default:
          BOOL v22 = *(llvm::Type ***)(v5 + 32);
LABEL_33:
          unsigned int v23 = *v22;
          unint64_t result = llvm::ScalarEvolution::getConstant(a3, v23, 1uLL, 0);
          break;
      }
      return result;
    }
  }
  int v8 = *(unsigned __int16 *)(a2 + 24);
  if (!a2 || *(_WORD *)(a2 + 24))
  {
    uint64_t MulExpr = 0;
    int v14 = *(unsigned __int16 *)(a1 + 24);
    if (a1 && !*(_WORD *)(a1 + 24)) {
      return MulExpr;
    }
    goto LABEL_10;
  }
  uint64_t v9 = *(void *)(a2 + 32);
  uint64_t v10 = *(unsigned int *)(v9 + 32);
  if (!v10) {
    goto LABEL_19;
  }
  uint64_t v11 = (const llvm::APInt *)(v9 + 24);
  if (v10 <= 0x40)
  {
    uint64_t v12 = *(void **)v11;
    if (*(void *)v11 != 0xFFFFFFFFFFFFFFFFLL >> -(char)v10) {
      goto LABEL_48;
    }
LABEL_19:
    uint64_t v18 = v5;
    while (2)
    {
      switch(*(_WORD *)(v18 + 24))
      {
        case 1:
        case 2:
        case 3:
        case 0xD:
          uint64_t v20 = v18 + 40;
          goto LABEL_37;
        case 4:
          uint64_t v20 = v18 + 48;
          goto LABEL_37;
        case 5:
        case 7:
        case 8:
        case 9:
        case 0xA:
        case 0xB:
        case 0xC:
          uint64_t v19 = *(uint64_t **)(v18 + 32);
          goto LABEL_22;
        case 6:
          uint64_t v19 = (uint64_t *)(v18 + 40);
LABEL_22:
          uint64_t v18 = *v19;
          continue;
        case 0xE:
          uint64_t v20 = *(void *)(v18 - 8);
          goto LABEL_37;
        default:
          uint64_t v20 = *(void *)(v18 + 32);
LABEL_37:
          if (*(unsigned char *)(*(void *)v20 + 8) == 15) {
            return 0;
          }
          __s1 = v100;
          v100[0] = v5;
          v100[1] = a2;
          uint64_t v99 = 0x200000002;
          uint64_t MulExpr = llvm::ScalarEvolution::getMulExpr((uint64_t)a3, (uint64_t)&__s1, 0, 0);
          uint64_t v25 = __s1;
          if (__s1 != v100) {
            goto LABEL_143;
          }
          return MulExpr;
      }
    }
  }
  if (llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)(v9 + 24)) == v10) {
    goto LABEL_19;
  }
  int v26 = 0;
  int64_t v27 = (unint64_t)(v10 + 63) >> 6;
  do
  {
    BOOL v28 = v27-- < 1;
    if (v28) {
      break;
    }
    unint64_t v29 = *(void *)(*(void *)v11 + 8 * v27);
    v26 += __clz(v29);
  }
  while (!v29);
  int v30 = v10 | 0xFFFFFFC0;
  if ((v10 & 0x3F) == 0) {
    int v30 = 0;
  }
  if ((v10 - v26 - v30) > 0x40) {
    goto LABEL_50;
  }
  uint64_t v12 = **(void ***)v11;
LABEL_48:
  if (v12 == (void *)1) {
    return v5;
  }
LABEL_50:
  int v14 = *(unsigned __int16 *)(v5 + 24);
  uint64_t MulExpr = v5;
  if (v5 && !*(_WORD *)(v5 + 24))
  {
    unint64_t v31 = (llvm::APInt *)(*(void *)(v5 + 32) + 24);
    llvm::APInt::srem(v31, v11, (uint64_t)&__s1);
    if (v99 >= 0x41)
    {
      int v51 = 0;
      int64_t v52 = ((unint64_t)v99 + 63) >> 6;
      do
      {
        BOOL v28 = v52-- < 1;
        if (v28) {
          break;
        }
        unint64_t v53 = *((void *)__s1 + v52);
        v51 += __clz(v53);
      }
      while (!v53);
      int v54 = v99 | 0xFFFFFFC0;
      if ((v99 & 0x3F) == 0) {
        int v54 = 0;
      }
      if ((v99 - v51 - v54) >= 0x41)
      {
        if (__s1) {
          MEMORY[0x1D25D9CB0](__s1, 0x1000C8000313F17);
        }
      }
      else
      {
        uint64_t v55 = *(void *)__s1;
        MEMORY[0x1D25D9CB0]();
        if (!v55) {
          goto LABEL_94;
        }
      }
    }
    else if (!__s1)
    {
LABEL_94:
      llvm::APInt::sdiv(v31, v11, (uint64_t)&__s1);
      unint64_t v57 = (llvm::ConstantInt *)llvm::ConstantInt::get(***(llvm::ConstantInt ****)a3, (llvm::LLVMContext *)&__s1, v56);
      uint64_t MulExpr = llvm::ScalarEvolution::getConstant(a3, v57);
      if (v99 >= 0x41)
      {
        if (__s1) {
          MEMORY[0x1D25D9CB0](__s1, 0x1000C8000313F17);
        }
      }
      return MulExpr;
    }
    return 0;
  }
LABEL_10:
  if (v14 == 4)
  {
    if ((a4 & 1) == 0)
    {
      uint64_t v39 = ***(llvm::IntegerType ****)a3;
      uint64_t v40 = *(void *)(v5 + 48);
      unsigned int v41 = *(_DWORD *)(v40 + 8);
      uint64_t v42 = *(void *)(*(void *)a3 + 40);
      if (v41 == 15)
      {
        if ((v41 & 0xFE) == 0x12) {
          unsigned int v41 = *(_DWORD *)(**(void **)(v40 + 16) + 8);
        }
        uint64_t v77 = *(void *)(v42 + 504);
        if (v41 < 0x100) {
          goto LABEL_158;
        }
        unsigned int v78 = v41 >> 8;
        unint64_t v79 = *(unsigned int *)(v42 + 512);
        uint64_t v80 = *(void *)(v42 + 504);
        if (v79)
        {
          uint64_t v80 = v77;
          unint64_t v81 = v79;
          do
          {
            unint64_t v82 = v81 >> 1;
            uint64_t v83 = v80 + 16 * (v81 >> 1);
            unsigned int v84 = *(_DWORD *)(v83 + 8);
            uint64_t v85 = v83 + 16;
            v81 += ~(v81 >> 1);
            if (v84 < v78) {
              uint64_t v80 = v85;
            }
            else {
              unint64_t v81 = v82;
            }
          }
          while (v81);
        }
        if (v80 == v77 + 16 * v79 || *(_DWORD *)(v80 + 8) != v78) {
LABEL_158:
        }
          uint64_t v80 = v77;
        int v44 = *(_DWORD *)(v80 + 12);
      }
      else
      {
        int v44 = sub_1CB83544C(v42 + 272, v40);
        if (v43 == 1) {
      }
        }
      int v45 = (uint64_t **)llvm::IntegerType::get(v39, (llvm::LLVMContext *)(v44 + 1));
      if (*(_WORD *)(llvm::ScalarEvolution::getSignExtendExpr(a3, (llvm::detail::IEEEFloat **)v5, v45, 0) + 24) != 4) {
        return 0;
      }
    }
    __s1 = v100;
    uint64_t v99 = 0x800000000;
    uint64_t v46 = *(void *)(v5 + 40);
    if (!v46)
    {
LABEL_81:
      uint64_t AddExpr = llvm::ScalarEvolution::getAddExpr((uint64_t)a3, (unint64_t **)&__s1, 0, 0);
LABEL_140:
      uint64_t MulExpr = AddExpr;
      goto LABEL_142;
    }
    long long v47 = *(void **)(v5 + 32);
    uint64_t v48 = 8 * v46;
    while (1)
    {
      uint64_t v49 = sub_1CCE06F34(*v47, a2, a3, a4);
      if (!v49) {
        break;
      }
      if (v99 >= (unint64_t)HIDWORD(v99)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)__s1 + v99) = v49;
      LODWORD(v99) = v99 + 1;
      ++v47;
      v48 -= 8;
      if (!v48) {
        goto LABEL_81;
      }
    }
LABEL_141:
    uint64_t MulExpr = 0;
LABEL_142:
    uint64_t v25 = __s1;
    if (__s1 != v100) {
LABEL_143:
    }
      free(v25);
    return MulExpr;
  }
  if (v14 == 5)
  {
    if (a4)
    {
      if (!a2 || v8 != 5) {
        goto LABEL_127;
      }
    }
    else
    {
      if (!sub_1CCE07E18(v5, a3)) {
        return 0;
      }
      if (!a2 || *(_WORD *)(a2 + 24) != 5 || !sub_1CCE07E18(a2, a3))
      {
LABEL_127:
        __s1 = v100;
        uint64_t v99 = 0x400000000;
        uint64_t v70 = *(void *)(v5 + 40);
        if (v70)
        {
          unsigned int v71 = 0;
          BOOL v72 = 0;
          uint64_t v73 = *(uint64_t **)(v5 + 32);
          uint64_t v74 = 8 * v70;
          do
          {
            uint64_t v75 = *v73;
            if (v72)
            {
              BOOL v72 = 1;
            }
            else
            {
              uint64_t v76 = sub_1CCE06F34(*v73, a2, a3, a4);
              BOOL v72 = v76 != 0;
              if (v76) {
                uint64_t v75 = v76;
              }
              unsigned int v71 = v99;
            }
            if (v71 >= HIDWORD(v99)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)__s1 + v71) = v75;
            unsigned int v71 = v99 + 1;
            LODWORD(v99) = v99 + 1;
            ++v73;
            v74 -= 8;
          }
          while (v74);
          if (v72)
          {
            uint64_t AddExpr = llvm::ScalarEvolution::getMulExpr((uint64_t)a3, (uint64_t)&__s1, 0, 0);
            goto LABEL_140;
          }
        }
        goto LABEL_141;
      }
    }
    unint64_t v32 = *(uint64_t **)(v5 + 32);
    if (*(_WORD *)(*v32 + 24)) {
      uint64_t v33 = 0;
    }
    else {
      uint64_t v33 = *v32;
    }
    uint64_t v34 = **(void **)(a2 + 32);
    if (*(_WORD *)(v34 + 24)) {
      uint64_t v34 = 0;
    }
    if (v33) {
      BOOL v35 = v34 == 0;
    }
    else {
      BOOL v35 = 1;
    }
    if (!v35)
    {
      uint64_t v95 = v34;
      uint64_t v96 = v33;
      uint64_t v36 = *(void *)(v5 + 40);
      __s1 = v100;
      uint64_t v99 = 0x400000000;
      unint64_t v37 = 8 * v36 - 8;
      if (v37 >= 0x21) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      int v38 = 0;
      if (v36 != 1)
      {
        memcpy(__s1, v32 + 1, 8 * v36 - 8);
        int v38 = v99;
      }
      LODWORD(v99) = v38 + (v37 >> 3);
      uint64_t v67 = *(void *)(a2 + 40);
      unint64_t v68 = 8 * v67 - 8;
      if (v68 >= 0x21) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v67 != 1) {
        memcpy(v97, (const void *)(*(void *)(a2 + 32) + 8), 8 * v67 - 8);
      }
      if (v99 == (v68 >> 3) && !memcmp(__s1, v97, 8 * (v68 >> 3)))
      {
        uint64_t MulExpr = sub_1CCE06F34(v96, v95, a3, a4);
        char v69 = 1;
      }
      else
      {
        char v69 = 0;
      }
      if (__s1 != v100) {
        free(__s1);
      }
      if (v69) {
        return MulExpr;
      }
    }
    goto LABEL_127;
  }
  if (v14 != 7) {
    return 0;
  }
  if ((a4 & 1) == 0)
  {
    uint64_t v15 = ***(llvm::IntegerType ****)a3;
    uint64_t v16 = *(uint64_t **)(v5 + 32);
    while (2)
    {
      uint64_t v17 = *v16;
      switch(*(_WORD *)(v17 + 24))
      {
        case 1:
        case 2:
        case 3:
        case 0xD:
          uint64_t v58 = (uint64_t *)(v17 + 40);
          break;
        case 4:
          uint64_t v58 = (uint64_t *)(v17 + 48);
          break;
        case 5:
        case 7:
        case 8:
        case 9:
        case 0xA:
        case 0xB:
        case 0xC:
          uint64_t v16 = *(uint64_t **)(v17 + 32);
          continue;
        case 6:
          uint64_t v16 = (uint64_t *)(v17 + 40);
          continue;
        case 0xE:
          uint64_t v58 = *(uint64_t **)(v17 - 8);
          break;
        default:
          uint64_t v58 = *(uint64_t **)(v17 + 32);
          break;
      }
      break;
    }
    uint64_t v59 = *v58;
    unsigned int v60 = *(_DWORD *)(*v58 + 8);
    uint64_t v61 = *(void *)(*(void *)a3 + 40);
    if (v60 == 15)
    {
      if ((v60 & 0xFE) == 0x12) {
        unsigned int v60 = *(_DWORD *)(**(void **)(v59 + 16) + 8);
      }
      uint64_t v86 = *(void *)(v61 + 504);
      if (v60 < 0x100) {
        goto LABEL_171;
      }
      unsigned int v87 = v60 >> 8;
      unint64_t v88 = *(unsigned int *)(v61 + 512);
      uint64_t v89 = *(void *)(v61 + 504);
      if (v88)
      {
        uint64_t v89 = v86;
        unint64_t v90 = v88;
        do
        {
          unint64_t v91 = v90 >> 1;
          uint64_t v92 = v89 + 16 * (v90 >> 1);
          unsigned int v93 = *(_DWORD *)(v92 + 8);
          uint64_t v94 = v92 + 16;
          v90 += ~(v90 >> 1);
          if (v93 < v87) {
            uint64_t v89 = v94;
          }
          else {
            unint64_t v90 = v91;
          }
        }
        while (v90);
      }
      if (v89 == v86 + 16 * v88 || *(_DWORD *)(v89 + 8) != v87) {
LABEL_171:
      }
        uint64_t v89 = v86;
      int v63 = *(_DWORD *)(v89 + 12);
    }
    else
    {
      int v63 = sub_1CB83544C(v61 + 272, v59);
      if (v62 == 1) {
    }
      }
    uint64_t v64 = (uint64_t **)llvm::IntegerType::get(v15, (llvm::LLVMContext *)(v63 + 1));
    if (*(_WORD *)(llvm::ScalarEvolution::getSignExtendExpr(a3, (llvm::detail::IEEEFloat **)v5, v64, 0) + 24) != 7) {
      return 0;
    }
  }
  if (*(void *)(v5 + 40) != 2) {
    return 0;
  }
  uint64_t MulExpr = sub_1CCE06F34(*(void *)(*(void *)(v5 + 32) + 8), a2, a3, a4);
  if (!MulExpr) {
    return MulExpr;
  }
  uint64_t v65 = sub_1CCE06F34(**(void **)(v5 + 32), a2, a3, a4);
  if (!v65) {
    return 0;
  }
  uint64_t v66 = *(const llvm::Loop **)(v5 + 48);

  return llvm::ScalarEvolution::getAddRecExpr(a3, v65, MulExpr, v66, 0);
}

uint64_t sub_1CCE07A48(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = *(unsigned __int8 *)(a2 + 16);
  uint64_t result = v5 == 60;
  if (a2 && v5 == 61)
  {
    uint64_t v7 = *(void *)(a2 - 32);
    return v7 == a3;
  }
  if (v5 != 84)
  {
    if (a2 && v5 == 65)
    {
      uint64_t v7 = *(void *)(a2 - 64);
    }
    else
    {
      if (!a2 || v5 != 64) {
        return result;
      }
      uint64_t v7 = *(void *)(a2 - 96);
    }
    return v7 == a3;
  }
  uint64_t v8 = *(void *)(a2 - 32);
  if (!v8 || *(unsigned char *)(v8 + 16) || *(void *)(v8 + 24) != *(void *)(a2 + 72) || (*(unsigned char *)(v8 + 33) & 0x20) == 0) {
    return result;
  }
  uint64_t v9 = (*(_DWORD *)(v8 + 36) - 185);
  if (v9 <= 0x37)
  {
    if (((1 << v9) & 0x80000000004001) != 0)
    {
      uint64_t v7 = *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF));
      return v7 == a3;
    }
    if (((1 << v9) & 0x1200) != 0)
    {
      uint64_t v10 = (void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF));
      if (*v10 == a3 || v10[4] == a3) {
        return 1;
      }
      return result;
    }
    if (v9 == 2)
    {
      uint64_t v7 = *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 32);
      return v7 == a3;
    }
  }
  unsigned int v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 992))(a1);
  if (a3) {
    return 0;
  }
  else {
    return v11;
  }
}

unint64_t sub_1CCE07BF0(uint64_t a1, uint64_t a2, _DWORD **a3)
{
  uint64_t v3 = *(_DWORD **)a2;
  switch(*(unsigned char *)(a2 + 16))
  {
    case '<':
    case '>':
    case '?':
    case '@':
    case 'A':
      goto LABEL_13;
    case '=':
      uint64_t v3 = **(_DWORD ***)(a2 - 64);
      goto LABEL_13;
    default:
      if (*(unsigned char *)(a2 + 16) != 84) {
        goto LABEL_13;
      }
      uint64_t v4 = *(void *)(a2 - 32);
      if (!v4
        || *(unsigned char *)(v4 + 16)
        || *(void *)(v4 + 24) != *(void *)(a2 + 72)
        || (*(unsigned char *)(v4 + 33) & 0x20) == 0)
      {
        goto LABEL_13;
      }
      int v5 = *(_DWORD *)(v4 + 36);
      if (v5 > 196)
      {
        if (v5 != 197)
        {
          if (v5 == 240 || v5 == 199)
          {
            uint64_t v3 = *a3;
            goto LABEL_13;
          }
          goto LABEL_27;
        }
LABEL_24:
        uint64_t v3 = *a3;
        goto LABEL_13;
      }
      switch(v5)
      {
        case 185:
          goto LABEL_13;
        case 187:
          uint64_t v3 = **(_DWORD ***)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF));
          goto LABEL_13;
        case 194:
          goto LABEL_24;
      }
LABEL_27:
      (*(uint64_t (**)(uint64_t))(*(void *)a1 + 992))(a1);
LABEL_13:
      if (v3) {
        BOOL v6 = v3[2] == 15;
      }
      else {
        BOOL v6 = 0;
      }
      if (v6) {
        return llvm::PointerType::get((llvm::PointerType *)(**(void **)v3 + 1888), (llvm::Type *)(v3[2] >> 8));
      }
      return (unint64_t)v3;
  }
}

BOOL sub_1CCE07E18(uint64_t a1, llvm::ScalarEvolution *a2)
{
  uint64_t v4 = *(llvm::IntegerType ****)a2;
  int v5 = ***(llvm::IntegerType ****)a2;
  BOOL v6 = *(uint64_t **)(a1 + 32);
  while (2)
  {
    uint64_t v7 = *v6;
    switch(*(_WORD *)(v7 + 24))
    {
      case 1:
      case 2:
      case 3:
      case 0xD:
        uint64_t v8 = (uint64_t *)(v7 + 40);
        break;
      case 4:
        uint64_t v8 = (uint64_t *)(v7 + 48);
        break;
      case 5:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
        BOOL v6 = *(uint64_t **)(v7 + 32);
        continue;
      case 6:
        BOOL v6 = (uint64_t *)(v7 + 40);
        continue;
      case 0xE:
        uint64_t v8 = *(uint64_t **)(v7 - 8);
        break;
      default:
        uint64_t v8 = *(uint64_t **)(v7 + 32);
        break;
    }
    break;
  }
  uint64_t v9 = *v8;
  unsigned int v10 = *(_DWORD *)(*v8 + 8);
  unsigned int v11 = v4[5];
  if (v10 == 15)
  {
    if ((v10 & 0xFE) == 0x12) {
      unsigned int v10 = *(_DWORD *)(**(void **)(v9 + 16) + 8);
    }
    uint64_t v16 = v11[63];
    if (v10 < 0x100) {
      goto LABEL_24;
    }
    unsigned int v17 = v10 >> 8;
    unint64_t v18 = *((unsigned int *)v11 + 128);
    uint64_t v19 = v11[63];
    if (v18)
    {
      uint64_t v19 = v16;
      unint64_t v20 = v18;
      do
      {
        unint64_t v21 = v20 >> 1;
        uint64_t v22 = (uint64_t)v19 + 16 * (v20 >> 1);
        unsigned int v23 = *(_DWORD *)(v22 + 8);
        uint64_t v24 = (llvm::IntegerType *)(v22 + 16);
        v20 += ~(v20 >> 1);
        if (v23 < v17) {
          uint64_t v19 = v24;
        }
        else {
          unint64_t v20 = v21;
        }
      }
      while (v20);
    }
    if (v19 == (llvm::IntegerType *)((char *)v16 + 16 * v18) || *((_DWORD *)v19 + 2) != v17) {
LABEL_24:
    }
      uint64_t v19 = v16;
    int v12 = *((_DWORD *)v19 + 3);
  }
  else
  {
    int v12 = sub_1CB83544C((uint64_t)(v11 + 34), v9);
    if (v13 == 1)
    {
      int v25 = v12;
      int v12 = v25;
    }
  }
  int v14 = (uint64_t **)llvm::IntegerType::get(v5, (llvm::LLVMContext *)(*(_DWORD *)(a1 + 40) * v12));
  return *(unsigned __int16 *)(llvm::ScalarEvolution::getSignExtendExpr(a2, (llvm::detail::IEEEFloat **)a1, v14, 0)
                             + 24) == 5;
}

unint64_t *sub_1CCE07FF0(unint64_t *a1, unint64_t *a2, uint64_t a3, llvm::ScalarEvolution *this)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    while (1)
    {
      unint64_t v8 = *v4;
      BOOL v9 = *v4 && *(unsigned __int8 *)(*v4 + 16) >= 0x1Cu;
      if (v9 && (*(_DWORD *)(*(void *)v8 + 8) & 0xFD) == 0xD) {
        break;
      }
LABEL_24:
      v4 += 4;
      if (v4 == a2) {
        return a2;
      }
    }
    uint64_t v10 = *((void *)this + 13);
    unsigned int v11 = *((_DWORD *)this + 30);
    if (v11)
    {
      unsigned int v12 = (v11 - 1) & ((v8 >> 4) ^ (v8 >> 9));
      uint64_t v13 = v10 + 48 * v12;
      uint64_t v14 = *(void *)(v13 + 24);
      if (v14 == v8)
      {
LABEL_15:
        if (v13 == v10 + 48 * v11 || (uint64_t SCEVIter = *(void *)(v13 + 40)) == 0) {
          uint64_t SCEVIter = llvm::ScalarEvolution::createSCEVIter(this, v8);
        }
        if (SCEVIter) {
          BOOL v18 = *(unsigned __int16 *)(SCEVIter + 24) == 7;
        }
        else {
          BOOL v18 = 0;
        }
        if (v18 && *(void *)(SCEVIter + 48) == a3) {
          return v4;
        }
        goto LABEL_24;
      }
      int v15 = 1;
      while (v14 != -4096)
      {
        unsigned int v16 = v12 + v15++;
        unsigned int v12 = v16 & (v11 - 1);
        uint64_t v13 = v10 + 48 * v12;
        uint64_t v14 = *(void *)(v13 + 24);
        if (v14 == v8) {
          goto LABEL_15;
        }
      }
    }
    uint64_t v13 = v10 + 48 * v11;
    goto LABEL_15;
  }
  return v4;
}

void sub_1CCE0810C(uint64_t *a1, uint64_t a2, llvm::Value *a3, char **a4)
{
  v184[8] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = (uint64_t *)a3;
  if (a3)
  {
    uint64_t v7 = (uint64_t *)a3;
    if (*((unsigned char *)a3 + 16) == 66) {
      uint64_t v7 = (uint64_t *)*((void *)a3 - 4);
    }
  }
  uint64_t v8 = a1[1];
  uint64_t v9 = *(void *)(v8 + 104);
  unsigned int v10 = *(_DWORD *)(v8 + 120);
  if (!v10)
  {
LABEL_10:
    uint64_t v13 = v9 + 48 * v10;
    goto LABEL_11;
  }
  unsigned int v11 = v10 - 1;
  unsigned int v12 = (v10 - 1) & ((v7 >> 4) ^ (v7 >> 9));
  uint64_t v13 = v9 + 48 * v12;
  uint64_t v14 = *(uint64_t **)(v13 + 24);
  if (v14 != v7)
  {
    int v15 = 1;
    while (v14 != (uint64_t *)-4096)
    {
      unsigned int v16 = v12 + v15++;
      unsigned int v12 = v16 & v11;
      uint64_t v13 = v9 + 48 * (v16 & v11);
      uint64_t v14 = *(uint64_t **)(v13 + 24);
      if (v14 == v7) {
        goto LABEL_11;
      }
    }
    goto LABEL_10;
  }
LABEL_11:
  if (v13 == v9 + 48 * v10 || (uint64_t SCEVIter = *(void *)(v13 + 40)) == 0) {
    uint64_t SCEVIter = llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)v8, (unint64_t)v7);
  }
  uint64_t v18 = SCEVIter;
LABEL_15:
  while (2)
  {
    switch(*(_WORD *)(v18 + 24))
    {
      case 0:
        uint64_t v18 = 0;
        goto LABEL_23;
      case 1:
      case 2:
      case 3:
        uint64_t v19 = (uint64_t *)(v18 + 32);
        goto LABEL_18;
      case 4:
        uint64_t v20 = 8 * *(void *)(v18 + 40);
        break;
      case 7:
        uint64_t v19 = *(uint64_t **)(v18 + 32);
LABEL_18:
        uint64_t v18 = *v19;
        continue;
      default:
        goto LABEL_23;
    }
    break;
  }
  while (v20)
  {
    uint64_t v21 = *(void *)(*(void *)(v18 + 32) - 8 + v20);
    int v22 = *(unsigned __int16 *)(v21 + 24);
    v20 -= 8;
    if (v22 != 5)
    {
      uint64_t v18 = v21;
      if (v22 == 4) {
        goto LABEL_15;
      }
      break;
    }
  }
LABEL_23:
  uint64_t v178 = a4;
  uint64_t v179 = (llvm::SCEV *)SCEVIter;
  uint64_t v176 = (unsigned int *)(a1 + 3877);
  int v177 = a3;
  unsigned int v23 = (char **)(a1 + 3876);
  uint64_t v24 = *((unsigned int *)a1 + 7754);
  if (v24)
  {
    uint64_t v25 = 0;
    while (1)
    {
      uint64_t v26 = (uint64_t)&(*v23)[48 * v25];
      if (*(void *)(v26 + 40) != v18) {
        goto LABEL_62;
      }
      uint64_t v27 = *(void *)v26 + 24 * *(unsigned int *)(v26 + 8);
      unint64_t v28 = *(void *)(v27 - 16);
      if (v28 && *(unsigned char *)(v28 + 16) == 66) {
        unint64_t v28 = *(void *)(v28 - 32);
      }
      if (!sub_1CCE08F08(*(void *)v28, *v7)
        || *(unsigned char *)(a2 + 16) == 83 && *(unsigned char *)(*(void *)(v27 - 24) + 16) == 83)
      {
        goto LABEL_62;
      }
      uint64_t v29 = a1[1];
      uint64_t v30 = *(void *)(v29 + 104);
      unsigned int v31 = *(_DWORD *)(v29 + 120);
      if (!v31) {
        goto LABEL_38;
      }
      unsigned int v32 = v31 - 1;
      unsigned int v33 = (v31 - 1) & ((v28 >> 4) ^ (v28 >> 9));
      uint64_t v34 = v30 + 48 * v33;
      uint64_t v35 = *(void *)(v34 + 24);
      if (v35 != v28) {
        break;
      }
LABEL_39:
      if (v34 == v30 + 48 * v31 || (int v38 = *(const llvm::APInt **)(v34 + 40)) == 0)
      {
        int v38 = (const llvm::APInt *)llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)v29, v28);
        uint64_t v29 = a1[1];
      }
      unint64_t MinusSCEV = (llvm::SCEV *)llvm::ScalarEvolution::getMinusSCEV((llvm::ScalarEvolution *)v29, v179, v38, 0, 0);
      if (*((_WORD *)MinusSCEV + 12) == 15) {
        goto LABEL_62;
      }
      uint64_t v40 = MinusSCEV;
      if (llvm::ScalarEvolution::getLoopDisposition((llvm::ScalarEvolution *)a1[1], MinusSCEV, (const llvm::Loop *)a1[7]) != 1)goto LABEL_62; {
      uint64_t v41 = a1[1];
      }
      if (*((_WORD *)v40 + 12))
      {
        unint64_t v42 = *(void *)(*(void *)v26 + 8);
        if (v42 && *(unsigned char *)(v42 + 16) == 66) {
          unint64_t v42 = *(void *)(v42 - 32);
        }
        uint64_t v43 = *(void *)(v41 + 104);
        unsigned int v44 = *(_DWORD *)(v41 + 120);
        if (!v44) {
          goto LABEL_54;
        }
        unsigned int v45 = ((v42 >> 4) ^ (v42 >> 9)) & (v44 - 1);
        uint64_t v46 = v43 + 48 * v45;
        uint64_t v47 = *(void *)(v46 + 24);
        if (v47 != v42)
        {
          int v48 = 1;
          while (v47 != -4096)
          {
            unsigned int v49 = v45 + v48++;
            unsigned int v45 = v49 & (v44 - 1);
            uint64_t v46 = v43 + 48 * v45;
            uint64_t v47 = *(void *)(v46 + 24);
            if (v47 == v42) {
              goto LABEL_55;
            }
          }
LABEL_54:
          uint64_t v46 = v43 + 48 * v44;
        }
LABEL_55:
        if (v46 == v43 + 48 * v44 || (long long v50 = *(const llvm::APInt **)(v46 + 40)) == 0) {
          long long v50 = (const llvm::APInt *)llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)a1[1], v42);
        }
        if (!*(_WORD *)(llvm::ScalarEvolution::getMinusSCEV((llvm::ScalarEvolution *)v41, v179, v50, 0, 0) + 24)) {
          goto LABEL_62;
        }
      }
      *(void *)&long long v181 = v184;
      *((void *)&v181 + 1) = v184;
      uint64_t v182 = 8;
      LODWORD(v183) = 0;
      int v51 = sub_1CCE08F80((uint64_t)v40, (uint64_t)&v181, v41);
      if (*((void *)&v181 + 1) != (void)v181) {
        free(*((void **)&v181 + 1));
      }
      if (!v51) {
        goto LABEL_65;
      }
LABEL_62:
      if (++v25 == v24) {
        goto LABEL_66;
      }
    }
    int v36 = 1;
    while (v35 != -4096)
    {
      unsigned int v37 = v33 + v36++;
      unsigned int v33 = v37 & v32;
      uint64_t v34 = v30 + 48 * (v37 & v32);
      uint64_t v35 = *(void *)(v34 + 24);
      if (v35 == v28) {
        goto LABEL_39;
      }
    }
LABEL_38:
    uint64_t v34 = v30 + 48 * v31;
    goto LABEL_39;
  }
  LODWORD(v25) = 0;
  uint64_t v40 = 0;
LABEL_65:
  if (v25 == v24)
  {
LABEL_66:
    if (v24 > 7) {
      return;
    }
    uint64_t v52 = a2;
    if (*(unsigned char *)(a2 + 16) == 83 || *((_WORD *)v179 + 12) != 7) {
      return;
    }
    unint64_t v53 = (char *)&v181;
    *(void *)&long long v181 = &v182;
    uint64_t v182 = a2;
    unsigned int v183 = a3;
    *((void *)&v181 + 1) = 0x100000001;
    v184[0] = v179;
    v184[1] = v18;
    uint64_t v54 = *v176;
    uint64_t v55 = (char *)a1[3876];
    if (v54 >= *((_DWORD *)a1 + 7755))
    {
      unint64_t v172 = v54 + 1;
      BOOL v173 = &v55[48 * v54] > (char *)&v181;
      if (v55 <= (char *)&v181 && v173)
      {
        uint64_t v175 = (char *)((char *)&v181 - v55);
        sub_1CCE096A0(v23, v172);
        uint64_t v55 = *v23;
        unint64_t v53 = &v175[(void)*v23];
      }
      else
      {
        sub_1CCE096A0(v23, v172);
        uint64_t v55 = *v23;
        unint64_t v53 = (char *)&v181;
      }
    }
    int v56 = *v176;
    unint64_t v57 = &v55[48 * *v176];
    *(void *)unint64_t v57 = v57 + 16;
    *((void *)v57 + 1) = 0x100000000;
    unsigned int v58 = *((_DWORD *)v53 + 2);
    BOOL v59 = v57 == v53 || v58 == 0;
    if (!v59)
    {
      unsigned int v60 = *(const void **)v53;
      if (*(char **)v53 == v53 + 16)
      {
        if (v58 >= 2) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        memcpy(v57 + 16, v60, 0x18uLL);
        *((_DWORD *)v57 + 2) = v58;
      }
      else
      {
        *(void *)unint64_t v57 = v60;
        *((_DWORD *)v57 + 2) = v58;
        *((_DWORD *)v57 + 3) = *((_DWORD *)v53 + 3);
        *(void *)unint64_t v53 = v53 + 16;
        *((_DWORD *)v53 + 3) = 0;
      }
      *((_DWORD *)v53 + 2) = 0;
    }
    *(void *)&v55[48 * v56 + 40] = *((void *)v53 + 5);
    ++*v176;
    if ((uint64_t *)v181 != &v182) {
      free((void *)v181);
    }
    unint64_t v67 = v24 + 1;
    uint64_t v64 = (void **)v178;
    uint64_t v68 = *((unsigned int *)v178 + 2);
    if (v68 == v24 + 1) {
      goto LABEL_88;
    }
    if (v68 > (int)v24 + 1)
    {
      sub_1CCE09878((uint64_t)&(*v178)[128 * v67], (uint64_t)&(*v178)[128 * v68]);
      *((_DWORD *)v178 + 2) = v67;
LABEL_88:
      uint64_t v40 = v179;
      LODWORD(v25) = v24;
      goto LABEL_118;
    }
    uint64_t v69 = *((unsigned int *)v178 + 3);
    if (v69 <= v24)
    {
      if (v69 == -1) {
        sub_1CD0A89A8(0xFFFFFFFFuLL);
      }
      unint64_t v71 = (2 * v69) | 1;
      if (v71 <= v67) {
        unint64_t v71 = v24 + 1;
      }
      if (v71 >= 0xFFFFFFFF) {
        uint64_t v72 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v72 = v71;
      }
      uint64_t v73 = (char *)malloc_type_malloc(v72 << 7, 0x4065EBACuLL);
      if (!v73) {
        llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
      }
      uint64_t v70 = v73;
      uint64_t v74 = (uint64_t)*v178;
      uint64_t v75 = *((unsigned int *)v178 + 2);
      if (v75)
      {
        uint64_t v76 = 0;
        uint64_t v77 = v75 << 7;
        do
        {
          uint64_t v78 = v74 + v76;
          unint64_t v79 = &v70[v76];
          uint64_t v80 = &v70[v76 + 32];
          *(void *)&v70[v76] = v80;
          uint64_t v82 = *(void *)(v74 + v76);
          uint64_t v81 = *(void *)(v74 + v76 + 8);
          if (v81 == v82)
          {
            *((void *)v79 + 1) = v80;
            uint64_t v83 = *(unsigned int *)(v78 + 20);
            if (v83) {
              memmove(v80, *(const void **)(v78 + 8), 8 * v83);
            }
          }
          else
          {
            *((void *)v79 + 1) = v81;
            *(void *)(v78 + 8) = v82;
          }
          uint64_t v84 = v74 + v76;
          uint64_t v85 = &v70[v76];
          *((void *)v85 + 2) = *(void *)(v74 + v76 + 16);
          *((_DWORD *)v85 + 6) = *(_DWORD *)(v74 + v76 + 24);
          *(void *)(v84 + 16) = 4;
          *(_DWORD *)(v84 + 24) = 0;
          uint64_t v86 = &v70[v76 + 96];
          *((void *)v85 + 8) = v86;
          uint64_t v88 = *(void *)(v74 + v76 + 64);
          uint64_t v87 = *(void *)(v74 + v76 + 72);
          if (v87 == v88)
          {
            *((void *)v85 + 9) = v86;
            uint64_t v89 = *(unsigned int *)(v84 + 84);
            if (v89) {
              memmove(v86, *(const void **)(v84 + 72), 8 * v89);
            }
          }
          else
          {
            *((void *)v85 + 9) = v87;
            *(void *)(v84 + 72) = v88;
          }
          uint64_t v90 = v74 + v76;
          unint64_t v91 = &v70[v76];
          *((void *)v91 + 10) = *(void *)(v74 + v76 + 80);
          *((_DWORD *)v91 + 22) = *(_DWORD *)(v74 + v76 + 88);
          *(void *)(v90 + 80) = 4;
          *(_DWORD *)(v90 + 88) = 0;
          v76 += 128;
        }
        while (v77 != v76);
        uint64_t v64 = (void **)v178;
        uint64_t v74 = (uint64_t)*v178;
        uint64_t v92 = *((unsigned int *)v178 + 2);
      }
      else
      {
        uint64_t v92 = 0;
      }
      sub_1CCE09878(v74, v74 + (v92 << 7));
      if (*v64 != v64 + 2) {
        free(*v64);
      }
      *uint64_t v64 = v70;
      *((_DWORD *)v64 + 3) = v72;
      uint64_t v68 = *((unsigned int *)v64 + 2);
    }
    else
    {
      uint64_t v70 = *v178;
    }
    if (v68 != v67)
    {
      uint64_t v93 = v68 << 7;
      unint64_t v94 = v67 << 7;
      do
      {
        uint64_t v95 = &v70[v93];
        *(_OWORD *)(v95 + 56) = 0uLL;
        *(_OWORD *)(v95 + 72) = 0uLL;
        *((void *)v95 + 15) = 0;
        *(_OWORD *)(v95 + 104) = 0uLL;
        *(_OWORD *)(v95 + 88) = 0uLL;
        *(_OWORD *)(v95 + 40) = 0uLL;
        *(_OWORD *)(v95 + 24) = 0uLL;
        uint64_t v96 = (uint64_t)&v70[v93 + 32];
        *(void *)uint64_t v95 = v96;
        *((void *)v95 + 1) = v96;
        *((void *)v95 + 2) = 4;
        uint64_t v97 = (uint64_t)&v70[v93 + 96];
        *((void *)v95 + 8) = v97;
        *((void *)v95 + 9) = v97;
        v94 -= 128;
        v70 += 128;
        *((_DWORD *)v95 + 20) = 4;
      }
      while (v93 != v94);
    }
    *((_DWORD *)v64 + 2) = v67;
    LODWORD(v25) = v24;
    uint64_t v40 = v179;
  }
  else
  {
    uint64_t v61 = (uint64_t)&(*v23)[48 * v25];
    uint64_t v52 = a2;
    *(void *)&long long v181 = a2;
    *((void *)&v181 + 1) = a3;
    uint64_t v182 = (uint64_t)v40;
    unsigned int v62 = *(_DWORD *)(v61 + 8);
    unint64_t v63 = *(void *)v61;
    if (v62 >= *(_DWORD *)(v61 + 12))
    {
      BOOL v174 = v63 + 24 * v62 > (unint64_t)&v181;
      if (v63 > (unint64_t)&v181 || !v174) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v64 = (void **)v178;
    uint64_t v65 = v63 + 24 * *(unsigned int *)(v61 + 8);
    long long v66 = v181;
    *(void *)(v65 + 16) = v182;
    *(_OWORD *)uint64_t v65 = v66;
    ++*(_DWORD *)(v61 + 8);
  }
LABEL_118:
  BOOL v98 = *v23;
  unint64_t v99 = (unint64_t)*v64 + 128 * (unint64_t)v25;
  unint64_t v100 = v99 + 64;
  if (!llvm::SCEV::isZero(v40))
  {
    uint64_t v101 = *(unint64_t **)(v99 + 72);
    uint64_t v102 = 16;
    if (v101 == *(unint64_t **)v100) {
      uint64_t v102 = 20;
    }
    uint64_t v103 = *(unsigned int *)(v100 + v102);
    long long v104 = &v101[v103];
    if (v103)
    {
      uint64_t v105 = 8 * v103;
      while (*v101 >= 0xFFFFFFFFFFFFFFFELL)
      {
        ++v101;
        v105 -= 8;
        if (!v105)
        {
          uint64_t v101 = v104;
          break;
        }
      }
    }
    sub_1CC002B9C((llvm::SmallPtrSetImplBase *)v99, v101, v104, v104);
    uint64_t v106 = *(void **)(v99 + 72);
    if (v106 != *(void **)v100)
    {
      uint64_t v170 = *(unsigned int *)(v99 + 80);
      if (v170 >= 0x21 && 4 * (*(_DWORD *)(v99 + 84) - *(_DWORD *)(v99 + 88)) < v170)
      {
        llvm::SmallPtrSetImplBase::shrink_and_clear((void **)(v99 + 64));
        goto LABEL_128;
      }
      memset(v106, 255, 8 * v170);
    }
    *(_DWORD *)(v99 + 84) = 0;
    *(_DWORD *)(v99 + 88) = 0;
  }
LABEL_128:
  uint64_t v107 = *((void *)v177 + 1);
  if (v107)
  {
    long long v108 = &v98[48 * v25];
    while (1)
    {
      uint64_t v109 = *(unsigned __int8 **)(v107 + 24);
      if (v109) {
        BOOL v110 = v109[16] >= 0x1Cu;
      }
      else {
        BOOL v110 = 0;
      }
      if (!v110) {
        goto LABEL_206;
      }
      uint64_t v111 = *((unsigned int *)v108 + 2);
      if (v111)
      {
        BOOL v112 = *(unsigned __int8 ***)v108;
        uint64_t v113 = 24 * v111;
        while (*v112 != v109)
        {
          v112 += 3;
          v113 -= 24;
          if (!v113) {
            goto LABEL_139;
          }
        }
        goto LABEL_206;
      }
LABEL_139:
      if ((*(_DWORD *)(*(void *)v109 + 8) & 0xFD) == 0xD) {
        break;
      }
LABEL_174:
      uint64_t v139 = *(void *)(v100 + 8);
      uint64_t v140 = *(unsigned int *)(v100 + 20);
      if (v139 != *(void *)v100)
      {
        unsigned int v144 = *(_DWORD *)(v100 + 16);
LABEL_185:
        if (3 * v144 <= 4 * ((int)v140 - *(_DWORD *)(v100 + 24)))
        {
          if (v144 >= 0x40) {
            v144 *= 2;
          }
          else {
            unsigned int v144 = 128;
          }
        }
        else if (v144 - v140 >= v144 >> 3)
        {
          goto LABEL_187;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v100, v144);
        unsigned int v144 = *(_DWORD *)(v100 + 16);
        uint64_t v139 = *(void *)(v100 + 8);
LABEL_187:
        unsigned int v145 = v144 - 1;
        unsigned int v146 = (v144 - 1) & ((v109 >> 4) ^ (v109 >> 9));
        uint64_t v147 = (unsigned __int8 **)(v139 + 8 * v146);
        uint64_t v148 = *v147;
        if (*v147 == (unsigned __int8 *)-1)
        {
          uint64_t v149 = 0;
LABEL_199:
          if (v149) {
            unsigned int v153 = v149;
          }
          else {
            unsigned int v153 = v147;
          }
          if (*v153 != v109)
          {
            if (*v153 == (unsigned __int8 *)-2) {
              --*(_DWORD *)(v100 + 24);
            }
            else {
              ++*(_DWORD *)(v100 + 20);
            }
            *unsigned int v153 = v109;
          }
        }
        else
        {
          uint64_t v149 = 0;
          int v150 = 1;
          while (v148 != v109)
          {
            if (v149) {
              BOOL v151 = 0;
            }
            else {
              BOOL v151 = v148 == (unsigned __int8 *)-2;
            }
            if (v151) {
              uint64_t v149 = v147;
            }
            unsigned int v152 = v146 + v150++;
            unsigned int v146 = v152 & v145;
            uint64_t v147 = (unsigned __int8 **)(v139 + 8 * (v152 & v145));
            uint64_t v148 = *v147;
            if (*v147 == (unsigned __int8 *)-1) {
              goto LABEL_199;
            }
          }
        }
        goto LABEL_206;
      }
      if (v140)
      {
        uint64_t v141 = 0;
        uint64_t v142 = 8 * v140;
        uint64_t v143 = *(unsigned __int8 ***)(v100 + 8);
        while (*v143 != v109)
        {
          if (*v143 == (unsigned __int8 *)-2) {
            uint64_t v141 = v143;
          }
          ++v143;
          v142 -= 8;
          if (!v142)
          {
            if (!v141) {
              goto LABEL_182;
            }
            *uint64_t v141 = v109;
            --*(_DWORD *)(v100 + 24);
            goto LABEL_206;
          }
        }
        goto LABEL_206;
      }
LABEL_182:
      unsigned int v144 = *(_DWORD *)(v100 + 16);
      if (v140 >= v144) {
        goto LABEL_185;
      }
      *(_DWORD *)(v100 + 20) = v140 + 1;
      *(void *)(v139 + 8 * v140) = v109;
LABEL_206:
      uint64_t v107 = *(void *)(v107 + 8);
      if (!v107) {
        goto LABEL_219;
      }
    }
    uint64_t v114 = a1[1];
    uint64_t v115 = *(void *)(v114 + 104);
    unsigned int v116 = *(_DWORD *)(v114 + 120);
    if (v116)
    {
      unsigned int v117 = (v116 - 1) & ((v109 >> 4) ^ (v109 >> 9));
      uint64_t v118 = v115 + 48 * v117;
      int v119 = *(unsigned __int8 **)(v118 + 24);
      if (v119 == v109) {
        goto LABEL_147;
      }
      int v120 = 1;
      while (v119 != (unsigned __int8 *)-4096)
      {
        unsigned int v121 = v117 + v120++;
        unsigned int v117 = v121 & (v116 - 1);
        uint64_t v118 = v115 + 48 * v117;
        int v119 = *(unsigned __int8 **)(v118 + 24);
        if (v119 == v109) {
          goto LABEL_147;
        }
      }
    }
    uint64_t v118 = v115 + 48 * v116;
LABEL_147:
    if (v118 == v115 + 48 * v116 || (uint64_t v122 = *(void *)(v118 + 40)) == 0) {
      uint64_t v122 = llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)v114, *(void *)(v107 + 24));
    }
    if (*(_WORD *)(v122 + 24) != 14)
    {
      uint64_t v123 = *a1;
      uint64_t v125 = *(void *)(*a1 + 40);
      uint64_t v124 = *(void *)(*a1 + 48);
      if (v124 == v125)
      {
        uint64_t v126 = *(unsigned int *)(v123 + 60);
        uint64_t v127 = (unsigned __int8 **)(v124 + 8 * v126);
        if (v126)
        {
          uint64_t v128 = 0;
          uint64_t v129 = 8 * v126;
          while (*(unsigned __int8 **)(v124 + v128) != v109)
          {
            v128 += 8;
            if (v129 == v128) {
              goto LABEL_169;
            }
          }
          uint64_t v127 = (unsigned __int8 **)(v124 + v128);
        }
LABEL_169:
        uint64_t v125 = *(void *)(*a1 + 48);
      }
      else
      {
        uint64_t v130 = *(unsigned int *)(v123 + 56);
        int v131 = v130 - 1;
        unsigned int v132 = (v130 - 1) & ((v109 >> 4) ^ (v109 >> 9));
        uint64_t v127 = (unsigned __int8 **)(v124 + 8 * v132);
        uint64_t v133 = *v127;
        if (*v127 == (unsigned __int8 *)-1)
        {
          __int16 v134 = 0;
LABEL_210:
          if (v134) {
            uint64_t v127 = v134;
          }
          if (*v127 != v109) {
            uint64_t v127 = (unsigned __int8 **)(v124 + 8 * v130);
          }
        }
        else
        {
          __int16 v134 = 0;
          int v135 = 1;
          while (v133 != v109)
          {
            if (v134) {
              BOOL v136 = 0;
            }
            else {
              BOOL v136 = v133 == (unsigned __int8 *)-2;
            }
            if (v136) {
              __int16 v134 = v127;
            }
            unsigned int v137 = v132 + v135++;
            unsigned int v132 = v137 & v131;
            uint64_t v127 = (unsigned __int8 **)(v124 + 8 * (v137 & v131));
            uint64_t v133 = *v127;
            if (*v127 == (unsigned __int8 *)-1) {
              goto LABEL_210;
            }
          }
        }
      }
      uint64_t v138 = v124 == v125 ? 60 : 56;
      if (v127 != (unsigned __int8 **)(v124 + 8 * *(unsigned int *)(v123 + v138))) {
        goto LABEL_206;
      }
    }
    goto LABEL_174;
  }
LABEL_219:
  unint64_t v154 = (unint64_t)&(*v178)[128 * (unint64_t)v25];
  uint64_t v156 = *(void *)v154;
  uint64_t v155 = *(void *)(v154 + 8);
  if (v155 == *(void *)v154)
  {
    uint64_t v157 = *(unsigned int *)(v154 + 20);
    uint64_t v158 = (void *)(v155 + 8 * v157);
    if (v157)
    {
      uint64_t v159 = 0;
      uint64_t v160 = 8 * v157;
      while (*(void *)(v155 + v159) != v52)
      {
        v159 += 8;
        if (v160 == v159) {
          goto LABEL_237;
        }
      }
      uint64_t v158 = (void *)(v155 + v159);
    }
LABEL_237:
    uint64_t v156 = *(void *)(v154 + 8);
  }
  else
  {
    uint64_t v161 = *(unsigned int *)(v154 + 16);
    int v162 = v161 - 1;
    unsigned int v163 = (v161 - 1) & ((v52 >> 4) ^ (v52 >> 9));
    uint64_t v158 = (void *)(v155 + 8 * v163);
    uint64_t v164 = *v158;
    if (*v158 == -1)
    {
      unint64_t v165 = 0;
LABEL_244:
      if (v165) {
        uint64_t v158 = v165;
      }
      if (*v158 != v52) {
        uint64_t v158 = (void *)(v155 + 8 * v161);
      }
    }
    else
    {
      unint64_t v165 = 0;
      int v166 = 1;
      while (v164 != v52)
      {
        if (v165) {
          BOOL v167 = 0;
        }
        else {
          BOOL v167 = v164 == -2;
        }
        if (v167) {
          unint64_t v165 = v158;
        }
        unsigned int v168 = v163 + v166++;
        unsigned int v163 = v168 & v162;
        uint64_t v158 = (void *)(v155 + 8 * (v168 & v162));
        uint64_t v164 = *v158;
        if (*v158 == -1) {
          goto LABEL_244;
        }
      }
    }
  }
  BOOL v59 = v155 == v156;
  uint64_t v169 = 16;
  if (v59) {
    uint64_t v169 = 20;
  }
  if (v158 != (void *)(v155 + 8 * *(unsigned int *)(v154 + v169)))
  {
    void *v158 = -2;
    ++*(_DWORD *)(v154 + 24);
  }
}

BOOL sub_1CCE08F08(uint64_t a1, uint64_t a2)
{
  if (a1 == a2) {
    return 1;
  }
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 != 15) {
    return 0;
  }
  int v3 = *(_DWORD *)(a2 + 8);
  if (v3 != 15) {
    return 0;
  }
  if ((v2 & 0xFE) == 0x12) {
    unsigned int v2 = *(_DWORD *)(**(void **)(a1 + 16) + 8);
  }
  if ((v3 & 0xFE) == 0x12) {
    int v3 = *(_DWORD *)(**(void **)(a2 + 16) + 8);
  }
  return (v3 ^ v2) < 0x100;
}

uint64_t sub_1CCE08F80(uint64_t a1, uint64_t a2, uint64_t a3)
{
  while (2)
  {
    uint64_t result = 0;
    int v7 = *(unsigned __int16 *)(a1 + 24);
    switch(*(_WORD *)(a1 + 24))
    {
      case 0:
        return result;
      case 1:
      case 2:
      case 3:
        uint64_t v8 = (uint64_t *)(a1 + 32);
        goto LABEL_3;
      default:
        if (v7 == 14) {
          return result;
        }
        uint64_t v9 = *(void *)(a2 + 8);
        uint64_t v10 = *(unsigned int *)(a2 + 20);
        if (v9 == *(void *)a2)
        {
          if (v10)
          {
            unsigned int v11 = 0;
            uint64_t v12 = 8 * v10;
            uint64_t v13 = *(uint64_t **)(a2 + 8);
            do
            {
              if (*v13 == a1) {
                return 0;
              }
              if (*v13 == -2) {
                unsigned int v11 = v13;
              }
              ++v13;
              v12 -= 8;
            }
            while (v12);
            if (v11)
            {
              *unsigned int v11 = a1;
              --*(_DWORD *)(a2 + 24);
              if (!a1) {
                goto LABEL_39;
              }
              goto LABEL_38;
            }
          }
          unsigned int v14 = *(_DWORD *)(a2 + 16);
          if (v10 < v14)
          {
            *(_DWORD *)(a2 + 20) = v10 + 1;
            *(void *)(v9 + 8 * v10) = a1;
            if (!a1) {
              goto LABEL_39;
            }
            goto LABEL_38;
          }
        }
        else
        {
          unsigned int v14 = *(_DWORD *)(a2 + 16);
        }
        if (3 * v14 <= 4 * ((int)v10 - *(_DWORD *)(a2 + 24)))
        {
          if (v14 >= 0x40) {
            v14 *= 2;
          }
          else {
            unsigned int v14 = 128;
          }
        }
        else if (v14 - v10 >= v14 >> 3)
        {
          goto LABEL_19;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a2, v14);
        unsigned int v14 = *(_DWORD *)(a2 + 16);
        uint64_t v9 = *(void *)(a2 + 8);
LABEL_19:
        unsigned int v15 = v14 - 1;
        unsigned int v16 = (v14 - 1) & ((a1 >> 4) ^ (a1 >> 9));
        unsigned int v17 = (uint64_t *)(v9 + 8 * v16);
        uint64_t v18 = *v17;
        if (*v17 != -1)
        {
          uint64_t v19 = 0;
          int v20 = 1;
          while (v18 != a1)
          {
            if (v19) {
              BOOL v21 = 0;
            }
            else {
              BOOL v21 = v18 == -2;
            }
            if (v21) {
              uint64_t v19 = v17;
            }
            unsigned int v22 = v16 + v20++;
            unsigned int v16 = v22 & v15;
            unsigned int v17 = (uint64_t *)(v9 + 8 * (v22 & v15));
            uint64_t v18 = *v17;
            if (*v17 == -1) {
              goto LABEL_31;
            }
          }
          return 0;
        }
        uint64_t v19 = 0;
LABEL_31:
        if (v19) {
          unsigned int v23 = v19;
        }
        else {
          unsigned int v23 = v17;
        }
        if (*v23 == a1) {
          return 0;
        }
        if (*v23 == -2) {
          --*(_DWORD *)(a2 + 24);
        }
        else {
          ++*(_DWORD *)(a2 + 20);
        }
        *unsigned int v23 = a1;
        int v7 = *(unsigned __int16 *)(a1 + 24);
        if (!a1) {
          goto LABEL_39;
        }
LABEL_38:
        if (v7 == 4)
        {
          uint64_t v26 = *(void *)(a1 + 40);
          if (v26)
          {
            uint64_t v27 = *(uint64_t **)(a1 + 32);
            uint64_t v28 = 8 * v26 - 8;
            do
            {
              uint64_t v29 = *v27++;
              uint64_t result = sub_1CCE08F80(v29, a2, a3);
              if (result) {
                break;
              }
              uint64_t v30 = v28;
              v28 -= 8;
            }
            while (v30);
            return result;
          }
          return 0;
        }
LABEL_39:
        if (!a1 || v7 != 5) {
          return v7 != 7 || !a1 || (sub_1CCE092F0(a1, (llvm::ScalarEvolution *)a3) & 1) == 0;
        }
        if (*(void *)(a1 + 40) != 2) {
          return 1;
        }
        uint64_t v24 = *(uint64_t **)(a1 + 32);
        uint64_t v25 = *v24;
        uint64_t v8 = v24 + 1;
        if (!*(_WORD *)(v25 + 24))
        {
LABEL_3:
          a1 = *v8;
          continue;
        }
        uint64_t v31 = *v8;
        if (!v31) {
          return 1;
        }
        if (*(_WORD *)(v31 + 24) != 14) {
          return 1;
        }
        uint64_t v32 = *(void *)(*(void *)(v31 - 8) + 8);
        if (!v32) {
          return 1;
        }
        while (1)
        {
          unsigned int v33 = *(unsigned char **)(v32 + 24);
          if (v33)
          {
            if (v33[16] == 45 && (*(_DWORD *)(*(void *)v33 + 8) & 0xFD) == 0xD) {
              break;
            }
          }
          uint64_t v32 = *(void *)(v32 + 8);
          if (!v32) {
            return 1;
          }
        }
        uint64_t v34 = *(void *)(a3 + 104);
        unsigned int v35 = *(_DWORD *)(a3 + 120);
        if (v35)
        {
          unsigned int v36 = (v35 - 1) & ((v33 >> 4) ^ (v33 >> 9));
          uint64_t v37 = v34 + 48 * v36;
          int v38 = *(unsigned char **)(v37 + 24);
          if (v38 != v33)
          {
            int v39 = 1;
            while (v38 != (unsigned char *)-4096)
            {
              unsigned int v40 = v36 + v39++;
              unsigned int v36 = v40 & (v35 - 1);
              uint64_t v37 = v34 + 48 * v36;
              int v38 = *(unsigned char **)(v37 + 24);
              if (v38 == v33) {
                goto LABEL_76;
              }
            }
            goto LABEL_75;
          }
        }
        else
        {
LABEL_75:
          uint64_t v37 = v34 + 48 * v35;
        }
LABEL_76:
        if (v37 == v34 + 48 * v35 || (uint64_t SCEVIter = *(void *)(v37 + 40)) == 0) {
          uint64_t SCEVIter = llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)a3, (unint64_t)v33);
        }
        return SCEVIter == a1;
    }
  }
}

uint64_t sub_1CCE092F0(uint64_t a1, llvm::ScalarEvolution *this)
{
  uint64_t v2 = **(void **)(*(void *)(a1 + 48) + 32);
  if (*(void *)(v2 + 40) == v2 + 40) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v5 = *(void *)(v2 + 48);
  BOOL v6 = (uint64_t ***)(v5 - 24);
  if (v5) {
    uint64_t v7 = v5 - 24;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v5 && *(unsigned char *)(v7 + 16) == 83)
  {
    while (1)
    {
      uint64_t v9 = *v6;
      unsigned int v10 = *((_DWORD *)*v6 + 2);
      if ((v10 & 0xFD) != 0xD) {
        goto LABEL_29;
      }
      if (*((_DWORD *)*v6 + 2) != 13)
      {
        if ((v10 & 0xFE) == 0x12) {
          unsigned int v10 = *(_DWORD *)(*v9[2] + 8);
        }
        uint64_t v26 = *(void *)(*(void *)this + 40);
        uint64_t v27 = *(void *)(v26 + 504);
        if (v10 < 0x100) {
          goto LABEL_47;
        }
        unsigned int v28 = v10 >> 8;
        unint64_t v29 = *(unsigned int *)(v26 + 512);
        uint64_t v30 = v27;
        if (v29)
        {
          uint64_t v30 = v27;
          unint64_t v31 = v29;
          do
          {
            unint64_t v32 = v31 >> 1;
            uint64_t v33 = v30 + 16 * (v31 >> 1);
            unsigned int v34 = *(_DWORD *)(v33 + 8);
            uint64_t v35 = v33 + 16;
            v31 += ~(v31 >> 1);
            if (v34 < v28) {
              uint64_t v30 = v35;
            }
            else {
              unint64_t v31 = v32;
            }
          }
          while (v31);
        }
        if (v30 == v27 + 16 * v29 || *(_DWORD *)(v30 + 8) != v28) {
LABEL_47:
        }
          uint64_t v30 = v27;
        unsigned int v36 = (uint64_t **)llvm::IntegerType::get((llvm::IntegerType *)*v9, (llvm::LLVMContext *)*(unsigned int *)(v30 + 12));
        if ((v9[1] & 0xFE) == 0x12)
        {
          int v48 = (llvm::Type *)*((unsigned int *)v9 + 8);
          if (*((_DWORD *)v9 + 2) == 19) {
            llvm::ScalableVectorType::get(v36, v48);
          }
          else {
            llvm::FixedVectorType::get((llvm::FixedVectorType *)v36, v48);
          }
        }
        uint64_t v9 = v36;
      }
      unsigned int v11 = *(uint64_t **)(a1 + 32);
      while (2)
      {
        uint64_t v12 = *v11;
        switch(*(_WORD *)(v12 + 24))
        {
          case 1:
          case 2:
          case 3:
          case 0xD:
            uint64_t v13 = (uint64_t ***)(v12 + 40);
            break;
          case 4:
            uint64_t v13 = (uint64_t ***)(v12 + 48);
            break;
          case 5:
          case 7:
          case 8:
          case 9:
          case 0xA:
          case 0xB:
          case 0xC:
            unsigned int v11 = *(uint64_t **)(v12 + 32);
            continue;
          case 6:
            unsigned int v11 = (uint64_t *)(v12 + 40);
            continue;
          case 0xE:
            uint64_t v13 = *(uint64_t ****)(v12 - 8);
            break;
          default:
            uint64_t v13 = *(uint64_t ****)(v12 + 32);
            break;
        }
        break;
      }
      unsigned int v14 = *v13;
      unsigned int v15 = *((_DWORD *)*v13 + 2);
      if (v15 != 13)
      {
        if ((v15 & 0xFE) == 0x12) {
          unsigned int v15 = *(_DWORD *)(*v14[2] + 8);
        }
        uint64_t v37 = *(void *)(*(void *)this + 40);
        uint64_t v38 = *(void *)(v37 + 504);
        if (v15 < 0x100) {
          goto LABEL_61;
        }
        unsigned int v39 = v15 >> 8;
        unint64_t v40 = *(unsigned int *)(v37 + 512);
        uint64_t v41 = v38;
        if (v40)
        {
          uint64_t v41 = v38;
          unint64_t v42 = v40;
          do
          {
            unint64_t v43 = v42 >> 1;
            uint64_t v44 = v41 + 16 * (v42 >> 1);
            unsigned int v45 = *(_DWORD *)(v44 + 8);
            uint64_t v46 = v44 + 16;
            v42 += ~(v42 >> 1);
            if (v45 < v39) {
              uint64_t v41 = v46;
            }
            else {
              unint64_t v42 = v43;
            }
          }
          while (v42);
        }
        if (v41 == v38 + 16 * v40 || *(_DWORD *)(v41 + 8) != v39) {
LABEL_61:
        }
          uint64_t v41 = v38;
        uint64_t v47 = (uint64_t **)llvm::IntegerType::get((llvm::IntegerType *)*v14, (llvm::LLVMContext *)*(unsigned int *)(v41 + 12));
        if ((v14[1] & 0xFE) == 0x12)
        {
          unsigned int v49 = (llvm::Type *)*((unsigned int *)v14 + 8);
          if (*((_DWORD *)v14 + 2) == 19) {
            llvm::ScalableVectorType::get(v47, v49);
          }
          else {
            llvm::FixedVectorType::get((llvm::FixedVectorType *)v47, v49);
          }
        }
        unsigned int v14 = v47;
      }
      if (v9 != v14) {
        goto LABEL_29;
      }
      uint64_t v16 = *((void *)this + 13);
      unsigned int v17 = *((_DWORD *)this + 30);
      if (!v17) {
        goto LABEL_24;
      }
      unsigned int v18 = (v17 - 1) & ((v6 >> 4) ^ (v6 >> 9));
      uint64_t v19 = v16 + 48 * v18;
      int v20 = *(uint64_t ****)(v19 + 24);
      if (v20 != v6) {
        break;
      }
LABEL_25:
      if (v19 == v16 + 48 * v17 || (uint64_t SCEVIter = *(void *)(v19 + 40)) == 0) {
        uint64_t SCEVIter = llvm::ScalarEvolution::createSCEVIter(this, (unint64_t)v6);
      }
      if (SCEVIter == a1) {
        return 1;
      }
LABEL_29:
      uint64_t result = 0;
      uint64_t v24 = v6[4];
      BOOL v6 = (uint64_t ***)(v24 - 3);
      if (v24) {
        uint64_t v25 = v24 - 3;
      }
      else {
        uint64_t v25 = 0;
      }
      if (!v24 || *((unsigned char *)v25 + 16) != 83) {
        return result;
      }
    }
    int v21 = 1;
    while (v20 != (uint64_t ***)-4096)
    {
      unsigned int v22 = v18 + v21++;
      unsigned int v18 = v22 & (v17 - 1);
      uint64_t v19 = v16 + 48 * v18;
      int v20 = *(uint64_t ****)(v19 + 24);
      if (v20 == v6) {
        goto LABEL_25;
      }
    }
LABEL_24:
    uint64_t v19 = v16 + 48 * v17;
    goto LABEL_25;
  }
  return result;
}

void sub_1CCE096A0(char **a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *((unsigned int *)a1 + 3);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  BOOL v6 = (char *)malloc_type_malloc(48 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v7 = v6;
  uint64_t v8 = *a1;
  uint64_t v9 = *((unsigned int *)a1 + 2);
  if (v9)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 48 * v9;
    do
    {
      uint64_t v12 = &v7[v10];
      uint64_t v13 = &v8[v10];
      unsigned int v14 = &v7[v10 + 16];
      *(void *)uint64_t v12 = v14;
      *((void *)v12 + 1) = 0x100000000;
      if (v8 != v7)
      {
        unsigned int v15 = *((_DWORD *)v13 + 2);
        if (v15)
        {
          uint64_t v16 = &v8[v10];
          uint64_t v18 = (uint64_t)&v8[v10 + 16];
          unsigned int v17 = *(const void **)&v8[v10];
          if ((const void *)v18 == v17)
          {
            if (v15 >= 2) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            memcpy(v14, v17, 0x18uLL);
            *((_DWORD *)v12 + 2) = v15;
          }
          else
          {
            *(void *)uint64_t v12 = v17;
            int v19 = *((_DWORD *)v16 + 3);
            *((_DWORD *)v12 + 2) = v15;
            *((_DWORD *)v12 + 3) = v19;
            *(void *)uint64_t v16 = v18;
            *((_DWORD *)v16 + 3) = 0;
          }
          *((_DWORD *)v13 + 2) = 0;
        }
      }
      *((void *)v12 + 5) = *((void *)v13 + 5);
      v10 += 48;
    }
    while (v11 != v10);
    uint64_t v8 = *a1;
    uint64_t v20 = *((unsigned int *)a1 + 2);
    if (v20)
    {
      uint64_t v21 = 48 * v20;
      do
      {
        unsigned int v22 = *(char **)&v8[v21 - 48];
        if (&v8[v21 - 32] != v22) {
          free(v22);
        }
        v21 -= 48;
      }
      while (v21);
      uint64_t v8 = *a1;
    }
  }
  if (v8 != (char *)(a1 + 2)) {
    free(v8);
  }
  *a1 = v7;
  *((_DWORD *)a1 + 3) = v5;
}

void sub_1CCE09878(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    uint64_t v2 = a2;
    do
    {
      unint64_t v4 = *(void **)(v2 - 56);
      if (v4 != *(void **)(v2 - 64)) {
        free(v4);
      }
      uint64_t v5 = *(void **)(v2 - 120);
      if (v5 != *(void **)(v2 - 128)) {
        free(v5);
      }
      v2 -= 128;
    }
    while (v2 != a1);
  }
}

unint64_t sub_1CCE098D4(uint64_t a1, uint64_t *a2, unsigned int a3, void **a4, uint64_t a5)
{
  v116[4] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = (_DWORD *)(a1 + 31576);
  uint64_t v11 = *a2;
  uint64_t v12 = sub_1CCE0A444(a2, *(llvm::ScalarEvolution **)(a1 + 8));
  if (v12)
  {
    uint64_t v13 = a3 == 3 ? -1 : 1;
    if ((sub_1CCE0A944(**(void **)(a1 + 48), a3, (uint64_t)a4, a5, 0, v12, 1, v13) & 1) == 0)
    {
      uint64_t v12 = 0;
      *a2 = v11;
    }
  }
  unint64_t v14 = *a2 & 0xFFFFFFFFFFFFFFF9 | (2 * a3);
  unsigned int v15 = v10[2];
  if (v15)
  {
    uint64_t v16 = *(void *)(a1 + 31568);
    unsigned int v17 = (v15 - 1) & ((v14 >> 9) ^ v14);
    uint64_t v18 = (unint64_t *)(v16 + 16 * v17);
    unint64_t v19 = *v18;
    if (v14 == *v18)
    {
LABEL_9:
      unint64_t v20 = v18[1];
      if (sub_1CCE0A738(a1, *(void *)(a1 + 360) + 1904 * v20, v12, 1u, a3, a4, a5)) {
        return v20;
      }
      goto LABEL_18;
    }
    uint64_t v73 = 0;
    int v74 = 1;
    while (v19 != -2)
    {
      if (v73) {
        BOOL v75 = 0;
      }
      else {
        BOOL v75 = v19 == -16;
      }
      if (v75) {
        uint64_t v73 = v18;
      }
      unsigned int v76 = v17 + v74++;
      unsigned int v17 = v76 & (v15 - 1);
      uint64_t v18 = (unint64_t *)(v16 + 16 * v17);
      unint64_t v19 = *v18;
      if (v14 == *v18) {
        goto LABEL_9;
      }
    }
    if (v73) {
      uint64_t v18 = v73;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  uint64_t v21 = (void *)(a1 + 31568);
  if (4 * *v10 + 4 >= 3 * v15)
  {
    sub_1CCE0AA5C(a1 + 31568, 2 * v15);
    int v82 = v10[2] - 1;
    unsigned int v83 = v82 & ((v14 >> 9) ^ v14);
    uint64_t v18 = (unint64_t *)(*v21 + 16 * v83);
    unint64_t v84 = *v18;
    if (v14 == *v18)
    {
LABEL_94:
      unint64_t v22 = v14;
      goto LABEL_15;
    }
    uint64_t v85 = 0;
    int v86 = 1;
    while (v84 != -2)
    {
      if (v85) {
        BOOL v87 = 0;
      }
      else {
        BOOL v87 = v84 == -16;
      }
      if (v87) {
        uint64_t v85 = v18;
      }
      unsigned int v88 = v83 + v86++;
      unsigned int v83 = v88 & v82;
      uint64_t v18 = (unint64_t *)(*v21 + 16 * v83);
      unint64_t v84 = *v18;
      if (v14 == *v18) {
        goto LABEL_94;
      }
    }
LABEL_104:
    if (v85) {
      uint64_t v18 = v85;
    }
    goto LABEL_14;
  }
  if (v15 + ~*v10 - v10[1] <= v15 >> 3)
  {
    sub_1CCE0AA5C(a1 + 31568, v15);
    int v89 = v10[2] - 1;
    unsigned int v90 = v89 & ((v14 >> 9) ^ v14);
    uint64_t v18 = (unint64_t *)(*v21 + 16 * v90);
    unint64_t v91 = *v18;
    if (v14 == *v18) {
      goto LABEL_94;
    }
    uint64_t v85 = 0;
    int v92 = 1;
    while (v91 != -2)
    {
      if (v85) {
        BOOL v93 = 0;
      }
      else {
        BOOL v93 = v91 == -16;
      }
      if (v93) {
        uint64_t v85 = v18;
      }
      unsigned int v94 = v90 + v92++;
      unsigned int v90 = v94 & v89;
      uint64_t v18 = (unint64_t *)(*v21 + 16 * v90);
      unint64_t v91 = *v18;
      if (v14 == *v18) {
        goto LABEL_94;
      }
    }
    goto LABEL_104;
  }
LABEL_14:
  unint64_t v22 = *v18;
LABEL_15:
  ++*v10;
  if (v22 != -2) {
    --v10[1];
  }
  *uint64_t v18 = v14;
  v18[1] = 0;
LABEL_18:
  unint64_t v20 = *(unsigned int *)(a1 + 368);
  unsigned int v23 = &v108;
  uint64_t v24 = &v104;
  v18[1] = v20;
  uint64_t v25 = &v103;
  uint64_t v26 = (_DWORD *)&v102 + 1;
  uint64_t v27 = &v102;
  uint64_t v101 = 0;
  uint64_t v102 = 0;
  int v103 = 0;
  unsigned int v104 = a3;
  uint64_t v105 = a4;
  uint64_t v106 = a5;
  unsigned int v28 = &v101;
  uint64_t v107 = v109;
  uint64_t v108 = 0x800000000;
  v109[36] = xmmword_1CFB2D040;
  __int16 v110 = 1;
  uint64_t v111 = 0;
  BOOL v112 = v114;
  uint64_t v113 = 0xC00000000;
  v114[144] = v116;
  v114[145] = v116;
  v114[146] = 4;
  int v115 = 0;
  uint64_t v29 = *(unsigned int *)(a1 + 372);
  uint64_t v30 = *(uint64_t **)(a1 + 360);
  if (v20 >= v29)
  {
    unint64_t v47 = v20 + 1;
    BOOL v49 = v30 <= &v101 && &v30[238 * v20] > &v101;
    unint64_t v50 = -1;
    BOOL v97 = v49;
    if (v49) {
      unint64_t v50 = 0xD946FDD946FDD947 * (((char *)&v101 - (char *)v30) >> 4);
    }
    if (v20 == -1) {
      sub_1CD0A88F0(v47);
    }
    unint64_t v96 = v50;
    if (v29 == -1) {
      sub_1CD0A89A8(0xFFFFFFFFuLL);
    }
    unint64_t v51 = (2 * v29) | 1;
    if (v51 <= v47) {
      unint64_t v51 = v20 + 1;
    }
    uint64_t v52 = 0xFFFFFFFFLL;
    if (v51 < 0xFFFFFFFF) {
      uint64_t v52 = v51;
    }
    int v95 = v52;
    unint64_t v53 = (uint64_t *)malloc_type_malloc(1904 * v52, 0x4065EBACuLL);
    if (!v53) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    uint64_t v30 = v53;
    uint64_t v54 = *(char **)(a1 + 360);
    unsigned int v55 = *(_DWORD *)(a1 + 368);
    if (v55)
    {
      uint64_t v56 = 0;
      uint64_t v98 = 1904 * v55;
      unint64_t v99 = *(char **)(a1 + 360);
      do
      {
        unint64_t v57 = &v54[v56];
        uint64_t v100 = v56;
        unsigned int v58 = (char *)v30 + v56;
        *(void *)unsigned int v58 = 0;
        *((void *)v58 + 1) = 0;
        *((_DWORD *)v58 + 4) = 0;
        *(void *)unsigned int v58 = *(void *)v57;
        *(void *)unint64_t v57 = 0;
        *((_DWORD *)v58 + 2) = *((_DWORD *)v57 + 2);
        *((_DWORD *)v57 + 2) = 0;
        int v59 = *((_DWORD *)v58 + 3);
        *((_DWORD *)v58 + 3) = *((_DWORD *)v57 + 3);
        *((_DWORD *)v57 + 3) = v59;
        int v60 = *((_DWORD *)v58 + 4);
        *((_DWORD *)v58 + 4) = *((_DWORD *)v57 + 4);
        *((_DWORD *)v57 + 4) = v60;
        long long v61 = *(_OWORD *)(v57 + 24);
        int v62 = *((_DWORD *)v57 + 10);
        *((void *)v58 + 6) = v58 + 64;
        *((_DWORD *)v58 + 10) = v62;
        *(_OWORD *)(v58 + 24) = v61;
        *((void *)v58 + 7) = 0x800000000;
        if (*((_DWORD *)v57 + 14)) {
          sub_1CCE0ACD0((uint64_t)(v58 + 48), (uint64_t *)v57 + 6);
        }
        long long v63 = *((_OWORD *)v57 + 41);
        *((_OWORD *)v58 + 40) = *((_OWORD *)v57 + 40);
        *((_OWORD *)v58 + 41) = v63;
        *((void *)v58 + 84) = v58 + 688;
        *((void *)v58 + 85) = 0xC00000000;
        uint64_t v54 = v99;
        if (*((_DWORD *)v57 + 170))
        {
          sub_1CCE0B1A0((uint64_t)(v58 + 672), (uint64_t)&v99[v100 + 672]);
          uint64_t v54 = v99;
        }
        uint64_t v64 = (char *)v30 + v100;
        uint64_t v65 = (const void **)&v54[v100];
        long long v66 = (char *)v30 + v100 + 1872;
        *(uint64_t *)((char *)v30 + v100 + 1840) = (uint64_t)v66;
        unint64_t v67 = *(const void **)&v54[v100 + 1848];
        uint64_t v68 = *(const void **)&v54[v100 + 1840];
        if (v67 == v68)
        {
          *((void *)v64 + 231) = v66;
          uint64_t v69 = *((unsigned int *)v65 + 465);
          if (v69)
          {
            uint64_t v70 = v54;
            memmove(v66, v65[231], 8 * v69);
            uint64_t v54 = v70;
          }
        }
        else
        {
          *((void *)v64 + 231) = v67;
          v65[231] = v68;
        }
        unint64_t v71 = &v54[v100];
        uint64_t v72 = (char *)v30 + v100;
        *((void *)v72 + 232) = *(void *)&v54[v100 + 1856];
        *((_DWORD *)v72 + 466) = *(_DWORD *)&v54[v100 + 1864];
        *((void *)v71 + 232) = 4;
        *((_DWORD *)v71 + 466) = 0;
        uint64_t v56 = v100 + 1904;
      }
      while (v98 != v100 + 1904);
      uint64_t v54 = *(char **)(a1 + 360);
      unsigned int v77 = *(_DWORD *)(a1 + 368);
      if (v77)
      {
        uint64_t v78 = 1904 * v77;
        unint64_t v79 = v54 - 1904;
        do
        {
          sub_1CCE0A85C((uint64_t)&v79[v78]);
          v78 -= 1904;
        }
        while (v78);
        uint64_t v54 = *(char **)(a1 + 360);
      }
    }
    unsigned int v23 = &v108;
    if (v54 != (char *)(a1 + 376))
    {
      free(v54);
      unsigned int v23 = &v108;
    }
    *(void *)(a1 + 360) = v30;
    *(_DWORD *)(a1 + 372) = v95;
    uint64_t v80 = (char *)&v30[238 * v96];
    if (v97) {
      unsigned int v28 = &v30[238 * v96];
    }
    else {
      unsigned int v28 = &v101;
    }
    if (v97)
    {
      unsigned int v23 = (uint64_t *)(v80 + 56);
      uint64_t v24 = (unsigned int *)(v80 + 24);
      uint64_t v25 = (int *)(v80 + 16);
      uint64_t v26 = v80 + 12;
    }
    uint64_t v81 = (uint64_t *)(v80 + 8);
    if (v97) {
      uint64_t v27 = v81;
    }
    unsigned int v31 = *(_DWORD *)(a1 + 368);
  }
  else
  {
    unsigned int v31 = v20;
  }
  unint64_t v32 = (char *)&v30[238 * v31];
  *(void *)unint64_t v32 = 0;
  *((void *)v32 + 1) = 0;
  *((_DWORD *)v32 + 4) = 0;
  *(void *)unint64_t v32 = *v28;
  *unsigned int v28 = 0;
  *((_DWORD *)v32 + 2) = *(_DWORD *)v27;
  *(_DWORD *)uint64_t v27 = 0;
  int v33 = *((_DWORD *)v32 + 3);
  *((_DWORD *)v32 + 3) = *v26;
  *uint64_t v26 = v33;
  int v34 = *((_DWORD *)v32 + 4);
  *((_DWORD *)v32 + 4) = *v25;
  int *v25 = v34;
  long long v35 = *(_OWORD *)v24;
  unsigned int v36 = v24[4];
  *((void *)v32 + 6) = v32 + 64;
  uint64_t v37 = (uint64_t)(v32 + 48);
  *(_DWORD *)(v37 - 8) = v36;
  *(_OWORD *)(v37 - 24) = v35;
  *(void *)(v37 + 8) = 0x800000000;
  if (*(_DWORD *)v23) {
    sub_1CCE0ACD0(v37, v28 + 6);
  }
  uint64_t v38 = (char *)&v30[238 * v31];
  long long v39 = *((_OWORD *)v28 + 41);
  *((_OWORD *)v38 + 40) = *((_OWORD *)v28 + 40);
  *((_OWORD *)v38 + 41) = v39;
  *((void *)v38 + 84) = v38 + 688;
  *((void *)v38 + 85) = 0xC00000000;
  if (*((_DWORD *)v28 + 170)) {
    sub_1CCE0B1A0((uint64_t)(v38 + 672), (uint64_t)(v28 + 84));
  }
  unint64_t v40 = (char *)&v30[238 * v31];
  uint64_t v41 = v40 + 1840;
  unint64_t v42 = v40 + 1872;
  *((void *)v40 + 230) = v40 + 1872;
  uint64_t v43 = v28[231];
  uint64_t v44 = v28[230];
  if (v43 == v44)
  {
    *((void *)v41 + 1) = v42;
    uint64_t v45 = *((unsigned int *)v28 + 465);
    if (v45) {
      memmove(v42, (const void *)v28[231], 8 * v45);
    }
  }
  else
  {
    *((void *)v41 + 1) = v43;
    v28[231] = v44;
  }
  *((void *)v41 + 2) = v28[232];
  *((_DWORD *)v41 + 6) = *((_DWORD *)v28 + 466);
  v28[232] = 4;
  *((_DWORD *)v28 + 466) = 0;
  ++*(_DWORD *)(a1 + 368);
  sub_1CCE0A85C((uint64_t)&v101);
  *(int64x2_t *)(*(void *)(a1 + 360) + 1904 * v20 + 640) = vdupq_n_s64(v12);
  return v20;
}

uint64_t sub_1CCE0A058(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 48);
  long long v17 = 0u;
  long long v18 = 0u;
  long long v14 = 0u;
  unsigned int v15 = &v18;
  uint64_t v16 = &v18;
  LODWORD(v17) = 2;
  uint64_t v19 = 0;
  unint64_t v3 = sub_1CCE0B6D0(a1 + 48, (unint64_t)&v14);
  uint64_t v4 = *(void *)(a1 + 48);
  unsigned int v5 = *(_DWORD *)(a1 + 56);
  uint64_t v6 = v4 + 72 * v5;
  *(_OWORD *)uint64_t v6 = *(_OWORD *)v3;
  uint64_t v7 = (void *)(v6 + 48);
  *(void *)(v6 + 16) = v6 + 48;
  uint64_t v8 = v6 + 16;
  uint64_t v10 = *(void *)(v3 + 16);
  uint64_t v9 = *(void *)(v3 + 24);
  if (v9 == v10)
  {
    *(void *)(v8 + 8) = v7;
    uint64_t v11 = *(unsigned int *)(v3 + 36);
    if (v11) {
      memmove(v7, *(const void **)(v3 + 24), 8 * v11);
    }
  }
  else
  {
    *(void *)(v8 + 8) = v9;
    *(void *)(v3 + 24) = v10;
  }
  *(void *)(v8 + 16) = *(void *)(v3 + 32);
  *(_DWORD *)(v8 + 24) = *(_DWORD *)(v3 + 40);
  *(void *)(v3 + 32) = 2;
  *(_DWORD *)(v3 + 40) = 0;
  *(void *)(v4 + 72 * v5 + 64) = *(void *)(v3 + 64);
  unsigned int v12 = *(_DWORD *)(a1 + 56) + 1;
  *(_DWORD *)(a1 + 56) = v12;
  if (v16 != v15)
  {
    free(v16);
    unsigned int v12 = *(_DWORD *)(a1 + 56);
  }
  return *v2 + 72 * v12 - 72;
}

BOOL sub_1CCE0A174(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && *(unsigned char *)(a1 + 16) == 83)
  {
    int v3 = *(_DWORD *)(a1 + 20);
    uint64_t v4 = v3 & 0x7FFFFFF;
    if ((v3 & 0x7FFFFFF) != 0)
    {
      uint64_t v5 = 0;
      while (1)
      {
        if ((v3 & 0x40000000) != 0)
        {
          uint64_t v7 = *(void *)(a1 - 8);
          uint64_t v6 = *(void *)(v7 + 32 * v5);
        }
        else
        {
          uint64_t v6 = *(void *)(a1 - 32 * v4 + 32 * v5);
          uint64_t v7 = a1 - 32 * v4;
        }
        if (v6 == a2)
        {
          uint64_t v8 = *(void *)(v7 + 32 * *(unsigned int *)(a1 + 60) + 8 * v5);
          uint64_t v10 = *(void *)(a3 + 56);
          uint64_t v9 = *(void *)(a3 + 64);
          if (v9 == v10)
          {
            uint64_t v11 = *(unsigned int *)(a3 + 76);
            unsigned int v12 = (void *)(v9 + 8 * v11);
            if (v11)
            {
              uint64_t v13 = 0;
              uint64_t v14 = 8 * v11;
              while (*(void *)(v9 + v13) != v8)
              {
                v13 += 8;
                if (v14 == v13) {
                  goto LABEL_27;
                }
              }
              unsigned int v12 = (void *)(v9 + v13);
            }
LABEL_27:
            uint64_t v10 = *(void *)(a3 + 64);
          }
          else
          {
            uint64_t v15 = *(unsigned int *)(a3 + 72);
            int v16 = v15 - 1;
            unsigned int v17 = (v15 - 1) & ((v8 >> 4) ^ (v8 >> 9));
            unsigned int v12 = (void *)(v9 + 8 * v17);
            uint64_t v18 = *v12;
            if (*v12 == -1)
            {
              uint64_t v19 = 0;
LABEL_35:
              if (v19) {
                unsigned int v12 = v19;
              }
              if (*v12 != v8) {
                unsigned int v12 = (void *)(v9 + 8 * v15);
              }
            }
            else
            {
              uint64_t v19 = 0;
              int v20 = 1;
              while (v18 != v8)
              {
                if (v19) {
                  BOOL v21 = 0;
                }
                else {
                  BOOL v21 = v18 == -2;
                }
                if (v21) {
                  uint64_t v19 = v12;
                }
                unsigned int v22 = v17 + v20++;
                unsigned int v17 = v22 & v16;
                unsigned int v12 = (void *)(v9 + 8 * (v22 & v16));
                uint64_t v18 = *v12;
                if (*v12 == -1) {
                  goto LABEL_35;
                }
              }
            }
          }
          unsigned int v23 = (unsigned int *)(v9 == v10 ? a3 + 76 : a3 + 72);
          if (v12 != (void *)(v9 + 8 * *v23)) {
            return 0;
          }
        }
        if (++v5 == v4) {
          return 1;
        }
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    uint64_t v24 = *(void *)(a1 + 40);
    uint64_t v26 = *(void *)(a3 + 56);
    uint64_t v25 = *(void *)(a3 + 64);
    if (v25 == v26)
    {
      uint64_t v27 = *(unsigned int *)(a3 + 76);
      unsigned int v28 = (void *)(v25 + 8 * v27);
      if (v27)
      {
        uint64_t v29 = 0;
        uint64_t v30 = 8 * v27;
        while (*(void *)(v25 + v29) != v24)
        {
          v29 += 8;
          if (v30 == v29) {
            goto LABEL_59;
          }
        }
        unsigned int v28 = (void *)(v25 + v29);
      }
LABEL_59:
      uint64_t v26 = *(void *)(a3 + 64);
    }
    else
    {
      uint64_t v32 = *(unsigned int *)(a3 + 72);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v24 >> 4) ^ (v24 >> 9));
      unsigned int v28 = (void *)(v25 + 8 * v34);
      uint64_t v35 = *v28;
      if (*v28 == -1)
      {
        unsigned int v36 = 0;
LABEL_64:
        if (v36) {
          unsigned int v28 = v36;
        }
        if (*v28 != v24) {
          unsigned int v28 = (void *)(v25 + 8 * v32);
        }
      }
      else
      {
        unsigned int v36 = 0;
        int v37 = 1;
        while (v35 != v24)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            unsigned int v36 = v28;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          unsigned int v28 = (void *)(v25 + 8 * (v39 & v33));
          uint64_t v35 = *v28;
          if (*v28 == -1) {
            goto LABEL_64;
          }
        }
      }
    }
    BOOL v21 = v25 == v26;
    uint64_t v40 = 72;
    if (v21) {
      uint64_t v40 = 76;
    }
    return v28 == (void *)(v25 + 8 * *(unsigned int *)(a3 + v40));
  }
}

unint64_t *sub_1CCE0A3CC(unint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  uint64_t v6 = *(void *)(a2 + 80);
  if (v6) {
    uint64_t result = sub_1CCE0CE68((uint64_t)(result + 3855), v6, a3);
  }
  uint64_t v7 = *(unsigned int *)(a2 + 40);
  if (v7)
  {
    uint64_t v8 = *(uint64_t **)(a2 + 32);
    uint64_t v9 = (uint64_t)(v5 + 3855);
    uint64_t v10 = 8 * v7;
    do
    {
      uint64_t v11 = *v8++;
      uint64_t result = sub_1CCE0CE68(v9, v11, a3);
      v10 -= 8;
    }
    while (v10);
  }
  return result;
}

uint64_t sub_1CCE0A444(uint64_t *a1, llvm::ScalarEvolution *a2)
{
  v35[8] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a1;
  int v5 = *(unsigned __int16 *)(*a1 + 24);
  if (*a1) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 0;
  }
  if (!v6)
  {
    if (v4) {
      BOOL v7 = v5 == 4;
    }
    else {
      BOOL v7 = 0;
    }
    if (v7)
    {
      BOOL v21 = *(const void **)(v4 + 32);
      unint64_t v20 = *(void *)(v4 + 40);
      int v33 = v35;
      uint64_t v34 = 0x800000000;
      if (v20 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v20)
      {
        memcpy(v35, v21, 8 * v20);
        int v22 = v34;
        unsigned int v23 = v33;
      }
      else
      {
        int v22 = 0;
        unsigned int v23 = v35;
      }
      LODWORD(v34) = v22 + v20;
      uint64_t v19 = sub_1CCE0A444(v23, a2);
      if (!v19) {
        goto LABEL_35;
      }
      uint64_t AddExpr = llvm::ScalarEvolution::getAddExpr((uint64_t)a2, (unint64_t **)&v33, 0, 0);
    }
    else
    {
      if (v4) {
        BOOL v8 = v5 == 7;
      }
      else {
        BOOL v8 = 0;
      }
      if (!v8) {
        return 0;
      }
      uint64_t v10 = *(const void **)(v4 + 32);
      unint64_t v9 = *(void *)(v4 + 40);
      int v33 = v35;
      uint64_t v34 = 0x800000000;
      if (v9 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v9)
      {
        memcpy(v35, v10, 8 * v9);
        int v25 = v34;
        uint64_t v26 = v33;
      }
      else
      {
        int v25 = 0;
        uint64_t v26 = v35;
      }
      LODWORD(v34) = v25 + v9;
      uint64_t v19 = sub_1CCE0A444(v26, a2);
      if (!v19) {
        goto LABEL_35;
      }
      uint64_t AddExpr = llvm::ScalarEvolution::getAddRecExpr(a2, (uint64_t **)&v33, *(const llvm::Loop **)(v4 + 48), 0);
    }
    *a1 = AddExpr;
LABEL_35:
    if (v33 != v35) {
      free(v33);
    }
    return v19;
  }
  uint64_t v11 = *(void *)(v4 + 32);
  unsigned int v12 = (llvm::APInt *)(v11 + 24);
  uint64_t v13 = *(unsigned int *)(v11 + 32);
  unsigned int v14 = v13 - 1;
  if (v13 > 0x40)
  {
    if ((*(void *)(*(void *)v12 + 8 * (v14 >> 6)) >> v14))
    {
      int v16 = llvm::APInt::countLeadingOnesSlowCase(v12);
    }
    else
    {
      int v28 = 0;
      int64_t v29 = (unint64_t)(v13 + 63) >> 6;
      do
      {
        if (v29-- < 1) {
          break;
        }
        unint64_t v31 = *(void *)(*(void *)v12 + 8 * v29);
        v28 += __clz(v31);
      }
      while (!v31);
      int v32 = v13 | 0xFFFFFFC0;
      if ((v13 & 0x3F) == 0) {
        int v32 = 0;
      }
      int v16 = v28 + v32;
    }
  }
  else
  {
    unint64_t v15 = *(void *)v12;
    if ((*(void *)v12 >> v14))
    {
      if (v13) {
        int v16 = __clz(~(v15 << -(char)v13));
      }
      else {
        int v16 = 0;
      }
    }
    else
    {
      int v16 = v13 + __clz(v15) - 64;
    }
  }
  if ((v13 - v16 + 1) > 0x40) {
    return 0;
  }
  *a1 = llvm::ScalarEvolution::getConstant(a2, *(llvm::Type **)v11, 0, 0);
  uint64_t v17 = *(void *)(v4 + 32);
  unsigned int v18 = *(_DWORD *)(v17 + 32);
  if (v18 > 0x40) {
    return **(void **)(v17 + 24);
  }
  else {
    return (uint64_t)(*(void *)(v17 + 24) << -(char)v18) >> -(char)v18;
  }
}

uint64_t sub_1CCE0A738(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, void **a6, uint64_t a7)
{
  if (*(_DWORD *)(a2 + 24) != a5) {
    return 0;
  }
  uint64_t v8 = (uint64_t)a6;
  uint64_t v9 = a3;
  uint64_t v11 = *(void *)(a2 + 640);
  uint64_t v12 = *(void *)(a2 + 648);
  if (a5 == 2 && *(void ***)(a2 + 32) != a6) {
    uint64_t v8 = **a6 + 1576;
  }
  if (a3 < v11)
  {
    if (v12 != a3)
    {
      if (a5 == 3) {
        uint64_t v13 = -1;
      }
      else {
        uint64_t v13 = a4;
      }
      if (a5 == 3) {
        uint64_t v14 = a4;
      }
      else {
        uint64_t v14 = 1;
      }
      if ((sub_1CCE0A944(**(void **)(a1 + 48), a5, v8, a7, 0, v12 - a3, v14, v13) & 1) == 0) {
        return 0;
      }
      goto LABEL_26;
    }
    goto LABEL_17;
  }
  if (v12 >= a3)
  {
    uint64_t v9 = *(void *)(a2 + 640);
    goto LABEL_26;
  }
  if (a3 == v11)
  {
LABEL_17:
    uint64_t v12 = a3;
LABEL_26:
    *(void *)(a2 + 640) = v9;
    *(void *)(a2 + 648) = v12;
    *(void *)(a2 + 32) = v8;
    uint64_t result = 1;
    *(_DWORD *)(a2 + 40) = a7;
    return result;
  }
  if (a5 == 3) {
    uint64_t v16 = -1;
  }
  else {
    uint64_t v16 = a4;
  }
  if (a5 == 3) {
    uint64_t v17 = a4;
  }
  else {
    uint64_t v17 = 1;
  }
  uint64_t result = sub_1CCE0A944(**(void **)(a1 + 48), a5, v8, a7, 0, a3 - v11, v17, v16);
  uint64_t v12 = v9;
  uint64_t v9 = v11;
  if (result) {
    goto LABEL_26;
  }
  return result;
}

uint64_t sub_1CCE0A85C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 1848);
  if (v2 != *(void **)(a1 + 1840)) {
    free(v2);
  }
  int v3 = *(char **)(a1 + 672);
  uint64_t v4 = *(unsigned int *)(a1 + 680);
  if (v4)
  {
    uint64_t v5 = 96 * v4;
    do
    {
      BOOL v6 = *(char **)&v3[v5 - 64];
      if (&v3[v5 - 48] != v6) {
        free(v6);
      }
      v5 -= 96;
    }
    while (v5);
    int v3 = *(char **)(a1 + 672);
  }
  if (v3 != (char *)(a1 + 688)) {
    free(v3);
  }
  BOOL v7 = *(char **)(a1 + 48);
  uint64_t v8 = *(unsigned int *)(a1 + 56);
  if (v8)
  {
    uint64_t v9 = 72 * v8;
    do
    {
      uint64_t v10 = *(void **)&v7[v9 - 48];
      if (v10 != *(void **)&v7[v9 - 56]) {
        free(v10);
      }
      v9 -= 72;
    }
    while (v9);
    BOOL v7 = *(char **)(a1 + 48);
  }
  if (v7 != (char *)(a1 + 64)) {
    free(v7);
  }
  sub_1CCE0B5F0(a1);
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);
  return a1;
}

uint64_t sub_1CCE0A944(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(a2)
  {
    case 1:
      if (a5) {
        BOOL v9 = 1;
      }
      else {
        BOOL v9 = (unint64_t)(a8 + 1) >= 2;
      }
      return !v9 && a6 == 0;
    case 2:
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 264))(a1, a3, a5, a6, a7, a8, a4, 0);
    case 3:
      uint64_t v10 = 0;
      if (a5) {
        return v10;
      }
      BOOL v12 = a6 != 0;
      if (!a8) {
        BOOL v12 = 0;
      }
      if (unint64_t)(a8 - 1) < 0xFFFFFFFFFFFFFFFELL || (v12 & a7) {
        return v10;
      }
      if (a6)
      {
        if (a8) {
          uint64_t v13 = a6;
        }
        else {
          uint64_t v13 = -a6;
        }
        return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 256))(a1, v13);
      }
      else
      {
        return 1;
      }
    default:
      return (a5 | a8 | a6) == 0;
  }
}

void *sub_1CCE0AA5C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(unint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      uint64_t v11 = 16 * v10;
      BOOL v12 = result;
      do
      {
        void *v12 = -2;
        v12 += 2;
        v11 -= 16;
      }
      while (v11);
    }
    if (v3)
    {
      int v13 = 0;
      int v14 = v10 - 1;
      unint64_t v15 = v4;
      do
      {
        unint64_t v16 = *v15;
        if (*v15 != -16 && v16 != -2)
        {
          unsigned int v18 = v14 & ((v16 >> 9) ^ v16);
          uint64_t v19 = &result[2 * v18];
          unint64_t v20 = *v19;
          if (v16 != *v19)
          {
            BOOL v21 = 0;
            int v22 = 1;
            while (v20 != -2)
            {
              if (v21) {
                BOOL v23 = 0;
              }
              else {
                BOOL v23 = v20 == -16;
              }
              if (v23) {
                BOOL v21 = v19;
              }
              unsigned int v24 = v18 + v22++;
              unsigned int v18 = v24 & v14;
              uint64_t v19 = &result[2 * (v24 & v14)];
              unint64_t v20 = *v19;
              if (v16 == *v19) {
                goto LABEL_15;
              }
            }
            if (v21) {
              uint64_t v19 = v21;
            }
          }
LABEL_15:
          *uint64_t v19 = v16;
          v19[1] = v15[1];
          *(_DWORD *)(a1 + 8) = ++v13;
        }
        v15 += 2;
      }
      while (v15 != &v4[2 * v3]);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v25 = *(unsigned int *)(a1 + 16);
  if (v25)
  {
    uint64_t v26 = 16 * v25;
    do
    {
      void *result = -2;
      result += 2;
      v26 -= 16;
    }
    while (v26);
  }
  return result;
}

void sub_1CCE0ABEC(uint64_t a1)
{
  v6[4] = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = 0;
  uint64_t v4 = v6;
  v6[0] = -1;
  uint64_t v5 = 0x400000001;
  uint64_t v1 = *(unsigned int *)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = *(void **)a1;
    uint64_t v3 = 48 * v1;
    do
    {
      void *v2 = v2 + 2;
      v2[1] = 0x400000000;
      if (v5) {
        sub_1CD6BBEE8((uint64_t)v2, (uint64_t)&v4);
      }
      v2 += 6;
      v3 -= 48;
    }
    while (v3);
    if (v4 != v6) {
      free(v4);
    }
  }
}

uint64_t sub_1CCE0ACD0(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v5 = a2 + 2;
    uint64_t v4 = *a2;
    if ((uint64_t *)*a2 != a2 + 2)
    {
      unint64_t v6 = *(char **)a1;
      uint64_t v7 = *(unsigned int *)(a1 + 8);
      if (v7)
      {
        uint64_t v8 = 72 * v7;
        do
        {
          BOOL v9 = *(void **)&v6[v8 - 48];
          if (v9 != *(void **)&v6[v8 - 56]) {
            free(v9);
          }
          v8 -= 72;
        }
        while (v8);
        unint64_t v6 = *(char **)a1;
      }
      if (v6 != (char *)(a1 + 16)) {
        free(v6);
      }
      *(void *)a1 = *a2;
      uint64_t v10 = a2 + 1;
      *(void *)(a1 + 8) = a2[1];
      *a2 = (uint64_t)v5;
      *((_DWORD *)a2 + 3) = 0;
LABEL_12:
      *uint64_t v10 = 0;
      return a1;
    }
    uint64_t v10 = a2 + 1;
    unint64_t v12 = *((unsigned int *)a2 + 2);
    uint64_t v13 = *(unsigned int *)(a1 + 8);
    if (v13 >= v12)
    {
      uint64_t v17 = *(char **)a1;
      if (v12)
      {
        uint64_t v18 = v4 + 72 * v12;
        uint64_t v19 = v4 + 16;
        do
        {
          uint64_t v20 = v19 - 16;
          *(_OWORD *)uint64_t v17 = *(_OWORD *)(v19 - 16);
          if ((char *)(v19 - 16) != v17) {
            llvm::SmallPtrSetImplBase::MoveFrom((uint64_t)(v17 + 16), 2, (double *)v19);
          }
          *((void *)v17 + 8) = *(void *)(v19 + 48);
          v17 += 72;
          v19 += 72;
        }
        while (v20 + 72 != v18);
        BOOL v21 = v17;
        LODWORD(v13) = *(_DWORD *)(a1 + 8);
        uint64_t v17 = *(char **)a1;
      }
      else
      {
        BOOL v21 = *(char **)a1;
      }
      for (uint64_t i = &v17[72 * v13]; i != v21; i -= 72)
      {
        uint64_t v43 = (void *)*((void *)i - 6);
        if (v43 != *((void **)i - 7)) {
          free(v43);
        }
      }
      *(_DWORD *)(a1 + 8) = v12;
      uint64_t v44 = *((unsigned int *)a2 + 2);
      if (v44)
      {
        uint64_t v45 = *a2;
        uint64_t v46 = 72 * v44;
        do
        {
          unint64_t v47 = *(void **)(v45 + v46 - 48);
          if (v47 != *(void **)(v45 + v46 - 56)) {
            free(v47);
          }
          v46 -= 72;
        }
        while (v46);
      }
      goto LABEL_12;
    }
    if (*(_DWORD *)(a1 + 12) >= v12)
    {
      if (v13)
      {
        uint64_t v22 = v4 + 72 * v13;
        uint64_t v23 = *(void *)a1 + 16;
        uint64_t v24 = v4 + 16;
        do
        {
          *(_OWORD *)(v23 - 16) = *(_OWORD *)(v24 - 16);
          if (v24 != v23) {
            llvm::SmallPtrSetImplBase::MoveFrom(v23, 2, (double *)v24);
          }
          uint64_t v25 = v24 - 16;
          *(void *)(v23 + 48) = *(void *)(v24 + 48);
          v23 += 72;
          v24 += 72;
        }
        while (v25 + 72 != v22);
        goto LABEL_35;
      }
    }
    else
    {
      if (v13)
      {
        int v14 = *(char **)a1;
        uint64_t v15 = 72 * v13;
        do
        {
          unint64_t v16 = *(void **)&v14[v15 - 48];
          if (v16 != *(void **)&v14[v15 - 56]) {
            free(v16);
          }
          v15 -= 72;
        }
        while (v15);
      }
      *(_DWORD *)(a1 + 8) = 0;
      sub_1CCE0B00C((char **)a1, v12);
    }
    uint64_t v13 = 0;
LABEL_35:
    uint64_t v26 = *a2;
    uint64_t v27 = *((unsigned int *)a2 + 2);
    if (v13 != v27)
    {
      int v28 = *(char **)a1;
      uint64_t v29 = 72 * v13;
      uint64_t v30 = 72 * v27;
      do
      {
        uint64_t v31 = v26 + v29;
        int v32 = &v28[v29];
        *(_OWORD *)int v32 = *(_OWORD *)(v26 + v29);
        int v33 = &v28[v29 + 48];
        *((void *)v32 + 2) = v33;
        uint64_t v35 = *(void *)(v26 + v29 + 16);
        uint64_t v34 = *(void *)(v26 + v29 + 24);
        if (v34 == v35)
        {
          *((void *)v32 + 3) = v33;
          uint64_t v36 = *(unsigned int *)(v31 + 36);
          if (v36) {
            memmove(v33, *(const void **)(v31 + 24), 8 * v36);
          }
        }
        else
        {
          *((void *)v32 + 3) = v34;
          *(void *)(v31 + 24) = v35;
        }
        uint64_t v37 = v26 + v29;
        BOOL v38 = &v28[v29];
        *((void *)v38 + 4) = *(void *)(v26 + v29 + 32);
        *((_DWORD *)v38 + 10) = *(_DWORD *)(v26 + v29 + 40);
        *(void *)(v37 + 32) = 2;
        *(_DWORD *)(v37 + 40) = 0;
        *((void *)v38 + 8) = *(void *)(v26 + v29 + 64);
        v28 += 72;
        v26 += 72;
        v30 -= 72;
      }
      while (v29 != v30);
      uint64_t v26 = *a2;
    }
    *(_DWORD *)(a1 + 8) = v12;
    uint64_t v39 = *v10;
    if (v39)
    {
      uint64_t v40 = 72 * v39;
      do
      {
        uint64_t v41 = *(void **)(v26 + v40 - 48);
        if (v41 != *(void **)(v26 + v40 - 56)) {
          free(v41);
        }
        v40 -= 72;
      }
      while (v40);
    }
    goto LABEL_12;
  }
  return a1;
}

void sub_1CCE0B00C(char **a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *((unsigned int *)a1 + 3);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  unint64_t v6 = (char *)malloc_type_malloc(72 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v7 = v6;
  uint64_t v8 = *a1;
  uint64_t v9 = *((unsigned int *)a1 + 2);
  if (v9)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 72 * v9;
    do
    {
      unint64_t v12 = (const void **)&v8[v10];
      uint64_t v13 = &v7[v10];
      *(_OWORD *)uint64_t v13 = *(_OWORD *)&v8[v10];
      int v14 = &v7[v10 + 48];
      *((void *)v13 + 2) = v14;
      unint64_t v16 = *(const void **)&v8[v10 + 16];
      uint64_t v15 = *(const void **)&v8[v10 + 24];
      if (v15 == v16)
      {
        *((void *)v13 + 3) = v14;
        uint64_t v17 = *((unsigned int *)v12 + 9);
        if (v17) {
          memmove(v14, v12[3], 8 * v17);
        }
      }
      else
      {
        *((void *)v13 + 3) = v15;
        void v12[3] = v16;
      }
      uint64_t v18 = &v8[v10];
      uint64_t v19 = &v7[v10];
      *((void *)v19 + 4) = *(void *)&v8[v10 + 32];
      *((_DWORD *)v19 + 10) = *(_DWORD *)&v8[v10 + 40];
      *((void *)v18 + 4) = 2;
      *((_DWORD *)v18 + 10) = 0;
      *((void *)v19 + 8) = *(void *)&v8[v10 + 64];
      v10 += 72;
    }
    while (v11 != v10);
    uint64_t v8 = *a1;
    uint64_t v20 = *((unsigned int *)a1 + 2);
    if (v20)
    {
      uint64_t v21 = 72 * v20;
      do
      {
        uint64_t v22 = *(void **)&v8[v21 - 48];
        if (v22 != *(void **)&v8[v21 - 56]) {
          free(v22);
        }
        v21 -= 72;
      }
      while (v21);
      uint64_t v8 = *a1;
    }
  }
  if (v8 != (char *)(a1 + 2)) {
    free(v8);
  }
  *a1 = v7;
  *((_DWORD *)a1 + 3) = v5;
}

uint64_t sub_1CCE0B1A0(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = a2 + 16;
    uint64_t v5 = *(_OWORD **)a2;
    if (*(void *)a2 != a2 + 16)
    {
      unint64_t v6 = *(char **)a1;
      uint64_t v7 = *(unsigned int *)(a1 + 8);
      if (v7)
      {
        uint64_t v8 = 96 * v7;
        do
        {
          uint64_t v9 = *(char **)&v6[v8 - 64];
          if (&v6[v8 - 48] != v9) {
            free(v9);
          }
          v8 -= 96;
        }
        while (v8);
        unint64_t v6 = *(char **)a1;
      }
      if (v6 != (char *)(a1 + 16)) {
        free(v6);
      }
      *(void *)a1 = *(void *)a2;
      uint64_t v10 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)a2 = v4;
      *(_DWORD *)(a2 + 12) = 0;
LABEL_12:
      *uint64_t v10 = 0;
      return a1;
    }
    uint64_t v10 = (_DWORD *)(a2 + 8);
    unint64_t v12 = *(unsigned int *)(a2 + 8);
    uint64_t v13 = *(unsigned int *)(a1 + 8);
    if (v13 >= v12)
    {
      uint64_t v17 = *(char **)a1;
      if (v12)
      {
        uint64_t v18 = &v5[6 * v12];
        do
        {
          long long v19 = v5[1];
          *(_OWORD *)uint64_t v17 = *v5;
          *((_OWORD *)v17 + 1) = v19;
          sub_1CC133E7C((uint64_t)(v17 + 32), (uint64_t)(v5 + 2));
          *((_OWORD *)v17 + 5) = v5[5];
          v17 += 96;
          v5 += 6;
        }
        while (v5 != v18);
        uint64_t v20 = v17;
        LODWORD(v13) = *(_DWORD *)(a1 + 8);
        uint64_t v17 = *(char **)a1;
      }
      else
      {
        uint64_t v20 = *(char **)a1;
      }
      for (uint64_t i = &v17[96 * v13]; i != v20; i -= 96)
      {
        uint64_t v36 = (char *)*((void *)i - 8);
        if (i - 48 != v36) {
          free(v36);
        }
      }
      *(_DWORD *)(a1 + 8) = v12;
      uint64_t v37 = *(unsigned int *)(a2 + 8);
      if (v37)
      {
        BOOL v38 = *(_OWORD **)a2;
        uint64_t v39 = 6 * v37;
        do
        {
          uint64_t v40 = *(_OWORD **)&v38[v39 - 4];
          if (&v38[v39 - 3] != v40) {
            free(v40);
          }
          v39 -= 6;
        }
        while (v39 * 16);
      }
      goto LABEL_12;
    }
    if (*(_DWORD *)(a1 + 12) >= v12)
    {
      if (v13)
      {
        uint64_t v21 = &v5[6 * v13];
        uint64_t v22 = *(char **)a1;
        do
        {
          long long v23 = v5[1];
          *(_OWORD *)uint64_t v22 = *v5;
          *((_OWORD *)v22 + 1) = v23;
          sub_1CC133E7C((uint64_t)(v22 + 32), (uint64_t)(v5 + 2));
          *((_OWORD *)v22 + 5) = v5[5];
          v5 += 6;
          v22 += 96;
        }
        while (v5 != v21);
        goto LABEL_31;
      }
    }
    else
    {
      if (v13)
      {
        int v14 = *(char **)a1;
        uint64_t v15 = 96 * v13;
        do
        {
          unint64_t v16 = *(char **)&v14[v15 - 64];
          if (&v14[v15 - 48] != v16) {
            free(v16);
          }
          v15 -= 96;
        }
        while (v15);
      }
      *(_DWORD *)(a1 + 8) = 0;
      sub_1CCE0B488((char **)a1, v12);
    }
    uint64_t v13 = 0;
LABEL_31:
    uint64_t v24 = *(_OWORD **)a2;
    uint64_t v25 = *(unsigned int *)(a2 + 8);
    if (v13 != v25)
    {
      uint64_t v26 = &v24[6 * v25];
      uint64_t v27 = *(char **)a1;
      uint64_t v28 = 6 * v13;
      do
      {
        uint64_t v29 = &v24[v28];
        uint64_t v30 = &v27[v28 * 16];
        long long v31 = v24[v28 + 1];
        *(_OWORD *)uint64_t v30 = v24[v28];
        *((_OWORD *)v30 + 1) = v31;
        *(void *)&v27[v28 * 16 + 32] = &v27[v28 * 16 + 48];
        *((void *)v30 + 5) = 0x400000000;
        if (DWORD2(v24[v28 + 2])) {
          sub_1CC133E7C((uint64_t)&v27[v28 * 16 + 32], (uint64_t)(v29 + 2));
        }
        *((_OWORD *)v30 + 5) = v29[5];
        v24 += 6;
        v27 += 96;
      }
      while (v29 + 6 != v26);
      uint64_t v24 = *(_OWORD **)a2;
    }
    *(_DWORD *)(a1 + 8) = v12;
    uint64_t v32 = *v10;
    if (v32)
    {
      uint64_t v33 = 6 * v32;
      do
      {
        uint64_t v34 = *(_OWORD **)&v24[v33 - 4];
        if (&v24[v33 - 3] != v34) {
          free(v34);
        }
        v33 -= 6;
      }
      while (v33 * 16);
    }
    goto LABEL_12;
  }
  return a1;
}

void sub_1CCE0B488(char **a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *((unsigned int *)a1 + 3);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  unint64_t v6 = (char *)malloc_type_malloc(96 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v7 = v6;
  uint64_t v8 = *a1;
  int v9 = *((_DWORD *)a1 + 2);
  if (v9)
  {
    uint64_t v10 = &v8[96 * v9];
    uint64_t v11 = (uint64_t)(v8 + 32);
    unint64_t v12 = v6 + 40;
    do
    {
      long long v13 = *(_OWORD *)(v11 - 32);
      *(_OWORD *)(v12 - 24) = *(_OWORD *)(v11 - 16);
      *(_OWORD *)(v12 - 40) = v13;
      *((void *)v12 - 1) = v12 + 8;
      *(void *)unint64_t v12 = 0x400000000;
      if (*(_DWORD *)(v11 + 8)) {
        sub_1CC133E7C((uint64_t)(v12 - 8), v11);
      }
      uint64_t v14 = v11 - 32;
      *(_OWORD *)(v12 + 40) = *(_OWORD *)(v11 + 48);
      v11 += 96;
      v12 += 96;
    }
    while ((char *)(v14 + 96) != v10);
    uint64_t v8 = *a1;
    uint64_t v15 = *((unsigned int *)a1 + 2);
    if (v15)
    {
      uint64_t v16 = 96 * v15;
      do
      {
        uint64_t v17 = *(char **)&v8[v16 - 64];
        if (&v8[v16 - 48] != v17) {
          free(v17);
        }
        v16 -= 96;
      }
      while (v16);
      uint64_t v8 = *a1;
    }
  }
  if (v8 != (char *)(a1 + 2)) {
    free(v8);
  }
  *a1 = v7;
  *((_DWORD *)a1 + 3) = v5;
}

void sub_1CCE0B5F0(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = *(_DWORD *)(a1 + 16);
  if (v1)
  {
    uint64_t v7 = -1;
    uint64_t v2 = *(void ***)a1;
    uint64_t v3 = *(void *)a1 + 48 * v1;
    do
    {
      unint64_t v6 = *v2;
      uint64_t v5 = v2 + 2;
      unint64_t v4 = v6;
      if (v6 != v5) {
        free(v4);
      }
      uint64_t v2 = (void **)(v5 + 4);
    }
    while (v2 != (void **)v3);
  }
}

unint64_t sub_1CCE0B6D0(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v5 = v3 + 1;
    unint64_t v6 = *(void *)a1 + 72 * v3;
    if (*(void *)a1 <= a2 && v6 > a2)
    {
      unint64_t v8 = a2 - *(void *)a1;
      sub_1CCE0B00C((char **)a1, v5);
      return *(void *)a1 + v8;
    }
    else
    {
      sub_1CCE0B00C((char **)a1, v5);
    }
  }
  return a2;
}

uint64_t sub_1CCE0B73C(unint64_t *a1, uint64_t a2, unsigned int a3, unint64_t a4)
{
  v67[4] = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a2 + 680)) {
    BOOL v4 = *(unsigned char *)(a2 + 657) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4) {
    return 0;
  }
  __base = v65;
  uint64_t v64 = 0x400000000;
  unsigned int v9 = *(_DWORD *)(a4 + 40);
  if (v9)
  {
    sub_1CD6BBEE8((uint64_t)&__base, a4 + 32);
    unsigned int v9 = v64;
  }
  uint64_t v10 = *(void *)(a4 + 80);
  if (v10)
  {
    if (v9 >= HIDWORD(v64)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)__base + v9) = v10;
    unsigned int v9 = v64 + 1;
    LODWORD(v64) = v64 + 1;
  }
  if (v9 >= 2) {
    qsort(__base, v9, 8uLL, (int (__cdecl *)(const void *, const void *))sub_1CD4783D8);
  }
  v66[0] = 0;
  char v11 = sub_1CCE0CA38(*(void *)a2, *(_DWORD *)(a2 + 16), (uint64_t)&__base, v66);
  if ((v11 & 1) == 0)
  {
    int v13 = *(_DWORD *)(a2 + 8);
    unsigned int v14 = *(_DWORD *)(a2 + 16);
    if (4 * v13 + 4 >= 3 * v14)
    {
      v14 *= 2;
    }
    else if (v14 + ~v13 - *(_DWORD *)(a2 + 12) > v14 >> 3)
    {
LABEL_21:
      uint64_t v15 = v66[0];
      ++*(_DWORD *)(a2 + 8);
      v66[0] = v67;
      v67[0] = -1;
      v66[1] = 0x400000001;
      if (*(_DWORD *)(v15 + 8) != 1 || **(void **)v15 != v67[0]) {
        --*(_DWORD *)(a2 + 12);
      }
      sub_1CD6BBEE8(v15, (uint64_t)&__base);
      uint64_t v16 = *(unsigned int *)(a2 + 680);
      unint64_t v17 = *(void *)(a2 + 672);
      unint64_t v18 = a4;
      if (v16 >= *(_DWORD *)(a2 + 684))
      {
        int v59 = (unint64_t *)(a2 + 672);
        unint64_t v60 = v16 + 1;
        if (v17 <= a4 && v17 + 96 * v16 > a4)
        {
          unint64_t v61 = a4 - v17;
          sub_1CCE0B488((char **)(a2 + 672), v60);
          unint64_t v17 = *v59;
          unint64_t v18 = *v59 + v61;
        }
        else
        {
          sub_1CCE0B488((char **)(a2 + 672), v60);
          unint64_t v17 = *v59;
          unint64_t v18 = a4;
        }
      }
      unsigned int v19 = *(_DWORD *)(a2 + 680);
      unint64_t v20 = v17 + 96 * v19;
      long long v21 = *(_OWORD *)(v18 + 16);
      *(_OWORD *)unint64_t v20 = *(_OWORD *)v18;
      *(_OWORD *)(v20 + 16) = v21;
      *(void *)(v20 + 40) = 0x400000000;
      *(void *)(v20 + 32) = v20 + 48;
      uint64_t v22 = v20 + 32;
      if (*(_DWORD *)(v18 + 40)) {
        sub_1CD6BBEE8(v22, v18 + 32);
      }
      *(_OWORD *)(v17 + 96 * v19 + 80) = *(_OWORD *)(v18 + 80);
      ++*(_DWORD *)(a2 + 680);
      long long v23 = (llvm::SmallPtrSetImplBase *)(a2 + 1840);
      uint64_t v24 = *(unsigned int *)(a4 + 40);
      if (v24)
      {
        uint64_t v25 = *(uint64_t **)(a4 + 32);
        uint64_t v26 = &v25[v24];
        while (1)
        {
          uint64_t v27 = *(void *)(a2 + 1848);
          uint64_t v28 = *v25;
          uint64_t v29 = *(unsigned int *)(a2 + 1860);
          if (v27 != *(void *)(a2 + 1840)) {
            break;
          }
          if (v29)
          {
            uint64_t v30 = 0;
            uint64_t v31 = 8 * v29;
            uint64_t v32 = *(void **)(a2 + 1848);
            while (*v32 != v28)
            {
              if (*v32 == -2) {
                uint64_t v30 = v32;
              }
              ++v32;
              v31 -= 8;
              if (!v31)
              {
                if (!v30) {
                  goto LABEL_37;
                }
                *uint64_t v30 = v28;
                --*(_DWORD *)(a2 + 1864);
                goto LABEL_61;
              }
            }
            goto LABEL_61;
          }
LABEL_37:
          unsigned int v33 = *(_DWORD *)(a2 + 1856);
          if (v29 >= v33) {
            goto LABEL_40;
          }
          *(_DWORD *)(a2 + 1860) = v29 + 1;
          *(void *)(v27 + 8 * v29) = v28;
LABEL_61:
          if (++v25 == v26) {
            goto LABEL_69;
          }
        }
        unsigned int v33 = *(_DWORD *)(a2 + 1856);
LABEL_40:
        if (3 * v33 <= 4 * ((int)v29 - *(_DWORD *)(a2 + 1864)))
        {
          if (v33 >= 0x40) {
            v33 *= 2;
          }
          else {
            unsigned int v33 = 128;
          }
        }
        else if (v33 - v29 >= v33 >> 3)
        {
          goto LABEL_42;
        }
        int v62 = v23;
        llvm::SmallPtrSetImplBase::Grow(v23, v33);
        long long v23 = v62;
        unsigned int v33 = *(_DWORD *)(a2 + 1856);
        uint64_t v27 = *(void *)(a2 + 1848);
LABEL_42:
        unsigned int v34 = v33 - 1;
        unsigned int v35 = (v33 - 1) & ((v28 >> 4) ^ (v28 >> 9));
        uint64_t v36 = (void *)(v27 + 8 * v35);
        uint64_t v37 = *v36;
        if (*v36 == -1)
        {
          BOOL v38 = 0;
LABEL_54:
          if (v38) {
            unint64_t v42 = v38;
          }
          else {
            unint64_t v42 = v36;
          }
          if (*v42 != v28)
          {
            if (*v42 == -2) {
              --*(_DWORD *)(a2 + 1864);
            }
            else {
              ++*(_DWORD *)(a2 + 1860);
            }
            void *v42 = v28;
          }
        }
        else
        {
          BOOL v38 = 0;
          int v39 = 1;
          while (v37 != v28)
          {
            if (v38) {
              BOOL v40 = 0;
            }
            else {
              BOOL v40 = v37 == -2;
            }
            if (v40) {
              BOOL v38 = v36;
            }
            unsigned int v41 = v35 + v39++;
            unsigned int v35 = v41 & v34;
            uint64_t v36 = (void *)(v27 + 8 * (v41 & v34));
            uint64_t v37 = *v36;
            if (*v36 == -1) {
              goto LABEL_54;
            }
          }
        }
        goto LABEL_61;
      }
LABEL_69:
      uint64_t v43 = *(void *)(a4 + 80);
      if (!v43) {
        goto LABEL_14;
      }
      uint64_t v44 = *(void *)(a2 + 1848);
      uint64_t v45 = *(unsigned int *)(a2 + 1860);
      if (v44 == *(void *)(a2 + 1840))
      {
        if (v45)
        {
          uint64_t v46 = 0;
          uint64_t v47 = 8 * v45;
          int v48 = *(void **)(a2 + 1848);
          while (*v48 != v43)
          {
            if (*v48 == -2) {
              uint64_t v46 = v48;
            }
            ++v48;
            v47 -= 8;
            if (!v47)
            {
              if (!v46) {
                goto LABEL_78;
              }
              *uint64_t v46 = v43;
              --*(_DWORD *)(a2 + 1864);
              goto LABEL_14;
            }
          }
          goto LABEL_14;
        }
LABEL_78:
        unsigned int v49 = *(_DWORD *)(a2 + 1856);
        if (v45 < v49)
        {
          *(_DWORD *)(a2 + 1860) = v45 + 1;
          *(void *)(v44 + 8 * v45) = v43;
          goto LABEL_14;
        }
      }
      else
      {
        unsigned int v49 = *(_DWORD *)(a2 + 1856);
      }
      if (3 * v49 <= 4 * ((int)v45 - *(_DWORD *)(a2 + 1864)))
      {
        if (v49 >= 0x40) {
          v49 *= 2;
        }
        else {
          unsigned int v49 = 128;
        }
      }
      else if (v49 - v45 >= v49 >> 3)
      {
        goto LABEL_83;
      }
      llvm::SmallPtrSetImplBase::Grow(v23, v49);
      unsigned int v49 = *(_DWORD *)(a2 + 1856);
      uint64_t v44 = *(void *)(a2 + 1848);
LABEL_83:
      unsigned int v50 = v49 - 1;
      unsigned int v51 = (v49 - 1) & ((v43 >> 4) ^ (v43 >> 9));
      uint64_t v52 = (void *)(v44 + 8 * v51);
      uint64_t v53 = *v52;
      if (*v52 == -1)
      {
        uint64_t v54 = 0;
LABEL_95:
        if (v54) {
          unsigned int v58 = v54;
        }
        else {
          unsigned int v58 = v52;
        }
        if (*v58 != v43)
        {
          if (*v58 == -2) {
            --*(_DWORD *)(a2 + 1864);
          }
          else {
            ++*(_DWORD *)(a2 + 1860);
          }
          void *v58 = v43;
        }
      }
      else
      {
        uint64_t v54 = 0;
        int v55 = 1;
        while (v53 != v43)
        {
          if (v54) {
            BOOL v56 = 0;
          }
          else {
            BOOL v56 = v53 == -2;
          }
          if (v56) {
            uint64_t v54 = v52;
          }
          unsigned int v57 = v51 + v55++;
          unsigned int v51 = v57 & v50;
          uint64_t v52 = (void *)(v44 + 8 * (v57 & v50));
          uint64_t v53 = *v52;
          if (*v52 == -1) {
            goto LABEL_95;
          }
        }
      }
      goto LABEL_14;
    }
    sub_1CCE0CC48(a2, v14);
    v66[0] = 0;
    sub_1CCE0CA38(*(void *)a2, *(_DWORD *)(a2 + 16), (uint64_t)&__base, v66);
    goto LABEL_21;
  }
LABEL_14:
  if (__base != v65) {
    free(__base);
  }
  if (v11) {
    return 0;
  }
  sub_1CCE0A3CC(a1, a4, a3);
  return 1;
}

void sub_1CCE0BD38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  if (llvm::ScalarEvolution::getBlockDisposition((llvm::ScalarEvolution *)a5, (const llvm::SCEV *)a1, **(const llvm::BasicBlock ***)(a2 + 32)) == 2)
  {
    unsigned int v10 = *(_DWORD *)(a3 + 8);
    if (v10 >= *(_DWORD *)(a3 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)a3 + 8 * v10) = a1;
    ++*(_DWORD *)(a3 + 8);
    return;
  }
  int v11 = *(unsigned __int16 *)(a1 + 24);
  if (a1 && v11 == 4)
  {
    uint64_t v12 = *(void *)(a1 + 40);
    if (v12)
    {
      int v13 = *(uint64_t **)(a1 + 32);
      uint64_t v14 = 8 * v12;
      do
      {
        uint64_t v15 = *v13++;
        sub_1CCE0BD38(v15, a2, a3, a4, a5);
        v14 -= 8;
      }
      while (v14);
    }
    return;
  }
  if (a1 && v11 == 7)
  {
    uint64_t v16 = **(llvm::SCEV ***)(a1 + 32);
    if (!llvm::SCEV::isZero(v16) && *(void *)(a1 + 40) == 2)
    {
      sub_1CCE0BD38(v16, a2, a3, a4, a5);
      unint64_t v17 = *(uint64_t **)(a1 + 32);
      while (2)
      {
        uint64_t v18 = *v17;
        switch(*(_WORD *)(v18 + 24))
        {
          case 1:
          case 2:
          case 3:
          case 0xD:
            uint64_t v24 = (llvm::Type **)(v18 + 40);
            break;
          case 4:
            uint64_t v24 = (llvm::Type **)(v18 + 48);
            break;
          case 5:
          case 7:
          case 8:
          case 9:
          case 0xA:
          case 0xB:
          case 0xC:
            unint64_t v17 = *(uint64_t **)(v18 + 32);
            continue;
          case 6:
            unint64_t v17 = (uint64_t *)(v18 + 40);
            continue;
          case 0xE:
            uint64_t v24 = *(llvm::Type ***)(v18 - 8);
            break;
          default:
            uint64_t v24 = *(llvm::Type ***)(v18 + 32);
            break;
        }
        break;
      }
      unint64_t Constant = llvm::ScalarEvolution::getConstant((llvm::ScalarEvolution *)a5, *v24, 0, 0);
      uint64_t v52 = Constant;
      uint64_t v53 = *(void *)(a1 + 40);
      if (v53 == 2)
      {
        uint64_t v54 = *(void *)(*(void *)(a1 + 32) + 8);
      }
      else
      {
        unint64_t v67 = Constant;
        uint64_t v68 = *(void *)(a1 + 32);
        uint64_t v78 = v80;
        uint64_t v79 = 0x300000000;
        unint64_t v69 = 8 * v53 - 8;
        if (v69 >= 0x19) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        int v70 = 0;
        if (v53 != 1)
        {
          memcpy(v78, (const void *)(v68 + 8), 8 * v53 - 8);
          int v70 = v79;
        }
        LODWORD(v79) = v70 + (v69 >> 3);
        uint64_t v54 = sub_1CD478318((llvm::ScalarEvolution *)a5, (uint64_t)&v78, *(const llvm::Loop **)(a1 + 48), 0);
        if (v78 != v80) {
          free(v78);
        }
        uint64_t v52 = v67;
      }
      uint64_t AddRecExpr = llvm::ScalarEvolution::getAddRecExpr((llvm::ScalarEvolution *)a5, v52, v54, *(const llvm::Loop **)(a1 + 48), 0);
      sub_1CCE0BD38(AddRecExpr, a2, a3, a4, a5);
      return;
    }
    goto LABEL_23;
  }
  if (!a1 || v11 != 5 || (unsigned int v19 = *(llvm::SCEV ***)(a1 + 32), !llvm::SCEV::isAllOnesValue(*v19)))
  {
LABEL_23:
    unsigned int v23 = *(_DWORD *)(a4 + 8);
    if (v23 >= *(_DWORD *)(a4 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)a4 + 8 * v23) = a1;
    ++*(_DWORD *)(a4 + 8);
    return;
  }
  uint64_t v20 = *(void *)(a1 + 40);
  uint64_t v78 = v80;
  uint64_t v79 = 0x400000000;
  unint64_t v21 = 8 * v20 - 8;
  if (v21 >= 0x21) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  int v22 = 0;
  if (v20 != 1)
  {
    memcpy(v78, v19 + 1, 8 * v20 - 8);
    int v22 = v79;
  }
  LODWORD(v79) = v22 + (v21 >> 3);
  uint64_t MulExpr = llvm::ScalarEvolution::getMulExpr(a5, (uint64_t)&v78, 0, 0);
  BOOL v75 = v77;
  uint64_t v76 = 0x400000000;
  uint64_t v72 = v74;
  uint64_t v73 = 0x400000000;
  sub_1CCE0BD38(MulExpr, a2, &v75, &v72, a5);
  while (2)
  {
    switch(*(_WORD *)(MulExpr + 24))
    {
      case 1:
      case 2:
      case 3:
      case 0xD:
        uint64_t v29 = MulExpr + 40;
        goto LABEL_39;
      case 4:
        uint64_t v29 = MulExpr + 48;
        goto LABEL_39;
      case 5:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
        uint64_t v28 = *(uint64_t **)(MulExpr + 32);
        goto LABEL_33;
      case 6:
        uint64_t v28 = (uint64_t *)(MulExpr + 40);
LABEL_33:
        uint64_t MulExpr = *v28;
        continue;
      case 0xE:
        uint64_t v29 = *(void *)(MulExpr - 8);
        goto LABEL_39;
      default:
        uint64_t v29 = *(void *)(MulExpr + 32);
LABEL_39:
        uint64_t v30 = *(uint64_t ***)v29;
        unsigned int v31 = *(_DWORD *)(*(void *)v29 + 8);
        if (v31 != 13)
        {
          uint64_t v56 = *(void *)(*(void *)a5 + 40);
          if ((v31 & 0xFE) == 0x12) {
            unsigned int v31 = *(_DWORD *)(*v30[2] + 8);
          }
          uint64_t v57 = *(void *)(v56 + 504);
          if (v31 < 0x100) {
            goto LABEL_90;
          }
          unsigned int v58 = v31 >> 8;
          unint64_t v59 = *(unsigned int *)(v56 + 512);
          uint64_t v60 = v57;
          if (v59)
          {
            uint64_t v60 = v57;
            unint64_t v61 = v59;
            do
            {
              unint64_t v62 = v61 >> 1;
              uint64_t v63 = v60 + 16 * (v61 >> 1);
              unsigned int v64 = *(_DWORD *)(v63 + 8);
              uint64_t v65 = v63 + 16;
              v61 += ~(v61 >> 1);
              if (v64 < v58) {
                uint64_t v60 = v65;
              }
              else {
                unint64_t v61 = v62;
              }
            }
            while (v61);
          }
          if (v60 == v57 + 16 * v59 || *(_DWORD *)(v60 + 8) != v58) {
LABEL_90:
          }
            uint64_t v60 = v57;
          long long v66 = (uint64_t **)llvm::IntegerType::get((llvm::IntegerType *)*v30, (llvm::LLVMContext *)*(unsigned int *)(v60 + 12));
          if ((v30[1] & 0xFE) == 0x12)
          {
            unint64_t v71 = (llvm::Type *)*((unsigned int *)v30 + 8);
            if (*((_DWORD *)v30 + 2) == 19) {
              llvm::ScalableVectorType::get(v66, v71);
            }
            else {
              llvm::FixedVectorType::get((llvm::FixedVectorType *)v66, v71);
            }
          }
          uint64_t v30 = v66;
        }
        AllOnesValue = llvm::Constant::getAllOnesValue((llvm::Constant *)v30, v26, v27);
        uint64_t v33 = *(void *)(a5 + 104);
        unsigned int v34 = *(_DWORD *)(a5 + 120);
        if (!v34) {
          goto LABEL_46;
        }
        unsigned int v35 = ((AllOnesValue >> 4) ^ (AllOnesValue >> 9)) & (v34 - 1);
        uint64_t v36 = v33 + 48 * v35;
        uint64_t v37 = *(void **)(v36 + 24);
        if (v37 == AllOnesValue) {
          goto LABEL_47;
        }
        int v38 = 1;
        break;
    }
    break;
  }
  while (v37 != (void *)-4096)
  {
    unsigned int v39 = v35 + v38++;
    unsigned int v35 = v39 & (v34 - 1);
    uint64_t v36 = v33 + 48 * v35;
    uint64_t v37 = *(void **)(v36 + 24);
    if (v37 == AllOnesValue) {
      goto LABEL_47;
    }
  }
LABEL_46:
  uint64_t v36 = v33 + 48 * v34;
LABEL_47:
  if (v36 == v33 + 48 * v34 || (uint64_t SCEVIter = *(void *)(v36 + 40)) == 0) {
    uint64_t SCEVIter = llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)a5, (unint64_t)AllOnesValue);
  }
  if (v76)
  {
    unsigned int v41 = (uint64_t *)v75;
    uint64_t v42 = 8 * v76;
    do
    {
      uint64_t v43 = *v41;
      uint64_t v81 = &v83;
      uint64_t v83 = SCEVIter;
      uint64_t v84 = v43;
      uint64_t v82 = 0x200000002;
      uint64_t v44 = llvm::ScalarEvolution::getMulExpr(a5, (uint64_t)&v81, 0, 0);
      if (v81 != &v83) {
        free(v81);
      }
      unint64_t v45 = *(unsigned int *)(a3 + 8);
      if (v45 >= *(unsigned int *)(a3 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a3 + 8 * v45) = v44;
      ++*(_DWORD *)(a3 + 8);
      ++v41;
      v42 -= 8;
    }
    while (v42);
  }
  uint64_t v46 = (uint64_t *)v72;
  if (v73)
  {
    uint64_t v47 = 8 * v73;
    do
    {
      uint64_t v48 = *v46;
      uint64_t v81 = &v83;
      uint64_t v83 = SCEVIter;
      uint64_t v84 = v48;
      uint64_t v82 = 0x200000002;
      uint64_t v49 = llvm::ScalarEvolution::getMulExpr(a5, (uint64_t)&v81, 0, 0);
      if (v81 != &v83) {
        free(v81);
      }
      unint64_t v50 = *(unsigned int *)(a4 + 8);
      if (v50 >= *(unsigned int *)(a4 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a4 + 8 * v50) = v49;
      ++*(_DWORD *)(a4 + 8);
      ++v46;
      v47 -= 8;
    }
    while (v47);
    uint64_t v46 = (uint64_t *)v72;
  }
  if (v46 != (uint64_t *)v74) {
    free(v46);
  }
  if (v75 != v77) {
    free(v75);
  }
  if (v78 != v80) {
    free(v78);
  }
}

uint64_t sub_1CCE0C4F4(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 80);
  if (!result)
  {
    unint64_t v5 = (unsigned int *)(a1 + 40);
    unsigned int v10 = *(_DWORD *)(a1 + 40);
    if (v10 < 2) {
      return result;
    }
    unint64_t v6 = (uint64_t **)(a1 + 32);
LABEL_12:
    uint64_t result = *(void *)(*(void *)(a1 + 32) + 8 * v10 - 8);
    *(_DWORD *)(a1 + 40) = v10 - 1;
    *(void *)(a1 + 80) = result;
    *(void *)(a1 + 24) = 1;
    goto LABEL_13;
  }
  if (*(void *)(a1 + 24) != 1) {
    return result;
  }
  unint64_t v5 = (unsigned int *)(a1 + 40);
  unint64_t v6 = (uint64_t **)(a1 + 32);
  if (!*(_DWORD *)(a1 + 40)) {
    goto LABEL_26;
  }
  uint64_t result = sub_1CCE0C69C(result, a2);
  if (result) {
    return result;
  }
  uint64_t v7 = *v5;
  if (!v7) {
    return result;
  }
  unint64_t v8 = *v6;
  uint64_t v9 = 8 * v7;
  while (1)
  {
    uint64_t result = sub_1CCE0C69C(*v8, a2);
    if (result) {
      break;
    }
    ++v8;
    v9 -= 8;
    if (!v9) {
      return result;
    }
  }
  unsigned int v10 = *(_DWORD *)(a1 + 40);
  uint64_t result = *(void *)(a1 + 80);
  if (!v10)
  {
LABEL_26:
    if (!*(_DWORD *)(a1 + 44)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    **(void **)(a1 + 32) = result;
    ++*(_DWORD *)(a1 + 40);
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 80) = 0;
    return result;
  }
  if (!result) {
    goto LABEL_12;
  }
LABEL_13:
  uint64_t result = sub_1CCE0C69C(result, a2);
  if ((result & 1) == 0)
  {
    int v11 = *v6;
    uint64_t v12 = *v5;
    if (v12)
    {
      uint64_t v13 = 8 * v12;
      uint64_t v14 = &v11[v12];
      while (1)
      {
        uint64_t result = sub_1CCE0C69C(*v11, a2);
        if (result) {
          break;
        }
        ++v11;
        v13 -= 8;
        if (!v13)
        {
          int v11 = v14;
          break;
        }
      }
      uint64_t v15 = v11;
      int v11 = *v6;
      uint64_t v16 = *v5;
    }
    else
    {
      uint64_t v16 = 0;
      uint64_t v15 = *v6;
    }
    if (v15 != &v11[v16])
    {
      uint64_t v17 = *(void *)(a1 + 80);
      *(void *)(a1 + 80) = *v15;
      *uint64_t v15 = v17;
    }
  }
  return result;
}

uint64_t sub_1CCE0C69C(uint64_t a1, uint64_t a2)
{
  v21[8] = *MEMORY[0x1E4F143B8];
  unsigned __int8 v11 = 0;
  uint64_t v12 = a2;
  uint64_t v13 = &v11;
  uint64_t v14 = v16;
  uint64_t v15 = 0x800000000;
  uint64_t v17 = v21;
  uint64_t v18 = v21;
  uint64_t v19 = 8;
  int v20 = 0;
  sub_1CCE0C854((uint64_t)&v13, a1);
  unsigned int v2 = v15;
  while (v2)
  {
    if (*v13) {
      break;
    }
    uint64_t v3 = *((void *)v14 + --v2);
    LODWORD(v15) = v2;
    switch(*(_WORD *)(v3 + 24))
    {
      case 1:
      case 2:
      case 3:
      case 0xD:
        uint64_t v9 = (uint64_t *)(v3 + 32);
        goto LABEL_14;
      case 4:
      case 5:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
        uint64_t v4 = *(void *)(v3 + 40);
        if (v4)
        {
          unint64_t v5 = *(uint64_t **)(v3 + 32);
          uint64_t v6 = 8 * v4 - 8;
          do
          {
            uint64_t v7 = *v5++;
            sub_1CCE0C854((uint64_t)&v13, v7);
            if (*v13) {
              BOOL v8 = 1;
            }
            else {
              BOOL v8 = v6 == 0;
            }
            v6 -= 8;
          }
          while (!v8);
        }
        goto LABEL_15;
      case 6:
        sub_1CCE0C854((uint64_t)&v13, *(void *)(v3 + 32));
        uint64_t v9 = (uint64_t *)(v3 + 40);
LABEL_14:
        sub_1CCE0C854((uint64_t)&v13, *v9);
LABEL_15:
        unsigned int v2 = v15;
        break;
      default:
        break;
    }
  }
  if (v18 != v17) {
    free(v18);
  }
  if (v14 != v16) {
    free(v14);
  }
  return v11;
}

void sub_1CCE0C854(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *(void **)(a1 + 88);
  unint64_t v5 = *(void **)(a1 + 96);
  uint64_t v4 = (unsigned int *)(a1 + 88);
  uint64_t v7 = v4[5];
  if (v5 == v6)
  {
    if (v7)
    {
      BOOL v8 = 0;
      uint64_t v9 = 8 * v7;
      unsigned int v10 = v5;
      while (*v10 != a2)
      {
        if (*v10 == -2) {
          BOOL v8 = v10;
        }
        ++v10;
        v9 -= 8;
        if (!v9)
        {
          if (!v8) {
            goto LABEL_9;
          }
          void *v8 = a2;
          --*(_DWORD *)(a1 + 112);
          goto LABEL_33;
        }
      }
      return;
    }
LABEL_9:
    unsigned int v11 = *(_DWORD *)(a1 + 104);
    if (v7 < v11)
    {
      *(_DWORD *)(a1 + 108) = v7 + 1;
      v5[v7] = a2;
LABEL_33:
      if (*(_WORD *)(a2 + 24) == 7 && *(void *)(a2 + 48) == *(void *)(*(void *)a1 + 8))
      {
        **(unsigned char **)a1 = 1;
      }
      else
      {
        unsigned int v21 = *(_DWORD *)(a1 + 16);
        if (v21 >= *(_DWORD *)(a1 + 20)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 8) + 8 * v21) = a2;
        ++*(_DWORD *)(a1 + 16);
      }
      return;
    }
  }
  else
  {
    unsigned int v11 = *(_DWORD *)(a1 + 104);
  }
  if (3 * v11 <= 4 * ((int)v7 - *(_DWORD *)(a1 + 112)))
  {
    if (v11 >= 0x40) {
      v11 *= 2;
    }
    else {
      unsigned int v11 = 128;
    }
  }
  else if (v11 - v7 >= v11 >> 3)
  {
    goto LABEL_14;
  }
  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v4, v11);
  unsigned int v11 = *(_DWORD *)(a1 + 104);
  unint64_t v5 = *(void **)(a1 + 96);
LABEL_14:
  unsigned int v12 = v11 - 1;
  unsigned int v13 = (v11 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v14 = &v5[v13];
  uint64_t v15 = *v14;
  if (*v14 != -1)
  {
    uint64_t v16 = 0;
    int v17 = 1;
    while (v15 != a2)
    {
      if (v16) {
        BOOL v18 = 0;
      }
      else {
        BOOL v18 = v15 == -2;
      }
      if (v18) {
        uint64_t v16 = v14;
      }
      unsigned int v19 = v13 + v17++;
      unsigned int v13 = v19 & v12;
      uint64_t v14 = &v5[v19 & v12];
      uint64_t v15 = *v14;
      if (*v14 == -1) {
        goto LABEL_26;
      }
    }
    return;
  }
  uint64_t v16 = 0;
LABEL_26:
  if (v16) {
    int v20 = v16;
  }
  else {
    int v20 = v14;
  }
  if (*v20 != a2)
  {
    if (*v20 == -2) {
      --*(_DWORD *)(a1 + 112);
    }
    else {
      ++*(_DWORD *)(a1 + 108);
    }
    *int v20 = a2;
    goto LABEL_33;
  }
}

uint64_t sub_1CCE0CA38(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  void v20[4] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v19[4] = v20;
    v20[0] = -1;
    v19[5] = 0x400000001;
    v19[0] = -2;
    uint64_t v18 = 0;
    int v15 = a2 - 1;
    unsigned int v9 = (a2 - 1) & sub_1CD48BB60(*(void **)a3, *(void *)a3 + 8 * *(unsigned int *)(a3 + 8));
    uint64_t v10 = *(unsigned int *)(a3 + 8);
    uint64_t v16 = *(const void **)a3;
    for (int i = 1; ; ++i)
    {
      uint64_t v11 = a1 + 48 * v9;
      int v12 = *(_DWORD *)(v11 + 8);
      if (v10 == v12 && !memcmp(v16, *(const void **)v11, 8 * v10))
      {
        uint64_t v5 = 1;
        goto LABEL_18;
      }
      if (v12 == 1 && !memcmp(*(const void **)v11, v20, 8uLL)) {
        break;
      }
      BOOL v13 = v12 == 1 && memcmp(*(const void **)v11, v19, 8uLL) == 0;
      uint64_t v14 = v18;
      if (v13 && v18 == 0) {
        uint64_t v14 = a1 + 48 * v9;
      }
      uint64_t v18 = v14;
      unsigned int v9 = (v9 + i) & v15;
    }
    uint64_t v5 = 0;
    if (v18) {
      uint64_t v11 = v18;
    }
LABEL_18:
    *a4 = v11;
  }
  else
  {
    uint64_t v5 = 0;
    *a4 = 0;
  }
  return v5;
}

void sub_1CCE0CC48(uint64_t a1, int a2)
{
  uint64_t v19[4] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  *(void *)a1 = operator new(48 * v8, (std::align_val_t)8uLL);
  if (v4)
  {
    sub_1CCE0ABEC(a1);
    __s2 = v19;
    v19[0] = -1;
    uint64_t v18 = 0x400000001;
    uint64_t v14 = v16;
    v16[0] = -2;
    uint64_t v15 = 0x400000001;
    if (v3)
    {
      uint64_t v9 = 48 * v3;
      uint64_t v10 = v4;
      do
      {
        uint64_t v11 = *(unsigned int *)(v10 + 8);
        if (v11 != v18 || (int v12 = *(void **)v10, memcmp(*(const void **)v10, __s2, 8 * v11)))
        {
          if (v11 != v15 || (int v12 = *(void **)v10, memcmp(*(const void **)v10, v14, 8 * v11)))
          {
            uint64_t v13 = 0;
            sub_1CCE0CA38(*(void *)a1, *(_DWORD *)(a1 + 16), v10, &v13);
            sub_1CC133E7C(v13, v10);
            ++*(_DWORD *)(a1 + 8);
            int v12 = *(void **)v10;
          }
        }
        if ((void *)(v10 + 16) != v12) {
          free(v12);
        }
        v10 += 48;
        v9 -= 48;
      }
      while (v9);
      if (v14 != v16) {
        free(v14);
      }
    }
    if (__s2 != v19) {
      free(__s2);
    }
    MEMORY[0x1D25D9CD0](v4, 8);
  }
  else
  {
    sub_1CCE0ABEC(a1);
  }
}

unint64_t *sub_1CCE0CE68(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = 0;
  char v6 = sub_1CBB0BF40(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v18);
  int v7 = v18;
  if (v6) {
    goto LABEL_8;
  }
  int v8 = *(_DWORD *)(a1 + 8);
  unsigned int v9 = *(_DWORD *)(a1 + 16);
  if (4 * v8 + 4 >= 3 * v9)
  {
    v9 *= 2;
    goto LABEL_19;
  }
  if (v9 + ~v8 - *(_DWORD *)(a1 + 12) <= v9 >> 3)
  {
LABEL_19:
    sub_1CCE0D010(a1, v9);
    uint64_t v18 = 0;
    sub_1CBB0BF40(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v18);
    int v7 = v18;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*v7 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  *int v7 = a2;
  v7[1] = 1;
  unsigned int v10 = *(_DWORD *)(a1 + 32);
  if (v10 >= *(_DWORD *)(a1 + 36)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)(a1 + 24) + 8 * v10) = a2;
  ++*(_DWORD *)(a1 + 32);
LABEL_8:
  uint64_t v13 = v7[1];
  int v12 = (unint64_t *)(v7 + 1);
  unint64_t v11 = v13;
  if (v13) {
    unint64_t v14 = v11 >> 58;
  }
  else {
    unint64_t v14 = *(unsigned int *)(v11 + 64);
  }
  if (v14 <= a3 + 1) {
    uint64_t v15 = a3 + 1;
  }
  else {
    uint64_t v15 = v14;
  }
  uint64_t result = sub_1CBA7B5AC(v12, v15, 0);
  unint64_t v17 = *v12;
  if (*v12) {
    unint64_t *v12 = v17 & 0xFC00000000000000 | (2
  }
                                       * (((v17 >> 1) & ~(-1 << (v17 >> 58)) | (1 << a3)) & ~(-1 << (v17 >> 58)))) | 1;
  else {
    *(void *)(*(void *)v17 + 8 * (a3 >> 6)) |= 1 << a3;
  }
  return result;
}

void *sub_1CCE0D010(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      uint64_t v11 = 16 * v10;
      do
      {
        void *result = -4096;
        result += 2;
        v11 -= 16;
      }
      while (v11);
    }
    if (v3)
    {
      int v12 = 0;
      uint64_t v13 = 16 * v3;
      unint64_t v14 = (uint64_t *)(v4 + 8);
      do
      {
        uint64_t v15 = *(v14 - 1);
        if ((v15 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          int v20 = 0;
          sub_1CBB0BF40(*(void *)a1, *(_DWORD *)(a1 + 16), v15, &v20);
          uint64_t v16 = v20;
          uint64_t v17 = *v14;
          *int v20 = v15;
          v16[1] = v17;
          *unint64_t v14 = 1;
          *(_DWORD *)(a1 + 8) = ++v12;
        }
        v14 += 2;
        v13 -= 16;
      }
      while (v13);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v18 = *(unsigned int *)(a1 + 16);
  if (v18)
  {
    uint64_t v19 = 16 * v18;
    do
    {
      void *result = -4096;
      result += 2;
      v19 -= 16;
    }
    while (v19);
  }
  return result;
}

void sub_1CCE0D170(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5)
{
  if (a5 <= 2)
  {
    uint64_t v10 = *(unsigned int *)(a4 + 40);
    if (v10)
    {
      for (uint64_t i = 0; i != v10; ++i)
        sub_1CCE0D248(a1, a2, a3, a4, a5, i, 0);
    }
    if (*(void *)(a4 + 24) == 1)
    {
      sub_1CCE0D248(a1, a2, a3, a4, a5, -1, 1);
    }
  }
}

void sub_1CCE0D248(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, int a5, uint64_t a6, int a7)
{
  v89[8] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a4 + 32;
  uint64_t v13 = (uint64_t *)(*(void *)(a4 + 32) + 8 * a6);
  uint64_t v73 = (long long *)(a4 + 80);
  if (a7) {
    uint64_t v13 = (uint64_t *)(a4 + 80);
  }
  uint64_t v14 = *v13;
  if (*(_DWORD *)(a1 + 72) != 1
    || (sub_1CCE0DA4C(*(void **)(a1 + 48), *(_DWORD *)(a2 + 24), *(void *)(a2 + 32), v14, *(const llvm::Loop **)(a1 + 56), *(llvm::ScalarEvolution **)(a1 + 8)) & 1) == 0)
  {
    BOOL v87 = (const llvm::SCEV **)v89;
    uint64_t v88 = 0x800000000;
    uint64_t v15 = sub_1CCE0DD9C(v14, 0, (uint64_t)&v87, *(void *)(a1 + 56), *(llvm::ScalarEvolution **)(a1 + 8), 0);
    unsigned int v16 = v88;
    if (v15)
    {
      if (v88 >= HIDWORD(v88)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v87[v88] = (const llvm::SCEV *)v15;
      unsigned int v16 = v88 + 1;
      LODWORD(v88) = v88 + 1;
    }
    uint64_t v17 = v87;
    if (v16 >= 2)
    {
      uint64_t v18 = &v87[v16];
      uint64_t v72 = a6;
      int v71 = a5 + 1;
      while (1)
      {
        uint64_t v19 = *v17;
        if (*((_WORD *)*v17 + 12) != 14) {
          goto LABEL_13;
        }
        if (llvm::ScalarEvolution::getLoopDisposition(*(llvm::ScalarEvolution **)(a1 + 8), *v17, *(const llvm::Loop **)(a1 + 56)) == 1)break; {
LABEL_71:
        }
        if (++v17 == v18)
        {
          uint64_t v17 = v87;
          goto LABEL_103;
        }
      }
      uint64_t v19 = *v17;
LABEL_13:
      unint64_t v20 = *(unsigned int *)(a4 + 40);
      if (*(void *)(a4 + 80)) {
        ++v20;
      }
      if ((sub_1CCE0E2BC(*(uint64_t **)(a1 + 48), *(llvm::ScalarEvolution **)(a1 + 8), *(void *)(a2 + 640), *(void *)(a2 + 648), *(_DWORD *)(a2 + 24), *(void *)(a2 + 32), *(void *)(a2 + 40), v19, v20 > 1) & 1) == 0)
      {
        uint64_t v84 = v86;
        uint64_t v85 = 0x800000000;
        unint64_t v21 = (char *)v17 - (char *)v87;
        if ((unint64_t)((char *)v17 - (char *)v87) >= 0x41) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        int v22 = 0;
        if (v87 != v17)
        {
          memcpy(v84, v87, (char *)v17 - (char *)v87);
          int v22 = v85;
        }
        uint64_t v23 = v22 + (v21 >> 3);
        LODWORD(v85) = v23;
        uint64_t v24 = &v87[v88];
        uint64_t v25 = (char *)v24 - (char *)(v17 + 1);
        if (v23 + (v25 >> 3) > (unint64_t)HIDWORD(v85)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v17 + 1 != v24)
        {
          memcpy((char *)v84 + 8 * v23, v17 + 1, (char *)v24 - (char *)(v17 + 1));
          LODWORD(v23) = v85;
        }
        LODWORD(v85) = v23 + ((unint64_t)v25 >> 3);
        if (v85 != 1) {
          goto LABEL_29;
        }
        unint64_t v26 = *(unsigned int *)(a4 + 40);
        if (*(void *)(a4 + 80)) {
          ++v26;
        }
        if ((sub_1CCE0E2BC(*(uint64_t **)(a1 + 48), *(llvm::ScalarEvolution **)(a1 + 8), *(void *)(a2 + 640), *(void *)(a2 + 648), *(_DWORD *)(a2 + 24), *(void *)(a2 + 32), *(void *)(a2 + 40), *(llvm::SCEV **)v84, v26 > 1) & 1) == 0)
        {
LABEL_29:
          uint64_t AddExpr = llvm::ScalarEvolution::getAddExpr(*(void *)(a1 + 8), (unint64_t **)&v84, 0, 0);
          if (!llvm::SCEV::isZero((llvm::SCEV *)AddExpr))
          {
            long long v28 = *(_OWORD *)(a4 + 16);
            v79[0] = *(_OWORD *)a4;
            v79[1] = v28;
            uint64_t v80 = v82;
            uint64_t v81 = 0x400000000;
            if (*(_DWORD *)(a4 + 40)) {
              sub_1CD6BBEE8((uint64_t)&v80, v12);
            }
            long long v83 = *v73;
            if (!AddExpr || *(_WORD *)(AddExpr + 24)) {
              goto LABEL_45;
            }
            uint64_t v29 = **(void **)(AddExpr + 32);
            unsigned int v30 = *(_DWORD *)(v29 + 8);
            uint64_t v31 = *(void *)(**(void **)(a1 + 8) + 40);
            if (v30 == 15)
            {
              if ((v30 & 0xFE) == 0x12) {
                unsigned int v30 = *(_DWORD *)(**(void **)(v29 + 16) + 8);
              }
              uint64_t v53 = *(void *)(v31 + 504);
              if (v30 < 0x100) {
                goto LABEL_87;
              }
              unsigned int v54 = v30 >> 8;
              unint64_t v55 = *(unsigned int *)(v31 + 512);
              uint64_t v56 = *(void *)(v31 + 504);
              if (v55)
              {
                uint64_t v56 = v53;
                unint64_t v57 = v55;
                do
                {
                  unint64_t v58 = v57 >> 1;
                  uint64_t v59 = v56 + 16 * (v57 >> 1);
                  unsigned int v60 = *(_DWORD *)(v59 + 8);
                  uint64_t v61 = v59 + 16;
                  v57 += ~(v57 >> 1);
                  if (v60 < v54) {
                    uint64_t v56 = v61;
                  }
                  else {
                    unint64_t v57 = v58;
                  }
                }
                while (v57);
              }
              if (v56 == v53 + 16 * v55 || *(_DWORD *)(v56 + 8) != v54) {
LABEL_87:
              }
                uint64_t v56 = v53;
              unint64_t v33 = *(unsigned int *)(v56 + 12);
            }
            else
            {
              unint64_t v33 = sub_1CB83544C(v31 + 272, v29);
              if (v32 == 1) {
            }
              }
            if (v33 > 0x40) {
              goto LABEL_45;
            }
            uint64_t v34 = *(void *)(AddExpr + 32);
            unsigned int v35 = (void *)(v34 + 24);
            if (*(_DWORD *)(v34 + 32) >= 0x41u) {
              unsigned int v35 = (void *)*v35;
            }
            if ((*(unsigned int (**)(void, void))(***(void ***)(a1 + 48) + 248))(**(void **)(a1 + 48), *v35 + *((void *)&v83 + 1)))
            {
              uint64_t v36 = *(void *)(AddExpr + 32);
              uint64_t v37 = (void *)(v36 + 24);
              if (*(_DWORD *)(v36 + 32) >= 0x41u) {
                uint64_t v37 = (void *)*v37;
              }
              *((void *)&v83 + 1) += *v37;
              if (a7)
              {
                *(void *)&long long v83 = 0;
              }
              else
              {
                unint64_t v50 = (char *)v80 + 8 * v72;
                int v51 = v81;
                uint64_t v52 = (char *)v80 + 8 * v81;
                if (v52 != v50 + 8)
                {
                  memmove(v50, v50 + 8, v52 - (v50 + 8));
                  int v51 = v81;
                }
                LODWORD(v81) = v51 - 1;
              }
            }
            else
            {
LABEL_45:
              if (a7) {
                *(void *)&long long v83 = AddExpr;
              }
              else {
                *((void *)v80 + v72) = AddExpr;
              }
            }
            int v38 = *v17;
            if (!*v17 || *((_WORD *)v38 + 12)) {
              goto LABEL_60;
            }
            uint64_t v39 = **((void **)v38 + 4);
            unsigned int v40 = *(_DWORD *)(v39 + 8);
            uint64_t v41 = *(void *)(**(void **)(a1 + 8) + 40);
            if (v40 == 15)
            {
              if ((v40 & 0xFE) == 0x12) {
                unsigned int v40 = *(_DWORD *)(**(void **)(v39 + 16) + 8);
              }
              uint64_t v62 = *(void *)(v41 + 504);
              if (v40 < 0x100) {
                goto LABEL_100;
              }
              unsigned int v63 = v40 >> 8;
              unint64_t v64 = *(unsigned int *)(v41 + 512);
              uint64_t v65 = *(void *)(v41 + 504);
              if (v64)
              {
                uint64_t v65 = v62;
                unint64_t v66 = v64;
                do
                {
                  unint64_t v67 = v66 >> 1;
                  uint64_t v68 = v65 + 16 * (v66 >> 1);
                  unsigned int v69 = *(_DWORD *)(v68 + 8);
                  uint64_t v70 = v68 + 16;
                  v66 += ~(v66 >> 1);
                  if (v69 < v63) {
                    uint64_t v65 = v70;
                  }
                  else {
                    unint64_t v66 = v67;
                  }
                }
                while (v66);
              }
              if (v65 == v62 + 16 * v64 || *(_DWORD *)(v65 + 8) != v63) {
LABEL_100:
              }
                uint64_t v65 = v62;
              unint64_t v43 = *(unsigned int *)(v65 + 12);
            }
            else
            {
              unint64_t v43 = sub_1CB83544C(v41 + 272, v39);
              if (v42 == 1) {
            }
              }
            if (v43 > 0x40) {
              goto LABEL_60;
            }
            uint64_t v44 = *((void *)v38 + 4);
            unint64_t v45 = (void *)(v44 + 24);
            if (*(_DWORD *)(v44 + 32) >= 0x41u) {
              unint64_t v45 = (void *)*v45;
            }
            if ((*(unsigned int (**)(void, void))(***(void ***)(a1 + 48) + 248))(**(void **)(a1 + 48), *v45 + *((void *)&v83 + 1)))
            {
              uint64_t v46 = *((void *)v38 + 4);
              uint64_t v47 = (void *)(v46 + 24);
              if (*(_DWORD *)(v46 + 32) >= 0x41u) {
                uint64_t v47 = (void *)*v47;
              }
              *((void *)&v83 + 1) += *v47;
            }
            else
            {
LABEL_60:
              if (v81 >= (unint64_t)HIDWORD(v81)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v80 + v81) = *v17;
              LODWORD(v81) = v81 + 1;
            }
            sub_1CCE0C4F4((uint64_t)v79, *(void *)(a1 + 56));
            if (sub_1CCE0B73C((unint64_t *)a1, a2, a3, (unint64_t)v79))
            {
              uint64_t v48 = *(void *)(a2 + 672) + 96 * *(unsigned int *)(a2 + 680);
              long long v49 = *(_OWORD *)(v48 - 80);
              v76[0] = *(_OWORD *)(v48 - 96);
              v76[1] = v49;
              v77[0] = v78;
              v77[1] = (void *)0x400000000;
              if (*(_DWORD *)(v48 - 56)) {
                sub_1CD6BBEE8((uint64_t)v77, v48 - 64);
              }
              v78[2] = *(_OWORD *)(v48 - 16);
              sub_1CCE0D170(a1, a2, a3, v76, v71 + ((31 - __clz(v88)) >> 2));
              if (v77[0] != v78) {
                free(v77[0]);
              }
            }
            if (v80 != v82) {
              free(v80);
            }
          }
        }
        if (v84 != v86) {
          free(v84);
        }
      }
      goto LABEL_71;
    }
LABEL_103:
    if (v17 != v89) {
      free(v17);
    }
  }
}

uint64_t sub_1CCE0DA4C(void *a1, int a2, uint64_t a3, uint64_t a4, const llvm::Loop *a5, llvm::ScalarEvolution *a6)
{
  v27[3] = *MEMORY[0x1E4F143B8];
  if (a2 != 2) {
    return 0;
  }
  int v10 = (*(_DWORD *)(a3 + 8) & 0xFE) == 0x12
      ? *(unsigned __int8 *)(**(void **)(a3 + 16) + 8)
      : *(_DWORD *)(a3 + 8);
  if (v10 != 13) {
    return 0;
  }
  uint64_t result = 0;
  if (a4 && *(_WORD *)(a4 + 24) == 7)
  {
    uint64_t v12 = *(void *)(a4 + 40);
    if (v12 == 2)
    {
      uint64_t v13 = *(void *)(*(void *)(a4 + 32) + 8);
    }
    else
    {
      uint64_t v21 = *(void *)(a4 + 32);
      uint64_t v25 = v27;
      uint64_t v26 = 0x300000000;
      uint64_t v22 = v12;
      size_t v23 = 8 * v12 - 8;
      if (v23 >= 0x19) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      int v24 = 0;
      if (v22 != 1)
      {
        memcpy(v25, (const void *)(v21 + 8), v23);
        int v24 = v26;
      }
      LODWORD(v26) = v24 + (v23 >> 3);
      uint64_t v13 = sub_1CD478318(a6, (uint64_t)&v25, *(const llvm::Loop **)(a4 + 48), 0);
      if (v25 != v27) {
        free(v25);
      }
    }
    if (*(_WORD *)(v13 + 24)) {
      return 0;
    }
    uint64_t v14 = *(uint64_t **)(a4 + 32);
    while (2)
    {
      uint64_t v15 = *v14;
      switch(*(_WORD *)(v15 + 24))
      {
        case 1:
        case 2:
        case 3:
        case 0xD:
          unsigned int v16 = (void *)(v15 + 40);
          break;
        case 4:
          unsigned int v16 = (void *)(v15 + 48);
          break;
        case 5:
        case 7:
        case 8:
        case 9:
        case 0xA:
        case 0xB:
        case 0xC:
          uint64_t v14 = *(uint64_t **)(v15 + 32);
          continue;
        case 6:
          uint64_t v14 = (uint64_t *)(v15 + 40);
          continue;
        case 0xE:
          unsigned int v16 = *(void **)(v15 - 8);
          break;
        default:
          unsigned int v16 = *(void **)(v15 + 32);
          break;
      }
      break;
    }
    if ((*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 1048))(*a1, 3, *v16)) {
      goto LABEL_29;
    }
    uint64_t v17 = *(uint64_t **)(a4 + 32);
    while (2)
    {
      uint64_t v18 = *v17;
      switch(*(_WORD *)(v18 + 24))
      {
        case 1:
        case 2:
        case 3:
        case 0xD:
          uint64_t v19 = (void *)(v18 + 40);
          break;
        case 4:
          uint64_t v19 = (void *)(v18 + 48);
          break;
        case 5:
        case 7:
        case 8:
        case 9:
        case 0xA:
        case 0xB:
        case 0xC:
          uint64_t v17 = *(uint64_t **)(v18 + 32);
          continue;
        case 6:
          uint64_t v17 = (uint64_t *)(v18 + 40);
          continue;
        case 0xE:
          uint64_t v19 = *(void **)(v18 - 8);
          break;
        default:
          uint64_t v19 = *(void **)(v18 + 32);
          break;
      }
      break;
    }
    uint64_t result = (*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 1056))(*a1, 3, *v19);
    if (result)
    {
LABEL_29:
      unint64_t v20 = **(const llvm::SCEV ***)(a4 + 32);
      if (*((_WORD *)v20 + 12)) {
        return llvm::ScalarEvolution::getLoopDisposition(a6, v20, a5) == 1;
      }
      return 0;
    }
  }
  return result;
}

uint64_t sub_1CCE0DD9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, llvm::ScalarEvolution *a5, unsigned int a6)
{
  uint64_t v6 = a1;
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  if (a6 > 2) {
    return v6;
  }
  int v12 = *(unsigned __int16 *)(a1 + 24);
  if (a1 && v12 == 4)
  {
    uint64_t v13 = *(void *)(a1 + 40);
    if (v13)
    {
      uint64_t v14 = *(void **)(a1 + 32);
      uint64_t v15 = 8 * v13;
      do
      {
        uint64_t v16 = sub_1CCE0DD9C(*v14, a2, a3, a4, a5, a6 + 1);
        if (v16)
        {
          uint64_t MulExpr = v16;
          if (a2)
          {
            int v38 = &v40;
            uint64_t v40 = a2;
            uint64_t v41 = v16;
            uint64_t v39 = 0x200000002;
            uint64_t MulExpr = llvm::ScalarEvolution::getMulExpr((uint64_t)a5, (uint64_t)&v38, 0, 0);
            if (v38 != &v40) {
              free(v38);
            }
          }
          unint64_t v18 = *(unsigned int *)(a3 + 8);
          if (v18 >= *(unsigned int *)(a3 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)a3 + 8 * v18) = MulExpr;
          ++*(_DWORD *)(a3 + 8);
        }
        ++v14;
        v15 -= 8;
      }
      while (v15);
    }
    return 0;
  }
  if (a1 && v12 == 7)
  {
    uint64_t v19 = **(llvm::SCEV ***)(a1 + 32);
    if (llvm::SCEV::isZero(v19) || *(void *)(v6 + 40) != 2) {
      return v6;
    }
    uint64_t v20 = sub_1CCE0DD9C(v19, a2, a3, a4, a5, a6 + 1);
    if (v20)
    {
      uint64_t Constant = v20;
      if (*(void *)(v6 + 48) != a4 && *(_WORD *)(v20 + 24) == 7)
      {
        if (v20 == **(void **)(v6 + 32)) {
          return v6;
        }
LABEL_57:
        uint64_t v33 = *(void *)(v6 + 40);
        if (v33 == 2)
        {
          uint64_t v34 = *(void *)(*(void *)(v6 + 32) + 8);
        }
        else
        {
          uint64_t v35 = *(void *)(v6 + 32);
          int v38 = &v40;
          uint64_t v39 = 0x300000000;
          unint64_t v36 = 8 * v33 - 8;
          if (v36 >= 0x19) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          int v37 = 0;
          if (v33 != 1)
          {
            memcpy(v38, (const void *)(v35 + 8), 8 * v33 - 8);
            int v37 = v39;
          }
          LODWORD(v39) = v37 + (v36 >> 3);
          uint64_t v34 = sub_1CD478318(a5, (uint64_t)&v38, *(const llvm::Loop **)(v6 + 48), 0);
          if (v38 != &v40) {
            free(v38);
          }
        }
        return llvm::ScalarEvolution::getAddRecExpr(a5, Constant, v34, *(const llvm::Loop **)(v6 + 48), 0);
      }
      if (a2)
      {
        int v38 = &v40;
        uint64_t v40 = a2;
        uint64_t v41 = v20;
        uint64_t v39 = 0x200000002;
        uint64_t Constant = llvm::ScalarEvolution::getMulExpr((uint64_t)a5, (uint64_t)&v38, 0, 0);
        if (v38 != &v40) {
          free(v38);
        }
      }
      unsigned int v29 = *(_DWORD *)(a3 + 8);
      if (v29 >= *(_DWORD *)(a3 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a3 + 8 * v29) = Constant;
      ++*(_DWORD *)(a3 + 8);
    }
    uint64_t v30 = **(void **)(v6 + 32);
    if (!v30) {
      return v6;
    }
    while (2)
    {
      switch(*(_WORD *)(v30 + 24))
      {
        case 1:
        case 2:
        case 3:
        case 0xD:
          uint64_t v32 = (llvm::Type **)(v30 + 40);
          goto LABEL_56;
        case 4:
          uint64_t v32 = (llvm::Type **)(v30 + 48);
          goto LABEL_56;
        case 5:
        case 7:
        case 8:
        case 9:
        case 0xA:
        case 0xB:
        case 0xC:
          uint64_t v31 = *(uint64_t **)(v30 + 32);
          goto LABEL_51;
        case 6:
          uint64_t v31 = (uint64_t *)(v30 + 40);
LABEL_51:
          uint64_t v30 = *v31;
          continue;
        case 0xE:
          uint64_t v32 = *(llvm::Type ***)(v30 - 8);
          goto LABEL_56;
        default:
          uint64_t v32 = *(llvm::Type ***)(v30 + 32);
LABEL_56:
          uint64_t Constant = llvm::ScalarEvolution::getConstant(a5, *v32, 0, 0);
          break;
      }
      goto LABEL_57;
    }
  }
  if (a1 && v12 == 5 && *(void *)(a1 + 40) == 2)
  {
    uint64_t v22 = *(uint64_t **)(a1 + 32);
    uint64_t v23 = *v22;
    if (*v22 && *(_WORD *)(*v22 + 24) == 0)
    {
      if (a2)
      {
        int v38 = &v40;
        uint64_t v40 = a2;
        uint64_t v41 = v23;
        uint64_t v39 = 0x200000002;
        uint64_t v23 = llvm::ScalarEvolution::getMulExpr((uint64_t)a5, (uint64_t)&v38, 0, 0);
        if (v38 != &v40) {
          free(v38);
        }
        uint64_t v22 = *(uint64_t **)(v6 + 32);
      }
      uint64_t v25 = sub_1CCE0DD9C(v22[1], v23, a3, a4, a5, a6 + 1);
      if (!v25) {
        return 0;
      }
      int v38 = &v40;
      uint64_t v40 = v23;
      uint64_t v41 = v25;
      uint64_t v39 = 0x200000002;
      uint64_t v26 = llvm::ScalarEvolution::getMulExpr((uint64_t)a5, (uint64_t)&v38, 0, 0);
      if (v38 != &v40) {
        free(v38);
      }
      unsigned int v27 = *(_DWORD *)(a3 + 8);
      if (v27 >= *(_DWORD *)(a3 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v6 = 0;
      *(void *)(*(void *)a3 + 8 * v27) = v26;
      ++*(_DWORD *)(a3 + 8);
    }
  }
  return v6;
}

uint64_t sub_1CCE0E2BC(uint64_t *a1, llvm::ScalarEvolution *a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, llvm::SCEV *this, char a9)
{
  uint64_t v20 = this;
  if (llvm::SCEV::isZero(this)) {
    return 1;
  }
  uint64_t v17 = sub_1CCE0A444((uint64_t *)&v20, a2);
  uint64_t v18 = sub_1CCE0E39C((uint64_t *)&v20, a2);
  uint64_t result = llvm::SCEV::isZero(v20);
  if (result)
  {
    if (!v17 && !v18) {
      return 1;
    }
    uint64_t v19 = -1;
    if (a5 != 3) {
      uint64_t v19 = 1;
    }
    return sub_1CCE0E5CC(a1, a3, a4, a5, a6, a7, v18, v17, a9, v19);
  }
  return result;
}

uint64_t sub_1CCE0E39C(uint64_t *a1, llvm::ScalarEvolution *a2)
{
  v23[8] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a1;
  int v5 = *(unsigned __int16 *)(*a1 + 24);
  if (*a1) {
    BOOL v6 = v5 == 14;
  }
  else {
    BOOL v6 = 0;
  }
  if (!v6)
  {
    if (v4) {
      BOOL v7 = v5 == 4;
    }
    else {
      BOOL v7 = 0;
    }
    if (v7)
    {
      uint64_t v14 = *(const void **)(v4 + 32);
      unint64_t v13 = *(void *)(v4 + 40);
      uint64_t v21 = v23;
      uint64_t v22 = 0x800000000;
      if (v13 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v13)
      {
        memcpy(v23, v14, 8 * v13);
        int v15 = v22;
        uint64_t v16 = v21;
      }
      else
      {
        int v15 = 0;
        uint64_t v16 = v23;
      }
      LODWORD(v22) = v15 + v13;
      uint64_t v11 = sub_1CCE0E39C(&v16[(v15 + v13) - 1], a2);
      if (!v11) {
        goto LABEL_33;
      }
      uint64_t AddExpr = llvm::ScalarEvolution::getAddExpr((uint64_t)a2, (unint64_t **)&v21, 0, 0);
    }
    else
    {
      if (v4) {
        BOOL v8 = v5 == 7;
      }
      else {
        BOOL v8 = 0;
      }
      if (!v8) {
        return 0;
      }
      int v10 = *(const void **)(v4 + 32);
      unint64_t v9 = *(void *)(v4 + 40);
      uint64_t v21 = v23;
      uint64_t v22 = 0x800000000;
      if (v9 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v9)
      {
        memcpy(v23, v10, 8 * v9);
        int v18 = v22;
        uint64_t v19 = v21;
      }
      else
      {
        int v18 = 0;
        uint64_t v19 = v23;
      }
      LODWORD(v22) = v18 + v9;
      uint64_t v11 = sub_1CCE0E39C(v19, a2);
      if (!v11) {
        goto LABEL_33;
      }
      uint64_t AddExpr = llvm::ScalarEvolution::getAddRecExpr(a2, (uint64_t **)&v21, *(const llvm::Loop **)(v4 + 48), 0);
    }
    *a1 = AddExpr;
LABEL_33:
    if (v21 != v23) {
      free(v21);
    }
    return v11;
  }
  uint64_t v11 = *(void *)(v4 - 8);
  if (v11) {
    BOOL v12 = *(unsigned __int8 *)(v11 + 16) > 3u;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12) {
    return 0;
  }
  *a1 = llvm::ScalarEvolution::getConstant(a2, *(llvm::Type **)v11, 0, 0);
  return v11;
}

uint64_t sub_1CCE0E5CC(uint64_t *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 a9, uint64_t a10)
{
  if (a2 > 0 == a8 + a2 <= a8) {
    return 0;
  }
  uint64_t v11 = a8 + a3;
  if (a3 > 0 == a8 + a3 <= a8 || !sub_1CCE0A944(*a1, a4, a5, a6, a7, a8 + a2, a9, a10)) {
    return 0;
  }
  uint64_t v16 = *a1;

  return sub_1CCE0A944(v16, a4, a5, a6, a7, v11, a9, a10);
}

BOOL sub_1CCE0E6C4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1 == 1)
  {
    *(void *)(a1 + 24) = 0;
    unsigned int v2 = *(_DWORD *)(a1 + 40);
    if (v2 >= *(_DWORD *)(a1 + 44)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 32) + 8 * v2) = *(void *)(a1 + 80);
    ++*(_DWORD *)(a1 + 40);
    *(void *)(a1 + 80) = 0;
  }
  return v1 == 1;
}

void sub_1CCE0E748(void *a1, llvm::SCEV *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  long long v6 = *(_OWORD *)(*a1 + 16);
  v7[0] = *(_OWORD *)*a1;
  v7[1] = v6;
  BOOL v8 = v10;
  uint64_t v9 = 0x400000000;
  if (*(_DWORD *)(v5 + 40)) {
    sub_1CD6BBEE8((uint64_t)&v8, v5 + 32);
  }
  void v10[2] = *(_OWORD *)(v5 + 80);
  if (!llvm::SCEV::isZero(this))
  {
    if (v9 >= HIDWORD(v9)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v8 + v9) = this;
    LODWORD(v9) = v9 + 1;
    sub_1CCE0C4F4((uint64_t)v7, *(void *)(v4 + 56));
    sub_1CCE0B73C((unint64_t *)v4, a1[2], *(_DWORD *)a1[3], (unint64_t)v7);
  }
  if (v8 != v10) {
    free(v8);
  }
}

void sub_1CCE0E870(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a4 + 32;
  unint64_t v13 = (long long *)(a4 + 80);
  uint64_t v14 = (llvm::SCEV **)(*(void *)(a4 + 32) + 8 * a5);
  if (a6) {
    uint64_t v14 = (llvm::SCEV **)(a4 + 80);
  }
  uint64_t v19 = *v14;
  uint64_t v15 = sub_1CCE0E39C((uint64_t *)&v19, *(llvm::ScalarEvolution **)(a1 + 8));
  uint64_t v16 = v19;
  if (!llvm::SCEV::isZero(v19) && v15)
  {
    long long v17 = *(_OWORD *)(a4 + 16);
    v20[0] = *(_OWORD *)a4;
    v20[1] = v17;
    v21[0] = v22;
    v21[1] = (void *)0x400000000;
    if (*(_DWORD *)(a4 + 40)) {
      sub_1CD6BBEE8((uint64_t)v21, v12);
    }
    long long v23 = *v13;
    *(void *)&v20[0] = v15;
    if (sub_1CCE0E9E8(*(uint64_t **)(a1 + 48), *(void *)(a2 + 640), *(void *)(a2 + 648), *(_DWORD *)(a2 + 24), *(void *)(a2 + 32), *(void *)(a2 + 40), (uint64_t)v20))
    {
      int v18 = (llvm::SCEV **)&v23;
      if (!a6) {
        int v18 = (llvm::SCEV **)((char *)v21[0] + 8 * a5);
      }
      *int v18 = v16;
      sub_1CCE0B73C((unint64_t *)a1, a2, a3, (unint64_t)v20);
    }
    if (v21[0] != v22) {
      free(v21[0]);
    }
  }
}

uint64_t sub_1CCE0E9E8(uint64_t *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13 = *(void *)a7;
  uint64_t v14 = *(void *)(a7 + 8);
  uint64_t v15 = *(void *)(a7 + 24);
  if (sub_1CCE0E5CC(a1, a2, a3, a4, a5, a6, *(void *)a7, v14, *(unsigned char *)(a7 + 16), v15)) {
    return 1;
  }
  if (v15 == 1) {
    return sub_1CCE0E5CC(a1, a2, a3, a4, a5, a6, v13, v14, 1u, 0);
  }
  return 0;
}

void sub_1CCE0EAB0(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  unsigned int v46 = a3;
  uint64_t v45 = a6;
  char v44 = a7;
  v43[0] = (long long *)a4;
  v43[1] = (long long *)a1;
  v43[2] = (long long *)a2;
  v43[3] = (long long *)&v44;
  v43[4] = (long long *)&v45;
  void v43[5] = (long long *)&v46;
  uint64_t v11 = a4 + 32;
  uint64_t v12 = (long long *)(a4 + 80);
  uint64_t v13 = (llvm::SCEV **)(*(void *)(a4 + 32) + 8 * a6);
  if (a7) {
    uint64_t v13 = (llvm::SCEV **)(a4 + 80);
  }
  uint64_t v14 = *v13;
  uint64_t v42 = *v13;
  if (!*(_DWORD *)(a1 + 72) && *(_DWORD *)(a2 + 24) == 2 && *((_WORD *)v14 + 12) == 7 && v14 != 0)
  {
    uint64_t v16 = *((void *)v14 + 5);
    if (v16 == 2)
    {
      uint64_t v17 = *(void *)(*((void *)v14 + 4) + 8);
    }
    else
    {
      uint64_t v40 = *(llvm::ScalarEvolution **)(a1 + 8);
      uint64_t v41 = (long long *)(a4 + 80);
      uint64_t v36 = *((void *)v14 + 4);
      v47[0] = &v48;
      v47[1] = (void *)0x300000000;
      uint64_t v37 = v16;
      size_t v38 = 8 * v16 - 8;
      if (v38 >= 0x19) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      int v39 = 0;
      if (v37 != 1)
      {
        memcpy(v47[0], (const void *)(v36 + 8), v38);
        int v39 = (int)v47[1];
      }
      LODWORD(v47[1]) = v39 + (v38 >> 3);
      uint64_t v17 = sub_1CD478318(v40, (uint64_t)v47, *((const llvm::Loop **)v14 + 6), 0);
      if (v47[0] != &v48) {
        free(v47[0]);
      }
      uint64_t v12 = v41;
    }
    if (v17) {
      BOOL v18 = *(unsigned __int16 *)(v17 + 24) == 0;
    }
    else {
      BOOL v18 = 0;
    }
    if (v18)
    {
      uint64_t v19 = *(void *)(v17 + 32);
      unsigned int v20 = *(_DWORD *)(v19 + 32);
      if (v20 > 0x40)
      {
        uint64_t v24 = **(void **)(v19 + 24);
      }
      else
      {
        unint64_t v21 = *(void *)(v19 + 24);
        unint64_t v22 = v21 >> (v20 - 1);
        uint64_t v23 = (uint64_t)(v21 << -(char)v20) >> -(char)v20;
        uint64_t v24 = (v22 & 1) != 0 ? v23 : v21;
      }
      uint64_t v25 = *(unsigned int *)(a5 + 8);
      if (v25)
      {
        uint64_t v26 = *(unint64_t **)a5;
        uint64_t v27 = 8 * v25;
        do
        {
          uint64_t v28 = *v26++;
          sub_1CCE0EDDC(v43, (uint64_t)v14, v28 - v24);
          v27 -= 8;
        }
        while (v27);
      }
    }
  }
  uint64_t v29 = *(unsigned int *)(a5 + 8);
  if (v29)
  {
    uint64_t v30 = *(unint64_t **)a5;
    uint64_t v31 = 8 * v29;
    do
    {
      unint64_t v32 = *v30++;
      sub_1CCE0EDDC(v43, (uint64_t)v14, v32);
      v31 -= 8;
    }
    while (v31);
  }
  uint64_t v33 = sub_1CCE0A444((uint64_t *)&v42, *(llvm::ScalarEvolution **)(a1 + 8));
  uint64_t v34 = v42;
  if (!llvm::SCEV::isZero(v42) && v33)
  {
    long long v35 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)uint64_t v47 = *(_OWORD *)a4;
    long long v48 = v35;
    v49[0] = v50;
    v49[1] = (void *)0x400000000;
    if (*(_DWORD *)(a4 + 40)) {
      sub_1CD6BBEE8((uint64_t)v49, v11);
    }
    long long v51 = *v12;
    v47[1] = (char *)v47[1] + v33;
    if (sub_1CCE0E9E8(*(uint64_t **)(a1 + 48), *(void *)(a2 + 640), *(void *)(a2 + 648), *(_DWORD *)(a2 + 24), *(void *)(a2 + 32), *(void *)(a2 + 40), (uint64_t)v47))
    {
      if (v44)
      {
        *(void *)&long long v51 = v34;
      }
      else
      {
        *((void *)v49[0] + v45) = v34;
        sub_1CCE0C4F4((uint64_t)v47, *(void *)(a1 + 56));
      }
      sub_1CCE0B73C((unint64_t *)a1, a2, v46, (unint64_t)v47);
    }
    if (v49[0] != v50) {
      free(v49[0]);
    }
  }
}

void sub_1CCE0EDDC(long long **a1, uint64_t a2, unint64_t a3)
{
  void v27[2] = *MEMORY[0x1E4F143B8];
  BOOL v7 = *a1;
  long long v6 = a1[1];
  long long v8 = (*a1)[1];
  long long v20 = **a1;
  long long v21 = v8;
  unint64_t v22 = v24;
  uint64_t v23 = 0x400000000;
  uint64_t v9 = v7;
  if (*((_DWORD *)v7 + 10))
  {
    sub_1CD6BBEE8((uint64_t)&v22, (uint64_t)(v7 + 2));
    uint64_t v9 = *a1;
  }
  long long v25 = v7[5];
  *((void *)&v20 + 1) = *((void *)v9 + 1) - a3;
  if (sub_1CCE0E9E8(*((uint64_t **)v6 + 6), *((void *)a1[2] + 80), *((void *)a1[2] + 81), *((_DWORD *)a1[2] + 6), *((void *)a1[2] + 4), *((void *)a1[2] + 5), (uint64_t)&v20))
  {
    uint64_t v10 = *((void *)v6 + 1);
    uint64_t v11 = a2;
    while (2)
    {
      switch(*(_WORD *)(v11 + 24))
      {
        case 1:
        case 2:
        case 3:
        case 0xD:
          uint64_t v13 = (llvm::Type **)(v11 + 40);
          goto LABEL_12;
        case 4:
          uint64_t v13 = (llvm::Type **)(v11 + 48);
          goto LABEL_12;
        case 5:
        case 7:
        case 8:
        case 9:
        case 0xA:
        case 0xB:
        case 0xC:
          uint64_t v12 = *(uint64_t **)(v11 + 32);
          goto LABEL_7;
        case 6:
          uint64_t v12 = (uint64_t *)(v11 + 40);
LABEL_7:
          uint64_t v11 = *v12;
          continue;
        case 0xE:
          uint64_t v13 = *(llvm::Type ***)(v11 - 8);
          goto LABEL_12;
        default:
          uint64_t v13 = *(llvm::Type ***)(v11 + 32);
LABEL_12:
          unint64_t Constant = llvm::ScalarEvolution::getConstant(*((llvm::ScalarEvolution **)v6 + 1), *v13, a3, 0);
          v26[0] = v27;
          v27[0] = Constant;
          v27[1] = a2;
          v26[1] = (unint64_t *)0x200000002;
          uint64_t AddExpr = (llvm::SCEV *)llvm::ScalarEvolution::getAddExpr(v10, v26, 0, 0);
          if (v26[0] != v27) {
            free(v26[0]);
          }
          if (llvm::SCEV::isZero(AddExpr))
          {
            if (*(unsigned char *)a1[3])
            {
              *((void *)&v21 + 1) = 0;
              *(void *)&long long v25 = 0;
            }
            else
            {
              uint64_t v16 = (uint64_t *)((char *)v22 + 8 * *(void *)a1[4]);
              int v17 = v23;
              BOOL v18 = (uint64_t *)((char *)v22 + 8 * v23 - 8);
              if (v18 != v16)
              {
                uint64_t v19 = *v16;
                *uint64_t v16 = *v18;
                *BOOL v18 = v19;
              }
              LODWORD(v23) = v17 - 1;
            }
            sub_1CCE0C4F4((uint64_t)&v20, *((void *)v6 + 7));
          }
          else if (*(unsigned char *)a1[3])
          {
            *(void *)&long long v25 = AddExpr;
          }
          else
          {
            *((void *)v22 + *(void *)a1[4]) = AddExpr;
          }
          sub_1CCE0B73C((unint64_t *)v6, (uint64_t)a1[2], *(_DWORD *)a1[5], (unint64_t)&v20);
          break;
      }
      break;
    }
  }
  if (v22 != v24) {
    free(v22);
  }
}

uint64_t sub_1CCE0F064(uint64_t *a1)
{
  if (*((_DWORD *)a1 + 10))
  {
    uint64_t v1 = (uint64_t *)a1[4];
    while (2)
    {
      uint64_t v2 = *v1;
      switch(*(_WORD *)(v2 + 24))
      {
        case 1:
        case 2:
        case 3:
        case 0xD:
          goto LABEL_16;
        case 4:
          goto LABEL_13;
        case 5:
        case 7:
        case 8:
        case 9:
        case 0xA:
        case 0xB:
        case 0xC:
          uint64_t v1 = *(uint64_t **)(v2 + 32);
          continue;
        case 6:
          uint64_t v1 = (uint64_t *)(v2 + 40);
          continue;
        case 0xE:
          goto LABEL_12;
        default:
          goto LABEL_11;
      }
    }
  }
  uint64_t v2 = a1[10];
  if (v2)
  {
    while (2)
    {
      switch(*(_WORD *)(v2 + 24))
      {
        case 1:
        case 2:
        case 3:
        case 0xD:
LABEL_16:
          uint64_t v4 = v2 + 40;
          return *(void *)v4;
        case 4:
LABEL_13:
          uint64_t v4 = v2 + 48;
          return *(void *)v4;
        case 5:
        case 7:
        case 8:
        case 9:
        case 0xA:
        case 0xB:
        case 0xC:
          uint64_t v3 = *(uint64_t **)(v2 + 32);
          goto LABEL_9;
        case 6:
          uint64_t v3 = (uint64_t *)(v2 + 40);
LABEL_9:
          uint64_t v2 = *v3;
          continue;
        case 0xE:
LABEL_12:
          uint64_t v4 = *(void *)(v2 - 8);
          return *(void *)v4;
        default:
LABEL_11:
          uint64_t v4 = *(void *)(v2 + 32);
          return *(void *)v4;
      }
    }
  }
  uint64_t v4 = *a1;
  if (*a1) {
    return *(void *)v4;
  }
  else {
    return 0;
  }
}

BOOL sub_1CCE0F194(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v25 = 0;
  if (sub_1CBB0BF40(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v25))
  {
    uint64_t v5 = v25;
    uint64_t v6 = *(void *)a1;
    uint64_t v7 = *(unsigned int *)(a1 + 16);
  }
  else
  {
    uint64_t v6 = *(void *)a1;
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    uint64_t v5 = *(void *)a1 + 16 * v7;
  }
  if (v5 == v6 + 16 * v7) {
    return 0;
  }
  unint64_t v10 = *(void *)(v5 + 8);
  long long v8 = (unint64_t *)(v5 + 8);
  unint64_t v9 = v10;
  if (v10)
  {
    unint64_t v21 = (v9 >> 1) & ~(-1 << (v9 >> 58));
    if (!v21) {
      return v21;
    }
    int v22 = __clz(__rbit64(v21));
  }
  else
  {
    int v11 = *(_DWORD *)(v9 + 64);
    if (!v11) {
      return 0;
    }
    uint64_t v12 = 0;
    int v13 = -v11;
    int v14 = v11 - 1;
    uint64_t v15 = *(uint64_t **)v9;
    unint64_t v16 = 0xFFFFFFFFFFFFFFFFLL >> v13;
    uint64_t v17 = v14 & 0xFFFFFFC0;
    while (1)
    {
      uint64_t v19 = *v15++;
      uint64_t v18 = v19;
      uint64_t v20 = v17 + v12 ? -1 : v16;
      unint64_t v21 = v20 & v18;
      if (v21) {
        break;
      }
      v12 -= 64;
      if (v17 + v12 == -64) {
        return v21;
      }
    }
    int v23 = __clz(__rbit64(v21));
    if (v23 + 1 == v12) {
      return 0;
    }
    int v22 = v23 - v12;
  }
  return v22 != a3 || sub_1CB9F9DF0(v8, v22) != -1;
}

void sub_1CCE0F2C0(uint64_t a1, void *a2, llvm::SmallPtrSetImplBase *a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v12 = (_OWORD *)(a1 + 24);
  unsigned int v53 = *(_DWORD *)(a1 + 28);
  int v54 = *(_DWORD *)(a1 + 40);
  int v55 = *(_DWORD *)(a1 + 32);
  uint64_t v13 = a2[10];
  if (!v13) {
    goto LABEL_75;
  }
  if (sub_1CD4C9788(*(void *)a4, *(_DWORD *)(a4 + 16), v13, &v56))
  {
LABEL_71:
    *(void *)&long long v52 = -1;
    *((void *)&v52 + 1) = -1;
    _OWORD *v12 = v52;
    v12[1] = v52;
    return;
  }
  sub_1CCE0FFFC(a1, (uint64_t)a2, v13, a3, a6);
  if (*(_DWORD *)(a1 + 28) != -1)
  {
LABEL_75:
    uint64_t v14 = *((unsigned int *)a2 + 10);
    if (v14)
    {
      uint64_t v15 = (uint64_t *)a2[4];
      uint64_t v16 = 8 * v14;
      do
      {
        uint64_t v17 = *v15;
        if (sub_1CD4C9788(*(void *)a4, *(_DWORD *)(a4 + 16), *v15, &v56)) {
          goto LABEL_71;
        }
        sub_1CCE0FFFC(a1, (uint64_t)a2, v17, a3, a6);
        if (*(_DWORD *)(a1 + 28) == -1) {
          return;
        }
        ++v15;
        v16 -= 8;
      }
      while (v16);
      unint64_t v18 = *((unsigned int *)a2 + 10);
    }
    else
    {
      unint64_t v18 = 0;
    }
    if (a2[10]) {
      unint64_t v19 = v18 + 1;
    }
    else {
      unint64_t v19 = v18;
    }
    if (v19 <= 1)
    {
      int v22 = *(_DWORD *)(a1 + 40);
    }
    else
    {
      if (a2[3])
      {
        int v20 = sub_1CCE10414(*(uint64_t **)(a1 + 16), a5, a2);
        int v21 = -2;
        if (!v20) {
          int v21 = -1;
        }
      }
      else
      {
        int v21 = -1;
      }
      int v22 = *(_DWORD *)(a1 + 40) + v21 + v19;
    }
    if (a2[11]) {
      ++v22;
    }
    *(_DWORD *)(a1 + 40) = v22;
    uint64_t v23 = a2[3];
    if (v23)
    {
      uint64_t v24 = *(uint64_t **)(a1 + 16);
      if (sub_1CCE0E5CC(v24, *(void *)(a5 + 640), *(void *)(a5 + 648), *(_DWORD *)(a5 + 24), *(void *)(a5 + 32), *(void *)(a5 + 40), *a2, a2[1], *((unsigned char *)a2 + 16), a2[3]))
      {
        if (*(_DWORD *)(a5 + 24) == 2)
        {
          uint64_t v25 = (*(uint64_t (**)(uint64_t, void, void, void, void, void, void))(*(void *)*v24 + 440))(*v24, *(void *)(a5 + 32), *a2, *(void *)(a5 + 640) + a2[1], *((unsigned __int8 *)a2 + 16), a2[3], *(unsigned int *)(a5 + 40));
          int v27 = v26;
          uint64_t v28 = (*(uint64_t (**)(void))(*(void *)*v24 + 440))();
          BOOL v30 = v25 < v28;
          if (v27 != v29) {
            BOOL v30 = v27 < v29;
          }
          BOOL v31 = !v30;
          if (v30) {
            LODWORD(v23) = v28;
          }
          else {
            LODWORD(v23) = v25;
          }
          if (v31) {
            int v32 = v27;
          }
          else {
            int v32 = v29;
          }
          if (v32) {
            LODWORD(v23) = 0;
          }
        }
        else
        {
          LODWORD(v23) = 0;
        }
      }
      else
      {
        LODWORD(v23) = a2[3] != 1;
      }
    }
    *(_DWORD *)(a1 + 52) += v23;
    uint64_t v33 = *(unsigned int *)(a5 + 56);
    if (v33)
    {
      uint64_t v34 = 72 * v33;
      long long v35 = (void *)(*(void *)(a5 + 48) + 64);
      while (1)
      {
        int64_t v36 = a2[1] + *v35;
        if (*a2) {
          break;
        }
        if (v36)
        {
          int v38 = __clz(v36);
          int v39 = __clz(~v36);
          if (v36 < 0) {
            int v38 = v39;
          }
          int v37 = *(_DWORD *)(a1 + 44) - v38 + 65;
          goto LABEL_46;
        }
LABEL_52:
        v35 += 9;
        v34 -= 72;
        if (!v34) {
          goto LABEL_53;
        }
      }
      int v37 = *(_DWORD *)(a1 + 44) + 64;
LABEL_46:
      *(_DWORD *)(a1 + 44) = v37;
      BOOL v40 = *(_DWORD *)(a5 + 24) != 2 || v36 == 0;
      if (!v40
        && ((*(uint64_t (**)(void, void))(***(void ***)(a1 + 16) + 264))(**(void **)(a1 + 16), *(void *)(a5 + 32)) & 1) == 0)
      {
        ++*(_DWORD *)(a1 + 40);
      }
      goto LABEL_52;
    }
LABEL_53:
    if (byte_1EBCF51E8)
    {
      uint64_t v41 = *(void **)(a1 + 16);
      uint64_t v42 = sub_1CCE0F064(a2);
      (*(void (**)(void, void, uint64_t))(*(void *)*v41 + 680))(*v41, 0, v42);
      int v43 = (*(uint64_t (**)(void))(*(void *)*v41 + 672))();
      unsigned int v44 = *(_DWORD *)(a1 + 28);
      if (v44 > v43 - 1)
      {
        unsigned int v45 = v44 - v53;
        int v46 = v44 - v43;
        if (v53 <= v43 - 1) {
          unsigned int v47 = v46 + 1;
        }
        else {
          unsigned int v47 = v45;
        }
        *(_DWORD *)v12 += v47;
      }
      if (*(_DWORD *)(a5 + 24) == 3)
      {
        if (!a2[11] && !a2[1] && *((_DWORD *)a2 + 10) == 1 && !a2[10])
        {
          int v48 = *(_DWORD *)(a1 + 32) - v55 + *(_DWORD *)(a1 + 24);
LABEL_68:
          *(_DWORD *)(a1 + 24) = v48;
          return;
        }
        int v50 = (*(uint64_t (**)(void))(***(void ***)(a1 + 16) + 296))(**(void **)(a1 + 16));
        int v51 = *(_DWORD *)(a5 + 24);
        int v49 = *(_DWORD *)(a1 + 32) - v55 + *(_DWORD *)(a1 + 24) + (v50 ^ 1);
        *(_DWORD *)(a1 + 24) = v49;
        if (v51 == 3) {
          return;
        }
      }
      else
      {
        int v49 = *(_DWORD *)(a1 + 32) - v55 + *(_DWORD *)(a1 + 24);
      }
      int v48 = v49 - v54 + *(_DWORD *)(a1 + 40);
      goto LABEL_68;
    }
  }
}

void sub_1CCE0F7F0(uint64_t a1, long long *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 672);
  unsigned int v4 = *(_DWORD *)(a1 + 680);
  uint64_t v5 = v3 + 96 * v4;
  uint64_t v6 = (long long *)(v5 - 96);
  if ((long long *)(v5 - 96) != a2)
  {
    long long v12 = *a2;
    long long v13 = a2[1];
    v14[0] = v15;
    v14[1] = (void *)0x400000000;
    if (*((_DWORD *)a2 + 10)) {
      sub_1CC133E7C((uint64_t)v14, (uint64_t)(a2 + 2));
    }
    long long v16 = a2[5];
    long long v8 = *(_OWORD *)(v5 - 80);
    *a2 = *v6;
    a2[1] = v8;
    sub_1CC133E7C((uint64_t)(a2 + 2), v5 - 64);
    a2[5] = *(_OWORD *)(v5 - 16);
    *uint64_t v6 = v12;
    *(_OWORD *)(v5 - 80) = v13;
    sub_1CC133E7C(v5 - 64, (uint64_t)v14);
    *(_OWORD *)(v5 - 16) = v16;
    if (v14[0] != v15) {
      free(v14[0]);
    }
    unsigned int v4 = *(_DWORD *)(a1 + 680);
    uint64_t v3 = *(void *)(a1 + 672);
  }
  unsigned int v9 = v4 - 1;
  *(_DWORD *)(a1 + 680) = v9;
  uint64_t v10 = v3 + 96 * v9;
  int v11 = *(void **)(v10 + 32);
  if (v11 != (void *)(v10 + 48)) {
    free(v11);
  }
}

void sub_1CCE0F930(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unsigned int v4 = *(_OWORD **)(a1 + 1848);
  uint64_t v5 = *(_OWORD **)(a1 + 1840);
  if (v4 == v5)
  {
    uint64_t v78 = v81;
    uint64_t v6 = *(unsigned int *)(a1 + 1860);
    if (v6) {
      memmove(v81, v4, 8 * v6);
    }
  }
  else
  {
    uint64_t v78 = *(unsigned char **)(a1 + 1848);
    *(void *)(a1 + 1848) = v5;
    unsigned int v4 = v5;
    LODWORD(v6) = *(_DWORD *)(a1 + 1860);
  }
  uint64_t v7 = (void *)(a1 + 1860);
  int v79 = *(_DWORD *)(a1 + 1856);
  v80[0] = v6;
  v80[1] = *(_DWORD *)(a1 + 1864);
  *(_DWORD *)(a1 + 1856) = 4;
  if (v4 != v5)
  {
    *(void *)&long long v75 = -1;
    *((void *)&v75 + 1) = -1;
    *unsigned int v4 = v75;
    v4[1] = v75;
  }
  long long v8 = (unsigned int *)(a1 + 1856);
  unsigned int v9 = (uint64_t *)(a1 + 1840);
  *uint64_t v7 = 0;
  unsigned int v10 = *(_DWORD *)(a1 + 680);
  if (v10)
  {
    uint64_t v11 = *(void *)(a1 + 672);
    uint64_t v12 = v11 + 96 * v10;
    while (1)
    {
      uint64_t v13 = *(void *)(v11 + 80);
      if (!v13) {
        goto LABEL_41;
      }
      uint64_t v14 = *(void *)(a1 + 1848);
      uint64_t v15 = *(unsigned int *)(a1 + 1860);
      if (v14 != *(void *)(a1 + 1840))
      {
        unsigned int v19 = *v8;
        goto LABEL_20;
      }
      if (!v15) {
        break;
      }
      long long v16 = 0;
      uint64_t v17 = 8 * v15;
      unint64_t v18 = *(void **)(a1 + 1848);
      while (*v18 != v13)
      {
        if (*v18 == -2) {
          long long v16 = v18;
        }
        ++v18;
        v17 -= 8;
        if (!v17)
        {
          if (!v16) {
            goto LABEL_17;
          }
          *long long v16 = v13;
          --*(_DWORD *)(a1 + 1864);
          break;
        }
      }
LABEL_41:
      uint64_t v29 = *(unsigned int *)(v11 + 40);
      if (v29)
      {
        BOOL v30 = *(uint64_t **)(v11 + 32);
        BOOL v31 = &v30[v29];
        while (1)
        {
          uint64_t v32 = *(void *)(a1 + 1848);
          uint64_t v33 = *v30;
          uint64_t v34 = *(unsigned int *)(a1 + 1860);
          if (v32 != *(void *)(a1 + 1840)) {
            break;
          }
          if (v34)
          {
            long long v35 = 0;
            uint64_t v36 = 8 * v34;
            int v37 = *(void **)(a1 + 1848);
            while (*v37 != v33)
            {
              if (*v37 == -2) {
                long long v35 = v37;
              }
              ++v37;
              v36 -= 8;
              if (!v36)
              {
                if (!v35) {
                  goto LABEL_51;
                }
                *long long v35 = v33;
                --*(_DWORD *)(a1 + 1864);
                goto LABEL_75;
              }
            }
            goto LABEL_75;
          }
LABEL_51:
          unsigned int v38 = *v8;
          if (v34 >= *v8) {
            goto LABEL_54;
          }
          *(_DWORD *)uint64_t v7 = v34 + 1;
          *(void *)(v32 + 8 * v34) = v33;
LABEL_75:
          if (++v30 == v31) {
            goto LABEL_83;
          }
        }
        unsigned int v38 = *v8;
LABEL_54:
        if (3 * v38 <= 4 * ((int)v34 - *(_DWORD *)(a1 + 1864)))
        {
          if (v38 >= 0x40) {
            v38 *= 2;
          }
          else {
            unsigned int v38 = 128;
          }
        }
        else if (v38 - v34 >= v38 >> 3)
        {
          goto LABEL_56;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(a1 + 1840), v38);
        unsigned int v38 = *(_DWORD *)(a1 + 1856);
        uint64_t v32 = *(void *)(a1 + 1848);
LABEL_56:
        unsigned int v39 = v38 - 1;
        unsigned int v40 = (v38 - 1) & ((v33 >> 4) ^ (v33 >> 9));
        uint64_t v41 = (void *)(v32 + 8 * v40);
        uint64_t v42 = *v41;
        if (*v41 == -1)
        {
          int v43 = 0;
LABEL_68:
          if (v43) {
            unsigned int v47 = v43;
          }
          else {
            unsigned int v47 = v41;
          }
          if (*v47 != v33)
          {
            if (*v47 == -2) {
              --*(_DWORD *)(a1 + 1864);
            }
            else {
              ++*(_DWORD *)v7;
            }
            *unsigned int v47 = v33;
          }
        }
        else
        {
          int v43 = 0;
          int v44 = 1;
          while (v42 != v33)
          {
            if (v43) {
              BOOL v45 = 0;
            }
            else {
              BOOL v45 = v42 == -2;
            }
            if (v45) {
              int v43 = v41;
            }
            unsigned int v46 = v40 + v44++;
            unsigned int v40 = v46 & v39;
            uint64_t v41 = (void *)(v32 + 8 * (v46 & v39));
            uint64_t v42 = *v41;
            if (*v41 == -1) {
              goto LABEL_68;
            }
          }
        }
        goto LABEL_75;
      }
LABEL_83:
      v11 += 96;
      if (v11 == v12) {
        goto LABEL_91;
      }
    }
LABEL_17:
    unsigned int v19 = *v8;
    if (v15 < *v8)
    {
      *(_DWORD *)uint64_t v7 = v15 + 1;
      *(void *)(v14 + 8 * v15) = v13;
      goto LABEL_41;
    }
LABEL_20:
    if (3 * v19 <= 4 * ((int)v15 - *(_DWORD *)(a1 + 1864)))
    {
      if (v19 >= 0x40) {
        v19 *= 2;
      }
      else {
        unsigned int v19 = 128;
      }
    }
    else if (v19 - v15 >= v19 >> 3)
    {
      goto LABEL_22;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(a1 + 1840), v19);
    unsigned int v19 = *(_DWORD *)(a1 + 1856);
    uint64_t v14 = *(void *)(a1 + 1848);
LABEL_22:
    unsigned int v20 = v19 - 1;
    unsigned int v21 = (v19 - 1) & ((v13 >> 4) ^ (v13 >> 9));
    int v22 = (void *)(v14 + 8 * v21);
    uint64_t v23 = *v22;
    if (*v22 == -1)
    {
      uint64_t v24 = 0;
LABEL_34:
      if (v24) {
        uint64_t v28 = v24;
      }
      else {
        uint64_t v28 = v22;
      }
      if (*v28 != v13)
      {
        if (*v28 == -2) {
          --*(_DWORD *)(a1 + 1864);
        }
        else {
          ++*(_DWORD *)v7;
        }
        *uint64_t v28 = v13;
      }
    }
    else
    {
      uint64_t v24 = 0;
      int v25 = 1;
      while (v23 != v13)
      {
        if (v24) {
          BOOL v26 = 0;
        }
        else {
          BOOL v26 = v23 == -2;
        }
        if (v26) {
          uint64_t v24 = v22;
        }
        unsigned int v27 = v21 + v25++;
        unsigned int v21 = v27 & v20;
        int v22 = (void *)(v14 + 8 * (v27 & v20));
        uint64_t v23 = *v22;
        if (*v22 == -1) {
          goto LABEL_34;
        }
      }
    }
    goto LABEL_41;
  }
LABEL_91:
  int v48 = v78;
  int v49 = (unsigned int *)&v79;
  if (v78 == v81) {
    int v49 = v80;
  }
  uint64_t v50 = *v49;
  int v51 = (uint64_t *)v78;
  if (v50)
  {
    uint64_t v52 = 0;
    while (*(void *)&v78[v52] >= 0xFFFFFFFFFFFFFFFELL)
    {
      v52 += 8;
      if (8 * v50 == v52) {
        goto LABEL_142;
      }
    }
    int v51 = (uint64_t *)&v78[v52];
  }
  unsigned int v53 = &v78[8 * v50];
  if (v51 != v53)
  {
    uint64_t v54 = *(void *)(a1 + 1848);
    uint64_t v55 = *v51;
LABEL_101:
    uint64_t v56 = *v9;
    if (v54 == *v9)
    {
      uint64_t v57 = *(unsigned int *)v7;
      unint64_t v58 = (void *)(v54 + 8 * v57);
      if (v57)
      {
        uint64_t v59 = 0;
        uint64_t v60 = 8 * v57;
        while (*(void *)(v54 + v59) != v55)
        {
          v59 += 8;
          if (v60 == v59) {
            goto LABEL_119;
          }
        }
        unint64_t v58 = (void *)(v54 + v59);
      }
LABEL_119:
      uint64_t v56 = v54;
    }
    else
    {
      int v61 = *(_DWORD *)(a1 + 1856) - 1;
      uint64_t v54 = *(void *)(a1 + 1848);
      unsigned int v62 = v61 & ((v55 >> 4) ^ (v55 >> 9));
      unint64_t v58 = (void *)(v54 + 8 * v62);
      uint64_t v63 = *v58;
      if (*v58 == -1)
      {
        unint64_t v64 = 0;
LABEL_134:
        if (v64) {
          unint64_t v58 = v64;
        }
        if (*v58 != v55)
        {
          if (v54 == v56) {
            int v74 = (unsigned int *)(a1 + 1860);
          }
          else {
            int v74 = (unsigned int *)(a1 + 1856);
          }
          unint64_t v58 = (void *)(v54 + 8 * *v74);
        }
      }
      else
      {
        unint64_t v64 = 0;
        int v65 = 1;
        while (v63 != v55)
        {
          if (v64) {
            BOOL v66 = 0;
          }
          else {
            BOOL v66 = v63 == -2;
          }
          if (v66) {
            unint64_t v64 = v58;
          }
          unsigned int v67 = v62 + v65++;
          unsigned int v62 = v67 & v61;
          unint64_t v58 = (void *)(v54 + 8 * (v67 & v61));
          uint64_t v63 = *v58;
          if (*v58 == -1) {
            goto LABEL_134;
          }
        }
      }
    }
    if (v54 == v56) {
      uint64_t v68 = (unsigned int *)(a1 + 1860);
    }
    else {
      uint64_t v68 = (unsigned int *)(a1 + 1856);
    }
    if (v58 == (void *)(v54 + 8 * *v68))
    {
      uint64_t v82 = 0;
      int v69 = sub_1CBB0BF40(*(void *)a3, *(_DWORD *)(a3 + 16), v55, &v82);
      uint64_t v70 = v82;
      if (!v69) {
        uint64_t v70 = *(void *)a3 + 16 * *(unsigned int *)(a3 + 16);
      }
      unint64_t v71 = *(void *)(v70 + 8);
      if (v71) {
        *(void *)(v70 + 8) = ((2 * ~((-1 << (v71 >> 58)) | (1 << a2))) | 0xFC00000000000000) & v71 | 1;
      }
      else {
        *(void *)(*(void *)v71 + 8 * (a2 >> 6)) &= ~(1 << a2);
      }
    }
    uint64_t v72 = (unint64_t *)(v51 + 1);
    while (v72 != v53)
    {
      unint64_t v73 = *v72++;
      uint64_t v55 = v73;
      if (v73 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        int v51 = (uint64_t *)(v72 - 1);
        goto LABEL_101;
      }
    }
    int v48 = v78;
  }
LABEL_142:
  if (v48 != v81) {
    free(v48);
  }
}

void sub_1CCE0FF18(uint64_t a1)
{
  v6[4] = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = 0;
  unsigned int v4 = v6;
  v6[0] = -1;
  uint64_t v5 = 0x400000001;
  uint64_t v1 = *(unsigned int *)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = *(void **)a1;
    uint64_t v3 = 56 * v1;
    do
    {
      void *v2 = v2 + 2;
      v2[1] = 0x400000000;
      if (v5) {
        sub_1CD6BBEE8((uint64_t)v2, (uint64_t)&v4);
      }
      v2 += 7;
      v3 -= 56;
    }
    while (v3);
    if (v4 != v6) {
      free(v4);
    }
  }
}

void sub_1CCE0FFFC(uint64_t a1, uint64_t a2, uint64_t a3, llvm::SmallPtrSetImplBase *this, uint64_t *a5)
{
  if (a5)
  {
    uint64_t v11 = *a5;
    uint64_t v10 = a5[1];
    if (v10 == *a5)
    {
      uint64_t v12 = *((unsigned int *)a5 + 5);
      uint64_t v13 = (void *)(v10 + 8 * v12);
      if (v12)
      {
        uint64_t v14 = 0;
        uint64_t v15 = 8 * v12;
        while (*(void *)(v10 + v14) != a3)
        {
          v14 += 8;
          if (v15 == v14) {
            goto LABEL_20;
          }
        }
        uint64_t v13 = (void *)(v10 + v14);
      }
LABEL_20:
      uint64_t v11 = a5[1];
    }
    else
    {
      uint64_t v16 = *((unsigned int *)a5 + 4);
      int v17 = v16 - 1;
      unsigned int v18 = (v16 - 1) & ((a3 >> 4) ^ (a3 >> 9));
      uint64_t v13 = (void *)(v10 + 8 * v18);
      uint64_t v19 = *v13;
      if (*v13 == -1)
      {
        unsigned int v20 = 0;
LABEL_70:
        if (v20) {
          uint64_t v13 = v20;
        }
        if (*v13 != a3) {
          uint64_t v13 = (void *)(v10 + 8 * v16);
        }
      }
      else
      {
        unsigned int v20 = 0;
        int v21 = 1;
        while (v19 != a3)
        {
          if (v20) {
            BOOL v22 = 0;
          }
          else {
            BOOL v22 = v19 == -2;
          }
          if (v22) {
            unsigned int v20 = v13;
          }
          unsigned int v23 = v18 + v21++;
          unsigned int v18 = v23 & v17;
          uint64_t v13 = (void *)(v10 + 8 * (v23 & v17));
          uint64_t v19 = *v13;
          if (*v13 == -1) {
            goto LABEL_70;
          }
        }
      }
    }
    BOOL v22 = v10 == v11;
    uint64_t v24 = 16;
    if (v22) {
      uint64_t v24 = 20;
    }
    if (v13 != (void *)(v10 + 8 * *(unsigned int *)((char *)a5 + v24)))
    {
      *(void *)&long long v25 = -1;
      *((void *)&v25 + 1) = -1;
      *(_OWORD *)(a1 + 40) = v25;
      *(_OWORD *)(a1 + 24) = v25;
      return;
    }
  }
  uint64_t v26 = *((void *)this + 1);
  uint64_t v27 = *((unsigned int *)this + 5);
  if (v26 == *(void *)this)
  {
    if (v27)
    {
      uint64_t v28 = 0;
      uint64_t v29 = 8 * v27;
      BOOL v30 = (uint64_t *)*((void *)this + 1);
      while (*v30 != a3)
      {
        if (*v30 == -2) {
          uint64_t v28 = v30;
        }
        ++v30;
        v29 -= 8;
        if (!v29)
        {
          if (!v28) {
            goto LABEL_33;
          }
          *uint64_t v28 = a3;
          --*((_DWORD *)this + 6);
          goto LABEL_57;
        }
      }
      return;
    }
LABEL_33:
    unsigned int v31 = *((_DWORD *)this + 4);
    if (v27 < v31)
    {
      *((_DWORD *)this + 5) = v27 + 1;
      *(void *)(v26 + 8 * v27) = a3;
      goto LABEL_57;
    }
  }
  else
  {
    unsigned int v31 = *((_DWORD *)this + 4);
  }
  if (3 * v31 <= 4 * ((int)v27 - *((_DWORD *)this + 6)))
  {
    if (v31 >= 0x40) {
      v31 *= 2;
    }
    else {
      unsigned int v31 = 128;
    }
  }
  else if (v31 - v27 >= v31 >> 3)
  {
    goto LABEL_38;
  }
  llvm::SmallPtrSetImplBase::Grow(this, v31);
  unsigned int v31 = *((_DWORD *)this + 4);
  uint64_t v26 = *((void *)this + 1);
LABEL_38:
  unsigned int v32 = v31 - 1;
  unsigned int v33 = (v31 - 1) & ((a3 >> 4) ^ (a3 >> 9));
  uint64_t v34 = (uint64_t *)(v26 + 8 * v33);
  uint64_t v35 = *v34;
  if (*v34 != -1)
  {
    uint64_t v36 = 0;
    int v37 = 1;
    while (v35 != a3)
    {
      if (v36) {
        BOOL v38 = 0;
      }
      else {
        BOOL v38 = v35 == -2;
      }
      if (v38) {
        uint64_t v36 = v34;
      }
      unsigned int v39 = v33 + v37++;
      unsigned int v33 = v39 & v32;
      uint64_t v34 = (uint64_t *)(v26 + 8 * (v39 & v32));
      uint64_t v35 = *v34;
      if (*v34 == -1) {
        goto LABEL_50;
      }
    }
    return;
  }
  uint64_t v36 = 0;
LABEL_50:
  if (v36) {
    unsigned int v40 = v36;
  }
  else {
    unsigned int v40 = v34;
  }
  if (*v40 != a3)
  {
    if (*v40 == -2) {
      --*((_DWORD *)this + 6);
    }
    else {
      ++*((_DWORD *)this + 5);
    }
    uint64_t *v40 = a3;
LABEL_57:
    sub_1CCE1054C(a1, a2, a3, (uint64_t *)this);
    if (!a5 || *(_DWORD *)(a1 + 28) != -1) {
      return;
    }
    uint64_t v41 = a5[1];
    uint64_t v42 = *((unsigned int *)a5 + 5);
    if (v41 == *a5)
    {
      if (v42)
      {
        int v43 = 0;
        uint64_t v44 = 8 * v42;
        BOOL v45 = (uint64_t *)a5[1];
        while (*v45 != a3)
        {
          if (*v45 == -2) {
            int v43 = v45;
          }
          ++v45;
          v44 -= 8;
          if (!v44)
          {
            if (!v43) {
              goto LABEL_67;
            }
            uint64_t *v43 = a3;
            --*((_DWORD *)a5 + 6);
            return;
          }
        }
        return;
      }
LABEL_67:
      unsigned int v46 = *((_DWORD *)a5 + 4);
      if (v42 < v46)
      {
        *((_DWORD *)a5 + 5) = v42 + 1;
        *(void *)(v41 + 8 * v42) = a3;
        return;
      }
    }
    else
    {
      unsigned int v46 = *((_DWORD *)a5 + 4);
    }
    if (3 * v46 <= 4 * ((int)v42 - *((_DWORD *)a5 + 6)))
    {
      if (v46 >= 0x40) {
        v46 *= 2;
      }
      else {
        unsigned int v46 = 128;
      }
    }
    else if (v46 - v42 >= v46 >> 3)
    {
      goto LABEL_77;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a5, v46);
    unsigned int v46 = *((_DWORD *)a5 + 4);
    uint64_t v41 = a5[1];
LABEL_77:
    unsigned int v47 = v46 - 1;
    unsigned int v48 = (v46 - 1) & ((a3 >> 4) ^ (a3 >> 9));
    int v49 = (uint64_t *)(v41 + 8 * v48);
    uint64_t v50 = *v49;
    if (*v49 == -1)
    {
      int v51 = 0;
LABEL_89:
      if (v51) {
        uint64_t v55 = v51;
      }
      else {
        uint64_t v55 = v49;
      }
      if (*v55 != a3)
      {
        if (*v55 == -2) {
          --*((_DWORD *)a5 + 6);
        }
        else {
          ++*((_DWORD *)a5 + 5);
        }
        *uint64_t v55 = a3;
      }
    }
    else
    {
      int v51 = 0;
      int v52 = 1;
      while (v50 != a3)
      {
        if (v51) {
          BOOL v53 = 0;
        }
        else {
          BOOL v53 = v50 == -2;
        }
        if (v53) {
          int v51 = v49;
        }
        unsigned int v54 = v48 + v52++;
        unsigned int v48 = v54 & v47;
        int v49 = (uint64_t *)(v41 + 8 * (v54 & v47));
        uint64_t v50 = *v49;
        if (*v49 == -1) {
          goto LABEL_89;
        }
      }
    }
  }
}

uint64_t sub_1CCE10414(uint64_t *a1, uint64_t a2, void *a3)
{
  int v6 = *(_DWORD *)(a2 + 24);
  if (v6 != 2) {
    return sub_1CCE0E5CC(a1, *(void *)(a2 + 640), *(void *)(a2 + 648), v6, *(void *)(a2 + 32), *(void *)(a2 + 40), *a3, a3[1], *((unsigned char *)a3 + 16), a3[3]);
  }
  if (((*(uint64_t (**)(void))(*(void *)*a1 + 448))() & 1) == 0)
  {
    int v6 = *(_DWORD *)(a2 + 24);
    return sub_1CCE0E5CC(a1, *(void *)(a2 + 640), *(void *)(a2 + 648), v6, *(void *)(a2 + 32), *(void *)(a2 + 40), *a3, a3[1], *((unsigned char *)a3 + 16), a3[3]);
  }
  unsigned int v7 = *(_DWORD *)(a2 + 56);
  if (!v7) {
    return 1;
  }
  uint64_t v8 = 72 * v7 - 72;
  unsigned int v9 = (void *)(*(void *)(a2 + 48) + 64);
  do
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, void, void, void, void, void, void, void))(*(void *)*a1 + 264))(*a1, *(void *)(a2 + 32), *a3, *v9 + a3[1], *((unsigned __int8 *)a3 + 16), a3[3], *(unsigned int *)(a2 + 40), *(v9 - 8));
    if (result) {
      BOOL v11 = v8 == 0;
    }
    else {
      BOOL v11 = 1;
    }
    v8 -= 72;
    v9 += 9;
  }
  while (!v11);
  return result;
}

uint64_t sub_1CCE1054C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  v63[3] = *MEMORY[0x1E4F143B8];
  if (!a3 || *(_WORD *)(a3 + 24) != 7) {
    goto LABEL_87;
  }
  if (*(void *)(a3 + 48) == *(void *)a1)
  {
    uint64_t v10 = *(uint64_t **)(a3 + 32);
    while (2)
    {
      uint64_t v11 = *v10;
      switch(*(_WORD *)(v11 + 24))
      {
        case 1:
        case 2:
        case 3:
        case 0xD:
          uint64_t v12 = (void *)(v11 + 40);
          break;
        case 4:
          uint64_t v12 = (void *)(v11 + 48);
          break;
        case 5:
        case 7:
        case 8:
        case 9:
        case 0xA:
        case 0xB:
        case 0xC:
          uint64_t v10 = *(uint64_t **)(v11 + 32);
          continue;
        case 6:
          uint64_t v10 = (uint64_t *)(v11 + 40);
          continue;
        case 0xE:
          uint64_t v12 = *(void **)(v11 - 8);
          break;
        default:
          uint64_t v12 = *(void **)(v11 + 32);
          break;
      }
      break;
    }
    if (((*(uint64_t (**)(void, uint64_t, void))(***(void ***)(a1 + 16) + 1048))(**(void **)(a1 + 16), 3, *v12) & 1) == 0)
    {
      uint64_t v13 = *(uint64_t **)(a3 + 32);
      while (2)
      {
        uint64_t v14 = *v13;
        switch(*(_WORD *)(v14 + 24))
        {
          case 1:
          case 2:
          case 3:
          case 0xD:
            uint64_t v16 = (void *)(v14 + 40);
            break;
          case 4:
            uint64_t v16 = (void *)(v14 + 48);
            break;
          case 5:
          case 7:
          case 8:
          case 9:
          case 0xA:
          case 0xB:
          case 0xC:
            uint64_t v13 = *(uint64_t **)(v14 + 32);
            continue;
          case 6:
            uint64_t v13 = (uint64_t *)(v14 + 40);
            continue;
          case 0xE:
            uint64_t v16 = *(void **)(v14 - 8);
            break;
          default:
            uint64_t v16 = *(void **)(v14 + 32);
            break;
        }
        break;
      }
      if (!(*(unsigned int (**)(void, uint64_t, void))(***(void ***)(a1 + 16) + 1056))(**(void **)(a1 + 16), 3, *v16))goto LABEL_49; {
    }
      }
    int v17 = *(_DWORD *)(a1 + 56);
    if (v17 == 1)
    {
      uint64_t v30 = *(void *)(a3 + 40);
      if (v30 == 2)
      {
        uint64_t v31 = *(void *)(*(void *)(a3 + 32) + 8);
      }
      else
      {
        uint64_t v56 = *(llvm::ScalarEvolution **)(a1 + 8);
        uint64_t v57 = *(void *)(a3 + 32);
        int v61 = v63;
        uint64_t v62 = 0x300000000;
        uint64_t v58 = v30;
        size_t v59 = 8 * v30 - 8;
        if (v59 >= 0x19) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        int v60 = 0;
        if (v58 != 1)
        {
          memcpy(v61, (const void *)(v57 + 8), v59);
          int v60 = v62;
        }
        LODWORD(v62) = v60 + (v59 >> 3);
        uint64_t v31 = sub_1CD478318(v56, (uint64_t)&v61, *(const llvm::Loop **)(a3 + 48), 0);
        if (v61 != v63) {
          free(v61);
        }
      }
      if (*(_WORD *)(v31 + 24)) {
        goto LABEL_49;
      }
      unsigned int v47 = **(const llvm::SCEV ***)(a3 + 32);
      if (!*((_WORD *)v47 + 12)) {
        goto LABEL_49;
      }
      BOOL v29 = llvm::ScalarEvolution::getLoopDisposition(*(llvm::ScalarEvolution **)(a1 + 8), v47, *(const llvm::Loop **)a1) == 1;
    }
    else
    {
      if (v17) {
        goto LABEL_49;
      }
      uint64_t v18 = *(void *)(a3 + 40);
      if (v18 == 2)
      {
        uint64_t v19 = *(void *)(*(void *)(a3 + 32) + 8);
      }
      else
      {
        int v51 = *(llvm::ScalarEvolution **)(a1 + 8);
        uint64_t v52 = *(void *)(a3 + 32);
        int v61 = v63;
        uint64_t v62 = 0x300000000;
        uint64_t v53 = v18;
        size_t v54 = 8 * v18 - 8;
        if (v54 >= 0x19) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        int v55 = 0;
        if (v53 != 1)
        {
          memcpy(v61, (const void *)(v52 + 8), v54);
          int v55 = v62;
        }
        LODWORD(v62) = v55 + (v54 >> 3);
        uint64_t v19 = sub_1CD478318(v51, (uint64_t)&v61, *(const llvm::Loop **)(a3 + 48), 0);
        if (v61 != v63) {
          free(v61);
        }
      }
      if (!v19 || *(_WORD *)(v19 + 24) != 0) {
        goto LABEL_49;
      }
      uint64_t v21 = *(void *)(v19 + 32);
      BOOL v22 = (void *)(v21 + 24);
      uint64_t v23 = *(unsigned int *)(v21 + 32);
      if (v23 >= 0x41)
      {
        int v24 = 0;
        int64_t v25 = (unint64_t)(v23 + 63) >> 6;
        do
        {
          if (v25-- < 1) {
            break;
          }
          unint64_t v27 = *(void *)(*v22 + 8 * v25);
          v24 += __clz(v27);
        }
        while (!v27);
        int v28 = v23 | 0xFFFFFFC0;
        if ((v23 & 0x3F) == 0) {
          int v28 = 0;
        }
        if ((v23 - v24 - v28) > 0x40)
        {
LABEL_49:
          int v32 = 1;
          goto LABEL_50;
        }
        BOOL v22 = (void *)*v22;
      }
      BOOL v29 = *v22 == *(void *)(a2 + 8);
    }
    int v32 = !v29;
LABEL_50:
    *(_DWORD *)(a1 + 32) += v32;
    uint64_t v33 = *(void *)(*(void *)(a3 + 32) + 8);
    if (*(void *)(a3 + 40) != 2 || *(_WORD *)(v33 + 24))
    {
      uint64_t v35 = *a4;
      uint64_t v34 = a4[1];
      if (v34 == *a4)
      {
        uint64_t v36 = *((unsigned int *)a4 + 5);
        int v37 = (void *)(v34 + 8 * v36);
        if (v36)
        {
          uint64_t v38 = 0;
          while (*(void *)(v34 + v38) != v33)
          {
            v38 += 8;
            if (8 * v36 == v38) {
              goto LABEL_70;
            }
          }
          int v37 = (void *)(v34 + v38);
        }
LABEL_70:
        uint64_t v35 = a4[1];
      }
      else
      {
        uint64_t v39 = *((unsigned int *)a4 + 4);
        int v40 = v39 - 1;
        unsigned int v41 = (v39 - 1) & ((v33 >> 4) ^ (v33 >> 9));
        int v37 = (void *)(v34 + 8 * v41);
        uint64_t v42 = *v37;
        if (*v37 == -1)
        {
          int v43 = 0;
LABEL_77:
          if (v43) {
            int v37 = v43;
          }
          if (*v37 != v33)
          {
            LODWORD(v36) = *((_DWORD *)a4 + 5);
            int v37 = (void *)(v34 + 8 * v39);
            goto LABEL_82;
          }
        }
        else
        {
          int v43 = 0;
          int v44 = 1;
          while (v42 != v33)
          {
            if (v43) {
              BOOL v45 = 0;
            }
            else {
              BOOL v45 = v42 == -2;
            }
            if (v45) {
              int v43 = v37;
            }
            unsigned int v46 = v41 + v44++;
            unsigned int v41 = v46 & v40;
            int v37 = (void *)(v34 + 8 * (v46 & v40));
            uint64_t v42 = *v37;
            if (*v37 == -1) {
              goto LABEL_77;
            }
          }
        }
        LODWORD(v36) = *((_DWORD *)a4 + 5);
      }
LABEL_82:
      if (v34 == v35) {
        unsigned int v48 = v36;
      }
      else {
        unsigned int v48 = *((_DWORD *)a4 + 4);
      }
      if (v37 == (void *)(v34 + 8 * v48))
      {
        uint64_t result = sub_1CCE1054C(a1, a2, v33, a4);
        if (*(_DWORD *)(a1 + 28) == -1) {
          return result;
        }
      }
    }
LABEL_87:
    ++*(_DWORD *)(a1 + 28);
    uint64_t result = sub_1CCE10BBC(a3, dword_1EBCF54E8);
    unsigned int v49 = *(_DWORD *)(a1 + 48) + result;
    if (v49 >= 0x10000) {
      unsigned int v49 = 0x10000;
    }
    *(_DWORD *)(a1 + 48) = v49;
    if (*(_WORD *)(a3 + 24) == 5)
    {
      uint64_t result = llvm::ScalarEvolution::getLoopDisposition(*(llvm::ScalarEvolution **)(a1 + 8), (const llvm::SCEV *)a3, *(const llvm::Loop **)a1);
      int v50 = result == 2;
    }
    else
    {
      int v50 = 0;
    }
    *(_DWORD *)(a1 + 36) += v50;
    return result;
  }
  uint64_t result = sub_1CCE092F0(a3, *(llvm::ScalarEvolution **)(a1 + 8));
  if (!result || *(_DWORD *)(a1 + 56) == 1)
  {
    for (uint64_t i = *(const llvm::Loop **)a1; ; uint64_t i = *(const llvm::Loop **)i)
    {
      if (i == *(const llvm::Loop **)(a3 + 48))
      {
        ++*(_DWORD *)(a1 + 28);
        return result;
      }
      if (!i) {
        break;
      }
    }
    *(void *)&long long v15 = -1;
    *((void *)&v15 + 1) = -1;
    *(_OWORD *)(a1 + 40) = v15;
    *(_OWORD *)(a1 + 24) = v15;
  }
  return result;
}

uint64_t sub_1CCE10BBC(uint64_t a1, int a2)
{
  int v4 = 0;
  while (2)
  {
    for (int i = 1 - a2; ; ++i)
    {
      unsigned int v6 = *(unsigned __int16 *)(a1 + 24);
      if (*(_WORD *)(a1 + 24)) {
        BOOL v7 = v6 == 14;
      }
      else {
        BOOL v7 = 1;
      }
      if (v7)
      {
        int v10 = 1;
        return (v10 + v4);
      }
      if (i == 1) {
        goto LABEL_22;
      }
      if (v6 == 7)
      {
        uint64_t v8 = *(uint64_t **)(a1 + 32);
        goto LABEL_12;
      }
      if (v6 - 4 < 0xFFFFFFFD) {
        break;
      }
      uint64_t v8 = (uint64_t *)(a1 + 32);
LABEL_12:
      a1 = *v8;
    }
    if (v6 == 6)
    {
      a2 = -i;
      int v9 = sub_1CCE10BBC(*(void *)(a1 + 32), -i);
      a1 = *(void *)(a1 + 40);
      v4 += v9;
      continue;
    }
    break;
  }
  if (v6 > 0xC || ((1 << v6) & 0x1FB0) == 0 || (uint64_t v11 = *(void *)(a1 + 40)) == 0)
  {
LABEL_22:
    int v10 = 0;
    return (v10 + v4);
  }
  int v10 = 0;
  uint64_t v12 = *(uint64_t **)(a1 + 32);
  uint64_t v13 = -i;
  uint64_t v14 = 8 * v11;
  do
  {
    uint64_t v15 = *v12++;
    v10 += sub_1CCE10BBC(v15, v13);
    v14 -= 8;
  }
  while (v14);
  return (v10 + v4);
}

uint64_t sub_1CCE10CC4(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  void v20[4] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v19[4] = v20;
    v20[0] = -1;
    void v19[5] = 0x400000001;
    v19[0] = -2;
    uint64_t v18 = 0;
    int v15 = a2 - 1;
    unsigned int v10 = (a2 - 1) & sub_1CD48BB60(*(void **)a3, *(void *)a3 + 8 * *(unsigned int *)(a3 + 8));
    uint64_t v11 = *(unsigned int *)(a3 + 8);
    uint64_t v16 = *(const void **)a3;
    for (int i = 1; ; ++i)
    {
      uint64_t v5 = a1 + 56 * v10;
      int v12 = *(_DWORD *)(v5 + 8);
      if (v11 == v12 && !memcmp(v16, *(const void **)v5, 8 * v11))
      {
        uint64_t v6 = 1;
        goto LABEL_3;
      }
      if (v12 == 1 && !memcmp(*(const void **)v5, v20, 8uLL)) {
        break;
      }
      BOOL v13 = v12 == 1 && memcmp(*(const void **)v5, v19, 8uLL) == 0;
      uint64_t v14 = v18;
      if (v13 && v18 == 0) {
        uint64_t v14 = a1 + 56 * v10;
      }
      uint64_t v18 = v14;
      unsigned int v10 = (v10 + i) & v15;
    }
    uint64_t v6 = 0;
    if (v18) {
      uint64_t v5 = v18;
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
  }
LABEL_3:
  *a4 = v5;
  return v6;
}

void sub_1CCE10ED4(void **a1, unsigned int a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v2 = a1;
    uint64_t v7 = -1;
    uint64_t v3 = &a1[7 * a2];
    do
    {
      uint64_t v6 = *v2;
      uint64_t v5 = v2 + 2;
      int v4 = v6;
      if (v6 != v5) {
        free(v4);
      }
      uint64_t v2 = (void **)(v5 + 5);
    }
    while (v2 != v3);
  }
}

uint64_t sub_1CCE10FB0(uint64_t a1, uint64_t a2)
{
  v11[4] = *MEMORY[0x1E4F143B8];
  __base = v11;
  uint64_t v10 = 0x400000000;
  unsigned int v4 = *(_DWORD *)(a2 + 40);
  if (v4)
  {
    sub_1CD6BBEE8((uint64_t)&__base, a2 + 32);
    unsigned int v4 = v10;
  }
  uint64_t v5 = *(void *)(a2 + 80);
  if (v5)
  {
    if (v4 >= HIDWORD(v10)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)__base + v4) = v5;
    unsigned int v4 = v10 + 1;
    LODWORD(v10) = v10 + 1;
  }
  if (v4 >= 2) {
    qsort(__base, v4, 8uLL, (int (__cdecl *)(const void *, const void *))sub_1CD4783D8);
  }
  uint64_t v6 = sub_1CCE0CA38(*(void *)a1, *(_DWORD *)(a1 + 16), (uint64_t)&__base, &v8);
  if (__base != v11) {
    free(__base);
  }
  return v6;
}

_DWORD *sub_1CCE110E0(_DWORD *result, int a2)
{
  uint64_t v2 = result;
  if (a2)
  {
    unint64_t v3 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    LODWORD(v4) = (((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8)) + 1;
    result[4] = v4;
    uint64_t result = operator new(24 * v4, (std::align_val_t)8uLL);
    *(void *)uint64_t v2 = result;
    *((void *)v2 + 1) = 0;
    uint64_t v5 = v2[4];
    if (v5)
    {
      uint64_t v6 = 24 * v5;
      do
      {
        *(_OWORD *)uint64_t result = xmmword_1CFB2D050;
        result += 6;
        v6 -= 24;
      }
      while (v6);
    }
  }
  else
  {
    *(void *)uint64_t result = 0;
    *((void *)result + 1) = 0;
    result[4] = 0;
  }
  return result;
}

float sub_1CCE11180(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (a2)
  {
    LODWORD(v3) = 0;
    uint64_t v4 = a1 + 96 * a2;
    do
    {
      if (*(void *)(a1 + 80) == a3)
      {
        BOOL v9 = 1;
      }
      else
      {
        uint64_t v5 = *(void *)(a1 + 32);
        uint64_t v6 = *(unsigned int *)(a1 + 40);
        if (v6)
        {
          uint64_t v7 = 8 * v6;
          uint64_t v8 = *(void **)(a1 + 32);
          while (*v8 != a3)
          {
            ++v8;
            v7 -= 8;
            if (!v7)
            {
              uint64_t v8 = (void *)(v5 + 8 * v6);
              break;
            }
          }
        }
        else
        {
          uint64_t v8 = *(void **)(a1 + 32);
        }
        BOOL v9 = v6 != ((uint64_t)v8 - v5) >> 3;
      }
      uint64_t v3 = (v3 + v9);
      a1 += 96;
    }
    while (a1 != v4);
  }
  else
  {
    uint64_t v3 = 0;
  }
  return (float)((unint64_t)a2 - v3) / (float)a2;
}

void sub_1CCE1121C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, long long *a5, unsigned int *a6, uint64_t a7)
{
  void v90[4] = *MEMORY[0x1E4F143B8];
  unsigned int v11 = *(_DWORD *)(a4 + 8);
  uint64_t v12 = *(void *)(a1 + 360);
  uint64_t v85 = 1;
  int64x2_t v86 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  int64x2_t v87 = v86;
  uint64_t v88 = (char *)v90;
  uint64_t v89 = 0x400000000;
  uint64_t v13 = *((void *)a6 + 1);
  if (v13 == *(void *)a6) {
    uint64_t v14 = a6 + 5;
  }
  else {
    uint64_t v14 = a6 + 4;
  }
  uint64_t v15 = *v14;
  if (v15)
  {
    uint64_t v16 = 8 * v15;
    int v17 = (unint64_t *)*((void *)a6 + 1);
    while (*v17 >= 0xFFFFFFFFFFFFFFFELL)
    {
      ++v17;
      v16 -= 8;
      if (!v16) {
        goto LABEL_46;
      }
    }
  }
  else
  {
    int v17 = (unint64_t *)*((void *)a6 + 1);
  }
  uint64_t v18 = (unint64_t *)(v13 + 8 * v15);
  if (v17 != v18)
  {
    uint64_t v19 = v12 + 1904 * v11;
    unsigned int v20 = (uint64_t *)(v19 + 1840);
    uint64_t v21 = (unsigned int *)(v19 + 1860);
    BOOL v22 = (unsigned int *)(v19 + 1856);
LABEL_12:
    int v79 = 0;
    uint64_t v23 = (unsigned char *)*v17;
    int v79 = (unsigned char *)*v17;
    uint64_t v25 = *v20;
    uint64_t v24 = v20[1];
    if (v24 == *v20)
    {
      uint64_t v26 = *v21;
      unint64_t v27 = (void *)(v24 + 8 * v26);
      if (v26)
      {
        uint64_t v28 = 0;
        uint64_t v29 = 8 * v26;
        while (*(unsigned char **)(v24 + v28) != v23)
        {
          v28 += 8;
          if (v29 == v28) {
            goto LABEL_30;
          }
        }
        unint64_t v27 = (void *)(v24 + v28);
LABEL_30:
        uint64_t v25 = v20[1];
      }
      else
      {
        uint64_t v25 = v20[1];
      }
    }
    else
    {
      uint64_t v30 = *v22;
      int v31 = v30 - 1;
      unsigned int v32 = (v30 - 1) & ((v23 >> 4) ^ (v23 >> 9));
      unint64_t v27 = (void *)(v24 + 8 * v32);
      uint64_t v33 = (unsigned char *)*v27;
      if (*v27 == -1)
      {
        uint64_t v34 = 0;
LABEL_33:
        if (v34) {
          unint64_t v27 = v34;
        }
        if ((unsigned char *)*v27 != v23) {
          unint64_t v27 = (void *)(v24 + 8 * v30);
        }
      }
      else
      {
        uint64_t v34 = 0;
        int v35 = 1;
        while (v33 != v23)
        {
          if (v34) {
            BOOL v36 = 0;
          }
          else {
            BOOL v36 = v33 == (unsigned char *)-2;
          }
          if (v36) {
            uint64_t v34 = v27;
          }
          unsigned int v37 = v32 + v35++;
          unsigned int v32 = v37 & v31;
          unint64_t v27 = (void *)(v24 + 8 * (v37 & v31));
          uint64_t v33 = (unsigned char *)*v27;
          if (*v27 == -1) {
            goto LABEL_33;
          }
        }
      }
    }
    if (v24 == v25) {
      uint64_t v38 = v21;
    }
    else {
      uint64_t v38 = v22;
    }
    if (v27 != (void *)(v24 + 8 * *v38))
    {
      long long v75 = v22;
      sub_1CD4B43C4((uint64_t)&v85, (uint64_t *)&v79);
      BOOL v22 = v75;
    }
    uint64_t v39 = v17 + 1;
    while (v39 != v18)
    {
      unint64_t v40 = *v39++;
      if (v40 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        int v17 = v39 - 1;
        goto LABEL_12;
      }
    }
  }
LABEL_46:
  int v79 = v83;
  uint64_t v80 = v83;
  uint64_t v81 = 16;
  int v82 = 0;
  uint64_t v41 = *(void *)(a1 + 8);
  uint64_t v42 = *(void *)(a1 + 48);
  int v43 = *(_DWORD *)(a1 + 72);
  *(void *)&long long v77 = *(void *)(a1 + 56);
  *((void *)&v77 + 1) = v41;
  *(void *)uint64_t v78 = v42;
  *(_DWORD *)&v78[40] = v43;
  uint64_t v44 = v12 + 1904 * v11;
  memset(&v78[8], 0, 32);
  unsigned int v45 = *(_DWORD *)(v44 + 680);
  if (!v45) {
    goto LABEL_110;
  }
  uint64_t v76 = v12 + 1904 * v11;
  uint64_t v46 = *(void *)(v44 + 672);
  uint64_t v47 = v46 + 96 * v45;
  unsigned int v49 = (_OWORD *)a3;
  uint64_t v48 = a7;
  int v50 = (_DWORD *)(a3 + 24);
  do
  {
    if (*(_DWORD *)(a1 + 72) != 1 || *(_DWORD *)(v76 + 24) != 2)
    {
      uint64_t v52 = *(void *)(v46 + 80);
      uint64_t v53 = *(unsigned int *)(v46 + 40);
      if (v52) {
        unint64_t v54 = v53 + 1;
      }
      else {
        unint64_t v54 = *(unsigned int *)(v46 + 40);
      }
      if (v54 >= v89) {
        LODWORD(v54) = v89;
      }
      if (v89)
      {
        int v55 = (uint64_t *)v88;
        while (1)
        {
          uint64_t v56 = *v55;
          if (v52)
          {
            if (v52 == v56) {
              goto LABEL_116;
            }
          }
          uint64_t v57 = *(void *)(v46 + 32);
          if (v53)
          {
            uint64_t v58 = 8 * v53;
            size_t v59 = *(void **)(v46 + 32);
            while (*v59 != v56)
            {
              ++v59;
              v58 -= 8;
              if (!v58)
              {
                size_t v59 = (void *)(v57 + 8 * v53);
                break;
              }
            }
          }
          else
          {
            size_t v59 = *(void **)(v46 + 32);
          }
          if (v53 != ((uint64_t)v59 - v57) >> 3)
          {
LABEL_116:
            LODWORD(v54) = v54 - 1;
            if (!v54) {
              break;
            }
          }
          if (++v55 == (uint64_t *)&v88[8 * v89]) {
            goto LABEL_70;
          }
        }
      }
      else
      {
LABEL_70:
        if (v54) {
          goto LABEL_105;
        }
      }
    }
    long long v60 = a5[1];
    long long v77 = *a5;
    *(_OWORD *)uint64_t v78 = v60;
    *(_OWORD *)&v78[16] = a5[2];
    *(_OWORD *)&v78[28] = *(long long *)((char *)a5 + 44);
    if (&v79 != (unsigned char **)a6) {
      llvm::SmallPtrSetImplBase::CopyFrom((llvm::SmallPtrSetImplBase *)&v79, (const llvm::SmallPtrSetImplBase *)a6);
    }
    sub_1CCE0F2C0((uint64_t)&v77, (void *)v46, (llvm::SmallPtrSetImplBase *)&v79, v48, v76, 0);
    if (word_1EBCF5170) {
      BOOL v61 = byte_1EBCF51E8 == 0;
    }
    else {
      BOOL v61 = 1;
    }
    if (v61 || *(_DWORD *)&v78[8] == *v50)
    {
      if (!(*(unsigned int (**)(void, unsigned char *, _DWORD *))(***(void ***)v78 + 272))(**(void **)v78, &v78[8], v50))goto LABEL_105; {
    }
      }
    else if (*(_DWORD *)&v78[8] >= *v50)
    {
      goto LABEL_105;
    }
    unint64_t v62 = *(unsigned int *)(a4 + 8);
    if (v62 >= *(unsigned int *)(a4 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)a4 + 8 * v62) = v46;
    int v63 = *(_DWORD *)(a4 + 8) + 1;
    *(_DWORD *)(a4 + 8) = v63;
    if (v63 == *(_DWORD *)(a1 + 368))
    {
      long long v64 = *(_OWORD *)v78;
      _OWORD *v49 = v77;
      v49[1] = v64;
      v49[2] = *(_OWORD *)&v78[16];
      *(_OWORD *)((char *)v49 + 44) = *(_OWORD *)&v78[28];
      if (a2 != a4)
      {
        uint64_t v65 = *(unsigned int *)(a4 + 8);
        uint64_t v66 = a2;
        uint64_t v67 = *(unsigned int *)(a2 + 8);
        if (v67 >= v65)
        {
          if (v65)
          {
            memmove(*(void **)a2, *(const void **)a4, 8 * v65);
            uint64_t v66 = a2;
          }
          *(_DWORD *)(v66 + 8) = v65;
        }
        else
        {
          if (*(_DWORD *)(a2 + 12) < v65)
          {
            *(_DWORD *)(a2 + 8) = 0;
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          if (v67) {
            memmove(*(void **)a2, *(const void **)a4, 8 * v67);
          }
          else {
            uint64_t v67 = 0;
          }
          uint64_t v71 = *(unsigned int *)(a4 + 8);
          if (v67 != v71) {
            memcpy((void *)(*(void *)a2 + 8 * v67), (const void *)(*(void *)a4 + 8 * v67), *(void *)a4 + 8 * v71 - (*(void *)a4 + 8 * v67));
          }
          *(_DWORD *)(a2 + 8) = v65;
        }
        unsigned int v49 = (_OWORD *)a3;
        uint64_t v48 = a7;
      }
    }
    else
    {
      sub_1CCE1121C(a1, a2, v49, a4, &v77, &v79, v48);
      uint64_t v68 = (uint64_t *)(v46 + 80);
      uint64_t v69 = *(void *)(v46 + 80);
      uint64_t v70 = *(unsigned int *)(v46 + 40);
      if (v69) {
        ++v70;
      }
      if (v70 == 1 && *(_DWORD *)(a4 + 8) == 1)
      {
        if (!v69) {
          uint64_t v68 = *(uint64_t **)(v46 + 32);
        }
        sub_1CD4C96F8((uint64_t)v84, v48, v68);
      }
    }
    --*(_DWORD *)(a4 + 8);
LABEL_105:
    v46 += 96;
  }
  while (v46 != v47);
  if (v80 != v79) {
    free(v80);
  }
LABEL_110:
  if (v88 != (char *)v90) {
    free(v88);
  }
  if ((v85 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v86.i64[0], 8);
  }
}

uint64_t sub_1CCE11844(uint64_t *a1, void *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v6 = *a1;
    int v7 = v3 - 1;
    unsigned int v8 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
    uint64_t v4 = (void *)(*a1 + 8 * v8);
    uint64_t v9 = *v4;
    if (*a2 == *v4)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      uint64_t result = 1;
      while (v9 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v9 == -8192;
        }
        if (v12) {
          uint64_t v10 = v4;
        }
        unsigned int v13 = v8 + v11++;
        unsigned int v8 = v13 & v7;
        uint64_t v4 = (void *)(v6 + 8 * (v13 & v7));
        uint64_t v9 = *v4;
        if (*a2 == *v4) {
          goto LABEL_3;
        }
      }
      uint64_t result = 0;
      if (v10) {
        uint64_t v4 = v10;
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a3 = v4;
  return result;
}

llvm::ConstantExpr *sub_1CCE118E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, uint64_t a6, unsigned int *a7)
{
  uint64_t v7 = a3;
  uint64_t v235 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a2 + 657)) {
    return *(llvm::ConstantExpr **)(a3 + 8);
  }
  __int16 v228 = v230;
  uint64_t v229 = 0x400000000;
  uint64_t v14 = *(void *)(a3 + 8);
  if (v14) {
    BOOL v15 = *(unsigned __int8 *)(v14 + 16) >= 0x1Cu;
  }
  else {
    BOOL v15 = 0;
  }
  if (v15)
  {
    v230[0] = *(void *)(a3 + 8);
    unsigned int v16 = 1;
    LODWORD(v229) = 1;
  }
  else
  {
    unsigned int v16 = 0;
  }
  if (*(_DWORD *)(a2 + 24) == 3)
  {
    uint64_t v17 = *(void *)(*(void *)a3 - 32);
    if (v17 && *(unsigned __int8 *)(v17 + 16) >= 0x1Cu)
    {
      v230[v16++] = v17;
      LODWORD(v229) = v16;
    }
  }
  unsigned int v20 = *(unint64_t **)(a3 + 16);
  uint64_t v19 = *(unint64_t **)(a3 + 24);
  uint64_t v21 = (const llvm::SmallPtrSetImplBase *)(a3 + 16);
  uint64_t v22 = *(void *)(a1 + 56);
  if (v19 == v20)
  {
    uint64_t v23 = *(unsigned int *)(a3 + 36);
    uint64_t v24 = &v19[v23];
    if (v23)
    {
      uint64_t v25 = 0;
      while (v19[v25] != v22)
      {
        if (v23 == ++v25) {
          goto LABEL_34;
        }
      }
      uint64_t v24 = &v19[v25];
    }
LABEL_34:
    uint64_t v34 = *(unint64_t **)(a3 + 24);
    goto LABEL_42;
  }
  uint64_t v26 = *(unsigned int *)(a3 + 32);
  int v27 = v26 - 1;
  unsigned int v28 = (v26 - 1) & ((v22 >> 4) ^ (v22 >> 9));
  uint64_t v24 = &v19[v28];
  unint64_t v29 = *v24;
  if (*v24 != -1)
  {
    uint64_t v30 = 0;
    int v31 = 1;
    while (v29 != v22)
    {
      if (v30) {
        BOOL v32 = 0;
      }
      else {
        BOOL v32 = v29 == -2;
      }
      if (v32) {
        uint64_t v30 = v24;
      }
      unsigned int v33 = v28 + v31++;
      unsigned int v28 = v33 & v27;
      uint64_t v24 = &v19[v33 & v27];
      unint64_t v29 = *v24;
      if (*v24 == -1) {
        goto LABEL_36;
      }
    }
LABEL_40:
    LODWORD(v23) = *(_DWORD *)(a3 + 36);
    goto LABEL_41;
  }
  uint64_t v30 = 0;
LABEL_36:
  if (v30) {
    uint64_t v24 = v30;
  }
  if (*v24 == v22) {
    goto LABEL_40;
  }
  LODWORD(v23) = *(_DWORD *)(a3 + 36);
  uint64_t v24 = &v19[v26];
LABEL_41:
  uint64_t v34 = *(unint64_t **)(a3 + 16);
LABEL_42:
  unsigned int v35 = *(_DWORD *)(a3 + 32);
  if (v19 == v34) {
    int v36 = v23;
  }
  else {
    int v36 = *(_DWORD *)(a3 + 32);
  }
  uint64_t v224 = a2;
  if (v24 != &v19[v36])
  {
    if (sub_1CCE0A174(*(void *)a3, v14, v22)) {
      llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopLatch();
    }
    *((void *)v228 + v16) = *(void *)(a1 + 80);
    LODWORD(v229) = v229 + 1;
    uint64_t v7 = a3;
    unsigned int v20 = *(unint64_t **)(a3 + 16);
    uint64_t v19 = *(unint64_t **)(a3 + 24);
    unsigned int v35 = *(_DWORD *)(a3 + 32);
    LODWORD(v23) = *(_DWORD *)(a3 + 36);
  }
  if (v19 == v20) {
    uint64_t v37 = v23;
  }
  else {
    uint64_t v37 = v35;
  }
  uint64_t v38 = v19;
  if (v37)
  {
    uint64_t v39 = 8 * v37;
    uint64_t v38 = v19;
    while (*v38 >= 0xFFFFFFFFFFFFFFFELL)
    {
      ++v38;
      v39 -= 8;
      if (!v39) {
        goto LABEL_65;
      }
    }
  }
  unint64_t v40 = &v19[v37];
  if (v38 != v40)
  {
    unint64_t v41 = *v38;
LABEL_59:
    if (v41 != *(void *)(a1 + 56))
    {
      uint64_t v231 = v233;
      uint64_t v232 = 0x400000000;
      llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getExitingBlocks();
    }
    uint64_t v42 = v38 + 1;
    while (v42 != v40)
    {
      unint64_t v43 = *v42++;
      unint64_t v41 = v43;
      if (v43 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        uint64_t v38 = v42 - 1;
        goto LABEL_59;
      }
    }
  }
LABEL_65:
  uint64_t v44 = (const llvm::Instruction *)(a5 - 24);
  if (a5) {
    unsigned int v45 = a5 - 24;
  }
  else {
    unsigned int v45 = 0;
  }
  uint64_t v46 = a5;
  uint64_t v225 = a4;
  if (v45[16] == 38) {
    goto LABEL_134;
  }
  uint64_t v46 = a5;
  do
  {
    if (v229)
    {
      uint64_t v47 = 0;
      uint64_t v48 = (const llvm::Value **)v228;
      uint64_t v49 = 8 * v229;
      do
      {
        int v50 = *v48;
        if (*v48 == v44 || !llvm::DominatorTree::dominates(*(llvm::DominatorTree **)(a1 + 16), *v48, v44))
        {
          a4 = v225;
          uint64_t v7 = a3;
          goto LABEL_134;
        }
        if (*((void *)v44 + 5) == *((void *)v50 + 5)
          && (!v47 || (llvm::DominatorTree::dominates(*(llvm::DominatorTree **)(a1 + 16), v50, v47) & 1) == 0))
        {
          uint64_t v51 = *((void *)v50 + 4);
          if (v51) {
            uint64_t v47 = (const llvm::Instruction *)(v51 - 24);
          }
          else {
            uint64_t v47 = 0;
          }
        }
        ++v48;
        v49 -= 8;
      }
      while (v49);
    }
    else
    {
      uint64_t v47 = 0;
    }
    if (v47) {
      uint64_t v52 = v47;
    }
    else {
      uint64_t v52 = v44;
    }
    uint64_t v53 = *(uint64_t **)(a1 + 24);
    uint64_t v54 = *((void *)v52 + 5);
    uint64_t v55 = *v53;
    int v56 = *((_DWORD *)v53 + 4);
    unsigned int v57 = v54 >> 4;
    if (v56)
    {
      uint64_t v58 = (v57 ^ (v54 >> 9)) & (v56 - 1);
      uint64_t v59 = *(void *)(v55 + 16 * v58);
      a4 = v225;
      uint64_t v7 = a3;
      if (v54 != v59)
      {
        int v60 = 1;
        while (v59 != -4096)
        {
          int v61 = v58 + v60++;
          uint64_t v58 = v61 & (v56 - 1);
          uint64_t v59 = *(void *)(v55 + 16 * v58);
          if (v54 == v59) {
            goto LABEL_91;
          }
        }
        unint64_t v62 = 0;
LABEL_96:
        unsigned int v63 = 0;
        goto LABEL_97;
      }
LABEL_91:
      unint64_t v62 = *(void **)(v55 + 16 * v58 + 8);
      if (!v62) {
        goto LABEL_96;
      }
      unsigned int v63 = 0;
      long long v64 = v62;
      do
      {
        long long v64 = (void *)*v64;
        ++v63;
      }
      while (v64);
    }
    else
    {
      unint64_t v62 = 0;
      unsigned int v63 = 0;
      a4 = v225;
      uint64_t v7 = a3;
    }
LABEL_97:
    uint64_t v65 = *(void *)(a1 + 16);
    uint64_t v66 = *(void *)(v65 + 24);
    uint64_t v67 = *(unsigned int *)(v65 + 40);
    if (v67)
    {
      LODWORD(v68) = (v67 - 1) & (v57 ^ (v54 >> 9));
      uint64_t v69 = (uint64_t *)(v66 + 16 * v68);
      uint64_t v70 = *v69;
      if (v54 == *v69) {
        goto LABEL_104;
      }
      int v71 = 1;
      while (v70 != -4096)
      {
        int v72 = v68 + v71++;
        uint64_t v68 = v72 & (v67 - 1);
        uint64_t v70 = *(void *)(v66 + 16 * v68);
        if (v54 == v70)
        {
          uint64_t v69 = (uint64_t *)(v66 + 16 * v68);
          goto LABEL_104;
        }
      }
    }
    uint64_t v69 = (uint64_t *)(v66 + 16 * v67);
LABEL_104:
    uint64_t v46 = (char *)v52 + 24;
    if (v69 == (uint64_t *)(v66 + 16 * v67)) {
      goto LABEL_134;
    }
    uint64_t v73 = v69[1];
    if (!v73) {
      goto LABEL_134;
    }
    int v74 = *(uint64_t **)(v73 + 8);
    if (!v74) {
      goto LABEL_134;
    }
    unsigned int v75 = v56 - 1;
    while (1)
    {
      uint64_t v76 = *v74;
      if (!v56) {
        goto LABEL_118;
      }
      uint64_t v77 = ((v76 >> 4) ^ (v76 >> 9)) & v75;
      uint64_t v78 = *(void *)(v55 + 16 * v77);
      if (v76 != v78)
      {
        int v79 = 1;
        while (v78 != -4096)
        {
          int v80 = v77 + v79++;
          uint64_t v77 = v80 & v75;
          uint64_t v78 = *(void *)(v55 + 16 * v77);
          if (v76 == v78) {
            goto LABEL_113;
          }
        }
LABEL_118:
        unsigned int v82 = 0;
        uint64_t v81 = 0;
        goto LABEL_120;
      }
LABEL_113:
      uint64_t v81 = *(void **)(v55 + 16 * v77 + 8);
      if (v81)
      {
        unsigned int v82 = 0;
        long long v83 = v81;
        do
        {
          long long v83 = (void *)*v83;
          ++v82;
        }
        while (v83);
        if (v82 > v63) {
          goto LABEL_122;
        }
      }
      else
      {
        unsigned int v82 = 0;
      }
LABEL_120:
      if (v82 != v63 || v81 == v62) {
        break;
      }
LABEL_122:
      int v74 = (uint64_t *)v74[1];
      if (!v74) {
        goto LABEL_134;
      }
    }
    uint64_t v84 = *(void *)(v76 + 40);
    uint64_t v44 = (const llvm::Instruction *)(v84 - 24);
    if (v84) {
      uint64_t v85 = v84 - 24;
    }
    else {
      uint64_t v85 = 0;
    }
    if (*(unsigned __int8 *)(v85 + 16) - 29 >= 0xB) {
      uint64_t v85 = 0;
    }
  }
  while (*(unsigned char *)(v85 + 16) != 38);
  while (1)
  {
LABEL_134:
    int64x2_t v86 = v46 - 24;
    if (!v46) {
      int64x2_t v86 = 0;
    }
    if (v86[16] != 83) {
      break;
    }
    uint64_t v46 = (char *)*((void *)v46 + 1);
  }
  while (1)
  {
    uint64_t v87 = (uint64_t)(v46 - 24);
    uint64_t v88 = v46 ? (uint64_t)(v46 - 24) : 0;
    unsigned int v89 = *(unsigned __int8 *)(v88 + 16) - 38;
    BOOL v90 = v89 > 0x38;
    uint64_t v91 = (1 << v89) & 0x100060000000001;
    if (v90 || v91 == 0) {
      break;
    }
    uint64_t v46 = (char *)*((void *)v46 + 1);
  }
  if (sub_1CBF63B28(v88))
  {
    do
    {
      uint64_t v46 = (char *)*((void *)v46 + 1);
      if (v46) {
        uint64_t v87 = (uint64_t)(v46 - 24);
      }
      else {
        uint64_t v87 = 0;
      }
    }
    while (sub_1CBF63B28(v87));
  }
  while (sub_1CCE12E28(a6, v87) && v46 != a5)
  {
    uint64_t v46 = (char *)*((void *)v46 + 1);
    if (v46) {
      uint64_t v87 = (uint64_t)(v46 - 24);
    }
    else {
      uint64_t v87 = 0;
    }
  }
  if (v228 != v230) {
    free(v228);
  }
  *(void *)(a6 + 496) = *(void *)(v87 + 40);
  *(void *)(a6 + 504) = v87 + 24;
  unsigned int v94 = *(void **)(v87 + 48);
  uint64_t v231 = v94;
  if (v94)
  {
    llvm::MetadataTracking::track((uint64_t)&v231, (unsigned __int8 *)v94, 2);
    int v95 = v231;
  }
  else
  {
    int v95 = 0;
  }
  sub_1CB8461A4(a6 + 448, 0, (uint64_t)v95);
  if (v231)
  {
    int v129 = *(unsigned __int8 *)v231;
    if ((v129 - 4) > 0x1E)
    {
      if ((v129 - 3) >= 0xFFFFFFFE) {
        uint64_t v175 = v231;
      }
      else {
        uint64_t v175 = 0;
      }
      if ((v129 - 3) < 0xFFFFFFFE)
      {
        if (v129 == 3) {
          *((void *)v231 + 1) = 0;
        }
        goto LABEL_164;
      }
      unint64_t v131 = (unint64_t)v175 + 8;
    }
    else
    {
      if ((*((unsigned char *)v231 + 1) & 0x7F) != 2 && !*((_DWORD *)v231 + 3)) {
        goto LABEL_164;
      }
      uint64_t v130 = *((void *)v231 + 2);
      if ((v130 & 4) == 0) {
        goto LABEL_164;
      }
      unint64_t v131 = v130 & 0xFFFFFFFFFFFFFFF8;
      if (!v131) {
        goto LABEL_164;
      }
    }
    __int16 v228 = &v231;
    sub_1CC5FA668(v131 + 16, &v228);
  }
LABEL_164:
  if ((const llvm::SmallPtrSetImplBase *)(a6 + 352) != v21) {
    llvm::SmallPtrSetImplBase::CopyFrom((llvm::SmallPtrSetImplBase *)(a6 + 352), v21);
  }
  uint64_t v96 = **(void **)(v7 + 8);
  uint64_t v97 = sub_1CCE0F064((uint64_t *)a4);
  uint64_t v99 = v96;
  if (v97)
  {
    uint64_t v100 = v97;
    unsigned int v101 = *(_DWORD *)(v97 + 8);
    if (v101 == 13)
    {
      uint64_t v102 = (uint64_t **)v97;
    }
    else
    {
      uint64_t v188 = *(void *)(**(void **)(a1 + 8) + 40);
      if ((v101 & 0xFE) == 0x12) {
        unsigned int v101 = *(_DWORD *)(**(void **)(v97 + 16) + 8);
      }
      uint64_t v189 = *(void *)(v188 + 504);
      if (v101 < 0x100) {
        goto LABEL_306;
      }
      unsigned int v190 = v101 >> 8;
      unint64_t v191 = *(unsigned int *)(v188 + 512);
      uint64_t v192 = v189;
      if (v191)
      {
        uint64_t v192 = v189;
        unint64_t v193 = v191;
        do
        {
          unint64_t v194 = v193 >> 1;
          uint64_t v195 = v192 + 16 * (v193 >> 1);
          unsigned int v196 = *(_DWORD *)(v195 + 8);
          uint64_t v197 = v195 + 16;
          v193 += ~(v193 >> 1);
          if (v196 < v190) {
            uint64_t v192 = v197;
          }
          else {
            unint64_t v193 = v194;
          }
        }
        while (v193);
      }
      if (v192 == v189 + 16 * v191 || *(_DWORD *)(v192 + 8) != v190) {
LABEL_306:
      }
        uint64_t v192 = v189;
      unsigned int v198 = (uint64_t **)llvm::IntegerType::get(*(llvm::IntegerType **)v97, (llvm::LLVMContext *)*(unsigned int *)(v192 + 12));
      uint64_t v102 = v198;
      if ((*(_DWORD *)(v100 + 8) & 0xFE) == 0x12)
      {
        unsigned int v199 = (llvm::Type *)*(unsigned int *)(v100 + 32);
        if (*(_DWORD *)(v100 + 8) == 19) {
          llvm::ScalableVectorType::get(v198, v199);
        }
        else {
          llvm::FixedVectorType::get((llvm::FixedVectorType *)v198, v199);
        }
        uint64_t v102 = v200;
        a4 = v225;
        uint64_t v7 = a3;
      }
    }
    unsigned int v103 = *(_DWORD *)(v96 + 8);
    unsigned int v104 = (uint64_t **)v96;
    if (v103 != 13)
    {
      uint64_t v201 = *(void *)(**(void **)(a1 + 8) + 40);
      if ((v103 & 0xFE) == 0x12) {
        unsigned int v103 = *(_DWORD *)(**(void **)(v96 + 16) + 8);
      }
      uint64_t v202 = *(void *)(v201 + 504);
      if (v103 < 0x100) {
        goto LABEL_322;
      }
      unsigned int v203 = v103 >> 8;
      unint64_t v204 = *(unsigned int *)(v201 + 512);
      uint64_t v205 = v202;
      if (v204)
      {
        uint64_t v205 = v202;
        unint64_t v206 = v204;
        do
        {
          unint64_t v207 = v206 >> 1;
          uint64_t v208 = v205 + 16 * (v206 >> 1);
          unsigned int v209 = *(_DWORD *)(v208 + 8);
          uint64_t v210 = v208 + 16;
          v206 += ~(v206 >> 1);
          if (v209 < v203) {
            uint64_t v205 = v210;
          }
          else {
            unint64_t v206 = v207;
          }
        }
        while (v206);
      }
      if (v205 == v202 + 16 * v204 || *(_DWORD *)(v205 + 8) != v203) {
LABEL_322:
      }
        uint64_t v205 = v202;
      unsigned int v104 = (uint64_t **)llvm::IntegerType::get(*(llvm::IntegerType **)v96, (llvm::LLVMContext *)*(unsigned int *)(v205 + 12));
      if ((*(_DWORD *)(v96 + 8) & 0xFE) == 0x12)
      {
        uint64_t v211 = (llvm::Type *)*(unsigned int *)(v96 + 32);
        if (*(_DWORD *)(v96 + 8) == 19) {
          llvm::ScalableVectorType::get(v104, v211);
        }
        else {
          llvm::FixedVectorType::get((llvm::FixedVectorType *)v104, v211);
        }
        a4 = v225;
        uint64_t v7 = a3;
      }
    }
    if (v102 == v104) {
      uint64_t v99 = v96;
    }
    else {
      uint64_t v99 = v100;
    }
  }
  unsigned int v105 = *(_DWORD *)(v99 + 8);
  unsigned int v227 = (uint64_t **)v99;
  if (v105 != 13)
  {
    uint64_t v176 = *(void *)(**(void **)(a1 + 8) + 40);
    if ((v105 & 0xFE) == 0x12) {
      unsigned int v105 = *(_DWORD *)(**(void **)(v99 + 16) + 8);
    }
    uint64_t v177 = *(void *)(v176 + 504);
    if (v105 < 0x100) {
      goto LABEL_288;
    }
    unsigned int v178 = v105 >> 8;
    unint64_t v179 = *(unsigned int *)(v176 + 512);
    uint64_t v180 = v177;
    if (v179)
    {
      uint64_t v180 = v177;
      unint64_t v181 = v179;
      do
      {
        unint64_t v182 = v181 >> 1;
        uint64_t v183 = v180 + 16 * (v181 >> 1);
        unsigned int v184 = *(_DWORD *)(v183 + 8);
        uint64_t v185 = v183 + 16;
        v181 += ~(v181 >> 1);
        if (v184 < v178) {
          uint64_t v180 = v185;
        }
        else {
          unint64_t v181 = v182;
        }
      }
      while (v181);
    }
    if (v180 == v177 + 16 * v179 || *(_DWORD *)(v180 + 8) != v178) {
LABEL_288:
    }
      uint64_t v180 = v177;
    unsigned int v227 = (uint64_t **)llvm::IntegerType::get(*(llvm::IntegerType **)v99, (llvm::LLVMContext *)*(unsigned int *)(v180 + 12));
    if ((*(_DWORD *)(v99 + 8) & 0xFE) == 0x12)
    {
      uint64_t v186 = (llvm::Type *)*(unsigned int *)(v99 + 32);
      if (*(_DWORD *)(v99 + 8) == 19) {
        llvm::ScalableVectorType::get(v227, v186);
      }
      else {
        llvm::FixedVectorType::get((llvm::FixedVectorType *)v227, v186);
      }
      unsigned int v227 = v187;
      a4 = v225;
      uint64_t v7 = a3;
    }
  }
  __int16 v228 = v230;
  uint64_t v229 = 0x800000000;
  uint64_t v106 = *(unsigned int *)(a4 + 40);
  if (v106)
  {
    uint64_t v107 = *(uint64_t **)(a4 + 32);
    uint64_t v108 = 8 * v106;
    do
    {
      uint64_t v109 = (llvm::Instruction **)llvm::denormalizeForPostIncUse(*v107, (uint64_t)v21, *(void *)(a1 + 8));
      __int16 v110 = *(llvm::ScalarEvolution **)(a1 + 8);
      uint64_t v111 = llvm::SCEVExpander::expandCodeForImpl((llvm::SCEVExpander *)a6, v109, 0);
      unint64_t Unknown = llvm::ScalarEvolution::getUnknown(v110, v111);
      if (v229 >= (unint64_t)HIDWORD(v229)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v228 + v229) = Unknown;
      LODWORD(v106) = v229 + 1;
      LODWORD(v229) = v229 + 1;
      ++v107;
      v108 -= 8;
    }
    while (v108);
  }
  if (*(void *)(a4 + 24))
  {
    uint64_t v113 = (llvm::Instruction **)llvm::denormalizeForPostIncUse(*(void *)(a4 + 80), (uint64_t)v21, *(void *)(a1 + 8));
    int v114 = *(_DWORD *)(v224 + 24);
    if (v114 == 3)
    {
      if (*(void *)(a4 + 24) == 1)
      {
        int v115 = *(llvm::ScalarEvolution **)(a1 + 8);
        unsigned int v116 = llvm::SCEVExpander::expandCodeForImpl((llvm::SCEVExpander *)a6, v113, 0);
        unint64_t MulExpr = llvm::ScalarEvolution::getUnknown(v115, v116);
        goto LABEL_210;
      }
      uint64_t v118 = (uint64_t *)llvm::SCEVExpander::expandCodeForImpl((llvm::SCEVExpander *)a6, v113, 0);
      LODWORD(v106) = v229;
    }
    else
    {
      if (v114 == 2 && v229 && sub_1CCE10414(*(uint64_t **)(a1 + 48), v224, (void *)a4))
      {
        uint64_t AddExpr = (llvm::Instruction **)llvm::ScalarEvolution::getAddExpr(*(void *)(a1 + 8), (unint64_t **)&v228, 0, 0);
        int v120 = llvm::SCEVExpander::expandCodeForImpl((llvm::SCEVExpander *)a6, AddExpr, 0);
        LODWORD(v229) = 0;
        unint64_t v121 = llvm::ScalarEvolution::getUnknown(*(llvm::ScalarEvolution **)(a1 + 8), v120);
        if (v229 >= HIDWORD(v229)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v228 + v229) = v121;
        LODWORD(v229) = v229 + 1;
      }
      uint64_t v122 = *(llvm::ScalarEvolution **)(a1 + 8);
      uint64_t v123 = llvm::SCEVExpander::expandCodeForImpl((llvm::SCEVExpander *)a6, v113, 0);
      unint64_t v124 = llvm::ScalarEvolution::getUnknown(v122, v123);
      unint64_t MulExpr = v124;
      uint64_t v98 = *(const llvm::APInt **)(a4 + 24);
      if (v98 != (const llvm::APInt *)1)
      {
        uint64_t v125 = *(void *)(a1 + 8);
        unint64_t v126 = v124;
        while (2)
        {
          switch(*(_WORD *)(v126 + 24))
          {
            case 1:
            case 2:
            case 3:
            case 0xD:
              uint64_t v128 = (llvm::Type **)(v126 + 40);
              goto LABEL_207;
            case 4:
              uint64_t v128 = (llvm::Type **)(v126 + 48);
              goto LABEL_207;
            case 5:
            case 7:
            case 8:
            case 9:
            case 0xA:
            case 0xB:
            case 0xC:
              uint64_t v127 = *(unint64_t **)(v126 + 32);
              goto LABEL_194;
            case 6:
              uint64_t v127 = (unint64_t *)(v126 + 40);
LABEL_194:
              unint64_t v126 = *v127;
              continue;
            case 0xE:
              uint64_t v128 = *(llvm::Type ***)(v126 - 8);
              goto LABEL_207;
            default:
              uint64_t v128 = *(llvm::Type ***)(v126 + 32);
LABEL_207:
              unint64_t Constant = llvm::ScalarEvolution::getConstant(*(llvm::ScalarEvolution **)(a1 + 8), *v128, (unint64_t)v98, 0);
              uint64_t v231 = v233;
              v233[0] = MulExpr;
              v233[1] = Constant;
              uint64_t v232 = 0x200000002;
              unint64_t MulExpr = llvm::ScalarEvolution::getMulExpr(v125, (uint64_t)&v231, 0, 0);
              if (v231 != v233) {
                free(v231);
              }
              uint64_t v7 = a3;
              break;
          }
          break;
        }
      }
LABEL_210:
      if (v229 >= HIDWORD(v229)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v118 = 0;
      *((void *)v228 + v229) = MulExpr;
      LODWORD(v106) = v229 + 1;
      LODWORD(v229) = v229 + 1;
    }
  }
  else
  {
    uint64_t v118 = 0;
  }
  uint64_t v133 = *(llvm::Value **)a4;
  if (*(void *)a4)
  {
    if (v106)
    {
      __int16 v134 = (llvm::Instruction **)llvm::ScalarEvolution::getAddExpr(*(void *)(a1 + 8), (unint64_t **)&v228, 0, 0);
      int v135 = llvm::SCEVExpander::expandCodeForImpl((llvm::SCEVExpander *)a6, v134, (llvm::Type *)v227);
      LODWORD(v229) = 0;
      unint64_t v136 = llvm::ScalarEvolution::getUnknown(*(llvm::ScalarEvolution **)(a1 + 8), v135);
      if (v229 >= HIDWORD(v229)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v228 + v229) = v136;
      LODWORD(v229) = v229 + 1;
      uint64_t v133 = *(llvm::Value **)a4;
    }
    unint64_t v137 = llvm::ScalarEvolution::getUnknown(*(llvm::ScalarEvolution **)(a1 + 8), v133);
    if (v229 >= HIDWORD(v229)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v228 + v229) = v137;
    LODWORD(v106) = v229 + 1;
    LODWORD(v229) = v229 + 1;
  }
  if (v106)
  {
    uint64_t v138 = (llvm::Instruction **)llvm::ScalarEvolution::getAddExpr(*(void *)(a1 + 8), (unint64_t **)&v228, 0, 0);
    uint64_t v139 = llvm::SCEVExpander::expandCodeForImpl((llvm::SCEVExpander *)a6, v138, (llvm::Type *)v99);
    LODWORD(v229) = 0;
    unint64_t v140 = llvm::ScalarEvolution::getUnknown(*(llvm::ScalarEvolution **)(a1 + 8), v139);
    if (v229 >= HIDWORD(v229)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v228 + v229) = v140;
    LODWORD(v229) = v229 + 1;
  }
  unint64_t v141 = *(void *)(v7 + 64) + *(void *)(a4 + 8);
  if (v141)
  {
    if (*(_DWORD *)(v224 + 24) == 3)
    {
      if (v118)
      {
        unint64_t v142 = llvm::ScalarEvolution::getUnknown(*(llvm::ScalarEvolution **)(a1 + 8), (llvm::Value *)v118);
        if (v229 >= HIDWORD(v229)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        uint64_t v143 = (llvm::ConstantInt *)v227;
        *((void *)v228 + v229) = v142;
        LODWORD(v229) = v229 + 1;
        unint64_t v144 = v141;
      }
      else
      {
        unint64_t v144 = -(uint64_t)v141;
        uint64_t v143 = (llvm::ConstantInt *)v227;
      }
      uint64_t v118 = llvm::ConstantInt::get(v143, v144, 0);
    }
    else
    {
      unsigned int v145 = *(llvm::ScalarEvolution **)(a1 + 8);
      Signed = llvm::ConstantInt::getSigned((llvm::ConstantInt *)v227, v141, v98);
      unint64_t v147 = llvm::ScalarEvolution::getUnknown(v145, Signed);
      if (v229 >= HIDWORD(v229)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v228 + v229) = v147;
      LODWORD(v229) = v229 + 1;
    }
  }
  unint64_t v148 = *(void *)(a4 + 88);
  if (v148)
  {
    uint64_t v149 = *(llvm::ScalarEvolution **)(a1 + 8);
    int v150 = llvm::ConstantInt::getSigned((llvm::ConstantInt *)v227, v148, v98);
    unint64_t v151 = llvm::ScalarEvolution::getUnknown(v149, v150);
    if (v229 >= HIDWORD(v229)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v228 + v229) = v151;
    int v152 = v229 + 1;
    LODWORD(v229) = v229 + 1;
  }
  else
  {
    int v152 = v229;
  }
  unsigned int v153 = *(llvm::ScalarEvolution **)(a1 + 8);
  if (v152) {
    unint64_t v154 = (llvm::Instruction **)llvm::ScalarEvolution::getAddExpr((uint64_t)v153, (unint64_t **)&v228, 0, 0);
  }
  else {
    unint64_t v154 = (llvm::Instruction **)llvm::ScalarEvolution::getConstant(v153, (llvm::Type *)v227, 0, 0);
  }
  unsigned int v8 = llvm::SCEVExpander::expandCodeForImpl((llvm::SCEVExpander *)a6, v154, (llvm::Type *)v99);
  uint64_t v155 = *(void **)(a6 + 360);
  if (v155 == *(void **)(a6 + 352))
  {
LABEL_238:
    *(void *)(a6 + 372) = 0;
  }
  else
  {
    uint64_t v174 = *(unsigned int *)(a6 + 368);
    if (v174 < 0x21 || 4 * (*(_DWORD *)(a6 + 372) - *(_DWORD *)(a6 + 376)) >= v174)
    {
      memset(v155, 255, 8 * v174);
      goto LABEL_238;
    }
    llvm::SmallPtrSetImplBase::shrink_and_clear((void **)(a6 + 352));
  }
  sub_1CBFC9A80((_DWORD *)(a6 + 80));
  if (*(_DWORD *)(v224 + 24) == 3)
  {
    uint64_t v157 = *(void *)v7;
    uint64_t v158 = *(void *)v7 - 32;
    if (*(unsigned __int8 *)(*(void *)v158 + 16) <= 0x1Bu) {
      uint64_t v159 = 0;
    }
    else {
      uint64_t v159 = *(void **)(*(void *)v7 - 32);
    }
    uint64_t v231 = v159;
    if (v159)
    {
      uint64_t v160 = a7;
      unsigned int v161 = a7[2];
      if (v161 >= a7[3])
      {
        sub_1CC9E6F68(a7, (uint64_t *)&v231);
      }
      else
      {
        int v162 = (llvm::ValueHandleBase *)(*(void *)a7 + 24 * v161);
        *(void *)int v162 = 6;
        *((void *)v162 + 1) = 0;
        *((void *)v162 + 2) = v159;
        if (v159 != (void *)-8192 && v159 != (void *)-4096)
        {
          llvm::ValueHandleBase::AddToUseList(v162);
          uint64_t v160 = a7;
          unsigned int v161 = a7[2];
        }
        v160[2] = v161 + 1;
      }
    }
    if (*(void *)(v225 + 24) == -1)
    {
      if (*v118 != v96)
      {
        int CastOpcode = llvm::CastInst::getCastOpcode((llvm::CastInst *)v118, 0, v96, 0);
        uint64_t v231 = "tmp";
        __int16 v234 = 259;
        Cast = llvm::CastInst::Create(CastOpcode, (uint64_t)v118, v96, (const char **)&v231, v157);
LABEL_255:
        uint64_t v118 = (uint64_t *)Cast;
      }
    }
    else
    {
      unsigned int v163 = *(_DWORD *)(v96 + 8);
      uint64_t v164 = (uint64_t **)v96;
      if (v163 != 13)
      {
        uint64_t v212 = *(void *)(**(void **)(a1 + 8) + 40);
        if ((v163 & 0xFE) == 0x12) {
          unsigned int v163 = *(_DWORD *)(**(void **)(v96 + 16) + 8);
        }
        uint64_t v213 = *(void *)(v212 + 504);
        if (v163 < 0x100) {
          goto LABEL_338;
        }
        unsigned int v214 = v163 >> 8;
        unint64_t v215 = *(unsigned int *)(v212 + 512);
        uint64_t v216 = v213;
        if (v215)
        {
          uint64_t v216 = v213;
          unint64_t v217 = v215;
          do
          {
            unint64_t v218 = v217 >> 1;
            uint64_t v219 = v216 + 16 * (v217 >> 1);
            unsigned int v220 = *(_DWORD *)(v219 + 8);
            uint64_t v221 = v219 + 16;
            v217 += ~(v217 >> 1);
            if (v220 < v214) {
              uint64_t v216 = v221;
            }
            else {
              unint64_t v217 = v218;
            }
          }
          while (v217);
        }
        if (v216 == v213 + 16 * v215 || *(_DWORD *)(v216 + 8) != v214) {
LABEL_338:
        }
          uint64_t v216 = v213;
        uint64_t v164 = (uint64_t **)llvm::IntegerType::get(*(llvm::IntegerType **)v96, (llvm::LLVMContext *)*(unsigned int *)(v216 + 12));
        if ((*(_DWORD *)(v96 + 8) & 0xFE) == 0x12)
        {
          uint64_t v222 = (llvm::Type *)*(unsigned int *)(v96 + 32);
          if (*(_DWORD *)(v96 + 8) == 19) {
            llvm::ScalableVectorType::get(v164, v222);
          }
          else {
            llvm::FixedVectorType::get((llvm::FixedVectorType *)v164, v222);
          }
        }
      }
      unint64_t v165 = llvm::ConstantInt::getSigned((llvm::ConstantInt *)v164, -(uint64_t)v141, v156);
      uint64_t v118 = (uint64_t *)v165;
      if (*(void *)v165 != v96)
      {
        int v166 = (llvm::ConstantExpr *)llvm::CastInst::getCastOpcode(v165, 0, v96, 0);
        Cast = llvm::ConstantExpr::getCast(v166, (llvm::ConstantExpr *)v118, (llvm::Constant ***)v96, 0);
        goto LABEL_255;
      }
    }
    if (*(void *)v158)
    {
      **(void **)(v157 - 16) = *(void *)(v157 - 24);
      uint64_t v169 = *(void *)(v157 - 24);
      if (v169) {
        *(void *)(v169 + 16) = *(void *)(v157 - 16);
      }
    }
    *(void *)uint64_t v158 = v118;
    if (v118)
    {
      uint64_t v172 = v118[1];
      uint64_t v171 = v118 + 1;
      uint64_t v170 = v172;
      *(void *)(v157 - 24) = v172;
      if (v172) {
        *(void *)(v170 + 16) = v157 - 24;
      }
      *(void *)(v157 - 16) = v171;
      *uint64_t v171 = v158;
    }
  }
  if (v228 != v230) {
    free(v228);
  }
  return v8;
}

uint64_t sub_1CCE12E28(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = a2;
  uint64_t v7 = 0;
  if (sub_1CCE12E8C((uint64_t *)(a1 + 56), &v6, &v7)) {
    return 1;
  }
  uint64_t v5 = a2;
  uint64_t v7 = 0;
  return sub_1CCE12E8C((uint64_t *)(a1 + 80), &v5, &v7);
}

uint64_t sub_1CCE12E8C(uint64_t *a1, void *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    int v5 = v3 - 1;
    unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
    uint64_t v7 = (void *)(*a1 + 8 * v6);
    uint64_t v8 = *v7;
    if (*a2 == *v7)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v9 = 0;
      int v10 = 1;
      uint64_t result = 1;
      while (v8 != -4096)
      {
        if (v9) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v8 == -8192;
        }
        if (v12) {
          uint64_t v9 = v7;
        }
        unsigned int v13 = v6 + v10++;
        unsigned int v6 = v13 & v5;
        uint64_t v7 = (void *)(v4 + 8 * (v13 & v5));
        uint64_t v8 = *v7;
        if (*a2 == *v7) {
          goto LABEL_9;
        }
      }
      uint64_t result = 0;
      if (v9) {
        uint64_t v7 = v9;
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t result = 0;
  }
LABEL_9:
  *a3 = v7;
  return result;
}

uint64_t sub_1CCE12F28(uint64_t a1, llvm::ValueAsMetadata *this)
{
  unsigned int v4 = *(_DWORD *)(a1 + 8);
  if (v4 >= *(_DWORD *)(a1 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)a1 + 8 * v4) = 4101;
  int v5 = *(void **)(a1 + 64);
  ++*(_DWORD *)(a1 + 8);
  uint64_t v6 = *(unsigned int *)(a1 + 72);
  uint64_t result = llvm::ValueAsMetadata::get(this, this);
  if (v6)
  {
    uint64_t v9 = 8 * v6;
    int v10 = &v5[v6];
    while (*v5 != result)
    {
      ++v5;
      v9 -= 8;
      if (!v9)
      {
        int v5 = v10;
        break;
      }
    }
  }
  uint64_t v11 = *(void *)(a1 + 64);
  uint64_t v12 = *(unsigned int *)(a1 + 72);
  if (v5 == (void *)(v11 + 8 * v12))
  {
    uint64_t result = llvm::ValueAsMetadata::get(this, v8);
    unsigned int v13 = *(_DWORD *)(a1 + 72);
    if (v13 >= *(_DWORD *)(a1 + 76)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 64) + 8 * v13) = result;
    ++*(_DWORD *)(a1 + 72);
  }
  else
  {
    uint64_t v12 = ((uint64_t)v5 - v11) >> 3;
  }
  unsigned int v14 = *(_DWORD *)(a1 + 8);
  if (v14 >= *(_DWORD *)(a1 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)a1 + 8 * v14) = v12;
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1CCE13080(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  if (!a2 || *(_WORD *)(a2 + 24)) {
    return v2;
  }
  uint64_t v3 = *(void *)(a2 + 32);
  unsigned int v4 = (llvm::APInt *)(v3 + 24);
  uint64_t v5 = *(unsigned int *)(v3 + 32);
  unsigned int v6 = v5 - 1;
  if (v5 > 0x40)
  {
    uint64_t v18 = a1;
    int v19 = v5;
    unint64_t v20 = *(void *)v4;
    if ((*(void *)(*(void *)v4 + 8 * (v6 >> 6)) >> v6))
    {
      BOOL v15 = __CFADD__(v5 - llvm::APInt::countLeadingOnesSlowCase(v4) - 64, 65);
      a1 = v18;
      unint64_t v7 = v20;
      if (!v15) {
        return 0;
      }
      goto LABEL_22;
    }
    int v10 = 0;
    int64_t v11 = (unint64_t)(v5 + 63) >> 6;
    do
    {
      if (v11-- < 1) {
        break;
      }
      unint64_t v13 = *(void *)(v20 + 8 * v11);
      v10 += __clz(v13);
    }
    while (!v13);
    LODWORD(v5) = v19;
    unsigned int v14 = v19 | 0xFFFFFFC0;
    if ((v19 & 0x3F) == 0) {
      unsigned int v14 = 0;
    }
    int v8 = v10 + v14;
    unint64_t v7 = v20;
  }
  else
  {
    unint64_t v7 = *(void *)v4;
    if ((v7 >> v6))
    {
      if (v5) {
        int v8 = __clz(~(v7 << -(char)v5));
      }
      else {
        int v8 = 0;
      }
    }
    else
    {
      int v8 = v5 + __clz(v7) - 64;
    }
  }
  if ((v5 - v8 - 64) < 0xFFFFFFBF) {
    return 0;
  }
  if (v5 <= 0x40)
  {
    uint64_t v9 = (uint64_t)(v7 << -(char)v5) >> -(char)v5;
    goto LABEL_23;
  }
LABEL_22:
  uint64_t v9 = *(void *)v7;
LABEL_23:
  uint64_t v2 = 0;
  switch(a1)
  {
    case 27:
    case 30:
      BOOL v16 = v9 == 1;
      goto LABEL_26;
    case 28:
    case 34:
      BOOL v16 = v9 == 0;
LABEL_26:
      uint64_t v2 = v16;
      break;
    default:
      return v2;
  }
  return v2;
}

uint64_t sub_1CCE1321C(uint64_t a1, uint64_t a2)
{
  v31[3] = *MEMORY[0x1E4F143B8];
  unsigned int v4 = *(unsigned __int16 *)(a2 + 24);
  if (a2 && !*(_WORD *)(a2 + 24))
  {
    uint64_t v5 = *(void *)(a2 + 32);
    unsigned int v6 = (llvm::APInt *)(v5 + 24);
    uint64_t v7 = *(unsigned int *)(v5 + 32);
    unsigned int v8 = v7 - 1;
    if (v7 > 0x40)
    {
      if ((*(void *)(*(void *)v6 + 8 * (v8 >> 6)) >> v8))
      {
        int v10 = llvm::APInt::countLeadingOnesSlowCase(v6);
      }
      else
      {
        int v26 = 0;
        int64_t v27 = (unint64_t)(v7 + 63) >> 6;
        do
        {
          if (v27-- < 1) {
            break;
          }
          unint64_t v29 = *(void *)(*(void *)v6 + 8 * v27);
          v26 += __clz(v29);
        }
        while (!v29);
        int v30 = v7 | 0xFFFFFFC0;
        if ((v7 & 0x3F) == 0) {
          int v30 = 0;
        }
        int v10 = v26 + v30;
      }
    }
    else
    {
      unint64_t v9 = *(void *)v6;
      if ((*(void *)v6 >> v8))
      {
        if (v7) {
          int v10 = __clz(~(v9 << -(char)v7));
        }
        else {
          int v10 = 0;
        }
      }
      else
      {
        int v10 = v7 + __clz(v9) - 64;
      }
    }
    if ((v7 - v10 + 1) <= 0x40)
    {
      unsigned int v11 = *(_DWORD *)(a1 + 8);
      if (v11 >= *(_DWORD *)(a1 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a1 + 8 * v11) = 17;
      unsigned int v12 = *(_DWORD *)(a1 + 8) + 1;
      *(_DWORD *)(a1 + 8) = v12;
      uint64_t v13 = *(void *)(a2 + 32);
      unsigned int v14 = *(_DWORD *)(v13 + 32);
      if (v14 > 0x40) {
        uint64_t v15 = **(void **)(v13 + 24);
      }
      else {
        uint64_t v15 = (uint64_t)(*(void *)(v13 + 24) << -(char)v14) >> -(char)v14;
      }
      if (v12 >= *(_DWORD *)(a1 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a1 + 8 * v12) = v15;
      ++*(_DWORD *)(a1 + 8);
      return 1;
    }
    return 0;
  }
  if (a2 && v4 == 14)
  {
    BOOL v16 = *(llvm::ValueAsMetadata **)(a2 - 8);
    if (v16)
    {
      sub_1CCE12F28(a1, v16);
      return 1;
    }
    return 0;
  }
  if (a2 && v4 == 5)
  {
    uint64_t v18 = 30;
  }
  else
  {
    if (a2 && v4 == 6)
    {
      int v20 = sub_1CCE1321C(a1, *(void *)(a2 + 32));
      uint64_t v17 = v20 & sub_1CCE1321C(a1, *(void *)(a2 + 40));
      unsigned int v21 = *(_DWORD *)(a1 + 8);
      if (v21 >= *(_DWORD *)(a1 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a1 + 8 * v21) = 27;
      ++*(_DWORD *)(a1 + 8);
      return v17;
    }
    if (v4 <= 0xD && ((1 << v4) & 0x200E) != 0)
    {
      unint64_t v22 = (unint64_t)*(unsigned int *)(*(void *)(a2 + 40) + 8) >> 8;
      uint64_t v17 = sub_1CCE1321C(a1, *(void *)(a2 + 32));
      uint64_t v23 = 0;
      v31[0] = 4097;
      v31[1] = v22;
      uint64_t v24 = 7;
      if (v4 == 3) {
        uint64_t v24 = 5;
      }
      v31[2] = v24;
      unsigned int v25 = *(_DWORD *)(a1 + 8);
      do
      {
        if (v25 >= *(_DWORD *)(a1 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a1 + 8 * v25) = v31[v23];
        unsigned int v25 = *(_DWORD *)(a1 + 8) + 1;
        *(_DWORD *)(a1 + 8) = v25;
        ++v23;
      }
      while (v23 != 3);
      return v17;
    }
    uint64_t v17 = 0;
    if (!a2 || v4 != 4) {
      return v17;
    }
    uint64_t v18 = 34;
  }

  return sub_1CCE135D0(a1, a2, v18);
}

uint64_t sub_1CCE135D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 40);
  if (!v3) {
    return 1;
  }
  uint64_t v6 = 0;
  uint64_t v7 = *(void *)(a2 + 32);
  uint64_t v8 = 8 * v3;
  LODWORD(v9) = 1;
  do
  {
    int v10 = sub_1CCE1321C(a1, *(void *)(v7 + 8 * v6));
    if (v6)
    {
      unint64_t v11 = *(unsigned int *)(a1 + 8);
      if (v11 >= *(unsigned int *)(a1 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a1 + 8 * v11) = a3;
      ++*(_DWORD *)(a1 + 8);
    }
    uint64_t v9 = v9 & v10;
    ++v6;
    v8 -= 8;
  }
  while (v8);
  return v9;
}

void sub_1CCE13694()
{
}

void sub_1CCE136D4(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCE1370C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2 + 112;
  sub_1CB843600(a2, a2 + 112, (uint64_t)&unk_1EA61F34C);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600(a2, v3, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&unk_1EA61F34C);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, v3, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::ScalarEvolutionWrapperPass::ID);
  sub_1CB843600(a2, v3, (uint64_t)llvm::ScalarEvolutionWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::AssumptionCacheTracker::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetLibraryInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&unk_1EA61F34C);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::IVUsersWrapperPass::ID);
  sub_1CB843600(a2, v3, (uint64_t)&llvm::IVUsersWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);

  sub_1CB843600(a2, v3, (uint64_t)&llvm::MemorySSAWrapperPass::ID);
}

uint64_t sub_1CCE1386C(llvm::LoopPass *a1, const llvm::Loop *a2)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  if ((llvm::LoopPass::skipLoop(a1, a2) & 1) == 0)
  {
    uint64_t v5 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v6 = *v5;
    uint64_t v7 = v5[1];
    if (v6 == v7)
    {
LABEL_6:
      uint64_t v8 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v6 != &llvm::IVUsersWrapperPass::ID)
      {
        v6 += 16;
        if (v6 == v7) {
          goto LABEL_6;
        }
      }
      uint64_t v8 = *(void *)(v6 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v8 + 96))(v8, &llvm::IVUsersWrapperPass::ID);
    uint64_t v9 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v10 = *v9;
    uint64_t v11 = v9[1];
    if (v10 == v11)
    {
LABEL_11:
      uint64_t v12 = 0;
    }
    else
    {
      while (*(char **)v10 != llvm::ScalarEvolutionWrapperPass::ID)
      {
        v10 += 16;
        if (v10 == v11) {
          goto LABEL_11;
        }
      }
      uint64_t v12 = *(void *)(v10 + 8);
    }
    (*(void (**)(uint64_t, char *))(*(void *)v12 + 96))(v12, llvm::ScalarEvolutionWrapperPass::ID);
    uint64_t v13 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v14 = *v13;
    uint64_t v15 = v13[1];
    if (v14 == v15)
    {
LABEL_16:
      uint64_t v16 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v14 != &llvm::DominatorTreeWrapperPass::ID)
      {
        v14 += 16;
        if (v14 == v15) {
          goto LABEL_16;
        }
      }
      uint64_t v16 = *(void *)(v14 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v16 + 96))(v16, &llvm::DominatorTreeWrapperPass::ID);
    uint64_t v17 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v18 = *v17;
    uint64_t v19 = v17[1];
    if (v18 == v19)
    {
LABEL_21:
      uint64_t v20 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v18 != &llvm::LoopInfoWrapperPass::ID)
      {
        v18 += 16;
        if (v18 == v19) {
          goto LABEL_21;
        }
      }
      uint64_t v20 = *(void *)(v18 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v20 + 96))(v20, &llvm::LoopInfoWrapperPass::ID);
    unsigned int v21 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v22 = *v21;
    uint64_t v23 = v21[1];
    if (v22 == v23)
    {
LABEL_26:
      uint64_t v24 = 0;
    }
    else
    {
      while (*(char **)v22 != llvm::TargetTransformInfoWrapperPass::ID)
      {
        v22 += 16;
        if (v22 == v23) {
          goto LABEL_26;
        }
      }
      uint64_t v24 = *(void *)(v22 + 8);
    }
    unsigned int v25 = (llvm::TargetTransformInfoWrapperPass *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v24 + 96))(v24, llvm::TargetTransformInfoWrapperPass::ID);
    llvm::TargetTransformInfoWrapperPass::getTTI(v25, *(const Function **)(**((void **)a2 + 4) + 56));
    int v26 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v27 = *v26;
    uint64_t v28 = v26[1];
    if (v27 == v28)
    {
LABEL_31:
      uint64_t v29 = 0;
    }
    else
    {
      while (*(char **)v27 != llvm::AssumptionCacheTracker::ID)
      {
        v27 += 16;
        if (v27 == v28) {
          goto LABEL_31;
        }
      }
      uint64_t v29 = *(void *)(v27 + 8);
    }
    int v30 = (llvm::AssumptionCacheTracker *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v29 + 96))(v29, llvm::AssumptionCacheTracker::ID);
    llvm::AssumptionCacheTracker::getAssumptionCache(v30, *(llvm::Function **)(**((void **)a2 + 4) + 56));
    int v31 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v32 = *v31;
    uint64_t v33 = v31[1];
    if (v32 == v33)
    {
LABEL_36:
      uint64_t v34 = 0;
    }
    else
    {
      while (*(char **)v32 != llvm::TargetLibraryInfoWrapperPass::ID)
      {
        v32 += 16;
        if (v32 == v33) {
          goto LABEL_36;
        }
      }
      uint64_t v34 = *(void *)(v32 + 8);
    }
    uint64_t v35 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v34 + 96))(v34, llvm::TargetLibraryInfoWrapperPass::ID);
    uint64_t v36 = v35 + 32;
    if (!*(unsigned char *)(v35 + 232))
    {
      uint64_t v37 = *(void *)(*(void *)(**((void **)a2 + 4) + 56) + 40) + 216;
      __int16 v40 = 260;
      v39[0] = v37;
      llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v39);
      uint64_t v50 = 0;
      uint64_t v51 = 0;
      int v52 = 0;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      *(void *)&long long v38 = -1;
      *((void *)&v38 + 1) = -1;
      *(_OWORD *)__src = v38;
      long long v44 = v38;
      long long v45 = v38;
      long long v46 = v38;
      long long v47 = v38;
      long long v48 = v38;
      *(_OWORD *)uint64_t v49 = v38;
      *(void *)&v49[13] = -1;
      sub_1CC153974((uint64_t)__src, (int *)__p);
      sub_1CD4D04B8(v36, (uint64_t)__src);
      sub_1CD4CFA4C((uint64_t *)__src);
      if (v42 < 0) {
        operator delete(__p[0]);
      }
    }
    sub_1CC1569E8(__src, v36);
  }
  return 0;
}

uint64_t sub_1CCE13F28()
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  LODWORD(v3) = 1;
  LOBYTE(v4) = 1;
  *(void *)&long long v1 = &v4;
  v5.n128_u64[0] = (unint64_t)"Enable LSR phi elimination";
  v5.n128_u64[1] = 26;
  sub_1CC025F34((llvm::cl::Option *)&unk_1EBCF50A8, "enable-lsr-phielim", &v3, (unsigned char **)&v1, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF50A8, &dword_1CB82C000);
  LODWORD(v3) = 1;
  LOBYTE(v4) = 1;
  *(void *)&long long v1 = &v4;
  v5.n128_u64[0] = (unint64_t)"Add instruction count to a LSR cost model";
  v5.n128_u64[1] = 41;
  sub_1CC025F34((llvm::cl::Option *)&unk_1EBCF5168, "lsr-insns-cost", &v3, (unsigned char **)&v1, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF5168, &dword_1CB82C000);
  LODWORD(v3) = 1;
  LOBYTE(v4) = 0;
  *(void *)&long long v1 = &v4;
  v5.n128_u64[0] = (unint64_t)"Narrow LSR complex solution using expectation of registers number";
  v5.n128_u64[1] = 65;
  sub_1CC025F34((llvm::cl::Option *)&unk_1EBCF5228, "lsr-exp-narrow", &v3, (unsigned char **)&v1, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF5228, &dword_1CB82C000);
  LODWORD(v3) = 1;
  LOBYTE(v4) = 1;
  *(void *)&long long v1 = &v4;
  v5.n128_u64[0] = (unint64_t)"Narrow LSR search space by filtering non-optimal formulae with the same ScaledReg and Scale";
  v5.n128_u64[1] = 91;
  sub_1CC025F34((llvm::cl::Option *)&unk_1EBCF52E8, "lsr-filter-same-scaled-reg", &v3, (unsigned char **)&v1, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF52E8, &dword_1CB82C000);
  int v4 = 1;
  int v2 = 2;
  uint64_t v3 = &v2;
  *(void *)&long long v1 = "A flag that overrides the target's preferred addressing mode.";
  *((void *)&v1 + 1) = 61;
  v5.n128_u64[0] = (unint64_t)v6;
  v6[0] = "none";
  v6[1] = 4;
  int v7 = 2;
  uint64_t v8 = "Don't prefer any addressing mode";
  uint64_t v9 = 32;
  uint64_t v10 = "preindexed";
  uint64_t v11 = 10;
  int v12 = 0;
  uint64_t v13 = "Prefer pre-indexed addressing mode";
  uint64_t v14 = 34;
  uint64_t v15 = "postindexed";
  uint64_t v16 = 11;
  int v17 = 1;
  uint64_t v18 = "Prefer post-indexed addressing mode";
  uint64_t v19 = 35;
  v5.n128_u64[1] = 0x400000003;
  sub_1CD7756D8(&v4, &v3, &v1, (uint64_t)&v5);
  if ((void *)v5.n128_u64[0] != v6) {
    free((void *)v5.n128_u64[0]);
  }
  __cxa_atexit((void (*)(void *))sub_1CD773A64, &qword_1EBCF5528, &dword_1CB82C000);
  LODWORD(v3) = 1;
  LOWORD(v4) = -1;
  *(void *)&long long v1 = &v4;
  v5.n128_u64[0] = (unint64_t)"LSR search space complexity limit";
  v5.n128_u64[1] = 33;
  sub_1CD775BC8(&v3, (unsigned __int16 **)&v1, (long long *)&v5);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCF53A8, &dword_1CB82C000);
  LODWORD(v3) = 1;
  int v4 = 7;
  *(void *)&long long v1 = &v4;
  v5.n128_u64[0] = (unint64_t)"The limit on recursion depth for LSRs setup cost";
  v5.n128_u64[1] = 48;
  sub_1CD45A86C((uint64_t)&unk_1EBCF5468, "lsr-setupcost-depth-limit", &v3, (int **)&v1, &v5);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF5468, &dword_1CB82C000);
}

uint64_t llvm::gatherUnrollingPreferences@<X0>(llvm *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X5>, int a5@<W6>, uint64_t a6@<X7>, uint64_t a7@<X8>, uint64_t a8, __int16 a9, int a10, __int16 a11, int a12, __int16 a13, uint64_t a14)
{
  int v17 = &unk_1EBCF6410;
  if (a5 <= 2) {
    int v17 = &unk_1EBCF64D0;
  }
  *(_DWORD *)a7 = *v17;
  *(_DWORD *)(a7 + 4) = 400;
  int v18 = dword_1EBCF58D0;
  *(_DWORD *)(a7 + 8) = dword_1EBCF58D0;
  *(_DWORD *)(a7 + 12) = 150;
  *(_DWORD *)(a7 + 16) = v18;
  *(_OWORD *)(a7 + 20) = xmmword_1CFB2D090;
  *(_DWORD *)(a7 + 36) = 2;
  *(_WORD *)(a7 + 40) = 0;
  *(unsigned char *)(a7 + 42) = 1;
  *(_DWORD *)(a7 + 43) = 0;
  *(unsigned char *)(a7 + 47) = 0;
  int v19 = dword_1EBCF5B10;
  *(_DWORD *)(a7 + 48) = 60;
  *(_DWORD *)(a7 + 52) = v19;
  uint64_t result = (*(uint64_t (**)(void, llvm *, uint64_t, uint64_t, uint64_t))(*(void *)*a3 + 184))(*a3, a1, a2, a7, a4);
  uint64_t v22 = *(void *)(*(void *)(**((void **)a1 + 4) + 56) + 112);
  if (!v22 || (*(unsigned char *)(v22 + 17) & 4) == 0 && (*(char *)(v22 + 13) & 0x80000000) == 0) {
    llvm::hasUnrollTransformation(a1, v21);
  }
  int v23 = *(_DWORD *)(a7 + 8);
  *(_DWORD *)(a7 + 12) = *(_DWORD *)(a7 + 16);
  *(_DWORD *)a7 = v23;
  *(_DWORD *)(a7 + 4) = 100;
  if (word_1EBCF5798) {
    *(_DWORD *)a7 = dword_1EBCF5810;
  }
  if (word_1EBCF5918) {
    *(_DWORD *)(a7 + 12) = dword_1EBCF5990;
  }
  if (word_1EBCF59D8) {
    *(_DWORD *)(a7 + 4) = dword_1EBCF5A50;
  }
  if (word_1EBCF5C18) {
    *(_DWORD *)(a7 + 28) = dword_1EBCF5C90;
  }
  if (word_1EBCF5CD8) {
    *(_DWORD *)(a7 + 32) = dword_1EBCF5D50;
  }
  if (word_1EBCF5D98) {
    *(unsigned char *)(a7 + 40) = byte_1EBCF5E10;
  }
  if (word_1EBCF5E58) {
    *(unsigned char *)(a7 + 42) = byte_1EBCF5ED0;
  }
  if (word_1EBCF5F18) {
    *(unsigned char *)(a7 + 41) = byte_1EBCF5F90;
  }
  if (!dword_1EBCF6050) {
    *(unsigned char *)(a7 + 45) = 0;
  }
  if (word_1EBCF6218) {
    *(unsigned char *)(a7 + 46) = byte_1EBCF6290;
  }
  if (word_1EBCF5A98) {
    *(_DWORD *)(a7 + 52) = dword_1EBCF5B10;
  }
  if ((a6 & 0xFF00000000) != 0)
  {
    *(_DWORD *)a7 = a6;
    *(_DWORD *)(a7 + 12) = a6;
  }
  if ((a8 & 0xFF00000000) != 0) {
    *(_DWORD *)(a7 + 20) = a8;
  }
  if ((a9 & 0xFF00) != 0) {
    *(unsigned char *)(a7 + 40) = a9;
  }
  if ((a11 & 0xFF00) != 0) {
    *(unsigned char *)(a7 + 41) = a11;
  }
  if ((a13 & 0xFF00) != 0) {
    *(unsigned char *)(a7 + 45) = a13;
  }
  if ((a14 & 0xFF00000000) != 0) {
    *(_DWORD *)(a7 + 32) = a14;
  }
  return result;
}

uint64_t llvm::ApproximateLoopSize(uint64_t a1, _DWORD *a2, unsigned char *a3, unsigned char *a4, void *a5, uint64_t *a6, int a7)
{
  char v24 = 0;
  int v23 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t v25 = 0;
  int v28 = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v11 = *(llvm::BasicBlock ***)(a1 + 32);
  uint64_t v12 = *(void *)(a1 + 40) - (void)v11;
  if (v12)
  {
    uint64_t v15 = 8 * (v12 >> 3);
    do
    {
      uint64_t v16 = *v11++;
      llvm::CodeMetrics::analyzeBasicBlock((uint64_t)&v23, v16, a5, a6, 0);
      v15 -= 8;
    }
    while (v15);
    LODWORD(v12) = HIDWORD(v29);
    char v17 = BYTE2(v23);
    char v18 = HIBYTE(v23);
    unsigned int v19 = v25;
    uint64_t v20 = v26;
  }
  else
  {
    uint64_t v20 = 0;
    char v17 = 0;
    char v18 = 0;
    unsigned int v19 = 0;
  }
  *a2 = v12;
  *a3 = v17;
  *a4 = v18;
  if (v19 <= a7 + 1) {
    uint64_t v21 = (a7 + 1);
  }
  else {
    uint64_t v21 = v19;
  }
  MEMORY[0x1D25D9CD0](v20, 8);
  return v21;
}

void llvm::computeUnrollCount(llvm::Loop *a1)
{
}

void sub_1CCE159BC(llvm::Loop *a1)
{
}

uint64_t sub_1CCE15A14(uint64_t a1, unsigned int *a2, llvm::ConstantInt ****a3, uint64_t *a4, unsigned int a5, int a6, unsigned int *a7)
{
  v275[4] = *MEMORY[0x1E4F143B8];
  if (a7[8] < a5) {
    goto LABEL_393;
  }
  unsigned int v8 = a5;
  unint64_t v9 = *a7;
  if (a7[9] + a7[5] * (unint64_t)(a6 - a7[9]) < v9) {
    goto LABEL_3;
  }
  unsigned int v12 = a7[1];
  unsigned int v13 = a7[13];
  uint64_t v253 = a1;
  if (*(void *)(a1 + 8) != *(void *)(a1 + 16)) {
    goto LABEL_393;
  }
  int v231 = a5 - 1;
  if (a5 - 1 >= v13) {
    goto LABEL_393;
  }
  unsigned int v16 = v12 * v9 / 0x64;
  uint64_t v268 = 1;
  uint64_t v17 = 8;
  int64x2_t v18 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  do
  {
    *(int64x2_t *)((char *)&v268 + v17) = v18;
    v17 += 16;
  }
  while (v17 != 136);
  uint64_t v271 = v273;
  uint64_t v272 = 0x1000000000;
  uint64_t v263 = 1;
  memset_pattern16(v264, &unk_1CFAC3070, 0x40uLL);
  unsigned int v265 = v267;
  uint64_t v266 = 0x400000000;
  v251[0] = 0;
  v251[1] = 0;
  int v252 = 0;
  int v260 = v262;
  uint64_t v261 = 0x400000000;
  int64_t v249 = 0;
  int v250 = 0;
  int v246 = 0;
  uint64_t v247 = 0;
  unsigned int v248 = 0;
  v258[0] = v259;
  v258[1] = (void *)0x1000000000;
  v256[0] = v257;
  v256[1] = (void *)0x400000000;
  v245[0] = (unsigned int *)v258;
  v245[1] = (unsigned int *)&v246;
  v245[2] = (unsigned int *)&v253;
  v245[3] = (unsigned int *)v256;
  v245[4] = (unsigned int *)&v249;
  v245[5] = a2;
  if (!v8)
  {
    int64_t v196 = 0;
    int v197 = v249;
    BOOL v198 = v250 == 0;
LABEL_369:
    char v195 = 0;
    if (!v198) {
      int v197 = 0;
    }
    unint64_t v194 = v197 & 0xFFFFFF00 | (unint64_t)v196;
    int v193 = v197;
    goto LABEL_372;
  }
  uint64_t v230 = a3;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  int64_t v238 = 0;
  int64_t v232 = v16;
  while (1)
  {
    uint64_t v21 = **(void **)(v253 + 32);
    uint64_t v22 = *(void *)(v21 + 48);
    if (v22 != v21 + 40 && v22 && *(unsigned char *)(v22 - 8) == 83)
    {
      if (v19) {
        llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopLatch();
      }
      llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopPredecessor();
    }
    sub_1CC6FE80C(v251);
    while (1)
    {
      unsigned int v24 = v261;
      if (!v261) {
        break;
      }
      LODWORD(v261) = v261 - 1;
      long long v274 = *((_OWORD *)v260 + v24 - 1);
      sub_1CC27B388((uint64_t)v251, &v274, (void *)&v274 + 1, (uint64_t)v239);
    }
    v239[0] = 0;
    v239[1] = 0;
    int v240 = 0;
    int v242 = v251;
    int v243 = v230;
    uint64_t v244 = v253;
    DWORD2(v274) = 64;
    uint64_t v234 = v19;
    *(void *)&long long v274 = v19;
    uint64_t v25 = (llvm::ConstantInt *)llvm::ConstantInt::get(***v230, (llvm::LLVMContext *)&v274, v23);
    unint64_t Constant = llvm::ScalarEvolution::getConstant((llvm::ScalarEvolution *)v230, v25);
    uint64_t v26 = v20;
    if (DWORD2(v274) >= 0x41 && (void)v274) {
      MEMORY[0x1D25D9CB0](v274, 0x1000C8000313F17);
    }
    LOBYTE(v27) = v268;
    if (v268 > 1 || HIDWORD(v268))
    {
      int v28 = &v271;
      uint64_t v29 = (void **)&v269;
      if (v268) {
        goto LABEL_23;
      }
      unsigned int v27 = v270;
      if (((2 * v268) & 0xFFFFFFFC) >= v270 || v270 < 0x41)
      {
        if (v270)
        {
          uint64_t v29 = v269;
          int v28 = &v269[v270];
          do
LABEL_23:
            *v29++ = (void *)-4096;
          while (v29 != v28);
          unsigned int v27 = v268 & 1;
        }
        uint64_t v268 = v27;
        goto LABEL_26;
      }
      sub_1CD7765C8(&v268);
      LOBYTE(v27) = v268;
    }
LABEL_26:
    LODWORD(v272) = 0;
    uint64_t v30 = **(void **)(v253 + 32);
    *(void *)&long long v274 = v30;
    if (v27)
    {
      int v31 = 16;
      uint64_t v32 = &v269;
    }
    else
    {
      int v31 = v270;
      if (!v270)
      {
        unint64_t v41 = 0;
        goto LABEL_43;
      }
      uint64_t v32 = v269;
    }
    int v33 = v31 - 1;
    unsigned int v34 = v33 & ((v30 >> 4) ^ (v30 >> 9));
    uint64_t v35 = &v32[v34];
    uint64_t v36 = *v35;
    if (v30 != *v35) {
      break;
    }
LABEL_46:
    BOOL v44 = v249 < v238;
    if (v250 != v26) {
      BOOL v44 = v250 < (int)v26;
    }
    if (v44)
    {
      MEMORY[0x1D25D9CD0](v239[0], 8);
    }
    else
    {
      if (v250 == v26) {
        BOOL v45 = v238 < v249;
      }
      else {
        BOOL v45 = (int)v26 < v250;
      }
      MEMORY[0x1D25D9CD0](v239[0], 8);
      if (!v45) {
        goto LABEL_367;
      }
    }
    uint64_t v20 = v26;
    uint64_t v19 = v234 + 1;
    if (v234 + 1 == v8)
    {
      unsigned int v202 = v266;
      while (v202)
      {
        unsigned int v203 = (char *)v265 + 16 * v202;
        uint64_t v204 = *((void *)v203 - 2);
        uint64_t v205 = *((void *)v203 - 1);
        v239[0] = 0;
        if (sub_1CCE18AF0((uint64_t)&v263, v204, v205, v239))
        {
          uint64_t v206 = v239[0];
          *(void *)v239[0] = -8192;
          *(void *)(v206 + 8) = -8192;
          LODWORD(v263) = v263 - 2;
          ++HIDWORD(v263);
        }
        unsigned int v202 = v266 - 1;
        LODWORD(v266) = v266 - 1;
        uint64_t v207 = v205 + 40;
        uint64_t v208 = *(void *)(v205 + 48);
        if (v208 != v207)
        {
          do
          {
            if (v208) {
              uint64_t v209 = v208 - 24;
            }
            else {
              uint64_t v209 = 0;
            }
            if (!v208 || *(unsigned char *)(v209 + 16) != 83) {
              break;
            }
            uint64_t v210 = sub_1CBF73380(v209, v204);
            if (v210)
            {
              uint64_t v211 = v210;
              if (*(unsigned __int8 *)(v210 + 16) >= 0x1Cu)
              {
                uint64_t v212 = *(void *)(v210 + 40);
                uint64_t v214 = *(void *)(v253 + 56);
                uint64_t v213 = *(void *)(v253 + 64);
                if (v213 == v214)
                {
                  uint64_t v215 = *(unsigned int *)(v253 + 76);
                  uint64_t v216 = (void *)(v213 + 8 * v215);
                  if (v215)
                  {
                    uint64_t v217 = 0;
                    uint64_t v218 = 8 * v215;
                    while (*(void *)(v213 + v217) != v212)
                    {
                      v217 += 8;
                      if (v218 == v217) {
                        goto LABEL_424;
                      }
                    }
                    uint64_t v216 = (void *)(v213 + v217);
                  }
LABEL_424:
                  uint64_t v214 = *(void *)(v253 + 64);
                }
                else
                {
                  uint64_t v219 = *(unsigned int *)(v253 + 72);
                  int v220 = v219 - 1;
                  unsigned int v221 = (v219 - 1) & ((v212 >> 4) ^ (v212 >> 9));
                  uint64_t v216 = (void *)(v213 + 8 * v221);
                  uint64_t v222 = *v216;
                  if (*v216 == -1)
                  {
                    uint64_t v223 = 0;
LABEL_433:
                    if (v223) {
                      uint64_t v216 = v223;
                    }
                    if (*v216 != v212) {
                      uint64_t v216 = (void *)(v213 + 8 * v219);
                    }
                  }
                  else
                  {
                    uint64_t v223 = 0;
                    int v224 = 1;
                    while (v222 != v212)
                    {
                      if (v223) {
                        BOOL v225 = 0;
                      }
                      else {
                        BOOL v225 = v222 == -2;
                      }
                      if (v225) {
                        uint64_t v223 = v216;
                      }
                      unsigned int v226 = v221 + v224++;
                      unsigned int v221 = v226 & v220;
                      uint64_t v216 = (void *)(v213 + 8 * (v226 & v220));
                      uint64_t v222 = *v216;
                      if (*v216 == -1) {
                        goto LABEL_433;
                      }
                    }
                  }
                }
                if (v213 == v214) {
                  uint64_t v227 = 76;
                }
                else {
                  uint64_t v227 = 72;
                }
                if (v216 != (void *)(v213 + 8 * *(unsigned int *)(v253 + v227))) {
                  sub_1CCE182EC(v245, v211, v231);
                }
              }
            }
            uint64_t v208 = *(void *)(v208 + 8);
          }
          while (v208 != v207);
          unsigned int v202 = v266;
        }
      }
      int v197 = v249;
      BOOL v198 = v250 == 0;
      if (v20) {
        int64_t v196 = 0;
      }
      else {
        int64_t v196 = v238 << 32;
      }
      goto LABEL_369;
    }
  }
  uint64_t v37 = 0;
  int v38 = 1;
  while (v36 != -4096)
  {
    if (v37) {
      BOOL v39 = 0;
    }
    else {
      BOOL v39 = v36 == -8192;
    }
    if (v39) {
      uint64_t v37 = v35;
    }
    unsigned int v40 = v34 + v38++;
    unsigned int v34 = v40 & v33;
    uint64_t v35 = &v32[v34];
    uint64_t v36 = *v35;
    if (v30 == *v35) {
      goto LABEL_46;
    }
  }
  if (v37) {
    unint64_t v41 = v37;
  }
  else {
    unint64_t v41 = v35;
  }
LABEL_43:
  char v42 = sub_1CCD11EEC((uint64_t)&v268, (uint64_t)&v274, &v274, v41);
  void *v42 = v274;
  if (v272 >= (unint64_t)HIDWORD(v272)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((void *)v271 + v272) = v274;
  BOOL v43 = __CFADD__(v272, 1);
  LODWORD(v272) = v272 + 1;
  if (v43) {
    goto LABEL_46;
  }
  unsigned int v46 = 0;
  unsigned int v235 = v234 & 0x3FFFFFFF;
  while (2)
  {
    unsigned int v233 = v46;
    uint64_t v47 = *((void *)v271 + v46);
    long long v48 = (void *)(v47 + 40);
    uint64_t v237 = v47;
    uint64_t v49 = *(void **)(v47 + 48);
LABEL_57:
    if (v49 == v48)
    {
      uint64_t v104 = *v48 - 24;
      BOOL v105 = *v48 == 0;
      if (*v48) {
        uint64_t v106 = *v48 - 24;
      }
      else {
        uint64_t v106 = 0;
      }
      unsigned int v107 = *(unsigned __int8 *)(v106 + 16) - 40;
      if (v107 >= 0xFFFFFFF5) {
        uint64_t v108 = v106;
      }
      else {
        uint64_t v108 = 0;
      }
      uint64_t v254 = 0;
      int v109 = *(unsigned __int8 *)(v108 + 16);
      if (v107 < 0xFFFFFFF5) {
        BOOL v105 = 1;
      }
      if (v109 != 30 || v105)
      {
        char v114 = v109 != 31 || v105;
        if ((v114 & 1) == 0)
        {
          int v115 = *(_DWORD *)(v108 + 20);
          if ((v115 & 0x40000000) != 0) {
            unsigned int v116 = *(uint64_t **)(v108 - 8);
          }
          else {
            unsigned int v116 = (uint64_t *)(v108 - 32 * (v115 & 0x7FFFFFF));
          }
          uint64_t v117 = *v116;
          *(void *)&long long v274 = *v116;
          uint64_t v255 = 0;
          if (sub_1CBA0E618((uint64_t)v251, &v274, &v255))
          {
            *(void *)&long long v274 = v117;
            uint64_t v255 = 0;
            uint64_t v117 = 0;
            if (sub_1CBA0E618((uint64_t)v251, &v274, &v255)) {
              uint64_t v117 = *(void *)(v255 + 8);
            }
          }
          unsigned int v118 = *(unsigned __int8 *)(v117 + 16);
          if (v117 && v118 <= 0x14)
          {
            if (v118 - 11 <= 1)
            {
              int v135 = *(_DWORD *)(v108 + 20);
              if ((v135 & 0x40000000) != 0) {
                uint64_t v136 = *(void *)(v108 - 8);
              }
              else {
                uint64_t v136 = v108 - 32 * (v135 & 0x7FFFFFF);
              }
              uint64_t v113 = *(void *)(v136 + 32);
              goto LABEL_282;
            }
            if (v118 == 16)
            {
              sub_1CC025540(v108, v117);
              int v138 = *(_DWORD *)(v108 + 20);
              if ((v138 & 0x40000000) != 0) {
                uint64_t v139 = *(void *)(v108 - 8);
              }
              else {
                uint64_t v139 = v108 - 32 * (v138 & 0x7FFFFFF);
              }
              if (v137 == 4294967294) {
                uint64_t v155 = 1;
              }
              else {
                uint64_t v155 = (2 * v137 + 3);
              }
              uint64_t v113 = *(void *)(v139 + 32 * v155);
              goto LABEL_282;
            }
          }
        }
      }
      else if ((*(_DWORD *)(v108 + 20) & 0x7FFFFFF) == 3)
      {
        uint64_t v110 = *(void *)(v108 - 96);
        *(void *)&long long v274 = v110;
        uint64_t v255 = 0;
        if (sub_1CBA0E618((uint64_t)v251, &v274, &v255))
        {
          *(void *)&long long v274 = v110;
          uint64_t v255 = 0;
          uint64_t v110 = 0;
          if (sub_1CBA0E618((uint64_t)v251, &v274, &v255)) {
            uint64_t v110 = *(void *)(v255 + 8);
          }
        }
        unsigned int v111 = *(unsigned __int8 *)(v110 + 16);
        BOOL v112 = !v110 || v111 > 0x14;
        if (!v112)
        {
          if (v111 - 11 <= 1)
          {
            uint64_t v113 = *(void *)(v108 - 32);
            goto LABEL_282;
          }
          if (v111 == 16)
          {
            uint64_t v140 = *(unsigned int *)(v110 + 32);
            if (v140 > 0x40)
            {
              int v156 = 0;
              int64_t v157 = (unint64_t)(v140 + 63) >> 6;
              do
              {
                BOOL v112 = v157-- < 1;
                if (v112) {
                  break;
                }
                unint64_t v158 = *(void *)(*(void *)(v110 + 24) + 8 * v157);
                v156 += __clz(v158);
              }
              while (!v158);
              int v159 = v140 | 0xFFFFFFC0;
              if ((v140 & 0x3F) == 0) {
                int v159 = 0;
              }
              BOOL v141 = v156 + v159 == v140;
            }
            else
            {
              BOOL v141 = *(void *)(v110 + 24) == 0;
            }
            uint64_t v160 = v141;
            uint64_t v113 = *(void *)(v108 + 32 * (v160 << 63 >> 63) - 32);
LABEL_282:
            uint64_t v254 = v113;
            if (!v113) {
              goto LABEL_283;
            }
            goto LABEL_208;
          }
        }
      }
      uint64_t v113 = v254;
      if (!v254)
      {
LABEL_283:
        unsigned int v161 = (void *)*v48;
        if ((void *)*v48 != v48)
        {
          if (v161) {
            int v162 = v161 - 3;
          }
          else {
            int v162 = 0;
          }
          if (*((unsigned char *)v162 + 16) != 30)
          {
            int v192 = 2;
            switch(*((unsigned char *)v162 + 16))
            {
              case 0x1E:
                __break(1u);
                JUMPOUT(0x1CCE1712CLL);
              case 0x1F:
                int v192 = (*((_DWORD *)v162 + 5) >> 1) & 0x3FFFFFF;
                goto LABEL_349;
              case 0x20:
              case 0x26:
                int v192 = (*((_DWORD *)v162 + 5) & 0x7FFFFFF) - 1;
                goto LABEL_349;
              case 0x21:
                goto LABEL_292;
              case 0x24:
                int v192 = *((_WORD *)v162 + 9) & 1;
                goto LABEL_349;
              case 0x25:
                int v192 = 1;
                goto LABEL_292;
              case 0x27:
                int v192 = *((_DWORD *)v162 + 20) + 1;
LABEL_349:
                if (!v192) {
                  goto LABEL_345;
                }
                goto LABEL_292;
              default:
                goto LABEL_345;
            }
          }
          if ((*((_DWORD *)v162 + 5) & 0x7FFFFFF) == 3) {
            int v192 = 2;
          }
          else {
            int v192 = 1;
          }
LABEL_292:
          for (unsigned int i = 0; v192 != i; ++i)
          {
            uint64_t v255 = 0;
            uint64_t Successor = llvm::Instruction::getSuccessor((llvm::Instruction *)v162, i);
            uint64_t v255 = Successor;
            uint64_t v166 = *(void *)(v253 + 56);
            uint64_t v165 = *(void *)(v253 + 64);
            if (v165 == v166)
            {
              uint64_t v167 = *(unsigned int *)(v253 + 76);
              unsigned int v168 = (void *)(v165 + 8 * v167);
              if (v167)
              {
                uint64_t v169 = 0;
                uint64_t v170 = 8 * v167;
                while (*(void *)(v165 + v169) != Successor)
                {
                  v169 += 8;
                  if (v170 == v169) {
                    goto LABEL_311;
                  }
                }
                unsigned int v168 = (void *)(v165 + v169);
              }
LABEL_311:
              uint64_t v166 = *(void *)(v253 + 64);
            }
            else
            {
              uint64_t v171 = *(unsigned int *)(v253 + 72);
              int v172 = v171 - 1;
              unsigned int v173 = (v171 - 1) & ((Successor >> 4) ^ (Successor >> 9));
              unsigned int v168 = (void *)(v165 + 8 * v173);
              uint64_t v174 = *v168;
              if (*v168 == -1)
              {
                uint64_t v175 = 0;
LABEL_338:
                if (v175) {
                  unsigned int v168 = v175;
                }
                if (*v168 != Successor) {
                  unsigned int v168 = (void *)(v165 + 8 * v171);
                }
              }
              else
              {
                uint64_t v175 = 0;
                int v176 = 1;
                while (v174 != Successor)
                {
                  if (v175) {
                    BOOL v177 = 0;
                  }
                  else {
                    BOOL v177 = v174 == -2;
                  }
                  if (v177) {
                    uint64_t v175 = v168;
                  }
                  unsigned int v178 = v173 + v176++;
                  unsigned int v173 = v178 & v172;
                  unsigned int v168 = (void *)(v165 + 8 * (v178 & v172));
                  uint64_t v174 = *v168;
                  if (*v168 == -1) {
                    goto LABEL_338;
                  }
                }
              }
            }
            BOOL v39 = v165 == v166;
            uint64_t v179 = 76;
            if (!v39) {
              uint64_t v179 = 72;
            }
            if (v168 == (void *)(v165 + 8 * *(unsigned int *)(v253 + v179)))
            {
              *(void *)&long long v274 = v237;
              *((void *)&v274 + 1) = Successor;
              sub_1CCE188B8((uint64_t)&v263, (uint64_t *)&v274);
            }
            else
            {
              if (v268)
              {
                int v180 = 16;
                unint64_t v181 = &v269;
              }
              else
              {
                int v180 = v270;
                if (!v270)
                {
                  unsigned int v190 = 0;
LABEL_333:
                  unint64_t v191 = sub_1CCD11EEC((uint64_t)&v268, (uint64_t)&v255, &v255, v190);
                  *unint64_t v191 = v255;
                  if (v272 >= (unint64_t)HIDWORD(v272)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((void *)v271 + v272) = v255;
                  LODWORD(v272) = v272 + 1;
                  continue;
                }
                unint64_t v181 = v269;
              }
              int v182 = v180 - 1;
              unsigned int v183 = v182 & ((Successor >> 4) ^ (Successor >> 9));
              unsigned int v184 = &v181[v183];
              uint64_t v185 = *v184;
              if (Successor != *v184)
              {
                uint64_t v186 = 0;
                int v187 = 1;
                while (v185 != -4096)
                {
                  if (v186) {
                    BOOL v188 = 0;
                  }
                  else {
                    BOOL v188 = v185 == -8192;
                  }
                  if (v188) {
                    uint64_t v186 = v184;
                  }
                  unsigned int v189 = v183 + v187++;
                  unsigned int v183 = v189 & v182;
                  unsigned int v184 = &v181[v183];
                  uint64_t v185 = *v184;
                  if (Successor == *v184) {
                    goto LABEL_335;
                  }
                }
                if (v186) {
                  unsigned int v190 = v186;
                }
                else {
                  unsigned int v190 = v184;
                }
                goto LABEL_333;
              }
            }
LABEL_335:
            ;
          }
        }
LABEL_345:
        sub_1CCE182EC(v245, v104, v234);
        unsigned int v126 = v233;
        goto LABEL_346;
      }
LABEL_208:
      uint64_t v121 = *(void *)(v253 + 56);
      uint64_t v120 = *(void *)(v253 + 64);
      if (v120 == v121)
      {
        uint64_t v122 = *(unsigned int *)(v253 + 76);
        uint64_t v123 = (void *)(v120 + 8 * v122);
        if (v122)
        {
          uint64_t v124 = 0;
          uint64_t v125 = 8 * v122;
          unsigned int v126 = v233;
          while (*(void *)(v120 + v124) != v113)
          {
            v124 += 8;
            if (v125 == v124) {
              goto LABEL_229;
            }
          }
          uint64_t v123 = (void *)(v120 + v124);
LABEL_229:
          uint64_t v121 = *(void *)(v253 + 64);
        }
        else
        {
          uint64_t v121 = *(void *)(v253 + 64);
          unsigned int v126 = v233;
        }
      }
      else
      {
        uint64_t v127 = *(unsigned int *)(v253 + 72);
        int v128 = v127 - 1;
        unsigned int v129 = (v127 - 1) & ((v113 >> 4) ^ (v113 >> 9));
        uint64_t v123 = (void *)(v120 + 8 * v129);
        uint64_t v130 = *v123;
        if (*v123 == -1)
        {
          unint64_t v131 = 0;
          unsigned int v126 = v233;
LABEL_238:
          if (v131) {
            uint64_t v123 = v131;
          }
          if (*v123 != v113) {
            uint64_t v123 = (void *)(v120 + 8 * v127);
          }
        }
        else
        {
          unint64_t v131 = 0;
          int v132 = 1;
          unsigned int v126 = v233;
          while (v130 != v113)
          {
            if (v131) {
              BOOL v133 = 0;
            }
            else {
              BOOL v133 = v130 == -2;
            }
            if (v133) {
              unint64_t v131 = v123;
            }
            unsigned int v134 = v129 + v132++;
            unsigned int v129 = v134 & v128;
            uint64_t v123 = (void *)(v120 + 8 * (v134 & v128));
            uint64_t v130 = *v123;
            if (*v123 == -1) {
              goto LABEL_238;
            }
          }
        }
      }
      BOOL v39 = v120 == v121;
      uint64_t v142 = 76;
      if (!v39) {
        uint64_t v142 = 72;
      }
      if (v123 == (void *)(v120 + 8 * *(unsigned int *)(v253 + v142)))
      {
        *(void *)&long long v274 = v237;
        *((void *)&v274 + 1) = v113;
        sub_1CCE188B8((uint64_t)&v263, (uint64_t *)&v274);
        goto LABEL_346;
      }
      if (v268)
      {
        int v143 = 16;
        unint64_t v144 = &v269;
      }
      else
      {
        int v143 = v270;
        if (!v270)
        {
          unsigned int v153 = 0;
          goto LABEL_263;
        }
        unint64_t v144 = v269;
      }
      int v145 = v143 - 1;
      unsigned int v146 = ((v113 >> 4) ^ (v113 >> 9)) & v145;
      unint64_t v147 = &v144[v146];
      uint64_t v148 = *v147;
      if (v113 == *v147) {
        goto LABEL_346;
      }
      uint64_t v149 = 0;
      int v150 = 1;
      while (v148 != -4096)
      {
        if (v149) {
          BOOL v151 = 0;
        }
        else {
          BOOL v151 = v148 == -8192;
        }
        if (v151) {
          uint64_t v149 = v147;
        }
        unsigned int v152 = v146 + v150++;
        unsigned int v146 = v152 & v145;
        unint64_t v147 = &v144[v146];
        uint64_t v148 = *v147;
        if (v113 == *v147) {
          goto LABEL_346;
        }
      }
      if (v149) {
        unsigned int v153 = v149;
      }
      else {
        unsigned int v153 = v147;
      }
LABEL_263:
      unint64_t v154 = sub_1CCD11EEC((uint64_t)&v268, (uint64_t)&v254, &v254, v153);
      *unint64_t v154 = v254;
      if (v272 >= (unint64_t)HIDWORD(v272)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v271 + v272) = v254;
      LODWORD(v272) = v272 + 1;
LABEL_346:
      unsigned int v46 = v126 + 1;
      if (v272 == v46) {
        goto LABEL_46;
      }
      continue;
    }
    break;
  }
  if (v49) {
    uint64_t v50 = (uint64_t)(v49 - 3);
  }
  else {
    uint64_t v50 = 0;
  }
  if (sub_1CBF63B28(v50)) {
    goto LABEL_146;
  }
  uint64_t v52 = *a4;
  uint64_t v51 = a4[1];
  if (v51 == *a4)
  {
    uint64_t v53 = *((unsigned int *)a4 + 5);
    long long v54 = (void *)(v51 + 8 * v53);
    if (v53)
    {
      uint64_t v55 = 0;
      while (*(void *)(v51 + v55) != v50)
      {
        v55 += 8;
        if (8 * v53 == v55) {
          goto LABEL_81;
        }
      }
      long long v54 = (void *)(v51 + v55);
    }
LABEL_81:
    uint64_t v52 = a4[1];
  }
  else
  {
    uint64_t v56 = *((unsigned int *)a4 + 4);
    int v57 = v56 - 1;
    unsigned int v58 = (v56 - 1) & ((v50 >> 4) ^ (v50 >> 9));
    long long v54 = (void *)(v51 + 8 * v58);
    uint64_t v59 = *v54;
    if (*v54 == -1)
    {
      int v60 = 0;
LABEL_107:
      if (v60) {
        long long v54 = v60;
      }
      LODWORD(v53) = *((_DWORD *)a4 + 5);
      uint64_t v78 = (void *)(v51 + 8 * v56);
      if (*v54 != v50) {
        long long v54 = v78;
      }
    }
    else
    {
      int v60 = 0;
      int v61 = 1;
      while (v59 != v50)
      {
        if (v60) {
          BOOL v62 = 0;
        }
        else {
          BOOL v62 = v59 == -2;
        }
        if (v62) {
          int v60 = v54;
        }
        unsigned int v63 = v58 + v61++;
        unsigned int v58 = v63 & v57;
        long long v54 = (void *)(v51 + 8 * (v63 & v57));
        uint64_t v59 = *v54;
        if (*v54 == -1) {
          goto LABEL_107;
        }
      }
      LODWORD(v53) = *((_DWORD *)a4 + 5);
    }
  }
  unsigned int v64 = v51 == v52 ? v53 : *((_DWORD *)a4 + 4);
  if (v54 != (void *)(v51 + 8 * v64))
  {
LABEL_146:
    uint64_t v49 = (void *)v49[1];
    goto LABEL_57;
  }
  int v65 = *(_DWORD *)(v50 + 20);
  if ((v65 & 0x40000000) != 0)
  {
    uint64_t v67 = *(uint64_t **)(v50 - 8);
    unint64_t v66 = v65 & 0x7FFFFFF;
  }
  else
  {
    unint64_t v66 = v65 & 0x7FFFFFF;
    uint64_t v67 = (uint64_t *)(v50 - 32 * v66);
  }
  *(void *)&long long v274 = v275;
  *((void *)&v274 + 1) = 0x400000000;
  if (v66 >= 5) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v66)
  {
    uint64_t v68 = 32 * v66;
    uint64_t v69 = v275;
    do
    {
      uint64_t v70 = *v67;
      v67 += 4;
      *v69++ = v70;
      v68 -= 32;
    }
    while (v68);
    int v71 = (void *)v274;
  }
  else
  {
    int v71 = v275;
  }
  DWORD2(v274) = v66;
  uint64_t v72 = (*(uint64_t (**)(void, uint64_t, void *))(**(void **)a2 + 72))(*(void *)a2, v50, v71);
  int v74 = v73;
  if ((void *)v274 != v275) {
    free((void *)v274);
  }
  if (v74 == 1) {
    uint64_t v26 = 1;
  }
  else {
    uint64_t v26 = v26;
  }
  unint64_t v75 = ((v238 + v72) >> 63) ^ 0x8000000000000000;
  if (!__OFADD__(v238, v72)) {
    unint64_t v75 = v238 + v72;
  }
  int64_t v238 = v75;
  switch(*(unsigned char *)(v50 + 16))
  {
    case ')':
    case '*':
    case '+':
    case ',':
    case '-':
    case '.':
    case '/':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    case ':':
      if (llvm::UnrolledInstAnalyzer::visitBinaryOperator((llvm::UnrolledInstAnalyzer *)v239, (llvm::BinaryOperator *)v50))goto LABEL_105; {
      goto LABEL_121;
      }
    case '<':
      if ((llvm::UnrolledInstAnalyzer::visitLoad((llvm::UnrolledInstAnalyzer *)v239, (llvm::LoadInst *)v50) & 1) == 0) {
        goto LABEL_121;
      }
      goto LABEL_105;
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
      if ((llvm::UnrolledInstAnalyzer::visitCastInst((llvm::UnrolledInstAnalyzer *)v239, (llvm::CastInst *)v50) & 1) == 0) {
        goto LABEL_121;
      }
      goto LABEL_105;
    case 'Q':
    case 'R':
      if ((llvm::UnrolledInstAnalyzer::visitCmpInst((llvm::UnrolledInstAnalyzer *)v239, (llvm::CmpInst *)v50) & 1) == 0) {
        goto LABEL_121;
      }
      goto LABEL_105;
    case 'S':
      if ((llvm::UnrolledInstAnalyzer::simplifyInstWithSCEV((llvm::UnrolledInstAnalyzer *)v239, (llvm::Instruction *)v50) & 1) == 0&& *(void *)(v50 + 40) != **(void **)(v244 + 32))
      {
        goto LABEL_121;
      }
      goto LABEL_105;
    default:
      if (llvm::UnrolledInstAnalyzer::simplifyInstWithSCEV((llvm::UnrolledInstAnalyzer *)v239, (llvm::Instruction *)v50))
      {
LABEL_105:
        int v76 = 0x40000000;
        char v77 = 1;
      }
      else
      {
LABEL_121:
        char v77 = 0;
        int v76 = 0;
      }
      int v79 = v76 | v235;
      uint64_t v254 = 0;
      if (sub_1CCE189F0((uint64_t)v246, v248, v50, v76 | v235, &v254)) {
        goto LABEL_131;
      }
      uint64_t v80 = v254;
      uint64_t v255 = v254;
      int v81 = v247;
      uint64_t v82 = v248;
      if (4 * (int)v247 + 4 >= 3 * v248)
      {
        int v83 = 2 * v248;
      }
      else
      {
        int v83 = v248;
        if (v248 + ~v247 - HIDWORD(v247) > v248 >> 3) {
          goto LABEL_125;
        }
      }
      uint64_t v228 = (uint64_t)v246;
      unint64_t v89 = (v83 - 1) | ((unint64_t)(v83 - 1) >> 1);
      unint64_t v90 = v89 | (v89 >> 2) | ((v89 | (v89 >> 2)) >> 4);
      int v91 = ((v90 | (v90 >> 8)) >> 16) | v90 | (v90 >> 8);
      if ((v91 + 1) > 0x40) {
        unsigned int v92 = v91 + 1;
      }
      else {
        unsigned int v92 = 64;
      }
      unsigned int v248 = v92;
      BOOL v93 = operator new(16 * v92, (std::align_val_t)8uLL);
      int v246 = v93;
      if (v228)
      {
        uint64_t v247 = 0;
        if (v248)
        {
          uint64_t v94 = 16 * v248;
          do
          {
            *v93++ = xmmword_1CFB27310;
            v94 -= 16;
          }
          while (v94);
        }
        if (v82)
        {
          uint64_t v95 = 16 * v82;
          uint64_t v96 = v228;
          do
          {
            int v97 = *(_DWORD *)(v96 + 8);
            uint64_t v98 = *(void *)v96;
            if (*(void *)v96 != -8192 && v98 != -4096 || (v97 & 0x3FFFFFFF) != 0)
            {
              *(void *)&long long v274 = 0;
              uint64_t v229 = v95;
              sub_1CCE189F0((uint64_t)v246, v248, v98, v97, &v274);
              uint64_t v95 = v229;
              *(_OWORD *)long long v274 = *(_OWORD *)v96;
              LODWORD(v247) = v247 + 1;
            }
            v96 += 16;
            v95 -= 16;
          }
          while (v95);
        }
        MEMORY[0x1D25D9CD0](v228, 8);
        BOOL v93 = v246;
        int v101 = v248;
      }
      else
      {
        uint64_t v247 = 0;
        int v101 = v248;
        if (v248)
        {
          unint64_t v102 = 0;
          uint64_t v103 = 16 * v248;
          do
          {
            v93[v102 / 0x10] = xmmword_1CFB27310;
            v102 += 16;
          }
          while (v103 != v102);
        }
      }
      sub_1CCE189F0((uint64_t)v93, v101, v50, v79, &v255);
      int v81 = v247;
      uint64_t v80 = v255;
LABEL_125:
      LODWORD(v247) = v81 + 1;
      if (*(void *)v80 != -4096 || (*(_DWORD *)(v80 + 8) & 0x3FFFFFFF) != 0) {
        --HIDWORD(v247);
      }
      *(void *)uint64_t v80 = v50;
      *(_DWORD *)(v80 + 8) = v79;
LABEL_131:
      if (v77) {
        goto LABEL_146;
      }
      int v85 = *(unsigned __int8 *)(v50 + 16);
      uint64_t v86 = v85 == 84 ? v50 : 0;
      if (!v49
        || v85 != 84
        || (uint64_t v87 = *(void *)(v86 - 32)) != 0
        && !*(unsigned char *)(v87 + 16)
        && *(void *)(v87 + 24) == *(void *)(v86 + 72)
        && ((*(uint64_t (**)(void))(**(void **)a2 + 176))() & 1) == 0)
      {
        if (llvm::Instruction::mayHaveSideEffects((llvm::Instruction *)v50)) {
          sub_1CCE182EC(v245, v50, v234);
        }
        BOOL v88 = v250 > 0;
        if (!v250) {
          BOOL v88 = v249 > v232;
        }
        if (!v88) {
          goto LABEL_146;
        }
      }
      MEMORY[0x1D25D9CD0](v239[0], 8);
      break;
  }
LABEL_367:
  int v193 = 0;
  unint64_t v194 = 0;
  char v195 = 1;
LABEL_372:
  if (v256[0] != v257) {
    free(v256[0]);
  }
  if (v258[0] != v259) {
    free(v258[0]);
  }
  MEMORY[0x1D25D9CD0](v246, 8);
  if (v260 != v262) {
    free(v260);
  }
  MEMORY[0x1D25D9CD0](v251[0], 8);
  if (v265 != v267) {
    free(v265);
  }
  if ((v263 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v264[0], 8);
  }
  if (v271 != v273) {
    free(v271);
  }
  if (v268)
  {
    if ((v195 & 1) == 0) {
      goto LABEL_386;
    }
    goto LABEL_393;
  }
  MEMORY[0x1D25D9CD0](v269, 8);
  if (v195) {
    goto LABEL_393;
  }
LABEL_386:
  unsigned int v199 = v194 | v193;
  if (HIDWORD(v194) > 0x28F5C27)
  {
    unsigned int v200 = 100;
  }
  else
  {
    unsigned int v200 = a7[1];
    if (v199 && 100 * HIDWORD(v194) / v199 < v200) {
      unsigned int v200 = 100 * HIDWORD(v194) / v199;
    }
  }
  if (*a7 * v200 / 0x64 <= v199)
  {
LABEL_393:
    uint64_t v11 = 0;
    LOBYTE(v8) = 0;
    unsigned int v10 = 0;
    return v11 | v10 | v8;
  }
LABEL_3:
  unsigned int v10 = v8 & 0xFFFFFF00;
  uint64_t v11 = 0x100000000;
  return v11 | v10 | v8;
}

void sub_1CCE17290(llvm *a1)
{
  llvm::initializeAssumptionCacheTrackerPass((uint64_t)a1);
  llvm::initializeLoopPassPass(a1, v2);
  llvm::initializeTargetTransformInfoWrapperPassPass((uint64_t)a1);
  operator new();
}

uint64_t sub_1CCE17340(uint64_t a1, int a2, char a3, char a4, uint64_t a5, uint64_t a6, __int16 a7, __int16 a8, __int16 a9, int a10, __int16 a11, int a12, __int16 a13, uint64_t a14)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF5780;
  *(_DWORD *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = a2;
  *(void *)a1 = &unk_1F263F560;
  *(unsigned char *)(a1 + 32) = a3;
  *(unsigned char *)(a1 + 33) = a4;
  *(void *)(a1 + 36) = a6;
  *(void *)(a1 + 44) = a5;
  *(_WORD *)(a1 + 52) = a7;
  *(_WORD *)(a1 + 54) = a8;
  *(_WORD *)(a1 + 56) = a9;
  *(_WORD *)(a1 + 58) = a11;
  *(_WORD *)(a1 + 60) = a13;
  *(void *)(a1 + 64) = a14;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF5788, memory_order_acquire) != -1)
  {
    v18[0] = sub_1CCE17290;
    v18[1] = &PassRegistry;
    uint64_t v17 = v18;
    std::__call_once(&qword_1EBCF5788, &v17, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CCE17420(llvm *a1, const llvm::Loop *a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  llvm::hasUnrollTransformation(a1, a2);
}

void llvm::LoopUnrollPass::run()
{
}

unsigned int *sub_1CCE182EC(unsigned int **a1, uint64_t a2, int a3)
{
  v60[4] = *MEMORY[0x1E4F143B8];
  __n128 v5 = *a1;
  unsigned int v6 = (*a1)[2];
  if (v6 >= (*a1)[3]) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)v5 + 8 * v6) = a2;
  ++v5[2];
  while (2)
  {
    int v57 = a3;
    int v7 = a3 & 0x3FFFFFFF;
    uint64_t result = *a1;
    unsigned int v9 = (*a1)[2];
    do
    {
      uint64_t v10 = *(void *)(*(void *)result + 8 * v9 - 8);
      result[2] = v9 - 1;
      uint64_t v11 = a1[1];
      unsigned int v58 = 0;
      if (sub_1CCE189F0(*(void *)v11, v11[4], v10, v7, &v58))
      {
        unsigned int v12 = v58;
        uint64_t v13 = *(void *)v11;
        uint64_t v14 = v11[4];
      }
      else
      {
        uint64_t v13 = *(void *)v11;
        uint64_t v14 = v11[4];
        unsigned int v12 = (_DWORD *)(*(void *)v11 + 16 * v14);
      }
      if (v12 != (_DWORD *)(v13 + 16 * v14))
      {
        int v15 = v12[2];
        if ((v15 & 0x80000000) == 0)
        {
          v12[2] = v15 | 0x80000000;
          BOOL v16 = *(unsigned char *)(v10 + 16) != 83 || v10 == 0;
          if (!v16 && *(void *)(v10 + 40) == **(void **)(*(void *)a1[2] + 32))
          {
            if (v57) {
              llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopLatch();
            }
          }
          else
          {
            if ((v15 & 0x40000000) == 0)
            {
              int v17 = *(_DWORD *)(v10 + 20);
              if ((v17 & 0x40000000) != 0)
              {
                uint64_t v19 = *(uint64_t **)(v10 - 8);
                unint64_t v18 = v17 & 0x7FFFFFF;
              }
              else
              {
                unint64_t v18 = v17 & 0x7FFFFFF;
                uint64_t v19 = (uint64_t *)(v10 - 32 * v18);
              }
              uint64_t v20 = a1[5];
              unsigned int v58 = v60;
              uint64_t v59 = 0x400000000;
              if (v18 >= 5) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              if (v18)
              {
                uint64_t v21 = 32 * v18;
                uint64_t v22 = v60;
                do
                {
                  uint64_t v23 = *v19;
                  v19 += 4;
                  *v22++ = v23;
                  v21 -= 32;
                }
                while (v21);
                unsigned int v24 = v58;
              }
              else
              {
                unsigned int v24 = v60;
              }
              LODWORD(v59) = v18;
              uint64_t v25 = (*(uint64_t (**)(void, uint64_t, void *))(**(void **)v20 + 72))(*(void *)v20, v10, v24);
              int v27 = v26;
              if (v58 != v60) {
                free(v58);
              }
              int v28 = a1[4];
              if (v27 == 1) {
                void v28[2] = 1;
              }
              int64_t v29 = *(void *)v28 + v25;
              if (__OFADD__(*(void *)v28, v25)) {
                int64_t v29 = (v29 >> 63) ^ 0x8000000000000000;
              }
              *(void *)int v28 = v29;
            }
            int v30 = *(_DWORD *)(v10 + 20);
            if ((v30 & 0x40000000) != 0)
            {
              uint64_t v32 = *(void *)(v10 - 8);
              uint64_t v31 = v30 & 0x7FFFFFF;
              if (!v31) {
                goto LABEL_76;
              }
            }
            else
            {
              uint64_t v31 = v30 & 0x7FFFFFF;
              uint64_t v32 = v10 - 32 * v31;
              if (!v31) {
                goto LABEL_76;
              }
            }
            uint64_t v33 = v32 + 32 * v31;
            do
            {
              uint64_t v34 = *(void *)v32;
              if (*(void *)v32) {
                BOOL v35 = *(unsigned __int8 *)(*(void *)v32 + 16) >= 0x1Cu;
              }
              else {
                BOOL v35 = 0;
              }
              if (v35)
              {
                uint64_t v36 = *(void *)a1[2];
                uint64_t v37 = *(void *)(v34 + 40);
                uint64_t v39 = *(void *)(v36 + 56);
                uint64_t v38 = *(void *)(v36 + 64);
                if (v38 == v39)
                {
                  uint64_t v40 = *(unsigned int *)(v36 + 76);
                  unint64_t v41 = (void *)(v38 + 8 * v40);
                  if (v40)
                  {
                    uint64_t v42 = 0;
                    uint64_t v43 = 8 * v40;
                    while (*(void *)(v38 + v42) != v37)
                    {
                      v42 += 8;
                      if (v43 == v42) {
                        goto LABEL_60;
                      }
                    }
                    unint64_t v41 = (void *)(v38 + v42);
                  }
LABEL_60:
                  uint64_t v39 = *(void *)(v36 + 64);
                }
                else
                {
                  uint64_t v44 = *(unsigned int *)(v36 + 72);
                  int v45 = v44 - 1;
                  unsigned int v46 = (v44 - 1) & ((v37 >> 4) ^ (v37 >> 9));
                  unint64_t v41 = (void *)(v38 + 8 * v46);
                  uint64_t v47 = *v41;
                  if (*v41 == -1)
                  {
                    long long v48 = 0;
LABEL_70:
                    if (v48) {
                      unint64_t v41 = v48;
                    }
                    if (*v41 != v37) {
                      unint64_t v41 = (void *)(v38 + 8 * v44);
                    }
                  }
                  else
                  {
                    long long v48 = 0;
                    int v49 = 1;
                    while (v47 != v37)
                    {
                      if (v48) {
                        BOOL v50 = 0;
                      }
                      else {
                        BOOL v50 = v47 == -2;
                      }
                      if (v50) {
                        long long v48 = v41;
                      }
                      unsigned int v51 = v46 + v49++;
                      unsigned int v46 = v51 & v45;
                      unint64_t v41 = (void *)(v38 + 8 * (v51 & v45));
                      uint64_t v47 = *v41;
                      if (*v41 == -1) {
                        goto LABEL_70;
                      }
                    }
                  }
                }
                if (v38 == v39) {
                  uint64_t v52 = 76;
                }
                else {
                  uint64_t v52 = 72;
                }
                if (v41 != (void *)(v38 + 8 * *(unsigned int *)(v36 + v52)))
                {
                  uint64_t v53 = *a1;
                  unint64_t v54 = (*a1)[2];
                  if (v54 >= (*a1)[3]) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *(void *)(*(void *)v53 + 8 * v54) = v34;
                  ++v53[2];
                }
              }
              v32 += 32;
            }
            while (v32 != v33);
          }
        }
      }
LABEL_76:
      uint64_t result = *a1;
      unsigned int v9 = (*a1)[2];
    }
    while (v9);
    uint64_t v55 = a1[3];
    uint64_t v56 = v55[2];
    if (v56)
    {
      sub_1CBFCBB74(result, *(unsigned char **)v55, (unsigned char *)(*(void *)v55 + 8 * v56));
      a1[3][2] = 0;
      a3 = v57 - 1;
      continue;
    }
    return result;
  }
}

uint64_t sub_1CCE188B8(uint64_t a1, uint64_t *a2)
{
  unsigned int v9 = 0;
  uint64_t result = sub_1CCE18AF0(a1, *a2, a2[1], &v9);
  if (result) {
    return result;
  }
  int v5 = *(_DWORD *)a1 >> 1;
  if (*(_DWORD *)a1) {
    unsigned int v6 = 4;
  }
  else {
    unsigned int v6 = *(_DWORD *)(a1 + 16);
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 4) > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD7766A0(a1, v6);
  unsigned int v9 = 0;
  uint64_t result = sub_1CCE18AF0(a1, *a2, a2[1], &v9);
LABEL_6:
  int v7 = v9;
  *(_DWORD *)a1 += 2;
  if (*v7 != -4096 || v7[1] != -4096) {
    --*(_DWORD *)(a1 + 4);
  }
  *(_OWORD *)int v7 = *(_OWORD *)a2;
  unsigned int v8 = *(_DWORD *)(a1 + 80);
  if (v8 >= *(_DWORD *)(a1 + 84)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_OWORD *)(*(void *)(a1 + 72) + 16 * v8) = *(_OWORD *)a2;
  ++*(_DWORD *)(a1 + 80);
  return result;
}

uint64_t sub_1CCE189F0(uint64_t a1, int a2, uint64_t a3, int a4, void *a5)
{
  if (a2)
  {
    unint64_t v5 = ~((unint64_t)(37 * ((4 * a4) >> 2)) << 32)
       + (37 * ((4 * a4) >> 2))
       + ((unint64_t)((a3 >> 4) ^ (a3 >> 9)) << 32);
    unint64_t v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    int v8 = a2 - 1;
    unsigned int v9 = (a2 - 1) & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27)));
    uint64_t v10 = (uint64_t *)(a1 + 16 * v9);
    int v11 = *((_DWORD *)v10 + 2);
    uint64_t v12 = *v10;
    if (*v10 == a3 && ((v11 ^ a4) & 0x3FFFFFFF) == 0)
    {
      uint64_t v14 = 1;
    }
    else
    {
      BOOL v16 = 0;
      int v17 = 1;
      while (1)
      {
        uint64_t v14 = v11 & 0x3FFFFFFF;
        if (v12 == -4096 && !v14) {
          break;
        }
        if (v16) {
          BOOL v18 = 0;
        }
        else {
          BOOL v18 = v14 == 0;
        }
        if (v18 && v12 == -8192) {
          BOOL v16 = v10;
        }
        unsigned int v20 = v9 + v17++;
        unsigned int v9 = v20 & v8;
        uint64_t v10 = (uint64_t *)(a1 + 16 * (v20 & v8));
        int v11 = *((_DWORD *)v10 + 2);
        uint64_t v12 = *v10;
        uint64_t v14 = 1;
        if (*v10 == a3 && ((v11 ^ a4) & 0x3FFFFFFF) == 0) {
          goto LABEL_9;
        }
      }
      if (v16) {
        uint64_t v10 = v16;
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v14 = 0;
  }
LABEL_9:
  *a5 = v10;
  return v14;
}

uint64_t sub_1CCE18AF0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v4 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v5 = 4;
  }
  else
  {
    int v5 = *(_DWORD *)(a1 + 16);
    if (!v5)
    {
      uint64_t v12 = 0;
      uint64_t result = 0;
      goto LABEL_9;
    }
    uint64_t v4 = *(void *)(a1 + 8);
  }
  unint64_t v6 = ((a3 >> 4) ^ (a3 >> 9) | ((unint64_t)((a2 >> 4) ^ (a2 >> 9)) << 32))
     + ~((unint64_t)((a3 >> 4) ^ (a3 >> 9)) << 32);
  unint64_t v7 = (v6 ^ (v6 >> 22)) + ~((v6 ^ (v6 >> 22)) << 13);
  unint64_t v8 = (9 * (v7 ^ (v7 >> 8))) ^ ((9 * (v7 ^ (v7 >> 8))) >> 15);
  int v9 = ((v8 + ~(v8 << 27)) >> 31) ^ (v8 + ~(v8 << 27));
  int v10 = v5 - 1;
  unsigned int v11 = (v5 - 1) & v9;
  uint64_t v12 = (void *)(v4 + 16 * v11);
  uint64_t v13 = *v12;
  uint64_t v14 = v12[1];
  if (*v12 == a2 && v14 == a3)
  {
    uint64_t result = 1;
  }
  else
  {
    BOOL v16 = 0;
    int v17 = 1;
    uint64_t result = 1;
    while (v13 != -4096 || v14 != -4096)
    {
      if (v16) {
        BOOL v19 = 0;
      }
      else {
        BOOL v19 = v14 == -8192;
      }
      if (v19 && v13 == -8192) {
        BOOL v16 = v12;
      }
      unsigned int v21 = v11 + v17++;
      unsigned int v11 = v21 & v10;
      uint64_t v12 = (void *)(v4 + 16 * (v21 & v10));
      uint64_t v13 = *v12;
      uint64_t v14 = v12[1];
      if (*v12 == a2 && v14 == a3) {
        goto LABEL_9;
      }
    }
    uint64_t result = 0;
    if (v16) {
      uint64_t v12 = v16;
    }
  }
LABEL_9:
  *a4 = v12;
  return result;
}

void sub_1CCE18BF0()
{
}

void sub_1CCE18C50(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCE18C88(uint64_t a1, llvm *a2)
{
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::AssumptionCacheTracker::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);

  llvm::getLoopAnalysisUsage(a2, v3);
}

uint64_t sub_1CCE18CE0(llvm::LoopPass *a1, llvm *a2)
{
  if ((llvm::LoopPass::skipLoop(a1, a2) & 1) == 0)
  {
    uint64_t v4 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1];
    if (v5 == v6)
    {
LABEL_6:
      uint64_t v7 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v5 != &llvm::DominatorTreeWrapperPass::ID)
      {
        v5 += 16;
        if (v5 == v6) {
          goto LABEL_6;
        }
      }
      uint64_t v7 = *(void *)(v5 + 8);
    }
    unint64_t v8 = *(Function **)(**((void **)a2 + 4) + 56);
    uint64_t v9 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::DominatorTreeWrapperPass::ID);
    int v10 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v11 = *v10;
    uint64_t v12 = v10[1];
    if (v11 == v12)
    {
LABEL_11:
      uint64_t v13 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v11 != &llvm::LoopInfoWrapperPass::ID)
      {
        v11 += 16;
        if (v11 == v12) {
          goto LABEL_11;
        }
      }
      uint64_t v13 = *(void *)(v11 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v13 + 96))(v13, &llvm::LoopInfoWrapperPass::ID);
    uint64_t v14 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v15 = *v14;
    uint64_t v16 = v14[1];
    if (v15 == v16)
    {
LABEL_16:
      uint64_t v17 = 0;
    }
    else
    {
      while (*(char **)v15 != llvm::ScalarEvolutionWrapperPass::ID)
      {
        v15 += 16;
        if (v15 == v16) {
          goto LABEL_16;
        }
      }
      uint64_t v17 = *(void *)(v15 + 8);
    }
    BOOL v18 = (const llvm::Loop *)(v9 + 32);
    (*(void (**)(uint64_t, char *))(*(void *)v17 + 96))(v17, llvm::ScalarEvolutionWrapperPass::ID);
    BOOL v19 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v20 = *v19;
    uint64_t v21 = v19[1];
    if (v20 == v21)
    {
LABEL_21:
      uint64_t v22 = 0;
    }
    else
    {
      while (*(char **)v20 != llvm::TargetTransformInfoWrapperPass::ID)
      {
        v20 += 16;
        if (v20 == v21) {
          goto LABEL_21;
        }
      }
      uint64_t v22 = *(void *)(v20 + 8);
    }
    uint64_t v23 = (llvm::TargetTransformInfoWrapperPass *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v22 + 96))(v22, llvm::TargetTransformInfoWrapperPass::ID);
    llvm::TargetTransformInfoWrapperPass::getTTI(v23, v8);
    unsigned int v24 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v25 = *v24;
    uint64_t v26 = v24[1];
    if (v25 == v26)
    {
LABEL_26:
      uint64_t v27 = 0;
    }
    else
    {
      while (*(char **)v25 != llvm::AssumptionCacheTracker::ID)
      {
        v25 += 16;
        if (v25 == v26) {
          goto LABEL_26;
        }
      }
      uint64_t v27 = *(void *)(v25 + 8);
    }
    int v28 = (llvm::AssumptionCacheTracker *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v27 + 96))(v27, llvm::AssumptionCacheTracker::ID);
    llvm::AssumptionCacheTracker::getAssumptionCache(v28, (llvm::Function *)v8);
    llvm::OptimizationRemarkEmitter::OptimizationRemarkEmitter(&v30, (const llvm::Function *)v8);
    llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*((void *)a1 + 1) + 24), &unk_1EA61F34B, 1);
    sub_1CCE17420(a2, v18);
  }
  return 0;
}

uint64_t sub_1CCE19090()
{
  LOBYTE(v2) = 0;
  uint64_t v4 = &v2;
  int v3 = 1;
  v1.n128_u64[0] = (unint64_t)"Forget everything in SCEV when doing LoopUnroll, instead of just the current top-mo"
                                     "st loop. This is sometimes preferred to reduce compile time.";
  v1.n128_u64[1] = 143;
  sub_1CBA9E5B0((llvm::cl::Option *)&llvm::ForgetSCEVInLoopUnroll, "forget-scev-loop-unroll", (unsigned char **)&v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &llvm::ForgetSCEVInLoopUnroll, &dword_1CB82C000);
  LODWORD(v4) = 1;
  v1.n128_u64[0] = (unint64_t)"The cost threshold for loop unrolling";
  v1.n128_u64[1] = 37;
  sub_1CD513224((uint64_t)&unk_1EBCF5790, "unroll-threshold", &v4, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF5790, &dword_1CB82C000);
  int v2 = 1;
  int v3 = 0;
  uint64_t v4 = &v3;
  v1.n128_u64[0] = (unint64_t)"The cost threshold for loop unrolling when optimizing for size";
  v1.n128_u64[1] = 62;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF5850, "unroll-optsize-threshold", &v4, &v2, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF5850, &dword_1CB82C000);
  LODWORD(v4) = 1;
  v1.n128_u64[0] = (unint64_t)"The cost threshold for partial loop unrolling";
  v1.n128_u64[1] = 45;
  sub_1CD77690C(&v4, (long long *)&v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCF5910, &dword_1CB82C000);
  int v2 = 1;
  int v3 = 400;
  uint64_t v4 = &v3;
  v1.n128_u64[0] = (unint64_t)"The maximum 'boost' (represented as a percentage >= 100) applied to the threshold w"
                                     "hen aggressively unrolling a loop due to the dynamic cost savings. If completely un"
                                     "rolling a loop will reduce the total runtime from X to Y, we boost the loop unroll "
                                     "threshold to DefaultThreshold*std::min(MaxPercentThresholdBoost, X/Y). This limit a"
                                     "voids excessive code bloat.";
  v1.n128_u64[1] = 359;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF59D0, "unroll-max-percent-threshold-boost", &v4, &v2, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF59D0, &dword_1CB82C000);
  int v2 = 1;
  int v3 = 10;
  uint64_t v4 = &v3;
  v1.n128_u64[0] = (unint64_t)"Don't allow loop unrolling to simulate more than this number ofiterations when chec"
                                     "king full unroll profitability";
  v1.n128_u64[1] = 113;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF5A90, "unroll-max-iteration-count-to-analyze", &v4, &v2, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF5A90, &dword_1CB82C000);
  LODWORD(v4) = 1;
  v1.n128_u64[0] = (unint64_t)"Use this unroll count for all loops including those with unroll_count pragma values"
                                     ", for testing purposes";
  v1.n128_u64[1] = 105;
  sub_1CD776A18(&v4, (long long *)&v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCF5B50, &dword_1CB82C000);
  LODWORD(v4) = 1;
  v1.n128_u64[0] = (unint64_t)"Set the max unroll count for partial and runtime unrolling, fortesting purposes";
  v1.n128_u64[1] = 79;
  sub_1CD513224((uint64_t)&unk_1EBCF5C10, "unroll-max-count", &v4, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF5C10, &dword_1CB82C000);
  LODWORD(v4) = 1;
  v1.n128_u64[0] = (unint64_t)"Set the max unroll count for full unrolling, for testing purposes";
  v1.n128_u64[1] = 65;
  sub_1CD776B24(&v4, (long long *)&v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCF5CD0, &dword_1CB82C000);
  LODWORD(v4) = 1;
  v1.n128_u64[0] = (unint64_t)"Allows loops to be partially unrolled until -unroll-threshold loop size is reached.";
  v1.n128_u64[1] = 83;
  sub_1CD4C1500((uint64_t)&unk_1EBCF5D90, "unroll-allow-partial", &v4, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF5D90, &dword_1CB82C000);
  LODWORD(v4) = 1;
  v1.n128_u64[0] = (unint64_t)"Allow generation of a loop remainder (extra iterations) when unrolling a loop.";
  v1.n128_u64[1] = 78;
  sub_1CD4C1500((uint64_t)&unk_1EBCF5E50, "unroll-allow-remainder", &v4, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF5E50, &dword_1CB82C000);
  int v3 = 1;
  LODWORD(v4) = 1;
  v1.n128_u64[0] = (unint64_t)"Unroll loops with run-time trip counts";
  v1.n128_u64[1] = 38;
  sub_1CD776C30(&v4, &v3, (long long *)&v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCF5F10, &dword_1CB82C000);
  int v2 = 1;
  int v3 = 8;
  uint64_t v4 = &v3;
  v1.n128_u64[0] = (unint64_t)"The max of trip count upper bound that is considered in unrolling";
  v1.n128_u64[1] = 65;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF5FD0, "unroll-max-upperbound", &v4, &v2, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF5FD0, &dword_1CB82C000);
  int v2 = 1;
  int v3 = 0x4000;
  uint64_t v4 = &v3;
  v1.n128_u64[0] = (unint64_t)"Unrolled size limit for loops with an unroll(full) or unroll_count pragma.";
  v1.n128_u64[1] = 74;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF6090, "pragma-unroll-threshold", &v4, &v2, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF6090, &dword_1CB82C000);
  int v2 = 1;
  int v3 = 5;
  uint64_t v4 = &v3;
  v1.n128_u64[0] = (unint64_t)"If the runtime tripcount for the loop is lower than the threshold, the loop is cons"
                                     "idered as flat and will be less aggressively unrolled.";
  v1.n128_u64[1] = 137;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF6150, "flat-loop-tripcount-threshold", &v4, &v2, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF6150, &dword_1CB82C000);
  LODWORD(v4) = 1;
  v1.n128_u64[0] = (unint64_t)"Allow the loop remainder to be unrolled.";
  v1.n128_u64[1] = 40;
  sub_1CD4C1500((uint64_t)&unk_1EBCF6210, "unroll-remainder", &v4, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF6210, &dword_1CB82C000);
  LODWORD(v4) = 1;
  v1.n128_u64[0] = (unint64_t)"Enqueue and re-visit child loops in the loop PM after unrolling. This shouldn't typ"
                                     "ically be needed as child loops (or their clones) were already visited.";
  v1.n128_u64[1] = 154;
  sub_1CD4C1500((uint64_t)&unk_1EBCF62D0, "unroll-revisit-child-loops", &v4, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF62D0, &dword_1CB82C000);
  int v2 = 1;
  int v3 = 300;
  uint64_t v4 = &v3;
  v1.n128_u64[0] = (unint64_t)"Threshold (max size of unrolled loop) to use in aggressive (O3) optimizations";
  v1.n128_u64[1] = 77;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF6390, "unroll-threshold-aggressive", &v4, &v2, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF6390, &dword_1CB82C000);
  int v2 = 1;
  int v3 = 150;
  uint64_t v4 = &v3;
  v1.n128_u64[0] = (unint64_t)"Default threshold (max size of unrolled loop), used in all but O3 optimizations";
  v1.n128_u64[1] = 79;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF6450, "unroll-threshold-default", &v4, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF6450, &dword_1CB82C000);
}

void sub_1CCE195F8(llvm *a1)
{
  llvm::initializeDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializeLoopPassPass(a1, v2);
  llvm::initializeLoopInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeLoopSimplifyPass(a1, v3);
  llvm::initializeLCSSAWrapperPassPass(a1, v4);
  llvm::initializeScalarEvolutionWrapperPassPass(a1, v5);
  llvm::initializeTargetTransformInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeAssumptionCacheTrackerPass((uint64_t)a1);
  llvm::initializeDependenceAnalysisWrapperPassPass(a1, v6);
  llvm::initializeOptimizationRemarkEmitterWrapperPassPass(a1, v7);
  operator new();
}

uint64_t sub_1CCE196E0(uint64_t a1, int a2)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF6510;
  *(_DWORD *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = a2;
  *(void *)a1 = &unk_1F263F610;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF6518, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CCE195F8;
    v6[1] = &PassRegistry;
    uint64_t v5 = v6;
    std::__call_once(&qword_1EBCF6518, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void llvm::LoopUnrollAndJamPass::run(int *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X3>, uint64_t a4@<X8>)
{
  v58[4] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(const llvm::Function **)(**(void **)(**(void **)(a2 + 8) + 32) + 56);
  uint64_t v48 = *a3;
  int8x16_t v49 = vextq_s8(*(int8x16_t *)(a3 + 3), *(int8x16_t *)(a3 + 3), 8uLL);
  BOOL v50 = v7;
  llvm::OptimizationRemarkEmitter::OptimizationRemarkEmitter(v46, v7);
  uint64_t v8 = a3[3];
  uint64_t v9 = a3[4];
  int v10 = (void *)a3[6];
  uint64_t v43 = a3[2];
  int v44 = *a1;
  unint64_t v11 = *(void *)(a2 + 8);
  uint64_t v12 = *(unsigned int *)(a2 + 16);
  uint64_t v45 = a3[1];
  v55[0] = 1;
  for (uint64_t i = 1; i != 9; i += 2)
    v55[i] = -4096;
  uint64_t v56 = v58;
  uint64_t v57 = 0x400000000;
  std::string __dst = (void *)(v11 + 8 * v12);
  size_t v52 = (size_t)__dst;
  unint64_t v53 = v11;
  unint64_t v54 = v11;
  sub_1CD887020((uint64_t)&__dst, (char *)v55);
  if (v57)
  {
    uint64_t v14 = v43;
    uint64_t v15 = (char *)v56 + 8 * v57;
    uint64_t v16 = (llvm *)*((void *)v15 - 1);
    sub_1CCD7A0C4(v55, (void *)v15 - 1);
    unsigned int v17 = v57 - 1;
    do
    {
      unsigned int v18 = v17;
      if (!v17) {
        break;
      }
    }
    while (!*((void *)v56 + --v17));
    LODWORD(v57) = v18;
    uint64_t v20 = (uint64_t ***)**((void **)v16 + 4);
    if (v20 && (*((unsigned char *)v20 + 23) & 0x10) != 0)
    {
      uint64_t v24 = ***v20;
      uint64_t v25 = *(void *)(v24 + 152);
      uint64_t v26 = *(unsigned int *)(v24 + 168);
      if (v26)
      {
        LODWORD(v27) = (v26 - 1) & ((v20 >> 4) ^ (v20 >> 9));
        int v28 = (uint64_t ****)(v25 + 16 * v27);
        int64_t v29 = *v28;
        if (*v28 != v20)
        {
          int v30 = 1;
          do
          {
            if (v29 == (uint64_t ***)-4096) {
              goto LABEL_18;
            }
            int v31 = v27 + v30++;
            uint64_t v27 = v31 & (v26 - 1);
            int64_t v29 = *(uint64_t ****)(v25 + 16 * v27);
          }
          while (v29 != v20);
          int v28 = (uint64_t ****)(v25 + 16 * v27);
        }
      }
      else
      {
LABEL_18:
        int v28 = (uint64_t ****)(v25 + 16 * v26);
      }
      uint64_t v32 = v28[1];
      unint64_t v33 = (unint64_t)*v32;
      uint64_t v23 = (const char *)(v32 + 2);
      size_t v22 = v33;
      if (v33 >= 0x7FFFFFFFFFFFFFF8) {
        abort();
      }
      if (v22 >= 0x17)
      {
        uint64_t v34 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v22 | 7) != 0x17) {
          uint64_t v34 = v22 | 7;
        }
        BOOL v35 = v10;
        uint64_t v36 = v9;
        uint64_t v37 = v8;
        uint64_t v38 = v34 + 1;
        p_dst = operator new(v34 + 1);
        unint64_t v39 = v38 | 0x8000000000000000;
        uint64_t v8 = v37;
        uint64_t v9 = v36;
        int v10 = v35;
        uint64_t v14 = v43;
        size_t v52 = v22;
        unint64_t v53 = v39;
        std::string __dst = p_dst;
      }
      else
      {
        HIBYTE(v53) = v22;
        p_dst = &__dst;
        if (!v22)
        {
LABEL_11:
          *((unsigned char *)p_dst + v22) = 0;
          sub_1CCE1A0DC(v16, v14, v8, v9, v10, v45, (uint64_t)&v48, (uint64_t)v46, v44);
        }
      }
    }
    else
    {
      HIBYTE(v53) = 14;
      p_dst = &__dst;
      size_t v22 = 14;
      uint64_t v23 = "<unnamed loop>";
    }
    memmove(p_dst, v23, v22);
    goto LABEL_11;
  }
  if (v56 != v58) {
    free(v56);
  }
  if ((v55[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v55[1], 8);
  }
  *(void *)(a4 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a4 = a4 + 32;
  *(void *)(a4 + 8) = a4 + 32;
  *(_DWORD *)(a4 + 24) = 0;
  *(void *)(a4 + 48) = a4 + 80;
  *(void *)(a4 + 56) = a4 + 80;
  *(void *)(a4 + 64) = 2;
  *(_DWORD *)(a4 + 72) = 0;
  *(void *)(a4 + 16) = 0x100000002;
  uint64_t v40 = v47;
  uint64_t v47 = 0;
  if (v40)
  {
    uint64_t v41 = *v40;
    uint64_t *v40 = 0;
    if (v41) {
      (*(void (**)(uint64_t))(*(void *)v41 + 8))(v41);
    }
    MEMORY[0x1D25D9CE0](v40, 0x20C4093837F09);
  }
}

void sub_1CCE19BDC()
{
}

void sub_1CCE19C20(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCE19C58(uint64_t a1, llvm *a2)
{
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::ScalarEvolutionWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::AssumptionCacheTracker::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::DependenceAnalysisWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::OptimizationRemarkEmitterWrapperPass::ID);

  llvm::getLoopAnalysisUsage(a2, v3);
}

uint64_t sub_1CCE19D14(uint64_t a1, llvm *a2)
{
  if ((llvm::LoopPass::skipLoop((llvm::LoopPass *)a1, a2) & 1) == 0)
  {
    uint64_t v5 = *(uint64_t **)(a1 + 8);
    uint64_t v6 = *v5;
    uint64_t v7 = v5[1];
    if (v6 == v7)
    {
LABEL_6:
      uint64_t v8 = 0;
    }
    else
    {
      while (*(char **)v6 != llvm::ScalarEvolutionWrapperPass::ID)
      {
        v6 += 16;
        if (v6 == v7) {
          goto LABEL_6;
        }
      }
      uint64_t v8 = *(void *)(v6 + 8);
    }
    uint64_t v9 = *(Function **)(**((void **)a2 + 4) + 56);
    uint64_t v10 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v8 + 96))(v8, llvm::ScalarEvolutionWrapperPass::ID);
    unint64_t v11 = *(uint64_t **)(a1 + 8);
    uint64_t v12 = *v11;
    uint64_t v13 = v11[1];
    if (v12 == v13)
    {
LABEL_11:
      uint64_t v14 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v12 != &llvm::LoopInfoWrapperPass::ID)
      {
        v12 += 16;
        if (v12 == v13) {
          goto LABEL_11;
        }
      }
      uint64_t v14 = *(void *)(v12 + 8);
    }
    uint64_t v15 = *(void *)(v10 + 32);
    uint64_t v16 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v14 + 96))(v14, &llvm::LoopInfoWrapperPass::ID);
    unsigned int v17 = *(uint64_t **)(a1 + 8);
    uint64_t v18 = *v17;
    uint64_t v19 = v17[1];
    if (v18 == v19)
    {
LABEL_16:
      uint64_t v20 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v18 != &llvm::DependenceAnalysisWrapperPass::ID)
      {
        v18 += 16;
        if (v18 == v19) {
          goto LABEL_16;
        }
      }
      uint64_t v20 = *(void *)(v18 + 8);
    }
    uint64_t v21 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v20 + 96))(v20, &llvm::DependenceAnalysisWrapperPass::ID);
    size_t v22 = *(uint64_t **)(a1 + 8);
    uint64_t v23 = *v22;
    uint64_t v24 = v22[1];
    if (v23 == v24)
    {
LABEL_21:
      uint64_t v25 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v23 != &llvm::DominatorTreeWrapperPass::ID)
      {
        v23 += 16;
        if (v23 == v24) {
          goto LABEL_21;
        }
      }
      uint64_t v25 = *(void *)(v23 + 8);
    }
    uint64_t v26 = *(void *)(v21 + 32);
    uint64_t v27 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v25 + 96))(v25, &llvm::DominatorTreeWrapperPass::ID);
    int v28 = *(uint64_t **)(a1 + 8);
    uint64_t v29 = *v28;
    uint64_t v30 = v28[1];
    if (v29 == v30)
    {
LABEL_26:
      uint64_t v31 = 0;
    }
    else
    {
      while (*(char **)v29 != llvm::TargetTransformInfoWrapperPass::ID)
      {
        v29 += 16;
        if (v29 == v30) {
          goto LABEL_26;
        }
      }
      uint64_t v31 = *(void *)(v29 + 8);
    }
    uint64_t v32 = v16 + 32;
    uint64_t v33 = v27 + 32;
    uint64_t v34 = (llvm::TargetTransformInfoWrapperPass *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v31 + 96))(v31, llvm::TargetTransformInfoWrapperPass::ID);
    TTI = llvm::TargetTransformInfoWrapperPass::getTTI(v34, v9);
    uint64_t v36 = *(uint64_t **)(a1 + 8);
    uint64_t v37 = *v36;
    uint64_t v38 = v36[1];
    if (v37 == v38)
    {
LABEL_31:
      uint64_t v39 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v37 != &llvm::OptimizationRemarkEmitterWrapperPass::ID)
      {
        v37 += 16;
        if (v37 == v38) {
          goto LABEL_31;
        }
      }
      uint64_t v39 = *(void *)(v37 + 8);
    }
    uint64_t v40 = *(void *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v39 + 96))(v39, &llvm::OptimizationRemarkEmitterWrapperPass::ID)+ 32);
    uint64_t v41 = *(uint64_t **)(a1 + 8);
    uint64_t v42 = *v41;
    uint64_t v43 = v41[1];
    if (v42 == v43)
    {
LABEL_36:
      uint64_t v44 = 0;
    }
    else
    {
      while (*(char **)v42 != llvm::AssumptionCacheTracker::ID)
      {
        v42 += 16;
        if (v42 == v43) {
          goto LABEL_36;
        }
      }
      uint64_t v44 = *(void *)(v42 + 8);
    }
    uint64_t v45 = (llvm::AssumptionCacheTracker *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v44 + 96))(v44, llvm::AssumptionCacheTracker::ID);
    uint64_t AssumptionCache = llvm::AssumptionCacheTracker::getAssumptionCache(v45, (llvm::Function *)v9);
    sub_1CCE1A0DC(a2, v33, v32, v15, TTI, AssumptionCache, v26, v40, *(_DWORD *)(a1 + 28));
  }
  return 0;
}

void sub_1CCE1A0DC(llvm *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = 0;
  memset(v14, 0, sizeof(v14));
  llvm::gatherUnrollingPreferences(a1, a4, a5, a8, a9, 0, (uint64_t)v14, 0, 0, 0, 0, 0, 0, 0);
  LODWORD(v13[0]) = 0;
  WORD2(v13[0]) = 1;
  BYTE6(v13[0]) = 1;
  (*(void (**)(void, llvm *, uint64_t, void *))(*(void *)*a5 + 192))(*a5, a1, a4, v13);
  v13[37] = v13[0];
  llvm::hasUnrollAndJamTransformation(a1, v12);
}

void sub_1CCE1A878(llvm::Loop *a1)
{
}

uint64_t sub_1CCE1A924()
{
  LODWORD(v4) = 1;
  *(void *)&long long v1 = "Allows loops to be unroll-and-jammed.";
  *((void *)&v1 + 1) = 37;
  sub_1CD4C1500((uint64_t)&unk_1EBCF6520, "allow-unroll-and-jam", &v4, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF6520, &dword_1CB82C000);
  LODWORD(v4) = 1;
  *(void *)&long long v1 = "Use this unroll count for all loops including those with unroll_and_jam_count pragma values, for testing purposes";
  *((void *)&v1 + 1) = 113;
  sub_1CD513224((uint64_t)&unk_1EBCF65E0, "unroll-and-jam-count", &v4, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF65E0, &dword_1CB82C000);
  int v2 = 1;
  int v3 = 60;
  uint64_t v4 = &v3;
  *(void *)&long long v1 = "Threshold to use for inner loop when doing unroll and jam.";
  *((void *)&v1 + 1) = 58;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF66A0, "unroll-and-jam-threshold", &v4, &v2, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF66A0, &dword_1CB82C000);
  int v2 = 1;
  int v3 = 1024;
  uint64_t v4 = &v3;
  *(void *)&long long v1 = "Unrolled size limit for loops with an unroll_and_jam(full) or unroll_count pragma.";
  *((void *)&v1 + 1) = 82;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF6760, "pragma-unroll-and-jam-threshold", &v4, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF6760, &dword_1CB82C000);
}

void sub_1CCE1AAA0(llvm *a1)
{
  llvm::initializeAssumptionCacheTrackerPass((uint64_t)a1);
  llvm::initializeLoopPassPass(a1, v2);
  llvm::initializeTargetTransformInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeLegacyDivergenceAnalysisPass(a1, v3);
  llvm::initializeMemorySSAWrapperPassPass(a1, v4);
  operator new();
}

uint64_t sub_1CCE1AB60(uint64_t a1, char a2, char a3)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF6820;
  *(_DWORD *)(a1 + 24) = 1;
  *(void *)a1 = &unk_1F263F6C0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = a1 + 88;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 120) = dword_1EBCF68B0;
  *(unsigned char *)(a1 + 128) = a2;
  *(unsigned char *)(a1 + 129) = 0;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 224) = 0;
  *(void *)(a1 + 200) = &unk_1F26061F8;
  *(_WORD *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(unsigned char *)(a1 + 288) = a3;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF6828, memory_order_acquire) != -1)
  {
    v7[0] = sub_1CCE1AAA0;
    v7[1] = &PassRegistry;
    uint64_t v6 = v7;
    std::__call_once(&qword_1EBCF6828, &v6, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CCE1AC84()
{
}

void sub_1CCE1ACC8(uint64_t a1)
{
  *(void *)a1 = &unk_1F263F6C0;
  int v2 = *(void **)(a1 + 264);
  if (v2)
  {
    *(void *)(a1 + 272) = v2;
    operator delete(v2);
  }
  int v3 = *(void **)(a1 + 240);
  if (v3)
  {
    *(void *)(a1 + 248) = v3;
    operator delete(v3);
  }
  *(void *)(a1 + 200) = &unk_1F26065B0;
  sub_1CC0CADD4((uint64_t *)(a1 + 208));
  uint64_t v4 = *(void *)(a1 + 168);
  *(void *)(a1 + 168) = 0;
  if (v4)
  {
    sub_1CD3C5048(v4 + 584, *(void **)(v4 + 592));
    uint64_t v5 = *(void **)(v4 + 504);
    if (v5 != (void *)(v4 + 520)) {
      free(v5);
    }
    uint64_t v6 = *(void **)(v4 + 416);
    if (v6 != *(void **)(v4 + 408)) {
      free(v6);
    }
    sub_1CC0BD0FC((char **)(v4 + 8));
    MEMORY[0x1D25D9CE0](v4, 0x10E0C40B8556DDDLL);
  }
  sub_1CCE1D5D8(*(void **)(a1 + 88));
  uint64_t v7 = *(void **)(a1 + 56);
  if (v7)
  {
    *(void *)(a1 + 64) = v7;
    operator delete(v7);
  }

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1CCE1ADDC(uint64_t a1)
{
  sub_1CCE1ACC8(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCE1AE14(uint64_t a1, llvm *a2)
{
  uint64_t v4 = (uint64_t)a2 + 112;
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)llvm::LazyBlockFrequencyInfoPass::ID);
  sub_1CB843600((uint64_t)a2, v4, (uint64_t)&llvm::LazyBranchProbabilityInfoPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::AssumptionCacheTracker::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::MemorySSAWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, v4, (uint64_t)&llvm::MemorySSAWrapperPass::ID);
  if (*(unsigned char *)(a1 + 288)) {
    sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::LegacyDivergenceAnalysis::ID);
  }

  llvm::getLoopAnalysisUsage(a2, v5);
}

void sub_1CCE1AEEC(uint64_t a1)
{
  int v3 = (uint64_t *)(a1 + 88);
  int v2 = *(uint64_t **)(a1 + 88);
  if (v2)
  {
    unint64_t v4 = v3[6];
    uint64_t v5 = v2;
    uint64_t v6 = v3;
    do
    {
      unint64_t v7 = v5[4];
      BOOL v8 = v7 >= v4;
      if (v7 >= v4) {
        uint64_t v9 = (uint64_t **)v5;
      }
      else {
        uint64_t v9 = (uint64_t **)(v5 + 1);
      }
      if (v8) {
        uint64_t v6 = v5;
      }
      uint64_t v5 = *v9;
    }
    while (*v9);
    if (v6 != v3 && v6[4] <= v4)
    {
      *(_DWORD *)(a1 + 120) += (*((_DWORD *)v6 + 11) + *((_DWORD *)v6 + 10)) * *((_DWORD *)v6 + 12);
      uint64_t v10 = (uint64_t *)v6[1];
      if (v10)
      {
        do
        {
          uint64_t v12 = v10;
          uint64_t v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        unint64_t v11 = v6;
        do
        {
          uint64_t v12 = (uint64_t *)v11[2];
          BOOL v13 = *v12 == (void)v11;
          unint64_t v11 = v12;
        }
        while (!v13);
      }
      if (*(uint64_t **)(a1 + 80) == v6) {
        *(void *)(a1 + 80) = v12;
      }
      --*(void *)(a1 + 96);
      sub_1CB91F7C8(v2, v6);
      sub_1CD776ECC((_DWORD *)v6 + 14);
      MEMORY[0x1D25D9CD0](v6[7], 8);
      operator delete(v6);
    }
  }
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
}

uint64_t sub_1CCE1AFE4(llvm::LoopPass *a1, const llvm::Loop *a2, uint64_t a3)
{
  if ((llvm::LoopPass::skipLoop(a1, a2) & 1) == 0)
  {
    unint64_t v7 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v8 = *v7;
    uint64_t v9 = v7[1];
    if (v8 == v9)
    {
LABEL_6:
      uint64_t v10 = 0;
    }
    else
    {
      while (*(char **)v8 != llvm::AssumptionCacheTracker::ID)
      {
        v8 += 16;
        if (v8 == v9) {
          goto LABEL_6;
        }
      }
      uint64_t v10 = *(void *)(v8 + 8);
    }
    unint64_t v11 = (llvm::AssumptionCacheTracker *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v10 + 96))(v10, llvm::AssumptionCacheTracker::ID);
    *((void *)a1 + 6) = llvm::AssumptionCacheTracker::getAssumptionCache(v11, *(llvm::Function **)(**((void **)a2 + 4) + 56));
    uint64_t v12 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v13 = *v12;
    uint64_t v14 = v12[1];
    if (v13 == v14)
    {
LABEL_11:
      uint64_t v15 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v13 != &llvm::LoopInfoWrapperPass::ID)
      {
        v13 += 16;
        if (v13 == v14) {
          goto LABEL_11;
        }
      }
      uint64_t v15 = *(void *)(v13 + 8);
    }
    *((void *)a1 + 4) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v15 + 96))(v15, &llvm::LoopInfoWrapperPass::ID)+ 32;
    *((void *)a1 + 5) = a3;
    uint64_t v16 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v17 = *v16;
    uint64_t v18 = v16[1];
    if (v17 == v18)
    {
LABEL_16:
      uint64_t v19 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v17 != &llvm::DominatorTreeWrapperPass::ID)
      {
        v17 += 16;
        if (v17 == v18) {
          goto LABEL_16;
        }
      }
      uint64_t v19 = *(void *)(v17 + 8);
    }
    *((void *)a1 + 18) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v19 + 96))(v19, &llvm::DominatorTreeWrapperPass::ID)+ 32;
    uint64_t v20 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v21 = *v20;
    uint64_t v22 = v20[1];
    if (v21 == v22)
    {
LABEL_21:
      uint64_t v23 = 0;
    }
    else
    {
      while (*(char **)v21 != llvm::AAResultsWrapperPass::ID)
      {
        v21 += 16;
        if (v21 == v22) {
          goto LABEL_21;
        }
      }
      uint64_t v23 = *(void *)(v21 + 8);
    }
    *((void *)a1 + 20) = *(void *)((*(uint64_t (**)(uint64_t, char *))(*(void *)v23 + 96))(v23, llvm::AAResultsWrapperPass::ID)+ 32);
    uint64_t v24 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v25 = *v24;
    uint64_t v26 = v24[1];
    if (v25 == v26)
    {
LABEL_26:
      uint64_t v27 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v25 != &llvm::MemorySSAWrapperPass::ID)
      {
        v25 += 16;
        if (v25 == v26) {
          goto LABEL_26;
        }
      }
      uint64_t v27 = *(void *)(v25 + 8);
    }
    *((void *)a1 + 19) = *(void *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v27 + 96))(v27, &llvm::MemorySSAWrapperPass::ID)+ 32);
    operator new();
  }
  return 0;
}

void sub_1CCE1D5D8(void *a1)
{
  if (a1)
  {
    sub_1CCE1D5D8(*a1);
    sub_1CCE1D5D8(a1[1]);
    sub_1CD776ECC((_DWORD *)a1 + 14);
    MEMORY[0x1D25D9CD0](a1[7], 8);
    operator delete(a1);
  }
}

unsigned __int8 *sub_1CCE1D638(unsigned __int8 *a1, uint64_t a2, unsigned char *a3, uint64_t *a4)
{
  v7[0] = 0;
  v7[1] = 0;
  int v8 = 0;
  int v6 = 0;
  unint64_t v4 = sub_1CCE22CB8(a1, a2, a3, &v6, (uint64_t)v7, a4);
  MEMORY[0x1D25D9CD0](v7[0], 8);
  return v4;
}

uint64_t sub_1CCE1D694(uint64_t a1, const llvm::Value *a2, const llvm::APInt *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v401 = *MEMORY[0x1E4F143B8];
  if (!**(_DWORD **)(a1 + 112)) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 288))
  {
    uint64_t v30 = *(uint64_t **)(a1 + 8);
    uint64_t v31 = *v30;
    uint64_t v32 = v30[1];
    if (v31 == v32)
    {
LABEL_14:
      uint64_t v33 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v31 != &llvm::LegacyDivergenceAnalysis::ID)
      {
        v31 += 16;
        if (v31 == v32) {
          goto LABEL_14;
        }
      }
      uint64_t v33 = *(void *)(v31 + 8);
    }
    uint64_t v41 = (llvm::LegacyDivergenceAnalysis *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v33 + 96))(v33, &llvm::LegacyDivergenceAnalysis::ID);
    if (llvm::LegacyDivergenceAnalysis::isDivergent(v41, a2)) {
      return 0;
    }
  }
  uint64_t v13 = *(uint64_t **)(a1 + 136);
  uint64_t v381 = *(void *)(*(void *)(a1 + 176) + 56);
  uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*(void *)(a1 + 8) + 24), llvm::ScalarEvolutionWrapperPass::ID, 1);
  if (AnalysisPass)
  {
    uint64_t v16 = (*(uint64_t (**)(uint64_t, char *))(*(void *)AnalysisPass + 96))(AnalysisPass, llvm::ScalarEvolutionWrapperPass::ID);
    if (v16)
    {
      uint64_t v17 = *(int32x2_t **)(v16 + 32);
      uint64_t v18 = (const llvm::Loop *)v13;
      do
      {
        uint64_t v19 = v18;
        uint64_t v18 = *(const llvm::Loop **)v18;
      }
      while (v18);
      llvm::ScalarEvolution::forgetLoop(v17, v19);
    }
  }
  uint64_t v372 = a5;
  *(void *)(a1 + 248) = *(void *)(a1 + 240);
  *(void *)(a1 + 272) = *(void *)(a1 + 264);
  uint64_t v21 = *(llvm::BasicBlock **)(a1 + 176);
  uint64_t v20 = *(llvm **)(a1 + 184);
  uint64_t v22 = *(llvm::LoopInfo **)(a1 + 168);
  uint64_t v23 = *(llvm::BasicBlock **)(a1 + 144);
  uint64_t v24 = *(llvm::DominatorTree **)(a1 + 32);
  v400[8] = 257;
  uint64_t v25 = llvm::SplitEdge(v20, v21, v23, v24, v22, (llvm::MemorySSAUpdater *)&v398, v15);
  uint64_t v26 = v25;
  int v28 = *(uint64_t **)(a1 + 248);
  unint64_t v27 = *(void *)(a1 + 256);
  uint64_t v375 = a3;
  uint64_t v376 = v13;
  uint64_t v373 = a4;
  uint64_t v374 = a2;
  uint64_t __p = (char *)v25;
  if ((unint64_t)v28 >= v27)
  {
    uint64_t v34 = *(void **)(a1 + 240);
    uint64_t v35 = v28 - v34;
    unint64_t v36 = v35 + 1;
    if ((unint64_t)(v35 + 1) >> 61) {
      goto LABEL_514;
    }
    uint64_t v37 = v27 - (void)v34;
    if (v37 >> 2 > v36) {
      unint64_t v36 = v37 >> 2;
    }
    if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v38 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v38 = v36;
    }
    if (v38)
    {
      if (v38 >> 61) {
        goto LABEL_515;
      }
      uint64_t v39 = v25;
      uint64_t v40 = (char *)operator new(8 * v38);
      uint64_t v26 = v39;
    }
    else
    {
      uint64_t v40 = 0;
    }
    uint64_t v42 = (uint64_t *)&v40[8 * v35];
    uint64_t v43 = &v40[8 * v38];
    uint64_t *v42 = v26;
    uint64_t v29 = (char *)(v42 + 1);
    if (v28 == v34)
    {
      uint64_t v13 = v376;
    }
    else
    {
      uint64_t v13 = v376;
      do
      {
        uint64_t v44 = *--v28;
        *--uint64_t v42 = v44;
      }
      while (v28 != v34);
      int v28 = *(uint64_t **)(a1 + 240);
    }
    *(void *)(a1 + 240) = v42;
    *(void *)(a1 + 248) = v29;
    *(void *)(a1 + 256) = v43;
    if (v28) {
      operator delete(v28);
    }
  }
  else
  {
    *int v28 = v25;
    uint64_t v29 = (char *)(v28 + 1);
  }
  uint64_t v383 = a1;
  *(void *)(a1 + 248) = v29;
  unsigned int v46 = (char *)v13[4];
  uint64_t v45 = (unsigned char *)v13[5];
  int64_t v47 = v45 - v46;
  uint64_t v371 = a6;
  if (v45 - v46 >= 1)
  {
    uint64_t v48 = v47 >> 3;
    uint64_t v49 = *(void *)(v383 + 240);
    uint64_t v50 = (uint64_t)&v29[-v49];
    unsigned int v51 = (unsigned char *)(v49 + ((unint64_t)&v29[-v49] & 0xFFFFFFFFFFFFFFF8));
    uint64_t v52 = *(void *)(v383 + 256);
    if (v47 >> 3 <= (v52 - (uint64_t)v29) >> 3)
    {
      uint64_t v57 = (v29 - v51) >> 3;
      if (v57 >= v48)
      {
        uint64_t v59 = v29;
      }
      else
      {
        unsigned int v58 = &v46[8 * v57];
        memmove(v29, v58, v45 - v58);
        uint64_t v59 = &v29[v45 - v58];
        *(void *)(v383 + 248) = v59;
        if (v29 - v51 < 1) {
          goto LABEL_67;
        }
        uint64_t v45 = v58;
      }
      int v60 = &v51[8 * v48];
      int v61 = &v59[-8 * v48];
      BOOL v62 = v59;
      if (v61 < v29)
      {
        BOOL v62 = v59;
        do
        {
          uint64_t v63 = *(void *)v61;
          v61 += 8;
          *v62++ = v63;
        }
        while (v61 < v29);
      }
      *(void *)(v383 + 248) = v62;
      if (v59 != v60) {
        memmove(&v59[-8 * ((v59 - v60) >> 3)], v51, v59 - v60);
      }
      if (v45 != v46) {
        memmove(v51, v46, v45 - v46);
      }
    }
    else
    {
      a6 = v50 >> 3;
      unint64_t v53 = (v50 >> 3) + v48;
      if (v53 >> 61) {
        goto LABEL_514;
      }
      uint64_t v54 = v52 - v49;
      if (v54 >> 2 > v53) {
        unint64_t v53 = v54 >> 2;
      }
      if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v55 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v55 = v53;
      }
      if (v55)
      {
        if (v55 >> 61) {
          goto LABEL_515;
        }
        uint64_t v56 = (char *)operator new(8 * v55);
      }
      else
      {
        uint64_t v56 = 0;
      }
      unsigned int v64 = &v56[8 * a6];
      memcpy(v64, v46, v47);
      unint64_t v65 = v50 & 0xFFFFFFFFFFFFFFF8;
      if ((unint64_t)v50 >= 8)
      {
        uint64_t v68 = 8 * a6;
        uint64_t v67 = (void *)v383;
        do
        {
          *(void *)&v56[v68 - 8] = *(void *)(v49 - 8 + v68);
          v68 -= 8;
        }
        while (v68);
        uint64_t v29 = *(char **)(v383 + 248);
        unsigned int v64 = v56;
      }
      else
      {
        uint64_t v67 = (void *)v383;
      }
      unint64_t v66 = &v56[v47];
      uint64_t v69 = &v56[v47 + v65];
      if (v29 != v51) {
        memmove(&v66[v65], v51, v29 - v51);
      }
      uint64_t v70 = (void *)v67[30];
      v67[30] = v64;
      v67[31] = &v69[v29 - v51];
      v67[32] = &v56[8 * v55];
      if (v70) {
        operator delete(v70);
      }
    }
  }
LABEL_67:
  v398 = (char *)v400;
  uint64_t v399 = 0x800000000;
  sub_1CC082408(v376, (uint64_t)&v398);
  uint64_t v71 = v399;
  if (v399)
  {
    uint64_t v72 = 0;
    do
    {
      uint64_t v73 = *(void *)&v398[8 * v72];
      for (uint64_t i = *(void *)(v73 + 8); i; uint64_t i = *(void *)(i + 8))
      {
        uint64_t v75 = *(void *)(i + 24);
        unsigned int v76 = *(unsigned __int8 *)(v75 + 16);
        if (v75) {
          BOOL v77 = v76 >= 0x1C;
        }
        else {
          BOOL v77 = 0;
        }
        if (v77 && v76 - 29 < 0xB) {
          break;
        }
      }
      uint64_t v393 = &v395;
      *(void *)uint64_t v394 = 0x400000000;
      sub_1CBF846A4((uint64_t)&v393, i, 0);
      sub_1CD1271B8((uint64_t **)v73, (int)v393, v394[0], ".us-lcssa", 0, *(void *)(v383 + 144), *(void *)(v383 + 32), *(void *)(v383 + 168), 1);
      if (v393 != &v395) {
        free(v393);
      }
      ++v72;
    }
    while (v72 != v71);
  }
  LODWORD(v399) = 0;
  sub_1CC082408(v376, (uint64_t)&v398);
  uint64_t v79 = v399;
  if (v399)
  {
    uint64_t v80 = v398;
    uint64_t v81 = *(void *)(v383 + 240);
    uint64_t v82 = *(uint64_t **)(v383 + 248);
    uint64_t v83 = (uint64_t)v82 - v81;
    uint64_t v84 = (char *)(v81 + (((unint64_t)v82 - v81) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v85 = *(void *)(v383 + 256);
    if (v399 <= (v85 - (uint64_t)v82) >> 3)
    {
      unint64_t v90 = &v398[8 * v399];
      uint64_t v91 = ((char *)v82 - v84) >> 3;
      if (v91 >= v399)
      {
        BOOL v93 = *(char **)(v383 + 248);
      }
      else
      {
        unsigned int v92 = &v398[8 * v91];
        memmove(*(void **)(v383 + 248), v92, v90 - v92);
        BOOL v93 = (char *)v82 + v90 - v92;
        *(void *)(v383 + 248) = v93;
        if ((char *)v82 - v84 < 1) {
          goto LABEL_113;
        }
        unint64_t v90 = v92;
      }
      uint64_t v94 = &v84[8 * v79];
      uint64_t v95 = (uint64_t *)&v93[-8 * v79];
      uint64_t v96 = v93;
      if (v95 < v82)
      {
        uint64_t v96 = v93;
        do
        {
          uint64_t v97 = *v95++;
          *(void *)uint64_t v96 = v97;
          v96 += 8;
        }
        while (v95 < v82);
      }
      *(void *)(v383 + 248) = v96;
      if (v93 != v94) {
        memmove(&v93[-8 * ((v93 - v94) >> 3)], v84, v93 - v94);
      }
      if (v90 != v80) {
        memmove(v84, v80, v90 - v80);
      }
    }
    else
    {
      a6 = v83 >> 3;
      unint64_t v86 = (v83 >> 3) + v399;
      if (v86 >> 61) {
        goto LABEL_514;
      }
      uint64_t v87 = v85 - v81;
      if (v87 >> 2 > v86) {
        unint64_t v86 = v87 >> 2;
      }
      if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v88 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v88 = v86;
      }
      if (v88)
      {
        if (v88 >> 61) {
          goto LABEL_515;
        }
        unint64_t v89 = (char *)operator new(8 * v88);
      }
      else
      {
        unint64_t v89 = 0;
      }
      uint64_t v98 = &v89[8 * a6];
      memcpy(v98, v80, 8 * v79);
      if ((unint64_t)v83 >= 8)
      {
        uint64_t v99 = 8 * a6;
        do
        {
          *(void *)&v89[v99 - 8] = *(void *)(v81 - 8 + v99);
          v99 -= 8;
        }
        while (v99);
        uint64_t v82 = *(uint64_t **)(v383 + 248);
        uint64_t v98 = v89;
      }
      uint64_t v100 = &v89[8 * v79 + (v83 & 0xFFFFFFFFFFFFFFF8)];
      if (v82 != (uint64_t *)v84) {
        memmove(v100, v84, (char *)v82 - v84);
      }
      int v101 = *(void **)(v383 + 240);
      *(void *)(v383 + 240) = v98;
      *(void *)(v383 + 248) = &v100[(char *)v82 - v84];
      *(void *)(v383 + 256) = &v89[8 * v88];
      if (v101) {
        operator delete(v101);
      }
    }
  }
LABEL_113:
  unint64_t v102 = v383;
  int64_t v103 = *(void *)(v383 + 248) - *(void *)(v383 + 240);
  uint64_t v104 = v103 >> 3;
  BOOL v105 = *(unsigned char **)(v383 + 264);
  if (v103 >> 3 > (unint64_t)((uint64_t)(*(void *)(v383 + 280) - (void)v105) >> 3))
  {
    if (v103 < 0) {
      goto LABEL_514;
    }
    uint64_t v106 = *(unsigned char **)(v383 + 272);
    unsigned int v107 = (char *)operator new(v103);
    uint64_t v108 = &v107[(v106 - v105) & 0xFFFFFFFFFFFFFFF8];
    int v109 = v108;
    if (v106 != v105)
    {
      int v109 = &v107[(v106 - v105) & 0xFFFFFFFFFFFFFFF8];
      do
      {
        uint64_t v110 = *((void *)v106 - 1);
        v106 -= 8;
        *((void *)v109 - 1) = v110;
        v109 -= 8;
      }
      while (v106 != v105);
    }
    *(void *)(v383 + 264) = v109;
    *(void *)(v383 + 272) = v108;
    *(void *)(v383 + 280) = &v107[8 * v104];
    if (v105) {
      operator delete(v105);
    }
  }
  unsigned int v395 = 128;
  unsigned int v111 = operator new(0x2000uLL, (std::align_val_t)8uLL);
  uint64_t v393 = v111;
  *(void *)uint64_t v394 = 0;
  uint64_t v388 = 2;
  uint64_t v389 = 0;
  uint64_t v390 = -4096;
  int8x8_t v391 = 0;
  unint64_t v387 = (unint64_t)&unk_1F2615EC8;
  if (v395)
  {
    BOOL v112 = 0;
    unint64_t v113 = (unint64_t)v395 << 6;
    char v114 = v111 + 2;
    do
    {
      uint64_t v115 = v388;
      uint64_t v116 = v390;
      *(v114 - 1) = v388 & 6;
      *char v114 = 0;
      v114[1] = v116;
      if (v116 != -4096 && v116 != -8192 && v116 != 0)
      {
        *char v114 = *(void *)(v115 & 0xFFFFFFFFFFFFFFF8);
        *(void *)(v115 & 0xFFFFFFFFFFFFFFF8) = v114 - 1;
        *(v114 - 1) = v115 & 0xFFFFFFFFFFFFFFFELL;
        if (*v114) {
          *(void *)*char v114 = *(void *)*v114 & 7 | (unint64_t)(v111 + 2);
        }
        BOOL v112 = v391;
        unint64_t v102 = v383;
      }
      *(v114 - 2) = &unk_1F2615EC8;
      v114[2] = v112;
      v114 += 8;
      v111 += 8;
      v113 -= 64;
    }
    while (v113);
    if (v390 != -8192 && v390 != -4096 && v390)
    {
      unint64_t v360 = v388 & 0xFFFFFFFFFFFFFFF8;
      *(void *)(v388 & 0xFFFFFFFFFFFFFFF8) = v389;
      if (v389)
      {
        *(void *)uint64_t v389 = *(void *)v389 & 7 | v360;
      }
      else
      {
        uint64_t v361 = v390;
        uint64_t v362 = ***(int32x2_t ****)v390;
        unint64_t v363 = (unint64_t)v362[303];
        unint64_t v102 = v383;
        if (v363 > v360) {
          goto LABEL_135;
        }
        uint64_t v364 = v362[305].u32[0];
        if (v363 + 16 * v364 <= v360) {
          goto LABEL_135;
        }
        unsigned int v365 = v364 - 1;
        LODWORD(v366) = v365 & ((v390 >> 4) ^ (v390 >> 9));
        uint64_t v367 = (uint64_t *)(v363 + 16 * v366);
        uint64_t v368 = *v367;
        if (v390 == *v367)
        {
LABEL_525:
          *uint64_t v367 = -8192;
          v362[304] = vadd_s32(v362[304], (int32x2_t)0x1FFFFFFFFLL);
          uint64_t v361 = v390;
        }
        else
        {
          int v369 = 1;
          while (v368 != -4096)
          {
            int v370 = v366 + v369++;
            uint64_t v366 = v370 & v365;
            uint64_t v368 = *(void *)(v363 + 16 * v366);
            if (v390 == v368)
            {
              uint64_t v367 = (uint64_t *)(v363 + 16 * v366);
              goto LABEL_525;
            }
          }
        }
        *(unsigned char *)(v361 + 17) &= ~1u;
      }
      unint64_t v102 = v383;
    }
  }
LABEL_135:
  LOBYTE(v396[0]) = 0;
  char v397 = 0;
  if (((*(void *)(v102 + 248) - *(void *)(v102 + 240)) & 0x7FFFFFFF8) != 0)
  {
    unint64_t v387 = (unint64_t)".us";
    LOWORD(v391) = 259;
    llvm::CloneBasicBlock();
  }
  unsigned int v118 = (uint64_t *)(v381 + 72);
  int v119 = (uint64_t *)(__p + 24);
  uint64_t v120 = (uint64_t *)(**(void **)(v102 + 264) + 24);
  if (v120 != (uint64_t *)(v381 + 72) && v119 != v118)
  {
    uint64_t v122 = *v118;
    uint64_t v123 = *v120;
    *(void *)(v123 + 8) = v118;
    *unsigned int v118 = v123;
    uint64_t v124 = *v119;
    *(void *)(v122 + 8) = v119;
    *uint64_t v120 = v124;
    *(void *)(v124 + 8) = v120;
    uint64_t *v119 = v122;
  }
  uint64_t v125 = llvm::cloneLoop(v376, *v376, (uint64_t)&v393, *(void *)(v102 + 32), *(llvm::LPPassManager **)(v102 + 40));
  uint64_t v127 = v125;
  unint64_t v128 = *(void *)(v102 + 88);
  unsigned int v129 = (uint64_t **)(v102 + 88);
  unint64_t v130 = v102 + 88;
  if (v128)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v130 = v128;
        unint64_t v131 = *(void *)(v128 + 32);
        if (v131 <= (unint64_t)v125) {
          break;
        }
        unint64_t v128 = *(void *)v130;
        unsigned int v129 = (uint64_t **)v130;
        if (!*(void *)v130) {
          goto LABEL_149;
        }
      }
      if (v131 >= (unint64_t)v125) {
        break;
      }
      unint64_t v128 = *(void *)(v130 + 8);
      if (!v128)
      {
        unsigned int v129 = (uint64_t **)(v130 + 8);
        goto LABEL_149;
      }
    }
  }
  else
  {
LABEL_149:
    int v132 = (char *)operator new(0x50uLL);
    unint64_t v387 = (unint64_t)v132;
    uint64_t v388 = v102 + 88;
    *((void *)v132 + 4) = v127;
    *(_OWORD *)(v132 + 40) = 0u;
    *(_OWORD *)(v132 + 56) = 0u;
    *((void *)v132 + 9) = 0;
    LOBYTE(v389) = 1;
    *(void *)int v132 = 0;
    *((void *)v132 + 1) = 0;
    *((void *)v132 + 2) = v130;
    *unsigned int v129 = (uint64_t *)v132;
    unint64_t v133 = **(void **)(v102 + 80);
    if (v133)
    {
      *(void *)(v102 + 80) = v133;
      unsigned int v134 = *v129;
    }
    else
    {
      unsigned int v134 = (uint64_t *)v132;
    }
    sub_1CB8358B8(*(uint64_t **)(v102 + 88), v134);
    ++*(void *)(v102 + 96);
    unint64_t v130 = v387;
    unint64_t v387 = 0;
    sub_1CCE20C78((uint64_t)&v387);
  }
  unint64_t v135 = *(void *)(v102 + 112);
  uint64_t v137 = v135 + 16;
  uint64_t v136 = *(void *)(v135 + 16);
  unsigned int v138 = *(_DWORD *)v135 - 1;
  ++*(_DWORD *)(v135 + 4);
  *(_DWORD *)(v130 + 40) = v138 >> 1;
  *(_DWORD *)(v130 + 44) = 0;
  *(_DWORD *)unint64_t v135 = v138 - (v138 >> 1);
  *(_DWORD *)(v130 + 48) = *(_DWORD *)(v135 + 8);
  unsigned int v139 = *(_DWORD *)(v135 + 32);
  uint64_t v140 = v136 + 104 * v139;
  if (*(_DWORD *)(v135 + 24))
  {
    if (v139)
    {
      uint64_t v141 = 104 * v139;
      uint64_t v142 = v136;
      while ((*(void *)v142 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v142 += 104;
        v141 -= 104;
        if (!v141) {
          goto LABEL_158;
        }
      }
    }
    else
    {
      uint64_t v142 = v136;
    }
  }
  else
  {
LABEL_158:
    uint64_t v142 = v136 + 104 * v139;
  }
  int v143 = (uint64_t *)(v136 + 104 * v139);
  if ((uint64_t *)v142 != v143)
  {
    unint64_t v102 = (unint64_t)&v387;
    a6 = (uint64_t)&v388;
    uint64_t v144 = v130 + 56;
    while (1)
    {
      uint64_t v384 = 0;
      uint64_t v145 = *(void *)v142;
      uint64_t v384 = *(void *)v142;
      if (!v395) {
        goto LABEL_168;
      }
      uint64_t v146 = (v395 - 1) & ((v145 >> 4) ^ (v145 >> 9));
      unint64_t v147 = (char *)v393 + 64 * v146;
      uint64_t v148 = v147[3];
      if (v145 != v148) {
        break;
      }
LABEL_169:
      unint64_t v387 = 6;
      if (v147 == (void *)((char *)v393 + 64 * (unint64_t)v395))
      {
        uint64_t v151 = 0;
        unsigned int v152 = 0;
        uint64_t v388 = 0;
        uint64_t v389 = 0;
      }
      else
      {
        uint64_t v151 = 0;
        unsigned int v152 = (const char *)v147[7];
        uint64_t v388 = 0;
        uint64_t v389 = (char *)v152;
        if (v152 != (const char *)-8192 && v152 != (const char *)-4096 && v152 != 0)
        {
          unint64_t v154 = v147[5] & 0xFFFFFFFFFFFFFFF8;
          uint64_t v388 = *(void *)v154;
          *(void *)unint64_t v154 = &v387;
          unint64_t v387 = v154 | 6;
          uint64_t v151 = v388;
          if (v388) {
            *(void *)uint64_t v388 = *(void *)v388 & 7 | (unint64_t)&v388;
          }
          unsigned int v152 = v389;
        }
      }
      if (v152 != (const char *)-8192 && v152 != (const char *)-4096 && v152 != 0)
      {
        unint64_t v159 = v387 & 0xFFFFFFFFFFFFFFF8;
        *(void *)(v387 & 0xFFFFFFFFFFFFFFF8) = v151;
        if (v388)
        {
          *(void *)uint64_t v388 = *(void *)v388 & 7 | v159;
        }
        else
        {
          uint64_t v160 = v389;
          unsigned int v161 = ***(int32x2_t ****)v389;
          unint64_t v162 = (unint64_t)v161[303];
          if (v162 <= v159)
          {
            uint64_t v163 = v161[305].u32[0];
            if (v162 + 16 * v163 > v159)
            {
              unsigned int v164 = v163 - 1;
              LODWORD(v165) = v164 & ((v389 >> 4) ^ (v389 >> 9));
              uint64_t v166 = (char **)(v162 + 16 * v165);
              uint64_t v167 = *v166;
              if (v389 == *v166)
              {
LABEL_202:
                *uint64_t v166 = (char *)-8192;
                v161[304] = vadd_s32(v161[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v160 = v389;
              }
              else
              {
                int v168 = 1;
                while (v167 != (char *)-4096)
                {
                  int v169 = v165 + v168++;
                  uint64_t v165 = v169 & v164;
                  uint64_t v167 = *(char **)(v162 + 16 * v165);
                  if (v389 == v167)
                  {
                    uint64_t v166 = (char **)(v162 + 16 * v165);
                    goto LABEL_202;
                  }
                }
              }
              v160[17] &= ~1u;
            }
          }
        }
      }
      unint64_t v387 = (unint64_t)v152;
      int v156 = sub_1CD6658A4(v137, &v384);
      int64_t v157 = sub_1CD6658A4(v144, (uint64_t *)&v387);
      if (v156 != v157) {
        llvm::SmallPtrSetImplBase::CopyFrom((llvm::SmallPtrSetImplBase *)(v157 + 1), (const llvm::SmallPtrSetImplBase *)(v156 + 1));
      }
      uint64_t v158 = v142 + 104;
      uint64_t v142 = v140;
      if (v158 != v140)
      {
        uint64_t v142 = v158;
        while ((*(void *)v142 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v142 += 104;
          if (v142 == v140)
          {
            uint64_t v142 = v140;
            break;
          }
        }
      }
      if ((uint64_t *)v142 == v143) {
        goto LABEL_205;
      }
    }
    int v149 = 1;
    while (v148 != -4096)
    {
      int v150 = v146 + v149++;
      uint64_t v146 = v150 & (v395 - 1);
      unint64_t v147 = (char *)v393 + 64 * v146;
      uint64_t v148 = v147[3];
      if (v145 == v148) {
        goto LABEL_169;
      }
    }
LABEL_168:
    unint64_t v147 = (char *)v393 + 64 * (unint64_t)v395;
    goto LABEL_169;
  }
LABEL_205:
  uint64_t v170 = v383;
  if (*v376) {
    llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::addBasicBlockToLoop();
  }
  v377 = (llvm::Loop *)v399;
  if (!v399)
  {
LABEL_426:
    unint64_t v306 = *(void *)(v170 + 272) - *(void *)(v170 + 264);
    if ((v306 & 0x7FFFFFFF8) != 0)
    {
      uint64_t v307 = 0;
      uint64_t v308 = (v306 >> 3);
      do
      {
        uint64_t v309 = *(void *)(*(void *)(v170 + 264) + 8 * v307);
        uint64_t v310 = *(void *)(v309 + 48);
        if (v310 != v309 + 40) {
          operator new();
        }
        ++v307;
      }
      while (v307 != v308);
    }
    uint64_t v311 = *(void *)(v170 + 184);
    uint64_t v312 = *(void *)(v311 + 40);
    if (v312 == v311 + 40)
    {
      uint64_t v314 = 0;
    }
    else
    {
      if (v312) {
        uint64_t v313 = v312 - 24;
      }
      else {
        uint64_t v313 = 0;
      }
      if (*(unsigned __int8 *)(v313 + 16) - 29 >= 0xB) {
        uint64_t v314 = 0;
      }
      else {
        uint64_t v314 = v313;
      }
    }
    if (*(void *)(v170 + 168))
    {
      sub_1CBFCBAB0((uint64_t)&v387, (uint64_t)v376);
      llvm::LoopBlocksDFS::perform((llvm::LoopBlocksDFS *)&v387, *(llvm::LoopInfo **)(v170 + 32));
      llvm::MemorySSAUpdater::updateForClonedLoop(*(void *)(v170 + 168), (uint64_t)&v387, (uint64_t)v398, v399, (uint64_t)&v393, 0);
      if (v391)
      {
        uint8x8_t v392 = v391;
        operator delete(v391);
      }
      MEMORY[0x1D25D9CD0](v388, 8);
    }
    sub_1CCE1FC9C(v170, v374, v375, **(llvm::BasicBlock ***)(v170 + 264), **(llvm::BasicBlock ***)(v170 + 240), v314, v373, v126, v372, v371);
  }
  uint64_t v171 = 0;
  while (1)
  {
    uint64_t v172 = *(void *)&v398[8 * (void)v171];
    uint64_t v388 = 2;
    uint64_t v389 = 0;
    uint64_t v390 = v172;
    if (v172 != -8192 && v172 != -4096 && v172 != 0) {
      llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v388);
    }
    unint64_t v387 = (unint64_t)&unk_1F2615EC8;
    int8x8_t v391 = &v393;
    uint64_t v174 = sub_1CC4CFF80((uint64_t)&v393, &v387);
    if (v390 != -8192 && v390 != -4096 && v390 != 0)
    {
      unint64_t v176 = v388 & 0xFFFFFFFFFFFFFFF8;
      *(void *)(v388 & 0xFFFFFFFFFFFFFFF8) = v389;
      if (v389)
      {
        *(void *)uint64_t v389 = *(void *)v389 & 7 | v176;
      }
      else
      {
        uint64_t v177 = v390;
        unsigned int v178 = ***(int32x2_t ****)v390;
        unint64_t v179 = (unint64_t)v178[303];
        if (v179 <= v176)
        {
          uint64_t v180 = v178[305].u32[0];
          if (v179 + 16 * v180 > v176)
          {
            unsigned int v181 = v180 - 1;
            LODWORD(v182) = v181 & ((v390 >> 4) ^ (v390 >> 9));
            unsigned int v183 = (uint64_t *)(v179 + 16 * v182);
            uint64_t v184 = *v183;
            if (v390 == *v183)
            {
LABEL_228:
              *unsigned int v183 = -8192;
              v178[304] = vadd_s32(v178[304], (int32x2_t)0x1FFFFFFFFLL);
              uint64_t v177 = v390;
            }
            else
            {
              int v185 = 1;
              while (v184 != -4096)
              {
                int v186 = v182 + v185++;
                uint64_t v182 = v186 & v181;
                uint64_t v184 = *(void *)(v179 + 16 * v182);
                if (v390 == v184)
                {
                  unsigned int v183 = (uint64_t *)(v179 + 16 * v182);
                  goto LABEL_228;
                }
              }
            }
            *(unsigned char *)(v177 + 17) &= ~1u;
          }
        }
      }
    }
    uint64_t v187 = v174[7];
    BOOL v188 = *(uint64_t **)(v170 + 32);
    int v189 = *((_DWORD *)v188 + 4);
    if (v189)
    {
      uint64_t v190 = *(void *)&v398[8 * (void)v171];
      uint64_t v191 = *v188;
      unsigned int v192 = v189 - 1;
      uint64_t v193 = ((v190 >> 4) ^ (v190 >> 9)) & (v189 - 1);
      uint64_t v194 = *(void *)(*v188 + 16 * v193);
      if (v190 == v194)
      {
LABEL_236:
        uint64_t v174 = *(void **)(v191 + 16 * v193 + 8);
        if (v174) {
          llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::addBasicBlockToLoop();
        }
      }
      else
      {
        int v195 = 1;
        while (v194 != -4096)
        {
          int v196 = v193 + v195++;
          uint64_t v193 = v196 & v192;
          uint64_t v194 = *(void *)(v191 + 16 * v193);
          if (v190 == v194) {
            goto LABEL_236;
          }
        }
      }
    }
    uint64_t v197 = *(void *)(v187 + 40);
    if (v197 == v187 + 40)
    {
      uint64_t v198 = 0;
    }
    else
    {
      if (v197) {
        uint64_t v198 = v197 - 24;
      }
      else {
        uint64_t v198 = 0;
      }
      if (*(unsigned __int8 *)(v198 + 16) - 29 >= 0xB) {
        uint64_t v198 = 0;
      }
    }
    if (*(unsigned char *)(v198 + 16) != 30) {
      break;
    }
LABEL_247:
    unsigned int v199 = (uint64_t *)(v198 - 32);
LABEL_248:
    uint64_t v142 = *v199;
LABEL_249:
    uint64_t v378 = (uint64_t *)(v142 + 40);
    if (*(void *)(v142 + 40) != v142 + 40)
    {
      uint64_t v200 = *(void *)(v142 + 48);
      uint64_t v201 = v200 - 24;
      uint64_t v202 = v200 ? v200 - 24 : 0;
      if (v200)
      {
        uint64_t v382 = v171;
        if (*(unsigned char *)(v202 + 16) == 83)
        {
          do
          {
            uint64_t v203 = sub_1CBF73380(v201, *(void *)&v398[8 * (void)v171]);
            a6 = v203;
            if (v395)
            {
              uint64_t v204 = ((v203 >> 4) ^ (v203 >> 9)) & (v395 - 1);
              uint64_t v205 = (char *)v393 + 64 * v204;
              uint64_t v206 = v205[3];
              if (v203 == v206)
              {
LABEL_260:
                if (v205 != (void *)((char *)v393 + 64 * (unint64_t)v395)) {
                  a6 = v205[7];
                }
              }
              else
              {
                int v207 = 1;
                while (v206 != -4096)
                {
                  int v208 = v204 + v207++;
                  uint64_t v204 = v208 & (v395 - 1);
                  uint64_t v205 = (char *)v393 + 64 * v204;
                  uint64_t v206 = v205[3];
                  if (v203 == v206) {
                    goto LABEL_260;
                  }
                }
              }
            }
            int v209 = *(_DWORD *)(v201 + 20);
            uint64_t v210 = v209 & 0x7FFFFFF;
            if ((v209 & 0x7FFFFFF) == *(_DWORD *)(v201 + 60))
            {
              unsigned int v224 = v210 + (v210 >> 1);
              if (v224 <= 2) {
                uint64_t v225 = 2;
              }
              else {
                uint64_t v225 = v224;
              }
              *(_DWORD *)(v201 + 60) = v225;
              if ((v209 & 0x40000000) != 0) {
                unsigned int v226 = *(uint64_t **)(v201 - 8);
              }
              else {
                unsigned int v226 = (uint64_t *)(v201 - 32 * v210);
              }
              uint64_t v227 = v142;
              uint64_t v228 = operator new(40 * v225);
              *(void *)(v201 - 8) = v228;
              uint64_t v229 = v228;
              do
              {
                *uint64_t v229 = 0;
                v229[1] = 0;
                v229[2] = 0;
                v229[3] = v201;
                v229 += 4;
              }
              while (v229 != &v228[4 * v225]);
              int v230 = *(_DWORD *)(v201 + 20);
              if ((v230 & 0x40000000) != 0) {
                uint64_t v231 = (uint64_t)v228;
              }
              else {
                uint64_t v231 = v201 - 32 * (v230 & 0x7FFFFFF);
              }
              unint64_t v102 = v210;
              int v143 = &v226[4 * v210];
              sub_1CC5E4108((uint64_t)&v387, v226, v143, v231);
              if (v210)
              {
                memmove((void *)(v231 + 32 * v225), &v226[4 * v210], 8 * v210);
                uint64_t v232 = 4 * v210;
                do
                {
                  unsigned int v233 = &v226[v232];
                  if (v226[v232 - 4])
                  {
                    *(void *)*(v233 - 2) = *(v233 - 3);
                    uint64_t v234 = *(v233 - 3);
                    if (v234) {
                      *(void *)(v234 + 16) = *(v233 - 2);
                    }
                  }
                  v232 -= 4;
                }
                while (v232 * 8);
              }
              operator delete(v226);
              int v209 = *(_DWORD *)(v201 + 20);
              uint64_t v142 = v227;
              uint64_t v171 = v382;
              uint64_t v170 = v383;
            }
            uint64_t v211 = (v209 + 1) & 0x7FFFFFF;
            *(_DWORD *)(v201 + 20) = v209 & 0xF8000000 | (v209 + 1) & 0x7FFFFFF;
            if ((v209 & 0x40000000) != 0) {
              uint64_t v212 = *(void *)(v201 - 8);
            }
            else {
              uint64_t v212 = v201 - 32 * v211;
            }
            uint64_t v213 = (v211 - 1);
            uint64_t v214 = v212 + 32 * v213;
            if (*(void *)v214)
            {
              **(void **)(v214 + 16) = *(void *)(v214 + 8);
              uint64_t v223 = *(void *)(v214 + 8);
              if (v223) {
                *(void *)(v223 + 16) = *(void *)(v214 + 16);
              }
            }
            *(void *)uint64_t v214 = a6;
            if (a6)
            {
              uint64_t v216 = *(void *)(a6 + 8);
              a6 += 8;
              uint64_t v215 = v216;
              uint64_t v217 = v212 + 32 * v213;
              *(void *)(v217 + 8) = v216;
              if (v216) {
                *(void *)(v215 + 16) = v217 + 8;
              }
              *(void *)(v217 + 16) = a6;
              *(void *)a6 = v214;
            }
            int v218 = *(_DWORD *)(v201 + 20);
            uint64_t v219 = v218 & 0x7FFFFFF;
            if ((v218 & 0x40000000) != 0) {
              uint64_t v220 = *(void *)(v201 - 8);
            }
            else {
              uint64_t v220 = v201 - 32 * v219;
            }
            *(void *)(v220 + 32 * *(unsigned int *)(v201 + 60) + 8 * (v219 - 1)) = v187;
            uint64_t v221 = *(void *)(v201 + 32);
            uint64_t v201 = v221 - 24;
            if (v221) {
              uint64_t v222 = v221 - 24;
            }
            else {
              uint64_t v222 = 0;
            }
          }
          while (v221 && *(unsigned char *)(v222 + 16) == 83);
        }
      }
    }
    for (uint64_t j = *(void *)(v187 + 48); j != v187 + 40; uint64_t j = *(void *)(j + 8))
    {
      if (j) {
        uint64_t v236 = j - 24;
      }
      else {
        uint64_t v236 = 0;
      }
      if (*(unsigned char *)(v236 + 16) != 83)
      {
        if (*(unsigned char *)(j - 8) != 94) {
          break;
        }
        uint64_t v237 = *(void *)(j - 24);
        LOWORD(v391) = 257;
        int64_t v238 = *(uint64_t **)(v142 + 48);
        unsigned int v239 = v378;
        while (v238 != v378)
        {
          int v240 = v238 - 3;
          if (!v238) {
            int v240 = 0;
          }
          if (*((unsigned char *)v240 + 16) != 83)
          {
            unsigned int v241 = *((unsigned __int8 *)v238 - 8) - 38;
            BOOL v254 = v241 > 0x38;
            uint64_t v242 = (1 << v241) & 0x100060000000001;
            if (v254 || v242 == 0) {
              unsigned int v239 = v238;
            }
            else {
              unsigned int v239 = (uint64_t *)v238[1];
            }
            break;
          }
          int64_t v238 = (uint64_t *)v238[1];
        }
        uint64_t v244 = operator new(0x48uLL);
        unsigned int v245 = v244;
        v244[1] = v237;
        int v246 = (llvm::Value *)(v244 + 1);
        *uint64_t v244 = 0;
        v244[2] = 0;
        v244[3] = 0x4000000000000053;
        *((_OWORD *)v244 + 2) = 0u;
        uint64_t v247 = (char *)(v244 + 4);
        *((_OWORD *)v244 + 3) = 0u;
        *((_DWORD *)v244 + 16) = 0;
        if (v239)
        {
          uint64_t v286 = v239[2];
          v244[6] = v286;
          *(_WORD *)(v286 + 18) &= ~0x8000u;
          if ((*((unsigned char *)v244 + 31) & 0x10) != 0)
          {
            uint64_t v296 = *(void *)(v286 + 56);
            if (v296)
            {
              v297 = *(llvm::ValueSymbolTable **)(v296 + 104);
              if (v297) {
                llvm::ValueSymbolTable::reinsertValue(v297, v246);
              }
            }
          }
          uint64_t v287 = *v239;
          v245[4] = *v239;
          v245[5] = v239;
          *(void *)(v287 + 8) = v247;
          uint64_t *v239 = (uint64_t)v247;
        }
        *((_DWORD *)v245 + 17) = 0;
        llvm::Value::setNameImpl(v246, (const char **)&v387);
        if (*((unsigned char *)v245 + 24)) {
          goto LABEL_322;
        }
        if ((*((unsigned char *)v245 + 31) & 0x10) == 0) {
          goto LABEL_414;
        }
        uint64_t v288 = ***(void ***)v246;
        uint64_t v289 = *(void *)(v288 + 152);
        uint64_t v290 = *(unsigned int *)(v288 + 168);
        if (!v290) {
          goto LABEL_406;
        }
        LODWORD(v291) = (v290 - 1) & ((v246 >> 4) ^ (v246 >> 9));
        uint64_t v292 = (llvm::Value **)(v289 + 16 * v291);
        int v293 = *v292;
        if (*v292 != v246)
        {
          int v294 = 1;
          while (v293 != (llvm::Value *)-4096)
          {
            int v295 = v291 + v294++;
            uint64_t v291 = v295 & (v290 - 1);
            int v293 = *(llvm::Value **)(v289 + 16 * v291);
            if (v293 == v246)
            {
              uint64_t v292 = (llvm::Value **)(v289 + 16 * v291);
              goto LABEL_407;
            }
          }
LABEL_406:
          uint64_t v292 = (llvm::Value **)(v289 + 16 * v290);
        }
LABEL_407:
        uint64_t v298 = v292[1];
        unint64_t v301 = *(void *)v298;
        unsigned int v299 = (char *)v298 + 16;
        unint64_t v300 = v301;
        if (v301 >= 5 && (*(_DWORD *)v299 == *(_DWORD *)"llvm." ? (BOOL v302 = v299[4] == aLlvm_1[4]) : (BOOL v302 = 0), v302))
        {
          *((_DWORD *)v245 + 10) |= 0x2000u;
          int v303 = llvm::Function::lookupIntrinsicID(v299, v300);
        }
        else
        {
LABEL_414:
          int v303 = 0;
          *((_DWORD *)v245 + 10) &= ~0x2000u;
        }
        *((_DWORD *)v245 + 11) = v303;
LABEL_322:
        uint64_t v248 = *((unsigned int *)v245 + 17);
        int64_t v249 = operator new(40 * v248);
        *unsigned int v245 = v249;
        if (v248)
        {
          int v250 = &v249[4 * v248];
          do
          {
            *int64_t v249 = 0;
            v249[1] = 0;
            v249[2] = 0;
            void v249[3] = v246;
            v249 += 4;
          }
          while (v249 != v250);
        }
        unint64_t v102 = *(void *)(v142 + 8);
        if (v102)
        {
          while (1)
          {
            unint64_t v251 = *(void *)(v102 + 24);
            unsigned int v252 = *(unsigned __int8 *)(v251 + 16);
            BOOL v253 = v251 && v252 >= 0x1C;
            BOOL v254 = !v253 || v252 - 29 > 0xA;
            if (!v254) {
              break;
            }
            unint64_t v102 = *(void *)(v102 + 8);
            if (!v102) {
              goto LABEL_335;
            }
          }
LABEL_337:
          uint64_t v255 = *(void *)(v251 + 40);
          for (uint64_t k = *(void *)(v255 + 48); k != v255 + 40; uint64_t k = *(void *)(k + 8))
          {
            uint64_t v257 = k - 24;
            if (k) {
              uint64_t v258 = k - 24;
            }
            else {
              uint64_t v258 = 0;
            }
            if (*(unsigned char *)(v258 + 16) != 83) {
              goto LABEL_345;
            }
          }
          uint64_t v257 = 0;
LABEL_345:
          if (*(unsigned char *)(v257 + 16) == 94) {
            a6 = v257;
          }
          else {
            a6 = 0;
          }
          llvm::Value::doRAUW((llvm::ValueAsMetadata *)a6, v246, (llvm::Value *)1);
          int v259 = *((_DWORD *)v245 + 7);
          uint64_t v260 = v259 & 0x7FFFFFF;
          if ((v259 & 0x7FFFFFF) == *((_DWORD *)v245 + 17))
          {
            unsigned int v275 = v260 + (v260 >> 1);
            if (v275 <= 2) {
              uint64_t v276 = 2;
            }
            else {
              uint64_t v276 = v275;
            }
            *((_DWORD *)v245 + 17) = v276;
            if ((v259 & 0x40000000) != 0) {
              uint64_t v277 = (uint64_t *)*v245;
            }
            else {
              uint64_t v277 = (uint64_t *)((char *)v246 - 32 * v260);
            }
            __pa = v277;
            int v278 = operator new(40 * v276);
            *unsigned int v245 = v278;
            BOOL v279 = v278;
            do
            {
              void *v279 = 0;
              v279[1] = 0;
              v279[2] = 0;
              v279[3] = v246;
              v279 += 4;
            }
            while (v279 != &v278[4 * v276]);
            int v280 = *((_DWORD *)v245 + 7);
            if ((v280 & 0x40000000) != 0) {
              uint64_t v142 = (uint64_t)v278;
            }
            else {
              uint64_t v142 = (uint64_t)v246 - 32 * (v280 & 0x7FFFFFF);
            }
            int v143 = &__pa[4 * v260];
            sub_1CC5E4108((uint64_t)&v387, __pa, v143, v142);
            if (v260)
            {
              memmove((void *)(v142 + 32 * v276), v143, 8 * v260);
              uint64_t v281 = 4 * v260;
              do
              {
                unsigned int v282 = &__pa[v281];
                if (__pa[v281 - 4])
                {
                  *(void *)*(v282 - 2) = *(v282 - 3);
                  uint64_t v283 = *(v282 - 3);
                  if (v283) {
                    *(void *)(v283 + 16) = *(v282 - 2);
                  }
                }
                v281 -= 4;
              }
              while (v281 * 8);
            }
            operator delete(__pa);
            int v259 = *((_DWORD *)v245 + 7);
          }
          uint64_t v261 = (v259 + 1) & 0x7FFFFFF;
          *((_DWORD *)v245 + 7) = v259 & 0xF8000000 | (v259 + 1) & 0x7FFFFFF;
          if ((v259 & 0x40000000) != 0) {
            __int16 v262 = (char *)*v245;
          }
          else {
            __int16 v262 = (char *)v246 - 32 * v261;
          }
          uint64_t v263 = (v261 - 1);
          BOOL v264 = &v262[32 * v263];
          if (*(void *)v264)
          {
            **((void **)v264 + 2) = *((void *)v264 + 1);
            uint64_t v274 = *((void *)v264 + 1);
            if (v274) {
              *(void *)(v274 + 16) = *((void *)v264 + 2);
            }
          }
          *(void *)BOOL v264 = a6;
          if (a6)
          {
            uint64_t v266 = *(void *)(a6 + 8);
            a6 += 8;
            uint64_t v265 = v266;
            v267 = &v262[32 * v263];
            *((void *)v267 + 1) = v266;
            if (v266) {
              *(void *)(v265 + 16) = v267 + 8;
            }
            *((void *)v267 + 2) = a6;
            *(void *)a6 = v264;
          }
          int v268 = *((_DWORD *)v245 + 7);
          uint64_t v269 = v268 & 0x7FFFFFF;
          if ((v268 & 0x40000000) != 0) {
            unsigned int v270 = (char *)*v245;
          }
          else {
            unsigned int v270 = (char *)v246 - 32 * v269;
          }
          *(void *)&v270[32 * *((unsigned int *)v245 + 17) + 8 * (v269 - 1)] = v255;
          uint64_t v170 = v383;
          while (1)
          {
            unint64_t v102 = *(void *)(v102 + 8);
            if (!v102) {
              break;
            }
            unint64_t v251 = *(void *)(v102 + 24);
            unsigned int v271 = *(unsigned __int8 *)(v251 + 16);
            if (v251) {
              BOOL v272 = v271 >= 0x1C;
            }
            else {
              BOOL v272 = 0;
            }
            if (v272 && v271 - 29 < 0xB) {
              goto LABEL_337;
            }
          }
        }
        break;
      }
    }
LABEL_335:
    uint64_t v171 = (llvm::Loop *)((char *)v171 + 1);
    if (v171 == v377) {
      goto LABEL_426;
    }
  }
  switch(*(unsigned char *)(v198 + 16))
  {
    case ' ':
    case '&':
      int v304 = *(_DWORD *)(v198 + 20);
      if ((v304 & 0x40000000) == 0) {
        goto LABEL_424;
      }
      uint64_t v305 = *(void *)(v198 - 8);
      goto LABEL_425;
    case '!':
      unsigned int v199 = (uint64_t *)(v198 - 96);
      goto LABEL_248;
    case '""':
    case '#':
      __break(1u);
      operator delete((char *)v174 - *(v174 - 1) - 8);
      unint64_t v318 = *(uint64_t **)(v170 + 64);
      unint64_t v317 = *(void *)(v170 + 72);
      if ((unint64_t)v318 >= v317)
      {
        BOOL v320 = *(void **)(v170 + 56);
        uint64_t v321 = v318 - v320;
        unint64_t v322 = v321 + 1;
        if (!((unint64_t)(v321 + 1) >> 61))
        {
          uint64_t v323 = v317 - (void)v320;
          if (v323 >> 2 > v322) {
            unint64_t v322 = v323 >> 2;
          }
          if ((unint64_t)v323 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v324 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v324 = v322;
          }
          if (!v324)
          {
            uint64_t v325 = 0;
LABEL_456:
            uint64_t v326 = (uint64_t *)&v325[8 * v321];
            int v327 = &v325[8 * v324];
            *uint64_t v326 = a6;
            uint64_t v319 = v326 + 1;
            if (v318 == v320)
            {
              uint64_t v171 = (llvm::Loop *)v376;
            }
            else
            {
              uint64_t v171 = (llvm::Loop *)v376;
              do
              {
                uint64_t v328 = *--v318;
                *--uint64_t v326 = v328;
              }
              while (v318 != v320);
              unint64_t v318 = *(uint64_t **)(v170 + 56);
            }
            *(void *)(v170 + 56) = v326;
            *(void *)(v170 + 64) = v319;
            *(void *)(v170 + 72) = v327;
            if (v318) {
              operator delete(v318);
            }
            goto LABEL_463;
          }
          if (!(v324 >> 61))
          {
            uint64_t v325 = (char *)operator new(8 * v324);
            goto LABEL_456;
          }
LABEL_515:
          sub_1CB833614();
        }
LABEL_514:
        abort();
      }
      *unint64_t v318 = a6;
      uint64_t v319 = v318 + 1;
LABEL_463:
      *(void *)(v170 + 64) = v319;
      *(unsigned char *)(v170 + 129) = 1;
      uint64_t v384 = 6;
      uint64_t v385 = 0;
      *(void *)uint64_t v386 = v143;
      if (v143 != (uint64_t *)-8192 && v143 != (uint64_t *)-4096 && v143) {
        llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v384);
      }
      if (v102)
      {
        if (llvm::Constant::isOneValue((llvm::Constant *)v142))
        {
          uint64_t v388 = 2;
          uint64_t v389 = 0;
          uint64_t v390 = (uint64_t)v143;
          if (v143 != (uint64_t *)-8192 && v143 != (uint64_t *)-4096 && v143) {
            llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v388);
          }
          unint64_t v387 = (unint64_t)&unk_1F2615EC8;
          int8x8_t v391 = &v393;
          int v331 = sub_1CC4CFF80((uint64_t)&v393, &v387);
          if (v390 != -8192 && v390 != -4096 && v390)
          {
            unint64_t v334 = v388 & 0xFFFFFFFFFFFFFFF8;
            *(void *)(v388 & 0xFFFFFFFFFFFFFFF8) = v389;
            if (v389)
            {
              *(void *)uint64_t v389 = *(void *)v389 & 7 | v334;
            }
            else
            {
              uint64_t v335 = v390;
              uint64_t v336 = ***(int32x2_t ****)v390;
              unint64_t v337 = (unint64_t)v336[303];
              if (v337 <= v334)
              {
                uint64_t v338 = v336[305].u32[0];
                if (v337 + 16 * v338 > v334)
                {
                  unsigned int v339 = v338 - 1;
                  LODWORD(v340) = v339 & ((v390 >> 4) ^ (v390 >> 9));
                  BOOL v341 = (uint64_t *)(v337 + 16 * v340);
                  uint64_t v342 = *v341;
                  if (v390 != *v341)
                  {
                    int v343 = 1;
                    do
                    {
                      if (v342 == -4096) {
                        goto LABEL_485;
                      }
                      int v344 = v340 + v343++;
                      uint64_t v340 = v344 & v339;
                      uint64_t v342 = *(void *)(v337 + 16 * v340);
                    }
                    while (v390 != v342);
                    BOOL v341 = (uint64_t *)(v337 + 16 * v340);
                  }
                  *BOOL v341 = -8192;
                  v336[304] = vadd_s32(v336[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v335 = v390;
LABEL_485:
                  *(unsigned char *)(v335 + 17) &= ~1u;
                }
              }
            }
          }
          sub_1CCE21540(v170, a6, (const llvm::APInt *)v331[7], (uint64_t ***)v142, (llvm::Type *)1, v332, v333);
        }
        else
        {
          sub_1CCE21540(v170, (uint64_t)v171, (const llvm::APInt *)v143, (uint64_t ***)v142, (llvm::Type *)1, v329, v330);
        }
        int v348 = ****(uint64_t *****)(a6 + 32);
        unint64_t v387 = (unint64_t)llvm::MDString::get(v348, "llvm.loop.unswitch.partial.disable", 0x22uLL);
        llvm::MDTuple::getImpl((uint64_t)v348, &v387, 1, 0, 1);
        llvm::Loop::getLoopID(v171);
      }
      sub_1CCE21540(v170, (uint64_t)v171, (const llvm::APInt *)v143, (uint64_t ***)v142, 0, v315, v316);
      uint64_t v347 = *(void *)(v170 + 64);
      if (*(void *)(v170 + 56) != v347
        && *(void *)(v347 - 8) == a6
        && *(void *)v386
        && *(unsigned __int8 *)(*(void *)v386 + 16) >= 0x15u)
      {
        sub_1CCE21540(v170, a6, *(const llvm::APInt **)v386, (uint64_t ***)v142, (llvm::Type *)1, v345, v346);
      }
      if (*(void *)v386 != -8192 && *(void *)v386 != -4096 && *(void *)v386)
      {
        unint64_t v349 = v384 & 0xFFFFFFFFFFFFFFF8;
        *(void *)(v384 & 0xFFFFFFFFFFFFFFF8) = v385;
        if (v385)
        {
          *uint64_t v385 = *v385 & 7 | v349;
        }
        else
        {
          unsigned int v350 = *(const llvm::APInt **)v386;
          uint64_t v351 = ****(int32x2_t *****)v386;
          unint64_t v352 = (unint64_t)v351[303];
          if (v352 <= v349)
          {
            uint64_t v353 = v351[305].u32[0];
            if (v352 + 16 * v353 > v349)
            {
              unsigned int v354 = v353 - 1;
              LODWORD(v355) = v354 & ((v386[0] >> 4) ^ (v386[0] >> 9));
              uint64_t v356 = (uint64_t *)(v352 + 16 * v355);
              uint64_t v357 = *v356;
              if (*(void *)v386 == *v356)
              {
LABEL_506:
                *uint64_t v356 = -8192;
                v351[304] = vadd_s32(v351[304], (int32x2_t)0x1FFFFFFFFLL);
                unsigned int v350 = *(const llvm::APInt **)v386;
              }
              else
              {
                int v358 = 1;
                while (v357 != -4096)
                {
                  int v359 = v355 + v358++;
                  uint64_t v355 = v359 & v354;
                  uint64_t v357 = *(void *)(v352 + 16 * v355);
                  if (*(void *)v386 == v357)
                  {
                    uint64_t v356 = (uint64_t *)(v352 + 16 * v355);
                    goto LABEL_506;
                  }
                }
              }
              *((unsigned char *)v350 + 17) &= ~1u;
            }
          }
        }
      }
      if (v397)
      {
        sub_1CC009394((uint64_t)v396);
        MEMORY[0x1D25D9CD0](v396[0], 8);
        char v397 = 0;
      }
      sub_1CC4D021C(&v393);
      MEMORY[0x1D25D9CD0](v393, 8);
      if (v398 != (char *)v400) {
        free(v398);
      }
      return 1;
    case '$':
      if ((*(_WORD *)(v198 + 18) & 1) == 0)
      {
        uint64_t v142 = 0;
        uint64_t v170 = v383;
        goto LABEL_249;
      }
      int v304 = *(_DWORD *)(v198 + 20);
LABEL_424:
      uint64_t v305 = v198 - 32 * (v304 & 0x7FFFFFF);
LABEL_425:
      unsigned int v199 = (uint64_t *)(v305 + 32);
      uint64_t v170 = v383;
      goto LABEL_248;
    case '%':
      goto LABEL_247;
    case '\'':
      unsigned int v199 = (uint64_t *)(v198 - 32 * *(unsigned int *)(v198 + 80) - 64);
      goto LABEL_248;
    default:
      int v284 = *(_DWORD *)(v198 + 20);
      if ((v284 & 0x40000000) != 0) {
        uint64_t v285 = *(void *)(v198 - 8);
      }
      else {
        uint64_t v285 = v198 - 32 * (v284 & 0x7FFFFFF);
      }
      unsigned int v199 = (uint64_t *)(v285 + 32);
      goto LABEL_248;
  }
}

uint64_t sub_1CCE1F9B4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16) == 81 && (*(_WORD *)(a1 + 18) & 0x3E) == 0x20)
  {
    uint64_t v1 = *(void *)(a1 - 64);
    int v2 = *(unsigned __int8 *)(v1 + 16);
    if ((v2 - 11) < 2) {
      return 1;
    }
    uint64_t v3 = *(void *)(a1 - 32);
    int v4 = *(unsigned __int8 *)(v3 + 16);
    if ((v4 - 11) < 2) {
      return 1;
    }
    if (v4 == 83) {
      uint64_t v6 = *(void *)(a1 - 32);
    }
    else {
      uint64_t v6 = 0;
    }
    if (v2 == 83)
    {
      int v7 = *(_DWORD *)(v1 + 20);
      if ((v7 & 0x40000000) != 0)
      {
        uint64_t v9 = *(void *)(v1 - 8);
        uint64_t v8 = v7 & 0x7FFFFFF;
      }
      else
      {
        uint64_t v8 = v7 & 0x7FFFFFF;
        uint64_t v9 = v1 - 32 * v8;
      }
      if (v8)
      {
        uint64_t v10 = 32 * v8;
        while (*(unsigned __int8 *)(*(void *)v9 + 16) - 11 >= 2)
        {
          v9 += 32;
          v10 -= 32;
          if (!v10) {
            goto LABEL_17;
          }
        }
        return 1;
      }
    }
LABEL_17:
    if (v6)
    {
      int v11 = *(_DWORD *)(v6 + 20);
      if ((v11 & 0x40000000) != 0)
      {
        uint64_t v13 = *(void *)(v6 - 8);
        uint64_t v12 = v11 & 0x7FFFFFF;
      }
      else
      {
        uint64_t v12 = v11 & 0x7FFFFFF;
        uint64_t v13 = v6 - 32 * v12;
      }
      if (v12)
      {
        uint64_t v14 = 32 * v12;
        while (*(unsigned __int8 *)(*(void *)v13 + 16) - 11 >= 2)
        {
          v13 += 32;
          v14 -= 32;
          if (!v14) {
            goto LABEL_25;
          }
        }
        return 1;
      }
    }
LABEL_25:
    if (v4 != 85) {
      uint64_t v3 = 0;
    }
    if (v2 == 85
      && (*(unsigned __int8 *)(*(void *)(v1 - 64) + 16) - 11 < 2
       || *(unsigned __int8 *)(*(void *)(v1 - 32) + 16) - 11 < 2)
      || v3
      && (*(unsigned __int8 *)(*(void *)(v3 - 64) + 16) - 11 < 2
       || *(unsigned __int8 *)(*(void *)(v3 - 32) + 16) - 11 < 2))
    {
      return 1;
    }
  }
  return 0;
}

void sub_1CCE1FB08(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v20 = a2;
  int v4 = sub_1CD6658A4(a1, &v20);
  uint64_t v5 = v4[2];
  uint64_t v6 = *((unsigned int *)v4 + 7);
  if (v5 != v4[1])
  {
    unsigned int v10 = *((_DWORD *)v4 + 6);
    goto LABEL_12;
  }
  if (!v6)
  {
LABEL_9:
    unsigned int v10 = *((_DWORD *)v4 + 6);
    if (v6 < v10)
    {
      *((_DWORD *)v4 + 7) = v6 + 1;
      *(void *)(v5 + 8 * v6) = a3;
      return;
    }
LABEL_12:
    if (3 * v10 <= 4 * ((int)v6 - *((_DWORD *)v4 + 8)))
    {
      if (v10 >= 0x40) {
        v10 *= 2;
      }
      else {
        unsigned int v10 = 128;
      }
    }
    else if (v10 - v6 >= v10 >> 3)
    {
      goto LABEL_14;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(v4 + 1), v10);
    unsigned int v10 = *((_DWORD *)v4 + 6);
    uint64_t v5 = v4[2];
LABEL_14:
    unsigned int v11 = v10 - 1;
    unsigned int v12 = (v10 - 1) & ((a3 >> 4) ^ (a3 >> 9));
    uint64_t v13 = (void *)(v5 + 8 * v12);
    uint64_t v14 = *v13;
    if (*v13 == -1)
    {
      uint64_t v15 = 0;
LABEL_26:
      if (v15) {
        uint64_t v19 = v15;
      }
      else {
        uint64_t v19 = v13;
      }
      if (*v19 != a3)
      {
        if (*v19 == -2) {
          --*((_DWORD *)v4 + 8);
        }
        else {
          ++*((_DWORD *)v4 + 7);
        }
        *uint64_t v19 = a3;
      }
    }
    else
    {
      uint64_t v15 = 0;
      int v16 = 1;
      while (v14 != a3)
      {
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v14 == -2;
        }
        if (v17) {
          uint64_t v15 = v13;
        }
        unsigned int v18 = v12 + v16++;
        unsigned int v12 = v18 & v11;
        uint64_t v13 = (void *)(v5 + 8 * (v18 & v11));
        uint64_t v14 = *v13;
        if (*v13 == -1) {
          goto LABEL_26;
        }
      }
    }
    return;
  }
  int v7 = 0;
  uint64_t v8 = 8 * v6;
  uint64_t v9 = (void *)v4[2];
  while (*v9 != a3)
  {
    if (*v9 == -2) {
      int v7 = v9;
    }
    ++v9;
    v8 -= 8;
    if (!v8)
    {
      if (!v7) {
        goto LABEL_9;
      }
      *int v7 = a3;
      --*((_DWORD *)v4 + 8);
      return;
    }
  }
}

void sub_1CCE1FC9C(uint64_t a1, llvm::Value *a2, const llvm::APInt *a3, llvm::BasicBlock *a4, llvm::BasicBlock *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v11 = a6;
  unsigned int v12 = a5;
  v91[69] = *MEMORY[0x1E4F143B8];
  if (!a10)
  {
    if (*((unsigned char *)a3 + 16) == 16 && *(void *)a3 == ***(void ***)a2 + 1888)
    {
      int v16 = **(uint64_t ***)a3;
      uint64_t v17 = *v16;
      unsigned int v18 = *(const llvm::APInt **)(*v16 + 1560);
      if (!v18)
      {
        unint64_t v53 = *(llvm::ConstantInt **)(v17 + 1888);
        unsigned int v54 = *(_DWORD *)(v17 + 1896);
        LODWORD(v75) = v54 >> 8;
        if (v54 >> 8 > 0x40) {
          operator new[]();
        }
        if (v54 <= 0xFF) {
          LOBYTE(v55) = 0;
        }
        else {
          unint64_t v55 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v54) + 63);
        }
        int v74 = (void *)(v55 & 1);
        unsigned int v18 = (const llvm::APInt *)llvm::ConstantInt::get(v53, (llvm::LLVMContext *)&v74, a3);
        unsigned int v12 = a5;
        if (v75 >= 0x41 && v74) {
          MEMORY[0x1D25D9CB0](v74, 0x1000C8000313F17);
        }
        *(void *)(v17 + 1560) = v18;
      }
      if (v18 == a3)
      {
        int v19 = 0;
        uint64_t v20 = v12;
      }
      else
      {
        int v19 = 1;
        uint64_t v20 = a4;
        a4 = v12;
      }
      uint64_t v37 = a2;
    }
    else
    {
      unint64_t v36 = operator new(0x80uLL);
      uint64_t v37 = (llvm::Value *)(v36 + 16);
      unsigned char v36[21] = v36[21] & 0x38000000 | 2;
      *(void *)unint64_t v36 = 0;
      *((void *)v36 + 1) = 0;
      *((void *)v36 + 2) = 0;
      *((void *)v36 + 3) = v36 + 16;
      *((void *)v36 + 4) = 0;
      *((void *)v36 + 5) = 0;
      *((void *)v36 + 6) = 0;
      *((void *)v36 + 7) = v36 + 16;
      LOWORD(v78) = 257;
      unint64_t v38 = *(void ***)a2;
      uint64_t v39 = ***(void ***)a2 + 1888;
      if (*(void *)a2 && (v38[1] & 0xFE) == 0x12)
      {
        uint64_t v49 = (uint64_t **)(***(void ***)a2 + 1888);
        uint64_t v50 = (llvm::Type *)*((unsigned int *)v38 + 8);
        if (*((_DWORD *)v38 + 2) == 19) {
          llvm::ScalableVectorType::get(v49, v50);
        }
        else {
          llvm::FixedVectorType::get((llvm::FixedVectorType *)v49, v50);
        }
        uint64_t v39 = v51;
      }
      llvm::CmpInst::CmpInst(v37, v39, 53, 32, (uint64_t)a2, (uint64_t)a3, (const char **)&v74, v11, 0);
      int v19 = 0;
      uint64_t v20 = v12;
    }
    uint64_t v40 = 0;
    uint64_t v41 = *(void *)(v11 + 40);
    uint64_t v42 = **(void **)v11;
    int v74 = &v76;
    uint64_t v75 = 0x200000000;
    uint64_t v81 = v42;
    uint64_t v82 = &v90;
    uint64_t v83 = v91;
    uint64_t v84 = 0;
    int v85 = 0;
    __int16 v86 = 512;
    char v87 = 7;
    uint64_t v88 = 0;
    uint64_t v89 = 0;
    unint64_t v90 = &unk_1F2616E88;
    v91[0] = &unk_1F2617008;
    uint64_t v79 = v41;
    uint64_t v80 = v11 + 24;
    uint64_t v43 = *(unsigned __int8 **)(v11 + 48);
    uint64_t v68 = v43;
    if (v43)
    {
      llvm::MetadataTracking::track((uint64_t)&v68, v43, 2);
      uint64_t v40 = (uint64_t)v68;
    }
    sub_1CB8461A4((uint64_t)&v74, 0, v40);
    if (!v68)
    {
LABEL_37:
      uint64_t v44 = sub_1CD50F904((uint64_t *)&v74, v37, a4, v20, a7);
      if (v74 == &v76)
      {
        if (!v19) {
          goto LABEL_40;
        }
      }
      else
      {
        free(v74);
        if (!v19) {
LABEL_40:
        }
          llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
      }
      llvm::Instruction::swapProfMetadata(v44);
      goto LABEL_40;
    }
    int v45 = *v68;
    if ((v45 - 4) > 0x1E)
    {
      if ((v45 - 3) >= 0xFFFFFFFE) {
        uint64_t v48 = v68;
      }
      else {
        uint64_t v48 = 0;
      }
      if ((v45 - 3) < 0xFFFFFFFE)
      {
        if (v45 == 3) {
          *((void *)v68 + 1) = 0;
        }
        goto LABEL_37;
      }
      unint64_t v47 = (unint64_t)(v48 + 8);
    }
    else
    {
      if ((v68[1] & 0x7F) != 2 && !*((_DWORD *)v68 + 3)) {
        goto LABEL_37;
      }
      uint64_t v46 = *((void *)v68 + 2);
      if ((v46 & 4) == 0) {
        goto LABEL_37;
      }
      unint64_t v47 = v46 & 0xFFFFFFFFFFFFFFF8;
      if (!v47) {
        goto LABEL_37;
      }
    }
    uint64_t v69 = &v68;
    sub_1CC5FA668(v47 + 16, &v69);
    goto LABEL_37;
  }
  LODWORD(v76) = 128;
  uint64_t v21 = (char *)operator new(0x2000uLL, (std::align_val_t)8uLL);
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  int v74 = v21;
  uint64_t v75 = 0;
  uint64_t v70 = 2;
  uint64_t v71 = 0;
  uint64_t v72 = -4096;
  uint64_t v73 = 0;
  uint64_t v69 = &unk_1F2615EC8;
  do
  {
    uint64_t v24 = &v21[v22];
    uint64_t v25 = v70;
    uint64_t v26 = v72;
    *(void *)&v21[v22 + 8] = v70 & 6;
    *((void *)v24 + 2) = 0;
    *((void *)v24 + 3) = v26;
    if (v26 != -4096 && v26 != -8192 && v26 != 0)
    {
      *((void *)v24 + 2) = *(void *)(v25 & 0xFFFFFFFFFFFFFFF8);
      *(void *)(v25 & 0xFFFFFFFFFFFFFFF8) = &v21[v22 + 8];
      *((void *)v24 + 1) = v25 & 0xFFFFFFFFFFFFFFFELL;
      int v28 = (void *)*((void *)v24 + 2);
      if (v28) {
        *int v28 = &v21[v22 + 16 + (*v28 & 7)];
      }
      uint64_t v23 = v73;
      uint64_t v11 = a6;
    }
    *(void *)uint64_t v24 = &unk_1F2615EC8;
    *((void *)v24 + 4) = v23;
    v22 += 64;
  }
  while (v22 != 0x2000);
  if (v72 != -8192 && v72 != -4096 && v72 != 0)
  {
    unint64_t v56 = v70 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v70 & 0xFFFFFFFFFFFFFFF8) = v71;
    if (v71)
    {
      *uint64_t v71 = *v71 & 7 | v56;
LABEL_80:
      uint64_t v11 = a6;
      goto LABEL_24;
    }
    uint64_t v57 = v72;
    unsigned int v58 = ***(int32x2_t ****)v72;
    unint64_t v59 = (unint64_t)v58[303];
    uint64_t v11 = a6;
    if (v59 <= v56)
    {
      uint64_t v60 = v58[305].u32[0];
      if (v59 + 16 * v60 > v56)
      {
        unsigned int v61 = v60 - 1;
        LODWORD(v62) = v61 & ((v72 >> 4) ^ (v72 >> 9));
        uint64_t v63 = (uint64_t *)(v59 + 16 * v62);
        uint64_t v64 = *v63;
        if (v72 != *v63)
        {
          int v65 = 1;
          do
          {
            if (v64 == -4096) {
              goto LABEL_78;
            }
            int v66 = v62 + v65++;
            uint64_t v62 = v66 & v61;
            uint64_t v64 = *(void *)(v59 + 16 * v62);
          }
          while (v72 != v64);
          uint64_t v63 = (uint64_t *)(v59 + 16 * v62);
        }
        uint64_t *v63 = -8192;
        v58[304] = vadd_s32(v58[304], (int32x2_t)0x1FFFFFFFFLL);
        uint64_t v57 = v72;
LABEL_78:
        *(unsigned char *)(v57 + 17) &= ~1u;
        goto LABEL_80;
      }
    }
  }
LABEL_24:
  LOBYTE(v77) = 0;
  LOBYTE(v79) = 0;
  uint64_t v30 = (uint64_t *)(v11 + 24);
  uint64_t v31 = (llvm::Value *)llvm::Instruction::clone(*(llvm::Instruction **)(a9 + 8 * a10 - 8));
  uint64_t v32 = *(void *)(v11 + 40);
  *((void *)v31 + 5) = v32;
  *(_WORD *)(v32 + 18) &= ~0x8000u;
  if ((*((unsigned char *)v31 + 23) & 0x10) != 0)
  {
    uint64_t v34 = *(void *)(v32 + 56);
    if (v34)
    {
      uint64_t v35 = *(llvm::ValueSymbolTable **)(v34 + 104);
      if (v35) {
        llvm::ValueSymbolTable::reinsertValue(v35, v31);
      }
    }
  }
  uint64_t v33 = *v30;
  *((void *)v31 + 4) = v30;
  *((void *)v31 + 3) = v33;
  *(void *)(v33 + 8) = (char *)v31 + 24;
  *uint64_t v30 = (uint64_t)v31 + 24;
  operator new();
}

uint64_t sub_1CCE20C78(uint64_t a1)
{
  int v2 = *(_DWORD **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      sub_1CD776ECC(v2 + 14);
      MEMORY[0x1D25D9CD0](*((void *)v2 + 7), 8);
    }
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_1CCE20CD0(uint64_t a1, uint64_t a2)
{
  int v7 = v11;
  uint64_t v8 = v11;
  int v10 = 0;
  uint64_t v2 = **(void **)(a1 + 32);
  uint64_t v9 = 0x100000008;
  v11[0] = v2;
  uint64_t v6 = 0;
  int v3 = sub_1CCE2102C(a1, a2, &v6, (uint64_t)&v7);
  uint64_t v4 = v6;
  if (v8 != v7) {
    free(v8);
  }
  if (v3) {
    return v4;
  }
  else {
    return 0;
  }
}

void sub_1CCE20D4C(void *a1, const llvm::Loop *a2, uint64_t a3, uint64_t a4, llvm *a5)
{
  uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(a1[1] + 24), llvm::ScalarEvolutionWrapperPass::ID, 1);
  if (AnalysisPass)
  {
    uint64_t v10 = (*(uint64_t (**)(uint64_t, char *))(*(void *)AnalysisPass + 96))(AnalysisPass, llvm::ScalarEvolutionWrapperPass::ID);
    if (v10)
    {
      uint64_t v11 = *(int32x2_t **)(v10 + 32);
      unsigned int v12 = a2;
      do
      {
        uint64_t v13 = v12;
        unsigned int v12 = *(const llvm::Loop **)v12;
      }
      while (v12);
      llvm::ScalarEvolution::forgetLoop(v11, v13);
    }
  }
  uint64_t v15 = (llvm::BasicBlock *)a1[22];
  uint64_t v14 = (llvm *)a1[23];
  int v16 = (llvm::BasicBlock *)a1[18];
  uint64_t v17 = (llvm::DominatorTree *)a1[4];
  unsigned int v18 = (llvm::LoopInfo *)a1[21];
  __int16 v25 = 257;
  llvm::SplitEdge(v14, v15, v16, v17, v18, (llvm::MemorySSAUpdater *)v24, v9);
  uint64_t v19 = *((void *)a5 + 6);
  if (v19) {
    uint64_t v20 = (llvm::BasicBlock *)(v19 - 24);
  }
  else {
    uint64_t v20 = 0;
  }
  uint64_t v21 = a1[18];
  uint64_t v22 = (llvm::DomTreeUpdater *)a1[4];
  uint64_t v23 = (llvm::LoopInfo *)a1[21];
  __int16 v25 = 257;
  sub_1CD126150(a5, v20, 0, v21, v22, v23, (llvm::Twine *)v24, 0);
}

uint64_t sub_1CCE2102C(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a4 + 8);
  uint64_t v9 = *(unsigned int *)(a4 + 20);
  if (v8 == *(void *)a4)
  {
    if (v9)
    {
      uint64_t v10 = 0;
      uint64_t v11 = 8 * v9;
      unsigned int v12 = *(void **)(a4 + 8);
      while (*v12 != a2)
      {
        if (*v12 == -2) {
          uint64_t v10 = v12;
        }
        ++v12;
        v11 -= 8;
        if (!v11)
        {
          if (!v10) {
            goto LABEL_9;
          }
          *uint64_t v10 = a2;
          --*(_DWORD *)(a4 + 24);
          goto LABEL_33;
        }
      }
      return 0;
    }
LABEL_9:
    unsigned int v13 = *(_DWORD *)(a4 + 16);
    if (v9 < v13)
    {
      *(_DWORD *)(a4 + 20) = v9 + 1;
      *(void *)(v8 + 8 * v9) = a2;
      goto LABEL_33;
    }
  }
  else
  {
    unsigned int v13 = *(_DWORD *)(a4 + 16);
  }
  if (3 * v13 <= 4 * ((int)v9 - *(_DWORD *)(a4 + 24)))
  {
    if (v13 >= 0x40) {
      v13 *= 2;
    }
    else {
      unsigned int v13 = 128;
    }
    goto LABEL_117;
  }
  if (v13 - v9 < v13 >> 3)
  {
LABEL_117:
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a4, v13);
    unsigned int v13 = *(_DWORD *)(a4 + 16);
    uint64_t v8 = *(void *)(a4 + 8);
  }
  unsigned int v14 = v13 - 1;
  unsigned int v15 = (v13 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  int v16 = (void *)(v8 + 8 * v15);
  uint64_t v17 = *v16;
  if (*v16 != -1)
  {
    unsigned int v18 = 0;
    int v19 = 1;
    while (v17 != a2)
    {
      if (v18) {
        BOOL v20 = 0;
      }
      else {
        BOOL v20 = v17 == -2;
      }
      if (v20) {
        unsigned int v18 = v16;
      }
      unsigned int v21 = v15 + v19++;
      unsigned int v15 = v21 & v14;
      int v16 = (void *)(v8 + 8 * (v21 & v14));
      uint64_t v17 = *v16;
      if (*v16 == -1) {
        goto LABEL_26;
      }
    }
    return 0;
  }
  unsigned int v18 = 0;
LABEL_26:
  if (v18) {
    uint64_t v22 = v18;
  }
  else {
    uint64_t v22 = v16;
  }
  if (*v22 == a2) {
    return 0;
  }
  if (*v22 == -2) {
    --*(_DWORD *)(a4 + 24);
  }
  else {
    ++*(_DWORD *)(a4 + 20);
  }
  *uint64_t v22 = a2;
LABEL_33:
  uint64_t v24 = *(void *)(a1 + 56);
  uint64_t v23 = *(void *)(a1 + 64);
  if (v23 == v24)
  {
    uint64_t v25 = *(unsigned int *)(a1 + 76);
    uint64_t v26 = (void *)(v23 + 8 * v25);
    if (v25)
    {
      uint64_t v27 = 0;
      uint64_t v28 = 8 * v25;
      while (*(void *)(v23 + v27) != a2)
      {
        v27 += 8;
        if (v28 == v27) {
          goto LABEL_51;
        }
      }
      uint64_t v26 = (void *)(v23 + v27);
    }
LABEL_51:
    uint64_t v24 = *(void *)(a1 + 64);
  }
  else
  {
    uint64_t v29 = *(unsigned int *)(a1 + 72);
    int v30 = v29 - 1;
    unsigned int v31 = (v29 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v26 = (void *)(v23 + 8 * v31);
    uint64_t v32 = *v26;
    if (*v26 == -1)
    {
      uint64_t v33 = 0;
LABEL_96:
      if (v33) {
        uint64_t v26 = v33;
      }
      if (*v26 != a2) {
        uint64_t v26 = (void *)(v23 + 8 * v29);
      }
    }
    else
    {
      uint64_t v33 = 0;
      int v34 = 1;
      while (v32 != a2)
      {
        if (v33) {
          BOOL v35 = 0;
        }
        else {
          BOOL v35 = v32 == -2;
        }
        if (v35) {
          uint64_t v33 = v26;
        }
        unsigned int v36 = v31 + v34++;
        unsigned int v31 = v36 & v30;
        uint64_t v26 = (void *)(v23 + 8 * (v36 & v30));
        uint64_t v32 = *v26;
        if (*v26 == -1) {
          goto LABEL_96;
        }
      }
    }
  }
  BOOL v20 = v23 == v24;
  uint64_t v37 = 72;
  if (v20) {
    uint64_t v37 = 76;
  }
  if (v26 == (void *)(v23 + 8 * *(unsigned int *)(a1 + v37)))
  {
    if (!*a3)
    {
      *a3 = a2;
      return 1;
    }
    return 0;
  }
  uint64_t v64 = a2;
  uint64_t v39 = a2 + 40;
  uint64_t v38 = *(void *)(a2 + 40);
  if (v38 == a2 + 40) {
    goto LABEL_101;
  }
  if (v38) {
    uint64_t v40 = v38 - 24;
  }
  else {
    uint64_t v40 = 0;
  }
  int v41 = *(unsigned __int8 *)(v40 + 16);
  int v42 = v41 - 29;
  if (v41 == 30)
  {
    if ((*(_DWORD *)(v40 + 20) & 0x7FFFFFF) == 3) {
      unsigned int v60 = 2;
    }
    else {
      unsigned int v60 = 1;
    }
    goto LABEL_64;
  }
  unsigned int v60 = 2;
  switch(v42)
  {
    case 1:
LABEL_118:
      __break(1u);
      goto LABEL_119;
    case 2:
      unsigned int v60 = (*(_DWORD *)(v40 + 20) >> 1) & 0x3FFFFFF;
      break;
    case 3:
    case 9:
LABEL_119:
      unsigned int v60 = (*(_DWORD *)(v40 + 20) & 0x7FFFFFF) - 1;
      break;
    case 4:
      goto LABEL_64;
    case 7:
      unsigned int v60 = *(_WORD *)(v40 + 18) & 1;
      break;
    case 8:
      unsigned int v60 = 1;
      goto LABEL_64;
    case 10:
      unsigned int v60 = *(_DWORD *)(v40 + 80) + 1;
      break;
    default:
      goto LABEL_101;
  }
  if (v60)
  {
LABEL_64:
    int v43 = 0;
    uint64_t v44 = 0;
    uint64_t v45 = v40 - 64;
    uint64_t v46 = v60;
    do
    {
      int v47 = *(unsigned __int8 *)(v40 + 16);
      if (v47 == 30)
      {
        uint64_t v50 = (uint64_t *)(v40 - 32 - 32 * v44);
      }
      else
      {
        uint64_t v49 = (v47 - 31);
        uint64_t v50 = (uint64_t *)(v40 - 32);
        switch(v49)
        {
          case 1:
          case 7:
            int v54 = *(_DWORD *)(v40 + 20);
            if ((v54 & 0x40000000) != 0) {
              uint64_t v55 = *(void *)(v40 - 8);
            }
            else {
              uint64_t v55 = v40 - 32 * (v54 & 0x7FFFFFF);
            }
            uint64_t v53 = v55 + 32 * v44;
            goto LABEL_76;
          case 2:
            uint64_t v56 = -64;
            if (!v44) {
              uint64_t v56 = -96;
            }
            uint64_t v50 = (uint64_t *)(v40 + v56);
            break;
          case 3:
          case 4:
            goto LABEL_118;
          case 5:
            if ((*(_WORD *)(v40 + 18) & 1) == 0)
            {
              uint64_t v48 = 0;
              goto LABEL_69;
            }
            uint64_t v57 = *(_DWORD *)(v40 + 20) & 0x7FFFFFF;
            uint64_t v58 = v40 + 32;
            goto LABEL_91;
          case 6:
            break;
          case 8:
            if (v44)
            {
              uint64_t v50 = (uint64_t *)(v45 - 32 * *(unsigned int *)(v40 + 80));
            }
            else
            {
              uint64_t v57 = *(unsigned int *)(v40 + 80);
              uint64_t v58 = v40 - 64;
LABEL_91:
              uint64_t v50 = (uint64_t *)(v58 - 32 * v57);
            }
            break;
          default:
            int v51 = *(_DWORD *)(v40 + 20);
            if ((v51 & 0x40000000) != 0) {
              uint64_t v52 = *(void *)(v40 - 8);
            }
            else {
              uint64_t v52 = v40 - 32 * (v51 & 0x7FFFFFF);
            }
            uint64_t v53 = v52 + 32 * (v43 & 0xFFFFFFFE);
LABEL_76:
            uint64_t v50 = (uint64_t *)(v53 + 32);
            break;
        }
      }
      uint64_t v48 = *v50;
LABEL_69:
      if ((sub_1CCE2102C(a1, v48, a3, a4) & 1) == 0) {
        return 0;
      }
      ++v44;
      v43 += 2;
      v45 += 32;
    }
    while (v46 != v44);
  }
LABEL_101:
  uint64_t v61 = *(void *)(v64 + 48);
  if (v61 == v39) {
    return 1;
  }
  do
  {
    if (v61) {
      uint64_t v62 = (llvm::Instruction *)(v61 - 24);
    }
    else {
      uint64_t v62 = 0;
    }
    int HaveSideEffects = llvm::Instruction::mayHaveSideEffects(v62);
    if (HaveSideEffects) {
      break;
    }
    uint64_t v61 = *(void *)(v61 + 8);
  }
  while (v61 != v39);
  return HaveSideEffects ^ 1u;
}

void sub_1CCE21540(uint64_t a1, uint64_t a2, const llvm::APInt *a3, uint64_t ***a4, llvm::Type *a5, llvm::DSOLocalEquivalent **a6, uint64_t a7)
{
  int v7 = (llvm::Value *)a4;
  uint64_t v253 = *MEMORY[0x1E4F143B8];
  uint64_t v236 = 0;
  uint64_t v237 = 0;
  int64_t v238 = 0;
  if (a5) {
    goto LABEL_2;
  }
  if (*((unsigned char *)a4 + 16) != 16 || *((_DWORD *)*a4 + 2) != 269)
  {
    uint64_t v48 = *((void *)a3 + 1);
    if (!v48) {
      return;
    }
    uint64_t v11 = 0;
    uint64_t v49 = (unsigned int *)(a2 + 76);
    uint64_t v50 = (unsigned int *)(a2 + 72);
    while (1)
    {
      int v51 = *(unsigned char **)(v48 + 24);
      unsigned int v52 = v51[16];
      if (v51) {
        BOOL v53 = v52 >= 0x1C;
      }
      else {
        BOOL v53 = 0;
      }
      if (!v53) {
        goto LABEL_168;
      }
      uint64_t v54 = *((void *)v51 + 5);
      uint64_t v56 = *(void *)(a2 + 56);
      uint64_t v55 = *(void *)(a2 + 64);
      if (v55 == v56)
      {
        uint64_t v57 = *v49;
        uint64_t v58 = (void *)(v55 + 8 * v57);
        if (v57)
        {
          uint64_t v59 = 0;
          uint64_t v60 = 8 * v57;
          while (*(void *)(v55 + v59) != v54)
          {
            v59 += 8;
            if (v60 == v59) {
              goto LABEL_97;
            }
          }
          uint64_t v58 = (void *)(v55 + v59);
        }
LABEL_97:
        uint64_t v56 = *(void *)(a2 + 64);
      }
      else
      {
        uint64_t v61 = *v50;
        int v62 = v61 - 1;
        unsigned int v63 = (v61 - 1) & ((v54 >> 4) ^ (v54 >> 9));
        uint64_t v58 = (void *)(v55 + 8 * v63);
        uint64_t v64 = *v58;
        if (*v58 == -1)
        {
          int v65 = 0;
LABEL_114:
          if (v65) {
            uint64_t v58 = v65;
          }
          if (*v58 != v54) {
            uint64_t v58 = (void *)(v55 + 8 * v61);
          }
        }
        else
        {
          int v65 = 0;
          int v66 = 1;
          while (v64 != v54)
          {
            if (v65) {
              BOOL v67 = 0;
            }
            else {
              BOOL v67 = v64 == -2;
            }
            if (v67) {
              int v65 = v58;
            }
            unsigned int v68 = v63 + v66++;
            unsigned int v63 = v68 & v62;
            uint64_t v58 = (void *)(v55 + 8 * (v68 & v62));
            uint64_t v64 = *v58;
            if (*v58 == -1) {
              goto LABEL_114;
            }
          }
        }
      }
      uint64_t v69 = v55 == v56 ? (unsigned int *)(a2 + 76) : v50;
      if (v58 == (void *)(v55 + 8 * *v69)) {
        goto LABEL_168;
      }
      if (v52 == 81)
      {
        __int16 v70 = *((_WORD *)v51 + 9);
        if ((v70 & 0x3E) == 0x20)
        {
          if ((uint64_t v71 = (const llvm::APInt *)*((void *)v51 - 8), v72 = (llvm::Value *)*((void *)v51 - 4), v71 == a3)
            && v72 == v7
            || v71 == v7 && v72 == a3)
          {
            uint64_t v73 = ***(void ***)v51;
            if ((v70 & 0x3F) == 0x20)
            {
              int v74 = *(llvm::Value **)(v73 + 1568);
              if (v74) {
                goto LABEL_119;
              }
              uint64_t v75 = *(llvm::ConstantInt **)(v73 + 1888);
              unsigned int v76 = *(_DWORD *)(v73 + 1896);
              LODWORD(v244) = v76 >> 8;
              if (v76 >> 8 > 0x40) {
                operator new[]();
              }
              int v243 = 0;
              int v74 = (llvm::Value *)llvm::ConstantInt::get(v75, (llvm::LLVMContext *)&v243, a3);
              if (v244 >= 0x41 && v243) {
                MEMORY[0x1D25D9CB0](v243, 0x1000C8000313F17);
              }
              *(void *)(v73 + 1568) = v74;
            }
            else
            {
              int v74 = *(llvm::Value **)(v73 + 1560);
              if (v74) {
                goto LABEL_119;
              }
              uint64_t v95 = *(llvm::ConstantInt **)(v73 + 1888);
              unsigned int v96 = *(_DWORD *)(v73 + 1896);
              LODWORD(v244) = v96 >> 8;
              if (v96 >> 8 > 0x40) {
                operator new[]();
              }
              if (v96 <= 0xFF) {
                char v97 = 0;
              }
              else {
                char v97 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v96) + 63);
              }
              int v243 = (void *)(v97 & 1);
              int v74 = (llvm::Value *)llvm::ConstantInt::get(v95, (llvm::LLVMContext *)&v243, a3);
              if (v244 >= 0x41 && v243) {
                MEMORY[0x1D25D9CB0](v243, 0x1000C8000313F17);
              }
              *(void *)(v73 + 1560) = v74;
            }
            if (v74)
            {
LABEL_119:
              if (*((unsigned __int8 *)v74 + 16) >= 0x1Cu)
              {
                uint64_t v78 = *((void *)v74 + 5);
                uint64_t v79 = *((void *)v51 + 5);
                if (v78 != v79)
                {
                  uint64_t v80 = *(uint64_t **)(a1 + 32);
                  int v81 = *((_DWORD *)v80 + 4);
                  if (v81)
                  {
                    uint64_t v82 = *v80;
                    unsigned int v83 = v81 - 1;
                    LODWORD(v84) = v83 & ((v78 >> 4) ^ (v78 >> 9));
                    int v85 = (uint64_t *)(v82 + 16 * v84);
                    uint64_t v86 = *v85;
                    if (v78 == *v85)
                    {
                      uint64_t v89 = (void *)v85[1];
                      if (v89)
                      {
LABEL_130:
                        uint64_t v90 = v83 & ((v79 >> 4) ^ (v79 >> 9));
                        uint64_t v91 = *(void *)(v82 + 16 * v90);
                        if (v79 == v91)
                        {
LABEL_134:
                          uint64_t v94 = *(void **)(v82 + 16 * v90 + 8);
                          goto LABEL_136;
                        }
                        int v92 = 1;
                        while (v91 != -4096)
                        {
                          int v93 = v90 + v92++;
                          uint64_t v90 = v93 & v83;
                          uint64_t v91 = *(void *)(v82 + 16 * v90);
                          if (v79 == v91) {
                            goto LABEL_134;
                          }
                        }
                        uint64_t v94 = 0;
LABEL_136:
                        while (v94 != v89)
                        {
                          if (!v94) {
                            goto LABEL_146;
                          }
                          uint64_t v94 = (void *)*v94;
                        }
                      }
                    }
                    else
                    {
                      int v87 = 1;
                      while (v86 != -4096)
                      {
                        int v88 = v84 + v87++;
                        uint64_t v84 = v88 & v83;
                        uint64_t v86 = *(void *)(v82 + 16 * v84);
                        if (v78 == v86)
                        {
                          uint64_t v89 = *(void **)(v82 + 16 * v84 + 8);
                          if (v89) {
                            goto LABEL_130;
                          }
                          break;
                        }
                      }
                    }
                  }
                }
              }
              llvm::Value::doRAUW((llvm::ValueAsMetadata *)v51, v74, (llvm::Value *)1);
              uint64_t v77 = v237;
              goto LABEL_147;
            }
          }
        }
      }
LABEL_146:
      uint64_t v77 = v11;
LABEL_147:
      if (v77 >= (llvm::User **)v238)
      {
        uint64_t v98 = v236;
        uint64_t v99 = v77 - v236;
        unint64_t v100 = v99 + 1;
        if ((unint64_t)(v99 + 1) >> 61) {
LABEL_378:
        }
          abort();
        int v101 = v50;
        uint64_t v102 = v238 - (char *)v236;
        if ((v238 - (char *)v236) >> 2 > v100) {
          unint64_t v100 = v102 >> 2;
        }
        if ((unint64_t)v102 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v103 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v103 = v100;
        }
        if (v103)
        {
          if (v103 >> 61) {
LABEL_379:
          }
            sub_1CB833614();
          uint64_t v104 = (char *)operator new(8 * v103);
        }
        else
        {
          uint64_t v104 = 0;
        }
        BOOL v105 = &v104[8 * v99];
        *(void *)BOOL v105 = v51;
        uint64_t v11 = (llvm::User **)(v105 + 8);
        if (v77 != v98)
        {
          do
          {
            uint64_t v106 = (uint64_t)*--v77;
            *((void *)v105 - 1) = v106;
            v105 -= 8;
          }
          while (v77 != v98);
          uint64_t v77 = v236;
        }
        uint64_t v236 = (llvm::User **)v105;
        uint64_t v237 = v11;
        int64_t v238 = &v104[8 * v103];
        if (v77) {
          operator delete(v77);
        }
        uint64_t v50 = v101;
      }
      else
      {
        unsigned int *v77 = (llvm::User *)v51;
        uint64_t v11 = v77 + 1;
      }
      uint64_t v237 = v11;
      if (v51[16] == 31 && *((unsigned char *)v7 + 16) == 16)
      {
        sub_1CC025540((uint64_t)v51, (uint64_t)v7);
        if (v107 != 4294967294) {
          llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopLatch();
        }
      }
LABEL_168:
      uint64_t v48 = *(void *)(v48 + 8);
      if (!v48)
      {
        uint64_t v45 = v236;
        goto LABEL_177;
      }
    }
  }
  uint64_t v39 = ***a4;
  uint64_t v40 = a4 + 3;
  if (*((_DWORD *)a4 + 8) >= 0x41u) {
    uint64_t v40 = (void *)*v40;
  }
  BOOL v41 = *v40 == 0;
  int v42 = *(llvm::ConstantInt **)(v39 + 1888);
  unint64_t v43 = *(unsigned int *)(v39 + 1896);
  LODWORD(v244) = v43 >> 8;
  if (v43 >> 8 > 0x40) {
    operator new[]();
  }
  if (v43 <= 0xFF) {
    unint64_t v44 = 0;
  }
  else {
    unint64_t v44 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v43) + 63);
  }
  int v243 = (void *)(v44 & v41);
  int v7 = (llvm::Value *)llvm::ConstantInt::get(v42, (llvm::LLVMContext *)&v243, a3);
  if (v244 >= 0x41 && v243) {
    MEMORY[0x1D25D9CB0](v243, 0x1000C8000313F17);
  }
LABEL_2:
  uint64_t v10 = *((void *)a3 + 1);
  if (v10)
  {
    uint64_t v11 = 0;
    do
    {
      uint64_t v12 = *(void *)(v10 + 24);
      if (v12) {
        BOOL v13 = *(unsigned __int8 *)(v12 + 16) >= 0x1Cu;
      }
      else {
        BOOL v13 = 0;
      }
      if (v13)
      {
        uint64_t v14 = *(void *)(v12 + 40);
        uint64_t v16 = *(void *)(a2 + 56);
        uint64_t v15 = *(void *)(a2 + 64);
        if (v15 == v16)
        {
          uint64_t v17 = *(unsigned int *)(a2 + 76);
          unsigned int v18 = (void *)(v15 + 8 * v17);
          if (v17)
          {
            uint64_t v19 = 0;
            uint64_t v20 = 8 * v17;
            while (*(void *)(v15 + v19) != v14)
            {
              v19 += 8;
              if (v20 == v19) {
                goto LABEL_27;
              }
            }
            unsigned int v18 = (void *)(v15 + v19);
          }
LABEL_27:
          uint64_t v16 = *(void *)(a2 + 64);
        }
        else
        {
          uint64_t v21 = *(unsigned int *)(a2 + 72);
          int v22 = v21 - 1;
          unsigned int v23 = (v21 - 1) & ((v14 >> 4) ^ (v14 >> 9));
          unsigned int v18 = (void *)(v15 + 8 * v23);
          uint64_t v24 = *v18;
          if (*v18 == -1)
          {
            uint64_t v25 = 0;
LABEL_53:
            if (v25) {
              unsigned int v18 = v25;
            }
            if (*v18 != v14) {
              unsigned int v18 = (void *)(v15 + 8 * v21);
            }
          }
          else
          {
            uint64_t v25 = 0;
            int v26 = 1;
            while (v24 != v14)
            {
              if (v25) {
                BOOL v27 = 0;
              }
              else {
                BOOL v27 = v24 == -2;
              }
              if (v27) {
                uint64_t v25 = v18;
              }
              unsigned int v28 = v23 + v26++;
              unsigned int v23 = v28 & v22;
              unsigned int v18 = (void *)(v15 + 8 * (v28 & v22));
              uint64_t v24 = *v18;
              if (*v18 == -1) {
                goto LABEL_53;
              }
            }
          }
        }
        uint64_t v29 = (unsigned int *)(v15 == v16 ? a2 + 76 : a2 + 72);
        if (v18 != (void *)(v15 + 8 * *v29))
        {
          if (v11 >= (llvm::User **)v238)
          {
            unsigned int v31 = v236;
            uint64_t v32 = v11 - v236;
            unint64_t v33 = v32 + 1;
            if ((unint64_t)(v32 + 1) >> 61) {
              goto LABEL_378;
            }
            uint64_t v34 = v238 - (char *)v236;
            if ((v238 - (char *)v236) >> 2 > v33) {
              unint64_t v33 = v34 >> 2;
            }
            if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v35 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v35 = v33;
            }
            if (v35)
            {
              if (v35 >> 61) {
                goto LABEL_379;
              }
              unsigned int v36 = (char *)operator new(8 * v35);
            }
            else
            {
              unsigned int v36 = 0;
            }
            uint64_t v37 = &v36[8 * v32];
            *(void *)uint64_t v37 = v12;
            int v30 = (llvm::User **)(v37 + 8);
            if (v11 != v31)
            {
              do
              {
                uint64_t v38 = (uint64_t)*--v11;
                *((void *)v37 - 1) = v38;
                v37 -= 8;
              }
              while (v11 != v31);
              uint64_t v11 = v236;
            }
            uint64_t v236 = (llvm::User **)v37;
            int64_t v238 = &v36[8 * v35];
            if (v11) {
              operator delete(v11);
            }
          }
          else
          {
            *uint64_t v11 = (llvm::User *)v12;
            int v30 = v11 + 1;
          }
          uint64_t v237 = v30;
          uint64_t v11 = v30;
        }
      }
      uint64_t v10 = *(void *)(v10 + 8);
    }
    while (v10);
    uint64_t v45 = v236;
    if (v236 != v11)
    {
      uint64_t v46 = v236;
      do
      {
        int v47 = *v46++;
        llvm::User::replaceUsesOfWith(v47, a3, v7);
      }
      while (v46 != v11);
LABEL_177:
      if (v45 != v11)
      {
        uint64_t v232 = (llvm *)(*(void *)(*(void *)(**(void **)(a2 + 32) + 56) + 40) + 272);
        while (1)
        {
          uint64_t v110 = (uint64_t)*(v11 - 1);
          uint64_t v108 = v11 - 1;
          uint64_t v109 = v110;
          uint64_t v237 = v108;
          if (!*(void *)(v110 + 8) && llvm::wouldInstructionBeTriviallyDead(v109, 0))
          {
            int v167 = *(_DWORD *)(v109 + 20);
            uint64_t v168 = v167 & 0x7FFFFFF;
            if ((v167 & 0x7FFFFFF) != 0)
            {
              uint64_t v169 = 0;
              do
              {
                int v170 = *(_DWORD *)(v109 + 20);
                if ((v170 & 0x40000000) != 0) {
                  uint64_t v171 = *(void *)(v109 - 8);
                }
                else {
                  uint64_t v171 = v109 - 32 * (v170 & 0x7FFFFFF);
                }
                uint64_t v172 = *(unsigned __int8 **)(v171 + 32 * v169);
                if (v172) {
                  BOOL v173 = v172[16] >= 0x1Cu;
                }
                else {
                  BOOL v173 = 0;
                }
                if (v173)
                {
                  if (v108 >= (llvm::User **)v238)
                  {
                    uint64_t v175 = v236;
                    uint64_t v176 = v108 - v236;
                    unint64_t v177 = v176 + 1;
                    if ((unint64_t)(v176 + 1) >> 61) {
                      goto LABEL_378;
                    }
                    uint64_t v178 = v238 - (char *)v236;
                    if ((v238 - (char *)v236) >> 2 > v177) {
                      unint64_t v177 = v178 >> 2;
                    }
                    if ((unint64_t)v178 >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v179 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v179 = v177;
                    }
                    if (v179)
                    {
                      if (v179 >> 61) {
                        goto LABEL_379;
                      }
                      uint64_t v180 = (char *)operator new(8 * v179);
                    }
                    else
                    {
                      uint64_t v180 = 0;
                    }
                    unsigned int v181 = &v180[8 * v176];
                    *(void *)unsigned int v181 = v172;
                    uint64_t v174 = (llvm::User **)(v181 + 8);
                    if (v108 != v175)
                    {
                      do
                      {
                        uint64_t v182 = (uint64_t)*--v108;
                        *((void *)v181 - 1) = v182;
                        v181 -= 8;
                      }
                      while (v108 != v175);
                      uint64_t v108 = v236;
                    }
                    uint64_t v236 = (llvm::User **)v181;
                    uint64_t v237 = v174;
                    int64_t v238 = &v180[8 * v179];
                    if (v108) {
                      operator delete(v108);
                    }
                  }
                  else
                  {
                    char *v108 = (llvm::User *)v172;
                    uint64_t v174 = v108 + 1;
                  }
                  uint64_t v237 = v174;
                  uint64_t v108 = v174;
                }
                ++v169;
              }
              while (v169 != v168);
            }
            sub_1CD776F34((uint64_t)&v236, v109);
            uint64_t v146 = *(int32x2_t ***)(a1 + 168);
            if (!v146) {
              goto LABEL_293;
            }
            __int32 v183 = (*v146)[5].i32[0];
            if (!v183) {
              goto LABEL_293;
            }
            int32x2_t v148 = (*v146)[3];
            __int32 v184 = v183 - 1;
            uint64_t v150 = (v183 - 1) & ((v109 >> 4) ^ (v109 >> 9));
            uint64_t v185 = *(void *)(*(void *)&v148 + 16 * v150);
            if (v185 != v109)
            {
              int v186 = 1;
              while (v185 != -4096)
              {
                int v187 = v150 + v186++;
                uint64_t v150 = v187 & v184;
                uint64_t v185 = *(void *)(*(void *)&v148 + 16 * v150);
                if (v185 == v109) {
                  goto LABEL_246;
                }
              }
              goto LABEL_293;
            }
            goto LABEL_246;
          }
          unsigned int v239 = v232;
          long long v240 = 0u;
          long long v241 = 0u;
          __int16 v242 = 257;
          int v111 = *(_DWORD *)(v109 + 20);
          if ((v111 & 0x40000000) != 0)
          {
            unint64_t v113 = *(uint64_t **)(v109 - 8);
            unint64_t v112 = v111 & 0x7FFFFFF;
          }
          else
          {
            unint64_t v112 = v111 & 0x7FFFFFF;
            unint64_t v113 = (uint64_t *)(v109 - 32 * v112);
          }
          int v243 = v245;
          uint64_t v244 = 0x800000000;
          if (v112 >= 9) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          if (v112)
          {
            uint64_t v114 = 32 * v112;
            uint64_t v115 = v245;
            do
            {
              uint64_t v116 = *v113;
              v113 += 4;
              *v115++ = v116;
              v114 -= 32;
            }
            while (v114);
            uint64_t v117 = v243;
          }
          else
          {
            uint64_t v117 = v245;
          }
          LODWORD(v244) = v112;
          unsigned int v118 = llvm::SimplifyInstructionWithOperands((llvm *)v109, (uint64_t)v117, v112, (uint64_t)&v239, a5, a6, a7);
          if (v243 == v245)
          {
            if (v118) {
              goto LABEL_190;
            }
          }
          else
          {
            free(v243);
            if (v118)
            {
LABEL_190:
              if (*((unsigned __int8 *)v118 + 16) >= 0x1Cu)
              {
                uint64_t v155 = *((void *)v118 + 5);
                uint64_t v156 = *(void *)(v109 + 40);
                if (v155 != v156)
                {
                  int64_t v157 = *(uint64_t **)(a1 + 32);
                  int v158 = *((_DWORD *)v157 + 4);
                  if (v158)
                  {
                    uint64_t v159 = *v157;
                    unsigned int v160 = v158 - 1;
                    LODWORD(v161) = v160 & ((v155 >> 4) ^ (v155 >> 9));
                    unint64_t v162 = (uint64_t *)(v159 + 16 * v161);
                    uint64_t v163 = *v162;
                    if (v155 == *v162)
                    {
                      uint64_t v166 = (void *)v162[1];
                      if (v166)
                      {
LABEL_296:
                        uint64_t v188 = v160 & ((v156 >> 4) ^ (v156 >> 9));
                        uint64_t v189 = *(void *)(v159 + 16 * v188);
                        if (v156 == v189)
                        {
LABEL_300:
                          unsigned int v192 = *(void **)(v159 + 16 * v188 + 8);
                          goto LABEL_310;
                        }
                        int v190 = 1;
                        while (v189 != -4096)
                        {
                          int v191 = v188 + v190++;
                          uint64_t v188 = v191 & v160;
                          uint64_t v189 = *(void *)(v159 + 16 * v188);
                          if (v156 == v189) {
                            goto LABEL_300;
                          }
                        }
                        unsigned int v192 = 0;
LABEL_310:
                        while (v192 != v166)
                        {
                          if (!v192) {
                            goto LABEL_302;
                          }
                          unsigned int v192 = (void *)*v192;
                        }
                      }
                    }
                    else
                    {
                      int v164 = 1;
                      while (v163 != -4096)
                      {
                        int v165 = v161 + v164++;
                        uint64_t v161 = v165 & v160;
                        uint64_t v163 = *(void *)(v159 + 16 * v161);
                        if (v155 == v163)
                        {
                          uint64_t v166 = *(void **)(v159 + 16 * v161 + 8);
                          if (v166) {
                            goto LABEL_296;
                          }
                          break;
                        }
                      }
                    }
                  }
                }
              }
              unsigned int v233 = v118;
              int v230 = *(llvm::MemorySSAUpdater **)(a1 + 168);
              int v119 = *(_DWORD *)(v109 + 20);
              uint64_t v120 = v119 & 0x7FFFFFF;
              if ((v119 & 0x7FFFFFF) != 0)
              {
                uint64_t v121 = 0;
                do
                {
                  int v122 = *(_DWORD *)(v109 + 20);
                  if ((v122 & 0x40000000) != 0) {
                    uint64_t v123 = *(void *)(v109 - 8);
                  }
                  else {
                    uint64_t v123 = v109 - 32 * (v122 & 0x7FFFFFF);
                  }
                  uint64_t v124 = *(unsigned __int8 **)(v123 + 32 * v121);
                  if (v124) {
                    BOOL v125 = v124[16] >= 0x1Cu;
                  }
                  else {
                    BOOL v125 = 0;
                  }
                  if (v125)
                  {
                    if (v108 >= (llvm::User **)v238)
                    {
                      uint64_t v127 = v236;
                      uint64_t v128 = v108 - v236;
                      unint64_t v129 = v128 + 1;
                      if ((unint64_t)(v128 + 1) >> 61) {
                        goto LABEL_378;
                      }
                      uint64_t v130 = v238 - (char *)v236;
                      if ((v238 - (char *)v236) >> 2 > v129) {
                        unint64_t v129 = v130 >> 2;
                      }
                      if ((unint64_t)v130 >= 0x7FFFFFFFFFFFFFF8) {
                        unint64_t v131 = 0x1FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v131 = v129;
                      }
                      if (v131)
                      {
                        if (v131 >> 61) {
                          goto LABEL_379;
                        }
                        int v132 = (char *)operator new(8 * v131);
                      }
                      else
                      {
                        int v132 = 0;
                      }
                      unint64_t v133 = &v132[8 * v128];
                      *(void *)unint64_t v133 = v124;
                      uint64_t v126 = (llvm::User **)(v133 + 8);
                      if (v108 != v127)
                      {
                        do
                        {
                          uint64_t v134 = (uint64_t)*--v108;
                          *((void *)v133 - 1) = v134;
                          v133 -= 8;
                        }
                        while (v108 != v127);
                        uint64_t v108 = v236;
                      }
                      uint64_t v236 = (llvm::User **)v133;
                      uint64_t v237 = v126;
                      int64_t v238 = &v132[8 * v131];
                      if (v108) {
                        operator delete(v108);
                      }
                    }
                    else
                    {
                      char *v108 = (llvm::User *)v124;
                      uint64_t v126 = v108 + 1;
                    }
                    uint64_t v237 = v126;
                    uint64_t v108 = v126;
                  }
                  ++v121;
                }
                while (v121 != v120);
              }
              for (uint64_t i = *(void *)(v109 + 8); i; v108 = v137)
              {
                uint64_t v136 = *(llvm::User **)(i + 24);
                if (v108 >= (llvm::User **)v238)
                {
                  unsigned int v138 = v236;
                  uint64_t v139 = v108 - v236;
                  unint64_t v140 = v139 + 1;
                  if ((unint64_t)(v139 + 1) >> 61) {
                    goto LABEL_378;
                  }
                  uint64_t v141 = v238 - (char *)v236;
                  if ((v238 - (char *)v236) >> 2 > v140) {
                    unint64_t v140 = v141 >> 2;
                  }
                  if ((unint64_t)v141 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v142 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v142 = v140;
                  }
                  if (v142)
                  {
                    if (v142 >> 61) {
                      goto LABEL_379;
                    }
                    int v143 = (char *)operator new(8 * v142);
                  }
                  else
                  {
                    int v143 = 0;
                  }
                  uint64_t v144 = &v143[8 * v139];
                  *(void *)uint64_t v144 = v136;
                  uint64_t v137 = (llvm::User **)(v144 + 8);
                  if (v108 != v138)
                  {
                    do
                    {
                      uint64_t v145 = (uint64_t)*--v108;
                      *((void *)v144 - 1) = v145;
                      v144 -= 8;
                    }
                    while (v108 != v138);
                    uint64_t v108 = v236;
                  }
                  uint64_t v236 = (llvm::User **)v144;
                  uint64_t v237 = v137;
                  int64_t v238 = &v143[8 * v142];
                  if (v108) {
                    operator delete(v108);
                  }
                }
                else
                {
                  char *v108 = v136;
                  uint64_t v137 = v108 + 1;
                }
                uint64_t v237 = v137;
                uint64_t i = *(void *)(i + 8);
              }
              sub_1CD776F34((uint64_t)&v236, v109);
              llvm::Value::doRAUW((llvm::ValueAsMetadata *)v109, v233, (llvm::Value *)1);
              if ((llvm::Instruction::mayHaveSideEffects((llvm::Instruction *)v109) & 1) == 0)
              {
                uint64_t v146 = (int32x2_t **)v230;
                if (!v230) {
                  goto LABEL_293;
                }
                int v147 = *(_DWORD *)(*(void *)v230 + 40);
                if (!v147) {
                  goto LABEL_293;
                }
                int32x2_t v148 = *(int32x2_t *)(*(void *)v230 + 24);
                unsigned int v149 = v147 - 1;
                uint64_t v150 = (v147 - 1) & ((v109 >> 4) ^ (v109 >> 9));
                uint64_t v151 = *(void *)(*(void *)&v148 + 16 * v150);
                if (v151 != v109)
                {
                  int v152 = 1;
                  while (v151 != -4096)
                  {
                    int v153 = v150 + v152++;
                    uint64_t v150 = v153 & v149;
                    uint64_t v151 = *(void *)(*(void *)&v148 + 16 * v150);
                    if (v151 == v109) {
                      goto LABEL_246;
                    }
                  }
LABEL_293:
                  llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                }
LABEL_246:
                unint64_t v154 = *(llvm::MemoryAccess **)(*(void *)&v148 + 16 * v150 + 8);
                if (v154) {
                  llvm::MemorySSAUpdater::removeMemoryAccess(v146, v154, 0);
                }
                goto LABEL_293;
              }
              goto LABEL_306;
            }
          }
LABEL_302:
          if (v109)
          {
            if (*(unsigned char *)(v109 + 16) == 30 && (*(_DWORD *)(v109 + 20) & 0x7FFFFFF) == 1)
            {
              uint64_t v193 = *(llvm **)(v109 - 32);
              if (llvm::BasicBlock::getSinglePredecessor(v193))
              {
                sub_1CD776F34((uint64_t)&v236, v109);
                uint64_t v231 = v193;
                uint64_t v194 = (llvm::LLVMContext *)*((void *)v193 + 6);
                uint64_t v195 = (uint64_t)v194 - 24;
                if (v194) {
                  int v196 = (char *)v194 - 24;
                }
                else {
                  int v196 = 0;
                }
                if (v194 && v196[16] == 83)
                {
                  do
                  {
                    uint64_t v234 = (llvm::LLVMContext *)*((void *)v194 + 1);
                    int v197 = *(_DWORD *)(v195 + 20);
                    uint64_t v198 = v197 & 0x7FFFFFF;
                    if ((v197 & 0x7FFFFFF) != 0)
                    {
                      uint64_t v199 = 0;
                      do
                      {
                        int v200 = *(_DWORD *)(v195 + 20);
                        if ((v200 & 0x40000000) != 0) {
                          uint64_t v201 = *(void *)(v195 - 8);
                        }
                        else {
                          uint64_t v201 = v195 - 32 * (v200 & 0x7FFFFFF);
                        }
                        uint64_t v202 = *(unsigned __int8 **)(v201 + 32 * v199);
                        if (v202) {
                          BOOL v203 = v202[16] >= 0x1Cu;
                        }
                        else {
                          BOOL v203 = 0;
                        }
                        if (v203)
                        {
                          uint64_t v204 = v237;
                          if (v237 >= (llvm::User **)v238)
                          {
                            uint64_t v206 = v236;
                            uint64_t v207 = v237 - v236;
                            unint64_t v208 = v207 + 1;
                            if ((unint64_t)(v207 + 1) >> 61) {
                              goto LABEL_378;
                            }
                            uint64_t v209 = v238 - (char *)v236;
                            if ((v238 - (char *)v236) >> 2 > v208) {
                              unint64_t v208 = v209 >> 2;
                            }
                            if ((unint64_t)v209 >= 0x7FFFFFFFFFFFFFF8) {
                              unint64_t v210 = 0x1FFFFFFFFFFFFFFFLL;
                            }
                            else {
                              unint64_t v210 = v208;
                            }
                            if (v210)
                            {
                              if (v210 >> 61) {
                                goto LABEL_379;
                              }
                              uint64_t v211 = (char *)operator new(8 * v210);
                            }
                            else
                            {
                              uint64_t v211 = 0;
                            }
                            uint64_t v212 = &v211[8 * v207];
                            *(void *)uint64_t v212 = v202;
                            uint64_t v205 = (llvm::User **)(v212 + 8);
                            if (v204 != v206)
                            {
                              do
                              {
                                uint64_t v213 = (uint64_t)*--v204;
                                *((void *)v212 - 1) = v213;
                                v212 -= 8;
                              }
                              while (v204 != v206);
                              uint64_t v204 = v236;
                            }
                            uint64_t v236 = (llvm::User **)v212;
                            int64_t v238 = &v211[8 * v210];
                            if (v204) {
                              operator delete(v204);
                            }
                          }
                          else
                          {
                            *uint64_t v237 = (llvm::User *)v202;
                            uint64_t v205 = v204 + 1;
                          }
                          uint64_t v237 = v205;
                        }
                        ++v199;
                      }
                      while (v199 != v198);
                    }
                    uint64_t v214 = *(void *)(v195 + 8);
                    if (v214)
                    {
                      uint64_t v215 = (char *)v237;
                      do
                      {
                        uint64_t v216 = *(void *)(v214 + 24);
                        if (v215 >= v238)
                        {
                          int v218 = v236;
                          uint64_t v219 = (v215 - (char *)v236) >> 3;
                          unint64_t v220 = v219 + 1;
                          if ((unint64_t)(v219 + 1) >> 61) {
                            goto LABEL_378;
                          }
                          uint64_t v221 = v238 - (char *)v236;
                          if ((v238 - (char *)v236) >> 2 > v220) {
                            unint64_t v220 = v221 >> 2;
                          }
                          if ((unint64_t)v221 >= 0x7FFFFFFFFFFFFFF8) {
                            unint64_t v222 = 0x1FFFFFFFFFFFFFFFLL;
                          }
                          else {
                            unint64_t v222 = v220;
                          }
                          if (v222)
                          {
                            if (v222 >> 61) {
                              goto LABEL_379;
                            }
                            uint64_t v223 = (char *)operator new(8 * v222);
                          }
                          else
                          {
                            uint64_t v223 = 0;
                          }
                          unsigned int v224 = &v223[8 * v219];
                          *(void *)unsigned int v224 = v216;
                          uint64_t v217 = (llvm::User **)(v224 + 8);
                          if (v215 != (char *)v218)
                          {
                            do
                            {
                              uint64_t v225 = *((void *)v215 - 1);
                              v215 -= 8;
                              *((void *)v224 - 1) = v225;
                              v224 -= 8;
                            }
                            while (v215 != (char *)v218);
                            uint64_t v215 = (char *)v236;
                          }
                          uint64_t v236 = (llvm::User **)v224;
                          uint64_t v237 = v217;
                          int64_t v238 = &v223[8 * v222];
                          if (v215) {
                            operator delete(v215);
                          }
                        }
                        else
                        {
                          *(void *)uint64_t v215 = v216;
                          uint64_t v217 = (llvm::User **)(v215 + 8);
                        }
                        uint64_t v237 = v217;
                        uint64_t v214 = *(void *)(v214 + 8);
                        uint64_t v215 = (char *)v217;
                      }
                      while (v214);
                    }
                    sub_1CD776F34((uint64_t)&v236, v195);
                    uint64_t v194 = v234;
                    unsigned int v226 = (char *)v234 - 24;
                    if (!v234) {
                      unsigned int v226 = 0;
                    }
                    int v227 = v226[16];
                    if (v227 == 83) {
                      uint64_t v195 = (uint64_t)v226;
                    }
                    else {
                      uint64_t v195 = 0;
                    }
                  }
                  while (v234 && v227 == 83);
                }
                uint64_t v228 = *(void *)(a1 + 144);
                int v243 = v245;
                uint64_t v244 = 0x1000000000;
                v245[32] = 0;
                v245[33] = 0;
                v245[34] = v228;
                v245[35] = 0;
                char v246 = 0;
                uint64_t v247 = v251;
                uint64_t v248 = v251;
                uint64_t v249 = 8;
                int v250 = 0;
                memset(&v251[64], 0, 24);
                __int16 v252 = 0;
                llvm::MergeBlockIntoPredecessor(v231, (unint64_t)&v243, *(llvm::DomTreeUpdater **)(a1 + 32), *(void *)(a1 + 168), 0, 0);
                sub_1CC2930C0((uint64_t)&v243);
              }
            }
          }
LABEL_306:
          uint64_t v11 = v237;
          if (v236 == v237)
          {
            uint64_t v11 = v236;
            break;
          }
        }
      }
    }
    if (v11)
    {
      uint64_t v237 = v11;
      operator delete(v11);
    }
  }
}

unsigned __int8 *sub_1CCE22CB8(unsigned __int8 *a1, uint64_t a2, unsigned char *a3, int *a4, uint64_t a5, uint64_t *a6)
{
  unsigned int v18 = a1;
  uint64_t v19 = a1;
  uint64_t v20 = 0;
  if (sub_1CBA0E618(a5, &v19, &v20) && v20 != *(void *)a5 + 16 * *(unsigned int *)(a5 + 16)) {
    return *(unsigned __int8 **)(v20 + 8);
  }
  if ((*(_DWORD *)(*(void *)a1 + 8) & 0xFE) == 0x12) {
    return 0;
  }
  unsigned int v13 = a1[16];
  if (v13 < 0x15) {
    return 0;
  }
  if (v13 < 0x1C || llvm::Loop::makeLoopInvariant(a2, (uint64_t)a1, a3, 0, a6))
  {
    sub_1CC27AF70((uint64_t *)a5, &v18)[1] = a1;
    return v18;
  }
  else
  {
    unsigned int v15 = a1[16];
    if ((v15 & 0xFE) != 0x38 || v15 < 0x1C || v15 - 59 < 0xFFFFFFEE) {
      goto LABEL_26;
    }
    switch(*a4)
    {
      case 0:
        if (v15 == 56) {
          int v16 = 2;
        }
        else {
          int v16 = 1;
        }
        break;
      case 1:
        if (v15 != 57) {
          goto LABEL_26;
        }
        int v16 = 1;
        break;
      case 2:
        if (v15 != 56) {
          goto LABEL_26;
        }
        int v16 = 2;
        break;
      case 3:
        goto LABEL_26;
      default:
        int v16 = 0;
        break;
    }
    *a4 = v16;
    uint64_t v17 = sub_1CCE22CB8(*((void *)a1 - 8), a2, a3, a4, a5, a6);
    if (v17 || (*a4 = v16, (uint64_t v17 = sub_1CCE22CB8(*((void *)a1 - 4), a2, a3, a4, a5, a6)) != 0))
    {
      uint64_t v12 = v17;
      sub_1CC27AF70((uint64_t *)a5, &v18)[1] = v17;
    }
    else
    {
LABEL_26:
      uint64_t v12 = 0;
      sub_1CC27AF70((uint64_t *)a5, &v18)[1] = 0;
    }
  }
  return (unsigned __int8 *)v12;
}

uint64_t sub_1CCE22EB8()
{
  *(void *)&long long v4 = "Max loop size to unswitch";
  *((void *)&v4 + 1) = 25;
  int v3 = &v2;
  int v1 = 1;
  int v2 = 100;
  sub_1CD50BCD4((uint64_t)&unk_1EBCF6830, "loop-unswitch-threshold", &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF6830, &dword_1CB82C000);
  *(void *)&long long v4 = "Max number of memory uses to explore during partial unswitching analysis";
  *((void *)&v4 + 1) = 72;
  int v1 = 1;
  int v2 = 100;
  int v3 = &v2;
  sub_1CD776FEC(&v4, &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCF68F0, &dword_1CB82C000);
}

void sub_1CCE22F94(llvm *a1, llvm::PassRegistry *a2)
{
  llvm::initializeAAResultsWrapperPassPass(a1, a2);
  llvm::initializeDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializeGlobalsAAWrapperPassPass(a1, v3);
  llvm::initializeLCSSAWrapperPassPass(a1, v4);
  llvm::initializeLoopAccessLegacyAnalysisPass(a1, v5);
  llvm::initializeLoopInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeLoopSimplifyPass(a1, v6);
  llvm::initializeScalarEvolutionWrapperPassPass(a1, v7);
  llvm::initializeOptimizationRemarkEmitterWrapperPassPass(a1, v8);
  operator new();
}

uint64_t sub_1CCE23074(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF69B0;
  *(_DWORD *)(a1 + 24) = 1;
  *(void *)a1 = &unk_1F263F770;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF69B8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCE22F94;
    v5[1] = &PassRegistry;
    long long v4 = v5;
    std::__call_once(&qword_1EBCF69B8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CCE23124(int a1, llvm *this)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  llvm::hasLICMVersioningTransformation(this, this);
}

void sub_1CCE2509C()
{
}

void sub_1CCE250DC(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CCE25114()
{
  return "Loop Versioning for LICM";
}

void sub_1CCE25124(llvm::PassRegistry *a1, uint64_t a2)
{
  uint64_t v3 = a2 + 112;
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);
  sub_1CB843600(a2, a2, (uint64_t)llvm::AAResultsWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&unk_1EA61F34B);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LoopAccessLegacyAnalysis::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&unk_1EA61F34C);
  sub_1CB843600(a2, a2, (uint64_t)llvm::ScalarEvolutionWrapperPass::ID);
  sub_1CB843600(a2, v3, (uint64_t)llvm::AAResultsWrapperPass::ID);
  sub_1CB843600(a2, v3, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);

  sub_1CB843600(a2, a2, (uint64_t)&llvm::OptimizationRemarkEmitterWrapperPass::ID);
}

uint64_t sub_1CCE25258(llvm::LoopPass *a1, llvm *a2)
{
  if ((llvm::LoopPass::skipLoop(a1, a2) & 1) == 0)
  {
    long long v4 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1];
    if (v5 == v6)
    {
LABEL_6:
      uint64_t v7 = 0;
    }
    else
    {
      while (*(char **)v5 != llvm::AAResultsWrapperPass::ID)
      {
        v5 += 16;
        if (v5 == v6) {
          goto LABEL_6;
        }
      }
      uint64_t v7 = *(void *)(v5 + 8);
    }
    uint64_t v8 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v7 + 96))(v7, llvm::AAResultsWrapperPass::ID);
    uint64_t v9 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v10 = *v9;
    uint64_t v11 = v9[1];
    if (v10 == v11)
    {
LABEL_11:
      uint64_t v12 = 0;
    }
    else
    {
      while (*(char **)v10 != llvm::ScalarEvolutionWrapperPass::ID)
      {
        v10 += 16;
        if (v10 == v11) {
          goto LABEL_11;
        }
      }
      uint64_t v12 = *(void *)(v10 + 8);
    }
    uint64_t v13 = *(void *)(v8 + 32);
    uint64_t v14 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v12 + 96))(v12, llvm::ScalarEvolutionWrapperPass::ID);
    unsigned int v15 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v16 = *v15;
    uint64_t v17 = v15[1];
    if (v16 == v17)
    {
LABEL_16:
      uint64_t v18 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v16 != &llvm::OptimizationRemarkEmitterWrapperPass::ID)
      {
        v16 += 16;
        if (v16 == v17) {
          goto LABEL_16;
        }
      }
      uint64_t v18 = *(void *)(v16 + 8);
    }
    uint64_t v19 = *(void *)(v14 + 32);
    uint64_t v20 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v18 + 96))(v18, &llvm::OptimizationRemarkEmitterWrapperPass::ID);
    uint64_t v21 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v22 = *v21;
    uint64_t v23 = v21[1];
    if (v22 == v23)
    {
LABEL_21:
      uint64_t v24 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v22 != &llvm::LoopInfoWrapperPass::ID)
      {
        v22 += 16;
        if (v22 == v23) {
          goto LABEL_21;
        }
      }
      uint64_t v24 = *(void *)(v22 + 8);
    }
    uint64_t v25 = *(void *)(v20 + 32);
    (*(void (**)(uint64_t, void *))(*(void *)v24 + 96))(v24, &llvm::LoopInfoWrapperPass::ID);
    int v26 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v27 = *v26;
    uint64_t v28 = v26[1];
    if (v27 == v28)
    {
LABEL_26:
      uint64_t v29 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v27 != &llvm::DominatorTreeWrapperPass::ID)
      {
        v27 += 16;
        if (v27 == v28) {
          goto LABEL_26;
        }
      }
      uint64_t v29 = *(void *)(v27 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v29 + 96))(v29, &llvm::DominatorTreeWrapperPass::ID);
    uint64_t v37 = a1;
    v31[0] = v13;
    v31[1] = v19;
    v31[2] = 0;
    v31[3] = sub_1CCE25550;
    void v31[4] = &v37;
    v31[5] = 0;
    v31[6] = 0;
    int v32 = dword_1EBCF6B00;
    int v33 = dword_1EBCF6A40;
    uint64_t v34 = 0;
    char v35 = 1;
    uint64_t v36 = v25;
    sub_1CCE23124((int)v31, a2);
  }
  return 0;
}

uint64_t sub_1CCE25550(uint64_t a1, llvm::Loop *a2)
{
  uint64_t v3 = *(uint64_t **)(*(void *)a1 + 8);
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 == v5)
  {
LABEL_4:
    uint64_t v6 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v4 != &llvm::LoopAccessLegacyAnalysis::ID)
    {
      v4 += 16;
      if (v4 == v5) {
        goto LABEL_4;
      }
    }
    uint64_t v6 = *(void *)(v4 + 8);
  }
  uint64_t v7 = (llvm::LoopAccessLegacyAnalysis *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, &llvm::LoopAccessLegacyAnalysis::ID);

  return llvm::LoopAccessLegacyAnalysis::getInfo(v7, a2);
}

void sub_1CCE255F0()
{
}

uint64_t sub_1CCE25620()
{
  *(void *)&long long v4 = "LoopVersioningLICM's minimum allowed percentageof possible invariant instructions per loop";
  *((void *)&v4 + 1) = 90;
  uint64_t v3 = &v2;
  int v1 = 1;
  int v2 = 25;
  sub_1CD77732C(&v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CC08F43C, &qword_1EBCF69C0, &dword_1CB82C000);
  *(void *)&long long v4 = "LoopVersioningLICM's threshold for maximum allowed loop nest/depth";
  *((void *)&v4 + 1) = 66;
  int v1 = 1;
  int v2 = 2;
  uint64_t v3 = &v2;
  sub_1CD50BCD4((uint64_t)algn_1EBCF6A80, "licm-versioning-max-depth-threshold", &v4, &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, algn_1EBCF6A80, &dword_1CB82C000);
}

double llvm::LowerAtomicPass::run@<D0>(llvm::AtomicCmpXchgInst *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v3 = (void *)*((void *)a1 + 10);
  if (v3 != (void *)((char *)a1 + 72))
  {
    while (1)
    {
      long long v4 = v3 - 3;
      if (!v3) {
        long long v4 = 0;
      }
      uint64_t v5 = v4 + 5;
      uint64_t v6 = (void *)v4[6];
      if (v6 != v5) {
        break;
      }
LABEL_34:
      uint64_t v3 = (void *)v3[1];
      if (v3 == (void *)((char *)a1 + 72)) {
        goto LABEL_35;
      }
    }
    while (1)
    {
      uint64_t v7 = (void *)v6[1];
      if (v6) {
        uint64_t v8 = (uint64_t **)(v6 - 3);
      }
      else {
        uint64_t v8 = 0;
      }
      int v9 = *((unsigned __int8 *)v8 + 16);
      if (v6 && v9 == 63) {
        llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
      }
      if (v6 && v9 == 64) {
        llvm::lowerAtomicCmpXchgInst(v8, a1);
      }
      if (v6 && v9 == 65) {
        llvm::lowerAtomicRMWInst(v8, a1);
      }
      if (v9 == 60) {
        uint64_t v10 = (uint64_t)v8;
      }
      else {
        uint64_t v10 = 0;
      }
      if (!v6 || v9 != 60)
      {
        uint64_t v10 = v9 == 61 ? (uint64_t)v8 : 0;
        if (!v6 || v9 != 61) {
          goto LABEL_33;
        }
      }
      int v11 = *(unsigned __int8 *)(v10 + 16);
      if (v11 != 60 && v11 != 61) {
        break;
      }
      if ((*(_WORD *)(v10 + 18) & 0x380) != 0) {
        goto LABEL_27;
      }
LABEL_33:
      uint64_t v6 = v7;
      if (v7 == v5) {
        goto LABEL_34;
      }
    }
    if ((v11 - 63) >= 3) {
      goto LABEL_33;
    }
LABEL_27:
    *(_WORD *)(v10 + 18) &= 0xFC7Fu;
    *(unsigned char *)(v10 + 60) = 1;
    goto LABEL_33;
  }
LABEL_35:
  *(void *)(a2 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a2 = a2 + 32;
  *(void *)(a2 + 8) = a2 + 32;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 48) = a2 + 80;
  *(void *)(a2 + 56) = a2 + 80;
  *(void *)(a2 + 64) = 2;
  *(_DWORD *)(a2 + 72) = 0;
  *(void *)&double result = 0x100000002;
  *(void *)(a2 + 16) = 0x100000002;
  return result;
}

void sub_1CCE2590C()
{
}

uint64_t sub_1CCE259A8(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF6B40;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263F820;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF6B48, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCE2590C;
    v5[1] = &PassRegistry;
    long long v4 = v5;
    std::__call_once(&qword_1EBCF6B48, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CCE25A58()
{
}

void sub_1CCE25A98(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CCE25AD0(uint64_t a1, llvm::AtomicCmpXchgInst *a2)
{
  v24[0] = 0;
  v24[1] = 0;
  int v25 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  int v28 = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  int v31 = 0;
  llvm::LowerAtomicPass::run(a2, (uint64_t)&v16);
  if (v22 != v23)
  {
    BOOL v6 = 1;
    goto LABEL_32;
  }
  int v2 = v16;
  if (v17 == v16)
  {
    unsigned int v3 = v19;
    long long v4 = (void **)&v17[8 * v19];
    if (v19)
    {
      uint64_t v5 = 0;
      while (*(_UNKNOWN **)&v17[v5] != &llvm::PreservedAnalyses::AllAnalysesKey)
      {
        v5 += 8;
        if (8 * v19 == v5) {
          goto LABEL_21;
        }
      }
      long long v4 = (void **)&v17[v5];
    }
LABEL_21:
    int v2 = v17;
    goto LABEL_28;
  }
  unsigned int v7 = v18 - 1;
  unsigned int v8 = (v18 - 1) & ((&llvm::PreservedAnalyses::AllAnalysesKey >> 4) ^ (&llvm::PreservedAnalyses::AllAnalysesKey >> 9));
  long long v4 = (void **)&v17[8 * v8];
  int v9 = *v4;
  if (*v4 != (void *)-1)
  {
    uint64_t v10 = 0;
    int v11 = 1;
    while (v9 != &llvm::PreservedAnalyses::AllAnalysesKey)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v9 == (void *)-2;
      }
      if (v12) {
        uint64_t v10 = v4;
      }
      unsigned int v13 = v8 + v11++;
      unsigned int v8 = v13 & v7;
      long long v4 = (void **)&v17[8 * (v13 & v7)];
      int v9 = *v4;
      if (*v4 == (void *)-1) {
        goto LABEL_23;
      }
    }
LABEL_27:
    unsigned int v3 = v19;
    goto LABEL_28;
  }
  uint64_t v10 = 0;
LABEL_23:
  if (v10) {
    long long v4 = v10;
  }
  if (*v4 == &llvm::PreservedAnalyses::AllAnalysesKey) {
    goto LABEL_27;
  }
  unsigned int v3 = v19;
  long long v4 = (void **)&v17[8 * v18];
LABEL_28:
  if (v17 == v2) {
    unsigned int v14 = v3;
  }
  else {
    unsigned int v14 = v18;
  }
  BOOL v6 = v4 == (void **)&v17[8 * v14];
LABEL_32:
  if (v21 != v20) {
    free(v21);
  }
  if (v17 != v16) {
    free(v17);
  }
  MEMORY[0x1D25D9CD0](0, 8);
  MEMORY[0x1D25D9CD0](0, 8);
  sub_1CBF54128((unsigned int *)v24);
  MEMORY[0x1D25D9CD0](v24[0], 8);
  return v6;
}

void llvm::LowerConstantIntrinsicsPass::run()
{
}

BOOL sub_1CCE25D74(unint64_t a1, uint64_t a2, uint64_t a3)
{
  v104[8] = *MEMORY[0x1E4F143B8];
  uint64_t v87 = a3;
  v91[0] = 0;
  char v92 = 0;
  if (a3)
  {
    LOBYTE(v94) = 1;
    sub_1CD513098((uint64_t)v91, &v87, (char *)&v94);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  int v88 = (char *)&v90;
  uint64_t v89 = 0x800000000;
  unint64_t v94 = a1;
  int v85 = 0;
  uint64_t v86 = 0;
  uint64_t __p = 0;
  sub_1CC86D39C((char **)&__p, (uint64_t)&v94);
  int v9 = (char *)__p;
  unsigned int v8 = v85;
  if (v85 != __p)
  {
    do
    {
      uint64_t v10 = *((void *)v8 - 1);
      v8 -= 8;
      uint64_t v11 = v10 + 40;
      for (uint64_t i = *(void *)(v10 + 48); i != v11; uint64_t i = *(void *)(i + 8))
      {
        uint64_t v13 = i - 24;
        if (!i) {
          uint64_t v13 = 0;
        }
        if (*(unsigned char *)(v13 + 16) == 84)
        {
          uint64_t v14 = *(void *)(v13 - 32);
          if (v14)
          {
            if (!*(unsigned char *)(v14 + 16)
              && *(void *)(v14 + 24) == *(void *)(v13 + 72)
              && (*(unsigned char *)(v14 + 33) & 0x20) != 0)
            {
              int v15 = *(_DWORD *)(*(void *)(i - 56) + 36);
              if (v15 == 236 || v15 == 165)
              {
                unint64_t v94 = 6;
                uint64_t v95 = 0;
                unsigned int v96 = (int32x2_t ****)v13;
                if (v13 != -8192 && v13 != -4096 && v13) {
                  llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v94);
                }
                uint64_t v16 = v88;
                if (v89 >= HIDWORD(v89))
                {
                  unint64_t v34 = v89 + 1;
                  if (v88 <= (char *)&v94 && &v88[24 * v89] > (char *)&v94)
                  {
                    uint64_t v81 = (char *)&v94 - v88;
                    sub_1CC261F80((unsigned int *)&v88, v34);
                    uint64_t v16 = v88;
                    uint64_t v17 = &v88[v81];
                  }
                  else
                  {
                    sub_1CC261F80((unsigned int *)&v88, v34);
                    uint64_t v17 = (char *)&v94;
                    uint64_t v16 = v88;
                  }
                }
                else
                {
                  uint64_t v17 = (char *)&v94;
                }
                int v18 = v89;
                unsigned int v19 = (unint64_t *)&v16[24 * v89];
                *unsigned int v19 = 6;
                v19[1] = 0;
                unint64_t v20 = *((void *)v17 + 2);
                void v19[2] = v20;
                if (v20 != -8192 && v20 != -4096)
                {
                  if (v20)
                  {
                    unint64_t v21 = *(void *)v17 & 0xFFFFFFFFFFFFFFF8;
                    v19[1] = *(void *)v21;
                    *(void *)unint64_t v21 = v19;
                    *unsigned int v19 = v21 | 6;
                    int v22 = (unint64_t *)v19[1];
                    if (v22) {
                      *int v22 = *v22 & 7 | (unint64_t)(v19 + 1);
                    }
                  }
                }
                LODWORD(v89) = v18 + 1;
                if (v96 != (int32x2_t ****)-8192 && v96 != (int32x2_t ****)-4096 && v96)
                {
                  unint64_t v23 = v94 & 0xFFFFFFFFFFFFFFF8;
                  *(void *)(v94 & 0xFFFFFFFFFFFFFFF8) = v95;
                  if (v95)
                  {
                    *(void *)uint64_t v95 = *(void *)v95 & 7 | v23;
                  }
                  else
                  {
                    uint64_t v24 = v96;
                    int v25 = ***v96;
                    unint64_t v26 = (unint64_t)v25[303];
                    if (v26 <= v23)
                    {
                      uint64_t v27 = v25[305].u32[0];
                      if (v26 + 16 * v27 > v23)
                      {
                        unsigned int v28 = v27 - 1;
                        LODWORD(v29) = v28 & ((v96 >> 4) ^ (v96 >> 9));
                        uint64_t v30 = (int32x2_t *****)(v26 + 16 * v29);
                        int v31 = *v30;
                        if (v96 == *v30)
                        {
LABEL_37:
                          *uint64_t v30 = (int32x2_t ****)-8192;
                          v25[304] = vadd_s32(v25[304], (int32x2_t)0x1FFFFFFFFLL);
                          uint64_t v24 = v96;
                        }
                        else
                        {
                          int v32 = 1;
                          while (v31 != (int32x2_t ****)-4096)
                          {
                            int v33 = v29 + v32++;
                            uint64_t v29 = v33 & v28;
                            int v31 = *(int32x2_t *****)(v26 + 16 * v29);
                            if (v96 == v31)
                            {
                              uint64_t v30 = (int32x2_t *****)(v26 + 16 * v29);
                              goto LABEL_37;
                            }
                          }
                        }
                        *((unsigned char *)v24 + 17) &= ~1u;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    while (v8 != v9);
  }
  if (v89)
  {
    int v35 = 0;
    uint64_t v36 = v4 + 272;
    uint64_t v37 = v88;
    uint64_t v38 = &v88[24 * v89];
    uint64_t v39 = (char *)&v96;
    int64x2_t v40 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    while (1)
    {
      BOOL v41 = (uint64_t ***)*((void *)v37 + 2);
      if (!v41) {
        goto LABEL_57;
      }
      if (*((unsigned char *)v41 + 16) != 84) {
        goto LABEL_57;
      }
      uint64_t v42 = (uint64_t)*(v41 - 4);
      if (!v42 || *(unsigned char *)(v42 + 16) || *(uint64_t ***)(v42 + 24) != v41[9] || (*(unsigned char *)(v42 + 33) & 0x20) == 0) {
        goto LABEL_57;
      }
      int64x2_t v82 = v40;
      int v43 = *(_DWORD *)(v42 + 36);
      if (v43 == 236)
      {
        int v76 = v35;
        uint64_t v78 = v36;
        uint64_t v48 = llvm::lowerObjectSizeCall((llvm::Instruction *)v41, v36, a2, 0, 1, v6, v7);
        int64x2_t v49 = v82;
        goto LABEL_75;
      }
      if (v43 == 165) {
        break;
      }
LABEL_56:
      int64x2_t v40 = v82;
LABEL_57:
      v37 += 24;
      if (v37 == v38) {
        goto LABEL_130;
      }
    }
    int v76 = v35;
    uint64_t v78 = v36;
    unint64_t v44 = (unsigned __int8 *)v41[-4 * (*((_DWORD *)v41 + 5) & 0x7FFFFFF)];
    if (v44) {
      BOOL v45 = v44[16] > 0x14u;
    }
    else {
      BOOL v45 = 1;
    }
    if (v45 || !llvm::Constant::isManifestConstant((llvm::Constant *)v44))
    {
      uint64_t v46 = *v41;
      uint64_t v54 = **v41;
      uint64_t v55 = *v54;
      uint64_t v48 = *(llvm::Value **)(*v54 + 1568);
      int64x2_t v49 = v82;
      if (!v48)
      {
        uint64_t v72 = *(llvm::ConstantInt **)(v55 + 1888);
        LODWORD(v95) = *(_DWORD *)(v55 + 1896) >> 8;
        if (v95 > 0x40) {
          llvm::APInt::initSlowCase((llvm::APInt *)&v94);
        }
        unint64_t v94 = 0;
        uint64_t v48 = (llvm::Value *)llvm::ConstantInt::get(v72, (llvm::LLVMContext *)&v94, v5);
        if (v95 >= 0x41 && v94)
        {
          uint64_t v80 = v48;
          MEMORY[0x1D25D9CB0](v94, 0x1000C8000313F17);
          uint64_t v48 = v80;
        }
        *(void *)(v55 + 1568) = v48;
LABEL_123:
        int64x2_t v49 = v82;
      }
    }
    else
    {
      uint64_t v46 = *v41;
      uint64_t v47 = ***v41;
      uint64_t v48 = *(llvm::Value **)(v47 + 1560);
      int64x2_t v49 = v82;
      if (!v48)
      {
        uint64_t v50 = *(llvm::ConstantInt **)(v47 + 1888);
        uint64_t v79 = ***v41;
        unint64_t v51 = *(unsigned int *)(v47 + 1896);
        LODWORD(v95) = v51 >> 8;
        if (v51 >> 8 > 0x40) {
          llvm::APInt::initSlowCase((llvm::APInt *)&v94);
        }
        if (v51 <= 0xFF) {
          char v52 = 0;
        }
        else {
          char v52 = 0xFFFFFFFFFFFFFFFFLL >> -BYTE1(v51);
        }
        unint64_t v94 = v52 & 1;
        BOOL v53 = (llvm::Value *)llvm::ConstantInt::get(v50, (llvm::LLVMContext *)&v94, v5);
        if (v95 >= 0x41 && v94) {
          MEMORY[0x1D25D9CB0](v94, 0x1000C8000313F17);
        }
        uint64_t v48 = v53;
        *(void *)(v79 + 1560) = v53;
        goto LABEL_123;
      }
    }
    if ((v46[1] & 0xFE) == 0x12)
    {
      Splat = llvm::ConstantVector::getSplat((llvm::Type *)(*((unsigned int *)v46 + 8) | ((unint64_t)(*((_DWORD *)v46 + 2) == 19) << 32)), (uint64_t)v48);
      int64x2_t v49 = v82;
      uint64_t v48 = Splat;
    }
LABEL_75:
    uint64_t v97 = 1;
    int64x2_t v98 = v49;
    int64x2_t v99 = v49;
    int64x2_t v100 = v49;
    int64x2_t v101 = v49;
    uint64_t v102 = v104;
    uint64_t v103 = 0x800000000;
    llvm::replaceAndRecursivelySimplify((llvm::Instruction *)v41, v48, 0, 0, 0, (uint64_t)&v97);
    uint64_t v77 = v39;
    unint64_t v94 = (unint64_t)v39;
    uint64_t v95 = 0x800000000;
    sub_1CD7775FC((unsigned int *)&v94, (char *)v102, (char *)v102 + 8 * v103);
    if (!v95)
    {
LABEL_115:
      sub_1CC0BDE04((char **)&v94);
      if (v102 != v104) {
        free(v102);
      }
      uint64_t v39 = v77;
      if ((v97 & 1) == 0) {
        MEMORY[0x1D25D9CD0](v98.i64[0], 8);
      }
      int v35 = v76;
      uint64_t v36 = v78;
      goto LABEL_56;
    }
    uint64_t v56 = (char *)v94;
    uint64_t v57 = (char *)(v94 + 24 * v95);
    while (1)
    {
      uint64_t v58 = *((void *)v56 + 2);
      if (v58)
      {
        if (*(unsigned char *)(v58 + 16) == 30)
        {
          uint64_t v59 = *(_DWORD *)(v58 + 20) & 0x7FFFFFF;
          if (v59 != 1)
          {
            uint64_t v60 = *(void *)(v58 - 32 * v59);
            unsigned int v61 = *(unsigned __int8 *)(v60 + 16);
            if (v60) {
              BOOL v62 = v61 > 0x14;
            }
            else {
              BOOL v62 = 1;
            }
            if (!v62)
            {
              if (v61 == 16)
              {
                uint64_t v63 = *(unsigned int *)(v60 + 32);
                if (v63 >= 0x41)
                {
                  int v68 = 0;
                  int64_t v69 = (unint64_t)(v63 + 63) >> 6;
                  do
                  {
                    BOOL v45 = v69-- < 1;
                    if (v45) {
                      break;
                    }
                    unint64_t v70 = *(void *)(*(void *)(v60 + 24) + 8 * v69);
                    v68 += __clz(v70);
                  }
                  while (!v70);
                  int v71 = v63 | 0xFFFFFFC0;
                  if ((v63 & 0x3F) == 0) {
                    int v71 = 0;
                  }
                  if (v68 + v71 == v63)
                  {
LABEL_88:
                    uint64_t v64 = (llvm::Type **)(v58 - 32);
                    int v65 = (llvm::Type **)(v58 - 64);
                    goto LABEL_92;
                  }
                }
                else if (!*(void *)(v60 + 24))
                {
                  goto LABEL_88;
                }
              }
              else if (v61 == 17)
              {
                if (sub_1CB844168(v60, 0.0)) {
                  goto LABEL_88;
                }
              }
              else if (v61 - 18 < 3 || v61 == 13)
              {
                goto LABEL_88;
              }
              if (sub_1CC03F414((uint64_t)&v93, (llvm::Constant *)v60)) {
                goto LABEL_88;
              }
              uint64_t v60 = *(void *)(v58 - 32 * (*(_DWORD *)(v58 + 20) & 0x7FFFFFF));
            }
            if (sub_1CBF5250C((uint64_t)&v93, (llvm::Constant *)v60))
            {
              int v65 = (llvm::Type **)(v58 - 32);
              uint64_t v64 = (llvm::Type **)(v58 - 64);
LABEL_92:
              if (*v65) {
                BOOL v66 = *v65 == *v64;
              }
              else {
                BOOL v66 = 1;
              }
              if (!v66)
              {
                llvm::BasicBlock::removePredecessor(*v64, *(llvm::BasicBlock **)(v58 + 40), 0);
                llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
              }
            }
          }
        }
      }
      v56 += 24;
      if (v56 == v57) {
        goto LABEL_115;
      }
    }
  }
LABEL_130:
  int v74 = v89;
  if (__p)
  {
    int v85 = (char *)__p;
    operator delete(__p);
  }
  sub_1CC45E8E8(&v88);
  if (v92) {
    sub_1CC2930C0((uint64_t)v91);
  }
  return v74 != 0;
}

void sub_1CCE26674(uint64_t a1)
{
}

uint64_t sub_1CCE26718(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF6B50;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263F8C0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF6B58, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCE26674;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCF6B58, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CCE267C8()
{
}

void sub_1CCE26808(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCE26840(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetLibraryInfoWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);

  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
}

void sub_1CCE268A8(uint64_t a1, uint64_t a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unsigned int v3 = *(uint64_t **)(a1 + 8);
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 == v5)
  {
LABEL_4:
    uint64_t v6 = 0;
  }
  else
  {
    while (*(char **)v4 != llvm::TargetLibraryInfoWrapperPass::ID)
    {
      v4 += 16;
      if (v4 == v5) {
        goto LABEL_4;
      }
    }
    uint64_t v6 = *(void *)(v4 + 8);
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v6 + 96))(v6, llvm::TargetLibraryInfoWrapperPass::ID);
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  int v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  int v16 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  int v19 = 0;
  uint64_t v8 = v7 + 32;
  if (!*(unsigned char *)(v7 + 232))
  {
    uint64_t v9 = *(void *)(a2 + 40) + 216;
    __int16 v21 = 260;
    v20[0] = v9;
    llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v20);
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    int v33 = 0;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    *(void *)&long long v10 = -1;
    *((void *)&v10 + 1) = -1;
    *(_OWORD *)__src = v10;
    long long v25 = v10;
    long long v26 = v10;
    long long v27 = v10;
    long long v28 = v10;
    long long v29 = v10;
    *(_OWORD *)uint64_t v30 = v10;
    *(void *)&v30[13] = -1;
    sub_1CC153974((uint64_t)__src, (int *)__p);
    sub_1CD4D04B8(v8, (uint64_t)__src);
    sub_1CD4CFA4C((uint64_t *)__src);
    if (v23 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_1CC1569E8(__src, v8);
}

double llvm::LowerExpectIntrinsicPass::run@<D0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if (sub_1CCE26CC0(a1))
  {
    int v4 = 0;
    *(void *)(a2 + 88) = 0;
    *(_OWORD *)(a2 + 72) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 24) = 0u;
    uint64_t v3 = a2 + 32;
  }
  else
  {
    *(void *)(a2 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
    uint64_t v3 = a2 + 32;
    int v4 = 1;
  }
  *(void *)a2 = v3;
  *(void *)(a2 + 8) = v3;
  *(_DWORD *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 20) = v4;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 48) = a2 + 80;
  *(void *)(a2 + 56) = a2 + 80;
  *(void *)&double result = 2;
  *(void *)(a2 + 64) = 2;
  *(_DWORD *)(a2 + 72) = 0;
  return result;
}

uint64_t sub_1CCE26CC0(uint64_t a1)
{
  uint64_t v169 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1 + 72;
  uint64_t v2 = *(void *)(a1 + 80);
  if (v2 != a1 + 72)
  {
    uint64_t v155 = a1 + 72;
    do
    {
      uint64_t v161 = v2;
      if (v2) {
        uint64_t v3 = v2 - 24;
      }
      else {
        uint64_t v3 = 0;
      }
      uint64_t v6 = *(void ***)(v3 + 40);
      uint64_t v5 = (void **)(v3 + 40);
      int v4 = v6;
      int v158 = v5;
      if (v6 == v5) {
        goto LABEL_78;
      }
      if (v4) {
        uint64_t v7 = (uint64_t)(v4 - 3);
      }
      else {
        uint64_t v7 = 0;
      }
      unsigned int v8 = *(unsigned __int8 *)(v7 + 16) - 40;
      if (v8 >= 0xFFFFFFF5) {
        uint64_t v9 = v7;
      }
      else {
        uint64_t v9 = 0;
      }
      int v10 = *(unsigned __int8 *)(v9 + 16);
      if (v4 && (v10 == 30 ? (BOOL v11 = v8 >= 0xFFFFFFF5) : (BOOL v11 = 0), v11))
      {
        if ((*(_DWORD *)(v9 + 20) & 0x7FFFFFF) != 1)
        {
          int v13 = (void *)(v9 - 96);
          uint64_t v12 = *(void *)(v9 - 96);
          int v14 = *(unsigned __int8 *)(v12 + 16);
          if (v14 == 81) {
            uint64_t v15 = *(void *)(v9 - 96);
          }
          else {
            uint64_t v15 = 0;
          }
          if (v15)
          {
            int v16 = *(_WORD *)(v15 + 18) & 0x3F;
            if ((v16 - 34) < 0xFFFFFFFE) {
              goto LABEL_78;
            }
            uint64_t v17 = *(void *)(v15 - 32);
            if (!v17 || *(unsigned char *)(v17 + 16) != 16) {
              goto LABEL_78;
            }
            uint64_t v12 = *(void *)(v15 - 64);
            if (*(unsigned char *)(v12 + 16) != 84 || *(_DWORD *)(v17 + 32) > 0x40u) {
              goto LABEL_78;
            }
            uint64_t v19 = *(void *)(v17 + 24);
          }
          else
          {
            if (v14 != 84) {
              goto LABEL_78;
            }
            uint64_t v19 = 0;
            int v16 = 33;
          }
          uint64_t v43 = *(void *)(v12 - 32);
          if (v43)
          {
            if (!*(unsigned char *)(v43 + 16) && *(void *)(v43 + 24) == *(void *)(v12 + 72))
            {
              int v44 = *(_DWORD *)(v43 + 36);
              if ((v44 - 77) <= 1)
              {
                BOOL v45 = (uint64_t *)(v12 - 32 * (*(_DWORD *)(v12 + 20) & 0x7FFFFFF));
                uint64_t v46 = v45[4];
                if (v46 && *(unsigned char *)(v46 + 16) == 16)
                {
                  uint64_t v137 = *v45;
                  unint64_t __src = **(void **)v12;
                  unint64_t v138 = sub_1CCE27C74(v44, v12, 2);
                  unint64_t v139 = v138;
                  int v164 = v166;
                  uint64_t v165 = 0x400000000;
                  unint64_t v140 = (void *)(v46 + 24);
                  if (*(_DWORD *)(v46 + 32) >= 0x41u) {
                    unint64_t v140 = (void *)*v140;
                  }
                  unint64_t v141 = HIDWORD(v138);
                  if ((v16 == 32) == (*v140 != v19))
                  {
                    int v167 = (uint64_t *)__PAIR64__(v138, HIDWORD(v138));
                    BranchWeights = llvm::MDBuilder::createBranchWeights((uint64_t **)&__src, (uint64_t)&v167, 2);
                    LODWORD(v165) = 0;
                    if (HIDWORD(v165) <= 1) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    *(void *)int v164 = v141 | (v139 << 32);
                  }
                  else
                  {
                    int v167 = (uint64_t *)v138;
                    BranchWeights = llvm::MDBuilder::createBranchWeights((uint64_t **)&__src, (uint64_t)&v167, 2);
                    LODWORD(v165) = 0;
                    if (HIDWORD(v165) <= 1) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    *(void *)int v164 = v139;
                  }
                  uint64_t v143 = (v165 + 2);
                  LODWORD(v165) = v165 + 2;
                  if (v15)
                  {
                    int32x2_t v148 = (void *)(v15 - 64);
                    if (*(void *)(v15 - 64))
                    {
                      **(void **)(v15 - 48) = *(void *)(v15 - 56);
                      uint64_t v149 = *(void *)(v15 - 56);
                      if (v149) {
                        *(void *)(v149 + 16) = *(void *)(v15 - 48);
                      }
                    }
                    *int32x2_t v148 = v137;
                    if (v137)
                    {
                      uint64_t v152 = *(void *)(v137 + 8);
                      uint64_t v151 = (void *)(v137 + 8);
                      uint64_t v150 = v152;
                      *(void *)(v15 - 56) = v152;
                      if (v152) {
                        *(void *)(v150 + 16) = v15 - 56;
                      }
                      *(void *)(v15 - 48) = v151;
                      *uint64_t v151 = v148;
                    }
                  }
                  else
                  {
                    if (*v13)
                    {
                      **(void **)(v9 - 80) = *(void *)(v9 - 88);
                      uint64_t v144 = *(void *)(v9 - 88);
                      if (v144) {
                        *(void *)(v144 + 16) = *(void *)(v9 - 80);
                      }
                    }
                    *int v13 = v137;
                    if (v137)
                    {
                      uint64_t v147 = *(void *)(v137 + 8);
                      uint64_t v146 = (void *)(v137 + 8);
                      uint64_t v145 = v147;
                      *(void *)(v9 - 88) = v147;
                      if (v147) {
                        *(void *)(v145 + 16) = v9 - 88;
                      }
                      *(void *)(v9 - 80) = v146;
                      *uint64_t v146 = v13;
                    }
                  }
                  llvm::misexpect::checkFrontendInstrumentation((llvm::misexpect *)v9, (uint64_t)v164, v143);
                  uint64_t v42 = (llvm::Instruction *)v9;
                  BOOL v41 = BranchWeights;
                  goto LABEL_291;
                }
              }
            }
          }
        }
      }
      else if (v4)
      {
        if (v10 == 31 && v8 >= 0xFFFFFFF5)
        {
          int v21 = *(_DWORD *)(v9 + 20);
          int v22 = (v21 & 0x40000000) != 0 ? *(uint64_t **)(v9 - 8) : (uint64_t *)(v9 - 32 * (v21 & 0x7FFFFFF));
          uint64_t v23 = *v22;
          if (*v22)
          {
            if (*(unsigned char *)(v23 + 16) == 84)
            {
              uint64_t v24 = *(void *)(v23 - 32);
              if (v24)
              {
                if (!*(unsigned char *)(v24 + 16)
                  && *(void *)(v24 + 24) == *(void *)(v23 + 72)
                  && (*(_DWORD *)(v24 + 36) - 77) <= 1)
                {
                  long long v25 = (uint64_t *)(v23 - 32 * (*(_DWORD *)(v23 + 20) & 0x7FFFFFF));
                  uint64_t v26 = v25[4];
                  if (v26 && *(unsigned char *)(v26 + 16) == 16)
                  {
                    uint64_t v28 = *v25;
                    sub_1CC025540(v9, v26);
                    int v30 = v29;
                    unint64_t v31 = ((unint64_t)*(unsigned int *)(v9 + 20) >> 1) & 0x3FFFFFF;
                    unint64_t v32 = sub_1CCE27C74(*(_DWORD *)(v24 + 36), v23, (*(_DWORD *)(v9 + 20) >> 1) & 0x3FFFFFF);
                    int v33 = v166;
                    int v164 = v166;
                    HIDWORD(v165) = 16;
                    if (v31 >= 0x11)
                    {
                      LODWORD(v165) = 0;
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    if (v31)
                    {
                      unint64_t v34 = v31;
                      do
                      {
                        *v33++ = HIDWORD(v32);
                        --v34;
                      }
                      while (v34);
                    }
                    LODWORD(v165) = v31;
                    if (v30 == 4294967294) {
                      uint64_t v35 = 0;
                    }
                    else {
                      uint64_t v35 = (v30 + 1);
                    }
                    v166[v35] = v32;
                    llvm::misexpect::checkFrontendInstrumentation((llvm::misexpect *)v9, (uint64_t)v166, v165);
                    int v36 = *(_DWORD *)(v9 + 20);
                    if ((v36 & 0x40000000) != 0) {
                      uint64_t v37 = *(void *)(v9 - 8);
                    }
                    else {
                      uint64_t v37 = v9 - 32 * (v36 & 0x7FFFFFF);
                    }
                    if (*(void *)v37)
                    {
                      **(void **)(v37 + 16) = *(void *)(v37 + 8);
                      uint64_t v153 = *(void *)(v37 + 8);
                      if (v153) {
                        *(void *)(v153 + 16) = *(void *)(v37 + 16);
                      }
                    }
                    *(void *)uint64_t v37 = v28;
                    if (v28)
                    {
                      uint64_t v40 = *(void *)(v28 + 8);
                      uint64_t v39 = (uint64_t *)(v28 + 8);
                      uint64_t v38 = v40;
                      *(void *)(v37 + 8) = v40;
                      if (v40) {
                        *(void *)(v38 + 16) = v37 + 8;
                      }
                      *(void *)(v37 + 16) = v39;
                      uint64_t *v39 = v37;
                    }
                    int v167 = **(uint64_t ***)v23;
                    BOOL v41 = llvm::MDBuilder::createBranchWeights(&v167, (uint64_t)v164, v165);
                    uint64_t v42 = (llvm::Instruction *)v9;
LABEL_291:
                    llvm::Instruction::setMetadata(v42, 2, v41);
                    if (v164 != v166) {
                      free(v164);
                    }
                    uint64_t v5 = v158;
                  }
                }
              }
            }
          }
        }
      }
LABEL_78:
      uint64_t v48 = *v5;
      if (*v5 != v5)
      {
        do
        {
          int64x2_t v49 = (void *)*v48;
          int v50 = *((unsigned __int8 *)v48 - 8);
          if (v50 == 84) {
            unint64_t v51 = (llvm::ValueAsMetadata *)(v48 - 3);
          }
          else {
            unint64_t v51 = 0;
          }
          if (v50 == 84)
          {
            uint64_t v52 = *(v48 - 7);
            if (v52
              && !*(unsigned char *)(v52 + 16)
              && *(void *)(v52 + 24) == v48[6]
              && (*(_DWORD *)(v52 + 36) - 77) <= 1)
            {
              uint64_t v53 = *((_DWORD *)v48 - 1) & 0x7FFFFFF;
              uint64_t v54 = &v48[-4 * v53 - 3];
              uint64_t v55 = v54[4];
              uint64_t v156 = v55;
              if (v55) {
                BOOL v56 = *(unsigned char *)(v55 + 16) == 16;
              }
              else {
                BOOL v56 = 0;
              }
              if (!v56)
              {
LABEL_234:
                llvm::Value::doRAUW(v51, *((llvm::Value **)v51 - 4 * v53), (llvm::Value *)1);
                llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
              }
              unsigned int v57 = 0;
              uint64_t v58 = *v54;
              int v164 = v166;
              uint64_t v165 = 0x400000000;
              while (2)
              {
                unsigned int v59 = *(unsigned __int8 *)(v58 + 16);
                if (v59 <= 0x43)
                {
                  if (v59 == 58)
                  {
                    uint64_t v61 = *(void *)(v58 - 32);
                    if (v61) {
                      BOOL v62 = *(unsigned char *)(v61 + 16) == 16;
                    }
                    else {
                      BOOL v62 = 0;
                    }
                    if (!v62) {
                      goto LABEL_231;
                    }
                    uint64_t v60 = *(void *)(v58 - 64);
                  }
                  else
                  {
                    if (v59 != 67) {
                      goto LABEL_231;
                    }
LABEL_98:
                    uint64_t v60 = *(void *)(v58 - 32);
                  }
                  if (v57 >= HIDWORD(v165)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((void *)v164 + v57) = v58;
                  unsigned int v57 = v165 + 1;
                  LODWORD(v165) = v165 + 1;
                  uint64_t v58 = v60;
                  continue;
                }
                break;
              }
              if (v59 == 68) {
                goto LABEL_98;
              }
              if (v59 != 83 || (uint64_t v159 = (llvm::MDNode *)(*(_DWORD *)(v58 + 20) & 0x7FFFFFF), !v159))
              {
LABEL_231:
                if (v164 != v166) {
                  free(v164);
                }
                uint64_t v53 = *((_DWORD *)v48 - 1) & 0x7FFFFFF;
                goto LABEL_234;
              }
              uint64_t v76 = 0;
              while (2)
              {
                int v77 = *(_DWORD *)(v58 + 20);
                if ((v77 & 0x40000000) != 0) {
                  uint64_t v78 = *(void *)(v58 - 8);
                }
                else {
                  uint64_t v78 = v58 - 32 * (v77 & 0x7FFFFFF);
                }
                uint64_t v79 = *(void *)(v78 + 32 * v76);
                if (v79) {
                  BOOL v80 = *(unsigned char *)(v79 + 16) == 16;
                }
                else {
                  BOOL v80 = 0;
                }
                if (!v80)
                {
LABEL_230:
                  if ((llvm::MDNode *)++v76 == v159) {
                    goto LABEL_231;
                  }
                  continue;
                }
                break;
              }
              unsigned int v81 = *(_DWORD *)(v79 + 32);
              unsigned int v163 = v81;
              if (v81 > 0x40) {
                operator new[]();
              }
              unint64_t __src = *(void *)(v79 + 24);
              if (v165)
              {
                int64x2_t v82 = (char *)v164;
                unsigned int v83 = (char *)v164 + 8 * v165;
                while (1)
                {
                  uint64_t v85 = *((void *)v83 - 1);
                  v83 -= 8;
                  uint64_t v84 = (_DWORD *)v85;
                  int v86 = *(unsigned __int8 *)(v85 + 16);
                  if (v86 == 68) {
                    break;
                  }
                  if (v86 == 67)
                  {
                    unint64_t v87 = *(unsigned int *)(*(void *)v84 + 8);
                    if (v87 >> 8 > 0x40)
                    {
                      if (v81 != (v87 >> 8)) {
                        operator new[]();
                      }
                      sub_1CD0463BC((uint64_t)&v167, (uint64_t)&__src);
                    }
                    else
                    {
                      unsigned int v168 = v87 >> 8;
                      if (v87 <= 0xFF) {
                        unint64_t v88 = 0;
                      }
                      else {
                        unint64_t v88 = 0xFFFFFFFFFFFFFFFFLL >> -BYTE1(v87);
                      }
                      int v167 = (uint64_t *)(v88 & __src);
                    }
                    goto LABEL_157;
                  }
                  int v89 = v84[5];
                  if ((v89 & 0x40000000) != 0) {
                    uint64_t v90 = (_DWORD *)*((void *)v84 - 1);
                  }
                  else {
                    uint64_t v90 = &v84[-8 * (v89 & 0x7FFFFFF)];
                  }
                  uint64_t v91 = *((void *)v90 + 4);
                  unsigned int v81 = v163;
                  if (v163 > 0x40)
                  {
                    char v92 = (void *)__src;
                    uint64_t v93 = *(uint64_t **)(v91 + 24);
                    unint64_t v94 = ((unint64_t)v163 + 63) >> 6;
                    do
                    {
                      uint64_t v95 = *v93++;
                      *v92++ ^= v95;
                      --v94;
                    }
                    while (v94);
                  }
                  else
                  {
                    __src ^= *(void *)(v91 + 24);
                  }
LABEL_161:
                  if (v83 == v82) {
                    goto LABEL_174;
                  }
                }
                llvm::APInt::sext((uint64_t)&__src, *(_DWORD *)(*(void *)v84 + 8) >> 8, (uint64_t)&v167);
LABEL_157:
                if (v163 >= 0x41 && __src) {
                  MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
                }
                unint64_t __src = (unint64_t)v167;
                unsigned int v81 = v168;
                unsigned int v163 = v168;
                goto LABEL_161;
              }
LABEL_174:
              uint64_t v96 = *(unsigned int *)(v156 + 32);
              unint64_t v97 = __src;
              if (v96 > 0x40) {
                BOOL v98 = memcmp(*(const void **)(v156 + 24), (const void *)__src, ((unint64_t)(v96 + 63) >> 3) & 0x3FFFFFF8) == 0;
              }
              else {
                BOOL v98 = *(void *)(v156 + 24) == __src;
              }
              char v99 = v98;
              if (v163 >= 0x41 && v97) {
                MEMORY[0x1D25D9CB0](v97, 0x1000C8000313F17);
              }
              if (v99) {
                goto LABEL_230;
              }
              int v100 = *(_DWORD *)(v58 + 20);
              uint64_t v101 = (v100 & 0x40000000) != 0 ? *(void *)(v58 - 8) : v58 - 32 * (v100 & 0x7FFFFFF);
              uint64_t v102 = *(unsigned int *)(v58 + 60);
              uint64_t v103 = *(llvm::BasicBlock **)(v101 + 32 * v102 + 8 * v76);
              uint64_t v104 = (void *)*((void *)v103 + 5);
              if (v104 == (void *)((char *)v103 + 40)) {
                goto LABEL_213;
              }
              BOOL v105 = (llvm::Instruction *)(v104 - 3);
              if (v104) {
                uint64_t v106 = v104 - 3;
              }
              else {
                uint64_t v106 = 0;
              }
              unsigned int v107 = *((unsigned __int8 *)v106 + 16) - 40;
              if (v107 < 0xFFFFFFF5) {
                uint64_t v106 = 0;
              }
              if (!v104
                || (*((unsigned char *)v106 + 16) == 30 ? (BOOL v108 = v107 >= 0xFFFFFFF5) : (BOOL v108 = 0),
                    !v108 || (*((_DWORD *)v106 + 5) & 0x7FFFFFF) != 3))
              {
LABEL_213:
                uint64_t SinglePredecessor = llvm::BasicBlock::getSinglePredecessor(v103);
                if (!SinglePredecessor) {
                  goto LABEL_230;
                }
                uint64_t v110 = *(void *)(SinglePredecessor + 40);
                if (v110 == SinglePredecessor + 40) {
                  goto LABEL_230;
                }
                BOOL v105 = (llvm::Instruction *)(v110 - 24);
                if (v110) {
                  uint64_t v111 = v110 - 24;
                }
                else {
                  uint64_t v111 = 0;
                }
                unsigned int v112 = *(unsigned __int8 *)(v111 + 16) - 40;
                if (v112 < 0xFFFFFFF5) {
                  uint64_t v111 = 0;
                }
                if (!v110) {
                  goto LABEL_230;
                }
                BOOL v113 = *(unsigned char *)(v111 + 16) == 30 && v112 >= 0xFFFFFFF5;
                if (!v113 || (*(_DWORD *)(v111 + 20) & 0x7FFFFFF) == 1) {
                  goto LABEL_230;
                }
              }
              unint64_t __src = **(void **)v58;
              if ((v100 & 0x40000000) != 0) {
                uint64_t v114 = *(void *)(v58 - 8);
              }
              else {
                uint64_t v114 = v58 - 32 * (v100 & 0x7FFFFFF);
              }
              uint64_t v115 = *(void *)(v114 + 32 * v102 + 8 * v76);
              uint64_t v116 = (uint64_t *)sub_1CCE27C74(*(_DWORD *)(*(v48 - 7) + 36), (uint64_t)v51, 2);
              uint64_t v117 = *((void *)v105 - 8);
              if (v115 == v117) {
                goto LABEL_228;
              }
              if (v115 != *((void *)v105 + 5))
              {
                if (v115 != *((void *)v105 - 4)) {
                  goto LABEL_230;
                }
                goto LABEL_227;
              }
              uint64_t v118 = *(void *)(v58 + 40);
              if (v118 == v117)
              {
LABEL_228:
                int v167 = v116;
              }
              else
              {
                uint64_t v119 = *((void *)v105 - 4);
                if (v115 != v119 && v118 != v119) {
                  goto LABEL_230;
                }
LABEL_227:
                int v167 = (uint64_t *)__PAIR64__(v116, HIDWORD(v116));
              }
              uint64_t v121 = llvm::MDBuilder::createBranchWeights((uint64_t **)&__src, (uint64_t)&v167, 2);
              llvm::Instruction::setMetadata(v105, 2, v121);
              goto LABEL_230;
            }
          }
          else if (v50 == 85)
          {
            uint64_t v64 = v48 - 15;
            uint64_t v63 = *(v48 - 15);
            int v65 = *(unsigned __int8 *)(v63 + 16);
            if (v65 == 81) {
              uint64_t v66 = *(v48 - 15);
            }
            else {
              uint64_t v66 = 0;
            }
            if (v66)
            {
              int v67 = *(_WORD *)(v66 + 18) & 0x3F;
              if ((v67 - 34) >= 0xFFFFFFFE)
              {
                uint64_t v68 = *(void *)(v66 - 32);
                if (v68 && *(unsigned char *)(v68 + 16) == 16)
                {
                  uint64_t v63 = *(void *)(v66 - 64);
                  if (*(unsigned char *)(v63 + 16) == 84 && *(_DWORD *)(v68 + 32) <= 0x40u)
                  {
                    uint64_t v70 = *(void *)(v68 + 24);
LABEL_124:
                    uint64_t v71 = *(void *)(v63 - 32);
                    if (v71)
                    {
                      if (!*(unsigned char *)(v71 + 16) && *(void *)(v71 + 24) == *(void *)(v63 + 72))
                      {
                        int v72 = *(_DWORD *)(v71 + 36);
                        if ((v72 - 77) <= 1)
                        {
                          uint64_t v73 = (uint64_t *)(v63 - 32 * (*(_DWORD *)(v63 + 20) & 0x7FFFFFF));
                          uint64_t v74 = v73[4];
                          if (v74) {
                            BOOL v75 = *(unsigned char *)(v74 + 16) == 16;
                          }
                          else {
                            BOOL v75 = 0;
                          }
                          if (v75)
                          {
                            uint64_t v122 = *v73;
                            unint64_t __src = **(void **)v63;
                            unint64_t v123 = sub_1CCE27C74(v72, v63, 2);
                            int v164 = v166;
                            uint64_t v165 = 0x400000000;
                            uint64_t v124 = (void *)(v74 + 24);
                            if (*(_DWORD *)(v74 + 32) >= 0x41u) {
                              uint64_t v124 = (void *)*v124;
                            }
                            uint64_t v1 = v155;
                            if ((v67 == 32) == (*v124 != v70))
                            {
                              unint64_t v157 = HIDWORD(v123);
                              int v167 = (uint64_t *)__PAIR64__(v123, HIDWORD(v123));
                              unint64_t v126 = v123;
                              unsigned int v160 = llvm::MDBuilder::createBranchWeights((uint64_t **)&__src, (uint64_t)&v167, 2);
                              LODWORD(v165) = 0;
                              if (HIDWORD(v165) <= 1) {
                                llvm::SmallVectorBase<unsigned int>::grow_pod();
                              }
                              *(void *)int v164 = v157 | (v126 << 32);
                            }
                            else
                            {
                              unint64_t v125 = v123;
                              int v167 = (uint64_t *)v123;
                              unsigned int v160 = llvm::MDBuilder::createBranchWeights((uint64_t **)&__src, (uint64_t)&v167, 2);
                              LODWORD(v165) = 0;
                              if (HIDWORD(v165) <= 1) {
                                llvm::SmallVectorBase<unsigned int>::grow_pod();
                              }
                              *(void *)int v164 = v125;
                            }
                            uint64_t v127 = (v165 + 2);
                            LODWORD(v165) = v165 + 2;
                            if (v66)
                            {
                              int v132 = (void *)(v66 - 64);
                              if (*(void *)(v66 - 64))
                              {
                                **(void **)(v66 - 48) = *(void *)(v66 - 56);
                                uint64_t v133 = *(void *)(v66 - 56);
                                if (v133) {
                                  *(void *)(v133 + 16) = *(void *)(v66 - 48);
                                }
                              }
                              *int v132 = v122;
                              if (v122)
                              {
                                uint64_t v136 = *(void *)(v122 + 8);
                                unint64_t v135 = (void *)(v122 + 8);
                                uint64_t v134 = v136;
                                *(void *)(v66 - 56) = v136;
                                if (v136) {
                                  *(void *)(v134 + 16) = v66 - 56;
                                }
                                *(void *)(v66 - 48) = v135;
                                *unint64_t v135 = v132;
                              }
                            }
                            else
                            {
                              if (*v64)
                              {
                                *(void *)*(v48 - 13) = *(v48 - 14);
                                uint64_t v128 = *(v48 - 14);
                                if (v128) {
                                  *(void *)(v128 + 16) = *(v48 - 13);
                                }
                              }
                              *uint64_t v64 = v122;
                              if (v122)
                              {
                                uint64_t v131 = *(void *)(v122 + 8);
                                uint64_t v130 = (void *)(v122 + 8);
                                uint64_t v129 = v131;
                                *(v48 - 14) = v131;
                                if (v131) {
                                  *(void *)(v129 + 16) = v48 - 14;
                                }
                                *(v48 - 13) = v130;
                                *uint64_t v130 = v64;
                              }
                            }
                            llvm::misexpect::checkFrontendInstrumentation((llvm::misexpect *)(v48 - 3), (uint64_t)v164, v127);
                            llvm::Instruction::setMetadata((llvm::Instruction *)(v48 - 3), 2, v160);
                            if (v164 != v166) {
                              free(v164);
                            }
                            uint64_t v5 = v158;
                          }
                          else
                          {
                            uint64_t v1 = v155;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            else if (v65 == 84)
            {
              uint64_t v70 = 0;
              int v67 = 33;
              goto LABEL_124;
            }
          }
          uint64_t v48 = v49;
        }
        while (v49 != v5);
      }
      uint64_t v2 = *(void *)(v161 + 8);
    }
    while (v2 != v1);
  }
  return 0;
}

void sub_1CCE27B28()
{
}

uint64_t sub_1CCE27BC4(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF6B60;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263F960;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF6B68, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCE27B28;
    v5[1] = &PassRegistry;
    int v4 = v5;
    std::__call_once(&qword_1EBCF6B68, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

unint64_t sub_1CCE27C74(int a1, uint64_t a2, int a3)
{
  if (a1 == 77)
  {
    unsigned int v3 = dword_1EBCF6BF0;
    uint64_t v4 = dword_1EBCF6CB0;
  }
  else
  {
    double v6 = llvm::APFloat::convertToDouble((llvm::APFloat *)(*(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 64)
                                                        + 24));
    unsigned int v3 = vcvtpd_u64_f64(v6 * 2147483650.0 + 1.0);
    LODWORD(v4) = vcvtpd_u64_f64((1.0 - v6) / (double)(a3 - 1) * 2147483650.0 + 1.0);
  }
  return v3 | (unint64_t)(v4 << 32);
}

void sub_1CCE27CFC()
{
}

void sub_1CCE27D3C(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CCE27D74(uint64_t a1, uint64_t a2)
{
  return sub_1CCE26CC0(a2);
}

uint64_t sub_1CCE27D7C()
{
  int v4 = 1;
  int v2 = 2000;
  unsigned int v3 = &v2;
  *(void *)&long long v1 = "Weight of the branch likely to be taken (default = 2000)";
  *((void *)&v1 + 1) = 56;
  sub_1CD45A86C((uint64_t)&unk_1EBCF6B70, "likely-branch-weight", &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF6B70, &dword_1CB82C000);
  int v4 = 1;
  int v2 = 1;
  unsigned int v3 = &v2;
  *(void *)&long long v1 = "Weight of the branch unlikely to be taken (default = 1)";
  *((void *)&v1 + 1) = 55;
  sub_1CD45A86C((uint64_t)&unk_1EBCF6C30, "unlikely-branch-weight", &v4, &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF6C30, &dword_1CB82C000);
}

void sub_1CCE27E70()
{
}

void llvm::createLowerGuardIntrinsicPass(llvm *this)
{
}

uint64_t sub_1CCE27F48(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF6CF0;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263FA00;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF6CF8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCE27E70;
    v5[1] = &PassRegistry;
    int v4 = v5;
    std::__call_once(&qword_1EBCF6CF8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CCE27FF8(uint64_t a1)
{
  v25[8] = *MEMORY[0x1E4F143B8];
  long long v1 = *(uint64_t **)(*(void *)(a1 + 40) + 112);
  unsigned int v2 = *((_DWORD *)v1 + 8);
  if (v2 <= 1) {
    uint64_t v3 = 1;
  }
  else {
    uint64_t v3 = v2;
  }
  if (v2 <= 0x16) {
    size_t v4 = v3;
  }
  else {
    size_t v4 = 23;
  }
  uint64_t v5 = *((unsigned int *)v1 + 2);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = 0;
  int v7 = 0;
  do
    int v7 = 33 * v7 + aLlvmExperiment_45[v6++];
  while (v4 != v6);
  uint64_t v8 = *v1;
  uint64_t v9 = *v1 + 8 * v5 + 8;
  int v10 = 1;
  int v11 = v7;
  while (1)
  {
    uint64_t v12 = v11 & (v5 - 1);
    int v13 = *(void **)(v8 + 8 * v12);
    if (v13 != (void *)-8)
    {
      if (!v13) {
        return 0;
      }
      if (*(_DWORD *)(v9 + 4 * v12) == v7
        && v4 == *v13
        && !memcmp("llvm.experimental.guard", (char *)v13 + *((unsigned int *)v1 + 5), v4))
      {
        break;
      }
    }
    int v11 = v10 + v12;
    ++v10;
  }
  if (v12 == -1) {
    return 0;
  }
  if ((int)v12 == v5) {
    return 0;
  }
  uint64_t v14 = *(void *)(*(void *)(v8 + 8 * (int)v12) + 8);
  if (!v14 || *(unsigned char *)(v14 + 16)) {
    return 0;
  }
  uint64_t v15 = *(void *)(v14 + 8);
  if (v15)
  {
    unsigned int v17 = 0;
    uint64_t v23 = v25;
    uint64_t v24 = 0x800000000;
    do
    {
      uint64_t v18 = *(void *)(v15 + 24);
      if (v18 && *(unsigned char *)(v18 + 16) == 84 && *(void *)(*(void *)(v18 + 40) + 56) == a1)
      {
        if (v17 >= HIDWORD(v24)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v23 + v17) = v18;
        unsigned int v17 = v24 + 1;
        LODWORD(v24) = v24 + 1;
      }
      uint64_t v15 = *(void *)(v15 + 8);
    }
    while (v15);
    uint64_t v15 = v17 != 0;
    if (v17)
    {
      uint64_t v19 = *(uint64_t ***)(a1 + 40);
      uint64_t v22 = **(void **)(*(void *)(a1 + 24) + 16);
      uint64_t Declaration = (llvm *)llvm::Intrinsic::getDeclaration(v19, 119, (uint64_t)&v22, 1);
      *((_WORD *)Declaration + 9) = *((_WORD *)Declaration + 9) & 0xC00F | *(_WORD *)(v14 + 18) & 0x3FF0;
      if (v24) {
        llvm::makeGuardControlFlowExplicit(Declaration, *(llvm::Function **)v23, 0);
      }
    }
    if (v23 != v25) {
      free(v23);
    }
  }
  return v15;
}

void sub_1CCE282AC()
{
}

void sub_1CCE282EC(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CCE28324(uint64_t a1, uint64_t a2)
{
  return sub_1CCE27FF8(a2);
}

uint64_t sub_1CCE2832C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 40) + 272;
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = a4;
  *(void *)(a1 + 32) = a5;
  *(void *)(a1 + 40) = a6;
  *(void *)(a1 + 48) = a7;
  *(_DWORD *)(a1 + 72) = 128;
  *(void *)(a1 + 56) = operator new(0x1C00uLL, (std::align_val_t)8uLL);
  sub_1CCE3129C((uint64_t *)(a1 + 56));
  *(unsigned char *)(a1 + 80) = 0;
  *(unsigned char *)(a1 + 104) = 0;
  *(void *)(a1 + 120) = a1 + 136;
  *(void *)(a1 + 128) = 0x1000000000;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 304) = 0;
  *(void *)(a1 + 288) = 0;
  return a1;
}

uint64_t sub_1CCE283B8(uint64_t a1)
{
  uint64_t v1078 = *MEMORY[0x1E4F143B8];
  std::string __dst = v931;
  uint64_t v930 = 0x2000000000;
  uint64_t v3 = *(void *)a1 + 72;
  uint64_t v4 = *(void *)(*(void *)a1 + 80);
  if (v4 == v3) {
    goto LABEL_253;
  }
  uint64_t v895 = a1;
  unsigned int v5 = 0;
  do
  {
    uint64_t v6 = v4 - 24;
    if (!v4) {
      uint64_t v6 = 0;
    }
    uint64_t v7 = v6 + 40;
    for (uint64_t i = *(void *)(v6 + 48); i != v7; uint64_t i = *(void *)(i + 8))
    {
      if (i) {
        unint64_t v1 = i - 24;
      }
      else {
        unint64_t v1 = 0;
      }
      if (*(unsigned char *)(v1 + 16) == 84)
      {
        uint64_t v9 = *(void *)(v1 - 32);
        if (v9)
        {
          if (!*(unsigned char *)(v9 + 16)
            && *(void *)(v9 + 24) == *(void *)(v1 + 72)
            && (*(unsigned char *)(v9 + 33) & 0x20) != 0
            && (*(_DWORD *)(*(void *)(i - 56) + 36) & 0xFFFFFFFC) == 0xBC)
          {
            if (v5 >= HIDWORD(v930)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)__dst + v5) = v1;
            unsigned int v5 = v930 + 1;
            LODWORD(v930) = v930 + 1;
          }
        }
      }
    }
    uint64_t v4 = *(void *)(v4 + 8);
  }
  while (v4 != v3);
  if (!v5)
  {
LABEL_253:
    LOBYTE(v126) = 0;
    goto LABEL_1437;
  }
  uint64_t v10 = v895;
  v884 = (int32x2_t *)(v895 + 56);
  *(_OWORD *)v894 = xmmword_1CDF53750;
  *(_OWORD *)uint64_t __p = xmmword_1CFB2C520;
  unint64_t __src = (unint64_t)&v1007;
  do
  {
LABEL_23:
    v1005 = &v1007;
    v1006 = (void *)0x2000000000;
    do
    {
      uint64_t v11 = *((void *)__dst + v5 - 1);
      LODWORD(v930) = v5 - 1;
      *(void *)v1038 = 0;
      v1058 = 0;
      v951.__r_.__value_.__r.__words[0] = 0;
      v938.__r_.__value_.__r.__words[0] = 0;
      v932.__r_.__value_.__r.__words[0] = 0;
      v990.i32[0] = 190;
      v990.i64[1] = 0;
      v991 = (std::string *)v1038;
      *(void *)&long long v992 = 1;
      *((void *)&v992 + 1) = &v1058;
      *(void *)&long long v993 = 2;
      *((void *)&v993 + 1) = &v951;
      uint64_t v994 = 3;
      uint64_t v995 = (uint64_t)&v938;
      uint64_t v996 = 4;
      v997 = &v932;
      if (sub_1CCE324C8((uint64_t)&v990, v11))
      {
        if (v11)
        {
          if (*(unsigned char *)(v11 + 16) == 84)
          {
            uint64_t v12 = *(void *)(v11 - 32 * (*(_DWORD *)(v11 + 20) & 0x7FFFFFF) + 32 * v994);
            if (v12)
            {
              *(void *)uint64_t v995 = v12;
              uint64_t v13 = *(void *)(v11 - 32 * (*(_DWORD *)(v11 + 20) & 0x7FFFFFF) + 32 * v996);
              if (v13)
              {
                *(void *)v997 = v13;
                uint64_t v14 = (unsigned int *)(v951.__r_.__value_.__r.__words[0] + 24);
                if (*(_DWORD *)(v951.__r_.__value_.__r.__words[0] + 32) >= 0x41u) {
                  uint64_t v14 = *(unsigned int **)v14;
                }
                uint64_t v15 = *v14;
                int v16 = (void *)(v932.__r_.__value_.__r.__words[0] + 24);
                if (*(_DWORD *)(v932.__r_.__value_.__r.__words[0] + 32) >= 0x41u) {
                  int v16 = (void *)*v16;
                }
                uint64_t v17 = v15 | (*v16 << 32);
                unint64_t v1 = v1 & 0xFFFFFFFF00000000 | (dword_1EBCF6F18 == 0);
                uint64_t v18 = v10;
                uint64_t v19 = v11;
                BOOL v20 = v1;
                goto LABEL_40;
              }
            }
          }
        }
      }
      v990.i32[0] = 191;
      v990.i64[1] = 0;
      v991 = (std::string *)v1038;
      *(void *)&long long v992 = 1;
      *((void *)&v992 + 1) = &v951;
      *(void *)&long long v993 = 2;
      *((void *)&v993 + 1) = &v938;
      if (sub_1CCE324C8((uint64_t)&v990, v11))
      {
        int v21 = (unsigned int *)(v938.__r_.__value_.__r.__words[0] + 24);
        if (*(_DWORD *)(v938.__r_.__value_.__r.__words[0] + 32) >= 0x41u) {
          int v21 = *(unsigned int **)v21;
        }
        uint64_t v22 = (void *)(v951.__r_.__value_.__r.__words[0] + 24);
        if (*(_DWORD *)(v951.__r_.__value_.__r.__words[0] + 32) >= 0x41u) {
          uint64_t v22 = (void *)*v22;
        }
        uint64_t v17 = *v21 | (*v22 << 32);
        unint64_t v2 = v2 & 0xFFFFFFFF00000000 | (dword_1EBCF6F18 == 0);
        uint64_t v18 = v10;
        uint64_t v19 = v11;
        BOOL v20 = v2;
        goto LABEL_40;
      }
      v990.i32[0] = 189;
      v990.i64[1] = 0;
      v991 = (std::string *)v1038;
      long long v992 = *(_OWORD *)v894;
      long long v993 = *(_OWORD *)__p;
      uint64_t v994 = (uint64_t)&v951;
      uint64_t v995 = 5;
      uint64_t v996 = (uint64_t)&v938;
      if (sub_1CC062C2C((uint64_t)&v990, v11))
      {
        if (v11)
        {
          if (*(unsigned char *)(v11 + 16) == 84)
          {
            uint64_t v28 = *(void *)(v11 - 32 * (*(_DWORD *)(v11 + 20) & 0x7FFFFFF) + 32 * DWORD2(v993));
            if (v28)
            {
              *(void *)uint64_t v994 = v28;
              uint64_t v29 = *(void *)(v11 - 32 * (*(_DWORD *)(v11 + 20) & 0x7FFFFFF) + 32 * v995);
              if (v29)
              {
                *(void *)uint64_t v996 = v29;
                int v30 = (unsigned int *)(v938.__r_.__value_.__r.__words[0] + 24);
                if (*(_DWORD *)(v938.__r_.__value_.__r.__words[0] + 32) >= 0x41u) {
                  int v30 = *(unsigned int **)v30;
                }
                uint64_t v31 = *v30;
                unint64_t v32 = (void *)(v951.__r_.__value_.__r.__words[0] + 24);
                if (*(_DWORD *)(v951.__r_.__value_.__r.__words[0] + 32) >= 0x41u) {
                  unint64_t v32 = (void *)*v32;
                }
                uint64_t v17 = v31 | (*v32 << 32);
                BOOL v20 = dword_1EBCF6F18 == 0;
                uint64_t v18 = v10;
                uint64_t v19 = v11;
                unint64_t v879 = v879 & 0xFFFFFFFF00000000 | (dword_1EBCF6F18 == 0);
                goto LABEL_40;
              }
            }
          }
        }
      }
      v990.i32[0] = 188;
      *(uint64_t *)((char *)v990.i64 + 4) = 0;
      unsigned int v33 = *(unsigned __int8 *)(v11 + 16);
      if (v11 && v33 == 84)
      {
        uint64_t v37 = *(void *)(v11 - 32);
        if (v37)
        {
          if (!*(unsigned char *)(v37 + 16)
            && *(void *)(v37 + 24) == *(void *)(v11 + 72)
            && *(_DWORD *)(v37 + 36) == v990.i32[0])
          {
            uint64_t v38 = v11 - 32 * (*(_DWORD *)(v11 + 20) & 0x7FFFFFF);
            uint64_t v39 = *(void *)(v38 + 96);
            if (v39)
            {
              v951.__r_.__value_.__r.__words[0] = *(void *)(v38 + 96);
              std::string::size_type v40 = *(void *)(v38 + 128);
              if (v40)
              {
                v938.__r_.__value_.__r.__words[0] = v40;
                BOOL v41 = (unsigned int *)(v39 + 24);
                if (*(_DWORD *)(v39 + 32) >= 0x41u) {
                  BOOL v41 = *(unsigned int **)v41;
                }
                uint64_t v42 = *v41;
                uint64_t v43 = (void *)(v40 + 24);
                if (*(_DWORD *)(v40 + 32) >= 0x41u) {
                  uint64_t v43 = (void *)*v43;
                }
                uint64_t v17 = v42 | (*v43 << 32);
                BOOL v20 = dword_1EBCF6F18 == 0;
                uint64_t v18 = v10;
                uint64_t v19 = v11;
                unint64_t v876 = v876 & 0xFFFFFFFF00000000 | (dword_1EBCF6F18 == 0);
LABEL_40:
                if ((sub_1CCE32414(v18, v19, v17, v20) & 1) == 0) {
                  goto LABEL_97;
                }
LABEL_41:
                if (v1006 >= (unint64_t)HIDWORD(v1006)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *((void *)v1005 + v1006) = v11;
                LODWORD(v1006) = v1006 + 1;
                for (uint64_t j = *(void *)(v11 + 8); j; uint64_t j = *(void *)(j + 8))
                {
                  uint64_t v24 = *(void *)(j + 24);
                  v990.i64[0] = 0;
                  if (sub_1CCE317CC(*(void *)(v10 + 56), *(_DWORD *)(v10 + 72), v24, &v990))
                  {
                    uint64_t v25 = v990.i64[0];
                    uint64_t v26 = *(void *)(v10 + 56);
                    unsigned int v27 = *(_DWORD *)(v10 + 72);
                  }
                  else
                  {
                    uint64_t v26 = *(void *)(v10 + 56);
                    unsigned int v27 = *(_DWORD *)(v10 + 72);
                    uint64_t v25 = v26 + 56 * v27;
                  }
                  if (v25 == v26 + 56 * v27)
                  {
                    if (v930 >= (unint64_t)HIDWORD(v930)) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    *((void *)__dst + v930) = v24;
                    LODWORD(v930) = v930 + 1;
                  }
                }
                goto LABEL_97;
              }
            }
          }
        }
      }
      else if (v33 == 61)
      {
        int v34 = *(_DWORD *)(v11 + 20);
        uint64_t v35 = (v34 & 0x40000000) != 0 ? *(uint64_t **)(v11 - 8) : (uint64_t *)(v11 - 32 * (v34 & 0x7FFFFFF));
        uint64_t v36 = *v35;
        if (*v35)
        {
          *(void *)v1038 = *v35;
          v990.i64[0] = 0;
          if (sub_1CCE317CC(*(void *)(v10 + 56), *(_DWORD *)(v10 + 72), v36, &v990)
            && v990.i64[0] != *(void *)(v10 + 56) + 56 * *(unsigned int *)(v10 + 72))
          {
            uint64_t v891 = v891 & 0xFFFFFFFF00000000 | *(unsigned int *)(v990.i64[0] + 48);
            sub_1CCE32414(v10, v11, *(void *)(v990.i64[0] + 40), *(_DWORD *)(v990.i64[0] + 48));
          }
          goto LABEL_97;
        }
      }
      if (v33 < 0x1C || v33 - 40 <= 6)
      {
        int v44 = *(_DWORD *)(v11 + 20);
        if ((v44 & 0x40000000) != 0)
        {
          uint64_t v46 = *(uint64_t **)(v11 - 8);
          uint64_t v45 = v44 & 0x7FFFFFF;
        }
        else
        {
          uint64_t v45 = v44 & 0x7FFFFFF;
          uint64_t v46 = (uint64_t *)(v11 - 32 * v45);
        }
        if (v45)
        {
          uint64_t v47 = *(void *)(v10 + 56);
          unsigned int v48 = *(_DWORD *)(v10 + 72);
          uint64_t v49 = 32 * v45;
          while (1)
          {
            uint64_t v50 = *v46;
            v990.i64[0] = 0;
            int v51 = sub_1CCE317CC(v47, v48, v50, &v990);
            uint64_t v47 = *(void *)(v10 + 56);
            unsigned int v48 = *(_DWORD *)(v10 + 72);
            if (v51 && v990.i64[0] != v47 + 56 * v48) {
              break;
            }
            v46 += 4;
            v49 -= 32;
            if (!v49) {
              goto LABEL_97;
            }
          }
          unint64_t v887 = v887 & 0xFFFFFFFF00000000 | *(unsigned int *)(v990.i64[0] + 48);
          if (sub_1CCE32414(v10, v11, *(void *)(v990.i64[0] + 40), *(_DWORD *)(v990.i64[0] + 48))) {
            goto LABEL_41;
          }
        }
      }
LABEL_97:
      unsigned int v5 = v930;
    }
    while (v930);
    uint64_t v54 = v1005;
    if (v1005 != &v1007)
    {
      if (__dst != v931)
      {
        free(__dst);
        uint64_t v54 = v1005;
      }
      std::string __dst = v54;
      LODWORD(v1) = v1006;
      HIDWORD(v930) = HIDWORD(v1006);
LABEL_107:
      v1005 = &v1007;
      v1006 = (void *)0x2000000000;
      if (v1) {
        goto LABEL_110;
      }
      goto LABEL_254;
    }
    LODWORD(v1) = v1006;
    if (!v1006) {
      goto LABEL_254;
    }
    if (HIDWORD(v930) < v1006)
    {
      LODWORD(v930) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy(__dst, &v1007, 8 * v1006);
    LODWORD(v930) = v1;
    LODWORD(v1006) = 0;
    if (v1005 != &v1007)
    {
      free(v1005);
      LODWORD(v1) = v930;
      goto LABEL_107;
    }
    v1005 = &v1007;
    v1006 = (void *)0x2000000000;
LABEL_110:
    while (2)
    {
      uint64_t v55 = *((void *)__dst + v1 - 1);
      unint64_t v1 = (v1 - 1);
      LODWORD(v930) = v1;
      if (*(unsigned __int8 *)(v55 + 16) >= 0x1Cu)
      {
        v1058 = 0;
        v951.__r_.__value_.__r.__words[0] = 0;
        v938.__r_.__value_.__r.__words[0] = 0;
        v932.__r_.__value_.__r.__words[0] = 0;
        v897 = 0;
        v990.i32[0] = 190;
        v990.i64[1] = 0;
        v991 = (std::string *)&v1058;
        *(void *)&long long v992 = 1;
        *((void *)&v992 + 1) = &v951;
        *(void *)&long long v993 = 2;
        *((void *)&v993 + 1) = &v938;
        uint64_t v994 = 3;
        uint64_t v995 = (uint64_t)&v932;
        uint64_t v996 = 4;
        v997 = &v897;
        if (sub_1CCE32624((uint64_t)&v990, v55))
        {
          if (*(unsigned char *)(v55 + 16) == 84)
          {
            uint64_t v56 = *(void *)(v55 - 32 * (*(_DWORD *)(v55 + 20) & 0x7FFFFFF) + 32 * v994);
            if (v56)
            {
              *(void *)uint64_t v995 = v56;
              uint64_t v57 = *(void *)(v55 - 32 * (*(_DWORD *)(v55 + 20) & 0x7FFFFFF) + 32 * v996);
              if (v57)
              {
                *(void *)v997 = v57;
                uint64_t v58 = (unsigned int *)(v938.__r_.__value_.__r.__words[0] + 24);
                if (*(_DWORD *)(v938.__r_.__value_.__r.__words[0] + 32) >= 0x41u) {
                  uint64_t v58 = *(unsigned int **)v58;
                }
                uint64_t v59 = *v58;
                uint64_t v60 = (void *)(v932.__r_.__value_.__r.__words[0] + 24);
                if (*(_DWORD *)(v932.__r_.__value_.__r.__words[0] + 32) >= 0x41u) {
                  uint64_t v60 = (void *)*v60;
                }
                BOOL v61 = dword_1EBCF6F18 == 0;
                unint64_t v887 = v887 & 0xFFFFFFFF00000000 | v61;
                if (sub_1CCE32414(v10, (uint64_t)v1058, v59 | (*v60 << 32), v61)
                  && v1058
                  && *((unsigned __int8 *)v1058 + 16) >= 0x1Cu)
                {
                  if (v930 >= (unint64_t)HIDWORD(v930)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((void *)__dst + v930) = v1058;
                  LODWORD(v930) = v930 + 1;
                }
                BOOL v62 = (unsigned int *)(v932.__r_.__value_.__r.__words[0] + 24);
                if (*(_DWORD *)(v932.__r_.__value_.__r.__words[0] + 32) >= 0x41u) {
                  BOOL v62 = *(unsigned int **)v62;
                }
                uint64_t v63 = *v62;
                uint64_t v64 = v897 + 6;
                if (v897[8] >= 0x41u) {
                  uint64_t v64 = (void *)*v64;
                }
                int v65 = (void *)*v64;
                BOOL v66 = dword_1EBCF6F18 == 0;
                unint64_t v879 = v879 & 0xFFFFFFFF00000000 | v66;
                if (!sub_1CCE32414(v10, (uint64_t)v951.__r_.__value_.__l.__data_, v63 | ((void)v65 << 32), v66))goto LABEL_216; {
                int v67 = (unsigned __int8 *)v951.__r_.__value_.__r.__words[0];
                }
                if (!v951.__r_.__value_.__r.__words[0]) {
                  goto LABEL_216;
                }
LABEL_139:
                if (v67[16] >= 0x1Cu)
                {
                  if (v930 >= (unint64_t)HIDWORD(v930)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((void *)__dst + v930) = v67;
                  LODWORD(v930) = v930 + 1;
                }
                goto LABEL_216;
              }
            }
          }
        }
        v990.i32[0] = 191;
        v990.i64[1] = 0;
        v991 = (std::string *)&v1058;
        *(void *)&long long v992 = 1;
        *((void *)&v992 + 1) = &v938;
        *(void *)&long long v993 = 2;
        *((void *)&v993 + 1) = &v932;
        if (sub_1CCE32624((uint64_t)&v990, v55))
        {
          uint64_t v68 = (unsigned int *)(v938.__r_.__value_.__r.__words[0] + 24);
          if (*(_DWORD *)(v938.__r_.__value_.__r.__words[0] + 32) >= 0x41u) {
            uint64_t v68 = *(unsigned int **)v68;
          }
          int64_t v69 = (void *)(v932.__r_.__value_.__r.__words[0] + 24);
          if (*(_DWORD *)(v932.__r_.__value_.__r.__words[0] + 32) >= 0x41u) {
            int64_t v69 = (void *)*v69;
          }
          uint64_t v70 = v1058;
          uint64_t v71 = *v68 | (*v69 << 32);
          BOOL v72 = dword_1EBCF6F18 == 0;
          uint64_t v73 = v10;
          uint64_t v891 = v891 & 0xFFFFFFFF00000000 | (dword_1EBCF6F18 == 0);
          goto LABEL_137;
        }
        v990.i32[0] = 189;
        v990.i64[1] = 0;
        v991 = (std::string *)&v1058;
        long long v992 = *(_OWORD *)v894;
        long long v993 = *(_OWORD *)__p;
        uint64_t v994 = (uint64_t)&v938;
        uint64_t v995 = 5;
        uint64_t v996 = (uint64_t)&v932;
        if (sub_1CC045310((uint64_t)&v990, v55))
        {
          if (*(unsigned char *)(v55 + 16) == 84)
          {
            uint64_t v74 = *(void *)(v55 - 32 * (*(_DWORD *)(v55 + 20) & 0x7FFFFFF) + 32 * DWORD2(v993));
            if (v74)
            {
              *(void *)uint64_t v994 = v74;
              uint64_t v75 = *(void *)(v55 - 32 * (*(_DWORD *)(v55 + 20) & 0x7FFFFFF) + 32 * v995);
              if (v75)
              {
                *(void *)uint64_t v996 = v75;
                uint64_t v76 = (unsigned int *)(v938.__r_.__value_.__r.__words[0] + 24);
                if (*(_DWORD *)(v938.__r_.__value_.__r.__words[0] + 32) >= 0x41u) {
                  uint64_t v76 = *(unsigned int **)v76;
                }
                uint64_t v70 = v1058;
                uint64_t v77 = *v76;
                uint64_t v78 = (void *)(v932.__r_.__value_.__r.__words[0] + 24);
                if (*(_DWORD *)(v932.__r_.__value_.__r.__words[0] + 32) >= 0x41u) {
                  uint64_t v78 = (void *)*v78;
                }
                uint64_t v71 = v77 | (*v78 << 32);
                BOOL v72 = dword_1EBCF6F18 == 0;
                uint64_t v73 = v10;
                unint64_t v876 = v876 & 0xFFFFFFFF00000000 | (dword_1EBCF6F18 == 0);
LABEL_137:
                if (!sub_1CCE32414(v73, (uint64_t)v70, v71, v72)) {
                  goto LABEL_216;
                }
                int v67 = (unsigned __int8 *)v1058;
                if (!v1058) {
                  goto LABEL_216;
                }
                goto LABEL_139;
              }
            }
          }
        }
        unsigned int v79 = *(unsigned __int8 *)(v55 + 16);
        if (v79 - 60 >= 2
          && (v79 != 84
           || (uint64_t v80 = *(void *)(v55 - 32)) == 0
           || *(unsigned char *)(v80 + 16)
           || *(void *)(v80 + 24) != *(void *)(v55 + 72)
           || *(_DWORD *)(v80 + 36) != 188)
          && (v79 < 0x1C || v79 - 40 <= 6))
        {
          v990.i64[1] = 2;
          v991 = 0;
          uint64_t v81 = v55;
          *(void *)&long long v992 = v55;
          if (v55 != -8192)
          {
            uint64_t v81 = v55;
            if (v55 != -4096)
            {
              uint64_t v81 = v55;
              if (v55)
              {
                llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v990.u64[1]);
                uint64_t v81 = v992;
              }
            }
          }
          v990.i64[0] = (uint64_t)&unk_1F263FB98;
          *((void *)&v992 + 1) = v884;
          *(void *)v1038 = 0;
          char v82 = sub_1CCE317CC(*(void *)(v10 + 56), *(_DWORD *)(v10 + 72), v81, v1038);
          uint64_t v83 = *(void *)v1038;
          if ((v82 & 1) == 0)
          {
            uint64_t v84 = sub_1CCE31E24((uint64_t)v884, (uint64_t)&v990, *(uint64_t *)v1038);
            uint64_t v83 = v84;
            uint64_t v85 = *(void *)(v84 + 24);
            uint64_t v86 = v992;
            if (v85 != (void)v992)
            {
              if (v85 != -4096 && v85 && v85 != -8192)
              {
                unint64_t v102 = *(void *)(v84 + 8) & 0xFFFFFFFFFFFFFFF8;
                *(void *)unint64_t v102 = *(void *)(v84 + 16);
                uint64_t v103 = *(unint64_t **)(v84 + 16);
                if (v103)
                {
                  *uint64_t v103 = *v103 & 7 | v102;
                }
                else
                {
                  uint64_t v104 = *(void *)(v84 + 24);
                  BOOL v105 = ***(int32x2_t ****)v104;
                  unint64_t v106 = (unint64_t)v105[303];
                  if (v106 <= v102)
                  {
                    uint64_t v107 = v105[305].u32[0];
                    if (v106 + 16 * v107 > v102)
                    {
                      unsigned int v108 = v107 - 1;
                      LODWORD(v109) = v108 & ((v104 >> 4) ^ (v104 >> 9));
                      uint64_t v110 = (uint64_t *)(v106 + 16 * v109);
                      uint64_t v111 = *v110;
                      if (v104 == *v110)
                      {
LABEL_197:
                        uint64_t *v110 = -8192;
                        v105[304] = vadd_s32(v105[304], (int32x2_t)0x1FFFFFFFFLL);
                        uint64_t v104 = *(void *)(v84 + 24);
                      }
                      else
                      {
                        int v112 = 1;
                        while (v111 != -4096)
                        {
                          int v113 = v109 + v112++;
                          uint64_t v109 = v113 & v108;
                          uint64_t v111 = *(void *)(v106 + 16 * v109);
                          if (v104 == v111)
                          {
                            uint64_t v110 = (uint64_t *)(v106 + 16 * v109);
                            goto LABEL_197;
                          }
                        }
                      }
                      *(unsigned char *)(v104 + 17) &= ~1u;
                    }
                  }
                }
                uint64_t v86 = v992;
              }
              *(void *)(v84 + 24) = v86;
              if (v86 != -4096 && v86 != -8192 && v86 != 0)
              {
                uint64_t v88 = v990.i64[1];
                int v89 = (void *)(v990.i64[1] & 0xFFFFFFFFFFFFFFF8);
                *(void *)(v84 + 16) = *(void *)(v990.i64[1] & 0xFFFFFFFFFFFFFFF8);
                void *v89 = v84 + 8;
                *(void *)(v84 + 8) = v88 & 0xFFFFFFFFFFFFFFF8 | *(void *)(v84 + 8) & 7;
                uint64_t v90 = *(uint64_t **)(v84 + 16);
                if (v90) {
                  *uint64_t v90 = *v90 & 7 | (v84 + 16);
                }
              }
            }
            *(void *)(v84 + 32) = *((void *)&v992 + 1);
            *(void *)(v84 + 40) = 0;
            *(unsigned char *)(v84 + 48) = dword_1EBCF6F18 == 0;
          }
          if ((void)v992 != -8192 && (void)v992 != -4096 && (void)v992)
          {
            unint64_t v91 = v990.i64[1] & 0xFFFFFFFFFFFFFFF8;
            *(void *)(v990.i64[1] & 0xFFFFFFFFFFFFFFF8) = v991;
            if (v991)
            {
              v991->__r_.__value_.__r.__words[0] = v991->__r_.__value_.__r.__words[0] & 7 | v91;
            }
            else
            {
              uint64_t v92 = v992;
              uint64_t v93 = ***(int32x2_t ****)v992;
              unint64_t v94 = (unint64_t)v93[303];
              if (v94 <= v91)
              {
                uint64_t v95 = v93[305].u32[0];
                if (v94 + 16 * v95 > v91)
                {
                  unsigned int v96 = v95 - 1;
                  LODWORD(v97) = v96 & ((v992 >> 4) ^ (v992 >> 9));
                  BOOL v98 = (uint64_t *)(v94 + 16 * v97);
                  uint64_t v99 = *v98;
                  if ((void)v992 == *v98)
                  {
LABEL_185:
                    *BOOL v98 = -8192;
                    v93[304] = vadd_s32(v93[304], (int32x2_t)0x1FFFFFFFFLL);
                    uint64_t v92 = v992;
                  }
                  else
                  {
                    int v100 = 1;
                    while (v99 != -4096)
                    {
                      int v101 = v97 + v100++;
                      uint64_t v97 = v101 & v96;
                      uint64_t v99 = *(void *)(v94 + 16 * v97);
                      if ((void)v992 == v99)
                      {
                        BOOL v98 = (uint64_t *)(v94 + 16 * v97);
                        goto LABEL_185;
                      }
                    }
                  }
                  *(unsigned char *)(v92 + 17) &= ~1u;
                }
              }
            }
          }
          uint64_t v114 = *(void *)(v83 + 40);
          uint64_t v115 = *(unsigned int *)(v83 + 48);
          int v116 = *(_DWORD *)(v55 + 20);
          if ((v116 & 0x40000000) != 0)
          {
            uint64_t v118 = *(uint64_t **)(v55 - 8);
            uint64_t v117 = v116 & 0x7FFFFFF;
            if (!v117) {
              goto LABEL_216;
            }
          }
          else
          {
            uint64_t v117 = v116 & 0x7FFFFFF;
            uint64_t v118 = (uint64_t *)(v55 - 32 * v117);
            if (!v117) {
              goto LABEL_216;
            }
          }
          uint64_t v119 = 32 * v117;
          do
          {
            unint64_t v2 = v2 & 0xFFFFFFFF00000000 | v115;
            if (sub_1CCE32414(v10, *v118, v114, v2))
            {
              if (*v118 && *(unsigned __int8 *)(*v118 + 16) >= 0x1Cu)
              {
                if (v930 >= (unint64_t)HIDWORD(v930)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *((void *)__dst + v930) = *v118;
                LODWORD(v930) = v930 + 1;
              }
            }
            v118 += 4;
            v119 -= 32;
            uint64_t v10 = v895;
          }
          while (v119);
        }
LABEL_216:
        if (v1 != v930)
        {
          unint64_t v121 = v1;
          unint64_t v1 = v930;
          do
          {
            uint64_t v122 = *(void *)(*((void *)__dst + v121) + 8);
            if (v122)
            {
              do
              {
                uint64_t v123 = *(void *)(v122 + 24);
                if (v55 != v123 && *(unsigned __int8 *)(v123 + 16) >= 0x1Cu)
                {
                  if (v1006 >= (unint64_t)HIDWORD(v1006)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((void *)v1005 + v1006) = v123;
                  LODWORD(v1006) = v1006 + 1;
                }
                uint64_t v122 = *(void *)(v122 + 8);
              }
              while (v122);
              unint64_t v1 = v930;
            }
            ++v121;
          }
          while (v121 != v1);
        }
        uint64_t v10 = v895;
      }
      if (v1) {
        continue;
      }
      break;
    }
    unint64_t v125 = v1005;
    if (v1005 == &v1007)
    {
      unsigned int v5 = v1006;
      if (v1006)
      {
        if (HIDWORD(v930) < v1006)
        {
          LODWORD(v930) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        memcpy(__dst, &v1007, 8 * v1006);
        LODWORD(v930) = v5;
        LODWORD(v1006) = 0;
        if (v1005 != &v1007)
        {
          free(v1005);
          unsigned int v5 = v930;
        }
        if (!v5) {
          break;
        }
        goto LABEL_23;
      }
LABEL_254:
      LODWORD(v930) = 0;
      break;
    }
    if (__dst != v931)
    {
      free(__dst);
      unint64_t v125 = v1005;
    }
    std::string __dst = v125;
    uint64_t v930 = (uint64_t)v1006;
    unsigned int v5 = v1006;
  }
  while (v1006);
  uint64_t v127 = *(void **)v10;
  if (*(void *)(v10 + 32))
  {
    uint64_t v128 = (llvm::FixedVectorType *)(v127 + 9);
    v873 = (llvm::ValueHandleBase *)v127[10];
    if (v127 + 9 == (void *)v873) {
      goto LABEL_368;
    }
    unint64_t v887 = (unint64_t)&v1022;
    while (2)
    {
      uint64_t v129 = *(llvm::FixedVectorType **)v128;
      uint64_t v130 = *(void *)v128 - 24;
      if (!*(void *)v128) {
        uint64_t v130 = 0;
      }
      uint64_t v131 = *(llvm::FixedVectorType **)(v130 + 40);
      v894[0] = (llvm::FixedVectorType *)(v130 + 40);
      if (v131 != (llvm::FixedVectorType *)(v130 + 40))
      {
        v880 = (llvm::FixedVectorType **)v128;
        uint64_t v891 = (uint64_t)&unk_1F2616E88;
        unint64_t __src = (unint64_t)&unk_1F2617008;
        while (1)
        {
          uint64_t v132 = 0;
          uint64_t v133 = *(llvm::FixedVectorType **)v131;
          if (v131) {
            uint64_t v134 = (llvm::FixedVectorType *)((char *)v131 - 24);
          }
          else {
            uint64_t v134 = 0;
          }
          unint64_t v135 = **(void ****)v134;
          v1005 = &v1007;
          v1006 = (void *)0x200000000;
          v1013 = v135;
          uint64_t v1014 = (uint64_t)&v1022;
          v1015 = (void **)v1023;
          uint64_t v1016 = 0;
          int v1017 = 0;
          __int16 v1018 = 512;
          char v1019 = 7;
          v1011 = 0;
          uint64_t v1012 = 0;
          uint64_t v1020 = 0;
          uint64_t v1021 = 0;
          v1022 = &unk_1F2616E88;
          v1023[0] = &unk_1F2617008;
          v1011 = (void *)*((void *)v134 + 5);
          uint64_t v1012 = (uint64_t)v134 + 24;
          uint64_t v136 = (unsigned __int8 *)*((void *)v134 + 6);
          *(void *)v1038 = v136;
          if (v136)
          {
            llvm::MetadataTracking::track((uint64_t)v1038, v136, 2);
            uint64_t v132 = *(void *)v1038;
          }
          sub_1CB8461A4((uint64_t)&v1005, 0, v132);
          if (*(void *)v1038)
          {
            int v146 = **(unsigned char **)v1038;
            if ((v146 - 4) > 0x1E)
            {
              if ((v146 - 3) >= 0xFFFFFFFE) {
                uint64_t v149 = *(void *)v1038;
              }
              else {
                uint64_t v149 = 0;
              }
              if ((v146 - 3) >= 0xFFFFFFFE)
              {
                unint64_t v148 = v149 + 8;
LABEL_307:
                v990.i64[0] = (uint64_t)v1038;
                sub_1CC5FA668(v148 + 16, &v990);
                goto LABEL_268;
              }
              if (v146 == 3) {
                *(void *)(*(void *)v1038 + 8) = 0;
              }
            }
            else if ((*(unsigned char *)(*(void *)v1038 + 1) & 0x7F) == 2 || *(_DWORD *)(*(void *)v1038 + 12))
            {
              uint64_t v147 = *(void *)(*(void *)v1038 + 16);
              if ((v147 & 4) != 0)
              {
                unint64_t v148 = v147 & 0xFFFFFFFFFFFFFFF8;
                if (v148) {
                  goto LABEL_307;
                }
              }
            }
          }
LABEL_268:
          v1058 = &v1005;
          v951.__r_.__value_.__r.__words[0] = 0;
          v938.__r_.__value_.__r.__words[0] = 0;
          v932.__r_.__value_.__r.__words[0] = 0;
          v897 = 0;
          v926 = 0;
          v923 = 0;
          v990.i32[0] = 191;
          v990.i64[1] = 0;
          v991 = &v951;
          if (sub_1CC062C2C((uint64_t)&v990, (uint64_t)v134))
          {
            v970.__r_.__value_.__r.__words[0] = 0;
            v990.i32[0] = 191;
            v990.i64[1] = 0;
            v991 = &v970;
            if (sub_1CC045310((uint64_t)&v990, (uint64_t)v951.__r_.__value_.__l.__data_))
            {
              uint64_t v137 = (llvm::Value *)v970.__r_.__value_.__r.__words[0];
              v990.i64[0] = 0;
              int v138 = sub_1CCE317CC(*(void *)(v895 + 56), *(_DWORD *)(v895 + 72), (uint64_t)v134, &v990);
              uint64_t v139 = *(void *)(v895 + 56);
              unsigned int v140 = *(_DWORD *)(v895 + 72);
              if (v138) {
                uint64_t v141 = v990.i64[0];
              }
              else {
                uint64_t v141 = v139 + 56 * v140;
              }
              if (v139 + 56 * v140 != v141)
              {
                sub_1CCE31864(v884, (void *)v141);
                if (sub_1CCE325A8((uint64_t)v137))
                {
                  v990.i64[0] = (uint64_t)v137;
                  v990.i64[1] = *(void *)(v141 + 40);
                  LODWORD(v991) = *(_DWORD *)(v141 + 48);
                  sub_1CCE3196C((uint64_t)v1038, (uint64_t)v884, (uint64_t)&v990);
                }
              }
              llvm::Value::doRAUW(v134, v137, (llvm::Value *)1);
              if (!*((void *)v134 + 1)) {
                llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
              }
              if (!*(void *)(v951.__r_.__value_.__r.__words[0] + 8)) {
                llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
              }
            }
            else
            {
              std::string::size_type v142 = v951.__r_.__value_.__r.__words[0];
              v990.i32[0] = 190;
              v990.i64[1] = 0;
              v991 = &v938;
              *(void *)&long long v992 = 1;
              *((void *)&v992 + 1) = &v932;
              *(void *)&long long v993 = 2;
              *((void *)&v993 + 1) = &v897;
              uint64_t v994 = 3;
              uint64_t v995 = (uint64_t)&v926;
              uint64_t v996 = 4;
              v997 = &v923;
              if (sub_1CC9F99A8((uint64_t)&v990, (uint64_t)v951.__r_.__value_.__l.__data_))
              {
                if (v142)
                {
                  if (*(unsigned char *)(v142 + 16) == 84)
                  {
                    uint64_t v143 = *(void *)(v142 - 32 * (*(_DWORD *)(v142 + 20) & 0x7FFFFFF) + 32 * v993);
                    if (v143)
                    {
                      if (*(unsigned char *)(v143 + 16) == 16)
                      {
                        **((void **)&v993 + 1) = v143;
                        uint64_t v144 = *(void *)(v142 - 32 * (*(_DWORD *)(v142 + 20) & 0x7FFFFFF) + 32
                                                                                              * v994);
                        if (v144)
                        {
                          if (*(unsigned char *)(v144 + 16) == 16)
                          {
                            *(void *)uint64_t v995 = v144;
                            uint64_t v145 = *(void *)(v142
                                             - 32 * (*(_DWORD *)(v142 + 20) & 0x7FFFFFF)
                                             + 32 * v996);
                            if (v145)
                            {
                              if (*(unsigned char *)(v145 + 16) == 16)
                              {
                                *(void *)v997 = v145;
                                uint64_t v150 = (char *)v926 + 24;
                                if (*((_DWORD *)v926 + 8) >= 0x41u) {
                                  uint64_t v150 = (void *)*v150;
                                }
                                unsigned int v151 = *(_DWORD *)v150;
                                uint64_t v152 = (char *)v923 + 24;
                                if (*((_DWORD *)v923 + 8) >= 0x41u) {
                                  uint64_t v152 = (void *)*v152;
                                }
                                unsigned int v153 = *(_DWORD *)v152;
                                if ((*(unsigned char *)(v932.__r_.__value_.__r.__words[0] + 23) & 0x10) != 0)
                                {
                                  uint64_t v154 = ***(void ***)v932.__r_.__value_.__l.__data_;
                                  uint64_t v155 = *(void *)(v154 + 152);
                                  uint64_t v156 = *(unsigned int *)(v154 + 168);
                                  if (!v156) {
                                    goto LABEL_321;
                                  }
                                  LODWORD(v157) = (v156 - 1) & ((LODWORD(v932.__r_.__value_.__l.__data_) >> 4) ^ (LODWORD(v932.__r_.__value_.__l.__data_) >> 9));
                                  int v158 = (uint64_t *)(v155 + 16 * v157);
                                  uint64_t v159 = *v158;
                                  if (*v158 != v932.__r_.__value_.__r.__words[0])
                                  {
                                    int v160 = 1;
                                    while (v159 != -4096)
                                    {
                                      int v161 = v157 + v160++;
                                      uint64_t v157 = v161 & (v156 - 1);
                                      uint64_t v159 = *(void *)(v155 + 16 * v157);
                                      if (v159 == v932.__r_.__value_.__r.__words[0])
                                      {
                                        int v158 = (uint64_t *)(v155 + 16 * v157);
                                        goto LABEL_322;
                                      }
                                    }
LABEL_321:
                                    int v158 = (uint64_t *)(v155 + 16 * v156);
                                  }
LABEL_322:
                                  unint64_t v162 = (void *)v158[1];
                                  uint64_t v165 = *v162;
                                  int v164 = (char *)(v162 + 2);
                                  uint64_t v163 = v165;
                                }
                                else
                                {
                                  uint64_t v163 = 0;
                                  int v164 = &byte_1CFBCE98E;
                                }
                                WORD4(v992) = 773;
                                v990.i64[0] = (uint64_t)v164;
                                v990.i64[1] = v163;
                                v991 = (std::string *)"_t";
                                uint64_t v166 = sub_1CD778068((uint64_t **)&v1058, (uint64_t)v932.__r_.__value_.__l.__data_, v151, v153, (uint64_t)&v990);
                                int v167 = (unsigned int *)((char *)v923 + 24);
                                if (*((_DWORD *)v923 + 8) >= 0x41u) {
                                  int v167 = *(unsigned int **)v167;
                                }
                                uint64_t v168 = *v167;
                                uint64_t v169 = (char *)v926 + 24;
                                if (*((_DWORD *)v926 + 8) >= 0x41u) {
                                  uint64_t v169 = (void *)*v169;
                                }
                                int v170 = (void *)*v169;
                                BOOL v171 = dword_1EBCF6F18 == 0;
                                size_t v871 = v871 & 0xFFFFFFFF00000000 | v171;
                                sub_1CCE32414(v895, v166, v168 | ((void)v170 << 32), v171);
                                uint64_t v172 = v897 + 6;
                                if (v897[8] >= 0x41u) {
                                  uint64_t v172 = (void *)*v172;
                                }
                                unsigned int v173 = *(_DWORD *)v172;
                                uint64_t v174 = (char *)v926 + 24;
                                if (*((_DWORD *)v926 + 8) >= 0x41u) {
                                  uint64_t v174 = (void *)*v174;
                                }
                                unsigned int v175 = *(_DWORD *)v174;
                                if ((*(unsigned char *)(v938.__r_.__value_.__r.__words[0] + 23) & 0x10) != 0)
                                {
                                  uint64_t v176 = ***(void ***)v938.__r_.__value_.__l.__data_;
                                  uint64_t v177 = *(void *)(v176 + 152);
                                  uint64_t v178 = *(unsigned int *)(v176 + 168);
                                  if (!v178) {
                                    goto LABEL_338;
                                  }
                                  LODWORD(v179) = (v178 - 1) & ((LODWORD(v938.__r_.__value_.__l.__data_) >> 4) ^ (LODWORD(v938.__r_.__value_.__l.__data_) >> 9));
                                  uint64_t v180 = (uint64_t *)(v177 + 16 * v179);
                                  uint64_t v181 = *v180;
                                  if (*v180 != v938.__r_.__value_.__r.__words[0])
                                  {
                                    int v182 = 1;
                                    while (v181 != -4096)
                                    {
                                      int v183 = v179 + v182++;
                                      uint64_t v179 = v183 & (v178 - 1);
                                      uint64_t v181 = *(void *)(v177 + 16 * v179);
                                      if (v181 == v938.__r_.__value_.__r.__words[0])
                                      {
                                        uint64_t v180 = (uint64_t *)(v177 + 16 * v179);
                                        goto LABEL_339;
                                      }
                                    }
LABEL_338:
                                    uint64_t v180 = (uint64_t *)(v177 + 16 * v178);
                                  }
LABEL_339:
                                  __int32 v184 = (void *)v180[1];
                                  uint64_t v187 = *v184;
                                  int v186 = (char *)(v184 + 2);
                                  uint64_t v185 = v187;
                                }
                                else
                                {
                                  uint64_t v185 = 0;
                                  int v186 = &byte_1CFBCE98E;
                                }
                                WORD4(v992) = 773;
                                v990.i64[0] = (uint64_t)v186;
                                v990.i64[1] = v185;
                                v991 = (std::string *)"_t";
                                uint64_t v188 = (uint64_t *)sub_1CD778068((uint64_t **)&v1058, (uint64_t)v938.__r_.__value_.__l.__data_, v173, v175, (uint64_t)&v990);
                                uint64_t v189 = (unsigned int *)((char *)v926 + 24);
                                if (*((_DWORD *)v926 + 8) >= 0x41u) {
                                  uint64_t v189 = *(unsigned int **)v189;
                                }
                                uint64_t v190 = *v189;
                                int v191 = v897 + 6;
                                if (v897[8] >= 0x41u) {
                                  int v191 = (void *)*v191;
                                }
                                unsigned int v192 = (void *)*v191;
                                BOOL v193 = dword_1EBCF6F18 == 0;
                                unint64_t v868 = v868 & 0xFFFFFFFF00000000 | v193;
                                sub_1CCE32414(v895, (uint64_t)v188, v190 | ((void)v192 << 32), v193);
                                uint64_t v194 = (char *)v923 + 24;
                                if (*((_DWORD *)v923 + 8) >= 0x41u) {
                                  uint64_t v194 = (void *)*v194;
                                }
                                unsigned int v195 = *(_DWORD *)v194;
                                int v196 = (char *)v926 + 24;
                                if (*((_DWORD *)v926 + 8) >= 0x41u) {
                                  int v196 = (void *)*v196;
                                }
                                unsigned int v197 = *(_DWORD *)v196;
                                uint64_t v198 = v897 + 6;
                                if (v897[8] >= 0x41u) {
                                  uint64_t v198 = (void *)*v198;
                                }
                                unsigned int v199 = *(_DWORD *)v198;
                                v990.i64[0] = (uint64_t)"mmul";
                                WORD4(v992) = 259;
                                int v200 = (llvm::Value *)sub_1CD77816C((uint64_t **)&v1058, v166, v188, v195, v197, v199, (uint64_t)&v990);
                                v990.i64[0] = 0;
                                int v201 = sub_1CCE317CC(*(void *)(v895 + 56), *(_DWORD *)(v895 + 72), (uint64_t)v134, &v990);
                                uint64_t v202 = *(void *)(v895 + 56);
                                unsigned int v203 = *(_DWORD *)(v895 + 72);
                                if (v201) {
                                  uint64_t v204 = v990.i64[0];
                                }
                                else {
                                  uint64_t v204 = v202 + 56 * v203;
                                }
                                if (v202 + 56 * v203 != v204)
                                {
                                  sub_1CCE31864(v884, (void *)v204);
                                  if (sub_1CCE325A8((uint64_t)v200))
                                  {
                                    v990.i64[0] = (uint64_t)v200;
                                    v990.i64[1] = *(void *)(v204 + 40);
                                    LODWORD(v991) = *(_DWORD *)(v204 + 48);
                                    sub_1CCE3196C((uint64_t)v1038, (uint64_t)v884, (uint64_t)&v990);
                                  }
                                }
                                llvm::Value::doRAUW(v134, v200, (llvm::Value *)1);
                                if (!*((void *)v134 + 1)) {
                                  llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                                }
                                if (!*(void *)(v951.__r_.__value_.__r.__words[0] + 8)) {
                                  llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                                }
                                if (v200) {
                                  uint64_t v131 = (llvm::FixedVectorType *)*((void *)v200 + 3);
                                }
                                else {
                                  uint64_t v131 = v133;
                                }
                                goto LABEL_298;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          uint64_t v131 = v133;
LABEL_298:
          if (v1005 != &v1007) {
            free(v1005);
          }
          if (v131 == v894[0])
          {
            uint64_t v128 = *v880;
            goto LABEL_366;
          }
        }
      }
      uint64_t v128 = v129;
LABEL_366:
      if (v128 != v873) {
        continue;
      }
      break;
    }
    uint64_t v127 = *(void **)v895;
    uint64_t v128 = *(llvm::FixedVectorType **)(*(void *)v895 + 80);
LABEL_368:
    v894[0] = (llvm::FixedVectorType *)(v127 + 9);
    if (v128 != (llvm::FixedVectorType *)(v127 + 9))
    {
      unint64_t __src = (unint64_t)&v1022;
      unint64_t v887 = (unint64_t)v1023;
      while (1)
      {
        uint64_t v205 = (char *)v128 - 24;
        v881 = v128;
        if (!v128) {
          uint64_t v205 = 0;
        }
        uint64_t v206 = v205 + 40;
        uint64_t v207 = (char *)*((void *)v205 + 6);
        if (v207 != v205 + 40) {
          break;
        }
LABEL_437:
        uint64_t v128 = (llvm::FixedVectorType *)*((void *)v881 + 1);
        if (v128 == v894[0])
        {
          uint64_t v127 = *(void **)v895;
          goto LABEL_439;
        }
      }
      while (1)
      {
        unint64_t v208 = (char *)*((void *)v207 + 1);
        uint64_t v209 = v207 ? v207 - 24 : 0;
        v1058 = 0;
        v951.__r_.__value_.__r.__words[0] = 0;
        v938.__r_.__value_.__r.__words[0] = 0;
        v932.__r_.__value_.__r.__words[0] = 0;
        v897 = 0;
        v926 = 0;
        v923 = 0;
        LODWORD(v1005) = 190;
        v1006 = 0;
        v1007 = (llvm::Type *)&v1058;
        uint64_t v1008 = 1;
        v1009 = &v951;
        uint64_t v1010 = 2;
        v1011 = &v897;
        uint64_t v1012 = 3;
        v1013 = &v926;
        uint64_t v1014 = 4;
        v1015 = &v923;
        if (sub_1CCE32538((uint64_t)&v1005, (uint64_t)v209) && v207 && v209[16] == 84)
        {
          uint64_t v210 = *(void *)&v209[32 * v1010 + -32 * (*((_DWORD *)v209 + 5) & 0x7FFFFFF)];
          if (v210 && *(unsigned char *)(v210 + 16) == 16)
          {
            void *v1011 = v210;
            uint64_t v212 = *(unsigned char **)&v209[32 * v1012 + -32 * (*((_DWORD *)v209 + 5) & 0x7FFFFFF)];
            if (v212)
            {
              if (v212[16] == 16)
              {
                *v1013 = v212;
                uint64_t v213 = *(unsigned char **)&v209[32 * v1014 + -32 * (*((_DWORD *)v209 + 5) & 0x7FFFFFF)];
                if (v213)
                {
                  if (v213[16] == 16)
                  {
                    *v1015 = v213;
                    v990.i32[0] = 191;
                    v990.i64[1] = 0;
                    v991 = &v938;
                    if (sub_1CC045310((uint64_t)&v990, (uint64_t)v1058))
                    {
                      *(_DWORD *)v1038 = 191;
                      *(void *)&v1038[8] = 0;
                      *(void *)&v1038[16] = &v932;
                      if (sub_1CC045310((uint64_t)v1038, (uint64_t)v951.__r_.__value_.__l.__data_)) {
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
LABEL_383:
        uint64_t v207 = v208;
        if (v208 == v206) {
          goto LABEL_437;
        }
      }
      uint64_t v214 = 0;
      uint64_t v215 = **(void ****)v209;
      v1005 = &v1007;
      v1006 = (void *)0x200000000;
      v1013 = v215;
      uint64_t v1014 = (uint64_t)&v1022;
      v1015 = (void **)v1023;
      uint64_t v1016 = 0;
      int v1017 = 0;
      __int16 v1018 = 512;
      char v1019 = 7;
      v1011 = 0;
      uint64_t v1012 = 0;
      uint64_t v1020 = 0;
      uint64_t v1021 = 0;
      v1022 = &unk_1F2616E88;
      v1023[0] = &unk_1F2617008;
      v1011 = (void *)*((void *)v209 + 5);
      uint64_t v1012 = (uint64_t)(v209 + 24);
      uint64_t v216 = (unsigned __int8 *)*((void *)v209 + 6);
      *(void *)v1038 = v216;
      if (v216)
      {
        llvm::MetadataTracking::track((uint64_t)v1038, v216, 2);
        uint64_t v214 = *(void *)v1038;
      }
      sub_1CB8461A4((uint64_t)&v1005, 0, v214);
      if (*(void *)v1038)
      {
        int v237 = **(unsigned char **)v1038;
        if ((v237 - 4) > 0x1E)
        {
          if ((v237 - 3) >= 0xFFFFFFFE) {
            uint64_t v240 = *(void *)v1038;
          }
          else {
            uint64_t v240 = 0;
          }
          if ((v237 - 3) < 0xFFFFFFFE)
          {
            if (v237 == 3) {
              *(void *)(*(void *)v1038 + 8) = 0;
            }
            goto LABEL_394;
          }
          unint64_t v239 = v240 + 8;
        }
        else
        {
          if ((*(unsigned char *)(*(void *)v1038 + 1) & 0x7F) != 2 && !*(_DWORD *)(*(void *)v1038 + 12)) {
            goto LABEL_394;
          }
          uint64_t v238 = *(void *)(*(void *)v1038 + 16);
          if ((v238 & 4) == 0) {
            goto LABEL_394;
          }
          unint64_t v239 = v238 & 0xFFFFFFFFFFFFFFF8;
          if (!v239) {
            goto LABEL_394;
          }
        }
        v990.i64[0] = (uint64_t)v1038;
        sub_1CC5FA668(v239 + 16, &v990);
      }
LABEL_394:
      v970.__r_.__value_.__r.__words[0] = (std::string::size_type)&v1005;
      uint64_t v217 = (char *)v923 + 24;
      if (*((_DWORD *)v923 + 8) >= 0x41u) {
        uint64_t v217 = (void *)*v217;
      }
      unsigned int v218 = *(_DWORD *)v217;
      uint64_t v219 = (char *)v926 + 24;
      if (*((_DWORD *)v926 + 8) >= 0x41u) {
        uint64_t v219 = (void *)*v219;
      }
      unsigned int v220 = *(_DWORD *)v219;
      uint64_t v221 = v897 + 6;
      if (v897[8] >= 0x41u) {
        uint64_t v221 = (void *)*v221;
      }
      unsigned int v222 = *(_DWORD *)v221;
      WORD4(v992) = 257;
      uint64_t v223 = sub_1CD77816C((uint64_t **)&v970, (uint64_t)v932.__r_.__value_.__l.__data_, (uint64_t *)v938.__r_.__value_.__l.__data_, v218, v220, v222, (uint64_t)&v990);
      unsigned int v224 = (unsigned int *)((char *)v923 + 24);
      if (*((_DWORD *)v923 + 8) >= 0x41u) {
        unsigned int v224 = *(unsigned int **)v224;
      }
      uint64_t v225 = *v224;
      unsigned int v226 = v897 + 6;
      if (v897[8] >= 0x41u) {
        unsigned int v226 = (void *)*v226;
      }
      int v227 = (void *)*v226;
      BOOL v228 = dword_1EBCF6F18 == 0;
      unint64_t v868 = v868 & 0xFFFFFFFF00000000 | v228;
      sub_1CCE32414(v895, v223, v225 | ((void)v227 << 32), v228);
      uint64_t v229 = (char *)v923 + 24;
      if (*((_DWORD *)v923 + 8) >= 0x41u) {
        uint64_t v229 = (void *)*v229;
      }
      unsigned int v230 = *(_DWORD *)v229;
      uint64_t v231 = v897 + 6;
      if (v897[8] >= 0x41u) {
        uint64_t v231 = (void *)*v231;
      }
      unsigned int v232 = *(_DWORD *)v231;
      WORD4(v992) = 257;
      uint64_t v891 = sub_1CD778068((uint64_t **)&v970, v223, v230, v232, (uint64_t)&v990);
      v990.i64[0] = 0;
      int v233 = sub_1CCE317CC(*(void *)(v895 + 56), *(_DWORD *)(v895 + 72), (uint64_t)v209, &v990);
      uint64_t v234 = *(void *)(v895 + 56);
      unsigned int v235 = *(_DWORD *)(v895 + 72);
      if (v233) {
        uint64_t v236 = v990.i64[0];
      }
      else {
        uint64_t v236 = v234 + 56 * v235;
      }
      if (v234 + 56 * v235 != v236)
      {
        sub_1CCE31864(v884, (void *)v236);
        if (sub_1CCE325A8(v891))
        {
          v990.i64[0] = v891;
          v990.i64[1] = *(void *)(v236 + 40);
          LODWORD(v991) = *(_DWORD *)(v236 + 48);
          sub_1CCE3196C((uint64_t)v1038, (uint64_t)v884, (uint64_t)&v990);
        }
      }
      llvm::Value::doRAUW((llvm::ValueAsMetadata *)v209, (llvm::Value *)v891, (llvm::Value *)1);
      if (!*((void *)v209 + 1)) {
        llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
      }
      if (!*((void *)v1058 + 1)) {
        llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
      }
      if (v1058 != v951.__r_.__value_.__l.__data_ && !*(void *)(v951.__r_.__value_.__r.__words[0] + 8)) {
        llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
      }
      if (v1005 != &v1007) {
        free(v1005);
      }
      goto LABEL_383;
    }
  }
LABEL_439:
  v926 = v928;
  uint64_t v927 = 0x1000000000;
  v923 = v925;
  uint64_t v924 = 0x1000000000;
  v1005 = v127;
  uint64_t v904 = 0;
  v902 = 0;
  v903 = 0;
  sub_1CC86D39C((char **)&v902, (uint64_t)&v1005);
  __int16 v242 = v903;
  int v243 = (char *)v902;
  if (v903 != v902)
  {
    uint64_t v244 = v895;
    do
    {
      uint64_t v245 = *((void *)v242 - 1);
      v242 -= 8;
      uint64_t v246 = v245 + 40;
      for (uint64_t k = *(void *)(v245 + 48); k != v246; uint64_t k = *(void *)(k + 8))
      {
        if (k) {
          uint64_t v248 = k - 24;
        }
        else {
          uint64_t v248 = 0;
        }
        v1005 = 0;
        if (sub_1CCE317CC(*(void *)(v244 + 56), *(_DWORD *)(v244 + 72), v248, &v1005)) {
          BOOL v249 = v1005 == (void *)(*(void *)(v244 + 56) + 56 * *(unsigned int *)(v244 + 72));
        }
        else {
          BOOL v249 = 1;
        }
        if (!v249)
        {
          if (k)
          {
            if (*(unsigned char *)(v248 + 16) == 84)
            {
              uint64_t v250 = *(void *)(v248 - 32);
              if (v250)
              {
                if (!*(unsigned char *)(v250 + 16)
                  && *(void *)(v250 + 24) == *(void *)(v248 + 72)
                  && *(_DWORD *)(v250 + 36) == 190)
                {
                  if (v927 >= (unint64_t)HIDWORD(v927)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((void *)v926 + v927) = v248;
                  LODWORD(v927) = v927 + 1;
                }
              }
            }
          }
          if (v924 >= (unint64_t)HIDWORD(v924)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v923 + v924) = v248;
          LODWORD(v924) = v924 + 1;
        }
      }
    }
    while (v242 != v243);
  }
  v897 = v901;
  v898 = v901;
  uint64_t v899 = 16;
  int v900 = 0;
  int v251 = v927;
  if (v927)
  {
    unint64_t v252 = (unint64_t)v926;
    uint64_t v253 = (char *)v926 + 8 * v927;
    unint64_t v254 = v895;
    v840 = (uint64_t *)(v895 + 288);
    uint64_t v841 = v895 + 264;
    uint64_t v839 = v895 + 304;
    uint64_t v255 = &qword_1EBD0B000;
    v842 = v253;
    while (1)
    {
      if (!*((unsigned char *)v255 + 2104) || !*(void *)(v254 + 32)) {
        goto LABEL_660;
      }
      uint64_t v256 = *(void *)v252;
      uint64_t v257 = v897;
      if (v898 == v897)
      {
        unsigned int v258 = HIDWORD(v899);
        int v259 = (char *)v898 + 8 * HIDWORD(v899);
        if (HIDWORD(v899))
        {
          uint64_t v260 = 0;
          while (*(void *)((char *)v898 + v260) != v256)
          {
            v260 += 8;
            if (8 * HIDWORD(v899) == v260) {
              goto LABEL_487;
            }
          }
          int v259 = (char *)v898 + v260;
        }
LABEL_487:
        uint64_t v257 = v898;
      }
      else
      {
        int v261 = v899 - 1;
        unsigned int v262 = (v899 - 1) & ((v256 >> 4) ^ (v256 >> 9));
        int v259 = (char *)v898 + 8 * v262;
        uint64_t v263 = *(void *)v259;
        if (*(void *)v259 == -1)
        {
          BOOL v264 = 0;
LABEL_633:
          if (v264) {
            int v259 = v264;
          }
          unsigned int v258 = HIDWORD(v899);
          if (*(void *)v259 != v256) {
            int v259 = (char *)v898 + 8 * v899;
          }
        }
        else
        {
          BOOL v264 = 0;
          int v265 = 1;
          while (v263 != v256)
          {
            if (v264) {
              BOOL v266 = 0;
            }
            else {
              BOOL v266 = v263 == -2;
            }
            if (v266) {
              BOOL v264 = v259;
            }
            unsigned int v267 = v262 + v265++;
            unsigned int v262 = v267 & v261;
            int v259 = (char *)v898 + 8 * (v267 & v261);
            uint64_t v263 = *(void *)v259;
            if (*(void *)v259 == -1) {
              goto LABEL_633;
            }
          }
          unsigned int v258 = HIDWORD(v899);
        }
      }
      if (v898 == v257) {
        unsigned int v268 = v258;
      }
      else {
        unsigned int v268 = v899;
      }
      uint64_t v269 = (char *)v898 + 8 * v268;
      if (v259 != v269)
      {
        while (*(void *)v259 >= 0xFFFFFFFFFFFFFFFELL)
        {
          v259 += 8;
          if (v259 == v269) {
            goto LABEL_496;
          }
        }
      }
      if (v259 != v269) {
        goto LABEL_660;
      }
LABEL_496:
      unsigned int v270 = (uint64_t *)(v256 - 32 * (*(_DWORD *)(v256 + 20) & 0x7FFFFFF));
      uint64_t v271 = *v270;
      uint64_t v272 = v270[4];
      v1002 = 0;
      uint64_t v867 = v256;
      if (dword_1EBCF6F18)
      {
        v990.i32[0] = 191;
        v990.i64[1] = 0;
        v991 = (std::string *)&v1002;
        if (sub_1CC045310((uint64_t)&v990, v271)) {
          goto LABEL_498;
        }
      }
      else
      {
        LODWORD(v1005) = 191;
        v1006 = 0;
        v1007 = (llvm::Type *)&v1002;
        if (sub_1CC045310((uint64_t)&v1005, v272))
        {
LABEL_498:
          uint64_t v273 = 0;
          uint64_t v274 = **(void **)v256;
          v970.__r_.__value_.__r.__words[0] = (std::string::size_type)&v970.__r_.__value_.__r.__words[2];
          v970.__r_.__value_.__l.__size_ = 0x200000000;
          uint64_t v975 = v274;
          v976 = &v984;
          v977 = &v985;
          uint64_t v978 = 0;
          int v979 = 0;
          __int16 v980 = 512;
          char v981 = 7;
          uint64_t v973 = 0;
          uint64_t v974 = 0;
          uint64_t v982 = 0;
          uint64_t v983 = 0;
          v984 = &unk_1F2616E88;
          v985 = &unk_1F2617008;
          uint64_t v973 = *(void *)(v256 + 40);
          uint64_t v974 = v256 + 24;
          unsigned int v275 = *(unsigned __int8 **)(v256 + 48);
          v990.i64[0] = (uint64_t)v275;
          if (v275)
          {
            llvm::MetadataTracking::track((uint64_t)&v990, v275, 2);
            uint64_t v273 = v990.i64[0];
          }
          sub_1CB8461A4((uint64_t)&v970, 0, v273);
          if (v990.i64[0])
          {
            int v339 = *(unsigned __int8 *)v990.i64[0];
            if ((v339 - 4) > 0x1E)
            {
              if ((v339 - 3) >= 0xFFFFFFFE) {
                uint64_t v448 = v990.i64[0];
              }
              else {
                uint64_t v448 = 0;
              }
              if ((v339 - 3) < 0xFFFFFFFE)
              {
                if (v339 == 3) {
                  *(void *)(v990.i64[0] + 8) = 0;
                }
                goto LABEL_501;
              }
              unint64_t v341 = v448 + 8;
            }
            else
            {
              if ((*(unsigned char *)(v990.i64[0] + 1) & 0x7F) != 2 && !*(_DWORD *)(v990.i64[0] + 12)) {
                goto LABEL_501;
              }
              uint64_t v340 = *(void *)(v990.i64[0] + 16);
              if ((v340 & 4) == 0) {
                goto LABEL_501;
              }
              unint64_t v341 = v340 & 0xFFFFFFFFFFFFFFF8;
              if (!v341) {
                goto LABEL_501;
              }
            }
            v1005 = &v990;
            sub_1CC5FA668(v341 + 16, &v1005);
          }
LABEL_501:
          uint64_t v276 = *(llvm::FixedVectorType **)(*(void *)v256 + 24);
          uint64_t v277 = (void *)(v256 - 32 * (*(_DWORD *)(v256 + 20) & 0x7FFFFFF));
          uint64_t v278 = v277[8];
          uint64_t v279 = v277[12];
          int v280 = (void *)(v278 + 24);
          if (*(_DWORD *)(v278 + 32) >= 0x41u) {
            int v280 = (void *)*v280;
          }
          uint64_t v281 = (void *)*v280;
          unsigned int v282 = (void *)(v279 + 24);
          if (*(_DWORD *)(v279 + 32) >= 0x41u) {
            unsigned int v282 = (void *)*v282;
          }
          unsigned int v283 = *(_DWORD *)v282;
          uint64_t v284 = v277[16];
          uint64_t v285 = (void *)(v284 + 24);
          if (*(_DWORD *)(v284 + 32) >= 0x41u) {
            uint64_t v285 = (void *)*v285;
          }
          unsigned int v286 = *(_DWORD *)v285;
          *(void *)v1038 = &v1038[16];
          *(void *)&v1038[8] = 0x1000000000;
          long long v1053 = 0uLL;
          LOBYTE(v1054) = dword_1EBCF6F18 == 0;
          v1058 = &v1060;
          v1059 = (void *)0x1000000000;
          long long v1076 = 0uLL;
          char v1077 = dword_1EBCF6F18 == 0;
          if (dword_1EBCF6F18)
          {
            v990.i64[0] = __PAIR64__(v283, v281);
            v990.i8[8] = 0;
            sub_1CCE32694((uint64_t)&v1005, v895, (llvm::PoisonValue **)v1002, (uint64_t)&v990, (uint64_t)&v970);
            uint64_t v287 = v1005;
            if (v1005 == &v1007)
            {
              int v288 = (int)v1006;
              uint64_t v289 = *(unsigned int *)&v1038[8];
              if (*(_DWORD *)&v1038[8] >= v1006)
              {
                if (v1006) {
                  memmove(*(void **)v1038, &v1007, 8 * v1006);
                }
                *(_DWORD *)&v1038[8] = v288;
              }
              else
              {
                if (*(_DWORD *)&v1038[12] < v1006)
                {
                  *(_DWORD *)&v1038[8] = 0;
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (*(_DWORD *)&v1038[8]) {
                  memmove(*(void **)v1038, &v1007, 8 * *(unsigned int *)&v1038[8]);
                }
                else {
                  uint64_t v289 = 0;
                }
                if (v289 != v1006) {
                  memcpy((void *)(*(void *)v1038 + 8 * v289), (char *)v1005 + 8 * v289, 8 * v1006 - 8 * v289);
                }
                *(_DWORD *)&v1038[8] = v288;
              }
            }
            else
            {
              if (*(unsigned char **)v1038 != &v1038[16])
              {
                free(*(void **)v1038);
                uint64_t v287 = v1005;
              }
              *(void *)v1038 = v287;
              *(void *)&v1038[8] = v1006;
              v1005 = &v1007;
              HIDWORD(v1006) = 0;
            }
            LODWORD(v1006) = 0;
            long long v1053 = *(_OWORD *)v1024;
            LOBYTE(v1054) = v1024[16];
            if (v1005 != &v1007) {
              free(v1005);
            }
            v990.i64[0] = __PAIR64__(v283, v286);
            v990.i8[8] = dword_1EBCF6F18 == 0;
            sub_1CCE32694((uint64_t)&v1005, v895, (llvm::PoisonValue **)v272, (uint64_t)&v990, (uint64_t)&v970);
            uint64_t v290 = v1005;
            if (v1005 == &v1007)
            {
              int v291 = (int)v1006;
              uint64_t v292 = v1059;
              if (v1059 >= v1006)
              {
                if (v1006) {
                  memmove(v1058, &v1007, 8 * v1006);
                }
                LODWORD(v1059) = v291;
              }
              else
              {
                if (HIDWORD(v1059) < v1006)
                {
                  LODWORD(v1059) = 0;
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (v1059) {
                  memmove(v1058, &v1007, 8 * v1059);
                }
                else {
                  uint64_t v292 = 0;
                }
                if (v292 != v1006) {
                  memcpy((char *)v1058 + 8 * v292, (char *)v1005 + 8 * v292, 8 * v1006 - 8 * v292);
                }
                LODWORD(v1059) = v291;
              }
            }
            else
            {
              if (v1058 != &v1060)
              {
                free(v1058);
                uint64_t v290 = v1005;
              }
              v1058 = v290;
              v1059 = v1006;
              v1005 = &v1007;
              HIDWORD(v1006) = 0;
            }
            LODWORD(v1006) = 0;
            long long v1076 = *(_OWORD *)v1024;
            char v1077 = v1024[16];
            if (v1005 != &v1007) {
              free(v1005);
            }
            uint64_t v272 = v271;
          }
          else
          {
            v990.i64[0] = __PAIR64__(v283, v281);
            v990.i8[8] = 1;
            sub_1CCE32694((uint64_t)&v1005, v895, (llvm::PoisonValue **)v271, (uint64_t)&v990, (uint64_t)&v970);
            uint64_t v313 = v1005;
            if (v1005 == &v1007)
            {
              int v314 = (int)v1006;
              uint64_t v315 = *(unsigned int *)&v1038[8];
              if (*(_DWORD *)&v1038[8] >= v1006)
              {
                if (v1006) {
                  memmove(*(void **)v1038, &v1007, 8 * v1006);
                }
                *(_DWORD *)&v1038[8] = v314;
              }
              else
              {
                if (*(_DWORD *)&v1038[12] < v1006)
                {
                  *(_DWORD *)&v1038[8] = 0;
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (*(_DWORD *)&v1038[8]) {
                  memmove(*(void **)v1038, &v1007, 8 * *(unsigned int *)&v1038[8]);
                }
                else {
                  uint64_t v315 = 0;
                }
                if (v315 != v1006) {
                  memcpy((void *)(*(void *)v1038 + 8 * v315), (char *)v1005 + 8 * v315, 8 * v1006 - 8 * v315);
                }
                *(_DWORD *)&v1038[8] = v314;
              }
            }
            else
            {
              if (*(unsigned char **)v1038 != &v1038[16])
              {
                free(*(void **)v1038);
                uint64_t v313 = v1005;
              }
              *(void *)v1038 = v313;
              *(void *)&v1038[8] = v1006;
              v1005 = &v1007;
              HIDWORD(v1006) = 0;
            }
            LODWORD(v1006) = 0;
            long long v1053 = *(_OWORD *)v1024;
            LOBYTE(v1054) = v1024[16];
            if (v1005 != &v1007) {
              free(v1005);
            }
            v990.i64[0] = __PAIR64__(v283, v286);
            v990.i8[8] = dword_1EBCF6F18 == 0;
            sub_1CCE32694((uint64_t)&v1005, v895, (llvm::PoisonValue **)v1002, (uint64_t)&v990, (uint64_t)&v970);
            uint64_t v316 = v1005;
            if (v1005 == &v1007)
            {
              int v317 = (int)v1006;
              uint64_t v318 = v1059;
              if (v1059 >= v1006)
              {
                if (v1006) {
                  memmove(v1058, &v1007, 8 * v1006);
                }
                LODWORD(v1059) = v317;
              }
              else
              {
                if (HIDWORD(v1059) < v1006)
                {
                  LODWORD(v1059) = 0;
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (v1059) {
                  memmove(v1058, &v1007, 8 * v1059);
                }
                else {
                  uint64_t v318 = 0;
                }
                if (v318 != v1006) {
                  memcpy((char *)v1058 + 8 * v318, (char *)v1005 + 8 * v318, 8 * v1006 - 8 * v318);
                }
                LODWORD(v1059) = v317;
              }
            }
            else
            {
              if (v1058 != &v1060)
              {
                free(v1058);
                uint64_t v316 = v1005;
              }
              v1058 = v316;
              v1059 = v1006;
              v1005 = &v1007;
              HIDWORD(v1006) = 0;
            }
            LODWORD(v1006) = 0;
            long long v1076 = *(_OWORD *)v1024;
            char v1077 = v1024[16];
            if (v1005 != &v1007) {
              free(v1005);
            }
          }
          sub_1CCE329F0((uint64_t)&v951, v281, v286, v276);
          unsigned int v319 = sub_1CCE33144(v256);
          sub_1CCE32AD0(v895, (uint64_t **)&v951, (uint64_t)v1038, (uint64_t)&v1058, (uint64_t)&v970, 0, 1, v319);
          BOOL v320 = (char *)v898;
          uint64_t v321 = HIDWORD(v899);
          if (v898 == v897)
          {
            if (HIDWORD(v899))
            {
              unint64_t v322 = 0;
              uint64_t v323 = 8 * HIDWORD(v899);
              unint64_t v324 = (uint64_t *)v898;
              while (*v324 != v256)
              {
                if (*v324 == -2) {
                  unint64_t v322 = v324;
                }
                ++v324;
                v323 -= 8;
                if (!v323)
                {
                  if (!v322) {
                    goto LABEL_616;
                  }
                  *unint64_t v322 = v256;
                  --v900;
                  break;
                }
              }
LABEL_646:
              uint64_t v335 = *(void *)(v272 + 8);
              if (!v335 || *(void *)(v335 + 8))
              {
LABEL_648:
                v932.__r_.__value_.__r.__words[0] = (std::string::size_type)&v932.__r_.__value_.__r.__words[2];
                v932.__r_.__value_.__l.__size_ = 0x1000000000;
                if (LODWORD(v951.__r_.__value_.__r.__words[1])) {
                  sub_1CBB08064((uint64_t)&v932, (uint64_t)&v951);
                }
                long long v936 = v968;
                char v937 = v969;
                unint64_t v254 = v895;
                sub_1CCE33198(v895, v256, &v932.__r_.__value_.__l.__data_, (uint64_t)&v970);
                uint64_t v253 = v842;
                uint64_t v255 = &qword_1EBD0B000;
                if ((std::string::size_type *)v932.__r_.__value_.__l.__data_ != &v932.__r_.__value_.__r.__words[2]) {
                  free(v932.__r_.__value_.__l.__data_);
                }
                if ((std::string::size_type *)v951.__r_.__value_.__l.__data_ != &v951.__r_.__value_.__r.__words[2]) {
                  free(v951.__r_.__value_.__l.__data_);
                }
                if (v1058 != &v1060) {
                  free(v1058);
                }
                if (*(unsigned char **)v1038 != &v1038[16]) {
                  free(*(void **)v1038);
                }
                if ((std::string::size_type *)v970.__r_.__value_.__l.__data_ != &v970.__r_.__value_.__r.__words[2]) {
                  free(v970.__r_.__value_.__l.__data_);
                }
                goto LABEL_660;
              }
              uint64_t v342 = (char *)v898;
              uint64_t v343 = HIDWORD(v899);
              unsigned int v344 = v899;
              if (v898 == v897)
              {
                if (HIDWORD(v899))
                {
                  uint64_t v345 = 0;
                  uint64_t v346 = 8 * HIDWORD(v899);
                  uint64_t v347 = (uint64_t *)v898;
                  while (*v347 != v272)
                  {
                    if (*v347 == -2) {
                      uint64_t v345 = v347;
                    }
                    ++v347;
                    v346 -= 8;
                    if (!v346)
                    {
                      if (!v345) {
                        goto LABEL_678;
                      }
                      *uint64_t v345 = v272;
                      --v900;
                      goto LABEL_896;
                    }
                  }
                  goto LABEL_896;
                }
LABEL_678:
                if (v899 > HIDWORD(v899))
                {
                  ++HIDWORD(v899);
                  *((void *)v898 + v343) = v272;
LABEL_896:
                  unint64_t v477 = *(unsigned int *)(v895 + 128);
                  if (v477 >= *(unsigned int *)(v895 + 132)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  uint64_t v478 = v895;
                  *(void *)(*(void *)(v895 + 120) + 8 * v477) = v272;
                  ++*(_DWORD *)(v478 + 128);
                  sub_1CCE329F0((uint64_t)&v938, v283, v286, v276);
                  v906.__r_.__value_.__r.__words[0] = v272;
                  LODWORD(v906.__r_.__value_.__r.__words[1]) = 0;
                  sub_1CD5D55BC(v841, (uint64_t *)&v906, &v906.__r_.__value_.__r.__words[1], (uint64_t)&v909);
                  std::string::size_type v479 = v909.__r_.__value_.__r.__words[0];
                  if (v909.__r_.__value_.__s.__data_[16])
                  {
                    v990.i64[0] = (uint64_t)&v991;
                    v990.i64[1] = 0x1000000000;
                    long long v1000 = 0uLL;
                    BOOL v1001 = dword_1EBCF6F18 == 0;
                    v1005 = (void *)v272;
                    v1006 = &v1008;
                    v1007 = (llvm::Type *)0x1000000000;
                    *(_OWORD *)&v1024[8] = 0uLL;
                    BOOL v1025 = dword_1EBCF6F18 == 0;
                    unint64_t v481 = *(void *)(v478 + 296);
                    unint64_t v480 = *(void *)(v478 + 304);
                    if (v481 >= v480)
                    {
                      uint64_t v487 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v481 - *v840) >> 4);
                      unint64_t v488 = v487 + 1;
                      if ((unint64_t)(v487 + 1) > 0x1745D1745D1745DLL) {
                        abort();
                      }
                      unint64_t v489 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v480 - *v840) >> 4);
                      if (2 * v489 > v488) {
                        unint64_t v488 = 2 * v489;
                      }
                      if (v489 >= 0xBA2E8BA2E8BA2ELL) {
                        unint64_t v490 = 0x1745D1745D1745DLL;
                      }
                      else {
                        unint64_t v490 = v488;
                      }
                      uint64_t v988 = v839;
                      if (v490)
                      {
                        if (v490 > 0x1745D1745D1745DLL) {
                          sub_1CB833614();
                        }
                        unsigned int v491 = (char *)operator new(176 * v490);
                      }
                      else
                      {
                        unsigned int v491 = 0;
                      }
                      std::string::size_type v492 = (std::string::size_type)&v491[176 * v487];
                      v986.__r_.__value_.__r.__words[0] = (std::string::size_type)v491;
                      v986.__r_.__value_.__l.__size_ = v492;
                      *(void *)std::string::size_type v492 = v272;
                      *(void *)(v492 + 8) = v492 + 24;
                      *(void *)(v492 + 16) = 0x1000000000;
                      *(_OWORD *)(v492 + 152) = v1000;
                      *(unsigned char *)(v492 + 168) = v1001;
                      v987 = &v491[176 * v490];
                      v986.__r_.__value_.__r.__words[2] = v492 + 176;
                      sub_1CCE33D24(v840, &v986);
                      unint64_t v484 = *(void *)(v895 + 296);
                      std::string::size_type v494 = v986.__r_.__value_.__r.__words[2];
                      std::string::size_type size = v986.__r_.__value_.__l.__size_;
                      while (v494 != size)
                      {
                        int v495 = *(void **)(v494 - 168);
                        if ((void *)(v494 - 152) != v495) {
                          free(v495);
                        }
                        v494 -= 176;
                      }
                      if (v986.__r_.__value_.__r.__words[0]) {
                        operator delete(v986.__r_.__value_.__l.__data_);
                      }
                    }
                    else
                    {
                      *(void *)unint64_t v481 = v272;
                      *(void *)(v481 + 8) = v481 + 24;
                      *(void *)(v481 + 16) = 0x1000000000;
                      if ((void **)v481 != &v1005)
                      {
                        int v482 = (int)v1007;
                        if (v1007)
                        {
                          if (v1006 == &v1008)
                          {
                            if (v1007 >= 0x11) {
                              llvm::SmallVectorBase<unsigned int>::grow_pod();
                            }
                            memcpy((void *)(v481 + 24), &v1008, 8 * v1007);
                            *(_DWORD *)(v481 + 16) = v482;
                          }
                          else
                          {
                            *(void *)(v481 + 8) = v1006;
                            *(_DWORD *)(v481 + 16) = v482;
                            *(_DWORD *)(v481 + 20) = HIDWORD(v1007);
                            v1006 = &v1008;
                            HIDWORD(v1007) = 0;
                          }
                          LODWORD(v1007) = 0;
                        }
                      }
                      long long v483 = *(_OWORD *)&v1024[8];
                      *(unsigned char *)(v481 + 168) = v1025;
                      *(_OWORD *)(v481 + 152) = v483;
                      unint64_t v484 = v481 + 176;
                    }
                    uint64_t v496 = v895;
                    *(void *)(v895 + 296) = v484;
                    if (v1006 != &v1008) {
                      free(v1006);
                    }
                    if ((std::string **)v990.i64[0] != &v991) {
                      free((void *)v990.i64[0]);
                    }
                    uint64_t v486 = *(void *)(v496 + 288);
                    unsigned int v485 = -1 - 1171354717 * ((unint64_t)(*(void *)(v496 + 296) - v486) >> 4);
                    *(_DWORD *)(v479 + 8) = v485;
                  }
                  else
                  {
                    unsigned int v485 = *(_DWORD *)(v909.__r_.__value_.__r.__words[0] + 8);
                    uint64_t v486 = *v840;
                  }
                  unsigned int v497 = (std::string *)(v486 + 176 * v485 + 8);
                  if (v497 != &v938)
                  {
                    std::string::size_type v498 = v938.__r_.__value_.__r.__words[0];
                    if ((std::string::size_type *)v938.__r_.__value_.__l.__data_ == &v938.__r_.__value_.__r.__words[2])
                    {
                      int v499 = v938.__r_.__value_.__r.__words[1];
                      uint64_t v500 = *(unsigned int *)(v486 + 176 * v485 + 16);
                      if (v500 >= LODWORD(v938.__r_.__value_.__r.__words[1]))
                      {
                        if (LODWORD(v938.__r_.__value_.__r.__words[1])) {
                          memmove(v497->__r_.__value_.__l.__data_, &v938.__r_.__value_.__r.__words[2], 8 * LODWORD(v938.__r_.__value_.__r.__words[1]));
                        }
                        *(_DWORD *)(v486 + 176 * v485 + 16) = v499;
                      }
                      else
                      {
                        if (*(_DWORD *)(v486 + 176 * v485 + 20) < LODWORD(v938.__r_.__value_.__r.__words[1]))
                        {
                          *(_DWORD *)(v486 + 176 * v485 + 16) = 0;
                          llvm::SmallVectorBase<unsigned int>::grow_pod();
                        }
                        if (v500) {
                          memmove(v497->__r_.__value_.__l.__data_, &v938.__r_.__value_.__r.__words[2], 8 * v500);
                        }
                        else {
                          uint64_t v500 = 0;
                        }
                        if (v500 != LODWORD(v938.__r_.__value_.__r.__words[1])) {
                          memcpy((void *)(v497->__r_.__value_.__r.__words[0] + 8 * v500), (const void *)(v938.__r_.__value_.__r.__words[0] + 8 * v500), 8 * LODWORD(v938.__r_.__value_.__r.__words[1]) - 8 * v500);
                        }
                        *(_DWORD *)(v486 + 176 * v485 + 16) = v499;
                      }
                    }
                    else
                    {
                      if (*(void *)(v486 + 176 * v485 + 8) != v486 + 176 * v485 + 24)
                      {
                        free(v497->__r_.__value_.__l.__data_);
                        std::string::size_type v498 = v938.__r_.__value_.__r.__words[0];
                      }
                      v497->__r_.__value_.__r.__words[0] = v498;
                      *(void *)(v486 + 176 * v485 + 16) = v938.__r_.__value_.__l.__size_;
                      v938.__r_.__value_.__r.__words[0] = (std::string::size_type)&v938.__r_.__value_.__r.__words[2];
                      HIDWORD(v938.__r_.__value_.__r.__words[1]) = 0;
                    }
                    LODWORD(v938.__r_.__value_.__r.__words[1]) = 0;
                  }
                  uint64_t v501 = v486 + 176 * v485;
                  long long v502 = v949;
                  *(unsigned char *)(v501 + 168) = v950;
                  *(_OWORD *)(v501 + 152) = v502;
                  if ((std::string::size_type *)v938.__r_.__value_.__l.__data_ != &v938.__r_.__value_.__r.__words[2]) {
                    free(v938.__r_.__value_.__l.__data_);
                  }
                  goto LABEL_648;
                }
              }
              if (3 * (int)v899 <= (4 * (HIDWORD(v899) - v900)))
              {
                if (v899 >= 0x40) {
                  unsigned int v344 = 2 * v899;
                }
                else {
                  unsigned int v344 = 128;
                }
              }
              else if ((int)v899 - HIDWORD(v899) >= v899 >> 3)
              {
                goto LABEL_829;
              }
              llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v897, v344);
              unsigned int v344 = v899;
              uint64_t v342 = (char *)v898;
LABEL_829:
              unsigned int v449 = v344 - 1;
              unsigned int v450 = (v344 - 1) & ((v272 >> 4) ^ (v272 >> 9));
              unint64_t v451 = &v342[8 * v450];
              uint64_t v452 = *(void *)v451;
              if (*(void *)v451 == -1)
              {
                int v453 = 0;
LABEL_889:
                if (v453) {
                  int v476 = v453;
                }
                else {
                  int v476 = (uint64_t *)v451;
                }
                if (*v476 != v272)
                {
                  if (*v476 == -2) {
                    --v900;
                  }
                  else {
                    ++HIDWORD(v899);
                  }
                  uint64_t *v476 = v272;
                }
              }
              else
              {
                int v453 = 0;
                int v454 = 1;
                while (v452 != v272)
                {
                  if (v453) {
                    BOOL v455 = 0;
                  }
                  else {
                    BOOL v455 = v452 == -2;
                  }
                  if (v455) {
                    int v453 = (uint64_t *)v451;
                  }
                  unsigned int v456 = v450 + v454++;
                  unsigned int v450 = v456 & v449;
                  unint64_t v451 = &v342[8 * (v456 & v449)];
                  uint64_t v452 = *(void *)v451;
                  if (*(void *)v451 == -1) {
                    goto LABEL_889;
                  }
                }
              }
              goto LABEL_896;
            }
LABEL_616:
            unsigned int v325 = v899;
            if (HIDWORD(v899) < v899)
            {
              ++HIDWORD(v899);
              *((void *)v898 + v321) = v256;
              goto LABEL_646;
            }
          }
          else
          {
            unsigned int v325 = v899;
          }
          if (3 * v325 <= 4 * (HIDWORD(v899) - v900))
          {
            if (v325 >= 0x40) {
              v325 *= 2;
            }
            else {
              unsigned int v325 = 128;
            }
          }
          else if (v325 - HIDWORD(v899) >= v325 >> 3)
          {
            goto LABEL_621;
          }
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v897, v325);
          unsigned int v325 = v899;
          BOOL v320 = (char *)v898;
LABEL_621:
          unsigned int v326 = v325 - 1;
          unsigned int v327 = (v325 - 1) & ((v256 >> 4) ^ (v256 >> 9));
          uint64_t v328 = &v320[8 * v327];
          uint64_t v329 = *(void *)v328;
          if (*(void *)v328 == -1)
          {
            uint64_t v330 = 0;
LABEL_639:
            if (v330) {
              unint64_t v334 = v330;
            }
            else {
              unint64_t v334 = (uint64_t *)v328;
            }
            if (*v334 != v256)
            {
              if (*v334 == -2) {
                --v900;
              }
              else {
                ++HIDWORD(v899);
              }
              *unint64_t v334 = v256;
            }
          }
          else
          {
            uint64_t v330 = 0;
            int v331 = 1;
            while (v329 != v256)
            {
              if (v330) {
                BOOL v332 = 0;
              }
              else {
                BOOL v332 = v329 == -2;
              }
              if (v332) {
                uint64_t v330 = (uint64_t *)v328;
              }
              unsigned int v333 = v327 + v331++;
              unsigned int v327 = v333 & v326;
              uint64_t v328 = &v320[8 * (v333 & v326)];
              uint64_t v329 = *(void *)v328;
              if (*(void *)v328 == -1) {
                goto LABEL_639;
              }
            }
          }
          goto LABEL_646;
        }
      }
      uint64_t v293 = *(void *)(v256 + 8);
      if (v293)
      {
        if (!*(void *)(v293 + 8) && dword_1EBCF6F18 == 0)
        {
          uint64_t v295 = *(unsigned char *)(v271 + 16) == 60 ? v271 : 0;
          uint64_t v296 = *(unsigned char *)(v272 + 16) == 60 ? v272 : 0;
          uint64_t v297 = *(void *)(v293 + 24);
          uint64_t v298 = *(unsigned char *)(v297 + 16) == 61 ? (llvm::Type *)v297 : 0;
          uint64_t v866 = v295;
          BOOL v299 = !v295 || v296 == 0;
          if (!v299 && v298 != 0)
          {
            uint64_t v864 = v296;
            memset(&v909, 0, 20);
            v911 = 0;
            uint64_t v912 = 0;
            v910 = 0;
            uint64_t v852 = v298;
            v1005 = (void *)*((void *)v298 - 4);
            sub_1CBF5F714(&v909, &v1005);
            v970.__r_.__value_.__r.__words[0] = (std::string::size_type)&v970.__r_.__value_.__r.__words[2];
            v970.__r_.__value_.__l.__size_ = 0x600000000;
            unint64_t v301 = v910;
            if (v911 == v910)
            {
              v1005 = (void *)v254;
              uint64_t v336 = (const llvm::Instruction **)&v970.__r_.__value_.__r.__words[2];
              unint64_t v337 = &v970.__r_.__value_.__s.__data_[16];
            }
            else
            {
              uint64_t v302 = 0;
              unsigned int v303 = 1;
              do
              {
                uint64_t v304 = v301[v302];
                unsigned int v305 = *(unsigned __int8 *)(v304 + 16);
                if (v304) {
                  BOOL v306 = v305 >= 0x1C;
                }
                else {
                  BOOL v306 = 0;
                }
                if (v306)
                {
                  if (v305 == 83) {
                    goto LABEL_959;
                  }
                  if ((llvm::DominatorTree::dominates(*(llvm::DominatorTree **)(v254 + 32), (const llvm::Value *)v304, (const llvm::Instruction *)v256) & 1) == 0)
                  {
                    if (llvm::Instruction::mayHaveSideEffects((llvm::Instruction *)v304)) {
                      goto LABEL_959;
                    }
                    uint64_t v307 = *(unsigned __int8 *)(v304 + 16) - 33;
                    if (v307 <= 0x37)
                    {
                      if (((1 << (*(unsigned char *)(v304 + 16) - 33)) & 0x8000000000041) != 0)
                      {
                        uint64_t v311 = *(void *)(v304 + 64);
                        if (!v311 || (*(unsigned char *)(v311 + 20) & 4) == 0 && (*(unsigned char *)(v311 + 17) & 0x10) == 0)
                        {
                          LODWORD(v1005) = 7;
                          if (sub_1CC5CB59C(v304, (__int32 *)&v1005, 1uLL))
                          {
                            uint64_t v312 = *(void *)(v304 - 32);
                            if (!v312 || *(unsigned char *)(v312 + 16) || *(void *)(v312 + 24) != *(void *)(v304 + 72))
                            {
                              unint64_t v254 = v895;
                              uint64_t v253 = v842;
LABEL_820:
                              uint64_t v255 = &qword_1EBD0B000;
                              goto LABEL_959;
                            }
                            unint64_t v254 = v895;
                            uint64_t v253 = v842;
                            uint64_t v255 = &qword_1EBD0B000;
                            uint64_t v256 = v867;
                            if (*(_DWORD *)(v312 + 36) != 7) {
                              goto LABEL_959;
                            }
                          }
                          if ((llvm::CallBase::hasFnAttrOnCalledFunction(v304, 66) & 1) == 0
                            && !llvm::CallBase::hasFnAttrOnCalledFunction(v304, 44))
                          {
                            goto LABEL_959;
                          }
                        }
                      }
                      else if (((1 << (*(unsigned char *)(v304 + 16) - 33)) & 0x808001C8000010) != 0 {
                             || v307 == 28 && (*(_WORD *)(v304 + 18) & 0x301) != 0)
                      }
                      {
                        goto LABEL_959;
                      }
                    }
                    if (LODWORD(v970.__r_.__value_.__r.__words[1]) >= (unint64_t)HIDWORD(v970.__r_.__value_.__r.__words[1])) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    *(void *)(v970.__r_.__value_.__r.__words[0] + 8 * LODWORD(v970.__r_.__value_.__r.__words[1])) = v304;
                    ++LODWORD(v970.__r_.__value_.__r.__words[1]);
                    int v308 = *(_DWORD *)(v304 + 20);
                    if ((v308 & 0x40000000) != 0)
                    {
                      uint64_t v310 = *(uint64_t **)(v304 - 8);
                      uint64_t v309 = v308 & 0x7FFFFFF;
                    }
                    else
                    {
                      uint64_t v309 = v308 & 0x7FFFFFF;
                      uint64_t v310 = (uint64_t *)(v304 - 32 * v309);
                    }
                    sub_1CD7782B0((uint64_t)&v909, v310, &v310[4 * v309]);
                  }
                }
                uint64_t v302 = v303;
                unint64_t v301 = v910;
                ++v303;
              }
              while (v302 != (v911 - (unsigned char *)v910) >> 3);
              unint64_t v337 = (std::string::value_type *)v970.__r_.__value_.__r.__words[0];
              uint64_t v336 = (const llvm::Instruction **)(v970.__r_.__value_.__r.__words[0]
                                                + 8 * LODWORD(v970.__r_.__value_.__r.__words[1]));
              v1005 = (void *)v254;
              if (LODWORD(v970.__r_.__value_.__r.__words[1]))
              {
                uint64_t v338 = 126 - 2 * __clz(LODWORD(v970.__r_.__value_.__r.__words[1]));
LABEL_682:
                sub_1CCE33E9C((uint64_t)v337, v336, (uint64_t)&v1005, v338, 1);
                if (LODWORD(v970.__r_.__value_.__r.__words[1]))
                {
                  int v348 = (llvm::Instruction **)v970.__r_.__value_.__r.__words[0];
                  uint64_t v349 = 8 * LODWORD(v970.__r_.__value_.__r.__words[1]);
                  do
                  {
                    unsigned int v350 = *v348++;
                    llvm::Instruction::moveBefore(v350, (llvm::Instruction *)v256);
                    v349 -= 8;
                  }
                  while (v349);
                }
                if (byte_1EBD0B9B8) {
                  goto LABEL_686;
                }
                v423 = (void *)(v256 - 32 * (*(_DWORD *)(v256 + 20) & 0x7FFFFFF));
                uint64_t v424 = v423[8];
                unsigned int v425 = (void *)(v424 + 24);
                if (*(_DWORD *)(v424 + 32) >= 0x41u) {
                  unsigned int v425 = (void *)*v425;
                }
                uint64_t v426 = v423[12];
                uint64_t v427 = (void *)(v426 + 24);
                if (*(_DWORD *)(v426 + 32) >= 0x41u) {
                  uint64_t v427 = (void *)*v427;
                }
                uint64_t v428 = v423[16];
                unsigned int v429 = (void *)(v428 + 24);
                if (*(_DWORD *)(v428 + 32) >= 0x41u) {
                  unsigned int v429 = (void *)*v429;
                }
                uint64_t v430 = (void *)*v425;
                int v431 = *(_DWORD *)v427;
                int v432 = *(_DWORD *)v429;
                BOOL v433 = *(llvm::Type **)(*(void *)v256 + 24);
                unint64_t v434 = v254;
                unint64_t v435 = (*(uint64_t (**)(void, uint64_t))(***(void ***)(v254 + 16) + 696))(**(void **)(v254 + 16), 1);
                unint64_t v436 = v435 / llvm::Type::getPrimitiveSizeInBits(v433);
                if (v436 <= 1) {
                  LODWORD(v436) = 1;
                }
                if (v436 >= v430 && v432 == 1)
                {
                  unint64_t v254 = v434;
                  uint64_t v253 = v842;
                  goto LABEL_820;
                }
                unsigned int v438 = ((int)v430 + (int)v436 - 1) / v436 * v431
                     + (v431 + (int)v436 - 1) / v436 * v432;
                uint64_t v439 = *(void **)(v434 + 16);
                (*(void (**)(void, uint64_t, void))(*(void *)*v439 + 680))(*v439, 1, 0);
                unint64_t v254 = v434;
                uint64_t v253 = v842;
                uint64_t v255 = &qword_1EBD0B000;
                if (v438 > (*(unsigned int (**)(void))(*(void *)*v439 + 672))())
                {
LABEL_686:
                  uint64_t v351 = (void *)(v256 - 32 * (*(_DWORD *)(v256 + 20) & 0x7FFFFFF));
                  uint64_t v352 = v351[8];
                  uint64_t v353 = (unsigned int *)(v352 + 24);
                  if (*(_DWORD *)(v352 + 32) >= 0x41u) {
                    uint64_t v353 = *(unsigned int **)v353;
                  }
                  uint64_t v354 = v351[12];
                  uint64_t v355 = (unsigned int *)(v354 + 24);
                  unsigned int v356 = *(_DWORD *)(v354 + 32);
                  uint64_t v357 = (uint64_t *)(v354 + 24);
                  if (v356 >= 0x41)
                  {
                    uint64_t v357 = *(uint64_t **)v355;
                    uint64_t v355 = *(unsigned int **)v355;
                  }
                  uint64_t v358 = v351[16];
                  int v359 = (void *)(v358 + 24);
                  if (*(_DWORD *)(v358 + 32) >= 0x41u) {
                    int v359 = (void *)*v359;
                  }
                  uint64_t v360 = *v353;
                  uint64_t v877 = *v357;
                  v874 = (llvm::ValueHandleBase *)(v360 | (*v357 << 32));
                  int v361 = dword_1EBCF6F18;
                  v843 = (void *)*v359;
                  unint64_t v863 = *v355 | (*v359 << 32);
                  v894[0] = *(llvm::FixedVectorType **)(*(void *)v256 + 24);
                  unint64_t v362 = (unint64_t)v852;
                  v860 = (const llvm::APInt *)sub_1CCE34AF4((void *)v254, (uint64_t *)v866, (uint64_t)v852, (void *)v256);
                  v861 = (const llvm::APInt *)sub_1CCE34AF4((void *)v254, (uint64_t *)v864, (uint64_t)v852, (void *)v256);
                  uint64_t v848 = (const llvm::APInt *)*((void *)v852 - 4);
                  if (byte_1EBCF6D98
                    && !(v360 % dword_1EBD0B8F8)
                    && !(v843 % dword_1EBD0B8F8))
                  {
                    std::string::size_type v473 = *(void *)(*(void *)v256 + 24);
                    v938.__r_.__value_.__r.__words[0] = __PAIR64__(v843, v360);
                    v938.__r_.__value_.__l.__size_ = __PAIR64__(dword_1EBD0B8F8, v877);
                    v938.__r_.__value_.__r.__words[2] = v473;
                    memset(&v941[4], 0, 44);
                    v1005 = &v1007;
                    v1006 = (void *)0x1000000000;
                    uint64_t v1027 = 0;
                    uint64_t v1028 = 0;
                    BOOL v474 = *(llvm::DomTreeUpdater **)(v254 + 40);
                    uint64_t v1029 = *(void *)(v254 + 32);
                    uint64_t v1030 = 0;
                    char v1031 = 1;
                    v1032 = v1036;
                    v1033 = v1036;
                    uint64_t v1034 = 8;
                    int v1035 = 0;
                    memset(&v1036[64], 0, 24);
                    __int16 v1037 = 0;
                    unint64_t v475 = *(llvm **)(v256 + 40);
                    v990.i64[0] = (uint64_t)"continue";
                    WORD4(v992) = 259;
                    sub_1CD126150(v475, (llvm::BasicBlock *)v256, 0, v1029, v474, 0, (llvm::Twine *)&v990, 0);
                  }
                  uint64_t v363 = 0;
                  uint64_t v364 = **(void **)v852;
                  v1058 = &v1060;
                  v1059 = (void *)0x200000000;
                  uint64_t v1065 = v364;
                  v1066 = &v1074;
                  v1067 = v1075;
                  uint64_t v1068 = 0;
                  int v1069 = 0;
                  __int16 v1070 = 512;
                  char v1071 = 7;
                  v1063 = 0;
                  v1064 = 0;
                  uint64_t v1072 = 0;
                  uint64_t v1073 = 0;
                  v1074 = &unk_1F2616E88;
                  v1075[0] = &unk_1F2617008;
                  v1063 = (uint64_t *)*((void *)v852 + 5);
                  v1064 = (char *)v852 + 24;
                  unsigned int v365 = (unsigned __int8 *)*((void *)v852 + 6);
                  v990.i64[0] = (uint64_t)v365;
                  if (v365)
                  {
                    llvm::MetadataTracking::track((uint64_t)&v990, v365, 2);
                    uint64_t v363 = v990.i64[0];
                  }
                  sub_1CB8461A4((uint64_t)&v1058, 0, v363);
                  if (v990.i64[0])
                  {
                    int v503 = *(unsigned __int8 *)v990.i64[0];
                    if ((v503 - 4) > 0x1E)
                    {
                      if ((v503 - 3) >= 0xFFFFFFFE) {
                        uint64_t v506 = v990.i64[0];
                      }
                      else {
                        uint64_t v506 = 0;
                      }
                      if ((v503 - 3) < 0xFFFFFFFE)
                      {
                        if (v503 == 3) {
                          *(void *)(v990.i64[0] + 8) = 0;
                        }
                        goto LABEL_698;
                      }
                      unint64_t v505 = v506 + 8;
                    }
                    else
                    {
                      if ((*(unsigned char *)(v990.i64[0] + 1) & 0x7F) != 2 && !*(_DWORD *)(v990.i64[0] + 12)) {
                        goto LABEL_698;
                      }
                      uint64_t v504 = *(void *)(v990.i64[0] + 16);
                      if ((v504 & 4) == 0) {
                        goto LABEL_698;
                      }
                      unint64_t v505 = v504 & 0xFFFFFFFFFFFFFFF8;
                      if (!v505) {
                        goto LABEL_698;
                      }
                    }
                    v1005 = &v990;
                    sub_1CC5FA668(v505 + 16, &v1005);
                  }
LABEL_698:
                  if (v843)
                  {
                    unsigned int v366 = 0;
                    __p[0] = (void *)(v361 == 0);
                    unsigned int v367 = dword_1EBD0B8F8;
                    unsigned int v846 = v360;
                    do
                    {
                      unsigned int v844 = v366;
                      if (v360)
                      {
                        unsigned int v368 = 0;
                        unsigned int v854 = v843 - v366;
                        uint64_t v882 = v366;
                        do
                        {
                          if (v367 >= v360 - v368) {
                            size_t v369 = v360 - v368;
                          }
                          else {
                            size_t v369 = v367;
                          }
                          if (v367 >= v854) {
                            uint64_t v370 = v854;
                          }
                          else {
                            uint64_t v370 = v367;
                          }
                          v1005 = &v1007;
                          v1006 = (void *)0x1000000000;
                          *(void *)v1024 = 0;
                          *(void *)&v1024[8] = 0;
                          v1024[16] = dword_1EBCF6F18 == 0;
                          size_t v872 = v369;
                          llvm::FixedVectorType::get(v894[0], (llvm::Type *)v369);
                          if (v370)
                          {
                            uint64_t v374 = v371;
                            int v375 = v370;
                            do
                            {
                              uint64_t v376 = llvm::ConstantAggregateZero::get(v374, v372);
                              if (v1006 >= (unint64_t)HIDWORD(v1006)) {
                                llvm::SmallVectorBase<unsigned int>::grow_pod();
                              }
                              *((void *)v1005 + v1006) = v376;
                              LODWORD(v1006) = v1006 + 1;
                              --v375;
                            }
                            while (v375);
                          }
                          unsigned int v857 = v368;
                          uint64_t v885 = v368;
                          int v377 = v877;
                          if (v877)
                          {
                            unsigned int v378 = 0;
                            uint64_t v869 = v370 << 32;
                            unsigned int v379 = dword_1EBD0B8F8;
                            do
                            {
                              unsigned int v380 = v377 - v378;
                              if (v379 >= v380) {
                                unint64_t v381 = v380;
                              }
                              else {
                                unint64_t v381 = v379;
                              }
                              unint64_t v382 = *(unsigned __int16 *)(v866 + 18);
                              uint64_t v383 = *(llvm::ConstantInt **)(*(void *)v1065 + 1984);
                              unsigned int v384 = *(_DWORD *)(*(void *)v1065 + 1992);
                              *(_DWORD *)&v1038[8] = v384 >> 8;
                              if (v384 >> 8 > 0x40) {
                                operator new[]();
                              }
                              if (v384 <= 0xFF) {
                                unint64_t v385 = 0;
                              }
                              else {
                                unint64_t v385 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v384) + 63);
                              }
                              *(void *)v1038 = v385 & v885;
                              unint64_t v387 = llvm::ConstantInt::get(v383, (llvm::LLVMContext *)v1038, v373);
                              if (*(_DWORD *)&v1038[8] >= 0x41u && *(void *)v1038) {
                                MEMORY[0x1D25D9CB0](*(void *)v1038, 0x1000C8000313F17);
                              }
                              uint64_t v388 = *(llvm::ConstantInt **)(*(void *)v1065 + 1984);
                              unsigned int v389 = *(_DWORD *)(*(void *)v1065 + 1992);
                              *(_DWORD *)&v1038[8] = v389 >> 8;
                              if (v389 >> 8 > 0x40) {
                                operator new[]();
                              }
                              if (v389 <= 0xFF) {
                                LODWORD(v390) = 0;
                              }
                              else {
                                unint64_t v390 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v389) + 63);
                              }
                              *(void *)v1038 = v390 & v378;
                              int8x8_t v391 = llvm::ConstantInt::get(v388, (llvm::LLVMContext *)v1038, v386);
                              if (*(_DWORD *)&v1038[8] >= 0x41u && *(void *)v1038) {
                                MEMORY[0x1D25D9CB0](*(void *)v1038, 0x1000C8000313F17);
                              }
                              unint64_t v362 = (v382 >> 1) & 0x3F | v362 & 0xFFFFFFFFFFFF0000 | 0x100;
                              unint64_t v254 = v254 & 0xFFFFFFFF00000000 | (unint64_t)__p[0];
                              unint64_t __src = __src & 0xFFFFFFFF00000000 | (dword_1EBCF6F18 == 0);
                              sub_1CCE35FB4((uint64_t)&v990, v895, v860, v362, v382 & 1, (unint64_t)v874, v254, (uint64_t)v387, (uint64_t)v391, v872, (v872 | (v381 << 32)) >> 32, __src, v894[0], (uint64_t)&v1058);
                              unint64_t v393 = *(unsigned __int16 *)(v864 + 18);
                              uint64_t v394 = *(llvm::ConstantInt **)(*(void *)v1065 + 1984);
                              unsigned int v395 = *(_DWORD *)(*(void *)v1065 + 1992);
                              LODWORD(v951.__r_.__value_.__r.__words[1]) = v395 >> 8;
                              if (v395 >> 8 > 0x40) {
                                operator new[]();
                              }
                              if (v395 <= 0xFF) {
                                LODWORD(v396) = 0;
                              }
                              else {
                                unint64_t v396 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v395) + 63);
                              }
                              v951.__r_.__value_.__r.__words[0] = v396 & v378;
                              v398 = llvm::ConstantInt::get(v394, (llvm::LLVMContext *)&v951, v392);
                              if (LODWORD(v951.__r_.__value_.__r.__words[1]) >= 0x41
                                && v951.__r_.__value_.__r.__words[0])
                              {
                                MEMORY[0x1D25D9CB0](v951.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
                              }
                              uint64_t v399 = *(llvm::ConstantInt **)(*(void *)v1065 + 1984);
                              unsigned int v400 = *(_DWORD *)(*(void *)v1065 + 1992);
                              LODWORD(v951.__r_.__value_.__r.__words[1]) = v400 >> 8;
                              if (v400 >> 8 > 0x40) {
                                operator new[]();
                              }
                              if (v400 <= 0xFF) {
                                unint64_t v401 = 0;
                              }
                              else {
                                unint64_t v401 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v400) + 63);
                              }
                              uint64_t v256 = v867;
                              v951.__r_.__value_.__r.__words[0] = v401 & v882;
                              uint64_t v402 = llvm::ConstantInt::get(v399, (llvm::LLVMContext *)&v951, v397);
                              if (LODWORD(v951.__r_.__value_.__r.__words[1]) >= 0x41
                                && v951.__r_.__value_.__r.__words[0])
                              {
                                MEMORY[0x1D25D9CB0](v951.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
                              }
                              unint64_t v252 = v252 & 0xFFFFFFFF00000000 | (dword_1EBCF6F18 == 0);
                              unint64_t v887 = (v393 >> 1) & 0x3F | v887 & 0xFFFFFFFFFFFF0000 | 0x100;
                              uint64_t v891 = v891 & 0xFFFFFFFF00000000 | (unint64_t)__p[0];
                              sub_1CCE35FB4((uint64_t)v1038, v895, v861, v887, v393 & 1, v863, (char)__p[0], (uint64_t)v398, (uint64_t)v402, v869 | v381, (v869 | v381) >> 32, v252, v894[0], (uint64_t)&v1058);
                              unsigned int v403 = sub_1CCE33144(v867);
                              sub_1CCE32AD0(v895, (uint64_t **)&v1005, (uint64_t)&v990, (uint64_t)v1038, (uint64_t)&v1058, 1, 0, v403);
                              if (*(unsigned char **)v1038 != &v1038[16]) {
                                free(*(void **)v1038);
                              }
                              if ((std::string **)v990.i64[0] != &v991) {
                                free((void *)v990.i64[0]);
                              }
                              unsigned int v379 = dword_1EBD0B8F8;
                              v378 += dword_1EBD0B8F8;
                              int v377 = v877;
                            }
                            while (v378 < v877);
                          }
                          unint64_t v404 = *((unsigned __int16 *)v852 + 9);
                          int v405 = dword_1EBCF6F18;
                          uint64_t v406 = *(llvm::ConstantInt **)(*(void *)v1065 + 1984);
                          unsigned int v407 = *(_DWORD *)(*(void *)v1065 + 1992);
                          v990.i32[2] = v407 >> 8;
                          if (v407 >> 8 > 0x40) {
                            operator new[]();
                          }
                          if (v407 <= 0xFF) {
                            unint64_t v408 = 0;
                          }
                          else {
                            unint64_t v408 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v407) + 63);
                          }
                          v990.i64[0] = v408 & v885;
                          v410 = llvm::ConstantInt::get(v406, (llvm::LLVMContext *)&v990, v373);
                          if (v990.i32[2] >= 0x41u && v990.i64[0]) {
                            MEMORY[0x1D25D9CB0](v990.i64[0], 0x1000C8000313F17);
                          }
                          uint64_t v411 = *(llvm::ConstantInt **)(*(void *)v1065 + 1984);
                          unsigned int v412 = *(_DWORD *)(*(void *)v1065 + 1992);
                          v990.i32[2] = v412 >> 8;
                          if (v412 >> 8 > 0x40) {
                            operator new[]();
                          }
                          if (v412 <= 0xFF) {
                            unint64_t v413 = 0;
                          }
                          else {
                            unint64_t v413 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v412) + 63);
                          }
                          v990.i64[0] = v413 & v882;
                          int v414 = llvm::ConstantInt::get(v411, (llvm::LLVMContext *)&v990, v409);
                          if (v990.i32[2] >= 0x41u && v990.i64[0]) {
                            MEMORY[0x1D25D9CB0](v990.i64[0], 0x1000C8000313F17);
                          }
                          uint64_t v415 = (v404 >> 1) & 0x3F;
                          BOOL v416 = v405 == 0;
                          unint64_t v858 = v415 | v858 & 0xFFFFFFFFFFFF0000 | 0x100;
                          unint64_t v859 = v859 & 0xFFFFFFFF00000000 | v416;
                          sub_1CCE362F0(v895, (uint64_t)&v1005, v848, v415 | 0x100, v404 & 1, (unint64_t)v874, v416, (uint64_t)v410, (uint64_t)v414, v894[0], (uint64_t)&v1058);
                          if (v1005 != &v1007) {
                            free(v1005);
                          }
                          unsigned int v367 = dword_1EBD0B8F8;
                          unsigned int v368 = dword_1EBD0B8F8 + v857;
                          LODWORD(v360) = v846;
                        }
                        while (dword_1EBD0B8F8 + v857 < v846);
                      }
                      unsigned int v366 = v367 + v844;
                    }
                    while (v367 + v844 < v843);
                  }
                  if (v1058 != &v1060) {
                    free(v1058);
                  }
                  v417 = (char *)v898;
                  uint64_t v418 = HIDWORD(v899);
                  if (v898 != v897)
                  {
                    unsigned int v422 = v899;
                    goto LABEL_806;
                  }
                  if (HIDWORD(v899))
                  {
                    int v419 = 0;
                    uint64_t v420 = 8 * HIDWORD(v899);
                    BOOL v421 = (llvm::Type **)v898;
                    do
                    {
                      if (*v421 == v852) {
                        goto LABEL_848;
                      }
                      if (*v421 == (llvm::Type *)-2) {
                        int v419 = v421;
                      }
                      ++v421;
                      v420 -= 8;
                    }
                    while (v420);
                    if (v419)
                    {
                      *int v419 = v852;
                      --v900;
                      goto LABEL_848;
                    }
                  }
                  unsigned int v422 = v899;
                  if (HIDWORD(v899) < v899)
                  {
                    ++HIDWORD(v899);
                    *((void *)v898 + v418) = v852;
                    goto LABEL_848;
                  }
LABEL_806:
                  if (3 * v422 <= 4 * (HIDWORD(v899) - v900))
                  {
                    if (v422 >= 0x40) {
                      v422 *= 2;
                    }
                    else {
                      unsigned int v422 = 128;
                    }
                  }
                  else if (v422 - HIDWORD(v899) >= v422 >> 3)
                  {
LABEL_808:
                    unsigned int v440 = v422 - 1;
                    unsigned int v441 = (v422 - 1) & ((v852 >> 4) ^ (v852 >> 9));
                    int v442 = &v417[8 * v441];
                    uint64_t v443 = *(llvm::Type **)v442;
                    if (*(void *)v442 == -1)
                    {
                      int v444 = 0;
LABEL_841:
                      if (v444) {
                        uint64_t v457 = v444;
                      }
                      else {
                        uint64_t v457 = (llvm::Type **)v442;
                      }
                      if (*v457 != v852)
                      {
                        if (*v457 == (llvm::Type *)-2) {
                          --v900;
                        }
                        else {
                          ++HIDWORD(v899);
                        }
                        *uint64_t v457 = v852;
                      }
                    }
                    else
                    {
                      int v444 = 0;
                      int v445 = 1;
                      while (v443 != v852)
                      {
                        if (v444) {
                          BOOL v446 = 0;
                        }
                        else {
                          BOOL v446 = v443 == (llvm::Type *)-2;
                        }
                        if (v446) {
                          int v444 = (llvm::Type **)v442;
                        }
                        unsigned int v447 = v441 + v445++;
                        unsigned int v441 = v447 & v440;
                        int v442 = &v417[8 * (v447 & v440)];
                        uint64_t v443 = *(llvm::Type **)v442;
                        if (*(void *)v442 == -1) {
                          goto LABEL_841;
                        }
                      }
                    }
LABEL_848:
                    int v458 = (char *)v898;
                    uint64_t v459 = HIDWORD(v899);
                    unsigned int v460 = v899;
                    if (v898 != v897) {
                      goto LABEL_858;
                    }
                    if (!HIDWORD(v899)) {
                      goto LABEL_856;
                    }
                    uint64_t v461 = 0;
                    uint64_t v462 = 8 * HIDWORD(v899);
                    uint64_t v463 = (uint64_t *)v898;
                    do
                    {
                      if (*v463 == v256) {
                        goto LABEL_879;
                      }
                      if (*v463 == -2) {
                        uint64_t v461 = v463;
                      }
                      ++v463;
                      v462 -= 8;
                    }
                    while (v462);
                    if (!v461)
                    {
LABEL_856:
                      if (v899 > HIDWORD(v899))
                      {
                        ++HIDWORD(v899);
                        *((void *)v898 + v459) = v256;
                        goto LABEL_879;
                      }
LABEL_858:
                      if (3 * (int)v899 <= (4 * (HIDWORD(v899) - v900)))
                      {
                        if (v899 >= 0x40) {
                          unsigned int v460 = 2 * v899;
                        }
                        else {
                          unsigned int v460 = 128;
                        }
                      }
                      else if ((int)v899 - HIDWORD(v899) >= v899 >> 3)
                      {
LABEL_860:
                        unsigned int v464 = v460 - 1;
                        unsigned int v465 = (v460 - 1) & ((v256 >> 4) ^ (v256 >> 9));
                        v466 = &v458[8 * v465];
                        uint64_t v467 = *(void *)v466;
                        if (*(void *)v466 == -1)
                        {
                          unsigned int v468 = 0;
LABEL_872:
                          if (v468) {
                            uint8x8_t v472 = v468;
                          }
                          else {
                            uint8x8_t v472 = (uint64_t *)v466;
                          }
                          if (*v472 != v256)
                          {
                            if (*v472 == -2) {
                              --v900;
                            }
                            else {
                              ++HIDWORD(v899);
                            }
                            uint64_t *v472 = v256;
                          }
                        }
                        else
                        {
                          unsigned int v468 = 0;
                          int v469 = 1;
                          while (v467 != v256)
                          {
                            if (v468) {
                              BOOL v470 = 0;
                            }
                            else {
                              BOOL v470 = v467 == -2;
                            }
                            if (v470) {
                              unsigned int v468 = (uint64_t *)v466;
                            }
                            unsigned int v471 = v465 + v469++;
                            unsigned int v465 = v471 & v464;
                            v466 = &v458[8 * (v471 & v464)];
                            uint64_t v467 = *(void *)v466;
                            if (*(void *)v466 == -1) {
                              goto LABEL_872;
                            }
                          }
                        }
LABEL_879:
                        llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                      }
                      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v897, v460);
                      unsigned int v460 = v899;
                      int v458 = (char *)v898;
                      goto LABEL_860;
                    }
                    uint64_t *v461 = v256;
                    --v900;
                    goto LABEL_879;
                  }
                  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v897, v422);
                  unsigned int v422 = v899;
                  v417 = (char *)v898;
                  goto LABEL_808;
                }
LABEL_959:
                if ((std::string::size_type *)v970.__r_.__value_.__l.__data_ != &v970.__r_.__value_.__r.__words[2]) {
                  free(v970.__r_.__value_.__l.__data_);
                }
                if (v910)
                {
                  v911 = v910;
                  operator delete(v910);
                }
                MEMORY[0x1D25D9CD0](v909.__r_.__value_.__r.__words[0], 8);
                goto LABEL_660;
              }
            }
            uint64_t v338 = 0;
            goto LABEL_682;
          }
        }
      }
LABEL_660:
      v252 += 8;
      if ((char *)v252 == v253)
      {
        int v251 = HIDWORD(v899);
        int v507 = v900;
        goto LABEL_1023;
      }
    }
  }
  int v507 = 0;
  unint64_t v254 = v895;
LABEL_1023:
  uint64_t v126 = v251 != v507;
  if (v924)
  {
    uint64_t v508 = (uint64_t ***)v923;
    uint64_t v509 = (char *)v923 + 8 * v924;
    std::string::pointer v510 = &v938.__r_.__value_.__s.__data_[16];
    v894[0] = (llvm::FixedVectorType *)&v1007;
    __srca = v509;
    while (1)
    {
      uint64_t v511 = *v508;
      BOOL v512 = v897;
      if (v898 == v897)
      {
        int v513 = HIDWORD(v899);
        uint64_t v514 = (char *)v898 + 8 * HIDWORD(v899);
        if (HIDWORD(v899))
        {
          uint64_t v515 = 0;
          while (*(uint64_t ***)((char *)v898 + v515) != v511)
          {
            v515 += 8;
            if (8 * HIDWORD(v899) == v515) {
              goto LABEL_1044;
            }
          }
          uint64_t v514 = (char *)v898 + v515;
        }
LABEL_1044:
        BOOL v512 = v898;
      }
      else
      {
        int v516 = v899 - 1;
        unsigned int v517 = (v899 - 1) & ((v511 >> 4) ^ (v511 >> 9));
        uint64_t v514 = (char *)v898 + 8 * v517;
        unsigned int v518 = *(uint64_t ***)v514;
        if (*(void *)v514 == -1)
        {
          v519 = 0;
LABEL_1134:
          if (v519) {
            uint64_t v514 = v519;
          }
          int v513 = HIDWORD(v899);
          if (*(uint64_t ***)v514 != v511) {
            uint64_t v514 = (char *)v898 + 8 * v899;
          }
        }
        else
        {
          v519 = 0;
          int v520 = 1;
          while (v518 != v511)
          {
            if (v519) {
              BOOL v521 = 0;
            }
            else {
              BOOL v521 = v518 == (uint64_t **)-2;
            }
            if (v521) {
              v519 = v514;
            }
            unsigned int v522 = v517 + v520++;
            unsigned int v517 = v522 & v516;
            uint64_t v514 = (char *)v898 + 8 * (v522 & v516);
            unsigned int v518 = *(uint64_t ***)v514;
            if (*(void *)v514 == -1) {
              goto LABEL_1134;
            }
          }
          int v513 = HIDWORD(v899);
        }
      }
      unsigned int v523 = v898 == v512 ? v513 : v899;
      if (v514 == (char *)v898 + 8 * v523) {
        break;
      }
      unint64_t v254 = v895;
LABEL_1174:
      if (++v508 == (uint64_t ***)v509) {
        goto LABEL_1371;
      }
    }
    uint64_t v524 = 0;
    uint64_t v525 = **v511;
    v938.__r_.__value_.__r.__words[0] = (std::string::size_type)v510;
    v938.__r_.__value_.__l.__size_ = 0x200000000;
    *(void *)&v941[16] = v525;
    *(void *)&v941[24] = &v947;
    *(void *)&v941[32] = &v948;
    *(void *)&v941[40] = 0;
    int v942 = 0;
    __int16 v943 = 512;
    char v944 = 7;
    *(void *)v941 = 0;
    *(void *)&v941[8] = 0;
    uint64_t v945 = 0;
    uint64_t v946 = 0;
    v947 = &unk_1F2616E88;
    v948 = &unk_1F2617008;
    BOOL v526 = v511 + 3;
    *(void *)v941 = v511[5];
    *(void *)&v941[8] = v511 + 3;
    unsigned int v527 = (unsigned __int8 *)v511[6];
    v990.i64[0] = (uint64_t)v527;
    if (v527)
    {
      llvm::MetadataTracking::track((uint64_t)&v990, v527, 2);
      uint64_t v524 = v990.i64[0];
    }
    sub_1CB8461A4((uint64_t)&v938, 0, v524);
    if (v990.i64[0])
    {
      int v600 = *(unsigned __int8 *)v990.i64[0];
      if ((v600 - 4) > 0x1E)
      {
        if ((v600 - 3) >= 0xFFFFFFFE) {
          uint64_t v616 = v990.i64[0];
        }
        else {
          uint64_t v616 = 0;
        }
        if ((v600 - 3) < 0xFFFFFFFE)
        {
          if (v600 == 3) {
            *(void *)(v990.i64[0] + 8) = 0;
          }
          goto LABEL_1053;
        }
        unint64_t v602 = v616 + 8;
      }
      else
      {
        if ((*(unsigned char *)(v990.i64[0] + 1) & 0x7F) != 2 && !*(_DWORD *)(v990.i64[0] + 12)) {
          goto LABEL_1053;
        }
        uint64_t v601 = *(void *)(v990.i64[0] + 16);
        if ((v601 & 4) == 0) {
          goto LABEL_1053;
        }
        unint64_t v602 = v601 & 0xFFFFFFFFFFFFFFF8;
        if (!v602) {
          goto LABEL_1053;
        }
      }
      v1005 = &v990;
      sub_1CC5FA668(v602 + 16, &v1005);
    }
LABEL_1053:
    int v529 = *((unsigned __int8 *)v511 + 16);
    if (v529 == 84)
    {
      uint64_t v530 = (uint64_t)*(v511 - 4);
      if (v530)
      {
        if (!*(unsigned char *)(v530 + 16) && *(uint64_t **)(v530 + 24) == v511[9] && (*(unsigned char *)(v530 + 33) & 0x20) != 0)
        {
          switch(*(_DWORD *)(v530 + 36))
          {
            case 0xBC:
              int v603 = v126;
              __int16 v604 = (uint64_t *)&v511[-4 * (*((_DWORD *)v511 + 5) & 0x7FFFFFF)];
              uint64_t v126 = *v604;
              uint64_t v605 = v604[4];
              BOOL v606 = v511[8];
              if (!v606) {
                goto LABEL_1302;
              }
              if (*((_DWORD *)v606 + 2) >= 3u && (unsigned int v607 = (llvm::AttributeSetNode *)v606[7]) != 0)
              {
                __int16 Alignment = llvm::AttributeSetNode::getAlignment(v607);
                unsigned __int8 v609 = Alignment;
                LOWORD(v606) = HIBYTE(Alignment);
              }
              else
              {
                LOWORD(v606) = 0;
LABEL_1302:
                unsigned __int8 v609 = 0;
              }
              uint64_t v680 = v604[8];
              uint64_t v681 = *(unsigned int *)(v680 + 32);
              if (v681 > 0x40)
              {
                int v683 = 0;
                int64_t v684 = (unint64_t)(v681 + 63) >> 6;
                do
                {
                  BOOL v685 = v684-- < 1;
                  if (v685) {
                    break;
                  }
                  unint64_t v686 = *(void *)(*(void *)(v680 + 24) + 8 * v684);
                  v683 += __clz(v686);
                }
                while (!v686);
                int v687 = v681 | 0xFFFFFFC0;
                if ((v681 & 0x3F) == 0) {
                  int v687 = 0;
                }
                BOOL v682 = v683 + v687 == v681 - 1;
              }
              else
              {
                BOOL v682 = *(void *)(v680 + 24) == 1;
              }
              __int16 v688 = v682;
              uint64_t v689 = v604[12];
              uint64_t v690 = v604[16];
              uint64_t v691 = (unsigned int *)(v689 + 24);
              if (*(_DWORD *)(v689 + 32) >= 0x41u) {
                uint64_t v691 = *(unsigned int **)v691;
              }
              uint64_t v692 = *v691;
              v693 = (void *)(v690 + 24);
              if (*(_DWORD *)(v690 + 32) >= 0x41u) {
                v693 = (void *)*v693;
              }
              sub_1CCE3705C(v895, (uint64_t)v511, (llvm::CastInst *)v126, v609 | (unsigned __int16)((_WORD)v606 << 8), v605, v688, v692 | (*v693 << 32), dword_1EBCF6F18 == 0);
              LODWORD(v530) = 1;
              LODWORD(v126) = v603;
              break;
            case 0xBD:
              int v671 = v126;
              int v672 = (uint64_t *)&v511[-4 * (*((_DWORD *)v511 + 5) & 0x7FFFFFF)];
              uint64_t v126 = *v672;
              int v673 = (llvm::CastInst *)v672[4];
              uint64_t v674 = v672[8];
              v675 = v511[8];
              if (!v675) {
                goto LABEL_1320;
              }
              if (*((_DWORD *)v675 + 2) >= 4u && (unint64_t v676 = (llvm::AttributeSetNode *)v675[8]) != 0)
              {
                __int16 v677 = llvm::AttributeSetNode::getAlignment(v676);
                unsigned __int8 v678 = v677;
                LOWORD(v675) = HIBYTE(v677);
              }
              else
              {
                LOWORD(v675) = 0;
LABEL_1320:
                unsigned __int8 v678 = 0;
              }
              uint64_t v694 = v672[12];
              uint64_t v695 = *(unsigned int *)(v694 + 32);
              if (v695 > 0x40)
              {
                int v697 = 0;
                int64_t v698 = (unint64_t)(v695 + 63) >> 6;
                do
                {
                  BOOL v685 = v698-- < 1;
                  if (v685) {
                    break;
                  }
                  unint64_t v699 = *(void *)(*(void *)(v694 + 24) + 8 * v698);
                  v697 += __clz(v699);
                }
                while (!v699);
                int v700 = v695 | 0xFFFFFFC0;
                if ((v695 & 0x3F) == 0) {
                  int v700 = 0;
                }
                BOOL v696 = v697 + v700 == v695 - 1;
              }
              else
              {
                BOOL v696 = *(void *)(v694 + 24) == 1;
              }
              __int16 v701 = v696;
              uint64_t v702 = v672[16];
              uint64_t v703 = v672[20];
              unint64_t v704 = (unsigned int *)(v702 + 24);
              if (*(_DWORD *)(v702 + 32) >= 0x41u) {
                unint64_t v704 = *(unsigned int **)v704;
              }
              uint64_t v705 = *v704;
              uint64_t v706 = (void *)(v703 + 24);
              if (*(_DWORD *)(v703 + 32) >= 0x41u) {
                uint64_t v706 = (void *)*v706;
              }
              sub_1CCE37298(v895, (uint64_t)v511, (llvm::PoisonValue **)v126, v673, v678 | (unsigned __int16)((_WORD)v675 << 8), v674, v701, v528, v705 | (*v706 << 32), dword_1EBCF6F18 == 0);
              LODWORD(v530) = 1;
              LODWORD(v126) = v671;
              BOOL v526 = v511 + 3;
              break;
            case 0xBE:
              uint64_t v619 = 0;
              uint64_t v620 = **v511;
              v951.__r_.__value_.__r.__words[0] = (std::string::size_type)&v951.__r_.__value_.__r.__words[2];
              v951.__r_.__value_.__l.__size_ = 0x200000000;
              uint64_t v957 = v620;
              v958 = &v966;
              v959 = v967;
              uint64_t v960 = 0;
              int v961 = 0;
              __int16 v962 = 512;
              char v963 = 7;
              v955 = 0;
              v956 = 0;
              uint64_t v964 = 0;
              uint64_t v965 = 0;
              v966 = &unk_1F2616E88;
              v967[0] = &unk_1F2617008;
              v955 = v511[5];
              v956 = v511 + 3;
              int v621 = (unsigned __int8 *)v511[6];
              v990.i64[0] = (uint64_t)v621;
              if (v621)
              {
                llvm::MetadataTracking::track((uint64_t)&v990, v621, 2);
                uint64_t v619 = v990.i64[0];
              }
              sub_1CB8461A4((uint64_t)&v951, 0, v619);
              if (!v990.i64[0]) {
                goto LABEL_1222;
              }
              int v707 = *(unsigned __int8 *)v990.i64[0];
              if ((v707 - 4) > 0x1E)
              {
                if ((v707 - 3) >= 0xFFFFFFFE) {
                  uint64_t v713 = v990.i64[0];
                }
                else {
                  uint64_t v713 = 0;
                }
                if ((v707 - 3) >= 0xFFFFFFFE)
                {
                  unint64_t v709 = v713 + 8;
LABEL_1355:
                  v1005 = &v990;
                  sub_1CC5FA668(v709 + 16, &v1005);
                  goto LABEL_1222;
                }
                if (v707 == 3) {
                  *(void *)(v990.i64[0] + 8) = 0;
                }
              }
              else if ((*(unsigned char *)(v990.i64[0] + 1) & 0x7F) == 2 || *(_DWORD *)(v990.i64[0] + 12))
              {
                uint64_t v708 = *(void *)(v990.i64[0] + 16);
                if ((v708 & 4) != 0)
                {
                  unint64_t v709 = v708 & 0xFFFFFFFFFFFFFFF8;
                  if (v709) {
                    goto LABEL_1355;
                  }
                }
              }
LABEL_1222:
              unsigned int v622 = (llvm::FixedVectorType *)(*v511)[3];
              int v623 = (llvm::PoisonValue ***)&v511[-4 * (*((_DWORD *)v511 + 5) & 0x7FFFFFF)];
              unsigned int v624 = v623[8];
              uint64_t v625 = v623[12];
              int v626 = v624 + 3;
              int v849 = v126;
              if (*((_DWORD *)v624 + 8) >= 0x41u) {
                int v626 = (void *)*v626;
              }
              int v627 = (void *)*v626;
              unsigned int v628 = (void **)(v625 + 3);
              unsigned int v629 = *((_DWORD *)v625 + 8);
              v630 = v625 + 3;
              if (v629 >= 0x41) {
                v630 = *v628;
              }
              v932.__r_.__value_.__r.__words[0] = __PAIR64__(*v630, v627);
              v932.__r_.__value_.__s.__data_[8] = dword_1EBCF6F18 == 0;
              uint64_t v631 = v623[16];
              if (v629 >= 0x41) {
                unsigned int v628 = (void **)*v628;
              }
              v632 = *v628;
              uint64_t v633 = (unsigned int *)(v631 + 3);
              if (*((_DWORD *)v631 + 8) >= 0x41u) {
                uint64_t v633 = *(unsigned int **)v633;
              }
              unsigned int v634 = *v633;
              v970.__r_.__value_.__r.__words[0] = __PAIR64__(*v633, v632);
              v970.__r_.__value_.__s.__data_[8] = dword_1EBCF6F18 == 0;
              sub_1CCE32694((uint64_t)&v1005, v895, *v623, (uint64_t)&v932, (uint64_t)&v951);
              sub_1CCE32694((uint64_t)&v990, v895, (llvm::PoisonValue **)v511[-4 * (*((_DWORD *)v511 + 5) & 0x7FFFFFF) + 4], (uint64_t)&v970, (uint64_t)&v951);
              sub_1CCE329F0((uint64_t)v1038, v627, v634, v622);
              unsigned int v635 = sub_1CCE33144((uint64_t)v511);
              sub_1CCE32AD0(v895, (uint64_t **)v1038, (uint64_t)&v1005, (uint64_t)&v990, (uint64_t)&v951, 0, 0, v635);
              v1058 = &v1060;
              v1059 = (void *)0x1000000000;
              if (*(_DWORD *)&v1038[8]) {
                sub_1CBB08064((uint64_t)&v1058, (uint64_t)v1038);
              }
              long long v1076 = v1053;
              char v1077 = (char)v1054;
              sub_1CCE33198(v895, (uint64_t)v511, (unsigned char **)&v1058, (uint64_t)&v951);
              LODWORD(v126) = v849;
              BOOL v526 = v511 + 3;
              if (v1058 != &v1060) {
                free(v1058);
              }
              if (*(unsigned char **)v1038 != &v1038[16]) {
                free(*(void **)v1038);
              }
              if ((std::string **)v990.i64[0] != &v991) {
                free((void *)v990.i64[0]);
              }
              if (v1005 != v894[0]) {
                free(v1005);
              }
              v636 = (llvm::FixedVectorType *)v951.__r_.__value_.__r.__words[0];
              v637 = (llvm::FixedVectorType *)&v951.__r_.__value_.__r.__words[2];
              goto LABEL_1298;
            case 0xBF:
              uint64_t v638 = 0;
              v1005 = v894[0];
              v1006 = (void *)0x1000000000;
              *(void *)v1024 = 0;
              *(void *)&v1024[8] = 0;
              v1024[16] = dword_1EBCF6F18 == 0;
              uint64_t v639 = **v511;
              v1058 = &v1060;
              v1059 = (void *)0x200000000;
              uint64_t v1065 = v639;
              v1066 = &v1074;
              v1067 = v1075;
              uint64_t v1068 = 0;
              int v1069 = 0;
              __int16 v1070 = 512;
              char v1071 = 7;
              v1063 = 0;
              v1064 = 0;
              uint64_t v1072 = 0;
              uint64_t v1073 = 0;
              v1074 = &unk_1F2616E88;
              v1075[0] = &unk_1F2617008;
              v1063 = v511[5];
              v1064 = (char *)(v511 + 3);
              v640 = (unsigned __int8 *)v511[6];
              v951.__r_.__value_.__r.__words[0] = (std::string::size_type)v640;
              if (v640)
              {
                llvm::MetadataTracking::track((uint64_t)&v951, v640, 2);
                uint64_t v638 = v951.__r_.__value_.__r.__words[0];
              }
              sub_1CB8461A4((uint64_t)&v1058, 0, v638);
              if (!v951.__r_.__value_.__r.__words[0]) {
                goto LABEL_1244;
              }
              int v710 = *v951.__r_.__value_.__l.__data_;
              if ((v710 - 4) > 0x1E)
              {
                if ((v710 - 3) >= 0xFFFFFFFE) {
                  std::string::size_type v714 = v951.__r_.__value_.__r.__words[0];
                }
                else {
                  std::string::size_type v714 = 0;
                }
                if ((v710 - 3) >= 0xFFFFFFFE)
                {
                  unint64_t v712 = v714 + 8;
LABEL_1361:
                  v990.i64[0] = (uint64_t)&v951;
                  sub_1CC5FA668(v712 + 16, &v990);
                  goto LABEL_1244;
                }
                if (v710 == 3) {
                  *(void *)(v951.__r_.__value_.__r.__words[0] + 8) = 0;
                }
              }
              else if ((*(unsigned char *)(v951.__r_.__value_.__r.__words[0] + 1) & 0x7F) == 2 {
                     || *(_DWORD *)(v951.__r_.__value_.__r.__words[0] + 12))
              }
              {
                uint64_t v711 = *(void *)(v951.__r_.__value_.__r.__words[0] + 16);
                if ((v711 & 4) != 0)
                {
                  unint64_t v712 = v711 & 0xFFFFFFFFFFFFFFF8;
                  if (v712) {
                    goto LABEL_1361;
                  }
                }
              }
LABEL_1244:
              uint64_t v641 = (llvm::PoisonValue ***)&v511[-4 * (*((_DWORD *)v511 + 5) & 0x7FFFFFF)];
              v642 = *v641;
              size_t v856 = (size_t)**v641;
              int v643 = v641[4];
              int v644 = v641[8];
              int v645 = v643 + 3;
              if (*((_DWORD *)v643 + 8) >= 0x41u) {
                int v645 = (void *)*v645;
              }
              int v646 = (void *)*v645;
              unint64_t v647 = (unsigned int *)(v644 + 3);
              if (*((_DWORD *)v644 + 8) >= 0x41u) {
                unint64_t v647 = *(unsigned int **)v647;
              }
              unsigned int v648 = *v647;
              v970.__r_.__value_.__r.__words[0] = __PAIR64__(*v647, v646);
              v970.__r_.__value_.__s.__data_[8] = dword_1EBCF6F18 == 0;
              sub_1CCE32694((uint64_t)&v990, v895, v642, (uint64_t)&v970, (uint64_t)&v1058);
              if (v1001) {
                size_t v649 = v646;
              }
              else {
                size_t v649 = v648;
              }
              if (v1001) {
                unsigned int v650 = v648;
              }
              else {
                unsigned int v650 = v646;
              }
              unsigned int v853 = v650;
              size_t v855 = v649;
              if (v649)
              {
                unsigned int v845 = v648;
                int v847 = (int)v646;
                int v850 = v126;
                uint64_t v651 = 0;
                do
                {
                  llvm::FixedVectorType::get(*(llvm::FixedVectorType **)(v856 + 24), (llvm::Type *)v853);
                  int v655 = (unsigned __int8 *)llvm::UndefValue::get(v652, v653);
                  if (v990.i32[2])
                  {
                    uint64_t v656 = 0;
                    uint64_t v657 = v990.i64[0];
                    uint64_t v658 = 8 * v990.u32[2];
                    do
                    {
                      uint64_t v659 = *(unsigned __int8 **)(v657 + 8 * v656);
                      __int16 v953 = 257;
                      uint64_t v660 = *(llvm::ConstantInt **)(*(void *)v1065 + 1984);
                      unsigned int v661 = *(_DWORD *)(*(void *)v1065 + 1992);
                      LODWORD(v932.__r_.__value_.__r.__words[1]) = v661 >> 8;
                      if (v661 >> 8 > 0x40) {
                        operator new[]();
                      }
                      if (v661 <= 0xFF) {
                        unint64_t v662 = 0;
                      }
                      else {
                        unint64_t v662 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v661) + 63);
                      }
                      v932.__r_.__value_.__r.__words[0] = v662 & v651;
                      uint64_t v663 = (unsigned __int8 *)llvm::ConstantInt::get(v660, (llvm::LLVMContext *)&v932, v654);
                      if (LODWORD(v932.__r_.__value_.__r.__words[1]) >= 0x41 && v932.__r_.__value_.__r.__words[0]) {
                        MEMORY[0x1D25D9CB0](v932.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
                      }
                      uint64_t v665 = (unsigned __int8 *)sub_1CB8445F4((uint64_t)&v1058, v659, v663, (uint64_t)&v951);
                      __int16 v953 = 257;
                      int v666 = *(llvm::ConstantInt **)(*(void *)v1065 + 1984);
                      unsigned int v667 = *(_DWORD *)(*(void *)v1065 + 1992);
                      LODWORD(v932.__r_.__value_.__r.__words[1]) = v667 >> 8;
                      if (v667 >> 8 > 0x40) {
                        operator new[]();
                      }
                      if (v667 <= 0xFF) {
                        unint64_t v668 = 0;
                      }
                      else {
                        unint64_t v668 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v667) + 63);
                      }
                      v932.__r_.__value_.__r.__words[0] = v668 & v656;
                      v669 = (unsigned __int8 *)llvm::ConstantInt::get(v666, (llvm::LLVMContext *)&v932, v664);
                      if (LODWORD(v932.__r_.__value_.__r.__words[1]) >= 0x41 && v932.__r_.__value_.__r.__words[0]) {
                        MEMORY[0x1D25D9CB0](v932.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
                      }
                      int v655 = (unsigned __int8 *)sub_1CB84478C((uint64_t)&v1058, v655, v665, v669, (uint64_t)&v951);
                      ++v656;
                      v658 -= 8;
                    }
                    while (v658);
                  }
                  if (v1006 >= (unint64_t)HIDWORD(v1006)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  uint64_t v509 = __srca;
                  std::string::pointer v510 = &v938.__r_.__value_.__s.__data_[16];
                  BOOL v526 = v511 + 3;
                  *((void *)v1005 + v1006) = v655;
                  int v670 = v1006 + 1;
                  LODWORD(v1006) = v1006 + 1;
                  ++v651;
                }
                while (v651 != v855);
                LODWORD(v126) = v850;
                LODWORD(v646) = v847;
                unsigned int v648 = v845;
              }
              else
              {
                int v670 = (int)v1006;
              }
              v679.i32[1] = 1;
              v679.i32[0] = 2 * v646 * v648;
              *(int32x2_t *)&v1024[8] = vadd_s32(*(int32x2_t *)&v1024[8], v679);
              *(void *)v1038 = &v1038[16];
              *(void *)&v1038[8] = 0x1000000000;
              if (v670) {
                sub_1CBB08064((uint64_t)v1038, (uint64_t)&v1005);
              }
              long long v1053 = *(_OWORD *)v1024;
              LOBYTE(v1054) = v1024[16];
              sub_1CCE33198(v895, (uint64_t)v511, (unsigned char **)v1038, (uint64_t)&v1058);
              if (*(unsigned char **)v1038 != &v1038[16]) {
                free(*(void **)v1038);
              }
              if ((std::string **)v990.i64[0] != &v991) {
                free((void *)v990.i64[0]);
              }
              if (v1058 != &v1060) {
                free(v1058);
              }
              v636 = (llvm::FixedVectorType *)v1005;
              v637 = v894[0];
LABEL_1298:
              if (v636 != v637) {
                free(v636);
              }
              LODWORD(v530) = 1;
              break;
            default:
              goto LABEL_1058;
          }
        }
        else
        {
LABEL_1058:
          LODWORD(v530) = 0;
        }
      }
      uint64_t v126 = v126 | v530;
      int v529 = *((unsigned __int8 *)v511 + 16);
    }
    if ((v529 - 59) >= 0xFFFFFFEE)
    {
      v1005 = 0;
      int v531 = sub_1CCE317CC(*(void *)(v895 + 56), *(_DWORD *)(v895 + 72), (uint64_t)v511, &v1005);
      uint64_t v532 = *(void *)(v895 + 56);
      unsigned int v533 = *(_DWORD *)(v895 + 72);
      uint64_t v534 = (unsigned char *)(v532 + 56 * v533);
      if (v531) {
        uint64_t v535 = v1005;
      }
      else {
        uint64_t v535 = (unsigned char *)(v532 + 56 * v533);
      }
      if (v535 != v534)
      {
        int v536 = v126;
        uint64_t v537 = 0;
        uint64_t v538 = (llvm::PoisonValue **)*(v511 - 8);
        uint64_t v539 = (llvm::PoisonValue **)*(v511 - 4);
        uint64_t v540 = **v511;
        v951.__r_.__value_.__r.__words[0] = (std::string::size_type)&v951.__r_.__value_.__r.__words[2];
        v951.__r_.__value_.__l.__size_ = 0x200000000;
        uint64_t v957 = v540;
        v958 = &v966;
        v959 = v967;
        uint64_t v960 = 0;
        int v961 = 0;
        __int16 v962 = 512;
        char v963 = 7;
        v955 = 0;
        v956 = 0;
        uint64_t v964 = 0;
        uint64_t v965 = 0;
        v966 = &unk_1F2616E88;
        v967[0] = &unk_1F2617008;
        v955 = v511[5];
        v956 = v526;
        uint64_t v541 = (unsigned __int8 *)v511[6];
        v990.i64[0] = (uint64_t)v541;
        if (v541)
        {
          llvm::MetadataTracking::track((uint64_t)&v990, v541, 2);
          uint64_t v537 = v990.i64[0];
        }
        sub_1CB8461A4((uint64_t)&v951, 0, v537);
        if (v990.i64[0])
        {
          int v610 = *(unsigned __int8 *)v990.i64[0];
          if ((v610 - 4) > 0x1E)
          {
            if ((v610 - 3) >= 0xFFFFFFFE) {
              uint64_t v617 = v990.i64[0];
            }
            else {
              uint64_t v617 = 0;
            }
            if ((v610 - 3) < 0xFFFFFFFE)
            {
              if (v610 == 3) {
                *(void *)(v990.i64[0] + 8) = 0;
              }
              goto LABEL_1068;
            }
            unint64_t v612 = v617 + 8;
          }
          else
          {
            if ((*(unsigned char *)(v990.i64[0] + 1) & 0x7F) != 2 && !*(_DWORD *)(v990.i64[0] + 12)) {
              goto LABEL_1068;
            }
            uint64_t v611 = *(void *)(v990.i64[0] + 16);
            if ((v611 & 4) == 0) {
              goto LABEL_1068;
            }
            unint64_t v612 = v611 & 0xFFFFFFFFFFFFFFF8;
            if (!v612) {
              goto LABEL_1068;
            }
          }
          v1005 = &v990;
          sub_1CC5FA668(v612 + 16, &v1005);
        }
LABEL_1068:
        v1005 = v894[0];
        v1006 = (void *)0x1000000000;
        *(void *)v1024 = 0;
        *(void *)&v1024[8] = 0;
        v1024[16] = dword_1EBCF6F18 == 0;
        sub_1CCE32694((uint64_t)&v990, v895, v538, (uint64_t)(v535 + 40), (uint64_t)&v951);
        sub_1CCE32694((uint64_t)v1038, v895, v539, (uint64_t)(v535 + 40), (uint64_t)&v951);
        int v961 = sub_1CCE33144((uint64_t)v511);
        uint64_t v542 = 44;
        if (!v535[48]) {
          uint64_t v542 = 40;
        }
        LODWORD(v126) = v536;
        uint64_t v509 = __srca;
        if (*(_DWORD *)&v535[v542])
        {
          unint64_t v543 = 0;
          do
          {
            unsigned int v544 = *(void **)(v990.i64[0] + 8 * v543);
            uint64_t v545 = *(void *)(*(void *)v1038 + 8 * v543);
            switch(*((unsigned char *)v511 + 16))
            {
              case '*':
                __int16 v934 = 257;
                uint64_t v546 = sub_1CC52C04C((uint64_t)&v951, (uint64_t)v544, v545, (uint64_t)&v932, 0);
                break;
              case '+':
                __int16 v934 = 257;
                uint64_t v546 = (uint64_t)sub_1CB84494C((uint64_t)&v951, (uint64_t)v544, v545, (uint64_t)&v932, 0, 0);
                break;
              case ',':
                __int16 v934 = 257;
                uint64_t v546 = sub_1CB843E40((uint64_t)&v951, (uint64_t)v544, v545, (uint64_t)&v932, 0);
                break;
              case '-':
                __int16 v934 = 257;
                uint64_t v546 = (uint64_t)sub_1CC09A1EC((uint64_t)&v951, (uint64_t)v544, v545, (uint64_t)&v932, 0, 0);
                break;
              case '.':
                __int16 v934 = 257;
                uint64_t v546 = sub_1CB843C88((uint64_t)&v951, (uint64_t)v544, v545, (uint64_t)&v932, 0);
                break;
              default:
                __int16 v934 = 257;
                uint64_t v546 = (uint64_t)sub_1CB844A3C((uint64_t)&v951, v544, v545, (uint64_t)&v932, 0, 0);
                break;
            }
            if (v1006 >= (unint64_t)HIDWORD(v1006)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v1005 + v1006) = v546;
            LODWORD(v1006) = v1006 + 1;
            ++v543;
            uint64_t v547 = 44;
            if (!v535[48]) {
              uint64_t v547 = 40;
            }
          }
          while (v543 < *(unsigned int *)&v535[v547]);
        }
        unsigned int v548 = sub_1CCE33C80(v895, **(void **)v1005);
        *(_DWORD *)&v1024[8] += v1006 * v548;
        v1058 = &v1060;
        v1059 = (void *)0x1000000000;
        if (v1006) {
          sub_1CBB08064((uint64_t)&v1058, (uint64_t)&v1005);
        }
        long long v1076 = *(_OWORD *)v1024;
        char v1077 = v1024[16];
        sub_1CCE33198(v895, (uint64_t)v511, (unsigned char **)&v1058, (uint64_t)&v951);
        if (v1058 != &v1060) {
          free(v1058);
        }
        if (*(unsigned char **)v1038 != &v1038[16]) {
          free(*(void **)v1038);
        }
        if ((std::string **)v990.i64[0] != &v991) {
          free((void *)v990.i64[0]);
        }
        if (v1005 != v894[0]) {
          free(v1005);
        }
        if ((std::string::size_type *)v951.__r_.__value_.__l.__data_ != &v951.__r_.__value_.__r.__words[2]) {
          free(v951.__r_.__value_.__l.__data_);
        }
      }
      uint64_t v126 = v126 | (v535 != v534);
      int v529 = *((unsigned __int8 *)v511 + 16);
      std::string::pointer v510 = &v938.__r_.__value_.__s.__data_[16];
    }
    if (v529 == 40)
    {
      unsigned int v549 = v510;
      int v550 = v126;
      v1005 = 0;
      int v551 = sub_1CCE317CC(*(void *)(v895 + 56), *(_DWORD *)(v895 + 72), (uint64_t)v511, &v1005);
      uint64_t v552 = *(void *)(v895 + 56);
      unsigned int v553 = *(_DWORD *)(v895 + 72);
      v554 = (unsigned char *)(v552 + 56 * v553);
      if (v551) {
        int v555 = v1005;
      }
      else {
        int v555 = (unsigned char *)(v552 + 56 * v553);
      }
      if (v555 != v554)
      {
        uint64_t v556 = 0;
        unsigned int v557 = (llvm::PoisonValue **)*(v511 - 4);
        uint64_t v558 = **v511;
        v1058 = &v1060;
        v1059 = (void *)0x200000000;
        uint64_t v1065 = v558;
        v1066 = &v1074;
        v1067 = v1075;
        uint64_t v1068 = 0;
        int v1069 = 0;
        __int16 v1070 = 512;
        char v1071 = 7;
        v1063 = 0;
        v1064 = 0;
        uint64_t v1072 = 0;
        uint64_t v1073 = 0;
        v1074 = &unk_1F2616E88;
        v1075[0] = &unk_1F2617008;
        v1063 = v511[5];
        v1064 = (char *)v526;
        unsigned int v559 = (unsigned __int8 *)v511[6];
        v990.i64[0] = (uint64_t)v559;
        if (v559)
        {
          llvm::MetadataTracking::track((uint64_t)&v990, v559, 2);
          uint64_t v556 = v990.i64[0];
        }
        sub_1CB8461A4((uint64_t)&v1058, 0, v556);
        if (v990.i64[0])
        {
          int v613 = *(unsigned __int8 *)v990.i64[0];
          if ((v613 - 4) > 0x1E)
          {
            if ((v613 - 3) >= 0xFFFFFFFE) {
              uint64_t v618 = v990.i64[0];
            }
            else {
              uint64_t v618 = 0;
            }
            if ((v613 - 3) < 0xFFFFFFFE)
            {
              if (v613 == 3) {
                *(void *)(v990.i64[0] + 8) = 0;
              }
              goto LABEL_1106;
            }
            unint64_t v615 = v618 + 8;
          }
          else
          {
            if ((*(unsigned char *)(v990.i64[0] + 1) & 0x7F) != 2 && !*(_DWORD *)(v990.i64[0] + 12)) {
              goto LABEL_1106;
            }
            uint64_t v614 = *(void *)(v990.i64[0] + 16);
            if ((v614 & 4) == 0) {
              goto LABEL_1106;
            }
            unint64_t v615 = v614 & 0xFFFFFFFFFFFFFFF8;
            if (!v615) {
              goto LABEL_1106;
            }
          }
          v1005 = &v990;
          sub_1CC5FA668(v615 + 16, &v1005);
        }
LABEL_1106:
        v1005 = v894[0];
        v1006 = (void *)0x1000000000;
        *(void *)v1024 = 0;
        *(void *)&v1024[8] = 0;
        v1024[16] = dword_1EBCF6F18 == 0;
        sub_1CCE32694((uint64_t)&v990, v895, v557, (uint64_t)(v555 + 40), (uint64_t)&v1058);
        int v1069 = sub_1CCE33144((uint64_t)v511);
        uint64_t v560 = 44;
        if (!v555[48]) {
          uint64_t v560 = 40;
        }
        if (*(_DWORD *)&v555[v560])
        {
          unint64_t v561 = 0;
          do
          {
            uint64_t v562 = *(void *)(v990.i64[0] + 8 * v561);
            __int16 v953 = 257;
            uint64_t v563 = sub_1CB843FF8((uint64_t)&v1058, v562, (uint64_t)&v951, 0);
            if (v1006 >= (unint64_t)HIDWORD(v1006)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v1005 + v1006) = v563;
            LODWORD(v1006) = v1006 + 1;
            ++v561;
            uint64_t v564 = 44;
            if (!v555[48]) {
              uint64_t v564 = 40;
            }
          }
          while (v561 < *(unsigned int *)&v555[v564]);
        }
        unsigned int v565 = sub_1CCE33C80(v895, **(void **)v1005);
        *(_DWORD *)&v1024[8] += v1006 * v565;
        *(void *)v1038 = &v1038[16];
        *(void *)&v1038[8] = 0x1000000000;
        if (v1006) {
          sub_1CBB08064((uint64_t)v1038, (uint64_t)&v1005);
        }
        long long v1053 = *(_OWORD *)v1024;
        LOBYTE(v1054) = v1024[16];
        sub_1CCE33198(v895, (uint64_t)v511, (unsigned char **)v1038, (uint64_t)&v1058);
        if (*(unsigned char **)v1038 != &v1038[16]) {
          free(*(void **)v1038);
        }
        if ((std::string **)v990.i64[0] != &v991) {
          free((void *)v990.i64[0]);
        }
        if (v1005 != v894[0]) {
          free(v1005);
        }
        if (v1058 != &v1060) {
          free(v1058);
        }
      }
      uint64_t v126 = v550 | (v555 != v554);
      int v529 = *((unsigned __int8 *)v511 + 16);
      std::string::pointer v510 = v549;
      uint64_t v509 = __srca;
    }
    if (v529 == 61)
    {
      int v568 = *((_DWORD *)v511 + 5);
      if ((v568 & 0x40000000) != 0) {
        uint64_t v569 = (llvm::PoisonValue ***)*(v511 - 1);
      }
      else {
        uint64_t v569 = (llvm::PoisonValue ***)&v511[-4 * (v568 & 0x7FFFFFF)];
      }
      uint64_t v584 = *v569;
      if (*v569)
      {
        uint64_t v585 = v126;
        unsigned int v586 = (llvm::CastInst *)v569[4];
        if (v586)
        {
          v1005 = 0;
          int v587 = sub_1CCE317CC(*(void *)(v895 + 56), *(_DWORD *)(v895 + 72), (uint64_t)v584, &v1005);
          uint64_t v589 = *(void *)(v895 + 56);
          unsigned int v590 = *(_DWORD *)(v895 + 72);
          BOOL v591 = (char *)(v589 + 56 * v590);
          if (v587) {
            unsigned int v592 = (char *)v1005;
          }
          else {
            unsigned int v592 = (char *)(v589 + 56 * v590);
          }
          if (v592 != v591)
          {
            unint64_t v870 = *((unsigned __int16 *)v511 + 9);
            uint64_t v593 = 44;
            if (v592[48]) {
              uint64_t v593 = 40;
            }
            uint64_t v594 = *(unsigned int *)&v592[v593];
            uint64_t v595 = *(llvm::ConstantInt **)(**(void **)&v941[16] + 1984);
            unsigned int v596 = *(_DWORD *)(**(void **)&v941[16] + 1992);
            LODWORD(v1006) = v596 >> 8;
            if (v596 >> 8 > 0x40) {
              operator new[]();
            }
            if (v596 <= 0xFF) {
              unint64_t v597 = 0;
            }
            else {
              unint64_t v597 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v596) + 63);
            }
            v1005 = (void *)(v597 & v594);
            v599 = llvm::ConstantInt::get(v595, (llvm::LLVMContext *)&v1005, v588);
            std::string::pointer v510 = &v938.__r_.__value_.__s.__data_[16];
            if (v1006 >= 0x41 && v1005) {
              MEMORY[0x1D25D9CB0](v1005, 0x1000C8000313F17);
            }
            sub_1CCE37298(v895, (uint64_t)v511, v584, v586, (v870 >> 1) & 0x3F | 0x100, (uint64_t)v599, *((_WORD *)v511 + 9) & 1, v598, *((void *)v592 + 5), *((_DWORD *)v592 + 12));
          }
          uint64_t v126 = v585 | (v592 != v591);
        }
        else
        {
          uint64_t v126 = v585;
        }
        uint64_t v509 = __srca;
      }
    }
    else if (v529 == 60)
    {
      int v566 = *((_DWORD *)v511 + 5);
      uint64_t v567 = (v566 & 0x40000000) != 0
           ? (llvm::CastInst **)*(v511 - 1)
           : (llvm::CastInst **)&v511[-4 * (v566 & 0x7FFFFFF)];
      unsigned int v570 = *v567;
      if (*v567)
      {
        v1005 = 0;
        int v571 = sub_1CCE317CC(*(void *)(v895 + 56), *(_DWORD *)(v895 + 72), (uint64_t)v511, &v1005);
        uint64_t v573 = *(void *)(v895 + 56);
        unsigned int v574 = *(_DWORD *)(v895 + 72);
        uint64_t v575 = (char *)(v573 + 56 * v574);
        if (v571) {
          uint64_t v576 = (char *)v1005;
        }
        else {
          uint64_t v576 = (char *)(v573 + 56 * v574);
        }
        if (v576 != v575)
        {
          int v577 = v126;
          unint64_t v578 = *((unsigned __int16 *)v511 + 9);
          uint64_t v579 = 44;
          if (v576[48]) {
            uint64_t v579 = 40;
          }
          uint64_t v580 = *(unsigned int *)&v576[v579];
          int v581 = *(llvm::ConstantInt **)(**(void **)&v941[16] + 1984);
          unsigned int v582 = *(_DWORD *)(**(void **)&v941[16] + 1992);
          LODWORD(v1006) = v582 >> 8;
          if (v582 >> 8 > 0x40) {
            operator new[]();
          }
          if (v582 <= 0xFF) {
            unint64_t v583 = 0;
          }
          else {
            unint64_t v583 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v582) + 63);
          }
          v1005 = (void *)(v583 & v580);
          uint64_t v126 = (uint64_t)llvm::ConstantInt::get(v581, (llvm::LLVMContext *)&v1005, v572);
          if (v1006 >= 0x41 && v1005) {
            MEMORY[0x1D25D9CB0](v1005, 0x1000C8000313F17);
          }
          sub_1CCE3705C(v895, (uint64_t)v511, v570, (v578 >> 1) & 0x3F | 0x100, v126, *((_WORD *)v511 + 9) & 1, *((void *)v576 + 5), *((_DWORD *)v576 + 12));
          LODWORD(v126) = v577;
          uint64_t v509 = __srca;
          std::string::pointer v510 = &v938.__r_.__value_.__s.__data_[16];
        }
        uint64_t v126 = v126 | (v576 != v575);
      }
    }
    unint64_t v254 = v895;
    if (v938.__r_.__value_.__l.__data_ != v510) {
      free(v938.__r_.__value_.__l.__data_);
    }
    goto LABEL_1174;
  }
LABEL_1371:
  int v715 = *(uint64_t **)(v254 + 48);
  if (v715)
  {
    unsigned int v716 = *(uint64_t **)v254;
    unint64_t v886 = v254 + 264;
    v896[0] = (uint64_t *)(v254 + 264);
    v896[1] = v715;
    v717 = (uint64_t *)(v716[5] + 272);
    v896[2] = v716;
    v883 = v717;
    v896[3] = v717;
    uint64_t v718 = ***(void ***)*v715;
    if (*(void *)(v718 + 128)
      || sub_1CC421DEC(*(void *)(v718 + 72), (uint64_t)"lower-matrix-intrinsics", 23))
    {
      v875 = (uint64_t ***)v715;
      char v851 = v126;
      v917[1] = 0;
      v917[0] = 0;
      int v918 = 0;
      uint64_t v921 = 0;
      uint64_t v919 = 0;
      uint64_t v920 = 0;
      uint64_t v746 = *(void *)(v254 + 288);
      uint64_t v747 = *(void *)(v254 + 296);
      if (v746 == v747) {
        goto LABEL_1505;
      }
      unsigned int v748 = (v716 >> 4) ^ (v716 >> 9);
      while (1)
      {
        if ((*((unsigned char *)v716 + 23) & 0x20) == 0) {
          goto LABEL_1457;
        }
        uint64_t v749 = **(void **)*v716;
        v1005 = v716;
        int v750 = *(_DWORD *)(v749 + 2496);
        if (!v750) {
          break;
        }
        uint64_t v751 = *(void *)(v749 + 2480);
        int v752 = v750 - 1;
        unsigned int v753 = v752 & v748;
        v754 = (void *)(v751 + 40 * (v752 & v748));
        uint64_t v755 = (void ***)*v754;
        if ((uint64_t *)*v754 != v716)
        {
          v756 = 0;
          int v757 = 1;
          while (v755 != (void ***)-4096)
          {
            if (v756) {
              BOOL v758 = 0;
            }
            else {
              BOOL v758 = v755 == (void ***)-8192;
            }
            if (v758) {
              v756 = v754;
            }
            unsigned int v759 = v753 + v757++;
            unsigned int v753 = v759 & v752;
            v754 = (void *)(v751 + 40 * v753);
            uint64_t v755 = (void ***)*v754;
            if ((uint64_t *)*v754 == v716) {
              goto LABEL_1453;
            }
          }
          if (v756) {
            v775 = v756;
          }
          else {
            v775 = v754;
          }
          goto LABEL_1501;
        }
LABEL_1453:
        uint64_t v760 = *((unsigned int *)v754 + 4);
        if (v760)
        {
          v761 = (void *)(v754[1] + 8);
          uint64_t v762 = 16 * v760;
          while (*((_DWORD *)v761 - 2))
          {
            v761 += 2;
            v762 -= 16;
            if (!v762) {
              goto LABEL_1457;
            }
          }
          if (*v761)
          {
            uint64_t v765 = *(void *)(*(void *)v746 + 48);
            if (v765)
            {
              while (1)
              {
                uint64_t v766 = *(unsigned __int8 **)(v765 - 8 * *(unsigned int *)(v765 + 8));
                int v767 = *v766;
                if (v767 != 17 && (v767 & 0xFE) == 18)
                {
                  do
                    uint64_t v766 = *(unsigned __int8 **)&v766[-8 * *((unsigned int *)v766 + 2) + 8];
                  while ((*v766 & 0xFE) == 0x12);
                }
                v990.i64[0] = (uint64_t)&v991;
                v990.i64[1] = 0x800000000;
                v1005 = v766;
                v1006 = &v1008;
                v1007 = (llvm::Type *)0x800000000;
                uint64_t v769 = sub_1CD778350((uint64_t)v917, (uint64_t *)&v1005, (uint64_t)&v1006);
                if (v1006 != &v1008) {
                  free(v1006);
                }
                if ((std::string **)v990.i64[0] != &v991) {
                  free((void *)v990.i64[0]);
                }
                unint64_t v770 = *(unsigned int *)(v769 + 16);
                if (v770 >= *(unsigned int *)(v769 + 20)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *(void *)(*(void *)(v769 + 8) + 8 * v770) = *(void *)v746;
                ++*(_DWORD *)(v769 + 16);
                v990.i64[0] = v765;
                llvm::MetadataTracking::track((uint64_t)&v990, (unsigned __int8 *)v765, 2);
                if (*(_DWORD *)(v990.i64[0] + 8) == 2) {
                  uint64_t v765 = *(void *)(v990.i64[0] - 8);
                }
                else {
                  uint64_t v765 = 0;
                }
                int v771 = *(unsigned __int8 *)v990.i64[0];
                if ((v771 - 4) > 0x1E)
                {
                  if ((v771 - 3) >= 0xFFFFFFFE) {
                    uint64_t v772 = v990.i64[0];
                  }
                  else {
                    uint64_t v772 = 0;
                  }
                  if ((v771 - 3) < 0xFFFFFFFE)
                  {
                    if (v771 == 3) {
                      *(void *)(v990.i64[0] + 8) = 0;
                    }
                    goto LABEL_1482;
                  }
                  unint64_t v773 = v772 + 8;
                }
                else
                {
                  if ((*(unsigned char *)(v990.i64[0] + 1) & 0x7F) != 2 && !*(_DWORD *)(v990.i64[0] + 12)) {
                    goto LABEL_1482;
                  }
                  uint64_t v774 = *(void *)(v990.i64[0] + 16);
                  if ((v774 & 4) == 0) {
                    goto LABEL_1482;
                  }
                  unint64_t v773 = v774 & 0xFFFFFFFFFFFFFFF8;
                  if (!v773) {
                    goto LABEL_1482;
                  }
                }
                v1005 = &v990;
                sub_1CC5FA668(v773 + 16, &v1005);
LABEL_1482:
                if (!v765) {
                  goto LABEL_1463;
                }
              }
            }
            goto LABEL_1463;
          }
        }
LABEL_1457:
        v990.i64[0] = (uint64_t)&v991;
        v990.i64[1] = 0x800000000;
        v1005 = 0;
        v1006 = &v1008;
        v1007 = (llvm::Type *)0x800000000;
        uint64_t v763 = sub_1CD778350((uint64_t)v917, (uint64_t *)&v1005, (uint64_t)&v1006);
        if (v1006 != &v1008) {
          free(v1006);
        }
        if ((std::string **)v990.i64[0] != &v991) {
          free((void *)v990.i64[0]);
        }
        unint64_t v764 = *(unsigned int *)(v763 + 16);
        if (v764 >= *(unsigned int *)(v763 + 20)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v763 + 8) + 8 * v764) = *(void *)v746;
        ++*(_DWORD *)(v763 + 16);
LABEL_1463:
        v746 += 176;
        if (v746 == v747)
        {
          uint64_t v777 = v919;
          uint64_t v865 = v920;
          unint64_t v254 = v895;
          if (v919 == v920) {
            goto LABEL_1505;
          }
          v894[0] = (llvm::FixedVectorType *)&v997;
          int64x2_t v778 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
          int64x2_t v862 = v778;
LABEL_1507:
          v779 = *(void **)(v777 + 8);
          uint64_t v780 = *(unsigned int *)(v777 + 16);
          uint64_t v781 = 8;
          v1005 = (void *)1;
          do
          {
            *(int64x2_t *)((char *)&v1005 + v781) = v778;
            v781 += 16;
          }
          while (v781 != 264);
          v1026 = &v1028;
          uint64_t v1027 = 0x2000000000;
          sub_1CD778540(&v1005, v779, &v779[v780]);
          v1002 = v1004;
          uint64_t v1003 = 0x400000000;
          if (!v1027)
          {
            uint64_t v915 = 0;
            uint64_t v914 = 0;
            unsigned int v916 = 0;
            goto LABEL_1536;
          }
          unsigned int v782 = 0;
          uint64_t v783 = (char *)v1026;
          uint64_t v784 = (char *)v1026 + 8 * v1027;
          do
          {
            uint64_t v785 = *(void *)v783;
            if (*(unsigned char *)(**(void **)v783 + 8) != 7)
            {
              uint64_t v786 = *(void *)(v785 + 8);
              if (v786)
              {
                if (v1005) {
                  unsigned int v787 = &v1006;
                }
                else {
                  unsigned int v787 = v1006;
                }
                if (v1005) {
                  int v788 = 31;
                }
                else {
                  int v788 = v1007 - 1;
                }
                do
                {
                  if (v1005 & 1 | (v1007 != 0))
                  {
                    uint64_t v789 = *(void *)(v786 + 24);
                    unsigned int v790 = ((v789 >> 4) ^ (v789 >> 9)) & v788;
                    uint64_t v791 = v787[v790];
                    if (v789 == v791) {
                      goto LABEL_1529;
                    }
                    int v792 = 1;
                    while (v791 != -4096)
                    {
                      unsigned int v793 = v790 + v792++;
                      unsigned int v790 = v793 & v788;
                      uint64_t v791 = v787[v790];
                      if (v789 == v791) {
                        goto LABEL_1529;
                      }
                    }
                  }
                  uint64_t v786 = *(void *)(v786 + 8);
                }
                while (v786);
              }
            }
            if (v782 >= HIDWORD(v1003)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v1002 + v782) = v785;
            unsigned int v782 = v1003 + 1;
            LODWORD(v1003) = v1003 + 1;
LABEL_1529:
            v783 += 8;
          }
          while (v783 != v784);
          uint64_t v794 = (uint64_t *)v1002;
          uint64_t v915 = 0;
          uint64_t v914 = 0;
          unsigned int v916 = 0;
          unint64_t v254 = v895;
          if (!v782) {
            goto LABEL_1536;
          }
          uint64_t v795 = 8 * v782;
          do
          {
            uint64_t v796 = *v794++;
            sub_1CCE37558(v796, v796, (uint64_t)&v1005, (uint64_t)&v914);
            v795 -= 8;
          }
          while (v795);
          if (!v1003) {
            goto LABEL_1536;
          }
          v797 = (char *)v1002;
          v878 = (char *)v1002 + 8 * v1003;
LABEL_1545:
          __p[0] = v797;
          uint64_t v798 = *(void *)v797;
          uint64_t v799 = *(unsigned __int8 **)(*(void *)v797 + 48);
          v913 = v799;
          if (!v799) {
            goto LABEL_1576;
          }
          llvm::MetadataTracking::track((uint64_t)&v913, v799, 2);
          uint64_t v800 = *(void *)(v798 + 48);
          if (!v800) {
            goto LABEL_1576;
          }
          while (1)
          {
            v801 = *(unsigned __int8 **)(v800 - 8 * *(unsigned int *)(v800 + 8));
            int v802 = *v801;
            if (v802 != 17 && (v802 & 0xFE) == 18)
            {
              do
                v801 = *(unsigned __int8 **)&v801[-8 * *((unsigned int *)v801 + 2) + 8];
              while ((*v801 & 0xFE) == 0x12);
            }
            if (v801 == *(unsigned __int8 **)v777)
            {
              *(void *)v1038 = v800;
              llvm::MetadataTracking::track((uint64_t)v1038, (unsigned __int8 *)v800, 2);
              if (!v913) {
                goto LABEL_1574;
              }
              int v833 = *v913;
              if ((v833 - 4) <= 0x1E)
              {
                if ((v913[1] & 0x7F) != 2 && !*((_DWORD *)v913 + 3)) {
                  goto LABEL_1574;
                }
                uint64_t v834 = *((void *)v913 + 2);
                if ((v834 & 4) == 0) {
                  goto LABEL_1574;
                }
                unint64_t v835 = v834 & 0xFFFFFFFFFFFFFFF8;
                if (!v835) {
                  goto LABEL_1574;
                }
                goto LABEL_1663;
              }
              if ((v833 - 3) >= 0xFFFFFFFE) {
                unint64_t v836 = v913;
              }
              else {
                unint64_t v836 = 0;
              }
              if ((v833 - 3) >= 0xFFFFFFFE)
              {
                unint64_t v835 = (unint64_t)(v836 + 8);
LABEL_1663:
                v990.i64[0] = (uint64_t)&v913;
                sub_1CC5FA668(v835 + 16, &v990);
                goto LABEL_1574;
              }
              if (v833 == 3) {
                *((void *)v913 + 1) = 0;
              }
LABEL_1574:
              v913 = *(unsigned __int8 **)v1038;
              if (*(void *)v1038) {
                llvm::MetadataTracking::retrack((uint64_t)v1038, *(unsigned __int8 **)v1038, (uint64_t)&v913);
              }
LABEL_1576:
              v1058 = v1062;
              v1059 = v1062;
              uint64_t v1060 = 8;
              int v1061 = 0;
              sub_1CCE3780C(&v990, v896, v798, (uint64_t)&v1058, (uint64_t)&v1005, (uint64_t)&v914);
              unsigned int v808 = v990.i32[0];
              unsigned int v809 = v990.u32[1];
              unsigned int v810 = v990.u32[2];
              uint64_t v811 = v798;
              unsigned int v812 = v990.u32[3];
              unsigned int __srcb = v991;
              unsigned int v813 = HIDWORD(v991);
              unsigned int v892 = v992;
              *(void *)&v1038[8] = 0;
              *(void *)v1038 = 0;
              if (v913)
              {
                uint64_t v838 = *(void *)&v913[-8 * *((unsigned int *)v913 + 2)];
                if (*(unsigned char *)v838 != 15) {
                  uint64_t v838 = *(void *)(v838 - 8 * *(unsigned int *)(v838 + 8));
                }
                *(void *)v1038 = v838;
                *(_DWORD *)&v1038[8] = *((_DWORD *)v913 + 1);
                *(_DWORD *)&v1038[12] = *((unsigned __int16 *)v913 + 1);
              }
              uint64_t v814 = v811;
              llvm::OptimizationRemark::OptimizationRemark((uint64_t)&v990, (uint64_t)"lower-matrix-intrinsics", (uint64_t)"matrix-lowered", 14, v1038, *(void *)(v811 + 40));
              *(void *)v1038 = "Lowered with ";
              *(void *)&v1038[8] = 13;
              sub_1CC59ADEC((uint64_t *)v894[0], (uint64_t)v1038);
              llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v951, "NumStores", 9uLL, v808);
              uint64_t v815 = sub_1CD3D6290((uint64_t)&v990, (long long *)&v951);
              *(void *)v1038 = " stores, ";
              *(void *)&v1038[8] = 9;
              sub_1CC59ADEC((uint64_t *)(v815 + 80), (uint64_t)v1038);
              llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v938, "NumLoads", 8uLL, v809);
              uint64_t v816 = sub_1CD3D6290(v815, (long long *)&v938);
              *(void *)v1038 = " loads, ";
              *(void *)&v1038[8] = 8;
              sub_1CC59ADEC((uint64_t *)(v816 + 80), (uint64_t)v1038);
              llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v932, "NumComputeOps", 0xDuLL, v810);
              uint64_t v817 = sub_1CD3D6290(v816, (long long *)&v932);
              *(void *)v1038 = " compute ops, ";
              *(void *)&v1038[8] = 14;
              sub_1CC59ADEC((uint64_t *)(v817 + 80), (uint64_t)v1038);
              llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v970, "NumExposedTransposes", 0x14uLL, v812);
              uint64_t v818 = sub_1CD3D6290(v817, (long long *)&v970);
              *(void *)v1038 = " exposed transposes";
              *(void *)&v1038[8] = 19;
              sub_1CC59ADEC((uint64_t *)(v818 + 80), (uint64_t)v1038);
              if (v972 < 0) {
                operator delete(v971);
              }
              if (SHIBYTE(v970.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v970.__r_.__value_.__l.__data_);
              }
              if (v935 < 0) {
                operator delete(v933);
              }
              if (SHIBYTE(v932.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v932.__r_.__value_.__l.__data_);
              }
              if (SHIBYTE(v940) < 0) {
                operator delete(v939);
              }
              if (SHIBYTE(v938.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v938.__r_.__value_.__l.__data_);
              }
              if (v954 < 0) {
                operator delete(v952);
              }
              if (SHIBYTE(v951.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v951.__r_.__value_.__l.__data_);
              }
              if (__srcb || v813 || v892)
              {
                *(void *)v1038 = ",\nadditionally ";
                *(void *)&v1038[8] = 15;
                sub_1CC59ADEC((uint64_t *)v894[0], (uint64_t)v1038);
                llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v986, "NumStores", 9uLL, __srcb);
                uint64_t v819 = sub_1CD3D6290((uint64_t)&v990, (long long *)&v986);
                *(void *)v1038 = " stores, ";
                *(void *)&v1038[8] = 9;
                sub_1CC59ADEC((uint64_t *)(v819 + 80), (uint64_t)v1038);
                llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v909, "NumLoads", 8uLL, v813);
                uint64_t v820 = sub_1CD3D6290(v819, (long long *)&v909);
                *(void *)v1038 = " loads, ";
                *(void *)&v1038[8] = 8;
                sub_1CC59ADEC((uint64_t *)(v820 + 80), (uint64_t)v1038);
                llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v906, "NumFPOps", 8uLL, v892);
                uint64_t v821 = sub_1CD3D6290(v820, (long long *)&v906);
                *(void *)v1038 = " compute ops";
                *(void *)&v1038[8] = 12;
                int v822 = (uint64_t *)(v821 + 80);
                sub_1CC59ADEC((uint64_t *)(v821 + 80), (uint64_t)v1038);
                *(void *)v1038 = " are shared with other expressions";
                *(void *)&v1038[8] = 34;
                sub_1CC59ADEC(v822, (uint64_t)v1038);
                if (v908 < 0) {
                  operator delete(v907);
                }
                if (SHIBYTE(v906.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v906.__r_.__value_.__l.__data_);
                }
                if (SHIBYTE(v912) < 0) {
                  operator delete(v910);
                }
                if (SHIBYTE(v909.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v909.__r_.__value_.__l.__data_);
                }
                if (v989 < 0) {
                  operator delete(v987);
                }
                if (SHIBYTE(v986.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v986.__r_.__value_.__l.__data_);
                }
              }
              memset(&v1038[8], 0, 24);
              *(_DWORD *)v1038 = 100;
              int v1040 = 0;
              char v1044 = 0;
              uint64_t v1045 = 0;
              v1039 = &unk_1F2646F30;
              v1047 = &v1038[8];
              int v1046 = 0;
              int v1048 = 0;
              uint64_t v1042 = 0;
              v1043 = 0;
              v1041 = 0;
              v1049 = v883;
              unint64_t v1050 = v886;
              v1051 = &v914;
              v1052 = &v1005;
              *(void *)&long long v1053 = v814;
              *((void *)&v1053 + 1) = v1057;
              v1054 = v1057;
              uint64_t v1055 = 8;
              int v1056 = 0;
              sub_1CCE37E90((uint64_t)v1038, v814, 0, 0, 0);
              if (v1043 != v1041)
              {
                v1043 = v1041;
                llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)&v1039, v1041);
              }
              unint64_t v254 = v895;
              if ((v1038[31] & 0x80000000) != 0) {
                sub_1CB8BDF7C((uint64_t)&v905, *(const void **)&v1038[8], *(unint64_t *)&v1038[16]);
              }
              else {
                std::string v905 = *(std::string *)&v1038[8];
              }
              if (v1054 != *((void **)&v1053 + 1)) {
                free(v1054);
              }
              v1039 = &unk_1F2646B98;
              if (v1046 == 1 && v1041) {
                MEMORY[0x1D25D9CB0](v1041, 0x1000C8077774924);
              }
              if ((v1038[31] & 0x80000000) != 0) {
                operator delete(*(void **)&v1038[8]);
              }
              long long v823 = std::string::insert(&v905, 0, "\n");
              std::string::size_type v824 = v823->__r_.__value_.__r.__words[2];
              *(_OWORD *)v1038 = *(_OWORD *)&v823->__r_.__value_.__l.__data_;
              *(void *)&v1038[16] = v824;
              v823->__r_.__value_.__l.__size_ = 0;
              v823->__r_.__value_.__r.__words[2] = 0;
              v823->__r_.__value_.__r.__words[0] = 0;
              v825 = *(unsigned char **)v1038;
              if (v1038[23] >= 0) {
                v825 = v1038;
              }
              uint64_t v826 = v1038[23] & 0x7F;
              if (v1038[23] < 0) {
                uint64_t v826 = *(void *)&v1038[8];
              }
              v922[0] = v825;
              v922[1] = v826;
              sub_1CC59ADEC((uint64_t *)v894[0], (uint64_t)v922);
              if ((v1038[23] & 0x80000000) != 0) {
                operator delete(*(void **)v1038);
              }
              if (SHIBYTE(v905.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v905.__r_.__value_.__l.__data_);
              }
              llvm::OptimizationRemarkEmitter::emit(v875, (llvm::DiagnosticInfoOptimizationBase *)&v990);
              v990.i64[0] = (uint64_t)&unk_1F2616800;
              v827 = (char *)v997;
              if (v998)
              {
                unint64_t v828 = (unint64_t)v998 << 6;
                do
                {
                  v829 = (void **)&v827[v828];
                  if (v827[v828 - 17] < 0) {
                    operator delete(*(v829 - 5));
                  }
                  if (*((char *)v829 - 41) < 0) {
                    operator delete(*(v829 - 8));
                  }
                  v828 -= 64;
                }
                while (v828);
                v827 = (char *)v997;
                unint64_t v254 = v895;
              }
              if (v827 != (char *)&v999) {
                free(v827);
              }
              if (v1059 != v1058) {
                free(v1059);
              }
              if (v913)
              {
                int v830 = *v913;
                if ((v830 - 4) > 0x1E)
                {
                  if ((v830 - 3) >= 0xFFFFFFFE) {
                    v831 = v913;
                  }
                  else {
                    v831 = 0;
                  }
                  if ((v830 - 3) >= 0xFFFFFFFE)
                  {
                    unint64_t v832 = (unint64_t)(v831 + 8);
                    goto LABEL_1649;
                  }
                  if (v830 == 3) {
                    *((void *)v913 + 1) = 0;
                  }
                }
                else if ((v913[1] & 0x7F) == 2 || *((_DWORD *)v913 + 3))
                {
                  uint64_t v837 = *((void *)v913 + 2);
                  if ((v837 & 4) != 0)
                  {
                    unint64_t v832 = v837 & 0xFFFFFFFFFFFFFFF8;
                    if (v832)
                    {
LABEL_1649:
                      v990.i64[0] = (uint64_t)&v913;
                      sub_1CC5FA668(v832 + 16, &v990);
                    }
                  }
                }
              }
              v797 = (char *)__p[0] + 8;
              if ((char *)__p[0] + 8 == v878)
              {
LABEL_1536:
                sub_1CD6C0F9C(v914, v916);
                MEMORY[0x1D25D9CD0](v914, 8);
                if (v1002 != v1004) {
                  free(v1002);
                }
                if (v1026 != &v1028) {
                  free(v1026);
                }
                if ((v1005 & 1) == 0) {
                  MEMORY[0x1D25D9CD0](v1006, 8);
                }
                v777 += 88;
                int64x2_t v778 = v862;
                if (v777 == v865)
                {
LABEL_1505:
                  sub_1CD719F1C((uint64_t)v917);
                  LOBYTE(v126) = v851;
                  goto LABEL_1374;
                }
                goto LABEL_1507;
              }
              goto LABEL_1545;
            }
            *(void *)v1038 = v800;
            llvm::MetadataTracking::track((uint64_t)v1038, (unsigned __int8 *)v800, 2);
            if (*(_DWORD *)(*(void *)v1038 + 8) == 2) {
              uint64_t v800 = *(void *)(*(void *)v1038 - 8);
            }
            else {
              uint64_t v800 = 0;
            }
            int v804 = **(unsigned char **)v1038;
            if ((v804 - 4) > 0x1E)
            {
              if ((v804 - 3) >= 0xFFFFFFFE) {
                uint64_t v805 = *(void *)v1038;
              }
              else {
                uint64_t v805 = 0;
              }
              if ((v804 - 3) < 0xFFFFFFFE)
              {
                if (v804 == 3) {
                  *(void *)(*(void *)v1038 + 8) = 0;
                }
                goto LABEL_1558;
              }
              unint64_t v806 = v805 + 8;
            }
            else
            {
              if ((*(unsigned char *)(*(void *)v1038 + 1) & 0x7F) != 2 && !*(_DWORD *)(*(void *)v1038 + 12)) {
                goto LABEL_1558;
              }
              uint64_t v807 = *(void *)(*(void *)v1038 + 16);
              if ((v807 & 4) == 0) {
                goto LABEL_1558;
              }
              unint64_t v806 = v807 & 0xFFFFFFFFFFFFFFF8;
              if (!v806) {
                goto LABEL_1558;
              }
            }
            v990.i64[0] = (uint64_t)v1038;
            sub_1CC5FA668(v806 + 16, &v990);
LABEL_1558:
            if (!v800) {
              goto LABEL_1576;
            }
          }
        }
      }
      v775 = 0;
LABEL_1501:
      v754 = sub_1CC609054(v749 + 2480, (uint64_t)&v1005, (uint64_t *)&v1005, v775);
      uint64_t v776 = v1005;
      v754[4] = 0;
      v754[3] = 0;
      void *v754 = v776;
      v754[1] = v754 + 3;
      v754[2] = 0x100000000;
      goto LABEL_1453;
    }
  }
LABEL_1374:
  v1005 = &v1009;
  v1006 = &v1009;
  v1007 = (llvm::Type *)16;
  LODWORD(v1008) = 0;
  uint64_t v719 = *(unsigned int *)(v254 + 128);
  if (v719)
  {
    uint64_t v720 = *(void *)(*(void *)(v254 + 120) + 8 * v719 - 8);
    uint64_t v721 = *(void *)(v720 + 8);
    if (!v721) {
LABEL_1428:
    }
      llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
    while (2)
    {
      unsigned int v723 = (void *)(v721 + 8);
      uint64_t v722 = *(void *)(v721 + 8);
      uint64_t v724 = *(void *)(v721 + 24);
      if (v724) {
        BOOL v725 = *(unsigned __int8 *)(v724 + 16) >= 0x1Cu;
      }
      else {
        BOOL v725 = 0;
      }
      if (!v725)
      {
LABEL_1413:
        v740 = llvm::UndefValue::get(*(llvm::UndefValue **)v720, v241);
        if (*(void *)v721)
        {
          **(void **)(v721 + 16) = *(void *)(v721 + 8);
          uint64_t v741 = *(void *)(v721 + 8);
          if (v741) {
            *(void *)(v741 + 16) = *(void *)(v721 + 16);
          }
        }
        *(void *)uint64_t v721 = v740;
        if (v740)
        {
          uint64_t v744 = *((void *)v740 + 1);
          v742 = (void *)((char *)v740 + 8);
          uint64_t v743 = v744;
          *unsigned int v723 = v744;
          if (v744) {
            *(void *)(v743 + 16) = v723;
          }
          *(void *)(v721 + 16) = v742;
          void *v742 = v721;
        }
        uint64_t v721 = v722;
        if (!v722) {
          goto LABEL_1428;
        }
        continue;
      }
      break;
    }
    int v726 = (char *)v1006;
    uint64_t v727 = HIDWORD(v1007);
    if (v1006 == v1005)
    {
      if (HIDWORD(v1007))
      {
        __int16 v728 = 0;
        uint64_t v729 = 8 * HIDWORD(v1007);
        v730 = v1006;
        do
        {
          if (*v730 == v724) {
            goto LABEL_1413;
          }
          if (*v730 == -2) {
            __int16 v728 = v730;
          }
          ++v730;
          v729 -= 8;
        }
        while (v729);
        if (v728)
        {
          *__int16 v728 = v724;
          LODWORD(v1008) = v1008 - 1;
          goto LABEL_1413;
        }
      }
      long long v241 = (llvm::Type *)v1007;
      if (HIDWORD(v1007) < v1007)
      {
        ++HIDWORD(v1007);
        *((void *)v1006 + v727) = v724;
        goto LABEL_1413;
      }
    }
    else
    {
      long long v241 = (llvm::Type *)v1007;
    }
    if (3 * (int)v241 <= (4 * (HIDWORD(v1007) - v1008)))
    {
      if (v241 >= 0x40) {
        LODWORD(v241) = 2 * v241;
      }
      else {
        LODWORD(v241) = 128;
      }
    }
    else if ((int)v241 - HIDWORD(v1007) >= v241 >> 3)
    {
      goto LABEL_1394;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v1005, v241);
    long long v241 = (llvm::Type *)v1007;
    int v726 = (char *)v1006;
LABEL_1394:
    int v731 = v241 - 1;
    unsigned int v732 = (v241 - 1) & ((v724 >> 4) ^ (v724 >> 9));
    v733 = &v726[8 * v732];
    uint64_t v734 = *(void *)v733;
    if (*(void *)v733 == -1)
    {
      int v735 = 0;
LABEL_1406:
      if (v735) {
        uint64_t v739 = v735;
      }
      else {
        uint64_t v739 = v733;
      }
      if (*(void *)v739 != v724)
      {
        if (*(void *)v739 == -2) {
          LODWORD(v1008) = v1008 - 1;
        }
        else {
          ++HIDWORD(v1007);
        }
        *(void *)uint64_t v739 = v724;
      }
    }
    else
    {
      int v735 = 0;
      int v736 = 1;
      while (v734 != v724)
      {
        if (v735) {
          BOOL v737 = 0;
        }
        else {
          BOOL v737 = v734 == -2;
        }
        if (v737) {
          int v735 = v733;
        }
        unsigned int v738 = v732 + v736++;
        unsigned int v732 = v738 & v731;
        v733 = &v726[8 * (v738 & v731)];
        uint64_t v734 = *(void *)v733;
        if (*(void *)v733 == -1) {
          goto LABEL_1406;
        }
      }
    }
    goto LABEL_1413;
  }
  if (v898 != v897) {
    free(v898);
  }
  if (v902)
  {
    v903 = (char *)v902;
    operator delete(v902);
  }
  if (v923 != v925) {
    free(v923);
  }
  if (v926 != v928) {
    free(v926);
  }
LABEL_1437:
  if (__dst != v931) {
    free(__dst);
  }
  return v126 & 1;
}