unint64_t sub_1CBF1DCB8(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int v33;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  int v77;
  int v78;

  v2 = *(void *)(a1 + 1248);
  v3 = v2;
  if (v2)
  {
    *(unsigned char *)a2 = *(unsigned char *)a1 & 1;
    v3 = *(void *)(a1 + 1248);
    if ((v3 & 2) == 0)
    {
LABEL_3:
      if ((v3 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_111;
    }
  }
  else if ((v2 & 2) == 0)
  {
    goto LABEL_3;
  }
  *(_WORD *)a2 = *(void *)(a1 + 8);
  if ((v3 & 4) == 0)
  {
LABEL_4:
    if ((v3 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_112;
  }
LABEL_111:
  *(_WORD *)a2 = *(_WORD *)(a1 + 16) & 0x1FF;
  if ((v3 & 8) == 0)
  {
LABEL_5:
    if ((v3 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_113;
  }
LABEL_112:
  *(_WORD *)a2 = *(_WORD *)(a1 + 24) & 0x1FF;
  if ((v3 & 0x10) == 0)
  {
LABEL_6:
    if ((v3 & 0x20) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
LABEL_113:
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 32) & 0x1FFFF;
  if ((v3 & 0x20) != 0) {
LABEL_7:
  }
    *(_WORD *)a2 = *(_WORD *)(a1 + 40) & 0x1FFF;
LABEL_8:
  v4 = v3;
  if ((v3 & 0x40) != 0)
  {
    *(unsigned char *)a2 = *(unsigned char *)(a1 + 48) & 0x7F;
    v4 = *(void *)(a1 + 1248);
  }
  if ((v4 & 0x80) != 0) {
    *(_DWORD *)a2 = *(void *)(a1 + 56);
  }
  v5 = v4;
  if ((v4 & 0x100) != 0)
  {
    *(unsigned char *)(a2 + 4) = *(unsigned char *)(a1 + 64) & 0xF;
    v5 = *(void *)(a1 + 1248);
    if ((v5 & 0x200) == 0)
    {
LABEL_14:
      if ((v5 & 0x400) == 0) {
        goto LABEL_15;
      }
      goto LABEL_117;
    }
  }
  else if ((v4 & 0x200) == 0)
  {
    goto LABEL_14;
  }
  *(_DWORD *)(a2 + 8) = *(void *)(a1 + 72);
  if ((v5 & 0x400) == 0)
  {
LABEL_15:
    if ((v5 & 0x800) == 0) {
      goto LABEL_16;
    }
    goto LABEL_118;
  }
LABEL_117:
  *(_DWORD *)(a2 + 12) = *(void *)(a1 + 80);
  if ((v5 & 0x800) == 0)
  {
LABEL_16:
    if ((v5 & 0x1000) == 0) {
      goto LABEL_17;
    }
    goto LABEL_119;
  }
LABEL_118:
  *(unsigned char *)(a2 + 16) = *(void *)(a1 + 88) != 0;
  if ((v5 & 0x1000) == 0)
  {
LABEL_17:
    if ((v5 & 0x2000) == 0) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
LABEL_119:
  *(_DWORD *)(a2 + 20) = *(void *)(a1 + 96);
  if ((v5 & 0x2000) != 0) {
LABEL_18:
  }
    *(_DWORD *)(a2 + 24) = *(void *)(a1 + 104);
LABEL_19:
  v6 = v5;
  if ((v5 & 0x4000) != 0)
  {
    *(unsigned char *)(a2 + 28) = *(unsigned char *)(a1 + 112) & 1;
    v6 = *(void *)(a1 + 1248);
    if ((v6 & 0x8000) == 0)
    {
LABEL_21:
      if ((v6 & 0x10000) == 0) {
        goto LABEL_22;
      }
      goto LABEL_123;
    }
  }
  else if ((v5 & 0x8000) == 0)
  {
    goto LABEL_21;
  }
  *(_WORD *)(a2 + 28) = *(void *)(a1 + 120);
  if ((v6 & 0x10000) == 0)
  {
LABEL_22:
    if ((v6 & 0x20000) == 0) {
      goto LABEL_23;
    }
    goto LABEL_124;
  }
LABEL_123:
  *(_WORD *)(a2 + 28) = *(_WORD *)(a1 + 128) & 0x1FF;
  if ((v6 & 0x20000) == 0)
  {
LABEL_23:
    if ((v6 & 0x40000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_125;
  }
LABEL_124:
  *(_WORD *)(a2 + 28) = *(_WORD *)(a1 + 136) & 0x1FF;
  if ((v6 & 0x40000) == 0)
  {
LABEL_24:
    if ((v6 & 0x80000) == 0) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }
LABEL_125:
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 144) & 0x1FFFF;
  if ((v6 & 0x80000) != 0) {
LABEL_25:
  }
    *(_WORD *)(a2 + 28) = *(_WORD *)(a1 + 152) & 0x1FFF;
LABEL_26:
  v7 = v6;
  if ((v6 & 0x100000) != 0)
  {
    *(unsigned char *)(a2 + 28) = *(unsigned char *)(a1 + 160) & 0x7F;
    v7 = *(void *)(a1 + 1248);
  }
  if ((v7 & 0x200000) != 0) {
    *(_DWORD *)(a2 + 28) = *(void *)(a1 + 168);
  }
  v8 = v7;
  if ((v7 & 0x400000) != 0)
  {
    *(unsigned char *)(a2 + 32) = *(unsigned char *)(a1 + 176) & 0xF;
    v8 = *(void *)(a1 + 1248);
    if ((v8 & 0x800000) == 0)
    {
LABEL_32:
      if ((v8 & 0x1000000) == 0) {
        goto LABEL_33;
      }
      goto LABEL_129;
    }
  }
  else if ((v7 & 0x800000) == 0)
  {
    goto LABEL_32;
  }
  *(_DWORD *)(a2 + 36) = *(void *)(a1 + 184);
  if ((v8 & 0x1000000) == 0)
  {
LABEL_33:
    if ((v8 & 0x2000000) == 0) {
      goto LABEL_34;
    }
    goto LABEL_130;
  }
LABEL_129:
  *(_DWORD *)(a2 + 40) = *(void *)(a1 + 192);
  if ((v8 & 0x2000000) == 0)
  {
LABEL_34:
    if ((v8 & 0x4000000) == 0) {
      goto LABEL_35;
    }
    goto LABEL_131;
  }
LABEL_130:
  *(unsigned char *)(a2 + 44) = *(void *)(a1 + 200) != 0;
  if ((v8 & 0x4000000) == 0)
  {
LABEL_35:
    if ((v8 & 0x8000000) == 0) {
      goto LABEL_36;
    }
    goto LABEL_132;
  }
LABEL_131:
  *(_DWORD *)(a2 + 48) = *(void *)(a1 + 208);
  if ((v8 & 0x8000000) == 0)
  {
LABEL_36:
    if ((v8 & 0x10000000) == 0) {
      goto LABEL_38;
    }
    goto LABEL_37;
  }
LABEL_132:
  *(unsigned char *)(a2 + 52) = *(void *)(a1 + 216) != 0;
  if ((v8 & 0x10000000) != 0) {
LABEL_37:
  }
    *(unsigned char *)(a2 + 53) = *(void *)(a1 + 224) != 0;
LABEL_38:
  v9 = v8;
  if ((v8 & 0x20000000) != 0)
  {
    *(unsigned char *)(a2 + 56) = *(unsigned char *)(a1 + 232) & 1;
    v9 = *(void *)(a1 + 1248);
    if ((v9 & 0x40000000) == 0)
    {
LABEL_40:
      if ((v9 & 0x80000000) == 0) {
        goto LABEL_41;
      }
      goto LABEL_136;
    }
  }
  else if ((v8 & 0x40000000) == 0)
  {
    goto LABEL_40;
  }
  *(_WORD *)(a2 + 56) = *(void *)(a1 + 240);
  if ((v9 & 0x80000000) == 0)
  {
LABEL_41:
    if ((v9 & 0x100000000) == 0) {
      goto LABEL_42;
    }
    goto LABEL_137;
  }
LABEL_136:
  *(_WORD *)(a2 + 56) = *(_WORD *)(a1 + 248) & 0x1FF;
  if ((v9 & 0x100000000) == 0)
  {
LABEL_42:
    if ((v9 & 0x200000000) == 0) {
      goto LABEL_43;
    }
    goto LABEL_138;
  }
LABEL_137:
  *(_WORD *)(a2 + 56) = *(_WORD *)(a1 + 256) & 0x1FF;
  if ((v9 & 0x200000000) == 0)
  {
LABEL_43:
    if ((v9 & 0x400000000) == 0) {
      goto LABEL_45;
    }
    goto LABEL_44;
  }
LABEL_138:
  *(_DWORD *)(a2 + 56) = *(_DWORD *)(a1 + 264) & 0x1FFFF;
  if ((v9 & 0x400000000) != 0) {
LABEL_44:
  }
    *(_WORD *)(a2 + 56) = *(_WORD *)(a1 + 272) & 0x1FFF;
LABEL_45:
  v10 = v9;
  if ((v9 & 0x800000000) != 0)
  {
    *(unsigned char *)(a2 + 56) = *(unsigned char *)(a1 + 280) & 0x7F;
    v10 = *(void *)(a1 + 1248);
  }
  if ((v10 & 0x1000000000) != 0) {
    *(_DWORD *)(a2 + 56) = *(void *)(a1 + 288);
  }
  v11 = v10;
  if ((v10 & 0x2000000000) != 0)
  {
    *(unsigned char *)(a2 + 60) = *(unsigned char *)(a1 + 296) & 0xF;
    v11 = *(void *)(a1 + 1248);
    if ((v11 & 0x4000000000) == 0)
    {
LABEL_51:
      if ((v11 & 0x8000000000) == 0) {
        goto LABEL_52;
      }
      goto LABEL_142;
    }
  }
  else if ((v10 & 0x4000000000) == 0)
  {
    goto LABEL_51;
  }
  *(_DWORD *)(a2 + 64) = *(void *)(a1 + 304);
  if ((v11 & 0x8000000000) == 0)
  {
LABEL_52:
    if ((v11 & 0x10000000000) == 0) {
      goto LABEL_53;
    }
    goto LABEL_143;
  }
LABEL_142:
  *(_DWORD *)(a2 + 68) = *(void *)(a1 + 312);
  if ((v11 & 0x10000000000) == 0)
  {
LABEL_53:
    if ((v11 & 0x20000000000) == 0) {
      goto LABEL_54;
    }
    goto LABEL_144;
  }
LABEL_143:
  *(unsigned char *)(a2 + 72) = *(void *)(a1 + 320) != 0;
  if ((v11 & 0x20000000000) == 0)
  {
LABEL_54:
    if ((v11 & 0x40000000000) == 0) {
      goto LABEL_55;
    }
    goto LABEL_145;
  }
LABEL_144:
  *(_DWORD *)(a2 + 76) = *(void *)(a1 + 328);
  if ((v11 & 0x40000000000) == 0)
  {
LABEL_55:
    if ((v11 & 0x80000000000) == 0) {
      goto LABEL_57;
    }
    goto LABEL_56;
  }
LABEL_145:
  *(unsigned char *)(a2 + 80) = *(void *)(a1 + 336) != 0;
  if ((v11 & 0x80000000000) != 0) {
LABEL_56:
  }
    *(unsigned char *)(a2 + 81) = *(void *)(a1 + 344) != 0;
LABEL_57:
  v12 = v11;
  if ((v11 & 0x100000000000) != 0)
  {
    *(unsigned char *)(a2 + 84) = *(unsigned char *)(a1 + 352) & 1;
    v12 = *(void *)(a1 + 1248);
    if ((v12 & 0x200000000000) == 0)
    {
LABEL_59:
      if ((v12 & 0x400000000000) == 0) {
        goto LABEL_60;
      }
      goto LABEL_149;
    }
  }
  else if ((v11 & 0x200000000000) == 0)
  {
    goto LABEL_59;
  }
  *(_WORD *)(a2 + 84) = *(void *)(a1 + 360);
  if ((v12 & 0x400000000000) == 0)
  {
LABEL_60:
    if ((v12 & 0x800000000000) == 0) {
      goto LABEL_61;
    }
    goto LABEL_150;
  }
LABEL_149:
  *(_WORD *)(a2 + 84) = *(_WORD *)(a1 + 368) & 0x1FF;
  if ((v12 & 0x800000000000) == 0)
  {
LABEL_61:
    if ((v12 & 0x1000000000000) == 0) {
      goto LABEL_62;
    }
    goto LABEL_151;
  }
LABEL_150:
  *(_WORD *)(a2 + 84) = *(_WORD *)(a1 + 376) & 0x1FF;
  if ((v12 & 0x1000000000000) == 0)
  {
LABEL_62:
    if ((v12 & 0x2000000000000) == 0) {
      goto LABEL_64;
    }
    goto LABEL_63;
  }
LABEL_151:
  *(_DWORD *)(a2 + 84) = *(_DWORD *)(a1 + 384) & 0x1FFFF;
  if ((v12 & 0x2000000000000) != 0) {
LABEL_63:
  }
    *(_WORD *)(a2 + 84) = *(_WORD *)(a1 + 392) & 0x1FFF;
LABEL_64:
  v13 = v12;
  if ((v12 & 0x4000000000000) != 0)
  {
    *(unsigned char *)(a2 + 84) = *(unsigned char *)(a1 + 400) & 0x7F;
    v13 = *(void *)(a1 + 1248);
  }
  v78 = v7;
  if ((v13 & 0x8000000000000) != 0) {
    *(_DWORD *)(a2 + 84) = *(void *)(a1 + 408);
  }
  v14 = v13;
  if ((v13 & 0x10000000000000) != 0)
  {
    *(unsigned char *)(a2 + 88) = *(unsigned char *)(a1 + 416) & 0xF;
    v14 = *(void *)(a1 + 1248);
    if ((v14 & 0x20000000000000) == 0)
    {
LABEL_70:
      if ((v14 & 0x40000000000000) == 0) {
        goto LABEL_71;
      }
      goto LABEL_155;
    }
  }
  else if ((v13 & 0x20000000000000) == 0)
  {
    goto LABEL_70;
  }
  *(_DWORD *)(a2 + 92) = *(void *)(a1 + 424);
  if ((v14 & 0x40000000000000) == 0)
  {
LABEL_71:
    if ((v14 & 0x80000000000000) == 0) {
      goto LABEL_72;
    }
    goto LABEL_156;
  }
LABEL_155:
  *(_DWORD *)(a2 + 96) = *(void *)(a1 + 432);
  if ((v14 & 0x80000000000000) == 0)
  {
LABEL_72:
    if ((v14 & 0x100000000000000) == 0) {
      goto LABEL_73;
    }
    goto LABEL_157;
  }
LABEL_156:
  *(unsigned char *)(a2 + 100) = *(void *)(a1 + 440) != 0;
  if ((v14 & 0x100000000000000) == 0)
  {
LABEL_73:
    if ((v14 & 0x200000000000000) == 0) {
      goto LABEL_74;
    }
    goto LABEL_158;
  }
LABEL_157:
  *(_DWORD *)(a2 + 104) = *(void *)(a1 + 448);
  if ((v14 & 0x200000000000000) == 0)
  {
LABEL_74:
    if ((v14 & 0x400000000000000) == 0) {
      goto LABEL_75;
    }
    goto LABEL_159;
  }
LABEL_158:
  *(unsigned char *)(a2 + 108) = *(void *)(a1 + 456) != 0;
  if ((v14 & 0x400000000000000) == 0)
  {
LABEL_75:
    if ((v14 & 0x800000000000000) == 0) {
      goto LABEL_76;
    }
    goto LABEL_160;
  }
LABEL_159:
  *(unsigned char *)(a2 + 109) = *(void *)(a1 + 464) != 0;
  if ((v14 & 0x800000000000000) == 0)
  {
LABEL_76:
    if ((v14 & 0x1000000000000000) == 0) {
      goto LABEL_77;
    }
    goto LABEL_161;
  }
LABEL_160:
  *(_DWORD *)(a2 + 112) = *(void *)(a1 + 472);
  if ((v14 & 0x1000000000000000) == 0)
  {
LABEL_77:
    if ((v14 & 0x2000000000000000) == 0) {
      goto LABEL_78;
    }
    goto LABEL_162;
  }
LABEL_161:
  *(_DWORD *)(a2 + 116) = *(void *)(a1 + 480);
  if ((v14 & 0x2000000000000000) == 0)
  {
LABEL_78:
    if ((v14 & 0x4000000000000000) == 0) {
      goto LABEL_79;
    }
LABEL_163:
    *(unsigned char *)(a2 + 121) = *(void *)(a1 + 496) != 0;
    if ((v14 & 0x8000000000000000) == 0) {
      goto LABEL_80;
    }
    goto LABEL_164;
  }
LABEL_162:
  *(unsigned char *)(a2 + 120) = *(void *)(a1 + 488) != 0;
  if ((v14 & 0x4000000000000000) != 0) {
    goto LABEL_163;
  }
LABEL_79:
  if ((v14 & 0x8000000000000000) == 0) {
    goto LABEL_80;
  }
LABEL_164:
  *(unsigned char *)(a2 + 122) = *(void *)(a1 + 504) != 0;
LABEL_80:
  v15 = *(void *)(a1 + 1256);
  if (v15)
  {
    *(unsigned char *)(a2 + 123) = *(void *)(a1 + 512) != 0;
    if ((v15 & 2) == 0)
    {
LABEL_82:
      if ((v15 & 4) == 0) {
        goto LABEL_83;
      }
      goto LABEL_167;
    }
  }
  else if ((v15 & 2) == 0)
  {
    goto LABEL_82;
  }
  *(unsigned char *)(a2 + 124) = *(void *)(a1 + 520) != 0;
  if ((v15 & 4) == 0)
  {
LABEL_83:
    if ((v15 & 8) == 0) {
      goto LABEL_84;
    }
    goto LABEL_168;
  }
LABEL_167:
  *(unsigned char *)(a2 + 125) = *(void *)(a1 + 528) != 0;
  if ((v15 & 8) == 0)
  {
LABEL_84:
    if ((v15 & 0x10) == 0) {
      goto LABEL_85;
    }
    goto LABEL_169;
  }
LABEL_168:
  *(unsigned char *)(a2 + 126) = *(void *)(a1 + 536) != 0;
  if ((v15 & 0x10) == 0)
  {
LABEL_85:
    if ((v15 & 0x20) == 0) {
      goto LABEL_86;
    }
    goto LABEL_170;
  }
LABEL_169:
  *(unsigned char *)(a2 + 127) = *(void *)(a1 + 544) != 0;
  if ((v15 & 0x20) == 0)
  {
LABEL_86:
    if ((v15 & 0x40) == 0) {
      goto LABEL_87;
    }
    goto LABEL_171;
  }
LABEL_170:
  *(_DWORD *)(a2 + 128) = *(void *)(a1 + 552);
  if ((v15 & 0x40) == 0)
  {
LABEL_87:
    if ((v15 & 0x80) == 0) {
      goto LABEL_88;
    }
    goto LABEL_172;
  }
LABEL_171:
  *(_DWORD *)(a2 + 132) = *(void *)(a1 + 560);
  if ((v15 & 0x80) == 0)
  {
LABEL_88:
    if ((v15 & 0x100) == 0) {
      goto LABEL_89;
    }
    goto LABEL_173;
  }
LABEL_172:
  *(_DWORD *)(a2 + 136) = *(void *)(a1 + 568);
  if ((v15 & 0x100) == 0)
  {
LABEL_89:
    if ((v15 & 0x200) == 0) {
      goto LABEL_90;
    }
    goto LABEL_174;
  }
LABEL_173:
  *(_DWORD *)(a2 + 140) = *(void *)(a1 + 576);
  if ((v15 & 0x200) == 0)
  {
LABEL_90:
    if ((v15 & 0x400) == 0) {
      goto LABEL_91;
    }
    goto LABEL_175;
  }
LABEL_174:
  *(_DWORD *)(a2 + 144) = *(void *)(a1 + 584);
  if ((v15 & 0x400) == 0)
  {
LABEL_91:
    if ((v15 & 0x800) == 0) {
      goto LABEL_92;
    }
    goto LABEL_176;
  }
LABEL_175:
  *(_DWORD *)(a2 + 148) = *(void *)(a1 + 592);
  if ((v15 & 0x800) == 0)
  {
LABEL_92:
    if ((v15 & 0x1000) == 0) {
      goto LABEL_93;
    }
    goto LABEL_177;
  }
LABEL_176:
  *(_DWORD *)(a2 + 152) = *(void *)(a1 + 600);
  if ((v15 & 0x1000) == 0)
  {
LABEL_93:
    if ((v15 & 0x2000) == 0) {
      goto LABEL_94;
    }
    goto LABEL_178;
  }
LABEL_177:
  *(_DWORD *)(a2 + 156) = *(void *)(a1 + 608);
  if ((v15 & 0x2000) == 0)
  {
LABEL_94:
    if ((v15 & 0x4000) == 0) {
      goto LABEL_95;
    }
    goto LABEL_179;
  }
LABEL_178:
  *(unsigned char *)(a2 + 160) = *(void *)(a1 + 616) != 0;
  if ((v15 & 0x4000) == 0)
  {
LABEL_95:
    if ((v15 & 0x8000) == 0) {
      goto LABEL_96;
    }
    goto LABEL_180;
  }
LABEL_179:
  *(_DWORD *)(a2 + 164) = *(void *)(a1 + 624);
  if ((v15 & 0x8000) == 0)
  {
LABEL_96:
    if ((v15 & 0x10000) == 0) {
      goto LABEL_97;
    }
    goto LABEL_181;
  }
LABEL_180:
  *(_DWORD *)(a2 + 168) = *(void *)(a1 + 632);
  if ((v15 & 0x10000) == 0)
  {
LABEL_97:
    if ((v15 & 0x20000) == 0) {
      goto LABEL_98;
    }
    goto LABEL_182;
  }
LABEL_181:
  *(_DWORD *)(a2 + 172) = *(void *)(a1 + 640);
  if ((v15 & 0x20000) == 0)
  {
LABEL_98:
    if ((v15 & 0x40000) == 0) {
      goto LABEL_99;
    }
    goto LABEL_183;
  }
LABEL_182:
  *(_DWORD *)(a2 + 176) = *(void *)(a1 + 648);
  if ((v15 & 0x40000) == 0)
  {
LABEL_99:
    if ((v15 & 0x80000) == 0) {
      goto LABEL_100;
    }
    goto LABEL_184;
  }
LABEL_183:
  *(_DWORD *)(a2 + 180) = *(void *)(a1 + 656);
  if ((v15 & 0x80000) == 0)
  {
LABEL_100:
    if ((v15 & 0x100000) == 0) {
      goto LABEL_101;
    }
    goto LABEL_185;
  }
LABEL_184:
  *(_DWORD *)(a2 + 184) = *(void *)(a1 + 664);
  if ((v15 & 0x100000) == 0)
  {
LABEL_101:
    if ((v15 & 0x200000) == 0) {
      goto LABEL_102;
    }
    goto LABEL_186;
  }
LABEL_185:
  *(_DWORD *)(a2 + 188) = *(void *)(a1 + 672);
  if ((v15 & 0x200000) == 0)
  {
LABEL_102:
    if ((v15 & 0x400000) == 0) {
      goto LABEL_104;
    }
    goto LABEL_103;
  }
LABEL_186:
  *(_DWORD *)(a2 + 192) = *(void *)(a1 + 680);
  if ((v15 & 0x400000) != 0) {
LABEL_103:
  }
    *(_DWORD *)(a2 + 196) = *(void *)(a1 + 688);
LABEL_104:
  v16 = v2 & 1;
  if ((v15 & 0x800000) != 0) {
    *(_DWORD *)(a2 + 200) = *(void *)(a1 + 696);
  }
  v17 = v3 & 2;
  v18 = v3 & 4;
  v19 = v3 & 8;
  v20 = v3 & 0x10;
  v21 = v3 & 0x20;
  v22 = v3 & 0x40;
  v23 = v4 & 0x80;
  v24 = v4 & 0x100;
  v48 = v11 & 0x4000000000;
  v49 = v11 & 0x8000000000;
  v50 = v11 & 0x10000000000;
  v51 = v11 & 0x20000000000;
  v52 = v11 & 0x40000000000;
  v53 = v11 & 0x80000000000;
  v54 = v11 & 0x100000000000;
  if ((v15 & 0x1000000) != 0) {
    *(_DWORD *)(a2 + 204) = *(void *)(a1 + 704);
  }
  v25 = v5 & 0x200;
  v32 = v6 & 0x10000;
  v31 = (unsigned __int16)v6 & 0x8000;
  v30 = v5 & 0x4000;
  v29 = v5 & 0x2000;
  v28 = v5 & 0x1000;
  v27 = v5 & 0x800;
  v26 = v5 & 0x400;
  v35 = v6 & 0x20000;
  v36 = v6 & 0x40000;
  v37 = v6 & 0x80000;
  v38 = v6 & 0x100000;
  v41 = v8 & 0x800000;
  v42 = v8 & 0x1000000;
  v43 = v8 & 0x2000000;
  v44 = v8 & 0x4000000;
  v45 = v8 & 0x8000000;
  v46 = v8 & 0x10000000;
  v47 = v8 & 0x20000000;
  v39 = v78 & 0x200000;
  v40 = v78 & 0x400000;
  v33 = BYTE4(v9) & 1;
  LODWORD(v25) = (v17 >> 1)
               + v16
               + (v18 >> 2)
               + (v19 >> 3)
               + (v20 >> 4)
               + (v21 >> 5)
               + (v22 >> 6)
               + (v23 >> 7)
               + (v24 >> 8)
               + (v25 >> 9)
               + (v26 >> 10)
               + (v27 >> 11)
               + (v28 >> 12)
               + (v29 >> 13)
               + (v30 >> 14)
               + (v31 >> 15)
               + (v32 >> 16)
               + (v35 >> 17)
               + (v36 >> 18)
               + (v37 >> 19)
               + (v38 >> 20)
               + (v39 >> 21)
               + (v40 >> 22)
               + (v41 >> 23)
               + (v42 >> 24)
               + (v43 >> 25)
               + (v44 >> 26)
               + (v45 >> 27)
               + (v46 >> 28)
               + (v47 >> 29)
               + ((v9 & 0x40000000) >> 30)
               + (v9 >> 31)
               + v33
               + ((v9 & 0x200000000) >> 33)
               + ((v9 & 0x400000000) >> 34)
               + ((v9 & 0x800000000) >> 35)
               + ((v10 & 0x1000000000) >> 36)
               + ((v10 & 0x2000000000) >> 37)
               + (v48 >> 38)
               + (v49 >> 39)
               + (v50 >> 40)
               + (v51 >> 41)
               + (v52 >> 42);
  v55 = v12 & 0x200000000000;
  v56 = v12 & 0x400000000000;
  v57 = v12 & 0x800000000000;
  v58 = v12 & 0x1000000000000;
  v59 = v12 & 0x2000000000000;
  v60 = v12 & 0x4000000000000;
  v61 = v13 & 0x8000000000000;
  v62 = v13 & 0x10000000000000;
  v63 = v14 & 0x20000000000000;
  v64 = v14 & 0x80000000000000;
  v65 = v14 & 0x40000000000000;
  v66 = v14 & 0x100000000000000;
  v67 = v15 & 0x20000;
  v68 = v15 & 0x10000;
  v69 = (unsigned __int16)v15 & 0x8000;
  v70 = v15 & 0x4000;
  v71 = v15 & 0x2000;
  v72 = v15 & 0x1000;
  v73 = v15 & 0x800;
  v74 = v15 & 0x400;
  v75 = v15 & 0x200;
  v76 = v15 & 0x100;
  v77 = v15 & 1;
  LODWORD(v25) = v25
               + (v53 >> 43)
               + (v54 >> 44)
               + (v55 >> 45)
               + (v56 >> 46)
               + (v57 >> 47)
               + HIWORD(v58)
               + (v59 >> 49)
               + (v60 >> 50)
               + (v61 >> 51)
               + (v62 >> 52)
               + (v14 >> 63)
               + (v63 >> 53)
               + (v65 >> 54)
               + (v64 >> 55)
               + HIBYTE(v66)
               + ((v14 & 0x200000000000000) >> 57)
               + ((v14 & 0x400000000000000) >> 58)
               + ((v14 & 0x800000000000000) >> 59)
               + ((v14 & 0x1000000000000000) >> 60)
               + ((v14 & 0x2000000000000000) >> 61)
               + ((v14 & 0x4000000000000000) >> 62)
               + v77
               + ((unint64_t)(v15 & 2) >> 1)
               + ((unint64_t)(v15 & 4) >> 2)
               + ((unint64_t)(v15 & 8) >> 3)
               + ((unint64_t)(v15 & 0x10) >> 4)
               + ((unint64_t)(v15 & 0x20) >> 5)
               + ((unint64_t)(v15 & 0x40) >> 6)
               + ((unint64_t)(v15 & 0x80) >> 7)
               + (v76 >> 8)
               + (v75 >> 9)
               + (v74 >> 10)
               + (v73 >> 11)
               + (v72 >> 12)
               + (v71 >> 13)
               + (v70 >> 14)
               + (v69 >> 15)
               + (v68 >> 16)
               + (v67 >> 17);
  return v25
       + ((v15 & 0x40000uLL) >> 18)
       + ((v15 & 0x80000uLL) >> 19)
       + ((v15 & 0x100000uLL) >> 20)
       + ((v15 & 0x200000uLL) >> 21)
       + ((v15 & 0x400000uLL) >> 22)
       + ((v15 & 0x800000uLL) >> 23)
       + ((v15 & 0x1000000) >> 24);
}

unint64_t sub_1CBF1E9C4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 1248);
  uint64_t v3 = v2;
  if (v2)
  {
    *(unsigned char *)a2 = *(unsigned char *)a1 & 1;
    uint64_t v3 = *(void *)(a1 + 1248);
    if ((v3 & 2) == 0)
    {
LABEL_3:
      if ((v3 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_48;
    }
  }
  else if ((v2 & 2) == 0)
  {
    goto LABEL_3;
  }
  *(_WORD *)a2 = *(void *)(a1 + 8);
  if ((v3 & 4) == 0)
  {
LABEL_4:
    if ((v3 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_49;
  }
LABEL_48:
  *(_WORD *)a2 = *(_WORD *)(a1 + 16) & 0x1FF;
  if ((v3 & 8) == 0)
  {
LABEL_5:
    if ((v3 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_50;
  }
LABEL_49:
  *(_WORD *)a2 = *(_WORD *)(a1 + 24) & 0x1FF;
  if ((v3 & 0x10) == 0)
  {
LABEL_6:
    if ((v3 & 0x20) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
LABEL_50:
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 32) & 0x1FFFF;
  if ((v3 & 0x20) != 0) {
LABEL_7:
  }
    *(_WORD *)a2 = *(_WORD *)(a1 + 40) & 0x1FFF;
LABEL_8:
  uint64_t v4 = v3;
  if ((v3 & 0x40) != 0)
  {
    *(unsigned char *)a2 = *(unsigned char *)(a1 + 48) & 0x7F;
    uint64_t v4 = *(void *)(a1 + 1248);
  }
  if ((v4 & 0x80) != 0) {
    *(_DWORD *)a2 = *(void *)(a1 + 56);
  }
  uint64_t v5 = v4;
  if ((v4 & 0x100) != 0)
  {
    *(unsigned char *)(a2 + 4) = *(unsigned char *)(a1 + 64) & 0xF;
    uint64_t v5 = *(void *)(a1 + 1248);
    if ((v5 & 0x200) == 0)
    {
LABEL_14:
      if ((v5 & 0x400) == 0) {
        goto LABEL_15;
      }
      goto LABEL_54;
    }
  }
  else if ((v4 & 0x200) == 0)
  {
    goto LABEL_14;
  }
  *(_DWORD *)(a2 + 8) = *(void *)(a1 + 72);
  if ((v5 & 0x400) == 0)
  {
LABEL_15:
    if ((v5 & 0x800) == 0) {
      goto LABEL_16;
    }
    goto LABEL_55;
  }
LABEL_54:
  *(_DWORD *)(a2 + 12) = *(void *)(a1 + 80);
  if ((v5 & 0x800) == 0)
  {
LABEL_16:
    if ((v5 & 0x1000) == 0) {
      goto LABEL_17;
    }
    goto LABEL_56;
  }
LABEL_55:
  *(unsigned char *)(a2 + 16) = *(void *)(a1 + 88) != 0;
  if ((v5 & 0x1000) == 0)
  {
LABEL_17:
    if ((v5 & 0x2000) == 0) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
LABEL_56:
  *(_DWORD *)(a2 + 20) = *(void *)(a1 + 96);
  if ((v5 & 0x2000) != 0) {
LABEL_18:
  }
    *(unsigned char *)(a2 + 24) = *(void *)(a1 + 104) != 0;
LABEL_19:
  uint64_t v6 = v5;
  if ((v5 & 0x4000) != 0)
  {
    *(void *)(a2 + 32) = *(void *)(a1 + 112) & 0xFFFFFFFFFFFFLL;
    uint64_t v6 = *(void *)(a1 + 1248);
    if ((v6 & 0x8000) == 0)
    {
LABEL_21:
      if ((v6 & 0x10000) == 0) {
        goto LABEL_22;
      }
      goto LABEL_60;
    }
  }
  else if ((v5 & 0x8000) == 0)
  {
    goto LABEL_21;
  }
  *(_DWORD *)(a2 + 40) = *(void *)(a1 + 120);
  if ((v6 & 0x10000) == 0)
  {
LABEL_22:
    if ((v6 & 0x20000) == 0) {
      goto LABEL_23;
    }
    goto LABEL_61;
  }
LABEL_60:
  *(_DWORD *)(a2 + 44) = *(void *)(a1 + 128);
  if ((v6 & 0x20000) == 0)
  {
LABEL_23:
    if ((v6 & 0x40000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_62;
  }
LABEL_61:
  *(unsigned char *)(a2 + 48) = *(void *)(a1 + 136) != 0;
  if ((v6 & 0x40000) == 0)
  {
LABEL_24:
    if ((v6 & 0x80000) == 0) {
      goto LABEL_25;
    }
    goto LABEL_63;
  }
LABEL_62:
  *(unsigned char *)(a2 + 49) = *(void *)(a1 + 144) != 0;
  if ((v6 & 0x80000) == 0)
  {
LABEL_25:
    if ((v6 & 0x100000) == 0) {
      goto LABEL_26;
    }
    goto LABEL_64;
  }
LABEL_63:
  *(unsigned char *)(a2 + 50) = *(void *)(a1 + 152) != 0;
  if ((v6 & 0x100000) == 0)
  {
LABEL_26:
    if ((v6 & 0x200000) == 0) {
      goto LABEL_27;
    }
    goto LABEL_65;
  }
LABEL_64:
  *(unsigned char *)(a2 + 51) = *(void *)(a1 + 160) != 0;
  if ((v6 & 0x200000) == 0)
  {
LABEL_27:
    if ((v6 & 0x400000) == 0) {
      goto LABEL_28;
    }
    goto LABEL_66;
  }
LABEL_65:
  *(unsigned char *)(a2 + 52) = *(void *)(a1 + 168) != 0;
  if ((v6 & 0x400000) == 0)
  {
LABEL_28:
    if ((v6 & 0x800000) == 0) {
      goto LABEL_29;
    }
    goto LABEL_67;
  }
LABEL_66:
  *(unsigned char *)(a2 + 53) = *(void *)(a1 + 176) != 0;
  if ((v6 & 0x800000) == 0)
  {
LABEL_29:
    if ((v6 & 0x1000000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_68;
  }
LABEL_67:
  *(unsigned char *)(a2 + 54) = *(void *)(a1 + 184) != 0;
  if ((v6 & 0x1000000) == 0)
  {
LABEL_30:
    if ((v6 & 0x2000000) == 0) {
      goto LABEL_31;
    }
    goto LABEL_69;
  }
LABEL_68:
  *(unsigned char *)(a2 + 55) = *(void *)(a1 + 192) != 0;
  if ((v6 & 0x2000000) == 0)
  {
LABEL_31:
    if ((v6 & 0x4000000) == 0) {
      goto LABEL_32;
    }
    goto LABEL_70;
  }
LABEL_69:
  *(unsigned char *)(a2 + 56) = *(void *)(a1 + 200) != 0;
  if ((v6 & 0x4000000) == 0)
  {
LABEL_32:
    if ((v6 & 0x8000000) == 0) {
      goto LABEL_33;
    }
    goto LABEL_71;
  }
LABEL_70:
  *(unsigned char *)(a2 + 57) = *(void *)(a1 + 208) != 0;
  if ((v6 & 0x8000000) == 0)
  {
LABEL_33:
    if ((v6 & 0x10000000) == 0) {
      goto LABEL_34;
    }
    goto LABEL_72;
  }
LABEL_71:
  *(_DWORD *)(a2 + 60) = *(void *)(a1 + 216);
  if ((v6 & 0x10000000) == 0)
  {
LABEL_34:
    if ((v6 & 0x20000000) == 0) {
      goto LABEL_35;
    }
    goto LABEL_73;
  }
LABEL_72:
  *(_DWORD *)(a2 + 64) = *(void *)(a1 + 224);
  if ((v6 & 0x20000000) == 0)
  {
LABEL_35:
    if ((v6 & 0x40000000) == 0) {
      goto LABEL_36;
    }
    goto LABEL_74;
  }
LABEL_73:
  *(_DWORD *)(a2 + 68) = *(void *)(a1 + 232);
  if ((v6 & 0x40000000) == 0)
  {
LABEL_36:
    if ((v6 & 0x80000000) == 0) {
      goto LABEL_37;
    }
    goto LABEL_75;
  }
LABEL_74:
  *(_DWORD *)(a2 + 72) = *(void *)(a1 + 240);
  if ((v6 & 0x80000000) == 0)
  {
LABEL_37:
    if ((v6 & 0x100000000) == 0) {
      goto LABEL_38;
    }
    goto LABEL_76;
  }
LABEL_75:
  *(_DWORD *)(a2 + 76) = *(void *)(a1 + 248);
  if ((v6 & 0x100000000) == 0)
  {
LABEL_38:
    if ((v6 & 0x200000000) == 0) {
      goto LABEL_39;
    }
    goto LABEL_77;
  }
LABEL_76:
  *(_DWORD *)(a2 + 80) = *(void *)(a1 + 256);
  if ((v6 & 0x200000000) == 0)
  {
LABEL_39:
    if ((v6 & 0x400000000) == 0) {
      goto LABEL_41;
    }
    goto LABEL_40;
  }
LABEL_77:
  *(_DWORD *)(a2 + 84) = *(void *)(a1 + 264);
  if ((v6 & 0x400000000) != 0) {
LABEL_40:
  }
    *(_DWORD *)(a2 + 88) = *(void *)(a1 + 272);
LABEL_41:
  int v7 = v2 & 1;
  if ((v6 & 0x800000000) != 0) {
    *(unsigned char *)(a2 + 92) = *(void *)(a1 + 280) != 0;
  }
  if ((v6 & 0x1000000000) != 0) {
    *(unsigned char *)(a2 + 93) = *(unsigned char *)(a1 + 288) & 0x1F;
  }
  unint64_t v8 = v3 & 8;
  unint64_t v11 = v6 & 0x800000;
  unint64_t v10 = v4 & 0x100;
  unint64_t v9 = v4 & 0x80;
  unint64_t v13 = v6 & 0x2000000;
  unint64_t v14 = v6 & 0x4000000;
  unint64_t v15 = v6 & 0x8000000;
  unint64_t v16 = v6 & 0x10000000;
  unint64_t v17 = v6 & 0x20000000;
  unint64_t v18 = v6 & 0x40000000;
  unint64_t v20 = v6 & 0x200000000;
  unint64_t v21 = v6 & 0x400000000;
  int v19 = BYTE4(v6) & 1;
  return ((unint64_t)(v3 & 2) >> 1)
       + v7
       + ((unint64_t)(v3 & 4) >> 2)
       + (v8 >> 3)
       + ((unint64_t)(v3 & 0x10) >> 4)
       + ((unint64_t)(v3 & 0x20) >> 5)
       + ((unint64_t)(v3 & 0x40) >> 6)
       + (v9 >> 7)
       + (v10 >> 8)
       + ((unint64_t)(v5 & 0x200) >> 9)
       + ((unint64_t)(v5 & 0x400) >> 10)
       + ((unint64_t)(v5 & 0x800) >> 11)
       + ((unint64_t)(v5 & 0x1000) >> 12)
       + ((unint64_t)(v5 & 0x2000) >> 13)
       + ((unint64_t)(v5 & 0x4000) >> 14)
       + ((unint64_t)((unsigned __int16)v6 & 0x8000) >> 15)
       + ((v6 & 0x10000uLL) >> 16)
       + ((v6 & 0x20000uLL) >> 17)
       + ((v6 & 0x40000uLL) >> 18)
       + ((v6 & 0x80000uLL) >> 19)
       + ((v6 & 0x100000uLL) >> 20)
       + ((v6 & 0x200000uLL) >> 21)
       + ((v6 & 0x400000uLL) >> 22)
       + (v11 >> 23)
       + ((v6 & 0x1000000) >> 24)
       + (v13 >> 25)
       + (v14 >> 26)
       + (v15 >> 27)
       + (v16 >> 28)
       + (v17 >> 29)
       + (v18 >> 30)
       + (v6 >> 31)
       + v19
       + (v20 >> 33)
       + (v21 >> 34)
       + ((v6 & 0x800000000uLL) >> 35)
       + ((v6 & 0x1000000000uLL) >> 36);
}

unint64_t sub_1CBF1EEF0(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 1248);
  unint64_t v3 = v2;
  if (v2)
  {
    *(unsigned char *)a2 = *(unsigned char *)a1 & 1;
    unint64_t v3 = *(void *)(a1 + 1248);
    if ((v3 & 2) == 0)
    {
LABEL_3:
      if ((v3 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_130;
    }
  }
  else if ((v2 & 2) == 0)
  {
    goto LABEL_3;
  }
  *(_WORD *)a2 = *(void *)(a1 + 8);
  if ((v3 & 4) == 0)
  {
LABEL_4:
    if ((v3 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_131;
  }
LABEL_130:
  *(_WORD *)a2 = *(_WORD *)(a1 + 16) & 0x1FF;
  if ((v3 & 8) == 0)
  {
LABEL_5:
    if ((v3 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_132;
  }
LABEL_131:
  *(_WORD *)a2 = *(_WORD *)(a1 + 24) & 0x1FF;
  if ((v3 & 0x10) == 0)
  {
LABEL_6:
    if ((v3 & 0x20) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
LABEL_132:
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 32) & 0x1FFFF;
  if ((v3 & 0x20) != 0) {
LABEL_7:
  }
    *(_WORD *)a2 = *(_WORD *)(a1 + 40) & 0x1FFF;
LABEL_8:
  unint64_t v4 = v3;
  if ((v3 & 0x40) != 0)
  {
    *(unsigned char *)a2 = *(unsigned char *)(a1 + 48) & 0x7F;
    unint64_t v4 = *(void *)(a1 + 1248);
  }
  if ((v4 & 0x80) != 0) {
    *(_DWORD *)a2 = *(void *)(a1 + 56);
  }
  unint64_t v5 = v4;
  if ((v4 & 0x100) != 0)
  {
    *(unsigned char *)(a2 + 4) = *(unsigned char *)(a1 + 64) & 0xF;
    unint64_t v5 = *(void *)(a1 + 1248);
    if ((v5 & 0x200) == 0)
    {
LABEL_14:
      if ((v5 & 0x400) == 0) {
        goto LABEL_15;
      }
      goto LABEL_136;
    }
  }
  else if ((v4 & 0x200) == 0)
  {
    goto LABEL_14;
  }
  *(_DWORD *)(a2 + 8) = *(void *)(a1 + 72);
  if ((v5 & 0x400) == 0)
  {
LABEL_15:
    if ((v5 & 0x800) == 0) {
      goto LABEL_16;
    }
    goto LABEL_137;
  }
LABEL_136:
  *(_DWORD *)(a2 + 12) = *(void *)(a1 + 80);
  if ((v5 & 0x800) == 0)
  {
LABEL_16:
    if ((v5 & 0x1000) == 0) {
      goto LABEL_17;
    }
    goto LABEL_138;
  }
LABEL_137:
  *(unsigned char *)(a2 + 16) = *(void *)(a1 + 88) != 0;
  if ((v5 & 0x1000) == 0)
  {
LABEL_17:
    if ((v5 & 0x2000) == 0) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
LABEL_138:
  *(_DWORD *)(a2 + 20) = *(void *)(a1 + 96);
  if ((v5 & 0x2000) != 0) {
LABEL_18:
  }
    *(_DWORD *)(a2 + 24) = *(void *)(a1 + 104);
LABEL_19:
  unint64_t v6 = v5;
  if ((v5 & 0x4000) != 0)
  {
    *(unsigned char *)(a2 + 28) = *(unsigned char *)(a1 + 112) & 1;
    unint64_t v6 = *(void *)(a1 + 1248);
    if ((v6 & 0x8000) == 0)
    {
LABEL_21:
      if ((v6 & 0x10000) == 0) {
        goto LABEL_22;
      }
      goto LABEL_142;
    }
  }
  else if ((v5 & 0x8000) == 0)
  {
    goto LABEL_21;
  }
  *(_WORD *)(a2 + 28) = *(void *)(a1 + 120);
  if ((v6 & 0x10000) == 0)
  {
LABEL_22:
    if ((v6 & 0x20000) == 0) {
      goto LABEL_23;
    }
    goto LABEL_143;
  }
LABEL_142:
  *(_WORD *)(a2 + 28) = *(_WORD *)(a1 + 128) & 0x1FF;
  if ((v6 & 0x20000) == 0)
  {
LABEL_23:
    if ((v6 & 0x40000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_144;
  }
LABEL_143:
  *(_WORD *)(a2 + 28) = *(_WORD *)(a1 + 136) & 0x1FF;
  if ((v6 & 0x40000) == 0)
  {
LABEL_24:
    if ((v6 & 0x80000) == 0) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }
LABEL_144:
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 144) & 0x1FFFF;
  if ((v6 & 0x80000) != 0) {
LABEL_25:
  }
    *(_WORD *)(a2 + 28) = *(_WORD *)(a1 + 152) & 0x1FFF;
LABEL_26:
  unint64_t v7 = v6;
  if ((v6 & 0x100000) != 0)
  {
    *(unsigned char *)(a2 + 28) = *(unsigned char *)(a1 + 160) & 0x7F;
    unint64_t v7 = *(void *)(a1 + 1248);
  }
  if ((v7 & 0x200000) != 0) {
    *(_DWORD *)(a2 + 28) = *(void *)(a1 + 168);
  }
  unint64_t v8 = v7;
  if ((v7 & 0x400000) != 0)
  {
    *(unsigned char *)(a2 + 32) = *(unsigned char *)(a1 + 176) & 0xF;
    unint64_t v8 = *(void *)(a1 + 1248);
    if ((v8 & 0x800000) == 0)
    {
LABEL_32:
      if ((v8 & 0x1000000) == 0) {
        goto LABEL_33;
      }
      goto LABEL_148;
    }
  }
  else if ((v7 & 0x800000) == 0)
  {
    goto LABEL_32;
  }
  *(_DWORD *)(a2 + 36) = *(void *)(a1 + 184);
  if ((v8 & 0x1000000) == 0)
  {
LABEL_33:
    if ((v8 & 0x2000000) == 0) {
      goto LABEL_34;
    }
    goto LABEL_149;
  }
LABEL_148:
  *(_DWORD *)(a2 + 40) = *(void *)(a1 + 192);
  if ((v8 & 0x2000000) == 0)
  {
LABEL_34:
    if ((v8 & 0x4000000) == 0) {
      goto LABEL_36;
    }
    goto LABEL_35;
  }
LABEL_149:
  *(unsigned char *)(a2 + 44) = *(void *)(a1 + 200) != 0;
  if ((v8 & 0x4000000) != 0) {
LABEL_35:
  }
    *(_DWORD *)(a2 + 48) = *(void *)(a1 + 208);
LABEL_36:
  int v82 = v7;
  if ((v8 & 0x8000000) != 0) {
    *(unsigned char *)(a2 + 52) = *(void *)(a1 + 216) != 0;
  }
  unint64_t v9 = v8;
  if ((v8 & 0x10000000) != 0)
  {
    *(unsigned char *)(a2 + 56) = *(unsigned char *)(a1 + 224) & 1;
    unint64_t v9 = *(void *)(a1 + 1248);
    if ((v9 & 0x20000000) == 0)
    {
LABEL_40:
      if ((v9 & 0x40000000) == 0) {
        goto LABEL_41;
      }
      goto LABEL_153;
    }
  }
  else if ((v8 & 0x20000000) == 0)
  {
    goto LABEL_40;
  }
  *(_WORD *)(a2 + 56) = *(void *)(a1 + 232);
  if ((v9 & 0x40000000) == 0)
  {
LABEL_41:
    if ((v9 & 0x80000000) == 0) {
      goto LABEL_42;
    }
    goto LABEL_154;
  }
LABEL_153:
  *(_WORD *)(a2 + 56) = *(_WORD *)(a1 + 240) & 0x1FF;
  if ((v9 & 0x80000000) == 0)
  {
LABEL_42:
    if ((v9 & 0x100000000) == 0) {
      goto LABEL_43;
    }
    goto LABEL_155;
  }
LABEL_154:
  *(_WORD *)(a2 + 56) = *(_WORD *)(a1 + 248) & 0x1FF;
  if ((v9 & 0x100000000) == 0)
  {
LABEL_43:
    if ((v9 & 0x200000000) == 0) {
      goto LABEL_45;
    }
    goto LABEL_44;
  }
LABEL_155:
  *(_DWORD *)(a2 + 56) = *(_DWORD *)(a1 + 256) & 0x1FFFF;
  if ((v9 & 0x200000000) != 0) {
LABEL_44:
  }
    *(_WORD *)(a2 + 56) = *(_WORD *)(a1 + 264) & 0x1FFF;
LABEL_45:
  unint64_t v10 = v9;
  if ((v9 & 0x400000000) != 0)
  {
    *(unsigned char *)(a2 + 56) = *(unsigned char *)(a1 + 272) & 0x7F;
    unint64_t v10 = *(void *)(a1 + 1248);
  }
  if ((v10 & 0x800000000) != 0) {
    *(_DWORD *)(a2 + 56) = *(void *)(a1 + 280);
  }
  unint64_t v11 = v10;
  if ((v10 & 0x1000000000) != 0)
  {
    *(unsigned char *)(a2 + 60) = *(unsigned char *)(a1 + 288) & 0xF;
    unint64_t v11 = *(void *)(a1 + 1248);
    if ((v11 & 0x2000000000) == 0)
    {
LABEL_51:
      if ((v11 & 0x4000000000) == 0) {
        goto LABEL_52;
      }
      goto LABEL_159;
    }
  }
  else if ((v10 & 0x2000000000) == 0)
  {
    goto LABEL_51;
  }
  *(_DWORD *)(a2 + 64) = *(void *)(a1 + 296);
  if ((v11 & 0x4000000000) == 0)
  {
LABEL_52:
    if ((v11 & 0x8000000000) == 0) {
      goto LABEL_53;
    }
    goto LABEL_160;
  }
LABEL_159:
  *(_DWORD *)(a2 + 68) = *(void *)(a1 + 304);
  if ((v11 & 0x8000000000) == 0)
  {
LABEL_53:
    if ((v11 & 0x10000000000) == 0) {
      goto LABEL_54;
    }
    goto LABEL_161;
  }
LABEL_160:
  *(unsigned char *)(a2 + 72) = *(void *)(a1 + 312) != 0;
  if ((v11 & 0x10000000000) == 0)
  {
LABEL_54:
    if ((v11 & 0x20000000000) == 0) {
      goto LABEL_55;
    }
    goto LABEL_162;
  }
LABEL_161:
  *(_DWORD *)(a2 + 76) = *(void *)(a1 + 320);
  if ((v11 & 0x20000000000) == 0)
  {
LABEL_55:
    if ((v11 & 0x40000000000) == 0) {
      goto LABEL_57;
    }
    goto LABEL_56;
  }
LABEL_162:
  *(unsigned char *)(a2 + 80) = *(void *)(a1 + 328) != 0;
  if ((v11 & 0x40000000000) != 0) {
LABEL_56:
  }
    *(unsigned char *)(a2 + 81) = *(void *)(a1 + 336) != 0;
LABEL_57:
  unint64_t v12 = v11;
  if ((v11 & 0x80000000000) != 0)
  {
    *(unsigned char *)(a2 + 84) = *(unsigned char *)(a1 + 344) & 1;
    unint64_t v12 = *(void *)(a1 + 1248);
    if ((v12 & 0x100000000000) == 0)
    {
LABEL_59:
      if ((v12 & 0x200000000000) == 0) {
        goto LABEL_60;
      }
      goto LABEL_166;
    }
  }
  else if ((v11 & 0x100000000000) == 0)
  {
    goto LABEL_59;
  }
  *(_WORD *)(a2 + 84) = *(void *)(a1 + 352);
  if ((v12 & 0x200000000000) == 0)
  {
LABEL_60:
    if ((v12 & 0x400000000000) == 0) {
      goto LABEL_61;
    }
    goto LABEL_167;
  }
LABEL_166:
  *(_WORD *)(a2 + 84) = *(_WORD *)(a1 + 360) & 0x1FF;
  if ((v12 & 0x400000000000) == 0)
  {
LABEL_61:
    if ((v12 & 0x800000000000) == 0) {
      goto LABEL_62;
    }
    goto LABEL_168;
  }
LABEL_167:
  *(_WORD *)(a2 + 84) = *(_WORD *)(a1 + 368) & 0x1FF;
  if ((v12 & 0x800000000000) == 0)
  {
LABEL_62:
    if ((v12 & 0x1000000000000) == 0) {
      goto LABEL_64;
    }
    goto LABEL_63;
  }
LABEL_168:
  *(_DWORD *)(a2 + 84) = *(_DWORD *)(a1 + 376) & 0x1FFFF;
  if ((v12 & 0x1000000000000) != 0) {
LABEL_63:
  }
    *(_WORD *)(a2 + 84) = *(_WORD *)(a1 + 384) & 0x1FFF;
LABEL_64:
  unint64_t v13 = v12;
  if ((v12 & 0x2000000000000) != 0)
  {
    *(unsigned char *)(a2 + 84) = *(unsigned char *)(a1 + 392) & 0x7F;
    unint64_t v13 = *(void *)(a1 + 1248);
  }
  if ((v13 & 0x4000000000000) != 0) {
    *(_DWORD *)(a2 + 84) = *(void *)(a1 + 400);
  }
  unint64_t v14 = v13;
  if ((v13 & 0x8000000000000) != 0)
  {
    *(unsigned char *)(a2 + 88) = *(unsigned char *)(a1 + 408) & 0xF;
    unint64_t v14 = *(void *)(a1 + 1248);
    if ((v14 & 0x10000000000000) == 0)
    {
LABEL_70:
      if ((v14 & 0x20000000000000) == 0) {
        goto LABEL_71;
      }
      goto LABEL_172;
    }
  }
  else if ((v13 & 0x10000000000000) == 0)
  {
    goto LABEL_70;
  }
  *(_DWORD *)(a2 + 92) = *(void *)(a1 + 416);
  if ((v14 & 0x20000000000000) == 0)
  {
LABEL_71:
    if ((v14 & 0x40000000000000) == 0) {
      goto LABEL_72;
    }
    goto LABEL_173;
  }
LABEL_172:
  *(_DWORD *)(a2 + 96) = *(void *)(a1 + 424);
  if ((v14 & 0x40000000000000) == 0)
  {
LABEL_72:
    if ((v14 & 0x80000000000000) == 0) {
      goto LABEL_73;
    }
    goto LABEL_174;
  }
LABEL_173:
  *(unsigned char *)(a2 + 100) = *(void *)(a1 + 432) != 0;
  if ((v14 & 0x80000000000000) == 0)
  {
LABEL_73:
    if ((v14 & 0x100000000000000) == 0) {
      goto LABEL_75;
    }
    goto LABEL_74;
  }
LABEL_174:
  *(_DWORD *)(a2 + 104) = *(void *)(a1 + 440);
  if ((v14 & 0x100000000000000) != 0) {
LABEL_74:
  }
    *(unsigned char *)(a2 + 108) = *(void *)(a1 + 448) != 0;
LABEL_75:
  unint64_t v81 = v10;
  if ((v14 & 0x200000000000000) != 0) {
    *(unsigned char *)(a2 + 112) = *(void *)(a1 + 456) != 0;
  }
  unint64_t v15 = v14;
  if ((v14 & 0x400000000000000) != 0)
  {
    *(unsigned char *)(a2 + 116) = *(unsigned char *)(a1 + 464) & 1;
    unint64_t v15 = *(void *)(a1 + 1248);
    if ((v15 & 0x800000000000000) == 0)
    {
LABEL_79:
      if ((v15 & 0x1000000000000000) == 0) {
        goto LABEL_80;
      }
      goto LABEL_178;
    }
  }
  else if ((v14 & 0x800000000000000) == 0)
  {
    goto LABEL_79;
  }
  *(_WORD *)(a2 + 116) = *(void *)(a1 + 472);
  if ((v15 & 0x1000000000000000) == 0)
  {
LABEL_80:
    if ((v15 & 0x2000000000000000) == 0) {
      goto LABEL_81;
    }
    goto LABEL_179;
  }
LABEL_178:
  *(_WORD *)(a2 + 116) = *(_WORD *)(a1 + 480) & 0x1FF;
  if ((v15 & 0x2000000000000000) == 0)
  {
LABEL_81:
    if ((v15 & 0x4000000000000000) == 0) {
      goto LABEL_82;
    }
LABEL_180:
    *(_DWORD *)(a2 + 116) = *(_DWORD *)(a1 + 496) & 0x1FFFF;
    if ((v15 & 0x8000000000000000) == 0) {
      goto LABEL_83;
    }
    goto LABEL_181;
  }
LABEL_179:
  *(_WORD *)(a2 + 116) = *(_WORD *)(a1 + 488) & 0x1FF;
  if ((v15 & 0x4000000000000000) != 0) {
    goto LABEL_180;
  }
LABEL_82:
  if ((v15 & 0x8000000000000000) == 0) {
    goto LABEL_83;
  }
LABEL_181:
  *(_WORD *)(a2 + 116) = *(_WORD *)(a1 + 504) & 0x1FFF;
LABEL_83:
  uint64_t v16 = *(void *)(a1 + 1256);
  uint64_t v17 = v16;
  if (v16)
  {
    *(unsigned char *)(a2 + 116) = *(unsigned char *)(a1 + 512) & 0x7F;
    uint64_t v17 = *(void *)(a1 + 1256);
  }
  if ((v17 & 2) != 0) {
    *(_DWORD *)(a2 + 116) = *(void *)(a1 + 520);
  }
  uint64_t v18 = v17;
  if ((v17 & 4) != 0)
  {
    *(unsigned char *)(a2 + 120) = *(unsigned char *)(a1 + 528) & 0xF;
    uint64_t v18 = *(void *)(a1 + 1256);
    if ((v18 & 8) == 0)
    {
LABEL_89:
      if ((v18 & 0x10) == 0) {
        goto LABEL_90;
      }
      goto LABEL_184;
    }
  }
  else if ((v17 & 8) == 0)
  {
    goto LABEL_89;
  }
  *(_DWORD *)(a2 + 124) = *(void *)(a1 + 536);
  if ((v18 & 0x10) == 0)
  {
LABEL_90:
    if ((v18 & 0x20) == 0) {
      goto LABEL_91;
    }
    goto LABEL_185;
  }
LABEL_184:
  *(_DWORD *)(a2 + 128) = *(void *)(a1 + 544);
  if ((v18 & 0x20) == 0)
  {
LABEL_91:
    if ((v18 & 0x40) == 0) {
      goto LABEL_92;
    }
    goto LABEL_186;
  }
LABEL_185:
  *(unsigned char *)(a2 + 132) = *(void *)(a1 + 552) != 0;
  if ((v18 & 0x40) == 0)
  {
LABEL_92:
    if ((v18 & 0x80) == 0) {
      goto LABEL_93;
    }
    goto LABEL_187;
  }
LABEL_186:
  *(_DWORD *)(a2 + 136) = *(void *)(a1 + 560);
  if ((v18 & 0x80) == 0)
  {
LABEL_93:
    if ((v18 & 0x100) == 0) {
      goto LABEL_94;
    }
    goto LABEL_188;
  }
LABEL_187:
  *(unsigned char *)(a2 + 140) = *(void *)(a1 + 568) != 0;
  if ((v18 & 0x100) == 0)
  {
LABEL_94:
    if ((v18 & 0x200) == 0) {
      goto LABEL_96;
    }
    goto LABEL_95;
  }
LABEL_188:
  *(_DWORD *)(a2 + 144) = *(void *)(a1 + 576);
  if ((v18 & 0x200) != 0) {
LABEL_95:
  }
    *(_DWORD *)(a2 + 148) = *(void *)(a1 + 584);
LABEL_96:
  uint64_t v19 = v18;
  if ((v18 & 0x400) != 0)
  {
    *(unsigned char *)(a2 + 152) = *(unsigned char *)(a1 + 592) & 0xF;
    uint64_t v19 = *(void *)(a1 + 1256);
  }
  uint64_t v20 = v19;
  if ((v19 & 0x800) != 0)
  {
    *(unsigned char *)(a2 + 153) = *(unsigned char *)(a1 + 600) & 0xF;
    uint64_t v20 = *(void *)(a1 + 1256);
    if ((v20 & 0x1000) == 0)
    {
LABEL_100:
      if ((v20 & 0x2000) == 0) {
        goto LABEL_101;
      }
      goto LABEL_192;
    }
  }
  else if ((v19 & 0x1000) == 0)
  {
    goto LABEL_100;
  }
  *(unsigned char *)(a2 + 154) = *(void *)(a1 + 608) != 0;
  if ((v20 & 0x2000) == 0)
  {
LABEL_101:
    if ((v20 & 0x4000) == 0) {
      goto LABEL_102;
    }
    goto LABEL_193;
  }
LABEL_192:
  *(unsigned char *)(a2 + 155) = *(void *)(a1 + 616) != 0;
  if ((v20 & 0x4000) == 0)
  {
LABEL_102:
    if ((v20 & 0x8000) == 0) {
      goto LABEL_103;
    }
    goto LABEL_194;
  }
LABEL_193:
  *(unsigned char *)(a2 + 156) = *(void *)(a1 + 624) != 0;
  if ((v20 & 0x8000) == 0)
  {
LABEL_103:
    if ((v20 & 0x10000) == 0) {
      goto LABEL_104;
    }
    goto LABEL_195;
  }
LABEL_194:
  *(unsigned char *)(a2 + 157) = *(void *)(a1 + 632) != 0;
  if ((v20 & 0x10000) == 0)
  {
LABEL_104:
    if ((v20 & 0x20000) == 0) {
      goto LABEL_105;
    }
    goto LABEL_196;
  }
LABEL_195:
  *(unsigned char *)(a2 + 158) = *(void *)(a1 + 640) != 0;
  if ((v20 & 0x20000) == 0)
  {
LABEL_105:
    if ((v20 & 0x40000) == 0) {
      goto LABEL_106;
    }
    goto LABEL_197;
  }
LABEL_196:
  *(unsigned char *)(a2 + 159) = *(void *)(a1 + 648) != 0;
  if ((v20 & 0x40000) == 0)
  {
LABEL_106:
    if ((v20 & 0x80000) == 0) {
      goto LABEL_107;
    }
    goto LABEL_198;
  }
LABEL_197:
  *(unsigned char *)(a2 + 160) = *(void *)(a1 + 656) != 0;
  if ((v20 & 0x80000) == 0)
  {
LABEL_107:
    if ((v20 & 0x100000) == 0) {
      goto LABEL_108;
    }
    goto LABEL_199;
  }
LABEL_198:
  *(unsigned char *)(a2 + 161) = *(void *)(a1 + 664) != 0;
  if ((v20 & 0x100000) == 0)
  {
LABEL_108:
    if ((v20 & 0x200000) == 0) {
      goto LABEL_110;
    }
    goto LABEL_109;
  }
LABEL_199:
  *(_DWORD *)(a2 + 164) = *(void *)(a1 + 672);
  if ((v20 & 0x200000) != 0) {
LABEL_109:
  }
    *(unsigned char *)(a2 + 168) = *(void *)(a1 + 680) != 0;
LABEL_110:
  uint64_t v21 = v20;
  if ((v20 & 0x400000) != 0)
  {
    *(unsigned char *)(a2 + 169) = *(unsigned char *)(a1 + 688) & 0xF;
    uint64_t v21 = *(void *)(a1 + 1256);
    if ((v21 & 0x800000) == 0)
    {
LABEL_112:
      if ((v21 & 0x1000000) == 0) {
        goto LABEL_113;
      }
      goto LABEL_203;
    }
  }
  else if ((v20 & 0x800000) == 0)
  {
    goto LABEL_112;
  }
  *(_DWORD *)(a2 + 172) = *(void *)(a1 + 696);
  if ((v21 & 0x1000000) == 0)
  {
LABEL_113:
    if ((v21 & 0x2000000) == 0) {
      goto LABEL_114;
    }
    goto LABEL_204;
  }
LABEL_203:
  *(_WORD *)(a2 + 176) = *(void *)(a1 + 704);
  if ((v21 & 0x2000000) == 0)
  {
LABEL_114:
    if ((v21 & 0x4000000) == 0) {
      goto LABEL_115;
    }
    goto LABEL_205;
  }
LABEL_204:
  *(_DWORD *)(a2 + 180) = *(void *)(a1 + 712);
  if ((v21 & 0x4000000) == 0)
  {
LABEL_115:
    if ((v21 & 0x8000000) == 0) {
      goto LABEL_116;
    }
    goto LABEL_206;
  }
LABEL_205:
  *(_DWORD *)(a2 + 184) = *(void *)(a1 + 720);
  if ((v21 & 0x8000000) == 0)
  {
LABEL_116:
    if ((v21 & 0x10000000) == 0) {
      goto LABEL_117;
    }
    goto LABEL_207;
  }
LABEL_206:
  *(_DWORD *)(a2 + 188) = *(void *)(a1 + 728);
  if ((v21 & 0x10000000) == 0)
  {
LABEL_117:
    if ((v21 & 0x20000000) == 0) {
      goto LABEL_118;
    }
    goto LABEL_208;
  }
LABEL_207:
  *(_DWORD *)(a2 + 192) = *(void *)(a1 + 736);
  if ((v21 & 0x20000000) == 0)
  {
LABEL_118:
    if ((v21 & 0x40000000) == 0) {
      goto LABEL_119;
    }
    goto LABEL_209;
  }
LABEL_208:
  *(_DWORD *)(a2 + 196) = *(void *)(a1 + 744);
  if ((v21 & 0x40000000) == 0)
  {
LABEL_119:
    if ((v21 & 0x80000000) == 0) {
      goto LABEL_120;
    }
    goto LABEL_210;
  }
LABEL_209:
  *(_DWORD *)(a2 + 200) = *(void *)(a1 + 752);
  if ((v21 & 0x80000000) == 0)
  {
LABEL_120:
    if ((v21 & 0x100000000) == 0) {
      goto LABEL_121;
    }
    goto LABEL_211;
  }
LABEL_210:
  *(_DWORD *)(a2 + 204) = *(void *)(a1 + 760);
  if ((v21 & 0x100000000) == 0)
  {
LABEL_121:
    if ((v21 & 0x200000000) == 0) {
      goto LABEL_123;
    }
    goto LABEL_122;
  }
LABEL_211:
  *(_DWORD *)(a2 + 208) = *(void *)(a1 + 768);
  if ((v21 & 0x200000000) != 0) {
LABEL_122:
  }
    *(unsigned char *)(a2 + 212) = *(void *)(a1 + 776) != 0;
LABEL_123:
  int v22 = v2 & 1;
  int v80 = v16 & 1;
  if ((v21 & 0x400000000) != 0) {
    *(unsigned char *)(a2 + 213) = *(void *)(a1 + 784) != 0;
  }
  unint64_t v23 = v3 & 2;
  unint64_t v24 = v3 & 4;
  unint64_t v25 = v3 & 8;
  unint64_t v26 = v3 & 0x10;
  unint64_t v27 = v3 & 0x20;
  unint64_t v28 = v3 & 0x40;
  unint64_t v29 = v4 & 0x80;
  unint64_t v30 = v4 & 0x100;
  unint64_t v53 = v11 & 0x2000000000;
  unint64_t v54 = v11 & 0x4000000000;
  unint64_t v55 = v11 & 0x8000000000;
  unint64_t v56 = v11 & 0x10000000000;
  unint64_t v57 = v11 & 0x20000000000;
  unint64_t v58 = v11 & 0x40000000000;
  unint64_t v34 = v11 & 0x80000000000;
  unint64_t v59 = v12 & 0x100000000000;
  unint64_t v60 = v12 & 0x200000000000;
  unint64_t v61 = v12 & 0x400000000000;
  unint64_t v62 = v12 & 0x800000000000;
  unint64_t v35 = v12 & 0x1000000000000;
  unint64_t v36 = v12 & 0x2000000000000;
  if ((v21 & 0x800000000) != 0) {
    *(_DWORD *)(a2 + 216) = *(void *)(a1 + 792);
  }
  HIDWORD(v17) = BYTE4(v9) & 1;
  unint64_t v33 = v5 & 0x800;
  unint64_t v32 = v5 & 0x400;
  unint64_t v31 = v5 & 0x200;
  unint64_t v38 = v5 & 0x1000;
  unint64_t v39 = v5 & 0x2000;
  unint64_t v40 = v5 & 0x4000;
  unint64_t v41 = (unsigned __int16)v6 & 0x8000;
  unint64_t v42 = v6 & 0x10000;
  unint64_t v43 = v6 & 0x20000;
  unint64_t v44 = v6 & 0x40000;
  unint64_t v45 = v6 & 0x80000;
  unint64_t v46 = v6 & 0x100000;
  unint64_t v49 = v8 & 0x1000000;
  unint64_t v50 = v8 & 0x2000000;
  unint64_t v51 = v8 & 0x4000000;
  unint64_t v52 = v8 & 0x8000000;
  unint64_t v47 = v82 & 0x200000;
  unint64_t v48 = v82 & 0x400000;
  LODWORD(v33) = (v23 >> 1)
               + v22
               + (v24 >> 2)
               + (v25 >> 3)
               + (v26 >> 4)
               + (v27 >> 5)
               + (v28 >> 6)
               + (v29 >> 7)
               + (v30 >> 8)
               + (v31 >> 9)
               + (v32 >> 10)
               + (v33 >> 11)
               + (v38 >> 12)
               + (v39 >> 13)
               + (v40 >> 14)
               + (v41 >> 15)
               + (v42 >> 16)
               + (v43 >> 17)
               + (v44 >> 18)
               + (v45 >> 19)
               + (v46 >> 20)
               + (v47 >> 21)
               + (v48 >> 22)
               + ((v8 & 0x800000) >> 23)
               + (v49 >> 24)
               + (v50 >> 25)
               + (v51 >> 26)
               + (v52 >> 27)
               + ((v8 & 0x10000000) >> 28)
               + ((v9 & 0x20000000) >> 29)
               + ((v9 & 0x40000000) >> 30)
               + (v9 >> 31)
               + HIDWORD(v17)
               + ((v9 & 0x200000000) >> 33)
               + ((v9 & 0x400000000) >> 34)
               + ((v81 & 0x800000000) >> 35)
               + ((v81 & 0x1000000000) >> 36)
               + (v53 >> 37)
               + (v54 >> 38)
               + (v55 >> 39)
               + (v56 >> 40)
               + (v57 >> 41)
               + (v58 >> 42);
  unint64_t v63 = v13 & 0x4000000000000;
  unint64_t v64 = v13 & 0x8000000000000;
  unint64_t v65 = v14 & 0x10000000000000;
  unint64_t v66 = v14 & 0x20000000000000;
  unint64_t v67 = v14 & 0x40000000000000;
  unint64_t v68 = v14 & 0x80000000000000;
  unint64_t v69 = v14 & 0x100000000000000;
  unint64_t v70 = v14 & 0x200000000000000;
  unint64_t v71 = v14 & 0x400000000000000;
  unint64_t v72 = v15 & 0x1000000000000000;
  unint64_t v73 = v15 & 0x2000000000000000;
  unint64_t v74 = v15 & 0x4000000000000000;
  unint64_t v75 = v17 & 2;
  unint64_t v76 = v20 & 0x20000;
  unint64_t v77 = v20 & 0x10000;
  unint64_t v78 = (unsigned __int16)v20 & 0x8000;
  unint64_t v79 = v20 & 0x4000;
  LODWORD(v33) = v33
               + (v34 >> 43)
               + (v59 >> 44)
               + (v60 >> 45)
               + (v61 >> 46)
               + (v62 >> 47)
               + HIWORD(v35)
               + (v36 >> 49)
               + (v63 >> 50)
               + (v64 >> 51)
               + (v65 >> 52)
               + (v66 >> 53)
               + (v67 >> 54)
               + (v68 >> 55)
               + HIBYTE(v69)
               + (v70 >> 57)
               + (v71 >> 58)
               + (v15 >> 63)
               + ((v15 & 0x800000000000000) >> 59)
               + (v72 >> 60)
               + (v73 >> 61)
               + (v74 >> 62)
               + v80
               + (v75 >> 1)
               + ((unint64_t)(v17 & 4) >> 2)
               + ((unint64_t)(v18 & 8) >> 3)
               + ((unint64_t)(v18 & 0x10) >> 4)
               + ((unint64_t)(v18 & 0x20) >> 5)
               + ((unint64_t)(v18 & 0x40) >> 6)
               + ((unint64_t)(v18 & 0x80) >> 7)
               + ((unint64_t)(v18 & 0x100) >> 8)
               + ((unint64_t)(v18 & 0x200) >> 9)
               + ((unint64_t)(v18 & 0x400) >> 10)
               + ((unint64_t)(v19 & 0x800) >> 11)
               + ((unint64_t)(v20 & 0x1000) >> 12)
               + ((unint64_t)(v20 & 0x2000) >> 13)
               + (v79 >> 14)
               + (v78 >> 15)
               + (v77 >> 16)
               + (v76 >> 17);
  return v33
       + ((v20 & 0x40000uLL) >> 18)
       + ((v20 & 0x80000uLL) >> 19)
       + ((v20 & 0x100000uLL) >> 20)
       + ((v20 & 0x200000uLL) >> 21)
       + ((v20 & 0x400000uLL) >> 22)
       + ((v21 & 0x800000uLL) >> 23)
       + ((v21 & 0x1000000) >> 24)
       + ((v21 & 0x2000000) >> 25)
       + ((v21 & 0x4000000) >> 26)
       + ((v21 & 0x8000000) >> 27)
       + ((v21 & 0x10000000) >> 28)
       + ((v21 & 0x20000000) >> 29)
       + ((v21 & 0x40000000) >> 30)
       + (v21 >> 31)
       + (BYTE4(v21) & 1)
       + ((v21 & 0x200000000uLL) >> 33)
       + ((v21 & 0x400000000uLL) >> 34)
       + ((v21 & 0x800000000uLL) >> 35);
}

unint64_t sub_1CBF1FDD0(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 1248);
  unint64_t v3 = v2;
  if (v2)
  {
    *(unsigned char *)a2 = *(unsigned char *)a1 & 1;
    unint64_t v3 = *(void *)(a1 + 1248);
    if ((v3 & 2) == 0)
    {
LABEL_3:
      if ((v3 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_112;
    }
  }
  else if ((v2 & 2) == 0)
  {
    goto LABEL_3;
  }
  *(_WORD *)a2 = *(void *)(a1 + 8);
  if ((v3 & 4) == 0)
  {
LABEL_4:
    if ((v3 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_113;
  }
LABEL_112:
  *(_WORD *)a2 = *(_WORD *)(a1 + 16) & 0x1FF;
  if ((v3 & 8) == 0)
  {
LABEL_5:
    if ((v3 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_114;
  }
LABEL_113:
  *(_WORD *)a2 = *(_WORD *)(a1 + 24) & 0x1FF;
  if ((v3 & 0x10) == 0)
  {
LABEL_6:
    if ((v3 & 0x20) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
LABEL_114:
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 32) & 0x1FFFF;
  if ((v3 & 0x20) != 0) {
LABEL_7:
  }
    *(_WORD *)a2 = *(_WORD *)(a1 + 40) & 0x1FFF;
LABEL_8:
  unint64_t v4 = v3;
  if ((v3 & 0x40) != 0)
  {
    *(unsigned char *)a2 = *(unsigned char *)(a1 + 48) & 0x7F;
    unint64_t v4 = *(void *)(a1 + 1248);
  }
  if ((v4 & 0x80) != 0) {
    *(_DWORD *)a2 = *(void *)(a1 + 56);
  }
  unint64_t v5 = v4;
  if ((v4 & 0x100) != 0)
  {
    *(unsigned char *)(a2 + 4) = *(unsigned char *)(a1 + 64) & 0xF;
    unint64_t v5 = *(void *)(a1 + 1248);
    if ((v5 & 0x200) == 0)
    {
LABEL_14:
      if ((v5 & 0x400) == 0) {
        goto LABEL_15;
      }
      goto LABEL_118;
    }
  }
  else if ((v4 & 0x200) == 0)
  {
    goto LABEL_14;
  }
  *(_DWORD *)(a2 + 8) = *(void *)(a1 + 72);
  if ((v5 & 0x400) == 0)
  {
LABEL_15:
    if ((v5 & 0x800) == 0) {
      goto LABEL_16;
    }
    goto LABEL_119;
  }
LABEL_118:
  *(_DWORD *)(a2 + 12) = *(void *)(a1 + 80);
  if ((v5 & 0x800) == 0)
  {
LABEL_16:
    if ((v5 & 0x1000) == 0) {
      goto LABEL_17;
    }
    goto LABEL_120;
  }
LABEL_119:
  *(unsigned char *)(a2 + 16) = *(void *)(a1 + 88) != 0;
  if ((v5 & 0x1000) == 0)
  {
LABEL_17:
    if ((v5 & 0x2000) == 0) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
LABEL_120:
  *(_DWORD *)(a2 + 20) = *(void *)(a1 + 96);
  if ((v5 & 0x2000) != 0) {
LABEL_18:
  }
    *(_DWORD *)(a2 + 24) = *(void *)(a1 + 104);
LABEL_19:
  unint64_t v6 = v5;
  if ((v5 & 0x4000) != 0)
  {
    *(unsigned char *)(a2 + 28) = *(unsigned char *)(a1 + 112) & 1;
    unint64_t v6 = *(void *)(a1 + 1248);
    if ((v6 & 0x8000) == 0)
    {
LABEL_21:
      if ((v6 & 0x10000) == 0) {
        goto LABEL_22;
      }
      goto LABEL_124;
    }
  }
  else if ((v5 & 0x8000) == 0)
  {
    goto LABEL_21;
  }
  *(_WORD *)(a2 + 28) = *(void *)(a1 + 120);
  if ((v6 & 0x10000) == 0)
  {
LABEL_22:
    if ((v6 & 0x20000) == 0) {
      goto LABEL_23;
    }
    goto LABEL_125;
  }
LABEL_124:
  *(_WORD *)(a2 + 28) = *(_WORD *)(a1 + 128) & 0x1FF;
  if ((v6 & 0x20000) == 0)
  {
LABEL_23:
    if ((v6 & 0x40000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_126;
  }
LABEL_125:
  *(_WORD *)(a2 + 28) = *(_WORD *)(a1 + 136) & 0x1FF;
  if ((v6 & 0x40000) == 0)
  {
LABEL_24:
    if ((v6 & 0x80000) == 0) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }
LABEL_126:
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 144) & 0x1FFFF;
  if ((v6 & 0x80000) != 0) {
LABEL_25:
  }
    *(_WORD *)(a2 + 28) = *(_WORD *)(a1 + 152) & 0x1FFF;
LABEL_26:
  unint64_t v7 = v6;
  if ((v6 & 0x100000) != 0)
  {
    *(unsigned char *)(a2 + 28) = *(unsigned char *)(a1 + 160) & 0x7F;
    unint64_t v7 = *(void *)(a1 + 1248);
  }
  if ((v7 & 0x200000) != 0) {
    *(_DWORD *)(a2 + 28) = *(void *)(a1 + 168);
  }
  unint64_t v8 = v7;
  if ((v7 & 0x400000) != 0)
  {
    *(unsigned char *)(a2 + 32) = *(unsigned char *)(a1 + 176) & 0xF;
    unint64_t v8 = *(void *)(a1 + 1248);
    if ((v8 & 0x800000) == 0)
    {
LABEL_32:
      if ((v8 & 0x1000000) == 0) {
        goto LABEL_33;
      }
      goto LABEL_130;
    }
  }
  else if ((v7 & 0x800000) == 0)
  {
    goto LABEL_32;
  }
  *(_DWORD *)(a2 + 36) = *(void *)(a1 + 184);
  if ((v8 & 0x1000000) == 0)
  {
LABEL_33:
    if ((v8 & 0x2000000) == 0) {
      goto LABEL_34;
    }
    goto LABEL_131;
  }
LABEL_130:
  *(_DWORD *)(a2 + 40) = *(void *)(a1 + 192);
  if ((v8 & 0x2000000) == 0)
  {
LABEL_34:
    if ((v8 & 0x4000000) == 0) {
      goto LABEL_36;
    }
    goto LABEL_35;
  }
LABEL_131:
  *(unsigned char *)(a2 + 44) = *(void *)(a1 + 200) != 0;
  if ((v8 & 0x4000000) != 0) {
LABEL_35:
  }
    *(_DWORD *)(a2 + 48) = *(void *)(a1 + 208);
LABEL_36:
  int v73 = v7;
  if ((v8 & 0x8000000) != 0) {
    *(unsigned char *)(a2 + 52) = *(void *)(a1 + 216) != 0;
  }
  unint64_t v9 = v8;
  if ((v8 & 0x10000000) != 0)
  {
    *(unsigned char *)(a2 + 56) = *(unsigned char *)(a1 + 224) & 1;
    unint64_t v9 = *(void *)(a1 + 1248);
    if ((v9 & 0x20000000) == 0)
    {
LABEL_40:
      if ((v9 & 0x40000000) == 0) {
        goto LABEL_41;
      }
      goto LABEL_135;
    }
  }
  else if ((v8 & 0x20000000) == 0)
  {
    goto LABEL_40;
  }
  *(_WORD *)(a2 + 56) = *(void *)(a1 + 232);
  if ((v9 & 0x40000000) == 0)
  {
LABEL_41:
    if ((v9 & 0x80000000) == 0) {
      goto LABEL_42;
    }
    goto LABEL_136;
  }
LABEL_135:
  *(_WORD *)(a2 + 56) = *(_WORD *)(a1 + 240) & 0x1FF;
  if ((v9 & 0x80000000) == 0)
  {
LABEL_42:
    if ((v9 & 0x100000000) == 0) {
      goto LABEL_43;
    }
    goto LABEL_137;
  }
LABEL_136:
  *(_WORD *)(a2 + 56) = *(_WORD *)(a1 + 248) & 0x1FF;
  if ((v9 & 0x100000000) == 0)
  {
LABEL_43:
    if ((v9 & 0x200000000) == 0) {
      goto LABEL_45;
    }
    goto LABEL_44;
  }
LABEL_137:
  *(_DWORD *)(a2 + 56) = *(_DWORD *)(a1 + 256) & 0x1FFFF;
  if ((v9 & 0x200000000) != 0) {
LABEL_44:
  }
    *(_WORD *)(a2 + 56) = *(_WORD *)(a1 + 264) & 0x1FFF;
LABEL_45:
  unint64_t v10 = v9;
  if ((v9 & 0x400000000) != 0)
  {
    *(unsigned char *)(a2 + 56) = *(unsigned char *)(a1 + 272) & 0x7F;
    unint64_t v10 = *(void *)(a1 + 1248);
  }
  if ((v10 & 0x800000000) != 0) {
    *(_DWORD *)(a2 + 56) = *(void *)(a1 + 280);
  }
  unint64_t v11 = v10;
  if ((v10 & 0x1000000000) != 0)
  {
    *(unsigned char *)(a2 + 60) = *(unsigned char *)(a1 + 288) & 0xF;
    unint64_t v11 = *(void *)(a1 + 1248);
    if ((v11 & 0x2000000000) == 0)
    {
LABEL_51:
      if ((v11 & 0x4000000000) == 0) {
        goto LABEL_52;
      }
      goto LABEL_141;
    }
  }
  else if ((v10 & 0x2000000000) == 0)
  {
    goto LABEL_51;
  }
  *(_DWORD *)(a2 + 64) = *(void *)(a1 + 296);
  if ((v11 & 0x4000000000) == 0)
  {
LABEL_52:
    if ((v11 & 0x8000000000) == 0) {
      goto LABEL_53;
    }
    goto LABEL_142;
  }
LABEL_141:
  *(_DWORD *)(a2 + 68) = *(void *)(a1 + 304);
  if ((v11 & 0x8000000000) == 0)
  {
LABEL_53:
    if ((v11 & 0x10000000000) == 0) {
      goto LABEL_54;
    }
    goto LABEL_143;
  }
LABEL_142:
  *(unsigned char *)(a2 + 72) = *(void *)(a1 + 312) != 0;
  if ((v11 & 0x10000000000) == 0)
  {
LABEL_54:
    if ((v11 & 0x20000000000) == 0) {
      goto LABEL_55;
    }
    goto LABEL_144;
  }
LABEL_143:
  *(_DWORD *)(a2 + 76) = *(void *)(a1 + 320);
  if ((v11 & 0x20000000000) == 0)
  {
LABEL_55:
    if ((v11 & 0x40000000000) == 0) {
      goto LABEL_57;
    }
    goto LABEL_56;
  }
LABEL_144:
  *(unsigned char *)(a2 + 80) = *(void *)(a1 + 328) != 0;
  if ((v11 & 0x40000000000) != 0) {
LABEL_56:
  }
    *(unsigned char *)(a2 + 81) = *(void *)(a1 + 336) != 0;
LABEL_57:
  unint64_t v12 = v11;
  if ((v11 & 0x80000000000) != 0)
  {
    *(unsigned char *)(a2 + 84) = *(unsigned char *)(a1 + 344) & 1;
    unint64_t v12 = *(void *)(a1 + 1248);
    if ((v12 & 0x100000000000) == 0)
    {
LABEL_59:
      if ((v12 & 0x200000000000) == 0) {
        goto LABEL_60;
      }
      goto LABEL_148;
    }
  }
  else if ((v11 & 0x100000000000) == 0)
  {
    goto LABEL_59;
  }
  *(_WORD *)(a2 + 84) = *(void *)(a1 + 352);
  if ((v12 & 0x200000000000) == 0)
  {
LABEL_60:
    if ((v12 & 0x400000000000) == 0) {
      goto LABEL_61;
    }
    goto LABEL_149;
  }
LABEL_148:
  *(_WORD *)(a2 + 84) = *(_WORD *)(a1 + 360) & 0x1FF;
  if ((v12 & 0x400000000000) == 0)
  {
LABEL_61:
    if ((v12 & 0x800000000000) == 0) {
      goto LABEL_62;
    }
    goto LABEL_150;
  }
LABEL_149:
  *(_WORD *)(a2 + 84) = *(_WORD *)(a1 + 368) & 0x1FF;
  if ((v12 & 0x800000000000) == 0)
  {
LABEL_62:
    if ((v12 & 0x1000000000000) == 0) {
      goto LABEL_64;
    }
    goto LABEL_63;
  }
LABEL_150:
  *(_DWORD *)(a2 + 84) = *(_DWORD *)(a1 + 376) & 0x1FFFF;
  if ((v12 & 0x1000000000000) != 0) {
LABEL_63:
  }
    *(_WORD *)(a2 + 84) = *(_WORD *)(a1 + 384) & 0x1FFF;
LABEL_64:
  unint64_t v13 = v12;
  if ((v12 & 0x2000000000000) != 0)
  {
    *(unsigned char *)(a2 + 84) = *(unsigned char *)(a1 + 392) & 0x7F;
    unint64_t v13 = *(void *)(a1 + 1248);
  }
  if ((v13 & 0x4000000000000) != 0) {
    *(_DWORD *)(a2 + 84) = *(void *)(a1 + 400);
  }
  unint64_t v14 = v13;
  if ((v13 & 0x8000000000000) != 0)
  {
    *(unsigned char *)(a2 + 88) = *(unsigned char *)(a1 + 408) & 0xF;
    unint64_t v14 = *(void *)(a1 + 1248);
    if ((v14 & 0x10000000000000) == 0)
    {
LABEL_70:
      if ((v14 & 0x20000000000000) == 0) {
        goto LABEL_71;
      }
      goto LABEL_154;
    }
  }
  else if ((v13 & 0x10000000000000) == 0)
  {
    goto LABEL_70;
  }
  *(_DWORD *)(a2 + 92) = *(void *)(a1 + 416);
  if ((v14 & 0x20000000000000) == 0)
  {
LABEL_71:
    if ((v14 & 0x40000000000000) == 0) {
      goto LABEL_72;
    }
    goto LABEL_155;
  }
LABEL_154:
  *(_DWORD *)(a2 + 96) = *(void *)(a1 + 424);
  if ((v14 & 0x40000000000000) == 0)
  {
LABEL_72:
    if ((v14 & 0x80000000000000) == 0) {
      goto LABEL_73;
    }
    goto LABEL_156;
  }
LABEL_155:
  *(unsigned char *)(a2 + 100) = *(void *)(a1 + 432) != 0;
  if ((v14 & 0x80000000000000) == 0)
  {
LABEL_73:
    if ((v14 & 0x100000000000000) == 0) {
      goto LABEL_74;
    }
    goto LABEL_157;
  }
LABEL_156:
  *(_DWORD *)(a2 + 104) = *(void *)(a1 + 440);
  if ((v14 & 0x100000000000000) == 0)
  {
LABEL_74:
    if ((v14 & 0x200000000000000) == 0) {
      goto LABEL_75;
    }
    goto LABEL_158;
  }
LABEL_157:
  *(unsigned char *)(a2 + 108) = *(void *)(a1 + 448) != 0;
  if ((v14 & 0x200000000000000) == 0)
  {
LABEL_75:
    if ((v14 & 0x400000000000000) == 0) {
      goto LABEL_77;
    }
    goto LABEL_76;
  }
LABEL_158:
  *(_DWORD *)(a2 + 112) = *(void *)(a1 + 456);
  if ((v14 & 0x400000000000000) != 0) {
LABEL_76:
  }
    *(_DWORD *)(a2 + 116) = *(void *)(a1 + 464);
LABEL_77:
  unint64_t v72 = v10;
  unint64_t v15 = v14;
  if ((v14 & 0x800000000000000) != 0)
  {
    *(unsigned char *)(a2 + 120) = *(unsigned char *)(a1 + 472) & 0xF;
    unint64_t v15 = *(void *)(a1 + 1248);
  }
  unint64_t v16 = v15;
  if ((v15 & 0x1000000000000000) != 0)
  {
    *(unsigned char *)(a2 + 121) = *(unsigned char *)(a1 + 480) & 0xF;
    unint64_t v16 = *(void *)(a1 + 1248);
    if ((v16 & 0x2000000000000000) == 0)
    {
LABEL_81:
      if ((v16 & 0x4000000000000000) == 0) {
        goto LABEL_82;
      }
LABEL_162:
      *(unsigned char *)(a2 + 123) = *(void *)(a1 + 496) != 0;
      if ((v16 & 0x8000000000000000) == 0) {
        goto LABEL_83;
      }
      goto LABEL_163;
    }
  }
  else if ((v15 & 0x2000000000000000) == 0)
  {
    goto LABEL_81;
  }
  *(unsigned char *)(a2 + 122) = *(void *)(a1 + 488) != 0;
  if ((v16 & 0x4000000000000000) != 0) {
    goto LABEL_162;
  }
LABEL_82:
  if ((v16 & 0x8000000000000000) == 0) {
    goto LABEL_83;
  }
LABEL_163:
  *(unsigned char *)(a2 + 124) = *(void *)(a1 + 504) != 0;
LABEL_83:
  uint64_t v17 = *(void *)(a1 + 1256);
  if (v17)
  {
    *(unsigned char *)(a2 + 125) = *(void *)(a1 + 512) != 0;
    if ((v17 & 2) == 0)
    {
LABEL_85:
      if ((v17 & 4) == 0) {
        goto LABEL_86;
      }
      goto LABEL_166;
    }
  }
  else if ((v17 & 2) == 0)
  {
    goto LABEL_85;
  }
  *(unsigned char *)(a2 + 126) = *(void *)(a1 + 520) != 0;
  if ((v17 & 4) == 0)
  {
LABEL_86:
    if ((v17 & 8) == 0) {
      goto LABEL_87;
    }
    goto LABEL_167;
  }
LABEL_166:
  *(unsigned char *)(a2 + 127) = *(void *)(a1 + 528) != 0;
  if ((v17 & 8) == 0)
  {
LABEL_87:
    if ((v17 & 0x10) == 0) {
      goto LABEL_88;
    }
    goto LABEL_168;
  }
LABEL_167:
  *(unsigned char *)(a2 + 128) = *(void *)(a1 + 536) != 0;
  if ((v17 & 0x10) == 0)
  {
LABEL_88:
    if ((v17 & 0x20) == 0) {
      goto LABEL_89;
    }
    goto LABEL_169;
  }
LABEL_168:
  *(unsigned char *)(a2 + 129) = *(void *)(a1 + 544) != 0;
  if ((v17 & 0x20) == 0)
  {
LABEL_89:
    if ((v17 & 0x40) == 0) {
      goto LABEL_90;
    }
    goto LABEL_170;
  }
LABEL_169:
  *(unsigned char *)(a2 + 130) = *(void *)(a1 + 552) != 0;
  if ((v17 & 0x40) == 0)
  {
LABEL_90:
    if ((v17 & 0x80) == 0) {
      goto LABEL_92;
    }
    goto LABEL_91;
  }
LABEL_170:
  *(_DWORD *)(a2 + 132) = *(void *)(a1 + 560);
  if ((v17 & 0x80) != 0) {
LABEL_91:
  }
    *(unsigned char *)(a2 + 136) = *(void *)(a1 + 568) != 0;
LABEL_92:
  LODWORD(v18) = v17;
  if ((v17 & 0x100) != 0)
  {
    *(unsigned char *)(a2 + 137) = *(unsigned char *)(a1 + 576) & 0xF;
    uint64_t v18 = *(void *)(a1 + 1256);
    if ((v18 & 0x200) == 0)
    {
LABEL_94:
      if ((v18 & 0x400) == 0) {
        goto LABEL_95;
      }
      goto LABEL_174;
    }
  }
  else if ((v17 & 0x200) == 0)
  {
    goto LABEL_94;
  }
  *(_DWORD *)(a2 + 140) = *(void *)(a1 + 584);
  if ((v18 & 0x400) == 0)
  {
LABEL_95:
    if ((v18 & 0x800) == 0) {
      goto LABEL_96;
    }
    goto LABEL_175;
  }
LABEL_174:
  *(_WORD *)(a2 + 144) = *(void *)(a1 + 592);
  if ((v18 & 0x800) == 0)
  {
LABEL_96:
    if ((v18 & 0x1000) == 0) {
      goto LABEL_97;
    }
    goto LABEL_176;
  }
LABEL_175:
  *(_DWORD *)(a2 + 148) = *(void *)(a1 + 600);
  if ((v18 & 0x1000) == 0)
  {
LABEL_97:
    if ((v18 & 0x2000) == 0) {
      goto LABEL_98;
    }
    goto LABEL_177;
  }
LABEL_176:
  *(_DWORD *)(a2 + 152) = *(void *)(a1 + 608);
  if ((v18 & 0x2000) == 0)
  {
LABEL_98:
    if ((v18 & 0x4000) == 0) {
      goto LABEL_99;
    }
    goto LABEL_178;
  }
LABEL_177:
  *(_DWORD *)(a2 + 156) = *(void *)(a1 + 616);
  if ((v18 & 0x4000) == 0)
  {
LABEL_99:
    if ((v18 & 0x8000) == 0) {
      goto LABEL_100;
    }
    goto LABEL_179;
  }
LABEL_178:
  *(_DWORD *)(a2 + 160) = *(void *)(a1 + 624);
  if ((v18 & 0x8000) == 0)
  {
LABEL_100:
    if ((v18 & 0x10000) == 0) {
      goto LABEL_101;
    }
    goto LABEL_180;
  }
LABEL_179:
  *(_DWORD *)(a2 + 164) = *(void *)(a1 + 632);
  if ((v18 & 0x10000) == 0)
  {
LABEL_101:
    if ((v18 & 0x20000) == 0) {
      goto LABEL_102;
    }
    goto LABEL_181;
  }
LABEL_180:
  *(_DWORD *)(a2 + 168) = *(void *)(a1 + 640);
  if ((v18 & 0x20000) == 0)
  {
LABEL_102:
    if ((v18 & 0x40000) == 0) {
      goto LABEL_103;
    }
    goto LABEL_182;
  }
LABEL_181:
  *(_DWORD *)(a2 + 172) = *(void *)(a1 + 648);
  if ((v18 & 0x40000) == 0)
  {
LABEL_103:
    if ((v18 & 0x80000) == 0) {
      goto LABEL_105;
    }
    goto LABEL_104;
  }
LABEL_182:
  *(_DWORD *)(a2 + 176) = *(void *)(a1 + 656);
  if ((v18 & 0x80000) != 0) {
LABEL_104:
  }
    *(unsigned char *)(a2 + 180) = *(void *)(a1 + 664) != 0;
LABEL_105:
  if ((v18 & 0x100000) != 0) {
    *(unsigned char *)(a2 + 181) = *(void *)(a1 + 672) != 0;
  }
  unint64_t v19 = v4 & 0x80;
  unint64_t v20 = v4 & 0x100;
  unint64_t v21 = v5 & 0x200;
  unint64_t v22 = v5 & 0x400;
  unint64_t v23 = v5 & 0x800;
  unint64_t v24 = v5 & 0x1000;
  unint64_t v25 = v5 & 0x2000;
  unint64_t v26 = v5 & 0x4000;
  unint64_t v50 = v11 & 0x2000000000;
  unint64_t v51 = v11 & 0x4000000000;
  unint64_t v52 = v11 & 0x8000000000;
  unint64_t v53 = v11 & 0x10000000000;
  unint64_t v54 = v11 & 0x20000000000;
  unint64_t v55 = v11 & 0x40000000000;
  unint64_t v27 = v11 & 0x80000000000;
  unint64_t v56 = v12 & 0x100000000000;
  unint64_t v57 = v12 & 0x200000000000;
  unint64_t v58 = v12 & 0x400000000000;
  unint64_t v59 = v12 & 0x800000000000;
  unint64_t v60 = v12 & 0x1000000000000;
  unint64_t v61 = v12 & 0x2000000000000;
  unint64_t v64 = v14 & 0x10000000000000;
  unint64_t v65 = v14 & 0x20000000000000;
  unint64_t v66 = v14 & 0x40000000000000;
  unint64_t v67 = v14 & 0x80000000000000;
  unint64_t v68 = v14 & 0x100000000000000;
  unint64_t v69 = v14 & 0x200000000000000;
  unint64_t v70 = v14 & 0x400000000000000;
  unint64_t v71 = v14 & 0x800000000000000;
  if ((v18 & 0x200000) != 0) {
    *(_DWORD *)(a2 + 184) = *(void *)(a1 + 680);
  }
  int v30 = ((v3 & 2) >> 1)
      + (v2 & 1)
      + ((v3 & 4) >> 2)
      + ((v3 & 8) >> 3)
      + ((v3 & 0x10) >> 4)
      + ((v3 & 0x20) >> 5)
      + ((v3 & 0x40) >> 6)
      + (v19 >> 7)
      + (v20 >> 8)
      + (v21 >> 9)
      + (v22 >> 10);
  unint64_t v31 = v25 >> 13;
  unint64_t v32 = v26 >> 14;
  unint64_t v28 = v9 & 0x20000000;
  unint64_t v43 = v8 & 0x800000;
  unint64_t v44 = v8 & 0x1000000;
  unint64_t v45 = v8 & 0x2000000;
  unint64_t v46 = v8 & 0x4000000;
  unint64_t v47 = v8 & 0x8000000;
  unint64_t v48 = v8 & 0x10000000;
  unint64_t v62 = v13 & 0x4000000000000;
  unint64_t v63 = v13 & 0x8000000000000;
  unint64_t v35 = (unsigned __int16)v6 & 0x8000;
  unint64_t v36 = v6 & 0x10000;
  unint64_t v37 = v6 & 0x20000;
  unint64_t v38 = v6 & 0x40000;
  unint64_t v39 = v6 & 0x80000;
  unint64_t v40 = v6 & 0x100000;
  unint64_t v41 = v73 & 0x200000;
  unint64_t v42 = v73 & 0x400000;
  unint64_t v49 = v72 & 0x800000000;
  int v29 = BYTE4(v9) & 1;
  int v33 = v30
      + (v23 >> 11)
      + (v24 >> 12)
      + v31
      + v32
      + (v35 >> 15)
      + (v36 >> 16)
      + (v37 >> 17)
      + (v38 >> 18)
      + (v39 >> 19)
      + (v40 >> 20)
      + (v41 >> 21)
      + (v42 >> 22)
      + (v43 >> 23)
      + (v44 >> 24)
      + (v45 >> 25)
      + (v46 >> 26)
      + (v47 >> 27)
      + (v48 >> 28)
      + (v28 >> 29)
      + ((v9 & 0x40000000) >> 30)
      + (v9 >> 31)
      + v29
      + ((v9 & 0x200000000) >> 33)
      + ((v9 & 0x400000000) >> 34)
      + (v49 >> 35)
      + ((v72 & 0x1000000000) >> 36)
      + (v50 >> 37)
      + (v51 >> 38)
      + (v52 >> 39)
      + (v53 >> 40)
      + (v54 >> 41)
      + (v55 >> 42)
      + (v27 >> 43)
      + (v56 >> 44)
      + (v57 >> 45)
      + (v58 >> 46)
      + (v59 >> 47)
      + HIWORD(v60)
      + (v61 >> 49)
      + (v62 >> 50)
      + (v63 >> 51)
      + (v64 >> 52)
      + (v65 >> 53)
      + (v66 >> 54);
  return v33
       + (v67 >> 55)
       + HIBYTE(v68)
       + (v69 >> 57)
       + (v70 >> 58)
       + (v71 >> 59)
       + ((v15 & 0x1000000000000000) >> 60)
       + (v16 >> 63)
       + ((v16 & 0x2000000000000000) >> 61)
       + ((v16 & 0x4000000000000000) >> 62)
       + (v17 & 1)
       + ((unint64_t)(v17 & 2) >> 1)
       + ((unint64_t)(v17 & 4) >> 2)
       + ((unint64_t)(v17 & 8) >> 3)
       + ((unint64_t)(v17 & 0x10) >> 4)
       + ((unint64_t)(v17 & 0x20) >> 5)
       + ((unint64_t)(v17 & 0x40) >> 6)
       + ((unint64_t)(v17 & 0x80) >> 7)
       + ((unint64_t)(v17 & 0x100) >> 8)
       + ((unint64_t)(v18 & 0x200) >> 9)
       + ((unint64_t)(v18 & 0x400) >> 10)
       + ((unint64_t)(v18 & 0x800) >> 11)
       + ((unint64_t)(v18 & 0x1000) >> 12)
       + ((unint64_t)(v18 & 0x2000) >> 13)
       + ((unint64_t)(v18 & 0x4000) >> 14)
       + ((unint64_t)((unsigned __int16)v18 & 0x8000) >> 15)
       + ((v18 & 0x10000uLL) >> 16)
       + ((v18 & 0x20000uLL) >> 17)
       + ((v18 & 0x40000uLL) >> 18)
       + ((v18 & 0x80000uLL) >> 19)
       + ((v18 & 0x100000uLL) >> 20)
       + ((v18 & 0x200000uLL) >> 21);
}

void sub_1CBF20A68(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  v37[0] = a1;
  unsigned int v36 = 10;
  int v7 = 1;
  do
  {
    while (1)
    {
      unsigned int v35 = v7 - 1;
      unint64_t v8 = (int *)(a2 + 4 * v37[v7 - 1]);
      int v9 = *v8;
      if (*v8 < 0)
      {
        int v24 = ~v9;
        unint64_t v25 = (*(uint64_t (**)(uint64_t, void))(*(void *)a4 + 8))(a4, ~v9) & ~v5;
        if ((v25 & v6) != 0)
        {
          uint64_t v26 = v6;
        }
        else
        {
          uint64_t v26 = v5;
          while (2)
          {
            uint64_t v5 = v26;
            while (1)
            {
              if (!v25)
              {
                uint64_t v26 = v6;
                goto LABEL_58;
              }
              uint64_t v27 = 1 << __clz(__rbit64(v25));
              if ((v27 & v6) == 0) {
                break;
              }
              if ((v27 & v26) != 0) {
                uint64_t v28 = ~v27;
              }
              else {
                uint64_t v28 = -1;
              }
              v25 &= v28;
              if ((v27 & v26) == 0)
              {
                uint64_t v26 = v6;
                if (v25) {
                  goto LABEL_60;
                }
                goto LABEL_58;
              }
            }
            int v29 = (**(uint64_t (***)(uint64_t))a4)(a4);
            if (v29) {
              uint64_t v30 = v26;
            }
            else {
              uint64_t v30 = v6;
            }
            uint64_t v26 = v30 | v27;
            if (v29) {
              uint64_t v31 = ~v27;
            }
            else {
              uint64_t v31 = -1;
            }
            v25 &= v31;
            if (v29) {
              continue;
            }
            break;
          }
          if (v25) {
            goto LABEL_60;
          }
LABEL_58:
          unint64_t v32 = *(unsigned int *)(a3 + 8);
          if (v32 >= *(unsigned int *)(a3 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(_DWORD *)(*(void *)a3 + 4 * v32) = v24;
          ++*(_DWORD *)(a3 + 8);
        }
        goto LABEL_60;
      }
      int v11 = v8[1];
      int v10 = v8[2];
      if (v11 == -1) {
        int v12 = 0;
      }
      else {
        int v12 = v8[1];
      }
      if (v10 == -1) {
        int v13 = 0;
      }
      else {
        int v13 = v8[2];
      }
      int v14 = v8[3];
      if (v14 == -1) {
        int v15 = 0;
      }
      else {
        int v15 = v14;
      }
      uint64_t v16 = 1 << v9;
      BOOL v17 = ((1 << v9) & v5) != 0;
      if (((1 << v9) & v6) == 0)
      {
        int v18 = v13;
        int v19 = (**(uint64_t (***)(uint64_t))a4)(a4);
        int v13 = v18;
        BOOL v17 = v19;
        if (v19) {
          uint64_t v20 = v5;
        }
        else {
          uint64_t v20 = v6;
        }
        uint64_t v21 = v20 | v16;
        if (v19) {
          uint64_t v5 = v21;
        }
        else {
          uint64_t v6 = v21;
        }
      }
      if (v11 != -1)
      {
        if (v35 >= (unint64_t)v36) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        v37[v35++] = v12 | v11 & 0xFFFFFF00;
      }
      char v22 = v14 == -1 || v17;
      if ((v22 & 1) == 0)
      {
        if (v35 >= (unint64_t)v36) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        v37[v35++] = v15 | v14 & 0xFFFFFF00;
      }
      if (v10 != -1 && v17) {
        break;
      }
      uint64_t v26 = v6;
LABEL_60:
      int v7 = v35;
      uint64_t v6 = v26;
      if (!v35) {
        return;
      }
    }
    if (v35 >= (unint64_t)v36) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    v37[v35] = v13 | v10 & 0xFFFFFF00;
    int v7 = v35 + 1;
  }
  while (v35 != -1);
}

void LLVMInitializeAGX2Disassembler()
{
  qword_1EBD025C0 = (uint64_t)sub_1CBF20E6C;
  qword_1EBD02628 = (uint64_t)sub_1CBF228B4;
}

void sub_1CBF20E6C()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1CBF228B4()
{
}

void sub_1CBF2293C(char **a1, uint64_t a2, int *a3)
{
  unsigned int v6 = *((_DWORD *)a1 + 2);
  uint64_t v7 = *((unsigned int *)a1 + 3);
  if (v6 >= v7)
  {
    if (v7 == -1) {
      sub_1CD0A89A8(0xFFFFFFFFuLL);
    }
    if (((2 * v7) | 1uLL) >= 0xFFFFFFFF) {
      uint64_t v8 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v8 = (2 * v7) | 1;
    }
    int v9 = (char *)malloc_type_malloc(88 * v8, 0x4065EBACuLL);
    if (!v9) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    int v10 = v9;
    sub_1CBF235A4((uint64_t)&v9[88 * *((unsigned int *)a1 + 2)], a2, *a3);
    int v11 = *a1;
    unsigned int v12 = *((_DWORD *)a1 + 2);
    if (v12)
    {
      uint64_t v13 = 0;
      uint64_t v14 = 88 * v12;
      do
      {
        int v15 = &v10[v13];
        uint64_t v16 = &v11[v13];
        BOOL v17 = &v10[v13 + 16];
        *(void *)int v15 = v17;
        *((void *)v15 + 1) = 0x400000000;
        if (v11 != v10)
        {
          unint64_t v18 = *((unsigned int *)v16 + 2);
          if (*((_DWORD *)v16 + 2))
          {
            int v19 = &v11[v13];
            uint64_t v21 = (uint64_t)&v11[v13 + 16];
            uint64_t v20 = *(const void **)&v11[v13];
            if ((const void *)v21 == v20)
            {
              if (v18 >= 5) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              memcpy(v17, v20, 16 * *((unsigned int *)v16 + 2));
              *((_DWORD *)v15 + 2) = v18;
            }
            else
            {
              *(void *)int v15 = v20;
              int v22 = *((_DWORD *)v19 + 3);
              *((_DWORD *)v15 + 2) = v18;
              *((_DWORD *)v15 + 3) = v22;
              *(void *)int v19 = v21;
              *((_DWORD *)v19 + 3) = 0;
            }
            *((_DWORD *)v16 + 2) = 0;
          }
        }
        *((_DWORD *)v15 + 20) = *((_DWORD *)v16 + 20);
        v13 += 88;
      }
      while (v14 != v13);
      int v11 = *a1;
      unsigned int v23 = *((_DWORD *)a1 + 2);
      if (v23)
      {
        uint64_t v24 = 88 * v23;
        do
        {
          unint64_t v25 = *(char **)&v11[v24 - 88];
          if (&v11[v24 - 72] != v25) {
            free(v25);
          }
          v24 -= 88;
        }
        while (v24);
        int v11 = *a1;
      }
    }
    if (v11 != (char *)(a1 + 2)) {
      free(v11);
    }
    *a1 = v10;
    *((_DWORD *)a1 + 3) = v8;
  }
  else
  {
    sub_1CBF235A4((uint64_t)&(*a1)[88 * v6], a2, *a3);
  }
  ++*((_DWORD *)a1 + 2);
}

uint64_t sub_1CBF22B48(uint64_t a1)
{
  *(void *)a1 = &unk_1F25FEB58;
  unint64_t v2 = *(char **)(a1 + 40);
  unsigned int v3 = *(_DWORD *)(a1 + 48);
  if (v3)
  {
    uint64_t v4 = 88 * v3;
    do
    {
      uint64_t v5 = *(char **)&v2[v4 - 88];
      if (&v2[v4 - 72] != v5) {
        free(v5);
      }
      v4 -= 88;
    }
    while (v4);
    unint64_t v2 = *(char **)(a1 + 40);
  }
  if (v2 != (char *)(a1 + 56)) {
    free(v2);
  }
  *(void *)a1 = &unk_1F26321D0;
  uint64_t v6 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  return a1;
}

void sub_1CBF22C28(uint64_t a1)
{
  sub_1CBF22B48(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CBF22C60(uint64_t __sz, uint64_t a2, unint64_t *a3, unsigned __int8 *a4, unint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v142 = *MEMORY[0x1E4F143B8];
  *(void *)(__sz + 32) = a7;
  *a3 = 2;
  unsigned int v7 = *(_DWORD *)(__sz + 48);
  if (v7)
  {
    int v9 = (void *)__sz;
    int v10 = *(uint64_t **)(__sz + 40);
    v122 = &v10[11 * v7];
    v124 = (void **)(a2 + 16);
    v123 = a4;
    __sza = (void *)__sz;
    while (1)
    {
      unint64_t v11 = (unint64_t)*((unsigned int *)v10 + 20) >> 3;
      if (a5 < v11) {
        unint64_t v11 = a5;
      }
      uint64_t v12 = v11 >= 8 ? 8 : v11;
      if (v12)
      {
        uint64_t v13 = 0;
        unint64_t v14 = 0;
        int v15 = a4;
        do
        {
          unsigned int v16 = *v15++;
          v14 |= (unint64_t)v16 << v13;
          v13 += 8;
        }
        while (8 * v12 != v13);
        int v17 = v12;
      }
      else
      {
        unint64_t v14 = 0;
        int v17 = 0;
      }
      if (v17 == v11)
      {
        unint64_t v18 = 0;
      }
      else
      {
        unint64_t v18 = 0;
        unint64_t v19 = v11 - v12;
        uint64_t v20 = &a4[v12];
        uint64_t v21 = 8 * v12 + 4294967232;
        do
        {
          unsigned int v22 = *v20++;
          v18 |= (unint64_t)v22 << (v21 & 0xF8);
          v21 += 8;
          --v19;
        }
        while (v19);
      }
      uint64_t v23 = *((unsigned int *)v10 + 2);
      if (v23) {
        break;
      }
LABEL_143:
      v10 += 11;
      a4 = v123;
      if (v10 == v122) {
        return 0;
      }
    }
    uint64_t v24 = *v10;
    uint64_t v132 = *v10 + 16 * v23;
    v127 = v10;
    while (1)
    {
      v9[73] = *(void *)(v24 + 8) & 0x1FLL;
      if (a5 < (unint64_t)*((unsigned int *)v10 + 20) >> 3) {
        break;
      }
      uint64_t v25 = 0;
      uint64_t v26 = 0;
      uint64_t v27 = *(unsigned __int8 **)v24;
      v135[0] = v18;
      v135[1] = v14;
      uint64_t v28 = (unsigned __int8 *)v9[2];
      unsigned int v134 = 3;
      v133 = v27;
      do
      {
        while (2)
        {
          switch(*v27)
          {
            case 1u:
              unsigned int v69 = v27[1];
              unsigned int v70 = v27[2];
              v27 += 3;
              __sz = (uint64_t)sub_1CBF23644((unint64_t *)&v137, v18, v14, v69, v70);
              uint64_t v26 = *((void *)&v137 + 1);
              uint64_t v25 = v137;
              continue;
            case 2u:
              uint64_t v29 = 0;
              uint64_t v30 = 0;
              uint64_t v31 = 0;
              unsigned int v32 = 0;
              int v33 = v27 + 1;
              do
              {
                char v34 = v33[v29];
                int v35 = v34;
                uint64_t v36 = v34 & 0x7F;
                BOOL v37 = __CFADD__(v30, v36 << v32);
                uint64_t v38 = (v36 << v32) + v30;
                uint64_t v39 = v36 << v32;
                if (v32 < 0x40)
                {
                  uint64_t v30 = v38;
                  uint64_t v39 = v37;
                }
                v31 += v39;
                v32 += 7;
                ++v29;
              }
              while (v35 < 0);
              unint64_t v40 = (unsigned __int16 *)&v33[v29];
              uint64_t v41 = *((unsigned __int8 *)v40 + 2);
              BOOL v42 = v30 == v26 && v31 == v25;
              goto LABEL_42;
            case 3u:
              __sz = (uint64_t)sub_1CBF23644((unint64_t *)&v137, v18, v14, v27[1], v27[2]);
              uint64_t v43 = 0;
              uint64_t v44 = 0;
              uint64_t v45 = 0;
              unsigned int v46 = 0;
              unint64_t v47 = v27 + 3;
              do
              {
                char v48 = v47[v43];
                int v49 = v48;
                uint64_t v50 = v48 & 0x7F;
                BOOL v51 = __CFADD__(v44, v50 << v46);
                uint64_t v52 = (v50 << v46) + v44;
                uint64_t v53 = v50 << v46;
                if (v46 < 0x40)
                {
                  uint64_t v44 = v52;
                  uint64_t v53 = v51;
                }
                v45 += v53;
                v46 += 7;
                ++v43;
              }
              while (v49 < 0);
              unint64_t v40 = (unsigned __int16 *)&v47[v43];
              uint64_t v41 = *((unsigned __int8 *)v40 + 2);
              BOOL v42 = v44 == *((void *)&v137 + 1) && v45 == (void)v137;
LABEL_42:
              unint64_t v54 = *v40 | (unint64_t)(v41 << 16);
              if (v42) {
                unint64_t v54 = 0;
              }
              uint64_t v27 = (unsigned __int8 *)v40 + v54 + 3;
              continue;
            case 4u:
              uint64_t v55 = 0;
              uint64_t v56 = 0;
              unsigned int v57 = 0;
              unint64_t v58 = v27 + 1;
              do
              {
                char v59 = v58[v55];
                uint64_t v60 = v59 & 0x7F;
                if (v57 >= 0x40 && (v59 & 0x7F) != 0 || (unint64_t)(v60 << v57) >> v57 != v60)
                {
                  unint64_t v67 = &v58[v55];
                  uint64_t v62 = *v67;
                  uint64_t v63 = v67[1];
                  unint64_t v64 = v67 + 3;
                  uint64_t v65 = v67[2];
LABEL_54:
                  int v66 = (v28[196] >> 1) & 1;
                  goto LABEL_55;
                }
                v56 += v60 << v57;
                v57 += 7;
                ++v55;
              }
              while (v59 < 0);
              unint64_t v61 = &v58[v55];
              uint64_t v62 = *v61;
              uint64_t v63 = v61[1];
              unint64_t v64 = v61 + 3;
              uint64_t v65 = v61[2];
              switch((int)v56)
              {
                case 1:
                  int v66 = (v28[196] & 2) == 0;
                  break;
                case 2:
                  unsigned __int8 v92 = v28[197];
                  goto LABEL_85;
                case 3:
                  int v66 = v28[195] >> 7;
                  break;
                case 4:
                  unsigned int v91 = v28[196];
                  goto LABEL_87;
                case 5:
                  unsigned int v90 = v28[196];
                  goto LABEL_83;
                case 6:
                  unsigned __int8 v92 = v28[196];
LABEL_85:
                  int v66 = v92 & 1;
                  break;
                case 7:
                  unsigned int v93 = v28[196];
                  goto LABEL_89;
                case 8:
                  unsigned int v91 = v28[197];
LABEL_87:
                  int v66 = (v91 >> 3) & 1;
                  break;
                case 9:
                  int v66 = (v28[196] >> 2) & 1;
                  break;
                case 10:
                  unsigned int v93 = v28[194];
LABEL_89:
                  int v66 = (v93 >> 5) & 1;
                  break;
                case 11:
                  unsigned int v90 = v28[194];
LABEL_83:
                  int v66 = (v90 >> 4) & 1;
                  break;
                default:
                  goto LABEL_54;
              }
LABEL_55:
              uint64_t v68 = v62 | (v63 << 8) | (v65 << 16);
              if (v66) {
                uint64_t v68 = 0;
              }
              uint64_t v27 = &v64[v68];
              continue;
            case 5u:
              uint64_t v106 = 0;
              unsigned int v107 = 0;
              v108 = (char *)(v27 + 1);
              while (1)
              {
                char v109 = *v108;
                uint64_t v110 = *v108 & 0x7F;
                if (v107 >= 0x40 && (*v108 & 0x7F) != 0) {
                  break;
                }
                if ((unint64_t)(v110 << v107) >> v107 != v110) {
                  break;
                }
                v106 += v110 << v107;
                v107 += 7;
                ++v108;
                if ((v109 & 0x80) == 0) {
                  goto LABEL_129;
                }
              }
              LODWORD(v106) = 0;
LABEL_129:
              uint64_t v116 = 0;
              unsigned int v117 = 0;
              v118 = &v27[v108 - (v27 + 1) + 1];
              while (1)
              {
                unsigned __int8 v119 = *v118;
                uint64_t v120 = *v118 & 0x7F;
                if (v117 >= 0x40 && (*v118 & 0x7F) != 0) {
                  break;
                }
                if ((unint64_t)(v120 << v117) >> v117 != v120) {
                  break;
                }
                v116 += v120 << v117;
                v117 += 7;
                ++v118;
                if ((v119 & 0x80) == 0) {
                  goto LABEL_136;
                }
              }
              LODWORD(v116) = 0;
LABEL_136:
              *(_DWORD *)(a2 + 24) = 0;
              *(_DWORD *)a2 = v106;
              unsigned int v130 = sub_1CBF236C0(v134, v116, v135, (unsigned __int16 *)a2, a6, v9, &v137);
              goto LABEL_137;
            case 6u:
              uint64_t v85 = 0;
              unsigned int v86 = 0;
              v87 = (char *)(v27 + 1);
              break;
            case 7u:
              uint64_t v71 = 0;
              uint64_t v72 = 0;
              unsigned int v73 = 0;
              unint64_t v74 = v27 + 1;
              do
              {
                char v75 = v74[v71];
                unint64_t v76 = (unint64_t)(v75 & 0x7F) << v73;
                if (v73 > 0x3F) {
                  unint64_t v76 = 0;
                }
                v72 += v76;
                v73 += 7;
                ++v71;
              }
              while (v75 < 0);
              uint64_t v77 = 0;
              uint64_t v78 = 0;
              unsigned int v79 = 0;
              int v80 = &v74[v71];
              uint64_t v81 = (uint64_t)&v27[v71 + 1];
              do
              {
                char v82 = *(unsigned char *)(v81 + v77);
                unint64_t v83 = (unint64_t)(v82 & 0x7F) << v79;
                if (v79 > 0x3F) {
                  unint64_t v83 = 0;
                }
                v78 += v83;
                v79 += 7;
                ++v77;
              }
              while (v82 < 0);
              uint64_t v27 = &v80[v77];
              BOOL v42 = (v72 & v14 | v78 & ~v14) == 0;
              int v84 = v134;
              if (!v42) {
                int v84 = 1;
              }
              unsigned int v134 = v84;
              continue;
            case 8u:
              goto LABEL_139;
            default:
              v111 = (llvm::raw_ostream *)llvm::errs((llvm *)__sz);
              v112 = v111;
              if (v27 - v133 < 0)
              {
                unint64_t v113 = v133 - v27;
                int v114 = 1;
              }
              else
              {
                unint64_t v113 = v27 - v133;
                int v114 = 0;
              }
              __sz = (uint64_t)sub_1CD098D14(v111, v113, 0, 0, v114);
              v115 = (void *)*((void *)v112 + 4);
              int v10 = v127;
              if (*((void *)v112 + 3) - (void)v115 > 0x21uLL)
              {
                qmemcpy(v115, ": Unexpected decode table opcode!\n", 34);
                *((void *)v112 + 4) += 34;
              }
              else
              {
                __sz = (uint64_t)llvm::raw_ostream::write(v112, ": Unexpected decode table opcode!\n", 0x22uLL);
              }
              int v9 = __sza;
              goto LABEL_139;
          }
          break;
        }
        while (1)
        {
          char v88 = *v87;
          uint64_t v89 = *v87 & 0x7F;
          if (v86 >= 0x40 && (*v87 & 0x7F) != 0) {
            break;
          }
          if ((unint64_t)(v89 << v86) >> v86 != v89) {
            break;
          }
          v85 += v89 << v86;
          v86 += 7;
          ++v87;
          if ((v88 & 0x80) == 0) {
            goto LABEL_91;
          }
        }
        LODWORD(v85) = 0;
LABEL_91:
        uint64_t v94 = 0;
        unsigned int v95 = 0;
        uint64_t v96 = (uint64_t)&v27[v87 - (v27 + 1) + 1];
        v97 = (char *)v96;
        while (1)
        {
          char v98 = *v97;
          uint64_t v99 = *v97 & 0x7F;
          if (v95 >= 0x40 && (*v97 & 0x7F) != 0) {
            break;
          }
          if ((unint64_t)(v99 << v95) >> v95 != v99) {
            break;
          }
          v94 += v99 << v95;
          v95 += 7;
          ++v97;
          if ((v98 & 0x80) == 0) {
            goto LABEL_98;
          }
        }
        LODWORD(v94) = 0;
LABEL_98:
        v100 = (unsigned __int8 *)(v96 + (v97 - v96));
        uint64_t v125 = *v100;
        uint64_t v101 = v100[1];
        uint64_t v27 = v100 + 3;
        uint64_t v102 = v100[2];
        __src = v140;
        uint64_t v139 = 0x800000000;
        char v141 = 0;
        long long v137 = v85;
        unsigned __int8 v136 = 0;
        unsigned int v134 = sub_1CBF236C0(v134, v94, v135, (unsigned __int16 *)&v137, a6, __sza, &v136);
        int v126 = v136;
        if (v136)
        {
          uint64_t v103 = a2;
          *(_OWORD *)a2 = v137;
          if (&v137 != (long long *)a2)
          {
            int v104 = v139;
            uint64_t v105 = *(unsigned int *)(a2 + 24);
            if (v105 >= v139)
            {
              if (v139) {
                memmove(*v124, __src, 16 * v139);
              }
            }
            else
            {
              if (*(_DWORD *)(a2 + 28) < v139)
              {
                *(_DWORD *)(a2 + 24) = 0;
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              if (v105) {
                memmove(*v124, __src, 16 * v105);
              }
              else {
                uint64_t v105 = 0;
              }
              if (v105 != v139) {
                memcpy((char *)*v124 + 16 * v105, (char *)__src + 16 * v105, 16 * v139 - 16 * v105);
              }
            }
            uint64_t v103 = a2;
            *(_DWORD *)(a2 + 24) = v104;
          }
          *(unsigned char *)(v103 + 160) = v141;
          unsigned int v130 = v134;
        }
        else
        {
          v27 += v125 | (v101 << 8) | (v102 << 16);
          unsigned int v134 = 3;
        }
        int v9 = __sza;
        __sz = (uint64_t)__src;
        int v10 = v127;
        if (__src != v140) {
          free(__src);
        }
      }
      while (!v126);
LABEL_137:
      __sz = v130;
      if (v130 == 1) {
        return __sz;
      }
      if (v130 == 3)
      {
        *a3 = (unint64_t)*((unsigned int *)v10 + 20) >> 3;
        return __sz;
      }
LABEL_139:
      v24 += 16;
      if (v24 == v132) {
        goto LABEL_143;
      }
    }
  }
  return 0;
}

uint64_t sub_1CBF23540(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 8);
  if (v2 >= *(_DWORD *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unsigned int v3 = (void *)(*(void *)result + 16 * v2);
  *unsigned int v3 = a2;
  v3[1] = 0;
  ++*(_DWORD *)(result + 8);
  return result;
}

uint64_t sub_1CBF235A4(uint64_t a1, uint64_t a2, int a3)
{
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x400000000;
  if (a1 != a2)
  {
    unsigned int v5 = *(_DWORD *)(a2 + 8);
    if (v5)
    {
      if (v5 >= 5) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy((void *)(a1 + 16), *(const void **)a2, 16 * *(unsigned int *)(a2 + 8));
      *(_DWORD *)(a1 + 8) = v5;
    }
  }
  *(_DWORD *)(a1 + 80) = a3;
  return a1;
}

unint64_t *sub_1CBF23644(unint64_t *result, unint64_t a2, unint64_t a3, unsigned int a4, unsigned int a5)
{
  if (!a5)
  {
    unint64_t v5 = 0;
LABEL_11:
    unint64_t v6 = 0;
    if (!a4) {
      goto LABEL_20;
    }
    goto LABEL_12;
  }
  unint64_t v5 = -1;
  if ((a5 & 0x3F) == 0) {
    goto LABEL_11;
  }
  unint64_t v6 = 0xFFFFFFFFFFFFFFFFLL >> -(a5 & 0x3F);
  if (a5 >= 0x40) {
    unint64_t v5 = -1;
  }
  else {
    unint64_t v5 = 0xFFFFFFFFFFFFFFFFLL >> -(a5 & 0x3F);
  }
  if (a5 < 0x40) {
    unint64_t v6 = 0;
  }
  if (a4)
  {
LABEL_12:
    if ((int)(a4 - 64) < 0)
    {
      if (a4 <= 0x3F) {
        a3 = (a2 << -(char)a4) | (a3 >> a4);
      }
      else {
        a3 = a2 << -(char)a4;
      }
      if (a4 <= 0x3F) {
        a2 >>= a4;
      }
      else {
        a2 = 0;
      }
    }
    else
    {
      a3 = a2 >> (a4 - 64);
      a2 = 0;
    }
  }
LABEL_20:
  *result = a2 & v6;
  result[1] = a3 & v5;
  return result;
}

uint64_t sub_1CBF236C0(unsigned int a1, unsigned int a2, uint64_t *a3, unsigned __int16 *a4, uint64_t a5, void *__sz, unsigned char *a7)
{
  unsigned int v7 = __sz;
  uint64_t v8 = a5;
  int v9 = a4;
  uint64_t v11 = 0;
  unint64_t v12 = 0;
  uint64_t v13 = dword_1CFA73BB0[a2];
  unint64_t v14 = (char *)&unk_1CFA7CC58 + dword_1CFA7CD04[dword_1CFA61A60[a2]];
  uint64_t v62 = (char *)&unk_1CFA7CD3C + 4 * dword_1CFA8FC48[dword_1CFA6AB08[a2]];
  int v15 = (unsigned __int16 *)((char *)&unk_1CFA92788 + 2 * dword_1CFA9AE74[v13]);
  *a7 = 1;
LABEL_2:
  switch(*v14)
  {
    case 1:
      if (sub_1CBF23AD4(&v62, v9, v11, v12, v8, v7)) {
        goto LABEL_60;
      }
      a1 = 0;
      *a7 = 0;
      return a1;
    case 2:
      if (sub_1CBF23AD4(&v62, v9, v11, v12, v8, v7)) {
        goto LABEL_60;
      }
      return 0;
    case 3:
      uint64_t v11 = *a3;
      unint64_t v12 = a3[1];
      goto LABEL_60;
    case 4:
      return a1;
    default:
      uint64_t v16 = 0;
      unsigned int v17 = 0;
      unsigned int v18 = *v15++;
      unint64_t v19 = (unsigned __int8 *)&unk_1CFA9D458 + dword_1CFA9F548[v18];
      int v22 = *v19;
      uint64_t v20 = v19 + 1;
      int v21 = v22;
      uint64_t v23 = v20;
      break;
  }
  while (1)
  {
    unsigned __int8 v24 = *v23;
    uint64_t v25 = *v23 & 0x7F;
    if (v17 >= 0x40 && (*v23 & 0x7F) != 0) {
      break;
    }
    if ((unint64_t)(v25 << v17) >> v17 != v25) {
      break;
    }
    v16 += v25 << v17;
    v17 += 7;
    ++v23;
    if ((v24 & 0x80) == 0) {
      goto LABEL_15;
    }
  }
  LODWORD(v16) = 0;
LABEL_15:
  uint64_t v26 = 0;
  unsigned int v27 = 0;
  uint64_t v28 = &v20[v23 - v20];
  while (1)
  {
    unsigned __int8 v29 = *v28;
    uint64_t v30 = *v28 & 0x7F;
    if (v27 >= 0x40 && (*v28 & 0x7F) != 0) {
      break;
    }
    if ((unint64_t)(v30 << v27) >> v27 != v30) {
      break;
    }
    v26 += v30 << v27;
    v27 += 7;
    ++v28;
    if ((v29 & 0x80) == 0) {
      goto LABEL_22;
    }
  }
  LODWORD(v26) = 0;
LABEL_22:
  unint64_t v12 = v26 | ((unint64_t)v16 << 32);
  uint64_t v11 = 0;
  int v31 = v21 - 2;
  if (v21 == 2) {
    goto LABEL_60;
  }
  unsigned int v32 = &v20[v28 - v20];
  unint64_t v33 = *a3;
  unint64_t v34 = a3[1];
LABEL_24:
  int v35 = 0;
  unsigned int v36 = 0;
  BOOL v37 = v32;
  uint64_t v38 = 0;
  while (v37)
  {
    unsigned __int8 v39 = *v37;
    uint64_t v40 = *v37 & 0x7F;
    if (v36 >= 0x40 && (*v37 & 0x7F) != 0 || (unint64_t)(v40 << v36) >> v36 != v40)
    {
      LODWORD(v38) = 0;
      goto LABEL_33;
    }
    v38 += v40 << v36;
    v36 += 7;
    ++v37;
    if ((v39 & 0x80) == 0) {
      goto LABEL_33;
    }
  }
  LODWORD(v38) = 0;
  LODWORD(v37) = 0;
LABEL_33:
  uint64_t v41 = 0;
  unsigned int v42 = 0;
  uint64_t v43 = &v32[v37 - v32];
  uint64_t v44 = v43;
  while (v44)
  {
    unsigned __int8 v45 = *v44;
    uint64_t v46 = *v44 & 0x7F;
    if (v42 >= 0x40 && (*v44 & 0x7F) != 0 || (unint64_t)(v46 << v42) >> v42 != v46)
    {
      LODWORD(v41) = 0;
      goto LABEL_42;
    }
    v41 += v46 << v42;
    v42 += 7;
    ++v44;
    if ((v45 & 0x80) == 0) {
      goto LABEL_42;
    }
  }
  LODWORD(v41) = 0;
  LODWORD(v44) = 0;
LABEL_42:
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  unsigned int v49 = 0;
  uint64_t v50 = &v43[v44 - v43];
  int v51 = (int)v50;
  while (1)
  {
    if (!&v50[v47]) {
      goto LABEL_53;
    }
    unsigned __int8 v52 = v50[v47];
    uint64_t v53 = v52 & 0x7F;
    if (v49 >= 0x40 && (v52 & 0x7F) != 0) {
      break;
    }
    if ((unint64_t)(v53 << v49) >> v49 != v53)
    {
      int v35 = v51;
      goto LABEL_53;
    }
    v48 += v53 << v49;
    v49 += 7;
    ++v51;
    ++v47;
    if ((v52 & 0x80) == 0)
    {
      unsigned int v32 = &v50[v47];
      sub_1CBF23644(&v63, v33, v34, v38, v41);
      if (!v48) {
        goto LABEL_54;
      }
      if ((int)v48 - 64 < 0)
      {
        unint64_t v55 = v64 >> -(char)v48;
        if (v48 <= 0x3F)
        {
          v55 |= v63 << v48;
          uint64_t v54 = v64 << v48;
        }
        else
        {
          uint64_t v54 = 0;
        }
      }
      else
      {
        uint64_t v54 = 0;
        unint64_t v55 = v64 << (v48 - 64);
      }
LABEL_55:
      v11 |= v55;
      v12 |= v54;
      v31 -= 3;
      if (!v31)
      {
        uint64_t v8 = a5;
        unsigned int v7 = __sz;
        int v9 = a4;
LABEL_60:
        ++v14;
        goto LABEL_2;
      }
      goto LABEL_24;
    }
  }
  int v35 = v50 + v47;
LABEL_53:
  unsigned int v32 = &v50[v35 - v50];
  sub_1CBF23644(&v63, v33, v34, v38, v41);
LABEL_54:
  unint64_t v55 = v63;
  uint64_t v54 = v64;
  goto LABEL_55;
}

uint64_t sub_1CBF23AD4(void *a1, unsigned __int16 *a2, uint64_t a3, unint64_t a4, uint64_t a5, void *__sz)
{
  uint64_t v6 = *(unsigned int *)*a1;
  *a1 += 4;
  unint64_t v8 = a4;
  switch(v6)
  {
    case 1:
      goto LABEL_297;
    case 2:
      int v76 = 8;
      goto LABEL_177;
    case 3:
      int v76 = 16;
      goto LABEL_177;
    case 4:
      goto LABEL_77;
    case 5:
      uint64_t v46 = (uint64_t)a2;
      unsigned int v47 = 12;
      goto LABEL_106;
    case 6:
      uint64_t v13 = (uint64_t)a2;
      unint64_t v14 = a4;
      uint64_t v15 = (uint64_t)__sz;
      int v16 = 16;
      goto LABEL_189;
    case 7:
      uint64_t v72 = (uint64_t)a2;
      unint64_t v73 = a4;
      uint64_t v74 = (uint64_t)__sz;
      int v75 = 16;
      goto LABEL_200;
    case 8:
      uint64_t v13 = (uint64_t)a2;
      unint64_t v14 = a4;
      uint64_t v15 = (uint64_t)__sz;
      int v16 = 32;
      goto LABEL_189;
    case 9:
      uint64_t v72 = (uint64_t)a2;
      unint64_t v73 = a4;
      uint64_t v74 = (uint64_t)__sz;
      int v75 = 32;
      goto LABEL_200;
    case 10:
      uint64_t v98 = (a4 >> 11) & 7;
      unint64_t v99 = a4;
      if ((unint64_t)(v98 - 5) < 3)
      {
        uint64_t v100 = (uint64_t)a2;
        unsigned int v101 = 6;
        unsigned int v102 = 128;
        unsigned int v103 = 2;
      }
      else
      {
        if ((unint64_t)(v98 - 1) > 2) {
          return 0;
        }
        uint64_t v100 = (uint64_t)a2;
        unsigned int v101 = 0;
        unsigned int v102 = 256;
        unsigned int v103 = 1;
      }
      uint64_t result = sub_1CBF27734(v100, v101, 0, v102, v103, v99, (uint64_t)__sz);
      if (!result) {
        return result;
      }
      uint64_t v143 = __rbit32(v8 >> 8) >> 29;
      uint64_t v144 = (16 * (((v8 >> 11) & 3) == 3)) | (32 * (((v8 >> 11) & 3) == 2));
LABEL_296:
      unint64_t v8 = v144 | v143;
LABEL_297:
      unsigned int v176 = *((_DWORD *)a2 + 6);
      if (v176 >= *((_DWORD *)a2 + 7)) {
LABEL_431:
      }
        llvm::SmallVectorBase<unsigned int>::grow_pod();
LABEL_298:
      v177 = (void *)(*((void *)a2 + 2) + 16 * v176);
      goto LABEL_326;
    case 11:
      goto LABEL_46;
    case 12:
      uint64_t v46 = (uint64_t)a2;
      unsigned int v47 = 15;
      unsigned int v48 = 0;
      unsigned int v49 = 253;
      goto LABEL_183;
    case 13:
      unint64_t v89 = a4 & 0x7F;
      uint64_t v90 = __sz[1];
      *(void *)(v90 + 272) += 24;
      uint64_t v91 = *(void *)(v90 + 192);
      if (((v91 + 7) & 0xFFFFFFFFFFFFFFF8) - v91 + 24 > *(void *)(v90 + 200) - v91)
      {
        unsigned int v186 = *(_DWORD *)(v90 + 216) >> 7;
        if (v186 >= 0x1E) {
          LOBYTE(v186) = 30;
        }
        uint64_t v187 = 4096 << v186;
        unint64_t v92 = (unint64_t)operator new(4096 << v186, (std::align_val_t)8uLL);
        unsigned int v188 = *(_DWORD *)(v90 + 216);
        if (v188 >= *(_DWORD *)(v90 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v90 + 208) + 8 * v188) = v92;
        ++*(_DWORD *)(v90 + 216);
        *(void *)(v90 + 200) = v92 + v187;
      }
      else
      {
        unint64_t v92 = (v91 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v90 + 192) = v92 + 24;
      *(unsigned char *)unint64_t v92 = 1;
      *(_DWORD *)(v92 + 1) = *(unsigned __int8 *)(v92 + 4) << 24;
      *(void *)(v92 + 8) = 0;
      *(void *)(v92 + 16) = v89;
      uint64_t v93 = __sz[1];
      *(void *)(v93 + 272) += 40;
      uint64_t v94 = *(void *)(v93 + 192);
      if (((v94 + 7) & 0xFFFFFFFFFFFFFFF8) - v94 + 40 > *(void *)(v93 + 200) - v94)
      {
        unsigned int v189 = *(_DWORD *)(v93 + 216) >> 7;
        if (v189 >= 0x1E) {
          LOBYTE(v189) = 30;
        }
        uint64_t v190 = 4096 << v189;
        unint64_t v95 = (unint64_t)operator new(4096 << v189, (std::align_val_t)8uLL);
        unsigned int v191 = *(_DWORD *)(v93 + 216);
        if (v191 >= *(_DWORD *)(v93 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v93 + 208) + 8 * v191) = v95;
        ++*(_DWORD *)(v93 + 216);
        *(void *)(v93 + 200) = v95 + v190;
      }
      else
      {
        unint64_t v95 = (v94 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v93 + 192) = v95 + 40;
      *(unsigned char *)(v95 + 8) = 4;
      *(_DWORD *)(v95 + 9) = *(unsigned __int8 *)(v95 + 12) << 24;
      *(void *)(v95 + 16) = 0;
      *(void *)unint64_t v95 = &unk_1F25FD370;
      *(_DWORD *)(v95 + 24) = 7;
      *(void *)(v95 + 32) = v92;
      unsigned int v96 = *((_DWORD *)a2 + 6);
      if (v96 >= *((_DWORD *)a2 + 7)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v97 = (void *)(*((void *)a2 + 2) + 16 * v96);
      void *v97 = 5;
      v97[1] = v95 + 8;
      goto LABEL_327;
    case 14:
      uint64_t v46 = (uint64_t)a2;
      unsigned int v47 = 35;
      unsigned int v48 = 0;
      unsigned int v49 = 125;
      goto LABEL_181;
    case 15:
      uint64_t v46 = (uint64_t)a2;
      unsigned int v47 = 4;
      unsigned int v48 = 0;
      unsigned int v49 = 255;
      goto LABEL_183;
    case 16:
      uint64_t v46 = (uint64_t)a2;
      unsigned int v47 = 10;
      unsigned int v48 = 0;
      unsigned int v49 = 254;
      goto LABEL_183;
    case 17:
      uint64_t v46 = (uint64_t)a2;
      unsigned int v47 = 17;
LABEL_106:
      unsigned int v48 = 0;
      unsigned int v49 = 127;
      goto LABEL_181;
    case 18:
      uint64_t v46 = (uint64_t)a2;
      unsigned int v47 = 27;
      unsigned int v48 = 0;
      unsigned int v49 = 126;
      goto LABEL_181;
    case 19:
      uint64_t v46 = (uint64_t)a2;
      unsigned int v47 = 45;
      unsigned int v48 = 0;
      unsigned int v49 = 117;
      goto LABEL_181;
    case 20:
      uint64_t v46 = (uint64_t)a2;
      unsigned int v47 = 39;
      unsigned int v48 = 0;
      unsigned int v49 = 123;
      goto LABEL_181;
    case 21:
      uint64_t v46 = (uint64_t)a2;
      unsigned int v47 = 43;
      unsigned int v48 = 0;
      unsigned int v49 = 120;
      goto LABEL_181;
    case 22:
      uint64_t v13 = (uint64_t)a2;
      unint64_t v14 = a4;
      uint64_t v15 = (uint64_t)__sz;
      int v16 = 64;
      goto LABEL_189;
    case 23:
      if (a4 > 0xFF) {
        return 0;
      }
      if (a3 || a4 != 255)
      {
        if ((int)a4 <= 123)
        {
          uint64_t v67 = 43;
          switch(a4)
          {
            case 1uLL:
              goto LABEL_157;
            case 2uLL:
              uint64_t v67 = 45;
              goto LABEL_157;
            case 3uLL:
            case 7uLL:
            case 0xBuLL:
            case 0x16uLL:
            case 0x17uLL:
            case 0x1AuLL:
            case 0x1BuLL:
            case 0x1DuLL:
            case 0x21uLL:
            case 0x22uLL:
            case 0x23uLL:
            case 0x24uLL:
            case 0x25uLL:
            case 0x26uLL:
            case 0x27uLL:
            case 0x28uLL:
            case 0x29uLL:
            case 0x2AuLL:
            case 0x2BuLL:
            case 0x2CuLL:
            case 0x2DuLL:
            case 0x2EuLL:
            case 0x2FuLL:
            case 0x36uLL:
            case 0x37uLL:
            case 0x3DuLL:
            case 0x40uLL:
            case 0x41uLL:
            case 0x42uLL:
            case 0x43uLL:
            case 0x44uLL:
            case 0x45uLL:
            case 0x46uLL:
            case 0x47uLL:
            case 0x48uLL:
            case 0x49uLL:
            case 0x4AuLL:
            case 0x4BuLL:
            case 0x53uLL:
            case 0x54uLL:
            case 0x55uLL:
            case 0x56uLL:
            case 0x57uLL:
            case 0x58uLL:
            case 0x59uLL:
            case 0x5AuLL:
            case 0x5BuLL:
            case 0x5CuLL:
            case 0x5DuLL:
            case 0x5EuLL:
            case 0x5FuLL:
              goto LABEL_485;
            case 4uLL:
              uint64_t v67 = 42;
              goto LABEL_157;
            case 5uLL:
              uint64_t v67 = 44;
              goto LABEL_157;
            case 6uLL:
              uint64_t v67 = 46;
              goto LABEL_157;
            case 8uLL:
              uint64_t v67 = 38;
              goto LABEL_157;
            case 9uLL:
              uint64_t v67 = 39;
              goto LABEL_157;
            case 0xAuLL:
              uint64_t v67 = 40;
              goto LABEL_157;
            case 0xCuLL:
              uint64_t v67 = 23;
              goto LABEL_157;
            case 0xDuLL:
              uint64_t v67 = 24;
              goto LABEL_157;
            case 0xEuLL:
              uint64_t v67 = 22;
              goto LABEL_157;
            case 0xFuLL:
              uint64_t v67 = 21;
              goto LABEL_157;
            case 0x10uLL:
              uint64_t v67 = 17;
              goto LABEL_157;
            case 0x11uLL:
              uint64_t v67 = 37;
              goto LABEL_157;
            case 0x12uLL:
              uint64_t v67 = 55;
              goto LABEL_157;
            case 0x13uLL:
              uint64_t v67 = 14;
              goto LABEL_157;
            case 0x14uLL:
              uint64_t v67 = 5;
              goto LABEL_157;
            case 0x15uLL:
              uint64_t v67 = 6;
              goto LABEL_157;
            case 0x18uLL:
              uint64_t v67 = 30;
              goto LABEL_157;
            case 0x19uLL:
              uint64_t v67 = 29;
              goto LABEL_157;
            case 0x1CuLL:
              uint64_t v67 = 4;
              goto LABEL_157;
            case 0x1EuLL:
              uint64_t v67 = 8;
              goto LABEL_157;
            case 0x1FuLL:
              uint64_t v67 = 12;
              goto LABEL_157;
            case 0x20uLL:
              uint64_t v67 = 36;
              goto LABEL_157;
            case 0x30uLL:
              uint64_t v67 = 26;
              goto LABEL_157;
            case 0x31uLL:
              uint64_t v67 = 27;
              goto LABEL_157;
            case 0x32uLL:
              uint64_t v67 = 28;
              goto LABEL_157;
            case 0x33uLL:
              uint64_t v67 = 25;
              goto LABEL_157;
            case 0x34uLL:
              uint64_t v67 = 33;
              goto LABEL_157;
            case 0x35uLL:
              uint64_t v67 = 34;
              goto LABEL_157;
            case 0x38uLL:
              uint64_t v67 = 31;
              goto LABEL_157;
            case 0x39uLL:
              uint64_t v67 = 50;
              goto LABEL_157;
            case 0x3AuLL:
              uint64_t v67 = 32;
              goto LABEL_157;
            case 0x3BuLL:
              uint64_t v67 = 51;
              goto LABEL_157;
            case 0x3CuLL:
              uint64_t v67 = 7;
              goto LABEL_157;
            case 0x3EuLL:
              uint64_t v67 = 3;
              goto LABEL_157;
            case 0x3FuLL:
              uint64_t v67 = 18;
              goto LABEL_157;
            case 0x4CuLL:
              uint64_t v67 = 20;
              goto LABEL_157;
            case 0x4DuLL:
              uint64_t v67 = 19;
              goto LABEL_157;
            case 0x4EuLL:
              uint64_t v67 = 10;
              goto LABEL_157;
            case 0x4FuLL:
              uint64_t v67 = 9;
              goto LABEL_157;
            case 0x50uLL:
              uint64_t v67 = 47;
              goto LABEL_157;
            case 0x51uLL:
              uint64_t v67 = 48;
              goto LABEL_157;
            case 0x52uLL:
              uint64_t v67 = 49;
              goto LABEL_157;
            case 0x60uLL:
              uint64_t v67 = 15;
              goto LABEL_157;
            case 0x61uLL:
              uint64_t v67 = 16;
              goto LABEL_157;
            case 0x62uLL:
              uint64_t v67 = 11;
              goto LABEL_157;
            default:
              uint64_t v67 = 41;
              goto LABEL_157;
          }
        }
        uint64_t v178 = 53;
        if (a4 != 146) {
          uint64_t v178 = 52;
        }
        uint64_t v179 = 35;
        if (a4 != 124) {
          uint64_t v179 = 54;
        }
        if ((int)a4 <= 145) {
          uint64_t v67 = v179;
        }
        else {
          uint64_t v67 = v178;
        }
      }
      else
      {
        uint64_t v67 = 184;
      }
LABEL_157:
      unsigned int v122 = *((_DWORD *)a2 + 6);
      if (v122 >= *((_DWORD *)a2 + 7)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v120 = (uint64_t *)(*((void *)a2 + 2) + 16 * v122);
      uint64_t v121 = 1;
      goto LABEL_152;
    case 24:
      unint64_t v77 = (a4 >> 11) & 3;
      if (v77 <= 1)
      {
        uint64_t result = sub_1CBF27734((uint64_t)a2, 6u, 0, 0x80u, 2u, a4, (uint64_t)__sz);
        if (!result) {
          return result;
        }
        unsigned int v87 = *((_DWORD *)a2 + 6);
      }
      else
      {
        uint64_t v78 = (a4 >> 3) & 0x100 | a4;
        uint64_t v79 = __sz[1];
        *(void *)(v79 + 272) += 24;
        uint64_t v80 = *(void *)(v79 + 192);
        if (((v80 + 7) & 0xFFFFFFFFFFFFFFF8) - v80 + 24 > *(void *)(v79 + 200) - v80)
        {
          unsigned int v198 = *(_DWORD *)(v79 + 216) >> 7;
          if (v198 >= 0x1E) {
            LOBYTE(v198) = 30;
          }
          uint64_t v199 = 4096 << v198;
          uint64_t v234 = v79;
          v200 = (char *)operator new(4096 << v198, (std::align_val_t)8uLL);
          uint64_t v79 = v234;
          unint64_t v81 = (unint64_t)v200;
          unsigned int v201 = *(_DWORD *)(v234 + 216);
          if (v201 >= *(_DWORD *)(v234 + 220)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(v234 + 208) + 8 * v201) = v200;
          ++*(_DWORD *)(v234 + 216);
          *(void *)(v234 + 200) = &v200[v199];
        }
        else
        {
          unint64_t v81 = (v80 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(v79 + 192) = v81 + 24;
        *(unsigned char *)unint64_t v81 = 1;
        *(_DWORD *)(v81 + 1) = *(unsigned __int8 *)(v81 + 4) << 24;
        *(void *)(v81 + 8) = 0;
        *(void *)(v81 + 16) = v78;
        uint64_t v82 = __sz[1];
        *(void *)(v82 + 272) += 40;
        uint64_t v83 = *(void *)(v82 + 192);
        if (((v83 + 7) & 0xFFFFFFFFFFFFFFF8) - v83 + 40 > *(void *)(v82 + 200) - v83)
        {
          unsigned int v202 = *(_DWORD *)(v82 + 216) >> 7;
          if (v202 >= 0x1E) {
            LOBYTE(v202) = 30;
          }
          uint64_t v203 = 4096 << v202;
          unint64_t v84 = (unint64_t)operator new(4096 << v202, (std::align_val_t)8uLL);
          unsigned int v204 = *(_DWORD *)(v82 + 216);
          if (v204 >= *(_DWORD *)(v82 + 220)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(v82 + 208) + 8 * v204) = v84;
          ++*(_DWORD *)(v82 + 216);
          *(void *)(v82 + 200) = v84 + v203;
        }
        else
        {
          unint64_t v84 = (v83 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(v82 + 192) = v84 + 40;
        *(unsigned char *)(v84 + 8) = 4;
        *(_DWORD *)(v84 + 9) = *(unsigned __int8 *)(v84 + 12) << 24;
        *(void *)(v84 + 16) = 0;
        *(void *)unint64_t v84 = &unk_1F25FD370;
        *(_DWORD *)(v84 + 24) = 4;
        *(void *)(v84 + 32) = v81;
        unsigned int v85 = *((_DWORD *)a2 + 6);
        if (v85 >= *((_DWORD *)a2 + 7)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        unsigned int v86 = (void *)(*((void *)a2 + 2) + 16 * v85);
        *unsigned int v86 = 5;
        v86[1] = v84 + 8;
        unsigned int v87 = *((_DWORD *)a2 + 6) + 1;
        *((_DWORD *)a2 + 6) = v87;
      }
      if (v77 <= 1) {
        unint64_t v8 = 16 * (v77 == 1);
      }
      else {
        unint64_t v8 = 0;
      }
      if (v87 >= *((_DWORD *)a2 + 7)) {
LABEL_467:
      }
        llvm::SmallVectorBase<unsigned int>::grow_pod();
LABEL_325:
      v177 = (void *)(*((void *)a2 + 2) + 16 * v87);
LABEL_326:
      void *v177 = 2;
      v177[1] = v8;
      goto LABEL_327;
    case 25:
      int v76 = 24;
      goto LABEL_177;
    case 26:
      int v76 = 32;
LABEL_177:
      return sub_1CBF261C0(v76, (uint64_t)a2, a4);
    case 27:
      uint64_t result = 0;
      uint64_t v53 = (a4 >> 15) & 7;
      unint64_t v54 = a4;
      switch((a4 >> 11) & 0xF)
      {
        case 0uLL:
          uint64_t v145 = (unint64_t)a4 << v53;
          goto LABEL_249;
        case 1uLL:
        case 2uLL:
        case 3uLL:
          uint64_t v55 = (uint64_t)a2;
          unsigned int v56 = 0;
          unsigned int v57 = 256;
          unsigned int v58 = 1;
          goto LABEL_247;
        case 5uLL:
        case 6uLL:
        case 7uLL:
          uint64_t v55 = (uint64_t)a2;
          unsigned int v56 = 6;
          unsigned int v57 = 128;
          goto LABEL_246;
        case 9uLL:
        case 0xAuLL:
        case 0xBuLL:
          uint64_t v55 = (uint64_t)a2;
          unsigned int v56 = 17;
          unsigned int v57 = 127;
LABEL_246:
          unsigned int v58 = 2;
LABEL_247:
          uint64_t result = sub_1CBF27734(v55, v56, 0, v57, v58, v54, (uint64_t)__sz);
          if (!result) {
            return result;
          }
          uint64_t v145 = (16 * (((v8 >> 11) & 3) == 3)) | (32 * (((v8 >> 11) & 3) == 2)) | (v8 >> 7) & 8 | (v53 << 6);
LABEL_249:
          unsigned int v146 = *((_DWORD *)a2 + 6);
          if (v146 >= *((_DWORD *)a2 + 7)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          v147 = (void *)(*((void *)a2 + 2) + 16 * v146);
          void *v147 = 2;
          v147[1] = v145;
          ++*((_DWORD *)a2 + 6);
          break;
        default:
          return result;
      }
      return 3;
    case 28:
      unint64_t v123 = ((a4 >> 11) & 3) - 1;
      if (v123 > 2) {
        return 0;
      }
      unint64_t v124 = a4 | (v123 << 11);
      uint64_t v125 = 26624;
      goto LABEL_163;
    case 29:
      unint64_t v126 = ((a4 >> 11) & 3) - 1;
      if (v126 > 2) {
        return 0;
      }
      unint64_t v124 = a4 | (v126 << 11);
      uint64_t v125 = 18432;
LABEL_163:
      unint64_t v60 = v124 + v125;
      goto LABEL_164;
    case 30:
      unsigned int v30 = *((_DWORD *)a2 + 6);
      if (v30 >= *((_DWORD *)a2 + 7)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v31 = a4 & 0x1F;
      BOOL v44 = v31 == 0;
      goto LABEL_127;
    case 31:
      unint64_t v69 = a4;
      uint64_t v46 = (uint64_t)a2;
      unsigned int v47 = 0;
      unsigned int v48 = 0;
      unsigned int v49 = 256;
      unsigned int v70 = 1;
      goto LABEL_185;
    case 32:
      uint64_t v104 = (uint64_t)a2;
      unint64_t v60 = a4;
      goto LABEL_165;
    case 33:
      unint64_t v69 = a4;
      uint64_t v46 = (uint64_t)a2;
      unsigned int v47 = 6;
      unsigned int v48 = 0;
      unsigned int v49 = 128;
      unsigned int v70 = 2;
      goto LABEL_185;
    case 34:
      unint64_t v59 = (a4 >> 11) & 0xF;
      if (v59 > 0xB || ((0xEFFu >> v59) & 1) == 0) {
        return 0;
      }
      unint64_t v60 = a4 | (qword_1CFA9FF70[v59] << 11);
LABEL_164:
      uint64_t v104 = (uint64_t)a2;
LABEL_165:
      return sub_1CBF26A7C(v104, v60, (uint64_t)__sz);
    case 35:
      unint64_t v35 = (a4 >> 11) & 0xF;
      if (v35 > 0xB || ((0xEFFu >> v35) & 1) == 0) {
        return 0;
      }
      unsigned int v36 = qword_1CFA9FF70;
      goto LABEL_45;
    case 36:
      unint64_t v52 = (a4 >> 11) & 0xF;
      if (v52 > 0xB || ((0xEFFu >> v52) & 1) == 0) {
        return 0;
      }
      unint64_t v51 = a4 | (qword_1CFA9FFD0[v52] << 11);
      goto LABEL_260;
    case 37:
      unint64_t v35 = (a4 >> 11) & 0xF;
      if (v35 > 0xB || ((0xEFFu >> v35) & 1) == 0) {
        return 0;
      }
      unsigned int v36 = qword_1CFA9FFD0;
LABEL_45:
      unint64_t v8 = a4 & 0x7FF | (v36[v35] << 11);
LABEL_46:
      uint64_t v50 = (uint64_t)a2;
      unint64_t v51 = v8;
      goto LABEL_261;
    case 38:
      unsigned int v30 = *((_DWORD *)a2 + 6);
      if (v30 >= *((_DWORD *)a2 + 7)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      BOOL v32 = (a4 & 0x10000) == 0 || (*(void *)(__sz[2] + 192) & 0x2000000000) == 0;
      unint64_t v33 = a4 & 0xBFFFFFFFFFFEFFFFLL;
      goto LABEL_173;
    case 39:
      unsigned int v30 = *((_DWORD *)a2 + 6);
      if (v30 >= *((_DWORD *)a2 + 7)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v31 = a4;
      goto LABEL_175;
    case 40:
      if ((*(unsigned char *)(__sz[2] + 196) & 0x20) != 0)
      {
LABEL_77:
        uint64_t v46 = (uint64_t)a2;
        unsigned int v47 = 0;
        unsigned int v48 = 0;
LABEL_133:
        unsigned int v49 = 256;
LABEL_183:
        unsigned int v70 = 1;
LABEL_184:
        unint64_t v69 = v8;
LABEL_185:
        return sub_1CBF27734(v46, v47, v48, v49, v70, v69, (uint64_t)__sz);
      }
      else
      {
        unsigned int v71 = *((_DWORD *)a2 + 6);
        if (v71 >= *((_DWORD *)a2 + 7)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(_OWORD *)(*((void *)a2 + 2) + 16 * v71) = xmmword_1CD91D2D0;
LABEL_327:
        ++*((_DWORD *)a2 + 6);
        return 3;
      }
    case 41:
      unsigned int v17 = sub_1CBF262B8;
      goto LABEL_204;
    case 42:
      unint64_t v110 = *(void *)(*((void *)a2 + 2) + 16 * sub_1CBC7A3F8(*a2, 0x16u) + 8);
      uint64_t v111 = v110 & 1;
      uint64_t v112 = (v110 >> 5) & 0xF;
      if ((v110 & 0x10) != 0)
      {
        switch(v112)
        {
          case 1:
            int v142 = 4 * v111;
            break;
          case 2:
          case 4:
            BOOL v113 = v111 == 0;
            int v114 = 4;
LABEL_300:
            if (v113) {
              int v142 = -1;
            }
            else {
              int v142 = v114;
            }
            break;
          case 3:
          case 5:
          case 6:
            if (v110) {
              int v142 = 10;
            }
            else {
              int v142 = 0;
            }
            break;
          case 7:
          case 8:
            BOOL v151 = v111 == 0;
            int v152 = 15;
            int v153 = 4;
            goto LABEL_310;
          default:
            if (v110) {
              int v142 = 0;
            }
            else {
              int v142 = -1;
            }
            break;
        }
      }
      else
      {
        switch(v112)
        {
          case 1:
            BOOL v151 = v111 == 0;
            int v152 = 12;
            break;
          case 2:
          case 4:
            BOOL v113 = v111 == 0;
            int v114 = 17;
            goto LABEL_300;
          case 3:
          case 6:
            BOOL v151 = v111 == 0;
            int v152 = 22;
            break;
          case 5:
          case 8:
            BOOL v151 = v111 == 0;
            int v152 = 27;
            int v153 = 6;
            goto LABEL_310;
          case 7:
            BOOL v151 = v111 == 0;
            int v152 = 32;
            int v153 = 12;
            goto LABEL_310;
          default:
            BOOL v113 = v111 == 0;
            int v114 = 6;
            goto LABEL_300;
        }
        int v153 = 2;
LABEL_310:
        if (v151) {
          int v142 = v153;
        }
        else {
          int v142 = v152;
        }
      }
      uint64_t result = sub_1CBF27BBC((uint64_t)a2, v8, (uint64_t)__sz, v142);
      if (!result) {
        return result;
      }
      unint64_t v8 = (v8 >> 4) & 0x10;
      unsigned int v176 = *((_DWORD *)a2 + 6);
      if (v176 >= *((_DWORD *)a2 + 7)) {
        goto LABEL_431;
      }
      goto LABEL_298;
    case 43:
      unsigned int v30 = *((_DWORD *)a2 + 6);
      if (v30 >= *((_DWORD *)a2 + 7)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      BOOL v32 = (a4 & 0x800000) == 0 || (*(void *)(__sz[2] + 192) & 0x2000000000) == 0;
      unint64_t v33 = a4 & 0xFFFFFFFFFF7FFFFFLL;
LABEL_173:
      uint64_t v31 = v33 | 0x4000000000000000;
      if (v32) {
        uint64_t v31 = a4;
      }
      goto LABEL_175;
    case 44:
      uint64_t v61 = __sz[1];
      *(void *)(v61 + 272) += 24;
      uint64_t v62 = *(void *)(v61 + 192);
      if (((v62 + 7) & 0xFFFFFFFFFFFFFFF8) - v62 + 24 > *(void *)(v61 + 200) - v62)
      {
        unsigned int v180 = *(_DWORD *)(v61 + 216) >> 7;
        if (v180 >= 0x1E) {
          LOBYTE(v180) = 30;
        }
        uint64_t v181 = 4096 << v180;
        unint64_t v63 = (unint64_t)operator new(4096 << v180, (std::align_val_t)8uLL);
        unsigned int v182 = *(_DWORD *)(v61 + 216);
        if (v182 >= *(_DWORD *)(v61 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v61 + 208) + 8 * v182) = v63;
        ++*(_DWORD *)(v61 + 216);
        *(void *)(v61 + 200) = v63 + v181;
      }
      else
      {
        unint64_t v63 = (v62 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v61 + 192) = v63 + 24;
      *(unsigned char *)unint64_t v63 = 1;
      *(_DWORD *)(v63 + 1) = *(unsigned __int8 *)(v63 + 4) << 24;
      *(void *)(v63 + 8) = 0;
      *(void *)(v63 + 16) = v8;
      uint64_t v64 = __sz[1];
      *(void *)(v64 + 272) += 40;
      uint64_t v65 = *(void *)(v64 + 192);
      if (((v65 + 7) & 0xFFFFFFFFFFFFFFF8) - v65 + 40 > *(void *)(v64 + 200) - v65)
      {
        unsigned int v183 = *(_DWORD *)(v64 + 216) >> 7;
        if (v183 >= 0x1E) {
          LOBYTE(v183) = 30;
        }
        uint64_t v184 = 4096 << v183;
        unint64_t v66 = (unint64_t)operator new(4096 << v183, (std::align_val_t)8uLL);
        unsigned int v185 = *(_DWORD *)(v64 + 216);
        if (v185 >= *(_DWORD *)(v64 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v64 + 208) + 8 * v185) = v66;
        ++*(_DWORD *)(v64 + 216);
        *(void *)(v64 + 200) = v66 + v184;
      }
      else
      {
        unint64_t v66 = (v65 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v64 + 192) = v66 + 40;
      *(unsigned char *)(v66 + 8) = 4;
      uint64_t v67 = v66 + 8;
      *(_DWORD *)(v66 + 9) = *(unsigned __int8 *)(v66 + 12) << 24;
      *(void *)(v66 + 16) = 0;
      *(void *)unint64_t v66 = &unk_1F25FD370;
      int v68 = 8;
      goto LABEL_150;
    case 45:
      uint64_t v46 = (uint64_t)a2;
      unsigned int v47 = 1;
      unsigned int v48 = 1;
      goto LABEL_133;
    case 46:
      uint64_t v40 = a2;
      unint64_t v41 = a4;
      uint64_t v42 = (uint64_t)__sz;
      int v43 = 32;
      goto LABEL_196;
    case 47:
      uint64_t v40 = a2;
      unint64_t v41 = a4;
      uint64_t v42 = (uint64_t)__sz;
      int v43 = 16;
LABEL_196:
      return sub_1CBF27D94(v40, v41, v42, v43);
    case 48:
      uint64_t v46 = (uint64_t)a2;
      unsigned int v47 = 2;
      goto LABEL_101;
    case 49:
      unsigned int v30 = *((_DWORD *)a2 + 6);
      if (v30 >= *((_DWORD *)a2 + 7)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v31 = (__int16)a4;
      if ((a4 & 0x10000) != 0) {
        uint64_t v31 = (unsigned __int16)a4;
      }
      goto LABEL_175;
    case 50:
      unsigned int v30 = *((_DWORD *)a2 + 6);
      if (v30 >= *((_DWORD *)a2 + 7)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v31 = a4 & 7;
      goto LABEL_175;
    case 51:
      unint64_t v128 = ((a4 >> 11) & 7) - 1;
      if (v128 > 6 || ((0x67u >> v128) & 1) == 0) {
        return 0;
      }
      v129 = &unk_1CFAA0030;
      goto LABEL_258;
    case 52:
      unint64_t v128 = ((a4 >> 11) & 7) - 1;
      if (v128 > 6 || ((0x67u >> v128) & 1) == 0) {
        return 0;
      }
      v129 = &unk_1CFAA0068;
LABEL_258:
      uint64_t v39 = v129[v128];
      unint64_t v38 = a4 & 0x7FF;
      goto LABEL_259;
    case 53:
      unsigned int v30 = *((_DWORD *)a2 + 6);
      if (v30 >= *((_DWORD *)a2 + 7)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v31 = a4 & 0x3F;
      BOOL v44 = v31 == 0;
      uint64_t v45 = 64;
      goto LABEL_128;
    case 54:
      uint64_t v46 = (uint64_t)a2;
      unsigned int v47 = 37;
      unsigned int v48 = 0;
      unsigned int v49 = 124;
      goto LABEL_181;
    case 55:
      uint64_t v13 = (uint64_t)a2;
      unint64_t v14 = a4;
      uint64_t v15 = (uint64_t)__sz;
      int v16 = 96;
      goto LABEL_189;
    case 56:
      uint64_t v13 = (uint64_t)a2;
      unint64_t v14 = a4;
      uint64_t v15 = (uint64_t)__sz;
      int v16 = 160;
      goto LABEL_189;
    case 57:
      uint64_t result = 0;
      unint64_t v105 = a4;
      switch((a4 >> 11) & 0xF)
      {
        case 0uLL:
          v155 = a2 + 12;
          unsigned int v154 = *((_DWORD *)a2 + 6);
          if (v154 >= *((_DWORD *)a2 + 7)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          v156 = (uint64_t *)(*((void *)a2 + 2) + 16 * v154);
          uint64_t v157 = 2;
          goto LABEL_294;
        case 1uLL:
        case 2uLL:
        case 3uLL:
          uint64_t v106 = (uint64_t)a2;
          unsigned int v107 = 4;
          unsigned int v108 = 255;
          unsigned int v109 = 1;
          goto LABEL_252;
        case 4uLL:
          uint64_t v161 = __sz[1];
          *(void *)(v161 + 272) += 24;
          uint64_t v162 = *(void *)(v161 + 192);
          if (((v162 + 7) & 0xFFFFFFFFFFFFFFF8) - v162 + 24 > *(void *)(v161 + 200) - v162)
          {
            unint64_t v238 = a4;
            unsigned int v221 = *(_DWORD *)(v161 + 216) >> 7;
            if (v221 >= 0x1E) {
              LOBYTE(v221) = 30;
            }
            uint64_t v222 = 4096 << v221;
            unint64_t v160 = (unint64_t)operator new(4096 << v221, (std::align_val_t)8uLL);
            unsigned int v223 = *(_DWORD *)(v161 + 216);
            if (v223 >= *(_DWORD *)(v161 + 220)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(v161 + 208) + 8 * v223) = v160;
            ++*(_DWORD *)(v161 + 216);
            *(void *)(v161 + 200) = v160 + v222;
            unint64_t v105 = v238;
          }
          else
          {
            unint64_t v160 = (v162 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(v161 + 192) = v160 + 24;
          *(unsigned char *)unint64_t v160 = 1;
          *(_DWORD *)(v160 + 1) = *(unsigned __int8 *)(v160 + 4) << 24;
          *(void *)(v160 + 8) = 0;
          *(void *)(v160 + 16) = v105;
          goto LABEL_283;
        case 5uLL:
          uint64_t v163 = a4 | 0x100;
          uint64_t v164 = __sz[1];
          *(void *)(v164 + 272) += 24;
          uint64_t v165 = *(void *)(v164 + 192);
          if (((v165 + 7) & 0xFFFFFFFFFFFFFFF8) - v165 + 24 > *(void *)(v164 + 200) - v165)
          {
            unsigned int v224 = *(_DWORD *)(v164 + 216) >> 7;
            if (v224 >= 0x1E) {
              LOBYTE(v224) = 30;
            }
            uint64_t v225 = v164;
            uint64_t v226 = 4096 << v224;
            unint64_t v160 = (unint64_t)operator new(4096 << v224, (std::align_val_t)8uLL);
            unsigned int v227 = *(_DWORD *)(v225 + 216);
            if (v227 >= *(_DWORD *)(v225 + 220)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(v225 + 208) + 8 * v227) = v160;
            ++*(_DWORD *)(v225 + 216);
            uint64_t v164 = v225;
            *(void *)(v225 + 200) = v160 + v226;
          }
          else
          {
            unint64_t v160 = (v165 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(v164 + 192) = v160 + 24;
          *(unsigned char *)unint64_t v160 = 1;
          *(_DWORD *)(v160 + 1) = *(unsigned __int8 *)(v160 + 4) << 24;
          *(void *)(v160 + 8) = 0;
          *(void *)(v160 + 16) = v163;
LABEL_283:
          uint64_t v166 = __sz[1];
          *(void *)(v166 + 272) += 40;
          uint64_t v167 = *(void *)(v166 + 192);
          if (((v167 + 7) & 0xFFFFFFFFFFFFFFF8) - v167 + 40 > *(void *)(v166 + 200) - v167)
          {
            unsigned int v212 = *(_DWORD *)(v166 + 216) >> 7;
            if (v212 >= 0x1E) {
              LOBYTE(v212) = 30;
            }
            uint64_t v213 = 4096 << v212;
            unint64_t v168 = (unint64_t)operator new(4096 << v212, (std::align_val_t)8uLL);
            unsigned int v214 = *(_DWORD *)(v166 + 216);
            if (v214 >= *(_DWORD *)(v166 + 220)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(v166 + 208) + 8 * v214) = v168;
            ++*(_DWORD *)(v166 + 216);
            *(void *)(v166 + 200) = v168 + v213;
          }
          else
          {
            unint64_t v168 = (v167 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(v166 + 192) = v168 + 40;
          int v169 = 4;
          *(unsigned char *)(v168 + 8) = 4;
          unint64_t v105 = v168 + 8;
          *(_DWORD *)(v168 + 9) = *(unsigned __int8 *)(v168 + 12) << 24;
          *(void *)(v168 + 16) = 0;
          *(void *)unint64_t v168 = &unk_1F25FD370;
          goto LABEL_292;
        case 6uLL:
          uint64_t v158 = __sz[1];
          *(void *)(v158 + 272) += 24;
          uint64_t v159 = *(void *)(v158 + 192);
          if (((v159 + 7) & 0xFFFFFFFFFFFFFFF8) - v159 + 24 > *(void *)(v158 + 200) - v159)
          {
            unint64_t v237 = a4;
            unsigned int v218 = *(_DWORD *)(v158 + 216) >> 7;
            if (v218 >= 0x1E) {
              LOBYTE(v218) = 30;
            }
            uint64_t v219 = 4096 << v218;
            unint64_t v160 = (unint64_t)operator new(4096 << v218, (std::align_val_t)8uLL);
            unsigned int v220 = *(_DWORD *)(v158 + 216);
            if (v220 >= *(_DWORD *)(v158 + 220)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(v158 + 208) + 8 * v220) = v160;
            ++*(_DWORD *)(v158 + 216);
            *(void *)(v158 + 200) = v160 + v219;
            unint64_t v105 = v237;
          }
          else
          {
            unint64_t v160 = (v159 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(v158 + 192) = v160 + 24;
          *(unsigned char *)unint64_t v160 = 1;
          *(_DWORD *)(v160 + 1) = *(unsigned __int8 *)(v160 + 4) << 24;
          *(void *)(v160 + 8) = 0;
          *(void *)(v160 + 16) = v105;
          goto LABEL_289;
        case 7uLL:
          uint64_t v170 = a4 | 0x100;
          uint64_t v171 = __sz[1];
          *(void *)(v171 + 272) += 24;
          uint64_t v172 = *(void *)(v171 + 192);
          if (((v172 + 7) & 0xFFFFFFFFFFFFFFF8) - v172 + 24 > *(void *)(v171 + 200) - v172)
          {
            unsigned int v228 = *(_DWORD *)(v171 + 216) >> 7;
            if (v228 >= 0x1E) {
              LOBYTE(v228) = 30;
            }
            uint64_t v229 = v171;
            uint64_t v230 = 4096 << v228;
            unint64_t v160 = (unint64_t)operator new(4096 << v228, (std::align_val_t)8uLL);
            unsigned int v231 = *(_DWORD *)(v229 + 216);
            if (v231 >= *(_DWORD *)(v229 + 220)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(v229 + 208) + 8 * v231) = v160;
            ++*(_DWORD *)(v229 + 216);
            uint64_t v171 = v229;
            *(void *)(v229 + 200) = v160 + v230;
          }
          else
          {
            unint64_t v160 = (v172 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(v171 + 192) = v160 + 24;
          *(unsigned char *)unint64_t v160 = 1;
          *(_DWORD *)(v160 + 1) = *(unsigned __int8 *)(v160 + 4) << 24;
          *(void *)(v160 + 8) = 0;
          *(void *)(v160 + 16) = v170;
LABEL_289:
          uint64_t v173 = __sz[1];
          *(void *)(v173 + 272) += 40;
          uint64_t v174 = *(void *)(v173 + 192);
          if (((v174 + 7) & 0xFFFFFFFFFFFFFFF8) - v174 + 40 > *(void *)(v173 + 200) - v174)
          {
            unsigned int v215 = *(_DWORD *)(v173 + 216) >> 7;
            if (v215 >= 0x1E) {
              LOBYTE(v215) = 30;
            }
            uint64_t v216 = 4096 << v215;
            unint64_t v168 = (unint64_t)operator new(4096 << v215, (std::align_val_t)8uLL);
            unsigned int v217 = *(_DWORD *)(v173 + 216);
            if (v217 >= *(_DWORD *)(v173 + 220)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(v173 + 208) + 8 * v217) = v168;
            ++*(_DWORD *)(v173 + 216);
            *(void *)(v173 + 200) = v168 + v216;
          }
          else
          {
            unint64_t v168 = (v174 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(v173 + 192) = v168 + 40;
          *(unsigned char *)(v168 + 8) = 4;
          unint64_t v105 = v168 + 8;
          *(_DWORD *)(v168 + 9) = *(unsigned __int8 *)(v168 + 12) << 24;
          *(void *)(v168 + 16) = 0;
          *(void *)unint64_t v168 = &unk_1F25FD370;
          int v169 = 2;
LABEL_292:
          *(_DWORD *)(v168 + 24) = v169;
          *(void *)(v168 + 32) = v160;
          v155 = a2 + 12;
          unsigned int v175 = *((_DWORD *)a2 + 6);
          if (v175 >= *((_DWORD *)a2 + 7)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          v156 = (uint64_t *)(*((void *)a2 + 2) + 16 * v175);
          uint64_t v157 = 5;
LABEL_294:
          uint64_t *v156 = v157;
          v156[1] = v105;
          ++*v155;
          goto LABEL_295;
        case 9uLL:
        case 0xAuLL:
        case 0xBuLL:
          uint64_t v106 = (uint64_t)a2;
          unsigned int v107 = 17;
          unsigned int v108 = 127;
          unsigned int v109 = 2;
LABEL_252:
          uint64_t result = sub_1CBF27734(v106, v107, 0, v108, v109, v105, (uint64_t)__sz);
          if (!result) {
            return result;
          }
LABEL_295:
          uint64_t v143 = __rbit32(v8 >> 8) >> 29;
          uint64_t v144 = (32 * ((v8 & 0x3800) == 4096)) | (16 * ((v8 & 0x3800) == 6144));
          goto LABEL_296;
        default:
          return result;
      }
    case 58:
      unsigned int v30 = *((_DWORD *)a2 + 6);
      if (v30 >= *((_DWORD *)a2 + 7)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v31 = a4 & 7 | 8;
      goto LABEL_175;
    case 59:
      uint64_t v115 = __sz[1];
      *(void *)(v115 + 272) += 24;
      uint64_t v116 = *(void *)(v115 + 192);
      if (((v116 + 7) & 0xFFFFFFFFFFFFFFF8) - v116 + 24 > *(void *)(v115 + 200) - v116)
      {
        unsigned int v192 = *(_DWORD *)(v115 + 216) >> 7;
        if (v192 >= 0x1E) {
          LOBYTE(v192) = 30;
        }
        uint64_t v193 = 4096 << v192;
        unint64_t v63 = (unint64_t)operator new(4096 << v192, (std::align_val_t)8uLL);
        unsigned int v194 = *(_DWORD *)(v115 + 216);
        if (v194 >= *(_DWORD *)(v115 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v115 + 208) + 8 * v194) = v63;
        ++*(_DWORD *)(v115 + 216);
        *(void *)(v115 + 200) = v63 + v193;
      }
      else
      {
        unint64_t v63 = (v116 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v115 + 192) = v63 + 24;
      *(unsigned char *)unint64_t v63 = 1;
      *(_DWORD *)(v63 + 1) = *(unsigned __int8 *)(v63 + 4) << 24;
      *(void *)(v63 + 8) = 0;
      *(void *)(v63 + 16) = v8;
      uint64_t v117 = __sz[1];
      *(void *)(v117 + 272) += 40;
      uint64_t v118 = *(void *)(v117 + 192);
      if (((v118 + 7) & 0xFFFFFFFFFFFFFFF8) - v118 + 40 > *(void *)(v117 + 200) - v118)
      {
        unsigned int v195 = *(_DWORD *)(v117 + 216) >> 7;
        if (v195 >= 0x1E) {
          LOBYTE(v195) = 30;
        }
        uint64_t v196 = 4096 << v195;
        unint64_t v66 = (unint64_t)operator new(4096 << v195, (std::align_val_t)8uLL);
        unsigned int v197 = *(_DWORD *)(v117 + 216);
        if (v197 >= *(_DWORD *)(v117 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v117 + 208) + 8 * v197) = v66;
        ++*(_DWORD *)(v117 + 216);
        *(void *)(v117 + 200) = v66 + v196;
      }
      else
      {
        unint64_t v66 = (v118 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v117 + 192) = v66 + 40;
      *(unsigned char *)(v66 + 8) = 4;
      uint64_t v67 = v66 + 8;
      *(_DWORD *)(v66 + 9) = *(unsigned __int8 *)(v66 + 12) << 24;
      *(void *)(v66 + 16) = 0;
      *(void *)unint64_t v66 = &unk_1F25FD370;
      int v68 = 6;
LABEL_150:
      *(_DWORD *)(v66 + 24) = v68;
      *(void *)(v66 + 32) = v63;
      unsigned int v119 = *((_DWORD *)a2 + 6);
      if (v119 >= *((_DWORD *)a2 + 7)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v120 = (uint64_t *)(*((void *)a2 + 2) + 16 * v119);
      uint64_t v121 = 5;
LABEL_152:
      *uint64_t v120 = v121;
      v120[1] = v67;
      goto LABEL_327;
    case 60:
      unsigned int v30 = *((_DWORD *)a2 + 6);
      if (v30 >= *((_DWORD *)a2 + 7)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v31 = (uint64_t)(a4 << 58) >> 58;
      goto LABEL_175;
    case 61:
    case 62:
      uint64_t v11 = a4 & 0x1F;
      if ((a4 & 0x1F) == 0) {
        uint64_t v11 = 32;
      }
      uint64_t v12 = a4 & 0xF;
      if ((a4 & 0xF) == 0) {
        uint64_t v12 = 16;
      }
      if (*(unsigned char *)(__sz[2] + 196)) {
        unint64_t v8 = v12;
      }
      else {
        unint64_t v8 = v11;
      }
      goto LABEL_297;
    case 63:
      unsigned int v30 = *((_DWORD *)a2 + 6);
      if (v30 >= *((_DWORD *)a2 + 7)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v88 = 31;
      if ((*(void *)(__sz[2] + 192) & 0x200000000) == 0) {
        uint64_t v88 = 255;
      }
      uint64_t v31 = v88 & a4;
      BOOL v44 = v31 == 0;
LABEL_127:
      uint64_t v45 = 32;
      goto LABEL_128;
    case 64:
      unsigned int v30 = *((_DWORD *)a2 + 6);
      if (v30 >= *((_DWORD *)a2 + 7)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v31 = a4 & 0xF;
      BOOL v44 = v31 == 0;
      uint64_t v45 = 16;
LABEL_128:
      if (v44) {
        uint64_t v31 = v45;
      }
LABEL_175:
      v127 = (void *)(*((void *)a2 + 2) + 16 * v30);
      void *v127 = 2;
      v127[1] = v31;
      goto LABEL_327;
    case 65:
      uint64_t result = __sz[3];
      if (result)
      {
        if ((*(unsigned int (**)(uint64_t, unsigned __int16 *, void, void, uint64_t, void, uint64_t, void))(*(void *)result + 16))(result, a2, __sz[4], a4, a5, 0, 2, 0))
        {
          return 3;
        }
        else
        {
          return 0;
        }
      }
      return result;
    case 66:
      unint64_t v34 = (uint64_t (*)(uint64_t, void *, uint64_t, uint64_t))sub_1CBF27438;
      goto LABEL_227;
    case 67:
      uint64_t v23 = a2;
      unint64_t v24 = a4;
      uint64_t v25 = (uint64_t)__sz;
      int v26 = 32;
      uint64_t v27 = 0;
      unsigned __int8 v28 = 1;
      goto LABEL_222;
    case 68:
      uint64_t v130 = *(void *)(*((void *)a2 + 2) + 16 * sub_1CBC7A3F8(*a2, 0x16u) + 8);
      unsigned int v131 = (v130 >> 6) & 0xF;
      int v132 = 4;
      uint64_t result = 3;
      int v133 = 0;
      switch(v131)
      {
        case 1u:
        case 2u:
          int v132 = 5;
          goto LABEL_214;
        case 3u:
        case 7u:
        case 0xAu:
        case 0xBu:
LABEL_485:
          __break(1u);
          JUMPOUT(0x1CBF25DA4);
        case 4u:
        case 0xCu:
          switch(v130 & 0xF)
          {
            case 2:
            case 3:
            case 4:
            case 8:
              goto LABEL_265;
            case 5:
              goto LABEL_318;
            case 6:
            case 7:
              if ((v130 & 0x40000) != 0)
              {
LABEL_265:
                BOOL v148 = v131 == 12;
                int v149 = 35;
                int v150 = 37;
              }
              else
              {
LABEL_318:
                BOOL v148 = v131 == 12;
                int v149 = 39;
                int v150 = 41;
              }
              break;
            default:
              BOOL v148 = v131 == 12;
              int v149 = 17;
              int v150 = 22;
              break;
          }
          if (v148) {
            int v133 = v150;
          }
          else {
            int v133 = v149;
          }
          goto LABEL_322;
        case 5u:
        case 6u:
        case 8u:
          goto LABEL_322;
        case 9u:
LABEL_214:
          uint64_t v134 = __sz[1];
          *(void *)(v134 + 272) += 24;
          uint64_t v135 = *(void *)(v134 + 192);
          if (((v135 + 7) & 0xFFFFFFFFFFFFFFF8) - v135 + 24 > *(void *)(v134 + 200) - v135)
          {
            int v232 = v132;
            unsigned int v205 = *(_DWORD *)(v134 + 216) >> 7;
            if (v205 >= 0x1E) {
              LOBYTE(v205) = 30;
            }
            uint64_t v206 = v134;
            uint64_t v207 = 4096 << v205;
            v235 = (char *)operator new(4096 << v205, (std::align_val_t)8uLL);
            unsigned int v208 = *(_DWORD *)(v206 + 216);
            if (v208 >= *(_DWORD *)(v206 + 220)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            uint64_t v134 = v206;
            unint64_t v136 = (unint64_t)v235;
            *(void *)(*(void *)(v206 + 208) + 8 * v208) = v235;
            ++*(_DWORD *)(v206 + 216);
            *(void *)(v206 + 200) = &v235[v207];
            int v132 = v232;
          }
          else
          {
            unint64_t v136 = (v135 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(v134 + 192) = v136 + 24;
          *(unsigned char *)unint64_t v136 = 1;
          *(_DWORD *)(v136 + 1) = *(unsigned __int8 *)(v136 + 4) << 24;
          *(void *)(v136 + 8) = 0;
          *(void *)(v136 + 16) = v8;
          uint64_t v137 = __sz[1];
          *(void *)(v137 + 272) += 40;
          uint64_t v138 = *(void *)(v137 + 192);
          if (((v138 + 7) & 0xFFFFFFFFFFFFFFF8) - v138 + 40 > *(void *)(v137 + 200) - v138)
          {
            int v233 = v132;
            unint64_t v236 = v136;
            unsigned int v209 = *(_DWORD *)(v137 + 216) >> 7;
            if (v209 >= 0x1E) {
              LOBYTE(v209) = 30;
            }
            uint64_t v210 = 4096 << v209;
            unint64_t v139 = (unint64_t)operator new(4096 << v209, (std::align_val_t)8uLL);
            unsigned int v211 = *(_DWORD *)(v137 + 216);
            if (v211 >= *(_DWORD *)(v137 + 220)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(v137 + 208) + 8 * v211) = v139;
            ++*(_DWORD *)(v137 + 216);
            *(void *)(v137 + 200) = v139 + v210;
            unint64_t v136 = v236;
            int v132 = v233;
          }
          else
          {
            unint64_t v139 = (v138 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(v137 + 192) = v139 + 40;
          *(unsigned char *)(v139 + 8) = 4;
          *(_DWORD *)(v139 + 9) = *(unsigned __int8 *)(v139 + 12) << 24;
          *(void *)(v139 + 16) = 0;
          *(void *)unint64_t v139 = &unk_1F25FD370;
          *(_DWORD *)(v139 + 24) = v132;
          *(void *)(v139 + 32) = v136;
          unsigned int v140 = *((_DWORD *)a2 + 6);
          if (v140 >= *((_DWORD *)a2 + 7)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          char v141 = (void *)(*((void *)a2 + 2) + 16 * v140);
          *char v141 = 5;
          v141[1] = v139 + 8;
          unsigned int v87 = *((_DWORD *)a2 + 6) + 1;
          *((_DWORD *)a2 + 6) = v87;
          goto LABEL_324;
        case 0xDu:
          int v133 = 4;
LABEL_322:
          uint64_t result = sub_1CBF27BBC((uint64_t)a2, v8, (uint64_t)__sz, v133);
          if (!result) {
            return result;
          }
          unsigned int v87 = *((_DWORD *)a2 + 6);
LABEL_324:
          unint64_t v8 = (v8 >> 4) & 0x10;
          if (v87 < *((_DWORD *)a2 + 7)) {
            goto LABEL_325;
          }
          goto LABEL_467;
        default:
          return result;
      }
    case 69:
      uint64_t v23 = a2;
      unint64_t v24 = a4;
      uint64_t v25 = (uint64_t)__sz;
      int v26 = 32;
      goto LABEL_221;
    case 70:
      uint64_t v23 = a2;
      unint64_t v24 = a4;
      uint64_t v25 = (uint64_t)__sz;
      int v26 = 16;
      uint64_t v27 = 1;
      unsigned __int8 v28 = 0;
      int v29 = 0;
      goto LABEL_223;
    case 71:
      unsigned int v18 = a2;
      unint64_t v19 = a4;
      uint64_t v20 = (uint64_t)__sz;
      int v21 = 0;
      goto LABEL_31;
    case 72:
      uint64_t v46 = (uint64_t)a2;
      unsigned int v47 = 20;
      unsigned int v48 = 0;
      unsigned int v49 = 252;
      goto LABEL_183;
    case 73:
      uint64_t v72 = (uint64_t)a2;
      unint64_t v73 = a4;
      uint64_t v74 = (uint64_t)__sz;
      int v75 = 64;
LABEL_200:
      return sub_1CBF27AD8(v72, v73, v74, v75);
    case 74:
      uint64_t result = sub_1CBF27734((uint64_t)a2, 0x2Du, 0, 0x75u, 2u, a4, (uint64_t)__sz);
      if (!result) {
        return result;
      }
      unint64_t v8 = (v8 >> 4) & 0x10;
      goto LABEL_297;
    case 75:
      uint64_t v46 = (uint64_t)a2;
      unsigned int v47 = 41;
      unsigned int v48 = 0;
      unsigned int v49 = 122;
      goto LABEL_181;
    case 76:
    case 78:
    case 80:
      int v10 = sub_1CBF27580;
      goto LABEL_14;
    case 77:
      int v10 = sub_1CBF276C4;
LABEL_14:
      return sub_1CBF275EC((uint64_t (*)(uint64_t, void *, uint64_t, uint64_t))v10, (uint64_t)a2, a3, a4, a5, (uint64_t)__sz);
    case 79:
      uint64_t v37 = (a4 >> 16) & 7;
      if (v37 == 7 || ((0x5Bu >> (BYTE2(a4) & 7)) & 1) == 0) {
        return 0;
      }
      unint64_t v38 = a4;
      uint64_t v39 = qword_1CFAA00A0[v37];
LABEL_259:
      unint64_t v51 = v39 | v38;
LABEL_260:
      uint64_t v50 = (uint64_t)a2;
LABEL_261:
      return sub_1CBF262D4(v50, v51, (uint64_t)__sz);
    case 81:
      unsigned int v17 = sub_1CBF261A4;
      goto LABEL_204;
    case 82:
      unsigned int v17 = sub_1CBF26A0C;
      goto LABEL_204;
    case 83:
      unsigned int v17 = sub_1CBF26A44;
      goto LABEL_204;
    case 84:
      uint64_t v13 = (uint64_t)a2;
      unint64_t v14 = a4;
      uint64_t v15 = (uint64_t)__sz;
      int v16 = 48;
LABEL_189:
      return sub_1CBF277EC(v13, v14, v15, v16);
    case 85:
      unsigned int v17 = sub_1CBF26A28;
      goto LABEL_204;
    case 86:
      unsigned int v17 = sub_1CBF26A60;
      goto LABEL_204;
    case 87:
      unsigned int v17 = sub_1CBF269D4;
      goto LABEL_204;
    case 88:
      unsigned int v17 = sub_1CBF269F0;
LABEL_204:
      return sub_1CBF27398((uint64_t (*)(uint64_t, void *, uint64_t, uint64_t))v17, (uint64_t)a2, a4, a5, (uint64_t)__sz);
    case 89:
      unint64_t v34 = (uint64_t (*)(uint64_t, void *, uint64_t, uint64_t))sub_1CBF27580;
LABEL_227:
      return sub_1CBF274CC(v34, (uint64_t)a2, a3, a4, a5, (uint64_t)__sz);
    case 90:
      uint64_t v23 = a2;
      unint64_t v24 = a4;
      uint64_t v25 = (uint64_t)__sz;
      int v26 = 16;
LABEL_221:
      uint64_t v27 = 1;
      unsigned __int8 v28 = 0;
LABEL_222:
      int v29 = 1;
LABEL_223:
      return sub_1CBF27F90(v23, v24, v25, v26, v27, v28, v29);
    case 91:
      unsigned int v18 = a2;
      unint64_t v19 = a4;
      uint64_t v20 = (uint64_t)__sz;
      int v21 = 1;
LABEL_31:
      return sub_1CBF28178(v18, v19, v20, v21);
    default:
      uint64_t v46 = (uint64_t)a2;
      unsigned int v47 = 6;
LABEL_101:
      unsigned int v48 = 0;
      unsigned int v49 = 128;
LABEL_181:
      unsigned int v70 = 2;
      goto LABEL_184;
  }
}

uint64_t sub_1CBF261A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1CBF27734(a1, 6u, 0, 0x80u, 2u, *(void *)(a2 + 8), a4);
}

uint64_t sub_1CBF261C0(int a1, uint64_t a2, unint64_t a3)
{
  HIDWORD(v3) = a1;
  LODWORD(v3) = a1 - 8;
  switch((v3 >> 3))
  {
    case 0u:
      if (a3 > 0xFF) {
        goto LABEL_12;
      }
      LODWORD(a3) = (char)a3;
      goto LABEL_10;
    case 1u:
      if (a3 >> 16) {
        goto LABEL_12;
      }
      LODWORD(a3) = (__int16)a3;
      goto LABEL_10;
    case 2u:
      if (a3 >> 24) {
        goto LABEL_12;
      }
      LODWORD(a3) = (int)(a3 << 8) >> 8;
LABEL_10:
      unsigned int v5 = *(_DWORD *)(a2 + 24);
      if (v5 >= *(_DWORD *)(a2 + 28)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v6 = (void *)(*(void *)(a2 + 16) + 16 * v5);
      *uint64_t v6 = 2;
      v6[1] = (int)a3;
      ++*(_DWORD *)(a2 + 24);
      uint64_t result = 3;
      break;
    case 3u:
      if (!HIDWORD(a3)) {
        goto LABEL_10;
      }
LABEL_12:
      uint64_t result = 0;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t sub_1CBF262B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1CBF27734(a1, 0, 0, 0x100u, 1u, *(void *)(a2 + 8), a4);
}

uint64_t sub_1CBF262D4(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t result = 0;
  unsigned int v6 = a2;
  unint64_t v7 = a2;
  switch((a2 >> 11) & 0xF)
  {
    case 0uLL:
      uint64_t v13 = (_DWORD *)(a1 + 24);
      unsigned int v12 = *(_DWORD *)(a1 + 24);
      if (v12 >= *(_DWORD *)(a1 + 28)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      unint64_t v14 = (uint64_t *)(*(void *)(a1 + 16) + 16 * v12);
      uint64_t v15 = 2;
      goto LABEL_28;
    case 1uLL:
    case 2uLL:
    case 3uLL:
      uint64_t v8 = a1;
      unsigned int v9 = 0;
      unsigned int v10 = 256;
      unsigned int v11 = 1;
      goto LABEL_4;
    case 4uLL:
      uint64_t v16 = *(void *)(a3 + 8);
      *(void *)(v16 + 272) += 24;
      uint64_t v17 = *(void *)(v16 + 192);
      if (((v17 + 7) & 0xFFFFFFFFFFFFFFF8) - v17 + 24 > *(void *)(v16 + 200) - v17)
      {
        unsigned int v43 = *(_DWORD *)(v16 + 216) >> 7;
        if (v43 >= 0x1E) {
          LOBYTE(v43) = 30;
        }
        uint64_t v44 = 4096 << v43;
        unint64_t v18 = (unint64_t)operator new(4096 << v43, (std::align_val_t)8uLL);
        unsigned int v45 = *(_DWORD *)(v16 + 216);
        if (v45 >= *(_DWORD *)(v16 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v16 + 208) + 8 * v45) = v18;
        ++*(_DWORD *)(v16 + 216);
        *(void *)(v16 + 200) = v18 + v44;
      }
      else
      {
        unint64_t v18 = (v17 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v16 + 192) = v18 + 24;
      *(unsigned char *)unint64_t v18 = 1;
      *(_DWORD *)(v18 + 1) = *(unsigned __int8 *)(v18 + 4) << 24;
      *(void *)(v18 + 8) = 0;
      *(void *)(v18 + 16) = v7;
      goto LABEL_14;
    case 5uLL:
      uint64_t v19 = a2 | 0x100;
      uint64_t v20 = *(void *)(a3 + 8);
      *(void *)(v20 + 272) += 24;
      uint64_t v21 = *(void *)(v20 + 192);
      if (((v21 + 7) & 0xFFFFFFFFFFFFFFF8) - v21 + 24 > *(void *)(v20 + 200) - v21)
      {
        unsigned int v46 = *(_DWORD *)(v20 + 216) >> 7;
        if (v46 >= 0x1E) {
          LOBYTE(v46) = 30;
        }
        uint64_t v47 = 4096 << v46;
        unint64_t v18 = (unint64_t)operator new(4096 << v46, (std::align_val_t)8uLL);
        unsigned int v48 = *(_DWORD *)(v20 + 216);
        if (v48 >= *(_DWORD *)(v20 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v20 + 208) + 8 * v48) = v18;
        ++*(_DWORD *)(v20 + 216);
        *(void *)(v20 + 200) = v18 + v47;
      }
      else
      {
        unint64_t v18 = (v21 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v20 + 192) = v18 + 24;
      *(unsigned char *)unint64_t v18 = 1;
      *(_DWORD *)(v18 + 1) = *(unsigned __int8 *)(v18 + 4) << 24;
      *(void *)(v18 + 8) = 0;
      *(void *)(v18 + 16) = v19;
LABEL_14:
      uint64_t v22 = *(void *)(a3 + 8);
      *(void *)(v22 + 272) += 40;
      uint64_t v23 = *(void *)(v22 + 192);
      if (((v23 + 7) & 0xFFFFFFFFFFFFFFF8) - v23 + 40 > *(void *)(v22 + 200) - v23)
      {
        unsigned int v37 = *(_DWORD *)(v22 + 216) >> 7;
        if (v37 >= 0x1E) {
          LOBYTE(v37) = 30;
        }
        uint64_t v38 = 4096 << v37;
        unint64_t v24 = (unint64_t)operator new(4096 << v37, (std::align_val_t)8uLL);
        unsigned int v39 = *(_DWORD *)(v22 + 216);
        if (v39 >= *(_DWORD *)(v22 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v22 + 208) + 8 * v39) = v24;
        ++*(_DWORD *)(v22 + 216);
        *(void *)(v22 + 200) = v24 + v38;
      }
      else
      {
        unint64_t v24 = (v23 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v22 + 192) = v24 + 40;
      *(unsigned char *)(v24 + 8) = 4;
      unint64_t v7 = v24 + 8;
      *(_DWORD *)(v24 + 9) = *(unsigned __int8 *)(v24 + 12) << 24;
      *(void *)(v24 + 16) = 0;
      *(void *)unint64_t v24 = &unk_1F25FD370;
      int v25 = 5;
      goto LABEL_26;
    case 6uLL:
      uint64_t v26 = *(void *)(a3 + 8);
      *(void *)(v26 + 272) += 24;
      uint64_t v27 = *(void *)(v26 + 192);
      if (((v27 + 7) & 0xFFFFFFFFFFFFFFF8) - v27 + 24 > *(void *)(v26 + 200) - v27)
      {
        unsigned int v49 = *(_DWORD *)(v26 + 216) >> 7;
        if (v49 >= 0x1E) {
          LOBYTE(v49) = 30;
        }
        uint64_t v50 = 4096 << v49;
        unint64_t v18 = (unint64_t)operator new(4096 << v49, (std::align_val_t)8uLL);
        unsigned int v51 = *(_DWORD *)(v26 + 216);
        if (v51 >= *(_DWORD *)(v26 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v26 + 208) + 8 * v51) = v18;
        ++*(_DWORD *)(v26 + 216);
        *(void *)(v26 + 200) = v18 + v50;
      }
      else
      {
        unint64_t v18 = (v27 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v26 + 192) = v18 + 24;
      *(unsigned char *)unint64_t v18 = 1;
      *(_DWORD *)(v18 + 1) = *(unsigned __int8 *)(v18 + 4) << 24;
      *(void *)(v18 + 8) = 0;
      *(void *)(v18 + 16) = v7;
      goto LABEL_23;
    case 7uLL:
      uint64_t v28 = a2 | 0x100;
      uint64_t v29 = *(void *)(a3 + 8);
      *(void *)(v29 + 272) += 24;
      uint64_t v30 = *(void *)(v29 + 192);
      if (((v30 + 7) & 0xFFFFFFFFFFFFFFF8) - v30 + 24 > *(void *)(v29 + 200) - v30)
      {
        unsigned int v52 = *(_DWORD *)(v29 + 216) >> 7;
        if (v52 >= 0x1E) {
          LOBYTE(v52) = 30;
        }
        uint64_t v53 = 4096 << v52;
        unint64_t v18 = (unint64_t)operator new(4096 << v52, (std::align_val_t)8uLL);
        unsigned int v54 = *(_DWORD *)(v29 + 216);
        if (v54 >= *(_DWORD *)(v29 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v29 + 208) + 8 * v54) = v18;
        ++*(_DWORD *)(v29 + 216);
        *(void *)(v29 + 200) = v18 + v53;
      }
      else
      {
        unint64_t v18 = (v30 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v29 + 192) = v18 + 24;
      *(unsigned char *)unint64_t v18 = 1;
      *(_DWORD *)(v18 + 1) = *(unsigned __int8 *)(v18 + 4) << 24;
      *(void *)(v18 + 8) = 0;
      *(void *)(v18 + 16) = v28;
LABEL_23:
      uint64_t v31 = *(void *)(a3 + 8);
      *(void *)(v31 + 272) += 40;
      uint64_t v32 = *(void *)(v31 + 192);
      if (((v32 + 7) & 0xFFFFFFFFFFFFFFF8) - v32 + 40 > *(void *)(v31 + 200) - v32)
      {
        unsigned int v40 = *(_DWORD *)(v31 + 216) >> 7;
        if (v40 >= 0x1E) {
          LOBYTE(v40) = 30;
        }
        uint64_t v41 = 4096 << v40;
        unint64_t v24 = (unint64_t)operator new(4096 << v40, (std::align_val_t)8uLL);
        unsigned int v42 = *(_DWORD *)(v31 + 216);
        if (v42 >= *(_DWORD *)(v31 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v31 + 208) + 8 * v42) = v24;
        ++*(_DWORD *)(v31 + 216);
        *(void *)(v31 + 200) = v24 + v41;
      }
      else
      {
        unint64_t v24 = (v32 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v31 + 192) = v24 + 40;
      int v25 = 4;
      *(unsigned char *)(v24 + 8) = 4;
      unint64_t v7 = v24 + 8;
      *(_DWORD *)(v24 + 9) = *(unsigned __int8 *)(v24 + 12) << 24;
      *(void *)(v24 + 16) = 0;
      *(void *)unint64_t v24 = &unk_1F25FD370;
LABEL_26:
      *(_DWORD *)(v24 + 24) = v25;
      *(void *)(v24 + 32) = v18;
      uint64_t v13 = (_DWORD *)(a1 + 24);
      unsigned int v33 = *(_DWORD *)(a1 + 24);
      if (v33 >= *(_DWORD *)(a1 + 28)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      unint64_t v14 = (uint64_t *)(*(void *)(a1 + 16) + 16 * v33);
      uint64_t v15 = 5;
LABEL_28:
      *unint64_t v14 = v15;
      v14[1] = v7;
      ++*v13;
      goto LABEL_29;
    case 9uLL:
    case 0xAuLL:
    case 0xBuLL:
      uint64_t v8 = a1;
      unsigned int v9 = 6;
      unsigned int v10 = 128;
      unsigned int v11 = 2;
LABEL_4:
      uint64_t result = sub_1CBF27734(v8, v9, 0, v10, v11, v7, a3);
      if (!result) {
        return result;
      }
LABEL_29:
      uint64_t v34 = (32 * ((v6 & 0x3800) == 4096)) | (16 * ((v6 & 0x3800) == 6144)) | (__rbit32(v6 >> 8) >> 29);
      unsigned int v35 = *(_DWORD *)(a1 + 24);
      if (v35 >= *(_DWORD *)(a1 + 28)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      unsigned int v36 = (void *)(*(void *)(a1 + 16) + 16 * v35);
      *unsigned int v36 = 2;
      v36[1] = v34;
      ++*(_DWORD *)(a1 + 24);
      uint64_t result = 3;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_1CBF269D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1CBF27734(a1, 0xFu, 0, 0xFDu, 1u, *(void *)(a2 + 8), a4);
}

uint64_t sub_1CBF269F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1CBF27734(a1, 0x23u, 0, 0x7Du, 2u, *(void *)(a2 + 8), a4);
}

uint64_t sub_1CBF26A0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1CBF27734(a1, 4u, 0, 0xFFu, 1u, *(void *)(a2 + 8), a4);
}

uint64_t sub_1CBF26A28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1CBF27734(a1, 0xAu, 0, 0xFEu, 1u, *(void *)(a2 + 8), a4);
}

uint64_t sub_1CBF26A44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1CBF27734(a1, 0x11u, 0, 0x7Fu, 2u, *(void *)(a2 + 8), a4);
}

uint64_t sub_1CBF26A60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1CBF27734(a1, 0x1Bu, 0, 0x7Eu, 2u, *(void *)(a2 + 8), a4);
}

uint64_t sub_1CBF26A7C(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t result = 0;
  uint64_t v5 = (a2 >> 11) & 0xF;
  uint64_t v8 = (a2 >> 15) & 7;
  unint64_t v9 = a2;
  switch(v5)
  {
    case 0:
      uint64_t v16 = (unint64_t)a2 << v8;
      goto LABEL_38;
    case 1:
    case 2:
    case 3:
      uint64_t v10 = a1;
      unsigned int v11 = 0;
      unsigned int v12 = 256;
      unsigned int v13 = 1;
      goto LABEL_6;
    case 4:
      uint64_t v17 = *(void *)(a3 + 8);
      *(void *)(v17 + 272) += 24;
      uint64_t v18 = *(void *)(v17 + 192);
      if (((v18 + 7) & 0xFFFFFFFFFFFFFFF8) - v18 + 24 > *(void *)(v17 + 200) - v18)
      {
        unsigned int v49 = *(_DWORD *)(v17 + 216) >> 7;
        if (v49 >= 0x1E) {
          LOBYTE(v49) = 30;
        }
        uint64_t v50 = 4096 << v49;
        unint64_t v19 = (unint64_t)operator new(4096 << v49, (std::align_val_t)8uLL);
        unsigned int v51 = *(_DWORD *)(v17 + 216);
        if (v51 >= *(_DWORD *)(v17 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v17 + 208) + 8 * v51) = v19;
        ++*(_DWORD *)(v17 + 216);
        *(void *)(v17 + 200) = v19 + v50;
      }
      else
      {
        unint64_t v19 = (v18 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v17 + 192) = v19 + 24;
      *(unsigned char *)unint64_t v19 = 1;
      *(_DWORD *)(v19 + 1) = *(unsigned __int8 *)(v19 + 4) << 24;
      *(void *)(v19 + 8) = 0;
      *(void *)(v19 + 16) = v9;
      uint64_t v20 = *(void *)(a3 + 8);
      *(void *)(v20 + 272) += 40;
      uint64_t v21 = *(void *)(v20 + 192);
      if (((v21 + 7) & 0xFFFFFFFFFFFFFFF8) - v21 + 40 > *(void *)(v20 + 200) - v21)
      {
        unsigned int v52 = *(_DWORD *)(v20 + 216) >> 7;
        if (v52 >= 0x1E) {
          LOBYTE(v52) = 30;
        }
        uint64_t v53 = 4096 << v52;
        unint64_t v22 = (unint64_t)operator new(4096 << v52, (std::align_val_t)8uLL);
        unsigned int v54 = *(_DWORD *)(v20 + 216);
        if (v54 >= *(_DWORD *)(v20 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v20 + 208) + 8 * v54) = v22;
        ++*(_DWORD *)(v20 + 216);
        *(void *)(v20 + 200) = v22 + v53;
      }
      else
      {
        unint64_t v22 = (v21 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v20 + 192) = v22 + 40;
      *(unsigned char *)(v22 + 8) = 4;
      unint64_t v23 = v22 + 8;
      *(_DWORD *)(v22 + 9) = *(unsigned __int8 *)(v22 + 12) << 24;
      *(void *)(v22 + 16) = 0;
      *(void *)unint64_t v22 = &unk_1F25FD370;
      int v24 = 5;
      goto LABEL_27;
    case 5:
      uint64_t v25 = a2 | 0x100;
      uint64_t v26 = *(void *)(a3 + 8);
      *(void *)(v26 + 272) += 24;
      uint64_t v27 = *(void *)(v26 + 192);
      if (((v27 + 7) & 0xFFFFFFFFFFFFFFF8) - v27 + 24 > *(void *)(v26 + 200) - v27)
      {
        unsigned int v55 = *(_DWORD *)(v26 + 216) >> 7;
        if (v55 >= 0x1E) {
          LOBYTE(v55) = 30;
        }
        uint64_t v56 = 4096 << v55;
        unint64_t v28 = (unint64_t)operator new(4096 << v55, (std::align_val_t)8uLL);
        unsigned int v57 = *(_DWORD *)(v26 + 216);
        if (v57 >= *(_DWORD *)(v26 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v26 + 208) + 8 * v57) = v28;
        ++*(_DWORD *)(v26 + 216);
        *(void *)(v26 + 200) = v28 + v56;
      }
      else
      {
        unint64_t v28 = (v27 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v26 + 192) = v28 + 24;
      *(unsigned char *)unint64_t v28 = 1;
      *(_DWORD *)(v28 + 1) = *(unsigned __int8 *)(v28 + 4) << 24;
      *(void *)(v28 + 8) = 0;
      *(void *)(v28 + 16) = v25;
      uint64_t v29 = *(void *)(a3 + 8);
      *(void *)(v29 + 272) += 40;
      uint64_t v30 = *(void *)(v29 + 192);
      if (((v30 + 7) & 0xFFFFFFFFFFFFFFF8) - v30 + 40 > *(void *)(v29 + 200) - v30)
      {
        unsigned int v58 = *(_DWORD *)(v29 + 216) >> 7;
        if (v58 >= 0x1E) {
          LOBYTE(v58) = 30;
        }
        uint64_t v59 = 4096 << v58;
        unint64_t v31 = (unint64_t)operator new(4096 << v58, (std::align_val_t)8uLL);
        unsigned int v60 = *(_DWORD *)(v29 + 216);
        if (v60 >= *(_DWORD *)(v29 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v29 + 208) + 8 * v60) = v31;
        ++*(_DWORD *)(v29 + 216);
        *(void *)(v29 + 200) = v31 + v59;
      }
      else
      {
        unint64_t v31 = (v30 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v29 + 192) = v31 + 40;
      *(unsigned char *)(v31 + 8) = 4;
      unint64_t v32 = v31 + 8;
      *(_DWORD *)(v31 + 9) = *(unsigned __int8 *)(v31 + 12) << 24;
      *(void *)(v31 + 16) = 0;
      *(void *)unint64_t v31 = &unk_1F25FD370;
      int v33 = 5;
      goto LABEL_34;
    case 6:
      uint64_t v34 = *(void *)(a3 + 8);
      *(void *)(v34 + 272) += 24;
      uint64_t v35 = *(void *)(v34 + 192);
      if (((v35 + 7) & 0xFFFFFFFFFFFFFFF8) - v35 + 24 > *(void *)(v34 + 200) - v35)
      {
        unsigned int v61 = *(_DWORD *)(v34 + 216) >> 7;
        if (v61 >= 0x1E) {
          LOBYTE(v61) = 30;
        }
        uint64_t v62 = 4096 << v61;
        unint64_t v19 = (unint64_t)operator new(4096 << v61, (std::align_val_t)8uLL);
        unsigned int v63 = *(_DWORD *)(v34 + 216);
        if (v63 >= *(_DWORD *)(v34 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v34 + 208) + 8 * v63) = v19;
        ++*(_DWORD *)(v34 + 216);
        *(void *)(v34 + 200) = v19 + v62;
      }
      else
      {
        unint64_t v19 = (v35 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v34 + 192) = v19 + 24;
      *(unsigned char *)unint64_t v19 = 1;
      *(_DWORD *)(v19 + 1) = *(unsigned __int8 *)(v19 + 4) << 24;
      *(void *)(v19 + 8) = 0;
      *(void *)(v19 + 16) = v9;
      uint64_t v36 = *(void *)(a3 + 8);
      *(void *)(v36 + 272) += 40;
      uint64_t v37 = *(void *)(v36 + 192);
      if (((v37 + 7) & 0xFFFFFFFFFFFFFFF8) - v37 + 40 > *(void *)(v36 + 200) - v37)
      {
        unsigned int v64 = *(_DWORD *)(v36 + 216) >> 7;
        if (v64 >= 0x1E) {
          LOBYTE(v64) = 30;
        }
        uint64_t v65 = 4096 << v64;
        unint64_t v22 = (unint64_t)operator new(4096 << v64, (std::align_val_t)8uLL);
        unsigned int v66 = *(_DWORD *)(v36 + 216);
        if (v66 >= *(_DWORD *)(v36 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v36 + 208) + 8 * v66) = v22;
        ++*(_DWORD *)(v36 + 216);
        *(void *)(v36 + 200) = v22 + v65;
      }
      else
      {
        unint64_t v22 = (v37 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v36 + 192) = v22 + 40;
      int v24 = 4;
      *(unsigned char *)(v22 + 8) = 4;
      unint64_t v23 = v22 + 8;
      *(_DWORD *)(v22 + 9) = *(unsigned __int8 *)(v22 + 12) << 24;
      *(void *)(v22 + 16) = 0;
      *(void *)unint64_t v22 = &unk_1F25FD370;
LABEL_27:
      *(_DWORD *)(v22 + 24) = v24;
      *(void *)(v22 + 32) = v19;
      unsigned int v38 = *(_DWORD *)(a1 + 24);
      if (v38 >= *(_DWORD *)(a1 + 28)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v15 = 0;
      unsigned int v39 = (void *)(*(void *)(a1 + 16) + 16 * v38);
      *unsigned int v39 = 5;
      v39[1] = v23;
      goto LABEL_36;
    case 7:
      uint64_t v40 = a2 | 0x100;
      uint64_t v41 = *(void *)(a3 + 8);
      *(void *)(v41 + 272) += 24;
      uint64_t v42 = *(void *)(v41 + 192);
      if (((v42 + 7) & 0xFFFFFFFFFFFFFFF8) - v42 + 24 > *(void *)(v41 + 200) - v42)
      {
        unsigned int v67 = *(_DWORD *)(v41 + 216) >> 7;
        if (v67 >= 0x1E) {
          LOBYTE(v67) = 30;
        }
        uint64_t v68 = 4096 << v67;
        unint64_t v28 = (unint64_t)operator new(4096 << v67, (std::align_val_t)8uLL);
        unsigned int v69 = *(_DWORD *)(v41 + 216);
        if (v69 >= *(_DWORD *)(v41 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v41 + 208) + 8 * v69) = v28;
        ++*(_DWORD *)(v41 + 216);
        *(void *)(v41 + 200) = v28 + v68;
      }
      else
      {
        unint64_t v28 = (v42 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v41 + 192) = v28 + 24;
      *(unsigned char *)unint64_t v28 = 1;
      *(_DWORD *)(v28 + 1) = *(unsigned __int8 *)(v28 + 4) << 24;
      *(void *)(v28 + 8) = 0;
      *(void *)(v28 + 16) = v40;
      uint64_t v43 = *(void *)(a3 + 8);
      *(void *)(v43 + 272) += 40;
      uint64_t v44 = *(void *)(v43 + 192);
      if (((v44 + 7) & 0xFFFFFFFFFFFFFFF8) - v44 + 40 > *(void *)(v43 + 200) - v44)
      {
        unsigned int v70 = *(_DWORD *)(v43 + 216) >> 7;
        if (v70 >= 0x1E) {
          LOBYTE(v70) = 30;
        }
        uint64_t v71 = 4096 << v70;
        unint64_t v31 = (unint64_t)operator new(4096 << v70, (std::align_val_t)8uLL);
        unsigned int v72 = *(_DWORD *)(v43 + 216);
        if (v72 >= *(_DWORD *)(v43 + 220)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v43 + 208) + 8 * v72) = v31;
        ++*(_DWORD *)(v43 + 216);
        *(void *)(v43 + 200) = v31 + v71;
      }
      else
      {
        unint64_t v31 = (v44 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(v43 + 192) = v31 + 40;
      int v33 = 4;
      *(unsigned char *)(v31 + 8) = 4;
      unint64_t v32 = v31 + 8;
      *(_DWORD *)(v31 + 9) = *(unsigned __int8 *)(v31 + 12) << 24;
      *(void *)(v31 + 16) = 0;
      *(void *)unint64_t v31 = &unk_1F25FD370;
LABEL_34:
      *(_DWORD *)(v31 + 24) = v33;
      *(void *)(v31 + 32) = v28;
      unsigned int v45 = *(_DWORD *)(a1 + 24);
      if (v45 >= *(_DWORD *)(a1 + 28)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v15 = 0;
      unsigned int v46 = (void *)(*(void *)(a1 + 16) + 16 * v45);
      *unsigned int v46 = 5;
      v46[1] = v32;
LABEL_36:
      ++*(_DWORD *)(a1 + 24);
      goto LABEL_37;
    case 9:
    case 10:
    case 11:
      uint64_t v10 = a1;
      unsigned int v11 = 6;
      unsigned int v12 = 128;
      goto LABEL_5;
    case 13:
    case 14:
    case 15:
      uint64_t v10 = a1;
      unsigned int v11 = 17;
      unsigned int v12 = 127;
LABEL_5:
      unsigned int v13 = 2;
LABEL_6:
      uint64_t result = sub_1CBF27734(v10, v11, 0, v12, v13, v9, a3);
      if (result)
      {
        uint64_t v14 = v5 - 1;
        if (unint64_t)(v5 - 1) <= 0xE && ((0x7707u >> v14))
        {
          uint64_t v15 = qword_1CFAA00D8[v14];
LABEL_37:
          uint64_t v16 = v15 | (a2 >> 7) & 8 | (v8 << 6);
LABEL_38:
          unsigned int v47 = *(_DWORD *)(a1 + 24);
          if (v47 >= *(_DWORD *)(a1 + 28)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          unsigned int v48 = (void *)(*(void *)(a1 + 16) + 16 * v47);
          *unsigned int v48 = 2;
          v48[1] = v16;
          ++*(_DWORD *)(a1 + 24);
          uint64_t result = 3;
        }
        else
        {
          uint64_t result = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_1CBF27398(uint64_t (*a1)(uint64_t, void *, uint64_t, uint64_t), uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  v11[0] = 0;
  v11[1] = a3;
  uint64_t result = a1(a2, v11, a4, a5);
  if (result)
  {
    uint64_t v8 = (a3 >> 4) & 0x10;
    unsigned int v9 = *(_DWORD *)(a2 + 24);
    if (v9 >= *(_DWORD *)(a2 + 28)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v10 = (void *)(*(void *)(a2 + 16) + 16 * v9);
    *uint64_t v10 = 2;
    v10[1] = v8;
    ++*(_DWORD *)(a2 + 24);
    return 3;
  }
  return result;
}

uint64_t sub_1CBF27438(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = *(void *)(a2 + 8);
  if ((*(unsigned char *)(*(void *)(a4 + 16) + 196) & 0x20) != 0)
  {
    if ((v4 & 0x10) != 0) {
      return 0;
    }
    if ((v4 & 8) != 0) {
      unint64_t v4 = v4 & 0xFFFFFFFFFFFFFFE7 | 0x10;
    }
  }
  unsigned int v5 = *(_DWORD *)(a1 + 24);
  if (v5 >= *(_DWORD *)(a1 + 28)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unsigned int v6 = (void *)(*(void *)(a1 + 16) + 16 * v5);
  *unsigned int v6 = 2;
  v6[1] = v4;
  ++*(_DWORD *)(a1 + 24);
  return 3;
}

uint64_t sub_1CBF274CC(uint64_t (*a1)(uint64_t, void *, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v15[0] = a3;
  v15[1] = a4;
  uint64_t result = a1(a2, v15, a5, a6);
  if (result)
  {
    int v9 = *(_DWORD *)(a2 + 24);
    if (v9
      && (uint64_t v10 = (v9 - 1), v11 = *(void *)(a2 + 16), *(unsigned char *)(v11 + 16 * v10) == 2)
      && (unint64_t v12 = *(void *)(v11 + 16 * v10 + 8),
          uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)((v12 >> 11) & 0xF)),
          v13.i16[0] = vaddlv_u8(v13),
          uint64_t v14 = v13.u32[0] + ((v12 >> 21) & 1),
          (unint64_t)(v14 - 1) <= 4)
      && v14 == *(void *)(a6 + 584))
    {
      return 3;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1CBF27580(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  unsigned int v3 = *(_DWORD *)(a1 + 24);
  if (v3 >= *(_DWORD *)(a1 + 28)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unint64_t v4 = (void *)(*(void *)(a1 + 16) + 16 * v3);
  *unint64_t v4 = 2;
  v4[1] = v2;
  ++*(_DWORD *)(a1 + 24);
  return 3;
}

uint64_t sub_1CBF275EC(uint64_t (*a1)(uint64_t, void *, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v19[0] = a3;
  v19[1] = a4;
  uint64_t result = a1(a2, v19, a5, a6);
  if (result)
  {
    int v10 = *(_DWORD *)(a2 + 24);
    if (v10
      && (uint64_t v11 = (v10 - 1), v12 = *(void *)(a2 + 16), *(unsigned char *)(v12 + 16 * v11) == 2))
    {
      int v13 = *(_DWORD *)(v12 + 16 * v11 + 8);
      if ((v13 & 0xF) == 8)
      {
        int v14 = 15;
      }
      else
      {
        int v15 = v13 & 0xE;
        int v14 = 7;
        if (v15 != 12)
        {
          int v16 = v13 >> 4;
          if ((*(void *)(*(void *)(a6 + 16) + 192) & 0x10000000000) != 0 && v15 == 14) {
            int v14 = 7;
          }
          else {
            int v14 = v16;
          }
        }
      }
      v9.i32[0] = v14;
      uint8x8_t v18 = (uint8x8_t)vcnt_s8(v9);
      v18.i16[0] = vaddlv_u8(v18);
      if (*(void *)(a6 + 584) == v18.u32[0]) {
        return 3;
      }
      else {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1CBF276C4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  unsigned int v3 = *(_DWORD *)(a1 + 24);
  if (v3 >= *(_DWORD *)(a1 + 28)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unint64_t v4 = (void *)(*(void *)(a1 + 16) + 16 * v3);
  *unint64_t v4 = 2;
  v4[1] = v2 ^ 0x8000000000000000;
  ++*(_DWORD *)(a1 + 24);
  return 3;
}

uint64_t sub_1CBF27734(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, unint64_t a6, uint64_t a7)
{
  unint64_t v7 = a6 / a5;
  if (a6 % a5) {
    return 0;
  }
  if (v7 < a3 || v7 >= a4) {
    return 0;
  }
  uint64_t v10 = *(unsigned __int16 *)(*(void *)(*(void *)(*(void *)(*(void *)(a7 + 8) + 160) + 24) + 32 * a2)
                            + 2 * (v7 - a3));
  unsigned int v11 = *(_DWORD *)(a1 + 24);
  if (v11 >= *(_DWORD *)(a1 + 28)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v12 = (void *)(*(void *)(a1 + 16) + 16 * v11);
  *uint64_t v12 = 1;
  v12[1] = v10;
  ++*(_DWORD *)(a1 + 24);
  return 3;
}

uint64_t sub_1CBF277EC(uint64_t a1, unint64_t a2, uint64_t a3, int a4)
{
  HIDWORD(v5) = a4;
  LODWORD(v5) = a4 - 16;
  unsigned int v4 = v5 >> 4;
  int v6 = (1 << (v5 >> 4)) & 0x22F;
  if (v4 > 9 || v6 == 0) {
    return 0;
  }
  uint64_t v10 = (a2 >> 11) & 0xF;
  if (!v10)
  {
    if ((a2 & 0x100) == 0) {
      goto LABEL_13;
    }
LABEL_17:
    uint64_t v11 = 256;
    goto LABEL_18;
  }
  if ((a2 & 0x100) != 0) {
    return 0;
  }
  if (a4 == 32)
  {
    if (v10 == 6) {
      goto LABEL_13;
    }
    if (v10 == 7) {
      goto LABEL_17;
    }
    return 0;
  }
  if (a4 != 16) {
    return 0;
  }
  if (v10 != 4)
  {
    if (v10 != 5) {
      return 0;
    }
    goto LABEL_17;
  }
LABEL_13:
  uint64_t v11 = 0;
LABEL_18:
  if (v4 > 9 || ((0x22Fu >> v4) & 1) == 0) {
    return 0;
  }
  int v13 = dword_1CFAA0150[v4];
  uint64_t v14 = v11 | a2;
  uint64_t v15 = *(void *)(a3 + 8);
  *(void *)(v15 + 272) += 24;
  uint64_t v16 = *(void *)(v15 + 192);
  if (((v16 + 7) & 0xFFFFFFFFFFFFFFF8) - v16 + 24 > *(void *)(v15 + 200) - v16)
  {
    unsigned int v23 = *(_DWORD *)(v15 + 216) >> 7;
    if (v23 >= 0x1E) {
      LOBYTE(v23) = 30;
    }
    uint64_t v24 = 4096 << v23;
    unint64_t v17 = (unint64_t)operator new(4096 << v23, (std::align_val_t)8uLL);
    unsigned int v25 = *(_DWORD *)(v15 + 216);
    if (v25 >= *(_DWORD *)(v15 + 220)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(v15 + 208) + 8 * v25) = v17;
    ++*(_DWORD *)(v15 + 216);
    *(void *)(v15 + 200) = v17 + v24;
  }
  else
  {
    unint64_t v17 = (v16 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *(void *)(v15 + 192) = v17 + 24;
  *(unsigned char *)unint64_t v17 = 1;
  *(_DWORD *)(v17 + 1) = *(unsigned __int8 *)(v17 + 4) << 24;
  *(void *)(v17 + 8) = 0;
  *(void *)(v17 + 16) = v14;
  uint64_t v18 = *(void *)(a3 + 8);
  *(void *)(v18 + 272) += 40;
  uint64_t v19 = *(void *)(v18 + 192);
  if (((v19 + 7) & 0xFFFFFFFFFFFFFFF8) - v19 + 40 > *(void *)(v18 + 200) - v19)
  {
    unsigned int v26 = *(_DWORD *)(v18 + 216) >> 7;
    if (v26 >= 0x1E) {
      LOBYTE(v26) = 30;
    }
    uint64_t v27 = 4096 << v26;
    unint64_t v20 = (unint64_t)operator new(4096 << v26, (std::align_val_t)8uLL);
    unsigned int v28 = *(_DWORD *)(v18 + 216);
    if (v28 >= *(_DWORD *)(v18 + 220)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(v18 + 208) + 8 * v28) = v20;
    ++*(_DWORD *)(v18 + 216);
    *(void *)(v18 + 200) = v20 + v27;
  }
  else
  {
    unint64_t v20 = (v19 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *(void *)(v18 + 192) = v20 + 40;
  *(unsigned char *)(v20 + 8) = 4;
  *(_DWORD *)(v20 + 9) = *(unsigned __int8 *)(v20 + 12) << 24;
  *(void *)(v20 + 16) = 0;
  *(void *)unint64_t v20 = &unk_1F25FD370;
  *(_DWORD *)(v20 + 24) = v13;
  *(void *)(v20 + 32) = v17;
  unsigned int v21 = *(_DWORD *)(a1 + 24);
  if (v21 >= *(_DWORD *)(a1 + 28)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unint64_t v22 = (void *)(*(void *)(a1 + 16) + 16 * v21);
  *unint64_t v22 = 5;
  v22[1] = v20 + 8;
  ++*(_DWORD *)(a1 + 24);
  return 3;
}

uint64_t sub_1CBF27AD8(uint64_t a1, unint64_t a2, uint64_t a3, int a4)
{
  unint64_t v6 = a2;
  if (a4 == 64)
  {
    unsigned int v7 = 17;
    unsigned int v8 = 127;
LABEL_7:
    unsigned int v9 = 2;
    goto LABEL_8;
  }
  if (a4 == 32)
  {
    unsigned int v7 = 6;
    unsigned int v8 = 128;
    goto LABEL_7;
  }
  if (a4 != 16) {
    return 0;
  }
  unsigned int v7 = 0;
  unsigned int v8 = 256;
  unsigned int v9 = 1;
LABEL_8:
  uint64_t result = sub_1CBF27734(a1, v7, 0, v8, v9, v6, a3);
  if (result)
  {
    uint64_t v11 = (a2 >> 4) & 0x10;
    unsigned int v12 = *(_DWORD *)(a1 + 24);
    if (v12 >= *(_DWORD *)(a1 + 28)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    int v13 = (void *)(*(void *)(a1 + 16) + 16 * v12);
    *int v13 = 2;
    v13[1] = v11;
    ++*(_DWORD *)(a1 + 24);
    return 3;
  }
  return result;
}

uint64_t sub_1CBF27BBC(uint64_t a1, unint64_t a2, uint64_t a3, int a4)
{
  switch(a4)
  {
    case 0:
      unsigned int v6 = 0;
      unsigned int v7 = 0;
      goto LABEL_4;
    case 1:
      unsigned int v6 = 1;
      unsigned int v7 = 1;
LABEL_4:
      unsigned int v8 = 256;
      goto LABEL_16;
    case 2:
      unsigned int v6 = 2;
      goto LABEL_9;
    case 4:
      unsigned int v6 = 4;
      unsigned int v7 = 0;
      unsigned int v8 = 255;
      goto LABEL_16;
    case 6:
      unsigned int v6 = 6;
LABEL_9:
      unsigned int v7 = 0;
      unsigned int v8 = 128;
      goto LABEL_27;
    case 10:
      unsigned int v6 = 10;
      unsigned int v7 = 0;
      unsigned int v8 = 254;
      goto LABEL_16;
    case 12:
      unsigned int v6 = 12;
      goto LABEL_14;
    case 15:
      unsigned int v6 = 15;
      unsigned int v7 = 0;
      unsigned int v8 = 253;
      goto LABEL_16;
    case 17:
      unsigned int v6 = 17;
LABEL_14:
      unsigned int v7 = 0;
      unsigned int v8 = 127;
      goto LABEL_27;
    case 20:
      unsigned int v6 = 20;
      unsigned int v7 = 0;
      unsigned int v8 = 252;
LABEL_16:
      unsigned int v10 = 1;
      goto LABEL_17;
    case 22:
      unsigned int v6 = 22;
      goto LABEL_20;
    case 27:
      unsigned int v6 = 27;
LABEL_20:
      unsigned int v7 = 0;
      unsigned int v8 = 126;
      goto LABEL_27;
    case 32:
      unsigned int v6 = 32;
      goto LABEL_23;
    case 35:
      unsigned int v6 = 35;
LABEL_23:
      unsigned int v7 = 0;
      unsigned int v8 = 125;
      goto LABEL_27;
    case 37:
      unsigned int v6 = 37;
      unsigned int v7 = 0;
      unsigned int v8 = 124;
      goto LABEL_27;
    case 39:
      unsigned int v6 = 39;
      unsigned int v7 = 0;
      unsigned int v8 = 123;
      goto LABEL_27;
    case 41:
      unsigned int v6 = 41;
      unsigned int v7 = 0;
      unsigned int v8 = 122;
LABEL_27:
      unsigned int v10 = 2;
LABEL_17:
      uint64_t result = sub_1CBF27734(a1, v6, v7, v8, v10, a2, a3);
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t sub_1CBF27D94(unsigned __int16 *a1, unint64_t a2, uint64_t a3, int a4)
{
  unint64_t v8 = a2;
  uint64_t v9 = *(void *)(*((void *)a1 + 2) + 16 * sub_1CBC7A3F8(*a1, 0x16u) + 8);
  uint64_t v10 = v9 & 0xF;
  unint64_t v11 = v9 & 0x80000;
  if (a4 == 32)
  {
    switch(v10)
    {
      case 1:
        BOOL v12 = v11 == 0;
        int v13 = 12;
        break;
      case 2:
        BOOL v18 = v11 == 0;
        int v19 = 17;
        goto LABEL_25;
      case 3:
      case 6:
        BOOL v12 = v11 == 0;
        int v13 = 22;
        break;
      case 4:
        BOOL v14 = v11 == 0;
        int v15 = 22;
        goto LABEL_6;
      case 5:
      case 8:
        BOOL v12 = v11 == 0;
        int v13 = 27;
        int v17 = 6;
        goto LABEL_17;
      case 7:
        BOOL v12 = v11 == 0;
        int v13 = 32;
        int v17 = 12;
        goto LABEL_17;
      default:
        BOOL v18 = v11 == 0;
        int v19 = 6;
        goto LABEL_25;
    }
    int v17 = 2;
LABEL_17:
    if (v12) {
      LODWORD(v16) = v17;
    }
    else {
      LODWORD(v16) = v13;
    }
  }
  else
  {
    switch(v10)
    {
      case 1:
        unint64_t v16 = v11 >> 17;
        break;
      case 2:
        BOOL v18 = v11 == 0;
        int v19 = 4;
LABEL_25:
        if (v18) {
          LODWORD(v16) = -1;
        }
        else {
          LODWORD(v16) = v19;
        }
        break;
      case 3:
      case 4:
      case 5:
      case 6:
        BOOL v14 = v11 == 0;
        int v15 = 10;
LABEL_6:
        if (v14) {
          LODWORD(v16) = 0;
        }
        else {
          LODWORD(v16) = v15;
        }
        break;
      case 7:
      case 8:
        BOOL v12 = v11 == 0;
        int v13 = 15;
        int v17 = 4;
        goto LABEL_17;
      default:
        if (v11) {
          LODWORD(v16) = 0;
        }
        else {
          LODWORD(v16) = -1;
        }
        break;
    }
  }
  uint64_t result = sub_1CBF27BBC((uint64_t)a1, v8, a3, v16);
  if (result)
  {
    uint64_t v21 = (a2 >> 4) & 0x10;
    unsigned int v22 = *((_DWORD *)a1 + 6);
    if (v22 >= *((_DWORD *)a1 + 7)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    unsigned int v23 = (void *)(*((void *)a1 + 2) + 16 * v22);
    *unsigned int v23 = 2;
    v23[1] = v21;
    ++*((_DWORD *)a1 + 6);
    return 3;
  }
  return result;
}

uint64_t sub_1CBF27F90(unsigned __int16 *a1, unint64_t a2, uint64_t a3, int a4, uint64_t a5, unsigned __int8 a6, int a7)
{
  unint64_t v13 = a2;
  uint64_t v14 = *(void *)(*((void *)a1 + 2) + 16 * sub_1CBC7A3F8(*a1, 0x16u) + 8);
  if (a4 == 32)
  {
    int v15 = 6;
    switch(v14 & 0xF)
    {
      case 1:
        int v15 = 12;
        break;
      case 2:
        int v15 = 17;
        break;
      case 3:
      case 4:
        int v15 = 22;
        break;
      case 5:
      case 8:
        int v15 = 27;
        break;
      case 6:
        BOOL v16 = (((v14 & 0x40000) == 0) & a6) == 0;
        int v17 = 22;
        int v18 = 27;
        goto LABEL_12;
      case 7:
        int v15 = 32;
        break;
      default:
        break;
    }
  }
  else
  {
    switch(v14 & 0xF)
    {
      case 1:
      case 2:
        BOOL v16 = a7 == 0;
        int v17 = 4;
        int v18 = 6;
        goto LABEL_12;
      case 3:
      case 4:
      case 5:
      case 6:
        BOOL v16 = a7 == 0;
        int v17 = 10;
        int v18 = 12;
        goto LABEL_12;
      case 7:
      case 8:
        BOOL v16 = a7 == 0;
        int v17 = 15;
        int v18 = 17;
LABEL_12:
        if (v16) {
          int v15 = v17;
        }
        else {
          int v15 = v18;
        }
        break;
      default:
        if (a7) {
          int v15 = 2;
        }
        else {
          int v15 = 0;
        }
        break;
    }
  }
  uint64_t result = sub_1CBF27BBC((uint64_t)a1, v13, a3, v15);
  if (result)
  {
    uint64_t v20 = (a2 >> 4) & 0x10;
    unsigned int v21 = *((_DWORD *)a1 + 6);
    if (v21 >= *((_DWORD *)a1 + 7)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    unsigned int v22 = (void *)(*((void *)a1 + 2) + 16 * v21);
    *unsigned int v22 = 2;
    v22[1] = v20;
    ++*((_DWORD *)a1 + 6);
    return 3;
  }
  return result;
}

uint64_t sub_1CBF28178(unsigned __int16 *a1, unint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = *(void *)(*((void *)a1 + 2) + 16 * sub_1CBC7A3F8(*a1, 0x16u) + 8);
  if ((~v8 & 0x410) != 0) {
    int v9 = 6;
  }
  else {
    int v9 = 12;
  }
  if ((v8 & 0x10) == 0)
  {
    if ((v8 & 0x400) == 0) {
      return 3;
    }
    if (a4) {
      int v9 = 2;
    }
    else {
      int v9 = 0;
    }
  }
  uint64_t result = sub_1CBF27BBC((uint64_t)a1, a2, a3, v9);
  if (!result) {
    return result;
  }
  uint64_t v11 = (a2 >> 4) & 0x10;
  unsigned int v12 = *((_DWORD *)a1 + 6);
  if (v12 >= *((_DWORD *)a1 + 7)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unint64_t v13 = (void *)(*((void *)a1 + 2) + 16 * v12);
  *unint64_t v13 = 2;
  v13[1] = v11;
  ++*((_DWORD *)a1 + 6);
  return 3;
}

void LLVMInitializeAGX3Disassembler()
{
  qword_1EA61E930 = (uint64_t)sub_1CBF2828C;
  qword_1EA61E998 = (uint64_t)sub_1CBF28324;
}

void sub_1CBF2828C(uint64_t a1)
{
  v1 = *(void (**)(void))(a1 + 64);
  if (v1) {
    v1();
  }
  operator new();
}

void sub_1CBF28324()
{
}

uint64_t sub_1CBF283AC(uint64_t a1)
{
  *(void *)a1 = &unk_1F25FEB88;
  uint64_t v2 = *(void *)(a1 + 592);
  *(void *)(a1 + 592) = 0;
  if (v2) {
    MEMORY[0x1D25D9CE0](v2, 0x10F0C40CB53E019);
  }
  unsigned int v3 = *(char **)(a1 + 40);
  unsigned int v4 = *(_DWORD *)(a1 + 48);
  if (v4)
  {
    uint64_t v5 = 88 * v4;
    do
    {
      unsigned int v6 = *(char **)&v3[v5 - 88];
      if (&v3[v5 - 72] != v6) {
        free(v6);
      }
      v5 -= 88;
    }
    while (v5);
    unsigned int v3 = *(char **)(a1 + 40);
  }
  if (v3 != (char *)(a1 + 56)) {
    free(v3);
  }
  *(void *)a1 = &unk_1F26321D0;
  uint64_t v7 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  return a1;
}

void sub_1CBF284AC(uint64_t a1)
{
  sub_1CBF283AC(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CBF284E4(void *a1, uint64_t a2, unint64_t *a3, uint64_t *a4, unint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = (unsigned char *)a5;
  uint64_t v8 = a4;
  int v9 = a3;
  uint64_t v10 = a2;
  uint64_t v11 = a1;
  uint64_t v104 = *MEMORY[0x1E4F143B8];
  a1[4] = a7;
  uint64_t v12 = a1[2];
  if ((*(unsigned char *)(v12 + 197) & 8) != 0)
  {
    unsigned int v28 = &v99;
    uint64_t v14 = a1[1];
    unint64_t v18 = *(void *)(v14 + 160);
    uint64_t v11 = (void *)a1[74];
    *(void *)&long long v99 = &unk_1F25FDD00;
    *((void *)&v99 + 1) = v12;
    *((void *)&v100 + 1) = &v99;
    uint64_t v22 = sub_1CBD854F8((uint64_t)&v99);
    uint64_t v89 = *((void *)&v100 + 1);
    if (*((long long **)&v100 + 1) == &v99)
    {
      (*(void (**)(long long *))(v99 + 32))(&v99);
    }
    else
    {
LABEL_101:
      if (v89) {
        (*(void (**)(uint64_t))(*(void *)v89 + 40))(v89);
      }
    }
    uint64_t v98 = 0;
    uint64_t v103 = 0;
    v28[20] = 0u;
    v28[21] = 0u;
    v28[18] = 0u;
    v28[19] = 0u;
    v28[16] = 0u;
    v28[17] = 0u;
    v28[14] = 0u;
    v28[15] = 0u;
    v28[12] = 0u;
    v28[13] = 0u;
    v28[10] = 0u;
    v28[11] = 0u;
    v28[8] = 0u;
    v28[9] = 0u;
    memset(v101, 0, 96);
    long long v99 = 0u;
    long long v100 = 0u;
    if (sub_1CBE56C98(v22, (uint64_t)v8, (unint64_t)v7, v9, (int *)&v98 + 1, (uint64_t)&v99, &v98)
      && sub_1CD4336A4(v22, v11, v18, v14, (int *)&v98 + 1, (unsigned __int16 *)&v99, v10, 1))
    {
      return 3;
    }
    goto LABEL_93;
  }
  *a3 = 2;
  if (a5 < 2 || (unsigned int v13 = *((_DWORD *)a1 + 12)) == 0)
  {
LABEL_93:
    unint64_t v91 = 0;
    uint64_t v29 = 0;
LABEL_94:
    *int v9 = v91;
    return v29;
  }
  uint64_t v14 = a1[5];
  uint64_t v92 = v14 + 88 * v13;
  while (1)
  {
    unint64_t v15 = (unint64_t)*(unsigned int *)(v14 + 80) >> 3;
    if ((unint64_t)v7 < v15) {
      unint64_t v15 = (unint64_t)v7;
    }
    uint64_t v16 = v15 >= 8 ? 8 : v15;
    if (v16)
    {
      uint64_t v17 = 0;
      unint64_t v18 = 0;
      int v19 = v8;
      do
      {
        unsigned int v20 = *(unsigned __int8 *)v19;
        int v19 = (uint64_t *)((char *)v19 + 1);
        v18 |= (unint64_t)v20 << v17;
        v17 += 8;
      }
      while (8 * v16 != v17);
      int v21 = v16;
    }
    else
    {
      unint64_t v18 = 0;
      int v21 = 0;
    }
    if (v21 == v15)
    {
      uint64_t v22 = 0;
    }
    else
    {
      uint64_t v22 = 0;
      unint64_t v23 = v15 - v16;
      uint64_t v24 = (unsigned __int8 *)v8 + v16;
      uint64_t v25 = 8 * v16 + 4294967232;
      do
      {
        unsigned int v26 = *v24++;
        v22 |= (unint64_t)v26 << (v25 & 0xF8);
        v25 += 8;
        --v23;
      }
      while (v23);
    }
    uint64_t v27 = *(unsigned int *)(v14 + 8);
    if (v27) {
      break;
    }
LABEL_88:
    unint64_t v91 = 0;
    uint64_t v29 = 0;
    v14 += 88;
    uint64_t v8 = a4;
    int v9 = a3;
    if (v14 == v92) {
      goto LABEL_94;
    }
  }
  uint64_t v8 = *(uint64_t **)v14;
  uint64_t v97 = *(void *)v14 + 16 * v27;
LABEL_21:
  v11[73] = v8[1] & 0x1F;
  if ((unint64_t)v7 < (unint64_t)*(unsigned int *)(v14 + 80) >> 3)
  {
    unint64_t v91 = 0;
    uint64_t v29 = 0;
    goto LABEL_97;
  }
  unsigned int v28 = 0;
  int v9 = 0;
  uint64_t v10 = *v8;
  uint64_t v29 = 3;
  uint64_t v7 = (unsigned char *)*v8;
  while (2)
  {
    switch(*v7)
    {
      case 1:
        int v69 = v7[1];
        unsigned int v70 = v7[2];
        v7 += 3;
        a1 = sub_1CBF28BC4((unint64_t *)&v99, v22, v18, v69, v70);
        int v9 = (unint64_t *)*((void *)&v99 + 1);
        unsigned int v28 = (long long *)v99;
        continue;
      case 2:
        uint64_t v30 = 0;
        unint64_t v31 = 0;
        unint64_t v32 = 0;
        unsigned int v33 = 0;
        uint64_t v34 = v7 + 1;
        do
        {
          char v35 = v34[v30];
          int v36 = v35;
          uint64_t v37 = v35 & 0x7F;
          BOOL v38 = __CFADD__(v31, v37 << v33);
          unsigned int v39 = (unint64_t *)((char *)v31 + (v37 << v33));
          uint64_t v40 = v37 << v33;
          if (v33 < 0x40)
          {
            unint64_t v31 = v39;
            uint64_t v40 = v38;
          }
          unint64_t v32 = (long long *)((char *)v32 + v40);
          v33 += 7;
          ++v30;
        }
        while (v36 < 0);
        uint64_t v41 = (unsigned __int16 *)&v34[v30];
        uint64_t v42 = *((unsigned __int8 *)v41 + 2);
        BOOL v43 = v31 == v9 && v32 == v28;
        goto LABEL_44;
      case 3:
        a1 = sub_1CBF28BC4((unint64_t *)&v99, v22, v18, v7[1], v7[2]);
        uint64_t v44 = 0;
        uint64_t v45 = 0;
        uint64_t v46 = 0;
        unsigned int v47 = 0;
        unsigned int v48 = v7 + 3;
        do
        {
          char v49 = v48[v44];
          int v50 = v49;
          uint64_t v51 = v49 & 0x7F;
          BOOL v52 = __CFADD__(v45, v51 << v47);
          uint64_t v53 = (v51 << v47) + v45;
          uint64_t v54 = v51 << v47;
          if (v47 < 0x40)
          {
            uint64_t v45 = v53;
            uint64_t v54 = v52;
          }
          v46 += v54;
          v47 += 7;
          ++v44;
        }
        while (v50 < 0);
        uint64_t v41 = (unsigned __int16 *)&v48[v44];
        uint64_t v42 = *((unsigned __int8 *)v41 + 2);
        BOOL v43 = v45 == *((void *)&v99 + 1) && v46 == (void)v99;
LABEL_44:
        unint64_t v55 = *v41 | (unint64_t)(v42 << 16);
        if (v43) {
          unint64_t v55 = 0;
        }
        uint64_t v7 = (char *)v41 + v55 + 3;
        continue;
      case 4:
        LODWORD(v99) = 0;
        uint64_t v89 = sub_1CBF28C40(v7 + 1, &v99, 0, 0);
        __break(1u);
        goto LABEL_101;
      case 5:
        uint64_t v77 = 0;
        unsigned int v78 = 0;
        uint64_t v79 = v7 + 1;
        while (1)
        {
          char v81 = *v79++;
          char v80 = v81;
          uint64_t v82 = v81 & 0x7F;
          if (v78 >= 0x40)
          {
            if (v82) {
              break;
            }
          }
          if ((unint64_t)(v82 << v78) >> v78 != v82) {
            break;
          }
          v77 += v82 << v78;
          v78 += 7;
          if ((v80 & 0x80) == 0) {
            goto LABEL_77;
          }
        }
        LODWORD(v77) = 0;
LABEL_77:
        *(_DWORD *)(a2 + 24) = 0;
        *(_DWORD *)a2 = v77;
        goto LABEL_82;
      case 6:
        uint64_t v83 = 0;
        unsigned int v84 = 0;
        unsigned int v85 = v7 + 1;
        break;
      case 7:
        uint64_t v56 = 0;
        uint64_t v57 = 0;
        unsigned int v58 = 0;
        uint64_t v59 = v7 + 1;
        do
        {
          char v60 = v59[v56];
          unint64_t v61 = (unint64_t)(v60 & 0x7F) << v58;
          if (v58 > 0x3F) {
            unint64_t v61 = 0;
          }
          v57 += v61;
          v58 += 7;
          ++v56;
        }
        while (v60 < 0);
        uint64_t v62 = 0;
        uint64_t v63 = 0;
        unsigned int v64 = 0;
        uint64_t v65 = &v59[v56];
        uint64_t v66 = (uint64_t)&v7[v56 + 1];
        do
        {
          char v67 = *(unsigned char *)(v66 + v62);
          unint64_t v68 = (unint64_t)(v67 & 0x7F) << v64;
          if (v64 > 0x3F) {
            unint64_t v68 = 0;
          }
          v63 += v68;
          v64 += 7;
          ++v62;
        }
        while (v67 < 0);
        uint64_t v7 = &v65[v62];
        if (v57 & v18 | v63 & ~v18) {
          uint64_t v29 = 1;
        }
        else {
          uint64_t v29 = v29;
        }
        continue;
      case 8:
        goto LABEL_84;
      default:
        unint64_t v71 = (unint64_t)&v7[-v10];
        unsigned int v72 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
        unint64_t v73 = v72;
        if ((v71 & 0x8000000000000000) != 0)
        {
          unint64_t v74 = -(uint64_t)v71;
          int v75 = 1;
        }
        else
        {
          unint64_t v74 = v71;
          int v75 = 0;
        }
        a1 = sub_1CD098D14(v72, v74, 0, 0, v75);
        int v76 = (void *)*((void *)v73 + 4);
        if (*((void *)v73 + 3) - (void)v76 > 0x21uLL)
        {
          qmemcpy(v76, ": Unexpected decode table opcode!\n", 34);
          *((void *)v73 + 4) += 34;
        }
        else
        {
          a1 = llvm::raw_ostream::write(v73, ": Unexpected decode table opcode!\n", 0x22uLL);
        }
LABEL_84:
        v8 += 2;
        uint64_t v7 = (unsigned char *)a5;
        if (v8 == (uint64_t *)v97) {
          goto LABEL_88;
        }
        goto LABEL_21;
    }
    break;
  }
  while (1)
  {
    char v87 = *v85++;
    char v86 = v87;
    uint64_t v88 = v87 & 0x7F;
    if (v84 >= 0x40)
    {
      if (v88) {
        break;
      }
    }
    if ((unint64_t)(v88 << v84) >> v84 != v88) {
      break;
    }
    v83 += v88 << v84;
    v84 += 7;
    if ((v86 & 0x80) == 0) {
      goto LABEL_79;
    }
  }
  LODWORD(v83) = 0;
LABEL_79:
  *(void *)&long long v100 = v101;
  *((void *)&v100 + 1) = 0x800000000;
  char v102 = 0;
  long long v99 = v83;
  *(_OWORD *)a2 = v83;
  if (&v99 != (long long *)a2) {
    *(_DWORD *)(a2 + 24) = 0;
  }
  *(unsigned char *)(a2 + 160) = 0;
LABEL_82:
  if (v29 != 1)
  {
    unint64_t v91 = (unint64_t)*(unsigned int *)(v14 + 80) >> 3;
LABEL_97:
    int v9 = a3;
    goto LABEL_94;
  }
  return v29;
}

unint64_t *sub_1CBF28BC4(unint64_t *result, unint64_t a2, unint64_t a3, int a4, unsigned int a5)
{
  if (!a5)
  {
    unint64_t v5 = 0;
    goto LABEL_10;
  }
  unint64_t v5 = -1;
  if ((a5 & 0x3F) == 0)
  {
LABEL_10:
    unint64_t v6 = 0;
    goto LABEL_11;
  }
  unint64_t v6 = 0xFFFFFFFFFFFFFFFFLL >> -(a5 & 0x3F);
  if (a5 >= 0x40) {
    unint64_t v5 = -1;
  }
  else {
    unint64_t v5 = 0xFFFFFFFFFFFFFFFFLL >> -(a5 & 0x3F);
  }
  if (a5 < 0x40) {
    unint64_t v6 = 0;
  }
LABEL_11:
  unint64_t v7 = a2 << -(char)a4;
  unint64_t v8 = a2 >> a4;
  if (a4 > 0x3F) {
    unint64_t v8 = 0;
  }
  else {
    v7 |= a3 >> a4;
  }
  if (a4 >= 64)
  {
    unint64_t v7 = a2 >> a4;
    unint64_t v8 = 0;
  }
  if (!a4)
  {
    unint64_t v7 = a3;
    unint64_t v8 = a2;
  }
  *uint64_t result = v8 & v6;
  result[1] = v7 & v5;
  return result;
}

uint64_t sub_1CBF28C40(char *a1, _DWORD *a2, char *a3, void *a4)
{
  if (a4) {
    *a4 = 0;
  }
  uint64_t v4 = 0;
  unsigned int v5 = 0;
  unint64_t v6 = a1;
  while (v6 != a3)
  {
    char v7 = *v6;
    uint64_t v8 = *v6 & 0x7F;
    if (v5 >= 0x40 && (*v6 & 0x7F) != 0 || (unint64_t)(v8 << v5) >> v5 != v8)
    {
      if (a4) {
        *a4 = "uleb128 too big for uint64";
      }
      uint64_t v4 = 0;
LABEL_13:
      LODWORD(a3) = v6;
      if (!a2) {
        return v4;
      }
LABEL_14:
      *a2 = a3 - a1;
      return v4;
    }
    v4 += v8 << v5;
    v5 += 7;
    ++v6;
    if ((v7 & 0x80) == 0) {
      goto LABEL_13;
    }
  }
  if (a4) {
    *a4 = "malformed uleb128, extends past end";
  }
  uint64_t v4 = 0;
  if (a2) {
    goto LABEL_14;
  }
  return v4;
}

uint64_t sub_1CBF28CDC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  char v7 = *(uint64_t **)(a1 + 40);
  if (!v7) {
    return 0;
  }
  uint64_t v8 = (unsigned __int8 ***)v7[1];
  int v9 = *v8;
  uint64_t v10 = v8[1];
  if (*v8 == v10) {
    return 0;
  }
  uint64_t v14 = *v7;
  uint64_t v15 = a7 + a5;
  while ((*(uint64_t (**)(unsigned __int8 *, unsigned __int8 *))(*(void *)v9[1] + 296))(v9[1], *v9) != v15)
  {
    v9 += 2;
    if (v9 == v10)
    {
      int v9 = v10;
      break;
    }
  }
  if (v9 == v8[1]) {
    return 0;
  }
  uint64_t v16 = (*(uint64_t (**)(unsigned __int8 *, unsigned __int8 *))(*(void *)v9[1] + 304))(v9[1], *v9);
  (*(void (**)(unsigned __int8 ***__return_ptr, uint64_t, uint64_t))(*(void *)v17 + 72))(&v58, v17, v16);
  char v18 = v60;
  if (v60)
  {
    uint64_t v57 = v58;
    unsigned int v58 = 0;
    sub_1CD4515D0(&v57);
    if (v57) {
      (*(void (**)(void *))(*v57 + 8))(v57);
    }
  }
  else
  {
    uint64_t v10 = v58;
    uint64_t v15 = v59;
  }
  if (v60)
  {
    int v19 = v58;
    unsigned int v58 = 0;
    if (v19) {
      (*((void (**)(unsigned __int8 **))*v19 + 1))(v19);
    }
  }
  if (v18)
  {
    unint64_t v31 = v9;
    unint64_t v29 = (unint64_t)*v9;
    uint64_t v30 = v31[1];
    uint64_t Relocation = llvm::object::MachOObjectFile::getRelocation((uint64_t)v30, v29);
    if (*((_DWORD *)v30 + 13) != 16777223 && (Relocation & 0x80000000) != 0) {
      return 0;
    }
    unsigned int v33 = *((_DWORD *)v30 + 2);
    if (v33 <= 0x13 && ((1 << v33) & 0xAAC00) != 0)
    {
      if ((Relocation & 0x1000000000) != 0) {
        return 0;
      }
    }
    else if ((HIDWORD(Relocation) >> 27))
    {
      return 0;
    }
    unsigned int v58 = (unsigned __int8 **)llvm::object::MachOObjectFile::getRelocation((uint64_t)v30, v29);
    unint64_t AnyRelocationSection = llvm::object::MachOObjectFile::getAnyRelocationSection(v30, &v58);
    uint64_t v39 = v38;
    uint64_t v40 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v30 + 352))(v30);
    if (v39 != v41 || AnyRelocationSection != v40)
    {
      (*(void (**)(unsigned __int8 ***__return_ptr, uint64_t, unint64_t))(*(void *)v39 + 136))(&v58, v39, AnyRelocationSection);
      if (v60)
      {
        uint64_t v53 = v58;
        unsigned int v58 = 0;
        if (v53) {
          (*((void (**)(unsigned __int8 **))*v53 + 1))(v53);
        }
      }
      else
      {
        BOOL v43 = *(void **)(v14 + 8);
        if (!v43) {
LABEL_49:
        }
          abort();
        while (1)
        {
          while (1)
          {
            unint64_t v44 = bswap64(AnyRelocationSection);
            unint64_t v45 = bswap64(v43[4]);
            BOOL v46 = v44 >= v45;
            BOOL v47 = v44 > v45;
            BOOL v48 = !v46;
            if (v47 - v48 >= 0) {
              break;
            }
            BOOL v43 = (void *)*v43;
            if (!v43) {
              goto LABEL_49;
            }
          }
          unint64_t v49 = bswap64(v43[4]);
          unint64_t v50 = bswap64(AnyRelocationSection);
          BOOL v46 = v49 >= v50;
          BOOL v51 = v49 > v50;
          BOOL v52 = !v46;
          if (v51 - v52 >= 0) {
            break;
          }
          BOOL v43 = (void *)v43[1];
          if (!v43) {
            goto LABEL_49;
          }
        }
        uint64_t v54 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v39 + 144))(v39, AnyRelocationSection);
        unint64_t v55 = (void *)v43[6];
        uint64_t v56 = (void *)v43[7];
        if (v55 != v56)
        {
          while (*v55 != v54 + a4)
          {
            v55 += 6;
            if (v55 == v56) {
              return 0;
            }
          }
          uint64_t v10 = (unsigned __int8 **)v55[1];
          uint64_t v15 = v55[2];
          goto LABEL_14;
        }
      }
    }
    return 0;
  }
LABEL_14:
  unsigned int v20 = *(llvm::MCContext **)(a1 + 8);
  __int16 v61 = 261;
  unsigned int v58 = v10;
  uint64_t v59 = v15;
  uint64_t v21 = llvm::MCContext::getOrCreateSymbol(v20, &v58);
  uint64_t v22 = *(void *)(a1 + 8);
  *(void *)(v22 + 272) += 24;
  uint64_t v23 = *(void *)(v22 + 192);
  if (((v23 + 7) & 0xFFFFFFFFFFFFFFF8) - v23 + 24 > *(void *)(v22 + 200) - v23)
  {
    unsigned int v34 = *(_DWORD *)(v22 + 216) >> 7;
    if (v34 >= 0x1E) {
      LOBYTE(v34) = 30;
    }
    uint64_t v35 = 4096 << v34;
    unint64_t v24 = (unint64_t)operator new(4096 << v34, (std::align_val_t)8uLL);
    unsigned int v36 = *(_DWORD *)(v22 + 216);
    if (v36 >= *(_DWORD *)(v22 + 220)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(v22 + 208) + 8 * v36) = v24;
    ++*(_DWORD *)(v22 + 216);
    *(void *)(v22 + 200) = v24 + v35;
  }
  else
  {
    unint64_t v24 = (v23 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *(void *)(v22 + 192) = v24 + 24;
  int v25 = *(unsigned __int8 *)(*(void *)(v22 + 152) + 18) << 16;
  *(unsigned char *)unint64_t v24 = 2;
  *(_DWORD *)(v24 + 1) = v25 | (*(unsigned __int8 *)(v24 + 4) << 24);
  *(void *)(v24 + 8) = 0;
  *(void *)(v24 + 16) = v21;
  unsigned int v26 = *(_DWORD *)(a2 + 24);
  if (v26 >= *(_DWORD *)(a2 + 28)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v27 = (void *)(*(void *)(a2 + 16) + 16 * v26);
  *uint64_t v27 = 5;
  v27[1] = v24;
  ++*(_DWORD *)(a2 + 24);
  return 1;
}

void *sub_1CBF291F8(void *a1)
{
  *a1 = &unk_1F2632260;
  uint64_t v2 = a1[2];
  a1[2] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_1CBF29268(void *a1)
{
  *a1 = &unk_1F2632260;
  uint64_t v2 = a1[2];
  a1[2] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CBF292F8()
{
  return 0;
}

void *sub_1CBF29304(void **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  sub_1CBF29364(&v2, &v3);
  uint64_t result = v2;
  if (v2) {
    return (void *)(*(uint64_t (**)(void *))(*v2 + 8))(v2);
  }
  return result;
}

void **sub_1CBF29364@<X0>(void **result@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *result;
  if (*result)
  {
    *uint64_t result = 0;
    if ((*(unsigned int (**)(void *, void *))(*v3 + 48))(v3, &llvm::ErrorList::ID))
    {
      *a2 = 0;
      unsigned int v5 = (char **)v3[1];
      unint64_t v6 = (char **)v3[2];
      if (v5 != v6)
      {
        char v7 = 0;
        do
        {
          uint64_t v10 = v7;
          uint64_t v8 = *v5;
          *unsigned int v5 = 0;
          if ((*(unsigned int (**)(char *, void *))(*(void *)v8 + 48))(v8, &llvm::ErrorInfoBase::ID))
          {
            (*(void (**)(char *))(*(void *)v8 + 8))(v8);
            uint64_t v8 = 0;
          }
          int v9 = v8;
          sub_1CD451630(&v10, &v9, &v11);
          char v7 = v11;
          *a2 = v11;
          uint64_t v11 = 0;
          if (v9) {
            (*(void (**)(char *))(*(void *)v9 + 8))(v9);
          }
          if (v10) {
            (*(void (**)(char *))(*(void *)v10 + 8))(v10);
          }
          ++v5;
        }
        while (v5 != v6);
      }
      return (void **)(*(uint64_t (**)(void *))(*v3 + 8))(v3);
    }
    else
    {
      uint64_t result = (void **)(*(uint64_t (**)(void *, void *))(*v3 + 48))(v3, &llvm::ErrorInfoBase::ID);
      if (result)
      {
        *a2 = 0;
        uint64_t v4 = *(uint64_t (**)(void *))(*v3 + 8);
        return (void **)v4(v3);
      }
      else
      {
        *a2 = v3;
      }
    }
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

uint64_t *sub_1CBF295A0(uint64_t **a1, uint64_t a2, uint64_t *a3)
{
  unsigned int v5 = *a1;
  unint64_t v6 = (unint64_t)a1[1];
  uint64_t v7 = a2 - (void)*a1;
  uint64_t v8 = v7 >> 3;
  int v9 = (uint64_t *)((char *)*a1 + (v7 & 0xFFFFFFFFFFFFFFF8));
  unint64_t v10 = (unint64_t)a1[2];
  if (v6 >= v10)
  {
    unint64_t v16 = ((uint64_t)(v6 - (void)v5) >> 3) + 1;
    if (v16 >> 61) {
      abort();
    }
    uint64_t v17 = v10 - (void)v5;
    if (v17 >> 2 > v16) {
      unint64_t v16 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v16;
    }
    uint64_t v42 = a1 + 2;
    if (v18)
    {
      if (v18 >> 61) {
        sub_1CB833614();
      }
      int v19 = (char *)operator new(8 * v18);
    }
    else
    {
      int v19 = 0;
    }
    uint64_t v38 = v19;
    uint64_t v39 = (uint64_t *)&v19[8 * v8];
    uint64_t v40 = v39;
    uint64_t v41 = &v19[8 * v18];
    sub_1CBF29980(&v38, a3);
    uint64_t v21 = v39;
    uint64_t v22 = *a1;
    uint64_t v23 = v39;
    if (v9 != *a1)
    {
      unint64_t v24 = v9;
      uint64_t v23 = v39;
      do
      {
        uint64_t v25 = *--v24;
        *unint64_t v24 = 0;
        *--uint64_t v23 = v25;
      }
      while (v24 != v22);
    }
    uint64_t v39 = v23;
    unsigned int v26 = a1[1];
    uint64_t v27 = v40;
    if (v9 != v26)
    {
      do
      {
        uint64_t v28 = *v9;
        *v9++ = 0;
        *v27++ = v28;
      }
      while (v9 != v26);
      uint64_t v23 = v39;
      int v9 = a1[1];
    }
    unint64_t v29 = *a1;
    *a1 = v23;
    a1[1] = v27;
    uint64_t v30 = (char *)a1[2];
    a1[2] = (uint64_t *)v41;
    uint64_t v40 = v9;
    uint64_t v41 = v30;
    uint64_t v38 = (char *)v29;
    uint64_t v39 = v29;
    sub_1CBF29904((uint64_t)&v38);
  }
  else
  {
    if (v9 == (uint64_t *)v6)
    {
      uint64_t v20 = *a3;
      *a3 = 0;
      *int v9 = v20;
      a1[1] = v9 + 1;
    }
    else
    {
      uint64_t v11 = v9 + 1;
      uint64_t v12 = (uint64_t *)(v6 - 8);
      if (v6 < 8)
      {
        uint64_t v14 = a1[1];
      }
      else
      {
        unsigned int v13 = (uint64_t *)(v6 - 8);
        uint64_t v14 = a1[1];
        do
        {
          uint64_t v15 = *v13;
          *v13++ = 0;
          *v14++ = v15;
        }
        while ((unint64_t)v13 < v6);
      }
      a1[1] = v14;
      if ((void *)v6 != v11)
      {
        uint64_t v31 = 8 * ((uint64_t)(v6 - (void)v11) >> 3);
        uint64_t v32 = (uint64_t)&v5[v8 - 1];
        do
        {
          uint64_t v33 = *(void *)(v32 + v31);
          *(void *)(v32 + v31) = 0;
          uint64_t v34 = *v12;
          *uint64_t v12 = v33;
          if (v34) {
            (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
          }
          --v12;
          v31 -= 8;
        }
        while (v31);
      }
      uint64_t v35 = *a3;
      *a3 = 0;
      uint64_t v36 = *v9;
      *int v9 = v35;
      if (v36) {
        (*(void (**)(uint64_t))(*(void *)v36 + 8))(v36);
      }
    }
    return v9;
  }
  return v21;
}

char *sub_1CBF297F8(char **a1, void *a2)
{
  uint64_t v2 = (a1[1] - *a1) >> 3;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    abort();
  }
  uint64_t v6 = a1[2] - *a1;
  if (v6 >> 2 > v3) {
    unint64_t v3 = v6 >> 2;
  }
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v7 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v7 = v3;
  }
  uint64_t v21 = a1 + 2;
  if (v7)
  {
    if (v7 >> 61) {
      sub_1CB833614();
    }
    uint64_t v8 = (char *)operator new(8 * v7);
  }
  else
  {
    uint64_t v8 = 0;
  }
  int v9 = &v8[8 * v2];
  unint64_t v10 = &v8[8 * v7];
  *(void *)int v9 = *a2;
  uint64_t v11 = v9 + 8;
  *a2 = 0;
  v19.i64[1] = (uint64_t)(v9 + 8);
  uint64_t v20 = v10;
  unsigned int v13 = *a1;
  uint64_t v12 = a1[1];
  if (v12 == *a1)
  {
    int64x2_t v15 = vdupq_n_s64((unint64_t)v12);
  }
  else
  {
    do
    {
      uint64_t v14 = *((void *)v12 - 1);
      v12 -= 8;
      *(void *)uint64_t v12 = 0;
      *((void *)v9 - 1) = v14;
      v9 -= 8;
    }
    while (v12 != v13);
    int64x2_t v15 = *(int64x2_t *)a1;
    uint64_t v11 = (char *)v19.i64[1];
    unint64_t v10 = v20;
  }
  *a1 = v9;
  a1[1] = v11;
  int64x2_t v19 = v15;
  unint64_t v16 = a1[2];
  a1[2] = v10;
  uint64_t v20 = v16;
  uint64_t v18 = v15.i64[0];
  sub_1CBF29904((uint64_t)&v18);
  return v11;
}

uint64_t sub_1CBF29904(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    uint64_t v4 = *(void *)(i - 8);
    *(void *)(i - 8) = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_1CBF29980(void *result, uint64_t *a2)
{
  uint64_t v3 = result;
  uint64_t v4 = (char *)result[2];
  if (v4 == (char *)result[3])
  {
    uint64_t v6 = (char *)*result;
    unsigned int v5 = (char *)result[1];
    if ((unint64_t)v5 <= *result)
    {
      if (v4 == v6) {
        unint64_t v12 = 1;
      }
      else {
        unint64_t v12 = (v4 - v6) >> 2;
      }
      uint64_t v26 = result[4];
      if (v12 >> 61) {
        sub_1CB833614();
      }
      unsigned int v13 = (char *)operator new(8 * v12);
      uint64_t v14 = &v13[8 * (v12 >> 2)];
      uint64_t v15 = v4 - v5;
      if (v4 == v5)
      {
        int64x2_t v21 = vdupq_n_s64((unint64_t)v4);
        uint64_t v17 = &v13[8 * (v12 >> 2)];
      }
      else
      {
        uint64_t v16 = v15 >> 3;
        uint64_t v17 = &v14[v15 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v18 = 8 * v16;
        int64x2_t v19 = &v13[8 * (v12 >> 2)];
        do
        {
          uint64_t v20 = *(void *)v5;
          *(void *)unsigned int v5 = 0;
          v5 += 8;
          *(void *)int64x2_t v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
        uint64_t v6 = (char *)*v3;
        int64x2_t v21 = *(int64x2_t *)(v3 + 1);
        uint64_t v4 = (char *)v3[3];
      }
      uint64_t v23 = v6;
      *uint64_t v3 = v13;
      v3[1] = v14;
      int64x2_t v24 = v21;
      v3[2] = v17;
      v3[3] = &v13[8 * v12];
      uint64_t v25 = v4;
      uint64_t result = (void *)sub_1CBF29904((uint64_t)&v23);
      uint64_t v4 = (char *)v3[2];
    }
    else
    {
      uint64_t v7 = (uint64_t)&v5[-*result] >> 3;
      if (v7 >= -1) {
        uint64_t v8 = v7 + 1;
      }
      else {
        uint64_t v8 = v7 + 2;
      }
      uint64_t v9 = -(v8 >> 1);
      if (v5 == v4)
      {
        uint64_t v11 = &v5[-8 * (v8 >> 1)];
      }
      else
      {
        do
        {
          uint64_t v10 = *(void *)v5;
          *(void *)unsigned int v5 = 0;
          uint64_t result = *(void **)&v5[8 * v9];
          *(void *)&v5[8 * v9] = v10;
          if (result) {
            uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
          }
          v5 += 8;
        }
        while (v5 != v4);
        uint64_t v4 = (char *)v3[1];
        uint64_t v11 = &v5[8 * v9];
      }
      v3[1] = &v4[8 * v9];
      v3[2] = v11;
      uint64_t v4 = v11;
    }
  }
  uint64_t v22 = *a2;
  *a2 = 0;
  *(void *)uint64_t v4 = v22;
  v3[2] += 8;
  return result;
}

void sub_1CBF29B0C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a3 + 24);
  if ((int)v3 >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v21 = a2;
    while (1)
    {
      uint64_t v6 = *(void *)(a3 + 16);
      int v7 = *(unsigned __int8 *)(v6 + 16 * v5);
      if (v7 == 2) {
        break;
      }
      if (v7 == 1)
      {
        uint64_t v8 = *(unsigned int *)(v6 + 16 * v5 + 8);
LABEL_7:
        uint64_t v9 = *(void **)a2;
        uint64_t v10 = *(unsigned char **)(*(void *)a2 + 520);
        unint64_t v11 = *(void *)(*(void *)a2 + 528);
        if ((unint64_t)v10 >= v11)
        {
          unsigned int v13 = (unsigned char *)v9[64];
          unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((v10 - v13) >> 3) + 1;
          if (v14 > 0xAAAAAAAAAAAAAAALL) {
            abort();
          }
          unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - (void)v13) >> 3);
          if (2 * v15 > v14) {
            unint64_t v14 = 2 * v15;
          }
          if (v15 >= 0x555555555555555) {
            unint64_t v16 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v16 = v14;
          }
          if (v16)
          {
            if (v16 > 0xAAAAAAAAAAAAAAALL) {
              sub_1CB833614();
            }
            uint64_t v17 = (char *)operator new(24 * v16);
          }
          else
          {
            uint64_t v17 = 0;
          }
          uint64_t v18 = &v17[8 * ((v10 - v13) >> 3)];
          *uint64_t v18 = v7;
          *((void *)v18 + 1) = v8;
          *((_DWORD *)v18 + 4) = v5;
          int64x2_t v19 = v18;
          if (v10 != v13)
          {
            do
            {
              long long v20 = *(_OWORD *)(v10 - 24);
              *((_DWORD *)v19 - 2) = *((_DWORD *)v10 - 2);
              *(_OWORD *)(v19 - 24) = v20;
              v19 -= 24;
              v10 -= 24;
            }
            while (v10 != v13);
            uint64_t v10 = (unsigned char *)v9[64];
          }
          v9[64] = v19;
          unint64_t v12 = v18 + 24;
          v9[65] = v18 + 24;
          v9[66] = &v17[24 * v16];
          if (v10) {
            operator delete(v10);
          }
          a2 = v21;
        }
        else
        {
          *uint64_t v10 = v7;
          *((void *)v10 + 1) = v8;
          unint64_t v12 = v10 + 24;
          *((_DWORD *)v10 + 4) = v5;
        }
        v9[65] = v12;
      }
      if (++v5 == v3) {
        return;
      }
    }
    uint64_t v8 = *(void *)(v6 + 16 * v5 + 8);
    goto LABEL_7;
  }
}

unsigned char *sub_1CBF29CCC(unsigned char *result)
{
  result[40] = byte_1EA61F350;
  result[42] = byte_1EA61F351;
  result[41] = byte_1EA61F352;
  result[43] = byte_1EA61F353;
  return result;
}

unsigned char *sub_1CBF29D10(unsigned char *result, int a2, char a3)
{
  if (a2 == 3)
  {
    result[43] = a3;
  }
  else if (a2 == 2)
  {
    result[41] = a3;
  }
  else
  {
    result[40] = a3;
  }
  return result;
}

void sub_1CBF29D38(void *a1, int a2, int *a3, _DWORD *a4, int a5, unsigned int a6)
{
  uint64_t v10 = (char *)a1[10];
  if (*a4 != a5)
  {
    unint64_t v11 = (char *)a1[9];
    uint64_t v14 = v10 - v11;
    unint64_t v15 = (unint64_t)(v10 - v11) >> 4;
    *(_DWORD *)(a1[6] + 4 * a2) = v15;
    int v16 = *a3 + 1;
    *a3 = v16;
    unint64_t v17 = a1[11];
    if ((unint64_t)v10 < v17)
    {
      *(_DWORD *)uint64_t v10 = a5;
      *((_DWORD *)v10 + 1) = 1;
      *((_DWORD *)v10 + 2) = v15;
      *((_DWORD *)v10 + 3) = v16;
LABEL_8:
      long long v20 = v10 + 16;
LABEL_32:
      a1[10] = v20;
      goto LABEL_33;
    }
    uint64_t v21 = v14 >> 4;
    unint64_t v22 = (v14 >> 4) + 1;
    if (!(v22 >> 60))
    {
      uint64_t v23 = v17 - (void)v11;
      if (v23 >> 3 > v22) {
        unint64_t v22 = v23 >> 3;
      }
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v24 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v24 = v22;
      }
      if (!(v24 >> 60))
      {
        uint64_t v25 = (char *)operator new(16 * v24);
        uint64_t v26 = &v25[16 * v21];
        *(_DWORD *)uint64_t v26 = a5;
        *((_DWORD *)v26 + 1) = 1;
        uint64_t v27 = &v25[16 * v24];
        *((_DWORD *)v26 + 2) = v15;
        *((_DWORD *)v26 + 3) = v16;
        long long v20 = v26 + 16;
        if (v10 != v11)
        {
          do
          {
            uint64_t v28 = v26 - 16;
            *((_OWORD *)v26 - 1) = *((_OWORD *)v10 - 1);
            v10 -= 16;
            v26 -= 16;
          }
          while (v10 != v11);
LABEL_30:
          a1[9] = v28;
          a1[10] = v20;
          a1[11] = v27;
          if (v11) {
            operator delete(v11);
          }
          goto LABEL_32;
        }
LABEL_29:
        uint64_t v28 = v26;
        goto LABEL_30;
      }
LABEL_35:
      sub_1CB833614();
    }
LABEL_34:
    abort();
  }
  unint64_t v11 = (char *)a1[9];
  uint64_t v12 = v10 - v11;
  unint64_t v13 = (unint64_t)(v10 - v11) >> 4;
  if (*((_DWORD *)v10 - 3) >= a6)
  {
    *(_DWORD *)(a1[6] + 4 * a2) = v13;
    unint64_t v18 = a1[11];
    if ((unint64_t)v10 < v18)
    {
      int v19 = *a3;
      *(_DWORD *)uint64_t v10 = a5;
      *((_DWORD *)v10 + 1) = 1;
      *((_DWORD *)v10 + 2) = v13;
      *((_DWORD *)v10 + 3) = v19;
      goto LABEL_8;
    }
    uint64_t v29 = v12 >> 4;
    unint64_t v30 = (v12 >> 4) + 1;
    if (!(v30 >> 60))
    {
      uint64_t v31 = v18 - (void)v11;
      if (v31 >> 3 > v30) {
        unint64_t v30 = v31 >> 3;
      }
      if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v32 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v32 = v30;
      }
      if (!(v32 >> 60))
      {
        uint64_t v33 = (char *)operator new(16 * v32);
        int v34 = *a3;
        uint64_t v26 = &v33[16 * v29];
        *(_DWORD *)uint64_t v26 = a5;
        *((_DWORD *)v26 + 1) = 1;
        uint64_t v27 = &v33[16 * v32];
        *((_DWORD *)v26 + 2) = v13;
        *((_DWORD *)v26 + 3) = v34;
        long long v20 = v26 + 16;
        if (v10 != v11)
        {
          do
          {
            uint64_t v28 = v26 - 16;
            *((_OWORD *)v26 - 1) = *((_OWORD *)v10 - 1);
            v10 -= 16;
            v26 -= 16;
          }
          while (v10 != v11);
          goto LABEL_30;
        }
        goto LABEL_29;
      }
      goto LABEL_35;
    }
    goto LABEL_34;
  }
  *(_DWORD *)(a1[6] + 4 * a2) = v13 - 1;
  ++*((_DWORD *)v10 - 3);
LABEL_33:
  *a4 = a5;
}

void sub_1CBF29F64(unsigned char *a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  if (!byte_1EBCC2978) {
    operator new();
  }
  if (a1[43]) {
    operator new();
  }
  if (a1[41]) {
    operator new();
  }
  sub_1CD271F94(a1[42], &v4);
  sub_1CBF2AB14((char **)a2, *(void *)(a2 + 8), v4, v5, v5 - v4);
  if (a1[40]) {
    operator new();
  }
  uint64_t v6 = (void **)&v4;
  sub_1CBF2A9F0(&v6);
}

uint64_t sub_1CBF2A560(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a4 + 8);
  if (*(_DWORD *)(v4 + 536) != 8277) {
    return 0;
  }
  uint64_t v5 = a2;
  uint64_t v6 = *(void *)(v4 + 512);
  do
  {
    uint64_t v7 = v6;
    int v8 = *(_DWORD *)(v6 + 16);
    v6 += 24;
  }
  while (v8);
  if (!a3) {
    return 0;
  }
  uint64_t v9 = *(void *)(v7 + 8);
  uint64_t v10 = a2 + 16 * a3;
  while (1)
  {
    uint64_t v11 = 0;
    uint64_t v12 = *(void *)(v5 + 8);
    int v13 = *(_DWORD *)(v12 + 536);
    char v14 = 1;
    do
    {
      int v15 = sub_1CBC7A3F8((unsigned __int16)v13, (unsigned __int16)word_1CDB158B0[2 * v11]);
      if ((v14 & 1) == 0) {
        break;
      }
      char v14 = 0;
      uint64_t v11 = 1;
    }
    while (v15 == -1);
    if (v15 != -1)
    {
      uint64_t v16 = *(void *)(v12 + 512);
      do
      {
        uint64_t v17 = v16;
        int v18 = *(_DWORD *)(v16 + 16);
        v16 += 24;
      }
      while (v18 != v15);
      if (*(void *)(v17 + 8) == v9) {
        break;
      }
    }
    v5 += 16;
    if (v5 == v10) {
      return 0;
    }
  }
  return *(unsigned int *)(v12 + 548);
}

void LLVMInitializeAGX2TargetMCA()
{
  qword_1EBD02630 = (uint64_t)sub_1CBF2A678;
  qword_1EBD02638 = (uint64_t)sub_1CBF2A7A8;
}

void sub_1CBF2A678()
{
}

void sub_1CBF2A7A8()
{
}

void sub_1CBF2A808()
{
}

void sub_1CBF2A824(void *a1)
{
  sub_1CBF2A864(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CBF2A85C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 96) = a2;
  return result;
}

void *sub_1CBF2A864(void *a1)
{
  *a1 = &unk_1F25FEBF0;
  uint64_t v2 = (void *)a1[9];
  if (v2)
  {
    a1[10] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[6];
  if (v3)
  {
    a1[7] = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_1CBF2A8C4(char **a1, unint64_t a2)
{
  uint64_t v5 = a1[1];
  uint64_t v4 = a1[2];
  if (a2 > (v4 - v5) >> 2)
  {
    uint64_t v6 = *a1;
    uint64_t v7 = v5 - *a1;
    unint64_t v8 = a2 + (v7 >> 2);
    if (v8 >> 62) {
      abort();
    }
    uint64_t v9 = v4 - v6;
    if (v9 >> 1 > v8) {
      unint64_t v8 = v9 >> 1;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v10 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 >> 62) {
        sub_1CB833614();
      }
      uint64_t v11 = (char *)operator new(4 * v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    uint64_t v12 = &v11[4 * (v7 >> 2)];
    int v13 = &v11[4 * v10];
    bzero(v12, 4 * a2);
    while (v5 != v6)
    {
      int v14 = *((_DWORD *)v5 - 1);
      v5 -= 4;
      *((_DWORD *)v12 - 1) = v14;
      v12 -= 4;
    }
    *a1 = v12;
    a1[1] = &v11[4 * a2 + v7];
    a1[2] = v13;
    if (v6)
    {
      operator delete(v6);
    }
  }
  else
  {
    if (a2)
    {
      bzero(a1[1], 4 * a2);
      v5 += 4 * a2;
    }
    a1[1] = v5;
  }
}

void sub_1CBF2A9F0(void ***a1)
{
  v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        *uint64_t v4 = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v6 + 80))(v6);
        }
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1CBF2AA98(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    uint64_t v4 = *(void *)(i - 8);
    *(void *)(i - 8) = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 80))(v4);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *sub_1CBF2AB14(char **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5 = *a1;
  uint64_t v6 = a2 - (void)*a1;
  uint64_t v7 = &(*a1)[v6 & 0xFFFFFFFFFFFFFFF8];
  if (a5 < 1) {
    return v7;
  }
  uint64_t v9 = a3;
  uint64_t v11 = v6 >> 3;
  uint64_t v12 = a1[2];
  unint64_t v13 = (unint64_t)a1[1];
  if (a5 <= (uint64_t)&v12[-v13] >> 3)
  {
    uint64_t v18 = (uint64_t)(v13 - (void)v7) >> 3;
    if (v18 >= a5)
    {
      int v19 = &a3[a5];
      long long v20 = a1[1];
    }
    else
    {
      int v19 = &a3[v18];
      long long v20 = a1[1];
      if (v19 != a4)
      {
        uint64_t v21 = v19;
        unint64_t v22 = a1[1];
        do
        {
          uint64_t v23 = *v21;
          *v21++ = 0;
          *(void *)unint64_t v22 = v23;
          v22 += 8;
          v20 += 8;
        }
        while (v21 != a4);
      }
      a1[1] = v20;
      if ((uint64_t)(v13 - (void)v7) < 1) {
        return v7;
      }
    }
    unint64_t v24 = &v7[8 * a5];
    uint64_t v25 = (uint64_t *)&v20[-8 * a5];
    uint64_t v26 = v20;
    if ((unint64_t)v25 < v13)
    {
      uint64_t v26 = v20;
      do
      {
        uint64_t v27 = *v25;
        *v25++ = 0;
        *(void *)uint64_t v26 = v27;
        v26 += 8;
      }
      while ((unint64_t)v25 < v13);
    }
    a1[1] = v26;
    if (v20 != v24)
    {
      uint64_t v28 = (uint64_t *)(v20 - 8);
      uint64_t v29 = 8 * ((v20 - v24) >> 3);
      uint64_t v30 = (uint64_t)&v5[8 * v11 - 8];
      do
      {
        uint64_t v31 = *(void *)(v30 + v29);
        *(void *)(v30 + v29) = 0;
        uint64_t v32 = *v28;
        *uint64_t v28 = v31;
        if (v32) {
          (*(void (**)(uint64_t))(*(void *)v32 + 80))(v32);
        }
        --v28;
        v29 -= 8;
      }
      while (v29);
    }
    if (v19 != v9)
    {
      uint64_t v33 = (uint64_t *)v7;
      do
      {
        uint64_t v34 = *v9;
        *uint64_t v9 = 0;
        uint64_t v35 = *v33;
        *uint64_t v33 = v34;
        if (v35) {
          (*(void (**)(uint64_t))(*(void *)v35 + 80))(v35);
        }
        ++v9;
        ++v33;
      }
      while (v9 != v19);
    }
    return v7;
  }
  unint64_t v14 = a5 + ((uint64_t)(v13 - (void)v5) >> 3);
  if (v14 >> 61) {
    abort();
  }
  uint64_t v15 = v12 - v5;
  if (v15 >> 2 > v14) {
    unint64_t v14 = v15 >> 2;
  }
  if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v16 = v14;
  }
  BOOL v52 = a1 + 2;
  if (v16)
  {
    if (v16 >> 61) {
      sub_1CB833614();
    }
    uint64_t v17 = (char *)operator new(8 * v16);
  }
  else
  {
    uint64_t v17 = 0;
  }
  uint64_t v36 = &v17[8 * v11];
  BOOL v51 = &v17[8 * v16];
  uint64_t v37 = 8 * a5;
  uint64_t v38 = v36;
  uint64_t v39 = &v36[8 * a5];
  do
  {
    uint64_t v40 = *v9;
    *v9++ = 0;
    *(void *)uint64_t v38 = v40;
    v38 += 8;
    v37 -= 8;
  }
  while (v37);
  uint64_t v41 = *a1;
  uint64_t v42 = &v17[8 * v11];
  if (v7 != *a1)
  {
    BOOL v43 = v7;
    uint64_t v42 = &v17[8 * v11];
    do
    {
      uint64_t v44 = *((void *)v43 - 1);
      v43 -= 8;
      *(void *)BOOL v43 = 0;
      *((void *)v42 - 1) = v44;
      v42 -= 8;
    }
    while (v43 != v41);
  }
  unint64_t v45 = a1[1];
  if (v7 != v45)
  {
    do
    {
      uint64_t v46 = *(void *)v7;
      *(void *)uint64_t v7 = 0;
      v7 += 8;
      *(void *)uint64_t v39 = v46;
      v39 += 8;
    }
    while (v7 != v45);
    uint64_t v7 = a1[1];
  }
  BOOL v47 = *a1;
  *a1 = v42;
  a1[1] = v39;
  BOOL v48 = a1[2];
  a1[2] = v51;
  v50[2] = v7;
  BOOL v51 = v48;
  v50[0] = v47;
  v50[1] = v47;
  sub_1CBF2AA98((uint64_t)v50);
  return v36;
}

uint64_t sub_1CBF2ADD4()
{
  qword_1EBCC28D8 = (uint64_t)"Custom View Options";
  unk_1EBCC28E0 = 19;
  qword_1EBCC28E8 = (uint64_t)"";
  unk_1EBCC28F0 = 0;
  llvm::cl::OptionCategory::registerCategory((llvm::cl::OptionCategory *)&qword_1EBCC28D8);
  uint64_t v0 = sub_1CB883A14((uint64_t)qword_1EBCC28F8, 0, 0);
  byte_1EBCC2978 = 0;
  qword_1EBCC2980 = (uint64_t)&unk_1F25EDE58;
  *(void *)&word_1EBCC2988 = 0;
  qword_1EBCC28F8[0] = (uint64_t)&unk_1F26440A0;
  qword_1EBCC2990 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCC2998 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCC29B0 = (uint64_t)&qword_1EBCC2998;
  llvm::cl::Option::setArgStr(v0, "disable-agx2-clause-view", 0x18uLL);
  qword_1EBCC2918 = (uint64_t)"Omit the ClauseView in mca's output for AGX2.";
  unk_1EBCC2920 = 45;
  llvm::cl::Option::addCategory((llvm::cl::Option *)qword_1EBCC28F8, (llvm::cl::OptionCategory *)&qword_1EBCC28D8);
  byte_1EBCC2978 = 0;
  word_1EBCC2988 = 256;
  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EBCC28F8);

  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, qword_1EBCC28F8, &dword_1CB82C000);
}

void sub_1CBF2AF20(uint64_t a1, llvm::raw_ostream *a2)
{
  v51[16] = *MEMORY[0x1E4F143B8];
  __p = 0;
  size_t v47 = 0;
  uint64_t v48 = 0;
  int v38 = 0;
  char v42 = 0;
  uint64_t v43 = 0;
  p_p = &__p;
  int v44 = 0;
  uint64_t v37 = &unk_1F2646F30;
  uint64_t v39 = 0;
  unint64_t v40 = 0;
  uint64_t v41 = 0;
  unint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    uint64_t v32 = a2;
    unint64_t v49 = v51;
    uint64_t v50 = 0x1000000000;
    sub_1CBF2CDDC((uint64_t)&v49, v3);
    sub_1CBF2B49C(*(void *)(a1 + 32), *(void *)(a1 + 40), (uint64_t)v49, v50);
    uint64_t v5 = v41;
    if (v40 - (unint64_t)v41 > 0x18)
    {
      *uint64_t v41 = *(_OWORD *)"\n\nAGX2 Instruction Info:\n";
      *(_OWORD *)((char *)v5 + 9) = *(_OWORD *)"struction Info:\n";
      uint64_t v6 = (char *)v41 + 25;
      uint64_t v41 = (_OWORD *)((char *)v41 + 25);
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v37, "\n\nAGX2 Instruction Info:\n", 0x19uLL);
      uint64_t v6 = (char *)v41;
    }
    if (v40 - (unint64_t)v6 > 0x11)
    {
      *((_WORD *)v6 + 8) = 2661;
      *(_OWORD *)uint64_t v6 = *(_OWORD *)"[1]: >=Quad Scope\n";
      uint64_t v7 = (char *)v41 + 18;
      uint64_t v41 = (_OWORD *)((char *)v41 + 18);
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v37, "[1]: >=Quad Scope\n", 0x12uLL);
      uint64_t v7 = (char *)v41;
    }
    if (v40 - (unint64_t)v7 > 0x11)
    {
      *((_WORD *)v7 + 8) = 2661;
      *(_OWORD *)uint64_t v7 = *(_OWORD *)"[2]: >=SIMD Scope\n";
      unint64_t v8 = (char *)v41 + 18;
      uint64_t v41 = (_OWORD *)((char *)v41 + 18);
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v37, "[2]: >=SIMD Scope\n", 0x12uLL);
      unint64_t v8 = (char *)v41;
    }
    if (v40 - (unint64_t)v8 > 0x11)
    {
      *((_WORD *)v8 + 8) = 2661;
      *(_OWORD *)unint64_t v8 = *(_OWORD *)"[3]: >=Instr Rate\n";
      uint64_t v9 = (char *)v41 + 18;
      uint64_t v41 = (_OWORD *)((char *)v41 + 18);
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v37, "[3]: >=Instr Rate\n", 0x12uLL);
      uint64_t v9 = (char *)v41;
    }
    if (v40 - (unint64_t)v9 > 0x1A)
    {
      qmemcpy(v9, "\n[1] [2] [3] Instructions:\n", 27);
      uint64_t v41 = (_OWORD *)((char *)v41 + 27);
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v37, "\n[1] [2] [3] Instructions:\n", 0x1BuLL);
    }
    if (v50)
    {
      unint64_t v10 = (char *)v49;
      uint64_t v33 = (char *)v49 + 8 * v50;
      uint64_t v11 = *(void *)(a1 + 32);
      uint64_t v12 = 168 * *(void *)(a1 + 40);
      while (1)
      {
        unint64_t v13 = (char *)v41;
        if (!v12) {
          break;
        }
        if (*v10) {
          unint64_t v14 = " *  ";
        }
        else {
          unint64_t v14 = "    ";
        }
        if (v40 - (unint64_t)v41 >= 4)
        {
          *(_DWORD *)uint64_t v41 = *(_DWORD *)v14;
          uint64_t v15 = (_DWORD *)v41 + 1;
          uint64_t v41 = (_OWORD *)((char *)v41 + 4);
        }
        else
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v37, v14, 4uLL);
          uint64_t v15 = v41;
        }
        if (v10[1]) {
          unint64_t v16 = " *  ";
        }
        else {
          unint64_t v16 = "    ";
        }
        if (v40 - (unint64_t)v15 > 3)
        {
          *uint64_t v15 = *(_DWORD *)v16;
          uint64_t v41 = (_OWORD *)((char *)v41 + 4);
        }
        else
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v37, v16, 4uLL);
        }
        uint64_t v34 = &unk_1F25FED10;
        uint64_t v17 = *((unsigned int *)v10 + 1);
        uint64_t v35 = "%3d ";
        uint64_t v36 = v17;
        llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v37, (uint64_t)&v34);
        MEMORY[0x1D25D9630](a1 + 48, "");
        (*(void (**)(void, uint64_t, void, const char *, void, void, uint64_t))(**(void **)(a1 + 16)
                                                                                               + 32))(*(void *)(a1 + 16), v11, 0, "", 0, *(void *)(a1 + 8), a1 + 72);
        uint64_t v18 = *(const char **)(a1 + 88);
        if (*(const char **)(a1 + 104) != v18)
        {
          *(void *)(a1 + 104) = v18;
          llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)(a1 + 72), v18);
        }
        char v19 = *(unsigned char *)(a1 + 71);
        BOOL v20 = v19 < 0;
        if (v19 >= 0) {
          uint64_t v21 = (char *)(a1 + 48);
        }
        else {
          uint64_t v21 = *(char **)(a1 + 48);
        }
        unint64_t v22 = (const char *)(v19 & 0x7F);
        if (v20) {
          uint64_t v23 = *(const char **)(a1 + 56);
        }
        else {
          uint64_t v23 = v22;
        }
        uint64_t v34 = v21;
        uint64_t v35 = v23;
        unint64_t first_not_of = llvm::StringRef::find_first_not_of(&v34, " \t\n\v\f\r", 6, 0);
        unint64_t v25 = first_not_of;
        if (first_not_of >= (unint64_t)v23) {
          unint64_t v26 = (unint64_t)v23;
        }
        else {
          unint64_t v26 = first_not_of;
        }
        uint64_t v27 = &v21[v26];
        size_t v28 = (size_t)&v23[-v26];
        uint64_t v29 = (char *)v41;
        if ((unint64_t)&v23[-v26] <= v40 - (unint64_t)v41)
        {
          if ((unint64_t)v23 > v25)
          {
            memcpy(v41, v27, v28);
            uint64_t v29 = (char *)v41 + v28;
            uint64_t v41 = (_OWORD *)((char *)v41 + v28);
          }
        }
        else
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v37, v27, v28);
          uint64_t v29 = (char *)v41;
        }
        if ((unint64_t)v29 >= v40)
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v37, 10);
        }
        else
        {
          uint64_t v41 = v29 + 1;
          *uint64_t v29 = 10;
        }
        v11 += 168;
        v12 -= 168;
        v10 += 8;
        if (v10 == v33) {
          goto LABEL_47;
        }
      }
    }
    else
    {
LABEL_47:
      unint64_t v13 = (char *)v41;
    }
    if (v13 != v39)
    {
      uint64_t v41 = v39;
      llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)&v37, v39);
    }
    if (v48 >= 0) {
      uint64_t v30 = (const char *)&__p;
    }
    else {
      uint64_t v30 = (const char *)__p;
    }
    if (v48 >= 0) {
      size_t v31 = HIBYTE(v48) & 0x7F;
    }
    else {
      size_t v31 = v47;
    }
    llvm::raw_ostream::write(v32, v30, v31);
    if (v49 != v51) {
      free(v49);
    }
    uint64_t v37 = &unk_1F2646B98;
    if (v44 == 1 && v39) {
      MEMORY[0x1D25D9CB0](v39, 0x1000C8077774924);
    }
  }
  if (SHIBYTE(v48) < 0) {
    operator delete(__p);
  }
}

uint64_t sub_1CBF2B49C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 && a4)
  {
    uint64_t v4 = a3;
    uint64_t v5 = (unsigned int *)result;
    uint64_t v6 = a3 + 8 * a4;
    uint64_t v7 = 168 * a2 - 168;
    do
    {
      uint64_t v8 = *v5;
      unsigned int v9 = byte_1CDE9A168[v8];
      int v10 = (v9 >> 1) & 1;
      BOOL v11 = (v9 & 4) == 0;
      BOOL v12 = (v9 & 4) != 0 || (v9 & 3) != 0;
      if (v11) {
        char v13 = v10;
      }
      else {
        char v13 = 1;
      }
      *(unsigned char *)uint64_t v4 = v12;
      *(unsigned char *)(v4 + 1) = v13;
      uint64_t result = sub_1CBD7904C(v8);
      *(_DWORD *)(v4 + 4) = result;
      if (!v7) {
        break;
      }
      v5 += 42;
      v4 += 8;
      v7 -= 168;
    }
    while (v4 != v6);
  }
  return result;
}

void sub_1CBF2B540(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    unint64_t v22 = v24;
    uint64_t v23 = 0x1000000000;
    sub_1CBF2CDDC((uint64_t)&v22, v3);
    sub_1CBF2B49C(*(void *)(a1 + 32), *(void *)(a1 + 40), (uint64_t)v22, v23);
    long long v20 = 0uLL;
    unint64_t v21 = 0;
    if (v23)
    {
      unsigned int v5 = 0;
      uint64_t v6 = (char *)v22;
      uint64_t v7 = (char *)v22 + 8 * v23;
      do
      {
        sub_1CBF2C538(v25, "QUADScope", 9uLL);
        char v8 = *v6;
        LOWORD(v26) = 1;
        LOBYTE(v27) = v8;
        sub_1CBF2C538(v29, "SIMDScope", 9uLL);
        char v9 = v6[1];
        __int16 v30 = 1;
        char v31 = v9;
        sub_1CBF2C538(v32, "InstrRate", 9uLL);
        uint64_t v10 = *((unsigned int *)v6 + 1);
        __int16 v33 = 3;
        uint64_t v34 = v10;
        sub_1CD451B70((uint64_t)&v17, (uint64_t)v25, 3);
        uint64_t v11 = 168;
        do
        {
          llvm::json::Value::destroy((llvm::json::Value *)&v24[v11 + 96]);
          sub_1CB833F88((uint64_t *)&v24[v11 + 72], 0);
          v11 -= 56;
        }
        while (v11);
        sub_1CBF2C538(v25, "Instruction", 0xBuLL);
        unsigned int v16 = v5;
        sub_1CBF2CE7C((uint64_t)&v17, (uint64_t)v25, &v16, (uint64_t)&v15);
        BOOL v12 = v25[0];
        v25[0] = 0;
        if (v12)
        {
          if (*((char *)v12 + 23) < 0) {
            operator delete(*v12);
          }
          MEMORY[0x1D25D9CE0](v12, 0x1012C40EC159624);
        }
        LOWORD(v25[0]) = 7;
        v25[1] = v17;
        v25[2] = v18;
        uint64_t v17 = 0;
        uint64_t v18 = 0;
        int v26 = v19;
        int v19 = 0;
        uint64_t v13 = *((void *)&v20 + 1);
        if (*((void *)&v20 + 1) >= v21)
        {
          uint64_t v14 = sub_1CBF2C6D0((unsigned __int16 **)&v20, (unsigned __int16 *)v25);
        }
        else
        {
          llvm::json::Value::moveFrom(*((uint64_t *)&v20 + 1), (unsigned __int16 *)v25);
          uint64_t v14 = v13 + 32;
        }
        *((void *)&v20 + 1) = v14;
        llvm::json::Value::destroy((llvm::json::Value *)v25);
        sub_1CD452448((unsigned int *)&v17);
        MEMORY[0x1D25D9CD0](v17, 8);
        v6 += 8;
        ++v5;
      }
      while (v6 != v7);
    }
    sub_1CBF2C538(v25, "InstructionList", 0xFuLL);
    LOWORD(v26) = 8;
    long long v27 = v20;
    unint64_t v28 = v21;
    long long v20 = 0uLL;
    unint64_t v21 = 0;
    sub_1CD451B70((uint64_t)&v17, (uint64_t)v25, 1);
    *(_WORD *)a2 = 7;
    *(void *)(a2 + 8) = v17;
    *(void *)(a2 + 16) = v18;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    *(_DWORD *)(a2 + 24) = v19;
    int v19 = 0;
    sub_1CD452448((unsigned int *)&v17);
    MEMORY[0x1D25D9CD0](v17, 8);
    llvm::json::Value::destroy((llvm::json::Value *)&v26);
    sub_1CB833F88((uint64_t *)v25, 0);
    v25[0] = (void **)&v20;
    sub_1CBF2C7E0(v25);
    if (v22 != v24) {
      free(v22);
    }
  }
  else
  {
    *(_WORD *)a2 = 3;
    *(void *)(a2 + 8) = 0;
  }
}

uint64_t sub_1CBF2B874(uint64_t a1, uint64_t a2)
{
  v114[16] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = *(void *)(a1 + 40);
  uint64_t v112 = v114;
  uint64_t v113 = 0x1000000000;
  sub_1CBF2CDDC((uint64_t)&v112, v4);
  sub_1CBF2B49C(*(void *)(a1 + 32), *(void *)(a1 + 40), (uint64_t)v112, v113);
  if (v113)
  {
    unsigned int v58 = 0;
    uint64_t v6 = 0;
    uint64_t v59 = 0;
    char v60 = (char *)v112;
    unint64_t v110 = (char *)v112 + 8 * v113;
    while (1)
    {
      unint64_t v111 = (unint64_t)v58;
      int v61 = *v60;
      int v62 = v60[1];
      int v63 = *((_DWORD *)v60 + 1);
      *(unsigned char *)(a2 + 70) = 1;
      uint64_t v64 = *(void *)(a2 + 40);
      uint64_t v65 = *(void *)(a2 + 48);
      uint64_t v66 = *(void *)(a2 + 32);
      if (v63 || *(unsigned char *)(a2 + 80) != 0) {
        break;
      }
      BOOL v76 = 0;
LABEL_105:
      if (v62) {
        BOOL v77 = 0;
      }
      else {
        BOOL v77 = !v76;
      }
      if (v77)
      {
        BOOL v81 = 0;
      }
      else
      {
        unsigned int v78 = sub_1CBF2CB00(a2, v62);
        uint64_t v79 = *(uint64_t **)(a2 + 56);
        if (*(void *)(a2 + 48) - (void)v79 <= 7uLL)
        {
          sub_1CBF2C904((uint64_t *)a2, 8uLL);
          uint64_t v79 = *(uint64_t **)(a2 + 56);
        }
        *uint64_t v79 = v78 | 0x600000000;
        *(void *)(a2 + 56) += 8;
        ++*(_DWORD *)(a2 + 64);
        unsigned int v80 = *(unsigned __int16 *)(a2 + 68);
        if (v80 <= 6) {
          LOWORD(v80) = 6;
        }
        *(_WORD *)(a2 + 68) = v80;
        BOOL v81 = *(unsigned char *)(a2 + 80) != 0;
      }
      if (v61) {
        BOOL v82 = 0;
      }
      else {
        BOOL v82 = !v81;
      }
      unsigned int v58 = (char *)v111;
      if (!v82)
      {
        unsigned int v83 = sub_1CBF2CB00(a2, v61);
        unsigned int v84 = *(uint64_t **)(a2 + 56);
        if (*(void *)(a2 + 48) - (void)v84 <= 7uLL)
        {
          sub_1CBF2C904((uint64_t *)a2, 8uLL);
          unsigned int v84 = *(uint64_t **)(a2 + 56);
        }
        *unsigned int v84 = v83 | 0x400000000;
        *(void *)(a2 + 56) += 8;
        ++*(_DWORD *)(a2 + 64);
        unsigned int v85 = *(unsigned __int16 *)(a2 + 68);
        if (v85 <= 4) {
          LOWORD(v85) = 4;
        }
        *(_WORD *)(a2 + 68) = v85;
      }
      int v86 = sub_1CBF2CB78(a2, (unsigned __int16)v66 - (unsigned __int16)v65 + (unsigned __int16)v64);
      int v87 = v86;
      if ((unint64_t)v59 >= v111)
      {
        uint64_t v88 = (v59 - v6) >> 2;
        unint64_t v89 = v88 + 1;
        if ((unint64_t)(v88 + 1) >> 62) {
          abort();
        }
        if ((uint64_t)(v111 - (void)v6) >> 1 > v89) {
          unint64_t v89 = (uint64_t)(v111 - (void)v6) >> 1;
        }
        if (v111 - (unint64_t)v6 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v90 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v90 = v89;
        }
        if (v90)
        {
          if (v90 >> 62) {
            sub_1CB833614();
          }
          unint64_t v91 = (char *)operator new(4 * v90);
        }
        else
        {
          unint64_t v91 = 0;
        }
        uint64_t v92 = &v91[4 * v88];
        *(_DWORD *)uint64_t v92 = v87;
        unsigned int v5 = v92 + 4;
        while (v59 != v6)
        {
          int v93 = *((_DWORD *)v59 - 1);
          v59 -= 4;
          *((_DWORD *)v92 - 1) = v93;
          v92 -= 4;
        }
        unsigned int v58 = &v91[4 * v90];
        if (v6) {
          operator delete(v6);
        }
        uint64_t v6 = v92;
      }
      else
      {
        *(_DWORD *)uint64_t v59 = v86;
        unsigned int v5 = v59 + 4;
      }
      v60 += 8;
      uint64_t v59 = v5;
      if (v60 == v110) {
        goto LABEL_3;
      }
    }
    if (*(void *)(a2 + 72) <= 3uLL) {
      *(void *)(a2 + 72) = 4;
    }
    __int16 v108 = v66;
    __int16 v109 = v64;
    unint64_t v68 = ((_BYTE)v65 - ((_BYTE)v66 + (_BYTE)v64)) & 3;
    int v69 = *(uint64_t **)(a2 + 56);
    if (v65 - (uint64_t)v69 < v68)
    {
      sub_1CBF2C904((uint64_t *)a2, v68);
      *(void *)(a2 + 48) -= v68;
    }
    else
    {
      uint64_t v70 = v65 - v68;
      *(void *)(a2 + 48) = v65 - v68;
      if (!v68)
      {
LABEL_97:
        if ((unint64_t)(v70 - (void)v69) <= 3)
        {
          sub_1CBF2C904((uint64_t *)a2, 4uLL);
          uint64_t v70 = *(void *)(a2 + 48);
          int v69 = *(uint64_t **)(a2 + 56);
        }
        *(_DWORD *)(v70 - 4) = v63;
        uint64_t v72 = v70 - 4;
        *(void *)(a2 + 48) = v72;
        uint64_t v73 = *(void *)(a2 + 32);
        uint64_t v74 = *(void *)(a2 + 40);
        if ((unint64_t)(v72 - (void)v69) <= 7)
        {
          sub_1CBF2C904((uint64_t *)a2, 8uLL);
          int v69 = *(uint64_t **)(a2 + 56);
        }
        *int v69 = (v73 - v72 + v74) | 0x800000000;
        *(void *)(a2 + 56) += 8;
        ++*(_DWORD *)(a2 + 64);
        unsigned int v75 = *(unsigned __int16 *)(a2 + 68);
        if (v75 <= 8) {
          LOWORD(v75) = 8;
        }
        *(_WORD *)(a2 + 68) = v75;
        BOOL v76 = *(unsigned char *)(a2 + 80) != 0;
        LOWORD(v66) = v108;
        LOWORD(v64) = v109;
        goto LABEL_105;
      }
    }
    uint64_t v71 = 0;
    do
      *(unsigned char *)(*(void *)(a2 + 48) + v71++) = 0;
    while (v68 != v71);
    uint64_t v70 = *(void *)(a2 + 48);
    int v69 = *(uint64_t **)(a2 + 56);
    goto LABEL_97;
  }
  unsigned int v5 = 0;
  uint64_t v6 = 0;
LABEL_3:
  uint64_t v7 = v5 - v6;
  if (v5 == v6) {
    char v8 = (char *)&unk_1CFAA0178;
  }
  else {
    char v8 = v6;
  }
  *(unsigned char *)(a2 + 70) = 1;
  if (*(void *)(a2 + 72) <= 3uLL) {
    *(void *)(a2 + 72) = 4;
  }
  uint64_t v9 = *(void *)(a2 + 48);
  unint64_t v10 = ((_BYTE)v9 - (*(_DWORD *)(a2 + 32) + *(_DWORD *)(a2 + 40))) & 3;
  if (v9 - *(void *)(a2 + 56) < v10)
  {
    sub_1CBF2C904((uint64_t *)a2, ((_BYTE)v9 - (*(_DWORD *)(a2 + 32) + *(_DWORD *)(a2 + 40))) & 3);
    *(void *)(a2 + 48) -= v10;
  }
  else
  {
    *(void *)(a2 + 48) = v9 - v10;
    if (!v10) {
      goto LABEL_10;
    }
  }
  uint64_t v107 = 0;
  do
    *(unsigned char *)(*(void *)(a2 + 48) + v107++) = 0;
  while (v10 != v107);
  if (*(void *)(a2 + 72) <= 3uLL) {
    *(void *)(a2 + 72) = 4;
  }
LABEL_10:
  uint64_t v11 = *(void *)(a2 + 48);
  unint64_t v12 = ((_BYTE)v11 - (*(_DWORD *)(a2 + 32) + *(_DWORD *)(a2 + 40))) & 3;
  if (v11 - *(void *)(a2 + 56) < v12)
  {
    sub_1CBF2C904((uint64_t *)a2, ((_BYTE)v11 - (*(_DWORD *)(a2 + 32) + *(_DWORD *)(a2 + 40))) & 3);
    *(void *)(a2 + 48) -= v12;
  }
  else
  {
    *(void *)(a2 + 48) = v11 - v12;
    if (!v12) {
      goto LABEL_14;
    }
  }
  uint64_t v13 = 0;
  do
    *(unsigned char *)(*(void *)(a2 + 48) + v13++) = 0;
  while (v12 != v13);
LABEL_14:
  if (v6 != v5)
  {
    uint64_t v94 = v7 >> 2;
    do
    {
      --v94;
      int v95 = *(_DWORD *)&v8[4 * v94];
      if (*(void *)(a2 + 72) <= 3uLL) {
        *(void *)(a2 + 72) = 4;
      }
      uint64_t v96 = *(void *)(a2 + 32);
      uint64_t v97 = *(void *)(a2 + 40);
      uint64_t v98 = *(void *)(a2 + 48);
      unint64_t v99 = ((int)v98 - ((int)v96 + (int)v97)) & 3;
      if (v98 - *(void *)(a2 + 56) < v99)
      {
        sub_1CBF2C904((uint64_t *)a2, ((int)v98 - ((int)v96 + (int)v97)) & 3);
        *(void *)(a2 + 48) -= v99;
      }
      else
      {
        uint64_t v100 = v98 - v99;
        *(void *)(a2 + 48) = v100;
        if (!v99)
        {
          int v101 = v96 + v97 - v100;
          goto LABEL_156;
        }
      }
      uint64_t v102 = 0;
      do
        *(unsigned char *)(*(void *)(a2 + 48) + v102++) = 0;
      while (v99 != v102);
      uint64_t v97 = *(void *)(a2 + 40);
      uint64_t v100 = *(void *)(a2 + 48);
      uint64_t v96 = *(void *)(a2 + 32);
      int v101 = v96 - v100 + v97;
      if (*(void *)(a2 + 72) <= 3uLL) {
        *(void *)(a2 + 72) = 4;
      }
LABEL_156:
      unint64_t v103 = ((_BYTE)v100 - ((_BYTE)v96 + (_BYTE)v97)) & 3;
      uint64_t v104 = *(void *)(a2 + 56);
      if (v100 - v104 < v103)
      {
        sub_1CBF2C904((uint64_t *)a2, v103);
        *(void *)(a2 + 48) -= v103;
LABEL_158:
        uint64_t v106 = 0;
        do
          *(unsigned char *)(*(void *)(a2 + 48) + v106++) = 0;
        while (v103 != v106);
        uint64_t v105 = *(void *)(a2 + 48);
        uint64_t v104 = *(void *)(a2 + 56);
        goto LABEL_161;
      }
      uint64_t v105 = v100 - v103;
      *(void *)(a2 + 48) = v100 - v103;
      if (v103) {
        goto LABEL_158;
      }
LABEL_161:
      if ((unint64_t)(v105 - v104) <= 3)
      {
        sub_1CBF2C904((uint64_t *)a2, 4uLL);
        uint64_t v105 = *(void *)(a2 + 48);
      }
      *(_DWORD *)(v105 - 4) = v101 - v95 + 4;
      *(void *)(a2 + 48) = v105 - 4;
    }
    while (v94);
  }
  *(unsigned char *)(a2 + 70) = 0;
  if (*(void *)(a2 + 72) <= 3uLL) {
    *(void *)(a2 + 72) = 4;
  }
  uint64_t v15 = *(void *)(a2 + 48);
  uint64_t v14 = *(void *)(a2 + 56);
  unint64_t v16 = ((_BYTE)v15 - (*(_DWORD *)(a2 + 32) + *(_DWORD *)(a2 + 40))) & 3;
  if (v15 - v14 < v16)
  {
    sub_1CBF2C904((uint64_t *)a2, ((_BYTE)v15 - (*(_DWORD *)(a2 + 32) + *(_DWORD *)(a2 + 40))) & 3);
    *(void *)(a2 + 48) -= v16;
  }
  else
  {
    uint64_t v17 = v15 - v16;
    *(void *)(a2 + 48) = v15 - v16;
    if (!v16) {
      goto LABEL_22;
    }
  }
  uint64_t v18 = 0;
  do
    *(unsigned char *)(*(void *)(a2 + 48) + v18++) = 0;
  while (v16 != v18);
  uint64_t v17 = *(void *)(a2 + 48);
  uint64_t v14 = *(void *)(a2 + 56);
LABEL_22:
  if ((unint64_t)(v17 - v14) <= 3)
  {
    sub_1CBF2C904((uint64_t *)a2, 4uLL);
    uint64_t v17 = *(void *)(a2 + 48);
  }
  *(_DWORD *)(v17 - 4) = (unint64_t)v7 >> 2;
  uint64_t v19 = v17 - 4;
  *(void *)(a2 + 48) = v19;
  uint64_t v20 = *(void *)(a2 + 32);
  uint64_t v21 = *(void *)(a2 + 40);
  *(unsigned char *)(a2 + 70) = 1;
  int v22 = v20 - v19 + v21;
  if (v22)
  {
    if (*(void *)(a2 + 72) <= 3uLL) {
      *(void *)(a2 + 72) = 4;
    }
    unint64_t v23 = ((_BYTE)v19 - ((_BYTE)v20 + (_BYTE)v21)) & 3;
    if (v19 - *(void *)(a2 + 56) < v23)
    {
      sub_1CBF2C904((uint64_t *)a2, ((_BYTE)v19 - ((_BYTE)v20 + (_BYTE)v21)) & 3);
      *(void *)(a2 + 48) -= v23;
    }
    else
    {
      uint64_t v24 = v19 - v23;
      *(void *)(a2 + 48) = v24;
      if (!v23)
      {
LABEL_32:
        int v26 = v21 - v24 + v20 - v22 + 4;
        if (v21 - v24 + v20 - v22 == -4 && *(unsigned char *)(a2 + 80) == 0) {
          goto LABEL_50;
        }
        if (*(void *)(a2 + 72) <= 3uLL) {
          *(void *)(a2 + 72) = 4;
        }
        unint64_t v28 = ((_BYTE)v24 - ((_BYTE)v20 + (_BYTE)v21)) & 3;
        uint64_t v29 = *(uint64_t **)(a2 + 56);
        if (v24 - (uint64_t)v29 < v28)
        {
          sub_1CBF2C904((uint64_t *)a2, v28);
          *(void *)(a2 + 48) -= v28;
        }
        else
        {
          uint64_t v30 = v24 - v28;
          *(void *)(a2 + 48) = v24 - v28;
          if (!v28)
          {
LABEL_43:
            if ((unint64_t)(v30 - (void)v29) <= 3)
            {
              sub_1CBF2C904((uint64_t *)a2, 4uLL);
              uint64_t v30 = *(void *)(a2 + 48);
              uint64_t v29 = *(uint64_t **)(a2 + 56);
            }
            *(_DWORD *)(v30 - 4) = v26;
            uint64_t v32 = v30 - 4;
            *(void *)(a2 + 48) = v32;
            uint64_t v33 = *(void *)(a2 + 32) - v32 + *(void *)(a2 + 40);
            if ((unint64_t)(v32 - (void)v29) <= 7)
            {
              sub_1CBF2C904((uint64_t *)a2, 8uLL);
              uint64_t v29 = *(uint64_t **)(a2 + 56);
            }
            *uint64_t v29 = v33 | 0x400000000;
            *(void *)(a2 + 56) += 8;
            ++*(_DWORD *)(a2 + 64);
            unsigned int v34 = *(unsigned __int16 *)(a2 + 68);
            if (v34 <= 4) {
              LOWORD(v34) = 4;
            }
            *(_WORD *)(a2 + 68) = v34;
            goto LABEL_50;
          }
        }
        uint64_t v31 = 0;
        do
          *(unsigned char *)(*(void *)(a2 + 48) + v31++) = 0;
        while (v28 != v31);
        uint64_t v30 = *(void *)(a2 + 48);
        uint64_t v29 = *(uint64_t **)(a2 + 56);
        goto LABEL_43;
      }
    }
    uint64_t v25 = 0;
    do
      *(unsigned char *)(*(void *)(a2 + 48) + v25++) = 0;
    while (v23 != v25);
    uint64_t v21 = *(void *)(a2 + 40);
    uint64_t v24 = *(void *)(a2 + 48);
    uint64_t v20 = *(void *)(a2 + 32);
    goto LABEL_32;
  }
LABEL_50:
  int v35 = sub_1CBF2CB78(a2, v22);
  *(unsigned char *)(a2 + 70) = 1;
  int v36 = *(_DWORD *)(a2 + 32) - *(_DWORD *)(a2 + 48) + *(_DWORD *)(a2 + 40);
  unsigned int v37 = sub_1CD4525F4(a2, 4);
  int v38 = *(uint64_t **)(a2 + 56);
  if (*(void *)(a2 + 48) - (void)v38 <= 7uLL)
  {
    sub_1CBF2C904((uint64_t *)a2, 8uLL);
    int v38 = *(uint64_t **)(a2 + 56);
  }
  *int v38 = v37 | 0x400000000;
  uint64_t v39 = *(void *)(a2 + 56) + 8;
  *(void *)(a2 + 56) = v39;
  ++*(_DWORD *)(a2 + 64);
  unsigned int v40 = *(unsigned __int16 *)(a2 + 68);
  if (v40 <= 4) {
    LOWORD(v40) = 4;
  }
  *(_WORD *)(a2 + 68) = v40;
  if (v35)
  {
    if (*(void *)(a2 + 72) <= 3uLL) {
      *(void *)(a2 + 72) = 4;
    }
    uint64_t v41 = *(void *)(a2 + 40);
    uint64_t v42 = *(void *)(a2 + 48);
    uint64_t v43 = *(void *)(a2 + 32);
    unint64_t v44 = ((int)v42 - ((int)v43 + (int)v41)) & 3;
    if (v42 - v39 < v44)
    {
      sub_1CBF2C904((uint64_t *)a2, ((int)v42 - ((int)v43 + (int)v41)) & 3);
      *(void *)(a2 + 48) -= v44;
    }
    else
    {
      uint64_t v45 = v42 - v44;
      *(void *)(a2 + 48) = v42 - v44;
      if (!v44)
      {
LABEL_62:
        int v47 = v41 - v45 + v43 - v35 + 4;
        if (v41 - v45 + v43 - v35 == -4 && *(unsigned char *)(a2 + 80) == 0) {
          goto LABEL_80;
        }
        if (*(void *)(a2 + 72) <= 3uLL) {
          *(void *)(a2 + 72) = 4;
        }
        unint64_t v49 = ((_BYTE)v45 - ((_BYTE)v43 + (_BYTE)v41)) & 3;
        uint64_t v50 = *(uint64_t **)(a2 + 56);
        if (v45 - (uint64_t)v50 < v49)
        {
          sub_1CBF2C904((uint64_t *)a2, v49);
          *(void *)(a2 + 48) -= v49;
        }
        else
        {
          uint64_t v51 = v45 - v49;
          *(void *)(a2 + 48) = v45 - v49;
          if (!v49)
          {
LABEL_73:
            if ((unint64_t)(v51 - (void)v50) <= 3)
            {
              sub_1CBF2C904((uint64_t *)a2, 4uLL);
              uint64_t v51 = *(void *)(a2 + 48);
              uint64_t v50 = *(uint64_t **)(a2 + 56);
            }
            *(_DWORD *)(v51 - 4) = v47;
            uint64_t v53 = v51 - 4;
            *(void *)(a2 + 48) = v53;
            uint64_t v54 = *(void *)(a2 + 32) - v53 + *(void *)(a2 + 40);
            if ((unint64_t)(v53 - (void)v50) <= 7)
            {
              sub_1CBF2C904((uint64_t *)a2, 8uLL);
              uint64_t v50 = *(uint64_t **)(a2 + 56);
            }
            *uint64_t v50 = v54 | 0xE00000000;
            *(void *)(a2 + 56) += 8;
            ++*(_DWORD *)(a2 + 64);
            unsigned int v55 = *(unsigned __int16 *)(a2 + 68);
            if (v55 <= 0xE) {
              LOWORD(v55) = 14;
            }
            *(_WORD *)(a2 + 68) = v55;
            goto LABEL_80;
          }
        }
        uint64_t v52 = 0;
        do
          *(unsigned char *)(*(void *)(a2 + 48) + v52++) = 0;
        while (v49 != v52);
        uint64_t v51 = *(void *)(a2 + 48);
        uint64_t v50 = *(uint64_t **)(a2 + 56);
        goto LABEL_73;
      }
    }
    uint64_t v46 = 0;
    do
      *(unsigned char *)(*(void *)(a2 + 48) + v46++) = 0;
    while (v44 != v46);
    uint64_t v41 = *(void *)(a2 + 40);
    uint64_t v45 = *(void *)(a2 + 48);
    uint64_t v43 = *(void *)(a2 + 32);
    goto LABEL_62;
  }
LABEL_80:
  unsigned int v56 = sub_1CBF2CB78(a2, v36);
  if (v6) {
    operator delete(v6);
  }
  if (v112 != v114) {
    free(v112);
  }
  return v56 | 0x100000000;
}

uint64_t sub_1CBF2C3C8(uint64_t a1)
{
  *(void *)a1 = &unk_1F25FEC78;
  *(void *)(a1 + 72) = &unk_1F2646B98;
  if (*(_DWORD *)(a1 + 128) == 1)
  {
    uint64_t v3 = *(void *)(a1 + 88);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8077774924);
    }
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  return a1;
}

void sub_1CBF2C464(uint64_t a1)
{
  *(void *)a1 = &unk_1F25FEC78;
  *(void *)(a1 + 72) = &unk_1F2646B98;
  if (*(_DWORD *)(a1 + 128) == 1)
  {
    uint64_t v2 = *(void *)(a1 + 88);
    if (v2) {
      MEMORY[0x1D25D9CB0](v2, 0x1000C8077774924);
    }
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CBF2C520()
{
  return "AGX2InstructionInfoView";
}

uint64_t sub_1CBF2C530()
{
  return 1;
}

void *sub_1CBF2C538(void *a1, unsigned __int8 *a2, unint64_t a3)
{
  *a1 = 0;
  a1[1] = a2;
  a1[2] = a3;
  if (!llvm::json::isUTF8(a2, a3, 0))
  {
    llvm::json::fixUTF8((unint64_t)a2, a3, (uint64_t)&__p);
    sub_1CD451A6C();
  }
  return a1;
}

uint64_t sub_1CBF2C614(uint64_t result, uint64_t a2)
{
  if (*(void *)a2) {
    operator new();
  }
  *(_OWORD *)(result + 8) = *(_OWORD *)(a2 + 8);
  return result;
}

uint64_t sub_1CBF2C6D0(unsigned __int16 **a1, unsigned __int16 *a2)
{
  uint64_t v2 = ((char *)a1[1] - (char *)*a1) >> 5;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 59) {
    abort();
  }
  uint64_t v6 = (char *)a1[2] - (char *)*a1;
  if (v6 >> 4 > v3) {
    unint64_t v3 = v6 >> 4;
  }
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v7 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v7 = v3;
  }
  if (v7)
  {
    if (v7 >> 59) {
      sub_1CB833614();
    }
    char v8 = (char *)operator new(32 * v7);
  }
  else
  {
    char v8 = 0;
  }
  uint64_t v9 = (uint64_t)&v8[32 * v2];
  unint64_t v10 = (unsigned __int16 *)&v8[32 * v7];
  llvm::json::Value::moveFrom(v9, a2);
  uint64_t v11 = v9 + 32;
  uint64_t v13 = *a1;
  unint64_t v12 = a1[1];
  if (v12 == *a1)
  {
    *a1 = (unsigned __int16 *)v9;
    a1[1] = (unsigned __int16 *)v11;
    a1[2] = v10;
  }
  else
  {
    do
    {
      v9 -= 32;
      v12 -= 16;
      llvm::json::Value::moveFrom(v9, v12);
    }
    while (v12 != v13);
    unint64_t v12 = *a1;
    uint64_t v14 = (llvm::json::Value *)a1[1];
    *a1 = (unsigned __int16 *)v9;
    a1[1] = (unsigned __int16 *)v11;
    a1[2] = v10;
    while (v14 != (llvm::json::Value *)v12)
    {
      uint64_t v14 = (llvm::json::Value *)((char *)v14 - 32);
      llvm::json::Value::destroy(v14);
    }
  }
  if (v12) {
    operator delete(v12);
  }
  return v11;
}

void sub_1CBF2C7E0(void ***a1)
{
  v1 = *a1;
  uint64_t v2 = (llvm::json::Value *)**a1;
  if (v2)
  {
    unint64_t v4 = (llvm::json::Value *)v1[1];
    unsigned int v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unint64_t v4 = (llvm::json::Value *)((char *)v4 - 32);
        llvm::json::Value::destroy(v4);
      }
      while (v4 != v2);
      unsigned int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1CBF2C864(uint64_t result, unint64_t a2)
{
  if (*(void *)(result + 72) < a2) {
    *(void *)(result + 72) = a2;
  }
  uint64_t v2 = *(void *)(result + 48);
  unint64_t v3 = (a2 - 1) & -(uint64_t)(*(_DWORD *)(result + 32) - v2 + *(_DWORD *)(result + 40));
  if (v2 - *(void *)(result + 56) < v3)
  {
    uint64_t v5 = (a2 - 1) & -(uint64_t)(*(_DWORD *)(result + 32) - v2 + *(_DWORD *)(result + 40));
    uint64_t v6 = result;
    sub_1CBF2C904((uint64_t *)result, v3);
    unint64_t v3 = v5;
    uint64_t result = v6;
    *(void *)(v6 + 48) -= v5;
  }
  else
  {
    *(void *)(result + 48) = v2 - v3;
    if (!v3) {
      return result;
    }
  }
  uint64_t v4 = 0;
  do
    *(unsigned char *)(*(void *)(result + 48) + v4++) = 0;
  while (v3 != v4);
  return result;
}

uint64_t sub_1CBF2C904(uint64_t *a1, unint64_t a2)
{
  unint64_t v3 = a1[4];
  uint64_t v4 = a1[5];
  unint64_t v5 = v4 - a1[6] + v3;
  uint64_t v6 = a1[7] - v4;
  if (v3) {
    unint64_t v7 = v3 >> 1;
  }
  else {
    unint64_t v7 = a1[2];
  }
  if (v7 <= a2) {
    unint64_t v7 = a2;
  }
  uint64_t v8 = (v3 + a1[3] + v7 - 1) & -a1[3];
  a1[4] = v8;
  uint64_t v9 = *a1;
  if (v4)
  {
    if (!v9)
    {
      unint64_t v12 = &unk_1F25E97F8;
      operator new[]();
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t, uint64_t, void, void))(*(void *)v9 + 32))(v9, v4, v3, v8, v5, v6);
  }
  else
  {
    if (!v9)
    {
      unint64_t v12 = &unk_1F25E97F8;
      operator new[]();
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v9 + 16))(v9, v8);
  }
  uint64_t v11 = result + a1[4] - v5;
  a1[5] = result;
  a1[6] = v11;
  a1[7] = result + v6;
  return result;
}

uint64_t sub_1CBF2CB00(uint64_t a1, char a2)
{
  if (!*(void *)(a1 + 72)) {
    *(void *)(a1 + 72) = 1;
  }
  uint64_t v4 = *(void *)(a1 + 48);
  if (v4 == *(void *)(a1 + 56))
  {
    sub_1CBF2C904((uint64_t *)a1, 1uLL);
    uint64_t v4 = *(void *)(a1 + 48);
  }
  *(void *)(a1 + 48) = v4 - 1;
  *(unsigned char *)(v4 - 1) = a2;
  return (*(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 48) + *(_DWORD *)(a1 + 40));
}

uint64_t sub_1CBF2CB78(uint64_t a1, __int16 a2)
{
  if (*(void *)(a1 + 72) <= 3uLL) {
    *(void *)(a1 + 72) = 4;
  }
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 56);
  unint64_t v6 = ((_BYTE)v4 - (*(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 40))) & 3;
  if (v4 - v5 < v6)
  {
    sub_1CBF2C904((uint64_t *)a1, ((_BYTE)v4 - (*(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 40))) & 3);
    *(void *)(a1 + 48) -= v6;
  }
  else
  {
    uint64_t v7 = v4 - v6;
    *(void *)(a1 + 48) = v7;
    if (!v6) {
      goto LABEL_5;
    }
  }
  uint64_t v24 = 0;
  do
    *(unsigned char *)(*(void *)(a1 + 48) + v24++) = 0;
  while (v6 != v24);
  uint64_t v7 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 56);
LABEL_5:
  if ((unint64_t)(v7 - v5) <= 3)
  {
    sub_1CBF2C904((uint64_t *)a1, 4uLL);
    uint64_t v7 = *(void *)(a1 + 48);
    uint64_t v5 = *(void *)(a1 + 56);
  }
  *(_DWORD *)(v7 - 4) = 0;
  uint64_t v8 = v7 - 4;
  *(void *)(a1 + 48) = v8;
  uint64_t v9 = *(void *)(a1 + 32) - v8 + *(void *)(a1 + 40);
  if ((unsigned __int16)(*(_WORD *)(a1 + 68) + 2) <= 4u) {
    unint64_t v10 = 4;
  }
  else {
    unint64_t v10 = (unsigned __int16)(*(_WORD *)(a1 + 68) + 2);
  }
  *(_WORD *)(a1 + 68) = v10;
  if (v8 - v5 < v10)
  {
    sub_1CBF2C904((uint64_t *)a1, v10);
    uint64_t v8 = *(void *)(a1 + 48);
  }
  *(void *)(a1 + 48) = v8 - v10;
  bzero((void *)(v8 - v10), v10);
  unsigned __int16 v11 = v9 - a2;
  uint64_t v13 = *(unsigned __int16 **)(a1 + 48);
  unint64_t v12 = *(void *)(a1 + 56);
  v13[1] = v11;
  *uint64_t v13 = *(_WORD *)(a1 + 68);
  uint64_t v14 = *(unsigned int *)(a1 + 64);
  uint64_t v15 = (char *)(v12 - 8 * v14);
  if (v14)
  {
    unint64_t v16 = (_WORD *)(v12 - 8 * v14);
    do
    {
      *(unsigned __int16 *)((char *)v13 + (unsigned __int16)v16[2]) = v9 - *v16;
      v16 += 4;
    }
    while ((unint64_t)v16 < v12);
  }
  *(void *)(a1 + 56) = v15;
  *(_DWORD *)(a1 + 64) = 0;
  *(_WORD *)(a1 + 68) = 0;
  uint64_t v18 = *(void *)(a1 + 32);
  unint64_t v17 = *(void *)(a1 + 40);
  LODWORD(v19) = v17 - v13 + v18;
  if (*(unsigned char *)(a1 + 81) && v17 < (unint64_t)v15)
  {
    size_t v20 = *v13;
    uint64_t v21 = v17 + v18;
    int v22 = *(unsigned int **)(a1 + 40);
    while (1)
    {
      uint64_t v19 = *v22;
      if (v20 == *(unsigned __int16 *)(v21 - v19) && !memcmp((const void *)(v21 - v19), v13, v20)) {
        break;
      }
      if (++v22 >= (unsigned int *)v15)
      {
        LODWORD(v19) = v17 - v13 + v18;
        goto LABEL_23;
      }
    }
    uint64_t v13 = (unsigned __int16 *)((char *)v13 + (v17 - v13 + v18 - v9));
    *(void *)(a1 + 48) = v13;
  }
LABEL_23:
  if (v19 == v18 + v17 - v13)
  {
    if ((unint64_t)((char *)v13 - v15) <= 3)
    {
      sub_1CBF2C904((uint64_t *)a1, 4uLL);
      uint64_t v15 = *(char **)(a1 + 56);
      uint64_t v18 = *(void *)(a1 + 32);
      unint64_t v17 = *(void *)(a1 + 40);
    }
    *(_DWORD *)uint64_t v15 = v19;
    *(void *)(a1 + 56) = v15 + 4;
  }
  *(_DWORD *)(v17 + v18 - v9) = v19 - v9;
  *(unsigned char *)(a1 + 70) = 0;
  return v9;
}

void sub_1CBF2CDDC(uint64_t a1, unint64_t a2)
{
  if (*(unsigned int *)(a1 + 12) < a2)
  {
    *(_DWORD *)(a1 + 8) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unint64_t v4 = *(unsigned int *)(a1 + 8);
  if (v4 >= a2) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = *(unsigned int *)(a1 + 8);
  }
  if (v5)
  {
    memset_pattern16(*(void **)a1, &unk_1CFAA0180, 8 * v5);
    unint64_t v4 = *(unsigned int *)(a1 + 8);
  }
  if (a2 > v4) {
    memset_pattern16((void *)(*(void *)a1 + 8 * v4), &unk_1CFAA0180, 8 * (a2 - v4));
  }
  *(_DWORD *)(a1 + 8) = a2;
}

uint64_t sub_1CBF2CE7C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v14 = 0;
  uint64_t result = sub_1CD451D3C((uint64_t *)a1, a2, &v14);
  uint64_t v9 = v14;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t v9 = sub_1CD45205C(a1, a2, a2, v14);
    uint64_t v12 = *(void *)a2;
    *(void *)a2 = 0;
    uint64_t result = (uint64_t)sub_1CB833F88((uint64_t *)v9, v12);
    *(_OWORD *)(v9 + 8) = *(_OWORD *)(a2 + 8);
    uint64_t v13 = *a3;
    *(_WORD *)(v9 + 24) = 3;
    *(void *)(v9 + 32) = v13;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a1 + 56 * *(unsigned int *)(a1 + 16);
  *(void *)a4 = v9;
  *(void *)(a4 + 8) = v11;
  *(unsigned char *)(a4 + 16) = v10;
  return result;
}

void sub_1CBF2CF34(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1 + 48296;
  int v2 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 160))(a1);
  unsigned int v3 = v2 + 63;
  uint64_t v4 = (v2 + 63) >> 6;
  uint64_t v11 = v14;
  int v13 = 6;
  if ((v2 + 63) >= 0x1C0)
  {
    unsigned int v12 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unint64_t v5 = v14;
  if (v3 >= 0x40)
  {
    bzero(v14, 8 * v4);
    unint64_t v5 = v14;
  }
  unsigned int v12 = (v2 + 63) >> 6;
  int v15 = v2;
  if ((void **)v1 == &v11)
  {
    int v7 = v2;
  }
  else
  {
    uint64_t v6 = *(unsigned int *)(v1 + 8);
    if (v6 < v4)
    {
      if (*(_DWORD *)(v1 + 12) < v4)
      {
        *(_DWORD *)(v1 + 8) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v6) {
        memmove(*(void **)v1, v14, 8 * v6);
      }
      else {
        uint64_t v6 = 0;
      }
      if (v6 != v12) {
        memcpy((void *)(*(void *)v1 + 8 * v6), (char *)v11 + 8 * v6, 8 * v12 - 8 * v6);
      }
    }
    else if (v3 >= 0x40)
    {
      memmove(*(void **)v1, v14, 8 * v4);
    }
    *(_DWORD *)(v1 + 8) = v4;
    unsigned int v12 = 0;
    int v7 = v15;
    unint64_t v5 = v11;
  }
  *(_DWORD *)(v1 + 64) = v7;
  if (v5 != v14) {
    free(v5);
  }
  uint64_t v11 = v14;
  int v13 = 6;
  if (v3 >= 0x1C0)
  {
    unsigned int v12 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v8 = v14;
  if (v3 >= 0x40)
  {
    bzero(v14, 8 * v4);
    uint64_t v8 = v14;
  }
  unsigned int v12 = (v2 + 63) >> 6;
  int v15 = v2;
  uint64_t v9 = (void **)(v1 + 72);
  if ((void **)(v1 + 72) != &v11)
  {
    uint64_t v10 = *(unsigned int *)(v1 + 80);
    if (v10 < v4)
    {
      if (*(_DWORD *)(v1 + 84) < v4)
      {
        *(_DWORD *)(v1 + 80) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v10)
      {
        memmove(*v9, v14, 8 * v10);
        uint64_t v9 = (void **)(v1 + 72);
      }
      else
      {
        uint64_t v10 = 0;
      }
      if (v10 != v12) {
        memcpy((char *)*v9 + 8 * v10, (char *)v11 + 8 * v10, 8 * v12 - 8 * v10);
      }
    }
    else if (v3 >= 0x40)
    {
      memmove(*v9, v14, 8 * v4);
    }
    *(_DWORD *)(v1 + 80) = v4;
    unsigned int v12 = 0;
    int v2 = v15;
    uint64_t v8 = v11;
  }
  *(_DWORD *)(v1 + 136) = v2;
  if (v8 != v14) {
    free(v8);
  }
}

uint64_t sub_1CBF2D2EC()
{
  return 254;
}

uint64_t sub_1CBF2D2F4(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = *(void *)(result + 48440);
  unint64_t v4 = (unint64_t)a3 >> 3;
  if (v4 < *(unsigned __int16 *)(v3 + 22)
    && ((*(unsigned __int8 *)(*(void *)(v3 + 8) + v4) >> (a3 & 7)) & 1) != 0)
  {
    if (a3 - 185 <= 0x7F) {
      int v5 = 2 * a3 - 369;
    }
    else {
      int v5 = -1;
    }
    if (a3 - 313 <= 0x7F) {
      unsigned int v6 = 2 * a3 - 626;
    }
    else {
      unsigned int v6 = v5;
    }
    *(void *)(*(void *)(a2 + 88) + 8 * (v6 >> 6)) |= 1 << v6;
  }
  return result;
}

uint64_t sub_1CBF2D36C(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = *(void *)(result + 48440);
  unint64_t v4 = (unint64_t)a3 >> 3;
  if (v4 < *(unsigned __int16 *)(v3 + 22)
    && ((*(unsigned __int8 *)(*(void *)(v3 + 8) + v4) >> (a3 & 7)) & 1) != 0)
  {
    if (a3 - 185 <= 0x7F) {
      int v5 = 2 * a3 - 369;
    }
    else {
      int v5 = -1;
    }
    if (a3 - 313 <= 0x7F) {
      unsigned int v6 = 2 * a3 - 626;
    }
    else {
      unsigned int v6 = v5;
    }
    *(void *)(*(void *)(a2 + 16) + 8 * (v6 >> 6)) |= 1 << v6;
  }
  return result;
}

void sub_1CBF2D3E4(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)(*(void *)(*(void *)(a2 + 8) + 8) + 536) - 789) <= 2)
  {
    uint64_t v2 = a1 + 48296;
    uint64_t v3 = *(unsigned int *)(a1 + 48376);
    if (v3) {
      bzero(*(void **)(a1 + 48368), 8 * v3);
    }
    uint64_t v4 = *(unsigned int *)(v2 + 8);
    if (v4)
    {
      int v5 = *(void **)v2;
      bzero(v5, 8 * v4);
    }
  }
}

void sub_1CBF2D460(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)(*(void *)(*(void *)(a2 + 8) + 8) + 536) - 789) <= 2)
  {
    uint64_t v2 = a1 + 48296;
    uint64_t v3 = *(unsigned int *)(a1 + 48376);
    if (v3) {
      bzero(*(void **)(a1 + 48368), 8 * v3);
    }
    uint64_t v4 = *(unsigned int *)(v2 + 8);
    if (v4)
    {
      int v5 = *(void **)v2;
      bzero(v5, 8 * v4);
    }
  }
}

uint64_t sub_1CBF2D4DC(uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 48296);
  *(void *)a1 = &unk_1F2649290;
  uint64_t v3 = *(void **)(a1 + 48368);
  if (v3 != (void *)(a1 + 48384)) {
    free(v3);
  }
  if (*v2 != (void *)(a1 + 48312)) {
    free(*v2);
  }
  sub_1CBF2D6C8((char **)(a1 + 152));
  *(void *)(a1 + 80) = &unk_1F2646B98;
  if (*(_DWORD *)(a1 + 136) == 1)
  {
    uint64_t v5 = *(void *)(a1 + 96);
    if (v5) {
      MEMORY[0x1D25D9CB0](v5, 0x1000C8077774924);
    }
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  return a1;
}

void sub_1CBF2D5B8(uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 48296);
  *(void *)a1 = &unk_1F2649290;
  uint64_t v3 = *(void **)(a1 + 48368);
  if (v3 != (void *)(a1 + 48384)) {
    free(v3);
  }
  if (*v2 != (void *)(a1 + 48312)) {
    free(*v2);
  }
  sub_1CBF2D6C8((char **)(a1 + 152));
  *(void *)(a1 + 80) = &unk_1F2646B98;
  if (*(_DWORD *)(a1 + 136) == 1)
  {
    uint64_t v4 = *(void *)(a1 + 96);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8077774924);
    }
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CBF2D6B8()
{
  return "AGXRegisterPressureView";
}

char **sub_1CBF2D6C8(char **a1)
{
  uint64_t v2 = *a1;
  unsigned int v3 = *((_DWORD *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 0;
    uint64_t v5 = 376 * v3;
    do
    {
      unsigned int v6 = &v2[v5];
      int v7 = *(char **)&v2[v5 - 72];
      if (&v2[v5 - 56] != v7) {
        free(v7);
      }
      uint64_t v8 = (char *)*((void *)v6 - 18);
      if (v6 - 128 != v8) {
        free(v8);
      }
      uint64_t v9 = &v2[v5];
      uint64_t v10 = *(char **)&v2[v5 - 216];
      if (&v2[v5 - 200] != v10) {
        free(v10);
      }
      uint64_t v11 = (char *)*((void *)v9 - 36);
      if (v9 - 272 != v11) {
        free(v11);
      }
      unsigned int v12 = *(char **)&v2[v5 - 360];
      if (&v2[v5 - 344] != v12) {
        free(v12);
      }
      v2 -= 376;
      v4 += 376;
    }
    while (v5 != v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CBF2D7B4(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a2 == 8277) {
    return 1 << *(void *)(*(void *)(a2 + 16) + 8);
  }
  else {
    return 0;
  }
}

uint64_t sub_1CBF2D7E0(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2 = *((unsigned int *)a2 + 6);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = 0;
  uint64_t result = 0;
  uint64_t v5 = (void *)(*((void *)a2 + 2) + 8);
  do
  {
    if (word_1CDE19A64[word_1CDE15928[*a2] + (unint64_t)(unsigned __int16)v3] == 123) {
      result |= 1 << *v5;
    }
    ++v3;
    v5 += 2;
  }
  while (v2 != v3);
  return result;
}

uint64_t sub_1CBF2D84C(uint64_t result)
{
  return result;
}

uint64_t sub_1CBF2D85C(uint64_t a1)
{
  *(void *)a1 = &unk_1F2649358;
  uint64_t v4 = (void **)(a1 + 176);
  sub_1CBF2DA1C(&v4);
  uint64_t v4 = (void **)(a1 + 152);
  sub_1CBF2DA1C(&v4);
  *(void *)(a1 + 80) = &unk_1F2646B98;
  if (*(_DWORD *)(a1 + 136) == 1)
  {
    uint64_t v3 = *(void *)(a1 + 96);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8077774924);
    }
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  return a1;
}

uint64_t sub_1CBF2D920(uint64_t a1)
{
  *(void *)a1 = &unk_1F2649358;
  uint64_t v4 = (void **)(a1 + 176);
  sub_1CBF2DA1C(&v4);
  uint64_t v4 = (void **)(a1 + 152);
  sub_1CBF2DA1C(&v4);
  *(void *)(a1 + 80) = &unk_1F2646B98;
  if (*(_DWORD *)(a1 + 136) == 1)
  {
    uint64_t v3 = *(void *)(a1 + 96);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8077774924);
    }
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  return MEMORY[0x1D25D9CE0](a1, 0x10F3C40C9DB3135);
}

const char *sub_1CBF2D9F8()
{
  return "AGX2WaitView";
}

llvm::json::Value *sub_1CBF2DA08@<X0>(llvm::json::Value *a1@<X8>)
{
  return sub_1CD452690(a1, "not implemented", 0xFuLL);
}

void sub_1CBF2DA1C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      unsigned int v6 = v4 - 32;
      do
      {
        int v7 = (char *)*((void *)v6 - 2);
        if (v6 != v7) {
          free(v7);
        }
        uint64_t v8 = (void *)*((void *)v6 - 5);
        if (v8)
        {
          *((void *)v6 - 4) = v8;
          operator delete(v8);
        }
        uint64_t v9 = v6 - 48;
        v6 -= 80;
      }
      while (v9 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1CBF2DAC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6)
{
  *(void *)a1 = &unk_1F25FEEA8;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a6;
  *(void *)(a1 + 24) = 0;
  int v7 = (char **)(a1 + 24);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + ++*(_DWORD *)(result + 48) = a4;
  *(void *)(a1 + 56) = a5;
  *(void *)(a1 + 64) = a2;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(unsigned char *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 96) = &unk_1F2646F30;
  *(void *)(a1 + 160) = a1 + 72;
  *(_DWORD *)(a1 + 152) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  if (a5) {
    sub_1CBF2A8C4(v7, a5);
  }
  return a1;
}

uint64_t sub_1CBF2DB68(uint64_t result, uint64_t a2)
{
  unint64_t v2 = **(unsigned int **)(a2 + 8);
  if (*(void *)(result + 56) > v2 && *(_DWORD *)a2 == 8) {
    ++*(_DWORD *)(*(void *)(result + 24) + 4 * v2);
  }
  return result;
}

llvm::raw_ostream *sub_1CBF2DB98(uint64_t a1, uint64_t a2)
{
  int v51 = 0;
  char v55 = 0;
  uint64_t v56 = 0;
  int v57 = 1;
  uint64_t v53 = 0;
  uint64_t v54 = 0;
  uint64_t v52 = 0;
  uint64_t v50 = &unk_1F2644C68;
  uint64_t v58 = 0;
  uint64_t v59 = 0;
  char v60 = &v62;
  long long v61 = xmmword_1CDB159A0;
  sub_1CBF2ECF8((uint64_t)&v50, a2);
  if (v54 != v52)
  {
    uint64_t v54 = v52;
    llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)&v50, v52);
  }
  uint64_t v3 = *(int **)(a1 + 24);
  uint64_t v4 = *(int **)(a1 + 32);
  if (v3 == v4)
  {
    unsigned int v6 = 0;
    unsigned int v5 = 0;
  }
  else
  {
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    do
    {
      int v7 = *v3++;
      v5 += v7;
      if (v7) {
        ++v6;
      }
    }
    while (v3 != v4);
  }
  if ((unint64_t)(v53 - v54) > 1)
  {
    *(_WORD *)uint64_t v54 = 2570;
    uint64_t v8 = v54 + 2;
    v54 += 2;
  }
  else
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v50, "\n\n", 2uLL);
    uint64_t v8 = v54;
  }
  if ((unint64_t)(v53 - v8) > 0xC)
  {
    qmemcpy(v8, "Clause View:\n", 13);
    uint64_t v9 = v54 + 13;
    v54 += 13;
  }
  else
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v50, "Clause View:\n", 0xDuLL);
    uint64_t v9 = v54;
  }
  if ((unint64_t)(v53 - v9) > 0x16)
  {
    qmemcpy(v9, "Total Pipeline Stalls: ", 23);
    v54 += 23;
  }
  else
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v50, "Total Pipeline Stalls: ", 0x17uLL);
  }
  sub_1CD098D14((llvm::raw_ostream *)&v50, v6, 0, 0, 0);
  if (v53 == v54)
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v50, "\n", 1uLL);
    uint64_t v10 = v54;
  }
  else
  {
    *uint64_t v54 = 10;
    uint64_t v10 = ++v54;
  }
  if ((unint64_t)(v53 - v10) > 0x1C)
  {
    qmemcpy(v10, "Total Pipeline Stall Cycles: ", 29);
    v54 += 29;
  }
  else
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v50, "Total Pipeline Stall Cycles: ", 0x1DuLL);
  }
  sub_1CD098D14((llvm::raw_ostream *)&v50, v5, 0, 0, 0);
  if (v53 == v54)
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v50, "\n", 1uLL);
    uint64_t v11 = v54;
  }
  else
  {
    *uint64_t v54 = 10;
    uint64_t v11 = ++v54;
  }
  if ((unint64_t)(v53 - v11) > 0x25)
  {
    qmemcpy(v11, "[Clause, Chain, Cycles Stalled, Type]\n", 38);
    unsigned int v12 = v54 + 38;
    v54 += 38;
  }
  else
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v50, "[Clause, Chain, Cycles Stalled, Type]\n", 0x26uLL);
    unsigned int v12 = v54;
  }
  if (v12 != v52)
  {
    uint64_t v54 = v52;
    llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)&v50, v52);
  }
  uint64_t v13 = *(void *)(*(void *)(a1 + 16) + 72)
      + 16
      * *(unsigned int *)(*(void *)(*(void *)(a1 + 16) + 48) + 4 * (*(_DWORD *)(a1 + 56) - 1));
  unsigned int v14 = *(_DWORD *)(v13 + 12);
  std::to_string(&v49, *(_DWORD *)(v13 + 8));
  int v15 = v49.__r_.__value_.__r.__words[1];
  if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v15 = HIBYTE(v49.__r_.__value_.__r.__words[2]);
  }
  int v47 = v15;
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v49.__r_.__value_.__l.__data_);
  }
  std::to_string(&v49, v14);
  int v16 = v49.__r_.__value_.__r.__words[1];
  if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v16 = HIBYTE(v49.__r_.__value_.__r.__words[2]);
  }
  int v46 = v16;
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v49.__r_.__value_.__l.__data_);
  }
  unint64_t v17 = *(unsigned int **)(a1 + 24);
  uint64_t v18 = *(unsigned int **)(a1 + 32);
  if (v17 == v18)
  {
    unsigned int v19 = 0;
  }
  else
  {
    unsigned int v19 = 0;
    do
    {
      unsigned int v21 = *v17++;
      unsigned int v20 = v21;
      if (v21 > v19) {
        unsigned int v19 = v20;
      }
    }
    while (v17 != v18);
  }
  std::to_string(&v49, v19);
  int v22 = v49.__r_.__value_.__r.__words[1];
  if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v22 = HIBYTE(v49.__r_.__value_.__r.__words[2]);
  }
  int v45 = v22;
  if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v49.__r_.__value_.__l.__data_);
  }
  uint64_t v23 = *(void *)(a1 + 56);
  if (v23)
  {
    unsigned int v24 = 0;
    uint64_t v25 = *(void *)(a1 + 48);
    uint64_t v44 = v25 + 168 * v23;
    uint64_t v48 = a1;
    do
    {
      int v26 = (_DWORD *)(*(void *)(*(void *)(a1 + 16) + 72)
                     + 16 * *(unsigned int *)(*(void *)(*(void *)(a1 + 16) + 48) + 4 * v24));
      std::to_string(&v49, v26[2]);
      if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v27 = HIBYTE(v49.__r_.__value_.__r.__words[2]);
      }
      else {
        int v27 = v49.__r_.__value_.__r.__words[1];
      }
      if ((*((unsigned char *)&v49.__r_.__value_.__s + 23) & 0x80) != 0) {
        operator delete(v49.__r_.__value_.__l.__data_);
      }
      std::to_string(&v49, v26[3]);
      if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v28 = HIBYTE(v49.__r_.__value_.__r.__words[2]);
      }
      else {
        int v28 = v49.__r_.__value_.__r.__words[1];
      }
      if ((*((unsigned char *)&v49.__r_.__value_.__s + 23) & 0x80) != 0) {
        operator delete(v49.__r_.__value_.__l.__data_);
      }
      uint64_t v29 = v24;
      std::to_string(&v49, *(_DWORD *)(*(void *)(v48 + 24) + 4 * v24));
      if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v30 = HIBYTE(v49.__r_.__value_.__r.__words[2]);
      }
      else {
        int v30 = v49.__r_.__value_.__r.__words[1];
      }
      if ((*((unsigned char *)&v49.__r_.__value_.__s + 23) & 0x80) != 0) {
        operator delete(v49.__r_.__value_.__l.__data_);
      }
      if (v53 == v54) {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v50, "[", 1uLL);
      }
      else {
        *v54++ = 91;
      }
      for (int i = v47 - v27; i; --i)
      {
        if (v53 == v54) {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v50, " ", 1uLL);
        }
        else {
          *v54++ = 32;
        }
      }
      sub_1CD098D14((llvm::raw_ostream *)&v50, v26[2], 0, 0, 0);
      if ((unint64_t)(v53 - v54) > 1)
      {
        *(_WORD *)uint64_t v54 = 8236;
        v54 += 2;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v50, ", ", 2uLL);
      }
      int v32 = v46 - v28;
      if (v46 != v28)
      {
        do
        {
          if (v53 == v54) {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v50, " ", 1uLL);
          }
          else {
            *v54++ = 32;
          }
          --v32;
        }
        while (v32);
      }
      sub_1CD098D14((llvm::raw_ostream *)&v50, v26[3], 0, 0, 0);
      if ((unint64_t)(v53 - v54) > 1)
      {
        *(_WORD *)uint64_t v54 = 8236;
        v54 += 2;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v50, ", ", 2uLL);
      }
      int v33 = v45 - v30;
      if (v45 != v30)
      {
        do
        {
          if (v53 == v54) {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v50, " ", 1uLL);
          }
          else {
            *v54++ = 32;
          }
          --v33;
        }
        while (v33);
      }
      a1 = v48;
      sub_1CD098D14((llvm::raw_ostream *)&v50, *(unsigned int *)(*(void *)(v48 + 24) + 4 * v29), 0, 0, 0);
      if ((unint64_t)(v53 - v54) > 1)
      {
        *(_WORD *)uint64_t v54 = 8236;
        unsigned int v34 = v54 + 2;
        v54 += 2;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v50, ", ", 2uLL);
        unsigned int v34 = v54;
      }
      unint64_t v35 = v53 - v34;
      if (*v26 == 1)
      {
        if (v35 > 2)
        {
          v34[2] = 93;
          __int16 v42 = 20548;
LABEL_114:
          *(_WORD *)unsigned int v34 = v42;
          v54 += 3;
          goto LABEL_94;
        }
        int v36 = "DP]";
      }
      else
      {
        if (v35 > 2)
        {
          v34[2] = 93;
          __int16 v42 = 19780;
          goto LABEL_114;
        }
        int v36 = "DM]";
      }
      llvm::raw_ostream::write((llvm::raw_ostream *)&v50, v36, 3uLL);
LABEL_94:
      unsigned int v37 = v54;
      if ((unint64_t)(v53 - v54) > 2)
      {
        v54[2] = 32;
        *(_WORD *)unsigned int v37 = 8224;
        v54 += 3;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v50, "   ", 3uLL);
      }
      uint64_t v39 = (const void *)sub_1CBF2E410(v48, v25);
      size_t v40 = v38;
      uint64_t v41 = v54;
      if (v38 <= v53 - v54)
      {
        if (v38)
        {
          memcpy(v54, v39, v38);
          uint64_t v41 = &v54[v40];
          v54 += v40;
        }
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v50, (const char *)v39, v38);
        uint64_t v41 = v54;
      }
      if (v41 >= v53)
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v50, 10);
      }
      else
      {
        uint64_t v54 = v41 + 1;
        *uint64_t v41 = 10;
      }
      if (v54 != v52)
      {
        uint64_t v54 = v52;
        llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)&v50, v52);
      }
      unsigned int v24 = v29 + 1;
      v25 += 168;
    }
    while (v25 != v44);
  }
  return sub_1CBF2EF74((llvm::raw_ostream *)&v50);
}

uint64_t sub_1CBF2E410(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 72;
  MEMORY[0x1D25D9630](a1 + 72, "");
  (*(void (**)(void, uint64_t, void, const char *, void, void, uint64_t))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), a2, 0, "", 0, *(void *)(a1 + 64), a1 + 96);
  unsigned int v5 = *(const char **)(a1 + 112);
  if (*(const char **)(a1 + 128) != v5)
  {
    *(void *)(a1 + 128) = v5;
    llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)(a1 + 96), v5);
  }
  char v6 = *(unsigned char *)(a1 + 95);
  BOOL v7 = v6 < 0;
  unint64_t v8 = *(void *)(a1 + 80);
  if (v6 >= 0) {
    uint64_t v9 = v4;
  }
  else {
    uint64_t v9 = *(void *)(a1 + 72);
  }
  unint64_t v10 = v6 & 0x7F;
  if (v7) {
    unint64_t v11 = v8;
  }
  else {
    unint64_t v11 = v10;
  }
  v15[0] = v9;
  v15[1] = v11;
  unint64_t first_not_of = llvm::StringRef::find_first_not_of(v15, " \t\n\v\f\r", 6, 0);
  if (first_not_of >= v11) {
    unint64_t v13 = v11;
  }
  else {
    unint64_t v13 = first_not_of;
  }
  return v9 + v13;
}

void sub_1CBF2E50C(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v22[4] = *(void ***)MEMORY[0x1E4F143B8];
  unint64_t v21 = 0;
  long long v3 = 0uLL;
  long long v20 = 0u;
  unint64_t v4 = *(void *)(a1 + 56);
  if (v4)
  {
    uint64_t v6 = *(void *)(a1 + 48);
    uint64_t v7 = 168 * v4;
    while (1)
    {
      uint64_t v8 = sub_1CBF2E410(a1, v6);
      if (v8) {
        break;
      }
      __dst = 0;
      size_t v18 = 0;
      unint64_t v19 = 0;
LABEL_14:
      sub_1CD452764((uint64_t)v22, (unint64_t)&__dst);
      uint64_t v15 = *((void *)&v20 + 1);
      if (*((void *)&v20 + 1) >= v21)
      {
        uint64_t v16 = sub_1CBF2C6D0((unsigned __int16 **)&v20, (unsigned __int16 *)v22);
      }
      else
      {
        llvm::json::Value::moveFrom(*((uint64_t *)&v20 + 1), (unsigned __int16 *)v22);
        uint64_t v16 = v15 + 32;
      }
      *((void *)&v20 + 1) = v16;
      llvm::json::Value::destroy((llvm::json::Value *)v22);
      if (SHIBYTE(v19) < 0) {
        operator delete(__dst);
      }
      v6 += 168;
      v7 -= 168;
      if (!v7)
      {
        long long v3 = v20;
        unint64_t v4 = v21;
        goto LABEL_21;
      }
    }
    size_t v10 = v9;
    if (v9 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    unint64_t v11 = (const void *)v8;
    if (v9 >= 0x17)
    {
      uint64_t v13 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v9 | 7) != 0x17) {
        uint64_t v13 = v9 | 7;
      }
      uint64_t v14 = v13 + 1;
      p_dst = (void **)operator new(v13 + 1);
      size_t v18 = v10;
      unint64_t v19 = v14 | 0x8000000000000000;
      __dst = p_dst;
    }
    else
    {
      HIBYTE(v19) = v9;
      p_dst = (void **)&__dst;
      if (!v9) {
        goto LABEL_13;
      }
    }
    memmove(p_dst, v11, v10);
LABEL_13:
    *((unsigned char *)p_dst + v10) = 0;
    goto LABEL_14;
  }
LABEL_21:
  *(_WORD *)a2 = 8;
  *(_OWORD *)(a2 + 8) = v3;
  *(void *)(a2 + 24) = v4;
  unint64_t v21 = 0;
  long long v20 = 0uLL;
  v22[0] = (void **)&v20;
  sub_1CBF2C7E0(v22);
}

uint64_t sub_1CBF2E6C4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = *(void *)(a1 + 56);
  if (v3)
  {
    uint64_t v7 = 0;
    unsigned int v5 = 0;
    unint64_t v4 = 0;
    uint64_t v8 = *(void *)(a1 + 48);
    uint64_t v9 = v8 + 168 * v3;
    while (1)
    {
      uint64_t v10 = sub_1CBF2E410(a1, v8);
      if (v10) {
        break;
      }
      size_t v15 = 0;
      uint64_t v16 = 0;
      char v17 = 0;
      __dst = 0;
      size_t v62 = 0;
      unint64_t v63 = 0;
LABEL_15:
      BOOL v21 = v17 < 0;
      if (v17 >= 0) {
        p_dst = (void **)&__dst;
      }
      else {
        p_dst = v16;
      }
      size_t v23 = v17 & 0x7F;
      if (v21) {
        size_t v24 = v15;
      }
      else {
        size_t v24 = v23;
      }
      int v25 = sub_1CBF2F03C(v2, p_dst, v24);
      int v26 = v25;
      if (v4 >= v7)
      {
        uint64_t v27 = (v4 - v5) >> 2;
        unint64_t v28 = v27 + 1;
        if ((unint64_t)(v27 + 1) >> 62) {
LABEL_78:
        }
          abort();
        if ((v7 - v5) >> 1 > v28) {
          unint64_t v28 = (v7 - v5) >> 1;
        }
        if ((unint64_t)(v7 - v5) >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v29 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v29 = v28;
        }
        if (v29)
        {
          if (v29 >> 62) {
            sub_1CB833614();
          }
          int v30 = (char *)operator new(4 * v29);
        }
        else
        {
          int v30 = 0;
        }
        uint64_t v31 = &v30[4 * v27];
        *(_DWORD *)uint64_t v31 = v26;
        int v32 = v31 + 4;
        while (v4 != v5)
        {
          int v33 = *((_DWORD *)v4 - 1);
          v4 -= 4;
          *((_DWORD *)v31 - 1) = v33;
          v31 -= 4;
        }
        uint64_t v7 = &v30[4 * v29];
        if (v5) {
          operator delete(v5);
        }
        unsigned int v5 = v31;
        unint64_t v4 = v32;
        uint64_t v2 = a2;
      }
      else
      {
        *(_DWORD *)unint64_t v4 = v25;
        v4 += 4;
      }
      if (SHIBYTE(v63) < 0) {
        operator delete(__dst);
      }
      v8 += 168;
      if (v8 == v9) {
        goto LABEL_42;
      }
    }
    size_t v12 = v11;
    if (v11 >= 0x7FFFFFFFFFFFFFF8) {
      goto LABEL_78;
    }
    uint64_t v13 = (const void *)v10;
    if (v11 >= 0x17)
    {
      uint64_t v18 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v11 | 7) != 0x17) {
        uint64_t v18 = v11 | 7;
      }
      uint64_t v19 = v18 + 1;
      uint64_t v14 = (void **)operator new(v18 + 1);
      unint64_t v20 = v19 | 0x8000000000000000;
      uint64_t v2 = a2;
      size_t v62 = v12;
      unint64_t v63 = v20;
      __dst = v14;
    }
    else
    {
      HIBYTE(v63) = v11;
      uint64_t v14 = (void **)&__dst;
      if (!v11) {
        goto LABEL_14;
      }
    }
    memmove(v14, v13, v12);
LABEL_14:
    *((unsigned char *)v14 + v12) = 0;
    char v17 = HIBYTE(v63);
    uint64_t v16 = __dst;
    size_t v15 = v62;
    goto LABEL_15;
  }
  unint64_t v4 = 0;
  unsigned int v5 = 0;
LABEL_42:
  if (v4 == v5) {
    unsigned int v34 = (char *)&flatbuffers::data<flatbuffers::Offset<flatbuffers::String>,std::allocator<flatbuffers::Offset<flatbuffers::String>>>(std::vector<flatbuffers::Offset<flatbuffers::String>> const&)::t;
  }
  else {
    unsigned int v34 = v5;
  }
  int v35 = sub_1CD45296C(v2, (uint64_t)v34, (v4 - v5) >> 2);
  *(unsigned char *)(v2 + 70) = 1;
  int v36 = *(_DWORD *)(v2 + 32) - *(_DWORD *)(v2 + 48) + *(_DWORD *)(v2 + 40);
  sub_1CD4528D4((uint64_t *)v2, 4, v35);
  int v37 = sub_1CBF2CB78(v2, v36);
  *(unsigned char *)(v2 + 70) = 1;
  int v38 = *(_DWORD *)(v2 + 32) - *(_DWORD *)(v2 + 48) + *(_DWORD *)(v2 + 40);
  unsigned int v39 = sub_1CD4525F4(v2, 3);
  size_t v40 = *(uint64_t **)(v2 + 56);
  if (*(void *)(v2 + 48) - (void)v40 <= 7uLL)
  {
    sub_1CBF2C904((uint64_t *)v2, 8uLL);
    size_t v40 = *(uint64_t **)(v2 + 56);
  }
  *size_t v40 = v39 | 0x400000000;
  uint64_t v41 = *(void *)(v2 + 56) + 8;
  *(void *)(v2 + 56) = v41;
  ++*(_DWORD *)(v2 + 64);
  unsigned int v42 = *(unsigned __int16 *)(v2 + 68);
  if (v42 <= 4) {
    LOWORD(v42) = 4;
  }
  *(_WORD *)(v2 + 68) = v42;
  if (v37)
  {
    if (*(void *)(v2 + 72) <= 3uLL) {
      *(void *)(v2 + 72) = 4;
    }
    uint64_t v43 = *(void *)(v2 + 40);
    uint64_t v44 = *(void *)(v2 + 48);
    uint64_t v45 = *(void *)(v2 + 32);
    unint64_t v46 = ((int)v44 - ((int)v45 + (int)v43)) & 3;
    if (v44 - v41 < v46)
    {
      sub_1CBF2C904((uint64_t *)v2, ((int)v44 - ((int)v45 + (int)v43)) & 3);
      *(void *)(v2 + 48) -= v46;
    }
    else
    {
      uint64_t v47 = v44 - v46;
      *(void *)(v2 + ++*(_DWORD *)(result + 48) = v44 - v46;
      if (!v46)
      {
LABEL_57:
        int v49 = v43 - v47 + v45 - v37 + 4;
        if (v43 - v47 + v45 - v37 == -4 && *(unsigned char *)(v2 + 80) == 0) {
          goto LABEL_75;
        }
        if (*(void *)(v2 + 72) <= 3uLL) {
          *(void *)(v2 + 72) = 4;
        }
        unint64_t v51 = ((_BYTE)v47 - ((_BYTE)v45 + (_BYTE)v43)) & 3;
        uint64_t v52 = *(uint64_t **)(v2 + 56);
        if (v47 - (uint64_t)v52 < v51)
        {
          sub_1CBF2C904((uint64_t *)v2, v51);
          *(void *)(v2 + 48) -= v51;
        }
        else
        {
          uint64_t v53 = v47 - v51;
          *(void *)(v2 + ++*(_DWORD *)(result + 48) = v47 - v51;
          if (!v51)
          {
LABEL_68:
            if ((unint64_t)(v53 - (void)v52) <= 3)
            {
              sub_1CBF2C904((uint64_t *)v2, 4uLL);
              uint64_t v53 = *(void *)(v2 + 48);
              uint64_t v52 = *(uint64_t **)(v2 + 56);
            }
            *(_DWORD *)(v53 - 4) = v49;
            uint64_t v55 = v53 - 4;
            *(void *)(v2 + ++*(_DWORD *)(result + 48) = v55;
            uint64_t v56 = *(void *)(v2 + 32) - v55 + *(void *)(v2 + 40);
            if ((unint64_t)(v55 - (void)v52) <= 7)
            {
              sub_1CBF2C904((uint64_t *)v2, 8uLL);
              uint64_t v52 = *(uint64_t **)(v2 + 56);
            }
            *uint64_t v52 = v56 | 0xC00000000;
            *(void *)(v2 + 56) += 8;
            ++*(_DWORD *)(v2 + 64);
            unsigned int v57 = *(unsigned __int16 *)(v2 + 68);
            if (v57 <= 0xC) {
              LOWORD(v57) = 12;
            }
            *(_WORD *)(v2 + 68) = v57;
            goto LABEL_75;
          }
        }
        uint64_t v54 = 0;
        do
          *(unsigned char *)(*(void *)(v2 + 48) + v54++) = 0;
        while (v51 != v54);
        uint64_t v53 = *(void *)(v2 + 48);
        uint64_t v52 = *(uint64_t **)(v2 + 56);
        goto LABEL_68;
      }
    }
    uint64_t v48 = 0;
    do
      *(unsigned char *)(*(void *)(v2 + 48) + v48++) = 0;
    while (v46 != v48);
    uint64_t v43 = *(void *)(v2 + 40);
    uint64_t v47 = *(void *)(v2 + 48);
    uint64_t v45 = *(void *)(v2 + 32);
    goto LABEL_57;
  }
LABEL_75:
  unsigned int v58 = sub_1CBF2CB78(v2, v38);
  if (v5) {
    operator delete(v5);
  }
  return v58 | 0x100000000;
}

uint64_t sub_1CBF2EB70(uint64_t a1)
{
  *(void *)a1 = &unk_1F25FEEA8;
  *(void *)(a1 + 96) = &unk_1F2646B98;
  if (*(_DWORD *)(a1 + 152) == 1)
  {
    uint64_t v4 = *(void *)(a1 + 112);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8077774924);
    }
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1CBF2EC1C(uint64_t a1)
{
  *(void *)a1 = &unk_1F25FEEA8;
  *(void *)(a1 + 96) = &unk_1F2646B98;
  if (*(_DWORD *)(a1 + 152) == 1)
  {
    uint64_t v3 = *(void *)(a1 + 112);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8077774924);
    }
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CBF2ECE8()
{
  return "ClauseView";
}

uint64_t sub_1CBF2ECF8(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1CBF2EE60(a1);
  *(void *)(a1 + 64) = a2;
  uint64_t v5 = *(void *)(a2 + 16);
  if (*(_DWORD *)(a2 + 56)) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 88))(a2);
    uint64_t v7 = result;
  }
  else
  {
    uint64_t v7 = *(void *)(a2 + 24) - v5;
  }
  if (v7) {
    sub_1CD452824((llvm::raw_ostream *)a1);
  }
  uint64_t v9 = (uint64_t *)(a1 + 16);
  uint64_t v8 = *(const char **)(a1 + 16);
  if (*(const char **)(a1 + 32) != v8)
  {
    *(void *)(a1 + 32) = v8;
    uint64_t result = llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)a1, v8);
  }
  if (*(_DWORD *)(a1 + 56) == 1)
  {
    uint64_t result = *v9;
    if (*v9) {
      uint64_t result = MEMORY[0x1D25D9CB0](result, 0x1000C8077774924);
    }
  }
  *(_DWORD *)(a1 + 56) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *uint64_t v9 = 0;
  uint64_t v10 = *(void *)(a1 + 64);
  size_t v12 = (uint64_t *)(v10 + 16);
  unint64_t v11 = *(const char **)(v10 + 16);
  if (*(const char **)(v10 + 32) != v11)
  {
    *(void *)(v10 + 32) = v11;
    size_t v15 = (uint64_t *)(v10 + 16);
    uint64_t v13 = v10;
    uint64_t result = llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)v10, v11);
    uint64_t v10 = v13;
    size_t v12 = v15;
  }
  if (*(_DWORD *)(v10 + 56) == 1)
  {
    uint64_t result = *v12;
    if (*v12)
    {
      uint64_t v14 = v10;
      uint64_t result = MEMORY[0x1D25D9CB0](result, 0x1000C8077774924);
      uint64_t v10 = v14;
    }
  }
  *(_DWORD *)(v10 + 56) = 0;
  v12[1] = 0;
  v12[2] = 0;
  *size_t v12 = 0;
  *(void *)(a1 + 80) = 0;
  return result;
}

uint64_t sub_1CBF2EE60(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 64);
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (*(_DWORD *)(a1 + 56)) {
      BOOL v4 = v3 == 0;
    }
    else {
      BOOL v4 = 0;
    }
    if (v4)
    {
      uint64_t v8 = a1;
      uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
      uint64_t result = *(void *)(v8 + 64);
    }
    else
    {
      uint64_t v5 = *(void *)(a1 + 24) - v3;
    }
    if (v5)
    {
      sub_1CD452824((llvm::raw_ostream *)result);
    }
    uint64_t v7 = (void *)(result + 16);
    BOOL v6 = *(const char **)(result + 16);
    if (*(const char **)(result + 32) != v6)
    {
      *(void *)(result + 32) = v6;
      uint64_t v10 = (void *)(result + 16);
      uint64_t v12 = result;
      llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)result, v6);
      uint64_t v7 = v10;
      uint64_t result = v12;
    }
    if (*(_DWORD *)(result + 56) == 1)
    {
      if (*v7)
      {
        uint64_t v9 = v7;
        uint64_t v11 = result;
        MEMORY[0x1D25D9CB0](*v7, 0x1000C8077774924);
        uint64_t v7 = v9;
        uint64_t result = v11;
      }
    }
    *(_DWORD *)(result + 56) = 0;
    v7[1] = 0;
    v7[2] = 0;
    *uint64_t v7 = 0;
  }
  return result;
}

llvm::raw_ostream *sub_1CBF2EF74(llvm::raw_ostream *this)
{
  *(void *)this = &unk_1F2644C68;
  uint64_t v2 = (const char *)*((void *)this + 2);
  if (*((const char **)this + 4) != v2)
  {
    *((void *)this + 4) = v2;
    llvm::raw_ostream::flush_tied_then_write(this, v2);
  }
  sub_1CBF2EE60((uint64_t)this);
  uint64_t v3 = (char *)*((void *)this + 11);
  if (v3 != (char *)this + 112) {
    free(v3);
  }
  *(void *)this = &unk_1F2646B98;
  if (*((_DWORD *)this + 14) == 1)
  {
    uint64_t v5 = *((void *)this + 2);
    if (v5) {
      MEMORY[0x1D25D9CB0](v5, 0x1000C8077774924);
    }
  }
  return this;
}

uint64_t sub_1CBF2F03C(uint64_t a1, void *__src, size_t __n)
{
  if (*(void *)(a1 + 72) <= 3uLL) {
    *(void *)(a1 + 72) = 4;
  }
  uint64_t v7 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 56);
  unint64_t v8 = (~(_BYTE)__n + (_BYTE)v7 - (*(unsigned char *)(a1 + 32) + *(_DWORD *)(a1 + 40))) & 3;
  if (v7 - v6 < v8)
  {
    sub_1CBF2C904((uint64_t *)a1, v8);
    *(void *)(a1 + 48) -= v8;
  }
  else
  {
    uint64_t v9 = v7 - v8;
    *(void *)(a1 + ++*(_DWORD *)(result + 48) = v7 - v8;
    if (!v8) {
      goto LABEL_5;
    }
  }
  uint64_t v17 = 0;
  do
    *(unsigned char *)(*(void *)(a1 + 48) + v17++) = 0;
  while (v8 != v17);
  uint64_t v9 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 56);
LABEL_5:
  if (v9 == v6)
  {
    sub_1CBF2C904((uint64_t *)a1, 1uLL);
    uint64_t v9 = *(void *)(a1 + 48);
  }
  *(void *)(a1 + ++*(_DWORD *)(result + 48) = v9 - 1;
  *(unsigned char *)(v9 - 1) = 0;
  if (__n)
  {
    uint64_t v10 = *(void *)(a1 + 48);
    if (v10 - *(void *)(a1 + 56) < __n)
    {
      sub_1CBF2C904((uint64_t *)a1, __n);
      uint64_t v10 = *(void *)(a1 + 48);
    }
    *(void *)(a1 + ++*(_DWORD *)(result + 48) = v10 - __n;
    memcpy((void *)(v10 - __n), __src, __n);
  }
  if (*(void *)(a1 + 72) <= 3uLL) {
    *(void *)(a1 + 72) = 4;
  }
  uint64_t v11 = *(void *)(a1 + 48);
  uint64_t v12 = *(void *)(a1 + 56);
  unint64_t v13 = ((_BYTE)v11 - (*(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 40))) & 3;
  if (v11 - v12 < v13)
  {
    sub_1CBF2C904((uint64_t *)a1, ((_BYTE)v11 - (*(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 40))) & 3);
    *(void *)(a1 + 48) -= v13;
  }
  else
  {
    uint64_t v14 = v11 - v13;
    *(void *)(a1 + ++*(_DWORD *)(result + 48) = v14;
    if (!v13) {
      goto LABEL_15;
    }
  }
  uint64_t v18 = 0;
  do
    *(unsigned char *)(*(void *)(a1 + 48) + v18++) = 0;
  while (v13 != v18);
  uint64_t v14 = *(void *)(a1 + 48);
  uint64_t v12 = *(void *)(a1 + 56);
LABEL_15:
  if ((unint64_t)(v14 - v12) <= 3)
  {
    sub_1CBF2C904((uint64_t *)a1, 4uLL);
    uint64_t v14 = *(void *)(a1 + 48);
  }
  *(_DWORD *)(v14 - 4) = __n;
  uint64_t v15 = v14 - 4;
  *(void *)(a1 + ++*(_DWORD *)(result + 48) = v15;
  return (*(_DWORD *)(a1 + 32) - v15 + *(_DWORD *)(a1 + 40));
}

uint64_t sub_1CBF2F210(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 72) <= 3uLL) {
    *(void *)(a1 + 72) = 4;
  }
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 56);
  unint64_t v6 = ((_BYTE)v4 - (*(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 40))) & 3;
  if (v4 - v5 < v6)
  {
    unint64_t v11 = ((_BYTE)v4 - (*(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 40))) & 3;
    sub_1CBF2C904((uint64_t *)a1, v6);
    unint64_t v6 = v11;
    *(void *)(a1 + 48) -= v11;
  }
  else
  {
    uint64_t v7 = v4 - v6;
    *(void *)(a1 + ++*(_DWORD *)(result + 48) = v7;
    if (!v6) {
      goto LABEL_5;
    }
  }
  uint64_t v10 = 0;
  do
    *(unsigned char *)(*(void *)(a1 + 48) + v10++) = 0;
  while (v6 != v10);
  uint64_t v7 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 56);
LABEL_5:
  if ((unint64_t)(v7 - v5) <= 3)
  {
    sub_1CBF2C904((uint64_t *)a1, 4uLL);
    uint64_t v7 = *(void *)(a1 + 48);
  }
  *(_DWORD *)(v7 - 4) = a2;
  uint64_t v8 = v7 - 4;
  *(void *)(a1 + ++*(_DWORD *)(result + 48) = v8;
  return (*(_DWORD *)(a1 + 32) - v8 + *(_DWORD *)(a1 + 40));
}

uint64_t sub_1CBF2F2FC(uint64_t result, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = result;
  if (*(void *)(result + 72) < a3) {
    *(void *)(result + 72) = a3;
  }
  uint64_t v4 = *(void *)(result + 48);
  unint64_t v5 = (a3 - 1) & (-a2 - (*(_DWORD *)(result + 32) - v4 + *(_DWORD *)(result + 40)));
  if (v4 - *(void *)(result + 56) < v5)
  {
    uint64_t result = sub_1CBF2C904((uint64_t *)result, (a3 - 1) & (-a2 - (*(_DWORD *)(result + 32) - v4 + *(_DWORD *)(result + 40))));
    *(void *)(v3 + 48) -= v5;
  }
  else
  {
    *(void *)(result + ++*(_DWORD *)(result + 48) = v4 - v5;
    if (!v5) {
      return result;
    }
  }
  uint64_t v6 = 0;
  do
    *(unsigned char *)(*(void *)(v3 + 48) + v6++) = 0;
  while (v5 != v6);
  return result;
}

uint64_t *sub_1CBF2F3A0(uint64_t *result, uint64_t a2, unsigned int a3)
{
  unint64_t v5 = result;
  uint64_t v6 = (unint64_t *)result[7];
  if ((unint64_t)(result[6] - (void)v6) <= 7)
  {
    uint64_t result = (uint64_t *)sub_1CBF2C904(result, 8uLL);
    uint64_t v6 = (unint64_t *)v5[7];
  }
  *uint64_t v6 = a3 | (unint64_t)(a2 << 32);
  v5[7] += 8;
  ++*((_DWORD *)v5 + 16);
  unsigned int v7 = *((unsigned __int16 *)v5 + 34);
  if (v7 <= a2) {
    LOWORD(v7) = a2;
  }
  *((_WORD *)v5 + 34) = v7;
  return result;
}

void sub_1CBF2F428(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a3 + 24);
  if ((int)v3 >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v21 = a2;
    while (1)
    {
      uint64_t v6 = *(void *)(a3 + 16);
      int v7 = *(unsigned __int8 *)(v6 + 16 * v5);
      if (v7 == 2) {
        break;
      }
      if (v7 == 1)
      {
        uint64_t v8 = *(unsigned int *)(v6 + 16 * v5 + 8);
LABEL_7:
        uint64_t v9 = *(void **)a2;
        uint64_t v10 = *(unsigned char **)(*(void *)a2 + 520);
        unint64_t v11 = *(void *)(*(void *)a2 + 528);
        if ((unint64_t)v10 >= v11)
        {
          unint64_t v13 = (unsigned char *)v9[64];
          unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((v10 - v13) >> 3) + 1;
          if (v14 > 0xAAAAAAAAAAAAAAALL) {
            abort();
          }
          unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - (void)v13) >> 3);
          if (2 * v15 > v14) {
            unint64_t v14 = 2 * v15;
          }
          if (v15 >= 0x555555555555555) {
            unint64_t v16 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v16 = v14;
          }
          if (v16)
          {
            if (v16 > 0xAAAAAAAAAAAAAAALL) {
              sub_1CB833614();
            }
            uint64_t v17 = (char *)operator new(24 * v16);
          }
          else
          {
            uint64_t v17 = 0;
          }
          uint64_t v18 = &v17[8 * ((v10 - v13) >> 3)];
          *uint64_t v18 = v7;
          *((void *)v18 + 1) = v8;
          *((_DWORD *)v18 + 4) = v5;
          uint64_t v19 = v18;
          if (v10 != v13)
          {
            do
            {
              long long v20 = *(_OWORD *)(v10 - 24);
              *((_DWORD *)v19 - 2) = *((_DWORD *)v10 - 2);
              *(_OWORD *)(v19 - 24) = v20;
              v19 -= 24;
              v10 -= 24;
            }
            while (v10 != v13);
            uint64_t v10 = (unsigned char *)v9[64];
          }
          v9[64] = v19;
          uint64_t v12 = v18 + 24;
          v9[65] = v18 + 24;
          v9[66] = &v17[24 * v16];
          if (v10) {
            operator delete(v10);
          }
          a2 = v21;
        }
        else
        {
          *uint64_t v10 = v7;
          *((void *)v10 + 1) = v8;
          uint64_t v12 = v10 + 24;
          *((_DWORD *)v10 + 4) = v5;
        }
        v9[65] = v12;
      }
      if (++v5 == v3) {
        return;
      }
    }
    uint64_t v8 = *(void *)(v6 + 16 * v5 + 8);
    goto LABEL_7;
  }
}

unsigned char *sub_1CBF2F5E8(unsigned char *result)
{
  result[40] = byte_1EA61F350;
  result[41] = byte_1EA61F351;
  result[42] = byte_1EA61F352;
  result[43] = byte_1EA61F353;
  return result;
}

unsigned char *sub_1CBF2F62C(unsigned char *result, int a2, char a3)
{
  if (a2 == 3)
  {
    result[43] = a3;
  }
  else if (a2 == 2)
  {
    result[42] = a3;
  }
  else
  {
    result[40] = a3;
  }
  return result;
}

void sub_1CBF2F654(unsigned char *a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  if (a1[43]) {
    operator new();
  }
  if (a1[40]) {
    operator new();
  }
  sub_1CD271F94(a1[41], &v4);
  sub_1CBF2AB14((char **)a2, *(void *)(a2 + 8), v4, (uint64_t *)v5, (uint64_t)(v5 - (void)v4) >> 3);
  uint64_t v3 = (void **)&v4;
  sub_1CBF2A9F0(&v3);
}

void LLVMInitializeAGX3TargetMCA()
{
  qword_1EA61E9A0 = (uint64_t)sub_1CBF2F9C0;
  qword_1EA61E9A8 = (uint64_t)sub_1CBF2FA34;
}

void sub_1CBF2F9C0()
{
}

void sub_1CBF2FA34()
{
}

void sub_1CBF2FA94()
{
}

void sub_1CBF2FAAC()
{
}

void *sub_1CBF2FAC4()
{
  qword_1EBCC29B8 = (uint64_t)"AGX3 Custom View Options";
  unk_1EBCC29C0 = 24;
  qword_1EBCC29C8 = (uint64_t)"";
  unk_1EBCC29D0 = 0;
  return llvm::cl::OptionCategory::registerCategory((llvm::cl::OptionCategory *)&qword_1EBCC29B8);
}

uint64_t sub_1CBF2FAEC(uint64_t result, int a2)
{
  switch(a2)
  {
    case 0:
      *(unsigned char *)(result + 23) = 7;
      *(_DWORD *)uint64_t result = 1852534357;
      int v2 = 1853321070;
      goto LABEL_24;
    case 1:
      *(unsigned char *)(result + 23) = 4;
      int v3 = 1752457549;
      goto LABEL_19;
    case 2:
      *(unsigned char *)(result + 23) = 10;
      *(_WORD *)(result + 8) = 28271;
      uint64_t v4 = "Comparison";
      goto LABEL_32;
    case 3:
      *(unsigned char *)(result + 23) = 6;
      *(_DWORD *)uint64_t result = 1701602643;
      __int16 v5 = 29795;
      goto LABEL_14;
    case 4:
      uint64_t v6 = "BitManipulation";
      goto LABEL_16;
    case 5:
      *(unsigned char *)(result + 23) = 10;
      *(_WORD *)(result + 8) = 28271;
      uint64_t v4 = "Conversion";
      goto LABEL_32;
    case 6:
      *(unsigned char *)(result + 23) = 7;
      *(_DWORD *)uint64_t result = 1836213584;
      int v2 = 1702131053;
      goto LABEL_24;
    case 7:
      *(unsigned char *)(result + 23) = 6;
      *(_DWORD *)uint64_t result = 1969513810;
      __int16 v5 = 25955;
      goto LABEL_14;
    case 8:
      *(unsigned char *)(result + 23) = 7;
      *(_DWORD *)uint64_t result = 1953394499;
      int v2 = 1819243124;
      goto LABEL_24;
    case 9:
      *(unsigned char *)(result + 23) = 11;
      *(_DWORD *)(result + 7) = 1852795252;
      int v7 = "Predication";
      goto LABEL_29;
    case 10:
      *(unsigned char *)(result + 23) = 6;
      *(_DWORD *)uint64_t result = 1886216531;
      __int16 v5 = 25964;
LABEL_14:
      *(_WORD *)(result + 4) = v5;
      *(unsigned char *)(result + 6) = 0;
      return result;
    case 11:
      uint64_t v6 = "Synchronization";
LABEL_16:
      *(unsigned char *)(result + 23) = 15;
      *(void *)uint64_t result = *(void *)v6;
      *(void *)(result + 7) = *(void *)(v6 + 7);
      *(unsigned char *)(result + 15) = 0;
      return result;
    case 12:
      *(unsigned char *)(result + 23) = 9;
      *(_WORD *)(result + 8) = 101;
      uint64_t v8 = "LoadStore";
      goto LABEL_22;
    case 13:
      *(unsigned char *)(result + 23) = 4;
      int v3 = 1684107084;
LABEL_19:
      *(_DWORD *)uint64_t result = v3;
      *(unsigned char *)(result + 4) = 0;
      return result;
    case 14:
      *(unsigned char *)(result + 23) = 5;
      strcpy((char *)result, "Store");
      return result;
    case 15:
      *(unsigned char *)(result + 23) = 9;
      *(_WORD *)(result + 8) = 87;
      uint64_t v8 = "AtomicRMW";
LABEL_22:
      *(void *)uint64_t result = *(void *)v8;
      return result;
    case 16:
      *(unsigned char *)(result + 23) = 7;
      *(_DWORD *)uint64_t result = 1920098626;
      int v2 = 1919248754;
LABEL_24:
      *(_DWORD *)(result + 3) = v2;
      *(unsigned char *)(result + 7) = 0;
      return result;
    case 17:
      *(unsigned char *)(result + 23) = 16;
      uint64_t v9 = "FragmentFeedback";
      goto LABEL_27;
    case 18:
      *(unsigned char *)(result + 23) = 16;
      uint64_t v9 = "VertexProcessing";
LABEL_27:
      *(_OWORD *)uint64_t result = *(_OWORD *)v9;
      *(unsigned char *)(result + 16) = 0;
      return result;
    case 19:
      *(unsigned char *)(result + 23) = 11;
      *(_DWORD *)(result + 7) = 1936942435;
      int v7 = "ImageAccess";
LABEL_29:
      *(void *)uint64_t result = *(void *)v7;
      *(unsigned char *)(result + 11) = 0;
      return result;
    case 20:
      *(unsigned char *)(result + 23) = 12;
      *(_DWORD *)(result + 8) = 1953391981;
      uint64_t v10 = "DataMovement";
      goto LABEL_34;
    case 21:
      *(unsigned char *)(result + 23) = 10;
      *(_WORD *)(result + 8) = 26478;
      uint64_t v4 = "RayTracing";
LABEL_32:
      *(void *)uint64_t result = *(void *)v4;
      *(unsigned char *)(result + 10) = 0;
      return result;
    case 22:
      *(unsigned char *)(result + 23) = 12;
      *(_DWORD *)(result + 8) = 1684107084;
      uint64_t v10 = "ImgBlockLoad";
LABEL_34:
      *(void *)uint64_t result = *(void *)v10;
      *(unsigned char *)(result + 12) = 0;
      break;
    case 23:
      *(unsigned char *)(result + 23) = 13;
      strcpy((char *)result, "ImgBlockWrite");
      break;
    case 24:
      *(unsigned char *)(result + 23) = 8;
      strcpy((char *)result, "ImgWrite");
      break;
    default:
      *(unsigned char *)(result + 23) = 1;
      *(_WORD *)uint64_t result = 33;
      break;
  }
  return result;
}

uint64_t sub_1CBF2FEB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  *(void *)a1 = &unk_1F25FEFC8;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = &unk_1F25FDA68;
  *(void *)(a1 + 32) = a4;
  *(void *)(a1 + 40) = a5;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + ++*(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(unsigned char *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 72) = &unk_1F2646F30;
  *(void *)(a1 + 136) = a1 + 48;
  *(_DWORD *)(a1 + 128) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 88) = 0;
  int v7 = 257;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  *(void *)(a1 + 144) = a1 + 160;
  *(void *)(a1 + 152) = 0x1000000000;
  sub_1CBF33718(a1 + 144, a5, (long long *)&v7);
  return a1;
}

uint64_t sub_1CBF2FF98(uint64_t result, int a2)
{
  switch(a2)
  {
    case 0:
      *(unsigned char *)(result + 23) = 7;
      *(_DWORD *)uint64_t result = 1852534357;
      int v2 = 1853321070;
      goto LABEL_4;
    case 1:
      *(unsigned char *)(result + 23) = 4;
      int v3 = 1701736270;
      goto LABEL_25;
    case 2:
      *(unsigned char *)(result + 23) = 4;
      int v3 = 1313163073;
      goto LABEL_25;
    case 3:
      *(unsigned char *)(result + 23) = 3;
      unsigned __int16 v4 = 17987;
      goto LABEL_17;
    case 4:
      *(unsigned char *)(result + 23) = 8;
      uint64_t v5 = 0x4E45474126554643;
      goto LABEL_22;
    case 5:
      *(unsigned char *)(result + 23) = 3;
      int v6 = 3551558;
      goto LABEL_18;
    case 6:
      *(unsigned char *)(result + 23) = 3;
      int v6 = 3289926;
      goto LABEL_18;
    case 7:
      *(unsigned char *)(result + 23) = 2;
      strcpy((char *)result, "IC");
      return result;
    case 8:
      *(unsigned char *)(result + 23) = 6;
      *(_DWORD *)uint64_t result = 1127891785;
      __int16 v7 = 22605;
      goto LABEL_15;
    case 9:
      *(unsigned char *)(result + 23) = 6;
      *(_DWORD *)uint64_t result = 1127891785;
      __int16 v7 = 21590;
      goto LABEL_15;
    case 10:
      *(unsigned char *)(result + 23) = 6;
      *(_DWORD *)uint64_t result = 1228555081;
      __int16 v7 = 21325;
LABEL_15:
      *(_WORD *)(result + 4) = v7;
      *(unsigned char *)(result + 6) = 0;
      return result;
    case 11:
      *(unsigned char *)(result + 23) = 3;
      unsigned __int16 v4 = 22605;
LABEL_17:
      int v6 = v4 | 0x550000;
LABEL_18:
      *(_DWORD *)uint64_t result = v6;
      return result;
    case 12:
      *(unsigned char *)(result + 23) = 4;
      int v3 = 1297237328;
      goto LABEL_25;
    case 13:
      *(unsigned char *)(result + 23) = 8;
      uint64_t v5 = 0x363146264D524550;
      goto LABEL_22;
    case 14:
      *(unsigned char *)(result + 23) = 8;
      uint64_t v5 = 0x323346264D524550;
LABEL_22:
      *(void *)uint64_t result = v5;
      *(unsigned char *)(result + 8) = 0;
      break;
    case 15:
      *(unsigned char *)(result + 23) = 9;
      strcpy((char *)result, "PERM&SCIB");
      break;
    case 16:
      *(unsigned char *)(result + 23) = 4;
      int v3 = 1112097619;
LABEL_25:
      *(_DWORD *)uint64_t result = v3;
      *(unsigned char *)(result + 4) = 0;
      break;
    default:
      *(unsigned char *)(result + 23) = 7;
      *(_DWORD *)uint64_t result = 1635151433;
      int v2 = 1684630625;
LABEL_4:
      *(_DWORD *)(result + 3) = v2;
      *(unsigned char *)(result + 7) = 0;
      break;
  }
  return result;
}

void *sub_1CBF301EC(void *result, uint64_t a2)
{
  if (*(_DWORD *)a2 == 4)
  {
    unint64_t v2 = (unint64_t)**(unsigned int **)(a2 + 8) % result[5];
    uint64_t v3 = result[18];
    uint64_t v4 = *(void *)(a2 + 24);
    if (v4)
    {
      uint64_t v5 = *(_DWORD **)(a2 + 16);
      uint64_t v6 = v3 + 28 * v2;
      int v9 = *(_DWORD *)(v6 + 8);
      __int16 v7 = (int *)(v6 + 8);
      int v8 = v9;
      uint64_t v10 = *(void *)(result[1] + 192);
      uint64_t v11 = 24 * v4;
      while (2)
      {
        int v12 = 2;
        char v13 = 1;
        int v14 = 0;
        char v15 = 0;
        if ((v10 & 0x2000000000000) == 0)
        {
          if ((v10 & 0x800000000000) == 0)
          {
            switch(*v5)
            {
              case 2:
                goto LABEL_9;
              case 3:
                goto LABEL_10;
              case 4:
                goto LABEL_11;
              case 5:
                goto LABEL_12;
              case 6:
                goto LABEL_13;
              case 7:
                goto LABEL_14;
              case 8:
                goto LABEL_15;
              case 9:
                goto LABEL_16;
              case 0xA:
                goto LABEL_17;
              case 0xB:
                goto LABEL_18;
              case 0xC:
                goto LABEL_19;
              default:
                goto LABEL_21;
            }
          }
          switch(*v5)
          {
            case 2:
              goto LABEL_9;
            case 3:
              goto LABEL_10;
            case 4:
              goto LABEL_11;
            case 5:
              goto LABEL_12;
            case 6:
              goto LABEL_13;
            case 7:
              goto LABEL_14;
            case 8:
              goto LABEL_15;
            case 9:
              goto LABEL_16;
            case 0xA:
              goto LABEL_20;
            case 0xB:
              goto LABEL_17;
            case 0xC:
              goto LABEL_18;
            case 0xD:
              goto LABEL_19;
            default:
              goto LABEL_21;
          }
        }
        switch(*v5)
        {
          case 2:
LABEL_9:
            int v14 = 0;
            char v13 = 0;
            int v12 = 3;
            char v15 = 1;
            break;
          case 3:
LABEL_10:
            int v14 = 0;
            char v13 = 0;
            char v15 = 0;
            int v12 = 5;
            break;
          case 4:
LABEL_11:
            int v14 = 0;
            char v13 = 0;
            char v15 = 0;
            int v12 = 6;
            break;
          case 5:
LABEL_12:
            int v14 = 0;
            char v13 = 0;
            char v15 = 0;
            int v12 = 7;
            break;
          case 6:
LABEL_13:
            int v14 = 0;
            char v13 = 0;
            char v15 = 0;
            int v12 = 8;
            break;
          case 7:
LABEL_14:
            int v14 = 0;
            char v13 = 0;
            char v15 = 0;
            int v12 = 9;
            break;
          case 8:
LABEL_15:
            int v14 = 0;
            char v13 = 0;
            char v15 = 0;
            int v12 = 10;
            break;
          case 9:
LABEL_16:
            int v14 = 0;
            char v13 = 0;
            char v15 = 0;
            int v12 = 0;
            break;
          case 0xA:
LABEL_20:
            int v14 = 0;
            char v13 = 0;
            char v15 = 0;
            int v12 = 11;
            break;
          case 0xB:
LABEL_17:
            int v14 = 0;
            char v13 = 0;
            char v15 = 0;
            int v12 = 1;
            break;
          case 0xC:
LABEL_18:
            char v13 = 0;
            char v15 = 0;
            int v12 = 12;
            int v14 = 1;
            break;
          case 0xD:
LABEL_19:
            int v14 = 0;
            char v13 = 0;
            char v15 = 0;
            int v12 = 16;
            break;
          default:
            break;
        }
LABEL_21:
        switch(v8)
        {
          case 0:
            goto LABEL_38;
          case 2:
            if (v15) {
              goto LABEL_33;
            }
            int v8 = 2;
            goto LABEL_39;
          case 3:
            if (v13)
            {
LABEL_33:
              int v12 = 4;
              goto LABEL_38;
            }
            int v8 = 3;
            goto LABEL_39;
          case 5:
            if (v14) {
              goto LABEL_35;
            }
            int v8 = 5;
            goto LABEL_39;
          case 6:
            if (v14) {
              goto LABEL_37;
            }
            int v8 = 6;
            goto LABEL_39;
          case 7:
            if ((v12 - 8) < 3) {
              goto LABEL_38;
            }
            int v8 = 7;
            goto LABEL_39;
          case 12:
            switch(v12)
            {
              case 5:
LABEL_35:
                int v12 = 13;
                break;
              case 16:
LABEL_31:
                int v12 = 15;
                break;
              case 6:
LABEL_37:
                int v12 = 14;
                break;
              default:
                int v8 = 12;
                goto LABEL_39;
            }
LABEL_38:
            *__int16 v7 = v12;
            int v8 = v12;
LABEL_39:
            v5 += 6;
            v11 -= 24;
            if (!v11) {
              break;
            }
            continue;
          case 16:
            if (v14) {
              goto LABEL_31;
            }
            int v8 = 16;
            goto LABEL_39;
          default:
            goto LABEL_39;
        }
        break;
      }
    }
    int v16 = *(_DWORD *)(result[4] + 168 * v2);
    uint64_t v17 = (_DWORD *)(v3 + 28 * v2);
    v17[3] = sub_1CBF305BC(v16);
    v17[4] = sub_1CBF305E4(v16);
    v17[5] = sub_1CBF3060C(v16);
    uint64_t result = (void *)sub_1CBF30634(v16);
    v17[6] = result;
  }
  return result;
}

uint64_t sub_1CBF305BC(int a1)
{
  if ((a1 - 359) > 0x22DC) {
    return 0;
  }
  else {
    return dword_1CFAA0194[a1 - 359];
  }
}

uint64_t sub_1CBF305E4(int a1)
{
  if ((a1 - 359) > 0x22DC) {
    return 0;
  }
  else {
    return dword_1CFAA8D08[a1 - 359];
  }
}

uint64_t sub_1CBF3060C(int a1)
{
  if ((a1 - 359) > 0x22DC) {
    return 0;
  }
  else {
    return dword_1CFAB187C[a1 - 359];
  }
}

uint64_t sub_1CBF30634(int a1)
{
  if ((a1 - 359) > 0x22DC) {
    return 0;
  }
  else {
    return dword_1CFABA3F0[a1 - 359];
  }
}

void sub_1CBF3065C(uint64_t a1, llvm::raw_ostream *a2)
{
  uint64_t v100 = 0;
  size_t v101 = 0;
  uint64_t v102 = 0;
  int v92 = 0;
  char v96 = 0;
  uint64_t v97 = 0;
  unint64_t v99 = (void **)&v100;
  int v98 = 0;
  unint64_t v91 = &unk_1F2646F30;
  int v93 = 0;
  uint64_t v94 = 0;
  int v95 = 0;
  if (*(void *)(a1 + 40))
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v91, "\n\nAGX3 Instruction Info:\n", 0x19uLL);
    uint64_t v5 = v95;
    if (byte_1EBCC2A58)
    {
      if ((unint64_t)(v94 - v95) > 0xB)
      {
        *((_DWORD *)v95 + 2) = 174417007;
        *(void *)uint64_t v5 = *(void *)"[0]: Opcode\n";
        uint64_t v5 = v95 + 12;
        v95 += 12;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v91, "[0]: Opcode\n", 0xCuLL);
        uint64_t v5 = v95;
      }
    }
    if ((unint64_t)(v94 - v5) > 0x11)
    {
      *((_WORD *)v5 + 8) = 2661;
      *(_OWORD *)uint64_t v5 = *(_OWORD *)"[1]: >=Quad Scope\n";
      uint64_t v6 = v95 + 18;
      v95 += 18;
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, "[1]: >=Quad Scope\n", 0x12uLL);
      uint64_t v6 = v95;
    }
    if ((unint64_t)(v94 - v6) > 0x11)
    {
      *((_WORD *)v6 + 8) = 2661;
      *(_OWORD *)uint64_t v6 = *(_OWORD *)"[2]: >=SIMD Scope\n";
      __int16 v7 = v95 + 18;
      v95 += 18;
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, "[2]: >=SIMD Scope\n", 0x12uLL);
      __int16 v7 = v95;
    }
    if ((unint64_t)(v94 - v7) > 0xF)
    {
      *(_OWORD *)__int16 v7 = *(_OWORD *)"[3]: Instr Rate\n";
      int v8 = v95 + 16;
      v95 += 16;
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, "[3]: Instr Rate\n", 0x10uLL);
      int v8 = v95;
    }
    if ((unint64_t)(v94 - v8) > 0x10)
    {
      v8[16] = 10;
      *(_OWORD *)int v8 = *(_OWORD *)"[4]: ALU Subpipe\n";
      int v9 = v95 + 17;
      v95 += 17;
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, "[4]: ALU Subpipe\n", 0x11uLL);
      int v9 = v95;
    }
    if ((unint64_t)(v94 - v9) > 0xA)
    {
      *(_DWORD *)(v9 + 7) = 174420079;
      *(void *)int v9 = *(void *)"[5]: Scope\n";
      uint64_t v10 = v95 + 11;
      v95 += 11;
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, "[5]: Scope\n", 0xBuLL);
      uint64_t v10 = v95;
    }
    if ((unint64_t)(v94 - v10) > 0x10)
    {
      v10[16] = 10;
      *(_OWORD *)uint64_t v10 = *(_OWORD *)"[6]: Memory Type\n";
      uint64_t v11 = v95 + 17;
      v95 += 17;
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, "[6]: Memory Type\n", 0x11uLL);
      uint64_t v11 = v95;
    }
    if ((unint64_t)(v94 - v11) > 0xE)
    {
      qmemcpy(v11, "[7]: Data Type\n", 15);
      int v12 = v95 + 15;
      v95 += 15;
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, "[7]: Data Type\n", 0xFuLL);
      int v12 = v95;
    }
    if ((unint64_t)(v94 - v12) > 0xE)
    {
      qmemcpy(v12, "[8]: Operation\n", 15);
      char v13 = v95 + 15;
      v95 += 15;
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, "[8]: Operation\n", 0xFuLL);
      char v13 = v95;
    }
    if (v94 == v13)
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, "\n", 1uLL);
    }
    else
    {
      *char v13 = 10;
      ++v95;
    }
    if (byte_1EBCC2A58)
    {
      HIBYTE(v87) = 3;
      LODWORD(__p[0]) = 6107227;
      uint64_t v88 = &unk_1F25FF060;
      unint64_t v89 = "%-4s";
      unint64_t v90 = __p;
      llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v91, (uint64_t)&v88);
      if (v94 == v95) {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v91, " ", 1uLL);
      }
      else {
        *v95++ = 32;
      }
      if (SHIBYTE(v87) < 0) {
        operator delete(__p[0]);
      }
    }
    int v14 = v95;
    if ((unint64_t)(v94 - v95) > 2)
    {
      v95[2] = 93;
      *(_WORD *)int v14 = 12635;
      char v15 = v95 + 3;
      v95 += 3;
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, "[1]", 3uLL);
      char v15 = v95;
    }
    if (v94 == v15)
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, " ", 1uLL);
      int v16 = v95;
    }
    else
    {
      *char v15 = 32;
      int v16 = ++v95;
    }
    if ((unint64_t)(v94 - v16) > 2)
    {
      v16[2] = 93;
      *(_WORD *)int v16 = 12891;
      uint64_t v17 = v95 + 3;
      v95 += 3;
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, "[2]", 3uLL);
      uint64_t v17 = v95;
    }
    if (v94 == v17)
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, " ", 1uLL);
      uint64_t v18 = v95;
    }
    else
    {
      *uint64_t v17 = 32;
      uint64_t v18 = ++v95;
    }
    if ((unint64_t)(v94 - v18) > 2)
    {
      v18[2] = 93;
      *(_WORD *)uint64_t v18 = 13147;
      uint64_t v19 = v95 + 3;
      v95 += 3;
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, "[3]", 3uLL);
      uint64_t v19 = v95;
    }
    if (v94 == v19)
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, " ", 1uLL);
    }
    else
    {
      *uint64_t v19 = 32;
      ++v95;
    }
    HIBYTE(v87) = 3;
    LODWORD(__p[0]) = 6108251;
    uint64_t v88 = &unk_1F25FF060;
    unint64_t v89 = "%-9s";
    unint64_t v90 = __p;
    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v91, (uint64_t)&v88);
    if (v94 == v95) {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, " ", 1uLL);
    }
    else {
      *v95++ = 32;
    }
    if (SHIBYTE(v87) < 0) {
      operator delete(__p[0]);
    }
    HIBYTE(v87) = 3;
    LODWORD(__p[0]) = 6108507;
    if (byte_1EBCC2B18) {
      long long v20 = "%-11s";
    }
    else {
      long long v20 = "%-3s";
    }
    uint64_t v88 = &unk_1F25FF060;
    unint64_t v89 = v20;
    unint64_t v90 = __p;
    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v91, (uint64_t)&v88);
    if (v94 == v95) {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, " ", 1uLL);
    }
    else {
      *v95++ = 32;
    }
    if (SHIBYTE(v87) < 0) {
      operator delete(__p[0]);
    }
    HIBYTE(v87) = 3;
    LODWORD(__p[0]) = 6108763;
    if (byte_1EBCC2B18) {
      uint64_t v21 = "%-10s";
    }
    else {
      uint64_t v21 = "%-3s";
    }
    uint64_t v88 = &unk_1F25FF060;
    unint64_t v89 = v21;
    unint64_t v90 = __p;
    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v91, (uint64_t)&v88);
    if (v94 == v95) {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, " ", 1uLL);
    }
    else {
      *v95++ = 32;
    }
    if (SHIBYTE(v87) < 0) {
      operator delete(__p[0]);
    }
    HIBYTE(v87) = 3;
    LODWORD(__p[0]) = 6109019;
    if (byte_1EBCC2B18) {
      int v22 = "%-7s";
    }
    else {
      int v22 = "%-3s";
    }
    uint64_t v88 = &unk_1F25FF060;
    unint64_t v89 = v22;
    unint64_t v90 = __p;
    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v91, (uint64_t)&v88);
    if (v94 == v95) {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, " ", 1uLL);
    }
    else {
      *v95++ = 32;
    }
    if (SHIBYTE(v87) < 0) {
      operator delete(__p[0]);
    }
    HIBYTE(v87) = 3;
    LODWORD(__p[0]) = 6109275;
    size_t v23 = "%-6s";
    if (byte_1EBCC2B18) {
      size_t v23 = "%-15s";
    }
    uint64_t v88 = &unk_1F25FF060;
    unint64_t v89 = v23;
    unint64_t v90 = __p;
    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v91, (uint64_t)&v88);
    if (v94 == v95) {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, " ", 1uLL);
    }
    else {
      *v95++ = 32;
    }
    if (SHIBYTE(v87) < 0) {
      operator delete(__p[0]);
    }
    size_t v24 = v95;
    unsigned int v78 = a2;
    if ((unint64_t)(v94 - v95) > 0xD)
    {
      *(void *)int v95 = *(void *)"Instructions:\n";
      *(void *)((char *)v24 + 6) = *(void *)"ctions:\n";
      v95 += 14;
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v91, "Instructions:\n", 0xEuLL);
    }
    uint64_t v82 = a1;
    unsigned int v25 = *(_DWORD *)(a1 + 152);
    if (v25)
    {
      uint64_t v26 = *(void *)(a1 + 40);
      if (v26)
      {
        uint64_t v27 = 0;
        uint64_t v28 = 0;
        uint64_t v29 = *(void *)(a1 + 144);
        uint64_t v79 = (int *)(v29 + 28 * v25);
        int v30 = *(unsigned int **)(a1 + 32);
        uint64_t v83 = 168 * v26 - 168;
        uint64_t v31 = (int *)(v29 + 24);
        do
        {
          if (byte_1EBCC2A58)
          {
            int v32 = (void **)*v30;
            uint64_t v88 = &unk_1F25FED10;
            unint64_t v89 = "%4d ";
            unint64_t v90 = v32;
            llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v91, (uint64_t)&v88);
          }
          if (*((unsigned char *)v31 - 24)) {
            int v33 = " Q  ";
          }
          else {
            int v33 = " .  ";
          }
          if ((unint64_t)(v94 - v95) > 3)
          {
            *(_DWORD *)int v95 = *(_DWORD *)v33;
            unsigned int v34 = v95 + 4;
            v95 += 4;
          }
          else
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v91, v33, 4uLL);
            unsigned int v34 = v95;
          }
          if (*((unsigned char *)v31 - 23)) {
            int v35 = " S  ";
          }
          else {
            int v35 = " .  ";
          }
          if ((unint64_t)(v94 - v34) > 3)
          {
            *(_DWORD *)unsigned int v34 = *(_DWORD *)v35;
            v95 += 4;
          }
          else
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v91, v35, 4uLL);
          }
          uint64_t v88 = &unk_1F25FED10;
          int v36 = (void **)*(v31 - 5);
          unint64_t v89 = "%3d ";
          unint64_t v90 = v36;
          llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v91, (uint64_t)&v88);
          sub_1CBF2FF98((uint64_t)__p, *(v31 - 4));
          if (v87 >= 0) {
            int v37 = __p;
          }
          else {
            int v37 = (void **)__p[0];
          }
          uint64_t v88 = &unk_1F25FF060;
          unint64_t v89 = "%-9s";
          unint64_t v90 = v37;
          llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v91, (uint64_t)&v88);
          if (SHIBYTE(v87) < 0) {
            operator delete(__p[0]);
          }
          if (byte_1EBCC2B18)
          {
            uint64_t v38 = 0;
            unint64_t v39 = 0x6E614C7265746E49;
            char v40 = 9;
            uint64_t v41 = 101;
            switch(*(v31 - 3))
            {
              case 0:
                unint64_t v39 = v2 & 0xFFFFFFFFFFFF0000 | 0x3F;
                char v40 = 1;
                uint64_t v38 = v28;
                uint64_t v41 = v27;
                goto LABEL_114;
              case 1:
                unint64_t v47 = v2 & 0xFFFFFF0000000000 | 0x656E614C;
                char v40 = 4;
                goto LABEL_111;
              case 2:
                goto LABEL_114;
              case 3:
                unint64_t v47 = v2 & 0xFF00000000000000 | 0x657571696C43;
                char v40 = 6;
                goto LABEL_111;
              case 4:
                unint64_t v39 = 0x7247646165726854;
                char v40 = 11;
                uint64_t v38 = 117;
                uint64_t v41 = 111;
                goto LABEL_114;
              case 5:
                uint64_t v41 = 0;
                unint64_t v39 = 0x746E656D67617246;
                char v40 = 8;
                uint64_t v38 = v28;
                goto LABEL_114;
              default:
                unint64_t v47 = v2 & 0xFFFFFFFFFFFF0000 | 0x21;
                char v40 = 1;
LABEL_111:
                uint64_t v38 = v28;
                uint64_t v41 = v27;
                unint64_t v39 = v47;
LABEL_114:
                __p[0] = (void *)v39;
                __p[1] = (void *)(v41 | (v38 << 8) | 0x700000);
                HIBYTE(v87) = v40;
                uint64_t v88 = &unk_1F25FF060;
                unint64_t v89 = " %-11s";
                unint64_t v90 = __p;
                llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v91, (uint64_t)&v88);
                if (SHIBYTE(v87) < 0) {
                  operator delete(__p[0]);
                }
                uint64_t v48 = v82;
                int v49 = (llvm::raw_ostream *)(v82 + 72);
                char v50 = 10;
                unint64_t v51 = 0x6F43726564616853;
                switch(*(v31 - 2))
                {
                  case 0:
                    unint64_t v51 = v81 & 0xFFFFFFFFFFFF0000 | 0x3F;
                    goto LABEL_119;
                  case 1:
                    v81 &= 0xFFFFFFFFFFFFFF00;
                    HIBYTE(v87) = 2;
                    strcpy((char *)__p, "\"\"");
                    goto LABEL_127;
                  case 2:
                    unint64_t v51 = v81 & 0xFF00000000000000 | 0x6C61626F6C47;
                    char v50 = 6;
                    break;
                  case 3:
                    uint64_t v52 = 0x6C61636F4CLL;
                    goto LABEL_124;
                  case 4:
                    uint64_t v52 = 0x6B63617453;
LABEL_124:
                    unint64_t v51 = v81 & 0xFFFF000000000000 | v52 & 0xFFFFFFFFFFFFLL;
                    char v50 = 5;
                    break;
                  case 5:
                    break;
                  case 6:
                    char v50 = 7;
                    unint64_t v51 = 0x636972656E6547;
                    break;
                  default:
                    unint64_t v51 = v81 & 0xFFFFFFFFFFFF0000 | 0x21;
LABEL_119:
                    char v50 = 1;
                    break;
                }
                __p[0] = (void *)v51;
                __p[1] = (void *)25970;
                unint64_t v81 = v51;
                HIBYTE(v87) = v50;
LABEL_127:
                uint64_t v88 = &unk_1F25FF060;
                unint64_t v89 = " %-10s";
                unint64_t v90 = __p;
                llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v91, (uint64_t)&v88);
                if (SHIBYTE(v87) < 0) {
                  operator delete(__p[0]);
                }
                char v53 = 7;
                unint64_t v54 = 0x363174616F6C46;
                switch(*(v31 - 1))
                {
                  case 0:
                    unint64_t v54 = v80 & 0xFFFFFFFFFFFF0000 | 0x3F;
                    goto LABEL_132;
                  case 1:
                    v80 &= 0xFFFFFFFFFFFFFF00;
                    HIBYTE(v87) = 2;
                    strcpy((char *)__p, "\"\"");
                    goto LABEL_138;
                  case 2:
                    goto LABEL_137;
                  case 3:
                    unint64_t v54 = 0x323374616F6C46;
                    goto LABEL_137;
                  case 4:
                    unint64_t v54 = v80 & 0xFFFFFFFF00000000 | 0x746E49;
                    char v53 = 3;
                    goto LABEL_137;
                  case 5:
                    unint64_t v54 = v80 & 0xFFFFFF0000000000 | 0x73746942;
                    char v53 = 4;
                    goto LABEL_137;
                  default:
                    unint64_t v54 = v80 & 0xFFFFFFFFFFFF0000 | 0x21;
LABEL_132:
                    char v53 = 1;
LABEL_137:
                    __p[0] = (void *)v54;
                    HIBYTE(v87) = v53;
                    unint64_t v80 = v54;
LABEL_138:
                    uint64_t v88 = &unk_1F25FF060;
                    unint64_t v89 = " %-7s";
                    unint64_t v90 = __p;
                    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v91, (uint64_t)&v88);
                    if (SHIBYTE(v87) < 0) {
                      operator delete(__p[0]);
                    }
                    sub_1CBF2FAEC((uint64_t)v84, *v31);
                    if (SHIBYTE(v85) < 0)
                    {
                      if (v84[1])
                      {
                        sub_1CB8BDF7C((uint64_t)__p, v84[0], (unint64_t)v84[1]);
                        goto LABEL_146;
                      }
                    }
                    else if (HIBYTE(v85))
                    {
                      *(_OWORD *)__p = *(_OWORD *)v84;
                      uint64_t v87 = v85;
                      goto LABEL_146;
                    }
                    HIBYTE(v87) = 2;
                    strcpy((char *)__p, "\"\"");
LABEL_146:
                    uint64_t v55 = __p;
                    if (v87 < 0) {
                      uint64_t v55 = (void **)__p[0];
                    }
                    uint64_t v88 = &unk_1F25FF060;
                    unint64_t v89 = " %-15s";
                    unint64_t v90 = v55;
                    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v91, (uint64_t)&v88);
                    if (SHIBYTE(v87) < 0) {
                      operator delete(__p[0]);
                    }
                    if (SHIBYTE(v85) < 0) {
                      operator delete(v84[0]);
                    }
                    break;
                }
                break;
            }
          }
          else
          {
            unint64_t v42 = *(v31 - 3);
            if (v42 >= 6) {
              unsigned __int8 v43 = 33;
            }
            else {
              unsigned __int8 v43 = 0x4654434D4C3FuLL >> (8 * v42);
            }
            HIBYTE(v87) = 1;
            LOWORD(__p[0]) = v43;
            uint64_t v88 = &unk_1F25FF060;
            unint64_t v89 = " %1s  ";
            unint64_t v90 = __p;
            llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v91, (uint64_t)&v88);
            if (SHIBYTE(v87) < 0) {
              operator delete(__p[0]);
            }
            unint64_t v44 = *(v31 - 2);
            if (v44 >= 7) {
              unsigned __int8 v45 = 33;
            }
            else {
              unsigned __int8 v45 = 0x4E43534C472E3FuLL >> (8 * v44);
            }
            HIBYTE(v87) = 1;
            LOWORD(__p[0]) = v45;
            uint64_t v88 = &unk_1F25FF060;
            unint64_t v89 = " %1s  ";
            unint64_t v90 = __p;
            llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v91, (uint64_t)&v88);
            if (SHIBYTE(v87) < 0) {
              operator delete(__p[0]);
            }
            switch(*(v31 - 1))
            {
              case 0:
                HIBYTE(v87) = 1;
                __int16 v46 = 63;
                goto LABEL_158;
              case 1:
                HIBYTE(v87) = 0;
                LOBYTE(__p[0]) = 0;
                goto LABEL_159;
              case 2:
                HIBYTE(v87) = 1;
                __int16 v46 = 70;
                goto LABEL_158;
              case 3:
                HIBYTE(v87) = 1;
                __int16 v46 = 68;
                goto LABEL_158;
              case 4:
                HIBYTE(v87) = 1;
                __int16 v46 = 73;
                goto LABEL_158;
              case 5:
                HIBYTE(v87) = 1;
                __int16 v46 = 66;
                goto LABEL_158;
              default:
                HIBYTE(v87) = 1;
                __int16 v46 = 33;
LABEL_158:
                LOWORD(__p[0]) = v46;
LABEL_159:
                uint64_t v88 = &unk_1F25FF060;
                unint64_t v89 = " %1s  ";
                unint64_t v90 = __p;
                llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v91, (uint64_t)&v88);
                if (SHIBYTE(v87) < 0) {
                  operator delete(__p[0]);
                }
                switch(*v31)
                {
                  case 0:
                    HIBYTE(v87) = 1;
                    __int16 v56 = 63;
                    goto LABEL_196;
                  case 1:
                    HIBYTE(v87) = 1;
                    __int16 v56 = 77;
                    goto LABEL_196;
                  case 2:
                    HIBYTE(v87) = 3;
                    unsigned __int16 v57 = 27971;
                    goto LABEL_177;
                  case 3:
                    HIBYTE(v87) = 3;
                    unsigned __int16 v58 = 25939;
                    goto LABEL_174;
                  case 4:
                    HIBYTE(v87) = 3;
                    unsigned __int16 v59 = 26946;
                    goto LABEL_170;
                  case 5:
                    HIBYTE(v87) = 3;
                    unsigned __int16 v59 = 30275;
LABEL_170:
                    int v60 = v59 | 0x740000;
                    goto LABEL_187;
                  case 6:
                    HIBYTE(v87) = 4;
                    int v61 = 1836213584;
                    goto LABEL_194;
                  case 7:
                    HIBYTE(v87) = 4;
                    int v61 = 1969513810;
                    goto LABEL_194;
                  case 8:
                    HIBYTE(v87) = 3;
                    unsigned __int16 v58 = 29763;
LABEL_174:
                    int v60 = v58 | 0x6C0000;
                    goto LABEL_187;
                  case 9:
                    HIBYTE(v87) = 3;
                    int v60 = 6581827;
                    goto LABEL_187;
                  case 10:
                    HIBYTE(v87) = 3;
                    unsigned __int16 v57 = 27987;
LABEL_177:
                    int v60 = v57 | 0x700000;
                    goto LABEL_187;
                  case 11:
                    HIBYTE(v87) = 4;
                    int v61 = 1668184403;
                    goto LABEL_194;
                  case 12:
                    HIBYTE(v87) = 4;
                    int v61 = 1951622220;
                    goto LABEL_194;
                  case 13:
                    HIBYTE(v87) = 4;
                    int v61 = 1684107084;
                    goto LABEL_194;
                  case 14:
                    HIBYTE(v87) = 5;
                    LODWORD(__p[0]) = 1919906899;
                    __int16 v62 = 101;
                    goto LABEL_192;
                  case 15:
                    HIBYTE(v87) = 4;
                    int v61 = 1464685121;
                    goto LABEL_194;
                  case 16:
                    HIBYTE(v87) = 3;
                    int v60 = 7496002;
                    goto LABEL_187;
                  case 17:
                    HIBYTE(v87) = 4;
                    int v61 = 1181184582;
                    goto LABEL_194;
                  case 18:
                    HIBYTE(v87) = 3;
                    int v60 = 7894102;
                    goto LABEL_187;
                  case 19:
                    HIBYTE(v87) = 3;
                    int v60 = 6778185;
LABEL_187:
                    LODWORD(__p[0]) = v60;
                    break;
                  case 20:
                    HIBYTE(v87) = 4;
                    int v61 = 1702260557;
                    goto LABEL_194;
                  case 21:
                    HIBYTE(v87) = 4;
                    int v61 = 1417240914;
                    goto LABEL_194;
                  case 22:
                    HIBYTE(v87) = 5;
                    LODWORD(__p[0]) = 1279421769;
                    __int16 v62 = 100;
                    goto LABEL_192;
                  case 23:
                    HIBYTE(v87) = 5;
                    LODWORD(__p[0]) = 1463971145;
                    __int16 v62 = 114;
LABEL_192:
                    WORD2(__p[0]) = v62;
                    break;
                  case 24:
                    HIBYTE(v87) = 4;
                    int v61 = 1466395977;
LABEL_194:
                    LODWORD(__p[0]) = v61;
                    BYTE4(__p[0]) = 0;
                    break;
                  default:
                    HIBYTE(v87) = 1;
                    __int16 v56 = 33;
LABEL_196:
                    LOWORD(__p[0]) = v56;
                    break;
                }
                uint64_t v88 = &unk_1F25FF060;
                unint64_t v89 = " %-5s ";
                unint64_t v90 = __p;
                llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v91, (uint64_t)&v88);
                if (SHIBYTE(v87) < 0) {
                  operator delete(__p[0]);
                }
                uint64_t v41 = v27;
                unint64_t v39 = v2;
                uint64_t v48 = v82;
                uint64_t v38 = v28;
                int v49 = (llvm::raw_ostream *)(v82 + 72);
                break;
            }
          }
          if (v94 == v95) {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v91, " ", 1uLL);
          }
          else {
            *v95++ = 32;
          }
          MEMORY[0x1D25D9630](v82 + 48, "");
          (*(void (**)(void, unsigned int *, void, const char *, void, void, llvm::raw_ostream *))(**(void **)(v48 + 16) + 32))(*(void *)(v48 + 16), v30, 0, "", 0, *(void *)(v48 + 8), v49);
          unint64_t v63 = *(const char **)(v48 + 88);
          if (*(const char **)(v48 + 104) != v63)
          {
            *(void *)(v48 + 104) = v63;
            llvm::raw_ostream::flush_tied_then_write(v49, v63);
          }
          char v64 = *(unsigned char *)(v48 + 71);
          BOOL v65 = v64 < 0;
          if (v64 >= 0) {
            uint64_t v66 = (char *)(v82 + 48);
          }
          else {
            uint64_t v66 = *(char **)(v48 + 48);
          }
          char v67 = (const char *)(v64 & 0x7F);
          if (v65) {
            unint64_t v68 = *(const char **)(v48 + 56);
          }
          else {
            unint64_t v68 = v67;
          }
          uint64_t v88 = v66;
          unint64_t v89 = v68;
          unint64_t first_not_of = llvm::StringRef::find_first_not_of(&v88, " \t\n\v\f\r", 6, 0);
          unint64_t v70 = first_not_of;
          if (first_not_of >= (unint64_t)v68) {
            unint64_t v71 = (unint64_t)v68;
          }
          else {
            unint64_t v71 = first_not_of;
          }
          uint64_t v72 = &v66[v71];
          size_t v73 = (size_t)&v68[-v71];
          uint64_t v74 = v95;
          if ((unint64_t)&v68[-v71] <= v94 - v95)
          {
            if ((unint64_t)v68 > v70)
            {
              memcpy(v95, v72, v73);
              uint64_t v74 = &v95[v73];
              v95 += v73;
            }
          }
          else
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v91, v72, v73);
            uint64_t v74 = v95;
          }
          if (v74 >= v94)
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v91, 10);
          }
          else
          {
            int v95 = v74 + 1;
            *uint64_t v74 = 10;
          }
          if (v31 + 1 == v79) {
            break;
          }
          v30 += 42;
          uint64_t v75 = v83;
          v31 += 7;
          v83 -= 168;
          unint64_t v2 = v39;
          uint64_t v27 = v41;
          uint64_t v28 = v38;
        }
        while (v75);
      }
    }
    if (v95 != v93)
    {
      int v95 = v93;
      llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)&v91, v93);
    }
    if (v102 >= 0) {
      BOOL v76 = (const char *)&v100;
    }
    else {
      BOOL v76 = v100;
    }
    if (v102 >= 0) {
      size_t v77 = HIBYTE(v102) & 0x7F;
    }
    else {
      size_t v77 = v101;
    }
    llvm::raw_ostream::write(v78, v76, v77);
    unint64_t v91 = &unk_1F2646B98;
    if (v98 == 1 && v93) {
      MEMORY[0x1D25D9CB0](v93, 0x1000C8077774924);
    }
  }
  if (SHIBYTE(v102) < 0) {
    operator delete(v100);
  }
}

uint64_t sub_1CBF31DBC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 40);
  unsigned int v2 = *(_DWORD *)(result + 152);
  if (v1) {
    BOOL v3 = v2 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    uint64_t v4 = *(unsigned int **)(result + 32);
    uint64_t v5 = *(void *)(*(void *)(result + 8) + 192);
    uint64_t v6 = (_DWORD *)(*(void *)(result + 144) + 4);
    uint64_t v7 = 28 * v2 - 28;
    uint64_t v8 = 168 * v1 - 168;
    do
    {
      uint64_t v9 = *v4;
      unsigned int v10 = byte_1CDF30944[v9];
      int v11 = (v10 >> 1) & 1;
      BOOL v12 = (v10 & 4) == 0;
      BOOL v13 = (v10 & 4) != 0 || (v10 & 3) != 0;
      if (v12) {
        char v14 = v11;
      }
      else {
        char v14 = 1;
      }
      *((unsigned char *)v6 - 4) = v13;
      *((unsigned char *)v6 - 3) = v14;
      uint64_t result = sub_1CBD7C038(v9);
      *uint64_t v6 = result;
      if ((v5 & 0x800000000000) == 0
        || ((int v15 = v6[1], (v15 - 7) >= 4) ? (v16 = v15 == 5) : (v16 = 1), v16))
      {
        if (!v8) {
          return result;
        }
      }
      else
      {
        *uint64_t v6 = 2 * result;
        if (!v8) {
          return result;
        }
      }
      v4 += 42;
      v6 += 7;
      uint64_t v17 = v7;
      v7 -= 28;
      v8 -= 168;
    }
    while (v17);
  }
  return result;
}

void sub_1CBF31EB4(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v55[4] = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 40))
  {
    long long v22 = 0uLL;
    unint64_t v23 = 0;
    unsigned int v3 = *(_DWORD *)(a1 + 152);
    if (v3)
    {
      int v4 = 0;
      uint64_t v5 = *(char **)(a1 + 144);
      uint64_t v18 = &v5[28 * v3];
      do
      {
        sub_1CBF2C538(v36, "QUADScope", 9uLL);
        char v6 = *v5;
        LOWORD(v37) = 1;
        LOBYTE(v38) = v6;
        sub_1CBF2C538(v40, "SIMDScope", 9uLL);
        char v7 = v5[1];
        __int16 v41 = 1;
        char v42 = v7;
        sub_1CBF2C538(v43, "InstrRate", 9uLL);
        uint64_t v8 = *((unsigned int *)v5 + 1);
        __int16 v44 = 3;
        uint64_t v45 = v8;
        sub_1CBF2C538(v46, "ALUSubpipe", 0xAuLL);
        sub_1CBF2FF98((uint64_t)&v32, *((_DWORD *)v5 + 2));
        sub_1CD452764((uint64_t)&v47, (unint64_t)&v32);
        sub_1CBF2C538(v48, "Scope", 5uLL);
        switch(*((_DWORD *)v5 + 3))
        {
          case 0:
            char v31 = 1;
            __int16 v9 = 63;
            goto LABEL_9;
          case 1:
            char v31 = 4;
            strcpy(v30, "Lane");
            break;
          case 2:
            char v31 = 9;
            strcpy(v30, "InterLane");
            break;
          case 3:
            char v31 = 6;
            strcpy(v30, "Clique");
            break;
          case 4:
            char v31 = 11;
            strcpy(v30, "ThreadGroup");
            break;
          case 5:
            char v31 = 8;
            strcpy(v30, "Fragment");
            break;
          default:
            char v31 = 1;
            __int16 v9 = 33;
LABEL_9:
            *(_WORD *)int v30 = v9;
            break;
        }
        sub_1CD452764((uint64_t)&v49, (unint64_t)v30);
        sub_1CBF2C538(v50, "Memory", 6uLL);
        switch(*((_DWORD *)v5 + 4))
        {
          case 0:
            char v29 = 1;
            __int16 v10 = 63;
            goto LABEL_18;
          case 1:
            char v29 = 0;
            v28[0] = 0;
            break;
          case 2:
            char v29 = 6;
            strcpy(v28, "Global");
            break;
          case 3:
            char v29 = 5;
            *(_DWORD *)uint64_t v28 = 1633906508;
            __int16 v11 = 108;
            goto LABEL_23;
          case 4:
            char v29 = 5;
            *(_DWORD *)uint64_t v28 = 1667331155;
            __int16 v11 = 107;
LABEL_23:
            *(_WORD *)&v28[4] = v11;
            break;
          case 5:
            char v29 = 10;
            strcpy(v28, "ShaderCore");
            break;
          case 6:
            char v29 = 7;
            strcpy(v28, "Generic");
            break;
          default:
            char v29 = 1;
            __int16 v10 = 33;
LABEL_18:
            *(_WORD *)uint64_t v28 = v10;
            break;
        }
        sub_1CD452764((uint64_t)&v51, (unint64_t)v28);
        sub_1CBF2C538(v52, "DataType", 8uLL);
        switch(*((_DWORD *)v5 + 5))
        {
          case 0:
            char v27 = 1;
            __int16 v12 = 63;
            goto LABEL_29;
          case 1:
            char v27 = 0;
            LOBYTE(v26[0]) = 0;
            break;
          case 2:
            char v27 = 7;
            LODWORD(v26[0]) = 1634692166;
            int v13 = 909210721;
            goto LABEL_33;
          case 3:
            char v27 = 7;
            LODWORD(v26[0]) = 1634692166;
            int v13 = 842232929;
LABEL_33:
            *(_DWORD *)((char *)v26 + 3) = v13;
            HIBYTE(v26[0]) = 0;
            break;
          case 4:
            char v27 = 3;
            LODWORD(v26[0]) = 7630409;
            break;
          case 5:
            char v27 = 4;
            strcpy((char *)v26, "Bits");
            break;
          default:
            char v27 = 1;
            __int16 v12 = 33;
LABEL_29:
            LOWORD(v26[0]) = v12;
            break;
        }
        sub_1CD452764((uint64_t)&v53, (unint64_t)v26);
        sub_1CBF2C538(v54, "Op", 2uLL);
        sub_1CBF2FAEC((uint64_t)__p, *((_DWORD *)v5 + 6));
        sub_1CD452764((uint64_t)v55, (unint64_t)__p);
        sub_1CD451B70((uint64_t)&v19, (uint64_t)v36, 8);
        uint64_t v14 = 448;
        do
        {
          llvm::json::Value::destroy((llvm::json::Value *)&v30[v14 + 16]);
          sub_1CB833F88((uint64_t *)&v28[v14 + 16], 0);
          v14 -= 56;
        }
        while (v14);
        if (v25 < 0) {
          operator delete(__p[0]);
        }
        if (v27 < 0) {
          operator delete(v26[0]);
        }
        if (v29 < 0) {
          operator delete(*(void **)v28);
        }
        if (v31 < 0) {
          operator delete(*(void **)v30);
        }
        if (v35 < 0) {
          operator delete(v32);
        }
        sub_1CBF2C538(v36, "Instruction", 0xBuLL);
        *(_DWORD *)int v30 = v4;
        sub_1CBF2CE7C((uint64_t)&v19, (uint64_t)v36, (unsigned int *)v30, (uint64_t)&v32);
        int v15 = v36[0];
        v36[0] = 0;
        if (v15)
        {
          if (*((char *)v15 + 23) < 0) {
            operator delete(*v15);
          }
          MEMORY[0x1D25D9CE0](v15, 0x1012C40EC159624);
        }
        LOWORD(v36[0]) = 7;
        v36[1] = v19;
        v36[2] = v20;
        uint64_t v19 = 0;
        long long v20 = 0;
        int v37 = v21;
        int v21 = 0;
        uint64_t v16 = *((void *)&v22 + 1);
        if (*((void *)&v22 + 1) >= v23)
        {
          uint64_t v17 = sub_1CBF2C6D0((unsigned __int16 **)&v22, (unsigned __int16 *)v36);
        }
        else
        {
          llvm::json::Value::moveFrom(*((uint64_t *)&v22 + 1), (unsigned __int16 *)v36);
          uint64_t v17 = v16 + 32;
        }
        *((void *)&v22 + 1) = v17;
        llvm::json::Value::destroy((llvm::json::Value *)v36);
        sub_1CD452448((unsigned int *)&v19);
        MEMORY[0x1D25D9CD0](v19, 8);
        v5 += 28;
        ++v4;
      }
      while (v5 != v18);
    }
    sub_1CBF2C538(v36, "InstructionList", 0xFuLL);
    LOWORD(v37) = 8;
    long long v38 = v22;
    unint64_t v39 = v23;
    long long v22 = 0uLL;
    unint64_t v23 = 0;
    sub_1CD451B70((uint64_t)&v32, (uint64_t)v36, 1);
    *(_WORD *)a2 = 7;
    *(void *)(a2 + 8) = v32;
    *(void *)(a2 + 16) = v33;
    int v32 = 0;
    uint64_t v33 = 0;
    *(_DWORD *)(a2 + 24) = v34;
    int v34 = 0;
    sub_1CD452448((unsigned int *)&v32);
    MEMORY[0x1D25D9CD0](v32, 8);
    llvm::json::Value::destroy((llvm::json::Value *)&v37);
    sub_1CB833F88((uint64_t *)v36, 0);
    v36[0] = (void **)&v22;
    sub_1CBF2C7E0(v36);
  }
  else
  {
    *(_WORD *)a2 = 3;
    *(void *)(a2 + 8) = 0;
  }
}

uint64_t sub_1CBF325F4(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 152);
  if (v3)
  {
    unsigned __int16 v57 = 0;
    uint64_t v5 = 0;
    unsigned __int16 v58 = 0;
    unsigned __int16 v59 = *(unsigned __int8 **)(a1 + 144);
    int v60 = &v59[28 * v3];
    uint64_t v161 = v60;
    while (1)
    {
      int v61 = *v59;
      int v62 = v59[1];
      int v63 = 1;
      int v64 = *((_DWORD *)v59 + 1);
      __int16 v65 = 0;
      uint64_t v163 = v57;
      switch(*((_DWORD *)v59 + 2))
      {
        case 1:
          int v63 = 0;
          __int16 v65 = 1;
          break;
        case 2:
          int v63 = 0;
          __int16 v65 = 2;
          break;
        case 3:
          int v63 = 0;
          __int16 v65 = 3;
          break;
        case 4:
          int v63 = 0;
          __int16 v65 = 4;
          break;
        case 5:
          int v63 = 0;
          __int16 v65 = 5;
          break;
        case 6:
          int v63 = 0;
          __int16 v65 = 6;
          break;
        case 7:
          int v63 = 0;
          __int16 v65 = 7;
          break;
        case 8:
          int v63 = 0;
          __int16 v65 = 8;
          break;
        case 9:
          int v63 = 0;
          __int16 v65 = 9;
          break;
        case 0xA:
          int v63 = 0;
          __int16 v65 = 10;
          break;
        case 0xB:
          int v63 = 0;
          __int16 v65 = 16;
          break;
        case 0xC:
          int v63 = 0;
          __int16 v65 = 11;
          break;
        case 0xD:
          int v63 = 0;
          __int16 v65 = 12;
          break;
        case 0xE:
          int v63 = 0;
          __int16 v65 = 13;
          break;
        case 0xF:
          int v63 = 0;
          __int16 v65 = 14;
          break;
        case 0x10:
          int v63 = 0;
          __int16 v65 = 15;
          break;
        default:
          break;
      }
      int v66 = *((_DWORD *)v59 + 3);
      int v67 = *((_DWORD *)v59 + 4);
      int v68 = *((_DWORD *)v59 + 5);
      int v69 = *((_DWORD *)v59 + 6);
      BOOL v70 = 1;
      *(unsigned char *)(a2 + 70) = 1;
      uint64_t v71 = *(void *)(a2 + 48);
      uint64_t v165 = *(void *)(a2 + 32);
      uint64_t v166 = *(void *)(a2 + 40);
      __int16 v164 = v71;
      if (v64 || *(unsigned char *)(a2 + 80)) {
        break;
      }
LABEL_117:
      if ((_WORD)v69 || !v70)
      {
        __int16 v150 = v66;
        int v154 = v63;
        int v142 = v62;
        __int16 v146 = v65;
        int v104 = v61;
        unsigned int v105 = sub_1CD4525F4(a2, v69);
        uint64_t v106 = *(uint64_t **)(a2 + 56);
        if (*(void *)(a2 + 48) - (void)v106 <= 7uLL)
        {
          sub_1CBF2C904((uint64_t *)a2, 8uLL);
          uint64_t v106 = *(uint64_t **)(a2 + 56);
        }
        *uint64_t v106 = v105 | 0x1200000000;
        *(void *)(a2 + 56) += 8;
        ++*(_DWORD *)(a2 + 64);
        unsigned int v107 = *(unsigned __int16 *)(a2 + 68);
        if (v107 <= 0x12) {
          LOWORD(v107) = 18;
        }
        *(_WORD *)(a2 + 68) = v107;
        BOOL v80 = *(unsigned char *)(a2 + 80) == 0;
        int v61 = v104;
        int v62 = v142;
        __int16 v65 = v146;
        LOWORD(v71) = v164;
        LOWORD(v66) = v150;
        int v63 = v154;
      }
      else
      {
        BOOL v80 = 1;
      }
      if ((_WORD)v68 || !v80)
      {
        __int16 v151 = v66;
        int v155 = v63;
        __int16 v147 = v65;
        int v108 = v62;
        int v109 = v61;
        unsigned int v110 = sub_1CD4525F4(a2, v68);
        unint64_t v111 = *(uint64_t **)(a2 + 56);
        if (*(void *)(a2 + 48) - (void)v111 <= 7uLL)
        {
          sub_1CBF2C904((uint64_t *)a2, 8uLL);
          unint64_t v111 = *(uint64_t **)(a2 + 56);
        }
        uint64_t *v111 = v110 | 0x1000000000;
        *(void *)(a2 + 56) += 8;
        ++*(_DWORD *)(a2 + 64);
        unsigned int v112 = *(unsigned __int16 *)(a2 + 68);
        if (v112 <= 0x10) {
          LOWORD(v112) = 16;
        }
        *(_WORD *)(a2 + 68) = v112;
        BOOL v81 = *(unsigned char *)(a2 + 80) == 0;
        int v61 = v109;
        int v62 = v108;
        LOWORD(v71) = v164;
        __int16 v65 = v147;
        LOWORD(v66) = v151;
        int v63 = v155;
      }
      else
      {
        BOOL v81 = 1;
      }
      if ((_WORD)v67 || !v81)
      {
        __int16 v152 = v66;
        int v156 = v63;
        __int16 v113 = v65;
        int v114 = v62;
        int v115 = v61;
        unsigned int v116 = sub_1CD4525F4(a2, v67);
        uint64_t v117 = *(uint64_t **)(a2 + 56);
        if (*(void *)(a2 + 48) - (void)v117 <= 7uLL)
        {
          sub_1CBF2C904((uint64_t *)a2, 8uLL);
          uint64_t v117 = *(uint64_t **)(a2 + 56);
        }
        *uint64_t v117 = v116 | 0xE00000000;
        *(void *)(a2 + 56) += 8;
        ++*(_DWORD *)(a2 + 64);
        unsigned int v118 = *(unsigned __int16 *)(a2 + 68);
        if (v118 <= 0xE) {
          LOWORD(v118) = 14;
        }
        *(_WORD *)(a2 + 68) = v118;
        BOOL v82 = *(unsigned char *)(a2 + 80) == 0;
        unsigned __int16 v57 = v163;
        LOWORD(v71) = v164;
        int v61 = v115;
        int v62 = v114;
        __int16 v65 = v113;
        LOWORD(v66) = v152;
        int v63 = v156;
      }
      else
      {
        BOOL v82 = 1;
        unsigned __int16 v57 = v163;
      }
      if ((_WORD)v66 || !v82)
      {
        int v157 = v63;
        __int16 v119 = v65;
        int v120 = v62;
        int v121 = v61;
        unsigned int v122 = sub_1CD4525F4(a2, v66);
        unint64_t v123 = *(uint64_t **)(a2 + 56);
        if (*(void *)(a2 + 48) - (void)v123 <= 7uLL)
        {
          sub_1CBF2C904((uint64_t *)a2, 8uLL);
          unint64_t v123 = *(uint64_t **)(a2 + 56);
        }
        uint64_t *v123 = v122 | 0xC00000000;
        *(void *)(a2 + 56) += 8;
        ++*(_DWORD *)(a2 + 64);
        unsigned int v124 = *(unsigned __int16 *)(a2 + 68);
        if (v124 <= 0xC) {
          LOWORD(v124) = 12;
        }
        *(_WORD *)(a2 + 68) = v124;
        BOOL v83 = *(unsigned char *)(a2 + 80) == 0;
        int v61 = v121;
        int v62 = v120;
        LOWORD(v71) = v164;
        __int16 v65 = v119;
        int v63 = v157;
      }
      else
      {
        BOOL v83 = 1;
      }
      if (v63 & v83)
      {
        BOOL v84 = 0;
        if (v62) {
          goto LABEL_132;
        }
      }
      else
      {
        int v99 = v62;
        int v100 = v61;
        unsigned int v101 = sub_1CD4525F4(a2, v65);
        uint64_t v102 = *(uint64_t **)(a2 + 56);
        if (*(void *)(a2 + 48) - (void)v102 <= 7uLL)
        {
          sub_1CBF2C904((uint64_t *)a2, 8uLL);
          uint64_t v102 = *(uint64_t **)(a2 + 56);
        }
        *uint64_t v102 = v101 | 0xA00000000;
        *(void *)(a2 + 56) += 8;
        ++*(_DWORD *)(a2 + 64);
        unsigned int v103 = *(unsigned __int16 *)(a2 + 68);
        if (v103 <= 0xA) {
          LOWORD(v103) = 10;
        }
        *(_WORD *)(a2 + 68) = v103;
        BOOL v84 = *(unsigned char *)(a2 + 80) != 0;
        int v61 = v100;
        LOBYTE(v62) = v99;
        LOWORD(v71) = v164;
        if (v99)
        {
LABEL_132:
          unsigned int v85 = sub_1CBF2CB00(a2, v62);
          int v86 = *(uint64_t **)(a2 + 56);
          if (*(void *)(a2 + 48) - (void)v86 <= 7uLL)
          {
            sub_1CBF2C904((uint64_t *)a2, 8uLL);
            int v86 = *(uint64_t **)(a2 + 56);
          }
          *int v86 = v85 | 0x600000000;
          *(void *)(a2 + 56) += 8;
          ++*(_DWORD *)(a2 + 64);
          unsigned int v87 = *(unsigned __int16 *)(a2 + 68);
          if (v87 <= 6) {
            LOWORD(v87) = 6;
          }
          *(_WORD *)(a2 + 68) = v87;
          BOOL v84 = *(unsigned char *)(a2 + 80) != 0;
          LOWORD(v71) = v164;
          goto LABEL_137;
        }
      }
      if (v84) {
        goto LABEL_132;
      }
LABEL_137:
      if (v61 || v84)
      {
        unsigned int v88 = sub_1CBF2CB00(a2, v61);
        unint64_t v89 = *(uint64_t **)(a2 + 56);
        if (*(void *)(a2 + 48) - (void)v89 <= 7uLL)
        {
          sub_1CBF2C904((uint64_t *)a2, 8uLL);
          unint64_t v89 = *(uint64_t **)(a2 + 56);
        }
        *unint64_t v89 = v88 | 0x400000000;
        *(void *)(a2 + 56) += 8;
        ++*(_DWORD *)(a2 + 64);
        unsigned int v90 = *(unsigned __int16 *)(a2 + 68);
        if (v90 <= 4) {
          LOWORD(v90) = 4;
        }
        *(_WORD *)(a2 + 68) = v90;
        LOWORD(v71) = v164;
      }
      int v91 = sub_1CBF2CB78(a2, (unsigned __int16)v165 - (unsigned __int16)v71 + (unsigned __int16)v166);
      int v92 = v91;
      if (v58 >= v57)
      {
        uint64_t v93 = (v58 - v5) >> 2;
        unint64_t v94 = v93 + 1;
        if ((unint64_t)(v93 + 1) >> 62) {
          abort();
        }
        if ((v57 - v5) >> 1 > v94) {
          unint64_t v94 = (v57 - v5) >> 1;
        }
        if ((unint64_t)(v57 - v5) >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v95 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v95 = v94;
        }
        if (v95)
        {
          if (v95 >> 62) {
            sub_1CB833614();
          }
          char v96 = (char *)operator new(4 * v95);
        }
        else
        {
          char v96 = 0;
        }
        uint64_t v97 = &v96[4 * v93];
        *(_DWORD *)uint64_t v97 = v92;
        int v4 = v97 + 4;
        while (v58 != v5)
        {
          int v98 = *((_DWORD *)v58 - 1);
          v58 -= 4;
          *((_DWORD *)v97 - 1) = v98;
          v97 -= 4;
        }
        unsigned __int16 v57 = &v96[4 * v95];
        if (v5) {
          operator delete(v5);
        }
        uint64_t v5 = v97;
      }
      else
      {
        *(_DWORD *)unsigned __int16 v58 = v91;
        int v4 = v58 + 4;
      }
      v59 += 28;
      unsigned __int16 v58 = v4;
      if (v59 == v60) {
        goto LABEL_3;
      }
    }
    int v162 = v61;
    if (*(void *)(a2 + 72) <= 3uLL) {
      *(void *)(a2 + 72) = 4;
    }
    unint64_t v72 = ((_BYTE)v71 - ((_BYTE)v165 + (_BYTE)v166)) & 3;
    size_t v73 = *(uint64_t **)(a2 + 56);
    if (v71 - (uint64_t)v73 < v72)
    {
      int v145 = v62;
      __int16 v149 = v65;
      int v160 = v63;
      __int16 v127 = v66;
      sub_1CBF2C904((uint64_t *)a2, ((_BYTE)v71 - ((_BYTE)v165 + (_BYTE)v166)) & 3);
      LOWORD(v66) = v127;
      int v63 = v160;
      int v62 = v145;
      __int16 v65 = v149;
      LOWORD(v71) = v164;
      *(void *)(a2 + 48) -= v72;
    }
    else
    {
      uint64_t v74 = v71 - v72;
      *(void *)(a2 + ++*(_DWORD *)(result + 48) = v71 - v72;
      if ((((_BYTE)v71 - ((_BYTE)v165 + (_BYTE)v166)) & 3) == 0)
      {
LABEL_110:
        if ((unint64_t)(v74 - (void)v73) <= 3)
        {
          int v143 = v62;
          __int16 v125 = v65;
          int v158 = v63;
          __int16 v126 = v66;
          sub_1CBF2C904((uint64_t *)a2, 4uLL);
          LOWORD(v66) = v126;
          int v63 = v158;
          __int16 v65 = v125;
          LOWORD(v71) = v164;
          int v62 = v143;
          uint64_t v74 = *(void *)(a2 + 48);
          size_t v73 = *(uint64_t **)(a2 + 56);
        }
        *(_DWORD *)(v74 - 4) = v64;
        uint64_t v76 = v74 - 4;
        *(void *)(a2 + ++*(_DWORD *)(result + 48) = v76;
        uint64_t v77 = *(void *)(a2 + 32);
        uint64_t v78 = *(void *)(a2 + 40);
        if ((unint64_t)(v76 - (void)v73) <= 7)
        {
          int v144 = v62;
          __int16 v148 = v65;
          __int16 v153 = v66;
          int v159 = v63;
          sub_1CBF2C904((uint64_t *)a2, 8uLL);
          LOWORD(v66) = v153;
          int v63 = v159;
          int v62 = v144;
          __int16 v65 = v148;
          LOWORD(v71) = v164;
          size_t v73 = *(uint64_t **)(a2 + 56);
        }
        *size_t v73 = (v77 - v76 + v78) | 0x800000000;
        *(void *)(a2 + 56) += 8;
        ++*(_DWORD *)(a2 + 64);
        unsigned int v79 = *(unsigned __int16 *)(a2 + 68);
        if (v79 <= 8) {
          LOWORD(v79) = 8;
        }
        *(_WORD *)(a2 + 68) = v79;
        BOOL v70 = *(unsigned char *)(a2 + 80) == 0;
        int v60 = v161;
        int v61 = v162;
        goto LABEL_117;
      }
    }
    uint64_t v75 = 0;
    do
      *(unsigned char *)(*(void *)(a2 + 48) + v75++) = 0;
    while (v72 != v75);
    uint64_t v74 = *(void *)(a2 + 48);
    size_t v73 = *(uint64_t **)(a2 + 56);
    goto LABEL_110;
  }
  int v4 = 0;
  uint64_t v5 = 0;
LABEL_3:
  uint64_t v6 = v4 - v5;
  if (v4 == v5) {
    char v7 = (char *)&unk_1CFAA0190;
  }
  else {
    char v7 = v5;
  }
  *(unsigned char *)(a2 + 70) = 1;
  if (*(void *)(a2 + 72) <= 3uLL) {
    *(void *)(a2 + 72) = 4;
  }
  uint64_t v8 = *(void *)(a2 + 48);
  unint64_t v9 = ((_BYTE)v8 - (*(_DWORD *)(a2 + 32) + *(_DWORD *)(a2 + 40))) & 3;
  if (v8 - *(void *)(a2 + 56) < v9)
  {
    sub_1CBF2C904((uint64_t *)a2, ((_BYTE)v8 - (*(_DWORD *)(a2 + 32) + *(_DWORD *)(a2 + 40))) & 3);
    *(void *)(a2 + 48) -= v9;
  }
  else
  {
    *(void *)(a2 + ++*(_DWORD *)(result + 48) = v8 - v9;
    if (!v9) {
      goto LABEL_10;
    }
  }
  uint64_t v141 = 0;
  do
    *(unsigned char *)(*(void *)(a2 + 48) + v141++) = 0;
  while (v9 != v141);
  if (*(void *)(a2 + 72) <= 3uLL) {
    *(void *)(a2 + 72) = 4;
  }
LABEL_10:
  uint64_t v10 = *(void *)(a2 + 48);
  unint64_t v11 = ((_BYTE)v10 - (*(_DWORD *)(a2 + 32) + *(_DWORD *)(a2 + 40))) & 3;
  if (v10 - *(void *)(a2 + 56) < v11)
  {
    sub_1CBF2C904((uint64_t *)a2, ((_BYTE)v10 - (*(_DWORD *)(a2 + 32) + *(_DWORD *)(a2 + 40))) & 3);
    *(void *)(a2 + 48) -= v11;
  }
  else
  {
    *(void *)(a2 + ++*(_DWORD *)(result + 48) = v10 - v11;
    if (!v11) {
      goto LABEL_14;
    }
  }
  uint64_t v12 = 0;
  do
    *(unsigned char *)(*(void *)(a2 + 48) + v12++) = 0;
  while (v11 != v12);
LABEL_14:
  if (v5 != v4)
  {
    uint64_t v128 = v6 >> 2;
    do
    {
      --v128;
      int v129 = *(_DWORD *)&v7[4 * v128];
      if (*(void *)(a2 + 72) <= 3uLL) {
        *(void *)(a2 + 72) = 4;
      }
      uint64_t v130 = *(void *)(a2 + 32);
      uint64_t v131 = *(void *)(a2 + 40);
      uint64_t v132 = *(void *)(a2 + 48);
      unint64_t v133 = ((int)v132 - ((int)v130 + (int)v131)) & 3;
      if (v132 - *(void *)(a2 + 56) < v133)
      {
        sub_1CBF2C904((uint64_t *)a2, ((int)v132 - ((int)v130 + (int)v131)) & 3);
        *(void *)(a2 + 48) -= v133;
      }
      else
      {
        uint64_t v134 = v132 - v133;
        *(void *)(a2 + ++*(_DWORD *)(result + 48) = v134;
        if (!v133)
        {
          int v135 = v130 + v131 - v134;
          goto LABEL_202;
        }
      }
      uint64_t v136 = 0;
      do
        *(unsigned char *)(*(void *)(a2 + 48) + v136++) = 0;
      while (v133 != v136);
      uint64_t v131 = *(void *)(a2 + 40);
      uint64_t v134 = *(void *)(a2 + 48);
      uint64_t v130 = *(void *)(a2 + 32);
      int v135 = v130 - v134 + v131;
      if (*(void *)(a2 + 72) <= 3uLL) {
        *(void *)(a2 + 72) = 4;
      }
LABEL_202:
      unint64_t v137 = ((_BYTE)v134 - ((_BYTE)v130 + (_BYTE)v131)) & 3;
      uint64_t v138 = *(void *)(a2 + 56);
      if (v134 - v138 < v137)
      {
        sub_1CBF2C904((uint64_t *)a2, v137);
        *(void *)(a2 + 48) -= v137;
LABEL_204:
        uint64_t v140 = 0;
        do
          *(unsigned char *)(*(void *)(a2 + 48) + v140++) = 0;
        while (v137 != v140);
        uint64_t v139 = *(void *)(a2 + 48);
        uint64_t v138 = *(void *)(a2 + 56);
        goto LABEL_207;
      }
      uint64_t v139 = v134 - v137;
      *(void *)(a2 + ++*(_DWORD *)(result + 48) = v134 - v137;
      if (v137) {
        goto LABEL_204;
      }
LABEL_207:
      if ((unint64_t)(v139 - v138) <= 3)
      {
        sub_1CBF2C904((uint64_t *)a2, 4uLL);
        uint64_t v139 = *(void *)(a2 + 48);
      }
      *(_DWORD *)(v139 - 4) = v135 - v129 + 4;
      *(void *)(a2 + ++*(_DWORD *)(result + 48) = v139 - 4;
    }
    while (v128);
  }
  *(unsigned char *)(a2 + 70) = 0;
  if (*(void *)(a2 + 72) <= 3uLL) {
    *(void *)(a2 + 72) = 4;
  }
  uint64_t v14 = *(void *)(a2 + 48);
  uint64_t v13 = *(void *)(a2 + 56);
  unint64_t v15 = ((_BYTE)v14 - (*(_DWORD *)(a2 + 32) + *(_DWORD *)(a2 + 40))) & 3;
  if (v14 - v13 < v15)
  {
    sub_1CBF2C904((uint64_t *)a2, ((_BYTE)v14 - (*(_DWORD *)(a2 + 32) + *(_DWORD *)(a2 + 40))) & 3);
    *(void *)(a2 + 48) -= v15;
  }
  else
  {
    uint64_t v16 = v14 - v15;
    *(void *)(a2 + ++*(_DWORD *)(result + 48) = v14 - v15;
    if (!v15) {
      goto LABEL_22;
    }
  }
  uint64_t v17 = 0;
  do
    *(unsigned char *)(*(void *)(a2 + 48) + v17++) = 0;
  while (v15 != v17);
  uint64_t v16 = *(void *)(a2 + 48);
  uint64_t v13 = *(void *)(a2 + 56);
LABEL_22:
  if ((unint64_t)(v16 - v13) <= 3)
  {
    sub_1CBF2C904((uint64_t *)a2, 4uLL);
    uint64_t v16 = *(void *)(a2 + 48);
  }
  *(_DWORD *)(v16 - 4) = (unint64_t)v6 >> 2;
  uint64_t v18 = v16 - 4;
  *(void *)(a2 + ++*(_DWORD *)(result + 48) = v18;
  uint64_t v19 = *(void *)(a2 + 32);
  uint64_t v20 = *(void *)(a2 + 40);
  *(unsigned char *)(a2 + 70) = 1;
  int v21 = v19 - v18 + v20;
  if (v21)
  {
    if (*(void *)(a2 + 72) <= 3uLL) {
      *(void *)(a2 + 72) = 4;
    }
    unint64_t v22 = ((_BYTE)v18 - ((_BYTE)v19 + (_BYTE)v20)) & 3;
    if (v18 - *(void *)(a2 + 56) < v22)
    {
      sub_1CBF2C904((uint64_t *)a2, ((_BYTE)v18 - ((_BYTE)v19 + (_BYTE)v20)) & 3);
      *(void *)(a2 + 48) -= v22;
    }
    else
    {
      uint64_t v23 = v18 - v22;
      *(void *)(a2 + ++*(_DWORD *)(result + 48) = v23;
      if (!v22)
      {
LABEL_32:
        int v25 = v20 - v23 + v19 - v21 + 4;
        if (v20 - v23 + v19 - v21 == -4 && *(unsigned char *)(a2 + 80) == 0) {
          goto LABEL_50;
        }
        if (*(void *)(a2 + 72) <= 3uLL) {
          *(void *)(a2 + 72) = 4;
        }
        unint64_t v27 = ((_BYTE)v23 - ((_BYTE)v19 + (_BYTE)v20)) & 3;
        uint64_t v28 = *(uint64_t **)(a2 + 56);
        if (v23 - (uint64_t)v28 < v27)
        {
          sub_1CBF2C904((uint64_t *)a2, v27);
          *(void *)(a2 + 48) -= v27;
        }
        else
        {
          uint64_t v29 = v23 - v27;
          *(void *)(a2 + ++*(_DWORD *)(result + 48) = v23 - v27;
          if (!v27)
          {
LABEL_43:
            if ((unint64_t)(v29 - (void)v28) <= 3)
            {
              sub_1CBF2C904((uint64_t *)a2, 4uLL);
              uint64_t v29 = *(void *)(a2 + 48);
              uint64_t v28 = *(uint64_t **)(a2 + 56);
            }
            *(_DWORD *)(v29 - 4) = v25;
            uint64_t v31 = v29 - 4;
            *(void *)(a2 + ++*(_DWORD *)(result + 48) = v31;
            uint64_t v32 = *(void *)(a2 + 32) - v31 + *(void *)(a2 + 40);
            if ((unint64_t)(v31 - (void)v28) <= 7)
            {
              sub_1CBF2C904((uint64_t *)a2, 8uLL);
              uint64_t v28 = *(uint64_t **)(a2 + 56);
            }
            *uint64_t v28 = v32 | 0x400000000;
            *(void *)(a2 + 56) += 8;
            ++*(_DWORD *)(a2 + 64);
            unsigned int v33 = *(unsigned __int16 *)(a2 + 68);
            if (v33 <= 4) {
              LOWORD(v33) = 4;
            }
            *(_WORD *)(a2 + 68) = v33;
            goto LABEL_50;
          }
        }
        uint64_t v30 = 0;
        do
          *(unsigned char *)(*(void *)(a2 + 48) + v30++) = 0;
        while (v27 != v30);
        uint64_t v29 = *(void *)(a2 + 48);
        uint64_t v28 = *(uint64_t **)(a2 + 56);
        goto LABEL_43;
      }
    }
    uint64_t v24 = 0;
    do
      *(unsigned char *)(*(void *)(a2 + 48) + v24++) = 0;
    while (v22 != v24);
    uint64_t v20 = *(void *)(a2 + 40);
    uint64_t v23 = *(void *)(a2 + 48);
    uint64_t v19 = *(void *)(a2 + 32);
    goto LABEL_32;
  }
LABEL_50:
  int v34 = sub_1CBF2CB78(a2, v21);
  *(unsigned char *)(a2 + 70) = 1;
  int v35 = *(_DWORD *)(a2 + 32) - *(_DWORD *)(a2 + 48) + *(_DWORD *)(a2 + 40);
  unsigned int v36 = sub_1CD4525F4(a2, 9);
  int v37 = *(uint64_t **)(a2 + 56);
  if (*(void *)(a2 + 48) - (void)v37 <= 7uLL)
  {
    sub_1CBF2C904((uint64_t *)a2, 8uLL);
    int v37 = *(uint64_t **)(a2 + 56);
  }
  *int v37 = v36 | 0x400000000;
  uint64_t v38 = *(void *)(a2 + 56) + 8;
  *(void *)(a2 + 56) = v38;
  ++*(_DWORD *)(a2 + 64);
  unsigned int v39 = *(unsigned __int16 *)(a2 + 68);
  if (v39 <= 4) {
    LOWORD(v39) = 4;
  }
  *(_WORD *)(a2 + 68) = v39;
  if (v34)
  {
    if (*(void *)(a2 + 72) <= 3uLL) {
      *(void *)(a2 + 72) = 4;
    }
    uint64_t v40 = *(void *)(a2 + 40);
    uint64_t v41 = *(void *)(a2 + 48);
    uint64_t v42 = *(void *)(a2 + 32);
    unint64_t v43 = ((int)v41 - ((int)v42 + (int)v40)) & 3;
    if (v41 - v38 < v43)
    {
      sub_1CBF2C904((uint64_t *)a2, ((int)v41 - ((int)v42 + (int)v40)) & 3);
      *(void *)(a2 + 48) -= v43;
    }
    else
    {
      uint64_t v44 = v41 - v43;
      *(void *)(a2 + ++*(_DWORD *)(result + 48) = v41 - v43;
      if (!v43)
      {
LABEL_62:
        int v46 = v40 - v44 + v42 - v34 + 4;
        if (v40 - v44 + v42 - v34 == -4 && *(unsigned char *)(a2 + 80) == 0) {
          goto LABEL_80;
        }
        if (*(void *)(a2 + 72) <= 3uLL) {
          *(void *)(a2 + 72) = 4;
        }
        unint64_t v48 = ((_BYTE)v44 - ((_BYTE)v42 + (_BYTE)v40)) & 3;
        uint64_t v49 = *(uint64_t **)(a2 + 56);
        if (v44 - (uint64_t)v49 < v48)
        {
          sub_1CBF2C904((uint64_t *)a2, v48);
          *(void *)(a2 + 48) -= v48;
        }
        else
        {
          uint64_t v50 = v44 - v48;
          *(void *)(a2 + ++*(_DWORD *)(result + 48) = v44 - v48;
          if (!v48)
          {
LABEL_73:
            if ((unint64_t)(v50 - (void)v49) <= 3)
            {
              sub_1CBF2C904((uint64_t *)a2, 4uLL);
              uint64_t v50 = *(void *)(a2 + 48);
              uint64_t v49 = *(uint64_t **)(a2 + 56);
            }
            *(_DWORD *)(v50 - 4) = v46;
            uint64_t v52 = v50 - 4;
            *(void *)(a2 + ++*(_DWORD *)(result + 48) = v52;
            uint64_t v53 = *(void *)(a2 + 32) - v52 + *(void *)(a2 + 40);
            if ((unint64_t)(v52 - (void)v49) <= 7)
            {
              sub_1CBF2C904((uint64_t *)a2, 8uLL);
              uint64_t v49 = *(uint64_t **)(a2 + 56);
            }
            *uint64_t v49 = v53 | 0x1800000000;
            *(void *)(a2 + 56) += 8;
            ++*(_DWORD *)(a2 + 64);
            unsigned int v54 = *(unsigned __int16 *)(a2 + 68);
            if (v54 <= 0x18) {
              LOWORD(v54) = 24;
            }
            *(_WORD *)(a2 + 68) = v54;
            goto LABEL_80;
          }
        }
        uint64_t v51 = 0;
        do
          *(unsigned char *)(*(void *)(a2 + 48) + v51++) = 0;
        while (v48 != v51);
        uint64_t v50 = *(void *)(a2 + 48);
        uint64_t v49 = *(uint64_t **)(a2 + 56);
        goto LABEL_73;
      }
    }
    uint64_t v45 = 0;
    do
      *(unsigned char *)(*(void *)(a2 + 48) + v45++) = 0;
    while (v43 != v45);
    uint64_t v40 = *(void *)(a2 + 40);
    uint64_t v44 = *(void *)(a2 + 48);
    uint64_t v42 = *(void *)(a2 + 32);
    goto LABEL_62;
  }
LABEL_80:
  unsigned int v55 = sub_1CBF2CB78(a2, v35);
  if (v5) {
    operator delete(v5);
  }
  return v55 | 0x100000000;
}

uint64_t sub_1CBF33588(uint64_t a1)
{
  *(void *)a1 = &unk_1F25FEFC8;
  unsigned int v2 = *(void **)(a1 + 144);
  if (v2 != (void *)(a1 + 160)) {
    free(v2);
  }
  *(void *)(a1 + 72) = &unk_1F2646B98;
  if (*(_DWORD *)(a1 + 128) == 1)
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8077774924);
    }
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  return a1;
}

void sub_1CBF33638(uint64_t a1)
{
  *(void *)a1 = &unk_1F25FEFC8;
  unsigned int v2 = *(void **)(a1 + 144);
  if (v2 != (void *)(a1 + 160)) {
    free(v2);
  }
  *(void *)(a1 + 72) = &unk_1F2646B98;
  if (*(_DWORD *)(a1 + 128) == 1)
  {
    uint64_t v3 = *(void *)(a1 + 88);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8077774924);
    }
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CBF33708()
{
  return "AGX3InstructionInfoView";
}

uint64_t sub_1CBF33718(uint64_t result, unint64_t a2, long long *a3)
{
  if (*(unsigned int *)(result + 12) < a2)
  {
    *(_DWORD *)(result + 8) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v4 = (_DWORD *)(result + 8);
  unint64_t v3 = *(unsigned int *)(result + 8);
  if (v3 >= a2) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = *(unsigned int *)(result + 8);
  }
  if (v5)
  {
    uint64_t v6 = *(_OWORD **)result;
    do
    {
      long long v7 = *a3;
      *(_OWORD *)((char *)v6 + 12) = *(long long *)((char *)a3 + 12);
      *uint64_t v6 = v7;
      uint64_t v6 = (_OWORD *)((char *)v6 + 28);
      --v5;
    }
    while (v5);
    unint64_t v3 = *v4;
  }
  unint64_t v8 = v3 - a2;
  if (v3 < a2)
  {
    unint64_t v9 = (_OWORD *)(*(void *)result + 28 * v3);
    do
    {
      long long v10 = *a3;
      *(_OWORD *)((char *)v9 + 12) = *(long long *)((char *)a3 + 12);
      *unint64_t v9 = v10;
      unint64_t v9 = (_OWORD *)((char *)v9 + 28);
    }
    while (!__CFADD__(v8++, 1));
  }
  *uint64_t v4 = a2;
  return result;
}

uint64_t sub_1CBF33818()
{
  uint64_t v0 = sub_1CB883A14((uint64_t)&qword_1EBCC29D8, 0, 0);
  byte_1EBCC2A58 = 0;
  qword_1EBCC2A60 = (uint64_t)&unk_1F25EDE58;
  unk_1EBCC2A68 = 0;
  qword_1EBCC29D8 = (uint64_t)&unk_1F26440A0;
  qword_1EBCC2A70 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCC2A78 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCC2A90 = (uint64_t)&qword_1EBCC2A78;
  llvm::cl::Option::setArgStr(v0, "agx3-instr-info-include-opcode", 0x1EuLL);
  qword_1EBCC29F8 = (uint64_t)"Include opcode in AGX Instr Info view";
  unk_1EBCC2A00 = 37;
  word_1EBCC29E2 = word_1EBCC29E2 & 0xFF9F | 0x20;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC29D8);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCC29D8, &dword_1CB82C000);
  sub_1CB883A14((uint64_t)&qword_1EBCC2A98, 0, 0);
  byte_1EBCC2B18 = 0;
  qword_1EBCC2B20 = (uint64_t)&unk_1F25EDE58;
  unk_1EBCC2B28 = 0;
  qword_1EBCC2A98 = (uint64_t)&unk_1F26440A0;
  qword_1EBCC2B30 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCC2B38 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCC2B50 = (uint64_t)&qword_1EBCC2B38;
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCC2A98, "agx3-instr-info-include-full-strings", 0x24uLL);
  qword_1EBCC2AB8 = (uint64_t)"Don't abbreviate columns";
  unk_1EBCC2AC0 = 24;
  word_1EBCC2AA2 = word_1EBCC2AA2 & 0xFF9F | 0x20;
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC2A98);

  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCC2A98, &dword_1CB82C000);
}

uint64_t sub_1CBF33A28(uint64_t a1, unsigned __int16 *a2)
{
  unsigned int v3 = sub_1CBDA6464(*a2, 0x2Eu);
  if (v3 == -1) {
    return 0;
  }
  else {
    return *(unsigned __int8 *)(*((void *)a2 + 2) + 16 * v3 + 11);
  }
}

uint64_t sub_1CBF33A70(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2 = *((unsigned int *)a2 + 6);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = 0;
  int v4 = word_1CDF69038[*a2];
  unint64_t v5 = (_DWORD *)(*((void *)a2 + 2) + 8);
  do
  {
    if (byte_1CDF6D8C0[v4])
    {
      int v6 = (*v5 >> 20) & 0xF;
      if (v6)
      {
        uint64_t v7 = 1 << (v6 - 1);
        **(void **)(a1 + 200) |= v7;
        v3 |= v7;
      }
    }
    ++v4;
    v5 += 4;
    --v2;
  }
  while (v2);
  return v3;
}

unint64_t sub_1CBF33AF0(unint64_t result, unsigned int *a2)
{
  unint64_t v3 = result;
  unint64_t v4 = *a2;
  if ((*(void *)(*(void *)(result + 200) + ((v4 >> 3) & 0x1FFFFFF8)) >> v4))
  {
    unint64_t v5 = *(void *)(result + 184);
  }
  else
  {
    unint64_t v5 = *(void *)(result + 184);
    unint64_t v6 = v5;
    while (v6 != *(void *)(result + 176))
    {
      int v7 = *(_DWORD *)(v6 - 80);
      v6 -= 80;
      if (v7 == v4)
      {
        uint64_t v8 = a2[10];
        if (v8)
        {
          uint64_t v9 = *((void *)a2 + 4);
          uint64_t v10 = v9 + 32 * v8;
          unsigned int v11 = *(_DWORD *)(v6 + 40);
          do
          {
            uint64_t v12 = *(void *)(v9 + 8);
            uint64_t v13 = *(void *)(v9 + 16);
            int v14 = *(_DWORD *)(v9 + 24);
            if (v11 >= *(_DWORD *)(v6 + 44))
            {
              v18[0] = *(void *)v9;
              v18[1] = v12;
              v18[2] = v13;
              int v19 = v14;
              uint64_t result = sub_1CB8968D4(v6 + 32, (unint64_t)v18, 1);
              uint64_t v16 = (_OWORD *)(*(void *)(v6 + 32) + 32 * *(unsigned int *)(v6 + 40));
              long long v17 = *(_OWORD *)(result + 16);
              *uint64_t v16 = *(_OWORD *)result;
              v16[1] = v17;
            }
            else
            {
              uint64_t v15 = *(void *)(v6 + 32) + 32 * v11;
              *(void *)uint64_t v15 = *(void *)v9;
              *(void *)(v15 + 8) = v12;
              *(void *)(v15 + 16) = v13;
              *(_DWORD *)(v15 + 24) = v14;
            }
            unsigned int v11 = *(_DWORD *)(v6 + 40) + 1;
            *(_DWORD *)(v6 + 40) = v11;
            v9 += 32;
          }
          while (v9 != v10);
        }
        return result;
      }
    }
  }
  if (v5 >= *(void *)(result + 192))
  {
    uint64_t result = (unint64_t)sub_1CBF33EA0((void **)(result + 176), (uint64_t)a2);
  }
  else
  {
    *(_DWORD *)unint64_t v5 = v4;
    *(void *)(v5 + 16) = 0;
    *(void *)(v5 + 24) = 0;
    *(void *)(v5 + 8) = 0;
    sub_1CBF340A8((void *)(v5 + 8), *((unsigned char **)a2 + 1), *((unsigned char **)a2 + 2), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a2 + 2) - *((void *)a2 + 1)) >> 3));
    *(void *)(v5 + 32) = v5 + 48;
    *(void *)(v5 + 40) = 0x100000000;
    if (a2[10]) {
      sub_1CBF3415C((uint64_t *)(v5 + 32), (uint64_t *)a2 + 4);
    }
    uint64_t result = v5 + 80;
  }
  *(void *)(v3 + 184) = result;
  *(void *)(*(void *)(v3 + 200) + (((unint64_t)*a2 >> 3) & 0x1FFFFFF8)) &= ~(1 << *a2);
  return result;
}

uint64_t sub_1CBF33C94(uint64_t a1)
{
  *(void *)a1 = &unk_1F25FF080;
  uint64_t v2 = *(void **)(a1 + 200);
  if (v2 != (void *)(a1 + 216)) {
    free(v2);
  }
  *(void *)a1 = &unk_1F2649358;
  unint64_t v5 = (void **)(a1 + 176);
  sub_1CBF2DA1C(&v5);
  unint64_t v5 = (void **)(a1 + 152);
  sub_1CBF2DA1C(&v5);
  *(void *)(a1 + 80) = &unk_1F2646B98;
  if (*(_DWORD *)(a1 + 136) == 1)
  {
    uint64_t v4 = *(void *)(a1 + 96);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8077774924);
    }
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  return a1;
}

uint64_t sub_1CBF33D88(uint64_t a1)
{
  *(void *)a1 = &unk_1F25FF080;
  uint64_t v2 = *(void **)(a1 + 200);
  if (v2 != (void *)(a1 + 216)) {
    free(v2);
  }
  *(void *)a1 = &unk_1F2649358;
  unint64_t v5 = (void **)(a1 + 176);
  sub_1CBF2DA1C(&v5);
  unint64_t v5 = (void **)(a1 + 152);
  sub_1CBF2DA1C(&v5);
  *(void *)(a1 + 80) = &unk_1F2646B98;
  if (*(_DWORD *)(a1 + 136) == 1)
  {
    uint64_t v4 = *(void *)(a1 + 96);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8077774924);
    }
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  return MEMORY[0x1D25D9CE0](a1, 0x10F3C4080A2E7AFLL);
}

const char *sub_1CBF33E90()
{
  return "AGX3WaitView";
}

char *sub_1CBF33EA0(void **a1, uint64_t a2)
{
  unint64_t v2 = 0xCCCCCCCCCCCCCCCDLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 4);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x333333333333333) {
    abort();
  }
  if (0x999999999999999ALL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4) > v3) {
    unint64_t v3 = 0x999999999999999ALL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4);
  }
  if (0xCCCCCCCCCCCCCCCDLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 4) >= 0x199999999999999) {
    unint64_t v6 = 0x333333333333333;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0x333333333333333) {
      sub_1CB833614();
    }
    int v7 = (char *)operator new(80 * v6);
  }
  else
  {
    int v7 = 0;
  }
  uint64_t v8 = &v7[80 * v2];
  *(_DWORD *)uint64_t v8 = *(_DWORD *)a2;
  *((void *)v8 + 2) = 0;
  *((void *)v8 + 3) = 0;
  *((void *)v8 + 1) = 0;
  sub_1CBF340A8((void *)v8 + 1, *(unsigned char **)(a2 + 8), *(unsigned char **)(a2 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 3));
  *((void *)v8 + 4) = v8 + 48;
  *((void *)v8 + 5) = 0x100000000;
  if (*(_DWORD *)(a2 + 40)) {
    sub_1CBF3415C((uint64_t *)v8 + 4, (uint64_t *)(a2 + 32));
  }
  uint64_t v9 = &v7[80 * v6];
  uint64_t v10 = v8 + 80;
  uint64_t v12 = (char *)*a1;
  unsigned int v11 = (char *)a1[1];
  if (v11 == *a1)
  {
    *a1 = v8;
    a1[1] = v10;
    a1[2] = v9;
    if (!v11) {
      return v8 + 80;
    }
    goto LABEL_26;
  }
  uint64_t v13 = 0;
  do
  {
    int v14 = &v8[v13];
    uint64_t v15 = &v11[v13];
    *((_DWORD *)v14 - 20) = *(_DWORD *)&v11[v13 - 80];
    *((void *)v14 - 8) = 0;
    *((void *)v14 - 7) = 0;
    *((void *)v14 - 9) = 0;
    *(_OWORD *)(v14 - 72) = *(_OWORD *)&v11[v13 - 72];
    *((void *)v14 - 7) = *(void *)&v11[v13 - 56];
    *((void *)v15 - 9) = 0;
    *((void *)v15 - 8) = 0;
    *((void *)v15 - 7) = 0;
    *((void *)v14 - 6) = &v8[v13 - 32];
    *(void *)&v8[v13 - 40] = 0x100000000;
    if (*(_DWORD *)&v11[v13 - 40]) {
      sub_1CBF34284((uint64_t)&v8[v13 - 48], (uint64_t *)v15 - 6);
    }
    v13 -= 80;
  }
  while (&v11[v13] != v12);
  unsigned int v11 = (char *)*a1;
  uint64_t v16 = (char *)a1[1];
  *a1 = &v8[v13];
  a1[1] = v10;
  a1[2] = v9;
  if (v16 != v11)
  {
    long long v17 = v16 - 32;
    do
    {
      uint64_t v18 = (char *)*((void *)v17 - 2);
      if (v17 != v18) {
        free(v18);
      }
      int v19 = (void *)*((void *)v17 - 5);
      if (v19)
      {
        *((void *)v17 - 4) = v19;
        operator delete(v19);
      }
      uint64_t v20 = v17 - 48;
      v17 -= 80;
    }
    while (v20 != v11);
  }
  if (v11) {
LABEL_26:
  }
    operator delete(v11);
  return v8 + 80;
}

void *sub_1CBF340A8(void *result, unsigned char *a2, unsigned char *a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    unint64_t v6 = result;
    uint64_t v7 = 3 * a4;
    uint64_t result = operator new(24 * a4);
    uint64_t v8 = result;
    *unint64_t v6 = result;
    v6[1] = result;
    v6[2] = &result[v7];
    if (a2 != a3)
    {
      size_t v9 = 24 * ((a3 - a2 - 24) / 0x18uLL) + 24;
      uint64_t result = memcpy(result, a2, v9);
      uint64_t v8 = (void *)((char *)v8 + v9);
    }
    v6[1] = v8;
  }
  return result;
}

uint64_t *sub_1CBF3415C(uint64_t *a1, uint64_t *a2)
{
  if (a1 != a2)
  {
    uint64_t v3 = *((unsigned int *)a2 + 2);
    uint64_t v4 = *((unsigned int *)a1 + 2);
    if (v4 >= v3)
    {
      if (v3)
      {
        uint64_t v5 = *a2;
        uint64_t v6 = *a2 + 32 * v3;
        uint64_t v7 = *a1;
        do
        {
          *(_DWORD *)uint64_t v7 = *(_DWORD *)v5;
          *(void *)(v7 + 8) = *(void *)(v5 + 8);
          uint64_t v8 = *(void *)(v5 + 16);
          *(_DWORD *)(v7 + 24) = *(_DWORD *)(v5 + 24);
          *(void *)(v7 + 16) = v8;
          v5 += 32;
          v7 += 32;
        }
        while (v5 != v6);
      }
    }
    else
    {
      if (*((_DWORD *)a1 + 3) < v3)
      {
        *((_DWORD *)a1 + 2) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v4)
      {
        uint64_t v9 = *a2;
        uint64_t v10 = *a2 + 32 * v4;
        uint64_t v11 = *a1;
        do
        {
          *(_DWORD *)uint64_t v11 = *(_DWORD *)v9;
          *(void *)(v11 + 8) = *(void *)(v9 + 8);
          uint64_t v12 = *(void *)(v9 + 16);
          *(_DWORD *)(v11 + 24) = *(_DWORD *)(v9 + 24);
          *(void *)(v11 + 16) = v12;
          v9 += 32;
          v11 += 32;
        }
        while (v9 != v10);
      }
      else
      {
        uint64_t v4 = 0;
      }
      uint64_t v13 = *((unsigned int *)a2 + 2);
      if (v4 != v13) {
        memcpy((void *)(*a1 + 32 * v4), (const void *)(*a2 + 32 * v4), *a2 + 32 * v13 - (*a2 + 32 * v4));
      }
    }
    *((_DWORD *)a1 + 2) = v3;
  }
  return a1;
}

uint64_t sub_1CBF34284(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v5 = a2 + 2;
    uint64_t v4 = *a2;
    if ((uint64_t *)*a2 == a2 + 2)
    {
      uint64_t v7 = a2 + 1;
      uint64_t v8 = *((unsigned int *)a2 + 2);
      uint64_t v9 = *(unsigned int *)(a1 + 8);
      if (v9 >= v8)
      {
        if (v8)
        {
          uint64_t v10 = v4 + 32 * v8;
          uint64_t v11 = *(void **)a1;
          do
          {
            *(_DWORD *)uint64_t v11 = *(_DWORD *)v4;
            v11[1] = *(void *)(v4 + 8);
            uint64_t v12 = *(void *)(v4 + 16);
            *((_DWORD *)v11 + 6) = *(_DWORD *)(v4 + 24);
            void v11[2] = v12;
            v4 += 32;
            v11 += 4;
          }
          while (v4 != v10);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v8)
        {
          *(_DWORD *)(a1 + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v9)
        {
          uint64_t v13 = v4 + 32 * v9;
          int v14 = *(void **)a1;
          do
          {
            *(_DWORD *)int v14 = *(_DWORD *)v4;
            v14[1] = *(void *)(v4 + 8);
            uint64_t v15 = *(void *)(v4 + 16);
            *((_DWORD *)v14 + 6) = *(_DWORD *)(v4 + 24);
            v14[2] = v15;
            v4 += 32;
            v14 += 4;
          }
          while (v4 != v13);
        }
        else
        {
          uint64_t v9 = 0;
        }
        uint64_t v16 = *v7;
        if (v9 != v16) {
          memcpy((void *)(*(void *)a1 + 32 * v9), (const void *)(*a2 + 32 * v9), *a2 + 32 * v16 - (*a2 + 32 * v9));
        }
      }
      *(_DWORD *)(a1 + 8) = v8;
    }
    else
    {
      uint64_t v6 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v6);
        uint64_t v4 = *a2;
      }
      *(void *)a1 = v4;
      uint64_t v7 = a2 + 1;
      *(void *)(a1 + 8) = a2[1];
      *a2 = (uint64_t)v5;
      *((_DWORD *)a2 + 3) = 0;
    }
    *uint64_t v7 = 0;
  }
  return a1;
}

uint64_t llvm::createAGCStatusReader@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  __int16 v10 = 261;
  v9[0] = a1;
  v9[1] = a2;
  llvm::MemoryBuffer::getFileOrSTDIN((llvm::MemoryBuffer *)v9, 0, 1, (uint64_t)&v11);
  if ((uint64_t)v12.__cat_)
  {
    uint64_t result = (uint64_t)v11;
    if (v11)
    {
      *(void *)&v4.__val_ = *(void *)&v12.__val_;
      uint64_t result = llvm::errorCodeToError(v11, v4, &v8);
      *(unsigned char *)(a3 + 192) |= 1u;
      *(void *)a3 = v8;
      return result;
    }
  }
  else
  {
    std::system_category();
    uint64_t result = (uint64_t)v11;
  }
  *(_WORD *)(a3 + 30) = 0;
  *(_DWORD *)(a3 + 26) = 0;
  *(void *)(a3 + 33) = 0;
  *(void *)(a3 + 40) = 0;
  *(_DWORD *)(a3 + 49) = 0;
  *(_DWORD *)(a3 + 52) = 0;
  *(_DWORD *)(a3 + 57) = 0;
  *(_DWORD *)(a3 + 60) = 0;
  *(_DWORD *)(a3 + 65) = 0;
  *(_DWORD *)(a3 + 68) = 0;
  *(void *)(a3 + 73) = 0;
  *(void *)(a3 + 80) = 0;
  *(_DWORD *)(a3 + 89) = 0;
  *(_DWORD *)(a3 + 92) = 0;
  uint64_t v6 = *(void *)(result + 8);
  uint64_t v7 = *(void *)(result + 16) - v6;
  *(unsigned char *)(a3 + 192) &= ~1u;
  *(void *)a3 = result;
  *(void *)(a3 + 8) = v6;
  *(void *)(a3 + 16) = v7;
  *(_WORD *)(a3 + 24) = 256;
  *(unsigned char *)(a3 + 32) = 0;
  *(unsigned char *)(a3 + ++*(_DWORD *)(result + 48) = 0;
  *(unsigned char *)(a3 + 56) = 0;
  *(unsigned char *)(a3 + 64) = 0;
  *(unsigned char *)(a3 + 72) = 0;
  *(unsigned char *)(a3 + 88) = 0;
  *(void *)(a3 + 96) = 0;
  *(void *)(a3 + 104) = 0;
  *(void *)(a3 + 112) = 0;
  *(void *)(a3 + 120) = "";
  *(void *)(a3 + 128) = 0;
  *(unsigned char *)(a3 + 136) = 0;
  *(_DWORD *)(a3 + 140) = -1;
  *(void *)(a3 + 144) = "";
  *(void *)(a3 + 152) = 0;
  *(_DWORD *)(a3 + 160) = 0;
  *(void *)(a3 + 168) = "";
  *(void *)(a3 + 176) = 0;
  *(_DWORD *)(a3 + 184) = 0;
  return result;
}

unint64_t llvm::AGCStatusReader::parseRecordWithFixedName@<X0>(void *__s2@<X1>, size_t __n@<X2>, unint64_t result@<X0>, uint64_t a4@<X3>, uint64_t a5@<X4>, int a6@<W5>, unsigned char *a7@<X8>)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  size_t v8 = *(void *)(result + 16);
  if (v8 < __n
    || (unint64_t v14 = result, v15 = (llvm *)(result + 8), v16 = *(void *)(result + 8), __n)
    && (uint64_t result = memcmp(*(const void **)(result + 8), __s2, __n), result))
  {
LABEL_4:
    a7[8] &= ~1u;
    *a7 = 1;
    return result;
  }
  if (v8 >= __n) {
    size_t v17 = __n;
  }
  else {
    size_t v17 = v8;
  }
  *(void *)(v14 + 8) = v16 + v17;
  *(void *)(v14 + 16) = v8 - v17;
  *(unsigned char *)(v14 + 136) = 1;
  sub_1CBF34874((uint64_t)&v35, (char *)(v16 + v17), v8 - v17, (void *)(v14 + 168));
  if ((v36 & 1) == 0)
  {
    sub_1CBF349B0((uint64_t)v32, " shader ", 8uLL, (char *)v35, *((size_t *)&v35 + 1));
    sub_1CD452A68(&v35, v32);
    if (v33)
    {
      unint64_t v20 = v32[0];
      v32[0] = 0;
      if (v20) {
        (*(void (**)(unint64_t))(*(void *)v20 + 8))(v20);
      }
    }
    if ((v36 & 1) == 0)
    {
      *(_OWORD *)uint64_t v15 = v35;
      v32[0] = 0;
      if (llvm::consumeSignedInteger(v15, (llvm::StringRef *)0xA, v32, v19) || v32[0] != SLODWORD(v32[0]))
      {
        __int16 v31 = 1283;
        v30[0] = "Expected integer in \"";
        v30[2] = __s2;
        v30[3] = __n;
        v32[0] = (unint64_t)v30;
        unsigned int v33 = "\" declaration\n";
        __int16 v34 = 770;
        std::generic_category();
        operator new();
      }
      *(_DWORD *)(v14 + 140) = v32[0];
      *(void *)(v14 + 144) = a4;
      *(void *)(v14 + 152) = a5;
      *(_DWORD *)(v14 + 160) = a6;
      unint64_t first_not_of = llvm::StringRef::find_first_not_of(v15, " \t\n\v\f\r", 6, 0);
      unint64_t v22 = *(void *)(v14 + 16);
      if (first_not_of >= v22) {
        unint64_t v23 = *(void *)(v14 + 16);
      }
      else {
        unint64_t v23 = first_not_of;
      }
      unint64_t v24 = *(void *)(v14 + 8) + v23;
      unint64_t v25 = v22 - v23;
      *(void *)(v14 + 8) = v24;
      *(void *)(v14 + 16) = v25;
      if (v22 <= first_not_of)
      {
LABEL_26:
        unint64_t v26 = -1;
      }
      else
      {
        unint64_t v26 = 0;
        while (*(unsigned char *)(v24 + v26) == 45)
        {
          if (v25 == ++v26) {
            goto LABEL_26;
          }
        }
      }
      if (v26 >= v25) {
        unint64_t v26 = v25;
      }
      unint64_t v27 = v24 + v26;
      unint64_t v28 = v25 - v26;
      *(void *)(v14 + 8) = v24 + v26;
      *(void *)(v14 + 16) = v25 - v26;
      uint64_t result = llvm::StringRef::find_first_not_of(v15, " \t\n\v\f\r", 6, 0);
      if (result >= v28) {
        unint64_t v29 = v28;
      }
      else {
        unint64_t v29 = result;
      }
      *(void *)(v14 + 8) = v27 + v29;
      *(void *)(v14 + 16) = v28 - v29;
      goto LABEL_4;
    }
  }
  uint64_t v18 = v35;
  *(void *)&long long v35 = 0;
  a7[8] |= 1u;
  *(void *)a7 = v18;
  uint64_t result = v35;
  *(void *)&long long v35 = 0;
  if (result) {
    return (*(uint64_t (**)(unint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

unint64_t sub_1CBF34874(uint64_t a1, char *__s, size_t __n, void *a4)
{
  v13[0] = (uint64_t)__s;
  v13[1] = __n;
  if (!__n || (size_t v8 = memchr(__s, 10, __n)) == 0 || (v9 = v8 - __s, v8 - __s == -1)) {
    unint64_t v9 = __n;
  }
  unint64_t result = llvm::StringRef::find(v13, " shader", 7uLL, 0);
  if (result == -1 || v9 < result)
  {
    std::generic_category();
    operator new();
  }
  if (__n >= result) {
    unint64_t v12 = result;
  }
  else {
    unint64_t v12 = __n;
  }
  *a4 = __s;
  a4[1] = v12;
  *(unsigned char *)(a1 + 16) &= ~1u;
  *(void *)(a1 + 8) = __n - v12;
  *(void *)a1 = &__s[v12];
  return result;
}

uint64_t sub_1CBF349B0(uint64_t result, void *__s2, size_t __n, char *__s1, size_t a5)
{
  uint64_t v9 = result;
  if (a5 < __n || __n && (unint64_t result = memcmp(__s1, __s2, __n), result))
  {
    __int16 v13 = 1283;
    v12[0] = "Expected \"";
    v12[2] = __s2;
    v12[3] = __n;
    v14[0] = v12;
    v14[2] = "\" at \"";
    __int16 v15 = 770;
    uint64_t v10 = 10;
    if (a5 < 0xA) {
      uint64_t v10 = a5;
    }
    v16[0] = v14;
    v16[2] = __s1;
    v16[3] = v10;
    __int16 v17 = 1282;
    uint64_t v18 = v16;
    uint64_t v19 = v10;
    unint64_t v20 = "\"\n";
    __int16 v21 = 770;
    std::generic_category();
    operator new();
  }
  if (a5 >= __n) {
    size_t v11 = __n;
  }
  else {
    size_t v11 = a5;
  }
  *(unsigned char *)(v9 + 16) &= ~1u;
  *(void *)uint64_t v9 = &__s1[v11];
  *(void *)(v9 + 8) = a5 - v11;
  return result;
}

uint64_t llvm::AGCStatusReader::parseRecordWithName@<X0>(void *__s2@<X1>, size_t __n@<X2>, uint64_t result@<X0>, int a4@<W3>, unsigned char *a5@<X8>)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  size_t v6 = *(void *)(result + 16);
  if (v6 < __n) {
    goto LABEL_4;
  }
  uint64_t v10 = result;
  size_t v11 = (llvm *)(result + 8);
  uint64_t v12 = *(void *)(result + 8);
  if (__n)
  {
    unint64_t result = memcmp(*(const void **)(result + 8), __s2, __n);
    if (result) {
      goto LABEL_4;
    }
  }
  if (v6 >= __n) {
    size_t v13 = __n;
  }
  else {
    size_t v13 = v6;
  }
  *(void *)(v10 + 8) = v12 + v13;
  *(void *)(v10 + 16) = v6 - v13;
  *(unsigned char *)(v10 + 136) = 1;
  unint64_t result = sub_1CBF34874((uint64_t)&v32, (char *)(v12 + v13), v6 - v13, (void *)(v10 + 168));
  if ((v33 & 1) == 0)
  {
    sub_1CBF349B0((uint64_t)v29, " shader ", 8uLL, (char *)v32, *((size_t *)&v32 + 1));
    unint64_t result = (uint64_t)sub_1CD452A68(&v32, v29);
    if (v30)
    {
      unint64_t result = v29[0];
      v29[0] = 0;
      if (result) {
        unint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
    }
    if ((v33 & 1) == 0)
    {
      *(_OWORD *)size_t v11 = v32;
      v29[0] = 0;
      if (llvm::consumeSignedInteger(v11, (llvm::StringRef *)0xA, v29, v15)
        || (int v16 = v29[0], v29[0] != SLODWORD(v29[0])))
      {
        __int16 v28 = 1283;
        v27[0] = "Expected integer in \"";
        v27[2] = __s2;
        v27[3] = __n;
        v29[0] = (unint64_t)v27;
        uint64_t v30 = "\" declaration\n";
        __int16 v31 = 770;
        std::generic_category();
        operator new();
      }
      sub_1CBF349B0((uint64_t)v29, " (", 2uLL, *(char **)(v10 + 8), *(void *)(v10 + 16));
      unint64_t result = (uint64_t)sub_1CD452A68(&v32, v29);
      if (v30)
      {
        unint64_t result = v29[0];
        v29[0] = 0;
        if (result) {
          unint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
        }
      }
      if ((v33 & 1) == 0)
      {
        *(_OWORD *)size_t v11 = v32;
        size_t v17 = *(void *)(v10 + 16);
        uint64_t v18 = (char *)v17;
        if (v17)
        {
          uint64_t v19 = *(void **)v11;
          unint64_t v20 = (char *)memchr(*(void **)v11, 41, v17);
          if (v20 && v20 - (unsigned char *)v19 != -1)
          {
            *(_DWORD *)(v10 + 140) = v16;
            if (v17 >= v20 - (unsigned char *)v19) {
              uint64_t v18 = (char *)(v20 - (unsigned char *)v19);
            }
            else {
              uint64_t v18 = (char *)v17;
            }
LABEL_30:
            *(void *)(v10 + 144) = v19;
            *(void *)(v10 + 152) = v18;
            *(void *)(v10 + 8) = &v18[(void)v19];
            *(void *)(v10 + 16) = v17 - (void)v18;
            sub_1CBF349B0((uint64_t)v29, ") -", 3uLL, &v18[(void)v19], v17 - (void)v18);
            unint64_t result = (uint64_t)sub_1CD452A68(&v32, v29);
            if (v30)
            {
              unint64_t result = v29[0];
              v29[0] = 0;
              if (result) {
                unint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
              }
            }
            if (v33) {
              goto LABEL_9;
            }
            *(_OWORD *)size_t v11 = v32;
            uint64_t v22 = *(void *)(v10 + 8);
            unint64_t v21 = *(void *)(v10 + 16);
            if (v21)
            {
              unint64_t v23 = 0;
              while (*(unsigned char *)(v22 + v23) == 45)
              {
                if (v21 == ++v23) {
                  goto LABEL_38;
                }
              }
              if (v23 >= v21) {
                unint64_t v26 = *(void *)(v10 + 16);
              }
              else {
                unint64_t v26 = v23;
              }
              unint64_t v25 = (char *)(v22 + v26);
              size_t v24 = v21 - v26;
              *(void *)(v10 + 8) = v22 + v26;
              *(void *)(v10 + 16) = v21 - v26;
              if (v21 <= v23 || *v25 != 13)
              {
LABEL_46:
                sub_1CBF349B0((uint64_t)v29, "\n", 1uLL, v25, v24);
                unint64_t result = (uint64_t)sub_1CD452A68(&v32, v29);
                if (v30)
                {
                  unint64_t result = v29[0];
                  v29[0] = 0;
                  if (result) {
                    unint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
                  }
                }
                if ((v33 & 1) == 0)
                {
                  *(_OWORD *)size_t v11 = v32;
                  *(_DWORD *)(v10 + 160) = a4;
LABEL_4:
                  a5[8] &= ~1u;
                  *a5 = 1;
                  return result;
                }
                goto LABEL_9;
              }
              ++v25;
              --v24;
            }
            else
            {
LABEL_38:
              size_t v24 = 0;
              unint64_t v25 = (char *)(v22 + v21);
            }
            *(void *)(v10 + 8) = v25;
            *(void *)(v10 + 16) = v24;
            goto LABEL_46;
          }
        }
        else
        {
          uint64_t v19 = *(void **)v11;
        }
        *(_DWORD *)(v10 + 140) = v16;
        goto LABEL_30;
      }
    }
  }
LABEL_9:
  uint64_t v14 = v32;
  a5[8] |= 1u;
  *(void *)a5 = v14;
  return result;
}

unint64_t llvm::AGCStatusReader::getNextRecord@<X0>(llvm::AGCStatusReader *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = *((void *)this + 2);
  *((unsigned char *)this + 24) = v4 != 0;
  uint64_t v5 = (llvm::AGCStatusReader *)((char *)this + 24);
  ++*((_DWORD *)this + 46);
  if (v4)
  {
    size_t v6 = (uint64_t *)((char *)this + 8);
    unint64_t v7 = v4 - 28;
    if (v4 >= 0x1C)
    {
      size_t v8 = (void *)*v6;
      BOOL v9 = *(void *)*v6 == 0x43202D2D2D2D2D2DLL && *(void *)(*v6 + 8) == 0x676E696C69706D6FLL;
      BOOL v10 = v9 && *(void *)(*v6 + 16) == 0x6F6974636E756620;
      if (v10 && *(_DWORD *)(*v6 + 24) == 540680302)
      {
        int v16 = (char *)v8 + 28;
        *((void *)this + 1) = (char *)v8 + 28;
        *((void *)this + 2) = v7;
        if (v4 < 0x1D
          || ((size_t v17 = (char *)memchr((char *)v8 + 28, 32, v4 - 28), v18 = (char *)(v17 - v16), v17)
            ? (BOOL v19 = v18 + 1 == 0)
            : (BOOL v19 = 1),
              v19))
        {
          uint64_t v18 = (char *)v7;
        }
        *((unsigned char *)this + 136) = 1;
        if (v7 < (unint64_t)v18) {
          uint64_t v18 = (char *)v7;
        }
        *((void *)this + 1) = &v18[(void)v16];
        *((void *)this + 2) = v7 - (void)v18;
        unint64_t result = sub_1CBF349B0((uint64_t)&v59, " ------", 7uLL, &v18[(void)v16], v7 - (void)v18);
        if (v60) {
          goto LABEL_32;
        }
        *(_OWORD *)size_t v6 = v59;
        size_t v21 = *((void *)this + 2);
        if (v21)
        {
          uint64_t v22 = (char *)*v6;
          if (*(unsigned char *)*v6 == 13)
          {
            ++v22;
            --v21;
            *((void *)this + 1) = v22;
            *((void *)this + 2) = v21;
          }
        }
        else
        {
          uint64_t v22 = (char *)*v6;
        }
        sub_1CBF349B0((uint64_t)v67, "\n", 1uLL, v22, v21);
        unint64_t result = (unint64_t)sub_1CD452A68(&v59, v67);
        if (v68)
        {
          unint64_t result = v67[0];
          v67[0] = 0;
          if (result) {
            unint64_t result = (*(uint64_t (**)(unint64_t))(*(void *)result + 8))(result);
          }
        }
        if (v60)
        {
LABEL_32:
          uint64_t v20 = v59;
          *(unsigned char *)(a2 + 112) |= 1u;
          *(void *)a2 = v20;
          return result;
        }
        *(_OWORD *)size_t v6 = v59;
      }
    }
    unint64_t result = llvm::AGCStatusReader::parseRecordWithFixedName("------ Compilation flags for ", 0x1DuLL, (unint64_t)this, (uint64_t)"compile_flags", 13, 7, &v71);
    if (v72) {
      goto LABEL_14;
    }
    llvm::AGCStatusReader::parseRecordWithFixedName("------ Start compilation key description for ", 0x2DuLL, (unint64_t)this, (uint64_t)"compile_key_desc", 16, 8, &v59);
    unint64_t result = (unint64_t)sub_1CD452AF8(&v71, &v59);
    if (BYTE8(v59))
    {
      unint64_t result = v59;
      *(void *)&long long v59 = 0;
      if (result) {
        unint64_t result = (*(uint64_t (**)(unint64_t))(*(void *)result + 8))(result);
      }
    }
    if (v72) {
      goto LABEL_14;
    }
    llvm::AGCStatusReader::parseRecordWithFixedName("------ Start Translator Metadata ", 0x21uLL, (unint64_t)this, (uint64_t)"translator_metadata", 19, 9, &v59);
    unint64_t result = (unint64_t)sub_1CD452AF8(&v71, &v59);
    if (BYTE8(v59))
    {
      unint64_t result = v59;
      *(void *)&long long v59 = 0;
      if (result) {
        unint64_t result = (*(uint64_t (**)(unint64_t))(*(void *)result + 8))(result);
      }
    }
    if (v72) {
      goto LABEL_14;
    }
    llvm::AGCStatusReader::parseRecordWithFixedName("------ Start Target Translator Metadata ", 0x28uLL, (unint64_t)this, (uint64_t)"target_translator_metadata", 26, 10, &v59);
    unint64_t result = (unint64_t)sub_1CD452AF8(&v71, &v59);
    if (BYTE8(v59))
    {
      unint64_t result = v59;
      *(void *)&long long v59 = 0;
      if (result) {
        unint64_t result = (*(uint64_t (**)(unint64_t))(*(void *)result + 8))(result);
      }
    }
    if (v72) {
      goto LABEL_14;
    }
    llvm::AGCStatusReader::parseRecordWithName("------ Start Graphics ", 0x16uLL, (uint64_t)this, 1, &v59);
    unint64_t result = (unint64_t)sub_1CD452AF8(&v71, &v59);
    if (BYTE8(v59))
    {
      unint64_t result = v59;
      *(void *)&long long v59 = 0;
      if (result) {
        unint64_t result = (*(uint64_t (**)(unint64_t))(*(void *)result + 8))(result);
      }
    }
    if (v72) {
      goto LABEL_14;
    }
    llvm::AGCStatusReader::parseRecordWithName("------ Start LLVM IR ", 0x15uLL, (uint64_t)this, 2, &v59);
    unint64_t result = (unint64_t)sub_1CD452AF8(&v71, &v59);
    if (BYTE8(v59))
    {
      unint64_t result = v59;
      *(void *)&long long v59 = 0;
      if (result) {
        unint64_t result = (*(uint64_t (**)(unint64_t))(*(void *)result + 8))(result);
      }
    }
    if (v72) {
      goto LABEL_14;
    }
    llvm::AGCStatusReader::parseRecordWithName("------ Start USC ", 0x11uLL, (uint64_t)this, 4, &v59);
    unint64_t result = (unint64_t)sub_1CD452AF8(&v71, &v59);
    if (BYTE8(v59))
    {
      unint64_t result = v59;
      *(void *)&long long v59 = 0;
      if (result) {
        unint64_t result = (*(uint64_t (**)(unint64_t))(*(void *)result + 8))(result);
      }
    }
    if (v72)
    {
LABEL_14:
      unint64_t v13 = v71;
      unint64_t v71 = 0;
      *(unsigned char *)(a2 + 112) |= 1u;
      *(void *)a2 = v13;
    }
    else
    {
      uint64_t v23 = *((void *)this + 1);
      unint64_t v24 = *((void *)this + 2);
      *(void *)&long long v59 = v23;
      *((void *)&v59 + 1) = v24;
      uint64_t v25 = llvm::StringRef::find((uint64_t *)&v59, "------ Start", 0xCuLL, 0);
      uint64_t v26 = llvm::StringRef::find((uint64_t *)&v59, "------ End", 0xAuLL, 0);
      if ((unint64_t)(v26 - 1) > 0xFFFFFFFFFFFFFFFDLL)
      {
        if (v26 == -1) {
          unint64_t v27 = v24;
        }
        else {
          unint64_t v27 = 0;
        }
      }
      else if (*(unsigned char *)(v23 + v26 - 1) == 45)
      {
        unint64_t v27 = v26 - 1;
      }
      else
      {
        unint64_t v27 = v26;
      }
      uint64_t v28 = llvm::StringRef::find((uint64_t *)&v59, "------ Compiling function : ", 0x1CuLL, 0);
      if (v28 == -1) {
        unint64_t v29 = v24;
      }
      else {
        unint64_t v29 = v28;
      }
      if (v25 == -1) {
        unint64_t v30 = v24;
      }
      else {
        unint64_t v30 = v25;
      }
      if (v29 >= v27) {
        unint64_t v29 = v27;
      }
      if (v29 >= v30) {
        unint64_t v31 = v30;
      }
      else {
        unint64_t v31 = v29;
      }
      if (!v31)
      {
        LOBYTE(v59) = 10;
        unint64_t v37 = llvm::StringRef::find(v6, (char *)&v59, 1uLL, 0);
        __int16 v70 = 1283;
        if (v24 >= v37) {
          unint64_t v38 = v37;
        }
        else {
          unint64_t v38 = v24;
        }
        if (v37 == -1) {
          unint64_t v38 = v24;
        }
        v67[0] = "Unexpected \"------ Start\" or \"------ End\"\nNear ";
        uint64_t v68 = v23;
        unint64_t v69 = v38;
        *(void *)&long long v59 = v67;
        *(void *)&long long v60 = "\n";
        LOWORD(v61) = 770;
        std::generic_category();
        operator new();
      }
      if (v24 >= v31) {
        unint64_t v32 = v31;
      }
      else {
        unint64_t v32 = v24;
      }
      *((void *)this + 15) = v23;
      char v33 = (long long *)((char *)this + 120);
      *((void *)this + 16) = v32;
      llvm::AGCStatusReader::computeMetadata(this, v5);
      long long v34 = *((_OWORD *)v5 + 3);
      long long v61 = *((_OWORD *)v5 + 2);
      long long v62 = v34;
      uint64_t v63 = *((void *)v5 + 8);
      long long v35 = *((_OWORD *)v5 + 1);
      long long v59 = *(_OWORD *)v5;
      long long v60 = v35;
      char v36 = (void **)((char *)this + 96);
      if (*((char *)this + 119) < 0)
      {
        sub_1CB8BDF7C((uint64_t)&v64, *((const void **)this + 12), *((void *)this + 13));
        int v39 = *((char *)this + 119);
        long long v66 = *v33;
        *((_WORD *)this + 12) = 256;
        *(_OWORD *)((char *)this + 26) = 0u;
        *(_OWORD *)((char *)this + 42) = 0u;
        *(_OWORD *)((char *)this + 58) = 0u;
        *(_OWORD *)((char *)this + 74) = 0u;
        *((void *)this + 11) = 0;
        if (v39 < 0) {
          operator delete(*v36);
        }
      }
      else
      {
        long long v64 = *(_OWORD *)v36;
        uint64_t v65 = *((void *)this + 14);
        long long v66 = *v33;
        *((_WORD *)this + 12) = 256;
        *(_OWORD *)((char *)this + 26) = 0u;
        *(_OWORD *)((char *)this + 42) = 0u;
        *(_OWORD *)((char *)this + 58) = 0u;
        *(_OWORD *)((char *)this + 74) = 0u;
        *((void *)this + 11) = 0;
      }
      char v40 = 0;
      uint64_t v41 = 0;
      *char v36 = 0;
      *((void *)this + 13) = 0;
      *((void *)this + 14) = 0;
      *((void *)this + 15) = "";
      *((void *)this + 16) = 0;
      uint64_t v43 = *((void *)this + 1);
      unint64_t v42 = *((void *)this + 2);
      if (v42 >= v31) {
        unint64_t v44 = v31;
      }
      else {
        unint64_t v44 = *((void *)this + 2);
      }
      uint64_t v45 = (char *)(v43 + v44);
      unint64_t v46 = v42 - v44;
      *((void *)this + 1) = v43 + v44;
      *((void *)this + 2) = v42 - v44;
      v67[0] = "------ End";
      v67[1] = "------- End";
      do
      {
        char v47 = v40;
        unint64_t v48 = (const void *)v67[v41];
        if (!v48
          || (unint64_t result = strlen((const char *)v67[v41]), v46 >= result)
          && (!result || (unint64_t result = memcmp(v45, v48, result), !result)))
        {
          char v58 = 10;
          uint64_t v49 = llvm::StringRef::find(v6, &v58, 1uLL, 0);
          unint64_t v50 = v49 + 1;
          if (v46 < v49 + 1) {
            unint64_t v50 = v46;
          }
          if (v49 == -1) {
            uint64_t v51 = 0;
          }
          else {
            uint64_t v51 = &v45[v50];
          }
          unint64_t v52 = v46 - v50;
          if (v49 == -1) {
            unint64_t v53 = 0;
          }
          else {
            unint64_t v53 = v52;
          }
          *((void *)this + 1) = v51;
          *((void *)this + 2) = v53;
          unint64_t result = llvm::StringRef::find_first_not_of(v6, " \t\n\v\f\r", 6, 0);
          if (result >= v53) {
            unint64_t v54 = v53;
          }
          else {
            unint64_t v54 = result;
          }
          uint64_t v45 = &v51[v54];
          unint64_t v46 = v53 - v54;
          *((void *)this + 1) = v45;
          *((void *)this + 2) = v53 - v54;
        }
        char v40 = 1;
        uint64_t v41 = 1;
      }
      while ((v47 & 1) == 0);
      *((void *)this + 18) = "";
      *((void *)this + 19) = 0;
      *((_DWORD *)this + 40) = 5;
      *((void *)this + 21) = "";
      *((void *)this + 22) = 0;
      *(unsigned char *)(a2 + 112) &= ~1u;
      long long v55 = v62;
      *(_OWORD *)(a2 + 32) = v61;
      *(_OWORD *)(a2 + ++*(_DWORD *)(result + 48) = v55;
      *(void *)(a2 + 64) = v63;
      long long v56 = v60;
      *(_OWORD *)a2 = v59;
      *(_OWORD *)(a2 + 16) = v56;
      long long v57 = v64;
      *(void *)(a2 + 88) = v65;
      *(_OWORD *)(a2 + 72) = v57;
      *(_OWORD *)(a2 + 96) = v66;
    }
    if (v72)
    {
      unint64_t result = v71;
      unint64_t v71 = 0;
      if (result) {
        return (*(uint64_t (**)(unint64_t))(*(void *)result + 8))(result);
      }
    }
  }
  else
  {
    *(unsigned char *)(a2 + 112) &= ~1u;
    long long v14 = *(_OWORD *)((char *)this + 72);
    *(_OWORD *)(a2 + 32) = *(_OWORD *)((char *)this + 56);
    *(_OWORD *)(a2 + ++*(_DWORD *)(result + 48) = v14;
    *(void *)(a2 + 64) = *((void *)this + 11);
    long long v15 = *(_OWORD *)((char *)this + 40);
    *(_OWORD *)a2 = *(_OWORD *)v5;
    *(_OWORD *)(a2 + 16) = v15;
    unint64_t result = a2 + 72;
    if (*((char *)this + 119) < 0)
    {
      unint64_t result = (unint64_t)sub_1CB8BDF7C(result, *((const void **)this + 12), *((void *)this + 13));
    }
    else
    {
      *(_OWORD *)unint64_t result = *((_OWORD *)this + 6);
      *(void *)(a2 + 88) = *((void *)this + 14);
    }
    *(_OWORD *)(a2 + 96) = *(_OWORD *)((char *)this + 120);
  }
  return result;
}

void llvm::AGCStatusReader::computeMetadata(llvm::AGCStatusReader *this, llvm::AGCStatusRecord *a2)
{
  uint64_t v4 = *((int *)this + 35);
  if (v4 != -1)
  {
    int v5 = *((unsigned __int8 *)this + 64);
    *((void *)this + 7) = v4;
    if (!v5) {
      *((unsigned char *)this + 64) = 1;
    }
  }
  long long v6 = *(_OWORD *)((char *)this + 168);
  if (!*((unsigned char *)this + 48)) {
    *((unsigned char *)this + ++*(_DWORD *)(result + 48) = 1;
  }
  *((_OWORD *)this + 2) = v6;
  size_t v7 = *((void *)this + 19);
  if (!v7)
  {
    if (*((unsigned char *)this + 136))
    {
      std::to_string(&v46, v4);
      BOOL v10 = std::string::append(&v46, "/anonymous_");
      std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v47.__r_.__value_.__l.__data_ = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
      v47.__r_.__value_.__r.__words[2] = v11;
      v10->__r_.__value_.__l.__size_ = 0;
      v10->__r_.__value_.__r.__words[2] = 0;
      v10->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v45, *((_DWORD *)this + 46));
      if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v12 = &v45;
      }
      else {
        uint64_t v12 = (std::string *)v45.__r_.__value_.__r.__words[0];
      }
      if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = *((unsigned char *)&v45.__r_.__value_.__s + 23) & 0x7F;
      }
      else {
        std::string::size_type size = v45.__r_.__value_.__l.__size_;
      }
      long long v14 = std::string::append(&v47, (const std::string::value_type *)v12, size);
      std::string::size_type v15 = v14->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v48.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
      v48.__r_.__value_.__r.__words[2] = v15;
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      int v16 = std::string::append(&v48, ".");
      std::string::size_type v17 = v16->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
      std::string::size_type v50 = v17;
      v16->__r_.__value_.__l.__size_ = 0;
      v16->__r_.__value_.__r.__words[2] = 0;
      v16->__r_.__value_.__r.__words[0] = 0;
      uint64_t v18 = *((int *)this + 40);
      uint64_t v19 = qword_1CFAC2F68[v18];
      uint64_t v20 = off_1E682C5D8[v18];
      v51[0] = __p;
      unint64_t v52 = v20;
      uint64_t v53 = v19;
      __int16 v54 = 1284;
      llvm::Twine::str((llvm::Twine *)v51, &__dst);
      size_t v21 = (void **)((char *)a2 + 72);
      if (*((char *)a2 + 95) < 0) {
        operator delete(*v21);
      }
      *(_OWORD *)size_t v21 = __dst;
      *((void *)a2 + 11) = v56;
      HIBYTE(v56) = 0;
      LOBYTE(__dst) = 0;
      if (SHIBYTE(v50) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v48.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v45.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v47.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v46.__r_.__value_.__l.__data_);
      }
      *((unsigned char *)a2 + 1) = 0;
      int v22 = *((_DWORD *)this + 40);
      goto LABEL_35;
    }
LABEL_34:
    MEMORY[0x1D25D9630]((char *)a2 + 72, "metadata.txt");
    *((unsigned char *)a2 + 1) = 0;
    int v22 = 6;
LABEL_35:
    *((_DWORD *)a2 + 1) = v22;
    return;
  }
  size_t v8 = (const void *)*((void *)this + 18);
  if (!*((unsigned char *)this + 88)) {
    *((unsigned char *)this + 88) = 1;
  }
  *((void *)this + 9) = v8;
  *((void *)this + 10) = v7;
  if (!*((unsigned char *)this + 136)) {
    goto LABEL_34;
  }
  if (v8)
  {
    if (v7 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    if (v7 >= 0x17)
    {
      uint64_t v26 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v7 | 7) != 0x17) {
        uint64_t v26 = v7 | 7;
      }
      uint64_t v27 = v26 + 1;
      p_dst = (long long *)operator new(v26 + 1);
      *((void *)&__dst + 1) = v7;
      int64_t v56 = v27 | 0x8000000000000000;
      *(void *)&long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v56) = v7;
      p_dst = &__dst;
    }
    memmove(p_dst, v8, v7);
    *((unsigned char *)p_dst + v7) = 0;
    char v25 = HIBYTE(v56);
    uint64_t v23 = *((void *)&__dst + 1);
    unint64_t v24 = (long long *)__dst;
  }
  else
  {
    uint64_t v23 = 0;
    unint64_t v24 = 0;
    char v25 = 0;
    long long __dst = 0uLL;
    int64_t v56 = 0;
  }
  uint64_t v28 = &__dst;
  if (v25 >= 0) {
    unint64_t v29 = &__dst;
  }
  else {
    unint64_t v29 = v24;
  }
  uint64_t v30 = v25 & 0x7F;
  if (v25 >= 0) {
    uint64_t v31 = v25 & 0x7F;
  }
  else {
    uint64_t v31 = v23;
  }
  if (v31)
  {
    do
    {
      if (*(unsigned char *)v29 == 32) {
        *(unsigned char *)unint64_t v29 = 95;
      }
      unint64_t v29 = (long long *)((char *)v29 + 1);
      --v31;
    }
    while (v31);
    char v25 = HIBYTE(v56);
    uint64_t v23 = *((void *)&__dst + 1);
    unint64_t v24 = (long long *)__dst;
    uint64_t v30 = HIBYTE(v56) & 0x7F;
  }
  if (v25 >= 0)
  {
    uint64_t v32 = v30;
  }
  else
  {
    uint64_t v28 = v24;
    uint64_t v32 = v23;
  }
  for (; v32; --v32)
  {
    if (*(unsigned char *)v28 == 58) {
      *(unsigned char *)uint64_t v28 = 95;
    }
    uint64_t v28 = (long long *)((char *)v28 + 1);
  }
  std::to_string(&v45, *((_DWORD *)this + 35));
  char v33 = std::string::append(&v45, "/");
  std::string::size_type v34 = v33->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v46.__r_.__value_.__l.__data_ = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
  v46.__r_.__value_.__r.__words[2] = v34;
  v33->__r_.__value_.__l.__size_ = 0;
  v33->__r_.__value_.__r.__words[2] = 0;
  v33->__r_.__value_.__r.__words[0] = 0;
  if (v56 >= 0) {
    long long v35 = (const std::string::value_type *)&__dst;
  }
  else {
    long long v35 = (const std::string::value_type *)__dst;
  }
  if (v56 >= 0) {
    std::string::size_type v36 = HIBYTE(v56) & 0x7F;
  }
  else {
    std::string::size_type v36 = *((void *)&__dst + 1);
  }
  unint64_t v37 = std::string::append(&v46, v35, v36);
  std::string::size_type v38 = v37->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v47.__r_.__value_.__l.__data_ = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
  v47.__r_.__value_.__r.__words[2] = v38;
  v37->__r_.__value_.__l.__size_ = 0;
  v37->__r_.__value_.__r.__words[2] = 0;
  v37->__r_.__value_.__r.__words[0] = 0;
  int v39 = std::string::append(&v47, ".");
  std::string::size_type v40 = v39->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v48.__r_.__value_.__l.__data_ = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
  v48.__r_.__value_.__r.__words[2] = v40;
  v39->__r_.__value_.__l.__size_ = 0;
  v39->__r_.__value_.__r.__words[2] = 0;
  v39->__r_.__value_.__r.__words[0] = 0;
  uint64_t v41 = *((int *)this + 40);
  uint64_t v42 = qword_1CFAC2F68[v41];
  uint64_t v43 = off_1E682C5D8[v41];
  v51[0] = &v48;
  unint64_t v52 = v43;
  uint64_t v53 = v42;
  __int16 v54 = 1284;
  llvm::Twine::str((llvm::Twine *)v51, __p);
  unint64_t v44 = (void **)((char *)a2 + 72);
  if (*((char *)a2 + 95) < 0) {
    operator delete(*v44);
  }
  *(_OWORD *)unint64_t v44 = *(_OWORD *)__p;
  *((void *)a2 + 11) = v50;
  HIBYTE(v50) = 0;
  LOBYTE(__p[0]) = 0;
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v48.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v47.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v46.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v45.__r_.__value_.__l.__data_);
  }
  *((_DWORD *)a2 + 1) = *((_DWORD *)this + 40);
  if (SHIBYTE(v56) < 0) {
    operator delete((void *)__dst);
  }
}

uint64_t llvm::AGCStatusReader::getLineNumber(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(unsigned __int8 **)(*(void *)a1 + 8);
  unint64_t v3 = *(void *)(*(void *)a1 + 16) - (void)v2;
  uint64_t result = 0;
  if (v3 >= a2 - (uint64_t)v2) {
    unint64_t v3 = a2 - (void)v2;
  }
  for (; v3; --v3)
  {
    int v5 = *v2++;
    if (v5 == 10) {
      ++result;
    }
  }
  return result;
}

uint64_t llvm::AGCStatusRecord::AGCStatusRecord(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(_WORD *)uint64_t result = 256;
  *(_DWORD *)(result + 4) = a2;
  *(void *)(result + 8) = a3;
  *(void *)(result + 16) = a4;
  *(unsigned char *)(result + 24) = 1;
  *(void *)(result + 32) = a5;
  *(unsigned char *)(result + 40) = 1;
  *(void *)(result + ++*(_DWORD *)(result + 48) = a6;
  *(void *)(result + 56) = a7;
  *(unsigned char *)(result + 64) = 1;
  *(unsigned char *)(result + 95) = 0;
  *(unsigned char *)(result + 72) = 0;
  *(void *)(result + 96) = &unk_1CFB4A537;
  *(void *)(result + 104) = 0;
  return result;
}

{
  *(_WORD *)uint64_t result = 256;
  *(_DWORD *)(result + 4) = a2;
  *(void *)(result + 8) = a3;
  *(void *)(result + 16) = a4;
  *(unsigned char *)(result + 24) = 1;
  *(void *)(result + 32) = a5;
  *(unsigned char *)(result + 40) = 1;
  *(void *)(result + ++*(_DWORD *)(result + 48) = a6;
  *(void *)(result + 56) = a7;
  *(unsigned char *)(result + 64) = 1;
  *(unsigned char *)(result + 95) = 0;
  *(unsigned char *)(result + 72) = 0;
  *(void *)(result + 96) = &unk_1CFB4A537;
  *(void *)(result + 104) = 0;
  return result;
}

uint64_t llvm::AGCStatusRecord::operator BOOL(unsigned __int8 *a1)
{
  return *a1;
}

llvm::raw_ostream *sub_1CBF35DFC(llvm::raw_ostream *this, const void *a2, size_t a3, uint64_t a4)
{
  if (*(unsigned char *)(a4 + 1))
  {
    size_t v7 = this;
    size_t v8 = (_DWORD *)*((void *)this + 4);
    if (*((void *)this + 3) - (void)v8 > 6uLL)
    {
      *(_DWORD *)((char *)v8 + 3) = 539831597;
      *size_t v8 = 757935405;
      this = (llvm::raw_ostream *)(*((void *)this + 4) + 7);
      *((void *)v7 + 4) = this;
    }
    else
    {
      llvm::raw_ostream::write(this, "------ ", 7uLL);
      this = (llvm::raw_ostream *)*((void *)v7 + 4);
    }
    if (a3 <= *((void *)v7 + 3) - (void)this)
    {
      if (a3)
      {
        memcpy(this, a2, a3);
        this = (llvm::raw_ostream *)(*((void *)v7 + 4) + a3);
        *((void *)v7 + 4) = this;
      }
    }
    else
    {
      llvm::raw_ostream::write(v7, (const char *)a2, a3);
      this = (llvm::raw_ostream *)*((void *)v7 + 4);
    }
    if (*((llvm::raw_ostream **)v7 + 3) == this)
    {
      this = llvm::raw_ostream::write(v7, " ", 1uLL);
    }
    else
    {
      *(unsigned char *)this = 32;
      ++*((void *)v7 + 4);
    }
    BOOL v9 = "compilation flags for";
    size_t v10 = 21;
    switch(*(_DWORD *)(a4 + 4))
    {
      case 2:
        std::string::size_type v11 = (_DWORD *)*((void *)v7 + 4);
        if (*((void *)v7 + 3) - (void)v11 <= 6uLL)
        {
          uint64_t v12 = "LLVM IR";
          unint64_t v13 = v7;
          size_t v14 = 7;
          goto LABEL_17;
        }
        *(_DWORD *)((char *)v11 + 3) = 1380524109;
        *std::string::size_type v11 = 1297501260;
        uint64_t v34 = *((void *)v7 + 4) + 7;
        goto LABEL_73;
      case 4:
        uint64_t v16 = *((void *)v7 + 4);
        if ((unint64_t)(*((void *)v7 + 3) - v16) <= 2)
        {
          uint64_t v12 = "USC";
          unint64_t v13 = v7;
          size_t v14 = 3;
          goto LABEL_17;
        }
        *(unsigned char *)(v16 + 2) = 67;
        *(_WORD *)uint64_t v16 = 21333;
        uint64_t v34 = *((void *)v7 + 4) + 3;
        goto LABEL_73;
      case 7:
        goto LABEL_22;
      case 8:
        BOOL v9 = "compilation key description for";
        size_t v10 = 31;
        goto LABEL_22;
      case 9:
        BOOL v9 = "Translator Metadata";
        size_t v10 = 19;
        goto LABEL_22;
      case 0xA:
        BOOL v9 = "Target Translator Metadata";
        size_t v10 = 26;
LABEL_22:
        uint64_t v18 = (void *)*((void *)v7 + 4);
        if (v10 <= *((void *)v7 + 3) - (void)v18)
        {
          this = (llvm::raw_ostream *)memcpy(v18, v9, v10);
          int v17 = 0;
          *((void *)v7 + 4) += v10;
        }
        else
        {
          this = llvm::raw_ostream::write(v7, v9, v10);
          int v17 = 0;
        }
        goto LABEL_25;
      default:
        uint64_t v15 = *((void *)v7 + 4);
        if ((unint64_t)(*((void *)v7 + 3) - v15) > 4)
        {
          *(unsigned char *)(v15 + 4) = 114;
          *(_DWORD *)uint64_t v15 = 1701344335;
          uint64_t v34 = *((void *)v7 + 4) + 5;
LABEL_73:
          *((void *)v7 + 4) = v34;
        }
        else
        {
          uint64_t v12 = "Other";
          unint64_t v13 = v7;
          size_t v14 = 5;
LABEL_17:
          this = llvm::raw_ostream::write(v13, v12, v14);
        }
        int v17 = 1;
LABEL_25:
        uint64_t v19 = (unsigned char *)*((void *)v7 + 4);
        if (*((unsigned char **)v7 + 3) == v19)
        {
          this = llvm::raw_ostream::write(v7, " ", 1uLL);
        }
        else
        {
          *uint64_t v19 = 32;
          ++*((void *)v7 + 4);
        }
        if (!*(unsigned char *)(a4 + 24))
        {
          unint64_t v24 = (_DWORD *)*((void *)v7 + 4);
          if (*((void *)v7 + 3) - (void)v24 <= 6uLL)
          {
            uint64_t v20 = "unknown";
            int v22 = v7;
            size_t v23 = 7;
            goto LABEL_32;
          }
          *(_DWORD *)((char *)v24 + 3) = 1853321070;
          *unint64_t v24 = 1852534389;
          uint64_t v25 = *((void *)v7 + 4) + 7;
          goto LABEL_35;
        }
        uint64_t v20 = *(const char **)(a4 + 8);
        unint64_t v21 = *(void *)(a4 + 16);
        this = (llvm::raw_ostream *)*((void *)v7 + 4);
        if (v21 > *((void *)v7 + 3) - (void)this)
        {
          int v22 = v7;
          size_t v23 = *(void *)(a4 + 16);
LABEL_32:
          this = llvm::raw_ostream::write(v22, v20, v23);
          goto LABEL_36;
        }
        if (v21)
        {
          this = (llvm::raw_ostream *)memcpy(this, v20, *(void *)(a4 + 16));
          uint64_t v25 = *((void *)v7 + 4) + v21;
LABEL_35:
          *((void *)v7 + 4) = v25;
        }
LABEL_36:
        uint64_t v26 = (unsigned char *)*((void *)v7 + 4);
        if (*((unsigned char **)v7 + 3) == v26)
        {
          this = llvm::raw_ostream::write(v7, " ", 1uLL);
          uint64_t v27 = (_DWORD *)*((void *)v7 + 4);
        }
        else
        {
          *uint64_t v26 = 32;
          uint64_t v27 = (_DWORD *)(*((void *)v7 + 4) + 1);
          *((void *)v7 + 4) = v27;
        }
        if (*((void *)v7 + 3) - (void)v27 > 6uLL)
        {
          *(_DWORD *)((char *)v27 + 3) = 544367972;
          *uint64_t v27 = 1684105331;
          *((void *)v7 + 4) += 7;
        }
        else
        {
          this = llvm::raw_ostream::write(v7, "shader ", 7uLL);
        }
        if (*(unsigned char *)(a4 + 40))
        {
          this = llvm::raw_ostream::operator<<(v7, *(void *)(a4 + 32));
          if (!v17) {
            goto LABEL_54;
          }
        }
        else
        {
          uint64_t v28 = (_DWORD *)*((void *)v7 + 4);
          if (*((void *)v7 + 3) - (void)v28 > 6uLL)
          {
            *(_DWORD *)((char *)v28 + 3) = 1853321070;
            *uint64_t v28 = 1852534389;
            *((void *)v7 + 4) += 7;
            if (!v17) {
              goto LABEL_54;
            }
          }
          else
          {
            this = llvm::raw_ostream::write(v7, "unknown", 7uLL);
            if (!v17) {
              goto LABEL_54;
            }
          }
        }
        if (*(unsigned char *)(a4 + 64))
        {
          uint64_t v31 = a4 + 48;
          unint64_t v29 = *(const void **)(a4 + 48);
          size_t v30 = *(void *)(v31 + 8);
          uint64_t v32 = (_WORD *)*((void *)v7 + 4);
          if (*((void *)v7 + 3) - (void)v32 > 1uLL)
          {
            *uint64_t v32 = 10272;
            this = (llvm::raw_ostream *)(*((void *)v7 + 4) + 2);
            *((void *)v7 + 4) = this;
          }
          else
          {
            llvm::raw_ostream::write(v7, " (", 2uLL);
            this = (llvm::raw_ostream *)*((void *)v7 + 4);
          }
          if (v30 <= *((void *)v7 + 3) - (void)this)
          {
            if (v30)
            {
              memcpy(this, v29, v30);
              this = (llvm::raw_ostream *)(*((void *)v7 + 4) + v30);
              *((void *)v7 + 4) = this;
            }
          }
          else
          {
            llvm::raw_ostream::write(v7, (const char *)v29, v30);
            this = (llvm::raw_ostream *)*((void *)v7 + 4);
          }
          if (*((llvm::raw_ostream **)v7 + 3) == this)
          {
            this = llvm::raw_ostream::write(v7, ")", 1uLL);
          }
          else
          {
            *(unsigned char *)this = 41;
            ++*((void *)v7 + 4);
          }
        }
LABEL_54:
        char v33 = (void *)*((void *)v7 + 4);
        if (*((void *)v7 + 3) - (void)v33 > 7uLL)
        {
          *char v33 = 0xA2D2D2D2D2D2D20;
          *((void *)v7 + 4) += 8;
        }
        else
        {
          this = llvm::raw_ostream::write(v7, " ------\n", 8uLL);
        }
        break;
    }
  }
  return this;
}

void llvm::AGCStatusRecord::emitTarRecord(llvm::AGCStatusRecord *this, llvm::raw_ostream *a2, int a3)
{
  long long v6 = (const std::string *)((char *)this + 72);
  if (*((char *)this + 95) < 0)
  {
    unint64_t v7 = *((void *)this + 10);
    if (v7 < 0x64)
    {
      sub_1CB8BDF7C((uint64_t)&v75, v6->__r_.__value_.__l.__data_, v7);
      goto LABEL_7;
    }
  }
  else
  {
    unint64_t v7 = *((unsigned __int8 *)this + 95);
    if (*((unsigned __int8 *)this + 95) <= 0x63u)
    {
      *(_OWORD *)&v75.__r_.__value_.__l.__data_ = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
      v75.__r_.__value_.__r.__words[2] = *((void *)this + 11);
      goto LABEL_7;
    }
  }
  std::string::basic_string(&v75, v6, v7 - 100, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v63);
LABEL_7:
  if (*((char *)this + 95) < 0) {
    uint64_t v8 = *((void *)this + 10);
  }
  else {
    uint64_t v8 = *((unsigned __int8 *)this + 95);
  }
  std::string::size_type size = *((unsigned char *)&v75.__r_.__value_.__s + 23) & 0x7F;
  if ((v75.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v75.__r_.__value_.__l.__size_;
  }
  std::string::basic_string(&v74, v6, 0, v8 - size, (std::allocator<char> *)&v63);
  unsigned int v10 = 0;
  uint64_t v11 = *((void *)this + 13);
  v72[0] = 0;
  v72[1] = 0;
  uint64_t v73 = 0;
  int v64 = 0;
  char v68 = 0;
  uint64_t v69 = 0;
  __str = (std::string *)v72;
  int v70 = 0;
  uint64_t v63 = &unk_1F2646F30;
  uint64_t v65 = 0;
  long long v66 = 0;
  int v67 = 0;
  if (a3) {
    unsigned int v10 = time(0);
  }
  if ((v75.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v12 = &v75;
  }
  else {
    uint64_t v12 = (std::string *)v75.__r_.__value_.__r.__words[0];
  }
  if ((v75.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v13 = *((unsigned char *)&v75.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    size_t v13 = v75.__r_.__value_.__l.__size_;
  }
  llvm::raw_ostream::write((llvm::raw_ostream *)&v63, (const char *)v12, v13);
  std::string::size_type v14 = *((unsigned char *)&v75.__r_.__value_.__s + 23) & 0x7F;
  if ((v75.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v14 = v75.__r_.__value_.__l.__size_;
  }
  std::string::size_type v15 = 100 - v14;
  if (100 - v14 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_148;
  }
  if (v15 >= 0x17)
  {
    uint64_t v17 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17) {
      uint64_t v17 = v15 | 7;
    }
    uint64_t v18 = v17 + 1;
    p_p = (std::string *)operator new(v17 + 1);
    __p.__r_.__value_.__l.__size_ = v15;
    __p.__r_.__value_.__r.__words[2] = v18 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)p_p;
    goto LABEL_29;
  }
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = 100 - v14;
  p_p = &__p;
  if (v14 != 100) {
LABEL_29:
  }
    bzero(p_p, v15);
  p_p->__r_.__value_.__s.__data_[v15] = 0;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v19 = &__p;
  }
  else {
    uint64_t v19 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v20 = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    size_t v20 = __p.__r_.__value_.__l.__size_;
  }
  llvm::raw_ostream::write((llvm::raw_ostream *)&v63, (const char *)v19, v20);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  sub_1CBF36C4C((llvm::raw_ostream *)&v63, 0x1A4u, 8u, 1);
  sub_1CBF36C4C((llvm::raw_ostream *)&v63, 0, 8u, 1);
  sub_1CBF36C4C((llvm::raw_ostream *)&v63, 0, 8u, 1);
  sub_1CBF36C4C((llvm::raw_ostream *)&v63, v11, 0xCu, 0);
  sub_1CBF36C4C((llvm::raw_ostream *)&v63, v10, 0xCu, 0);
  if ((unint64_t)(v66 - v67) > 7)
  {
    *(void *)int v67 = 0x2020202020202020;
    unint64_t v21 = v67 + 8;
    v67 += 8;
  }
  else
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v63, "        ", 8uLL);
    unint64_t v21 = v67;
  }
  if (v66 == v21)
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v63, "0", 1uLL);
  }
  else
  {
    *unint64_t v21 = 48;
    ++v67;
  }
  int v22 = operator new(0x68uLL);
  *int v22 = 0u;
  v22[1] = 0u;
  v22[2] = 0u;
  v22[3] = 0u;
  v22[4] = 0u;
  v22[5] = 0u;
  *((_DWORD *)v22 + 24) = 0;
  llvm::raw_ostream::write((llvm::raw_ostream *)&v63, (const char *)v22, 0x63uLL);
  operator delete(v22);
  size_t v23 = v67;
  if (v67 >= v66)
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v63, 0);
  }
  else
  {
    ++v67;
    *size_t v23 = 0;
  }
  unint64_t v24 = v67;
  if ((unint64_t)(v66 - v67) > 4)
  {
    v67[4] = 114;
    *unint64_t v24 = 1635021685;
    uint64_t v25 = v67 + 5;
    v67 += 5;
  }
  else
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v63, "ustar", 5uLL);
    uint64_t v25 = v67;
  }
  if (v25 >= v66)
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v63, 0);
  }
  else
  {
    int v67 = v25 + 1;
    *uint64_t v25 = 0;
  }
  if ((unint64_t)(v66 - v67) > 1)
  {
    *(_WORD *)int v67 = 12336;
    v67 += 2;
  }
  else
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v63, "00", 2uLL);
  }
  uint64_t v26 = operator new(0x28uLL);
  *uint64_t v26 = 0u;
  v26[1] = 0u;
  *((unsigned char *)v26 + 32) = 0;
  llvm::raw_ostream::write((llvm::raw_ostream *)&v63, (const char *)v26, 0x20uLL);
  operator delete(v26);
  uint64_t v27 = operator new(0x28uLL);
  *uint64_t v27 = 0u;
  v27[1] = 0u;
  *((unsigned char *)v27 + 32) = 0;
  llvm::raw_ostream::write((llvm::raw_ostream *)&v63, (const char *)v27, 0x20uLL);
  operator delete(v27);
  sub_1CBF36C4C((llvm::raw_ostream *)&v63, 0, 8u, 1);
  sub_1CBF36C4C((llvm::raw_ostream *)&v63, 0, 8u, 1);
  if ((v74.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v28 = &v74;
  }
  else {
    uint64_t v28 = (std::string *)v74.__r_.__value_.__r.__words[0];
  }
  if ((v74.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v29 = *((unsigned char *)&v74.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    size_t v29 = v74.__r_.__value_.__l.__size_;
  }
  llvm::raw_ostream::write((llvm::raw_ostream *)&v63, (const char *)v28, v29);
  std::string::size_type v30 = *((unsigned char *)&v74.__r_.__value_.__s + 23) & 0x7F;
  if ((v74.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v30 = v74.__r_.__value_.__l.__size_;
  }
  std::string::size_type v31 = 155 - v30;
  if (155 - v30 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_148;
  }
  if (v31 >= 0x17)
  {
    uint64_t v33 = (v31 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v31 | 7) != 0x17) {
      uint64_t v33 = v31 | 7;
    }
    uint64_t v34 = v33 + 1;
    uint64_t v32 = (std::string *)operator new(v33 + 1);
    __p.__r_.__value_.__l.__size_ = v31;
    __p.__r_.__value_.__r.__words[2] = v34 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v32;
    goto LABEL_67;
  }
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = -101 - v30;
  uint64_t v32 = &__p;
  if (v30 != 155) {
LABEL_67:
  }
    bzero(v32, v31);
  v32->__r_.__value_.__s.__data_[v31] = 0;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v35 = &__p;
  }
  else {
    long long v35 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v36 = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    size_t v36 = __p.__r_.__value_.__l.__size_;
  }
  llvm::raw_ostream::write((llvm::raw_ostream *)&v63, (const char *)v35, v36);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = 12;
  __p.__r_.__value_.__r.__words[0] = 0;
  *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 5) = 0;
  llvm::raw_ostream::write((llvm::raw_ostream *)&v63, (const char *)&__p, 0xCuLL);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type v38 = (std::string *)__str->__r_.__value_.__r.__words[0];
    std::string::size_type v37 = __str->__r_.__value_.__l.__size_;
  }
  else
  {
    std::string::size_type v37 = HIBYTE(__str->__r_.__value_.__r.__words[2]);
    std::string::size_type v38 = __str;
  }
  for (unsigned int i = 0; v37; --v37)
  {
    int v40 = v38->__r_.__value_.__s.__data_[0];
    std::string::size_type v38 = (std::string *)((char *)v38 + 1);
    i += v40;
  }
  std::string::basic_string(&__p, __str, 0, 0x94uLL, (std::allocator<char> *)&v76);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v41 = &__p;
  }
  else {
    uint64_t v41 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v42 = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    size_t v42 = __p.__r_.__value_.__l.__size_;
  }
  llvm::raw_ostream::write(a2, (const char *)v41, v42);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  sub_1CBF36C4C(a2, i, 8u, 2);
  std::string::basic_string(&__p, __str, 0x9CuLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v76);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v43 = &__p;
  }
  else {
    uint64_t v43 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v44 = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    size_t v44 = __p.__r_.__value_.__l.__size_;
  }
  llvm::raw_ostream::write(a2, (const char *)v43, v44);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  std::string v45 = (const void *)*((void *)this + 12);
  if (!v45)
  {
    char v48 = 0;
    memset(&__p, 0, sizeof(__p));
    uint64_t v49 = &__p;
    goto LABEL_113;
  }
  std::string::size_type v46 = *((void *)this + 13);
  if (v46 > 0x7FFFFFFFFFFFFFF7) {
LABEL_148:
  }
    abort();
  if (v46 >= 0x17)
  {
    uint64_t v50 = (v46 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v46 | 7) != 0x17) {
      uint64_t v50 = v46 | 7;
    }
    uint64_t v51 = v50 + 1;
    std::string v47 = (std::string *)operator new(v50 + 1);
    __p.__r_.__value_.__l.__size_ = v46;
    __p.__r_.__value_.__r.__words[2] = v51 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v47;
    goto LABEL_108;
  }
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = v46;
  std::string v47 = &__p;
  if (v46) {
LABEL_108:
  }
    memmove(v47, v45, v46);
  v47->__r_.__value_.__s.__data_[v46] = 0;
  char v48 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
  {
    uint64_t v49 = (std::string *)__p.__r_.__value_.__r.__words[0];
    if (!__p.__r_.__value_.__r.__words[0])
    {
      unint64_t v52 = 0;
LABEL_117:
      operator delete(v52);
      goto LABEL_118;
    }
  }
  else
  {
    uint64_t v49 = &__p;
  }
LABEL_113:
  size_t v53 = strlen((const char *)v49);
  __int16 v54 = (void *)*((void *)a2 + 4);
  if (v53 <= *((void *)a2 + 3) - (void)v54)
  {
    if (v53)
    {
      memcpy(v54, v49, v53);
      *((void *)a2 + 4) += v53;
    }
  }
  else
  {
    llvm::raw_ostream::write(a2, (const char *)v49, v53);
    char v48 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  if (v48 < 0)
  {
    unint64_t v52 = (void *)__p.__r_.__value_.__r.__words[0];
    goto LABEL_117;
  }
LABEL_118:
  uint64_t v55 = -v11;
  std::string::size_type v56 = -v11 & 0x1FF;
  if (v56 >= 0x17)
  {
    uint64_t v58 = (v55 & 0x1F8) + 8;
    if ((v56 | 7) == 0x17) {
      uint64_t v59 = v58;
    }
    else {
      uint64_t v59 = v56 | 7;
    }
    long long v57 = (std::string *)operator new(v59 + 1);
    __p.__r_.__value_.__l.__size_ = v56;
    __p.__r_.__value_.__r.__words[2] = v59 - 0x7FFFFFFFFFFFFFFFLL;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v57;
    goto LABEL_125;
  }
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = v55;
  long long v57 = &__p;
  if (v56) {
LABEL_125:
  }
    bzero(v57, v56);
  v57->__r_.__value_.__s.__data_[v56] = 0;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v60 = &__p;
  }
  else {
    long long v60 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v61 = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    size_t v61 = __p.__r_.__value_.__l.__size_;
  }
  llvm::raw_ostream::write(a2, (const char *)v60, v61);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  uint64_t v63 = &unk_1F2646B98;
  if (v70 == 1 && v65) {
    MEMORY[0x1D25D9CB0](v65, 0x1000C8077774924);
  }
  if (SHIBYTE(v73) < 0) {
    operator delete(v72[0]);
  }
  if (SHIBYTE(v74.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v74.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v75.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v75.__r_.__value_.__l.__data_);
  }
}

void sub_1CBF36C4C(llvm::raw_ostream *a1, unsigned int a2, unsigned int a3, int a4)
{
  unsigned int v7 = a3 - 1;
  if (a4) {
    unsigned int v7 = a3;
  }
  if ((a4 - 1) >= 2) {
    size_t v8 = v7;
  }
  else {
    size_t v8 = a3 - 2;
  }
  char v21 = v8;
  memset(__b, 48, v8);
  *((unsigned char *)__b + v8) = 0;
  if (a2)
  {
    unsigned int v9 = v8 - 1;
    do
    {
      if (v21 >= 0) {
        unsigned int v10 = __b;
      }
      else {
        unsigned int v10 = (void **)__b[0];
      }
      *((unsigned char *)v10 + v9--) = a2 & 7 | 0x30;
      BOOL v11 = a2 > 7;
      a2 >>= 3;
    }
    while (v11);
  }
  if (v21 >= 0) {
    uint64_t v12 = (const char *)__b;
  }
  else {
    uint64_t v12 = (const char *)__b[0];
  }
  if (v21 >= 0) {
    size_t v13 = v21 & 0x7F;
  }
  else {
    size_t v13 = (size_t)__b[1];
  }
  llvm::raw_ostream::write(a1, v12, v13);
  switch(a4)
  {
    case 2:
      std::string::size_type v15 = (unsigned char *)*((void *)a1 + 4);
      if ((unint64_t)v15 >= *((void *)a1 + 3))
      {
        llvm::raw_ostream::write(a1, 0);
      }
      else
      {
        *((void *)a1 + 4) = v15 + 1;
        *std::string::size_type v15 = 0;
      }
      goto LABEL_30;
    case 1:
      std::string::size_type v14 = (unsigned char *)*((void *)a1 + 4);
      if ((unint64_t)v14 >= *((void *)a1 + 3))
      {
        llvm::raw_ostream::write(a1, 32);
      }
      else
      {
        *((void *)a1 + 4) = v14 + 1;
        *std::string::size_type v14 = 32;
      }
      uint64_t v16 = (unsigned char *)*((void *)a1 + 4);
      if ((unint64_t)v16 < *((void *)a1 + 3))
      {
        *((void *)a1 + 4) = v16 + 1;
        *uint64_t v16 = 0;
        break;
      }
      uint64_t v18 = a1;
      char v19 = 0;
LABEL_34:
      llvm::raw_ostream::write(v18, v19);
      break;
    case 0:
LABEL_30:
      uint64_t v17 = (unsigned char *)*((void *)a1 + 4);
      if ((unint64_t)v17 < *((void *)a1 + 3))
      {
        *((void *)a1 + 4) = v17 + 1;
        *uint64_t v17 = 32;
        break;
      }
      uint64_t v18 = a1;
      char v19 = 32;
      goto LABEL_34;
  }
  if (v21 < 0) {
    operator delete(__b[0]);
  }
}

void llvm::agxapstrace::AGXAPSTraceSystem::createAddressTranslator(llvm::agxapstrace::AGXAPSTraceSystem *this)
{
}

void llvm::agxapstrace::AGXAPSTraceSystem::createDisassembler(llvm::agxapstrace::AGXAPSTraceSystem *this, const llvm::MCSubtargetInfo *a2, const llvm::MCDisassembler *a3, const llvm::MCInstPrinter *a4)
{
}

uint64_t llvm::agxapstrace::AGXAPSTraceSystem::getStreamFlagsForCPU(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  if (a3 != 7) {
    return 0;
  }
  if (*a2 == 1731408231 && *(_DWORD *)((char *)a2 + 3) == 811674983) {
    return 0;
  }
  BOOL v4 = *a2 == 1731408231 && *(_DWORD *)((char *)a2 + 3) == 811740519;
  uint64_t result = 3;
  if (!v4)
  {
    if (*a2 ^ 0x67333167 | *(_DWORD *)((char *)a2 + 3) ^ 0x30632D67) {
      return 0;
    }
    else {
      return 3;
    }
  }
  return result;
}

llvm::raw_ostream *llvm::agxapstrace::operator<<(llvm::raw_ostream *a1, unint64_t *a2)
{
  return a1;
}

llvm::raw_ostream *sub_1CBF36F68(llvm::raw_ostream *this, unint64_t a2)
{
  unsigned int v4 = __clz(a2);
  int v5 = (_WORD *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v5 > 1uLL)
  {
    *int v5 = 30768;
    *((void *)this + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(this, "0x", 2uLL);
  }
  if (v4 >= 0x24)
  {
    unsigned int v6 = v4 >> 2;
    do
    {
      unsigned int v7 = (unsigned char *)*((void *)this + 4);
      if (*((unsigned char **)this + 3) == v7)
      {
        llvm::raw_ostream::write(this, "0", 1uLL);
      }
      else
      {
        *unsigned int v7 = 48;
        ++*((void *)this + 4);
      }
      --v6;
    }
    while (v6 > 8);
  }

  return llvm::write_hex(this, a2, 1, 0, 0);
}

void llvm::agxapstrace::to_string(unint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  char v14 = 0;
  LOBYTE(v13) = 0;
  int v5 = 0;
  char v9 = 0;
  uint64_t v10 = 0;
  uint64_t v12 = &v13;
  int v11 = 0;
  unsigned int v4 = &unk_1F2646F30;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  sub_1CBF36F68((llvm::raw_ostream *)&v4, *a1);
  if (*((char *)v12 + 23) < 0)
  {
    sub_1CB8BDF7C(a2, *v12, (unint64_t)v12[1]);
  }
  else
  {
    long long v3 = *(_OWORD *)v12;
    *(void *)(a2 + 16) = v12[2];
    *(_OWORD *)a2 = v3;
  }
  unsigned int v4 = &unk_1F2646B98;
  if (v11 == 1 && v6) {
    MEMORY[0x1D25D9CB0](v6, 0x1000C8077774924);
  }
  if (v14 < 0) {
    operator delete(v13);
  }
}

llvm::raw_ostream *llvm::agxapstrace::operator<<(llvm::raw_ostream *this, unint64_t *a2)
{
  uint64_t v4 = *((void *)this + 4);
  if ((unint64_t)(*((void *)this + 3) - v4) > 4)
  {
    *(unsigned char *)(v4 + 4) = 43;
    *(_DWORD *)uint64_t v4 = 1702060386;
    *((void *)this + 4) += 5;
  }
  else
  {
    llvm::raw_ostream::write(this, "base+", 5uLL);
  }
  sub_1CBF36F68(this, *a2);
  return this;
}

void *llvm::agxapstrace::ObjectInfo::ObjectInfo(void *__dst, void *__src, size_t __len, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v13 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v13 = __len | 7;
    }
    size_t v14 = v13 + 1;
    uint64_t v12 = operator new(v13 + 1);
    __dst[1] = __len;
    __dst[2] = v14 | 0x8000000000000000;
    *long long __dst = v12;
  }
  else
  {
    *((unsigned char *)__dst + 23) = __len;
    uint64_t v12 = __dst;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memmove(v12, __src, __len);
LABEL_9:
  *((unsigned char *)v12 + __len) = 0;
  __dst[3] = a4;
  __dst[4] = a5;
  __dst[5] = a6;
  return __dst;
}

{
  void *v12;
  size_t v13;
  size_t v14;

  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v13 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v13 = __len | 7;
    }
    size_t v14 = v13 + 1;
    uint64_t v12 = operator new(v13 + 1);
    __dst[1] = __len;
    __dst[2] = v14 | 0x8000000000000000;
    *long long __dst = v12;
  }
  else
  {
    *((unsigned char *)__dst + 23) = __len;
    uint64_t v12 = __dst;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memmove(v12, __src, __len);
LABEL_9:
  *((unsigned char *)v12 + __len) = 0;
  __dst[3] = a4;
  __dst[4] = a5;
  __dst[5] = a6;
  return __dst;
}

llvm::raw_ostream *llvm::agxapstrace::operator<<(llvm::raw_ostream *this, unsigned char *a2)
{
  char v3 = a2[23];
  BOOL v4 = v3 < 0;
  size_t v5 = *((void *)a2 + 1);
  if (v3 < 0) {
    a2 = *(unsigned char **)a2;
  }
  size_t v6 = v3 & 0x7F;
  if (v4) {
    size_t v7 = v5;
  }
  else {
    size_t v7 = v6;
  }
  uint64_t v9 = *((void *)this + 3);
  uint64_t v8 = (void *)*((void *)this + 4);
  if (v7 <= v9 - (uint64_t)v8)
  {
    if (v7)
    {
      memcpy(v8, a2, v7);
      *((void *)this + 4) += v7;
    }
  }
  else
  {
    llvm::raw_ostream::write(this, a2, v7);
  }
  return this;
}

void llvm::agxapstrace::SectionInfo::SectionInfo(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *a1 = a2;
  a1[1] = a3;
  a1[2] = a4;
  a1[3] = a5;
  a1[4] = a6;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = a7;
  a1[8] = a8;
  llvm::agxapstrace::CachedSectionDisassembler::CachedSectionDisassembler((uint64_t)(a1 + 9), a2, (uint64_t)a1);
}

{
  llvm::agxapstrace::SectionInfo::SectionInfo(a1, a2, a3, a4, a5, a6, a7, a8);
}

BOOL llvm::agxapstrace::SectionInfo::isSystemAddressInSection(uint64_t a1, unint64_t a2)
{
  return *(void *)(a1 + 56) <= a2 && *(void *)(a1 + 64) > a2;
}

llvm::raw_ostream *llvm::agxapstrace::operator<<(llvm::raw_ostream *a1, uint64_t a2)
{
  BOOL v4 = llvm::agxapstrace::operator<<(a1, *(unsigned char **)a2);
  size_t v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(a1, "(", 1uLL);
  }
  else
  {
    *size_t v5 = 40;
    ++*((void *)a1 + 4);
  }
  unint64_t v6 = *(void *)(a2 + 16);
  if (v6)
  {
    size_t v7 = *(const void **)(a2 + 8);
    uint64_t v8 = (void *)*((void *)a1 + 4);
    if (v6 <= *((void *)a1 + 3) - (void)v8)
    {
      memcpy(v8, v7, *(void *)(a2 + 16));
      uint64_t v10 = (unsigned char *)(*((void *)a1 + 4) + v6);
      *((void *)a1 + 4) = v10;
      uint64_t v9 = a1;
    }
    else
    {
      uint64_t v9 = llvm::raw_ostream::write(a1, (const char *)v7, *(void *)(a2 + 16));
      uint64_t v10 = (unsigned char *)*((void *)v9 + 4);
    }
    if (*((unsigned char **)v9 + 3) == v10)
    {
      llvm::raw_ostream::write(v9, ",", 1uLL);
    }
    else
    {
      *uint64_t v10 = 44;
      ++*((void *)v9 + 4);
    }
  }
  int v11 = *(const void **)(a2 + 40);
  size_t v12 = *(void *)(a2 + 48);
  size_t v13 = (unsigned char *)*((void *)a1 + 4);
  if (v12 <= *((void *)a1 + 3) - (void)v13)
  {
    if (v12)
    {
      memcpy(v13, v11, v12);
      size_t v13 = (unsigned char *)(*((void *)a1 + 4) + v12);
      *((void *)a1 + 4) = v13;
    }
    size_t v14 = a1;
  }
  else
  {
    size_t v14 = llvm::raw_ostream::write(a1, (const char *)v11, v12);
    size_t v13 = (unsigned char *)*((void *)v14 + 4);
  }
  if (*((unsigned char **)v14 + 3) == v13)
  {
    llvm::raw_ostream::write(v14, ")", 1uLL);
  }
  else
  {
    *size_t v13 = 41;
    ++*((void *)v14 + 4);
  }
  return a1;
}

uint64_t llvm::agxapstrace::AddressTranslator::findObject(uint64_t *a1, void *__s2, size_t __n)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *((unsigned int *)a1 + 2);
  if (v4)
  {
    uint64_t v7 = 8 * v4;
    uint64_t v8 = v3 + 8 * v4;
    while (1)
    {
      char v9 = *(unsigned char *)(*(void *)v3 + 23);
      uint64_t v10 = v9 >= 0 ? *(const void **)v3 : **(const void ***)v3;
      uint64_t v11 = v9 & 0x7F;
      if (v9 < 0) {
        uint64_t v11 = *(void *)(*(void *)v3 + 8);
      }
      if (v11 == __n && (!__n || !memcmp(v10, __s2, __n))) {
        break;
      }
      v3 += 8;
      v7 -= 8;
      if (!v7) {
        return v8;
      }
    }
  }
  return v3;
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  char v9;
  const void *v10;
  uint64_t v11;

  uint64_t v3 = *a1;
  uint64_t v4 = *((unsigned int *)a1 + 2);
  if (v4)
  {
    uint64_t v7 = 8 * v4;
    uint64_t v8 = v3 + 8 * v4;
    while (1)
    {
      char v9 = *(unsigned char *)(*(void *)v3 + 23);
      uint64_t v10 = v9 >= 0 ? *(const void **)v3 : **(const void ***)v3;
      uint64_t v11 = v9 & 0x7F;
      if (v9 < 0) {
        uint64_t v11 = *(void *)(*(void *)v3 + 8);
      }
      if (v11 == __n && (!__n || !memcmp(v10, __s2, __n))) {
        break;
      }
      v3 += 8;
      v7 -= 8;
      if (!v7) {
        return v8;
      }
    }
  }
  return v3;
}

const void ***llvm::agxapstrace::AddressTranslator::findSection(uint64_t a1, const void ***a2, void *__s2, size_t __n, void *a5, size_t a6)
{
  unint64_t v6 = *(const void ****)(a1 + 48);
  uint64_t v7 = *(unsigned int *)(a1 + 56);
  if (v7)
  {
    size_t v12 = &v6[v7];
    char v13 = *((unsigned char *)*a2 + 23);
    if (v13 >= 0) {
      size_t v14 = *a2;
    }
    else {
      size_t v14 = **a2;
    }
    if (v13 >= 0) {
      size_t v15 = v13 & 0x7F;
    }
    else {
      size_t v15 = (size_t)(*a2)[1];
    }
    uint64_t v16 = 8 * v7;
    while (1)
    {
      uint64_t v17 = *v6;
      uint64_t v18 = **v6;
      char v19 = v18[23];
      uint64_t v20 = *((void *)v18 + 1);
      if (v19 >= 0) {
        char v21 = **v6;
      }
      else {
        char v21 = *(const void **)v18;
      }
      uint64_t v22 = v19 & 0x7F;
      if (v19 < 0) {
        uint64_t v22 = v20;
      }
      if (v22 == v15
        && (!v15 || !memcmp(v21, v14, v15))
        && v17[2] == (const void *)__n
        && (!__n || !memcmp(v17[1], __s2, __n))
        && v17[6] == (const void *)a6
        && (!a6 || !memcmp(v17[5], a5, a6)))
      {
        break;
      }
      ++v6;
      v16 -= 8;
      if (!v16) {
        return v12;
      }
    }
  }
  return v6;
}

{
  const void ***v6;
  uint64_t v7;
  const void ***v12;
  char v13;
  const void *v14;
  size_t v15;
  uint64_t v16;
  const void **v17;
  unsigned char *v18;
  char v19;
  uint64_t v20;
  const void *v21;
  uint64_t v22;

  unint64_t v6 = *(const void ****)(a1 + 48);
  uint64_t v7 = *(unsigned int *)(a1 + 56);
  if (v7)
  {
    size_t v12 = &v6[v7];
    char v13 = *((unsigned char *)*a2 + 23);
    if (v13 >= 0) {
      size_t v14 = *a2;
    }
    else {
      size_t v14 = **a2;
    }
    if (v13 >= 0) {
      size_t v15 = v13 & 0x7F;
    }
    else {
      size_t v15 = (size_t)(*a2)[1];
    }
    uint64_t v16 = 8 * v7;
    while (1)
    {
      uint64_t v17 = *v6;
      uint64_t v18 = **v6;
      char v19 = v18[23];
      uint64_t v20 = *((void *)v18 + 1);
      if (v19 >= 0) {
        char v21 = **v6;
      }
      else {
        char v21 = *(const void **)v18;
      }
      uint64_t v22 = v19 & 0x7F;
      if (v19 < 0) {
        uint64_t v22 = v20;
      }
      if (v22 == v15
        && (!v15 || !memcmp(v21, v14, v15))
        && v17[2] == (const void *)__n
        && (!__n || !memcmp(v17[1], __s2, __n))
        && v17[6] == (const void *)a6
        && (!a6 || !memcmp(v17[5], a5, a6)))
      {
        break;
      }
      ++v6;
      v16 -= 8;
      if (!v16) {
        return v12;
      }
    }
  }
  return v6;
}

void *llvm::agxapstrace::AddressTranslator::findSectionByAddress(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 48);
  unint64_t v3 = *(unsigned int *)(a1 + 56);
  if (v3)
  {
    uint64_t result = *(void **)(a1 + 48);
    unint64_t v5 = v3;
    do
    {
      unint64_t v6 = v5 >> 1;
      uint64_t v7 = &result[v5 >> 1];
      uint64_t v9 = *v7;
      uint64_t v8 = v7 + 1;
      v5 += ~(v5 >> 1);
      if (*(void *)(v9 + 64) < a2) {
        uint64_t result = v8;
      }
      else {
        unint64_t v5 = v6;
      }
    }
    while (v5);
  }
  else
  {
    uint64_t result = *(void **)(a1 + 48);
  }
  uint64_t v10 = (void *)(v2 + 8 * v3);
  if (result != v10 && (*(void *)(*result + 56) > a2 || *(void *)(*result + 64) <= a2)) {
    return v10;
  }
  return result;
}

{
  uint64_t v2;
  unint64_t v3;
  void *result;
  unint64_t v5;
  unint64_t v6;
  uint64_t *v7;
  void *v8;
  uint64_t v9;
  void *v10;

  uint64_t v2 = *(void *)(a1 + 48);
  unint64_t v3 = *(unsigned int *)(a1 + 56);
  if (v3)
  {
    uint64_t result = *(void **)(a1 + 48);
    unint64_t v5 = v3;
    do
    {
      unint64_t v6 = v5 >> 1;
      uint64_t v7 = &result[v5 >> 1];
      uint64_t v9 = *v7;
      uint64_t v8 = v7 + 1;
      v5 += ~(v5 >> 1);
      if (*(void *)(v9 + 64) < a2) {
        uint64_t result = v8;
      }
      else {
        unint64_t v5 = v6;
      }
    }
    while (v5);
  }
  else
  {
    uint64_t result = *(void **)(a1 + 48);
  }
  uint64_t v10 = (void *)(v2 + 8 * v3);
  if (result != v10 && (*(void *)(*result + 56) > a2 || *(void *)(*result + 64) <= a2)) {
    return v10;
  }
  return result;
}

void llvm::agxapstrace::AddressTranslator::loadObject()
{
}

void llvm::agxapstrace::AddressTranslator::loadSection(uint64_t a1, uint64_t a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(void *)(*(void *)a2 + 24);
  uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 344))(v9);
  uint64_t v12 = v11;
  uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 352))(v9);
  uint64_t v29 = v10;
  uint64_t v30 = v12;
  if (v12 != v14 || v10 != v13)
  {
    uint64_t v16 = v13;
    uint64_t v17 = v14;
    do
    {
      (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(*(void *)v12 + 136))(v31, v12, v10);
      char v18 = v32;
      uint64_t v19 = v31[0];
      if (v32) {
        uint64_t v20 = "<unknown-section-name>";
      }
      else {
        uint64_t v20 = (const char *)v31[0];
      }
      if (v32) {
        uint64_t v21 = 22;
      }
      else {
        uint64_t v21 = v31[1];
      }
      uint64_t v22 = *(void *)(*(void *)a2 + 24);
      if (v22) {
        BOOL v23 = (*(_DWORD *)(v22 + 8) & 0xFFFFFFFC) == 16;
      }
      else {
        BOOL v23 = 0;
      }
      if (v23)
      {
        uint64_t v26 = *(void *)(*(void *)(v22 + 80) + 8 * v29);
        uint64_t v25 = (const char *)(v26 + 16);
        if (*(unsigned char *)(v26 + 31)) {
          size_t v24 = 16;
        }
        else {
          size_t v24 = strlen(v25);
        }
      }
      else
      {
        size_t v24 = 0;
        uint64_t v25 = "";
      }
      if (v24 == a4 && (!a4 || !memcmp(v25, a3, a4)) && v21 == a6 && (!a6 || !memcmp(v20, a5, a6)))
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v30 + 160))(v30, v29);
        operator new();
      }
      if (v18)
      {
        v31[0] = 0;
        if (v19) {
          (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
        }
      }
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v30 + 128))(v30, &v29);
      uint64_t v10 = v29;
      uint64_t v12 = v30;
    }
    while (v30 != v17 || v29 != v16);
  }
  std::generic_category();
  operator new();
}

uint64_t *llvm::agxapstrace::AddressTranslator::unloadObject(uint64_t a1, const ObjectInfo **a2)
{
  unint64_t v3 = (uint64_t *)(a2 + 1);
  llvm::agxapstrace::AddressTranslator::unloadSectionsForObject(a1, *a2);
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  uint64_t v6 = *(void *)a1 + 8 * v5;
  if (v3 != (uint64_t *)v6)
  {
    do
    {
      uint64_t v7 = v3 - 1;
      uint64_t v8 = *v3;
      *v3++ = 0;
      sub_1CBF38BA4(v7, v8);
    }
    while (v3 != (uint64_t *)v6);
    LODWORD(v5) = *(_DWORD *)(a1 + 8);
    uint64_t v4 = *(void *)a1;
  }
  unsigned int v9 = v5 - 1;
  *(_DWORD *)(a1 + 8) = v9;

  return sub_1CBF38BA4((uint64_t *)(v4 + 8 * v9), 0);
}

uint64_t llvm::agxapstrace::AddressTranslator::unloadSectionsForObject(uint64_t this, const ObjectInfo *a2)
{
  uint64_t v2 = this;
  uint64_t v3 = *(void *)(this + 48);
  uint64_t v4 = *(unsigned int *)(this + 56);
  if (v4)
  {
    uint64_t v6 = 0;
    uint64_t v7 = (const ObjectInfo ***)(v3 + 8 * v4);
    while (**(const ObjectInfo ***)(v3 + v6) != a2)
    {
      v6 += 8;
      if (8 * v4 == v6)
      {
        uint64_t v8 = (const ObjectInfo ***)(v3 + 8 * v4);
        goto LABEL_25;
      }
    }
    uint64_t v8 = (const ObjectInfo ***)(v3 + v6);
    if (8 * v4 - 8 != v6)
    {
      unsigned int v9 = v8 + 1;
      do
      {
        uint64_t v10 = *v9;
        if (**v9 != a2)
        {
          *unsigned int v9 = 0;
          uint64_t v11 = *v8;
          *uint64_t v8 = v10;
          if (v11)
          {
            uint64_t v12 = v11[90];
            v11[90] = 0;
            if (v12) {
              MEMORY[0x1D25D9CB0](v12, 0x1000C80451B5BE8);
            }
            uint64_t v13 = v11[87];
            v11[87] = 0;
            if (v13) {
              MEMORY[0x1D25D9CB0](v13, 0x20C8093837F09);
            }
            uint64_t v14 = (char *)v11[21];
            uint64_t v15 = *((unsigned int *)v11 + 44);
            if (v15)
            {
              uint64_t v16 = 8 * v15;
              uint64_t v17 = v14 - 8;
              do
              {
                sub_1CBF38D08((uint64_t *)&v17[v16]);
                v16 -= 8;
              }
              while (v16);
              uint64_t v14 = (char *)v11[21];
            }
            if (v14 != (char *)(v11 + 23)) {
              free(v14);
            }
            std::recursive_mutex::~recursive_mutex((std::recursive_mutex *)(v11 + 12));
            this = MEMORY[0x1D25D9CE0](v11, 0x10F0C405548DE63);
          }
          ++v8;
        }
        ++v9;
      }
      while (v9 != v7);
      uint64_t v3 = *(void *)(v2 + 48);
      LODWORD(v4) = *(_DWORD *)(v2 + 56);
    }
  }
  else
  {
    uint64_t v8 = *(const ObjectInfo ****)(this + 48);
  }
LABEL_25:
  char v18 = (const ObjectInfo ***)(v3 + 8 * v4);
  if (v18 != v8)
  {
    do
    {
      uint64_t v20 = (uint64_t)*--v18;
      uint64_t v19 = v20;
      *char v18 = 0;
      if (v20)
      {
        uint64_t v21 = *(void *)(v19 + 720);
        *(void *)(v19 + 720) = 0;
        if (v21) {
          MEMORY[0x1D25D9CB0](v21, 0x1000C80451B5BE8);
        }
        uint64_t v22 = *(void *)(v19 + 696);
        *(void *)(v19 + 696) = 0;
        if (v22) {
          MEMORY[0x1D25D9CB0](v22, 0x20C8093837F09);
        }
        BOOL v23 = *(char **)(v19 + 168);
        uint64_t v24 = *(unsigned int *)(v19 + 176);
        if (v24)
        {
          uint64_t v25 = 8 * v24;
          uint64_t v26 = v23 - 8;
          do
          {
            sub_1CBF38D08((uint64_t *)&v26[v25]);
            v25 -= 8;
          }
          while (v25);
          BOOL v23 = *(char **)(v19 + 168);
        }
        if (v23 != (char *)(v19 + 184)) {
          free(v23);
        }
        std::recursive_mutex::~recursive_mutex((std::recursive_mutex *)(v19 + 96));
        this = MEMORY[0x1D25D9CE0](v19, 0x10F0C405548DE63);
      }
    }
    while (v18 != v8);
    uint64_t v3 = *(void *)(v2 + 48);
  }
  *(_DWORD *)(v2 + 56) = ((unint64_t)v8 - v3) >> 3;
  return this;
}

uint64_t llvm::agxapstrace::AddressTranslator::toSectionRelative@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v5 = result;
  uint64_t v7 = *(unsigned int *)(result + 56);
  if (v7)
  {
    uint64_t v8 = *(void **)(result + 48);
    unint64_t v9 = *(unsigned int *)(result + 56);
    do
    {
      unint64_t v10 = v9 >> 1;
      uint64_t v11 = &v8[v9 >> 1];
      uint64_t v13 = *v11;
      uint64_t v12 = v11 + 1;
      v9 += ~(v9 >> 1);
      if (*(void *)(v13 + 64) < a2) {
        uint64_t v8 = v12;
      }
      else {
        unint64_t v9 = v10;
      }
    }
    while (v9);
  }
  else
  {
    uint64_t v8 = *(void **)(result + 48);
  }
  if (v8 == (void *)(*(void *)(result + 48) + 8 * v7)
    || (uint64_t v14 = *v8, v15 = *(void *)(*v8 + 56), v16 = a2 >= v15, v17 = a2 - v15, !v16)
    || *(void *)(v14 + 64) <= a2)
  {
    if (a3
      && (uint64_t result = *(void *)(result + 120)) != 0
      && (unint64_t v18 = a2,
          uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t *))(*(void *)result + 48))(result, &v18),
          result))
    {
      return llvm::agxapstrace::AddressTranslator::toSectionRelative(v5, a2, 0);
    }
    else
    {
      *(unsigned char *)a4 = 0;
      *(unsigned char *)(a4 + 16) = 0;
    }
  }
  else
  {
    *(void *)a4 = v14;
    *(void *)(a4 + 8) = v17;
    *(unsigned char *)(a4 + 16) = 1;
  }
  return result;
}

char *llvm::agxapstrace::AddressTranslator::toSystem(uint64_t a1, void *a2, size_t a3, void *a4, size_t a5, void *a6, size_t a7, uint64_t a8)
{
  Object = (const void ***)llvm::agxapstrace::AddressTranslator::findObject((uint64_t *)a1, a2, a3);
  Section = llvm::agxapstrace::AddressTranslator::findSection(a1, Object, a4, a5, a6, a7);
  if (Section == (const void ***)(*(void *)(a1 + 48) + 8 * *(unsigned int *)(a1 + 56))) {
    return 0;
  }
  else {
    return (char *)(*Section)[7] + a8;
  }
}

llvm::raw_ostream *llvm::agxapstrace::AddressTranslator::print(llvm::agxapstrace::AddressTranslator *this, llvm::raw_ostream *a2)
{
  uint64_t v4 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v4) > 0x10)
  {
    *(unsigned char *)(v4 + 16) = 10;
    *(_OWORD *)uint64_t v4 = *(_OWORD *)"Address   : Name\n";
    *((void *)a2 + 4) += 17;
  }
  else
  {
    llvm::raw_ostream::write(a2, "Address   : Name\n", 0x11uLL);
  }
  uint64_t v5 = *((unsigned int *)this + 14);
  if (!v5)
  {
    unint64_t v6 = 0;
LABEL_20:
    uint64_t result = sub_1CBF36F68(a2, v6);
    uint64_t v15 = *((void *)a2 + 4);
    if ((unint64_t)(*((void *)a2 + 3) - v15) > 0xA)
    {
      *(_DWORD *)(v15 + 7) = 171861097;
      *(void *)uint64_t v15 = *(void *)" <invalid>\n";
      *((void *)a2 + 4) += 11;
    }
    else
    {
      return llvm::raw_ostream::write(a2, " <invalid>\n", 0xBuLL);
    }
    return result;
  }
  unint64_t v6 = 0;
  uint64_t v7 = (uint64_t *)*((void *)this + 6);
  uint64_t v8 = 8 * v5;
  do
  {
    if (*(void *)(*v7 + 56) != v6)
    {
      sub_1CBF36F68(a2, v6);
      uint64_t v9 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v9) > 0xA)
      {
        *(_DWORD *)(v9 + 7) = 171861097;
        *(void *)uint64_t v9 = *(void *)" <invalid>\n";
        *((void *)a2 + 4) += 11;
      }
      else
      {
        llvm::raw_ostream::write(a2, " <invalid>\n", 0xBuLL);
      }
    }
    sub_1CBF36F68(a2, *(void *)(*v7 + 56));
    unint64_t v10 = (unsigned char *)*((void *)a2 + 4);
    if (*((unsigned char **)a2 + 3) == v10)
    {
      uint64_t v11 = llvm::raw_ostream::write(a2, " ", 1uLL);
    }
    else
    {
      *unint64_t v10 = 32;
      ++*((void *)a2 + 4);
      uint64_t v11 = a2;
    }
    uint64_t result = llvm::agxapstrace::operator<<(v11, *v7);
    uint64_t v13 = (unsigned char *)*((void *)result + 4);
    if (*((unsigned char **)result + 3) == v13)
    {
      uint64_t result = llvm::raw_ostream::write(result, "\n", 1uLL);
    }
    else
    {
      *uint64_t v13 = 10;
      ++*((void *)result + 4);
    }
    uint64_t v14 = *v7++;
    unint64_t v6 = *(void *)(v14 + 64);
    v8 -= 8;
  }
  while (v8);
  if (v6 != -1) {
    goto LABEL_20;
  }
  return result;
}

uint64_t *sub_1CBF38BA4(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

void sub_1CBF38C0C(uint64_t a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  unint64_t v6 = malloc_type_malloc(8 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v7 = v6;
  uint64_t v8 = *(uint64_t **)a1;
  uint64_t v9 = *(unsigned int *)(a1 + 8);
  if (v9)
  {
    uint64_t v10 = 8 * v9;
    uint64_t v11 = 8 * v9;
    uint64_t v12 = v7;
    do
    {
      uint64_t v13 = *v8;
      *v8++ = 0;
      *v12++ = v13;
      v11 -= 8;
    }
    while (v11);
    uint64_t v14 = *(void *)a1 - 8;
    do
    {
      sub_1CBF38BA4((uint64_t *)(v14 + v10), 0);
      v10 -= 8;
    }
    while (v10);
    uint64_t v8 = *(uint64_t **)a1;
  }
  if (v8 != (uint64_t *)(a1 + 16)) {
    free(v8);
  }
  *(void *)a1 = v7;
  *(_DWORD *)(a1 + 12) = v5;
}

uint64_t *sub_1CBF38D08(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *(void **)(v2 + 16);
    if (v3 != (void *)(v2 + 32)) {
      free(v3);
    }
    MEMORY[0x1D25D9CE0](v2, 0x10D0C402C381C66);
  }
  return a1;
}

void sub_1CBF38D64(uint64_t a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  unint64_t v6 = malloc_type_malloc(8 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v7 = v6;
  uint64_t v8 = *(uint64_t **)a1;
  uint64_t v9 = *(unsigned int *)(a1 + 8);
  if (v9)
  {
    uint64_t v10 = 8 * v9;
    uint64_t v11 = v7;
    do
    {
      uint64_t v12 = *v8;
      *v8++ = 0;
      *v11++ = v12;
      v10 -= 8;
    }
    while (v10);
    uint64_t v13 = *(uint64_t **)a1;
    uint64_t v14 = (uint64_t *)(*(void *)a1 + 8 * v9);
    do
    {
      uint64_t v16 = *--v14;
      uint64_t v15 = v16;
      *uint64_t v14 = 0;
      if (v16)
      {
        uint64_t v17 = *(void *)(v15 + 720);
        *(void *)(v15 + 720) = 0;
        if (v17) {
          MEMORY[0x1D25D9CB0](v17, 0x1000C80451B5BE8);
        }
        uint64_t v18 = *(void *)(v15 + 696);
        *(void *)(v15 + 696) = 0;
        if (v18) {
          MEMORY[0x1D25D9CB0](v18, 0x20C8093837F09);
        }
        uint64_t v19 = *(char **)(v15 + 168);
        uint64_t v20 = *(unsigned int *)(v15 + 176);
        if (v20)
        {
          uint64_t v21 = 8 * v20;
          uint64_t v22 = v19 - 8;
          do
          {
            sub_1CBF38D08((uint64_t *)&v22[v21]);
            v21 -= 8;
          }
          while (v21);
          uint64_t v19 = *(char **)(v15 + 168);
        }
        if (v19 != (char *)(v15 + 184)) {
          free(v19);
        }
        std::recursive_mutex::~recursive_mutex((std::recursive_mutex *)(v15 + 96));
        MEMORY[0x1D25D9CE0](v15, 0x10F0C405548DE63);
      }
    }
    while (v14 != v13);
    uint64_t v8 = *(uint64_t **)a1;
  }
  if (v8 != (uint64_t *)(a1 + 16)) {
    free(v8);
  }
  *(void *)a1 = v7;
  *(_DWORD *)(a1 + 12) = v5;
}

void *llvm::agxapstrace::Disassembler::Disassembler(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *uint64_t result = a2;
  result[1] = a3;
  result[2] = a4;
  return result;
}

{
  *uint64_t result = a2;
  result[1] = a3;
  result[2] = a4;
  return result;
}

void llvm::agxapstrace::Disassembler::getUncachedInstAt(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, unint64_t a4@<X4>, uint64_t a5@<X8>)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)a3 + 168))(&v23, a3, a2);
  uint64_t v8 = v23;
  if (v24)
  {
    *(unsigned char *)(a5 + 176) |= 1u;
    *(void *)a5 = v8;
    return;
  }
  if (*((void *)&v23 + 1) - 2 < a4)
  {
    std::generic_category();
    operator new();
  }
  uint64_t v22 = 0;
  long long v32 = 0uLL;
  uint64_t v33 = v35;
  uint64_t v34 = 0x800000000;
  char v36 = 0;
  uint64_t v29 = v31;
  long long v30 = xmmword_1CDB15B30;
  int v14 = 0;
  char v18 = 0;
  uint64_t v19 = 0;
  uint64_t v21 = &v29;
  int v20 = 0;
  uint64_t v13 = &unk_1F2646FA8;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  int v9 = (*(uint64_t (**)(void, long long *, uint64_t *, unint64_t, unint64_t, unint64_t, void **))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), &v32, &v22, v23 + a4, *((void *)&v23 + 1) - a4, a4, &v13);
  uint64_t v10 = v22;
  if (!v22)
  {
    uint64_t v10 = 1;
    uint64_t v22 = 1;
    if (v9) {
      goto LABEL_6;
    }
LABEL_9:
    std::generic_category();
    operator new();
  }
  if (!v9) {
    goto LABEL_9;
  }
LABEL_6:
  if (v9 == 1)
  {
    std::generic_category();
    operator new();
  }
  long long v23 = v32;
  uint64_t v24 = v26;
  uint64_t v25 = 0x800000000;
  int v11 = v34;
  if (v34)
  {
    if (v34 >= 9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy(v26, v33, 16 * v34);
    LODWORD(v25) = v11;
    uint64_t v10 = v22;
  }
  char v12 = v36;
  char v27 = v36;
  uint64_t v28 = v10;
  *(unsigned char *)(a5 + 176) &= ~1u;
  *(_OWORD *)a5 = v23;
  *(void *)(a5 + 16) = a5 + 32;
  *(void *)(a5 + 24) = 0x800000000;
  if (v11)
  {
    sub_1CBF399E0(a5 + 16, (uint64_t)&v24);
    char v12 = v27;
    uint64_t v10 = v28;
  }
  *(unsigned char *)(a5 + 160) = v12;
  *(void *)(a5 + 168) = v10;
  if (v24 != v26) {
    free(v24);
  }
  uint64_t v13 = &unk_1F2646B98;
  if (v20 == 1 && v15) {
    MEMORY[0x1D25D9CB0](v15, 0x1000C8077774924);
  }
  if (v29 != v31) {
    free(v29);
  }
  if (v33 != v35) {
    free(v33);
  }
}

void llvm::agxapstrace::CachedSectionDisassembler::CachedSectionDisassembler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = (*(void *)(a3 + 64) - *(void *)(a3 + 56)) >> 1;
  MEMORY[0x1D25D9910](a1 + 24);
  *(_DWORD *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = a1 + 112;
  *(void *)(a1 + 104) = 0x4000000000;
  operator new[]();
}

void llvm::agxapstrace::CachedSectionDisassembler::getInstAt(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    std::generic_category();
    operator new();
  }
  unint64_t v6 = a2 >> 1;
  uint64_t v7 = *(void *)(*(void *)(a1 + 632) + 8 * (a2 >> 1));
  if (v7)
  {
    *(unsigned char *)(a3 + 8) &= ~1u;
    *(void *)a3 = v7;
  }
  else
  {
    std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 24));
    unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(*(void *)(a1 + 632) + 8 * v6), memory_order_acquire);
    if (explicit)
    {
      *(unsigned char *)(a3 + 8) &= ~1u;
      *(void *)a3 = explicit;
    }
    else
    {
      llvm::agxapstrace::Disassembler::getUncachedInstAt(*(void *)(*(void *)a1 + 32), *(void *)(*(void *)(a1 + 8) + 24), *(void *)(*(void *)(a1 + 8) + 32), a2, (uint64_t)&v11);
      if ((v12 & 1) == 0) {
        operator new();
      }
      uint64_t v9 = v11;
      *(void *)&long long v11 = 0;
      *(unsigned char *)(a3 + 8) |= 1u;
      *(void *)a3 = v9;
      uint64_t v10 = v11;
      *(void *)&long long v11 = 0;
      if (v10) {
        (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
      }
    }
    std::recursive_mutex::unlock((std::recursive_mutex *)(a1 + 24));
  }
}

uint64_t llvm::agxapstrace::CachedSectionDisassembler::getBranchTarget(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *a5)
{
  _X0 = 0;
  uint64_t v9 = *a2 >> 1;
  _X1 = 0;
  __asm { CASP            X0, X1, X0, X1, [X8] }
  std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 24));
  _X0 = 0;
  _X1 = 0;
  __asm { CASPA           X0, X1, X0, X1, [X8] }
  uint64_t v28 = 0;
  uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t *))(*(void *)a4 + 104))(a4, a3, *a2 + *(void *)(*(void *)(a1 + 8) + 56), *(void *)(a3 + 168), &v28);
  if (v21)
  {
    _X0 = v28;
    *a5 = v28;
    long long v23 = (uint64_t *)(*(void *)(a1 + 656) + 16 * v9);
    uint64_t v24 = *v23;
    do
    {
      _X5 = v23[1];
      __asm { CASPL           X4, X5, X0, X1, [X8] }
      _ZF = _X4 == v24;
      uint64_t v24 = _X4;
    }
    while (!_ZF);
  }
  std::recursive_mutex::unlock((std::recursive_mutex *)(a1 + 24));
  return v21;
}

uint64_t llvm::agxapstrace::CachedSectionDisassembler::getMCInstPrinter(llvm::agxapstrace::CachedSectionDisassembler *this)
{
  return *(void *)(*(void *)(*(void *)this + 32) + 16);
}

uint64_t llvm::agxapstrace::CachedSectionDisassembler::getSTI(llvm::agxapstrace::CachedSectionDisassembler *this)
{
  return **(void **)(*(void *)this + 32);
}

void llvm::agxapstrace::CachedSectionDisassembler::prefetchAll(llvm::agxapstrace::CachedSectionDisassembler *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(*((void *)this + 1) + 56);
  uint64_t v4 = *(void *)(*((void *)this + 1) + 64);
  unint64_t v5 = v4 - v3;
  if (v4 == v3)
  {
    int v6 = 0;
LABEL_6:
    *(unsigned char *)(a2 + 8) &= ~1u;
    *(_DWORD *)a2 = v6;
  }
  else
  {
    unint64_t v8 = 0;
    int v6 = 0;
    while (1)
    {
      llvm::agxapstrace::CachedSectionDisassembler::getInstAt((uint64_t)this, v8, (uint64_t)&v10);
      if (v11) {
        break;
      }
      ++v6;
      v8 += *(void *)(v10 + 168);
      if (v8 >= v5) {
        goto LABEL_6;
      }
    }
    uint64_t v9 = v10;
    *(unsigned char *)(a2 + 8) |= 1u;
    *(void *)a2 = v9;
  }
}

uint64_t sub_1CBF399E0(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unint64_t v5 = (const void *)(a2 + 16);
    uint64_t v4 = *(const void **)a2;
    if (v4 == v5)
    {
      uint64_t v7 = (_DWORD *)(a2 + 8);
      uint64_t v8 = *(unsigned int *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a1 + 8);
      if (v9 >= v8)
      {
        if (v8) {
          memmove(*(void **)a1, v4, 16 * v8);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v8)
        {
          *(_DWORD *)(a1 + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v9) {
          memmove(*(void **)a1, v4, 16 * v9);
        }
        else {
          uint64_t v9 = 0;
        }
        uint64_t v10 = *v7;
        if (v9 != v10) {
          memcpy((void *)(*(void *)a1 + 16 * v9), (const void *)(*(void *)a2 + 16 * v9), *(void *)a2 + 16 * v10 - (*(void *)a2 + 16 * v9));
        }
      }
      *(_DWORD *)(a1 + 8) = v8;
    }
    else
    {
      int v6 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v6);
        uint64_t v4 = *(const void **)a2;
      }
      *(void *)a1 = v4;
      uint64_t v7 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
    }
    *uint64_t v7 = 0;
  }
  return a1;
}

void sub_1CBF39AFC(uint64_t a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  int v6 = malloc_type_malloc(8 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v7 = v6;
  uint64_t v8 = *(uint64_t **)a1;
  uint64_t v9 = *(unsigned int *)(a1 + 8);
  if (v9)
  {
    uint64_t v10 = 8 * v9;
    uint64_t v11 = 8 * v9;
    uint64_t v12 = v7;
    do
    {
      uint64_t v13 = *v8;
      *v8++ = 0;
      *v12++ = v13;
      v11 -= 8;
    }
    while (v11);
    uint64_t v14 = *(void *)a1 - 8;
    do
    {
      sub_1CBF38D08((uint64_t *)(v14 + v10));
      v10 -= 8;
    }
    while (v10);
    uint64_t v8 = *(uint64_t **)a1;
  }
  if (v8 != (uint64_t *)(a1 + 16)) {
    free(v8);
  }
  *(void *)a1 = v7;
  *(_DWORD *)(a1 + 12) = v5;
}

llvm::raw_ostream *llvm::agxapstrace::operator<<(llvm::raw_ostream *this, uint64_t a2)
{
  unint64_t v4 = (_DWORD *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v4 > 6uLL)
  {
    *(_DWORD *)((char *)v4 + 3) = 2067621236;
    *unint64_t v4 = 1952543859;
    *((void *)this + 4) += 7;
  }
  else
  {
    llvm::raw_ostream::write(this, "state={", 7uLL);
  }
  sub_1CBF36F68(this, *(void *)a2);
  uint64_t v5 = (void *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v5 > 0xDuLL)
  {
    qmemcpy(v5, ", any-threads=", 14);
    *((void *)this + 4) += 14;
  }
  else
  {
    llvm::raw_ostream::write(this, ", any-threads=", 0xEuLL);
  }
  sub_1CD098D14(this, *(unsigned __int8 *)(a2 + 8), 0, 0, 0);
  int v6 = (unsigned char *)*((void *)this + 4);
  if (*((unsigned char **)this + 3) == v6)
  {
    llvm::raw_ostream::write(this, "}", 1uLL);
  }
  else
  {
    *int v6 = 125;
    ++*((void *)this + 4);
  }
  return this;
}

void *llvm::agxapstrace::TracedInst::TracedInst(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *uint64_t result = a2;
  result[1] = a3;
  result[2] = a4;
  return result;
}

{
  *uint64_t result = a2;
  result[1] = a3;
  result[2] = a4;
  return result;
}

void *llvm::agxapstrace::BranchTargetResolutionError::BranchTargetResolutionError(void *a1, llvm::Twine *this, uint64_t a3)
{
  *a1 = &unk_1F25FF170;
  llvm::Twine::str(this, a1 + 1);
  a1[4] = a3;
  return a1;
}

{
  *a1 = &unk_1F25FF170;
  llvm::Twine::str(this, a1 + 1);
  a1[4] = a3;
  return a1;
}

llvm::raw_ostream *llvm::agxapstrace::BranchTargetResolutionError::log(llvm::agxapstrace::BranchTargetResolutionError *this, llvm::raw_ostream *a2)
{
  uint64_t v5 = (const char *)*((void *)this + 1);
  uint64_t v3 = (char *)this + 8;
  unint64_t v4 = v5;
  char v6 = v3[23];
  int v7 = v6;
  if (v6 >= 0) {
    uint64_t v8 = v3;
  }
  else {
    uint64_t v8 = v4;
  }
  size_t v9 = v6 & 0x7F;
  if (v7 >= 0) {
    size_t v10 = v9;
  }
  else {
    size_t v10 = *((void *)v3 + 1);
  }
  return llvm::raw_ostream::write(a2, v8, v10);
}

uint64_t llvm::agxapstrace::BranchTargetResolutionError::convertToErrorCode(llvm::agxapstrace::BranchTargetResolutionError *this)
{
  return 45;
}

uint64_t sub_1CBF39E1C(uint64_t a1)
{
  *(void *)a1 = &unk_1F25FF170;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1CBF39E6C(uint64_t a1)
{
  *(void *)a1 = &unk_1F25FF170;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CBF39EDC()
{
  return &llvm::agxapstrace::BranchTargetResolutionError::ID;
}

BOOL sub_1CBF39EE8(uint64_t a1, void *a2)
{
  return a2 == &llvm::agxapstrace::BranchTargetResolutionError::ID || a2 == &llvm::ErrorInfoBase::ID;
}

void llvm::agxclauseanalyzer::createAsmInput(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::string **a10)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  __int16 v33 = 261;
  v32[0] = a1;
  v32[1] = a2;
  llvm::MemoryBuffer::getFileOrSTDIN((llvm::MemoryBuffer *)v32, 0, 1, (uint64_t)&v35);
  if (v36)
  {
    uint64_t v15 = v35;
    if (v35) {
      operator new();
    }
  }
  else
  {
    std::system_category();
    uint64_t v15 = v35;
  }
  llvm::mc::InitMCTargetOptionsFromFlags((uint64_t)v32);
  uint64_t v31 = 0;
  memset(v30, 0, sizeof(v30));
  uint64_t v35 = 0;
  uint64_t v29 = v15;
  sub_1CD452CE0((uint64_t)v30, &v29, 0);
  uint64_t v16 = v29;
  uint64_t v29 = 0;
  if (v16) {
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  uint64_t v17 = *(uint64_t (**)(uint64_t))(a3 + 64);
  if (!v17 || (uint64_t v18 = v17(v16)) == 0)
  {
    std::generic_category();
    operator new();
  }
  uint64_t v19 = v18;
  char v20 = *(unsigned char *)(a4 + 23);
  BOOL v21 = v20 < 0;
  uint64_t v22 = *(void *)(a4 + 8);
  if (v20 < 0) {
    a4 = *(void *)a4;
  }
  uint64_t v23 = v20 & 0x7F;
  if (v21) {
    uint64_t v24 = v22;
  }
  else {
    uint64_t v24 = v23;
  }
  sub_1CD4FB688(*a10, a10[1], ",", 1uLL, &v34);
  if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v25 = &v34;
  }
  else {
    uint64_t v25 = (std::string *)v34.__r_.__value_.__r.__words[0];
  }
  if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t size = *((unsigned char *)&v34.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    uint64_t size = v34.__r_.__value_.__l.__size_;
  }
  uint64_t v27 = sub_1CD452D6C(a3, a4, v24, a5, a6, (uint64_t)v25, size);
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v34.__r_.__value_.__l.__data_);
  }
  if (!v27)
  {
    std::generic_category();
    operator new();
  }
  uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 144);
  if (v28)
  {
    if (v28(v19, a7)) {
      operator new();
    }
  }
  std::generic_category();
  operator new();
}

char *sub_1CBF3A948(void **a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) > v3) {
    unint64_t v3 = 0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) >= 0x555555555555555) {
    unint64_t v5 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v5 = v3;
  }
  if (v5 > 0xAAAAAAAAAAAAAAALL) {
    sub_1CB833614();
  }
  uint64_t v7 = 3 * v5;
  uint64_t v8 = (char *)operator new(24 * v5);
  size_t v9 = &v8[24 * v2];
  size_t v10 = &v8[8 * v7];
  *(_OWORD *)size_t v9 = *(_OWORD *)a2;
  *((void *)v9 + 2) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v11 = v9 + 24;
  uint64_t v12 = (char *)*a1;
  uint64_t v13 = (char *)a1[1];
  if (v13 == *a1)
  {
    *a1 = v9;
    a1[1] = v11;
    a1[2] = v10;
  }
  else
  {
    uint64_t v14 = 0;
    do
    {
      uint64_t v15 = &v9[v14];
      uint64_t v16 = &v13[v14];
      long long v17 = *(_OWORD *)&v13[v14 - 24];
      *((void *)v16 - 3) = 0;
      *(_OWORD *)(v15 - 24) = v17;
      *((void *)v15 - 1) = *(void *)&v13[v14 - 8];
      *((void *)v16 - 2) = 0;
      v14 -= 24;
    }
    while (&v13[v14] != v12);
    uint64_t v13 = (char *)*a1;
    uint64_t v18 = (char *)a1[1];
    *a1 = &v9[v14];
    a1[1] = v11;
    a1[2] = v10;
    while (v18 != v13)
      llvm::SourceMgr::SrcBuffer::~SrcBuffer((llvm::SourceMgr::SrcBuffer *)(v18 - 24));
  }
  if (v13) {
    operator delete(v13);
  }
  return v11;
}

uint64_t sub_1CBF3AA88(uint64_t a1)
{
  *(void *)a1 = &unk_1F25FF1C0;
  sub_1CB833A08(a1 + 240, *(void **)(a1 + 248));
  unint64_t v2 = *(void **)(a1 + 96);
  if (v2 != (void *)(a1 + 112)) {
    free(v2);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 72), 8);
  unint64_t v5 = (void **)(a1 + 48);
  sub_1CBF3AE04(&v5);
  unint64_t v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(void *)(a1 + 32) = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_1CBF3AB18(uint64_t a1)
{
  *(void *)a1 = &unk_1F25FF1C0;
  sub_1CB833A08(a1 + 240, *(void **)(a1 + 248));
  unint64_t v2 = *(void **)(a1 + 96);
  if (v2 != (void *)(a1 + 112)) {
    free(v2);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 72), 8);
  unint64_t v4 = (void **)(a1 + 48);
  sub_1CBF3AE04(&v4);
  unint64_t v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(void *)(a1 + 32) = v3;
    operator delete(v3);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CBF3ABC8@<X0>(unint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return sub_1CBF3AE94(a3, a1, a2);
}

uint64_t sub_1CBF3ABD8@<X0>(unint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t result = sub_1CBF3AE94((uint64_t)&v6, a1, a2);
  uint64_t v5 = v6;
  *(unsigned char *)(a3 + 8) = *(unsigned char *)(a3 + 8) & 0xFE | v7 & 1;
  *(void *)a3 = v5;
  return result;
}

void sub_1CBF3AC54(uint64_t a1@<X0>, uint64_t a2@<X1>, char **a3@<X8>)
{
  unint64_t v4 = a3;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v5 = *(void *)(a1 + 256);
  if (v5)
  {
    uint64_t v6 = (unint64_t *)(a1 + 248);
    char v7 = *(unint64_t **)(a1 + 240);
  }
  else
  {
    char v7 = *(unint64_t **)(a1 + 96);
    uint64_t v6 = &v7[*(unsigned int *)(a1 + 104)];
  }
  if (v7 != v6)
  {
    uint64_t v8 = 0;
    size_t v9 = 0;
    size_t v10 = 0;
    do
    {
      uint64_t v11 = v7 + 4;
      if (!v5) {
        uint64_t v11 = v7;
      }
      unint64_t v12 = *v11;
      if (*(void *)(a2 + 8) <= *v11 && v12 < *(void *)(a2 + 24))
      {
        if (v10 >= v8)
        {
          uint64_t v14 = (v10 - v9) >> 3;
          unint64_t v15 = v14 + 1;
          if ((unint64_t)(v14 + 1) >> 61) {
            abort();
          }
          if ((v8 - v9) >> 2 > v15) {
            unint64_t v15 = (v8 - v9) >> 2;
          }
          if ((unint64_t)(v8 - v9) >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v16 = v15;
          }
          if (v16)
          {
            if (v16 >> 61) {
              sub_1CB833614();
            }
            long long v17 = (char *)operator new(8 * v16);
            unint64_t v4 = a3;
          }
          else
          {
            long long v17 = 0;
          }
          uint64_t v18 = &v17[8 * v14];
          *(void *)uint64_t v18 = v12;
          uint64_t v13 = v18 + 8;
          while (v10 != v9)
          {
            uint64_t v19 = *((void *)v10 - 1);
            v10 -= 8;
            *((void *)v18 - 1) = v19;
            v18 -= 8;
          }
          uint64_t v8 = &v17[8 * v16];
          *unint64_t v4 = v18;
          v4[1] = v13;
          v4[2] = v8;
          if (v9)
          {
            operator delete(v9);
            unint64_t v4 = a3;
          }
          size_t v9 = v18;
        }
        else
        {
          *(void *)size_t v10 = v12;
          uint64_t v13 = v10 + 8;
        }
        v4[1] = v13;
        size_t v10 = v13;
      }
      if (v5)
      {
        char v20 = (unint64_t *)v7[1];
        if (v20)
        {
          do
          {
            BOOL v21 = v20;
            char v20 = (unint64_t *)*v20;
          }
          while (v20);
        }
        else
        {
          do
          {
            BOOL v21 = (unint64_t *)v7[2];
            BOOL v22 = *v21 == (void)v7;
            char v7 = v21;
          }
          while (!v22);
        }
      }
      else
      {
        BOOL v21 = v7 + 1;
      }
      char v7 = v21;
    }
    while (v21 != v6);
  }
}

void sub_1CBF3AE04(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = (char *)*((void *)v4 - 19);
        if (v4 - 136 != v6) {
          free(v6);
        }
        v4 -= 192;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1CBF3AE94(uint64_t result, unint64_t *a2, unint64_t a3)
{
  unint64_t v20 = a3;
  for (unsigned int i = (void *)a2[6]; ; i += 24)
  {
    if (i == (void *)a2[7])
    {
      sub_1CD452F60(&v20, (uint64_t)&v15);
      uint64_t v5 = std::string::insert(&v15, 0, "Did not assemble instr at given offset ");
      std::string::size_type v6 = v5->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v16.__r_.__value_.__l.__data_ = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
      v16.__r_.__value_.__r.__words[2] = v6;
      v5->__r_.__value_.__l.__size_ = 0;
      v5->__r_.__value_.__r.__words[2] = 0;
      v5->__r_.__value_.__r.__words[0] = 0;
      char v7 = std::string::append(&v16, " of ");
      std::string::size_type v8 = v7->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v17.__r_.__value_.__l.__data_ = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
      v17.__r_.__value_.__r.__words[2] = v8;
      v7->__r_.__value_.__l.__size_ = 0;
      v7->__r_.__value_.__r.__words[2] = 0;
      v7->__r_.__value_.__r.__words[0] = 0;
      sub_1CD45302C((uint64_t)v13, a2[2]);
      if (v14 >= 0) {
        size_t v9 = v13;
      }
      else {
        size_t v9 = (void **)v13[0];
      }
      if (v14 >= 0) {
        std::string::size_type v10 = v14 & 0x7F;
      }
      else {
        std::string::size_type v10 = (std::string::size_type)v13[1];
      }
      uint64_t v11 = std::string::append(&v17, (const std::string::value_type *)v9, v10);
      std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
      std::string::size_type v19 = v12;
      v11->__r_.__value_.__l.__size_ = 0;
      v11->__r_.__value_.__r.__words[2] = 0;
      v11->__r_.__value_.__r.__words[0] = 0;
      std::generic_category();
      operator new();
    }
    if (*i == a3) {
      break;
    }
  }
  *(unsigned char *)(result + 8) &= ~1u;
  *(void *)uint64_t result = i;
  return result;
}

void sub_1CBF3B07C(llvm::MCStreamer *a1)
{
}

void sub_1CBF3B08C()
{
  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CBF3B0B4()
{
  return 0;
}

uint64_t sub_1CBF3B0BC()
{
  return 0;
}

uint64_t sub_1CBF3B0CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 288);
  char v14 = *(uint64_t **)(a1 + 272);
  char v7 = v14;
  uint64_t v15 = a2;
  sub_1CD4531A0((uint64_t *)(v6 + 72), &v15)[1] = v14;
  if (*(unsigned char *)(v15 + 8)) {
    return llvm::MCStreamer::emitLabel(a1, a2, a3);
  }
  if (*(void *)(v6 + 256))
  {
    std::string::size_type v12 = (uint64_t **)(v6 + 240);
LABEL_16:
    sub_1CD3CFB98(v12, (unint64_t *)&v14, &v14);
    return llvm::MCStreamer::emitLabel(a1, a2, a3);
  }
  uint64_t v8 = *(unsigned int *)(v6 + 104);
  if (v8)
  {
    uint64_t v9 = 8 * v8;
    std::string::size_type v10 = *(uint64_t ***)(v6 + 96);
    while (*v10 != v7)
    {
      ++v10;
      v9 -= 8;
      if (!v9) {
        goto LABEL_9;
      }
    }
    if (v9) {
      return llvm::MCStreamer::emitLabel(a1, a2, a3);
    }
LABEL_9:
    if (v8 > 0xF)
    {
      do
      {
        uint64_t v13 = (unint64_t *)(*(void *)(v6 + 96) + 8 * v8 - 8);
        sub_1CD3CFB98((uint64_t **)(v6 + 240), v13, (uint64_t **)v13);
        LODWORD(v8) = *(_DWORD *)(v6 + 104) - 1;
        *(_DWORD *)(v6 + 104) = v8;
      }
      while (v8);
      std::string::size_type v12 = (uint64_t **)(v6 + 240);
      goto LABEL_16;
    }
  }
  if (v8 >= *(_DWORD *)(v6 + 108)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)(v6 + 96) + 8 * v8) = v7;
  ++*(_DWORD *)(v6 + 104);
  return llvm::MCStreamer::emitLabel(a1, a2, a3);
}

uint64_t sub_1CBF3B214()
{
  return 1;
}

uint64_t sub_1CBF3B234(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 520))();
}

void sub_1CBF3B264(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 272);
  unint64_t v6 = a2 - 1 - (v5 + (unint64_t)a2 - 1) % a2;
  unint64_t v7 = a4;
  if (v6 < a4) {
    unint64_t v7 = v6;
  }
  if (a4) {
    unint64_t v8 = v7;
  }
  else {
    unint64_t v8 = v6;
  }
  __int16 v11 = 0;
  if (v8 >= 2)
  {
    do
    {
      std::string::size_type v10 = *(void **)(a1 + 288);
      long long v12 = 0uLL;
      uint64_t v13 = v15;
      uint64_t v14 = 0x800000000;
      v15[128] = 0;
      sub_1CBF3B5F0(v10, v5, (char *)&v11, 2, &v12);
      if (v13 != v15) {
        free(v13);
      }
      uint64_t v5 = *(void *)(a1 + 272) + 2;
      *(void *)(a1 + 272) = v5;
      v8 -= 2;
    }
    while (v8 > 1);
  }
}

void sub_1CBF3B368(uint64_t a1, long long *a2, uint64_t a3)
{
  v19[12] = *MEMORY[0x1E4F143B8];
  memset(&v17, 0, sizeof(v17));
  int v9 = 0;
  char v13 = 0;
  uint64_t v14 = 0;
  __str = &v17;
  int v15 = 0;
  unint64_t v8 = &unk_1F2646F30;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  v18[0] = v19;
  v18[1] = (void *)0x400000000;
  (*(void (**)(void, long long *, void **, void **, uint64_t))(**(void **)(a1 + 280) + 32))(*(void *)(a1 + 280), a2, &v8, v18, a3);
  std::string::operator=(&v17, __str);
  if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v5 = &v17;
  }
  else {
    uint64_t v5 = (std::string *)v17.__r_.__value_.__r.__words[0];
  }
  if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int64_t size = *((unsigned char *)&v17.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    int64_t size = v17.__r_.__value_.__l.__size_;
  }
  sub_1CBF3B5F0(*(void **)(a1 + 288), *(void *)(a1 + 272), (char *)v5, size, a2);
  std::string::size_type v7 = *((unsigned char *)&v17.__r_.__value_.__s + 23) & 0x7F;
  if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v7 = v17.__r_.__value_.__l.__size_;
  }
  *(void *)(a1 + 272) += v7;
  if (v18[0] != v19) {
    free(v18[0]);
  }
  unint64_t v8 = &unk_1F2646B98;
  if (v15 == 1 && v10) {
    MEMORY[0x1D25D9CB0](v10, 0x1000C8077774924);
  }
  if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v17.__r_.__value_.__l.__data_);
  }
}

void *sub_1CBF3B524(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  unint64_t v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4532B4(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *uint64_t result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

void sub_1CBF3B5F0(void *a1, uint64_t a2, char *a3, int64_t a4, long long *a5)
{
  unsigned int v8 = (char *)a1[4];
  int v9 = a1 + 3;
  uint64_t v10 = &v8[-a1[3]];
  sub_1CBF3B8F8((uint64_t)(a1 + 3), v8, a3, &a3[a4], a4);
  uint64_t v11 = &v10[*v9];
  uint64_t v12 = v9[1] - (void)v11;
  uint64_t v14 = (char *)v9[4];
  unint64_t v13 = v9[5];
  if ((unint64_t)v14 >= v13)
  {
    uint64_t v18 = (char *)a1[6];
    unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((v14 - v18) >> 6) + 1;
    if (v19 > 0x155555555555555) {
      abort();
    }
    unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v18) >> 6);
    if (2 * v20 > v19) {
      unint64_t v19 = 2 * v20;
    }
    if (v20 >= 0xAAAAAAAAAAAAAALL) {
      unint64_t v21 = 0x155555555555555;
    }
    else {
      unint64_t v21 = v19;
    }
    if (v21)
    {
      if (v21 > 0x155555555555555) {
        sub_1CB833614();
      }
      BOOL v22 = operator new(192 * v21);
    }
    else
    {
      BOOL v22 = 0;
    }
    unint64_t v36 = 0xAAAAAAAAAAAAAAABLL * ((v14 - v18) >> 6);
    uint64_t v23 = &v22[64 * ((v14 - v18) >> 6)];
    *(void *)uint64_t v23 = a2;
    *((void *)v23 + 1) = v11;
    *((void *)v23 + 2) = v12;
    *(_OWORD *)(v23 + 24) = *a5;
    *((void *)v23 + 5) = v23 + 56;
    *((void *)v23 + 6) = 0x800000000;
    unsigned int v24 = *((_DWORD *)a5 + 6);
    if (v24 && v23 + 40 != (char *)(a5 + 1))
    {
      if (v24 >= 9)
      {
        *((_DWORD *)v23 + 12) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v23 + 56, *((const void **)a5 + 2), 16 * *((unsigned int *)a5 + 6));
      *((_DWORD *)v23 + 12) = v24;
      uint64_t v18 = (char *)a1[6];
      uint64_t v14 = (char *)a1[7];
    }
    uint64_t v25 = &v22[192 * v21];
    v22[192 * v36 + 184] = *((unsigned char *)a5 + 160);
    std::string v17 = v23 + 192;
    if (v14 == v18)
    {
      a1[6] = v23;
      a1[7] = v17;
      a1[8] = v25;
    }
    else
    {
      uint64_t v26 = 0;
      do
      {
        uint64_t v27 = &v23[v26];
        uint64_t v28 = &v14[v26];
        long long v29 = *(_OWORD *)&v14[v26 - 192];
        *((void *)v27 - 22) = *(void *)&v14[v26 - 176];
        *((_OWORD *)v27 - 12) = v29;
        long long v30 = *(_OWORD *)&v14[v26 - 168];
        *(void *)&v23[v26 - 152] = &v23[v26 - 136];
        uint64_t v31 = (uint64_t)&v23[v26 - 152];
        *(_OWORD *)(v31 - 16) = v30;
        *(void *)(v31 + 8) = 0x800000000;
        if (*(_DWORD *)&v14[v26 - 144]) {
          sub_1CBF399E0(v31, (uint64_t)(v28 - 152));
        }
        *(v27 - 8) = *(v28 - 8);
        v26 -= 192;
      }
      while (&v14[v26] != v18);
      uint64_t v18 = (char *)a1[6];
      long long v32 = (char *)a1[7];
      a1[6] = &v23[v26];
      a1[7] = v17;
      a1[8] = v25;
      while (v32 != v18)
      {
        __int16 v33 = (char *)*((void *)v32 - 19);
        if (v32 - 136 != v33) {
          free(v33);
        }
        v32 -= 192;
      }
    }
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    *(void *)uint64_t v14 = a2;
    *((void *)v14 + 1) = v11;
    *((void *)v14 + 2) = v12;
    long long v15 = *a5;
    *((void *)v14 + 5) = v14 + 56;
    *(_OWORD *)(v14 + 24) = v15;
    *((void *)v14 + 6) = 0x800000000;
    unsigned int v16 = *((_DWORD *)a5 + 6);
    if (v16 && v14 + 40 != (char *)(a5 + 1))
    {
      if (v16 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v14 + 56, *((const void **)a5 + 2), 16 * *((unsigned int *)a5 + 6));
      *((_DWORD *)v14 + 12) = v16;
    }
    v14[184] = *((unsigned char *)a5 + 160);
    std::string v17 = v14 + 192;
  }
  a1[7] = v17;
  uint64_t v34 = a1[3];
  uint64_t v35 = a1[4] - v34;
  a1[1] = v34;
  a1[2] = v35;
}

char *sub_1CBF3B8F8(uint64_t a1, char *__dst, char *__src, char *a4, int64_t a5)
{
  unint64_t v5 = __dst;
  if (a5 < 1) {
    return v5;
  }
  uint64_t v10 = *(char **)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  if (v9 - (uint64_t)v10 < a5)
  {
    uint64_t v11 = *(char **)a1;
    uint64_t v12 = (uint64_t)&v10[a5 - *(void *)a1];
    if (v12 < 0) {
      abort();
    }
    unint64_t v13 = (char *)(__dst - v11);
    unint64_t v14 = v9 - (void)v11;
    if (2 * v14 > v12) {
      uint64_t v12 = 2 * v14;
    }
    if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v15 = v12;
    }
    if (v15)
    {
      size_t v16 = v15;
      std::string v17 = (char *)operator new(v15);
    }
    else
    {
      size_t v16 = 0;
      std::string v17 = 0;
    }
    uint64_t v27 = &v13[(void)v17];
    memcpy(&v13[(void)v17], __src, a5);
    uint64_t v28 = &v13[(void)v17];
    size_t v29 = v16;
    if (v11 != v5)
    {
      do
      {
        v13[(void)v17 - 1] = v13[(void)(v11 - 1)];
        --v13;
      }
      while (v13);
      uint64_t v10 = *(char **)(a1 + 8);
      uint64_t v28 = v17;
    }
    long long v30 = &v27[a5];
    uint64_t v31 = &v17[v29];
    if (v10 != v5) {
      memmove(v30, v5, v10 - v5);
    }
    long long v32 = *(char **)a1;
    *(void *)a1 = v28;
    *(void *)(a1 + 8) = &v30[v10 - v5];
    *(void *)(a1 + 16) = v31;
    if (v32) {
      operator delete(v32);
    }
    return v27;
  }
  uint64_t v18 = v10 - __dst;
  if (v10 - __dst >= a5)
  {
    unint64_t v19 = &__src[a5];
    unint64_t v21 = *(char **)(a1 + 8);
LABEL_17:
    BOOL v22 = &v5[a5];
    uint64_t v23 = &v21[-a5];
    unsigned int v24 = v21;
    if (&v21[-a5] < v10)
    {
      int64_t v25 = &v10[a5] - v21;
      unsigned int v24 = v21;
      do
      {
        char v26 = *v23++;
        *v24++ = v26;
        --v25;
      }
      while (v25);
    }
    *(void *)(a1 + 8) = v24;
    if (v21 != v22) {
      memmove(&v5[a5], v5, v21 - v22);
    }
    if (v19 != __src) {
      memmove(v5, __src, v19 - __src);
    }
    return v5;
  }
  unint64_t v19 = &__src[v18];
  int64_t v20 = a4 - &__src[v18];
  if (a4 != &__src[v18]) {
    memmove(*(void **)(a1 + 8), &__src[v18], a4 - &__src[v18]);
  }
  unint64_t v21 = &v10[v20];
  *(void *)(a1 + 8) = &v10[v20];
  if (v18 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

uint64_t sub_1CBF3BAE0()
{
  return llvm::mc::RegisterMCTargetOptionsFlags::RegisterMCTargetOptionsFlags((uint64_t)&unk_1EA618B28);
}

void *llvm::agxclauseanalyzer::createObjInput@<X0>(uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t result = (*(void *(**)(uint64_t *__return_ptr))(**(void **)(a1 + 8) + 168))(&v5);
  uint64_t v4 = v5;
  if ((v6 & 1) == 0) {
    operator new();
  }
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(a2 + 8) & 0xFE | 1;
  *(void *)a2 = v4;
  return result;
}

void *sub_1CBF3BC08(void *a1)
{
  *a1 = &unk_1F25FF718;
  sub_1CBF3C890(a1 + 7);
  return a1;
}

void sub_1CBF3BC4C(void *a1)
{
  *a1 = &unk_1F25FF718;
  sub_1CBF3C890(a1 + 7);

  JUMPOUT(0x1D25D9CE0);
}

int *sub_1CBF3BCB0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = *(unsigned int *)(a1 + 72);
  uint64_t result = sub_1CBF3C94C(v6, v7, a2);
  if ((int *)(v6 + 16 * v7) == result)
  {
    unint64_t v19 = &v21;
    uint64_t v20 = 0;
    v24[0] = 0;
    v24[1] = 0;
    v24[2] = v25;
    v24[3] = 0x800000000;
    v25[128] = 0;
    unint64_t v21 = &v23;
    long long v22 = xmmword_1CDB15B30;
    int v12 = 0;
    char v16 = 0;
    uint64_t v17 = 0;
    int v18 = 0;
    uint64_t v11 = &unk_1F2646FA8;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    int v10 = (*(uint64_t (**)(void, void *, uint64_t *, uint64_t, uint64_t, uint64_t, void **))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24), v24, &v20, *(void *)(a1 + 8) + a2, *(void *)(a1 + 16) - a2, a2, &v11);
    if (v20)
    {
      if (v10) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v20 = 1;
      if (v10)
      {
LABEL_5:
        if (v10 == 1)
        {
          std::generic_category();
          operator new();
        }
        operator new();
      }
    }
    std::generic_category();
    operator new();
  }
  uint64_t v9 = *((void *)result + 1);
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(void *)a3 = v9;
  return result;
}

int *sub_1CBF3C06C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = *(unsigned int *)(a1 + 72);
  uint64_t result = sub_1CBF3C94C(v6, v7, a2);
  if ((int *)(v6 + 16 * v7) == result)
  {
    unint64_t v19 = &v21;
    uint64_t v20 = 0;
    v24[0] = 0;
    v24[1] = 0;
    v24[2] = v25;
    v24[3] = 0x800000000;
    v25[128] = 0;
    unint64_t v21 = &v23;
    long long v22 = xmmword_1CDB15B30;
    int v12 = 0;
    char v16 = 0;
    uint64_t v17 = 0;
    int v18 = 0;
    uint64_t v11 = &unk_1F2646FA8;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    int v10 = (*(uint64_t (**)(void, void *, uint64_t *, uint64_t, uint64_t, uint64_t, void **))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24), v24, &v20, *(void *)(a1 + 8) + a2, *(void *)(a1 + 16) - a2, a2, &v11);
    if (v20)
    {
      if (v10) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v20 = 1;
      if (v10)
      {
LABEL_5:
        if (v10 == 1)
        {
          std::generic_category();
          operator new();
        }
        operator new();
      }
    }
    std::generic_category();
    operator new();
  }
  uint64_t v9 = *((void *)result + 1);
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(void *)a3 = v9;
  return result;
}

uint64_t sub_1CBF3C428@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, char **a4@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  uint64_t v8 = a1[4];
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 48))(v8);
  uint64_t v11 = v10;
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 56))(v8);
  uint64_t v43 = v9;
  uint64_t v44 = v11;
  if (v9 == v12) {
    return std::__sort<std::__less<unsigned long long,unsigned long long> &,unsigned long long *>();
  }
  uint64_t v14 = v12;
  uint64_t v15 = 0;
  char v16 = 0;
  uint64_t v17 = 0;
  do
  {
    (*(void (**)(unint64_t *__return_ptr))(*(void *)v44 + 80))(&v47);
    if (v48)
    {
      unint64_t v20 = v47;
      unint64_t v47 = 0;
      v45[0] = v20;
      unint64_t v21 = *(void **)(a3 + 8);
      if ((unint64_t)v21 >= *(void *)(a3 + 16))
      {
        unsigned int v24 = sub_1CBF3CD98((char **)a3, v45);
        uint64_t v25 = v45[0];
        *(void *)(a3 + 8) = v24;
        if (!v25) {
          goto LABEL_40;
        }
LABEL_39:
        (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
        goto LABEL_40;
      }
      *unint64_t v21 = 0;
      *unint64_t v21 = v45[0];
      *(void *)(a3 + 8) = v21 + 1;
    }
    else
    {
      (*(void (**)(void *__return_ptr))(*(void *)v44 + 120))(v45);
      if (v46)
      {
        uint64_t v22 = v45[0];
        v45[0] = 0;
        uint64_t v42 = v22;
        uint64_t v23 = *(void **)(a3 + 8);
        if ((unint64_t)v23 >= *(void *)(a3 + 16))
        {
          uint64_t v26 = sub_1CBF3CD98((char **)a3, &v42);
          uint64_t v27 = v42;
          *(void *)(a3 + 8) = v26;
          if (v27) {
            (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
          }
        }
        else
        {
          *uint64_t v23 = 0;
          *uint64_t v23 = v42;
          *(void *)(a3 + 8) = v23 + 1;
        }
      }
      else if (v45[1] == a1[6] && v45[0] == a1[5])
      {
        unint64_t v18 = v47;
        if (*(void *)(a2 + 8) <= v47 && v47 < *(void *)(a2 + 24))
        {
          uint64_t v41 = a2;
          if (v15 >= v16)
          {
            uint64_t v28 = (v15 - v17) >> 3;
            unint64_t v29 = v28 + 1;
            if ((unint64_t)(v28 + 1) >> 61) {
              abort();
            }
            if ((v16 - v17) >> 2 > v29) {
              unint64_t v29 = (v16 - v17) >> 2;
            }
            if ((unint64_t)(v16 - v17) >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v30 = v29;
            }
            if (v30)
            {
              if (v30 >> 61) {
                sub_1CB833614();
              }
              uint64_t v31 = (char *)operator new(8 * v30);
            }
            else
            {
              uint64_t v31 = 0;
            }
            long long v32 = &v31[8 * v28];
            *(void *)long long v32 = v18;
            unint64_t v19 = v32 + 8;
            while (v15 != v17)
            {
              uint64_t v33 = *((void *)v15 - 1);
              v15 -= 8;
              *((void *)v32 - 1) = v33;
              v32 -= 8;
            }
            char v16 = &v31[8 * v30];
            *a4 = v32;
            a4[1] = v19;
            a4[2] = v16;
            if (v17) {
              operator delete(v17);
            }
            uint64_t v17 = v32;
          }
          else
          {
            *(void *)uint64_t v15 = v47;
            unint64_t v19 = v15 + 8;
          }
          a4[1] = v19;
          uint64_t v15 = v19;
          a2 = v41;
        }
      }
      if (v46)
      {
        uint64_t v25 = v45[0];
        v45[0] = 0;
        if (v25) {
          goto LABEL_39;
        }
      }
    }
LABEL_40:
    if (v48)
    {
      unint64_t v34 = v47;
      unint64_t v47 = 0;
      if (v34) {
        (*(void (**)(unint64_t))(*(void *)v34 + 8))(v34);
      }
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v44 + 24))(v44, &v43);
  }
  while (v43 != v14);
  uint64_t v35 = *a4;
  uint64_t result = std::__sort<std::__less<unsigned long long,unsigned long long> &,unsigned long long *>();
  if (v35 != v15)
  {
    unint64_t v36 = v35 + 8;
    while (v36 != v15)
    {
      uint64_t v37 = *((void *)v36 - 1);
      uint64_t v38 = *(void *)v36;
      v36 += 8;
      if (v37 == v38)
      {
        int v39 = v36 - 16;
        while (v36 != v15)
        {
          uint64_t v40 = v37;
          uint64_t v37 = *(void *)v36;
          if (v40 != *(void *)v36)
          {
            *((void *)v39 + 1) = v37;
            v39 += 8;
          }
          v36 += 8;
        }
        if (v39 + 8 != v15) {
          a4[1] = v39 + 8;
        }
        return result;
      }
    }
  }
  return result;
}

uint64_t *sub_1CBF3C890(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v4 = 16 * v2;
    uint64_t v5 = (uint64_t *)(v3 + 8);
    do
    {
      if (*((_DWORD *)v5 - 2) <= 0xFFFFFFFD) {
        uint64_t v5 = sub_1CBF3C8F0(v5);
      }
      v5 += 2;
      v4 -= 16;
    }
    while (v4);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

uint64_t *sub_1CBF3C8F0(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *(void **)(v2 + 40);
    if (v3 != (void *)(v2 + 56)) {
      free(v3);
    }
    MEMORY[0x1D25D9CE0](v2, 0x10D0C4008C057FALL);
  }
  return a1;
}

int *sub_1CBF3C94C(uint64_t a1, unsigned int a2, int a3)
{
  if (!a2) {
    return (int *)(a1 + 16 * a2);
  }
  LODWORD(v3) = (37 * a3) & (a2 - 1);
  uint64_t v4 = (int *)(a1 + 16 * v3);
  int v5 = *v4;
  if (*v4 != a3)
  {
    int v6 = 1;
    while (v5 != -1)
    {
      int v7 = v3 + v6++;
      uint64_t v3 = v7 & (a2 - 1);
      int v5 = *(_DWORD *)(a1 + 16 * v3);
      if (v5 == a3) {
        return (int *)(a1 + 16 * v3);
      }
    }
    return (int *)(a1 + 16 * a2);
  }
  return v4;
}

_DWORD *sub_1CBF3C9AC(_DWORD *result, uint64_t a2, _DWORD *a3, uint64_t *a4)
{
  int v7 = result;
  unsigned int v8 = *(_DWORD *)(a2 + 16);
  if (v8)
  {
    uint64_t v9 = *(void *)a2;
    unsigned int v10 = v8 - 1;
    unsigned int v11 = (37 * *a3) & (v8 - 1);
    uint64_t v12 = *(void *)a2 + 16 * v11;
    int v13 = *(_DWORD *)v12;
    if (*a3 == *(_DWORD *)v12)
    {
LABEL_3:
      char v14 = 0;
      goto LABEL_10;
    }
    uint64_t v17 = 0;
    int v18 = 1;
    while (v13 != -1)
    {
      if (v17) {
        BOOL v19 = 0;
      }
      else {
        BOOL v19 = v13 == -2;
      }
      if (v19) {
        uint64_t v17 = v12;
      }
      unsigned int v20 = v11 + v18++;
      unsigned int v11 = v20 & v10;
      uint64_t v12 = v9 + 16 * (v20 & v10);
      int v13 = *(_DWORD *)v12;
      if (*a3 == *(_DWORD *)v12) {
        goto LABEL_3;
      }
    }
    if (v17) {
      uint64_t v12 = v17;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  int v15 = *(_DWORD *)(a2 + 8);
  if (4 * v15 + 4 >= 3 * v8)
  {
    uint64_t result = sub_1CBF3CBF0((uint64_t *)a2, 2 * v8);
    int v21 = *(_DWORD *)(a2 + 16);
    if (v21)
    {
      int v22 = v21 - 1;
      unsigned int v23 = (37 * *a3) & (v21 - 1);
      uint64_t v12 = *(void *)a2 + 16 * v23;
      int v24 = *(_DWORD *)v12;
      if (*a3 == *(_DWORD *)v12) {
        goto LABEL_7;
      }
      uint64_t v25 = 0;
      int v26 = 1;
      while (v24 != -1)
      {
        if (v25) {
          BOOL v27 = 0;
        }
        else {
          BOOL v27 = v24 == -2;
        }
        if (v27) {
          uint64_t v25 = v12;
        }
        unsigned int v28 = v23 + v26++;
        unsigned int v23 = v28 & v22;
        uint64_t v12 = *(void *)a2 + 16 * (v28 & v22);
        int v24 = *(_DWORD *)v12;
        if (*a3 == *(_DWORD *)v12) {
          goto LABEL_7;
        }
      }
LABEL_46:
      if (v25) {
        uint64_t v12 = v25;
      }
      goto LABEL_7;
    }
LABEL_45:
    uint64_t v12 = 0;
    goto LABEL_7;
  }
  if (v8 + ~v15 - *(_DWORD *)(a2 + 12) <= v8 >> 3)
  {
    uint64_t result = sub_1CBF3CBF0((uint64_t *)a2, v8);
    int v29 = *(_DWORD *)(a2 + 16);
    if (v29)
    {
      int v30 = v29 - 1;
      unsigned int v31 = (37 * *a3) & (v29 - 1);
      uint64_t v12 = *(void *)a2 + 16 * v31;
      int v32 = *(_DWORD *)v12;
      if (*a3 == *(_DWORD *)v12) {
        goto LABEL_7;
      }
      uint64_t v25 = 0;
      int v33 = 1;
      while (v32 != -1)
      {
        if (v25) {
          BOOL v34 = 0;
        }
        else {
          BOOL v34 = v32 == -2;
        }
        if (v34) {
          uint64_t v25 = v12;
        }
        unsigned int v35 = v31 + v33++;
        unsigned int v31 = v35 & v30;
        uint64_t v12 = *(void *)a2 + 16 * (v35 & v30);
        int v32 = *(_DWORD *)v12;
        if (*a3 == *(_DWORD *)v12) {
          goto LABEL_7;
        }
      }
      goto LABEL_46;
    }
    goto LABEL_45;
  }
LABEL_7:
  ++*(_DWORD *)(a2 + 8);
  if (*(_DWORD *)v12 != -1) {
    --*(_DWORD *)(a2 + 12);
  }
  *(_DWORD *)uint64_t v12 = *a3;
  uint64_t v16 = *a4;
  *a4 = 0;
  *(void *)(v12 + 8) = v16;
  uint64_t v9 = *(void *)a2;
  unsigned int v8 = *(_DWORD *)(a2 + 16);
  char v14 = 1;
LABEL_10:
  *(void *)int v7 = v12;
  *((void *)v7 + 1) = v9 + 16 * v8;
  *((unsigned char *)v7 + 16) = v14;
  return result;
}

_DWORD *sub_1CBF3CBF0(uint64_t *a1, int a2)
{
  uint64_t v3 = *((unsigned int *)a1 + 4);
  uint64_t v4 = (int *)*a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *((_DWORD *)a1 + 4) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *a1 = (uint64_t)result;
  if (v4)
  {
    a1[1] = 0;
    uint64_t v10 = *((unsigned int *)a1 + 4);
    if (v10)
    {
      uint64_t v11 = 16 * v10;
      do
      {
        *uint64_t result = -1;
        result += 4;
        v11 -= 16;
      }
      while (v11);
    }
    if (v3)
    {
      uint64_t v12 = v4;
      int v13 = &v4[4 * v3];
      do
      {
        int v14 = *v12;
        if (*v12 <= 0xFFFFFFFD)
        {
          int v15 = *((_DWORD *)a1 + 4) - 1;
          unsigned int v16 = v15 & (37 * v14);
          uint64_t v17 = *a1 + 16 * v16;
          int v18 = *(_DWORD *)v17;
          if (v14 != *(_DWORD *)v17)
          {
            uint64_t v20 = 0;
            int v21 = 1;
            while (v18 != -1)
            {
              if (v20) {
                BOOL v22 = 0;
              }
              else {
                BOOL v22 = v18 == -2;
              }
              if (v22) {
                uint64_t v20 = v17;
              }
              unsigned int v23 = v16 + v21++;
              unsigned int v16 = v23 & v15;
              uint64_t v17 = *a1 + 16 * (v23 & v15);
              int v18 = *(_DWORD *)v17;
              if (v14 == *(_DWORD *)v17) {
                goto LABEL_12;
              }
            }
            if (v20) {
              uint64_t v17 = v20;
            }
          }
LABEL_12:
          uint64_t v19 = *((void *)v12 + 1);
          *(_DWORD *)uint64_t v17 = v14;
          *((void *)v12 + 1) = 0;
          *(void *)(v17 + 8) = v19;
          ++*((_DWORD *)a1 + 2);
          sub_1CBF3C8F0((uint64_t *)v12 + 1);
        }
        v12 += 4;
      }
      while (v12 != v13);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  a1[1] = 0;
  uint64_t v24 = *((unsigned int *)a1 + 4);
  if (v24)
  {
    uint64_t v25 = 16 * v24;
    do
    {
      *uint64_t result = -1;
      result += 4;
      v25 -= 16;
    }
    while (v25);
  }
  return result;
}

char *sub_1CBF3CD98(char **a1, void *a2)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  uint64_t v4 = (v2 - *a1) >> 3;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 61) {
    abort();
  }
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 2 > v5) {
    unint64_t v5 = v8 >> 2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  if (v9)
  {
    if (v9 >> 61) {
      sub_1CB833614();
    }
    uint64_t v10 = (char *)operator new(8 * v9);
  }
  else
  {
    uint64_t v10 = 0;
  }
  uint64_t v11 = &v10[8 * v4];
  *(void *)uint64_t v11 = *a2;
  uint64_t v12 = v11 + 8;
  *a2 = 0;
  while (v2 != v3)
  {
    uint64_t v13 = *((void *)v2 - 1);
    v2 -= 8;
    *((void *)v11 - 1) = v13;
    v11 -= 8;
    *(void *)uint64_t v2 = 0;
  }
  int v14 = *a1;
  int v15 = a1[1];
  *a1 = v11;
  a1[1] = v12;
  a1[2] = &v10[8 * v9];
  while (v15 != v14)
  {
    uint64_t v17 = *((void *)v15 - 1);
    v15 -= 8;
    uint64_t v16 = v17;
    if (v17) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
    }
  }
  if (v14) {
    operator delete(v14);
  }
  return v12;
}

llvm::raw_ostream *llvm::agxclauseanalyzer::CAInst::printJSON(uint64_t *a1, llvm::json::OStream *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  llvm::json::OStream::objectBegin(a2);
  sub_1CD452690((llvm::json::Value *)&v18, "instr", 5uLL);
  llvm::json::OStream::attributeBegin((uint64_t)a2, "type", 4uLL);
  llvm::json::OStream::value((uint64_t)a2, (unsigned __int16 *)&v18);
  --*((_DWORD *)a2 + 2);
  llvm::json::Value::destroy((llvm::json::Value *)&v18);
  uint64_t v8 = *a1;
  LOWORD(v18) = 3;
  uint64_t v19 = v8;
  llvm::json::OStream::attributeBegin((uint64_t)a2, "offset", 6uLL);
  llvm::json::OStream::value((uint64_t)a2, (unsigned __int16 *)&v18);
  --*((_DWORD *)a2 + 2);
  llvm::json::Value::destroy((llvm::json::Value *)&v18);
  uint64_t v9 = a1[2];
  LOWORD(v18) = 3;
  uint64_t v19 = v9;
  llvm::json::OStream::attributeBegin((uint64_t)a2, "size_in_bytes", 0xDuLL);
  llvm::json::OStream::value((uint64_t)a2, (unsigned __int16 *)&v18);
  --*((_DWORD *)a2 + 2);
  llvm::json::Value::destroy((llvm::json::Value *)&v18);
  if (a3)
  {
    v15[0] = 0;
    v15[1] = 0;
    uint64_t v16 = 0;
    LODWORD(v19) = 0;
    char v23 = 0;
    uint64_t v24 = 0;
    int v26 = v15;
    int v10 = *((_DWORD *)a1 + 6);
    int v25 = 0;
    int v18 = &unk_1F2646F30;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    if (v10) {
      (*(void (**)(uint64_t, uint64_t *, void, const char *, void, uint64_t, void **))(*(void *)a3 + 32))(a3, a1 + 3, *a1, "", 0, a4, &v18);
    }
    else {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v18, "nop", 3uLL);
    }
    if (*((char *)v26 + 23) < 0)
    {
      sub_1CB8BDF7C((uint64_t)__p, *v26, (unint64_t)v26[1]);
    }
    else
    {
      long long v11 = *(_OWORD *)v26;
      int v14 = v26[2];
      *(_OWORD *)std::string __p = v11;
    }
    sub_1CD452764((uint64_t)v17, (unint64_t)__p);
    llvm::json::OStream::attributeBegin((uint64_t)a2, "assembly", 8uLL);
    llvm::json::OStream::value((uint64_t)a2, v17);
    --*((_DWORD *)a2 + 2);
    llvm::json::Value::destroy((llvm::json::Value *)v17);
    if (SHIBYTE(v14) < 0) {
      operator delete(__p[0]);
    }
    int v18 = &unk_1F2646B98;
    if (v25 == 1 && v20) {
      MEMORY[0x1D25D9CB0](v20, 0x1000C8077774924);
    }
    if (SHIBYTE(v16) < 0) {
      operator delete(v15[0]);
    }
  }
  return llvm::json::OStream::objectEnd(a2);
}

uint64_t llvm::agxclauseanalyzer::InstrClause::getOffset(llvm::agxclauseanalyzer::InstrClause *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (v1 == *((void *)this + 2)) {
    return -1;
  }
  else {
    return **(void **)v1;
  }
}

uint64_t llvm::agxclauseanalyzer::InstrClause::getSizeInBytes(llvm::agxclauseanalyzer::InstrClause *this)
{
  uint64_t v1 = (uint64_t *)*((void *)this + 1);
  uint64_t v2 = (uint64_t *)*((void *)this + 2);
  if (v1 == v2) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    uint64_t v4 = *v1++;
    result += *(void *)(v4 + 16);
  }
  while (v1 != v2);
  return result;
}

uint64_t llvm::agxclauseanalyzer::InstrStream::getOffset(llvm::agxclauseanalyzer::InstrStream *this)
{
  uint64_t v1 = (uint64_t *)*((void *)this + 1);
  if (v1 == *((uint64_t **)this + 2)) {
    return -1;
  }
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 8);
  if (v3 == *(void *)(v2 + 16)) {
    return -1;
  }
  else {
    return **(void **)v3;
  }
}

uint64_t llvm::agxclauseanalyzer::InstrStream::getSizeInBytes(llvm::agxclauseanalyzer::InstrStream *this)
{
  uint64_t v1 = *((void *)this + 1);
  uint64_t v2 = *((void *)this + 2);
  if (v1 == v2) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    uint64_t v4 = *(uint64_t **)(*(void *)v1 + 8);
    unint64_t v5 = *(uint64_t **)(*(void *)v1 + 16);
    if (v4 == v5)
    {
      uint64_t v6 = 0;
    }
    else
    {
      uint64_t v6 = 0;
      do
      {
        uint64_t v7 = *v4++;
        v6 += *(void *)(v7 + 16);
      }
      while (v4 != v5);
    }
    result += v6;
    v1 += 8;
  }
  while (v1 != v2);
  return result;
}

uint64_t llvm::agxclauseanalyzer::InstrStream::getSizeInPhysInstrs(llvm::agxclauseanalyzer::InstrStream *this)
{
  uint64_t v1 = (uint64_t *)*((void *)this + 1);
  uint64_t v2 = (uint64_t *)*((void *)this + 2);
  if (v1 == v2) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    uint64_t v4 = *v1++;
    result += (uint64_t)(*(void *)(v4 + 16) - *(void *)(v4 + 8)) >> 3;
  }
  while (v1 != v2);
  return result;
}

uint64_t llvm::agxclauseanalyzer::InstrStream::getSizeInExecInstrs(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 8);
  uint64_t v3 = *(uint64_t **)(a1 + 16);
  if (v2 == v3) {
    return 0;
  }
  uint64_t v5 = 0;
  do
  {
    uint64_t v6 = *v2++;
    v5 += (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v6 + 16))(v6, a2);
  }
  while (v2 != v3);
  return v5;
}

llvm *dumpInst(llvm *a1, uint64_t a2, uint64_t *a3, const void *a4, size_t a5)
{
  int v10 = llvm::dbgs(a1);
  long long v11 = v10;
  uint64_t v12 = (_WORD *)*((void *)v10 + 4);
  if (*((void *)v10 + 3) - (void)v12 > 1uLL)
  {
    *uint64_t v12 = 8224;
    uint64_t v13 = (_WORD *)(*((void *)v10 + 4) + 2);
    *((void *)v11 + 4) = v13;
  }
  else
  {
    long long v11 = llvm::raw_ostream::write(v10, "  ", 2uLL);
    uint64_t v13 = (_WORD *)*((void *)v11 + 4);
  }
  if (a5 <= *((void *)v11 + 3) - (void)v13)
  {
    if (a5)
    {
      memcpy(v13, a4, a5);
      uint64_t v13 = (_WORD *)(*((void *)v11 + 4) + a5);
      *((void *)v11 + 4) = v13;
    }
  }
  else
  {
    long long v11 = llvm::raw_ostream::write(v11, (const char *)a4, a5);
    uint64_t v13 = (_WORD *)*((void *)v11 + 4);
  }
  if (*((void *)v11 + 3) - (void)v13 > 5uLL)
  {
    uint64_t v13[2] = 10016;
    *(_DWORD *)uint64_t v13 = 1935767328;
    *((void *)v11 + 4) += 6;
  }
  else
  {
    long long v11 = llvm::raw_ostream::write(v11, " was '", 6uLL);
  }
  uint64_t v14 = *a3;
  v23[0] = &unk_1F25FF808;
  v23[1] = "%04x";
  v23[2] = v14;
  int v15 = llvm::raw_ostream::operator<<(v11, (uint64_t)v23);
  uint64_t v16 = (_WORD *)*((void *)v11 + 4);
  if (*((void *)v11 + 3) - (void)v16 > 1uLL)
  {
    *uint64_t v16 = 8250;
    *((void *)v11 + 4) += 2;
    if (!a1)
    {
LABEL_11:
      uint64_t v17 = llvm::dbgs(v15);
      uint64_t v18 = *((void *)v17 + 4);
      if ((unint64_t)(*((void *)v17 + 3) - v18) > 0x10)
      {
        *(unsigned char *)(v18 + 16) = 41;
        *(_OWORD *)uint64_t v18 = *(_OWORD *)"(no inst printer)";
        *((void *)v17 + 4) += 17;
      }
      else
      {
        uint64_t v17 = llvm::raw_ostream::write(v17, "(no inst printer)", 0x11uLL);
      }
      goto LABEL_17;
    }
  }
  else
  {
    int v15 = llvm::raw_ostream::write(v11, ": ", 2uLL);
    if (!a1) {
      goto LABEL_11;
    }
  }
  uint64_t v19 = *a3;
  uint64_t v20 = llvm::dbgs(v15);
  uint64_t v17 = (llvm *)(*(uint64_t (**)(llvm *, uint64_t *, uint64_t, const char *, void, uint64_t, llvm *))(*(void *)a1 + 32))(a1, a3 + 3, v19, "", 0, a2, v20);
LABEL_17:
  uint64_t result = llvm::dbgs(v17);
  uint64_t v22 = (_WORD *)*((void *)result + 4);
  if (*((void *)result + 3) - (void)v22 <= 1uLL) {
    return llvm::raw_ostream::write(result, "'\n", 2uLL);
  }
  *uint64_t v22 = 2599;
  *((void *)result + 4) += 2;
  return result;
}

void llvm::agxclauseanalyzer::AGXClauseAnalyzer::findStreamSprings(void **a1@<X0>, long long *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  v134[16] = *MEMORY[0x1E4F143B8];
  long long v7 = a2[1];
  long long v119 = *a2;
  long long v120 = v7;
  uint64_t v117 = v119;
  (*(void (**)(void **__return_ptr))(*(void *)v119 + 32))(&__p);
  uint64_t v9 = (char *)__p;
  uint64_t v8 = v122;
  unint64_t v10 = *((void *)a2 + 1);
  int v109 = v122;
  if (*((void *)a2 + 3) > v10)
  {
    if ((unint64_t)v122 >= v123)
    {
      uint64_t v12 = (v122 - (unsigned char *)__p) >> 3;
      unint64_t v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 61) {
LABEL_205:
      }
        abort();
      uint64_t v14 = v123 - (void)__p;
      if ((uint64_t)(v123 - (void)__p) >> 2 > v13) {
        unint64_t v13 = v14 >> 2;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15)
      {
        if (v15 >> 61) {
LABEL_206:
        }
          sub_1CB833614();
        uint64_t v16 = (char *)operator new(8 * v15);
      }
      else
      {
        uint64_t v16 = 0;
      }
      uint64_t v17 = &v16[8 * v12];
      uint64_t v18 = &v16[8 * v15];
      *(void *)uint64_t v17 = v10;
      long long v11 = v17 + 8;
      for (unsigned int i = v109; i != v9; v17 -= 8)
      {
        uint64_t v20 = *((void *)i - 1);
        i -= 8;
        *((void *)v17 - 1) = v20;
      }
      std::string __p = v17;
      unsigned int v122 = v11;
      unint64_t v123 = (unint64_t)v18;
      if (v9) {
        operator delete(v9);
      }
    }
    else
    {
      *(void *)unsigned int v122 = v10;
      long long v11 = v8 + 8;
    }
    unsigned int v122 = v11;
  }
  std::__sort<std::__less<unsigned long long,unsigned long long> &,unsigned long long *>();
  uint64_t v21 = (char *)__p;
  uint64_t v22 = v122;
  char v23 = (char *)__p;
  if (__p == v122)
  {
LABEL_25:
    if (v23 != v122)
    {
      uint64_t v27 = v23 + 16;
      if (v23 + 16 != v122)
      {
        uint64_t v28 = *(void *)v23;
        do
        {
          uint64_t v29 = v28;
          uint64_t v28 = *(void *)v27;
          if (v29 != *(void *)v27)
          {
            *((void *)v23 + 1) = v28;
            v23 += 8;
          }
          v27 += 8;
        }
        while (v27 != v22);
      }
      if (v23 + 8 != v22)
      {
        uint64_t v22 = v23 + 8;
        unsigned int v122 = v23 + 8;
      }
    }
  }
  else
  {
    uint64_t v24 = (char *)__p + 8;
    while (v24 != v122)
    {
      uint64_t v25 = *((void *)v24 - 1);
      uint64_t v26 = *(void *)v24;
      v24 += 8;
      if (v25 == v26)
      {
        char v23 = v24 - 16;
        goto LABEL_25;
      }
    }
  }
  uint64_t v132 = (char *)v134;
  uint64_t v133 = 0x1000000000;
  if (v21 != v22)
  {
    unsigned int v30 = 0;
    do
    {
      if (v30 >= HIDWORD(v133)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)&v132[8 * v30] = *(void *)v21;
      unsigned int v30 = v133 + 1;
      LODWORD(v133) = v133 + 1;
      v21 += 8;
    }
    while (v21 != v22);
  }
  int v108 = v9;
  int v129 = v131;
  uint64_t v130 = 0x1000000000;
  uint64_t v32 = *(void *)a2;
  uint64_t v31 = *((void *)a2 + 1);
  uint64_t v33 = *((void *)a2 + 2);
  uint64_t v115 = *((void *)a2 + 3);
  unsigned int v116 = a2;
  if (*(void *)a2 == v33 && v31 == *((void *)a2 + 3))
  {
    uint64_t v35 = v117;
LABEL_115:
    if (v108 == v109)
    {
      unsigned int v62 = 0;
      LODWORD(v130) = 0;
    }
    else
    {
      unsigned int v62 = v130;
    }
    if (v62 >= HIDWORD(v130)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v129 + v62) = v116[3];
    LODWORD(v130) = v130 + 1;
    std::__sort<std::__less<unsigned long long,unsigned long long> &,unsigned long long *>();
    int v64 = (char *)__p;
    uint64_t v63 = v122;
    if (__p != v122)
    {
      uint64_t v65 = (char *)__p + 8;
      do
      {
        if (v65 == v122) {
          goto LABEL_132;
        }
        uint64_t v66 = *((void *)v65 - 1);
        uint64_t v67 = *(void *)v65;
        v65 += 8;
      }
      while (v66 != v67);
      int v64 = v65 - 16;
    }
    if (v64 != v122)
    {
      char v68 = v64 + 16;
      if (v64 + 16 != v122)
      {
        uint64_t v69 = *(void *)v64;
        do
        {
          uint64_t v70 = v69;
          uint64_t v69 = *(void *)v68;
          if (v70 != *(void *)v68)
          {
            *((void *)v64 + 1) = v69;
            v64 += 8;
          }
          v68 += 8;
        }
        while (v68 != v63);
      }
      if (v64 + 8 != v63) {
        unsigned int v122 = v64 + 8;
      }
    }
LABEL_132:
    unint64_t v71 = &v132[8 * v133 - 8];
    if (v133) {
      BOOL v72 = v132 >= v71;
    }
    else {
      BOOL v72 = 1;
    }
    if (!v72)
    {
      uint64_t v73 = v132 + 8;
      do
      {
        uint64_t v74 = *((void *)v73 - 1);
        *((void *)v73 - 1) = *(void *)v71;
        *(void *)unint64_t v71 = v74;
        v71 -= 8;
        BOOL v72 = v73 >= v71;
        v73 += 8;
      }
      while (!v72);
    }
    std::string v75 = (char *)v129 + 8 * v130 - 8;
    if (v130) {
      BOOL v76 = v129 >= v75;
    }
    else {
      BOOL v76 = 1;
    }
    if (!v76)
    {
      uint64_t v77 = (char *)v129 + 8;
      do
      {
        uint64_t v78 = *((void *)v77 - 1);
        *((void *)v77 - 1) = *(void *)v75;
        *(void *)std::string v75 = v78;
        v75 -= 8;
        BOOL v72 = v77 >= v75;
        v77 += 8;
      }
      while (!v72);
    }
    uint64_t v114 = a4;
    unsigned int v79 = v122 - 8;
    if (__p != v122 && __p < v79)
    {
      BOOL v81 = (char *)__p + 8;
      do
      {
        uint64_t v82 = *((void *)v81 - 1);
        *((void *)v81 - 1) = *(void *)v79;
        *(void *)unsigned int v79 = v82;
        v79 -= 8;
        BOOL v72 = v81 >= v79;
        v81 += 8;
      }
      while (!v72);
    }
    unsigned int v83 = 0;
    BOOL v84 = 0;
    unsigned int v85 = 0;
    int v86 = 0;
    int v87 = 0;
    unsigned int v124 = v126;
    uint64_t v125 = 0x1000000000;
    unint64_t v88 = *(void *)(v35 + 16);
LABEL_154:
    uint64_t v89 = v35;
    while (1)
    {
      switch(v87)
      {
        case 0:
          LODWORD(v133) = v133 - 1;
          int v87 = 1;
          continue;
        case 1:
          unint64_t v88 = *((void *)v129 + v130 - 1);
          LODWORD(v130) = v130 - 1;
          if (v133)
          {
            int v90 = v133 - 1;
            int v91 = &v132[8 * v133 - 8];
            do
            {
              unint64_t v92 = *(void *)v91;
              v91 -= 8;
              if (v92 >= v88) {
                break;
              }
              LODWORD(v133) = v90--;
            }
            while (v90 != -1);
          }
          uint64_t v93 = v122;
          int v87 = 2;
          uint64_t v89 = v35;
          if (__p == v122) {
            continue;
          }
          do
          {
            unint64_t v106 = *((void *)v93 - 1);
            if (v106 >= v88) {
              break;
            }
            if (v83 >= HIDWORD(v125)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            unsigned int v107 = (char *)v124 + 16 * v83;
            *unsigned int v107 = v35;
            v107[1] = v106;
            unsigned int v83 = v125 + 1;
            LODWORD(v125) = v125 + 1;
            uint64_t v93 = v122 - 8;
            unsigned int v122 = v93;
          }
          while (__p != v93);
          int v87 = 2;
          goto LABEL_154;
        case 2:
          int v87 = 3;
          if (v130)
          {
            if (__p != v122)
            {
              int v87 = 1;
              if (v133)
              {
                if (*((void *)v122 - 1) < *(void *)&v132[8 * v133 - 8]) {
                  int v87 = 1;
                }
                else {
                  int v87 = 3;
                }
              }
            }
          }
          continue;
        case 3:
          if (!v83) {
            goto LABEL_189;
          }
          unint64_t v94 = (char *)v124;
          unint64_t v95 = (char *)v124 + 16 * v83;
          break;
        case 4:
          *(unsigned char *)(v114 + 24) &= ~1u;
          *(void *)uint64_t v114 = v84;
          *(void *)(v114 + 8) = v85;
          *(void *)(v114 + 16) = v86;
          if (v124 != v126) {
            free(v124);
          }
          goto LABEL_197;
        default:
          continue;
      }
      do
      {
        uint64_t v97 = *(void *)v94;
        uint64_t v96 = *((void *)v94 + 1);
        if (v85 >= v86)
        {
          uint64_t v98 = (v85 - v84) >> 5;
          unint64_t v99 = v98 + 1;
          if ((unint64_t)(v98 + 1) >> 59) {
            goto LABEL_205;
          }
          if ((v86 - v84) >> 4 > v99) {
            unint64_t v99 = (v86 - v84) >> 4;
          }
          if ((unint64_t)(v86 - v84) >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v100 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v100 = v99;
          }
          if (v100 >> 59) {
            goto LABEL_206;
          }
          unsigned int v101 = (char *)operator new(32 * v100);
          uint64_t v102 = &v101[32 * v98];
          *(void *)uint64_t v102 = v97;
          *((void *)v102 + 1) = v96;
          *((void *)v102 + 2) = v89;
          *((void *)v102 + 3) = v88;
          if (v85 == v84)
          {
            unsigned int v105 = &v101[32 * v98];
          }
          else
          {
            unsigned int v103 = &v101[32 * v98];
            do
            {
              long long v104 = *((_OWORD *)v85 - 1);
              unsigned int v105 = v103 - 32;
              *((_OWORD *)v103 - 2) = *((_OWORD *)v85 - 2);
              *((_OWORD *)v103 - 1) = v104;
              v85 -= 32;
              v103 -= 32;
            }
            while (v85 != v84);
          }
          int v86 = &v101[32 * v100];
          unsigned int v85 = v102 + 32;
          if (v84) {
            operator delete(v84);
          }
          BOOL v84 = v105;
        }
        else
        {
          *(void *)unsigned int v85 = v97;
          *((void *)v85 + 1) = v96;
          *((void *)v85 + 2) = v89;
          *((void *)v85 + 3) = v88;
          v85 += 32;
        }
        v94 += 16;
      }
      while (v94 != v95);
LABEL_189:
      unsigned int v83 = 0;
      LODWORD(v125) = 0;
      uint64_t v35 = v117;
      uint64_t v89 = v116[2];
      unint64_t v88 = v116[3];
      int v87 = 4 * (__p == v122);
    }
  }
  uint64_t v35 = v117;
  uint64_t v111 = v33;
  while (1)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v32 + 16))(&v127, v32, v31);
    unint64_t v36 = (void *)v127;
    if ((v128 & 1) == 0)
    {
      unsigned int v37 = *(_DWORD *)(v127 + 24);
      uint64_t v38 = *a1[1];
      if (((unsigned int (*)(void **, uint64_t))(*a1)[10])(a1, v127))
      {
        if (v130 >= (unint64_t)HIDWORD(v130)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v129 + v130) = v36[2] + *v36;
        LODWORD(v130) = v130 + 1;
        uint64_t v33 = v111;
      }
      if ((*(void *)(v38 + 48 * v37 + 8) & 0x800) != 0) {
        operator new();
      }
      if ((*(void *)(v38 + 48 * v37 + 8) & 0x400) != 0)
      {
        unint64_t v118 = 0;
        if (!(*(unsigned int (**)(uint64_t, void *, void, void, unint64_t *))(*(void *)a3 + 104))(a3, v36 + 3, *v36, v36[2], &v118))operator new(); {
        unint64_t v39 = v118;
        }
        if (v116[1] > v118 || v116[3] <= v118) {
          goto LABEL_98;
        }
        uint64_t v40 = v122;
        uint64_t v35 = v117;
        if ((unint64_t)v122 >= v123)
        {
          std::string v45 = (char *)__p;
          uint64_t v50 = (v122 - (unsigned char *)__p) >> 3;
          unint64_t v51 = v50 + 1;
          if ((unint64_t)(v50 + 1) >> 61) {
            goto LABEL_205;
          }
          uint64_t v52 = v123 - (void)__p;
          if ((uint64_t)(v123 - (void)__p) >> 2 > v51) {
            unint64_t v51 = v52 >> 2;
          }
          if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v51 = 0x1FFFFFFFFFFFFFFFLL;
          }
          unint64_t v113 = v51;
          if (v51)
          {
            if (v51 >> 61) {
              goto LABEL_206;
            }
            size_t v53 = (char *)operator new(8 * v51);
          }
          else
          {
            size_t v53 = 0;
          }
          __int16 v54 = &v53[8 * v50];
          *(void *)__int16 v54 = v39;
          uint64_t v44 = v54 + 8;
          if (v40 == v45)
          {
            uint64_t v33 = v111;
            unint64_t v57 = v113;
          }
          else
          {
            uint64_t v33 = v111;
            unint64_t v57 = v113;
            do
            {
              uint64_t v58 = *((void *)v40 - 1);
              v40 -= 8;
              *((void *)v54 - 1) = v58;
              v54 -= 8;
            }
            while (v40 != v45);
          }
          std::string::size_type v56 = &v53[8 * v57];
LABEL_95:
          std::string __p = v54;
          unsigned int v122 = v44;
          unint64_t v123 = (unint64_t)v56;
          if (v45) {
            operator delete(v45);
          }
          goto LABEL_97;
        }
        *(void *)unsigned int v122 = v118;
        unsigned int v122 = v40 + 8;
        goto LABEL_57;
      }
      if ((*(void *)(v38 + 48 * v37 + 8) & 0x80) != 0)
      {
        unint64_t v42 = v36[2] + *v36;
        uint64_t v35 = v117;
        if (v116[1] > v42 || v116[3] <= v42)
        {
LABEL_57:
          int v41 = 7;
          goto LABEL_100;
        }
        uint64_t v43 = v122;
        if ((unint64_t)v122 >= v123)
        {
          std::string v45 = (char *)__p;
          uint64_t v46 = (v122 - (unsigned char *)__p) >> 3;
          unint64_t v47 = v46 + 1;
          if ((unint64_t)(v46 + 1) >> 61) {
            goto LABEL_205;
          }
          uint64_t v48 = v123 - (void)__p;
          if ((uint64_t)(v123 - (void)__p) >> 2 > v47) {
            unint64_t v47 = v48 >> 2;
          }
          if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v47 = 0x1FFFFFFFFFFFFFFFLL;
          }
          unint64_t v112 = v47;
          if (v47)
          {
            if (v47 >> 61) {
              goto LABEL_206;
            }
            uint64_t v49 = (char *)operator new(8 * v47);
          }
          else
          {
            uint64_t v49 = 0;
          }
          __int16 v54 = &v49[8 * v46];
          *(void *)__int16 v54 = v42;
          uint64_t v44 = v54 + 8;
          if (v43 == v45)
          {
            uint64_t v33 = v111;
          }
          else
          {
            uint64_t v33 = v111;
            do
            {
              uint64_t v55 = *((void *)v43 - 1);
              v43 -= 8;
              *((void *)v54 - 1) = v55;
              v54 -= 8;
            }
            while (v43 != v45);
          }
          std::string::size_type v56 = &v49[8 * v112];
          goto LABEL_95;
        }
        *(void *)unsigned int v122 = v42;
        uint64_t v44 = v43 + 8;
LABEL_97:
        unsigned int v122 = v44;
LABEL_98:
        int v41 = 7;
      }
      else
      {
        int v41 = 0;
      }
      uint64_t v35 = v117;
      goto LABEL_100;
    }
    uint64_t v127 = 0;
    *(unsigned char *)(a4 + 24) |= 1u;
    *(void *)a4 = v36;
    int v41 = 1;
LABEL_100:
    if (v128)
    {
      uint64_t v59 = v127;
      uint64_t v127 = 0;
      if (v59) {
        (*(void (**)(uint64_t))(*(void *)v59 + 8))(v59);
      }
    }
    if (v41 != 7 && v41) {
      break;
    }
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)v32 + 16))(&v124, v32, v31);
    long long v60 = v124;
    if (v125)
    {
      unsigned int v124 = 0;
      if (v60) {
        (*(void (**)(void *))(*(void *)v60 + 8))(v60);
      }
      uint64_t v61 = 1;
    }
    else
    {
      uint64_t v61 = *((void *)v124 + 2);
    }
    v31 += v61;
    if (v32 == v33 && v31 == v115) {
      goto LABEL_115;
    }
  }
LABEL_197:
  if (v129 != v131) {
    free(v129);
  }
  if (v132 != (char *)v134) {
    free(v132);
  }
  if (__p)
  {
    unsigned int v122 = (char *)__p;
    operator delete(__p);
  }
}

void *llvm::agxclauseanalyzer::BranchTargetResolutionError::BranchTargetResolutionError(void *a1, llvm::Twine *this, uint64_t a3)
{
  *a1 = &unk_1F25FF750;
  llvm::Twine::str(this, a1 + 1);
  a1[4] = a3;
  return a1;
}

{
  *a1 = &unk_1F25FF750;
  llvm::Twine::str(this, a1 + 1);
  a1[4] = a3;
  return a1;
}

llvm::raw_ostream *llvm::agxclauseanalyzer::BranchTargetResolutionError::log(llvm::agxclauseanalyzer::BranchTargetResolutionError *this, llvm::raw_ostream *a2)
{
  uint64_t v5 = (const char *)*((void *)this + 1);
  uint64_t v3 = (char *)this + 8;
  uint64_t v4 = v5;
  char v6 = v3[23];
  int v7 = v6;
  if (v6 >= 0) {
    uint64_t v8 = v3;
  }
  else {
    uint64_t v8 = v4;
  }
  size_t v9 = v6 & 0x7F;
  if (v7 >= 0) {
    size_t v10 = v9;
  }
  else {
    size_t v10 = *((void *)v3 + 1);
  }
  return llvm::raw_ostream::write(a2, v8, v10);
}

uint64_t llvm::agxclauseanalyzer::BranchTargetResolutionError::convertToErrorCode(llvm::agxclauseanalyzer::BranchTargetResolutionError *this)
{
  return 45;
}

uint64_t sub_1CBF3E3EC()
{
  return 0;
}

uint64_t sub_1CBF3E3F4(uint64_t a1)
{
  *(void *)a1 = &unk_1F25FF750;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1CBF3E444(uint64_t a1)
{
  *(void *)a1 = &unk_1F25FF750;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CBF3E4B4()
{
  return &llvm::agxclauseanalyzer::BranchTargetResolutionError::ID;
}

BOOL sub_1CBF3E4C0(uint64_t a1, void *a2)
{
  return a2 == &llvm::agxclauseanalyzer::BranchTargetResolutionError::ID || a2 == &llvm::ErrorInfoBase::ID;
}

void llvm::AGX::AGCStatusPrinter::Resetter::~Resetter(llvm::AGX::AGCStatusPrinter::Resetter *this)
{
  uint64_t v1 = *(void *)(*(void *)this + 136);
  if (v1) {
    *(void *)(v1 + 64) = llvm::nulls(this);
  }
}

{
  uint64_t v1;

  if (*(void *)(*(void *)this + 136))
  {
    uint64_t v1 = *(void *)(*(void *)this + 136);
    *(void *)(v1 + 64) = llvm::nulls(this);
  }
}

uint64_t *llvm::AGX::AGCStatusPrinter::setOutput(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = result[17];
  if (v2)
  {
    if (!a2)
    {
      uint64_t result = llvm::nulls((llvm *)result);
      a2 = result;
    }
    *(void *)(v2 + 64) = a2;
  }
  return result;
}

llvm::raw_ostream *llvm::AGX::AGCStatusPrinter::logAssemblyOutput(llvm::raw_ostream *result, uint64_t a2)
{
  uint64_t v2 = *((void *)result + 17);
  if (v2)
  {
    char v4 = *(unsigned char *)(v2 + 95);
    BOOL v5 = v4 < 0;
    if (v4 >= 0) {
      uint64_t v6 = v2 + 72;
    }
    else {
      uint64_t v6 = *(void *)(v2 + 72);
    }
    uint64_t v7 = v4 & 0x7F;
    if (v5) {
      uint64_t v7 = *(void *)(v2 + 80);
    }
    uint64_t v8 = *(void *)(v2 + 96);
    v16[0] = 256;
    int v17 = 4;
    uint64_t v18 = v6;
    uint64_t v19 = v7;
    char v20 = 1;
    uint64_t v21 = v8;
    char v22 = 1;
    char v23 = "compiler assembly";
    uint64_t v24 = 17;
    char v25 = 1;
    char v27 = 0;
    char v26 = 0;
    uint64_t v28 = &unk_1CFB4A537;
    uint64_t v29 = 0;
    sub_1CBF35DFC((llvm::raw_ostream *)v2, "Start", 5uLL, (uint64_t)v16);
    char v9 = *(unsigned char *)(a2 + 23);
    BOOL v10 = v9 < 0;
    if (v9 >= 0) {
      long long v11 = (const char *)a2;
    }
    else {
      long long v11 = *(const char **)a2;
    }
    size_t v12 = v9 & 0x7F;
    if (v10) {
      size_t v13 = *(void *)(a2 + 8);
    }
    else {
      size_t v13 = v12;
    }
    uint64_t v14 = llvm::raw_ostream::write((llvm::raw_ostream *)v2, v11, v13);
    uint64_t result = sub_1CBF35DFC(v14, "End", 3uLL, (uint64_t)v16);
    unint64_t v15 = *(const char **)(v2 + 16);
    if (*(const char **)(v2 + 32) != v15)
    {
      *(void *)(v2 + 32) = v15;
      return (llvm::raw_ostream *)llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)v2, v15);
    }
  }
  return result;
}

llvm *llvm::AGX::AGCStatusPrinter::setTemporaryOutput@<X0>(llvm *result@<X0>, uint64_t *a2@<X1>, llvm **a3@<X8>)
{
  if (*((void *)result + 17))
  {
    uint64_t v3 = *((void *)result + 17);
    BOOL v5 = a3;
    char v4 = result;
    if (!a2) {
      a2 = llvm::nulls(result);
    }
    uint64_t result = v4;
    *(void *)(v3 + 64) = a2;
    a3 = v5;
  }
  *a3 = result;
  return result;
}

uint64_t llvm::AGX::AGCStatusPrinter::hookBefore(uint64_t this, llvm::legacy::PassManager *a2, const llvm::Pass *a3)
{
  if (*(void *)(this + 136)) {
    operator new();
  }
  return this;
}

uint64_t llvm::AGX::AGCStatusPrinter::hookAfter(uint64_t this, llvm::legacy::PassManager *a2, const llvm::Pass *a3)
{
  if (*(void *)(this + 136)) {
    operator new();
  }
  return this;
}

uint64_t llvm::AGX::AGCStatusPrinter::hookOptimizePrinter(llvm::AGX::AGCStatusPrinter *this, llvm::legacy::PassManager *a2)
{
  uint64_t result = *((void *)this + 17);
  if (result) {
    sub_1CBF3EC54();
  }
  return result;
}

void sub_1CBF3EC54()
{
}

uint64_t llvm::AGX::AGCStatusPrinter::hookLoweredPrinter(llvm::AGX::AGCStatusPrinter *this, llvm::legacy::PassManager *a2)
{
  uint64_t result = *((void *)this + 17);
  if (result) {
    sub_1CBF3ED34();
  }
  return result;
}

void sub_1CBF3ED34()
{
}

uint64_t llvm::AGX::AGCStatusPrinter::startRequest(uint64_t this, const llvm::AGX::CompileRequest *a2)
{
  if (*(void *)(this + 136))
  {
    uint64_t v3 = *(std::string **)(this + 136);
    ShaderType = (const std::string *)llvm::AGX::CompileRequest::getShaderType(a2);
    std::string::operator=(v3 + 3, ShaderType);
    this = llvm::AGX::CompileRequest::getId(a2);
    v3[4].__r_.__value_.__r.__words[0] = (int)this;
  }
  return this;
}

void **llvm::AGX::AGCStatusPrinter::disable(llvm::AGX::AGCStatusPrinter *this)
{
  uint64_t result = (void **)*((void *)this + 17);
  *((void *)this + 17) = 0;
  if (result)
  {
    sub_1CD453754(result);
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

BOOL llvm::AGX::AGCStatusPrinter::isEnabled(llvm::AGX::AGCStatusPrinter *this)
{
  return *((void *)this + 17) != 0;
}

llvm::raw_ostream *llvm::AGX::AGCStatusPrinter::flush(llvm::AGX::AGCStatusPrinter *this)
{
  uint64_t result = (llvm::raw_ostream *)*((void *)this + 17);
  if (result)
  {
    uint64_t v2 = (const char *)*((void *)result + 2);
    if (*((const char **)result + 4) != v2)
    {
      *((void *)result + 4) = v2;
      return (llvm::raw_ostream *)llvm::raw_ostream::flush_tied_then_write(result, v2);
    }
  }
  return result;
}

__n128 llvm::AGX::AGCStatusPrinter::AGCStatusPrinter(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v2;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  uint64_t v3 = *((void *)a2 + 3);
  *(_WORD *)(a1 + 32) = *((_WORD *)a2 + 16);
  *(void *)(a1 + 24) = v3;
  long long v4 = *(long long *)((char *)a2 + 40);
  *(void *)(a1 + 56) = *((void *)a2 + 7);
  *(_OWORD *)(a1 + 40) = v4;
  *((void *)a2 + 6) = 0;
  *((void *)a2 + 7) = 0;
  *((void *)a2 + 5) = 0;
  *(void *)(a1 + 64) = *((void *)a2 + 8);
  long long v5 = *(long long *)((char *)a2 + 72);
  *(void *)(a1 + 88) = *((void *)a2 + 11);
  *(_OWORD *)(a1 + 72) = v5;
  *((void *)a2 + 10) = 0;
  *((void *)a2 + 11) = 0;
  *((void *)a2 + 9) = 0;
  long long v6 = a2[6];
  *(void *)(a1 + 112) = *((void *)a2 + 14);
  *(_OWORD *)(a1 + 96) = v6;
  *((void *)a2 + 13) = 0;
  *((void *)a2 + 14) = 0;
  *((void *)a2 + 12) = 0;
  __n128 result = *(__n128 *)((char *)a2 + 120);
  *(__n128 *)(a1 + 120) = result;
  uint64_t v8 = *((void *)a2 + 17);
  *((void *)a2 + 17) = 0;
  *(void *)(a1 + 136) = v8;
  return result;
}

{
  long long v2;
  uint64_t v3;
  long long v4;
  long long v5;
  long long v6;
  __n128 result;
  uint64_t v8;

  long long v2 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v2;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  uint64_t v3 = *((void *)a2 + 3);
  *(_WORD *)(a1 + 32) = *((_WORD *)a2 + 16);
  *(void *)(a1 + 24) = v3;
  long long v4 = *(long long *)((char *)a2 + 40);
  *(void *)(a1 + 56) = *((void *)a2 + 7);
  *(_OWORD *)(a1 + 40) = v4;
  *((void *)a2 + 6) = 0;
  *((void *)a2 + 7) = 0;
  *((void *)a2 + 5) = 0;
  *(void *)(a1 + 64) = *((void *)a2 + 8);
  long long v5 = *(long long *)((char *)a2 + 72);
  *(void *)(a1 + 88) = *((void *)a2 + 11);
  *(_OWORD *)(a1 + 72) = v5;
  *((void *)a2 + 10) = 0;
  *((void *)a2 + 11) = 0;
  *((void *)a2 + 9) = 0;
  long long v6 = a2[6];
  *(void *)(a1 + 112) = *((void *)a2 + 14);
  *(_OWORD *)(a1 + 96) = v6;
  *((void *)a2 + 13) = 0;
  *((void *)a2 + 14) = 0;
  *((void *)a2 + 12) = 0;
  __n128 result = *(__n128 *)((char *)a2 + 120);
  *(__n128 *)(a1 + 120) = result;
  uint64_t v8 = *((void *)a2 + 17);
  *((void *)a2 + 17) = 0;
  *(void *)(a1 + 136) = v8;
  return result;
}

uint64_t llvm::AGX::AGCStatusPrinter::operator=(uint64_t a1, long long *a2)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((unsigned char *)a2 + 23) = 0;
  *(unsigned char *)a2 = 0;
  __int16 v5 = *((_WORD *)a2 + 16);
  *(void *)(a1 + 24) = *((void *)a2 + 3);
  *(_WORD *)(a1 + 32) = v5;
  long long v6 = (void **)(a1 + 40);
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*v6);
  }
  long long v7 = *(long long *)((char *)a2 + 40);
  *(void *)(a1 + 56) = *((void *)a2 + 7);
  *(_OWORD *)long long v6 = v7;
  *((unsigned char *)a2 + 63) = 0;
  *((unsigned char *)a2 + 40) = 0;
  *(void *)(a1 + 64) = *((void *)a2 + 8);
  uint64_t v8 = (void **)(a1 + 72);
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*v8);
  }
  long long v9 = *(long long *)((char *)a2 + 72);
  *(void *)(a1 + 88) = *((void *)a2 + 11);
  *(_OWORD *)uint64_t v8 = v9;
  *((unsigned char *)a2 + 95) = 0;
  *((unsigned char *)a2 + 72) = 0;
  BOOL v10 = (void **)(a1 + 96);
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*v10);
  }
  long long v11 = a2[6];
  *(void *)(a1 + 112) = *((void *)a2 + 14);
  *(_OWORD *)BOOL v10 = v11;
  *((unsigned char *)a2 + 119) = 0;
  *((unsigned char *)a2 + 96) = 0;
  *(_OWORD *)(a1 + 120) = *(long long *)((char *)a2 + 120);
  uint64_t v12 = *((void *)a2 + 17);
  *((void *)a2 + 17) = 0;
  size_t v13 = *(void ***)(a1 + 136);
  *(void *)(a1 + 136) = v12;
  if (v13)
  {
    sub_1CD453754(v13);
    MEMORY[0x1D25D9CE0]();
  }
  return a1;
}

void sub_1CBF3F138(void **this)
{
  *this = &unk_1F25FF828;
  if (*((char *)this + 63) < 0) {
    operator delete(this[5]);
  }

  llvm::Pass::~Pass((llvm::Pass *)this);
}

void sub_1CBF3F198(void **this)
{
  *this = &unk_1F25FF828;
  if (*((char *)this + 63) < 0) {
    operator delete(this[5]);
  }
  llvm::Pass::~Pass((llvm::Pass *)this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBF3F20C(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

uint64_t sub_1CBF3F218(uint64_t a1, const std::string *a2)
{
  uint64_t v4 = a1 + 40;
  uint64_t v3 = *(void *)(a1 + 40);
  __int16 v5 = *(uint64_t **)(a1 + 64);
  char v6 = *((unsigned char *)v5 + 23);
  BOOL v7 = v6 < 0;
  uint64_t v8 = v5[1];
  if (v6 < 0) {
    __int16 v5 = (uint64_t *)*v5;
  }
  uint64_t v9 = v6 & 0x7F;
  if (v7) {
    uint64_t v9 = v8;
  }
  uint64_t v10 = **(void **)(a1 + 72);
  char v11 = *(unsigned char *)(a1 + 63);
  int v12 = v11;
  if (v11 >= 0) {
    uint64_t v3 = a1 + 40;
  }
  uint64_t v13 = v11 & 0x7F;
  if (v12 < 0) {
    uint64_t v13 = *(void *)(a1 + 48);
  }
  v17[0] = 256;
  int v18 = 2;
  uint64_t v19 = v5;
  uint64_t v20 = v9;
  char v21 = 1;
  uint64_t v22 = v10;
  char v23 = 1;
  uint64_t v24 = v3;
  uint64_t v25 = v13;
  char v26 = 1;
  char v28 = 0;
  char v27 = 0;
  uint64_t v29 = &unk_1CFB4A537;
  uint64_t v30 = 0;
  sub_1CBF35DFC(*(llvm::raw_ostream **)(a1 + 32), "Start", 5uLL, (uint64_t)v17);
  llvm::Module::print(a2, *(llvm::raw_ostream **)(v4 - 8), 0, 0, 1);
  sub_1CBF35DFC(*(llvm::raw_ostream **)(v4 - 8), "End", 3uLL, (uint64_t)v17);
  uint64_t v14 = *(llvm::raw_ostream **)(v4 - 8);
  unint64_t v15 = (const char *)*((void *)v14 + 2);
  if (*((const char **)v14 + 4) != v15)
  {
    *((void *)v14 + 4) = v15;
    llvm::raw_ostream::flush_tied_then_write(v14, v15);
  }
  return 0;
}

llvm::raw_ostream *sub_1CBF3F330(uint64_t a1, const char *a2, size_t a3)
{
  return llvm::raw_ostream::write(*(llvm::raw_ostream **)(a1 + 64), a2, a3);
}

uint64_t sub_1CBF3F338(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 64);
  return (*(uint64_t (**)(void *))(*v1 + 80))(v1) + v1[4] - v1[2];
}

__n128 sub_1CBF3F390(uint64_t a1, long long *a2, int a3, int a4, char a5, char a6, long long *a7, uint64_t a8, long long *a9, __n128 *a10, int a11, uint64_t a12)
{
  uint64_t v13 = a9;
  int v12 = a10;
  long long v14 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v14;
  *((void *)a2 + 1) = 0;
  *((void *)a2 + 2) = 0;
  *(void *)a2 = 0;
  *(_DWORD *)(a1 + 24) = a3;
  *(_DWORD *)(a1 + 28) = a4;
  *(unsigned char *)(a1 + 32) = a5;
  *(unsigned char *)(a1 + 33) = a6;
  if (*((char *)a7 + 23) < 0)
  {
    uint64_t v22 = a1;
    uint64_t v20 = a8;
    sub_1CB8BDF7C(a1 + 40, *(const void **)a7, *((void *)a7 + 1));
    uint64_t v13 = a9;
    int v12 = a10;
    a8 = v20;
    a1 = v22;
  }
  else
  {
    long long v15 = *a7;
    *(void *)(a1 + 56) = *((void *)a7 + 2);
    *(_OWORD *)(a1 + 40) = v15;
  }
  uint64_t v16 = a12;
  int v17 = a11;
  *(void *)(a1 + 64) = a8;
  if (*((char *)v13 + 23) < 0)
  {
    uint64_t v23 = a1;
    char v21 = v12;
    sub_1CB8BDF7C(a1 + 72, *(const void **)v13, *((void *)v13 + 1));
    int v17 = a11;
    uint64_t v16 = a12;
    int v12 = v21;
    a1 = v23;
  }
  else
  {
    long long v18 = *v13;
    *(void *)(a1 + 88) = *((void *)v13 + 2);
    *(_OWORD *)(a1 + 72) = v18;
  }
  __n128 result = *v12;
  *(void *)(a1 + 112) = v12[1].n128_u64[0];
  *(__n128 *)(a1 + 96) = result;
  v12->n128_u64[1] = 0;
  v12[1].n128_u64[0] = 0;
  v12->n128_u64[0] = 0;
  *(_DWORD *)(a1 + 120) = v17;
  *(void *)(a1 + 128) = v16;
  return result;
}

uint64_t sub_1CBF3F490(uint64_t a1)
{
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *llvm::AGX3::getISAVersion(llvm::AGX3 *this, const llvm::MCSubtargetInfo *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v4[0] = &unk_1F25FDD00;
  v4[1] = this;
  __int16 v5 = v4;
  int v2 = sub_1CBD854F8((uint64_t)v4);
  if (v5 == v4)
  {
    (*(void (**)(void *))(v4[0] + 32))(v4);
  }
  else if (v5)
  {
    (*(void (**)(void))(*v5 + 40))();
  }
  return off_1E682C630[v2];
}

void llvm::AGX::AGCReplay::createFromAGCIR(const char **this@<X0>, void *a2@<X8>)
{
  uint64_t v193 = *MEMORY[0x1E4F143B8];
  long long __dst = "agxcompiler.config";
  __int16 v192 = 259;
  uint64_t NamedMetadata = llvm::Module::getNamedMetadata((llvm::Module *)this, (const char **)&__dst);
  if (!NamedMetadata)
  {
    unsigned int v110 = (llvm::raw_ostream *)llvm::errs(0);
    uint64_t v111 = (void *)*((void *)v110 + 4);
    if (*((void *)v110 + 3) - (void)v111 > 0x3BuLL)
    {
      qmemcpy(v111, "Can't load the AGC, agxcompiler.config metadata missing in '", 60);
      *((void *)v110 + 4) += 60;
    }
    else
    {
      unsigned int v110 = llvm::raw_ostream::write(v110, "Can't load the AGC, agxcompiler.config metadata missing in '", 0x3CuLL);
    }
    uint64_t v114 = this[21];
    unint64_t v113 = (char *)(this + 21);
    unint64_t v112 = v114;
    char v115 = v113[23];
    int v116 = v115;
    if (v115 >= 0) {
      uint64_t v117 = v113;
    }
    else {
      uint64_t v117 = v112;
    }
    size_t v118 = v115 & 0x7F;
    if (v116 >= 0) {
      size_t v119 = v118;
    }
    else {
      size_t v119 = *((void *)v113 + 1);
    }
    long long v120 = llvm::raw_ostream::write(v110, v117, v119);
    uint64_t v121 = *((void *)v120 + 4);
    if ((unint64_t)(*((void *)v120 + 3) - v121) > 2)
    {
      *(unsigned char *)(v121 + 2) = 10;
      *(_WORD *)uint64_t v121 = 11815;
      *((void *)v120 + 4) += 3;
    }
    else
    {
      llvm::raw_ostream::write(v120, "'.\n", 3uLL);
    }
    *a2 = 0;
    return;
  }
  uint64_t v6 = NamedMetadata;
  uint64_t v7 = *(unsigned int *)(*(void *)(NamedMetadata + 48) + 8);
  if (!v7)
  {
    long long __dst = (char *)&v191 + 8;
    *(void *)&long long v191 = 0x800000000;
    llvm::Module::getModuleFlagsMetadata((llvm::Module *)this, (uint64_t)&__dst);
    unsigned int v122 = __dst;
    if (v191)
    {
      unint64_t v123 = &__dst[24 * v191];
      unsigned int v124 = __dst;
      do
      {
        while (1)
        {
          uint64_t v125 = *(void *)(*((void *)v124 + 1) + 8);
          if (*(void *)v125 == 9) {
            break;
          }
          v124 += 24;
          if (v124 == v123) {
            goto LABEL_230;
          }
        }
        uint64_t v126 = *(void *)(v125 + 24);
        uint64_t v127 = *(unsigned __int8 *)(v125 + 32);
        BOOL v129 = *(void *)"PIC Level" != v126 || aPicLevel[8] != v127;
        v124 += 24;
      }
      while (v129 && v124 != v123);
    }
LABEL_230:
    if (__dst != (char *)&v191 + 8) {
      free(__dst);
    }
    uint64_t v131 = 0;
    LODWORD(v11) = 0;
    int v132 = 0;
    uint64_t v133 = 0;
    uint64_t v134 = 0;
    LODWORD(v9) = 0;
    int v135 = 0;
LABEL_233:
    uint64_t v136 = (llvm::raw_ostream *)llvm::errs((llvm *)v122);
    unint64_t v137 = (void *)*((void *)v136 + 4);
    if (*((void *)v136 + 3) - (void)v137 > 0x19uLL)
    {
      qmemcpy(v137, "Error: missing TargetGPU.\n", 26);
      *((void *)v136 + 4) += 26;
    }
    else
    {
      llvm::raw_ostream::write(v136, "Error: missing TargetGPU.\n", 0x1AuLL);
    }
    LODWORD(v10) = 0;
    goto LABEL_277;
  }
  uint64_t v171 = (llvm::Module *)this;
  uint64_t v8 = 0;
  uint64_t v173 = 0;
  int v170 = 0;
  int v169 = 0;
  std::string __p = 0;
  unsigned int v180 = 0;
  BOOL v174 = 0;
  uint64_t v9 = 0;
  int v172 = 0;
  uint64_t v10 = 0;
  unsigned int v182 = 0;
  unsigned int v183 = 0;
  int v184 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 8 * v7;
  uint64_t v181 = a2;
  while (2)
  {
    uint64_t v13 = *(void *)(**(void **)(v6 + 48) + v8);
    long long v14 = (void *)(v13 - 8 * *(unsigned int *)(v13 + 8));
    if (*(unsigned char *)*v14)
    {
      uint64_t v138 = (llvm::raw_ostream *)llvm::errs((llvm *)NamedMetadata);
      uint64_t v139 = (void *)*((void *)v138 + 4);
      if (*((void *)v138 + 3) - (void)v139 <= 0x21uLL)
      {
        uint64_t v140 = "Error: unamed metadata parameter.\n";
        size_t v141 = 34;
        goto LABEL_274;
      }
      qmemcpy(v139, "Error: unamed metadata parameter.\n", 34);
      uint64_t v163 = *((void *)v138 + 4) + 34;
      goto LABEL_329;
    }
    long long v15 = *(uint64_t **)(*v14 + 8);
    uint64_t v17 = *v15;
    uint64_t NamedMetadata = (uint64_t)(v15 + 3);
    uint64_t v16 = v17;
    switch(v17)
    {
      case 7:
        if (*(_DWORD *)NamedMetadata != 1215588679 || *(_DWORD *)(NamedMetadata + 3) != 1752392008) {
          goto LABEL_201;
        }
        uint64_t v19 = v14[1];
        if (*(unsigned char *)v19) {
          goto LABEL_292;
        }
        uint64_t v20 = v10;
        char v21 = *(unint64_t **)(v19 + 8);
        unint64_t v24 = *v21;
        uint64_t v23 = v21 + 3;
        size_t v22 = v24;
        if (v24 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_339;
        }
        uint64_t v25 = v9;
        if (v22 >= 0x17)
        {
          uint64_t v98 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v22 | 7) != 0x17) {
            uint64_t v98 = v22 | 7;
          }
          uint64_t v99 = v98 + 1;
          p_dst = (char *)operator new(v98 + 1);
          *(void *)&long long v191 = v22;
          *((void *)&v191 + 1) = v99 | 0x8000000000000000;
          long long __dst = p_dst;
          int v27 = v184;
        }
        else
        {
          HIBYTE(v191) = v22;
          p_dst = (char *)&__dst;
          int v27 = v184;
          if (!v22) {
            goto LABEL_162;
          }
        }
        uint64_t NamedMetadata = (uint64_t)memmove(p_dst, v23, v22);
LABEL_162:
        p_dst[v22] = 0;
        if (v27 && v175 < 0) {
          operator delete(v182);
        }
        unsigned int v182 = __dst;
        char v175 = HIBYTE(v191);
        int v184 = 1;
        uint64_t v9 = v25;
        goto LABEL_182;
      case 8:
      case 10:
      case 11:
      case 14:
      case 17:
      case 19:
      case 20:
      case 22:
      case 23:
      case 25:
        goto LABEL_201;
      case 9:
        if (*(void *)NamedMetadata != 0x5047746567726154 || *(unsigned char *)(NamedMetadata + 8) != 85)
        {
          if (*(void *)NamedMetadata == 0x704F656C62616E45 && *(unsigned char *)(NamedMetadata + 8) == 116)
          {
            uint64_t v30 = v14[1];
            if (*(unsigned char *)v30 != 1) {
              goto LABEL_268;
            }
            uint64_t v31 = *(void *)(v30 + 128);
            if (*(unsigned char *)(v31 + 16) != 16) {
              goto LABEL_268;
            }
            int v170 = 1;
          }
          goto LABEL_201;
        }
        uint64_t v84 = v14[1];
        if (*(unsigned char *)v84)
        {
LABEL_292:
          int v159 = (llvm::raw_ostream *)llvm::errs((llvm *)NamedMetadata);
          int v160 = (void *)*((void *)v159 + 4);
          int v132 = v184;
          if (*((void *)v159 + 3) - (void)v160 > 0x1CuLL)
          {
            qmemcpy(v160, "Error: string meta expected.\n", 29);
            *((void *)v159 + 4) += 29;
          }
          else
          {
            llvm::raw_ostream::write(v159, "Error: string meta expected.\n", 0x1DuLL);
          }
          uint64_t v134 = __p;
          uint64_t v133 = v182;
          uint64_t v131 = v183;
          goto LABEL_276;
        }
        uint64_t v85 = v10;
        int v86 = *(unint64_t **)(v84 + 8);
        unint64_t v89 = *v86;
        unint64_t v88 = v86 + 3;
        size_t v87 = v89;
        if (v89 > 0x7FFFFFFFFFFFFFF7) {
LABEL_339:
        }
          abort();
        uint64_t v90 = v11;
        uint64_t v91 = v9;
        if (v87 >= 0x17)
        {
          uint64_t v96 = (v87 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v87 | 7) != 0x17) {
            uint64_t v96 = v87 | 7;
          }
          uint64_t v97 = v96 + 1;
          unint64_t v92 = (char *)operator new(v96 + 1);
          *(void *)&long long v191 = v87;
          *((void *)&v191 + 1) = v97 | 0x8000000000000000;
          long long __dst = v92;
        }
        else
        {
          HIBYTE(v191) = v87;
          unint64_t v92 = (char *)&__dst;
          if (!v87) {
            goto LABEL_155;
          }
        }
        uint64_t NamedMetadata = (uint64_t)memmove(v92, v88, v87);
LABEL_155:
        v92[v87] = 0;
        if (v85)
        {
          uint64_t v10 = v85;
          uint64_t v9 = v91;
          a2 = v181;
          if (v177 < 0) {
            operator delete(__p);
          }
        }
        else
        {
          uint64_t v10 = 1;
          uint64_t v9 = v91;
          a2 = v181;
        }
        uint64_t v11 = v90;
        std::string __p = __dst;
        v188[0] = DWORD2(v191);
        *(_DWORD *)((char *)v188 + 3) = *(_DWORD *)((char *)&v191 + 11);
        char v177 = HIBYTE(v191);
        goto LABEL_201;
      case 12:
        if (*(void *)NamedMetadata != 0x656E696C65706950 || *(_DWORD *)(NamedMetadata + 8) != 1701869908) {
          goto LABEL_201;
        }
        uint64_t v42 = v14[1];
        if (*(unsigned char *)v42) {
          goto LABEL_272;
        }
        uint64_t v43 = *(uint64_t **)(v42 + 8);
        uint64_t v44 = *v43;
        if (*v43 == 6)
        {
          int v107 = *((_DWORD *)v43 + 6);
          int v108 = *((unsigned __int16 *)v43 + 14);
          if (v107 != 1986622020 || v108 != 29285)
          {
LABEL_194:
            BOOL v174 = 0;
            goto LABEL_201;
          }
          goto LABEL_199;
        }
        if (v44 == 14)
        {
          unint64_t v104 = 0x44796E616D69634CLL;
          unint64_t v105 = bswap64(v43[3]);
          if (v105 == 0x44796E616D69634CLL
            && (unint64_t v104 = 0x634C696272617279, v105 = bswap64(*(uint64_t *)((char *)v43 + 30)),
                                             v105 == 0x634C696272617279))
          {
            int v106 = 0;
          }
          else if (v105 < v104)
          {
            int v106 = -1;
          }
          else
          {
            int v106 = 1;
          }
          BOOL v174 = v106 == 0;
        }
        else
        {
          if (v44 != 7) {
            goto LABEL_194;
          }
          if (*((_DWORD *)v43 + 6) != 1886220099 || *(_DWORD *)((char *)v43 + 27) != 1702131056)
          {
            int v46 = *((_DWORD *)v43 + 6);
            int v47 = *(_DWORD *)((char *)v43 + 27);
            if (v46 != 1885434439 || v47 != 1667852400) {
              goto LABEL_194;
            }
LABEL_199:
            BOOL v174 = 1;
            goto LABEL_201;
          }
          BOOL v174 = 1;
        }
        goto LABEL_201;
      case 13:
        if (*(void *)NamedMetadata != 0x6F4C656C62616E45 || *(void *)(NamedMetadata + 5) != 0x676E6967676F4C65) {
          goto LABEL_201;
        }
        uint64_t v53 = v14[1];
        if (*(unsigned char *)v53 != 1) {
          goto LABEL_268;
        }
        uint64_t v54 = *(void *)(v53 + 128);
        if (*(unsigned char *)(v54 + 16) != 16) {
          goto LABEL_268;
        }
        LODWORD(v173) = 1;
        goto LABEL_201;
      case 15:
        if (*(void *)NamedMetadata != 0x655374757074754FLL || *(void *)(NamedMetadata + 7) != 0x6E6F697463656C65) {
          goto LABEL_201;
        }
        uint64_t v33 = (unsigned char *)v14[1];
        if (!*v33) {
          goto LABEL_201;
        }
        goto LABEL_272;
      case 16:
        if (*(void *)NamedMetadata != 0x2E74736575716552 || *(void *)(NamedMetadata + 8) != 0x4449726564616853) {
          goto LABEL_201;
        }
        uint64_t v50 = v14[1];
        if (*(unsigned char *)v50 != 1) {
          goto LABEL_268;
        }
        uint64_t v51 = *(void *)(v50 + 128);
        if (*(unsigned char *)(v51 + 16) != 16) {
          goto LABEL_268;
        }
        int v172 = 1;
        goto LABEL_201;
      case 18:
        if (*(void *)NamedMetadata != 0x2E74736575716552
          || *(void *)(NamedMetadata + 8) != 0x7954726564616853
          || *(_WORD *)(NamedMetadata + 16) != 25968)
        {
          goto LABEL_201;
        }
        uint64_t v57 = v14[1];
        if (*(unsigned char *)v57) {
          goto LABEL_292;
        }
        uint64_t v58 = v10;
        uint64_t v59 = *(unint64_t **)(v57 + 8);
        unint64_t v62 = *v59;
        uint64_t v61 = v59 + 3;
        size_t v60 = v62;
        if (v62 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_339;
        }
        uint64_t v63 = v11;
        uint64_t v64 = v9;
        if (v60 >= 0x17)
        {
          uint64_t v100 = (v60 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v60 | 7) != 0x17) {
            uint64_t v100 = v60 | 7;
          }
          uint64_t v101 = v100 + 1;
          uint64_t v65 = (char *)operator new(v100 + 1);
          *(void *)&long long v191 = v60;
          *((void *)&v191 + 1) = v101 | 0x8000000000000000;
          long long __dst = v65;
          char v66 = v178;
        }
        else
        {
          HIBYTE(v191) = v60;
          uint64_t v65 = (char *)&__dst;
          char v66 = v178;
          if (!v60) {
            goto LABEL_170;
          }
        }
        uint64_t NamedMetadata = (uint64_t)memmove(v65, v61, v60);
LABEL_170:
        v65[v60] = 0;
        if (v64)
        {
          uint64_t v9 = v64;
          uint64_t v10 = v58;
          uint64_t v11 = v63;
          if (v66 < 0) {
            operator delete(v180);
          }
          a2 = v181;
        }
        else
        {
          uint64_t v9 = 1;
          uint64_t v10 = v58;
          a2 = v181;
          uint64_t v11 = v63;
        }
        unsigned int v180 = __dst;
        v189[0] = v191;
        *(void *)((char *)v189 + 7) = *(void *)((char *)&v191 + 7);
        char v178 = HIBYTE(v191);
        goto LABEL_201;
      case 21:
        if (*(void *)NamedMetadata != 0x525458455F584741
          || *(void *)(NamedMetadata + 8) != 0x415F4D564C4C5F41
          || *(void *)(NamedMetadata + 13) != 0x4249525454415F4DLL)
        {
          goto LABEL_201;
        }
        uint64_t v69 = v14[1];
        if (*(unsigned char *)v69) {
          goto LABEL_292;
        }
        uint64_t v20 = v10;
        uint64_t v70 = *(unint64_t **)(v69 + 8);
        unint64_t v73 = *v70;
        BOOL v72 = v70 + 3;
        size_t v71 = v73;
        if (v73 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_339;
        }
        int v74 = v11;
        uint64_t v75 = v9;
        if (v71 >= 0x17)
        {
          uint64_t v102 = (v71 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v71 | 7) != 0x17) {
            uint64_t v102 = v71 | 7;
          }
          uint64_t v103 = v102 + 1;
          BOOL v76 = (char *)operator new(v102 + 1);
          *(void *)&long long v191 = v71;
          *((void *)&v191 + 1) = v103 | 0x8000000000000000;
          long long __dst = v76;
          char v77 = v176;
        }
        else
        {
          HIBYTE(v191) = v71;
          BOOL v76 = (char *)&__dst;
          char v77 = v176;
          if (!v71) {
            goto LABEL_178;
          }
        }
        uint64_t NamedMetadata = (uint64_t)memmove(v76, v72, v71);
LABEL_178:
        v76[v71] = 0;
        if (v74 && v77 < 0) {
          operator delete(v183);
        }
        unsigned int v183 = __dst;
        unint64_t v168 = (void *)v191;
        v187[0] = DWORD2(v191);
        *(_DWORD *)((char *)v187 + 3) = *(_DWORD *)((char *)&v191 + 11);
        char v176 = HIBYTE(v191);
        uint64_t v9 = v75;
        uint64_t v11 = 1;
LABEL_182:
        uint64_t v10 = v20;
        a2 = v181;
        goto LABEL_201;
      case 24:
        if (*(void *)NamedMetadata != 0x2E74736575716552
          || *(void *)(NamedMetadata + 8) != 0x2E736E6F6974704FLL
          || *(void *)(NamedMetadata + 16) != 0x6C65734974736146)
        {
          if (*(void *)NamedMetadata == 0x2E74736575716552
            && *(void *)(NamedMetadata + 8) == 0x2E736E6F6974704FLL
            && *(void *)(NamedMetadata + 16) == 0x6874614D74736146)
          {
            uint64_t v82 = v14[1];
            if (*(unsigned char *)v82 != 1) {
              goto LABEL_268;
            }
            uint64_t v83 = *(void *)(v82 + 128);
            if (*(unsigned char *)(v83 + 16) != 16) {
              goto LABEL_268;
            }
            int v169 = 1;
          }
          goto LABEL_201;
        }
        uint64_t v94 = v14[1];
        if (*(unsigned char *)v94 != 1 || (uint64_t v95 = *(void *)(v94 + 128), *(unsigned char *)(v95 + 16) != 16))
        {
LABEL_268:
          uint64_t v138 = (llvm::raw_ostream *)llvm::errs((llvm *)NamedMetadata);
          __int16 v152 = (void *)*((void *)v138 + 4);
          if (*((void *)v138 + 3) - (void)v152 <= 0x19uLL)
          {
            uint64_t v140 = "Error: int meta expected.\n";
            size_t v141 = 26;
            goto LABEL_274;
          }
          qmemcpy(v152, "Error: int meta expected.\n", 26);
          uint64_t v163 = *((void *)v138 + 4) + 26;
          goto LABEL_329;
        }
        HIDWORD(v173) = 1;
        goto LABEL_201;
      case 26:
        if (*(void *)NamedMetadata == 0x2E74736575716552
          && *(void *)(NamedMetadata + 8) == 0x2E736E6F6974704FLL
          && *(void *)(NamedMetadata + 16) == 0x6172746E6F435046
          && *(_WORD *)(NamedMetadata + 24) == 29795)
        {
          uint64_t v93 = (unsigned char *)v14[1];
          if (*v93) {
            goto LABEL_272;
          }
          goto LABEL_201;
        }
        BOOL v39 = *(void *)NamedMetadata == 0x2E74736575716552
           && *(void *)(NamedMetadata + 8) == 0x2E736E6F6974704FLL
           && *(void *)(NamedMetadata + 16) == 0x646F4D636F6C6552
           && *(_WORD *)(NamedMetadata + 24) == 27749;
        if (!v39 || (uint64_t v40 = (unsigned char *)v14[1], !*v40))
        {
LABEL_201:
          v8 += 8;
          if (v12 == v8)
          {
            long long __dst = (char *)&v191 + 8;
            *(void *)&long long v191 = 0x800000000;
            llvm::Module::getModuleFlagsMetadata(v171, (uint64_t)&__dst);
            unsigned int v122 = __dst;
            if (v191)
            {
              int v142 = __dst + 16;
              uint64_t v143 = 24 * v191;
              uint64_t v133 = v182;
              uint64_t v131 = v183;
              int v135 = v180;
              LOBYTE(v6) = v175;
              while (1)
              {
                uint64_t v144 = *(void *)(*((void *)v142 - 1) + 8);
                if (*(void *)v144 == 9)
                {
                  uint64_t v145 = *(void *)(v144 + 24);
                  uint64_t v146 = *(unsigned __int8 *)(v144 + 32);
                  if (*(void *)"PIC Level" == v145 && aPicLevel[8] == v146) {
                    break;
                  }
                }
                v142 += 24;
                v143 -= 24;
                if (!v143)
                {
                  uint64_t v148 = 0;
                  goto LABEL_249;
                }
              }
              uint64_t v148 = *(void *)v142;
            }
            else
            {
              uint64_t v148 = 0;
              uint64_t v133 = v182;
              uint64_t v131 = v183;
              int v135 = v180;
              LOBYTE(v6) = v175;
            }
LABEL_249:
            if (__dst == (char *)&v191 + 8)
            {
              if (!v148) {
                goto LABEL_251;
              }
            }
            else
            {
              free(__dst);
              if (!v148)
              {
LABEL_251:
                __int16 v149 = v168;
                if (v11) {
                  goto LABEL_252;
                }
                goto LABEL_299;
              }
            }
            __int16 v149 = v168;
            if (v11)
            {
LABEL_252:
              if (!byte_1EBCC2BD8 || !word_1EBCC2B60)
              {
                unsigned int v122 = (char *)llvm::errs((llvm *)v122);
                __int16 v150 = (void *)*((void *)v122 + 4);
                if (*((void *)v122 + 3) - (void)v150 > 0x49uLL)
                {
                  qmemcpy(v150, "!! AGX_EXTRA_LLVM_ATTRIB mismatch !! (-override-extra-attrib to override)\n", 74);
                  *((void *)v122 + 4) += 74;
                }
                else
                {
                  unsigned int v122 = (char *)llvm::raw_ostream::write((llvm::raw_ostream *)v122, "!! AGX_EXTRA_LLVM_ATTRIB mismatch !! (-override-extra-attrib to override)\n", 0x4AuLL);
                }
                __int16 v149 = v168;
                if (!byte_1EBCC2BD8)
                {
                  *a2 = 0;
                  LODWORD(v11) = 1;
                  uint64_t v134 = __p;
                  goto LABEL_317;
                }
              }
              int v151 = 1;
              if (v10)
              {
LABEL_258:
                if (v174)
                {
                  if (v170)
                  {
                    if (HIDWORD(v173))
                    {
                      if (v169)
                      {
                        if (v173)
                        {
                          if (v172)
                          {
                            if (v9)
                            {
                              if (v11)
                              {
                                if (v176 < 0)
                                {
                                  sub_1CB8BDF7C((uint64_t)v185, v183, (unint64_t)v149);
                                }
                                else
                                {
                                  v185[0] = v183;
                                  v185[1] = v149;
                                  LODWORD(v186) = v187[0];
                                  *(_DWORD *)((char *)&v186 + 3) = *(_DWORD *)((char *)v187 + 3);
                                  HIBYTE(v186) = v176;
                                }
                              }
                              else
                              {
                                v185[0] = 0;
                                v185[1] = 0;
                                uint64_t v186 = 0;
                              }
                              operator new();
                            }
                            __int16 v164 = (llvm::raw_ostream *)llvm::errs((llvm *)v122);
                            uint64_t v165 = (void *)*((void *)v164 + 4);
                            if (*((void *)v164 + 3) - (void)v165 > 0x1AuLL)
                            {
                              qmemcpy(v165, "Error: missing ShaderType.\n", 27);
                              *((void *)v164 + 4) += 27;
                            }
                            else
                            {
                              llvm::raw_ostream::write(v164, "Error: missing ShaderType.\n", 0x1BuLL);
                            }
                            uint64_t v134 = __p;
                            LODWORD(v9) = 0;
                            goto LABEL_316;
                          }
                          __int16 v153 = (llvm::raw_ostream *)llvm::errs((llvm *)v122);
                          uint64_t v161 = (_OWORD *)*((void *)v153 + 4);
                          if (*((void *)v153 + 3) - (void)v161 <= 0x18uLL)
                          {
                            int v155 = "Error: missing ShaderID.\n";
                            goto LABEL_313;
                          }
                          uint64_t v167 = "Error: missing ShaderID.\n";
                          goto LABEL_336;
                        }
                        __int16 v153 = (llvm::raw_ostream *)llvm::errs((llvm *)v122);
                        int v162 = (void *)*((void *)v153 + 4);
                        if (*((void *)v153 + 3) - (void)v162 <= 0x1DuLL)
                        {
                          int v155 = "Error: missing EnableLogging.\n";
                          size_t v156 = 30;
                          goto LABEL_314;
                        }
                        qmemcpy(v162, "Error: missing EnableLogging.\n", 30);
                        uint64_t v166 = *((void *)v153 + 4) + 30;
LABEL_337:
                        *((void *)v153 + 4) = v166;
                        goto LABEL_315;
                      }
                      __int16 v153 = (llvm::raw_ostream *)llvm::errs((llvm *)v122);
                      uint64_t v161 = (_OWORD *)*((void *)v153 + 4);
                      if (*((void *)v153 + 3) - (void)v161 <= 0x18uLL)
                      {
                        int v155 = "Error: missing FastMath.\n";
                        goto LABEL_313;
                      }
                      uint64_t v167 = "Error: missing FastMath.\n";
                    }
                    else
                    {
                      __int16 v153 = (llvm::raw_ostream *)llvm::errs((llvm *)v122);
                      uint64_t v161 = (_OWORD *)*((void *)v153 + 4);
                      if (*((void *)v153 + 3) - (void)v161 <= 0x18uLL)
                      {
                        int v155 = "Error: missing FastIsel.\n";
LABEL_313:
                        size_t v156 = 25;
                        goto LABEL_314;
                      }
                      uint64_t v167 = "Error: missing FastIsel.\n";
                    }
LABEL_336:
                    *uint64_t v161 = *(_OWORD *)v167;
                    *(_OWORD *)((char *)v161 + 9) = *(_OWORD *)(v167 + 9);
                    uint64_t v166 = *((void *)v153 + 4) + 25;
                    goto LABEL_337;
                  }
                  __int16 v153 = (llvm::raw_ostream *)llvm::errs((llvm *)v122);
                  int v158 = (void *)*((void *)v153 + 4);
                  if (*((void *)v153 + 3) - (void)v158 > 0x19uLL)
                  {
                    qmemcpy(v158, "Error: missing EnableOpt.\n", 26);
                    uint64_t v166 = *((void *)v153 + 4) + 26;
                    goto LABEL_337;
                  }
                  int v155 = "Error: missing EnableOpt.\n";
                  size_t v156 = 26;
                }
                else
                {
                  __int16 v153 = (llvm::raw_ostream *)llvm::errs((llvm *)v122);
                  int v154 = (void *)*((void *)v153 + 4);
                  if (*((void *)v153 + 3) - (void)v154 > 0x1CuLL)
                  {
                    qmemcpy(v154, "Error: missing PipelineType.\n", 29);
                    uint64_t v166 = *((void *)v153 + 4) + 29;
                    goto LABEL_337;
                  }
                  int v155 = "Error: missing PipelineType.\n";
                  size_t v156 = 29;
                }
LABEL_314:
                llvm::raw_ostream::write(v153, v155, v156);
LABEL_315:
                uint64_t v134 = __p;
LABEL_316:
                *a2 = 0;
                LODWORD(v10) = 1;
                LODWORD(v11) = v151;
LABEL_317:
                if (v184) {
                  goto LABEL_278;
                }
                goto LABEL_280;
              }
              goto LABEL_300;
            }
LABEL_299:
            int v151 = 0;
            if (v10) {
              goto LABEL_258;
            }
LABEL_300:
            LODWORD(v11) = v151;
            uint64_t v134 = __p;
            int v132 = v184;
            goto LABEL_233;
          }
          continue;
        }
LABEL_272:
        uint64_t v138 = (llvm::raw_ostream *)llvm::errs((llvm *)NamedMetadata);
        int v157 = (void *)*((void *)v138 + 4);
        if (*((void *)v138 + 3) - (void)v157 > 0x1CuLL)
        {
          qmemcpy(v157, "Error: string meta expected.\n", 29);
          uint64_t v163 = *((void *)v138 + 4) + 29;
LABEL_329:
          *((void *)v138 + 4) = v163;
          goto LABEL_275;
        }
        uint64_t v140 = "Error: string meta expected.\n";
        size_t v141 = 29;
LABEL_274:
        llvm::raw_ostream::write(v138, v140, v141);
LABEL_275:
        uint64_t v134 = __p;
        uint64_t v133 = v182;
        uint64_t v131 = v183;
        int v132 = v184;
LABEL_276:
        int v135 = v180;
        LOBYTE(v6) = v175;
LABEL_277:
        *a2 = 0;
        if (v132)
        {
LABEL_278:
          if ((v6 & 0x80) != 0) {
            operator delete(v133);
          }
        }
LABEL_280:
        if (v11 && v176 < 0) {
          operator delete(v131);
        }
        if (v9 && v178 < 0) {
          operator delete(v135);
        }
        if (v10 && v177 < 0) {
          operator delete(v134);
        }
        return;
      default:
        if (v16 != 35) {
          goto LABEL_201;
        }
        uint64_t NamedMetadata = memcmp((const void *)NamedMetadata, "Request.Options.ForwardProgressMode", 0x23uLL);
        if (NamedMetadata || !*(unsigned char *)v14[1]) {
          goto LABEL_201;
        }
        goto LABEL_272;
    }
  }
}

void llvm::AGX::AGCReplay::createRequest(llvm::AGX::AGCReplay *this, llvm::Module *a2)
{
  if (*((char *)this + 119) < 0)
  {
    sub_1CB8BDF7C((uint64_t)&v2, *((const void **)this + 12), *((void *)this + 13));
  }
  else
  {
    long long v2 = *((_OWORD *)this + 6);
    uint64_t v3 = *((void *)this + 14);
  }
  operator new();
}

uint64_t sub_1CBF40E84()
{
  char v2 = 1;
  uint64_t v3 = &v2;
  *(void *)&long long v1 = "Accept mismatch between AGX_EXTRA_LLVM_ATTRIB in the Metadata and the environment.";
  *((void *)&v1 + 1) = 82;
  sub_1CD4540A0((uint64_t)&unk_1EBCC2B58, "override-extra-attrib", &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC2B58, &dword_1CB82C000);
}

void llvm::AGX::AGXCompiler::AGXCompiler()
{
}

{
  operator new();
}

void sub_1CBF40FC0()
{
  uint64_t v0 = (llvm::PassRegistry *)LLVMInitializeAGX1TargetInfo();
  LLVMInitializeAGX1Target(v0);
  LLVMInitializeAGX1TargetMC();
  LLVMInitializeAGX1AsmPrinter();
  long long v1 = (llvm::PassRegistry *)LLVMInitializeAGX2TargetInfo();
  LLVMInitializeAGX2Target(v1);
  LLVMInitializeAGX2TargetMC();
  LLVMInitializeAGX2AsmPrinter();
  LLVMInitializeAGX2AsmParser_0();
  char v2 = (llvm::PassRegistry *)LLVMInitializeAGX3TargetInfo();
  LLVMInitializeAGX3Target(v2);
  LLVMInitializeAGX3TargetMC();
  LLVMInitializeAGX3AsmPrinter();
  LLVMInitializeAGX3AsmParser_0();
  PassRegistry = (llvm *)llvm::PassRegistry::getPassRegistry(v3);
  llvm::initializeCore(PassRegistry, v5);
  llvm::initializeCodeGen(PassRegistry, v6);
  llvm::initializeGPUCodeGen(PassRegistry, v7);
  llvm::initializeLowerIntrinsicsPass(PassRegistry, v8);
  llvm::initializeUnreachableBlockElimLegacyPassPass(PassRegistry, v9);

  llvm::initializeScalarOpts(PassRegistry, v10);
}

void llvm::AGX::AGXCompiler::createAssemblePlan()
{
}

void llvm::AGX::AGXCompiler::createCompilePlan()
{
}

{
  llvm::AGX::AGXCompilePlan::AGXCompilePlan();
}

{
  llvm::AGX::AGXCompilePlan::AGXCompilePlan();
}

void *llvm::AGX::AGXCompiler::AGXCompiler(void *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  *__n128 result = v2;
  return result;
}

{
  uint64_t v2;

  uint64_t v2 = *a2;
  *a2 = 0;
  *__n128 result = v2;
  return result;
}

uint64_t **llvm::AGX::AGXCompiler::operator=(uint64_t **a1, uint64_t **a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  uint64_t v4 = *a1;
  *a1 = v3;
  if (v4)
  {
    uint64_t v6 = sub_1CD4547D8(v4);
    MEMORY[0x1D25D9CE0](v6, 0x1032C4093FE8819);
  }
  return a1;
}

void llvm::AGX::AGXCompiler::~AGXCompiler(uint64_t **this)
{
  uint64_t v2 = *this;
  *this = 0;
  if (v2)
  {
    uint64_t v3 = sub_1CD4547D8(v2);
    MEMORY[0x1D25D9CE0](v3, 0x1032C4093FE8819);
  }
}

{
  uint64_t *v2;
  uint64_t *v3;

  uint64_t v2 = *this;
  *this = 0;
  if (v2)
  {
    uint64_t v3 = sub_1CD4547D8(v2);
    MEMORY[0x1D25D9CE0](v3, 0x1032C4093FE8819);
  }
}

uint64_t *sub_1CBF41290(uint64_t *a1, long long *a2, uint64_t a3)
{
  void v67[2] = *MEMORY[0x1E4F143B8];
  a1[4] = 0;
  __int16 v5 = (std::string *)(a1 + 5);
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  if (*((char *)a2 + 23) < 0)
  {
    sub_1CB8BDF7C((uint64_t)(a1 + 5), *(const void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v6 = *a2;
    a1[7] = *((void *)a2 + 2);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  if (atomic_load_explicit((atomic_ullong *volatile)&init_flag, memory_order_acquire) != -1)
  {
    uint64_t v40 = sub_1CBF40FC0;
    uint64_t v59 = &v40;
    std::__call_once(&init_flag, &v59, (void (__cdecl *)(void *))sub_1CBF42120);
  }
  llvm::AGX::TargetResolver::getTargetInfo(v5, (uint64_t)&v59);
  uint64_t v7 = v61 & 0x7F;
  if (v61 < 0) {
    uint64_t v7 = v60;
  }
  if (!v7)
  {
    *((unsigned char *)&v66.__r_.__value_.__s + 23) = 12;
    strcpy((char *)&v66, "Unknown GPU ");
    char v8 = *((unsigned char *)a1 + 63);
    BOOL v9 = v8 < 0;
    if (v8 >= 0) {
      uint64_t v10 = (const std::string::value_type *)v5;
    }
    else {
      uint64_t v10 = (const std::string::value_type *)a1[5];
    }
    std::string::size_type v11 = v8 & 0x7F;
    if (v9) {
      std::string::size_type v12 = a1[6];
    }
    else {
      std::string::size_type v12 = v11;
    }
    uint64_t v13 = std::string::append(&v66, v10, v12);
    v67[0] = v13->__r_.__value_.__l.__size_;
    *(void *)((char *)v67 + 7) = *(std::string::size_type *)((char *)&v13->__r_.__value_.__r.__words[1] + 7);
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    operator new();
  }
  long long v57 = 0uLL;
  uint64_t v58 = 0;
  long long v14 = llvm::TargetRegistry::lookupTarget((std::string::size_type)&v59, (uint64_t)&v57);
  if (!v14)
  {
    if (SHIBYTE(v58) < 0)
    {
      sub_1CB8BDF7C((uint64_t)v56, (const void *)v57, *((unint64_t *)&v57 + 1));
    }
    else
    {
      *(_OWORD *)std::string::size_type v56 = v57;
      v56[2] = v58;
    }
    operator new();
  }
  uint64_t v15 = (uint64_t)v14;
  sub_1CD4546AC((uint64_t)&v40);
  if (byte_1EBCC2C98) {
    __int16 v16 = 2560;
  }
  else {
    __int16 v16 = 2048;
  }
  __int16 v44 = v16 | v44 & 0xF5FF;
  if (a3)
  {
    int v17 = *(char *)(a3 + 23);
    if (v17 < 0)
    {
      if (!*(void *)(a3 + 8)) {
        goto LABEL_40;
      }
    }
    else if (!*(unsigned char *)(a3 + 23))
    {
      goto LABEL_40;
    }
    std::string::size_type size = *((unsigned char *)&v65.__r_.__value_.__s + 23) & 0x7F;
    if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v65.__r_.__value_.__l.__size_;
    }
    if (size)
    {
      std::string::append(&v65, ",");
      LOBYTE(v17) = *(unsigned char *)(a3 + 23);
    }
    if ((v17 & 0x80u) == 0) {
      uint64_t v19 = (const std::string::value_type *)a3;
    }
    else {
      uint64_t v19 = *(const std::string::value_type **)a3;
    }
    if ((v17 & 0x80u) == 0) {
      std::string::size_type v20 = v17 & 0x7F;
    }
    else {
      std::string::size_type v20 = *(void *)(a3 + 8);
    }
    std::string::append(&v65, v19, v20);
  }
LABEL_40:
  std::string::size_type v21 = *((unsigned char *)&v65.__r_.__value_.__s + 23) & 0x7F;
  if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v21 = v65.__r_.__value_.__l.__size_;
  }
  if (v21)
  {
    std::operator+<char>();
    operator new();
  }
  if (v61 >= 0) {
    size_t v22 = &v59;
  }
  else {
    size_t v22 = v59;
  }
  if (v61 >= 0) {
    uint64_t v23 = v61 & 0x7F;
  }
  else {
    uint64_t v23 = v60;
  }
  if (v64 >= 0) {
    unint64_t v24 = &v62;
  }
  else {
    unint64_t v24 = v62;
  }
  if (v64 >= 0) {
    uint64_t v25 = v64 & 0x7F;
  }
  else {
    uint64_t v25 = v63;
  }
  if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v26 = &v65;
  }
  else {
    char v26 = (std::string *)v65.__r_.__value_.__r.__words[0];
  }
  if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v27 = *((unsigned char *)&v65.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    uint64_t v27 = v65.__r_.__value_.__l.__size_;
  }
  uint64_t v28 = sub_1CD454388(v15, (uint64_t)v22, v23, (uint64_t)v24, v25, (uint64_t)v26, v27, (uint64_t)&v40, 0x100000000, 0, 2, 0);
  uint64_t v29 = *a1;
  *a1 = v28;
  if (v29)
  {
    (*(void (**)(uint64_t))(*(void *)v29 + 8))(v29);
    uint64_t v28 = *a1;
  }
  if (!v28)
  {
    strcpy((char *)operator new(0x20uLL), "Cannot create the TargetMachine");
    operator new();
  }
  if (v61 >= 0) {
    uint64_t v30 = &v59;
  }
  else {
    uint64_t v30 = v59;
  }
  if (v61 >= 0) {
    uint64_t v31 = v61 & 0x7F;
  }
  else {
    uint64_t v31 = v60;
  }
  if (v64 >= 0) {
    uint64_t v32 = &v62;
  }
  else {
    uint64_t v32 = v62;
  }
  if (v64 >= 0) {
    uint64_t v33 = v64 & 0x7F;
  }
  else {
    uint64_t v33 = v63;
  }
  if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    BOOL v34 = &v65;
  }
  else {
    BOOL v34 = (std::string *)v65.__r_.__value_.__r.__words[0];
  }
  if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v35 = *((unsigned char *)&v65.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    uint64_t v35 = v65.__r_.__value_.__l.__size_;
  }
  uint64_t v36 = sub_1CD454388(v15, (uint64_t)v30, v31, (uint64_t)v32, v33, (uint64_t)v34, v35, (uint64_t)&v40, 0x100000001, 0, 2, 0);
  uint64_t v37 = a1[1];
  a1[1] = v36;
  if (v37)
  {
    (*(void (**)(uint64_t))(*(void *)v37 + 8))(v37);
    uint64_t v36 = a1[1];
  }
  if (!v36)
  {
    strcpy((char *)operator new(0x20uLL), "Cannot create the TargetMachine");
    operator new();
  }
  if (v55 < 0) {
    operator delete(v54);
  }
  v66.__r_.__value_.__r.__words[0] = (std::string::size_type)&v53;
  sub_1CB8338B8((void ***)&v66);
  if (v52 < 0) {
    operator delete(v51);
  }
  if (v50 < 0) {
    operator delete(v49);
  }
  if (v48 < 0) {
    operator delete(v47);
  }
  if (v46 < 0) {
    operator delete(v45);
  }
  if (v43 < 0) {
    operator delete(v42);
  }
  uint64_t v38 = v41;
  if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
    std::__shared_weak_count::__release_weak(v38);
  }
  if (SHIBYTE(v58) < 0) {
    operator delete((void *)v57);
  }
  sub_1CD45475C((uint64_t)&v59);
  return a1;
}

uint64_t sub_1CBF41FFC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    uint64_t v4 = *(void *)(i - 8);
    *(void *)(i - 8) = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1CBF42078(void ***a1)
{
  long long v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    __int16 v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        *uint64_t v4 = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
        }
      }
      while (v4 != v2);
      __int16 v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1CBF42120(uint64_t (***a1)(void))
{
  return (**a1)();
}

uint64_t sub_1CBF4212C()
{
  *(void *)&long long v3 = "Show encoding in .s output";
  *((void *)&v3 + 1) = 26;
  char v1 = 1;
  uint64_t v2 = &v1;
  sub_1CD3F48AC((uint64_t)&unk_1EBCC2C18, "show-mc-encoding", &v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC2C18, &dword_1CB82C000);
}

uint64_t llvm::AGX::Diagnostic::getMessage(llvm::AGX::Diagnostic *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 16))();
}

void *llvm::AGX::DiagnosticHandlerResetter::DiagnosticHandlerResetter(void *result, uint64_t a2)
{
  *__n128 result = a2;
  result[1] = 0;
  uint64_t v2 = *(void *)(*(void *)a2 + 72);
  *(void *)(*(void *)a2 + 72) = 0;
  uint64_t v3 = result[1];
  result[1] = v2;
  if (v3)
  {
    uint64_t v4 = result;
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    return v4;
  }
  return result;
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  *__n128 result = a2;
  result[1] = 0;
  uint64_t v2 = *(void *)(*(void *)a2 + 72);
  *(void *)(*(void *)a2 + 72) = 0;
  uint64_t v3 = result[1];
  result[1] = v2;
  if (v3)
  {
    uint64_t v4 = result;
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    return v4;
  }
  return result;
}

void *llvm::AGX::DiagnosticHandlerResetter::DiagnosticHandlerResetter(void *a1, void *a2)
{
  *a1 = *a2;
  uint64_t v3 = a2[1];
  a2[1] = 0;
  a1[1] = v3;
  uint64_t v4 = a2[1];
  *a2 = 0;
  a2[1] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  return a1;
}

{
  uint64_t v3;
  uint64_t v4;

  *a1 = *a2;
  uint64_t v3 = a2[1];
  a2[1] = 0;
  a1[1] = v3;
  uint64_t v4 = a2[1];
  *a2 = 0;
  a2[1] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  return a1;
}

void llvm::AGX::DiagnosticHandlerResetter::~DiagnosticHandlerResetter(llvm::AGX::DiagnosticHandlerResetter *this)
{
  uint64_t v2 = *(uint64_t **)this;
  if (*(void *)this)
  {
    uint64_t v3 = *v2;
    uint64_t v4 = *((void *)this + 1);
    *((void *)this + 1) = 0;
    uint64_t v5 = *(void *)(v3 + 72);
    *(void *)(v3 + 72) = v4;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    *(unsigned char *)(*v2 + 80) = 0;
  }
  uint64_t v6 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
}

void llvm::AGX::DiagnosticManager::temporaryInstall(llvm::AGX::DiagnosticManager *this@<X0>, llvm::LLVMContext *a2@<X1>, llvm::LLVMContext **a3@<X8>)
{
  uint64_t v3 = *(llvm::LLVMContext **)(*(void *)a2 + 72);
  *(void *)(*(void *)a2 + 72) = 0;
  *a3 = a2;
  a3[1] = v3;
  llvm::AGX::DiagnosticManager::install(this, a2);
}

void llvm::AGX::DiagnosticManager::install(llvm::AGX::DiagnosticManager *this, llvm::LLVMContext *a2)
{
}

void *sub_1CBF42504(void *a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  sub_1CBF425D4((uint64_t)v4, a2);
  sub_1CBF4266C(v4, a1);
  if (v5 == v4)
  {
    (*(void (**)(void *))(v4[0] + 32))(v4);
  }
  else if (v5)
  {
    (*(void (**)(void))(*v5 + 40))();
  }
  return a1;
}

uint64_t sub_1CBF425D4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *sub_1CBF4266C(void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1CBF428D8()
{
}

void *sub_1CBF428EC(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F25FF9C0;
  result[1] = v3;
  return result;
}

uint64_t sub_1CBF42934(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F25FF9C0;
  a2[1] = v2;
  return result;
}

void sub_1CBF42960(int a1, llvm::SMDiagnostic *this)
{
  v18[2] = *MEMORY[0x1E4F143B8];
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v17 = 0;
  int v8 = 0;
  char v12 = 0;
  uint64_t v13 = 0;
  uint64_t v15 = __p;
  int v14 = 0;
  uint64_t v7 = &unk_1F2646F30;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  llvm::SMDiagnostic::print(this, "", (llvm::raw_ostream *)&v7, 0, 1);
  int v3 = *((_DWORD *)this + 12);
  if ((v3 - 2) < 2)
  {
    uint64_t v5 = v15;
    v18[0] = v15[1];
    *(void *)((char *)v18 + 7) = *(void **)((char *)v15 + 15);
    v15[1] = 0;
    v5[2] = 0;
    *uint64_t v5 = 0;
    operator new();
  }
  if (v3 == 1)
  {
    uint64_t v6 = v15;
    v18[0] = v15[1];
    *(void *)((char *)v18 + 7) = *(void **)((char *)v15 + 15);
    v15[1] = 0;
    v6[2] = 0;
    *uint64_t v6 = 0;
    operator new();
  }
  if (!v3)
  {
    uint64_t v4 = v15;
    v18[0] = v15[1];
    *(void *)((char *)v18 + 7) = *(void **)((char *)v15 + 15);
    v15[1] = 0;
    v4[2] = 0;
    *uint64_t v4 = 0;
    operator new();
  }
  uint64_t v7 = &unk_1F2646B98;
  if (v14 == 1 && v9) {
    MEMORY[0x1D25D9CB0](v9, 0x1000C8077774924);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1CBF42E34()
{
}

uint64_t sub_1CBF42E48(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 8);
  if ((v3 - 18) >= 0xFFFFFFF7)
  {
    if (!(*(unsigned int (**)(uint64_t))(*(void *)a2 + 32))(a2)) {
      return 1;
    }
    int v3 = *(_DWORD *)(a2 + 8);
  }
  if (v3 == 20)
  {
    memcpy(__dst, (const void *)(a2 + 16), sizeof(__dst));
    operator new();
  }
  int v4 = *(char *)(a2 + 12);
  if ((v4 - 2) < 2)
  {
    sub_1CBF4347C((uint64_t)&v6, a2);
    operator new();
  }
  if (v4 == 1)
  {
    sub_1CBF4347C((uint64_t)&__p, a2);
    operator new();
  }
  if (!*(unsigned char *)(a2 + 12))
  {
    sub_1CBF4347C((uint64_t)&v8, a2);
    operator new();
  }
  return 1;
}

uint64_t sub_1CBF43460(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t result = qword_1EA61EF78;
  if (qword_1EA61EF78) {
    return llvm::Regex::match(qword_1EA61EF78, a2, a3, 0, 0);
  }
  return result;
}

void sub_1CBF4347C(uint64_t a1, uint64_t a2)
{
  v14[0] = 0;
  v14[1] = 0;
  uint64_t v15 = 0;
  int v6 = 0;
  char v10 = 0;
  uint64_t v11 = 0;
  uint64_t v13 = v14;
  int v12 = 0;
  v4[1] = &v5;
  uint64_t v5 = &unk_1F2646F30;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  v4[0] = &unk_1F26169D0;
  (*(void (**)(uint64_t, void *))(*(void *)a2 + 24))(a2, v4);
  if (*((char *)v13 + 23) < 0)
  {
    sub_1CB8BDF7C(a1, *v13, (unint64_t)v13[1]);
  }
  else
  {
    long long v3 = *(_OWORD *)v13;
    *(void *)(a1 + 16) = v13[2];
    *(_OWORD *)a1 = v3;
  }
  uint64_t v5 = &unk_1F2646B98;
  if (v12 == 1 && v7) {
    MEMORY[0x1D25D9CB0](v7, 0x1000C8077774924);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(v14[0]);
  }
}

void *sub_1CBF435C4(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x1D25D97B0](v13, a1);
  if (v13[0])
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *(void *)(v6 + 40);
    uint64_t v8 = a2 + a3;
    if ((*(_DWORD *)(v6 + 8) & 0xB0) == 0x20) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = a2;
    }
    int v10 = *(_DWORD *)(v6 + 144);
    if (v10 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      uint64_t v11 = std::locale::use_facet(&v14, MEMORY[0x1E4FBA258]);
      int v10 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v10;
    }
    if (!sub_1CBF43708(v7, a2, v9, v8, v6, (char)v10)) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x1D25D97C0](v13);
  return a1;
}

uint64_t sub_1CBF43708(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      size_t v12 = 0;
    }
    else {
      size_t v12 = v11 - (a4 - a2);
    }
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1) != a3 - a2) {
      return 0;
    }
    if ((uint64_t)v12 >= 1)
    {
      if (v12 >= 0x7FFFFFFFFFFFFFF8) {
        abort();
      }
      if (v12 >= 0x17)
      {
        uint64_t v14 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v12 | 7) != 0x17) {
          uint64_t v14 = v12 | 7;
        }
        uint64_t v15 = v14 + 1;
        uint64_t v13 = (void **)operator new(v14 + 1);
        __b[1] = (void *)v12;
        int64_t v21 = v15 | 0x8000000000000000;
        __b[0] = v13;
      }
      else
      {
        HIBYTE(v21) = v12;
        uint64_t v13 = __b;
      }
      memset(v13, __c, v12);
      *((unsigned char *)v13 + v12) = 0;
      __int16 v16 = v21 >= 0 ? __b : (void **)__b[0];
      uint64_t v17 = (*(uint64_t (**)(uint64_t, void **, size_t))(*(void *)v6 + 96))(v6, v16, v12);
      if (SHIBYTE(v21) < 0) {
        operator delete(__b[0]);
      }
      if (v17 != v12) {
        return 0;
      }
    }
    uint64_t v18 = a4 - a3;
    if (v18 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96))(v6, a3, v18) == v18) {
      *(void *)(a5 + 24) = 0;
    }
    else {
      return 0;
    }
  }
  return v6;
}

uint64_t llvm::AGX::PerformanceDiagnostic::getMessageImpl(llvm::AGX::PerformanceDiagnostic *this)
{
  uint64_t result = *((void *)this + 59);
  if (!result)
  {
    sub_1CBF43AA8((uint64_t)&v4);
    sub_1CBF435C4(&v5, (uint64_t)"[Performance Stats] Instructions: ", 34);
    uint64_t v2 = (void *)std::ostream::operator<<();
    sub_1CBF435C4(v2, (uint64_t)" ; Registers: ", 14);
    long long v3 = (void *)std::ostream::operator<<();
    sub_1CBF435C4(v3, (uint64_t)" ...", 4);
    operator new();
  }
  return result;
}

uint64_t sub_1CBF43AA8(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v3 = MEMORY[0x1E4FBA488] + 104;
  *(void *)(a1 + 128) = MEMORY[0x1E4FBA488] + 104;
  uint64_t v4 = a1 + 16;
  uint64_t v5 = MEMORY[0x1E4FBA488] + 64;
  *(void *)(a1 + 16) = MEMORY[0x1E4FBA488] + 64;
  uint64_t v6 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v7 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  uint64_t v8 = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)a1 = v8;
  *(void *)(a1 + *(void *)(v8 - 24)) = v7;
  *(void *)(a1 + 8) = 0;
  uint64_t v9 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v9, (void *)(a1 + 24));
  v9[1].__vftable = 0;
  v9[1].__fmtflags_ = -1;
  uint64_t v10 = v6[5];
  uint64_t v11 = v6[4];
  *(void *)(a1 + 16) = v11;
  *(void *)(v4 + *(void *)(v11 - 24)) = v10;
  uint64_t v12 = v6[1];
  *(void *)a1 = v12;
  *(void *)(a1 + *(void *)(v12 - 24)) = v6[6];
  *(void *)a1 = v2;
  *(void *)(a1 + 128) = v3;
  *(void *)(a1 + 16) = v5;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

uint64_t llvm::AGX::TimingDiagnostic::getMessageImpl(llvm::AGX::TimingDiagnostic *this)
{
  uint64_t result = *((void *)this + 3);
  if (!result)
  {
    sub_1CBF43AA8((uint64_t)&v7);
    uint64_t v3 = sub_1CBF435C4(&v8, (uint64_t)"[Timing] ", 9);
    std::to_string(&__p, *((double *)this + 2));
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    sub_1CBF435C4(v3, (uint64_t)p_p, size);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    operator new();
  }
  return result;
}

void sub_1CBF43F50(void *a1)
{
  *a1 = &unk_1F25FFA78;
  sub_1CB833F88(a1 + 59, 0);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBF43FBC(void *a1)
{
  *a1 = &unk_1F25FFAA0;
  sub_1CB833F88(a1 + 3, 0);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t llvm::AGX::AssemblePipeline::AssemblerImpl::run(llvm::AGX::DiagnosticManager **a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  uint64_t v58 = 0;
  memset(v57, 0, sizeof(v57));
  char v5 = *((unsigned char *)a2 + 23);
  BOOL v6 = v5 < 0;
  if (v5 >= 0) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = (uint64_t *)*a2;
  }
  uint64_t v8 = v5 & 0x7F;
  if (v6) {
    uint64_t v9 = a2[1];
  }
  else {
    uint64_t v9 = v8;
  }
  __int16 v77 = 261;
  v76[0] = "";
  v76[1] = 0;
  *(void *)std::string v65 = v76;
  uint64_t v10 = sub_1CD096174((llvm::raw_ostream *)0x18, (uint64_t)v65);
  *uint64_t v10 = &unk_1F2644E70;
  v10[1] = v7;
  v10[2] = (char *)v7 + v9;
  std::string::size_type v56 = v10;
  sub_1CD452CE0((uint64_t)v57, (uint64_t *)&v56, 0);
  uint64_t v11 = (uint64_t)v56;
  std::string::size_type v56 = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  uint64_t v12 = *a1;
  uint64_t v13 = (long long *)((char *)*a1 + 448);
  char v14 = *((unsigned char *)*a1 + 519);
  if (v14 >= 0) {
    uint64_t v15 = (uint64_t)*a1 + 496;
  }
  else {
    uint64_t v15 = *((void *)*a1 + 62);
  }
  if (v14 >= 0) {
    uint64_t v16 = v14 & 0x7F;
  }
  else {
    uint64_t v16 = *((void *)*a1 + 63);
  }
  char v17 = *((unsigned char *)v12 + 543);
  int v18 = v17;
  if (v17 >= 0) {
    uint64_t v19 = (uint64_t)v12 + 520;
  }
  else {
    uint64_t v19 = *((void *)v12 + 65);
  }
  uint64_t v20 = v17 & 0x7F;
  if (v18 >= 0) {
    uint64_t v21 = v20;
  }
  else {
    uint64_t v21 = *((void *)v12 + 66);
  }
  uint64_t v22 = *((void *)v12 + 1);
  char v23 = *((unsigned char *)v12 + 471);
  BOOL v24 = v23 < 0;
  uint64_t v26 = *((void *)v12 + 56);
  uint64_t v25 = *((void *)v12 + 57);
  if (v23 >= 0) {
    uint64_t v27 = (uint64_t)*a1 + 448;
  }
  else {
    uint64_t v27 = v26;
  }
  uint64_t v28 = v23 & 0x7F;
  if (v24) {
    uint64_t v29 = v25;
  }
  else {
    uint64_t v29 = v28;
  }
  uint64_t v30 = sub_1CD452D6C(v22, v27, v29, v15, v16, v19, v21);
  uint64_t v31 = (llvm::MCStreamer *)*((void *)*a1 + 70);
  llvm::MCContext::MCContext((uint64_t)v76, v13, (uint64_t)v31, *((void *)*a1 + 71), v30, (uint64_t)v57, 0, 1, 0, 0);
  llvm::AGX::DiagnosticManager::install(a1[1], (llvm::MCContext *)v76);
  uint64_t v32 = sub_1CD454E24(*((void *)*a1 + 1), (uint64_t)v76, 0, 0);
  uint64_t v78 = v32;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCC2CE8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EBCC2CE8))
  {
    __cxa_atexit((void (*)(void *))sub_1CBF450F8, &qword_1EBCC2CE0, &dword_1CB82C000);
    __cxa_guard_release(&qword_1EBCC2CE8);
  }
  int v48 = 0;
  char v52 = 0;
  uint64_t v53 = 0;
  int v54 = 1;
  uint64_t v50 = 0;
  uint64_t v51 = 0;
  uint64_t v49 = 0;
  int v47 = &unk_1F25FF8C8;
  uint64_t v55 = a3;
  uint64_t v33 = *a1;
  BOOL v34 = *(uint64_t (**)(void, void *))(*((void *)*a1 + 1) + 144);
  if (!v34)
  {
    uint64_t v75 = 0;
    goto LABEL_31;
  }
  uint64_t v35 = *((void *)v33 + 73);
  uint64_t v75 = v34(*((void *)v33 + 72), v76);
  if (!v75)
  {
LABEL_31:
    strcpy((char *)operator new(0x20uLL), "Can't initialize CodeEmitter");
    operator new();
  }
  *(_WORD *)std::string v65 = 4096;
  *(void *)&v65[4] = 2;
  *(_OWORD *)std::string v66 = 0u;
  *(_OWORD *)uint64_t v67 = 0u;
  long long v68 = 0u;
  *(_OWORD *)uint64_t v69 = 0u;
  *(_OWORD *)uint64_t v70 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  uint64_t v36 = *(uint64_t (**)(void))(*((void *)v33 + 1) + 104);
  if (!v36)
  {
    char v64 = 0;
    goto LABEL_35;
  }
  uint64_t v37 = (llvm::MCAsmBackend *)v36();
  char v64 = v37;
  if (!v37)
  {
LABEL_35:
    strcpy((char *)operator new(0x20uLL), "Can't initialize AsmBackend");
    operator new();
  }
  uint64_t v38 = *((void *)v33 + 1);
  if (*((char *)v33 + 471) < 0)
  {
    sub_1CB8BDF7C((uint64_t)__p, *((const void **)v33 + 56), *((void *)v33 + 57));
    uint64_t v37 = v64;
  }
  else
  {
    *(_OWORD *)std::string __p = *((_OWORD *)v33 + 28);
    uint64_t v61 = *((void *)v33 + 58);
  }
  uint64_t v63 = *((void *)v33 + 61);
  long long v62 = *(_OWORD *)((char *)v33 + 472);
  llvm::MCAsmBackend::createObjectWriter(&v59, v37, (llvm::raw_pwrite_stream *)&v47);
  uint64_t v42 = sub_1CD455004(v38, (uint64_t)__p, (uint64_t)v76, (uint64_t)&v64, (uint64_t)&v59, (uint64_t)&v75, v35, *((_WORD *)v33 + 564) & 1, HIBYTE(*((_WORD *)v33 + 564)) & 1, 1u);
  uint64_t v44 = v59;
  uint64_t v59 = 0;
  if (v44) {
    (*(void (**)(uint64_t))(*(void *)v44 + 8))(v44);
  }
  if (SHIBYTE(v61) < 0) {
    operator delete(__p[0]);
  }
  if (!v42)
  {
    strcpy((char *)operator new(0x20uLL), "Can't initialize ObjStreamer");
    operator new();
  }
  BOOL v39 = v64;
  char v64 = 0;
  if (v39) {
    (*(void (**)(llvm::MCAsmBackend *))(*(void *)v39 + 8))(v39);
  }
  __p[0] = (char *)&v73 + 8;
  sub_1CB8338B8((void ***)__p);
  if (SHIBYTE(v71) < 0) {
    operator delete(v70[1]);
  }
  if (SHIBYTE(v70[0]) < 0) {
    operator delete(v69[0]);
  }
  if (SHIBYTE(v68) < 0) {
    operator delete(v67[1]);
  }
  if (SHIBYTE(v67[0]) < 0) {
    operator delete(v66[0]);
  }
  uint64_t v40 = v75;
  uint64_t v75 = 0;
  if (v40) {
    (*(void (**)(uint64_t))(*(void *)v40 + 8))(v40);
  }
  uint64_t v41 = qword_1EBCC2CE0;
  qword_1EBCC2CE0 = v42;
  if (v41)
  {
    (*(void (**)(uint64_t))(*(void *)v41 + 48))(v41);
    uint64_t v42 = qword_1EBCC2CE0;
  }
  if (v42)
  {
    char v43 = *(uint64_t (**)(void))(*((void *)*a1 + 1) + 64);
    if (v43)
    {
      if (v43())
      {
        long long v73 = 0u;
        long long v74 = 0u;
        long long v71 = 0u;
        long long v72 = 0u;
        *(_OWORD *)uint64_t v69 = 0u;
        *(_OWORD *)uint64_t v70 = 0u;
        *(_OWORD *)uint64_t v67 = 0u;
        long long v68 = 0u;
        *(_OWORD *)std::string v66 = 0u;
        *(void *)&v65[4] = 2;
        *(_WORD *)std::string v65 = 4096;
        llvm::createMCAsmParser((llvm *)v57, (llvm::SourceMgr *)v76, (llvm::MCContext *)qword_1EBCC2CE0, v31, 0);
      }
    }
    strcpy((char *)operator new(0x20uLL), "Cannot create MCInstrInfo\n");
    operator new();
  }
  int v47 = &unk_1F25FF8C8;
  int64_t v45 = v51 - v49;
  if (v51 != v49)
  {
    uint64_t v51 = v49;
    llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)&v47, v49);
  }
  int v47 = &unk_1F2646B98;
  if (v54 == 1 && v49) {
    MEMORY[0x1D25D9CB0](v49, 0x1000C8077774924, v45);
  }
  if (v32) {
    (*(void (**)(uint64_t))(*(void *)v32 + 8))(v32);
  }
  llvm::MCContext::~MCContext((llvm::MCContext *)v76);
  if (v30) {
    (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
  }
  llvm::SourceMgr::~SourceMgr((llvm::SourceMgr *)v57);
  return 0;
}

uint64_t *sub_1CBF450F8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 48))(v2);
  }
  return a1;
}

void llvm::AGX::Pipeline::Pipeline(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, char a7, char a8)
{
}

{
  sub_1CBF45190(a1, a2, a3, a4, a5, a6, a8, a7);
}

void sub_1CBF45190(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, char a7, char a8)
{
  int v10 = a5;
  char v9 = a7;
  char v8 = a8;
  operator new();
}

void llvm::AGX::Pipeline::collectConfiguration(uint64_t **this, llvm::AGX::CompileRequest *a2)
{
  uint64_t v2 = *this;
  uint64_t v3 = (*this)[1];
  if (v3 || (uint64_t v3 = *v2) != 0) {
    sub_1CBF4B32C(v3, (uint64_t)a2);
  }
}

void llvm::AGX::Pipeline::run(const llvm::Module ***this@<X0>, llvm::AGX::CompileRequest *a2@<X1>, uint64_t a3@<X8>)
{
}

void sub_1CBF4549C(const llvm::Module **a1@<X0>, llvm::AGX::CompileRequest *a2@<X1>, uint64_t a3@<X8>)
{
  v80[4] = *MEMORY[0x1E4F143B8];
  if ((atomic_load_explicit((atomic_uchar *volatile)qword_1EBCC2CF0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(qword_1EBCC2CF0))
  {
    CFStringRef v44 = CFStringCreateWithCStringNoCopy(0, "LogLoweredShaders", 0, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    keyExistsAndHasValidFormat[0] = 0;
    int AppBooleanValue = CFPreferencesGetAppBooleanValue(v44, @"com.apple.Metal", keyExistsAndHasValidFormat);
    CFRelease(@"com.apple.Metal");
    CFRelease(v44);
    __int16 v46 = keyExistsAndHasValidFormat[0];
    if (keyExistsAndHasValidFormat[0])
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"LogLoweredShaders";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = AppBooleanValue;
        _os_log_impl(&dword_1CB82C000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "Read preference %s: %d", (uint8_t *)&buf, 0x12u);
      }
      __int16 v46 = AppBooleanValue != 0;
      __int16 v47 = 1;
    }
    else
    {
      __int16 v47 = 0;
    }
    word_1EBCC2CDE = v46 | (v47 << 8);
    __cxa_guard_release(qword_1EBCC2CF0);
  }
  if ((unsigned __int16)word_1EBCC2CDE >= 0x100u && word_1EBCC2CDE != 0)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"/private/var/mobile/Library/Logs/Metal";
      _os_log_impl(&dword_1CB82C000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Logging shader %s", (uint8_t *)&buf, 0xCu);
    }
    llvm::AGX::AGCReplay::serializeRequestToIR((llvm::AGX::AGCReplay *)(a1 + 2), a2, a1[19]);
    uint64_t v30 = *(const std::string **)(*(void *)a2 + 8);
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)"/private/var/mobile/Library/Logs/Metal";
    LOWORD(v77) = 259;
    *(void *)&v65.__val_ = llvm::sys::fs::create_directory((unsigned __int8 *)&buf, 1, 0x1FFu);
    v65.__cat_ = v31;
    if (v65.__val_)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
      {
        std::error_code::message(&buf, &v65);
        uint64_t v32 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &buf
            : (std::string *)buf.__r_.__value_.__r.__words[0];
        *(_DWORD *)keyExistsAndHasValidFormat = 136315394;
        *(void *)&keyExistsAndHasValidFormat[4] = "/private/var/mobile/Library/Logs/Metal";
        *(_WORD *)&keyExistsAndHasValidFormat[12] = 2080;
        *(void *)&keyExistsAndHasValidFormat[14] = v32;
        _os_log_error_impl(&dword_1CB82C000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Could not create dir %s (%s)", keyExistsAndHasValidFormat, 0x16u);
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(buf.__r_.__value_.__l.__data_);
        }
      }
    }
    else
    {
      uint64_t v78 = v80;
      long long v79 = xmmword_1CDC7F9D0;
      int v57 = 0;
      char v61 = 0;
      uint64_t v62 = 0;
      char v64 = (std::string::size_type *)&v78;
      int v63 = 0;
      std::string::size_type v56 = (llvm::Module *)&unk_1F2646FA8;
      uint64_t v58 = 0;
      uint64_t v59 = 0;
      uint64_t v60 = 0;
      v33.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
      llvm::operator<<((llvm::raw_ostream *)&v56, 1000 * v33.__d_.__rep_);
      std::string::size_type v34 = *v64;
      std::string::size_type v35 = v64[1];
      buf.__r_.__value_.__r.__words[0] = *v64;
      buf.__r_.__value_.__l.__size_ = v35;
      keyExistsAndHasValidFormat[0] = 32;
      unint64_t v36 = llvm::StringRef::find((uint64_t *)&buf, keyExistsAndHasValidFormat, 1uLL, 0);
      if (v36 == -1)
      {
        std::string::size_type v40 = 0;
        std::string::size_type v39 = 0;
      }
      else
      {
        if (v35 >= v36) {
          std::string::size_type v37 = v36;
        }
        else {
          std::string::size_type v37 = v35;
        }
        if (v35 >= v36 + 1) {
          std::string::size_type v38 = v36 + 1;
        }
        else {
          std::string::size_type v38 = v35;
        }
        std::string::size_type v39 = v34 + v38;
        std::string::size_type v40 = v35 - v38;
        std::string::size_type v35 = v37;
      }
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v76;
      *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = xmmword_1CFAC3020;
      *(void *)keyExistsAndHasValidFormat = "/private/var/mobile/Library/Logs/Metal";
      v69[4] = 259;
      __int16 v53 = 1283;
      v52[0] = "llvm-agx-shader-";
      v52[2] = v34;
      void v52[3] = v35;
      v54[0] = v52;
      v54[2] = "_";
      __int16 v55 = 770;
      *(void *)uint64_t v70 = v54;
      *(void *)&v72[2] = v39;
      std::string::size_type v73 = v40;
      __int16 v74 = 1282;
      v66.__r_.__value_.__r.__words[0] = (std::string::size_type)v70;
      v66.__r_.__value_.__r.__words[2] = (std::string::size_type)".%%%%%%%%.ll";
      __int16 v67 = 770;
      __int16 v51 = 257;
      __int16 v49 = 257;
      llvm::sys::path::append(&buf, 0, (const char **)keyExistsAndHasValidFormat, &v66, (uint64_t)v50, (uint64_t)v48);
      LODWORD(v54[0]) = 0;
      *(void *)keyExistsAndHasValidFormat = v69;
      *(_OWORD *)&keyExistsAndHasValidFormat[8] = xmmword_1CFAC3020;
      __int16 v67 = 261;
      *(_OWORD *)&v66.__r_.__value_.__l.__data_ = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
      *(void *)&v65.__val_ = sub_1CD0E5038((uint64_t)&v66, (int *)v54, keyExistsAndHasValidFormat, 0, 1, 0, 438);
      v65.__cat_ = v41;
      if (v65.__val_)
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          if ((unint64_t)(*(void *)&keyExistsAndHasValidFormat[8] + 1) > *(void *)&keyExistsAndHasValidFormat[16]) {
            llvm::SmallVectorBase<unsigned long long>::grow_pod();
          }
          *(unsigned char *)(*(void *)keyExistsAndHasValidFormat + *(void *)&keyExistsAndHasValidFormat[8]) = 0;
          uint64_t v42 = *(void *)keyExistsAndHasValidFormat;
          std::error_code::message(&v66, &v65);
          if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            char v43 = &v66;
          }
          else {
            char v43 = (std::string *)v66.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)uint64_t v70 = 136315394;
          *(void *)&v70[4] = v42;
          __int16 v71 = 2080;
          *(void *)long long v72 = v43;
          _os_log_error_impl(&dword_1CB82C000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Could not create file %s (%s)", v70, 0x16u);
          if (SHIBYTE(v66.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v66.__r_.__value_.__l.__data_);
          }
        }
      }
      else
      {
        if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO))
        {
          if ((unint64_t)(*(void *)&keyExistsAndHasValidFormat[8] + 1) > *(void *)&keyExistsAndHasValidFormat[16]) {
            llvm::SmallVectorBase<unsigned long long>::grow_pod();
          }
          *(unsigned char *)(*(void *)keyExistsAndHasValidFormat + *(void *)&keyExistsAndHasValidFormat[8]) = 0;
          LODWORD(v66.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v66.__r_.__value_.__r.__words + 4) = *(void *)keyExistsAndHasValidFormat;
          _os_log_impl(&dword_1CB82C000, MEMORY[0x1E4F14500], OS_LOG_TYPE_INFO, "Writing lowered shader to %s", (uint8_t *)&v66, 0xCu);
        }
        llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v66, v54[0], 1, 0, 0);
        llvm::Module::print(v30, (llvm::raw_ostream *)&v66, 0, 0, 0);
        llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v66);
      }
      if (*(_WORD **)keyExistsAndHasValidFormat != v69) {
        free(*(void **)keyExistsAndHasValidFormat);
      }
      if ((uint64_t *)buf.__r_.__value_.__l.__data_ != &v76) {
        free(buf.__r_.__value_.__l.__data_);
      }
      std::string::size_type v56 = (llvm::Module *)&unk_1F2646B98;
      if (v63 == 1 && v58) {
        MEMORY[0x1D25D9CB0](v58, 0x1000C8077774924);
      }
      if (v78 != v80) {
        free(v78);
      }
    }
  }
  uint64_t v7 = *(_DWORD **)(*(void *)a2 + 8);
  unint64_t v8 = *(unsigned __int8 *)(*(void *)a2 + 47);
  if ((v8 & 0x80u) == 0) {
    unint64_t v9 = v8 & 0x7F;
  }
  else {
    unint64_t v9 = *(void *)(*(void *)a2 + 32);
  }
  if (v9 == 7)
  {
    int v10 = (void *)(*(void *)a2 + 24);
    if ((v8 & 0x80) != 0)
    {
      int v10 = (void *)*v10;
      unint64_t v8 = *(void *)(*(void *)a2 + 32);
    }
    if (v8 >= 7) {
      size_t v11 = 7;
    }
    else {
      size_t v11 = v8;
    }
    BOOL v12 = memcmp(v10, "utility", v11) == 0;
    BOOL v13 = v8 == 7 && v12;
  }
  else
  {
    BOOL v13 = 0;
  }
  uint64_t inserted = llvm::Module::getOrInsertNamedMetadata(v7, "agx.reduce.reg.pressure", 0x17uLL);
  uint64_t v16 = **(void **)v7;
  char v17 = *(llvm::ConstantInt **)(v16 + 1888);
  unint64_t v18 = *(unsigned int *)(v16 + 1896);
  LODWORD(buf.__r_.__value_.__r.__words[1]) = v18 >> 8;
  if (v18 >> 8 <= 0x40)
  {
    if (v18 <= 0xFF) {
      unint64_t v19 = 0;
    }
    else {
      unint64_t v19 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v18) + 63);
    }
    buf.__r_.__value_.__r.__words[0] = v19 & v13;
    uint64_t v21 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v17, (llvm::LLVMContext *)&buf, v14);
    if (LODWORD(buf.__r_.__value_.__r.__words[1]) >= 0x41 && buf.__r_.__value_.__r.__words[0]) {
      MEMORY[0x1D25D9CB0](buf.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
    }
    *(void *)keyExistsAndHasValidFormat = llvm::ValueAsMetadata::get(v21, v20);
    Impl = llvm::MDTuple::getImpl(*(void *)v7, keyExistsAndHasValidFormat, 1, 0, 1);
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)Impl;
    uint64_t v23 = *(void *)(inserted + 48);
    uint64_t v24 = *(unsigned int *)(v23 + 8);
    if (v24 >= *(_DWORD *)(v23 + 12))
    {
      sub_1CC608328(*(void *)(inserted + 48), (unsigned __int8 **)&buf);
    }
    else
    {
      uint64_t v25 = (unsigned __int8 *)Impl;
      uint64_t v26 = (unsigned __int8 **)(*(void *)v23 + 8 * v24);
      *uint64_t v26 = v25;
      if (v25)
      {
        llvm::MetadataTracking::track((uint64_t)v26, v25, 2);
        LODWORD(v24) = *(_DWORD *)(v23 + 8);
      }
      *(_DWORD *)(v23 + 8) = v24 + 1;
    }
    uint64_t v27 = *a1;
    if (*a1)
    {
      if (a1[1]) {
        llvm::CloneModule(*(llvm **)(*(void *)a2 + 8), v27);
      }
      uint64_t v28 = a3;
    }
    else
    {
      uint64_t v28 = a3;
      uint64_t v27 = a1[1];
    }
    sub_1CBF4B374(v28, v27, a2);
  }
  operator new[]();
}

void llvm::AGX::Pipeline::~Pipeline(llvm::AGX::Pipeline *this)
{
  uint64_t v1 = *(void *)this;
  *(void *)this = 0;
  if (v1) {
    sub_1CBF4C670((uint64_t)this, v1);
  }
}

{
  uint64_t v1;

  uint64_t v1 = *(void *)this;
  *(void *)this = 0;
  if (v1) {
    sub_1CBF4C670((uint64_t)this, v1);
  }
}

void llvm::AGX::AssemblePipeline::AssemblePipeline(llvm::AGX::AssemblePipeline *this, llvm::TargetMachine *a2, llvm::AGX::DiagnosticManager *a3)
{
}

{
  operator new();
}

void llvm::AGX::AssemblePipeline::~AssemblePipeline(llvm::AGX::AssemblePipeline *this)
{
  uint64_t v2 = *(void *)this;
  *(void *)this = 0;
  if (v2) {
    MEMORY[0x1D25D9CE0](v2, 0x20C40A4A59CD2);
  }
}

{
  uint64_t v2;

  uint64_t v2 = *(void *)this;
  *(void *)this = 0;
  if (v2) {
    MEMORY[0x1D25D9CE0](v2, 0x20C40A4A59CD2);
  }
}

void sub_1CBF461C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, int a8, unsigned __int8 a9)
{
  int DeviceTypeFromTarget = llvm::GPUBaseInfo::getDeviceTypeFromTarget(a3);
  switch(DeviceTypeFromTarget)
  {
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      int v15 = dword_1EBCC2CD8;
      break;
    default:
      int v15 = BYTE1(dword_1EBCC2CD8);
      break;
  }
  if (v15) {
    *(_DWORD *)(a3 + 1040) |= 0x80000u;
  }
  int v16 = *(_DWORD *)(a3 + 472);
  unsigned int v17 = v16 & 0xFFFFFFFE;
  BOOL v19 = a9 != 2 || v16 != 28;
  if (a5 == 3 || a9 - 1 < 2 || (DeviceTypeFromTarget - 4) < 0xC) {
    __int16 v23 = 4096;
  }
  else {
    __int16 v23 = 0;
  }
  if (v17 == 28) {
    __int16 v24 = v23;
  }
  else {
    __int16 v24 = 0;
  }
  if (a9 == 3) {
    __int16 v25 = 0;
  }
  else {
    __int16 v25 = v24;
  }
  *(_WORD *)(a3 + 1020) = *(_WORD *)(a3 + 1020) & 0xEFFF | v25;
  *(_DWORD *)(a3 + 1024) = v19;
  switch(a5)
  {
    case 1:
      uint64_t v26 = a1;
      uint64_t v27 = a2;
      uint64_t v28 = a3;
      break;
    case 2:
      uint64_t v26 = a1;
      uint64_t v27 = a2;
      uint64_t v28 = a3;
      break;
    case 3:
      if (a8)
      {
        strcpy((char *)operator new(0x30uLL), "Driver shader with opt requested (won't honor)");
        operator new();
      }
      operator new();
    case 4:
      uint64_t v26 = a1;
      uint64_t v27 = a2;
      uint64_t v28 = a3;
      break;
    default:
      operator new();
  }
  sub_1CBF46AB0(v26, v27, v28);
}

void sub_1CBF46AB0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (*(char *)(a3 + 471) < 0)
  {
    sub_1CB8BDF7C((uint64_t)__p, *(const void **)(a3 + 448), *(void *)(a3 + 456));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(a3 + 448);
    uint64_t v5 = *(void *)(a3 + 464);
  }
  long long v6 = *(_OWORD *)(a3 + 472);
  uint64_t v7 = *(void *)(a3 + 488);
  operator new();
}

void sub_1CBF4915C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = a3;
  uint64_t v4 = llvm::nulls((llvm *)a1);
  *(_DWORD *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + ++*(_DWORD *)(result + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 1;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = &unk_1F25FF8C8;
  *(void *)(a1 + 72) = v4;
  llvm::legacy::PassManager::PassManager((llvm::legacy::PassManager *)(a1 + 80));
}

uint64_t sub_1CBF4930C(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  v2[0] = &unk_1F25FFB58;
  v2[1] = a1;
  uint64_t v3 = v2;
  sub_1CBF49750(a1, (uint64_t)v2);
  uint64_t result = (uint64_t)v3;
  if (v3 == v2) {
    return (*(uint64_t (**)(void *))(v2[0] + 32))(v2);
  }
  if (v3) {
    return (*(uint64_t (**)(void))(*v3 + 40))();
  }
  return result;
}

uint64_t sub_1CBF493E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  if (a3 != 1)
  {
    if (a3 != 2)
    {
      strcpy((char *)operator new(0x38uLL), "Can't initialize backend, unhandled OutputSelection");
      operator new();
    }
    uint64_t v3 = 0;
  }
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t, void))(*(void *)a2 + 120))(a2, a1 + 80, a1 + 8, 0, v3, 1, 0))
  {
    strcpy((char *)operator new(0x20uLL), "Can't initialize backend");
    operator new();
  }
  return 1;
}

llvm *sub_1CBF49750(uint64_t a1, uint64_t a2)
{
  if (!a2)
  {
    sub_1CB920400();
    JUMPOUT(0x1CBF497BCLL);
  }
  uint64_t v3 = (llvm::Pass *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 48))(a2);
  uint64_t v4 = (int32x2_t *)(*(void *)(a1 + 88) + 416);

  return llvm::PMTopLevelManager::schedulePass(v4, v3);
}

void sub_1CBF497C0()
{
}

void *sub_1CBF497D4()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F25FFAC8;
  return result;
}

void sub_1CBF4980C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F25FFAC8;
}

void sub_1CBF49834()
{
}

void sub_1CBF498AC()
{
}

void *sub_1CBF498C0()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F25FFB10;
  return result;
}

void sub_1CBF498F8(uint64_t a1, void *a2)
{
  *a2 = &unk_1F25FFB10;
}

void sub_1CBF49920()
{
}

void sub_1CBF49980()
{
}

void *sub_1CBF49994(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F25FFB58;
  result[1] = v3;
  return result;
}

uint64_t sub_1CBF499DC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F25FFB58;
  a2[1] = v2;
  return result;
}

void sub_1CBF49A08()
{
}

void sub_1CBF49A18()
{
}

void *sub_1CBF49A2C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F25FFBA0;
  result[1] = v3;
  return result;
}

uint64_t sub_1CBF49A74(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F25FFBA0;
  a2[1] = v2;
  return result;
}

void sub_1CBF49AA0(uint64_t a1)
{
  v1[4] = *MEMORY[0x1E4F143B8];
  llvm::TargetMachine::getTargetIRAnalysis(**(llvm::TargetMachine ***)(a1 + 8), (uint64_t)v1);
  llvm::createTargetTransformInfoWrapperPass();
}

void sub_1CBF49B78()
{
}

void *sub_1CBF49B8C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F25FFCC0;
  return result;
}

void sub_1CBF49BC4(uint64_t a1, void *a2)
{
  *a2 = &unk_1F25FFCC0;
}

void sub_1CBF49BEC()
{
  v0[4] = *MEMORY[0x1E4F143B8];
  v0[0] = &unk_1F25FFD08;
  v0[3] = v0;
  llvm::createExternalAAWrapperPass();
}

void sub_1CBF49CD4()
{
}

void *sub_1CBF49CE8()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F25FFD08;
  return result;
}

void sub_1CBF49D20(uint64_t a1, void *a2)
{
  *a2 = &unk_1F25FFD08;
}

uint64_t sub_1CBF49D48(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*(void *)(a2 + 8) + 24), &llvm::GPUAAWrapperPass::ID, 1);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 96))(result, &llvm::GPUAAWrapperPass::ID);
    if (result) {
      operator new();
    }
  }
  return result;
}

uint64_t sub_1CBF49EF8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    uint64_t v4 = *(void *)(i - 8);
    *(void *)(i - 8) = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1CBF49F74()
{
}

uint64_t sub_1CBF49F88(uint64_t result, uint64_t a2)
{
  **(void **)(result + 8) = a2;
  return result;
}

BOOL sub_1CBF49F94(uint64_t a1, uint64_t **a2, uint64_t **a3)
{
  uint64_t v3 = **a2;
  unsigned int v4 = *(_DWORD *)(v3 + 8);
  if (v4 != 15) {
    return 1;
  }
  uint64_t v5 = **a3;
  unsigned int v6 = *(_DWORD *)(v5 + 8);
  if (v6 != 15) {
    return 1;
  }
  if ((v4 & 0xFE) == 0x12) {
    unsigned int v4 = *(_DWORD *)(**(void **)(v3 + 16) + 8);
  }
  if ((v6 & 0xFE) == 0x12) {
    unsigned int v6 = *(_DWORD *)(**(void **)(v5 + 16) + 8);
  }
  return v6 < 0x100 || v4 < 0x100 || (v6 ^ v4) <= 0xFF;
}

BOOL sub_1CBF4A028(uint64_t a1, llvm **a2)
{
  UnderlyingObject = llvm::getUnderlyingObject(*a2, (const llvm::Value *)6);
  int v3 = *(_DWORD *)(*(void *)UnderlyingObject + 8);
  if ((v3 & 0xFE) == 0x12) {
    int v3 = *(_DWORD *)(**(void **)(*(void *)UnderlyingObject + 16) + 8);
  }
  return (v3 & 0xFFFFFF00) == 512;
}

uint64_t sub_1CBF4A078()
{
  return 7;
}

uint64_t sub_1CBF4A080(uint64_t a1, const llvm::CallBase *a2)
{
  return llvm::GPUAAResult::getModRefBehavior(*(llvm::GPUAAResult **)(a1 + 8), a2);
}

uint64_t sub_1CBF4A088(uint64_t a1, llvm::Value *this)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *((void *)this + 14);
  if (v3)
  {
    if ((*(unsigned char *)(v3 + 17) & 0x10) != 0) {
      return 4;
    }
    if ((*(unsigned char *)(v3 + 17) & 0x20) != 0) {
      unsigned int v4 = 61;
    }
    else {
      unsigned int v4 = 63;
    }
    if ((*(unsigned char *)(v3 + 12) & 8) != 0) {
      uint64_t result = v4 & 0xF;
    }
    else {
      uint64_t result = v4;
    }
  }
  else
  {
    uint64_t result = 63;
  }
  unsigned int v6 = *(void **)(v2 + 8);
  if ((*(unsigned char *)(v6[1] + 40) & 0x80) == 0 && *(unsigned __int8 *)(*v6 + 81) >= 0x40u)
  {
    unsigned int v13 = result;
    Name = llvm::Value::getName(this);
    if (v8 == 16
      && (*(void *)Name == *(void *)"memset_pattern16"
        ? (BOOL v9 = *((void *)Name + 1) == *(void *)"attern16")
        : (BOOL v9 = 0),
          v9
       && (uint64_t v10 = *((void *)this + 3), *(_DWORD *)(v10 + 8) <= 0xFFu)
       && *(_DWORD *)(v10 + 12) == 4
       && (size_t v11 = *(void **)(v10 + 16), *(unsigned char *)(v11[1] + 8) == 15)
       && *(unsigned char *)(v11[2] + 8) == 15
       && *(unsigned char *)(v11[3] + 8) == 13))
    {
      return 15;
    }
    else
    {
      return v13;
    }
  }
  return result;
}

uint64_t sub_1CBF4A1A0()
{
  return 7;
}

uint64_t sub_1CBF4A1A8()
{
  return 7;
}

void sub_1CBF4A1B4()
{
}

void *sub_1CBF4A1C8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F25FFD50;
  result[1] = v3;
  return result;
}

uint64_t sub_1CBF4A210(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F25FFD50;
  a2[1] = v2;
  return result;
}

void sub_1CBF4A23C(uint64_t a1)
{
}

void sub_1CBF4A24C()
{
}

void *sub_1CBF4A260()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F25FFDE0;
  return result;
}

void sub_1CBF4A298(uint64_t a1, void *a2)
{
  *a2 = &unk_1F25FFDE0;
}

void sub_1CBF4A2C0()
{
}

void sub_1CBF4A2CC()
{
}

void *sub_1CBF4A2E0()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F25FFE28;
  return result;
}

void sub_1CBF4A318(uint64_t a1, void *a2)
{
  *a2 = &unk_1F25FFE28;
}

void sub_1CBF4A348()
{
}

void *sub_1CBF4A35C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F25FFE70;
  result[1] = v3;
  return result;
}

uint64_t sub_1CBF4A3A4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F25FFE70;
  a2[1] = v2;
  return result;
}

void sub_1CBF4A3D0()
{
}

void sub_1CBF4A3E0()
{
}

void *sub_1CBF4A3F4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F25FFEB8;
  result[1] = v3;
  return result;
}

uint64_t sub_1CBF4A43C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F25FFEB8;
  a2[1] = v2;
  return result;
}

void sub_1CBF4A468()
{
}

void sub_1CBF4A478()
{
}

void *sub_1CBF4A48C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F25FFF48;
  return result;
}

void sub_1CBF4A4C4(uint64_t a1, void *a2)
{
  *a2 = &unk_1F25FFF48;
}

void sub_1CBF4A4F4()
{
}

void *sub_1CBF4A508(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F25FFF90;
  result[1] = v3;
  return result;
}

uint64_t sub_1CBF4A550(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F25FFF90;
  a2[1] = v2;
  return result;
}

void sub_1CBF4A57C(uint64_t a1)
{
}

void sub_1CBF4A590()
{
}

void *sub_1CBF4A5A4()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F25FFFD8;
  return result;
}

void sub_1CBF4A5DC(uint64_t a1, void *a2)
{
  *a2 = &unk_1F25FFFD8;
}

void sub_1CBF4A604()
{
  llvm::createLoopUnrollPass((llvm *)2, 0, 0, -1, -1, -1, -1, -1, -1, v0);
}

void sub_1CBF4A650()
{
}

void *sub_1CBF4A664()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F2600020;
  return result;
}

void sub_1CBF4A69C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2600020;
}

void sub_1CBF4A6CC()
{
}

void *sub_1CBF4A6E0()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F2600068;
  return result;
}

void sub_1CBF4A718(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2600068;
}

void sub_1CBF4A748()
{
}

void *sub_1CBF4A75C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F26000B0;
  result[1] = v3;
  return result;
}

uint64_t sub_1CBF4A7A4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F26000B0;
  a2[1] = v2;
  return result;
}

void sub_1CBF4A7D0()
{
}

void sub_1CBF4A7E0()
{
}

void *sub_1CBF4A7F4()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F26000F8;
  return result;
}

void sub_1CBF4A82C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F26000F8;
}

void sub_1CBF4A854()
{
}

void sub_1CBF4A8B4()
{
}

void *sub_1CBF4A8C8()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F2600140;
  return result;
}

void sub_1CBF4A900(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2600140;
}

void sub_1CBF4A930()
{
}

void *sub_1CBF4A944(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F2600188;
  result[1] = v3;
  return result;
}

uint64_t sub_1CBF4A98C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2600188;
  a2[1] = v2;
  return result;
}

void sub_1CBF4A9B8()
{
}

void sub_1CBF4A9C8()
{
}

void *sub_1CBF4A9DC()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F26001D0;
  return result;
}

void sub_1CBF4AA14(uint64_t a1, void *a2)
{
  *a2 = &unk_1F26001D0;
}

void sub_1CBF4AA3C()
{
}

void sub_1CBF4AB28()
{
}

void *sub_1CBF4AB3C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F2600218;
  return result;
}

void sub_1CBF4AB74(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2600218;
}

void sub_1CBF4ABA4()
{
}

void *sub_1CBF4ABB8()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F2600260;
  return result;
}

void sub_1CBF4ABF0(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2600260;
}

void sub_1CBF4AC18()
{
}

void sub_1CBF4AC24()
{
}

void *sub_1CBF4AC38()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F26002A8;
  return result;
}

void sub_1CBF4AC70(uint64_t a1, void *a2)
{
  *a2 = &unk_1F26002A8;
}

void sub_1CBF4AC98()
{
  v0[4] = *MEMORY[0x1E4F143B8];
  v0[0] = &unk_1F26002F0;
  v0[3] = v0;
  llvm::createInternalizePass();
}

void sub_1CBF4AD80()
{
}

void *sub_1CBF4AD94()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F26002F0;
  return result;
}

void sub_1CBF4ADCC(uint64_t a1, void *a2)
{
  *a2 = &unk_1F26002F0;
}

BOOL sub_1CBF4ADF4(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 23) & 0x10) != 0)
  {
    uint64_t v3 = ***(void ***)a2;
    uint64_t v4 = *(void *)(v3 + 152);
    uint64_t v5 = *(unsigned int *)(v3 + 168);
    if (v5)
    {
      LODWORD(v6) = (v5 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      uint64_t v7 = (uint64_t *)(v4 + 16 * v6);
      uint64_t v8 = *v7;
      if (*v7 == a2)
      {
LABEL_9:
        uint64_t v11 = v7[1];
        if (*(void *)v11 >= 4uLL && *(_DWORD *)(v11 + 16) == 778266465) {
          return 1;
        }
        goto LABEL_11;
      }
      int v9 = 1;
      while (v8 != -4096)
      {
        int v10 = v6 + v9++;
        uint64_t v6 = v10 & (v5 - 1);
        uint64_t v8 = *(void *)(v4 + 16 * v6);
        if (v8 == a2)
        {
          uint64_t v7 = (uint64_t *)(v4 + 16 * v6);
          goto LABEL_9;
        }
      }
    }
    uint64_t v7 = (uint64_t *)(v4 + 16 * v5);
    goto LABEL_9;
  }
LABEL_11:
  sub_1CD3BBE1C(&v13, *(llvm::Module **)(a2 + 40));
  return sub_1CD3BBE9C((uint64_t)&v13, a2) || *(unsigned char *)(a2 + 16) == 3 && (*(unsigned char *)(a2 + 80) & 2) != 0;
}

void sub_1CBF4AEF4()
{
}

void *sub_1CBF4AF08(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F2600338;
  result[1] = v3;
  return result;
}

uint64_t sub_1CBF4AF50(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2600338;
  a2[1] = v2;
  return result;
}

void sub_1CBF4AF7C(uint64_t a1)
{
  v1[4] = *MEMORY[0x1E4F143B8];
  llvm::TargetMachine::getTargetIRAnalysis(**(llvm::TargetMachine ***)(a1 + 8), (uint64_t)v1);
  llvm::createTargetTransformInfoWrapperPass();
}

void sub_1CBF4B054()
{
}

void *sub_1CBF4B068(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F2600380;
  result[1] = v3;
  return result;
}

uint64_t sub_1CBF4B0B0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2600380;
  a2[1] = v2;
  return result;
}

void sub_1CBF4B0DC()
{
}

void sub_1CBF4B0EC()
{
}

void *sub_1CBF4B100()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F26003C8;
  return result;
}

void sub_1CBF4B138(uint64_t a1, void *a2)
{
  *a2 = &unk_1F26003C8;
}

void sub_1CBF4B168()
{
}

void *sub_1CBF4B17C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F2600410;
  result[1] = v3;
  return result;
}

uint64_t sub_1CBF4B1C4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2600410;
  a2[1] = v2;
  return result;
}

void sub_1CBF4B1F0()
{
}

uint64_t *sub_1CBF4B1FC(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    llvm::AGX::AGCStatusPrinter::~AGCStatusPrinter((void ***)(v2 + 104));
    *(void *)(v2 + 80) = &unk_1F26174C0;
    uint64_t v3 = *(void *)(v2 + 88);
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    *(void *)(v2 + 8) = &unk_1F25FF8C8;
    uint64_t v4 = *(const char **)(v2 + 40);
    uint64_t v5 = *(const char **)(v2 + 24);
    int64_t v6 = v4 - v5;
    if (v4 != v5)
    {
      *(void *)(v2 + 40) = v5;
      llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)(v2 + 8), v5);
    }
    *(void *)(v2 + 8) = &unk_1F2646B98;
    if (*(_DWORD *)(v2 + 64) == 1)
    {
      uint64_t v7 = *(void *)(v2 + 24);
      if (v7) {
        MEMORY[0x1D25D9CB0](v7, 0x1000C8077774924, v6);
      }
    }
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

void sub_1CBF4B32C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(xpc_object_t ***)(*(void *)a2 + 56);
  if (v2)
  {
    uint64_t v3 = *v2;
    if (v3)
    {
      uint64_t v4 = 3;
      if (!*(unsigned char *)(*(void *)a2 + 17)) {
        uint64_t v4 = 1;
      }
      if (*(unsigned char *)(a1 + 96)) {
        uint64_t v5 = 2;
      }
      else {
        uint64_t v5 = v4;
      }
      xpc_dictionary_set_uint64(*v3, "instruction_selector", v5);
    }
  }
}

void sub_1CBF4B374(uint64_t a1, void *a2, llvm::AGX::CompileRequest *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  llvm::TimeRecord::getCurrentTime((llvm::TimeRecord *)1, (uint64_t)v10);
  uint64_t v5 = *(const std::string **)a3;
  int64_t v6 = *(llvm::LLVMContext ***)(*(void *)a3 + 8);
  if (byte_1EBCC2E38 && (*(_DWORD *)(*a2 + 472) & 0xFFFFFFFE) == 0x1C) {
    v5->__r_.__value_.__s.__data_[16] = 0;
  }
  uint64_t v7 = (std::string *)a2[30];
  if (v7)
  {
    std::string::operator=(v7 + 3, v5 + 1);
    v7[4].__r_.__value_.__r.__words[0] = *(int *)(*(void *)a3 + 48);
    if (a2[30]) {
      llvm::AGX::AGCReplay::serializeRequestToIR((llvm::AGX::AGCReplay *)(a2 + 13), a3, (llvm::TargetMachine *)*a2);
    }
  }
  memset(v9, 0, 24);
  uint64_t v8 = *v6;
  *(void *)(*(void *)v8 + 72) = 0;
  llvm::AGX::DiagnosticManager::install((llvm::AGX::DiagnosticManager *)v9, v8);
}

double sub_1CBF4BD94(uint64_t a1, void *__src, size_t __len)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    p_dst = (long long *)operator new(v7 + 1);
    *((void *)&__dst + 1) = __len;
    unint64_t v12 = v8 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_8;
  }
  HIBYTE(v12) = __len;
  p_dst = &__dst;
  if (__len) {
LABEL_8:
  }
    memmove(p_dst, __src, __len);
  *((unsigned char *)p_dst + __len) = 0;
  int v9 = (void **)(a1 + 216);
  if (*(char *)(a1 + 239) < 0) {
    operator delete(*v9);
  }
  double result = *(double *)&__dst;
  *(_OWORD *)int v9 = __dst;
  *(void *)(a1 + 232) = v12;
  return result;
}

BOOL sub_1CBF4BE68(llvm::AGXIR *a1, const llvm::Module *a2, size_t a3)
{
  uint64_t ShaderID = llvm::AGXIR::getShaderID(a1, a2);
  if ((ShaderID & 0xFF00000000) == 0) {
    return 0;
  }
  int v6 = ShaderID;
  if (a3)
  {
    uint64_t v7 = 0;
    while ((*((char *)a2 + v7) & 0x80000000) == 0
         && (*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *((unsigned __int8 *)a2 + v7) + 60) & 0x400) != 0)
    {
      if (a3 == ++v7)
      {
        if (!a2) {
          goto LABEL_14;
        }
        if (a3 >= 0x7FFFFFFFFFFFFFF8) {
          abort();
        }
        if (a3 >= 0x17)
        {
          uint64_t v10 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((a3 | 7) != 0x17) {
            uint64_t v10 = a3 | 7;
          }
          uint64_t v11 = v10 + 1;
          p_dst = (char *)operator new(v10 + 1);
          size_t v15 = a3;
          unint64_t v16 = v11 | 0x8000000000000000;
          long long __dst = p_dst;
        }
        else
        {
          HIBYTE(v16) = a3;
          p_dst = (char *)&__dst;
        }
        memmove(p_dst, a2, a3);
        goto LABEL_19;
      }
    }
    return 0;
  }
  if (a2)
  {
    HIBYTE(v16) = 0;
    p_dst = (char *)&__dst;
LABEL_19:
    p_dst[a3] = 0;
    if (SHIBYTE(v16) < 0)
    {
      uint64_t v13 = __dst;
      int v12 = atoi(__dst);
      operator delete(v13);
      return v12 == v6;
    }
  }
  else
  {
LABEL_14:
    long long __dst = 0;
    size_t v15 = 0;
    unint64_t v16 = 0;
  }
  int v12 = atoi((const char *)&__dst);
  return v12 == v6;
}

BOOL sub_1CBF4BFB0(llvm::Module *a1, const void *a2, uint64_t a3)
{
  long long __dst = "agx.shaderHash";
  __int16 v23 = 259;
  uint64_t NamedMetadata = llvm::Module::getNamedMetadata(a1, (const char **)&__dst);
  if (!NamedMetadata) {
    return 0;
  }
  uint64_t v6 = *(void *)(***(void ***)(NamedMetadata + 48)
                 - 8 * *(unsigned int *)(***(void ***)(NamedMetadata + 48) + 8));
  if (*(unsigned char *)v6) {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(unint64_t **)(v6 + 8);
  unint64_t v10 = *v7;
  int v9 = v7 + 3;
  size_t v8 = v10;
  if (v10 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v8 >= 0x17)
  {
    uint64_t v13 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v13 = v8 | 7;
    }
    uint64_t v14 = v13 + 1;
    p_dst = (char *)operator new(v13 + 1);
    size_t v21 = v8;
    int64_t v22 = v14 | 0x8000000000000000;
    long long __dst = p_dst;
  }
  else
  {
    HIBYTE(v22) = v8;
    p_dst = (char *)&__dst;
    if (!v8) {
      goto LABEL_13;
    }
  }
  memmove(p_dst, v9, v8);
LABEL_13:
  BOOL v12 = 0;
  p_dst[v8] = 0;
  int v15 = SHIBYTE(v22);
  unint64_t v16 = __dst;
  if (v22 >= 0) {
    unsigned int v17 = (const char **)&__dst;
  }
  else {
    unsigned int v17 = (const char **)__dst;
  }
  if (v22 >= 0) {
    size_t v18 = HIBYTE(v22) & 0x7F;
  }
  else {
    size_t v18 = v21;
  }
  if (a3 == v18)
  {
    if (!v18)
    {
      BOOL v12 = 1;
      if ((SHIBYTE(v22) & 0x80000000) == 0) {
        return v12;
      }
      goto LABEL_23;
    }
    BOOL v12 = memcmp(a2, v17, v18) == 0;
  }
  if (v15 < 0) {
LABEL_23:
  }
    operator delete(v16);
  return v12;
}

BOOL sub_1CBF4C108(const std::string *a1, const void *a2, uint64_t a3)
{
  sub_1CD114070(a1, __p);
  sub_1CD113EF4((uint64_t)__p, v13);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  int v5 = v14;
  uint64_t v6 = (void *)v13[0];
  if (v14 >= 0) {
    uint64_t v7 = v13;
  }
  else {
    uint64_t v7 = (void *)v13[0];
  }
  if (v14 >= 0) {
    size_t v8 = v14 & 0x7F;
  }
  else {
    size_t v8 = v13[1];
  }
  if (a3 == v8)
  {
    if (!v8)
    {
      BOOL v9 = 1;
      if ((v14 & 0x80000000) == 0) {
        return v9;
      }
      goto LABEL_14;
    }
    BOOL v9 = memcmp(a2, v7, v8) == 0;
    if (v5 < 0) {
LABEL_14:
    }
      operator delete(v6);
  }
  else
  {
    BOOL v9 = 0;
    if (v14 < 0) {
      goto LABEL_14;
    }
  }
  return v9;
}

uint64_t sub_1CBF4C1CC(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA498] + 24;
  uint64_t v3 = MEMORY[0x1E4FBA498] + 64;
  *(void *)(a1 + 112) = MEMORY[0x1E4FBA498] + 64;
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA418] + 16);
  uint64_t v5 = *(void *)(MEMORY[0x1E4FBA418] + 8);
  *(void *)a1 = v5;
  *(void *)(a1 + *(void *)(v5 - 24)) = v4;
  uint64_t v6 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v6, (void *)(a1 + 8));
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *(void *)a1 = v2;
  *(void *)(a1 + 112) = v3;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 8) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void *sub_1CBF4C340(void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v3;
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return a1;
}

void sub_1CBF4C3C4(uint64_t a1, std::string *__str, std::string *a3, unint64_t a4)
{
  uint64_t v6 = __str;
  size_t v8 = *(std::string **)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) >= a4)
  {
    uint64_t v13 = *(std::string **)(a1 + 8);
    if (0xAAAAAAAAAAAAAAABLL * (((char *)v13 - (char *)v8) >> 3) >= a4)
    {
      if (__str == a3)
      {
        BOOL v19 = *(std::string **)a1;
      }
      else
      {
        BOOL v19 = *(std::string **)a1;
        do
        {
          std::string::operator=(v8++, v6++);
          ++v19;
        }
        while (v6 != a3);
        uint64_t v13 = *(std::string **)(a1 + 8);
      }
      while (v13 != v19)
      {
        if (SHIBYTE(v13[-1].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v13[-1].__r_.__value_.__l.__data_);
        }
        --v13;
      }
      *(void *)(a1 + 8) = v19;
    }
    else
    {
      char v14 = (std::string *)((char *)__str + 8 * (((char *)v13 - (char *)v8) >> 3));
      if (v13 != v8)
      {
        uint64_t v15 = 8 * (((char *)v13 - (char *)v8) >> 3);
        do
        {
          std::string::operator=(v8++, v6++);
          v15 -= 24;
        }
        while (v15);
        size_t v8 = *(std::string **)(a1 + 8);
      }
      unint64_t v16 = v8;
      if (v14 != a3)
      {
        unint64_t v16 = v8;
        uint64_t v17 = (uint64_t)v8;
        do
        {
          if (SHIBYTE(v14->__r_.__value_.__r.__words[2]) < 0)
          {
            sub_1CB8BDF7C(v17, v14->__r_.__value_.__l.__data_, v14->__r_.__value_.__l.__size_);
          }
          else
          {
            long long v18 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
            *(void *)(v17 + 16) = *((void *)&v14->__r_.__value_.__l + 2);
            *(_OWORD *)uint64_t v17 = v18;
          }
          ++v14;
          v17 += 24;
          ++v16;
        }
        while (v14 != a3);
      }
      *(void *)(a1 + 8) = v16;
    }
  }
  else
  {
    sub_1CBF4C5EC((void **)a1);
    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_38;
    }
    unint64_t v9 = 0x5555555555555556 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3);
    if (v9 <= a4) {
      unint64_t v9 = a4;
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) >= 0x555555555555555
        ? 0xAAAAAAAAAAAAAAALL
        : v9;
    if (v10 > 0xAAAAAAAAAAAAAAALL) {
LABEL_38:
    }
      abort();
    uint64_t v11 = 3 * v10;
    char v12 = operator new(24 * v10);
    *(void *)a1 = v12;
    *(void *)(a1 + 8) = v12;
    *(void *)(a1 + 16) = &v12[v11];
    while (v6 != a3)
    {
      if (SHIBYTE(v6->__r_.__value_.__r.__words[2]) < 0)
      {
        sub_1CB8BDF7C((uint64_t)v12, v6->__r_.__value_.__l.__data_, v6->__r_.__value_.__l.__size_);
      }
      else
      {
        *(_OWORD *)char v12 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
        v12[2] = *((void *)&v6->__r_.__value_.__l + 2);
      }
      ++v6;
      v12 += 3;
    }
    *(void *)(a1 + 8) = v12;
  }
}

void sub_1CBF4C5EC(void **a1)
{
  uint64_t v1 = (void **)*a1;
  if (*a1)
  {
    uint64_t v5 = (void **)*a1;
    uint64_t v2 = (void **)a1[1];
    uint64_t v3 = *a1;
    if (v2 != v1)
    {
      do
      {
        if (*((char *)v2 - 1) < 0) {
          operator delete(*(v2 - 3));
        }
        v2 -= 3;
      }
      while (v2 != v5);
      uint64_t v3 = *a1;
    }
    a1[1] = v5;
    operator delete(v3);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_1CBF4C670(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (*(char *)(a2 + 135) < 0) {
      operator delete(*(void **)(a2 + 112));
    }
    if (*(char *)(a2 + 111) < 0) {
      operator delete(*(void **)(a2 + 88));
    }
    if (*(char *)(a2 + 79) < 0) {
      operator delete(*(void **)(a2 + 56));
    }
    if (*(char *)(a2 + 39) < 0) {
      operator delete(*(void **)(a2 + 16));
    }
    sub_1CBF4B1FC((uint64_t *)(a2 + 8), 0);
    sub_1CBF4B1FC((uint64_t *)a2, 0);
    JUMPOUT(0x1D25D9CE0);
  }
}

uint64_t sub_1CBF4C724()
{
  int v3 = 1;
  v4.n128_u64[0] = (unint64_t)"Enable optimization passes in driver pipeline";
  v4.n128_u64[1] = 45;
  char v1 = 0;
  uint64_t v2 = &v1;
  sub_1CD413E90((llvm::cl::Option *)&qword_1EBCC2CF0[1], "enable-driver-opt-passes", &v3, &v4, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCC2CF0[1], &dword_1CB82C000);
  int v3 = 1;
  v4.n128_u64[0] = (unint64_t)"Turn of FastMath module flag for this compilation";
  v4.n128_u64[1] = 49;
  char v1 = 0;
  uint64_t v2 = &v1;
  sub_1CD413E90((llvm::cl::Option *)&unk_1EBCC2DB8, "disable-fast-math-module-flag", &v3, &v4, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC2DB8, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Synthesize debug info before compilation";
  v4.n128_u64[1] = 40;
  sub_1CD3F4B2C((llvm::cl::Option *)&unk_1EBCC2E78, "agx-debugify", &v4);
  uint64_t result = __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC2E78, &dword_1CB82C000);
  dword_1EBCC2CD8 = 65537;
  word_1EBCC2CDC = 1;
  return result;
}

void llvm::AGX::AGXCompilePlan::collectConfiguration(uint64_t ***a1, uint64_t a2)
{
  uint64_t v2 = **a1;
  uint64_t v3 = v2[1];
  if (v3 || (uint64_t v3 = *v2) != 0) {
    sub_1CBF4B32C(v3, a2);
  }
}

void llvm::AGX::AGXCompilePlan::execute(llvm::AGX::AGXCompilePlan *this@<X0>, llvm::AGX::CompileRequest *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = a2;
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(std::string **)(*(void *)a2 + 8);
  if (**(void **)a2)
  {
    std::string __p = "agx.shaderHash";
    __int16 v42 = 259;
    if (!llvm::Module::getNamedMetadata((llvm::Module *)v6, (const char **)&__p))
    {
      uint64_t inserted = llvm::Module::getOrInsertNamedMetadata(v6, "agx.shaderHash", 0xEuLL);
      size_t v8 = (uint64_t *)v6->__r_.__value_.__r.__words[0];
      sub_1CD114070(v6, v34);
      sub_1CD113EF4((uint64_t)v34, &__p);
      if (v40 >= 0) {
        p_p = (unsigned __int8 *)&__p;
      }
      else {
        p_p = (unsigned __int8 *)__p;
      }
      if (v40 >= 0) {
        size_t v10 = v40 & 0x7F;
      }
      else {
        size_t v10 = v39;
      }
      std::string::size_type v37 = llvm::MDString::get(v8, p_p, v10);
      Impl = (unsigned __int8 *)llvm::MDTuple::getImpl((uint64_t)v8, &v37, 1, 0, 1);
      v36[0] = Impl;
      uint64_t v12 = *(void *)(inserted + 48);
      uint64_t v13 = *(unsigned int *)(v12 + 8);
      if (v13 >= *(_DWORD *)(v12 + 12))
      {
        sub_1CC608328(v12, v36);
      }
      else
      {
        a2 = (llvm::AGX::CompileRequest *)Impl;
        char v14 = (void *)(*(void *)v12 + 8 * v13);
        *char v14 = a2;
        if (a2)
        {
          llvm::MetadataTracking::track((uint64_t)v14, (unsigned __int8 *)a2, 2);
          LODWORD(v13) = *(_DWORD *)(v12 + 8);
        }
        *(_DWORD *)(v12 + 8) = v13 + 1;
      }
      if (v40 < 0) {
        operator delete(__p);
      }
      if (v35 < 0) {
        operator delete(v34[0]);
      }
    }
  }
  if ((llvm::AGXIR::getShaderID((llvm::AGXIR *)v6, a2) & 0xFF00000000) == 0)
  {
    uint64_t v15 = (llvm::NamedMDNode *)llvm::Module::getOrInsertNamedMetadata(v6, "agxcompiler.config", 0x12uLL);
    uint64_t v16 = v6->__r_.__value_.__r.__words[0];
    std::string __p = llvm::MDString::get((uint64_t *)v6->__r_.__value_.__l.__data_, "Request.ShaderID", 0x10uLL);
    Int32Ty = (llvm::ConstantInt *)llvm::Type::getInt32Ty((llvm::Type *)v6->__r_.__value_.__l.__data_, v17);
    BOOL v19 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(Int32Ty, *(int *)(*(void *)v3 + 48), 0);
    uint64_t v39 = llvm::ValueAsMetadata::get(v19, v20);
    size_t v21 = llvm::MDTuple::getImpl(v16, &__p, 2, 0, 1);
    llvm::NamedMDNode::addOperand(v15, v21);
  }
  sub_1CD112980((llvm::Module *)v6, (uint64_t)&__p);
  if (!v41)
  {
    int64_t v22 = (llvm::NamedMDNode *)llvm::Module::getOrInsertNamedMetadata(v6, "agxcompiler.config", 0x12uLL);
    uint64_t v23 = v6->__r_.__value_.__r.__words[0];
    v36[0] = (unsigned __int8 *)llvm::MDString::get((uint64_t *)v6->__r_.__value_.__l.__data_, "Request.ShaderType", 0x12uLL);
    __int16 v24 = (uint64_t *)v6->__r_.__value_.__r.__words[0];
    uint64_t ShaderType = llvm::AGX::CompileRequest::getShaderType(v3);
    char v26 = *(unsigned char *)(ShaderType + 23);
    BOOL v27 = v26 < 0;
    if (v26 >= 0) {
      uint64_t v28 = (unsigned __int8 *)ShaderType;
    }
    else {
      uint64_t v28 = *(unsigned __int8 **)ShaderType;
    }
    size_t v29 = v26 & 0x7F;
    if (v27) {
      size_t v30 = *(void *)(ShaderType + 8);
    }
    else {
      size_t v30 = v29;
    }
    v36[1] = (unsigned __int8 *)llvm::MDString::get(v24, v28, v30);
    uint64_t v31 = llvm::MDTuple::getImpl(v23, v36, 2, 0, 1);
    llvm::NamedMDNode::addOperand(v22, v31);
  }
  if (!*((void *)this + 1)) {
LABEL_7:
  }
    sub_1CBF4549C(**(const llvm::Module ****)this, v3, a3);
  llvm::AGX::CompileReply::CompileReply(v36);
  if (!llvm::AGX::AGXAssemblePlan::execute(*((llvm::AGX::AGXAssemblePlan **)this + 1), v3, (llvm::AGX::CompileReply *)v36))
  {
    std::chrono::system_clock::time_point v33 = v36[0];
    v36[0] = 0;
    if (v33) {
      sub_1CBF4E82C((uint64_t)v36, (uint64_t)v33);
    }
    goto LABEL_7;
  }
  *(unsigned char *)a3 = 0;
  llvm::AGX::CompileReply::CompileReply((void *)(a3 + 8), (uint64_t *)v36);
  uint64_t v32 = v36[0];
  v36[0] = 0;
  if (v32) {
    sub_1CBF4E82C((uint64_t)v36, (uint64_t)v32);
  }
  if (v41)
  {
    if (v40 < 0) {
      operator delete(__p);
    }
  }
}

uint64_t llvm::AGX::AGXAssemblePlan::execute(llvm::AGX::AGXAssemblePlan *this, llvm::AGX::CompileRequest *a2, llvm::AGX::CompileReply *a3)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (void *)((char *)this + 8);
  std::to_string(&v41, *(_DWORD *)(*(void *)a2 + 48));
  uint64_t v6 = sub_1CD455F74(v5, (uint64_t)&v41);
  uint64_t v7 = v6;
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v41.__r_.__value_.__l.__data_);
    if (v7) {
      goto LABEL_5;
    }
  }
  else if (v6)
  {
    goto LABEL_5;
  }
  size_t v8 = *(llvm::Module **)(*(void *)a2 + 8);
  v41.__r_.__value_.__r.__words[0] = (std::string::size_type)"agx.shaderHash";
  LOWORD(v43) = 259;
  uint64_t result = llvm::Module::getNamedMetadata(v8, (const char **)&v41.__r_.__value_.__l.__data_);
  if (result)
  {
    uint64_t v10 = *(void *)(***(void ***)(result + 48) - 8 * *(unsigned int *)(***(void ***)(result + 48) + 8));
    if (*(unsigned char *)v10) {
      uint64_t v10 = 0;
    }
    uint64_t v11 = *(unint64_t **)(v10 + 8);
    unint64_t v14 = *v11;
    uint64_t v13 = v11 + 3;
    std::string::size_type v12 = v14;
    if (v14 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_48;
    }
    if (v12 >= 0x17)
    {
      uint64_t v28 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v12 | 7) != 0x17) {
        uint64_t v28 = v12 | 7;
      }
      uint64_t v29 = v28 + 1;
      uint64_t v15 = operator new(v28 + 1);
      v41.__r_.__value_.__l.__size_ = v12;
      v41.__r_.__value_.__r.__words[2] = v29 | 0x8000000000000000;
      v41.__r_.__value_.__r.__words[0] = (std::string::size_type)v15;
    }
    else
    {
      *((unsigned char *)&v41.__r_.__value_.__s + 23) = v12;
      uint64_t v15 = &v41;
      if (!v12)
      {
LABEL_44:
        v15[v12] = 0;
        uint64_t v7 = sub_1CD455F74(v5, (uint64_t)&v41);
        if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v41.__r_.__value_.__l.__data_);
        }
        if (!v7) {
          return 0;
        }
LABEL_5:
        if ((char)v7[63] < 0)
        {
          sub_1CB8BDF7C((uint64_t)&v49, *((const void **)v7 + 5), *((void *)v7 + 6));
        }
        else
        {
          long long v49 = *(_OWORD *)(v7 + 40);
          uint64_t v50 = *((void *)v7 + 7);
        }
        memset(v48, 0, sizeof(v48));
        LODWORD(v41.__r_.__value_.__r.__words[1]) = 0;
        char v44 = 0;
        uint64_t v45 = 0;
        __int16 v47 = v48;
        int v46 = 0;
        v41.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2646F30;
        v41.__r_.__value_.__r.__words[2] = 0;
        uint64_t v42 = 0;
        uint64_t v43 = 0;
        LOWORD(v52) = 260;
        *(void *)__int16 v51 = &v49;
        sub_1CD096690(v51, (llvm::WritableMemoryBuffer *)0xFFFFFFFFFFFFFFFFLL, 0, 0, 1, 0, (uint64_t)&v53);
        if (v54)
        {
          std::operator+<char>();
          LOWORD(v52) = 260;
          *(void *)__int16 v51 = &v39;
          llvm::report_fatal_error((llvm *)v51, (const llvm::Twine *)1);
        }
        memset(v38, 0, 24);
        long long v39 = 0u;
        uint64_t v40 = 0;
        if (*((_DWORD *)this + 12) == 2)
        {
          uint64_t v17 = *(unsigned char **)(v53 + 8);
          uint64_t v16 = *(unsigned char **)(v53 + 16);
          size_t v18 = v16 - v17;
          if ((unint64_t)(v16 - v17) <= 0x7FFFFFFFFFFFFFF7)
          {
            if (v18 >= 0x17)
            {
              uint64_t v24 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v18 | 7) != 0x17) {
                uint64_t v24 = v18 | 7;
              }
              uint64_t v25 = v24 + 1;
              BOOL v19 = operator new(v24 + 1);
              __dst[1] = v18;
              unint64_t v37 = v25 | 0x8000000000000000;
              __dst[0] = v19;
            }
            else
            {
              HIBYTE(v37) = (_BYTE)v16 - (_BYTE)v17;
              BOOL v19 = __dst;
              if (v16 == v17)
              {
LABEL_29:
                *((unsigned char *)v19 + v18) = 0;
                long long v34 = v38[0];
                uint64_t v35 = *(void *)&v38[1];
                memset(v38, 0, 24);
                llvm::AGX::CompileReply::CompileReply();
              }
            }
            memmove(v19, v17, v18);
            goto LABEL_29;
          }
LABEL_48:
          abort();
        }
        size_t v21 = *(unsigned char **)(v53 + 8);
        uint64_t v20 = *(unsigned char **)(v53 + 16);
        size_t v22 = v20 - v21;
        if ((unint64_t)(v20 - v21) > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_48;
        }
        if (v22 >= 0x17)
        {
          uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v22 | 7) != 0x17) {
            uint64_t v26 = v22 | 7;
          }
          uint64_t v27 = v26 + 1;
          uint64_t v23 = operator new(v26 + 1);
          v32[1] = (void *)v22;
          unint64_t v33 = v27 | 0x8000000000000000;
          v32[0] = v23;
        }
        else
        {
          HIBYTE(v33) = (_BYTE)v20 - (_BYTE)v21;
          uint64_t v23 = v32;
          if (v20 == v21)
          {
LABEL_34:
            *((unsigned char *)v23 + v22) = 0;
            if (llvm::AGX::AssemblePipeline::AssemblerImpl::run(**(llvm::AGX::DiagnosticManager ****)this, (uint64_t *)v32, (uint64_t)&v41))
            {
              if (SHIBYTE(v33) < 0)
              {
                sub_1CB8BDF7C((uint64_t)__p, v32[0], (unint64_t)v32[1]);
              }
              else
              {
                *(_OWORD *)std::string __p = *(_OWORD *)v32;
                unint64_t v31 = v33;
              }
              operator new();
            }
            llvm::report_fatal_error((llvm *)"Asm injection failed", (const llvm::Twine *)1);
          }
        }
        memmove(v23, v21, v22);
        goto LABEL_34;
      }
    }
    memmove(v15, v13, v12);
    goto LABEL_44;
  }
  return result;
}

void *llvm::AGX::AGXCompilePlan::AGXCompilePlan(void *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  *uint64_t result = v2;
  uint64_t v3 = a2[1];
  a2[1] = 0;
  result[1] = v3;
  return result;
}

{
  uint64_t v2;
  uint64_t v3;

  uint64_t v2 = *a2;
  *a2 = 0;
  *uint64_t result = v2;
  uint64_t v3 = a2[1];
  a2[1] = 0;
  result[1] = v3;
  return result;
}

uint64_t llvm::AGX::AGXCompilePlan::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v5 = *(uint64_t **)a1;
  *(void *)a1 = v4;
  if (v5)
  {
    uint64_t v6 = *v5;
    *uint64_t v5 = 0;
    if (v6) {
      sub_1CBF4C670((uint64_t)v5, v6);
    }
    MEMORY[0x1D25D9CE0](v5, 0x20C4093837F09);
  }
  uint64_t v7 = a2[1];
  a2[1] = 0;
  size_t v8 = *(uint64_t ***)(a1 + 8);
  *(void *)(a1 + 8) = v7;
  if (v8)
  {
    llvm::AGX::AGXAssemblePlan::~AGXAssemblePlan(v8);
    MEMORY[0x1D25D9CE0]();
  }
  return a1;
}

uint64_t llvm::AGX::AGXAssemblePlan::execute(llvm::AGX::DiagnosticManager ****a1, uint64_t *a2, uint64_t a3)
{
  return llvm::AGX::AssemblePipeline::AssemblerImpl::run(**a1, a2, a3);
}

BOOL llvm::AGX::AGXAssemblePlan::isValid(llvm::AGX::AGXAssemblePlan *this)
{
  return *(void *)this != 0;
}

void llvm::AGX::AGXAssemblePlan::AGXAssemblePlan(llvm::AGX::AGXAssemblePlan *this, llvm::TargetMachine *a2, llvm::AGX::DiagnosticManager *a3)
{
}

{
  operator new();
}

uint64_t llvm::AGX::AGXAssemblePlan::AGXAssemblePlan(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  *(void *)a1 = v4;
  sub_1CBF4DE40(a1 + 8, a2 + 1);
  *(_DWORD *)(a1 + ++*(_DWORD *)(result + 48) = *((_DWORD *)a2 + 12);
  return a1;
}

{
  uint64_t v4;

  uint64_t v4 = *a2;
  *a2 = 0;
  *(void *)a1 = v4;
  sub_1CBF4DE40(a1 + 8, a2 + 1);
  *(_DWORD *)(a1 + ++*(_DWORD *)(result + 48) = *((_DWORD *)a2 + 12);
  return a1;
}

uint64_t llvm::AGX::AGXAssemblePlan::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v5 = *(uint64_t **)a1;
  *(void *)a1 = v4;
  if (v5)
  {
    uint64_t v6 = *v5;
    *uint64_t v5 = 0;
    if (v6) {
      MEMORY[0x1D25D9CE0](v6, 0x20C40A4A59CD2);
    }
    MEMORY[0x1D25D9CE0](v5, 0x20C4093837F09);
  }
  if (*(void *)(a1 + 32))
  {
    uint64_t v7 = *(void **)(a1 + 24);
    if (v7)
    {
      do
      {
        size_t v8 = (void *)*v7;
        sub_1CD3C4FA4((uint64_t)(v7 + 2));
        operator delete(v7);
        uint64_t v7 = v8;
      }
      while (v8);
    }
    *(void *)(a1 + 24) = 0;
    uint64_t v9 = *(void *)(a1 + 16);
    if (v9)
    {
      for (uint64_t i = 0; i != v9; ++i)
        *(void *)(*(void *)(a1 + 8) + 8 * i) = 0;
    }
    *(void *)(a1 + 32) = 0;
  }
  uint64_t v11 = a2[1];
  a2[1] = 0;
  std::string::size_type v12 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = v11;
  if (v12) {
    operator delete(v12);
  }
  uint64_t v13 = a2[3];
  uint64_t v14 = a2[2];
  *(void *)(a1 + 24) = v13;
  *(void *)(a1 + 16) = v14;
  a2[2] = 0;
  uint64_t v15 = a2[4];
  *(void *)(a1 + 32) = v15;
  *(_DWORD *)(a1 + 40) = *((_DWORD *)a2 + 10);
  if (v15)
  {
    unint64_t v16 = *(void *)(v13 + 8);
    unint64_t v17 = *(void *)(a1 + 16);
    if ((v17 & (v17 - 1)) != 0)
    {
      if (v16 >= v17) {
        v16 %= v17;
      }
    }
    else
    {
      v16 &= v17 - 1;
    }
    *(void *)(*(void *)(a1 + 8) + 8 * v16) = a1 + 24;
    a2[3] = 0;
    a2[4] = 0;
  }
  *(_DWORD *)(a1 + ++*(_DWORD *)(result + 48) = *((_DWORD *)a2 + 12);
  return a1;
}

unint64_t sub_1CBF4D6C0(uint64_t a1, uint64_t *a2, unint64_t a3)
{
  if (a3 > 0x20)
  {
    if (a3 > 0x40)
    {
      uint64_t v9 = *(uint64_t *)((char *)a2 + a3 - 48);
      uint64_t v10 = *(uint64_t *)((char *)a2 + a3 - 40);
      uint64_t v11 = *(uint64_t *)((char *)a2 + a3 - 24);
      uint64_t v13 = *(uint64_t *)((char *)a2 + a3 - 64);
      uint64_t v12 = *(uint64_t *)((char *)a2 + a3 - 56);
      uint64_t v14 = *(uint64_t *)((char *)a2 + a3 - 16);
      uint64_t v15 = *(uint64_t *)((char *)a2 + a3 - 8);
      unint64_t v16 = v12 + v14;
      unint64_t v17 = 0x9DDFEA08EB382D69
          * (v11 ^ ((0x9DDFEA08EB382D69 * ((v9 + a3) ^ v11)) >> 47) ^ (0x9DDFEA08EB382D69 * ((v9 + a3) ^ v11)));
      unint64_t v18 = 0x9DDFEA08EB382D69 * (v17 ^ (v17 >> 47));
      unint64_t v19 = v9 + v12 + v13 + a3;
      uint64_t v20 = v19 + v10;
      unint64_t v21 = __ROR8__(v19, 44) + v13 + a3 + __ROR8__(v13 + a3 + v10 - 0x622015F714C7D297 * (v17 ^ (v17 >> 47)), 21);
      uint64_t v22 = v12 + v14 + *(uint64_t *)((char *)a2 + a3 - 32) - 0x4B6D499041670D8DLL;
      uint64_t v23 = v11 + v14 + v22;
      uint64_t v24 = __ROR8__(v23, 44);
      uint64_t v25 = v23 + v15;
      uint64_t v26 = v24 + v22 + __ROR8__(v22 + v10 + v15, 21);
      uint64_t v28 = *a2;
      uint64_t v27 = a2 + 4;
      unint64_t v29 = v28 - 0x4B6D499041670D8DLL * v10;
      uint64_t v30 = -(uint64_t)((a3 - 1) & 0xFFFFFFFFFFFFFFC0);
      do
      {
        uint64_t v31 = *(v27 - 3);
        uint64_t v32 = v29 + v20 + v16 + v31;
        uint64_t v33 = v27[2];
        uint64_t v34 = v27[3];
        uint64_t v35 = v27[1];
        unint64_t v16 = v35 + v20 - 0x4B6D499041670D8DLL * __ROR8__(v16 + v21 + v33, 42);
        uint64_t v36 = v18 + v25;
        uint64_t v37 = *(v27 - 2);
        uint64_t v38 = *(v27 - 1);
        uint64_t v39 = *(v27 - 4) - 0x4B6D499041670D8DLL * v21;
        uint64_t v40 = v39 + v25 + v38;
        uint64_t v41 = v39 + v31 + v37;
        uint64_t v20 = v41 + v38;
        uint64_t v42 = __ROR8__(v41, 44) + v39;
        unint64_t v43 = (0xB492B66FBE98F273 * __ROR8__(v32, 37)) ^ v26;
        unint64_t v29 = 0xB492B66FBE98F273 * __ROR8__(v36, 33);
        unint64_t v21 = v42 + __ROR8__(v40 + v43, 21);
        unint64_t v44 = v29 + v26 + *v27;
        uint64_t v25 = v35 + v33 + v44 + v34;
        uint64_t v26 = __ROR8__(v35 + v33 + v44, 44) + v44 + __ROR8__(v16 + v37 + v44 + v34, 21);
        v27 += 8;
        unint64_t v18 = v43;
        v30 += 64;
      }
      while (v30);
      unint64_t v45 = v29
          - 0x622015F714C7D297
          * ((0x9DDFEA08EB382D69
            * (v26 ^ ((0x9DDFEA08EB382D69 * (v26 ^ v21)) >> 47) ^ (0x9DDFEA08EB382D69 * (v26 ^ v21)))) ^ ((0x9DDFEA08EB382D69 * (v26 ^ ((0x9DDFEA08EB382D69 * (v26 ^ v21)) >> 47) ^ (0x9DDFEA08EB382D69 * (v26 ^ v21)))) >> 47));
      unint64_t v46 = 0x9DDFEA08EB382D69
          * (v45 ^ (v43
                  - 0x4B6D499041670D8DLL * (v16 ^ (v16 >> 47))
                  - 0x622015F714C7D297
                  * ((0x9DDFEA08EB382D69
                    * (v25 ^ ((0x9DDFEA08EB382D69 * (v25 ^ v20)) >> 47) ^ (0x9DDFEA08EB382D69 * (v25 ^ v20)))) ^ ((0x9DDFEA08EB382D69 * (v25 ^ ((0x9DDFEA08EB382D69 * (v25 ^ v20)) >> 47) ^ (0x9DDFEA08EB382D69 * (v25 ^ v20)))) >> 47))));
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v45 ^ (v46 >> 47) ^ v46)) ^ ((0x9DDFEA08EB382D69 * (v45 ^ (v46 >> 47) ^ v46)) >> 47));
    }
    else
    {
      return sub_1CBF4DA68(a2, a3);
    }
  }
  else if (a3 > 0x10)
  {
    uint64_t v4 = a2[1];
    unint64_t v5 = 0xB492B66FBE98F273 * *a2;
    uint64_t v6 = __ROR8__(0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a2 + a3 - 8), 30) + __ROR8__(v5 - v4, 43);
    unint64_t v7 = v5 + a3 + __ROR8__(v4 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a2 + a3 - 8);
    unint64_t v8 = 0x9DDFEA08EB382D69 * ((v6 - 0x3C5A37A36834CED9 * *(uint64_t *)((char *)a2 + a3 - 16)) ^ v7);
    return 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) ^ ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) >> 47));
  }
  else
  {
    return sub_1CBF4D970(a2, a3);
  }
}

unint64_t sub_1CBF4D970(_DWORD *a1, unint64_t a2)
{
  if (a2 < 9)
  {
    if (a2 < 4)
    {
      unint64_t result = 0x9AE16A3B2F90404FLL;
      if (a2)
      {
        unint64_t v8 = (0xC949D7C7509E6557 * (a2 + 4 * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                      * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
        return 0x9AE16A3B2F90404FLL * (v8 ^ (v8 >> 47));
      }
    }
    else
    {
      uint64_t v6 = *(unsigned int *)((char *)a1 + a2 - 4);
      unint64_t v7 = 0x9DDFEA08EB382D69 * (((8 * *a1) + a2) ^ v6);
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
    }
  }
  else
  {
    uint64_t v3 = *(void *)((char *)a1 + a2 - 8);
    uint64_t v4 = __ROR8__(v3 + a2, a2);
    return (0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69
            * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *(void *)a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *(void *)a1)))) ^ ((0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *(void *)a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *(void *)a1)))) >> 47))) ^ v3;
  }
  return result;
}

unint64_t sub_1CBF4DA68(void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)((char *)a1 + a2 - 16);
  uint64_t v3 = *a1 - 0x3C5A37A36834CED9 * (v2 + a2);
  uint64_t v5 = a1[2];
  uint64_t v4 = a1[3];
  uint64_t v6 = __ROR8__(v3 + v4, 52);
  uint64_t v7 = v3 + a1[1];
  uint64_t v8 = __ROR8__(v7, 7);
  uint64_t v9 = v7 + v5;
  uint64_t v10 = *(void *)((char *)a1 + a2 - 32) + v5;
  uint64_t v11 = v8 + __ROR8__(*a1 - 0x3C5A37A36834CED9 * (v2 + a2), 37) + v6 + __ROR8__(v9, 31);
  uint64_t v12 = *(void *)((char *)a1 + a2 - 24) + v10 + v2;
  unint64_t v13 = 0xC3A5C85C97CB3127 * (v12 + *(void *)((char *)a1 + a2 - 8) + v4 + v11)
      - 0x651E95C4D06FBFB1
      * (v9
       + v4
       + __ROR8__(v10, 37)
       + __ROR8__(*(void *)((char *)a1 + a2 - 24) + v10, 7)
       + __ROR8__(*(void *)((char *)a1 + a2 - 8) + v4 + v10, 52)
       + __ROR8__(v12, 31));
  return 0x9AE16A3B2F90404FLL
       * ((v11 - 0x3C5A37A36834CED9 * (v13 ^ (v13 >> 47))) ^ ((v11 - 0x3C5A37A36834CED9 * (v13 ^ (v13 >> 47))) >> 47));
}

uint64_t *sub_1CBF4DB28(uint64_t a1, unint64_t a2, unsigned __int8 **a3)
{
  unint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    uint8x8_t v6 = (uint8x8_t)vcnt_s8((int8x8_t)v4);
    v6.i16[0] = vaddlv_u8(v6);
    unint64_t v7 = v6.u32[0];
    if (v6.u32[0] > 1uLL) {
      uint64_t v8 = v4 <= a2 ? a2 % v4 : a2;
    }
    else {
      uint64_t v8 = (v4 - 1) & a2;
    }
    uint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v8);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        char v11 = *((unsigned char *)a3 + 23);
        int v12 = v11;
        unint64_t v13 = (unsigned __int8 *)(v11 & 0x7F);
        if (v12 >= 0) {
          uint64_t v14 = v13;
        }
        else {
          uint64_t v14 = a3[1];
        }
        if (v12 >= 0) {
          uint64_t v15 = (unsigned __int8 *)a3;
        }
        else {
          uint64_t v15 = *a3;
        }
        do
        {
          unint64_t v16 = v10[1];
          if (v16 == a2)
          {
            char v17 = *((unsigned char *)v10 + 39);
            uint64_t v18 = v17 & 0x7F;
            if (v17 >= 0) {
              unint64_t v19 = (unsigned __int8 *)(v17 & 0x7F);
            }
            else {
              unint64_t v19 = (unsigned __int8 *)v10[3];
            }
            if (v19 == v14)
            {
              if ((*((unsigned char *)v10 + 39) & 0x80) != 0)
              {
                if (!memcmp((const void *)v10[2], v15, v10[3])) {
                  return v10;
                }
              }
              else
              {
                if ((v17 & 0x7F) == 0) {
                  return v10;
                }
                uint64_t v20 = 0;
                while (*((unsigned __int8 *)v10 + v20 + 16) == v15[v20])
                {
                  if (v18 == ++v20) {
                    return v10;
                  }
                }
              }
            }
          }
          else
          {
            if (v7 > 1)
            {
              if (v16 >= v4) {
                v16 %= v4;
              }
            }
            else
            {
              v16 &= v4 - 1;
            }
            if (v16 != v8) {
              break;
            }
          }
          uint64_t v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
    }
  }
  float v21 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v22 = *(float *)(a1 + 32);
  if (!v4 || (float)(v22 * (float)v4) < v21)
  {
    BOOL v23 = 1;
    if (v4 >= 3) {
      BOOL v23 = (v4 & (v4 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v4);
    unint64_t v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25) {
      size_t prime = v25;
    }
    else {
      size_t prime = v24;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v4 = *(void *)(a1 + 8);
    }
    if (prime > v4) {
      goto LABEL_59;
    }
    if (prime < v4)
    {
      unint64_t v27 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v4 < 3 || (uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v4), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
      {
        unint64_t v27 = std::__next_prime(v27);
      }
      else
      {
        uint64_t v29 = 1 << -(char)__clz(v27 - 1);
        if (v27 >= 2) {
          unint64_t v27 = v29;
        }
      }
      if (prime <= v27) {
        size_t prime = v27;
      }
      if (prime < v4) {
LABEL_59:
      }
        sub_1CD3F1760(a1, prime);
    }
  }
  return 0;
}

void *sub_1CBF4DD88(void *result, void *a2)
{
  int8x8_t v2 = (int8x8_t)result[1];
  unint64_t v3 = a2[1];
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    if (v3 >= *(void *)&v2) {
      v3 %= *(void *)&v2;
    }
  }
  else
  {
    v3 &= *(void *)&v2 - 1;
  }
  uint64_t v5 = *(void **)(*result + 8 * v3);
  if (v5)
  {
    *a2 = *v5;
LABEL_13:
    *uint64_t v5 = a2;
    goto LABEL_14;
  }
  *a2 = result[2];
  result[2] = a2;
  *(void *)(*result + 8 * v3) = result + 2;
  if (*a2)
  {
    unint64_t v6 = *(void *)(*a2 + 8);
    if (v4.u32[0] > 1uLL)
    {
      if (v6 >= *(void *)&v2) {
        v6 %= *(void *)&v2;
      }
    }
    else
    {
      v6 &= *(void *)&v2 - 1;
    }
    uint64_t v5 = (void *)(*result + 8 * v6);
    goto LABEL_13;
  }
LABEL_14:
  ++result[3];
  return result;
}

uint64_t sub_1CBF4DE40(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  *(void *)unint64_t result = v2;
  *(void *)(result + 8) = a2[1];
  a2[1] = 0;
  uint64_t v5 = a2[2];
  unint64_t v3 = a2 + 2;
  uint64_t v4 = v5;
  *(void *)(result + 16) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 24) = v6;
  *(_DWORD *)(result + 32) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 16;
    *unint64_t v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t sub_1CBF4DEB0()
{
  *(void *)&long long v2 = "AsmInjection info file";
  *((void *)&v2 + 1) = 22;
  char v1 = "";
  sub_1CD455E68(&v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CD41C8DC, qword_1EBCC2F38, &dword_1CB82C000);
}

void sub_1CBF4DF18(uint64_t a1)
{
  *(void *)a1 = &unk_1F2646B98;
  if (*(_DWORD *)(a1 + 56) == 1)
  {
    uint64_t v1 = *(void *)(a1 + 16);
    if (v1) {
      MEMORY[0x1D25D9CB0](v1, 0x1000C8077774924);
    }
  }

  JUMPOUT(0x1D25D9CE0);
}

void *llvm::addExtraSegment(_DWORD *a1, uint64_t a2)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  uint64_t inserted = llvm::Module::getOrInsertNamedMetadata(a1, "agx.segments", 0xCuLL);
  uint64_t v5 = *(uint64_t **)a1;
  char v6 = *(unsigned char *)(a2 + 23);
  BOOL v7 = v6 < 0;
  if (v6 >= 0) {
    unint64_t v8 = (unsigned __int8 *)a2;
  }
  else {
    unint64_t v8 = *(unsigned __int8 **)a2;
  }
  size_t v9 = v6 & 0x7F;
  if (v7) {
    size_t v10 = *(void *)(a2 + 8);
  }
  else {
    size_t v10 = v9;
  }
  v17[0] = llvm::MDString::get(v5, v8, v10);
  Impl = (unsigned __int8 *)llvm::MDTuple::getImpl((uint64_t)v5, v17, 1, 0, 1);
  unint64_t v16 = Impl;
  uint64_t v12 = *(void *)(inserted + 48);
  uint64_t v13 = *(unsigned int *)(v12 + 8);
  if (v13 >= *(_DWORD *)(v12 + 12)) {
    return (void *)sub_1CC608328(*(void *)(inserted + 48), &v16);
  }
  uint64_t v14 = Impl;
  unint64_t result = (void *)(*(void *)v12 + 8 * v13);
  *unint64_t result = v14;
  if (v14)
  {
    unint64_t result = (void *)llvm::MetadataTracking::track((uint64_t)result, v14, 2);
    LODWORD(v13) = *(_DWORD *)(v12 + 8);
  }
  *(_DWORD *)(v12 + 8) = v13 + 1;
  return result;
}

void *llvm::AGX::CompileRequest::addDMAListEntry(llvm::AGX::CompileRequest *this, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  return sub_1CC89B848(*(_DWORD **)(*(void *)this + 8), a2, a3, a4, a5);
}

uint64_t llvm::AGX::CompileRequest::getModule(llvm::AGX::CompileRequest *this)
{
  return *(void *)(*(void *)this + 8);
}

void llvm::AGX::CompileRequest::addSegments(uint64_t a1, long long *a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v5 = 24 * a3;
    do
    {
      if (*((char *)a2 + 23) < 0)
      {
        sub_1CB8BDF7C((uint64_t)v10, *(const void **)a2, *((void *)a2 + 1));
      }
      else
      {
        long long v6 = *a2;
        uint64_t v11 = *((void *)a2 + 2);
        *(_OWORD *)size_t v10 = v6;
      }
      BOOL v7 = *(_DWORD **)(*(void *)a1 + 8);
      if (SHIBYTE(v11) < 0)
      {
        sub_1CB8BDF7C((uint64_t)__p, v10[0], (unint64_t)v10[1]);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)v10;
        uint64_t v9 = v11;
      }
      llvm::addExtraSegment(v7, (uint64_t)__p);
      if (SHIBYTE(v9) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v11) < 0) {
        operator delete(v10[0]);
      }
      a2 = (long long *)((char *)a2 + 24);
      v5 -= 24;
    }
    while (v5);
  }
}

void llvm::AGX::CompileRequest::CompileRequest()
{
}

{
  operator new();
}

{
  operator new();
}

{
  operator new();
}

uint64_t llvm::AGX::CompileRequest::getOptions(llvm::AGX::CompileRequest *this)
{
  return *(void *)this + 16;
}

{
  return *(void *)this + 16;
}

uint64_t llvm::AGX::CompileRequest::getMaybeLoggingStream(llvm::AGX::CompileRequest *this)
{
  return **(void **)this;
}

void llvm::AGX::CompileRequest::setLoggingStream()
{
}

uint64_t llvm::AGX::CompileRequest::getShaderType(llvm::AGX::CompileRequest *this)
{
  return *(void *)this + 24;
}

void llvm::AGX::CompileRequest::~CompileRequest(uint64_t **this)
{
  uint64_t v1 = *this;
  *this = 0;
  if (v1)
  {
    if (*((char *)v1 + 47) < 0) {
      operator delete((void *)v1[3]);
    }
    uint64_t v2 = *v1;
    *uint64_t v1 = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    MEMORY[0x1D25D9CE0](v1, 0x1032C405E930839);
  }
}

{
  uint64_t *v1;
  uint64_t v2;

  uint64_t v1 = *this;
  *this = 0;
  if (v1)
  {
    if (*((char *)v1 + 47) < 0) {
      operator delete((void *)v1[3]);
    }
    uint64_t v2 = *v1;
    *uint64_t v1 = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    MEMORY[0x1D25D9CE0](v1, 0x1032C405E930839);
  }
}

void *llvm::AGX::CompileRequest::CompileRequest(void *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  *unint64_t result = v2;
  return result;
}

{
  uint64_t v2;

  uint64_t v2 = *a2;
  *a2 = 0;
  *unint64_t result = v2;
  return result;
}

uint64_t **llvm::AGX::CompileRequest::operator=(uint64_t **a1, uint64_t *a2)
{
  unint64_t v3 = (uint64_t *)*a2;
  *a2 = 0;
  uint64_t v4 = *a1;
  *a1 = v3;
  if (v4)
  {
    if (*((char *)v4 + 47) < 0) {
      operator delete((void *)v4[3]);
    }
    uint64_t v5 = *v4;
    *uint64_t v4 = 0;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    MEMORY[0x1D25D9CE0](v4, 0x1032C405E930839);
  }
  return a1;
}

void llvm::AGX::CompileReply::CompileReply()
{
}

BOOL llvm::AGX::CompileReply::isValid(llvm::AGX::CompileReply *this)
{
  uint64_t v2 = *(void *)(*(void *)this + 24);
  uint64_t v1 = *(void *)(*(void *)this + 32);
  if (v2 == v1) {
    return 1;
  }
  uint64_t v3 = v2 + 8;
  do
  {
    int v4 = *(_DWORD *)(*(void *)(v3 - 8) + 8);
    BOOL result = v4 != 0;
    if (v4) {
      BOOL v6 = v3 == v1;
    }
    else {
      BOOL v6 = 1;
    }
    v3 += 8;
  }
  while (!v6);
  return result;
}

uint64_t llvm::AGX::CompileReply::getBinary(llvm::AGX::CompileReply *this)
{
  return *(void *)this;
}

uint64_t llvm::AGX::CompileReply::getDiagnostics(llvm::AGX::CompileReply *this)
{
  return *(void *)this + 24;
}

{
  return *(void *)this + 24;
}

void *llvm::AGX::CompileReply::CompileReply(void *this)
{
  *this = 0;
  return this;
}

{
  *this = 0;
  return this;
}

void *llvm::AGX::CompileReply::CompileReply(void *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  *BOOL result = v2;
  return result;
}

{
  uint64_t v2;

  uint64_t v2 = *a2;
  *a2 = 0;
  *BOOL result = v2;
  return result;
}

void llvm::AGX::CompileReply::~CompileReply(llvm::AGX::CompileReply *this)
{
  uint64_t v1 = *(void *)this;
  *(void *)this = 0;
  if (v1) {
    sub_1CBF4E82C((uint64_t)this, v1);
  }
}

{
  uint64_t v1;

  uint64_t v1 = *(void *)this;
  *(void *)this = 0;
  if (v1) {
    sub_1CBF4E82C((uint64_t)this, v1);
  }
}

uint64_t sub_1CBF4E82C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    int v4 = (void **)(a2 + 24);
    sub_1CBF42078(&v4);
    if (*(char *)(a2 + 23) < 0) {
      operator delete(*(void **)a2);
    }
    return MEMORY[0x1D25D9CE0](a2, 0x1032C402D514303);
  }
  return result;
}

uint64_t llvm::AGX::TargetResolver::supportsTarget(unsigned __int8 *a1)
{
  uint64_t v2 = (const char **)&off_1E674F928;
  while (1)
  {
    uint64_t v3 = *v2;
    size_t v4 = strlen(*v2);
    if (v4 > 0x7FFFFFFFFFFFFFF7) {
LABEL_108:
    }
      abort();
    size_t v5 = v4;
    if (v4 >= 0x17)
    {
      uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v4 | 7) != 0x17) {
        uint64_t v7 = v4 | 7;
      }
      uint64_t v8 = v7 + 1;
      p_dst = (void **)operator new(v7 + 1);
      size_t v66 = v5;
      int64_t v67 = v8 | 0x8000000000000000;
      long long __dst = p_dst;
LABEL_9:
      memmove(p_dst, v3, v5);
      goto LABEL_10;
    }
    HIBYTE(v67) = v4;
    p_dst = (void **)&__dst;
    if (v4) {
      goto LABEL_9;
    }
LABEL_10:
    BOOL v9 = 0;
    *((unsigned char *)p_dst + v5) = 0;
    signed __int8 v10 = a1[23];
    if (v10 >= 0) {
      uint64_t v11 = v10 & 0x7F;
    }
    else {
      uint64_t v11 = *((void *)a1 + 1);
    }
    int v12 = SHIBYTE(v67);
    size_t v13 = HIBYTE(v67) & 0x7F;
    if (v67 < 0) {
      size_t v13 = v66;
    }
    if (v11 != v13) {
      goto LABEL_29;
    }
    if (v67 >= 0) {
      uint64_t v14 = (void **)&__dst;
    }
    else {
      uint64_t v14 = __dst;
    }
    if ((a1[23] & 0x80) != 0)
    {
      BOOL v9 = memcmp(*(const void **)a1, v14, *((void *)a1 + 1)) == 0;
      goto LABEL_29;
    }
    if ((v10 & 0x7F) != 0)
    {
      uint64_t v15 = (v10 & 0x7F) - 1;
      unint64_t v16 = a1;
      do
      {
        int v18 = *v16++;
        int v17 = v18;
        int v20 = *(unsigned __int8 *)v14;
        uint64_t v14 = (void **)((char *)v14 + 1);
        int v19 = v20;
        BOOL v21 = v15-- != 0;
        char v22 = v21;
        BOOL v9 = v17 == v19;
      }
      while (v17 == v19 && (v22 & 1) != 0);
LABEL_29:
      if ((v12 & 0x80000000) == 0) {
        goto LABEL_31;
      }
LABEL_30:
      operator delete(__dst);
      goto LABEL_31;
    }
    BOOL v9 = 1;
    if (SHIBYTE(v67) < 0) {
      goto LABEL_30;
    }
LABEL_31:
    if (v9) {
      return 1;
    }
    v2 += 12;
    if (v2 == (const char **)&unk_1E674FD48)
    {
      BOOL v23 = (const char **)&off_1E67B4C60;
      while (1)
      {
        unint64_t v24 = *v23;
        size_t v25 = strlen(*v23);
        if (v25 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_108;
        }
        size_t v26 = v25;
        if (v25 >= 0x17) {
          break;
        }
        HIBYTE(v67) = v25;
        unint64_t v27 = (void **)&__dst;
        if (v25) {
          goto LABEL_43;
        }
LABEL_44:
        BOOL v30 = 0;
        *((unsigned char *)v27 + v26) = 0;
        signed __int8 v31 = a1[23];
        if (v31 >= 0) {
          uint64_t v32 = v31 & 0x7F;
        }
        else {
          uint64_t v32 = *((void *)a1 + 1);
        }
        int v33 = SHIBYTE(v67);
        size_t v34 = HIBYTE(v67) & 0x7F;
        if (v67 < 0) {
          size_t v34 = v66;
        }
        if (v32 == v34)
        {
          if (v67 >= 0) {
            uint64_t v35 = (void **)&__dst;
          }
          else {
            uint64_t v35 = __dst;
          }
          if ((a1[23] & 0x80) != 0)
          {
            BOOL v30 = memcmp(*(const void **)a1, v35, *((void *)a1 + 1)) == 0;
          }
          else
          {
            if ((v31 & 0x7F) == 0)
            {
              BOOL v30 = 1;
              if ((SHIBYTE(v67) & 0x80000000) == 0) {
                goto LABEL_65;
              }
LABEL_64:
              operator delete(__dst);
              goto LABEL_65;
            }
            uint64_t v36 = (v31 & 0x7F) - 1;
            uint64_t v37 = a1;
            do
            {
              int v39 = *v37++;
              int v38 = v39;
              int v41 = *(unsigned __int8 *)v35;
              uint64_t v35 = (void **)((char *)v35 + 1);
              int v40 = v41;
              BOOL v21 = v36-- != 0;
              char v42 = v21;
              BOOL v30 = v38 == v40;
            }
            while (v38 == v40 && (v42 & 1) != 0);
          }
        }
        if (v33 < 0) {
          goto LABEL_64;
        }
LABEL_65:
        if (v30) {
          return 1;
        }
        v23 += 12;
        if (v23 == (const char **)&unk_1E67B5B60)
        {
          unint64_t v45 = (const char **)&off_1E6829A20;
          while (1)
          {
            unint64_t v46 = *v45;
            size_t v47 = strlen(*v45);
            if (v47 > 0x7FFFFFFFFFFFFFF7) {
              goto LABEL_108;
            }
            size_t v48 = v47;
            if (v47 >= 0x17) {
              break;
            }
            HIBYTE(v67) = v47;
            long long v49 = (void **)&__dst;
            if (v47) {
              goto LABEL_79;
            }
LABEL_80:
            BOOL v43 = 0;
            *((unsigned char *)v49 + v++*(_DWORD *)(result + 48) = 0;
            signed __int8 v52 = a1[23];
            if (v52 >= 0) {
              uint64_t v53 = v52 & 0x7F;
            }
            else {
              uint64_t v53 = *((void *)a1 + 1);
            }
            int v54 = SHIBYTE(v67);
            size_t v55 = HIBYTE(v67) & 0x7F;
            if (v67 < 0) {
              size_t v55 = v66;
            }
            if (v53 == v55)
            {
              if (v67 >= 0) {
                std::string::size_type v56 = (void **)&__dst;
              }
              else {
                std::string::size_type v56 = __dst;
              }
              if ((a1[23] & 0x80) != 0)
              {
                BOOL v43 = memcmp(*(const void **)a1, v56, *((void *)a1 + 1)) == 0;
              }
              else
              {
                if ((v52 & 0x7F) == 0)
                {
                  BOOL v43 = 1;
                  if ((SHIBYTE(v67) & 0x80000000) == 0) {
                    goto LABEL_101;
                  }
LABEL_100:
                  operator delete(__dst);
                  goto LABEL_101;
                }
                uint64_t v57 = (v52 & 0x7F) - 1;
                uint64_t v58 = a1;
                do
                {
                  int v60 = *v58++;
                  int v59 = v60;
                  int v62 = *(unsigned __int8 *)v56;
                  std::string::size_type v56 = (void **)((char *)v56 + 1);
                  int v61 = v62;
                  BOOL v21 = v57-- != 0;
                  char v63 = v21;
                  BOOL v43 = v59 == v61;
                }
                while (v59 == v61 && (v63 & 1) != 0);
              }
            }
            if (v54 < 0) {
              goto LABEL_100;
            }
LABEL_101:
            v45 += 12;
            int v64 = v45 == (const char **)&off_1E682A200 || v43;
            if (v64 == 1) {
              return v43;
            }
          }
          uint64_t v50 = (v47 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v47 | 7) != 0x17) {
            uint64_t v50 = v47 | 7;
          }
          uint64_t v51 = v50 + 1;
          long long v49 = (void **)operator new(v50 + 1);
          size_t v66 = v48;
          int64_t v67 = v51 | 0x8000000000000000;
          long long __dst = v49;
LABEL_79:
          memmove(v49, v46, v48);
          goto LABEL_80;
        }
      }
      uint64_t v28 = (v25 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v25 | 7) != 0x17) {
        uint64_t v28 = v25 | 7;
      }
      uint64_t v29 = v28 + 1;
      unint64_t v27 = (void **)operator new(v28 + 1);
      size_t v66 = v26;
      int64_t v67 = v29 | 0x8000000000000000;
      long long __dst = v27;
LABEL_43:
      memmove(v27, v24, v26);
      goto LABEL_44;
    }
  }
}

char *sub_1CBF4ECB4(int64x2_t *a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((a1->i64[1] - a1->i64[0]) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * ((a1[1].i64[0] - a1->i64[0]) >> 3) > v3) {
    unint64_t v3 = 0x5555555555555556 * ((a1[1].i64[0] - a1->i64[0]) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[1].i64[0] - a1->i64[0]) >> 3) >= 0x555555555555555) {
    unint64_t v6 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v3;
  }
  int v20 = a1 + 1;
  if (v6)
  {
    if (v6 > 0xAAAAAAAAAAAAAAALL) {
      sub_1CB833614();
    }
    uint64_t v7 = (char *)operator new(24 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = &v7[24 * v2];
  *(_OWORD *)uint64_t v8 = *(_OWORD *)a2;
  *((void *)v8 + 2) = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  uint64_t v10 = a1->i64[0];
  unint64_t v9 = a1->u64[1];
  if (v9 == a1->i64[0])
  {
    int64x2_t v13 = vdupq_n_s64(v9);
    uint64_t v11 = &v7[24 * v2];
  }
  else
  {
    uint64_t v11 = &v7[24 * v2];
    do
    {
      long long v12 = *(_OWORD *)(v9 - 24);
      *((void *)v11 - 1) = *(void *)(v9 - 8);
      *(_OWORD *)(v11 - 24) = v12;
      v11 -= 24;
      *(void *)(v9 - 16) = 0;
      *(void *)(v9 - 8) = 0;
      *(void *)(v9 - 24) = 0;
      v9 -= 24;
    }
    while (v9 != v10);
    int64x2_t v13 = *a1;
  }
  uint64_t v14 = v8 + 24;
  a1->i64[0] = (uint64_t)v11;
  a1->i64[1] = (uint64_t)(v8 + 24);
  int64x2_t v18 = v13;
  uint64_t v15 = a1[1].i64[0];
  a1[1].i64[0] = (uint64_t)&v7[24 * v6];
  uint64_t v19 = v15;
  uint64_t v17 = v13.i64[0];
  sub_1CBF4EE0C((uint64_t)&v17);
  return v14;
}

uint64_t sub_1CBF4EE0C(uint64_t a1)
{
  unint64_t v2 = *(void ***)(a1 + 8);
  unint64_t v3 = *(void ***)(a1 + 16);
  if (v3 != v2)
  {
    do
    {
      size_t v4 = v3 - 3;
      *(void *)(a1 + 16) = v3 - 3;
      if (*((char *)v3 - 1) < 0)
      {
        unint64_t v6 = v2;
        operator delete(*v4);
        unint64_t v2 = v6;
        size_t v4 = *(void ***)(a1 + 16);
      }
      unint64_t v3 = v4;
    }
    while (v4 != v2);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *llvm::AGX::TelemetryCollector::TelemetryCollector(void *this)
{
  *this = 0;
  return this;
}

{
  *this = 0;
  return this;
}

void *llvm::AGX::TelemetryCollector::enable(void *this)
{
  if (!*this) {
    operator new();
  }
  byte_1EBD0C080 = 1;
  byte_1EBD0C081 = 1;
  llvm::TimePassesIsEnabled = 1;
  return this;
}

void llvm::AGX::TelemetryCollector::setInstructionSelector(xpc_object_t **this, int a2, int a3)
{
  if (*this)
  {
    uint64_t v3 = 3;
    if (!a3) {
      uint64_t v3 = 1;
    }
    if (a2) {
      uint64_t v4 = 2;
    }
    else {
      uint64_t v4 = v3;
    }
    xpc_dictionary_set_uint64(**this, "instruction_selector", v4);
  }
}

llvm *llvm::AGX::TelemetryCollector::startCollection(llvm *this)
{
  uint64_t v1 = *(xpc_object_t **)this;
  if (*(void *)this)
  {
    llvm::ResetStatistics(this);
    if (*v1) {
      xpc_release(*v1);
    }
    this = (llvm *)xpc_dictionary_create(0, 0, 0);
    *uint64_t v1 = this;
  }
  return this;
}

void llvm::AGX::TelemetryCollector::finishCollection(xpc_object_t **this)
{
  uint64_t v1 = *this;
  if (*this)
  {
    llvm::GetStatistics((const char ***)&v106);
    unint64_t v2 = (const void **)v106;
    uint64_t v3 = v107;
    if (v106 != v107)
    {
      do
      {
        uint64_t v4 = *v2;
        if (!*v2)
        {
          unint64_t v7 = 0;
          unint64_t v8 = 0;
          std::string __p = 0;
          size_t v104 = 0;
          unint64_t v105 = 0;
          goto LABEL_14;
        }
        size_t v5 = (size_t)v2[1];
        if (v5 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_187;
        }
        if (v5 >= 0x17)
        {
          uint64_t v9 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v5 | 7) != 0x17) {
            uint64_t v9 = v5 | 7;
          }
          uint64_t v10 = v9 + 1;
          p_p = operator new(v9 + 1);
          size_t v104 = v5;
          unint64_t v105 = v10 | 0x8000000000000000;
          std::string __p = p_p;
        }
        else
        {
          HIBYTE(v105) = v2[1];
          p_p = &__p;
          if (!v5) {
            goto LABEL_13;
          }
        }
        memmove(p_p, v4, v5);
LABEL_13:
        *((unsigned char *)p_p + v5) = 0;
        unint64_t v8 = HIBYTE(v105);
        unint64_t v7 = v104;
LABEL_14:
        int v11 = (char)v8;
        unint64_t v12 = v8 & 0x7F;
        if ((v8 & 0x80u) != 0) {
          unint64_t v12 = v7;
        }
        if (v12 != 19)
        {
          BOOL v16 = 0;
          if ((v11 & 0x80000000) == 0) {
            goto LABEL_29;
          }
LABEL_28:
          operator delete(__p);
          goto LABEL_29;
        }
        if ((char)v8 < 0)
        {
          int64x2_t v13 = __p;
          unint64_t v8 = v7;
        }
        else
        {
          int64x2_t v13 = &__p;
        }
        if (v8 >= 0x13) {
          size_t v14 = 19;
        }
        else {
          size_t v14 = v8;
        }
        BOOL v15 = memcmp(v13, "NumFastIselFailures", v14) == 0;
        BOOL v16 = v8 == 19 && v15;
        if (v11 < 0) {
          goto LABEL_28;
        }
LABEL_29:
        if (v16) {
          xpc_dictionary_set_uint64(*v1, "stat_numfastiselfailures", *((unsigned int *)v2 + 4));
        }
        uint64_t v17 = *v2;
        if (!*v2)
        {
          unint64_t v20 = 0;
          unint64_t v21 = 0;
          std::string __p = 0;
          size_t v104 = 0;
          unint64_t v105 = 0;
          goto LABEL_42;
        }
        size_t v18 = (size_t)v2[1];
        if (v18 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_187;
        }
        if (v18 >= 0x17)
        {
          uint64_t v22 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v18 | 7) != 0x17) {
            uint64_t v22 = v18 | 7;
          }
          uint64_t v23 = v22 + 1;
          uint64_t v19 = operator new(v22 + 1);
          size_t v104 = v18;
          unint64_t v105 = v23 | 0x8000000000000000;
          std::string __p = v19;
        }
        else
        {
          HIBYTE(v105) = v2[1];
          uint64_t v19 = &__p;
          if (!v18) {
            goto LABEL_41;
          }
        }
        memmove(v19, v17, v18);
LABEL_41:
        *((unsigned char *)v19 + v18) = 0;
        unint64_t v21 = HIBYTE(v105);
        unint64_t v20 = v104;
LABEL_42:
        int v24 = (char)v21;
        unint64_t v25 = v21 & 0x7F;
        if ((v21 & 0x80u) != 0) {
          unint64_t v25 = v20;
        }
        if (v25 != 18)
        {
          BOOL v29 = 0;
          if ((v24 & 0x80000000) == 0) {
            goto LABEL_57;
          }
LABEL_56:
          operator delete(__p);
          goto LABEL_57;
        }
        if ((char)v21 < 0)
        {
          size_t v26 = __p;
          unint64_t v21 = v20;
        }
        else
        {
          size_t v26 = &__p;
        }
        if (v21 >= 0x12) {
          size_t v27 = 18;
        }
        else {
          size_t v27 = v21;
        }
        BOOL v28 = memcmp(v26, "NumFastIselSuccess", v27) == 0;
        BOOL v29 = v21 == 18 && v28;
        if (v24 < 0) {
          goto LABEL_56;
        }
LABEL_57:
        if (v29) {
          xpc_dictionary_set_uint64(*v1, "stat_numfastiselsuccesses", *((unsigned int *)v2 + 4));
        }
        BOOL v30 = *v2;
        if (!*v2)
        {
          unint64_t v33 = 0;
          unint64_t v34 = 0;
          std::string __p = 0;
          size_t v104 = 0;
          unint64_t v105 = 0;
          goto LABEL_70;
        }
        size_t v31 = (size_t)v2[1];
        if (v31 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_187;
        }
        if (v31 >= 0x17)
        {
          uint64_t v35 = (v31 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v31 | 7) != 0x17) {
            uint64_t v35 = v31 | 7;
          }
          uint64_t v36 = v35 + 1;
          uint64_t v32 = operator new(v35 + 1);
          size_t v104 = v31;
          unint64_t v105 = v36 | 0x8000000000000000;
          std::string __p = v32;
        }
        else
        {
          HIBYTE(v105) = v2[1];
          uint64_t v32 = &__p;
          if (!v31) {
            goto LABEL_69;
          }
        }
        memmove(v32, v30, v31);
LABEL_69:
        *((unsigned char *)v32 + v31) = 0;
        unint64_t v34 = HIBYTE(v105);
        unint64_t v33 = v104;
LABEL_70:
        int v37 = (char)v34;
        unint64_t v38 = v34 & 0x7F;
        if ((v34 & 0x80u) != 0) {
          unint64_t v38 = v33;
        }
        if (v38 != 17)
        {
          BOOL v42 = 0;
          if ((v37 & 0x80000000) == 0) {
            goto LABEL_85;
          }
LABEL_84:
          operator delete(__p);
          goto LABEL_85;
        }
        if ((char)v34 < 0)
        {
          int v39 = __p;
          unint64_t v34 = v33;
        }
        else
        {
          int v39 = &__p;
        }
        if (v34 >= 0x11) {
          size_t v40 = 17;
        }
        else {
          size_t v40 = v34;
        }
        BOOL v41 = memcmp(v39, "NumFunctionsReset", v40) == 0;
        BOOL v42 = v34 == 17 && v41;
        if (v37 < 0) {
          goto LABEL_84;
        }
LABEL_85:
        if (v42) {
          xpc_dictionary_set_uint64(*v1, "stat_numfunctionsreset", *((unsigned int *)v2 + 4));
        }
        BOOL v43 = *v2;
        if (!*v2)
        {
          unint64_t v46 = 0;
          unint64_t v47 = 0;
          std::string __p = 0;
          size_t v104 = 0;
          unint64_t v105 = 0;
          goto LABEL_98;
        }
        size_t v44 = (size_t)v2[1];
        if (v44 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_187;
        }
        if (v44 >= 0x17)
        {
          uint64_t v48 = (v44 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v44 | 7) != 0x17) {
            uint64_t v48 = v44 | 7;
          }
          uint64_t v49 = v48 + 1;
          unint64_t v45 = operator new(v48 + 1);
          size_t v104 = v44;
          unint64_t v105 = v49 | 0x8000000000000000;
          std::string __p = v45;
        }
        else
        {
          HIBYTE(v105) = v2[1];
          unint64_t v45 = &__p;
          if (!v44) {
            goto LABEL_97;
          }
        }
        memmove(v45, v43, v44);
LABEL_97:
        *((unsigned char *)v45 + v44) = 0;
        unint64_t v47 = HIBYTE(v105);
        unint64_t v46 = v104;
LABEL_98:
        int v50 = (char)v47;
        unint64_t v51 = v47 & 0x7F;
        if ((v47 & 0x80u) != 0) {
          unint64_t v51 = v46;
        }
        if (v51 != 24)
        {
          BOOL v55 = 0;
          if ((v50 & 0x80000000) == 0) {
            goto LABEL_113;
          }
LABEL_112:
          operator delete(__p);
          goto LABEL_113;
        }
        if ((char)v47 < 0)
        {
          signed __int8 v52 = __p;
          unint64_t v47 = v46;
        }
        else
        {
          signed __int8 v52 = &__p;
        }
        if (v47 >= 0x18) {
          size_t v53 = 24;
        }
        else {
          size_t v53 = v47;
        }
        BOOL v54 = memcmp(v52, "FallbackReportsGenerated", v53) == 0;
        BOOL v55 = v47 == 24 && v54;
        if (v50 < 0) {
          goto LABEL_112;
        }
LABEL_113:
        if (v55) {
          xpc_dictionary_set_uint64(*v1, "stat_numfallbackreports_generated", *((unsigned int *)v2 + 4));
        }
        std::string::size_type v56 = *v2;
        if (!*v2)
        {
          unint64_t v59 = 0;
          unint64_t v60 = 0;
          std::string __p = 0;
          size_t v104 = 0;
          unint64_t v105 = 0;
          goto LABEL_126;
        }
        size_t v57 = (size_t)v2[1];
        if (v57 > 0x7FFFFFFFFFFFFFF7) {
LABEL_187:
        }
          abort();
        if (v57 >= 0x17)
        {
          uint64_t v61 = (v57 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v57 | 7) != 0x17) {
            uint64_t v61 = v57 | 7;
          }
          uint64_t v62 = v61 + 1;
          uint64_t v58 = operator new(v61 + 1);
          size_t v104 = v57;
          unint64_t v105 = v62 | 0x8000000000000000;
          std::string __p = v58;
        }
        else
        {
          HIBYTE(v105) = v2[1];
          uint64_t v58 = &__p;
          if (!v57) {
            goto LABEL_125;
          }
        }
        memmove(v58, v56, v57);
LABEL_125:
        *((unsigned char *)v58 + v57) = 0;
        unint64_t v60 = HIBYTE(v105);
        unint64_t v59 = v104;
LABEL_126:
        int v63 = (char)v60;
        unint64_t v64 = v60 & 0x7F;
        if ((v60 & 0x80u) != 0) {
          unint64_t v64 = v59;
        }
        if (v64 == 25)
        {
          if ((char)v60 < 0)
          {
            std::error_code v65 = __p;
            unint64_t v60 = v59;
          }
          else
          {
            std::error_code v65 = &__p;
          }
          if (v60 >= 0x19) {
            size_t v66 = 25;
          }
          else {
            size_t v66 = v60;
          }
          BOOL v67 = memcmp(v65, "FallbackReportsSuppressed", v66) == 0;
          BOOL v68 = v60 == 25 && v67;
          if ((v63 & 0x80000000) == 0) {
            goto LABEL_141;
          }
LABEL_140:
          operator delete(__p);
          goto LABEL_141;
        }
        BOOL v68 = 0;
        if (v63 < 0) {
          goto LABEL_140;
        }
LABEL_141:
        if (v68) {
          xpc_dictionary_set_uint64(*v1, "stat_numfallbackreports_suppressed", *((unsigned int *)v2 + 4));
        }
        v2 += 3;
      }
      while (v2 != v3);
    }
    uint64_t NamedTimer = llvm::getNamedTimer("sdag", 4uLL, "combine1", 8uLL);
    if (NamedTimer)
    {
      uint64_t v70 = ((*(double *)(NamedTimer + 8) + *(double *)(NamedTimer + 16)) * 1000000.0);
      *(_WORD *)(NamedTimer + 128) = 0;
      *(_OWORD *)(NamedTimer + 32) = 0u;
      *(_OWORD *)(NamedTimer + ++*(_DWORD *)(result + 48) = 0u;
      *(_OWORD *)(NamedTimer + 64) = 0u;
      *(_OWORD *)uint64_t NamedTimer = 0u;
      *(_OWORD *)(NamedTimer + 16) = 0u;
      xpc_dictionary_set_uint64(*v1, "time_dagsel_dagcombining1", v70);
    }
    uint64_t v71 = llvm::getNamedTimer("sdag", 4uLL, "legalize_types", 0xEuLL);
    if (v71)
    {
      uint64_t v72 = ((*(double *)(v71 + 8) + *(double *)(v71 + 16)) * 1000000.0);
      *(_WORD *)(v71 + 128) = 0;
      *(_OWORD *)(v71 + 32) = 0u;
      *(_OWORD *)(v71 + ++*(_DWORD *)(result + 48) = 0u;
      *(_OWORD *)(v71 + 64) = 0u;
      *(_OWORD *)uint64_t v71 = 0u;
      *(_OWORD *)(v71 + 16) = 0u;
      xpc_dictionary_set_uint64(*v1, "time_dagisel_typelegalization", v72);
    }
    uint64_t v73 = llvm::getNamedTimer("sdag", 4uLL, "combine_lt", 0xAuLL);
    if (v73)
    {
      uint64_t v74 = ((*(double *)(v73 + 8) + *(double *)(v73 + 16)) * 1000000.0);
      *(_WORD *)(v73 + 128) = 0;
      *(_OWORD *)(v73 + 32) = 0u;
      *(_OWORD *)(v73 + ++*(_DWORD *)(result + 48) = 0u;
      *(_OWORD *)(v73 + 64) = 0u;
      *(_OWORD *)uint64_t v73 = 0u;
      *(_OWORD *)(v73 + 16) = 0u;
      xpc_dictionary_set_uint64(*v1, "time_dagisel_dagcombiningafterlegalizetypes", v74);
    }
    uint64_t v75 = llvm::getNamedTimer("sdag", 4uLL, "legalize_vec", 0xCuLL);
    if (v75)
    {
      uint64_t v76 = ((*(double *)(v75 + 8) + *(double *)(v75 + 16)) * 1000000.0);
      *(_WORD *)(v75 + 128) = 0;
      *(_OWORD *)(v75 + 32) = 0u;
      *(_OWORD *)(v75 + ++*(_DWORD *)(result + 48) = 0u;
      *(_OWORD *)(v75 + 64) = 0u;
      *(_OWORD *)uint64_t v75 = 0u;
      *(_OWORD *)(v75 + 16) = 0u;
      xpc_dictionary_set_uint64(*v1, "time_dagisel_vectorlegalization", v76);
    }
    uint64_t v77 = llvm::getNamedTimer("sdag", 4uLL, "legalize_types2", 0xFuLL);
    if (v77)
    {
      uint64_t v78 = ((*(double *)(v77 + 8) + *(double *)(v77 + 16)) * 1000000.0);
      *(_WORD *)(v77 + 128) = 0;
      *(_OWORD *)(v77 + 32) = 0u;
      *(_OWORD *)(v77 + ++*(_DWORD *)(result + 48) = 0u;
      *(_OWORD *)(v77 + 64) = 0u;
      *(_OWORD *)uint64_t v77 = 0u;
      *(_OWORD *)(v77 + 16) = 0u;
      xpc_dictionary_set_uint64(*v1, "time_dagisel_typelegalization2", v78);
    }
    uint64_t v79 = llvm::getNamedTimer("sdag", 4uLL, "combine_lv", 0xAuLL);
    if (v79)
    {
      uint64_t v80 = ((*(double *)(v79 + 8) + *(double *)(v79 + 16)) * 1000000.0);
      *(_WORD *)(v79 + 128) = 0;
      *(_OWORD *)(v79 + 32) = 0u;
      *(_OWORD *)(v79 + ++*(_DWORD *)(result + 48) = 0u;
      *(_OWORD *)(v79 + 64) = 0u;
      *(_OWORD *)uint64_t v79 = 0u;
      *(_OWORD *)(v79 + 16) = 0u;
      xpc_dictionary_set_uint64(*v1, "time_dagisel_dagcombiningafterlegalizevectors", v80);
    }
    uint64_t v81 = llvm::getNamedTimer("sdag", 4uLL, "legalize", 8uLL);
    if (v81)
    {
      uint64_t v82 = ((*(double *)(v81 + 8) + *(double *)(v81 + 16)) * 1000000.0);
      *(_WORD *)(v81 + 128) = 0;
      *(_OWORD *)(v81 + 32) = 0u;
      *(_OWORD *)(v81 + ++*(_DWORD *)(result + 48) = 0u;
      *(_OWORD *)(v81 + 64) = 0u;
      *(_OWORD *)uint64_t v81 = 0u;
      *(_OWORD *)(v81 + 16) = 0u;
      xpc_dictionary_set_uint64(*v1, "time_dagisel_legalization", v82);
    }
    uint64_t v83 = llvm::getNamedTimer("sdag", 4uLL, "combine2", 8uLL);
    if (v83)
    {
      uint64_t v84 = ((*(double *)(v83 + 8) + *(double *)(v83 + 16)) * 1000000.0);
      *(_WORD *)(v83 + 128) = 0;
      *(_OWORD *)(v83 + 32) = 0u;
      *(_OWORD *)(v83 + ++*(_DWORD *)(result + 48) = 0u;
      *(_OWORD *)(v83 + 64) = 0u;
      *(_OWORD *)uint64_t v83 = 0u;
      *(_OWORD *)(v83 + 16) = 0u;
      xpc_dictionary_set_uint64(*v1, "time_dagisel_dagcombining2", v84);
    }
    uint64_t v85 = llvm::getNamedTimer("sdag", 4uLL, "isel", 4uLL);
    if (v85)
    {
      uint64_t v86 = ((*(double *)(v85 + 8) + *(double *)(v85 + 16)) * 1000000.0);
      *(_WORD *)(v85 + 128) = 0;
      *(_OWORD *)(v85 + 32) = 0u;
      *(_OWORD *)(v85 + ++*(_DWORD *)(result + 48) = 0u;
      *(_OWORD *)(v85 + 64) = 0u;
      *(_OWORD *)uint64_t v85 = 0u;
      *(_OWORD *)(v85 + 16) = 0u;
      xpc_dictionary_set_uint64(*v1, "time_dagisel_instructionselection", v86);
    }
    uint64_t v87 = llvm::getNamedTimer("sdag", 4uLL, "sched", 5uLL);
    if (v87)
    {
      uint64_t v88 = ((*(double *)(v87 + 8) + *(double *)(v87 + 16)) * 1000000.0);
      *(_WORD *)(v87 + 128) = 0;
      *(_OWORD *)(v87 + 32) = 0u;
      *(_OWORD *)(v87 + ++*(_DWORD *)(result + 48) = 0u;
      *(_OWORD *)(v87 + 64) = 0u;
      *(_OWORD *)uint64_t v87 = 0u;
      *(_OWORD *)(v87 + 16) = 0u;
      xpc_dictionary_set_uint64(*v1, "time_dagisel_instructionscheduling", v88);
    }
    uint64_t v89 = llvm::getNamedTimer("sdag", 4uLL, "emit", 4uLL);
    if (v89)
    {
      uint64_t v90 = ((*(double *)(v89 + 8) + *(double *)(v89 + 16)) * 1000000.0);
      *(_WORD *)(v89 + 128) = 0;
      *(_OWORD *)(v89 + 32) = 0u;
      *(_OWORD *)(v89 + ++*(_DWORD *)(result + 48) = 0u;
      *(_OWORD *)(v89 + 64) = 0u;
      *(_OWORD *)uint64_t v89 = 0u;
      *(_OWORD *)(v89 + 16) = 0u;
      xpc_dictionary_set_uint64(*v1, "time_dagisel_instructioncreation", v90);
    }
    uint64_t v91 = llvm::getNamedTimer("pass", 4uLL, "irtranslator", 0xCuLL);
    if (v91)
    {
      uint64_t v92 = ((*(double *)(v91 + 8) + *(double *)(v91 + 16)) * 1000000.0);
      *(_WORD *)(v91 + 128) = 0;
      *(_OWORD *)(v91 + 32) = 0u;
      *(_OWORD *)(v91 + ++*(_DWORD *)(result + 48) = 0u;
      *(_OWORD *)(v91 + 64) = 0u;
      *(_OWORD *)uint64_t v91 = 0u;
      *(_OWORD *)(v91 + 16) = 0u;
      xpc_dictionary_set_uint64(*v1, "time_gisel_irtranslator", v92);
    }
    uint64_t v93 = llvm::getNamedTimer("pass", 4uLL, "legalizer", 9uLL);
    if (v93)
    {
      uint64_t v94 = ((*(double *)(v93 + 8) + *(double *)(v93 + 16)) * 1000000.0);
      *(_WORD *)(v93 + 128) = 0;
      *(_OWORD *)(v93 + 32) = 0u;
      *(_OWORD *)(v93 + ++*(_DWORD *)(result + 48) = 0u;
      *(_OWORD *)(v93 + 64) = 0u;
      *(_OWORD *)uint64_t v93 = 0u;
      *(_OWORD *)(v93 + 16) = 0u;
      xpc_dictionary_set_uint64(*v1, "time_gisel_legalizer", v94);
    }
    uint64_t v95 = llvm::getNamedTimer("pass", 4uLL, "regbankselect", 0xDuLL);
    if (v95)
    {
      uint64_t v96 = ((*(double *)(v95 + 8) + *(double *)(v95 + 16)) * 1000000.0);
      *(_WORD *)(v95 + 128) = 0;
      *(_OWORD *)(v95 + 32) = 0u;
      *(_OWORD *)(v95 + ++*(_DWORD *)(result + 48) = 0u;
      *(_OWORD *)(v95 + 64) = 0u;
      *(_OWORD *)uint64_t v95 = 0u;
      *(_OWORD *)(v95 + 16) = 0u;
      xpc_dictionary_set_uint64(*v1, "time_gisel_regbankallocator", v96);
    }
    uint64_t v97 = llvm::getNamedTimer("pass", 4uLL, "instruction-select", 0x12uLL);
    if (v97)
    {
      uint64_t v98 = ((*(double *)(v97 + 8) + *(double *)(v97 + 16)) * 1000000.0);
      *(_WORD *)(v97 + 128) = 0;
      *(_OWORD *)(v97 + 32) = 0u;
      *(_OWORD *)(v97 + ++*(_DWORD *)(result + 48) = 0u;
      *(_OWORD *)(v97 + 64) = 0u;
      *(_OWORD *)uint64_t v97 = 0u;
      *(_OWORD *)(v97 + 16) = 0u;
      xpc_dictionary_set_uint64(*v1, "time_gisel_instructionselector", v98);
    }
    uint64_t v99 = llvm::getNamedTimer("pass", 4uLL, "agx2-prelegalizer-combiner", 0x1AuLL);
    if (v99)
    {
      uint64_t v100 = ((*(double *)(v99 + 8) + *(double *)(v99 + 16)) * 1000000.0);
      *(_WORD *)(v99 + 128) = 0;
      *(_OWORD *)(v99 + 32) = 0u;
      *(_OWORD *)(v99 + ++*(_DWORD *)(result + 48) = 0u;
      *(_OWORD *)(v99 + 64) = 0u;
      *(_OWORD *)uint64_t v99 = 0u;
      *(_OWORD *)(v99 + 16) = 0u;
      xpc_dictionary_set_uint64(*v1, "time_gisel_agx2_prelegalizer_combiner", v100);
    }
    uint64_t v101 = llvm::getNamedTimer("pass", 4uLL, "agx2-postlegalizer-combiner", 0x1BuLL);
    if (v101)
    {
      uint64_t v102 = ((*(double *)(v101 + 8) + *(double *)(v101 + 16)) * 1000000.0);
      *(_WORD *)(v101 + 128) = 0;
      *(_OWORD *)(v101 + 32) = 0u;
      *(_OWORD *)(v101 + ++*(_DWORD *)(result + 48) = 0u;
      *(_OWORD *)(v101 + 64) = 0u;
      *(_OWORD *)uint64_t v101 = 0u;
      *(_OWORD *)(v101 + 16) = 0u;
      xpc_dictionary_set_uint64(*v1, "time_gisel_agx2_postlegalizer_combiner", v102);
    }
    if (v106)
    {
      int v107 = (const void **)v106;
      operator delete(v106);
    }
  }
}

uint64_t llvm::AGX::TelemetryCollector::fetchData(llvm::AGX::TelemetryCollector *this)
{
  if (*(void *)this) {
    return **(void **)this;
  }
  else {
    return 0;
  }
}

uint64_t llvm::AGX::TelemetryCollector::getAndResetTimer(void *a1, unsigned __int8 *a2, size_t a3, unsigned __int8 *a4, size_t a5)
{
  if (!*a1) {
    return 0;
  }
  uint64_t result = llvm::getNamedTimer(a2, a3, a4, a5);
  if (result)
  {
    uint64_t v6 = ((*(double *)(result + 8) + *(double *)(result + 16)) * 1000000.0);
    *(_WORD *)(result + 128) = 0;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)(result + ++*(_DWORD *)(result + 48) = 0u;
    *(_OWORD *)(result + 64) = 0u;
    *(_OWORD *)uint64_t result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    return v6 | 0x100000000;
  }
  return result;
}

void llvm::AGX::TelemetryCollector::~TelemetryCollector(xpc_object_t **this)
{
  uint64_t v1 = *this;
  *this = 0;
  if (v1)
  {
    if (*v1) {
      xpc_release(*v1);
    }
    MEMORY[0x1D25D9CE0](v1, 0x80C40B8603338);
  }
}

uint64_t llvm::verifyAGXModule()
{
  return 0;
}

uint64_t sub_1CBF4FC58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 40) + 272;
  v8[0] = a2;
  v8[1] = a3;
  v8[2] = v5;
  v8[3] = a4;
  uint64_t v9 = v11;
  uint64_t v10 = 0x400000000;
  v12[0] = 0;
  v12[1] = 0;
  v11[4] = 0;
  int v13 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v14 = 0;
  char v6 = llvm::TruncInstCombine::run((llvm::TruncInstCombine *)v8, (llvm::Function **)a1);
  if (*(void *)(a1 + 80) != a1 + 72) {
    llvm::DominatorTreeBase<llvm::BasicBlock,false>::isReachableFromEntry();
  }
  sub_1CD456CB4(v12);
  if (v9 != v11) {
    free(v9);
  }
  return v6 & 1;
}

void llvm::initializeAggressiveInstCombinerLegacyPassPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC3028, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBF51EA8;
    v3[1] = &v1;
    unint64_t v2 = v3;
    std::__call_once(&qword_1EBCC3028, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBF51EA8(uint64_t a1)
{
}

void llvm::initializeAggressiveInstCombine(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC3028, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBF51EA8;
    v3[1] = &v1;
    unint64_t v2 = v3;
    std::__call_once(&qword_1EBCC3028, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void LLVMInitializeAggressiveInstCombiner(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC3028, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBF51EA8;
    v3[1] = &v1;
    unint64_t v2 = v3;
    std::__call_once(&qword_1EBCC3028, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t sub_1CBF52038(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCC3020;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F26005A0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC3028, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CBF51EA8;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC3028, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void LLVMAddAggressiveInstCombinerPass()
{
}

uint64_t sub_1CBF52160(uint64_t a1, uint64_t *a2)
{
  while (1)
  {
    unint64_t v2 = a2;
    uint64_t v3 = a1;
    uint64_t v34 = 0;
    if (*((unsigned char *)a2 + 24)) {
      break;
    }
    int v5 = *(unsigned __int8 *)(a1 + 16);
    if (v5 == 5)
    {
      int v11 = *(unsigned __int16 *)(a1 + 18);
      if (v11 != 29) {
        goto LABEL_39;
      }
      uint64_t v14 = (uint64_t *)(a1 - 32 * (*(_DWORD *)(a1 + 20) & 0x7FFFFFF));
      if (!*v14) {
        goto LABEL_38;
      }
      uint64_t v34 = *v14;
      uint64_t v6 = v14[4];
      if (!v6) {
        goto LABEL_38;
      }
    }
    else
    {
      if (v5 != 57) {
        goto LABEL_21;
      }
      if (!*(void *)(a1 - 64)) {
        goto LABEL_38;
      }
      uint64_t v34 = *(void *)(a1 - 64);
      uint64_t v6 = *(void *)(a1 - 32);
      if (!v6) {
        goto LABEL_38;
      }
    }
    uint64_t result = ((uint64_t (*)(void))sub_1CBF52160)();
    if (!result) {
      return result;
    }
    a1 = v6;
    a2 = v2;
  }
  int v4 = *(unsigned __int8 *)(a1 + 16);
  if (v4 != 5)
  {
    if (v4 != 56) {
      goto LABEL_16;
    }
    if (!*(void *)(a1 - 64)) {
      goto LABEL_16;
    }
    uint64_t v34 = *(void *)(a1 - 64);
    if (!sub_1CBF5250C((uint64_t)&v30, *(llvm::Constant **)(a1 - 32))) {
      goto LABEL_16;
    }
LABEL_15:
    *((unsigned char *)v2 + 25) = 1;
    uint64_t v8 = v34;
    return sub_1CBF52160(v8);
  }
  if (*(_WORD *)(a1 + 18) == 28)
  {
    unint64_t v7 = (uint64_t *)(a1 - 32 * (*(_DWORD *)(a1 + 20) & 0x7FFFFFF));
    if (*v7)
    {
      uint64_t v34 = *v7;
      if (sub_1CBF5270C((uint64_t)&v30, (llvm::Constant *)v7[4])) {
        goto LABEL_15;
      }
    }
  }
LABEL_16:
  int v5 = *(unsigned __int8 *)(v3 + 16);
  if (v5 == 5)
  {
    int v11 = *(unsigned __int16 *)(v3 + 18);
    if (v11 == 28)
    {
      unint64_t v12 = (uint64_t *)(v3 - 32 * (*(_DWORD *)(v3 + 20) & 0x7FFFFFF));
      uint64_t v9 = *v12;
      if (!*v12) {
        goto LABEL_38;
      }
      uint64_t v34 = *v12;
      uint64_t v10 = v12[4];
      if (!v10) {
        goto LABEL_38;
      }
LABEL_28:
      uint64_t result = sub_1CBF52160(v9);
      if (!result) {
        return result;
      }
      uint64_t v8 = v10;
      return sub_1CBF52160(v8);
    }
LABEL_39:
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    BOOL v30 = &v32;
    if (v11 != 26) {
      goto LABEL_42;
    }
    uint64_t v15 = (uint64_t *)(v3 - 32 * (*(_DWORD *)(v3 + 20) & 0x7FFFFFF));
    if (!*v15) {
      goto LABEL_42;
    }
    uint64_t v33 = *v15;
    if ((sub_1CBF5295C((uint64_t)&v30, (llvm::Constant *)v15[4]) & 1) == 0) {
      goto LABEL_42;
    }
  }
  else
  {
    if (v5 == 56)
    {
      uint64_t v9 = *(void *)(v3 - 64);
      if (!v9 || (v34 = *(void *)(v3 - 64), (uint64_t v10 = *(void *)(v3 - 32)) == 0))
      {
LABEL_38:
        uint64_t v32 = 0;
LABEL_42:
        uint64_t v33 = v3;
        goto LABEL_43;
      }
      goto LABEL_28;
    }
LABEL_21:
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    BOOL v30 = &v32;
    if (v5 != 54) {
      goto LABEL_42;
    }
    if (!*(void *)(v3 - 64)) {
      goto LABEL_42;
    }
    uint64_t v33 = *(void *)(v3 - 64);
    if (!sub_1CBF528D8((uint64_t)&v30, *(unsigned __int8 **)(v3 - 32))) {
      goto LABEL_42;
    }
  }
LABEL_43:
  uint64_t v16 = *v2;
  if (!*v2)
  {
    uint64_t v16 = v33;
    *unint64_t v2 = v33;
  }
  uint64_t v17 = (void *)v32;
  unint64_t v18 = *((unsigned int *)v2 + 4);
  if (!v32)
  {
LABEL_55:
    uint64_t v25 = 1 << (char)v17;
    uint64_t v27 = v2[1];
    size_t v26 = v2 + 1;
    BOOL v28 = (void *)(v27 + 8 * (v17 >> 6));
    if (v18 >= 0x41) {
      BOOL v29 = v28;
    }
    else {
      BOOL v29 = v26;
    }
    *v29 |= v25;
    return v16 == v33;
  }
  uint64_t v19 = *(unsigned int *)(v32 + 8);
  if (v19 < 0x41)
  {
LABEL_54:
    uint64_t v17 = (void *)*v17;
    if ((unint64_t)v17 >= v18) {
      return 0;
    }
    goto LABEL_55;
  }
  int v20 = 0;
  int64_t v21 = (unint64_t)(v19 + 63) >> 6;
  do
  {
    if (v21-- < 1) {
      break;
    }
    unint64_t v23 = *(void *)(*(void *)v32 + 8 * v21);
    v20 += __clz(v23);
  }
  while (!v23);
  uint64_t result = 0;
  int v24 = v19 | 0xFFFFFFC0;
  if ((v19 & 0x3F) == 0) {
    int v24 = 0;
  }
  if ((v19 - v20 - v24) < 0x41)
  {
    uint64_t v17 = *(void **)v32;
    goto LABEL_54;
  }
  return result;
}

llvm::Instruction *sub_1CBF52474(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = (llvm::Instruction *)(*(uint64_t (**)(void))(**(void **)(a1 + 72) + 24))(*(void *)(a1 + 72));
  if (!result)
  {
    __int16 v11 = 257;
    uint64_t v9 = llvm::BinaryOperator::Create(28, a2, a3, &v10, 0);
    return sub_1CB844E0C((uint64_t *)a1, v9, a4);
  }
  return result;
}

uint64_t sub_1CBF5250C(uint64_t a1, llvm::Constant *a2)
{
  unsigned int v4 = *((unsigned __int8 *)a2 + 16);
  if (a2 && v4 == 16)
  {
    uint64_t v5 = *((unsigned int *)a2 + 8);
    if (v5 > 0x40)
    {
      int v14 = 0;
      int64_t v15 = (unint64_t)(v5 + 63) >> 6;
      do
      {
        BOOL v9 = v15-- < 1;
        if (v9) {
          break;
        }
        unint64_t v16 = *(void *)(*((void *)a2 + 3) + 8 * v15);
        v14 += __clz(v16);
      }
      while (!v16);
      int v17 = v5 | 0xFFFFFFC0;
      if ((v5 & 0x3F) == 0) {
        int v17 = 0;
      }
      return v14 + v17 == v5 - 1;
    }
    else
    {
      return *((void *)a2 + 3) == 1;
    }
  }
  else
  {
    uint64_t v7 = *(void *)a2;
    if (*(void *)a2) {
      BOOL v8 = (*(_DWORD *)(*(void *)a2 + 8) & 0xFE) == 18;
    }
    else {
      BOOL v8 = 0;
    }
    BOOL v9 = !v8 || v4 > 0x14;
    int v10 = v9;
    if (!v9)
    {
      SplatValue = llvm::Constant::getSplatValue(a2, 0);
      if (SplatValue && *((unsigned char *)SplatValue + 16) == 16)
      {
        uint64_t v12 = *((unsigned int *)SplatValue + 8);
        if (v12 > 0x40)
        {
          int v28 = 0;
          int64_t v29 = (unint64_t)(v12 + 63) >> 6;
          do
          {
            BOOL v9 = v29-- < 1;
            if (v9) {
              break;
            }
            unint64_t v30 = *(void *)(SplatValue[3] + 8 * v29);
            v28 += __clz(v30);
          }
          while (!v30);
          int v31 = v12 | 0xFFFFFFC0;
          if ((v12 & 0x3F) == 0) {
            int v31 = 0;
          }
          BOOL v13 = v28 + v31 == v12 - 1;
        }
        else
        {
          BOOL v13 = SplatValue[3] == 1;
        }
        int v2 = v13;
      }
      else
      {
        if (*(unsigned char *)(v7 + 8) == 18)
        {
          int v19 = *(_DWORD *)(v7 + 32);
          if (v19)
          {
            int v20 = 0;
            int v2 = 0;
            while (1)
            {
              AggregateElement = llvm::Constant::getAggregateElement(a2, v20);
              if (!AggregateElement) {
                break;
              }
              int v22 = *((unsigned __int8 *)AggregateElement + 16);
              if ((v22 - 11) >= 2)
              {
                if (v22 != 16) {
                  break;
                }
                uint64_t v23 = *((unsigned int *)AggregateElement + 8);
                if (v23 > 0x40)
                {
                  int v24 = 0;
                  int64_t v25 = (unint64_t)(v23 + 63) >> 6;
                  do
                  {
                    BOOL v9 = v25-- < 1;
                    if (v9) {
                      break;
                    }
                    unint64_t v26 = *(void *)(AggregateElement[3] + 8 * v25);
                    v24 += __clz(v26);
                  }
                  while (!v26);
                  int v27 = v23 | 0xFFFFFFC0;
                  if ((v23 & 0x3F) == 0) {
                    int v27 = 0;
                  }
                  if (v24 + v27 != v23 - 1) {
                    break;
                  }
                }
                else if (AggregateElement[3] != 1)
                {
                  break;
                }
                int v2 = 1;
              }
              int v20 = (llvm::Type *)(v20 + 1);
              if (v20 == v19) {
                return (v10 ^ 1) & v2;
              }
            }
          }
        }
        int v2 = 0;
      }
    }
    return (v10 ^ 1) & v2;
  }
}

uint64_t sub_1CBF5270C(uint64_t a1, llvm::Constant *a2)
{
  if (!a2 || *((unsigned char *)a2 + 16) != 16)
  {
    uint64_t v6 = *(void *)a2;
    if (*(void *)a2) {
      BOOL v7 = (*(_DWORD *)(*(void *)a2 + 8) & 0xFE) == 18;
    }
    else {
      BOOL v7 = 0;
    }
    if (v7)
    {
      SplatValue = llvm::Constant::getSplatValue(a2, 0);
      if (SplatValue && *((unsigned char *)SplatValue + 16) == 16)
      {
        uint64_t v3 = *((unsigned int *)SplatValue + 8);
        if (v3 <= 0x40)
        {
          uint64_t v4 = SplatValue[3];
          goto LABEL_5;
        }
        int v9 = 0;
        int64_t v25 = (unint64_t)(v3 + 63) >> 6;
        do
        {
          BOOL v11 = v25-- < 1;
          if (v11) {
            break;
          }
          unint64_t v26 = *(void *)(SplatValue[3] + 8 * v25);
          v9 += __clz(v26);
        }
        while (!v26);
LABEL_18:
        int v13 = v3 | 0xFFFFFFC0;
        if ((v3 & 0x3F) == 0) {
          int v13 = 0;
        }
        BOOL v5 = v9 + v13 == v3 - 1;
        goto LABEL_21;
      }
      if (*(unsigned char *)(v6 + 8) == 18)
      {
        int v15 = *(_DWORD *)(v6 + 32);
        if (v15)
        {
          unint64_t v16 = 0;
          char v14 = 0;
          while (1)
          {
            AggregateElement = llvm::Constant::getAggregateElement(a2, v16);
            if (!AggregateElement) {
              break;
            }
            int v18 = *((unsigned __int8 *)AggregateElement + 16);
            if ((v18 - 11) >= 2)
            {
              if (v18 != 16) {
                break;
              }
              uint64_t v19 = *((unsigned int *)AggregateElement + 8);
              if (v19 > 0x40)
              {
                int v20 = 0;
                int64_t v21 = (unint64_t)(v19 + 63) >> 6;
                do
                {
                  BOOL v11 = v21-- < 1;
                  if (v11) {
                    break;
                  }
                  unint64_t v22 = *(void *)(AggregateElement[3] + 8 * v21);
                  v20 += __clz(v22);
                }
                while (!v22);
                int v23 = v19 | 0xFFFFFFC0;
                if ((v19 & 0x3F) == 0) {
                  int v23 = 0;
                }
                if (v20 + v23 != v19 - 1) {
                  break;
                }
              }
              else if (AggregateElement[3] != 1)
              {
                break;
              }
              char v14 = 1;
            }
            unint64_t v16 = (llvm::Type *)(v16 + 1);
            if (v16 == v15) {
              return v14 & 1;
            }
          }
        }
      }
    }
    char v14 = 0;
    return v14 & 1;
  }
  uint64_t v3 = *((unsigned int *)a2 + 8);
  if (v3 > 0x40)
  {
    int v9 = 0;
    int64_t v10 = (unint64_t)(v3 + 63) >> 6;
    do
    {
      BOOL v11 = v10-- < 1;
      if (v11) {
        break;
      }
      unint64_t v12 = *(void *)(*((void *)a2 + 3) + 8 * v10);
      v9 += __clz(v12);
    }
    while (!v12);
    goto LABEL_18;
  }
  uint64_t v4 = *((void *)a2 + 3);
LABEL_5:
  BOOL v5 = v4 == 1;
LABEL_21:
  char v14 = v5;
  return v14 & 1;
}

uint64_t sub_1CBF528D8(uint64_t a1, unsigned __int8 *a2)
{
  unsigned int v3 = a2[16];
  if (a2 && v3 == 16) {
    goto LABEL_3;
  }
  if (v3 <= 0x14 && (*(_DWORD *)(*(void *)a2 + 8) & 0xFE) == 18)
  {
    uint64_t result = (uint64_t)llvm::Constant::getSplatValue((llvm::Constant *)a2, (llvm::Type *)*(unsigned __int8 *)(a1 + 8));
    if (!result) {
      return result;
    }
    a2 = (unsigned __int8 *)result;
    if (*(unsigned char *)(result + 16) == 16)
    {
LABEL_3:
      **(void **)a1 = a2 + 24;
      return 1;
    }
  }
  return 0;
}

uint64_t sub_1CBF5295C(uint64_t a1, llvm::Constant *a2)
{
  if (a2 && *((unsigned char *)a2 + 16) == 16) {
    goto LABEL_3;
  }
  if ((*(_DWORD *)(*(void *)a2 + 8) & 0xFE) == 0x12)
  {
    uint64_t result = (uint64_t)llvm::Constant::getSplatValue(a2, (llvm::Type *)*(unsigned __int8 *)(a1 + 8));
    if (!result) {
      return result;
    }
    a2 = (llvm::Constant *)result;
    if (*(unsigned char *)(result + 16) == 16)
    {
LABEL_3:
      **(void **)a1 = (char *)a2 + 24;
      return 1;
    }
  }
  return 0;
}

uint64_t sub_1CBF529DC(uint64_t *a1, void *a2, void *a3, uint64_t *a4)
{
  uint64_t v61 = 0;
  uint64_t v8 = *a1;
  if ((*(_DWORD *)(v8 + 8) & 0xFE) == 0x12) {
    uint64_t v8 = **(void **)(v8 + 16);
  }
  unint64_t PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v8);
  BOOL v55 = a2;
  std::string::size_type v56 = a4;
  LODWORD(v59) = 64;
  size_t v57 = a3;
  uint64_t v58 = (uint64_t *)PrimitiveSizeInBits;
  uint64_t v10 = a1[1];
  unint64_t v60 = &v61;
  if (!v10 || *(void *)(v10 + 8)) {
    goto LABEL_5;
  }
  int v13 = *((unsigned __int8 *)a1 + 16);
  if (v13 == 5)
  {
    if (*((_WORD *)a1 + 9) != 29) {
      goto LABEL_69;
    }
    uint64_t v22 = a1[-4 * (*((_DWORD *)a1 + 5) & 0x7FFFFFF)];
    int v23 = *(unsigned __int8 *)(v22 + 16);
    if (v23 == 5)
    {
      if (*(_WORD *)(v22 + 18) != 25) {
        goto LABEL_54;
      }
      uint64_t v37 = *(void *)(v22 - 32 * (*(_DWORD *)(v22 + 20) & 0x7FFFFFF));
      if (!v37) {
        goto LABEL_54;
      }
      *a2 = v37;
      uint64_t v25 = *(void *)(v22 - 32 * (*(_DWORD *)(v22 + 20) & 0x7FFFFFF) + 32);
      if (!v25) {
        goto LABEL_54;
      }
    }
    else
    {
      if (v23 != 53) {
        goto LABEL_54;
      }
      uint64_t v24 = *(void *)(v22 - 64);
      if (!v24) {
        goto LABEL_54;
      }
      *a2 = v24;
      uint64_t v25 = *(void *)(v22 - 32);
      if (!v25) {
        goto LABEL_54;
      }
    }
    *a4 = v25;
    uint64_t v38 = (uint64_t)&a1[-4 * (*((_DWORD *)a1 + 5) & 0x7FFFFFF)];
    if (sub_1CBF52FC4(&v57, *(void *)(v38 + 32), v38)) {
      goto LABEL_53;
    }
LABEL_54:
    uint64_t v40 = a1[-4 * (*((_DWORD *)a1 + 5) & 0x7FFFFFF) + 4];
    int v41 = *(unsigned __int8 *)(v40 + 16);
    if (v41 == 5)
    {
      if (*(_WORD *)(v40 + 18) != 25) {
        goto LABEL_69;
      }
      uint64_t v47 = *(void *)(v40 - 32 * (*(_DWORD *)(v40 + 20) & 0x7FFFFFF));
      if (!v47) {
        goto LABEL_69;
      }
      *BOOL v55 = v47;
      uint64_t v43 = *(void *)(v40 - 32 * (*(_DWORD *)(v40 + 20) & 0x7FFFFFF) + 32);
      if (!v43) {
        goto LABEL_69;
      }
    }
    else
    {
      if (v41 != 53) {
        goto LABEL_69;
      }
      uint64_t v42 = *(void *)(v40 - 64);
      if (!v42) {
        goto LABEL_69;
      }
      *BOOL v55 = v42;
      uint64_t v43 = *(void *)(v40 - 32);
      if (!v43) {
        goto LABEL_69;
      }
    }
    *std::string::size_type v56 = v43;
    uint64_t v48 = &a1[-4 * (*((_DWORD *)a1 + 5) & 0x7FFFFFF)];
    BOOL v36 = sub_1CBF52FC4(&v57, *v48, (uint64_t)v48);
    goto LABEL_68;
  }
  if (v13 == 57)
  {
    uint64_t v14 = *(a1 - 8);
    int v15 = *(unsigned __int8 *)(v14 + 16);
    if (v15 == 5)
    {
      if (*(_WORD *)(v14 + 18) != 25) {
        goto LABEL_40;
      }
      uint64_t v30 = *(void *)(v14 - 32 * (*(_DWORD *)(v14 + 20) & 0x7FFFFFF));
      if (!v30) {
        goto LABEL_40;
      }
      *a2 = v30;
      uint64_t v17 = *(void *)(v14 - 32 * (*(_DWORD *)(v14 + 20) & 0x7FFFFFF) + 32);
      if (!v17) {
        goto LABEL_40;
      }
    }
    else
    {
      if (v15 != 53) {
        goto LABEL_40;
      }
      uint64_t v16 = *(void *)(v14 - 64);
      if (!v16) {
        goto LABEL_40;
      }
      *a2 = v16;
      uint64_t v17 = *(void *)(v14 - 32);
      if (!v17) {
        goto LABEL_40;
      }
    }
    *a4 = v17;
    if (!sub_1CBF52FC4(&v57, *(a1 - 4), v17))
    {
LABEL_40:
      uint64_t v31 = *(a1 - 4);
      int v32 = *(unsigned __int8 *)(v31 + 16);
      if (v32 == 5)
      {
        if (*(_WORD *)(v31 + 18) != 25) {
          goto LABEL_69;
        }
        uint64_t v35 = *(void *)(v31 - 32 * (*(_DWORD *)(v31 + 20) & 0x7FFFFFF));
        if (!v35) {
          goto LABEL_69;
        }
        *BOOL v55 = v35;
        uint64_t v34 = *(void *)(v31 - 32 * (*(_DWORD *)(v31 + 20) & 0x7FFFFFF) + 32);
        if (!v34) {
          goto LABEL_69;
        }
      }
      else
      {
        if (v32 != 53) {
          goto LABEL_69;
        }
        uint64_t v33 = *(void *)(v31 - 64);
        if (!v33) {
          goto LABEL_69;
        }
        *BOOL v55 = v33;
        uint64_t v34 = *(void *)(v31 - 32);
        if (!v34) {
          goto LABEL_69;
        }
      }
      *std::string::size_type v56 = v34;
      BOOL v36 = sub_1CBF52FC4(&v57, *(a1 - 8), v34);
LABEL_68:
      int v39 = v36;
      goto LABEL_70;
    }
LABEL_53:
    int v39 = 1;
    goto LABEL_70;
  }
LABEL_69:
  int v39 = 0;
LABEL_70:
  if (v59 >= 0x41 && v58)
  {
    MEMORY[0x1D25D9CB0](v58, 0x1000C8000313F17);
    if ((v39 & 1) == 0) {
      goto LABEL_5;
    }
  }
  else if (!v39)
  {
    goto LABEL_5;
  }
  if (*a4 == v61) {
    return 148;
  }
LABEL_5:
  LODWORD(v57) = 64;
  BOOL v55 = a2;
  std::string::size_type v56 = (uint64_t *)PrimitiveSizeInBits;
  uint64_t v11 = a1[1];
  uint64_t v58 = &v61;
  unint64_t v59 = a3;
  unint64_t v60 = a4;
  if (!v11 || *(void *)(v11 + 8)) {
    return 0;
  }
  uint64_t v18 = *((unsigned __int8 *)a1 + 16);
  if (v18 != 5)
  {
    if (v18 == 57)
    {
      if (sub_1CBF53434(&v55, *(a1 - 8), v18))
      {
        uint64_t v19 = *(a1 - 4);
        int v20 = *(unsigned __int8 *)(v19 + 16);
        if (v20 == 5)
        {
          if (*(_WORD *)(v19 + 18) == 26)
          {
            uint64_t v44 = *(void *)(v19 - 32 * (*(_DWORD *)(v19 + 20) & 0x7FFFFFF));
            if (v44)
            {
              *unint64_t v59 = v44;
              uint64_t v19 = *(void *)(v19 - 32 * (*(_DWORD *)(v19 + 20) & 0x7FFFFFF) + 32);
              if (v19) {
                goto LABEL_85;
              }
            }
          }
        }
        else if (v20 == 54)
        {
          uint64_t v21 = *(void *)(v19 - 64);
          if (v21)
          {
            *unint64_t v59 = v21;
            uint64_t v19 = *(void *)(v19 - 32);
            if (v19) {
              goto LABEL_85;
            }
          }
        }
      }
      if (sub_1CBF53434(&v55, *(a1 - 4), v19))
      {
        uint64_t v46 = *(a1 - 8);
        goto LABEL_82;
      }
    }
LABEL_86:
    int v53 = 0;
    goto LABEL_87;
  }
  if (*((_WORD *)a1 + 9) != 29) {
    goto LABEL_86;
  }
  unint64_t v26 = &a1[-4 * (*((_DWORD *)a1 + 5) & 0x7FFFFFF)];
  if (sub_1CBF53434(&v55, *v26, (uint64_t)v26))
  {
    uint64_t v27 = a1[-4 * (*((_DWORD *)a1 + 5) & 0x7FFFFFF) + 4];
    int v28 = *(unsigned __int8 *)(v27 + 16);
    if (v28 == 5)
    {
      if (*(_WORD *)(v27 + 18) == 26)
      {
        uint64_t v49 = *(void *)(v27 - 32 * (*(_DWORD *)(v27 + 20) & 0x7FFFFFF));
        if (v49)
        {
          *unint64_t v59 = v49;
          uint64_t v19 = *(void *)(v27 - 32 * (*(_DWORD *)(v27 + 20) & 0x7FFFFFF) + 32);
          if (v19) {
            goto LABEL_85;
          }
        }
      }
    }
    else if (v28 == 54)
    {
      uint64_t v29 = *(void *)(v27 - 64);
      if (v29)
      {
        *unint64_t v59 = v29;
        uint64_t v19 = *(void *)(v27 - 32);
        if (v19) {
          goto LABEL_85;
        }
      }
    }
  }
  uint64_t v50 = (uint64_t)&a1[-4 * (*((_DWORD *)a1 + 5) & 0x7FFFFFF)];
  if (!sub_1CBF53434(&v55, *(void *)(v50 + 32), v50)) {
    goto LABEL_86;
  }
  uint64_t v46 = a1[-4 * (*((_DWORD *)a1 + 5) & 0x7FFFFFF)];
LABEL_82:
  int v51 = *(unsigned __int8 *)(v46 + 16);
  if (v51 != 54)
  {
    if (v51 == 5)
    {
      if (*(_WORD *)(v46 + 18) != 26) {
        goto LABEL_99;
      }
      uint64_t v45 = *(void *)(v46 - 32 * (*(_DWORD *)(v46 + 20) & 0x7FFFFFF));
      if (v45)
      {
        *unint64_t v59 = v45;
        uint64_t v54 = *(void *)(v46 - 32 * (*(_DWORD *)(v46 + 20) & 0x7FFFFFF) + 32);
        if (v54)
        {
          *unint64_t v60 = v54;
          LOBYTE(v45) = 1;
          goto LABEL_100;
        }
LABEL_99:
        LOBYTE(v45) = 0;
      }
    }
LABEL_100:
    int v53 = (v51 == 5) & v45;
    goto LABEL_87;
  }
  uint64_t v52 = *(void *)(v46 - 64);
  if (!v52) {
    goto LABEL_86;
  }
  *unint64_t v59 = v52;
  uint64_t v19 = *(void *)(v46 - 32);
  if (!v19) {
    goto LABEL_86;
  }
LABEL_85:
  *unint64_t v60 = v19;
  int v53 = 1;
LABEL_87:
  if (v57 < 0x41 || !v56)
  {
    if (v53) {
      goto LABEL_92;
    }
    return 0;
  }
  MEMORY[0x1D25D9CB0](v56, 0x1000C8000313F17);
  if ((v53 & 1) == 0) {
    return 0;
  }
LABEL_92:
  if (*a4 != v61) {
    return 0;
  }
  return 149;
}

BOOL sub_1CBF52FC4@<W0>(void **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v4 = *(unsigned __int8 *)(a2 + 16);
  if (v4 == 54)
  {
    uint64_t v5 = *(void *)(a2 - 64);
    if (v5)
    {
      uint64_t v6 = (llvm::APInt *)(a1 + 1);
      **a1 = v5;
      uint64_t v7 = *(void *)(a2 - 32);
      int v8 = *(unsigned __int8 *)(v7 + 16);
      if (v8 == 5)
      {
        if (*(_WORD *)(v7 + 18) != 15) {
          return 0;
        }
        BOOL result = sub_1CBF531E4(v6, *(llvm::Constant **)(v7 - 32 * (*(_DWORD *)(v7 + 20) & 0x7FFFFFF)));
        if (!result) {
          return result;
        }
        uint64_t v10 = *(void *)(v7 - 32 * (*(_DWORD *)(v7 + 20) & 0x7FFFFFF) + 32);
        if (!v10) {
          return 0;
        }
      }
      else
      {
        if (v8 != 43) {
          return 0;
        }
        BOOL result = sub_1CBF53154(v6, *(unsigned __int8 **)(v7 - 64));
        if (!result) {
          return result;
        }
        uint64_t v10 = *(void *)(v7 - 32);
        if (!v10) {
          return 0;
        }
      }
      *a1[3] = v10;
      return 1;
    }
    return 0;
  }
  if (v4 == 5)
  {
    if (*(_WORD *)(a2 + 18) != 26) {
      goto LABEL_25;
    }
    a3 = *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF));
    if (a3)
    {
      uint64_t v11 = (llvm::APInt *)(a1 + 1);
      **a1 = a3;
      uint64_t v12 = *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 32);
      int v13 = *(unsigned __int8 *)(v12 + 16);
      if (v13 != 5)
      {
        if (v13 == 43 && sub_1CBF53154(v11, *(unsigned __int8 **)(v12 - 64)))
        {
          a3 = *(void *)(v12 - 32);
          if (!a3) {
            return (v4 == 5) & a3;
          }
          goto LABEL_24;
        }
LABEL_25:
        LOBYTE(a3) = 0;
        return (v4 == 5) & a3;
      }
      if (*(_WORD *)(v12 + 18) != 15
        || !sub_1CBF531E4(v11, *(llvm::Constant **)(v12 - 32 * (*(_DWORD *)(v12 + 20) & 0x7FFFFFF))))
      {
        goto LABEL_25;
      }
      a3 = *(void *)(v12 - 32 * (*(_DWORD *)(v12 + 20) & 0x7FFFFFF) + 32);
      if (a3)
      {
LABEL_24:
        *a1[3] = a3;
        LOBYTE(a3) = 1;
      }
    }
  }
  return (v4 == 5) & a3;
}

BOOL sub_1CBF53154(llvm::APInt *this, unsigned __int8 *a2)
{
  unsigned int v3 = a2[16];
  if (!a2 || v3 != 16)
  {
    if (v3 > 0x14 || (*(_DWORD *)(*(void *)a2 + 8) & 0xFE) != 18) {
      return 0;
    }
    SplatValue = (unsigned __int8 *)llvm::Constant::getSplatValue((llvm::Constant *)a2, 0);
    if (!SplatValue) {
      return 0;
    }
    a2 = SplatValue;
    if (SplatValue[16] != 16) {
      return 0;
    }
  }

  return sub_1CBF53278((uint64_t)(a2 + 24), this);
}

BOOL sub_1CBF531E4(llvm::APInt *this, llvm::Constant *a2)
{
  int v2 = this;
  if (!a2 || *((unsigned char *)a2 + 16) != 16)
  {
    if ((*(_DWORD *)(*(void *)a2 + 8) & 0xFE) != 0x12) {
      return 0;
    }
    SplatValue = (llvm::Constant *)llvm::Constant::getSplatValue(a2, 0);
    int v2 = this;
    if (!SplatValue) {
      return 0;
    }
    a2 = SplatValue;
    if (*((unsigned char *)SplatValue + 16) != 16) {
      return 0;
    }
  }

  return sub_1CBF53278((uint64_t)a2 + 24, v2);
}

BOOL sub_1CBF53278(uint64_t a1, llvm::APInt *this)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  unsigned int v5 = *((_DWORD *)this + 2);
  if (v4 == v5)
  {
    if (v4 > 0x40) {
      return memcmp(*(const void **)a1, *(const void **)this, ((unint64_t)(v4 + 63) >> 3) & 0x3FFFFFF8) == 0;
    }
    uint64_t v6 = *(const void **)a1;
    return v6 == *(const void **)this;
  }
  if (v4 <= v5)
  {
    if (v5 > 0x40) {
      operator new[]();
    }
    if (v5) {
      unint64_t v10 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v5;
    }
    else {
      unint64_t v10 = 0;
    }
    uint64_t v6 = (const void *)(v10 & *(void *)a1);
    return v6 == *(const void **)this;
  }
  llvm::APInt::zext((uint64_t *)this, v4, (uint64_t)&__s2);
  uint64_t v11 = *(unsigned int *)(a1 + 8);
  if (v11 > 0x40)
  {
    int v15 = *(const void **)a1;
    int v13 = __s2;
    BOOL v14 = memcmp(v15, __s2, ((unint64_t)(v11 + 63) >> 3) & 0x3FFFFFF8) == 0;
  }
  else
  {
    uint64_t v12 = *(void **)a1;
    int v13 = __s2;
    BOOL v14 = v12 == __s2;
  }
  uint64_t v8 = v14;
  if (v17 >= 0x41 && v13) {
    MEMORY[0x1D25D9CB0](v13, 0x1000C8000313F17);
  }
  return v8;
}

BOOL sub_1CBF53434@<W0>(void **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v4 = *(unsigned __int8 *)(a2 + 16);
  if (v4 == 53)
  {
    uint64_t v5 = *(void *)(a2 - 64);
    if (v5)
    {
      uint64_t v6 = (llvm::APInt *)(a1 + 1);
      **a1 = v5;
      uint64_t v7 = *(void *)(a2 - 32);
      int v8 = *(unsigned __int8 *)(v7 + 16);
      if (v8 == 5)
      {
        if (*(_WORD *)(v7 + 18) != 15) {
          return 0;
        }
        BOOL result = sub_1CBF531E4(v6, *(llvm::Constant **)(v7 - 32 * (*(_DWORD *)(v7 + 20) & 0x7FFFFFF)));
        if (!result) {
          return result;
        }
        uint64_t v10 = *(void *)(v7 - 32 * (*(_DWORD *)(v7 + 20) & 0x7FFFFFF) + 32);
        if (!v10) {
          return 0;
        }
      }
      else
      {
        if (v8 != 43) {
          return 0;
        }
        BOOL result = sub_1CBF53154(v6, *(unsigned __int8 **)(v7 - 64));
        if (!result) {
          return result;
        }
        uint64_t v10 = *(void *)(v7 - 32);
        if (!v10) {
          return 0;
        }
      }
      *a1[3] = v10;
      return 1;
    }
    return 0;
  }
  if (v4 == 5)
  {
    if (*(_WORD *)(a2 + 18) != 25) {
      goto LABEL_25;
    }
    a3 = *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF));
    if (a3)
    {
      uint64_t v11 = (llvm::APInt *)(a1 + 1);
      **a1 = a3;
      uint64_t v12 = *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 32);
      int v13 = *(unsigned __int8 *)(v12 + 16);
      if (v13 != 5)
      {
        if (v13 == 43 && sub_1CBF53154(v11, *(unsigned __int8 **)(v12 - 64)))
        {
          a3 = *(void *)(v12 - 32);
          if (!a3) {
            return (v4 == 5) & a3;
          }
          goto LABEL_24;
        }
LABEL_25:
        LOBYTE(a3) = 0;
        return (v4 == 5) & a3;
      }
      if (*(_WORD *)(v12 + 18) != 15
        || !sub_1CBF531E4(v11, *(llvm::Constant **)(v12 - 32 * (*(_DWORD *)(v12 + 20) & 0x7FFFFFF))))
      {
        goto LABEL_25;
      }
      a3 = *(void *)(v12 - 32 * (*(_DWORD *)(v12 + 20) & 0x7FFFFFF) + 32);
      if (a3)
      {
LABEL_24:
        *a1[3] = a3;
        LOBYTE(a3) = 1;
      }
    }
  }
  return (v4 == 5) & a3;
}

uint64_t sub_1CBF535C4(uint64_t a1, llvm::Constant *a2)
{
  unsigned int v4 = *((unsigned __int8 *)a2 + 16);
  if (a2 && v4 == 16)
  {
    uint64_t v5 = *((unsigned int *)a2 + 8);
    if (v5 > 0x40)
    {
      int v14 = 0;
      int64_t v15 = (unint64_t)(v5 + 63) >> 6;
      do
      {
        BOOL v9 = v15-- < 1;
        if (v9) {
          break;
        }
        unint64_t v16 = *(void *)(*((void *)a2 + 3) + 8 * v15);
        v14 += __clz(v16);
      }
      while (!v16);
      int v17 = v5 | 0xFFFFFFC0;
      if ((v5 & 0x3F) == 0) {
        int v17 = 0;
      }
      return v14 + v17 == v5;
    }
    else
    {
      return *((void *)a2 + 3) == 0;
    }
  }
  else
  {
    uint64_t v7 = *(void *)a2;
    if (*(void *)a2) {
      BOOL v8 = (*(_DWORD *)(*(void *)a2 + 8) & 0xFE) == 18;
    }
    else {
      BOOL v8 = 0;
    }
    BOOL v9 = !v8 || v4 > 0x14;
    int v10 = v9;
    if (!v9)
    {
      SplatValue = llvm::Constant::getSplatValue(a2, 0);
      if (SplatValue && *((unsigned char *)SplatValue + 16) == 16)
      {
        uint64_t v12 = *((unsigned int *)SplatValue + 8);
        if (v12 > 0x40)
        {
          int v28 = 0;
          int64_t v29 = (unint64_t)(v12 + 63) >> 6;
          do
          {
            BOOL v9 = v29-- < 1;
            if (v9) {
              break;
            }
            unint64_t v30 = *(void *)(SplatValue[3] + 8 * v29);
            v28 += __clz(v30);
          }
          while (!v30);
          int v31 = v12 | 0xFFFFFFC0;
          if ((v12 & 0x3F) == 0) {
            int v31 = 0;
          }
          BOOL v13 = v28 + v31 == v12;
        }
        else
        {
          BOOL v13 = SplatValue[3] == 0;
        }
        int v2 = v13;
      }
      else
      {
        if (*(unsigned char *)(v7 + 8) == 18)
        {
          int v19 = *(_DWORD *)(v7 + 32);
          if (v19)
          {
            int v20 = 0;
            int v2 = 0;
            while (1)
            {
              AggregateElement = llvm::Constant::getAggregateElement(a2, v20);
              if (!AggregateElement) {
                break;
              }
              int v22 = *((unsigned __int8 *)AggregateElement + 16);
              if ((v22 - 11) >= 2)
              {
                if (v22 != 16) {
                  break;
                }
                uint64_t v23 = *((unsigned int *)AggregateElement + 8);
                if (v23 > 0x40)
                {
                  int v24 = 0;
                  int64_t v25 = (unint64_t)(v23 + 63) >> 6;
                  do
                  {
                    BOOL v9 = v25-- < 1;
                    if (v9) {
                      break;
                    }
                    unint64_t v26 = *(void *)(AggregateElement[3] + 8 * v25);
                    v24 += __clz(v26);
                  }
                  while (!v26);
                  int v27 = v23 | 0xFFFFFFC0;
                  if ((v23 & 0x3F) == 0) {
                    int v27 = 0;
                  }
                  if (v24 + v27 != v23) {
                    break;
                  }
                }
                else if (AggregateElement[3])
                {
                  break;
                }
                int v2 = 1;
              }
              int v20 = (llvm::Type *)(v20 + 1);
              if (v20 == v19) {
                return (v10 ^ 1) & v2;
              }
            }
          }
        }
        int v2 = 0;
      }
    }
    return (v10 ^ 1) & v2;
  }
}

uint64_t sub_1CBF537B4(uint64_t a1, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = **a2;
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x200000000;
  *(void *)(a1 + 64) = v7;
  *(void *)(a1 + 72) = a1 + 120;
  *(void *)(a1 + 80) = a1 + 128;
  *(void *)(a1 + 88) = a4;
  *(_DWORD *)(a1 + 96) = 0;
  *(_WORD *)(a1 + 100) = 512;
  *(unsigned char *)(a1 + 102) = 7;
  *(void *)(a1 + 104) = a5;
  *(void *)(a1 + 112) = a6;
  *(void *)(a1 + ++*(_DWORD *)(result + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 120) = &unk_1F2616E88;
  *(void *)(a1 + 128) = &unk_1F2617008;
  sub_1CBF5385C(a1, (uint64_t)a2, a3);
  return a1;
}

uint64_t sub_1CBF5385C(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + ++*(_DWORD *)(result + 48) = a2;
  *(void *)(result + 56) = a3;
  if (a2 + 40 != a3)
  {
    uint64_t v4 = result;
    uint64_t v5 = 0;
    if (a3) {
      uint64_t v6 = a3 - 24;
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = *(unsigned __int8 **)(v6 + 48);
    uint64_t v12 = v7;
    if (v7)
    {
      llvm::MetadataTracking::track((uint64_t)&v12, v7, 2);
      uint64_t v5 = (uint64_t)v12;
    }
    BOOL result = sub_1CB8461A4(v4, 0, v5);
    if (v12)
    {
      int v8 = *v12;
      if ((v8 - 4) > 0x1E)
      {
        if ((v8 - 3) >= 0xFFFFFFFE) {
          uint64_t v11 = v12;
        }
        else {
          uint64_t v11 = 0;
        }
        if ((v8 - 3) < 0xFFFFFFFE)
        {
          if (v8 == 3) {
            *((void *)v12 + 1) = 0;
          }
          return result;
        }
        unint64_t v10 = (unint64_t)(v11 + 8);
      }
      else
      {
        if ((v12[1] & 0x7F) != 2 && !*((_DWORD *)v12 + 3)) {
          return result;
        }
        uint64_t v9 = *((void *)v12 + 2);
        if ((v9 & 4) == 0) {
          return result;
        }
        unint64_t v10 = v9 & 0xFFFFFFFFFFFFFFF8;
        if (!v10) {
          return result;
        }
      }
      BOOL v13 = &v12;
      return sub_1CC5FA668(v10 + 16, &v13);
    }
  }
  return result;
}

BOOL sub_1CBF53954@<W0>(void **a1@<X0>, uint64_t a2@<X1>, char a3@<W8>)
{
  int v5 = *(unsigned __int8 *)(a2 + 16);
  if (v5 == 56)
  {
    uint64_t v6 = *(void *)(a2 - 64);
    int v7 = *(unsigned __int8 *)(v6 + 16);
    if (v7 == 5)
    {
      if (*(_WORD *)(v6 + 18) != 26) {
        return 0;
      }
      uint64_t v10 = v6 - 32 * (*(_DWORD *)(v6 + 20) & 0x7FFFFFF);
      if (**a1 != *(void *)v10 || !sub_1CBF531E4((llvm::APInt *)(a1 + 1), *(llvm::Constant **)(v10 + 32))) {
        return 0;
      }
    }
    else if (v7 != 54 {
           || **a1 != *(void *)(v6 - 64)
    }
           || !sub_1CBF53154((llvm::APInt *)(a1 + 1), *(unsigned __int8 **)(v6 - 32)))
    {
      return 0;
    }
    return sub_1CBF53154((llvm::APInt *)(a1 + 3), *(unsigned __int8 **)(a2 - 32));
  }
  if (v5 == 5)
  {
    if (*(_WORD *)(a2 + 18) != 28) {
      goto LABEL_25;
    }
    uint64_t v8 = *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF));
    int v9 = *(unsigned __int8 *)(v8 + 16);
    if (v9 == 5)
    {
      if (*(_WORD *)(v8 + 18) != 26) {
        goto LABEL_25;
      }
      uint64_t v12 = v8 - 32 * (*(_DWORD *)(v8 + 20) & 0x7FFFFFF);
      if (**a1 != *(void *)v12 || !sub_1CBF531E4((llvm::APInt *)(a1 + 1), *(llvm::Constant **)(v12 + 32))) {
        goto LABEL_25;
      }
    }
    else if (v9 != 54 {
           || **a1 != *(void *)(v8 - 64)
    }
           || !sub_1CBF53154((llvm::APInt *)(a1 + 1), *(unsigned __int8 **)(v8 - 32)))
    {
      goto LABEL_25;
    }
    if (!sub_1CBF531E4((llvm::APInt *)(a1 + 3), *(llvm::Constant **)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 32)))
    {
LABEL_25:
      a3 = 0;
      return (v5 == 5) & a3;
    }
    a3 = 1;
  }
  return (v5 == 5) & a3;
}

void sub_1CBF53AF8()
{
}

void sub_1CBF53B38(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBF53B70(llvm::PassRegistry *a1, uint64_t a2)
{
  uint64_t v3 = a2 + 112;
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::AssumptionCacheTracker::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::TargetLibraryInfoWrapperPass::ID);
  sub_1CB843600(a2, v3, (uint64_t)&llvm::AAResultsWrapperPass::ID);
  sub_1CB843600(a2, v3, (uint64_t)&llvm::BasicAAWrapperPass::ID);
  sub_1CB843600(a2, v3, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);

  sub_1CB843600(a2, v3, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);
}

void sub_1CBF53C68(uint64_t a1, llvm::Function *a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_4:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::AssumptionCacheTracker::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_4;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = (llvm::AssumptionCacheTracker *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::AssumptionCacheTracker::ID);
  llvm::AssumptionCacheTracker::getAssumptionCache(v8, a2);
  int v9 = *(uint64_t **)(a1 + 8);
  uint64_t v10 = *v9;
  uint64_t v11 = v9[1];
  if (v10 == v11)
  {
LABEL_9:
    uint64_t v12 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v10 != &llvm::TargetLibraryInfoWrapperPass::ID)
    {
      v10 += 16;
      if (v10 == v11) {
        goto LABEL_9;
      }
    }
    uint64_t v12 = *(void *)(v10 + 8);
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v12 + 96))(v12, &llvm::TargetLibraryInfoWrapperPass::ID);
  uint64_t v14 = v13 + 32;
  if (!*(unsigned char *)(v13 + 232))
  {
    uint64_t v15 = *((void *)a2 + 5) + 216;
    __int16 v18 = 260;
    v17[0] = v15;
    llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v17);
    uint64_t v28 = 0;
    uint64_t v29 = 0;
    int v30 = 0;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    *(void *)&long long v16 = -1;
    *((void *)&v16 + 1) = -1;
    *(_OWORD *)__src = v16;
    long long v22 = v16;
    long long v23 = v16;
    long long v24 = v16;
    long long v25 = v16;
    long long v26 = v16;
    *(_OWORD *)int v27 = v16;
    *(void *)&v27[13] = -1;
    sub_1CC153974((uint64_t)__src, (int *)__p);
    sub_1CD4D04B8(v14, (uint64_t)__src);
    sub_1CD4CFA4C((uint64_t *)__src);
    if (v20 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_1CC1569E8(__src, v14);
}

void sub_1CBF5408C(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        uint64_t v5 = (uint64_t *)v3[1];
        uint64_t v6 = v3[3];
        v3[3] = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
        }
        operator delete(v3);
        uint64_t v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

unsigned int *sub_1CBF54128(unsigned int *result)
{
  uint64_t v1 = result[4];
  if (v1)
  {
    uint64_t v2 = 16 * v1;
    uint64_t v3 = (unsigned int **)(*(void *)result + 8);
    do
    {
      if (((unint64_t)*(v3 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        BOOL result = *v3;
        *uint64_t v3 = 0;
        if (result) {
          BOOL result = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 8))(result);
        }
      }
      v3 += 2;
      v2 -= 16;
    }
    while (v2);
  }
  return result;
}

void sub_1CBF541A4(llvm::SmallPtrSetImplBase *this, uint64_t a2)
{
  uint64_t v5 = *(void **)this;
  uint64_t v4 = (void *)*((void *)this + 1);
  if (*((_DWORD *)this + 17) != *((_DWORD *)this + 18)) {
    goto LABEL_11;
  }
  if (v4 == v5)
  {
    uint64_t v6 = *((unsigned int *)this + 5);
    uint64_t v7 = (void **)&v4[v6];
    if (v6)
    {
      unint64_t v8 = 0;
      uint64_t v9 = 8 * v6;
      while ((_UNKNOWN *)v4[v8 / 8] != &llvm::PreservedAnalyses::AllAnalysesKey)
      {
        v8 += 8;
        if (v9 == v8) {
          goto LABEL_7;
        }
      }
      uint64_t v7 = (void **)&v4[v8 / 8];
    }
LABEL_7:
    uint64_t v5 = (void *)*((void *)this + 1);
  }
  else
  {
    uint64_t v24 = *((unsigned int *)this + 4);
    int v25 = v24 - 1;
    unsigned int v26 = (v24 - 1) & ((&llvm::PreservedAnalyses::AllAnalysesKey >> 4) ^ (&llvm::PreservedAnalyses::AllAnalysesKey >> 9));
    uint64_t v7 = (void **)&v4[v26];
    int v27 = *v7;
    if (*v7 == (void *)-1)
    {
      uint64_t v28 = 0;
LABEL_57:
      if (v28) {
        uint64_t v7 = v28;
      }
      if (*v7 != &llvm::PreservedAnalyses::AllAnalysesKey) {
        uint64_t v7 = (void **)&v4[v24];
      }
    }
    else
    {
      uint64_t v28 = 0;
      int v29 = 1;
      while (v27 != &llvm::PreservedAnalyses::AllAnalysesKey)
      {
        if (v28) {
          BOOL v30 = 0;
        }
        else {
          BOOL v30 = v27 == (void *)-2;
        }
        if (v30) {
          uint64_t v28 = v7;
        }
        unsigned int v31 = v26 + v29++;
        unsigned int v26 = v31 & v25;
        uint64_t v7 = (void **)&v4[v31 & v25];
        int v27 = *v7;
        if (*v7 == (void *)-1) {
          goto LABEL_57;
        }
      }
    }
  }
  uint64_t v10 = 16;
  if (v4 == v5) {
    uint64_t v10 = 20;
  }
  if (v7 == &v4[*(unsigned int *)((char *)this + v10)])
  {
LABEL_11:
    uint64_t v11 = *((unsigned int *)this + 5);
    if (v4 == v5)
    {
      if (v11)
      {
        uint64_t v12 = 0;
        uint64_t v13 = 8 * v11;
        uint64_t v14 = v4;
        while (*v14 != a2)
        {
          if (*v14 == -2) {
            uint64_t v12 = v14;
          }
          ++v14;
          v13 -= 8;
          if (!v13)
          {
            if (!v12) {
              goto LABEL_19;
            }
            *uint64_t v12 = a2;
            --*((_DWORD *)this + 6);
            return;
          }
        }
        return;
      }
LABEL_19:
      unsigned int v15 = *((_DWORD *)this + 4);
      if (v11 < v15)
      {
        *((_DWORD *)this + 5) = v11 + 1;
        v4[v11] = a2;
        return;
      }
    }
    else
    {
      unsigned int v15 = *((_DWORD *)this + 4);
    }
    if (3 * v15 <= 4 * ((int)v11 - *((_DWORD *)this + 6)))
    {
      if (v15 >= 0x40) {
        v15 *= 2;
      }
      else {
        unsigned int v15 = 128;
      }
    }
    else if (v15 - v11 >= v15 >> 3)
    {
      goto LABEL_25;
    }
    llvm::SmallPtrSetImplBase::Grow(this, v15);
    unsigned int v15 = *((_DWORD *)this + 4);
    uint64_t v4 = (void *)*((void *)this + 1);
LABEL_25:
    unsigned int v16 = v15 - 1;
    unsigned int v17 = (v15 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    __int16 v18 = &v4[v17];
    uint64_t v19 = *v18;
    if (*v18 == -1)
    {
      char v20 = 0;
LABEL_49:
      if (v20) {
        long long v32 = v20;
      }
      else {
        long long v32 = v18;
      }
      if (*v32 != a2)
      {
        if (*v32 == -2) {
          --*((_DWORD *)this + 6);
        }
        else {
          ++*((_DWORD *)this + 5);
        }
        *long long v32 = a2;
      }
    }
    else
    {
      char v20 = 0;
      int v21 = 1;
      while (v19 != a2)
      {
        if (v20) {
          BOOL v22 = 0;
        }
        else {
          BOOL v22 = v19 == -2;
        }
        if (v22) {
          char v20 = v18;
        }
        unsigned int v23 = v17 + v21++;
        unsigned int v17 = v23 & v16;
        __int16 v18 = &v4[v23 & v16];
        uint64_t v19 = *v18;
        if (*v18 == -1) {
          goto LABEL_49;
        }
      }
    }
  }
}

uint64_t llvm::TruncInstCombine::buildTruncExpressionGraph(llvm::TruncInstCombine *this)
{
  v29[8] = *MEMORY[0x1E4F143B8];
  int v27 = v29;
  uint64_t v28 = 0x800000000;
  uint64_t v24 = v26;
  uint64_t v25 = 0x800000000;
  uint64_t v2 = (char *)this + 88;
  sub_1CBF568A4((_DWORD *)this + 22);
  *((void *)this + 15) = *((void *)this + 14);
  if (v28 >= HIDWORD(v28)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((void *)v27 + v28) = *(void *)(*((void *)this + 10) - 32);
  BOOL v3 = __CFADD__(v28, 1);
  unsigned int v4 = v28 + 1;
  LODWORD(v28) = v28 + 1;
  if (v3)
  {
LABEL_4:
    uint64_t v5 = 1;
    goto LABEL_5;
  }
  while (1)
  {
    uint64_t v7 = (unsigned __int8 *)*((void *)v27 + v4 - 1);
    unsigned int v8 = v7[16];
    if (v8 <= 0x14) {
      goto LABEL_22;
    }
    if (v8 < 0x1C) {
      break;
    }
    if (v25 && *((unsigned __int8 **)v24 + v25 - 1) == v7)
    {
      LODWORD(v28) = v4 - 1;
      LODWORD(v25) = v25 - 1;
      __src = v7;
      long long v23 = 0uLL;
      sub_1CD456E50((uint64_t)v2, (uint64_t *)&__src, &v23);
LABEL_46:
      unsigned int v4 = v28;
      goto LABEL_23;
    }
    uint64_t v9 = *((void *)this + 11);
    uint64_t v10 = *((unsigned int *)this + 26);
    if (v10)
    {
      LODWORD(v11) = (v10 - 1) & ((v7 >> 4) ^ (v7 >> 9));
      uint64_t v12 = (unsigned __int8 **)(v9 + 16 * v11);
      uint64_t v13 = *v12;
      if (v7 == *v12) {
        goto LABEL_21;
      }
      int v14 = 1;
      while (v13 != (unsigned __int8 *)-4096)
      {
        int v15 = v11 + v14++;
        uint64_t v11 = v15 & (v10 - 1);
        uint64_t v13 = *(unsigned __int8 **)(v9 + 16 * v11);
        if (v7 == v13)
        {
          uint64_t v12 = (unsigned __int8 **)(v9 + 16 * v11);
          goto LABEL_21;
        }
      }
    }
    uint64_t v12 = (unsigned __int8 **)(v9 + 16 * v10);
LABEL_21:
    if (v12 == (unsigned __int8 **)(v9 + 16 * v10))
    {
      if (v25 >= HIDWORD(v25)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v5 = 0;
      *((void *)v24 + v25) = v7;
      LODWORD(v25) = v25 + 1;
      uint64_t v16 = v7[16] - 41;
      if (v16 > 0x31) {
        goto LABEL_5;
      }
      if (((1 << (v7[16] - 41)) & 0xE000000) == 0)
      {
        if (v16 == 42)
        {
          __src = (char *)&v23 + 8;
          *(void *)&long long v23 = 0x200000000;
          sub_1CBF547D8((uint64_t)v7, (uint64_t)&__src);
          unsigned int v17 = (char *)__src;
          __int16 v18 = (char *)__src + 8 * v23;
          if (v23)
          {
            do
            {
              uint64_t v19 = *(void *)v17;
              if (v25)
              {
                char v20 = v24;
                uint64_t v21 = 8 * v25;
                while (*v20 != v19)
                {
                  ++v20;
                  v21 -= 8;
                  if (!v21) {
                    goto LABEL_34;
                  }
                }
              }
              else
              {
LABEL_34:
                if (v28 >= (unint64_t)HIDWORD(v28)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *((void *)v27 + v28) = v19;
                LODWORD(v28) = v28 + 1;
              }
              v17 += 8;
            }
            while (v17 != v18);
            unsigned int v17 = (char *)__src;
          }
          if (v17 != (char *)&v23 + 8) {
            free(v17);
          }
        }
        else
        {
          if (((1 << (v7[16] - 41)) & 0x310000003F255) == 0) {
            goto LABEL_5;
          }
          __src = (char *)&v23 + 8;
          *(void *)&long long v23 = 0x200000000;
          sub_1CBF547D8((uint64_t)v7, (uint64_t)&__src);
          sub_1CD456F08((unsigned int *)&v27, (uint64_t)v27 + 8 * v28, (uint64_t *)__src, (uint64_t *)__src + v23);
          if (__src != (char *)&v23 + 8) {
            free(__src);
          }
        }
      }
      goto LABEL_46;
    }
LABEL_22:
    LODWORD(v28) = --v4;
LABEL_23:
    if (!v4) {
      goto LABEL_4;
    }
  }
  uint64_t v5 = 0;
LABEL_5:
  if (v24 != v26) {
    free(v24);
  }
  if (v27 != v29) {
    free(v27);
  }
  return v5;
}

uint64_t sub_1CBF547D8(uint64_t result, uint64_t a2)
{
  if (*(unsigned __int8 *)(result + 16) > 0x34u && *(unsigned __int8 *)(result + 16) - 53 >= 6)
  {
    switch(*(unsigned char *)(result + 16))
    {
      case 'S':
        int v2 = *(_DWORD *)(result + 20);
        if ((v2 & 0x40000000) != 0)
        {
          unsigned int v4 = *(void **)(result - 8);
          uint64_t v3 = v2 & 0x7FFFFFF;
        }
        else
        {
          uint64_t v3 = v2 & 0x7FFFFFF;
          unsigned int v4 = (void *)(result - 32 * v3);
        }
        if (v3)
        {
          unsigned int v17 = *(_DWORD *)(a2 + 8);
          uint64_t v18 = 32 * v3;
          do
          {
            if (v17 >= *(_DWORD *)(a2 + 12)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)a2 + 8 * v17) = *v4;
            unsigned int v17 = *(_DWORD *)(a2 + 8) + 1;
            *(_DWORD *)(a2 + 8) = v17;
            v4 += 4;
            v18 -= 32;
          }
          while (v18);
        }
        return result;
      case 'T':
      case 'V':
      case 'W':
      case 'X':
        __break(1u);
        JUMPOUT(0x1CBF54A34);
      case 'U':
        int v15 = *(_DWORD *)(result + 20);
        if ((v15 & 0x40000000) != 0) {
          uint64_t v16 = *(void *)(result - 8);
        }
        else {
          uint64_t v16 = result - 32 * (v15 & 0x7FFFFFF);
        }
        uint64_t v19 = *(void *)(v16 + 32);
        unsigned int v20 = *(_DWORD *)(a2 + 8);
        if (v20 >= *(_DWORD *)(a2 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a2 + 8 * v20) = v19;
        unsigned int v9 = *(_DWORD *)(a2 + 8) + 1;
        *(_DWORD *)(a2 + 8) = v9;
        int v21 = *(_DWORD *)(result + 20);
        if ((v21 & 0x40000000) != 0) {
          uint64_t v22 = *(void *)(result - 8);
        }
        else {
          uint64_t v22 = result - 32 * (v21 & 0x7FFFFFF);
        }
        uint64_t v12 = *(void *)(v22 + 64);
        goto LABEL_14;
      case 'Y':
        int v13 = *(_DWORD *)(result + 20);
        if ((v13 & 0x40000000) != 0) {
          int v14 = *(uint64_t **)(result - 8);
        }
        else {
          int v14 = (uint64_t *)(result - 32 * (v13 & 0x7FFFFFF));
        }
        uint64_t v12 = *v14;
        unsigned int v9 = *(_DWORD *)(a2 + 8);
        goto LABEL_14;
      case 'Z':
        break;
      default:
        return result;
    }
  }
  int v5 = *(_DWORD *)(result + 20);
  if ((v5 & 0x40000000) != 0) {
    uint64_t v6 = *(uint64_t **)(result - 8);
  }
  else {
    uint64_t v6 = (uint64_t *)(result - 32 * (v5 & 0x7FFFFFF));
  }
  uint64_t v7 = *v6;
  unsigned int v8 = *(_DWORD *)(a2 + 8);
  if (v8 >= *(_DWORD *)(a2 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)a2 + 8 * v8) = v7;
  unsigned int v9 = *(_DWORD *)(a2 + 8) + 1;
  *(_DWORD *)(a2 + 8) = v9;
  int v10 = *(_DWORD *)(result + 20);
  if ((v10 & 0x40000000) != 0) {
    uint64_t v11 = *(void *)(result - 8);
  }
  else {
    uint64_t v11 = result - 32 * (v10 & 0x7FFFFFF);
  }
  uint64_t v12 = *(void *)(v11 + 32);
LABEL_14:
  if (v9 >= *(_DWORD *)(a2 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)a2 + 8 * v9) = v12;
  ++*(_DWORD *)(a2 + 8);
  return result;
}

unint64_t llvm::TruncInstCombine::getMinBitWidth(llvm::TruncInstCombine *this)
{
  v55[8] = *MEMORY[0x1E4F143B8];
  int v53 = v55;
  uint64_t v54 = 0x800000000;
  uint64_t v50 = v52;
  uint64_t v51 = 0x800000000;
  int v2 = (llvm::Type **)*((void *)this + 10);
  uint64_t v3 = (unsigned __int8 *)*(v2 - 4);
  unsigned int v4 = *v2;
  int v5 = *v2;
  if ((*((_DWORD *)*v2 + 2) & 0xFE) == 0x12) {
    int v5 = (llvm::Type *)**((void **)v4 + 2);
  }
  unint64_t PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits(v5);
  uint64_t v7 = *(llvm::Type **)v3;
  if ((*(_DWORD *)(*(void *)v3 + 8) & 0xFE) == 0x12) {
    uint64_t v7 = (llvm::Type *)**((void **)v7 + 2);
  }
  unint64_t v8 = llvm::Type::getPrimitiveSizeInBits(v7);
  if (v3[16] >= 0x15u)
  {
    unint64_t v9 = v8;
    v55[0] = v3;
    LODWORD(v54) = 1;
    uint64_t v44 = this;
    uint64_t v11 = (char *)this + 88;
    uint64_t v47 = v3;
    *(_DWORD *)sub_1CD456CF4((uint64_t)this + 88, (uint64_t *)&v47) = PrimitiveSizeInBits;
    for (unsigned int i = v54; v54; unsigned int i = v54)
    {
      while (1)
      {
        uint64_t v20 = *((void *)v53 + i - 1);
        if (*(unsigned __int8 *)(v20 + 16) > 0x14u) {
          break;
        }
        LODWORD(v54) = --i;
        if (!i) {
          goto LABEL_13;
        }
      }
      uint64_t v46 = *((void *)v53 + i - 1);
      int v21 = (unsigned int *)sub_1CD456CF4((uint64_t)v11, &v46);
      uint64_t v47 = v49;
      uint64_t v48 = 0x200000000;
      sub_1CBF547D8(v20, (uint64_t)&v47);
      if (v51 && *((void *)v50 + v51 - 1) == v20)
      {
        LODWORD(v54) = v54 - 1;
        LODWORD(v51) = v51 - 1;
        if (v48)
        {
          int v27 = (uint64_t *)v47;
          uint64_t v28 = 8 * v48;
          do
          {
            uint64_t v29 = *v27;
            if (*(unsigned __int8 *)(*v27 + 16) <= 0x1Bu) {
              uint64_t v29 = 0;
            }
            uint64_t v45 = v29;
            if (v29)
            {
              uint64_t v30 = sub_1CD456CF4((uint64_t)v11, &v45);
              unsigned int v31 = v21[1];
              if (v31 <= *(_DWORD *)(v30 + 4)) {
                unsigned int v31 = *(_DWORD *)(v30 + 4);
              }
              v21[1] = v31;
            }
            ++v27;
            v28 -= 8;
          }
          while (v28);
        }
      }
      else
      {
        if (v51 >= HIDWORD(v51)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v50 + v51) = v20;
        LODWORD(v51) = v51 + 1;
        unsigned int v23 = *v21;
        unsigned int v22 = v21[1];
        if (v22 <= *v21) {
          unsigned int v22 = *v21;
        }
        v21[1] = v22;
        if (v48)
        {
          uint64_t v24 = (uint64_t *)v47;
          uint64_t v25 = 8 * v48;
          do
          {
            if (*(unsigned __int8 *)(*v24 + 16) <= 0x1Bu) {
              uint64_t v26 = 0;
            }
            else {
              uint64_t v26 = *v24;
            }
            uint64_t v45 = v26;
            if (v26 && v23 > sub_1CD456DCC((uint64_t)v11, v26))
            {
              *(_DWORD *)sub_1CD456CF4((uint64_t)v11, &v45) = v23;
              if (v54 >= (unint64_t)HIDWORD(v54)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v53 + v54) = v26;
              LODWORD(v54) = v54 + 1;
            }
            ++v24;
            v25 -= 8;
          }
          while (v25);
        }
      }
      if (v47 != v49) {
        free(v47);
      }
    }
LABEL_13:
    unint64_t v13 = sub_1CD456DCC((uint64_t)v11, (uint64_t)v3);
    unint64_t v15 = HIDWORD(v13);
    if (PrimitiveSizeInBits >= HIDWORD(v13))
    {
      if (HIDWORD(v13) == 1)
      {
        BOOL v32 = 0;
        BOOL v33 = 1;
      }
      else
      {
        unint64_t v34 = v13;
        uint64_t v35 = *((void *)v44 + 2);
        BOOL v36 = *(char **)(v35 + 32);
        size_t v37 = *(void *)(v35 + 40);
        uint64_t v38 = &v36[v37];
        int v39 = &v36[v37];
        if (v9 <= 0xFF)
        {
          uint64_t v40 = (char *)memchr(v36, (char)v9, v37);
          if (v40) {
            int v39 = v40;
          }
          else {
            int v39 = &v36[v37];
          }
        }
        BOOL v32 = v39 - v36 == v37;
        if (!(v34 >> 40))
        {
          int v41 = (char *)memchr(v36, (char)v15, v37);
          if (v41) {
            uint64_t v38 = v41;
          }
        }
        BOOL v33 = v38 - v36 != v37;
      }
      int v42 = (*((_DWORD *)v4 + 2) & 0xFE) == 0x12 || v32;
      if (v42 | v33) {
        unint64_t v9 = v15;
      }
      else {
        unint64_t v9 = v9;
      }
    }
    else if ((*((_DWORD *)v4 + 2) & 0xFE) != 0x12)
    {
      uint64_t v16 = *((void *)v44 + 2);
      uint64_t v17 = *(void *)(v16 + 40);
      if (v17)
      {
        uint64_t v18 = *(unsigned __int8 **)(v16 + 32);
        while (1)
        {
          uint64_t v19 = (llvm::LLVMContext *)*v18;
          if (v19 >= HIDWORD(v13)) {
            break;
          }
          ++v18;
          if (!--v17) {
            goto LABEL_7;
          }
        }
        uint64_t IntNTy = llvm::Type::getIntNTy(*(llvm::Type **)v4, v19, v14);
        if (IntNTy)
        {
          if ((*(_DWORD *)(IntNTy + 8) & 0xFE) == 0x12) {
            uint64_t IntNTy = **(void **)(IntNTy + 16);
          }
          unint64_t v9 = llvm::Type::getPrimitiveSizeInBits((llvm::Type *)IntNTy);
        }
      }
    }
  }
  else
  {
    unint64_t v9 = PrimitiveSizeInBits;
  }
LABEL_7:
  if (v50 != v52) {
    free(v50);
  }
  if (v53 != v55) {
    free(v53);
  }
  return v9;
}

uint64_t llvm::TruncInstCombine::getBestTruncatedType(llvm::IntegerType ****this)
{
  if (!llvm::TruncInstCombine::buildTruncExpressionGraph((llvm::TruncInstCombine *)this)) {
    return 0;
  }
  int v2 = this[14];
  uint64_t v3 = this[15];
  if (v2 != v3)
  {
    unint64_t v4 = 0;
    int v5 = this[14];
    while (1)
    {
      uint64_t v6 = *v5;
      uint64_t v7 = (*v5)[1];
      if (v7)
      {
        if (*((void *)v7 + 1)) {
          break;
        }
      }
      unint64_t v18 = v4;
LABEL_34:
      v5 += 3;
      unint64_t v4 = v18;
      if (v5 == v3) {
        goto LABEL_37;
      }
    }
    unsigned int v8 = *((unsigned __int8 *)v6 + 16) - 67;
    while (1)
    {
      uint64_t v9 = *((void *)v7 + 3);
      if (v9) {
        BOOL v10 = *(unsigned __int8 *)(v9 + 16) >= 0x1Cu;
      }
      else {
        BOOL v10 = 0;
      }
      if (!v10 || (llvm::IntegerType ***)v9 == this[10]) {
        goto LABEL_21;
      }
      uint64_t v11 = this[11];
      uint64_t v12 = *((unsigned int *)this + 26);
      if (v12)
      {
        LODWORD(v13) = (v12 - 1) & ((v9 >> 4) ^ (v9 >> 9));
        unsigned int v14 = &v11[2 * v13];
        unint64_t v15 = *v14;
        if ((llvm::IntegerType **)v9 == *v14) {
          goto LABEL_20;
        }
        int v16 = 1;
        while (v15 != (llvm::IntegerType **)-4096)
        {
          int v17 = v13 + v16++;
          uint64_t v13 = v17 & (v12 - 1);
          unint64_t v15 = v11[2 * v13];
          if ((llvm::IntegerType **)v9 == v15)
          {
            unsigned int v14 = &v11[2 * v13];
            goto LABEL_20;
          }
        }
      }
      unsigned int v14 = &v11[2 * v12];
LABEL_20:
      if (v14 == &v11[2 * v12])
      {
        if (v8 > 1) {
          return 0;
        }
        int v19 = *((_DWORD *)v6 + 5);
        if ((v19 & 0x40000000) != 0) {
          uint64_t v20 = (llvm::IntegerType **)*(v6 - 1);
        }
        else {
          uint64_t v20 = &v6[-4 * (v19 & 0x7FFFFFF)];
        }
        uint64_t v21 = *(void *)*v20;
        if ((*(_DWORD *)(v21 + 8) & 0xFE) == 0x12) {
          uint64_t v21 = **(void **)(v21 + 16);
        }
        unint64_t PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v21);
        unint64_t v18 = PrimitiveSizeInBits;
        if (v4)
        {
          if (v4 != PrimitiveSizeInBits) {
            return 0;
          }
        }
        goto LABEL_22;
      }
LABEL_21:
      unint64_t v18 = v4;
LABEL_22:
      uint64_t v7 = (llvm::IntegerType *)*((void *)v7 + 1);
      unint64_t v4 = v18;
      if (!v7) {
        goto LABEL_34;
      }
    }
  }
  LODWORD(v18) = 0;
LABEL_37:
  uint64_t v23 = (uint64_t)**(this[10] - 4);
  if ((*(_DWORD *)(v23 + 8) & 0xFE) == 0x12) {
    uint64_t v23 = **(void **)(v23 + 16);
  }
  unsigned int v24 = llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v23);
  unsigned int v25 = v24;
  if (v2 == v3)
  {
LABEL_164:
    MinBitWidth = (llvm::LLVMContext *)llvm::TruncInstCombine::getMinBitWidth((llvm::TruncInstCombine *)this);
    if (MinBitWidth >= v25 || v18 && v18 != MinBitWidth) {
      return 0;
    }
    return llvm::IntegerType::get(**this[10], MinBitWidth);
  }
  unsigned int v73 = v24 + 1;
  unint64_t v74 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v24;
  unint64_t v75 = v24;
  while (1)
  {
    uint64_t v26 = *v2;
    int v27 = *((unsigned __int8 *)*v2 + 16);
    if ((v27 - 53) > 2) {
      goto LABEL_90;
    }
    int v28 = *((_DWORD *)v26 + 5);
    if ((v28 & 0x40000000) != 0) {
      uint64_t v29 = (llvm::IntegerType **)*(v26 - 1);
    }
    else {
      uint64_t v29 = &v26[-4 * (v28 & 0x7FFFFFF)];
    }
    uint64_t v30 = v29[4];
    unsigned int v31 = this[10];
    if (!v31 || !v31[5])
    {
      BOOL v65 = v30 && *((unsigned __int8 *)v30 + 16) >= 0x1Cu;
      if (!v65 || (unsigned int v31 = (llvm::IntegerType ***)v30, !*((void *)v30 + 5))) {
        unsigned int v31 = 0;
      }
    }
    BOOL v32 = *this;
    BOOL v33 = this[3];
    uint64_t v86 = this[2];
    uint64_t v87 = v32;
    uint64_t v88 = v31;
    uint64_t v89 = v33;
    uint64_t v90 = 0;
    char v91 = 1;
    sub_1CC16089C((uint64_t *)v30, 0, (const llvm::DataLayout **)&v86, (uint64_t)&__src);
    LODWORD(v87) = v83;
    if (v83 > 0x40) {
      operator new[]();
    }
    unint64_t v34 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v83;
    if (!v83) {
      unint64_t v34 = 0;
    }
    unsigned int v77 = v83;
    uint64_t v76 = (void *)(v34 & ~(unint64_t)__src);
    unsigned int v81 = v25;
    if (v25 > 0x40) {
      operator new[]();
    }
    char v35 = v74;
    if (!v25) {
      char v35 = 0;
    }
    uint64_t v80 = v35 & 1;
    llvm::APInt::uadd_sat((llvm::APInt *)&v76, (const llvm::APInt *)&v80, (uint64_t)&v86);
    if (v87 < 0x41)
    {
      if ((unint64_t)v86 <= v75) {
        unsigned int v36 = v86;
      }
      else {
        unsigned int v36 = v25;
      }
      goto LABEL_57;
    }
    int v66 = 0;
    int64_t v67 = ((unint64_t)v87 + 63) >> 6;
    do
    {
      if (v67-- < 1) {
        break;
      }
      unint64_t v69 = (unint64_t)v86[v67];
      v66 += __clz(v69);
    }
    while (!v69);
    unsigned int v70 = v87 | 0xFFFFFFC0;
    if ((v87 & 0x3F) == 0) {
      unsigned int v70 = 0;
    }
    if (v87 - v66 - v70 <= 0x40)
    {
      if ((unint64_t)*v86 <= v75) {
        unsigned int v36 = *v86;
      }
      else {
        unsigned int v36 = v25;
      }
LABEL_149:
      MEMORY[0x1D25D9CB0](v86, 0x1000C8000313F17);
      goto LABEL_57;
    }
    unsigned int v36 = v25;
    if (v86) {
      goto LABEL_149;
    }
LABEL_57:
    if (v81 >= 0x41 && v80) {
      MEMORY[0x1D25D9CB0](v80, 0x1000C8000313F17);
    }
    if (v77 >= 0x41 && v76) {
      MEMORY[0x1D25D9CB0](v76, 0x1000C8000313F17);
    }
    if (v36 == v25) {
      goto LABEL_171;
    }
    int v37 = *((unsigned __int8 *)v26 + 16);
    if (v37 == 54)
    {
      int v38 = *((_DWORD *)v26 + 5);
      if ((v38 & 0x40000000) != 0) {
        int v39 = (llvm::IntegerType **)*(v26 - 1);
      }
      else {
        int v39 = &v26[-4 * (v38 & 0x7FFFFFF)];
      }
      uint64_t v40 = *v39;
      int v41 = this[10];
      if (!v41 || !v41[5])
      {
        if (!v40 || *((unsigned __int8 *)v40 + 16) < 0x1Cu || (int v41 = (llvm::IntegerType ***)v40, !*((void *)v40 + 5))) {
          int v41 = 0;
        }
      }
      int v42 = *this;
      uint64_t v43 = this[3];
      uint64_t v86 = this[2];
      uint64_t v87 = v42;
      uint64_t v88 = v41;
      uint64_t v89 = v43;
      uint64_t v90 = 0;
      char v91 = 1;
      sub_1CC16089C((uint64_t *)v40, 0, (const llvm::DataLayout **)&v86, (uint64_t)&v76);
      LODWORD(v87) = v77;
      if (v77 > 0x40) {
        operator new[]();
      }
      if (v77) {
        unint64_t v44 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v77;
      }
      else {
        unint64_t v44 = 0;
      }
      unsigned int v45 = 64 - __clz(v44 & ~(unint64_t)v76);
      if (v45 > v36) {
        unsigned int v36 = v45;
      }
      if (v79 >= 0x41 && v78) {
        MEMORY[0x1D25D9CB0](v78, 0x1000C8000313F17);
      }
      if (v77 >= 0x41 && v76) {
        MEMORY[0x1D25D9CB0](v76, 0x1000C8000313F17);
      }
      int v37 = *((unsigned __int8 *)v26 + 16);
    }
    if (v37 == 55)
    {
      int v46 = *((_DWORD *)v26 + 5);
      if ((v46 & 0x40000000) != 0) {
        uint64_t v47 = (llvm::IntegerType **)*(v26 - 1);
      }
      else {
        uint64_t v47 = &v26[-4 * (v46 & 0x7FFFFFF)];
      }
      uint64_t v48 = *v47;
      uint64_t v49 = this[10];
      if (!v49 || !v49[5])
      {
        if (!v48 || *((unsigned __int8 *)v48 + 16) < 0x1Cu || (uint64_t v49 = (llvm::IntegerType ***)v48, !*((void *)v48 + 5))) {
          uint64_t v49 = 0;
        }
      }
      uint64_t v50 = *this;
      uint64_t v51 = this[3];
      uint64_t v86 = this[2];
      uint64_t v87 = v50;
      uint64_t v88 = v49;
      uint64_t v89 = v51;
      uint64_t v90 = 0;
      char v91 = 1;
      unsigned int v52 = v73 - sub_1CC162D6C(v48, 0, (uint64_t)&v86);
      if (v36 <= v52) {
        unsigned int v36 = v52;
      }
    }
    if (v36 >= v25)
    {
LABEL_171:
      if (v85 >= 0x41 && v84) {
        MEMORY[0x1D25D9CB0](v84, 0x1000C8000313F17);
      }
      if (v83 >= 0x41 && __src) {
        MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
      }
      return 0;
    }
    *((_DWORD *)v2 + 3) = v36;
    if (v85 >= 0x41 && v84) {
      MEMORY[0x1D25D9CB0](v84, 0x1000C8000313F17);
    }
    if (v83 >= 0x41 && __src) {
      MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
    }
    int v27 = *((unsigned __int8 *)v26 + 16);
LABEL_90:
    if (v27 != 50 && v27 != 47) {
      goto LABEL_123;
    }
    int v53 = *((_DWORD *)v26 + 5);
    if ((v53 & 0x40000000) != 0)
    {
      BOOL v55 = (llvm::IntegerType ****)*(v26 - 1);
      uint64_t v54 = v53 & 0x7FFFFFF;
    }
    else
    {
      uint64_t v54 = v53 & 0x7FFFFFF;
      BOOL v55 = (llvm::IntegerType ****)&v26[-4 * v54];
    }
    unsigned int v56 = 0;
    if (v54) {
      break;
    }
LABEL_122:
    *((_DWORD *)v2 + 3) = v56;
LABEL_123:
    v2 += 3;
    if (v2 == v3) {
      goto LABEL_164;
    }
  }
  size_t v57 = &v55[4 * v54];
  while (1)
  {
    uint64_t v58 = *v55;
    unint64_t v59 = this[10];
    if (!v59 || !v59[5])
    {
      BOOL v64 = v58 && *((unsigned __int8 *)v58 + 16) >= 0x1Cu;
      if (!v64 || (unint64_t v59 = *v55, !v58[5])) {
        unint64_t v59 = 0;
      }
    }
    unint64_t v60 = *this;
    uint64_t v61 = this[3];
    uint64_t v86 = this[2];
    uint64_t v87 = v60;
    uint64_t v88 = v59;
    uint64_t v89 = v61;
    uint64_t v90 = 0;
    char v91 = 1;
    sub_1CC16089C((uint64_t *)v58, 0, (const llvm::DataLayout **)&v86, (uint64_t)&__src);
    LODWORD(v87) = v83;
    if (v83 > 0x40) {
      operator new[]();
    }
    if (v83) {
      unint64_t v62 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v83;
    }
    else {
      unint64_t v62 = 0;
    }
    unsigned int v63 = 64 - __clz(v62 & ~(unint64_t)__src);
    if (v63 > v56) {
      unsigned int v56 = v63;
    }
    if (v85 >= 0x41 && v84) {
      MEMORY[0x1D25D9CB0](v84, 0x1000C8000313F17);
    }
    if (v83 >= 0x41 && __src) {
      MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
    }
    if (v56 >= v25) {
      return 0;
    }
    v55 += 4;
    if (v55 == v57) {
      goto LABEL_122;
    }
  }
}

llvm::Value *llvm::TruncInstCombine::getReducedOperand(llvm::TruncInstCombine *this, llvm::Value *a2, uint64_t **a3)
{
  v16[9] = *MEMORY[0x1E4F143B8];
  int v5 = *(_DWORD *)(*(void *)a2 + 8);
  if (*(void *)a2) {
    BOOL v6 = (*(_DWORD *)(*(void *)a2 + 8) & 0xFE) == 18;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6)
  {
    uint64_t v7 = (llvm::Type *)*(unsigned int *)(*(void *)a2 + 32);
    if (v5 == 19) {
      llvm::ScalableVectorType::get(a3, v7);
    }
    else {
      llvm::FixedVectorType::get((llvm::FixedVectorType *)a3, v7);
    }
    a3 = (uint64_t **)v8;
  }
  if (*((unsigned __int8 *)a2 + 16) > 0x14u)
  {
    sub_1CD456DCC((uint64_t)this + 88, (uint64_t)a2);
    return (llvm::Value *)v15;
  }
  else
  {
    IntegerCast = llvm::ConstantExpr::getIntegerCast(a2, (llvm::Type ***)a3, 0);
    uint64_t v11 = *((void *)this + 1);
    BOOL v10 = (llvm::DataLayout *)*((void *)this + 2);
    v16[0] = 1;
    for (uint64_t i = 1; i != 9; i += 2)
      v16[i] = -4096;
    uint64_t v13 = sub_1CBFB8694((uint64_t)IntegerCast, v10, v11, (uint64_t)v16);
    if ((v16[0] & 1) == 0) {
      MEMORY[0x1D25D9CD0](v16[1], 8);
    }
  }
  return v13;
}

void llvm::TruncInstCombine::ReduceExpressionGraph(llvm::Value **this, uint64_t **a2)
{
  int v2 = a2;
  uint64_t v3 = this;
  v148[4] = *MEMORY[0x1E4F143B8];
  uint64_t v146 = (llvm::Value ***)v148;
  uint64_t v147 = 0x200000000;
  unint64_t v4 = this[14];
  int v5 = this[15];
  if (v4 == v5) {
    goto LABEL_158;
  }
  BOOL v6 = (llvm::Value *)&v145;
  uint64_t v3 = (llvm::Value **)&v133;
  while (1)
  {
    uint64_t v7 = 0;
    unsigned int v8 = *(llvm::Instruction **)v4;
    uint64_t v9 = ***(llvm::Type *****)v4;
    uint64_t v131 = 0x200000000;
    int v135 = v9;
    uint64_t v136 = &v144;
    unint64_t v137 = &v145;
    uint64_t v138 = 0;
    int v139 = 0;
    __int16 v140 = 512;
    char v141 = 7;
    uint64_t v133 = 0;
    uint64_t v134 = 0;
    uint64_t v142 = 0;
    uint64_t v143 = 0;
    uint64_t v144 = &unk_1F2616E88;
    uint64_t v145 = &unk_1F2617008;
    uint64_t v133 = (llvm::Type ***)*((void *)v8 + 5);
    uint64_t v134 = (void *)((char *)v8 + 24);
    BOOL v10 = (unsigned __int8 *)*((void *)v8 + 6);
    BOOL v129 = v10;
    uint64_t v130 = v132;
    if (v10)
    {
      llvm::MetadataTracking::track((uint64_t)&v129, v10, 2);
      uint64_t v7 = (uint64_t)v129;
    }
    uint64_t v11 = (void *)sub_1CB8461A4((uint64_t)&v130, 0, v7);
    if (v129)
    {
      int v37 = *v129;
      if ((v37 - 4) > 0x1E)
      {
        if ((v37 - 3) >= 0xFFFFFFFE) {
          unsigned int v56 = v129;
        }
        else {
          unsigned int v56 = 0;
        }
        if ((v37 - 3) >= 0xFFFFFFFE)
        {
          unint64_t v39 = (unint64_t)(v56 + 8);
LABEL_74:
          v127[0] = &v129;
          uint64_t v11 = (void *)sub_1CC5FA668(v39 + 16, v127);
          goto LABEL_6;
        }
        if (v37 == 3) {
          *((void *)v129 + 1) = 0;
        }
      }
      else if ((v129[1] & 0x7F) == 2 || *((_DWORD *)v129 + 3))
      {
        uint64_t v38 = *((void *)v129 + 2);
        if ((v38 & 4) != 0)
        {
          unint64_t v39 = v38 & 0xFFFFFFFFFFFFFFF8;
          if (v39) {
            goto LABEL_74;
          }
        }
      }
    }
LABEL_6:
    unsigned int v13 = *((unsigned __int8 *)v8 + 16);
    uint64_t v14 = v13 - 28;
    if (v13 <= 0x34 || v13 - 53 < 6)
    {
      int v22 = *((_DWORD *)v8 + 5);
      if ((v22 & 0x40000000) != 0) {
        uint64_t v23 = (llvm::Value **)*((void *)v8 - 1);
      }
      else {
        uint64_t v23 = (llvm::Value **)((char *)v8 - 32 * (v22 & 0x7FFFFFF));
      }
      ReducedOperand = llvm::TruncInstCombine::getReducedOperand((llvm::TruncInstCombine *)this, *v23, a2);
      int v25 = *((_DWORD *)v8 + 5);
      if ((v25 & 0x40000000) != 0) {
        uint64_t v26 = (void **)*((void *)v8 - 1);
      }
      else {
        uint64_t v26 = (void **)((char *)v8 - 32 * (v25 & 0x7FFFFFF));
      }
      int v27 = llvm::TruncInstCombine::getReducedOperand((llvm::TruncInstCombine *)this, (llvm::Value *)v26[4], a2);
      __int16 v128 = 257;
      int v28 = sub_1CB844E98((uint64_t)&v130, v14, (uint64_t)ReducedOperand, (uint64_t)v27, (uint64_t)v127, 0);
      uint64_t v20 = v28;
      unsigned int v29 = *((unsigned __int8 *)v8 + 16);
      if (v29 <= 0x37
        && ((1 << v29) & 0xC1800000000000) != 0
        && *((unsigned __int8 *)v28 + 16) >= 0x1Cu
        && v28 != 0)
      {
        *((unsigned char *)v28 + 17) = *((unsigned char *)v28 + 17) & 0xFD | *((unsigned char *)v8 + 17) & 2;
      }
      goto LABEL_100;
    }
    switch(*((unsigned char *)v8 + 16))
    {
      case 'S':
        uint64_t v15 = *(void *)v8;
        int v16 = (llvm::Type *)a2;
        if (*(void *)v8)
        {
          int v16 = (llvm::Type *)a2;
          if ((*(_DWORD *)(v15 + 8) & 0xFE) == 0x12)
          {
            int v17 = (llvm::Type *)*(unsigned int *)(v15 + 32);
            if (*(_DWORD *)(v15 + 8) == 19) {
              llvm::ScalableVectorType::get(a2, v17);
            }
            else {
              llvm::FixedVectorType::get((llvm::FixedVectorType *)a2, v17);
            }
            int v16 = v18;
          }
        }
        int v19 = *((_DWORD *)v8 + 5) & 0x7FFFFFF;
        __int16 v128 = 257;
        uint64_t v20 = sub_1CB93113C((uint64_t)&v130, (uint64_t)v16, v19, (uint64_t)v127);
        if (v147 >= (unint64_t)HIDWORD(v147)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        uint64_t v21 = (llvm::Instruction **)&v146[2 * v147];
        *uint64_t v21 = v8;
        v21[1] = v20;
        LODWORD(v147) = v147 + 1;
        goto LABEL_100;
      case 'T':
      case 'V':
      case 'W':
      case 'X':
        __break(1u);
        goto LABEL_183;
      case 'U':
        int v52 = *((_DWORD *)v8 + 5);
        if ((v52 & 0x40000000) != 0) {
          int v53 = (llvm::Value **)*((void *)v8 - 1);
        }
        else {
          int v53 = (llvm::Value **)((char *)v8 - 32 * (v52 & 0x7FFFFFF));
        }
        BOOL v65 = *v53;
        int v66 = llvm::TruncInstCombine::getReducedOperand((llvm::TruncInstCombine *)this, v53[4], a2);
        int v67 = *((_DWORD *)v8 + 5);
        if ((v67 & 0x40000000) != 0) {
          BOOL v68 = (void **)*((void *)v8 - 1);
        }
        else {
          BOOL v68 = (void **)((char *)v8 - 32 * (v67 & 0x7FFFFFF));
        }
        unint64_t v69 = llvm::TruncInstCombine::getReducedOperand((llvm::TruncInstCombine *)this, (llvm::Value *)v68[8], a2);
        __int16 v128 = 257;
        Select = llvm::IRBuilderBase::CreateSelect((llvm::IRBuilderBase *)&v130, v65, v66, v69, (const llvm::Twine *)v127, 0);
        goto LABEL_93;
      case 'Y':
        int v54 = *((_DWORD *)v8 + 5);
        if ((v54 & 0x40000000) != 0) {
          BOOL v55 = (llvm::Value **)*((void *)v8 - 1);
        }
        else {
          BOOL v55 = (llvm::Value **)((char *)v8 - 32 * (v54 & 0x7FFFFFF));
        }
        unsigned int v70 = (unsigned __int8 *)llvm::TruncInstCombine::getReducedOperand((llvm::TruncInstCombine *)this, *v55, a2);
        int v71 = *((_DWORD *)v8 + 5);
        if ((v71 & 0x40000000) != 0) {
          uint64_t v72 = (void **)*((void *)v8 - 1);
        }
        else {
          uint64_t v72 = (void **)((char *)v8 - 32 * (v71 & 0x7FFFFFF));
        }
        unsigned int v73 = (unsigned __int8 *)v72[4];
        __int16 v128 = 257;
        Select = sub_1CB8445F4((uint64_t)&v130, v70, v73, (uint64_t)v127);
        goto LABEL_93;
      case 'Z':
        int v50 = *((_DWORD *)v8 + 5);
        if ((v50 & 0x40000000) != 0) {
          uint64_t v51 = (llvm::Value **)*((void *)v8 - 1);
        }
        else {
          uint64_t v51 = (llvm::Value **)((char *)v8 - 32 * (v50 & 0x7FFFFFF));
        }
        size_t v57 = (unsigned __int8 *)llvm::TruncInstCombine::getReducedOperand((llvm::TruncInstCombine *)this, *v51, a2);
        int v58 = *((_DWORD *)v8 + 5);
        if ((v58 & 0x40000000) != 0) {
          unint64_t v59 = (void **)*((void *)v8 - 1);
        }
        else {
          unint64_t v59 = (void **)((char *)v8 - 32 * (v58 & 0x7FFFFFF));
        }
        unint64_t v60 = (unsigned __int8 *)llvm::TruncInstCombine::getReducedOperand((llvm::TruncInstCombine *)this, (llvm::Value *)v59[4], a2);
        int v61 = *((_DWORD *)v8 + 5);
        if ((v61 & 0x40000000) != 0) {
          unint64_t v62 = (void **)*((void *)v8 - 1);
        }
        else {
          unint64_t v62 = (void **)((char *)v8 - 32 * (v61 & 0x7FFFFFF));
        }
        unsigned int v63 = (unsigned __int8 *)v62[8];
        __int16 v128 = 257;
        Select = sub_1CB84478C((uint64_t)&v130, v57, v60, v63, (uint64_t)v127);
LABEL_93:
        uint64_t v20 = Select;
        goto LABEL_100;
      default:
        uint64_t v31 = *(void *)v8;
        BOOL v32 = (llvm::Type ***)a2;
        if (*(void *)v8)
        {
          BOOL v32 = (llvm::Type ***)a2;
          if ((*(_DWORD *)(v31 + 8) & 0xFE) == 0x12)
          {
            BOOL v33 = (llvm::Type *)*(unsigned int *)(v31 + 32);
            if (*(_DWORD *)(v31 + 8) == 19) {
              llvm::ScalableVectorType::get(a2, v33);
            }
            else {
              llvm::FixedVectorType::get((llvm::FixedVectorType *)a2, v33);
            }
            BOOL v32 = v34;
          }
        }
        int v35 = *((_DWORD *)v8 + 5);
        if ((v35 & 0x40000000) != 0) {
          unsigned int v36 = (llvm::CastInst **)*((void *)v8 - 1);
        }
        else {
          unsigned int v36 = (llvm::CastInst **)((char *)v8 - 32 * (v35 & 0x7FFFFFF));
        }
        uint64_t v40 = *v36;
        if (*(llvm::Type ****)*v36 != v32)
        {
          __int16 v128 = 257;
          uint64_t v20 = sub_1CBF56614((uint64_t)&v130, v40, v32, (llvm::Type *)(v14 == 40), (uint64_t)v127, v12);
          int v41 = (llvm::Instruction **)this[4];
          uint64_t v42 = *((unsigned int *)this + 10);
          uint64_t v43 = (char *)&v41[v42];
          unint64_t v44 = v41;
          if (v42)
          {
            uint64_t v45 = 8 * v42;
            unint64_t v44 = (llvm::Instruction **)this[4];
            do
            {
              if (*v44 == v8) {
                goto LABEL_49;
              }
              ++v44;
              v45 -= 8;
            }
            while (v45);
            unint64_t v44 = &v41[v42];
          }
LABEL_49:
          BOOL v47 = *((unsigned char *)v20 + 16) != 66 || v20 == 0;
          if (v42 == v44 - v41)
          {
            if (!v47)
            {
              if (v42 >= *((_DWORD *)this + 11)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              v41[v42] = v20;
              uint64_t v48 = (llvm::TruncInstCombine *)this;
              int v49 = *((_DWORD *)this + 10) + 1;
LABEL_99:
              *((_DWORD *)v48 + 10) = v49;
            }
          }
          else
          {
            if (v47)
            {
              if (v43 == (char *)(v44 + 1))
              {
                uint64_t v48 = (llvm::TruncInstCombine *)this;
              }
              else
              {
                memmove(v44, v44 + 1, v43 - (char *)(v44 + 1));
                uint64_t v48 = (llvm::TruncInstCombine *)this;
                LODWORD(v42) = *((_DWORD *)this + 10);
              }
              int v49 = v42 - 1;
              goto LABEL_99;
            }
            *unint64_t v44 = v20;
          }
LABEL_100:
          *((void *)v4 + 2) = v20;
          if (v20 && *((unsigned __int8 *)v20 + 16) >= 0x1Cu) {
            llvm::Value::takeName((int32x2_t ****)v20, v8);
          }
          goto LABEL_103;
        }
        *((void *)v4 + 2) = v40;
LABEL_103:
        if (v130 != v132) {
          free(v130);
        }
        unint64_t v4 = (llvm::Value *)((char *)v4 + 24);
        if (v4 == v5)
        {
          uint64_t v3 = this;
          int v2 = a2;
          if (v147)
          {
            unint64_t v74 = v146;
            long long v120 = &v146[2 * v147];
            do
            {
              unint64_t v75 = *v74;
              int v76 = *((_DWORD *)*v74 + 5);
              if ((v76 & 0x40000000) != 0)
              {
                uint64_t v78 = (llvm::Value **)*(v75 - 1);
                uint64_t v77 = v76 & 0x7FFFFFF;
                unsigned int v79 = &v78[4 * v77];
              }
              else
              {
                uint64_t v77 = v76 & 0x7FFFFFF;
                uint64_t v78 = &v75[-4 * v77];
                unsigned int v79 = *v74;
              }
              if (v78 != v79 && v77 != 0)
              {
                unsigned int v81 = v74[1];
                uint64_t v82 = &v78[4 * *((unsigned int *)v75 + 15)];
                uint64_t v126 = &v82[v77];
                uint64_t v121 = v79;
                unsigned int v122 = v74;
                do
                {
                  unsigned int v83 = llvm::TruncInstCombine::getReducedOperand((llvm::TruncInstCombine *)v3, *v78, v2);
                  uint64_t v84 = *v82;
                  int v85 = *((_DWORD *)v81 + 5);
                  uint64_t v86 = v85 & 0x7FFFFFF;
                  if ((v85 & 0x7FFFFFF) == *((_DWORD *)v81 + 15))
                  {
                    unsigned int v99 = v86 + (v86 >> 1);
                    if (v99 <= 2) {
                      uint64_t v100 = 2;
                    }
                    else {
                      uint64_t v100 = v99;
                    }
                    *((_DWORD *)v81 + 15) = v100;
                    if ((v85 & 0x40000000) != 0) {
                      uint64_t v101 = (uint64_t *)*(v81 - 1);
                    }
                    else {
                      uint64_t v101 = (uint64_t *)&v81[-4 * v86];
                    }
                    std::string __p = v101;
                    uint64_t v102 = (llvm::Value *)operator new(40 * v100);
                    *(v81 - 1) = v102;
                    uint64_t v103 = v102;
                    do
                    {
                      *(void *)uint64_t v103 = 0;
                      *((void *)v103 + 1) = 0;
                      *((void *)v103 + 2) = 0;
                      *((void *)v103 + 3) = v81;
                      uint64_t v103 = (llvm::Value *)((char *)v103 + 32);
                    }
                    while (v103 != (llvm::Value *)((char *)v102 + 32 * v100));
                    int v104 = *((_DWORD *)v81 + 5);
                    if ((v104 & 0x40000000) != 0) {
                      uint64_t v105 = (uint64_t)v102;
                    }
                    else {
                      uint64_t v105 = (uint64_t)&v81[-4 * (v104 & 0x7FFFFFF)];
                    }
                    sub_1CC5E4108((uint64_t)&v130, __p, &__p[4 * v86], v105);
                    if (v86)
                    {
                      memmove((void *)(v105 + 32 * v100), &__p[4 * v86], 8 * v86);
                      uint64_t v106 = 4 * v86;
                      do
                      {
                        int v107 = &__p[v106];
                        if (__p[v106 - 4])
                        {
                          *(void *)*(v107 - 2) = *(v107 - 3);
                          uint64_t v108 = *(v107 - 3);
                          if (v108) {
                            *(void *)(v108 + 16) = *(v107 - 2);
                          }
                        }
                        v106 -= 4;
                      }
                      while (v106 * 8);
                    }
                    operator delete(__p);
                    int v85 = *((_DWORD *)v81 + 5);
                    uint64_t v3 = this;
                    int v2 = a2;
                    unsigned int v79 = v121;
                    unint64_t v74 = v122;
                  }
                  uint64_t v87 = (v85 + 1) & 0x7FFFFFF;
                  *((_DWORD *)v81 + 5) = v85 & 0xF8000000 | (v85 + 1) & 0x7FFFFFF;
                  if ((v85 & 0x40000000) != 0) {
                    uint64_t v88 = (llvm::Value **)*(v81 - 1);
                  }
                  else {
                    uint64_t v88 = &v81[-4 * v87];
                  }
                  uint64_t v89 = (v87 - 1);
                  uint64_t v90 = &v88[4 * v89];
                  if (*v90)
                  {
                    *(void *)v90[2] = v90[1];
                    uint64_t v98 = v90[1];
                    if (v98) {
                      *((void *)v98 + 2) = v90[2];
                    }
                  }
                  *uint64_t v90 = v83;
                  if (v83)
                  {
                    uint64_t v93 = (llvm::Value *)*((void *)v83 + 1);
                    uint64_t v92 = (llvm::Value ***)((char *)v83 + 8);
                    char v91 = v93;
                    uint64_t v94 = &v88[4 * v89];
                    v94[1] = v93;
                    if (v93) {
                      *((void *)v91 + 2) = v94 + 1;
                    }
                    v94[2] = (llvm::Value *)v92;
                    *uint64_t v92 = v90;
                  }
                  int v95 = *((_DWORD *)v81 + 5);
                  uint64_t v96 = v95 & 0x7FFFFFF;
                  if ((v95 & 0x40000000) != 0) {
                    uint64_t v97 = (llvm::Value **)*(v81 - 1);
                  }
                  else {
                    uint64_t v97 = &v81[-4 * v96];
                  }
                  *(&v97[4 * *((unsigned int *)v81 + 15)] + (v96 - 1)) = v84;
                  v78 += 4;
                  if (v78 == v79) {
                    break;
                  }
                  ++v82;
                }
                while (v82 != v126);
              }
              v74 += 2;
            }
            while (v74 != v120);
          }
LABEL_158:
          BOOL v6 = llvm::TruncInstCombine::getReducedOperand((llvm::TruncInstCombine *)v3, *((llvm::Value **)v3[10] - 4), v2);
          int v109 = (llvm::Type ****)v3[10];
          unsigned int v110 = *v109;
          if (*(llvm::Type ****)v6 != *v109)
          {
            uint64_t v111 = 0;
            unint64_t v112 = *v110;
            uint64_t v131 = 0x200000000;
            int v135 = v112;
            uint64_t v136 = &v144;
            unint64_t v137 = &v145;
            uint64_t v138 = 0;
            int v139 = 0;
            __int16 v140 = 512;
            char v141 = 7;
            uint64_t v142 = 0;
            uint64_t v143 = 0;
            uint64_t v144 = &unk_1F2616E88;
            uint64_t v145 = &unk_1F2617008;
            uint64_t v133 = v109[5];
            uint64_t v134 = v109 + 3;
            unint64_t v113 = (unsigned __int8 *)v109[6];
            BOOL v129 = v113;
            uint64_t v130 = v132;
            if (v113)
            {
              llvm::MetadataTracking::track((uint64_t)&v129, v113, 2);
              uint64_t v111 = (uint64_t)v129;
            }
            sub_1CB8461A4((uint64_t)&v130, 0, v111);
            if (v129)
            {
              int v116 = *v129;
              if ((v116 - 4) > 0x1E)
              {
                if ((v116 - 3) >= 0xFFFFFFFE) {
                  size_t v119 = v129;
                }
                else {
                  size_t v119 = 0;
                }
                if ((v116 - 3) < 0xFFFFFFFE)
                {
                  if (v116 == 3) {
                    *((void *)v129 + 1) = 0;
                  }
                  goto LABEL_162;
                }
                unint64_t v118 = (unint64_t)(v119 + 8);
              }
              else
              {
                if ((v129[1] & 0x7F) != 2 && !*((_DWORD *)v129 + 3)) {
                  goto LABEL_162;
                }
                uint64_t v117 = *((void *)v129 + 2);
                if ((v117 & 4) == 0) {
                  goto LABEL_162;
                }
                unint64_t v118 = v117 & 0xFFFFFFFFFFFFFFF8;
                if (!v118) {
                  goto LABEL_162;
                }
              }
              v127[0] = &v129;
              sub_1CC5FA668(v118 + 16, v127);
            }
LABEL_162:
            __int16 v128 = 257;
            char v115 = sub_1CBF56614((uint64_t)&v130, v6, v110, 0, (uint64_t)v127, v114);
            BOOL v6 = v115;
            if (v115)
            {
              if (*((unsigned __int8 *)v115 + 16) >= 0x1Cu) {
                llvm::Value::takeName((int32x2_t ****)v115, v3[10]);
              }
            }
            uint64_t v11 = v130;
            if (v130 != v132) {
LABEL_183:
            }
              free(v11);
            int v109 = (llvm::Type ****)v3[10];
          }
          llvm::Value::doRAUW((llvm::ValueAsMetadata *)v109, v6, (llvm::Value *)1);
          llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
        }
        return;
    }
  }
}

llvm::Instruction *sub_1CBF56614(uint64_t a1, llvm::CastInst *this, llvm::Type ***a3, llvm::Type *a4, uint64_t a5, llvm::Instruction *a6)
{
  BOOL v6 = this;
  if (*(llvm::Type ****)this == a3) {
    return v6;
  }
  if (*((unsigned __int8 *)this + 16) > 0x14u)
  {
    __int16 v15 = 257;
    BOOL v6 = llvm::CastInst::CreateIntegerCast(this, a3, a4, &v14, 0, a6);
    (*(void (**)(void, llvm::Value *, uint64_t, void, void))(**(void **)(a1 + 80) + 16))(*(void *)(a1 + 80), v6, a5, *(void *)(a1 + 48), *(void *)(a1 + 56));
    uint64_t v11 = *(unsigned int *)(a1 + 8);
    if (v11)
    {
      uint64_t v12 = *(void *)a1;
      uint64_t v13 = v12 + 16 * v11;
      do
      {
        llvm::Instruction::setMetadata(v6, *(_DWORD *)v12, *(llvm::MDNode **)(v12 + 8));
        v12 += 16;
      }
      while (v12 != v13);
    }
    return v6;
  }
  BOOL v6 = (llvm::Value *)(*(uint64_t (**)(void, llvm::CastInst *))(**(void **)(a1 + 72) + 248))(*(void *)(a1 + 72), this);
  if (!v6 || *((unsigned __int8 *)v6 + 16) < 0x1Cu) {
    return v6;
  }

  return sub_1CB844E0C((uint64_t *)a1, v6, a5);
}

uint64_t llvm::TruncInstCombine::run(llvm::TruncInstCombine *this, llvm::Function **a2)
{
  if (a2[10] != (llvm::Function *)(a2 + 9)) {
    llvm::DominatorTreeBase<llvm::BasicBlock,false>::isReachableFromEntry();
  }
  for (unsigned int i = *((_DWORD *)this + 10); i; unsigned int i = *((_DWORD *)this + 10))
  {
    uint64_t v4 = *(void *)(*((void *)this + 4) + 8 * i - 8);
    *((_DWORD *)this + 10) = i - 1;
    *((void *)this + 10) = v4;
    BestTruncatedType = (uint64_t **)llvm::TruncInstCombine::getBestTruncatedType((llvm::IntegerType ****)this);
    if (BestTruncatedType) {
      llvm::TruncInstCombine::ReduceExpressionGraph((llvm::Value **)this, BestTruncatedType);
    }
  }
  return 0;
}

_DWORD *sub_1CBF568A4(_DWORD *result)
{
  if (*((void *)result + 1))
  {
    uint64_t v1 = result[4];
    if (v1 <= 4 * result[2] || v1 < 0x41)
    {
      if (v1)
      {
        int v2 = *(void **)result;
        uint64_t v3 = 16 * v1;
        do
        {
          *int v2 = -4096;
          v2 += 2;
          v3 -= 16;
        }
        while (v3);
      }
      *((void *)result + 1) = 0;
    }
    else
    {
      return sub_1CBA7B248(result);
    }
  }
  return result;
}

void *sub_1CBF568F0@<X0>(_DWORD *a1@<X0>, uint64_t *a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int v8 = a1[4];
  if (!v8)
  {
    unint64_t v18 = 0;
LABEL_16:
    BOOL result = sub_1CBF569E0(a1, (uint64_t)a2, a2, v18);
    *BOOL result = *a2;
    *((_DWORD *)result + 2) = *a3;
    uint64_t v9 = *(void *)a1;
    unsigned int v8 = a1[4];
    char v17 = 1;
    goto LABEL_12;
  }
  uint64_t v9 = *(void *)a1;
  unsigned int v10 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v8 - 1);
  BOOL result = (void *)(*(void *)a1 + 16 * v10);
  uint64_t v12 = *result;
  if (*a2 != *result)
  {
    uint64_t v13 = 0;
    int v14 = 1;
    while (v12 != -4096)
    {
      if (v13) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v12 == -8192;
      }
      if (v15) {
        uint64_t v13 = result;
      }
      unsigned int v16 = v10 + v14++;
      unsigned int v10 = v16 & (v8 - 1);
      BOOL result = (void *)(v9 + 16 * v10);
      uint64_t v12 = *result;
      if (*a2 == *result) {
        goto LABEL_11;
      }
    }
    if (v13) {
      unint64_t v18 = v13;
    }
    else {
      unint64_t v18 = result;
    }
    goto LABEL_16;
  }
LABEL_11:
  char v17 = 0;
LABEL_12:
  *(void *)a4 = result;
  *(void *)(a4 + 8) = v9 + 16 * v8;
  *(unsigned char *)(a4 + 16) = v17;
  return result;
}

void *sub_1CBF569E0(_DWORD *a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v4 = a1[2];
  unsigned int v5 = a1[4];
  if (4 * v4 + 4 >= 3 * v5)
  {
    uint64_t v18 = (uint64_t)a1;
    sub_1CBF56B18((uint64_t)a1, 2 * v5);
    int v19 = 0;
    sub_1CB883B0C(v18, a3, &v19);
    a1 = (_DWORD *)v18;
    a4 = v19;
    goto LABEL_3;
  }
  if (v5 + ~v4 - a1[3] > v5 >> 3)
  {
LABEL_3:
    uint64_t v6 = *a4;
    goto LABEL_4;
  }
  unsigned int v8 = a1;
  sub_1CBF56B18((uint64_t)a1, v5);
  a1 = v8;
  uint64_t v6 = *a3;
  int v10 = v8[4] - 1;
  unsigned int v11 = ((*a3 >> 4) ^ (*a3 >> 9)) & v10;
  a4 = (void *)(*(void *)v8 + 16 * v11);
  uint64_t v12 = *a4;
  if (*a3 != *a4)
  {
    uint64_t v13 = 0;
    int v14 = 1;
    while (v12 != -4096)
    {
      if (v13) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v12 == -8192;
      }
      if (v15) {
        uint64_t v13 = a4;
      }
      unsigned int v16 = v11 + v14++;
      unsigned int v11 = v16 & v10;
      a4 = (void *)(*(void *)v8 + 16 * v11);
      uint64_t v12 = *a4;
      if (v6 == *a4) {
        goto LABEL_4;
      }
    }
    if (v13) {
      a4 = v13;
    }
    goto LABEL_3;
  }
LABEL_4:
  ++a1[2];
  if (v6 != -4096) {
    --a1[3];
  }
  return a4;
}

void *sub_1CBF56B18(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  BOOL result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CBF56BE4(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *BOOL result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CBF56BE4(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  *(void *)(result + 8) = 0;
  uint64_t v3 = *(unsigned int *)(result + 16);
  if (v3)
  {
    int v4 = *(void **)result;
    uint64_t v5 = 16 * v3;
    do
    {
      *int v4 = -4096;
      v4 += 2;
      v5 -= 16;
    }
    while (v5);
  }
  for (; a2 != a3; a2 += 2)
  {
    uint64_t v6 = *a2;
    if (*a2 != -4096 && v6 != -8192)
    {
      int v7 = *(_DWORD *)(result + 16) - 1;
      unsigned int v8 = v7 & ((v6 >> 4) ^ (v6 >> 9));
      uint64_t v9 = *(void *)result + 16 * v8;
      uint64_t v10 = *(void *)v9;
      if (v6 != *(void *)v9)
      {
        uint64_t v11 = 0;
        int v12 = 1;
        while (v10 != -4096)
        {
          if (v11) {
            BOOL v13 = 0;
          }
          else {
            BOOL v13 = v10 == -8192;
          }
          if (v13) {
            uint64_t v11 = v9;
          }
          unsigned int v14 = v8 + v12++;
          unsigned int v8 = v14 & v7;
          uint64_t v9 = *(void *)result + 16 * (v14 & v7);
          uint64_t v10 = *(void *)v9;
          if (v6 == *(void *)v9) {
            goto LABEL_21;
          }
        }
        if (v11) {
          uint64_t v9 = v11;
        }
      }
LABEL_21:
      *(void *)uint64_t v9 = v6;
      *(_DWORD *)(v9 + 8) = *((_DWORD *)a2 + 2);
      ++*(_DWORD *)(result + 8);
    }
  }
  return result;
}

char *sub_1CBF56CC0(void **a1, void *a2, _OWORD *a3)
{
  int v4 = (char *)*a1;
  uint64_t v3 = (char *)a1[1];
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((v3 - (unsigned char *)*a1) >> 3);
  unint64_t v6 = v5 + 1;
  if (v5 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((unsigned char *)a1[2] - v4) >> 3) > v6) {
    unint64_t v6 = 0x5555555555555556 * (((unsigned char *)a1[2] - v4) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - v4) >> 3) >= 0x555555555555555) {
    unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v10 = v6;
  }
  if (v10)
  {
    if (v10 > 0xAAAAAAAAAAAAAAALL) {
      sub_1CB833614();
    }
    uint64_t v11 = (char *)operator new(24 * v10);
  }
  else
  {
    uint64_t v11 = 0;
  }
  int v12 = &v11[24 * v5];
  *(void *)int v12 = *a2;
  *(_OWORD *)(v12 + 8) = *a3;
  BOOL v13 = v12 + 24;
  if (v3 != v4)
  {
    do
    {
      long long v14 = *(_OWORD *)(v3 - 24);
      *((void *)v12 - 1) = *((void *)v3 - 1);
      *(_OWORD *)(v12 - 24) = v14;
      v12 -= 24;
      v3 -= 24;
    }
    while (v3 != v4);
    uint64_t v3 = (char *)*a1;
  }
  *a1 = v12;
  a1[1] = v13;
  a1[2] = &v11[24 * v10];
  if (v3) {
    operator delete(v3);
  }
  return v13;
}

char *sub_1CBF56DE8(void **a1, uint64_t a2)
{
  uint64_t v3 = (char *)*a1;
  int v2 = (char *)a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v2 - (unsigned char *)*a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((unsigned char *)a1[2] - v3) >> 3) > v5) {
    unint64_t v5 = 0x5555555555555556 * (((unsigned char *)a1[2] - v3) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - v3) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v5;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      sub_1CB833614();
    }
    uint64_t v9 = (char *)operator new(24 * v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  unint64_t v10 = &v9[24 * v4];
  *(_OWORD *)unint64_t v10 = *(_OWORD *)a2;
  *((void *)v10 + 2) = *(void *)(a2 + 16);
  uint64_t v11 = v10 + 24;
  if (v2 != v3)
  {
    do
    {
      long long v12 = *(_OWORD *)(v2 - 24);
      *((void *)v10 - 1) = *((void *)v2 - 1);
      *(_OWORD *)(v10 - 24) = v12;
      v10 -= 24;
      v2 -= 24;
    }
    while (v2 != v3);
    int v2 = (char *)*a1;
  }
  *a1 = v10;
  a1[1] = v11;
  a1[2] = &v9[24 * v8];
  if (v2) {
    operator delete(v2);
  }
  return v11;
}

void *llvm::AAResults::AAResults(void *a1, uint64_t a2)
{
  *a1 = *(void *)a2;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  *(_OWORD *)(a1 + 1) = *(_OWORD *)(a2 + 8);
  a1[3] = *(void *)(a2 + 24);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  *((_OWORD *)a1 + 2) = *(_OWORD *)(a2 + 32);
  a1[6] = *(void *)(a2 + 48);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + ++*(_DWORD *)(result + 48) = 0;
  uint64_t v3 = (uint64_t *)a1[1];
  unint64_t v4 = (uint64_t *)a1[2];
  while (v3 != v4)
  {
    uint64_t v5 = *v3++;
    (*(void (**)(uint64_t, void *))(*(void *)v5 + 16))(v5, a1);
  }
  return a1;
}

void llvm::AAResults::~AAResults(llvm::AAResults *this)
{
  int v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void **)((char *)this + 8);
  sub_1CBF5BD78(&v3);
}

{
  void *v2;
  void **v3;

  int v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void **)((char *)this + 8);
  sub_1CBF5BD78(&v3);
}

uint64_t llvm::AAResults::invalidate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8 = *(void *)(a3 + 48);
  uint64_t v7 = *(void *)(a3 + 56);
  if (v7 == v8)
  {
    uint64_t v9 = *(unsigned int *)(a3 + 68);
    unint64_t v10 = (void **)(v7 + 8 * v9);
    if (v9)
    {
      uint64_t v11 = 0;
      while (*(_UNKNOWN **)(v7 + v11) != &llvm::AAManager::Key)
      {
        v11 += 8;
        if (8 * v9 == v11) {
          goto LABEL_6;
        }
      }
      unint64_t v10 = (void **)(v7 + v11);
    }
LABEL_6:
    uint64_t v8 = *(void *)(a3 + 56);
  }
  else
  {
    uint64_t v17 = *(unsigned int *)(a3 + 64);
    int v18 = v17 - 1;
    unsigned int v19 = (v17 - 1) & ((&llvm::AAManager::Key >> 4) ^ (&llvm::AAManager::Key >> 9));
    unint64_t v10 = (void **)(v7 + 8 * v19);
    uint64_t v20 = *v10;
    if (*v10 == (void *)-1)
    {
      uint64_t v21 = 0;
LABEL_32:
      if (v21) {
        unint64_t v10 = v21;
      }
      if (*v10 != &llvm::AAManager::Key)
      {
        LODWORD(v9) = *(_DWORD *)(a3 + 68);
        unint64_t v10 = (void **)(v7 + 8 * v17);
        goto LABEL_7;
      }
    }
    else
    {
      uint64_t v21 = 0;
      int v22 = 1;
      while (v20 != &llvm::AAManager::Key)
      {
        if (v21) {
          BOOL v23 = 0;
        }
        else {
          BOOL v23 = v20 == (void *)-2;
        }
        if (v23) {
          uint64_t v21 = v10;
        }
        unsigned int v24 = v19 + v22++;
        unsigned int v19 = v24 & v18;
        unint64_t v10 = (void **)(v7 + 8 * (v24 & v18));
        uint64_t v20 = *v10;
        if (*v10 == (void *)-1) {
          goto LABEL_32;
        }
      }
    }
    LODWORD(v9) = *(_DWORD *)(a3 + 68);
  }
LABEL_7:
  if (v7 == v8) {
    unsigned int v12 = v9;
  }
  else {
    unsigned int v12 = *(_DWORD *)(a3 + 64);
  }
  if (v10 != (void **)(v7 + 8 * v12)) {
    return 1;
  }
  uint64_t v13 = *(void *)(a1 + 32);
  uint64_t v14 = *(void *)(a1 + 40);
  if (v13 == v14) {
    return 0;
  }
  uint64_t v15 = v13 + 8;
  do
  {
    uint64_t result = llvm::AnalysisManager<llvm::Function>::Invalidator::invalidate(a4, *(void *)(v15 - 8), a2, a3);
    if (result) {
      break;
    }
    BOOL v23 = v15 == v14;
    v15 += 8;
  }
  while (!v23);
  return result;
}

uint64_t llvm::AAResults::alias(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  v16[0] = 1;
  uint64_t v5 = 1;
  do
  {
    unint64_t v6 = &v16[v5];
    *(_OWORD *)unint64_t v6 = xmmword_1CFAC3060;
    *((_OWORD *)v6 + 1) = xmmword_1CFAC3060;
    v5 += 5;
  }
  while (v6 + 5 != &v17);
  uint64_t v17 = &v23;
  int v19 = 0;
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  BOOL v23 = &unk_1F2600DB8;
  uint64_t v24 = 1;
  for (uint64_t i = 63; i != 79; i += 2)
    v16[i] = -4096;
  uint64_t v8 = 1;
  int v18 = 1;
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = *(void *)(a1 + 16);
  if (v9 == v10)
  {
    int v14 = 0;
  }
  else
  {
    uint64_t v11 = v9 + 8;
    do
    {
      uint64_t v12 = (*(uint64_t (**)(void, uint64_t, uint64_t, void *))(**(void **)(v11 - 8) + 24))(*(void *)(v11 - 8), a2, a3, v16);
      BOOL v13 = v12 != 1 || v11 == v10;
      v11 += 8;
    }
    while (!v13);
    uint64_t v8 = v12;
    int v14 = v18 - 1;
  }
  int v18 = v14;
  if ((v24 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v25, 8);
  }
  if (v20 != v22) {
    free(v20);
  }
  if ((v16[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v16[1], 8);
  }
  return v8;
}

uint64_t llvm::AAResults::alias(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v5 = *(_DWORD *)(a4 + 336);
  *(_DWORD *)(a4 + 336) = v5 + 1;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(void *)(a1 + 16);
  if (v6 == v7)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v10 = v6 + 8;
    do
    {
      uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(v10 - 8) + 24))(*(void *)(v10 - 8), a2, a3, a4);
      BOOL v12 = result != 1 || v10 == v7;
      v10 += 8;
    }
    while (!v12);
    int v5 = *(_DWORD *)(a4 + 336) - 1;
  }
  *(_DWORD *)(a4 + 336) = v5;
  return result;
}

uint64_t llvm::AAResults::pointsToConstantMemory(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  v14[0] = 1;
  uint64_t v5 = 1;
  do
  {
    uint64_t v6 = &v14[v5];
    *(_OWORD *)uint64_t v6 = xmmword_1CFAC3060;
    *((_OWORD *)v6 + 1) = xmmword_1CFAC3060;
    v5 += 5;
  }
  while (v6 + 5 != v15);
  v15[0] = &v19;
  v15[1] = 0;
  unsigned int v16 = v18;
  uint64_t v17 = 0x400000000;
  int v19 = &unk_1F2600DB8;
  uint64_t v20 = 1;
  for (uint64_t i = 63; i != 79; i += 2)
    v14[i] = -4096;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  if (v8 == v9)
  {
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v10 = v8 + 8;
    do
    {
      uint64_t v11 = (*(uint64_t (**)(void, uint64_t, void *, uint64_t))(**(void **)(v10 - 8) + 32))(*(void *)(v10 - 8), a2, v14, a3);
      if (v11) {
        break;
      }
      BOOL v12 = v10 == v9;
      v10 += 8;
    }
    while (!v12);
  }
  if ((v20 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v21, 8);
  }
  if (v16 != v18) {
    free(v16);
  }
  if ((v14[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v14[1], 8);
  }
  return v11;
}

uint64_t llvm::AAResults::pointsToConstantMemory(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  if (v4 == v5) {
    return 0;
  }
  uint64_t v9 = v4 + 8;
  do
  {
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(v9 - 8) + 32))(*(void *)(v9 - 8), a2, a3, a4);
    if (result) {
      break;
    }
    BOOL v11 = v9 == v5;
    v9 += 8;
  }
  while (!v11);
  return result;
}

uint64_t llvm::AAResults::getModRefInfo(llvm::AAResults *this, uint64_t ***a2, const llvm::CallBase *a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  v14[0] = 1;
  uint64_t v5 = 1;
  do
  {
    uint64_t v6 = &v14[v5];
    *(_OWORD *)uint64_t v6 = xmmword_1CFAC3060;
    *((_OWORD *)v6 + 1) = xmmword_1CFAC3060;
    v5 += 5;
  }
  while (v6 + 5 != v15);
  v15[0] = &v19;
  v15[1] = 0;
  unsigned int v16 = v18;
  uint64_t v17 = 0x400000000;
  int v19 = &unk_1F2600DB8;
  uint64_t v20 = 1;
  for (uint64_t i = 63; i != 79; i += 2)
    v14[i] = -4096;
  unsigned int v8 = *((unsigned __int8 *)a2 + 16) - 33;
  if (v8 > 0x33) {
    goto LABEL_8;
  }
  if (((1 << v8) & 0x8000000000041) != 0)
  {
    uint64_t ModRefInfo = llvm::AAResults::getModRefInfo((uint64_t)this, (uint64_t)a2, (uint64_t)a3, (uint64_t)v14);
    goto LABEL_11;
  }
  if (((1 << v8) & 0x800040000010) != 0)
  {
    uint64_t ModRefInfo = 7;
  }
  else
  {
LABEL_8:
    llvm::MemoryLocation::getOrNone(a2, (uint64_t)v13);
    v12[0] = v13[0];
    v12[1] = v13[1];
    void v12[2] = v13[2];
    int v9 = llvm::AAResults::getModRefInfo((uint64_t)this, (uint64_t)a3, (uint64_t)v12, (uint64_t)v14);
    if ((v9 & 3) != 0) {
      uint64_t ModRefInfo = v9 | 3u;
    }
    else {
      uint64_t ModRefInfo = 4;
    }
  }
LABEL_11:
  if ((v20 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v21, 8);
  }
  if (v16 != v18) {
    free(v16);
  }
  if ((v14[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v14[1], 8);
  }
  return ModRefInfo;
}

uint64_t llvm::AAResults::getModRefInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v7 = *(unsigned __int8 *)(a2 + 16) - 33;
  if (v7 > 0x33) {
    goto LABEL_4;
  }
  if (((1 << v7) & 0x8000000000041) != 0) {
    return llvm::AAResults::getModRefInfo(a1, a2, a3, a4);
  }
  if (((1 << v7) & 0x800040000010) != 0) {
    return 7;
  }
LABEL_4:
  llvm::MemoryLocation::getOrNone((uint64_t ***)a2, (uint64_t)v11);
  v10[0] = v11[0];
  v10[1] = v11[1];
  v10[2] = v11[2];
  int ModRefInfo = llvm::AAResults::getModRefInfo(a1, a3, (uint64_t)v10, a4);
  if ((ModRefInfo & 3) != 0) {
    return ModRefInfo | 3u;
  }
  else {
    return 4;
  }
}

{
  uint64_t v7;
  void *v8;
  void *v9;
  int v10;
  void *v11;
  void *v12;
  int v13;
  void *v14;
  void *v15;
  int v16;
  uint64_t v17;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  char v26;
  unint64_t v27;
  __n128 v28;
  uint64_t v29;
  void *v30;
  void *v31;
  int v32;
  unsigned int ModRefInfo;
  int v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  char v39;
  int v40;
  unint64_t v41;
  __n128 v42;
  void *v43;
  void *v44;
  int v45;
  int v46;
  int v47;
  unsigned int v48;
  char v49;
  BOOL v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  int v57;
  unsigned char v58[48];

  unsigned int v7 = a1;
  int v9 = *(void **)(a1 + 8);
  unsigned int v8 = *(void **)(a1 + 16);
  uint64_t v10 = 7;
  if (v9 == v8) {
    goto LABEL_13;
  }
  do
  {
    v10 &= (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(*(void *)*v9 + 72))(*v9, a2, a3, a4);
    if ((v10 & 3) == 0) {
      goto LABEL_16;
    }
    ++v9;
  }
  while (v9 != v8);
  BOOL v11 = *(void **)(v7 + 8);
  BOOL v12 = *(void **)(v7 + 16);
  if (v11 == v12)
  {
LABEL_13:
    BOOL v13 = 63;
  }
  else
  {
    BOOL v13 = 63;
    do
    {
      v13 &= (*(uint64_t (**)(void, uint64_t))(*(void *)*v11 + 48))(*v11, a2);
      if (v13 == 4) {
        goto LABEL_16;
      }
      ++v11;
    }
    while (v11 != v12);
    int v14 = *(void **)(v7 + 8);
    uint64_t v15 = *(void **)(v7 + 16);
    if (v14 != v15)
    {
      unsigned int v16 = 63;
      while (1)
      {
        v16 &= (*(uint64_t (**)(void, uint64_t))(*(void *)*v14 + 48))(*v14, a3);
        if (v16 == 4) {
          goto LABEL_16;
        }
        if (++v14 == v15) {
          goto LABEL_15;
        }
      }
    }
  }
  unsigned int v16 = 63;
LABEL_15:
  if (((v16 | v13) & 2) == 0)
  {
LABEL_16:
    LOBYTE(v17) = 4;
    return v17;
  }
  LODWORD(v17) = v10 & 6;
  if (v13) {
    LODWORD(v17) = v10;
  }
  if ((v13 & 2) == 0) {
    LODWORD(v17) = v10 & 5;
  }
  size_t v57 = v17;
  if ((v16 & 0x30) != 0)
  {
    if ((v13 & 0x30) != 0) {
      return v17;
    }
    LOBYTE(v17) = 4;
    if ((v13 & 3) == 0 || (v13 & 8) == 0) {
      return v17;
    }
    int v19 = *(_DWORD *)(a2 + 20);
    uint64_t v20 = a2 - 32 * (v19 & 0x7FFFFFF);
    uint64_t v21 = *(unsigned __int8 *)(a2 + 16);
    if (v21 == 84)
    {
      uint64_t v22 = 0;
    }
    else if (v21 == 39)
    {
      uint64_t v22 = (*(_DWORD *)(a2 + 80) + 1);
    }
    else
    {
      uint64_t v22 = 2;
    }
    if (v19 < 0 && (int v52 = *(void *)(v20 - 8), (v52 & 0xFFFFFFFF0) != 0)) {
      BOOL v23 = (*(_DWORD *)(v20 - 12) - *(_DWORD *)(v20 - v52));
    }
    else {
      BOOL v23 = 0;
    }
    uint64_t v24 = a2 - 32 * v22 - 32 * v23 - 32;
    if (v20 != v24)
    {
      uint64_t v25 = 4;
      uint64_t v26 = 1;
      int v53 = a2 - 32 * v22 - 32 * v23 - 32;
      while (1)
      {
        if (*(unsigned char *)(**(void **)v20 + 8) == 15)
        {
          BOOL v55 = v25;
          int v27 = (v20 - (a2 + 32 * (unint64_t)-(*(_DWORD *)(a2 + 20) & 0x7FFFFFF))) >> 5;
          v28.n128_f64[0] = llvm::MemoryLocation::getForArgument(a2, v27, *(uint64_t **)v7, (uint64_t)v58);
          unsigned int v29 = v7;
          uint64_t v30 = *(void **)(v7 + 8);
          uint64_t v31 = *(void **)(v7 + 16);
          BOOL v32 = 7;
          while (v30 != v31)
          {
            v32 &= (*(uint64_t (**)(void, uint64_t, unint64_t, __n128))(*(void *)*v30 + 40))(*v30, a2, v27, v28);
            if ((v32 & 3) == 0)
            {
              BOOL v32 = 4;
              break;
            }
            ++v30;
          }
          if ((unsigned int v7 = v29,
                int ModRefInfo = llvm::AAResults::getModRefInfo(v29, a3, (uint64_t)v58, a4),
                uint64_t v24 = v53,
                (v32 & 2) != 0)
            && (ModRefInfo & 3) != 0
            || (v32 & 1) != 0 && (ModRefInfo & 2) != 0)
          {
            uint64_t v25 = (v32 | v55) & v57;
          }
          else
          {
            uint64_t v25 = v55;
          }
          v26 &= ModRefInfo < 4;
          if (v57 == v25) {
            break;
          }
        }
        v20 += 32;
        if (v20 == v24) {
          goto LABEL_79;
        }
      }
      if (v20 + 32 != v53) {
        uint64_t v26 = 0;
      }
      LOBYTE(v25) = v57;
LABEL_79:
      LOBYTE(v17) = v25 & 3;
      if ((v25 & 3) != 0)
      {
        int v49 = v25 | 4;
        int v50 = (v26 & 1) == 0;
        goto LABEL_81;
      }
    }
    goto LABEL_16;
  }
  LOBYTE(v17) = 4;
  if ((v16 & 3) == 0 || (v16 & 8) == 0) {
    return v17;
  }
  unint64_t v34 = *(_DWORD *)(a3 + 20);
  int v35 = a3 - 32 * (v34 & 0x7FFFFFF);
  unsigned int v36 = *(unsigned __int8 *)(a3 + 16);
  if (v36 == 84) {
    uint64_t v17 = 0;
  }
  else {
    uint64_t v17 = v36 == 39 ? (*(_DWORD *)(a3 + 80) + 1) : 2;
  }
  if (v34 < 0 && (uint64_t v51 = *(void *)(v35 - 8), (v51 & 0xFFFFFFFF0) != 0)) {
    int v37 = (*(_DWORD *)(v35 - 12) - *(_DWORD *)(v35 - v51));
  }
  else {
    int v37 = 0;
  }
  uint64_t v38 = a3 - 32 * v17 - 32 * v37 - 32;
  LOBYTE(v17) = 4;
  if (v35 == v38) {
    return v17;
  }
  unint64_t v39 = 1;
  uint64_t v40 = 4;
  int v54 = v7;
  unsigned int v56 = v38;
  while (*(unsigned char *)(**(void **)v35 + 8) != 15)
  {
LABEL_69:
    v35 += 32;
    if (v35 == v38) {
      goto LABEL_74;
    }
  }
  int v41 = (v35 - (a3 + 32 * (unint64_t)-(*(_DWORD *)(a3 + 20) & 0x7FFFFFF))) >> 5;
  v42.n128_f64[0] = llvm::MemoryLocation::getForArgument(a3, v41, *(uint64_t **)v7, (uint64_t)v58);
  uint64_t v43 = *(void **)(v7 + 8);
  unint64_t v44 = *(void **)(v7 + 16);
  uint64_t v45 = 7;
  while (v43 != v44)
  {
    v45 &= (*(uint64_t (**)(void, uint64_t, unint64_t, __n128))(*(void *)*v43 + 40))(*v43, a3, v41, v42);
    if ((v45 & 3) == 0)
    {
      LOBYTE(v45) = 4;
      break;
    }
    ++v43;
  }
  if (v45) {
    int v46 = 6;
  }
  else {
    int v46 = 4;
  }
  if ((v45 & 2) != 0) {
    BOOL v47 = 7;
  }
  else {
    BOOL v47 = v46;
  }
  unsigned int v7 = v54;
  uint64_t v48 = llvm::AAResults::getModRefInfo(v54, a2, (uint64_t)v58, a4);
  v39 &= v48 < 4;
  uint64_t v40 = (v47 & v48 | v40) & v57;
  if (v40 != v57)
  {
    uint64_t v38 = v56;
    goto LABEL_69;
  }
  if (v35 + 32 != v56) {
    unint64_t v39 = 0;
  }
  LOBYTE(v40) = v57;
LABEL_74:
  LOBYTE(v17) = v40 & 3;
  if ((v40 & 3) == 0) {
    goto LABEL_16;
  }
  int v49 = v40 | 4;
  int v50 = (v39 & 1) == 0;
LABEL_81:
  if (v50) {
    LOBYTE(v17) = v49;
  }
  return v17;
}

{
  void *v8;
  void *v9;
  unsigned int v10;
  void *v11;
  void *v12;
  int v13;
  uint64_t v14;
  uint64_t result;
  void *v16;
  void *v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  __n128 v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned __int8 v31;
  BOOL v32;
  int v33;
  void *v34;
  void *v35;
  int v36;
  uint64_t v37;
  void *v38;
  int v39;
  uint64_t v40;
  char v41;
  unsigned char v42[48];

  unsigned int v8 = *(void **)(a1 + 8);
  int v9 = *(void **)(a1 + 16);
  if (v8 == v9)
  {
    LOBYTE(v13) = 63;
    uint64_t v10 = 7;
  }
  else
  {
    uint64_t v10 = 7;
    do
    {
      v10 &= (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(*(void *)*v8 + 64))(*v8, a2, a3, a4);
      if ((v10 & 3) == 0) {
        return 4;
      }
      ++v8;
    }
    while (v8 != v9);
    BOOL v11 = *(void **)(a1 + 8);
    BOOL v12 = *(void **)(a1 + 16);
    BOOL v13 = 63;
    if (v11 != v12)
    {
      do
      {
        v13 &= (*(uint64_t (**)(void, uint64_t))(*(void *)*v11 + 48))(*v11, a2);
        if (v13 == 4) {
          return 4;
        }
        ++v11;
      }
      while (v11 != v12);
      if ((v13 & 0x28) == 0) {
        return 4;
      }
      if ((v13 & 2) == 0)
      {
        int v14 = v10 & 5;
        goto LABEL_11;
      }
    }
  }
  if (v13) {
    int v14 = v10;
  }
  else {
    int v14 = v10 & 6;
  }
LABEL_11:
  if ((v13 & 0x20) != 0) {
    goto LABEL_12;
  }
  uint64_t result = 4;
  if ((v13 & 3) != 0 && (v13 & 8) != 0)
  {
    int v18 = *(_DWORD *)(a2 + 20);
    int v19 = a2 - 32 * (v18 & 0x7FFFFFF);
    uint64_t v20 = *(unsigned __int8 *)(a2 + 16);
    if (v20 == 84) {
      uint64_t v21 = 0;
    }
    else {
      uint64_t v21 = v20 == 39 ? (*(_DWORD *)(a2 + 80) + 1) : 2;
    }
    if (v18 < 0 && (int v37 = *(void *)(v19 - 8), (v37 & 0xFFFFFFFF0) != 0)) {
      uint64_t v22 = (*(_DWORD *)(v19 - 12) - *(_DWORD *)(v19 - v37));
    }
    else {
      uint64_t v22 = 0;
    }
    BOOL v23 = a2 - 32 * v21 - 32 * v22 - 32;
    if (v19 != v23)
    {
      uint64_t v24 = 0;
      uint64_t v25 = 1;
      unint64_t v39 = 4;
      uint64_t v40 = v23;
      while (*(unsigned char *)(**(void **)v19 + 8) != 15)
      {
LABEL_32:
        v19 += 32;
        uint64_t v24 = (v24 + 1);
        if (v19 == v23)
        {
          if ((v39 & 3) == 0) {
            return 4;
          }
          if (v25) {
            int v14 = v39 & v14 & 3;
          }
          else {
            int v14 = v39 & v14 | 4;
          }
LABEL_12:
          if ((v14 & 2) != 0)
          {
            uint64_t v17 = *(void **)(a1 + 8);
            unsigned int v16 = *(void **)(a1 + 16);
            while (v17 != v16)
            {
              if ((*(unsigned int (**)(void, uint64_t, uint64_t, void))(*(void *)*v17 + 32))(*v17, a3, a4, 0))
              {
                return v14 & 5;
              }
              ++v17;
            }
          }
          return v14;
        }
      }
      v26.n128_f64[0] = llvm::MemoryLocation::getForArgument(a2, v24, *(uint64_t **)a1, (uint64_t)v42);
      int v27 = *(_DWORD *)(a4 + 336);
      *(_DWORD *)(a4 + 336) = v27 + 1;
      int v28 = *(void *)(a1 + 8);
      unsigned int v29 = *(void *)(a1 + 16);
      if (v28 == v29)
      {
        *(_DWORD *)(a4 + 336) = v27;
        unsigned int v36 = 7;
        BOOL v33 = 1;
      }
      else
      {
        int v41 = v25;
        uint64_t v30 = v28 + 8;
        do
        {
          uint64_t v31 = (*(uint64_t (**)(void, unsigned char *, uint64_t, uint64_t, __n128))(**(void **)(v30 - 8) + 24))(*(void *)(v30 - 8), v42, a3, a4, v26);
          BOOL v32 = v31 != 1 || v30 == v29;
          v30 += 8;
        }
        while (!v32);
        --*(_DWORD *)(a4 + 336);
        BOOL v33 = v31;
        if (!v31)
        {
          uint64_t v25 = v41;
          BOOL v23 = v40;
LABEL_43:
          v25 &= v33 == 3;
          goto LABEL_32;
        }
        int v35 = *(void **)(a1 + 8);
        unint64_t v34 = *(void **)(a1 + 16);
        uint64_t v38 = v34;
        unsigned int v36 = 7;
        while (v35 != v34)
        {
          v36 &= (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)*v35 + 40))(*v35, a2, v24);
          if ((v36 & 3) == 0)
          {
            unsigned int v36 = 4;
            break;
          }
          ++v35;
          unint64_t v34 = v38;
        }
        uint64_t v25 = v41;
      }
      BOOL v23 = v40;
      v39 |= v36;
      goto LABEL_43;
    }
  }
  return result;
}

uint64_t llvm::AAResults::getModRefInfo(llvm::AAResults *this, const llvm::CallBase *a2, const llvm::MemoryLocation *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  v8[0] = 1;
  uint64_t v3 = 1;
  do
  {
    uint64_t v4 = &v8[v3];
    *(_OWORD *)uint64_t v4 = xmmword_1CFAC3060;
    *((_OWORD *)v4 + 1) = xmmword_1CFAC3060;
    v3 += 5;
  }
  while (v4 + 5 != v9);
  v9[0] = &v13;
  v9[1] = 0;
  uint64_t v10 = v12;
  uint64_t v11 = 0x400000000;
  BOOL v13 = &unk_1F2600DB8;
  uint64_t v14 = 1;
  for (uint64_t i = 63; i != 79; i += 2)
    v8[i] = -4096;
  uint64_t ModRefInfo = llvm::AAResults::getModRefInfo((uint64_t)this, (uint64_t)a2, (uint64_t)a3, (uint64_t)v8);
  if ((v14 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v15, 8);
  }
  if (v10 != v12) {
    free(v10);
  }
  if ((v8[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v8[1], 8);
  }
  return ModRefInfo;
}

uint64_t llvm::AAResults::getModRefBehavior(uint64_t a1, uint64_t a2)
{
  int v2 = *(void **)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 16);
  if (v2 == v3) {
    return 63;
  }
  LODWORD(v5) = 63;
  do
  {
    uint64_t v5 = (*(unsigned int (**)(void, uint64_t))(*(void *)*v2 + 48))(*v2, a2) & v5;
    if (v5 == 4) {
      break;
    }
    ++v2;
  }
  while (v2 != v3);
  return v5;
}

uint64_t llvm::AAResults::getModRefInfo(llvm::AAResults *this, const llvm::CallBase *a2, const llvm::CallBase *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  v8[0] = 1;
  uint64_t v3 = 1;
  do
  {
    uint64_t v4 = &v8[v3];
    *(_OWORD *)uint64_t v4 = xmmword_1CFAC3060;
    *((_OWORD *)v4 + 1) = xmmword_1CFAC3060;
    v3 += 5;
  }
  while (v4 + 5 != v9);
  v9[0] = &v13;
  v9[1] = 0;
  uint64_t v10 = v12;
  uint64_t v11 = 0x400000000;
  BOOL v13 = &unk_1F2600DB8;
  uint64_t v14 = 1;
  for (uint64_t i = 63; i != 79; i += 2)
    v8[i] = -4096;
  uint64_t ModRefInfo = llvm::AAResults::getModRefInfo((uint64_t)this, (uint64_t)a2, (uint64_t)a3, (uint64_t)v8);
  if ((v14 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v15, 8);
  }
  if (v10 != v12) {
    free(v10);
  }
  if ((v8[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v8[1], 8);
  }
  return ModRefInfo;
}

uint64_t llvm::AAResults::getModRefBehavior(llvm::AAResults *this, const Function *a2)
{
  int v2 = (void *)*((void *)this + 1);
  uint64_t v3 = (void *)*((void *)this + 2);
  if (v2 == v3) {
    return 63;
  }
  LODWORD(v5) = 63;
  do
  {
    uint64_t v5 = (*(unsigned int (**)(void, const Function *))(*(void *)*v2 + 56))(*v2, a2) & v5;
    if (v5 == 4) {
      break;
    }
    ++v2;
  }
  while (v2 != v3);
  return v5;
}

uint64_t llvm::AAResults::getModRefInfo(llvm::AAResults *this, const llvm::LoadInst *a2, const llvm::MemoryLocation *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  v8[0] = 1;
  uint64_t v3 = 1;
  do
  {
    uint64_t v4 = &v8[v3];
    *(_OWORD *)uint64_t v4 = xmmword_1CFAC3060;
    *((_OWORD *)v4 + 1) = xmmword_1CFAC3060;
    v3 += 5;
  }
  while (v4 + 5 != v9);
  v9[0] = &v13;
  v9[1] = 0;
  uint64_t v10 = v12;
  uint64_t v11 = 0x400000000;
  BOOL v13 = &unk_1F2600DB8;
  uint64_t v14 = 1;
  for (uint64_t i = 63; i != 79; i += 2)
    v8[i] = -4096;
  uint64_t ModRefInfo = llvm::AAResults::getModRefInfo((uint64_t)this, (uint64_t)a2, a3, (uint64_t)v8);
  if ((v14 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v15, 8);
  }
  if (v10 != v12) {
    free(v10);
  }
  if ((v8[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v8[1], 8);
  }
  return ModRefInfo;
}

uint64_t llvm::AAResults::getModRefInfo(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  if ((*(_WORD *)(a2 + 18) & 0x300) != 0) {
    return 7;
  }
  if (!*a3) {
    return 5;
  }
  uint64_t v9 = *(void *)(a2 - 32);
  uint64_t v10 = sub_1CB83544C(*(void *)(*(void *)(*(void *)(a2 + 40) + 56) + 40) + 272, *(void *)a2);
  if (v11 == 1) {
    unint64_t v12 = -2;
  }
  else {
    unint64_t v12 = (unint64_t)(v10 + 7) >> 3;
  }
  llvm::Instruction::getAAMetadata((uint64_t ***)a2, v21);
  v20[0] = v9;
  v20[1] = v12;
  int v13 = *(_DWORD *)(a4 + 336);
  *(_DWORD *)(a4 + 336) = v13 + 1;
  uint64_t v14 = *(void *)(a1 + 8);
  uint64_t v15 = *(void *)(a1 + 16);
  if (v14 == v15)
  {
    *(_DWORD *)(a4 + 336) = v13;
    return 5;
  }
  uint64_t v16 = v14 + 8;
  do
  {
    char v17 = (*(uint64_t (**)(void, void *, void *, uint64_t))(**(void **)(v16 - 8) + 24))(*(void *)(v16 - 8), v20, a3, a4);
    BOOL v18 = v17 != 1 || v16 == v15;
    v16 += 8;
  }
  while (!v18);
  if (v17 == 3) {
    unsigned int v19 = 1;
  }
  else {
    unsigned int v19 = 5;
  }
  if (v17) {
    uint64_t result = v19;
  }
  else {
    uint64_t result = 4;
  }
  --*(_DWORD *)(a4 + 336);
  return result;
}

{
  uint64_t v9;
  uint64_t v10;
  int v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 v17;
  BOOL v18;
  int v19;
  void *v20;
  void *v21;
  void v22[2];
  void v23[4];

  if ((*(_WORD *)(a2 + 18) & 0x300) != 0) {
    return 7;
  }
  if (*a3)
  {
    uint64_t v9 = *(void *)(a2 - 32);
    uint64_t v10 = sub_1CB83544C(*(void *)(*(void *)(*(void *)(a2 + 40) + 56) + 40) + 272, **(void **)(a2 - 64));
    if (v11 == 1) {
      unint64_t v12 = -2;
    }
    else {
      unint64_t v12 = (unint64_t)(v10 + 7) >> 3;
    }
    llvm::Instruction::getAAMetadata((uint64_t ***)a2, v23);
    v22[0] = v9;
    v22[1] = v12;
    int v13 = *(_DWORD *)(a4 + 336);
    *(_DWORD *)(a4 + 336) = v13 + 1;
    uint64_t v14 = *(void *)(a1 + 8);
    uint64_t v15 = *(void *)(a1 + 16);
    if (v14 == v15)
    {
      *(_DWORD *)(a4 + 336) = v13;
    }
    else
    {
      uint64_t v16 = v14 + 8;
      do
      {
        char v17 = (*(uint64_t (**)(void, void *, void *, uint64_t))(**(void **)(v16 - 8) + 24))(*(void *)(v16 - 8), v22, a3, a4);
        BOOL v18 = v17 != 1 || v16 == v15;
        v16 += 8;
      }
      while (!v18);
      --*(_DWORD *)(a4 + 336);
      unsigned int v19 = v17;
      if (!v17) {
        return 4;
      }
      uint64_t v21 = *(void **)(a1 + 8);
      uint64_t v20 = *(void **)(a1 + 16);
      while (v21 != v20)
      {
        if ((*(uint64_t (**)(void, void *, uint64_t, void))(*(void *)*v21 + 32))(*v21, a3, a4, 0)) {
          return 4;
        }
        ++v21;
      }
      if (v19 == 3) {
        return 2;
      }
    }
  }
  return 6;
}

{
  void *v4;
  void *v5;

  if (!*a3) {
    return 7;
  }
  uint64_t v4 = *(void **)(a1 + 8);
  uint64_t v5 = *(void **)(a1 + 16);
  if (v4 == v5) {
    return 7;
  }
  while (!(*(unsigned int (**)(void, void *, uint64_t, void))(*(void *)*v4 + 32))(*v4, a3, a4, 0))
  {
    if (++v4 == v5) {
      return 7;
    }
  }
  return 5;
}

{
  void *v4;
  void *v5;

  if (!*a3) {
    return 7;
  }
  uint64_t v4 = *(void **)(a1 + 8);
  uint64_t v5 = *(void **)(a1 + 16);
  if (v4 == v5) {
    return 7;
  }
  while (!(*(unsigned int (**)(void, void *, uint64_t, void))(*(void *)*v4 + 32))(*v4, a3, a4, 0))
  {
    if (++v4 == v5) {
      return 7;
    }
  }
  return 4;
}

{
  void *v4;
  void *v5;

  if (!*a3) {
    return 7;
  }
  uint64_t v4 = *(void **)(a1 + 8);
  uint64_t v5 = *(void **)(a1 + 16);
  if (v4 == v5) {
    return 7;
  }
  while (!(*(unsigned int (**)(void, void *, uint64_t, void))(*(void *)*v4 + 32))(*v4, a3, a4, 0))
  {
    if (++v4 == v5) {
      return 7;
    }
  }
  return 4;
}

{
  uint64_t v9;
  uint64_t v10;
  int v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  BOOL v18;
  unsigned __int8 v19;
  void v21[2];
  void v22[4];

  if ((((unint64_t)*(unsigned __int16 *)(a2 + 18) >> 1) & 7) - 3 < 5 || *a3 == 0) {
    return 7;
  }
  uint64_t v9 = *(void *)(a2 - 64);
  uint64_t v10 = sub_1CB83544C(*(void *)(*(void *)(*(void *)(a2 + 40) + 56) + 40) + 272, **(void **)(a2 - 32));
  if (v11 == 1) {
    unint64_t v12 = -2;
  }
  else {
    unint64_t v12 = (unint64_t)(v10 + 7) >> 3;
  }
  llvm::Instruction::getAAMetadata((uint64_t ***)a2, v22);
  v21[0] = v9;
  v21[1] = v12;
  int v13 = *(_DWORD *)(a4 + 336);
  *(_DWORD *)(a4 + 336) = v13 + 1;
  uint64_t v14 = *(void *)(a1 + 8);
  uint64_t v15 = *(void *)(a1 + 16);
  if (v14 == v15)
  {
    *(_DWORD *)(a4 + 336) = v13;
    return 7;
  }
  uint64_t v16 = v14 + 8;
  do
  {
    char v17 = (*(uint64_t (**)(void, void *, void *, uint64_t))(**(void **)(v16 - 8) + 24))(*(void *)(v16 - 8), v21, a3, a4);
    BOOL v18 = v17 != 1 || v16 == v15;
    v16 += 8;
  }
  while (!v18);
  if (v17 == 3) {
    unsigned int v19 = 3;
  }
  else {
    unsigned int v19 = 7;
  }
  if (!v17) {
    unsigned int v19 = 4;
  }
  --*(_DWORD *)(a4 + 336);
  return v19;
}

uint64_t llvm::AAResults::getModRefInfo(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  v11[0] = 1;
  uint64_t v4 = 1;
  do
  {
    uint64_t v5 = &v11[v4];
    *(_OWORD *)uint64_t v5 = xmmword_1CFAC3060;
    *((_OWORD *)v5 + 1) = xmmword_1CFAC3060;
    v4 += 5;
  }
  while (v5 + 5 != v12);
  v12[0] = &v16;
  v12[1] = 0;
  int v13 = v15;
  uint64_t v14 = 0x400000000;
  uint64_t v16 = &unk_1F2600DB8;
  uint64_t v17 = 1;
  for (uint64_t i = 63; i != 79; i += 2)
    v11[i] = -4096;
  if (*a3)
  {
    unsigned int v7 = *(void **)(a1 + 8);
    unsigned int v8 = *(void **)(a1 + 16);
    while (v7 != v8)
    {
      if ((*(unsigned int (**)(void, void *, void *, void))(*(void *)*v7 + 32))(*v7, a3, v11, 0))
      {
        uint64_t v9 = 5;
        goto LABEL_11;
      }
      ++v7;
    }
  }
  uint64_t v9 = 7;
LABEL_11:
  if ((v17 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v18, 8);
  }
  if (v13 != v15) {
    free(v13);
  }
  if ((v11[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v11[1], 8);
  }
  return v9;
}

{
  uint64_t v4;
  void *v5;
  uint64_t i;
  void *v7;
  void *v8;
  uint64_t v9;
  void v11[41];
  void v12[2];
  void *v13;
  uint64_t v14;
  unsigned char v15[128];
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  uint64_t v19 = *MEMORY[0x1E4F143B8];
  v11[0] = 1;
  uint64_t v4 = 1;
  do
  {
    uint64_t v5 = &v11[v4];
    *(_OWORD *)uint64_t v5 = xmmword_1CFAC3060;
    *((_OWORD *)v5 + 1) = xmmword_1CFAC3060;
    v4 += 5;
  }
  while (v5 + 5 != v12);
  v12[0] = &v16;
  v12[1] = 0;
  int v13 = v15;
  uint64_t v14 = 0x400000000;
  uint64_t v16 = &unk_1F2600DB8;
  uint64_t v17 = 1;
  for (uint64_t i = 63; i != 79; i += 2)
    v11[i] = -4096;
  if (*a3)
  {
    unsigned int v7 = *(void **)(a1 + 8);
    unsigned int v8 = *(void **)(a1 + 16);
    while (v7 != v8)
    {
      if ((*(unsigned int (**)(void, void *, void *, void))(*(void *)*v7 + 32))(*v7, a3, v11, 0))
      {
        uint64_t v9 = 4;
        goto LABEL_11;
      }
      ++v7;
    }
  }
  uint64_t v9 = 7;
LABEL_11:
  if ((v17 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v18, 8);
  }
  if (v13 != v15) {
    free(v13);
  }
  if ((v11[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v11[1], 8);
  }
  return v9;
}

{
  uint64_t v4;
  void *v5;
  uint64_t i;
  void *v7;
  void *v8;
  uint64_t v9;
  void v11[41];
  void v12[2];
  void *v13;
  uint64_t v14;
  unsigned char v15[128];
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  uint64_t v19 = *MEMORY[0x1E4F143B8];
  v11[0] = 1;
  uint64_t v4 = 1;
  do
  {
    uint64_t v5 = &v11[v4];
    *(_OWORD *)uint64_t v5 = xmmword_1CFAC3060;
    *((_OWORD *)v5 + 1) = xmmword_1CFAC3060;
    v4 += 5;
  }
  while (v5 + 5 != v12);
  v12[0] = &v16;
  v12[1] = 0;
  int v13 = v15;
  uint64_t v14 = 0x400000000;
  uint64_t v16 = &unk_1F2600DB8;
  uint64_t v17 = 1;
  for (uint64_t i = 63; i != 79; i += 2)
    v11[i] = -4096;
  if (*a3)
  {
    unsigned int v7 = *(void **)(a1 + 8);
    unsigned int v8 = *(void **)(a1 + 16);
    while (v7 != v8)
    {
      if ((*(unsigned int (**)(void, void *, void *, void))(*(void *)*v7 + 32))(*v7, a3, v11, 0))
      {
        uint64_t v9 = 4;
        goto LABEL_11;
      }
      ++v7;
    }
  }
  uint64_t v9 = 7;
LABEL_11:
  if ((v17 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v18, 8);
  }
  if (v13 != v15) {
    free(v13);
  }
  if ((v11[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v11[1], 8);
  }
  return v9;
}

uint64_t llvm::AAResults::getModRefInfo(llvm::AAResults *this, const llvm::VAArgInst *a2, const llvm::MemoryLocation *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  v8[0] = 1;
  uint64_t v3 = 1;
  do
  {
    uint64_t v4 = &v8[v3];
    *(_OWORD *)uint64_t v4 = xmmword_1CFAC3060;
    *((_OWORD *)v4 + 1) = xmmword_1CFAC3060;
    v3 += 5;
  }
  while (v4 + 5 != v9);
  v9[0] = &v13;
  v9[1] = 0;
  uint64_t v10 = v12;
  uint64_t v11 = 0x400000000;
  int v13 = &unk_1F2600DB8;
  uint64_t v14 = 1;
  for (uint64_t i = 63; i != 79; i += 2)
    v8[i] = -4096;
  uint64_t ModRefInfo = llvm::AAResults::getModRefInfo((uint64_t)this, a2, a3, (uint64_t)v8);
  if ((v14 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v15, 8);
  }
  if (v10 != v12) {
    free(v10);
  }
  if ((v8[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v8[1], 8);
  }
  return ModRefInfo;
}

uint64_t llvm::AAResults::getModRefInfo(uint64_t a1, llvm::Instruction *this, void *a3, uint64_t a4)
{
  if (*a3)
  {
    uint64_t v7 = *((void *)this - 4);
    llvm::Instruction::getAAMetadata((uint64_t ***)this, v19);
    v18[0] = v7;
    v18[1] = -2;
    int v8 = *(_DWORD *)(a4 + 336);
    *(_DWORD *)(a4 + 336) = v8 + 1;
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v10 = *(void *)(a1 + 16);
    if (v9 == v10)
    {
      *(_DWORD *)(a4 + 336) = v8;
    }
    else
    {
      uint64_t v11 = v9 + 8;
      do
      {
        unsigned __int8 v12 = (*(uint64_t (**)(void, void *, void *, uint64_t))(**(void **)(v11 - 8) + 24))(*(void *)(v11 - 8), v18, a3, a4);
        BOOL v13 = v12 != 1 || v11 == v10;
        v11 += 8;
      }
      while (!v13);
      --*(_DWORD *)(a4 + 336);
      int v14 = v12;
      if (!v12) {
        return 4;
      }
      uint64_t v16 = *(void **)(a1 + 8);
      uint64_t v15 = *(void **)(a1 + 16);
      while (v16 != v15)
      {
        if ((*(uint64_t (**)(void, void *, uint64_t, void))(*(void *)*v16 + 32))(*v16, a3, a4, 0)) {
          return 4;
        }
        ++v16;
      }
      if (v14 == 3) {
        return 3;
      }
    }
  }
  return 7;
}

uint64_t llvm::AAResults::getModRefInfo(llvm::AAResults *this, const llvm::AtomicCmpXchgInst *a2, const llvm::MemoryLocation *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  v8[0] = 1;
  uint64_t v3 = 1;
  do
  {
    uint64_t v4 = &v8[v3];
    *(_OWORD *)uint64_t v4 = xmmword_1CFAC3060;
    *((_OWORD *)v4 + 1) = xmmword_1CFAC3060;
    v3 += 5;
  }
  while (v4 + 5 != v9);
  v9[0] = &v13;
  v9[1] = 0;
  uint64_t v10 = v12;
  uint64_t v11 = 0x400000000;
  BOOL v13 = &unk_1F2600DB8;
  uint64_t v14 = 1;
  for (uint64_t i = 63; i != 79; i += 2)
    v8[i] = -4096;
  uint64_t ModRefInfo = llvm::AAResults::getModRefInfo((uint64_t)this, (unsigned __int16 *)a2, a3, (uint64_t)v8);
  if ((v14 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v15, 8);
  }
  if (v10 != v12) {
    free(v10);
  }
  if ((v8[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v8[1], 8);
  }
  return ModRefInfo;
}

uint64_t llvm::AAResults::getModRefInfo(uint64_t a1, unsigned __int16 *a2, void *a3, uint64_t a4)
{
  if ((((unint64_t)a2[9] >> 2) & 7) - 3 < 5 || *a3 == 0) {
    return 7;
  }
  llvm::MemoryLocation::get((llvm::MemoryLocation *)a2, v16);
  int v8 = *(_DWORD *)(a4 + 336);
  *(_DWORD *)(a4 + 336) = v8 + 1;
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = *(void *)(a1 + 16);
  if (v9 == v10)
  {
    *(_DWORD *)(a4 + 336) = v8;
    return 7;
  }
  uint64_t v11 = v9 + 8;
  do
  {
    char v12 = (*(uint64_t (**)(void, void *, void *, uint64_t))(**(void **)(v11 - 8) + 24))(*(void *)(v11 - 8), v16, a3, a4);
    BOOL v13 = v12 != 1 || v11 == v10;
    v11 += 8;
  }
  while (!v13);
  if (v12 == 3) {
    unsigned __int8 v14 = 3;
  }
  else {
    unsigned __int8 v14 = 7;
  }
  if (!v12) {
    unsigned __int8 v14 = 4;
  }
  --*(_DWORD *)(a4 + 336);
  return v14;
}

uint64_t llvm::AAResults::getModRefInfo(llvm::AAResults *this, const llvm::AtomicRMWInst *a2, const llvm::MemoryLocation *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  v8[0] = 1;
  uint64_t v3 = 1;
  do
  {
    uint64_t v4 = &v8[v3];
    *(_OWORD *)uint64_t v4 = xmmword_1CFAC3060;
    *((_OWORD *)v4 + 1) = xmmword_1CFAC3060;
    v3 += 5;
  }
  while (v4 + 5 != v9);
  v9[0] = &v13;
  v9[1] = 0;
  uint64_t v10 = v12;
  uint64_t v11 = 0x400000000;
  BOOL v13 = &unk_1F2600DB8;
  uint64_t v14 = 1;
  for (uint64_t i = 63; i != 79; i += 2)
    v8[i] = -4096;
  uint64_t ModRefInfo = llvm::AAResults::getModRefInfo((uint64_t)this, (uint64_t)a2, a3, (uint64_t)v8);
  if ((v14 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v15, 8);
  }
  if (v10 != v12) {
    free(v10);
  }
  if ((v8[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v8[1], 8);
  }
  return ModRefInfo;
}

uint64_t llvm::AAResults::getModRefInfo(uint64_t a1, llvm::Instruction *this, long long *a3, uint64_t a4)
{
  if (*((unsigned char *)a3 + 48))
  {
    int v6 = *((unsigned __int8 *)this + 16);
    long long v7 = a3[1];
    long long v22 = *a3;
    long long v23 = v7;
    long long v8 = a3[2];
  }
  else
  {
    int v6 = *((unsigned __int8 *)this + 16);
    if ((v6 - 33) <= 0x33 && ((1 << (v6 - 33)) & 0x8000000000041) != 0)
    {
      char v12 = *(void **)(a1 + 8);
      BOOL v13 = *(void **)(a1 + 16);
      int v14 = 63;
      while (v12 != v13)
      {
        v14 &= (*(uint64_t (**)(void, llvm::Instruction *))(*(void *)*v12 + 48))(*v12, this);
        if (v14 == 4) {
          break;
        }
        ++v12;
      }
      return v14 & 7;
    }
    *(void *)&long long v22 = 0;
    *((void *)&v22 + 1) = -1;
    long long v8 = 0uLL;
    long long v23 = 0u;
  }
  long long v24 = v8;
  uint64_t v9 = 4;
  if (v6 <= 59)
  {
    if (v6 == 33) {
      return llvm::AAResults::getModRefInfo(a1, (uint64_t)this, (uint64_t)&v22, a4);
    }
    if (v6 != 37)
    {
      if (v6 != 39) {
        return v9;
      }
      return llvm::AAResults::getModRefInfo(a1, (uint64_t)this, (uint64_t)&v22, a4);
    }
    if ((void)v22)
    {
      uint64_t v18 = *(void **)(a1 + 8);
      uint64_t v19 = *(void **)(a1 + 16);
      if (v18 != v19)
      {
        while (!(*(unsigned int (**)(void, long long *, uint64_t, void))(*(void *)*v18 + 32))(*v18, &v22, a4, 0))
        {
          ++v18;
          uint64_t v9 = 7;
          if (v18 == v19) {
            return v9;
          }
        }
        return 4;
      }
    }
    return 7;
  }
  if (v6 > 79)
  {
    if (v6 != 80)
    {
      if (v6 != 84)
      {
        if (v6 != 88) {
          return v9;
        }
        return llvm::AAResults::getModRefInfo(a1, this, &v22, a4);
      }
      return llvm::AAResults::getModRefInfo(a1, (uint64_t)this, (uint64_t)&v22, a4);
    }
    if ((void)v22)
    {
      uint64_t v20 = *(void **)(a1 + 8);
      uint64_t v21 = *(void **)(a1 + 16);
      if (v20 != v21)
      {
        while (((*(uint64_t (**)(void, long long *, uint64_t, void))(*(void *)*v20 + 32))(*v20, &v22, a4, 0) & 1) == 0)
        {
          ++v20;
          uint64_t v9 = 7;
          if (v20 == v21) {
            return v9;
          }
        }
        return 4;
      }
    }
    return 7;
  }
  switch(v6)
  {
    case '<':
      return llvm::AAResults::getModRefInfo(a1, (uint64_t)this, &v22, a4);
    case '=':
      return llvm::AAResults::getModRefInfo(a1, (uint64_t)this, &v22, a4);
    case '?':
      if (!(void)v22) {
        return 7;
      }
      uint64_t v15 = *(void **)(a1 + 8);
      uint64_t v16 = *(void **)(a1 + 16);
      if (v15 == v16) {
        return 7;
      }
      break;
    case '@':
      return llvm::AAResults::getModRefInfo(a1, (unsigned __int16 *)this, &v22, a4);
    case 'A':
      return llvm::AAResults::getModRefInfo(a1, (uint64_t)this, &v22, a4);
    default:
      return v9;
  }
  while (((*(uint64_t (**)(void, long long *, uint64_t, void))(*(void *)*v15 + 32))(*v15, &v22, a4, 0) & 1) == 0)
  {
    ++v15;
    uint64_t v9 = 7;
    if (v15 == v16) {
      return v9;
    }
  }
  return 5;
}

uint64_t llvm::AAResults::callCapturesBefore(uint64_t a1, uint64_t a2, llvm **a3, uint64_t a4, uint64_t a5)
{
  if (!a4) {
    return 7;
  }
  UnderlyingObject = llvm::getUnderlyingObject(*a3, (const llvm::Value *)6);
  if (!llvm::isIdentifiedFunctionLocal(UnderlyingObject, v10)) {
    return 7;
  }
  int v13 = *(unsigned __int8 *)(a2 + 16);
  if (v13 != 84 && v13 != 39 && v13 != 33) {
    return 7;
  }
  if (UnderlyingObject == (llvm *)a2) {
    return 7;
  }
  uint64_t v30 = &unk_1F2601EF8;
  uint64_t v31 = a2;
  *(void *)&long long v32 = a4;
  WORD4(v32) = 257;
  BYTE10(v32) = 0;
  *(void *)&long long v33 = 0;
  llvm::PointerMayBeCaptured(UnderlyingObject, (const llvm::Value *)&v30, 0);
  if (BYTE10(v32)) {
    return 7;
  }
  uint64_t v14 = a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF);
  int v15 = *(unsigned __int8 *)(a2 + 16);
  if (v15 == 84)
  {
    uint64_t v16 = 0;
  }
  else if (v15 == 39)
  {
    uint64_t v16 = (*(_DWORD *)(a2 + 80) + 1);
  }
  else
  {
    uint64_t v16 = 2;
  }
  uint64_t v26 = a2 - 32 * v16 - 32;
  if (v14 != v26)
  {
    unsigned int v17 = 0;
    char v25 = 4;
    char v18 = 1;
    while (1)
    {
      if (*(unsigned char *)(**(void **)v14 + 8) == 15
        && ((sub_1CBF5BC2C(a2, v17, 22) & 1) != 0
         || v17 >= ((sub_1CBF5BBBC(a2) - (a2 + 32 * (unint64_t)-(*(_DWORD *)(a2 + 20) & 0x7FFFFFF))) >> 5)
         || llvm::CallBase::paramHasAttr(a2, v17, 69)))
      {
        uint64_t v30 = *(void **)v14;
        uint64_t v31 = -1;
        long long v32 = 0u;
        long long v33 = 0u;
        v27[0] = UnderlyingObject;
        v27[1] = -1;
        long long v28 = 0u;
        long long v29 = 0u;
        int v19 = *(_DWORD *)(a5 + 336);
        *(_DWORD *)(a5 + 336) = v19 + 1;
        uint64_t v20 = *(uint64_t **)(a1 + 8);
        uint64_t v21 = *(uint64_t **)(a1 + 16);
        if (v20 == v21)
        {
          char v18 = 0;
          *(_DWORD *)(a5 + 336) = v19;
LABEL_21:
          if ((sub_1CBF5BC2C(a2, v17, 44) & 1) == 0)
          {
            if ((sub_1CBF5BC2C(a2, v17, 45) & 1) == 0 && !sub_1CBF5BC2C(a2, v17, 44)) {
              return 7;
            }
            char v25 = 5;
          }
          goto LABEL_25;
        }
        do
        {
          uint64_t v22 = *v20++;
          int v23 = (*(unsigned __int8 (**)(uint64_t, void **, void *, uint64_t))(*(void *)v22 + 24))(v22, &v30, v27, a5);
        }
        while (v23 == 1 && v20 != v21);
        --*(_DWORD *)(a5 + 336);
        v18 &= v23 == 3;
        if (v23) {
          goto LABEL_21;
        }
      }
LABEL_25:
      v14 += 32;
      ++v17;
      if (v14 == v26)
      {
        if (v18) {
          return v25 & 3;
        }
        return (v25 | 4);
      }
    }
  }
  char v25 = 4;
  return v25 & 3;
}

uint64_t llvm::isIdentifiedFunctionLocal(llvm *this, const llvm::Value *a2)
{
  unsigned int v2 = *((unsigned __int8 *)this + 16);
  if (v2 == 59) {
    return 1;
  }
  if (v2 >= 0x1C)
  {
    unsigned int v5 = v2 - 33;
    BOOL v6 = v5 > 0x33;
    uint64_t v7 = (1 << v5) & 0x8000000000041;
    if (v6 || v7 == 0) {
      return 0;
    }
    if (sub_1CBF5BCC4((uint64_t)this, 19)) {
      return 1;
    }
    unsigned int v2 = *((unsigned __int8 *)this + 16);
  }
  if (v2 != 21) {
    return 0;
  }
  if (*(unsigned char *)(*(void *)this + 8) != 15) {
    return 0;
  }
  uint64_t v9 = *(void *)(*((void *)this + 3) + 112);
  if (!v9) {
    return 0;
  }
  unsigned int v10 = *((_DWORD *)this + 8) + 2;
  if (v10 < *(_DWORD *)(v9 + 8))
  {
    uint64_t v11 = *(void *)(v9 + 8 * v10 + 40);
    if (v11)
    {
      if ((*(unsigned char *)(v11 + 14) & 8) != 0) {
        return 1;
      }
    }
  }
  if (v10 >= *(_DWORD *)(v9 + 8)) {
    return 0;
  }
  uint64_t v12 = *(void *)(v9 + 8 * v10 + 40);
  if (!v12) {
    return 0;
  }
  return (*(unsigned __int8 *)(v12 + 20) >> 5) & 1;
}

uint64_t llvm::AAResults::canBasicBlockModify(llvm::AAResults *this, const llvm::BasicBlock *a2, const llvm::MemoryLocation *a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)a2 + 5);
  uint64_t v3 = *((void *)a2 + 6);
  if (v3) {
    uint64_t v5 = v3 - 24;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v4) {
    uint64_t v6 = v4 - 24;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = v5 + 24;
  uint64_t v8 = *(void *)(v6 + 32);
  if (v5 + 24 == v8) {
    return 0;
  }
  long long v10 = xmmword_1CFAC3060;
  do
  {
    long long v11 = *((_OWORD *)a3 + 1);
    v19[0] = *(_OWORD *)a3;
    v19[1] = v11;
    void v19[2] = *((_OWORD *)a3 + 2);
    char v20 = 1;
    v21[0] = 1;
    uint64_t v12 = 1;
    do
    {
      int v13 = &v21[v12];
      *(_OWORD *)int v13 = v10;
      *((_OWORD *)v13 + 1) = v10;
      v12 += 5;
    }
    while (v13 + 5 != v22);
    v22[0] = &v26;
    v22[1] = 0;
    int v23 = v25;
    uint64_t v24 = 0x400000000;
    uint64_t v26 = &unk_1F2600DB8;
    uint64_t v14 = 63;
    uint64_t v27 = 1;
    do
    {
      v21[v14] = -4096;
      v14 += 2;
    }
    while (v14 != 79);
    if (v7) {
      int v15 = (llvm::Instruction *)(v7 - 24);
    }
    else {
      int v15 = 0;
    }
    unsigned int ModRefInfo = llvm::AAResults::getModRefInfo((uint64_t)this, v15, v19, (uint64_t)v21);
    if ((v27 & 1) == 0) {
      MEMORY[0x1D25D9CD0](v28, 8);
    }
    long long v10 = xmmword_1CFAC3060;
    if (v23 != v25)
    {
      free(v23);
      long long v10 = xmmword_1CFAC3060;
    }
    if ((v21[0] & 1) == 0)
    {
      MEMORY[0x1D25D9CD0](v21[1], 8);
      long long v10 = xmmword_1CFAC3060;
    }
    uint64_t result = (ModRefInfo >> 1) & 1;
    if ((ModRefInfo & 2) != 0) {
      break;
    }
    uint64_t v7 = *(void *)(v7 + 8);
  }
  while (v7 != v8);
  return result;
}

BOOL llvm::AAResults::canInstructionRangeModRef(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, char a5)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a2 + 24;
  uint64_t v16 = *(void *)(a3 + 32);
  if (a2 + 24 == v16) {
    return 0;
  }
  int v7 = a5 & 3;
  long long v8 = xmmword_1CFAC3060;
  do
  {
    long long v9 = a4[1];
    v18[0] = *a4;
    v18[1] = v9;
    void v18[2] = a4[2];
    char v19 = 1;
    v20[0] = 1;
    uint64_t v10 = 1;
    do
    {
      long long v11 = &v20[v10];
      *(_OWORD *)long long v11 = v8;
      *((_OWORD *)v11 + 1) = v8;
      v10 += 5;
    }
    while (v11 + 5 != v21);
    v21[0] = &v25;
    v21[1] = 0;
    uint64_t v22 = v24;
    uint64_t v23 = 0x400000000;
    char v25 = &unk_1F2600DB8;
    uint64_t v12 = 63;
    uint64_t v26 = 1;
    do
    {
      v20[v12] = -4096;
      v12 += 2;
    }
    while (v12 != 79);
    if (v5) {
      int v13 = (llvm::Instruction *)(v5 - 24);
    }
    else {
      int v13 = 0;
    }
    int ModRefInfo = llvm::AAResults::getModRefInfo(a1, v13, v18, (uint64_t)v20);
    if ((v26 & 1) == 0) {
      MEMORY[0x1D25D9CD0](v27, 8);
    }
    long long v8 = xmmword_1CFAC3060;
    if (v22 != v24)
    {
      free(v22);
      long long v8 = xmmword_1CFAC3060;
    }
    if ((v20[0] & 1) == 0)
    {
      MEMORY[0x1D25D9CD0](v20[1], 8);
      long long v8 = xmmword_1CFAC3060;
    }
    BOOL result = (v7 & ModRefInfo) != 0;
    if ((v7 & ModRefInfo) != 0) {
      break;
    }
    uint64_t v5 = *(void *)(v5 + 8);
  }
  while (v5 != v16);
  return result;
}

uint64_t sub_1CBF5A248(uint64_t a1, llvm::Instruction *a2, long long *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  v8[0] = 1;
  uint64_t v3 = 1;
  do
  {
    uint64_t v4 = &v8[v3];
    *(_OWORD *)uint64_t v4 = xmmword_1CFAC3060;
    *((_OWORD *)v4 + 1) = xmmword_1CFAC3060;
    v3 += 5;
  }
  while (v4 + 5 != v9);
  v9[0] = &v13;
  v9[1] = 0;
  uint64_t v10 = v12;
  uint64_t v11 = 0x400000000;
  int v13 = &unk_1F2600DB8;
  uint64_t v14 = 1;
  for (uint64_t i = 63; i != 79; i += 2)
    v8[i] = -4096;
  uint64_t ModRefInfo = llvm::AAResults::getModRefInfo(a1, a2, a3, (uint64_t)v8);
  if ((v14 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v15, 8);
  }
  if (v10 != v12) {
    free(v10);
  }
  if ((v8[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v8[1], 8);
  }
  return ModRefInfo;
}

void llvm::initializeExternalAAWrapperPassPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC3030, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBF5A408;
    v3[1] = &v1;
    unsigned int v2 = v3;
    std::__call_once(&qword_1EBCC3030, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBF5A408()
{
}

void sub_1CBF5A4AC(llvm *a1, llvm::PassRegistry *a2)
{
  llvm::initializeBasicAAWrapperPassPass(a1, a2);
  llvm::initializeCFLAndersAAWrapperPassPass(a1, v3);
  llvm::initializeCFLSteensAAWrapperPassPass(a1, v4);
  uint64_t v11 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC3030, memory_order_acquire) != -1)
  {
    v13[0] = sub_1CBF5A408;
    v13[1] = &v11;
    uint64_t v12 = v13;
    std::__call_once(&qword_1EBCC3030, &v12, (void (__cdecl *)(void *))sub_1CB848390);
  }
  llvm::initializeGPUAAWrapperPassPass(a1, v5);
  llvm::initializeGlobalsAAWrapperPassPass(a1, v6);
  llvm::initializeObjCARCAAWrapperPassPass(a1, v7);
  llvm::initializeSCEVAAWrapperPassPass(a1, v8);
  llvm::initializeScopedNoAliasAAWrapperPassPass(a1, v9);
  llvm::initializeTypeBasedAAWrapperPassPass(a1, v10);
  operator new();
}

void llvm::createAAResultsWrapperPass(llvm *this)
{
}

void llvm::AAResultsWrapperPass::runOnFunction(llvm::AAResultsWrapperPass *this, llvm::Function *a2)
{
}

void sub_1CBF5AC74(uint64_t a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  int v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  int v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  int v13 = 0;
  uint64_t v2 = a1 + 32;
  if (!*(unsigned char *)(a1 + 232))
  {
    uint64_t v3 = *(void *)(a2 + 40) + 216;
    __int16 v15 = 260;
    v14[0] = v3;
    llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v14);
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    int v27 = 0;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    *(void *)&long long v4 = -1;
    *((void *)&v4 + 1) = -1;
    *(_OWORD *)__src = v4;
    long long v19 = v4;
    long long v20 = v4;
    long long v21 = v4;
    long long v22 = v4;
    long long v23 = v4;
    *(_OWORD *)uint64_t v24 = v4;
    *(void *)&v24[13] = -1;
    sub_1CC153974((uint64_t)__src, (int *)__p);
    sub_1CD4D04B8(v2, (uint64_t)__src);
    sub_1CD4CFA4C((uint64_t *)__src);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_1CC1569E8(__src, v2);
}

void sub_1CBF5AEEC()
{
}

void sub_1CBF5B050()
{
}

void sub_1CBF5B1B4()
{
}

void sub_1CBF5B318()
{
}

void llvm::AAManager::run()
{
}

void llvm::createLegacyPMAAResults(llvm *this, llvm::Pass *a2, llvm::Function *a3, llvm::BasicAAResult *a4)
{
  uint64_t v5 = (uint64_t *)*((void *)this + 1);
  uint64_t v6 = *v5;
  uint64_t v7 = v5[1];
  if (v6 == v7)
  {
LABEL_4:
    uint64_t v8 = 0;
  }
  else
  {
    while (*(char **)v6 != llvm::TargetLibraryInfoWrapperPass::ID)
    {
      v6 += 16;
      if (v6 == v7) {
        goto LABEL_4;
      }
    }
    uint64_t v8 = *(void *)(v6 + 8);
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t, char *, llvm::Function *, llvm::BasicAAResult *))(*(void *)v8 + 96))(v8, llvm::TargetLibraryInfoWrapperPass::ID, a3, a4);
  sub_1CBF5AC74(v9, (uint64_t)a2);
}

uint64_t llvm::isNoAliasCall(llvm *this, const llvm::Value *a2)
{
  unsigned int v2 = *((unsigned __int8 *)this + 16);
  if (v2 < 0x1C) {
    return 0;
  }
  unsigned int v3 = v2 - 33;
  BOOL v4 = v3 >= 0x33;
  BOOL v6 = v3 == 51;
  uint64_t v5 = (1 << v3) & 0x8000000000041;
  BOOL v6 = !v6 && v4 || v5 == 0;
  if (v6) {
    return 0;
  }
  else {
    return sub_1CBF5BCC4((uint64_t)this, 19);
  }
}

uint64_t llvm::isIdentifiedObject(llvm *this, const llvm::Value *a2)
{
  unsigned int v2 = *((unsigned __int8 *)this + 16);
  if (v2 == 59) {
    return 1;
  }
  if (v2 <= 3 && v2 != 1) {
    return 1;
  }
  if (v2 >= 0x1C)
  {
    unsigned int v5 = v2 - 33;
    BOOL v6 = v5 > 0x33;
    uint64_t v7 = (1 << v5) & 0x8000000000041;
    if (v6 || v7 == 0) {
      return 0;
    }
    if (sub_1CBF5BCC4((uint64_t)this, 19)) {
      return 1;
    }
    unsigned int v2 = *((unsigned __int8 *)this + 16);
  }
  if (v2 != 21) {
    return 0;
  }
  if (*(unsigned char *)(*(void *)this + 8) != 15) {
    return 0;
  }
  uint64_t v10 = *(void *)(*((void *)this + 3) + 112);
  if (!v10) {
    return 0;
  }
  unsigned int v11 = *((_DWORD *)this + 8) + 2;
  if (v11 < *(_DWORD *)(v10 + 8))
  {
    uint64_t v12 = *(void *)(v10 + 8 * v11 + 40);
    if (v12)
    {
      if ((*(unsigned char *)(v12 + 14) & 8) != 0) {
        return 1;
      }
    }
  }
  if (v11 >= *(_DWORD *)(v10 + 8)) {
    return 0;
  }
  uint64_t v13 = *(void *)(v10 + 8 * v11 + 40);
  if (!v13) {
    return 0;
  }
  return (*(unsigned __int8 *)(v13 + 20) >> 5) & 1;
}

uint64_t llvm::isNotVisibleOnUnwind(llvm *this, const llvm::Value *a2, BOOL *a3)
{
  *(unsigned char *)a2 = 0;
  unsigned int v3 = *((unsigned __int8 *)this + 16);
  if (v3 == 59) {
    return 1;
  }
  if (v3 == 21)
  {
    if (*(unsigned char *)(*(void *)this + 8) == 15)
    {
      uint64_t v4 = *(void *)(*((void *)this + 3) + 112);
      if (v4)
      {
        unsigned int v5 = *((_DWORD *)this + 8) + 2;
        if (v5 < *(_DWORD *)(v4 + 8))
        {
          uint64_t v6 = *(void *)(v4 + 8 * v5 + 40);
          if (v6) {
            return (*(unsigned __int8 *)(v6 + 20) >> 5) & 1;
          }
        }
      }
    }
    return 0;
  }
  if (v3 < 0x1C) {
    return 0;
  }
  unsigned int v8 = v3 - 33;
  BOOL v9 = v8 > 0x33;
  uint64_t v10 = (1 << v8) & 0x8000000000041;
  if (v9 || v10 == 0) {
    return 0;
  }
  uint64_t result = sub_1CBF5BCC4((uint64_t)this, 19);
  if (result)
  {
    uint64_t result = 1;
    *(unsigned char *)a2 = 1;
  }
  return result;
}

void sub_1CBF5B9D4(llvm::Pass *this)
{
  *(void *)this = &unk_1F2600640;
  unsigned int v2 = (char *)this + 32;
  unsigned int v3 = (char *)*((void *)this + 7);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }

  llvm::Pass::~Pass(this);
}

void sub_1CBF5BA88(llvm::Pass *this)
{
  *(void *)this = &unk_1F2600640;
  unsigned int v2 = (char *)this + 32;
  unsigned int v3 = (char *)*((void *)this + 7);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  llvm::Pass::~Pass(this);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CBF5BB50(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 496) & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 504), 8);
  }
  unsigned int v2 = *(void **)(a1 + 344);
  if (v2 != (void *)(a1 + 360)) {
    free(v2);
  }
  if ((*(unsigned char *)a1 & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
  }
  return a1;
}

uint64_t sub_1CBF5BBBC(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 16);
  if (v1 == 84)
  {
    uint64_t v2 = 0;
  }
  else if (v1 == 39)
  {
    uint64_t v2 = (*(_DWORD *)(a1 + 80) + 1);
  }
  else
  {
    uint64_t v2 = 2;
  }
  int v3 = *(_DWORD *)(a1 + 20);
  if (v3 < 0 && (uint64_t v6 = a1 - 32 * (v3 & 0x7FFFFFF), v7 = *(void *)(v6 - 8), (v7 & 0xFFFFFFFF0) != 0)) {
    uint64_t v4 = (*(_DWORD *)(v6 - 12) - *(_DWORD *)(v6 - v7));
  }
  else {
    uint64_t v4 = 0;
  }
  return a1 - 32 * v2 - 32 * v4 - 32;
}

uint64_t sub_1CBF5BC2C(uint64_t a1, int a2, int a3)
{
  int v3 = *(unsigned __int8 *)(a1 + 16);
  if (v3 == 84)
  {
    uint64_t v4 = 0;
  }
  else if (v3 == 39)
  {
    uint64_t v4 = (*(_DWORD *)(a1 + 80) + 1);
  }
  else
  {
    uint64_t v4 = 2;
  }
  int v5 = 0;
  int v6 = *(_DWORD *)(a1 + 20);
  uint64_t v7 = -(uint64_t)(v6 & 0x7FFFFFF);
  if (v6 < 0)
  {
    uint64_t v9 = a1 - 32 * (v6 & 0x7FFFFFF);
    uint64_t v10 = *(void *)(v9 - 8);
    if ((v10 & 0xFFFFFFFF0) != 0) {
      int v5 = *(_DWORD *)(v9 - 12) - *(_DWORD *)(v9 - v10);
    }
    else {
      int v5 = 0;
    }
  }
  if (((-32 * v4 + 32 * (unint64_t)-v5 - 32 * v7 - 32) >> 5) <= a2) {
    return sub_1CD457E90(a1, a2, a3);
  }
  else {
    return llvm::CallBase::paramHasAttr(a1, a2, a3);
  }
}

uint64_t sub_1CBF5BCC4(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (v2)
  {
    if (*(_DWORD *)(v2 + 8) >= 2u)
    {
      uint64_t v6 = *(void *)(v2 + 48);
      if (v6)
      {
        if ((*(unsigned __int8 *)(v6 + a2 / 8 + 12) >> (a2 & 7))) {
          return 1;
        }
      }
    }
  }
  uint64_t v3 = *(void *)(a1 - 32);
  if (v3
    && !*(unsigned char *)(v3 + 16)
    && *(void *)(v3 + 24) == *(void *)(a1 + 72)
    && (uint64_t v4 = *(void *)(v3 + 112)) != 0
    && *(_DWORD *)(v4 + 8) >= 2u
    && (uint64_t v7 = *(void *)(v4 + 48)) != 0)
  {
    return (*(unsigned __int8 *)(v7 + a2 / 8 + 12) >> (a2 & 7)) & 1;
  }
  else
  {
    return 0;
  }
}

void sub_1CBF5BD78(void ***a1)
{
  int v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    int v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        *uint64_t v4 = 0;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
        }
      }
      while (v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t llvm::AnalysisManager<llvm::Function>::Invalidator::invalidate(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = sub_1CBF5BF34(*a1, a2);
  uint64_t v9 = *a1;
  uint64_t v10 = *a1 + 8;
  if (*(unsigned char *)*a1)
  {
    uint64_t v11 = 8;
  }
  else
  {
    uint64_t v10 = *(void *)(v9 + 8);
    uint64_t v11 = *(unsigned int *)(v9 + 16);
  }
  if (v10 + 16 * v11 == v8)
  {
    uint64_t v12 = a1[1];
    v19[0] = a2;
    v19[1] = a3;
    uint64_t v17 = 0;
    if (sub_1CBF5C064((uint64_t *)v12, v19, &v17)) {
      uint64_t v13 = v17;
    }
    else {
      uint64_t v13 = *(void *)v12 + 24 * *(unsigned int *)(v12 + 16);
    }
    uint64_t v14 = *a1;
    char v15 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(*(void *)(v13 + 16) + 24)
                                                                         + 16))(*(void *)(*(void *)(v13 + 16) + 24), a3, a4, a1);
    uint64_t v17 = a2;
    v18[0] = v15;
    sub_1CBF5C150(v14, &v17, v18, (uint64_t)v19);
    uint64_t v8 = v19[0];
  }
  return *(unsigned __int8 *)(v8 + 8);
}

uint64_t sub_1CBF5BF34(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = a2;
  uint64_t v8 = 0;
  int v3 = sub_1CBF5BFB4(a1, &v7, &v8);
  uint64_t v4 = a1 + 8;
  if (v3) {
    return v8;
  }
  if (*(_DWORD *)a1)
  {
    uint64_t v5 = 8;
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 16);
  }
  return v4 + 16 * v5;
}

uint64_t sub_1CBF5BFB4(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 8;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_18;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  uint64_t v7 = (void *)(v3 + 16 * v6);
  uint64_t v8 = *v7;
  if (*a2 == *v7)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v9 = 0;
    int v10 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v9) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v9 = v7;
      }
      unsigned int v13 = v6 + v10++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 16 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_18;
      }
    }
    uint64_t result = 0;
    if (v9) {
      uint64_t v7 = v9;
    }
  }
LABEL_18:
  *a3 = v7;
  return result;
}

uint64_t sub_1CBF5C064(uint64_t *a1, uint64_t *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    uint64_t v5 = *a2;
    uint64_t v6 = a2[1];
    unint64_t v7 = ((v6 >> 4) ^ (v6 >> 9) | ((unint64_t)((*a2 >> 4) ^ (*a2 >> 9)) << 32))
       + ~((unint64_t)((v6 >> 4) ^ (v6 >> 9)) << 32);
    unint64_t v8 = (v7 ^ (v7 >> 22)) + ~((v7 ^ (v7 >> 22)) << 13);
    unint64_t v9 = (9 * (v8 ^ (v8 >> 8))) ^ ((9 * (v8 ^ (v8 >> 8))) >> 15);
    int v10 = ((v9 + ~(v9 << 27)) >> 31) ^ (v9 + ~(v9 << 27));
    int v11 = v3 - 1;
    unsigned int v12 = (v3 - 1) & v10;
    unsigned int v13 = (void *)(*a1 + 24 * v12);
    uint64_t v15 = *v13;
    uint64_t v14 = v13[1];
    if (*a2 == *v13 && v6 == v14)
    {
LABEL_22:
      uint64_t result = 1;
    }
    else
    {
      uint64_t v17 = 0;
      int v18 = 1;
      while (v15 != -4096 || v14 != -4096)
      {
        if (v17) {
          BOOL v19 = 0;
        }
        else {
          BOOL v19 = v14 == -8192;
        }
        if (v19 && v15 == -8192) {
          uint64_t v17 = v13;
        }
        unsigned int v21 = v12 + v18++;
        unsigned int v12 = v21 & v11;
        unsigned int v13 = (void *)(v4 + 24 * (v21 & v11));
        uint64_t v15 = *v13;
        uint64_t v14 = v13[1];
        if (v5 == *v13 && v6 == v14) {
          goto LABEL_22;
        }
      }
      uint64_t result = 0;
      if (v17) {
        unsigned int v13 = v17;
      }
    }
  }
  else
  {
    unsigned int v13 = 0;
    uint64_t result = 0;
  }
  *a3 = v13;
  return result;
}

uint64_t sub_1CBF5C150@<X0>(uint64_t a1@<X0>, void *a2@<X1>, unsigned char *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v16 = 0;
  uint64_t result = sub_1CBF5C218(a1, a2, &v16);
  unint64_t v9 = v16;
  if (result)
  {
    uint64_t v14 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v15 = 8;
    }
    else
    {
      uint64_t v14 = *(void *)(a1 + 8);
      uint64_t v15 = *(unsigned int *)(a1 + 16);
    }
    char v13 = 0;
    uint64_t v12 = v14 + 16 * v15;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CBF5C2C0((_DWORD *)a1, (uint64_t)a2, a2, v16);
    unint64_t v9 = (void *)result;
    *(void *)uint64_t result = *a2;
    *(unsigned char *)(result + 8) = *a3;
    uint64_t v10 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v11 = 8;
    }
    else
    {
      uint64_t v10 = *(void *)(a1 + 8);
      uint64_t v11 = *(unsigned int *)(a1 + 16);
    }
    uint64_t v12 = v10 + 16 * v11;
    char v13 = 1;
  }
  *(void *)a4 = v9;
  *(void *)(a4 + 8) = v12;
  *(unsigned char *)(a4 + 16) = v13;
  return result;
}

uint64_t sub_1CBF5C218(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 8;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      unint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_16;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  unint64_t v7 = (void *)(v3 + 16 * v6);
  uint64_t v8 = *v7;
  if (*a2 == *v7)
  {
LABEL_13:
    uint64_t result = 1;
  }
  else
  {
    unint64_t v9 = 0;
    int v10 = 1;
    while (v8 != -4096)
    {
      if (v9) {
        BOOL v11 = 0;
      }
      else {
        BOOL v11 = v8 == -8192;
      }
      if (v11) {
        unint64_t v9 = v7;
      }
      unsigned int v12 = v6 + v10++;
      unsigned int v6 = v12 & v5;
      unint64_t v7 = (void *)(v3 + 16 * (v12 & v5));
      uint64_t v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_13;
      }
    }
    uint64_t result = 0;
    if (v9) {
      unint64_t v7 = v9;
    }
  }
LABEL_16:
  *a3 = v7;
  return result;
}

void *sub_1CBF5C2C0(_DWORD *a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *a1 >> 1;
  if (*a1) {
    unsigned int v7 = 8;
  }
  else {
    unsigned int v7 = a1[4];
  }
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - a1[1] > v7 >> 3)
  {
    goto LABEL_5;
  }
  sub_1CBF5C384((uint64_t)a1, v7);
  unint64_t v9 = 0;
  sub_1CBF5C218((uint64_t)a1, a3, &v9);
  a4 = v9;
LABEL_5:
  *a1 += 2;
  if (*a4 != -4096) {
    --a1[1];
  }
  return a4;
}

uint64_t sub_1CBF5C384(uint64_t a1, unsigned int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 9)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v11 = *(void *)(a1 + 8);
    uint64_t v12 = *(unsigned int *)(a1 + 16);
    if (a2 > 8)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CBF5C510(a1, v11, v11 + 16 * v12);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v6 = 0;
  unsigned int v7 = v14;
  do
  {
    uint64_t v8 = *(void *)(a1 + v6 + 8);
    if ((v8 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *(void *)unsigned int v7 = v8;
      v7[8] = *(unsigned char *)(a1 + v6 + 16);
      v7 += 16;
    }
    v6 += 16;
  }
  while (v6 != 128);
  if (a2 > 8)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v9 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v9;
  }
  return sub_1CBF5C510(a1, (uint64_t)v14, (uint64_t)v7);
}

uint64_t sub_1CBF5C510(uint64_t result, uint64_t a2, uint64_t a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 136);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_9;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[2 * v7];
  }
  do
  {
    *uint64_t v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_9:
  while (a2 != a3)
  {
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CBF5C218((uint64_t)v5, (void *)a2, &v11);
      int v10 = v11;
      *uint64_t v11 = *(void *)a2;
      *((unsigned char *)v10 + 8) = *(unsigned char *)(a2 + 8);
      *v5 += 2;
    }
    a2 += 16;
  }
  return result;
}

void sub_1CBF5C5D8()
{
}

uint64_t sub_1CBF5C5EC(uint64_t result, uint64_t a2)
{
  **(void **)(result + 8) = a2;
  return result;
}

uint64_t sub_1CBF5C5F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return llvm::BasicAAResult::aliasCheck(*(void *)(a1 + 8), *(llvm::Value **)a2, *(void *)(a2 + 8), *(llvm::Value **)a3, *(void *)(a3 + 8), a4);
}

uint64_t sub_1CBF5C614(uint64_t a1, uint64_t **a2, uint64_t a3, int a4)
{
  return llvm::BasicAAResult::pointsToConstantMemory(*(void *)(a1 + 8), a2, a3, a4);
}

uint64_t sub_1CBF5C61C(uint64_t a1, const llvm::CallBase *a2, int a3)
{
  return llvm::BasicAAResult::getArgModRefInfo(*(llvm::BasicAAResult **)(a1 + 8), a2, a3);
}

uint64_t sub_1CBF5C624(uint64_t a1, const llvm::CallBase *a2)
{
  return llvm::BasicAAResult::getModRefBehavior(*(llvm::BasicAAResult **)(a1 + 8), a2);
}

uint64_t sub_1CBF5C62C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned char **)(a2 + 112);
  if (!v2) {
    return 63;
  }
  if ((v2[17] & 0x10) != 0) {
    return 4;
  }
  if ((v2[17] & 0x20) != 0)
  {
    unsigned int v3 = 61;
  }
  else if ((v2[20] & 4) != 0)
  {
    unsigned int v3 = 62;
  }
  else
  {
    unsigned int v3 = 63;
  }
  if ((v2[12] & 8) != 0) {
    return v3 & 0xF;
  }
  char v4 = v2[13];
  if ((v4 & 8) != 0) {
    return v3 & 0x17;
  }
  if ((v4 & 0x10) != 0) {
    return v3 & 0x1F;
  }
  return v3;
}

uint64_t sub_1CBF5C69C(uint64_t a1, uint64_t a2, llvm **a3, uint64_t a4)
{
  return llvm::BasicAAResult::getModRefInfo(*(void *)(a1 + 8), a2, a3, a4);
}

uint64_t sub_1CBF5C6A4(uint64_t a1, uint64_t a2, const llvm::CallBase *a3)
{
  return llvm::BasicAAResult::getModRefInfo(*(llvm::BasicAAResult **)(a1 + 8), a2, a3);
}

void sub_1CBF5C6AC()
{
}

uint64_t sub_1CBF5C6C0(uint64_t result, uint64_t a2)
{
  **(void **)(result + 8) = a2;
  return result;
}

uint64_t sub_1CBF5C6CC(llvm::ScopedNoAliasAAResult *a1, uint64_t a2, uint64_t a3)
{
  if (!byte_1EBD04BF8) {
    return 1;
  }
  unsigned int v3 = *(const llvm::MDNode **)(a2 + 40);
  char v4 = *(const llvm::MDNode **)(a3 + 32);
  uint64_t result = llvm::ScopedNoAliasAAResult::mayAliasInScopes(a1, *(const llvm::MDNode **)(a2 + 32), *(const llvm::MDNode **)(a3 + 40));
  if (result) {
    return llvm::ScopedNoAliasAAResult::mayAliasInScopes((llvm::ScopedNoAliasAAResult *)result, v4, v3);
  }
  return result;
}

uint64_t sub_1CBF5C71C()
{
  return 0;
}

uint64_t sub_1CBF5C724()
{
  return 7;
}

uint64_t sub_1CBF5C72C()
{
  return 63;
}

uint64_t sub_1CBF5C734()
{
  return 63;
}

uint64_t sub_1CBF5C73C(uint64_t a1, uint64_t ***a2, uint64_t a3)
{
  return llvm::ScopedNoAliasAAResult::getModRefInfo(*(uint64_t *****)(a1 + 8), a2, a3);
}

uint64_t sub_1CBF5C744(uint64_t a1, uint64_t ***a2, uint64_t ***a3)
{
  return llvm::ScopedNoAliasAAResult::getModRefInfo(*(uint64_t *****)(a1 + 8), a2, a3);
}

void sub_1CBF5C74C()
{
}

uint64_t sub_1CBF5C760(uint64_t result, uint64_t a2)
{
  **(void **)(result + 8) = a2;
  return result;
}

uint64_t sub_1CBF5C76C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (byte_1EBD04B38) {
    return ((uint64_t (*)(void, void, void))loc_1CC15C65C)(*(void *)(a2 + 16), *(void *)(a3 + 16), 0);
  }
  else {
    return 1;
  }
}

BOOL sub_1CBF5C7A4(uint64_t a1, uint64_t a2)
{
  if (!byte_1EBD04B38) {
    return 0;
  }
  uint64_t v2 = *(void *)(a2 + 16);
  if (!v2) {
    return 0;
  }
  uint64_t v4 = *(unsigned int *)(v2 + 8);
  int v5 = (unsigned __int8 **)(v2 - 8 * v4);
  if (**v5 - 4 >= 0x1F)
  {
    if (v4 < 3) {
      return 0;
    }
    int v6 = v5[2];
    if (*v6 != 1) {
      return 0;
    }
    uint64_t v7 = *((void *)v6 + 16);
    if (*(unsigned char *)(v7 + 16) != 16) {
      return 0;
    }
    uint64_t v8 = (void *)(v7 + 24);
    if (*(_DWORD *)(v7 + 32) >= 0x41u) {
      uint64_t v8 = (void *)*v8;
    }
    return (*(unsigned char *)v8 & 1) != 0;
  }
  if (v4 >= 3)
  {
    uint64_t v9 = *(void *)(a2 + 16);
    if (sub_1CC15C0DC((uint64_t)&v9)) {
      return 1;
    }
  }
  return 0;
}

uint64_t sub_1CBF5C85C()
{
  return 7;
}

uint64_t sub_1CBF5C864(uint64_t a1, const llvm::CallBase *a2)
{
  return llvm::TypeBasedAAResult::getModRefBehavior(*(llvm::TypeBasedAAResult **)(a1 + 8), a2);
}

uint64_t sub_1CBF5C86C()
{
  return 63;
}

uint64_t sub_1CBF5C874(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return llvm::TypeBasedAAResult::getModRefInfo(*(void *)(a1 + 8), a2, a3);
}

uint64_t sub_1CBF5C87C(uint64_t a1, uint64_t a2, llvm::Instruction *a3)
{
  return llvm::TypeBasedAAResult::getModRefInfo(*(void *)(a1 + 8), a2, a3);
}

char *sub_1CBF5C884(char **a1, void *a2)
{
  unsigned int v3 = *a1;
  uint64_t v2 = a1[1];
  uint64_t v4 = (v2 - *a1) >> 3;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 61) {
    abort();
  }
  uint64_t v8 = a1[2];
  if ((v8 - v3) >> 2 > v5) {
    unint64_t v5 = (v8 - v3) >> 2;
  }
  if ((unint64_t)(v8 - v3) >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  long long v20 = a1 + 2;
  if (v9)
  {
    if (v9 >> 61) {
      sub_1CB833614();
    }
    int v10 = (char *)operator new(8 * v9);
  }
  else
  {
    int v10 = 0;
  }
  uint64_t v11 = &v10[8 * v4];
  *(void *)uint64_t v11 = *a2;
  uint64_t v12 = v11 + 8;
  uint64_t v13 = &v10[8 * v9];
  v18.i64[1] = (uint64_t)(v11 + 8);
  BOOL v19 = v13;
  if (v2 == v3)
  {
    int64x2_t v15 = vdupq_n_s64((unint64_t)v2);
  }
  else
  {
    do
    {
      uint64_t v14 = *((void *)v2 - 1);
      v2 -= 8;
      *(void *)uint64_t v2 = 0;
      *((void *)v11 - 1) = v14;
      v11 -= 8;
    }
    while (v2 != v3);
    int64x2_t v15 = *(int64x2_t *)a1;
    uint64_t v8 = a1[2];
    uint64_t v12 = (char *)v18.i64[1];
    uint64_t v13 = v19;
  }
  *a1 = v11;
  a1[1] = v12;
  int64x2_t v18 = v15;
  a1[2] = v13;
  BOOL v19 = v8;
  uint64_t v17 = v15.i64[0];
  sub_1CBF49EF8((uint64_t)&v17);
  return v12;
}

void sub_1CBF5C998()
{
}

uint64_t sub_1CBF5C9AC(uint64_t result, uint64_t a2)
{
  **(void **)(result + 8) = a2;
  return result;
}

BOOL sub_1CBF5C9B8(uint64_t a1, llvm::Value **a2, llvm::Value **a3)
{
  return llvm::GlobalsAAResult::alias(*(void *)(a1 + 8), a2, a3);
}

uint64_t sub_1CBF5C9C0()
{
  return 0;
}

uint64_t sub_1CBF5C9C8()
{
  return 7;
}

uint64_t sub_1CBF5C9D0(uint64_t a1, uint64_t a2)
{
  return llvm::GlobalsAAResult::getModRefBehavior(*(void *)(a1 + 8), a2);
}

uint64_t sub_1CBF5C9D8(uint64_t a1, const Function *a2)
{
  return llvm::GlobalsAAResult::getModRefBehavior(*(llvm::GlobalsAAResult **)(a1 + 8), a2);
}

uint64_t sub_1CBF5C9E0(uint64_t a1, uint64_t a2, llvm **a3)
{
  return llvm::GlobalsAAResult::getModRefInfo(*(void *)(a1 + 8), a2, a3);
}

uint64_t sub_1CBF5C9E8()
{
  return 7;
}

uint64_t sub_1CBF5C9F0()
{
  int v3 = 1;
  char v1 = 0;
  uint64_t v2 = &v1;
  sub_1CD458004(&v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &llvm::DisableBasicAA, &dword_1CB82C000);
}

void *llvm::AAEvaluator::runInternal(llvm::AAEvaluator *this, llvm::Function *a2, llvm::AAResults *a3)
{
  v357[16] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *((void *)a2 + 5);
  v295 = this;
  ++*(void *)this;
  v331[0] = 0;
  v331[1] = 0;
  int v332 = 0;
  v334 = 0;
  uint64_t v335 = 0;
  v333 = 0;
  v354[0] = 1;
  uint64_t v6 = 1;
  int64x2_t v7 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  do
  {
    *(int64x2_t *)&v354[v6] = v7;
    v6 += 2;
  }
  while (v6 != 17);
  v355 = v357;
  uint64_t v356 = 0x1000000000;
  v326[0] = 0;
  v326[1] = 0;
  int v327 = 0;
  v329 = 0;
  uint64_t v330 = 0;
  v328 = 0;
  uint64_t v8 = (char *)a2 + 72;
  v321[0] = 0;
  v321[1] = 0;
  int v322 = 0;
  v324 = 0;
  uint64_t v325 = 0;
  v323 = 0;
  for (uint64_t i = *((void *)a2 + 10); ; uint64_t i = *(void *)(i + 8))
  {
    if ((char *)i == v8) {
      goto LABEL_33;
    }
    uint64_t v10 = i - 24;
    if (!i) {
      uint64_t v10 = 0;
    }
    uint64_t v11 = *(void *)(v10 + 48);
    if (v11 != v10 + 40) {
      break;
    }
  }
  while (1)
  {
    if (v11) {
      uint64_t v12 = (llvm::Value *)(v11 - 24);
    }
    else {
      uint64_t v12 = 0;
    }
    int v13 = *((unsigned __int8 *)v12 + 16);
    if (v11 && v13 == 60)
    {
      unint64_t v14 = *(void *)v12;
      v343 = (llvm::Value *)*((void *)v12 - 4);
      unint64_t v344 = v14;
      sub_1CBF5F5F4(v331, (uint64_t *)&v343);
      v343 = v12;
      int64x2_t v15 = v326;
LABEL_18:
      this = (llvm::AAEvaluator *)sub_1CBF5F714(v15, &v343);
      goto LABEL_19;
    }
    if (v11 && v13 == 61)
    {
      unint64_t v16 = **((void **)v12 - 8);
      v343 = (llvm::Value *)*((void *)v12 - 4);
      unint64_t v344 = v16;
      sub_1CBF5F5F4(v331, (uint64_t *)&v343);
      v343 = v12;
      int64x2_t v15 = v321;
      goto LABEL_18;
    }
    unsigned int v19 = v13 - 33;
    BOOL v20 = v19 > 0x33;
    uint64_t v21 = (1 << v19) & 0x8000000000041;
    if (!v20 && v21 != 0)
    {
      v343 = (llvm::Value *)(v11 - 24);
      this = (llvm::AAEvaluator *)sub_1CBF5F834((uint64_t)v354, (uint64_t *)&v343);
    }
LABEL_19:
    uint64_t v11 = *(void *)(v11 + 8);
    uint64_t v17 = i - 24;
    if (!i) {
      uint64_t v17 = 0;
    }
    if (v11 == v17 + 40) {
      break;
    }
LABEL_26:
    if ((char *)i == v8) {
      goto LABEL_33;
    }
  }
  while (1)
  {
    uint64_t i = *(void *)(i + 8);
    if ((char *)i == v8) {
      break;
    }
    uint64_t v18 = i - 24;
    if (!i) {
      uint64_t v18 = 0;
    }
    uint64_t v11 = *(void *)(v18 + 48);
    if (v11 != v18 + 40) {
      goto LABEL_26;
    }
  }
LABEL_33:
  uint64_t v23 = v5 + 272;
  if (byte_1EBCC30C8) {
    BOOL v24 = 0;
  }
  else {
    BOOL v24 = byte_1EBCC3188 == 0;
  }
  BOOL v31 = v24
     && byte_1EBCC3248 == 0
     && byte_1EBCC3308 == 0
     && byte_1EBCC33C8 == 0
     && byte_1EBCC3488 == 0
     && byte_1EBCC3608 == 0
     && byte_1EBCC3548 == 0
     && byte_1EBCC36C8 == 0;
  v300 = a2;
  if (v31)
  {
    unint64_t v44 = (llvm::Value **)v333;
    uint64_t v43 = (llvm::Value **)v334;
  }
  else
  {
    long long v32 = (llvm::raw_ostream *)llvm::errs(this);
    long long v33 = v32;
    uint64_t v34 = *((void *)v32 + 4);
    if ((unint64_t)(*((void *)v32 + 3) - v34) > 9)
    {
      *(_WORD *)(v34 + 8) = 8250;
      *(void *)uint64_t v34 = *(void *)"Function: ";
      *((void *)v32 + 4) += 10;
    }
    else
    {
      llvm::raw_ostream::write(v32, "Function: ", 0xAuLL);
    }
    if ((*((unsigned char *)a2 + 23) & 0x10) != 0)
    {
      uint64_t v35 = ***(void ***)a2;
      uint64_t v36 = *(void *)(v35 + 152);
      uint64_t v37 = *(unsigned int *)(v35 + 168);
      if (!v37) {
        goto LABEL_68;
      }
      LODWORD(v38) = (v37 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      uint64_t v39 = v36 + 16 * v38;
      uint64_t v40 = *(llvm::Function **)v39;
      if (*(llvm::Function **)v39 != a2)
      {
        int v41 = 1;
        while (v40 != (llvm::Function *)-4096)
        {
          int v42 = v38 + v41++;
          uint64_t v38 = v42 & (v37 - 1);
          uint64_t v40 = *(llvm::Function **)(v36 + 16 * v38);
          if (v40 == a2)
          {
            uint64_t v39 = v36 + 16 * v38;
            goto LABEL_69;
          }
        }
LABEL_68:
        uint64_t v39 = v36 + 16 * v37;
      }
LABEL_69:
      uint64_t v45 = *(void **)(v39 + 8);
      size_t v48 = *v45;
      int v46 = (const char *)(v45 + 2);
      size_t v47 = v48;
      int v49 = (_WORD *)*((void *)v33 + 4);
      if (v48 > *((void *)v33 + 3) - (void)v49)
      {
        llvm::raw_ostream::write(v33, v46, v47);
        goto LABEL_71;
      }
      if (v47)
      {
        memcpy(v49, v46, v47);
        int v49 = (_WORD *)(*((void *)v33 + 4) + v47);
        *((void *)v33 + 4) = v49;
      }
    }
    else
    {
LABEL_71:
      int v49 = (_WORD *)*((void *)v33 + 4);
    }
    if (*((void *)v33 + 3) - (void)v49 > 1uLL)
    {
      *int v49 = 8250;
      *((void *)v33 + 4) += 2;
    }
    else
    {
      llvm::raw_ostream::write(v33, ": ", 2uLL);
    }
    unint64_t v44 = (llvm::Value **)v333;
    uint64_t v43 = (llvm::Value **)v334;
    sub_1CD098D14(v33, (v334 - v333) >> 4, 0, 0, 0);
    uint64_t v50 = *((void *)v33 + 4);
    if ((unint64_t)(*((void *)v33 + 3) - v50) > 0xA)
    {
      *(_DWORD *)(v50 + 7) = 539784050;
      *(void *)uint64_t v50 = *(void *)" pointers, ";
      *((void *)v33 + 4) += 11;
    }
    else
    {
      llvm::raw_ostream::write(v33, " pointers, ", 0xBuLL);
    }
    sub_1CD098D14(v33, v356, 0, 0, 0);
    uint64_t v51 = *((void *)v33 + 4);
    if ((unint64_t)(*((void *)v33 + 3) - v51) > 0xB)
    {
      *(_DWORD *)(v51 + 8) = 175334772;
      *(void *)uint64_t v51 = *(void *)" call sites\n";
      *((void *)v33 + 4) += 12;
    }
    else
    {
      llvm::raw_ostream::write(v33, " call sites\n", 0xCuLL);
    }
  }
  v320 = a3;
  uint64_t v301 = v23;
  if (v44 != v43)
  {
    uint64_t v52 = 0;
    int v53 = (void *)((char *)v295 + 8);
    v296 = (uint64_t *)(v44 + 1);
    v297 = v43;
    int v54 = v44;
    v299 = v44;
    do
    {
      unint64_t v55 = (unint64_t)(sub_1CB83544C(v23, (uint64_t)v54[1]) + 7) >> 3;
      if (v56 == 1) {
        unint64_t v55 = -2;
      }
      unint64_t v319 = v55;
      size_t v57 = v296;
      uint64_t v304 = v52;
      if (v44 != v54)
      {
        do
        {
          uint64_t v58 = sub_1CB83544C(v23, *v57);
          unint64_t v59 = (void *)*(v57 - 1);
          unint64_t v60 = (unint64_t)(v58 + 7) >> 3;
          if (v61 == 1) {
            unint64_t v60 = -2;
          }
          v343 = *v54;
          unint64_t v344 = v319;
          long long v345 = 0u;
          long long v346 = 0u;
          v336 = v59;
          unint64_t v337 = v60;
          long long v338 = 0u;
          long long v339 = 0u;
          int v62 = llvm::AAResults::alias((uint64_t)a3, (uint64_t)&v343, (uint64_t)&v336);
          unsigned int v63 = &byte_1EBCC3188;
          BOOL v64 = v53;
          switch((char)v62)
          {
            case 0:
              goto LABEL_91;
            case 1:
              unsigned int v63 = &byte_1EBCC3248;
              BOOL v64 = (void *)((char *)v295 + 16);
              goto LABEL_91;
            case 2:
              unsigned int v63 = &byte_1EBCC3308;
              BOOL v64 = (void *)((char *)v295 + 24);
              goto LABEL_91;
            case 3:
              unsigned int v63 = &byte_1EBCC33C8;
              BOOL v64 = (void *)((char *)v295 + 32);
LABEL_91:
              if (byte_1EBCC30C8 | *v63)
              {
                BOOL v65 = *v54;
                uint64_t v66 = *(void *)*v54;
                unint64_t v67 = *(unsigned int *)(v66 + 8);
                if ((v67 & 0xFE) == 0x12) {
                  unint64_t v67 = *(unsigned int *)(**(void **)(v66 + 16) + 8);
                }
                unint64_t v310 = v67;
                BOOL v68 = (llvm::Value *)*(v57 - 1);
                unint64_t v69 = *(unsigned int *)(*(void *)v68 + 8);
                if ((v69 & 0xFE) == 0x12) {
                  unint64_t v69 = *(unsigned int *)(**(void **)(*(void *)v68 + 16) + 8);
                }
                unint64_t v302 = v69;
                v309 = v54[1];
                v312 = (llvm::Type *)*v57;
                unsigned int v70 = (const llvm::Module *)*((void *)a2 + 5);
                v352[0] = 0;
                v352[1] = 0;
                uint64_t v353 = 0;
                __p[0] = 0;
                __p[1] = 0;
                uint64_t v351 = 0;
                LODWORD(v344) = 0;
                BYTE8(v346) = 0;
                uint64_t v347 = 0;
                v343 = (llvm::Value *)&unk_1F2646F30;
                v349 = v352;
                int v348 = 0;
                *(void *)&long long v346 = 0;
                long long v345 = 0uLL;
                LODWORD(v337) = 0;
                BYTE8(v339) = 0;
                uint64_t v340 = 0;
                v336 = &unk_1F2646F30;
                v342 = __p;
                int v341 = 0;
                *(void *)&long long v339 = 0;
                long long v338 = 0uLL;
                llvm::Value::printAsOperand(v65, (llvm::raw_ostream *)&v343, 0, v70);
                llvm::Value::printAsOperand(v68, (llvm::raw_ostream *)&v336, 0, v70);
                v336 = &unk_1F2646B98;
                if (v341 == 1 && (void)v338) {
                  MEMORY[0x1D25D9CB0](v338, 0x1000C8077774924);
                }
                v343 = (llvm::Value *)&unk_1F2646B98;
                if (v348 == 1 && (void)v345) {
                  MEMORY[0x1D25D9CB0](v345, 0x1000C8077774924);
                }
                unsigned int v306 = v62;
                unint64_t v71 = v310 >> 8;
                unint64_t v311 = v302 >> 8;
                if (v353 >= 0) {
                  uint64_t v72 = v352;
                }
                else {
                  uint64_t v72 = (void **)v352[0];
                }
                if (v353 >= 0) {
                  unsigned int v73 = (void *)(HIBYTE(v353) & 0x7F);
                }
                else {
                  unsigned int v73 = v352[1];
                }
                if (v351 >= 0) {
                  unint64_t v74 = (void *)(HIBYTE(v351) & 0x7F);
                }
                else {
                  unint64_t v74 = __p[1];
                }
                if (v351 >= 0) {
                  unint64_t v75 = __p;
                }
                else {
                  unint64_t v75 = (void **)__p[0];
                }
                if (v73 >= v74) {
                  size_t v76 = (size_t)v74;
                }
                else {
                  size_t v76 = (size_t)v73;
                }
                uint64_t v77 = (llvm *)memcmp(v75, v72, v76);
                BOOL v78 = v74 < v73;
                if (v77) {
                  BOOL v78 = (int)v77 < 0;
                }
                if (v78)
                {
                  uint64_t v79 = v353;
                  long long v80 = *(_OWORD *)v352;
                  *(_OWORD *)v352 = *(_OWORD *)__p;
                  uint64_t v353 = v351;
                  *(_OWORD *)std::string __p = v80;
                  uint64_t v351 = v79;
                  a3 = v320;
                  int v53 = (void *)((char *)v295 + 8);
                  if ((v62 & 0x100) == 0 || ((v62 >> 9) + 0x3FFFFF) >> 23)
                  {
                    uint64_t v77 = v309;
                  }
                  else
                  {
                    uint64_t v77 = v309;
                    unsigned int v306 = (v62 - (v62 & 0xFFFFFE00)) | 0x100;
                  }
                  unint64_t v81 = v302 >> 8;
                  v309 = v312;
                  unint64_t v311 = v71;
                  v312 = v77;
                }
                else
                {
                  unint64_t v81 = v71;
                  a3 = v320;
                  int v53 = (void *)((char *)v295 + 8);
                }
                uint64_t v82 = (llvm::raw_ostream *)llvm::errs(v77);
                unsigned int v83 = (_WORD *)*((void *)v82 + 4);
                uint64_t v23 = v301;
                if (*((void *)v82 + 3) - (void)v83 > 1uLL)
                {
                  *unsigned int v83 = 8224;
                  *((void *)v82 + 4) += 2;
                }
                else
                {
                  uint64_t v82 = llvm::raw_ostream::write(v82, "  ", 2uLL);
                }
                uint64_t v84 = llvm::operator<<(v82, v306);
                int v85 = (_WORD *)*((void *)v84 + 4);
                if (*((void *)v84 + 3) - (void)v85 > 1uLL)
                {
                  *int v85 = 2362;
                  *((void *)v84 + 4) += 2;
                }
                else
                {
                  uint64_t v84 = llvm::raw_ostream::write(v84, ":\t", 2uLL);
                }
                uint64_t v86 = (llvm::raw_ostream *)llvm::errs(v84);
                uint64_t v87 = (llvm *)llvm::Type::print(v309, v86, 0, 1);
                if (v81)
                {
                  uint64_t v88 = (llvm::raw_ostream *)llvm::errs(v87);
                  uint64_t v89 = v88;
                  uint64_t v90 = *((void *)v88 + 4);
                  if ((unint64_t)(*((void *)v88 + 3) - v90) > 0xA)
                  {
                    *(_DWORD *)(v90 + 7) = 677733217;
                    *(void *)uint64_t v90 = *(void *)" addrspace(";
                    *((void *)v88 + 4) += 11;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v88, " addrspace(", 0xBuLL);
                  }
                  uint64_t v87 = sub_1CD098D14(v89, v81, 0, 0, 0);
                  char v91 = (unsigned char *)*((void *)v89 + 4);
                  if (*((unsigned char **)v89 + 3) == v91)
                  {
                    uint64_t v87 = llvm::raw_ostream::write(v89, ")", 1uLL);
                  }
                  else
                  {
                    *char v91 = 41;
                    ++*((void *)v89 + 4);
                  }
                  int v53 = (void *)((char *)v295 + 8);
                }
                uint64_t v92 = (llvm::raw_ostream *)llvm::errs(v87);
                uint64_t v93 = (_WORD *)*((void *)v92 + 4);
                if (*((void *)v92 + 3) - (void)v93 > 1uLL)
                {
                  *uint64_t v93 = 8234;
                  *((void *)v92 + 4) += 2;
                }
                else
                {
                  uint64_t v92 = llvm::raw_ostream::write(v92, "* ", 2uLL);
                }
                if (v353 >= 0) {
                  uint64_t v94 = v352;
                }
                else {
                  uint64_t v94 = (void **)v352[0];
                }
                if (v353 >= 0) {
                  size_t v95 = HIBYTE(v353) & 0x7F;
                }
                else {
                  size_t v95 = (size_t)v352[1];
                }
                uint64_t v96 = llvm::raw_ostream::write(v92, (const char *)v94, v95);
                uint64_t v97 = (_WORD *)*((void *)v96 + 4);
                if (*((void *)v96 + 3) - (void)v97 > 1uLL)
                {
                  _WORD *v97 = 8236;
                  *((void *)v96 + 4) += 2;
                }
                else
                {
                  uint64_t v96 = llvm::raw_ostream::write(v96, ", ", 2uLL);
                }
                uint64_t v98 = (llvm::raw_ostream *)llvm::errs(v96);
                unsigned int v99 = (llvm *)llvm::Type::print(v312, v98, 0, 1);
                if (v311)
                {
                  uint64_t v100 = (llvm::raw_ostream *)llvm::errs(v99);
                  uint64_t v101 = v100;
                  uint64_t v102 = *((void *)v100 + 4);
                  if ((unint64_t)(*((void *)v100 + 3) - v102) > 0xA)
                  {
                    *(_DWORD *)(v102 + 7) = 677733217;
                    *(void *)uint64_t v102 = *(void *)" addrspace(";
                    *((void *)v100 + 4) += 11;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v100, " addrspace(", 0xBuLL);
                  }
                  unsigned int v99 = sub_1CD098D14(v101, v311, 0, 0, 0);
                  uint64_t v103 = (unsigned char *)*((void *)v101 + 4);
                  if (*((unsigned char **)v101 + 3) == v103)
                  {
                    unsigned int v99 = llvm::raw_ostream::write(v101, ")", 1uLL);
                  }
                  else
                  {
                    *uint64_t v103 = 41;
                    ++*((void *)v101 + 4);
                  }
                  int v53 = (void *)((char *)v295 + 8);
                }
                int v104 = (llvm::raw_ostream *)llvm::errs(v99);
                uint64_t v105 = (_WORD *)*((void *)v104 + 4);
                if (*((void *)v104 + 3) - (void)v105 > 1uLL)
                {
                  *uint64_t v105 = 8234;
                  *((void *)v104 + 4) += 2;
                }
                else
                {
                  int v104 = llvm::raw_ostream::write(v104, "* ", 2uLL);
                }
                if (v351 >= 0) {
                  uint64_t v106 = __p;
                }
                else {
                  uint64_t v106 = (void **)__p[0];
                }
                if (v351 >= 0) {
                  size_t v107 = HIBYTE(v351) & 0x7F;
                }
                else {
                  size_t v107 = (size_t)__p[1];
                }
                uint64_t v108 = llvm::raw_ostream::write(v104, (const char *)v106, v107);
                int v109 = (unsigned char *)*((void *)v108 + 4);
                if (*((unsigned char **)v108 + 3) == v109)
                {
                  llvm::raw_ostream::write(v108, "\n", 1uLL);
                }
                else
                {
                  *int v109 = 10;
                  ++*((void *)v108 + 4);
                }
                if (SHIBYTE(v351) < 0) {
                  operator delete(__p[0]);
                }
                if (SHIBYTE(v353) < 0) {
                  operator delete(v352[0]);
                }
              }
              ++*v64;
              break;
            default:
              break;
          }
          v57 += 2;
          v52 -= 16;
        }
        while (v52);
      }
      v54 += 2;
      uint64_t v52 = v304 + 16;
      unint64_t v44 = v299;
    }
    while (v54 != v297);
  }
  if (byte_1EBCC3A88)
  {
    unsigned int v110 = (uint64_t **)v328;
    v313 = v329;
    if (v328 != v329)
    {
      do
      {
        uint64_t v111 = (uint64_t *)v323;
        unint64_t v112 = v324;
        if (v323 != v324)
        {
          unint64_t v113 = *v110;
          do
          {
            uint64_t v114 = *v111;
            char v115 = (llvm::Value *)*(v113 - 4);
            uint64_t v116 = sub_1CB83544C(*(void *)(*(void *)(v113[5] + 56) + 40) + 272, *v113);
            if (v117 == 1) {
              unint64_t v118 = -2;
            }
            else {
              unint64_t v118 = (unint64_t)(v116 + 7) >> 3;
            }
            llvm::Instruction::getAAMetadata((uint64_t ***)v113, &v345);
            v343 = v115;
            unint64_t v344 = v118;
            size_t v119 = *(void **)(v114 - 32);
            uint64_t v120 = sub_1CB83544C(*(void *)(*(void *)(*(void *)(v114 + 40) + 56) + 40) + 272, **(void **)(v114 - 64));
            if (v121 == 1) {
              unint64_t v122 = -2;
            }
            else {
              unint64_t v122 = (unint64_t)(v120 + 7) >> 3;
            }
            llvm::Instruction::getAAMetadata((uint64_t ***)v114, &v338);
            v336 = v119;
            unint64_t v337 = v122;
            unint64_t v123 = (llvm *)llvm::AAResults::alias((uint64_t)v320, (uint64_t)&v343, (uint64_t)&v336);
            int v124 = (int)v123;
            switch((char)v123)
            {
              case 0:
                uint64_t v125 = (void *)((char *)v295 + 8);
                if (byte_1EBCC30C8 | byte_1EBCC3188)
                {
                  uint64_t v126 = (llvm::raw_ostream *)llvm::errs(v123);
                  uint64_t v127 = v126;
                  __int16 v128 = (_WORD *)*((void *)v126 + 4);
                  if (*((void *)v126 + 3) - (void)v128 > 1uLL)
                  {
                    *__int16 v128 = 8224;
                    *((void *)v126 + 4) += 2;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v126, "  ", 2uLL);
                  }
                  llvm::operator<<(v127, v124);
                  BOOL v129 = (_WORD *)*((void *)v127 + 4);
                  if (*((void *)v127 + 3) - (void)v129 > 1uLL)
                  {
                    _WORD *v129 = 8250;
                    *((void *)v127 + 4) += 2;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v127, ": ", 2uLL);
                  }
                  llvm::Value::print((llvm::Value *)v113, v127, 0);
                  uint64_t v130 = *((void *)v127 + 4);
                  if ((unint64_t)(*((void *)v127 + 3) - v130) > 4)
                  {
                    *(unsigned char *)(v130 + 4) = 32;
                    *(_DWORD *)uint64_t v130 = 1043151904;
                    *((void *)v127 + 4) += 5;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v127, " <-> ", 5uLL);
                  }
                  llvm::Value::print((llvm::Value *)v114, v127, 0);
                  uint64_t v131 = (unsigned char *)*((void *)v127 + 4);
                  if ((unint64_t)v131 >= *((void *)v127 + 3))
                  {
                    llvm::raw_ostream::write(v127, 10);
                  }
                  else
                  {
                    *((void *)v127 + 4) = v131 + 1;
                    *uint64_t v131 = 10;
                  }
                  uint64_t v125 = (void *)((char *)v295 + 8);
                }
                goto LABEL_219;
              case 1:
                uint64_t v125 = (void *)((char *)v295 + 16);
                if (byte_1EBCC30C8 | byte_1EBCC3248)
                {
                  uint64_t v144 = (llvm::raw_ostream *)llvm::errs(v123);
                  uint64_t v145 = v144;
                  uint64_t v146 = (_WORD *)*((void *)v144 + 4);
                  if (*((void *)v144 + 3) - (void)v146 > 1uLL)
                  {
                    *uint64_t v146 = 8224;
                    *((void *)v144 + 4) += 2;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v144, "  ", 2uLL);
                  }
                  llvm::operator<<(v145, v124);
                  uint64_t v147 = (_WORD *)*((void *)v145 + 4);
                  if (*((void *)v145 + 3) - (void)v147 > 1uLL)
                  {
                    _WORD *v147 = 8250;
                    *((void *)v145 + 4) += 2;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v145, ": ", 2uLL);
                  }
                  llvm::Value::print((llvm::Value *)v113, v145, 0);
                  uint64_t v148 = *((void *)v145 + 4);
                  if ((unint64_t)(*((void *)v145 + 3) - v148) > 4)
                  {
                    *(unsigned char *)(v148 + 4) = 32;
                    *(_DWORD *)uint64_t v148 = 1043151904;
                    *((void *)v145 + 4) += 5;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v145, " <-> ", 5uLL);
                  }
                  llvm::Value::print((llvm::Value *)v114, v145, 0);
                  __int16 v149 = (unsigned char *)*((void *)v145 + 4);
                  if ((unint64_t)v149 >= *((void *)v145 + 3))
                  {
                    llvm::raw_ostream::write(v145, 10);
                  }
                  else
                  {
                    *((void *)v145 + 4) = v149 + 1;
                    *__int16 v149 = 10;
                  }
                  uint64_t v125 = (void *)((char *)v295 + 16);
                }
                goto LABEL_219;
              case 2:
                uint64_t v125 = (void *)((char *)v295 + 24);
                if (byte_1EBCC30C8 | byte_1EBCC3308)
                {
                  int v132 = (llvm::raw_ostream *)llvm::errs(v123);
                  uint64_t v133 = v132;
                  uint64_t v134 = (_WORD *)*((void *)v132 + 4);
                  if (*((void *)v132 + 3) - (void)v134 > 1uLL)
                  {
                    *uint64_t v134 = 8224;
                    *((void *)v132 + 4) += 2;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v132, "  ", 2uLL);
                  }
                  llvm::operator<<(v133, v124);
                  int v135 = (_WORD *)*((void *)v133 + 4);
                  if (*((void *)v133 + 3) - (void)v135 > 1uLL)
                  {
                    *int v135 = 8250;
                    *((void *)v133 + 4) += 2;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v133, ": ", 2uLL);
                  }
                  llvm::Value::print((llvm::Value *)v113, v133, 0);
                  uint64_t v136 = *((void *)v133 + 4);
                  if ((unint64_t)(*((void *)v133 + 3) - v136) > 4)
                  {
                    *(unsigned char *)(v136 + 4) = 32;
                    *(_DWORD *)uint64_t v136 = 1043151904;
                    *((void *)v133 + 4) += 5;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v133, " <-> ", 5uLL);
                  }
                  llvm::Value::print((llvm::Value *)v114, v133, 0);
                  unint64_t v137 = (unsigned char *)*((void *)v133 + 4);
                  if ((unint64_t)v137 >= *((void *)v133 + 3))
                  {
                    llvm::raw_ostream::write(v133, 10);
                  }
                  else
                  {
                    *((void *)v133 + 4) = v137 + 1;
                    *unint64_t v137 = 10;
                  }
                  uint64_t v125 = (void *)((char *)v295 + 24);
                }
                goto LABEL_219;
              case 3:
                uint64_t v125 = (void *)((char *)v295 + 32);
                if (byte_1EBCC30C8 | byte_1EBCC33C8)
                {
                  uint64_t v138 = (llvm::raw_ostream *)llvm::errs(v123);
                  int v139 = v138;
                  __int16 v140 = (_WORD *)*((void *)v138 + 4);
                  if (*((void *)v138 + 3) - (void)v140 > 1uLL)
                  {
                    *__int16 v140 = 8224;
                    *((void *)v138 + 4) += 2;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v138, "  ", 2uLL);
                  }
                  llvm::operator<<(v139, v124);
                  char v141 = (_WORD *)*((void *)v139 + 4);
                  if (*((void *)v139 + 3) - (void)v141 > 1uLL)
                  {
                    *char v141 = 8250;
                    *((void *)v139 + 4) += 2;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v139, ": ", 2uLL);
                  }
                  llvm::Value::print((llvm::Value *)v113, v139, 0);
                  uint64_t v142 = *((void *)v139 + 4);
                  if ((unint64_t)(*((void *)v139 + 3) - v142) > 4)
                  {
                    *(unsigned char *)(v142 + 4) = 32;
                    *(_DWORD *)uint64_t v142 = 1043151904;
                    *((void *)v139 + 4) += 5;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v139, " <-> ", 5uLL);
                  }
                  llvm::Value::print((llvm::Value *)v114, v139, 0);
                  uint64_t v143 = (unsigned char *)*((void *)v139 + 4);
                  if ((unint64_t)v143 >= *((void *)v139 + 3))
                  {
                    llvm::raw_ostream::write(v139, 10);
                  }
                  else
                  {
                    *((void *)v139 + 4) = v143 + 1;
                    *uint64_t v143 = 10;
                  }
                  uint64_t v125 = (void *)((char *)v295 + 32);
                }
LABEL_219:
                ++*v125;
                break;
              default:
                break;
            }
            ++v111;
          }
          while (v111 != v112);
        }
        ++v110;
      }
      while (v110 != v313);
    }
    __int16 v150 = (uint64_t ****)v323;
    v318 = (uint64_t ****)v324;
    if (v323 != v324)
    {
      do
      {
        for (j = (uint64_t ****)v323; j != v150; ++j)
        {
          __int16 v152 = *v150;
          __int16 v153 = (llvm::Value *)*(*v150 - 4);
          uint64_t v154 = sub_1CB83544C((*v150)[5][7][5] + 272, (uint64_t)**(*v150 - 8));
          if (v155 == 1) {
            unint64_t v156 = -2;
          }
          else {
            unint64_t v156 = (unint64_t)(v154 + 7) >> 3;
          }
          llvm::Instruction::getAAMetadata(v152, &v345);
          v343 = v153;
          unint64_t v344 = v156;
          int v157 = *j;
          int v158 = *(*j - 4);
          uint64_t v159 = sub_1CB83544C((*j)[5][7][5] + 272, (uint64_t)**(*j - 8));
          if (v160 == 1) {
            unint64_t v161 = -2;
          }
          else {
            unint64_t v161 = (unint64_t)(v159 + 7) >> 3;
          }
          llvm::Instruction::getAAMetadata(v157, &v338);
          v336 = v158;
          unint64_t v337 = v161;
          int v162 = (llvm *)llvm::AAResults::alias((uint64_t)v320, (uint64_t)&v343, (uint64_t)&v336);
          int v163 = (int)v162;
          switch((char)v162)
          {
            case 0:
              __int16 v164 = (void *)((char *)v295 + 8);
              if (byte_1EBCC30C8 | byte_1EBCC3188)
              {
                v314 = (llvm::Value *)*v150;
                uint64_t v165 = (llvm::Value *)*j;
                uint64_t v166 = (llvm::raw_ostream *)llvm::errs(v162);
                uint64_t v167 = v166;
                unint64_t v168 = (_WORD *)*((void *)v166 + 4);
                if (*((void *)v166 + 3) - (void)v168 > 1uLL)
                {
                  *unint64_t v168 = 8224;
                  *((void *)v166 + 4) += 2;
                }
                else
                {
                  llvm::raw_ostream::write(v166, "  ", 2uLL);
                }
                llvm::operator<<(v167, v163);
                int v169 = (_WORD *)*((void *)v167 + 4);
                if (*((void *)v167 + 3) - (void)v169 > 1uLL)
                {
                  *int v169 = 8250;
                  *((void *)v167 + 4) += 2;
                }
                else
                {
                  llvm::raw_ostream::write(v167, ": ", 2uLL);
                }
                llvm::Value::print(v314, v167, 0);
                uint64_t v170 = *((void *)v167 + 4);
                if ((unint64_t)(*((void *)v167 + 3) - v170) > 4)
                {
                  *(unsigned char *)(v170 + 4) = 32;
                  *(_DWORD *)uint64_t v170 = 1043151904;
                  *((void *)v167 + 4) += 5;
                }
                else
                {
                  llvm::raw_ostream::write(v167, " <-> ", 5uLL);
                }
                llvm::Value::print(v165, v167, 0);
                uint64_t v171 = (unsigned char *)*((void *)v167 + 4);
                if ((unint64_t)v171 >= *((void *)v167 + 3))
                {
                  llvm::raw_ostream::write(v167, 10);
                }
                else
                {
                  *((void *)v167 + 4) = v171 + 1;
                  *uint64_t v171 = 10;
                }
                __int16 v164 = (void *)((char *)v295 + 8);
              }
              goto LABEL_289;
            case 1:
              __int16 v164 = (void *)((char *)v295 + 16);
              if (byte_1EBCC30C8 | byte_1EBCC3248)
              {
                v317 = (llvm::Value *)*v150;
                uint64_t v186 = (llvm::Value *)*j;
                uint64_t v187 = (llvm::raw_ostream *)llvm::errs(v162);
                unsigned int v188 = v187;
                unsigned int v189 = (_WORD *)*((void *)v187 + 4);
                if (*((void *)v187 + 3) - (void)v189 > 1uLL)
                {
                  *unsigned int v189 = 8224;
                  *((void *)v187 + 4) += 2;
                }
                else
                {
                  llvm::raw_ostream::write(v187, "  ", 2uLL);
                }
                llvm::operator<<(v188, v163);
                uint64_t v190 = (_WORD *)*((void *)v188 + 4);
                if (*((void *)v188 + 3) - (void)v190 > 1uLL)
                {
                  *uint64_t v190 = 8250;
                  *((void *)v188 + 4) += 2;
                }
                else
                {
                  llvm::raw_ostream::write(v188, ": ", 2uLL);
                }
                llvm::Value::print(v317, v188, 0);
                uint64_t v191 = *((void *)v188 + 4);
                if ((unint64_t)(*((void *)v188 + 3) - v191) > 4)
                {
                  *(unsigned char *)(v191 + 4) = 32;
                  *(_DWORD *)uint64_t v191 = 1043151904;
                  *((void *)v188 + 4) += 5;
                }
                else
                {
                  llvm::raw_ostream::write(v188, " <-> ", 5uLL);
                }
                llvm::Value::print(v186, v188, 0);
                __int16 v192 = (unsigned char *)*((void *)v188 + 4);
                if ((unint64_t)v192 >= *((void *)v188 + 3))
                {
                  llvm::raw_ostream::write(v188, 10);
                }
                else
                {
                  *((void *)v188 + 4) = v192 + 1;
                  *__int16 v192 = 10;
                }
                __int16 v164 = (void *)((char *)v295 + 16);
              }
              goto LABEL_289;
            case 2:
              __int16 v164 = (void *)((char *)v295 + 24);
              if (byte_1EBCC30C8 | byte_1EBCC3308)
              {
                v315 = (llvm::Value *)*v150;
                int v172 = (llvm::Value *)*j;
                uint64_t v173 = (llvm::raw_ostream *)llvm::errs(v162);
                BOOL v174 = v173;
                char v175 = (_WORD *)*((void *)v173 + 4);
                if (*((void *)v173 + 3) - (void)v175 > 1uLL)
                {
                  *char v175 = 8224;
                  *((void *)v173 + 4) += 2;
                }
                else
                {
                  llvm::raw_ostream::write(v173, "  ", 2uLL);
                }
                llvm::operator<<(v174, v163);
                char v176 = (_WORD *)*((void *)v174 + 4);
                if (*((void *)v174 + 3) - (void)v176 > 1uLL)
                {
                  *char v176 = 8250;
                  *((void *)v174 + 4) += 2;
                }
                else
                {
                  llvm::raw_ostream::write(v174, ": ", 2uLL);
                }
                llvm::Value::print(v315, v174, 0);
                uint64_t v177 = *((void *)v174 + 4);
                if ((unint64_t)(*((void *)v174 + 3) - v177) > 4)
                {
                  *(unsigned char *)(v177 + 4) = 32;
                  *(_DWORD *)uint64_t v177 = 1043151904;
                  *((void *)v174 + 4) += 5;
                }
                else
                {
                  llvm::raw_ostream::write(v174, " <-> ", 5uLL);
                }
                llvm::Value::print(v172, v174, 0);
                char v178 = (unsigned char *)*((void *)v174 + 4);
                if ((unint64_t)v178 >= *((void *)v174 + 3))
                {
                  llvm::raw_ostream::write(v174, 10);
                }
                else
                {
                  *((void *)v174 + 4) = v178 + 1;
                  *char v178 = 10;
                }
                __int16 v164 = (void *)((char *)v295 + 24);
              }
              goto LABEL_289;
            case 3:
              __int16 v164 = (void *)((char *)v295 + 32);
              if (byte_1EBCC30C8 | byte_1EBCC33C8)
              {
                v316 = (llvm::Value *)*v150;
                uint64_t v179 = (llvm::Value *)*j;
                unsigned int v180 = (llvm::raw_ostream *)llvm::errs(v162);
                uint64_t v181 = v180;
                unsigned int v182 = (_WORD *)*((void *)v180 + 4);
                if (*((void *)v180 + 3) - (void)v182 > 1uLL)
                {
                  *unsigned int v182 = 8224;
                  *((void *)v180 + 4) += 2;
                }
                else
                {
                  llvm::raw_ostream::write(v180, "  ", 2uLL);
                }
                llvm::operator<<(v181, v163);
                unsigned int v183 = (_WORD *)*((void *)v181 + 4);
                if (*((void *)v181 + 3) - (void)v183 > 1uLL)
                {
                  *unsigned int v183 = 8250;
                  *((void *)v181 + 4) += 2;
                }
                else
                {
                  llvm::raw_ostream::write(v181, ": ", 2uLL);
                }
                llvm::Value::print(v316, v181, 0);
                uint64_t v184 = *((void *)v181 + 4);
                if ((unint64_t)(*((void *)v181 + 3) - v184) > 4)
                {
                  *(unsigned char *)(v184 + 4) = 32;
                  *(_DWORD *)uint64_t v184 = 1043151904;
                  *((void *)v181 + 4) += 5;
                }
                else
                {
                  llvm::raw_ostream::write(v181, " <-> ", 5uLL);
                }
                llvm::Value::print(v179, v181, 0);
                unsigned int v185 = (unsigned char *)*((void *)v181 + 4);
                if ((unint64_t)v185 >= *((void *)v181 + 3))
                {
                  llvm::raw_ostream::write(v181, 10);
                }
                else
                {
                  *((void *)v181 + 4) = v185 + 1;
                  *unsigned int v185 = 10;
                }
                __int16 v164 = (void *)((char *)v295 + 32);
              }
LABEL_289:
              ++*v164;
              break;
            default:
              continue;
          }
        }
        ++v150;
      }
      while (v150 != v318);
    }
  }
  if (v356)
  {
    v308 = (const llvm::CallBase **)v355;
    uint64_t v193 = (void *)((char *)v295 + 40);
    unsigned int v194 = v320;
    uint64_t v195 = v301;
    v298 = (const llvm::CallBase **)((char *)v355 + 8 * v356);
    do
    {
      unsigned int v197 = (llvm::Value **)v333;
      uint64_t v196 = (llvm::Value **)v334;
      if (v333 != v334)
      {
        unsigned int v198 = *v308;
        do
        {
          unint64_t v199 = (unint64_t)(sub_1CB83544C(v195, (uint64_t)v197[1]) + 7) >> 3;
          if (v200 == 1) {
            unint64_t v199 = -2;
          }
          v343 = *v197;
          unint64_t v344 = v199;
          long long v345 = 0u;
          long long v346 = 0u;
          uint64_t ModRefInfo = (llvm *)llvm::AAResults::getModRefInfo(v194, v198, (const llvm::MemoryLocation *)&v343);
          unsigned int v202 = &byte_1EBCC3488;
          uint64_t v203 = "NoModRef";
          unsigned int v204 = v193;
          switch((int)ModRefInfo)
          {
            case 0:
              unsigned int v202 = &byte_1EBCC3788;
              uint64_t v203 = "Must";
              unsigned int v204 = (void *)((char *)v295 + 72);
              goto LABEL_334;
            case 1:
              unsigned int v202 = &byte_1EBCC3848;
              uint64_t v203 = "Just Ref (MustAlias)";
              unsigned int v204 = (void *)((char *)v295 + 80);
              goto LABEL_334;
            case 2:
              unsigned int v202 = &byte_1EBCC3908;
              uint64_t v203 = "Just Mod (MustAlias)";
              unsigned int v204 = (void *)((char *)v295 + 88);
              goto LABEL_334;
            case 3:
              unsigned int v202 = &byte_1EBCC39C8;
              uint64_t v203 = "Both ModRef (MustAlias)";
              unsigned int v204 = (void *)((char *)v295 + 96);
              goto LABEL_334;
            case 4:
              goto LABEL_334;
            case 5:
              unsigned int v202 = &byte_1EBCC3548;
              uint64_t v203 = "Just Ref";
              unsigned int v204 = (void *)((char *)v295 + 56);
              goto LABEL_334;
            case 6:
              unsigned int v202 = &byte_1EBCC3608;
              uint64_t v203 = "Just Mod";
              unsigned int v204 = (void *)((char *)v295 + 48);
              goto LABEL_334;
            case 7:
              unsigned int v202 = &byte_1EBCC36C8;
              uint64_t v203 = "Both ModRef";
              unsigned int v204 = (void *)((char *)v295 + 64);
LABEL_334:
              if (byte_1EBCC30C8 | *v202)
              {
                unsigned int v205 = *v197;
                uint64_t v206 = *(void *)*v197;
                unsigned int v207 = *(_DWORD *)(v206 + 8);
                if ((v207 & 0xFE) == 0x12) {
                  unsigned int v207 = *(_DWORD *)(**(void **)(v206 + 16) + 8);
                }
                v303 = v197[1];
                v305 = (const llvm::Module *)*((void *)v300 + 5);
                unsigned int v208 = (llvm::raw_ostream *)llvm::errs(ModRefInfo);
                unsigned int v209 = v208;
                uint64_t v210 = (_WORD *)*((void *)v208 + 4);
                v307 = v205;
                if (*((void *)v208 + 3) - (void)v210 > 1uLL)
                {
                  *uint64_t v210 = 8224;
                  unsigned int v211 = (void *)(*((void *)v208 + 4) + 2);
                  *((void *)v208 + 4) = v211;
                }
                else
                {
                  llvm::raw_ostream::write(v208, "  ", 2uLL);
                  unsigned int v211 = (void *)*((void *)v209 + 4);
                }
                unsigned int v212 = (llvm *)strlen(v203);
                uint64_t v213 = v212;
                if ((unint64_t)v212 <= *((void *)v209 + 3) - (void)v211)
                {
                  if (v212)
                  {
                    unsigned int v212 = (llvm *)memcpy(v211, v203, (size_t)v212);
                    unsigned int v211 = (void *)((char *)v213 + *((void *)v209 + 4));
                    *((void *)v209 + 4) = v211;
                  }
                }
                else
                {
                  unsigned int v212 = llvm::raw_ostream::write(v209, v203, (size_t)v212);
                  unsigned int v211 = (void *)*((void *)v209 + 4);
                }
                unsigned int v214 = v207;
                if (*((void *)v209 + 3) - (void)v211 > 7uLL)
                {
                  *unsigned int v211 = 0x203A72745020203ALL;
                  *((void *)v209 + 4) += 8;
                }
                else
                {
                  unsigned int v212 = llvm::raw_ostream::write(v209, ":  Ptr: ", 8uLL);
                }
                uint64_t v193 = (void *)((char *)v295 + 40);
                unsigned int v215 = (llvm::raw_ostream *)llvm::errs(v212);
                uint64_t v216 = (llvm *)llvm::Type::print(v303, v215, 0, 1);
                unsigned int v194 = v320;
                if (v207 >= 0x100)
                {
                  unsigned int v217 = (llvm::raw_ostream *)llvm::errs(v216);
                  unsigned int v218 = v217;
                  uint64_t v219 = *((void *)v217 + 4);
                  if ((unint64_t)(*((void *)v217 + 3) - v219) > 0xA)
                  {
                    *(_DWORD *)(v219 + 7) = 677733217;
                    *(void *)uint64_t v219 = *(void *)" addrspace(";
                    *((void *)v217 + 4) += 11;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v217, " addrspace(", 0xBuLL);
                  }
                  uint64_t v216 = sub_1CD098D14(v218, v214 >> 8, 0, 0, 0);
                  unsigned int v220 = (unsigned char *)*((void *)v218 + 4);
                  if (*((unsigned char **)v218 + 3) == v220)
                  {
                    uint64_t v216 = llvm::raw_ostream::write(v218, ")", 1uLL);
                  }
                  else
                  {
                    *unsigned int v220 = 41;
                    ++*((void *)v218 + 4);
                  }
                }
                unsigned int v221 = (llvm::raw_ostream *)llvm::errs(v216);
                uint64_t v222 = (_WORD *)*((void *)v221 + 4);
                if (*((void *)v221 + 3) - (void)v222 > 1uLL)
                {
                  *uint64_t v222 = 8234;
                  *((void *)v221 + 4) += 2;
                }
                else
                {
                  unsigned int v221 = llvm::raw_ostream::write(v221, "* ", 2uLL);
                }
                unsigned int v223 = (llvm::raw_ostream *)llvm::errs(v221);
                unsigned int v224 = (llvm *)llvm::Value::printAsOperand(v307, v223, 0, v305);
                uint64_t v225 = (llvm::raw_ostream *)llvm::errs(v224);
                uint64_t v226 = v225;
                unsigned int v227 = (_DWORD *)*((void *)v225 + 4);
                if (*((void *)v225 + 3) - (void)v227 > 3uLL)
                {
                  *unsigned int v227 = 1043151881;
                  *((void *)v225 + 4) += 4;
                }
                else
                {
                  llvm::raw_ostream::write(v225, "\t<->", 4uLL);
                }
                llvm::Value::print(v198, v226, 0);
                unsigned int v228 = (unsigned char *)*((void *)v226 + 4);
                if ((unint64_t)v228 >= *((void *)v226 + 3))
                {
                  llvm::raw_ostream::write(v226, 10);
                }
                else
                {
                  *((void *)v226 + 4) = v228 + 1;
                  *unsigned int v228 = 10;
                }
                uint64_t v195 = v301;
              }
              ++*v204;
              break;
            default:
              break;
          }
          v197 += 2;
        }
        while (v197 != v196);
      }
      ++v308;
    }
    while (v308 != v298);
    uint64_t v229 = v356;
    if (v356)
    {
      uint64_t v230 = (const llvm::CallBase **)v355;
      unsigned int v231 = (const llvm::CallBase **)((char *)v355 + 8 * v356);
      int v232 = (const llvm::CallBase **)v355;
LABEL_371:
      int v233 = *v232;
      uint64_t v234 = 8 * v229;
      do
      {
        v235 = *v230;
        if (v233 != *v230)
        {
          unint64_t v236 = (llvm *)llvm::AAResults::getModRefInfo(v320, v233, *v230);
          switch((int)v236)
          {
            case 0:
              unint64_t v237 = (void *)((char *)v295 + 72);
              if (byte_1EBCC30C8 | byte_1EBCC3788)
              {
                unint64_t v238 = (llvm::raw_ostream *)llvm::errs(v236);
                v239 = v238;
                v240 = (_WORD *)*((void *)v238 + 4);
                if (*((void *)v238 + 3) - (void)v240 > 1uLL)
                {
                  _WORD *v240 = 8224;
                  v241 = (_DWORD *)(*((void *)v238 + 4) + 2);
                  *((void *)v238 + 4) = v241;
                }
                else
                {
                  llvm::raw_ostream::write(v238, "  ", 2uLL);
                  v241 = (_DWORD *)*((void *)v239 + 4);
                }
                if (*((void *)v239 + 3) - (void)v241 > 3uLL)
                {
                  _DWORD *v241 = 1953723725;
                  v242 = (_WORD *)(*((void *)v239 + 4) + 4);
                  *((void *)v239 + 4) = v242;
                }
                else
                {
                  llvm::raw_ostream::write(v239, "Must", 4uLL);
                  v242 = (_WORD *)*((void *)v239 + 4);
                }
                if (*((void *)v239 + 3) - (void)v242 > 1uLL)
                {
                  _WORD *v242 = 8250;
                  *((void *)v239 + 4) += 2;
                }
                else
                {
                  llvm::raw_ostream::write(v239, ": ", 2uLL);
                }
                llvm::Value::print(v233, v239, 0);
                uint64_t v243 = *((void *)v239 + 4);
                if ((unint64_t)(*((void *)v239 + 3) - v243) > 4)
                {
                  *(unsigned char *)(v243 + 4) = 32;
                  *(_DWORD *)uint64_t v243 = 1043151904;
                  *((void *)v239 + 4) += 5;
                }
                else
                {
                  llvm::raw_ostream::write(v239, " <-> ", 5uLL);
                }
                llvm::Value::print(v235, v239, 0);
                v244 = (unsigned char *)*((void *)v239 + 4);
                if ((unint64_t)v244 >= *((void *)v239 + 3))
                {
                  llvm::raw_ostream::write(v239, 10);
                }
                else
                {
                  *((void *)v239 + 4) = v244 + 1;
                  unsigned char *v244 = 10;
                }
                unint64_t v237 = (void *)((char *)v295 + 72);
              }
              goto LABEL_452;
            case 1:
              unint64_t v237 = (void *)((char *)v295 + 80);
              if (byte_1EBCC30C8 | byte_1EBCC3848)
              {
                v259 = (llvm::raw_ostream *)llvm::errs(v236);
                v260 = v259;
                v261 = (_WORD *)*((void *)v259 + 4);
                if (*((void *)v259 + 3) - (void)v261 > 1uLL)
                {
                  _WORD *v261 = 8224;
                  uint64_t v262 = *((void *)v259 + 4) + 2;
                  *((void *)v259 + 4) = v262;
                }
                else
                {
                  llvm::raw_ostream::write(v259, "  ", 2uLL);
                  uint64_t v262 = *((void *)v260 + 4);
                }
                if ((unint64_t)(*((void *)v260 + 3) - v262) > 0x13)
                {
                  *(_DWORD *)(v262 + 16) = 695427433;
                  *(_OWORD *)uint64_t v262 = *(_OWORD *)"Just Ref (MustAlias)";
                  v263 = (_WORD *)(*((void *)v260 + 4) + 20);
                  *((void *)v260 + 4) = v263;
                }
                else
                {
                  llvm::raw_ostream::write(v260, "Just Ref (MustAlias)", 0x14uLL);
                  v263 = (_WORD *)*((void *)v260 + 4);
                }
                if (*((void *)v260 + 3) - (void)v263 > 1uLL)
                {
                  _WORD *v263 = 8250;
                  *((void *)v260 + 4) += 2;
                }
                else
                {
                  llvm::raw_ostream::write(v260, ": ", 2uLL);
                }
                llvm::Value::print(v233, v260, 0);
                uint64_t v264 = *((void *)v260 + 4);
                if ((unint64_t)(*((void *)v260 + 3) - v264) > 4)
                {
                  *(unsigned char *)(v264 + 4) = 32;
                  *(_DWORD *)uint64_t v264 = 1043151904;
                  *((void *)v260 + 4) += 5;
                }
                else
                {
                  llvm::raw_ostream::write(v260, " <-> ", 5uLL);
                }
                llvm::Value::print(v235, v260, 0);
                v265 = (unsigned char *)*((void *)v260 + 4);
                if ((unint64_t)v265 >= *((void *)v260 + 3))
                {
                  llvm::raw_ostream::write(v260, 10);
                }
                else
                {
                  *((void *)v260 + 4) = v265 + 1;
                  unsigned char *v265 = 10;
                }
                unint64_t v237 = (void *)((char *)v295 + 80);
              }
              goto LABEL_452;
            case 2:
              unint64_t v237 = (void *)((char *)v295 + 88);
              if (byte_1EBCC30C8 | byte_1EBCC3908)
              {
                v252 = (llvm::raw_ostream *)llvm::errs(v236);
                v253 = v252;
                v254 = (_WORD *)*((void *)v252 + 4);
                if (*((void *)v252 + 3) - (void)v254 > 1uLL)
                {
                  _WORD *v254 = 8224;
                  uint64_t v255 = *((void *)v252 + 4) + 2;
                  *((void *)v252 + 4) = v255;
                }
                else
                {
                  llvm::raw_ostream::write(v252, "  ", 2uLL);
                  uint64_t v255 = *((void *)v253 + 4);
                }
                if ((unint64_t)(*((void *)v253 + 3) - v255) > 0x13)
                {
                  *(_DWORD *)(v255 + 16) = 695427433;
                  *(_OWORD *)uint64_t v255 = *(_OWORD *)"Just Mod (MustAlias)";
                  v256 = (_WORD *)(*((void *)v253 + 4) + 20);
                  *((void *)v253 + 4) = v256;
                }
                else
                {
                  llvm::raw_ostream::write(v253, "Just Mod (MustAlias)", 0x14uLL);
                  v256 = (_WORD *)*((void *)v253 + 4);
                }
                if (*((void *)v253 + 3) - (void)v256 > 1uLL)
                {
                  _WORD *v256 = 8250;
                  *((void *)v253 + 4) += 2;
                }
                else
                {
                  llvm::raw_ostream::write(v253, ": ", 2uLL);
                }
                llvm::Value::print(v233, v253, 0);
                uint64_t v257 = *((void *)v253 + 4);
                if ((unint64_t)(*((void *)v253 + 3) - v257) > 4)
                {
                  *(unsigned char *)(v257 + 4) = 32;
                  *(_DWORD *)uint64_t v257 = 1043151904;
                  *((void *)v253 + 4) += 5;
                }
                else
                {
                  llvm::raw_ostream::write(v253, " <-> ", 5uLL);
                }
                llvm::Value::print(v235, v253, 0);
                v258 = (unsigned char *)*((void *)v253 + 4);
                if ((unint64_t)v258 >= *((void *)v253 + 3))
                {
                  llvm::raw_ostream::write(v253, 10);
                }
                else
                {
                  *((void *)v253 + 4) = v258 + 1;
                  unsigned char *v258 = 10;
                }
                unint64_t v237 = (void *)((char *)v295 + 88);
              }
              goto LABEL_452;
            case 3:
              unint64_t v237 = (void *)((char *)v295 + 96);
              if (byte_1EBCC30C8 | byte_1EBCC39C8)
              {
                v266 = (llvm::raw_ostream *)llvm::errs(v236);
                v267 = v266;
                v268 = (_WORD *)*((void *)v266 + 4);
                if (*((void *)v266 + 3) - (void)v268 > 1uLL)
                {
                  _WORD *v268 = 8224;
                  v269 = (void *)(*((void *)v266 + 4) + 2);
                  *((void *)v266 + 4) = v269;
                }
                else
                {
                  llvm::raw_ostream::write(v266, "  ", 2uLL);
                  v269 = (void *)*((void *)v267 + 4);
                }
                if (*((void *)v267 + 3) - (void)v269 > 0x16uLL)
                {
                  qmemcpy(v269, "Both ModRef (MustAlias)", 23);
                  v270 = (_WORD *)(*((void *)v267 + 4) + 23);
                  *((void *)v267 + 4) = v270;
                }
                else
                {
                  llvm::raw_ostream::write(v267, "Both ModRef (MustAlias)", 0x17uLL);
                  v270 = (_WORD *)*((void *)v267 + 4);
                }
                if (*((void *)v267 + 3) - (void)v270 > 1uLL)
                {
                  _WORD *v270 = 8250;
                  *((void *)v267 + 4) += 2;
                }
                else
                {
                  llvm::raw_ostream::write(v267, ": ", 2uLL);
                }
                llvm::Value::print(v233, v267, 0);
                uint64_t v271 = *((void *)v267 + 4);
                if ((unint64_t)(*((void *)v267 + 3) - v271) > 4)
                {
                  *(unsigned char *)(v271 + 4) = 32;
                  *(_DWORD *)uint64_t v271 = 1043151904;
                  *((void *)v267 + 4) += 5;
                }
                else
                {
                  llvm::raw_ostream::write(v267, " <-> ", 5uLL);
                }
                llvm::Value::print(v235, v267, 0);
                v272 = (unsigned char *)*((void *)v267 + 4);
                if ((unint64_t)v272 >= *((void *)v267 + 3))
                {
                  llvm::raw_ostream::write(v267, 10);
                }
                else
                {
                  *((void *)v267 + 4) = v272 + 1;
                  unsigned char *v272 = 10;
                }
                unint64_t v237 = (void *)((char *)v295 + 96);
              }
              goto LABEL_452;
            case 4:
              unint64_t v237 = (void *)((char *)v295 + 40);
              if (byte_1EBCC30C8 | byte_1EBCC3488)
              {
                v245 = (llvm::raw_ostream *)llvm::errs(v236);
                v246 = v245;
                v247 = (_WORD *)*((void *)v245 + 4);
                if (*((void *)v245 + 3) - (void)v247 > 1uLL)
                {
                  _WORD *v247 = 8224;
                  v248 = (void *)(*((void *)v245 + 4) + 2);
                  *((void *)v245 + 4) = v248;
                }
                else
                {
                  llvm::raw_ostream::write(v245, "  ", 2uLL);
                  v248 = (void *)*((void *)v246 + 4);
                }
                if (*((void *)v246 + 3) - (void)v248 > 7uLL)
                {
                  void *v248 = 0x666552646F4D6F4ELL;
                  v249 = (_WORD *)(*((void *)v246 + 4) + 8);
                  *((void *)v246 + 4) = v249;
                }
                else
                {
                  llvm::raw_ostream::write(v246, "NoModRef", 8uLL);
                  v249 = (_WORD *)*((void *)v246 + 4);
                }
                if (*((void *)v246 + 3) - (void)v249 > 1uLL)
                {
                  _WORD *v249 = 8250;
                  *((void *)v246 + 4) += 2;
                }
                else
                {
                  llvm::raw_ostream::write(v246, ": ", 2uLL);
                }
                llvm::Value::print(v233, v246, 0);
                uint64_t v250 = *((void *)v246 + 4);
                if ((unint64_t)(*((void *)v246 + 3) - v250) > 4)
                {
                  *(unsigned char *)(v250 + 4) = 32;
                  *(_DWORD *)uint64_t v250 = 1043151904;
                  *((void *)v246 + 4) += 5;
                }
                else
                {
                  llvm::raw_ostream::write(v246, " <-> ", 5uLL);
                }
                llvm::Value::print(v235, v246, 0);
                v251 = (unsigned char *)*((void *)v246 + 4);
                if ((unint64_t)v251 >= *((void *)v246 + 3))
                {
                  llvm::raw_ostream::write(v246, 10);
                }
                else
                {
                  *((void *)v246 + 4) = v251 + 1;
                  unsigned char *v251 = 10;
                }
                unint64_t v237 = (void *)((char *)v295 + 40);
              }
              goto LABEL_452;
            case 5:
              unint64_t v237 = (void *)((char *)v295 + 56);
              if (byte_1EBCC30C8 | byte_1EBCC3548)
              {
                v280 = (llvm::raw_ostream *)llvm::errs(v236);
                v281 = v280;
                v282 = (_WORD *)*((void *)v280 + 4);
                if (*((void *)v280 + 3) - (void)v282 > 1uLL)
                {
                  _WORD *v282 = 8224;
                  v283 = (void *)(*((void *)v280 + 4) + 2);
                  *((void *)v280 + 4) = v283;
                }
                else
                {
                  llvm::raw_ostream::write(v280, "  ", 2uLL);
                  v283 = (void *)*((void *)v281 + 4);
                }
                if (*((void *)v281 + 3) - (void)v283 > 7uLL)
                {
                  void *v283 = 0x666552207473754ALL;
                  v284 = (_WORD *)(*((void *)v281 + 4) + 8);
                  *((void *)v281 + 4) = v284;
                }
                else
                {
                  llvm::raw_ostream::write(v281, "Just Ref", 8uLL);
                  v284 = (_WORD *)*((void *)v281 + 4);
                }
                if (*((void *)v281 + 3) - (void)v284 > 1uLL)
                {
                  _WORD *v284 = 8250;
                  *((void *)v281 + 4) += 2;
                }
                else
                {
                  llvm::raw_ostream::write(v281, ": ", 2uLL);
                }
                llvm::Value::print(v233, v281, 0);
                uint64_t v285 = *((void *)v281 + 4);
                if ((unint64_t)(*((void *)v281 + 3) - v285) > 4)
                {
                  *(unsigned char *)(v285 + 4) = 32;
                  *(_DWORD *)uint64_t v285 = 1043151904;
                  *((void *)v281 + 4) += 5;
                }
                else
                {
                  llvm::raw_ostream::write(v281, " <-> ", 5uLL);
                }
                llvm::Value::print(v235, v281, 0);
                v286 = (unsigned char *)*((void *)v281 + 4);
                if ((unint64_t)v286 >= *((void *)v281 + 3))
                {
                  llvm::raw_ostream::write(v281, 10);
                }
                else
                {
                  *((void *)v281 + 4) = v286 + 1;
                  unsigned char *v286 = 10;
                }
                unint64_t v237 = (void *)((char *)v295 + 56);
              }
              goto LABEL_452;
            case 6:
              unint64_t v237 = (void *)((char *)v295 + 48);
              if (byte_1EBCC30C8 | byte_1EBCC3608)
              {
                v287 = (llvm::raw_ostream *)llvm::errs(v236);
                v288 = v287;
                v289 = (_WORD *)*((void *)v287 + 4);
                if (*((void *)v287 + 3) - (void)v289 > 1uLL)
                {
                  _WORD *v289 = 8224;
                  v290 = (void *)(*((void *)v287 + 4) + 2);
                  *((void *)v287 + 4) = v290;
                }
                else
                {
                  llvm::raw_ostream::write(v287, "  ", 2uLL);
                  v290 = (void *)*((void *)v288 + 4);
                }
                if (*((void *)v288 + 3) - (void)v290 > 7uLL)
                {
                  void *v290 = 0x646F4D207473754ALL;
                  v291 = (_WORD *)(*((void *)v288 + 4) + 8);
                  *((void *)v288 + 4) = v291;
                }
                else
                {
                  llvm::raw_ostream::write(v288, "Just Mod", 8uLL);
                  v291 = (_WORD *)*((void *)v288 + 4);
                }
                if (*((void *)v288 + 3) - (void)v291 > 1uLL)
                {
                  _WORD *v291 = 8250;
                  *((void *)v288 + 4) += 2;
                }
                else
                {
                  llvm::raw_ostream::write(v288, ": ", 2uLL);
                }
                llvm::Value::print(v233, v288, 0);
                uint64_t v292 = *((void *)v288 + 4);
                if ((unint64_t)(*((void *)v288 + 3) - v292) > 4)
                {
                  *(unsigned char *)(v292 + 4) = 32;
                  *(_DWORD *)uint64_t v292 = 1043151904;
                  *((void *)v288 + 4) += 5;
                }
                else
                {
                  llvm::raw_ostream::write(v288, " <-> ", 5uLL);
                }
                llvm::Value::print(v235, v288, 0);
                v293 = (unsigned char *)*((void *)v288 + 4);
                if ((unint64_t)v293 >= *((void *)v288 + 3))
                {
                  llvm::raw_ostream::write(v288, 10);
                }
                else
                {
                  *((void *)v288 + 4) = v293 + 1;
                  unsigned char *v293 = 10;
                }
                unint64_t v237 = (void *)((char *)v295 + 48);
              }
              goto LABEL_452;
            case 7:
              unint64_t v237 = (void *)((char *)v295 + 64);
              if (byte_1EBCC30C8 | byte_1EBCC36C8)
              {
                v273 = (llvm::raw_ostream *)llvm::errs(v236);
                v274 = v273;
                v275 = (_WORD *)*((void *)v273 + 4);
                if (*((void *)v273 + 3) - (void)v275 > 1uLL)
                {
                  _WORD *v275 = 8224;
                  uint64_t v276 = *((void *)v273 + 4) + 2;
                  *((void *)v273 + 4) = v276;
                }
                else
                {
                  llvm::raw_ostream::write(v273, "  ", 2uLL);
                  uint64_t v276 = *((void *)v274 + 4);
                }
                if ((unint64_t)(*((void *)v274 + 3) - v276) > 0xA)
                {
                  *(_DWORD *)(v276 + 7) = 1717916260;
                  *(void *)uint64_t v276 = *(void *)"Both ModRef";
                  v277 = (_WORD *)(*((void *)v274 + 4) + 11);
                  *((void *)v274 + 4) = v277;
                }
                else
                {
                  llvm::raw_ostream::write(v274, "Both ModRef", 0xBuLL);
                  v277 = (_WORD *)*((void *)v274 + 4);
                }
                if (*((void *)v274 + 3) - (void)v277 > 1uLL)
                {
                  _WORD *v277 = 8250;
                  *((void *)v274 + 4) += 2;
                }
                else
                {
                  llvm::raw_ostream::write(v274, ": ", 2uLL);
                }
                llvm::Value::print(v233, v274, 0);
                uint64_t v278 = *((void *)v274 + 4);
                if ((unint64_t)(*((void *)v274 + 3) - v278) > 4)
                {
                  *(unsigned char *)(v278 + 4) = 32;
                  *(_DWORD *)uint64_t v278 = 1043151904;
                  *((void *)v274 + 4) += 5;
                }
                else
                {
                  llvm::raw_ostream::write(v274, " <-> ", 5uLL);
                }
                llvm::Value::print(v235, v274, 0);
                v279 = (unsigned char *)*((void *)v274 + 4);
                if ((unint64_t)v279 >= *((void *)v274 + 3))
                {
                  llvm::raw_ostream::write(v274, 10);
                }
                else
                {
                  *((void *)v274 + 4) = v279 + 1;
                  unsigned char *v279 = 10;
                }
                unint64_t v237 = (void *)((char *)v295 + 64);
              }
LABEL_452:
              ++*v237;
              break;
            default:
              break;
          }
        }
        ++v230;
        v234 -= 8;
      }
      while (v234);
      while (++v232 != v231)
      {
        uint64_t v229 = v356;
        uint64_t v230 = (const llvm::CallBase **)v355;
        if (v356) {
          goto LABEL_371;
        }
      }
    }
  }
  if (v323)
  {
    v324 = (uint64_t *)v323;
    operator delete(v323);
  }
  MEMORY[0x1D25D9CD0](v321[0], 8);
  if (v328)
  {
    v329 = (uint64_t **)v328;
    operator delete(v328);
  }
  MEMORY[0x1D25D9CD0](v326[0], 8);
  if (v355 != v357) {
    free(v355);
  }
  if ((v354[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v354[1], 8);
  }
  return sub_1CD456CB4(v331);
}

void sub_1CBF5F5F4(void *a1, uint64_t *a2)
{
  sub_1CD459424((uint64_t)v14, (uint64_t)a1, a2);
  if (v14[16])
  {
    uint64_t v5 = (_OWORD *)a1[4];
    unint64_t v4 = a1[5];
    if ((unint64_t)v5 >= v4)
    {
      int64x2_t v7 = (_OWORD *)a1[3];
      uint64_t v8 = v5 - v7;
      unint64_t v9 = v8 + 1;
      if ((unint64_t)(v8 + 1) >> 60) {
        abort();
      }
      uint64_t v10 = v4 - (void)v7;
      if (v10 >> 3 > v9) {
        unint64_t v9 = v10 >> 3;
      }
      if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v11 = v9;
      }
      if (v11)
      {
        if (v11 >> 60) {
          sub_1CB833614();
        }
        uint64_t v12 = (char *)operator new(16 * v11);
      }
      else
      {
        uint64_t v12 = 0;
      }
      int v13 = &v12[16 * v8];
      *(_OWORD *)int v13 = *(_OWORD *)a2;
      uint64_t v6 = v13 + 16;
      if (v5 != v7)
      {
        do
        {
          *((_OWORD *)v13 - 1) = *(v5 - 1);
          v13 -= 16;
          --v5;
        }
        while (v5 != v7);
        uint64_t v5 = (_OWORD *)a1[3];
      }
      a1[3] = v13;
      a1[4] = v6;
      a1[5] = &v12[16 * v11];
      if (v5) {
        operator delete(v5);
      }
    }
    else
    {
      *uint64_t v5 = *(_OWORD *)a2;
      uint64_t v6 = v5 + 1;
    }
    a1[4] = v6;
  }
}

BOOL sub_1CBF5F714(void *a1, void *a2)
{
  sub_1CBF5FAF4((uint64_t)a1, a2, (uint64_t)&v17);
  int v4 = v18;
  if (v18)
  {
    uint64_t v6 = (void *)a1[4];
    unint64_t v5 = a1[5];
    if ((unint64_t)v6 >= v5)
    {
      uint64_t v8 = (void *)a1[3];
      uint64_t v9 = v6 - v8;
      unint64_t v10 = v9 + 1;
      if ((unint64_t)(v9 + 1) >> 61) {
        abort();
      }
      uint64_t v11 = v5 - (void)v8;
      if (v11 >> 2 > v10) {
        unint64_t v10 = v11 >> 2;
      }
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v12 = v10;
      }
      if (v12)
      {
        if (v12 >> 61) {
          sub_1CB833614();
        }
        int v13 = (char *)operator new(8 * v12);
      }
      else
      {
        int v13 = 0;
      }
      unint64_t v14 = &v13[8 * v9];
      *(void *)unint64_t v14 = *a2;
      int64x2_t v7 = v14 + 8;
      if (v6 != v8)
      {
        do
        {
          uint64_t v15 = *--v6;
          *((void *)v14 - 1) = v15;
          v14 -= 8;
        }
        while (v6 != v8);
        uint64_t v6 = (void *)a1[3];
      }
      a1[3] = v14;
      a1[4] = v7;
      a1[5] = &v13[8 * v12];
      if (v6) {
        operator delete(v6);
      }
    }
    else
    {
      *uint64_t v6 = *a2;
      int64x2_t v7 = v6 + 1;
    }
    a1[4] = v7;
  }
  return v4 != 0;
}

BOOL sub_1CBF5F834(uint64_t a1, uint64_t *a2)
{
  sub_1CBF5FD98(a1, a2, (uint64_t)&v8);
  int v4 = v9;
  if (v9)
  {
    uint64_t v5 = *a2;
    unsigned int v6 = *(_DWORD *)(a1 + 144);
    if (v6 >= *(_DWORD *)(a1 + 148)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 136) + 8 * v6) = v5;
    ++*(_DWORD *)(a1 + 144);
  }
  return v4 != 0;
}

llvm::raw_ostream *sub_1CBF5F8C4(llvm *a1, uint64_t a2)
{
  int v4 = (llvm::raw_ostream *)llvm::errs(a1);
  uint64_t v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    int v4 = llvm::raw_ostream::write(v4, "(", 1uLL);
  }
  else
  {
    *uint64_t v5 = 40;
    ++*((void *)v4 + 4);
  }
  unsigned int v6 = llvm::raw_ostream::operator<<(v4, 100 * (uint64_t)a1 / a2);
  int64x2_t v7 = (unsigned char *)*((void *)v6 + 4);
  if (*((unsigned char **)v6 + 3) == v7)
  {
    unsigned int v6 = llvm::raw_ostream::write(v6, ".", 1uLL);
  }
  else
  {
    *int64x2_t v7 = 46;
    ++*((void *)v6 + 4);
  }
  uint64_t result = llvm::raw_ostream::operator<<(v6, 1000 * (uint64_t)a1 / a2 % 10);
  uint64_t v9 = *((void *)result + 4);
  if ((unint64_t)(*((void *)result + 3) - v9) > 2)
  {
    *(unsigned char *)(v9 + 2) = 10;
    *(_WORD *)uint64_t v9 = 10533;
    *((void *)result + 4) += 3;
  }
  else
  {
    return llvm::raw_ostream::write(result, "%)\n", 3uLL);
  }
  return result;
}

void llvm::initializeAAEvalLegacyPassPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC3040, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBF5FA50;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC3040, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBF5FA50(llvm *a1, llvm::PassRegistry *a2)
{
}

uint64_t sub_1CBF5FAF4@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v10 = 0;
  uint64_t result = sub_1CBF5FB7C((uint64_t *)a1, a2, &v10);
  int64x2_t v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CBF5FC18(a1, (uint64_t)a2, a2, v10);
    int64x2_t v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CBF5FB7C(uint64_t *a1, void *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    int v5 = v3 - 1;
    unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
    int64x2_t v7 = (void *)(*a1 + 8 * v6);
    uint64_t v8 = *v7;
    if (*a2 == *v7)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v9 = 0;
      int v10 = 1;
      uint64_t result = 1;
      while (v8 != -4096)
      {
        if (v9) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v8 == -8192;
        }
        if (v12) {
          uint64_t v9 = v7;
        }
        unsigned int v13 = v6 + v10++;
        unsigned int v6 = v13 & v5;
        int64x2_t v7 = (void *)(v4 + 8 * (v13 & v5));
        uint64_t v8 = *v7;
        if (*a2 == *v7) {
          goto LABEL_7;
        }
      }
      uint64_t result = 0;
      if (v9) {
        int64x2_t v7 = v9;
      }
    }
  }
  else
  {
    int64x2_t v7 = 0;
    uint64_t result = 0;
  }
LABEL_7:
  *a3 = v7;
  return result;
}

void *sub_1CBF5FC18(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
LABEL_3:
    sub_1CBF5FCCC(a1, v7);
    uint64_t v9 = 0;
    sub_1CBF5FB7C((uint64_t *)a1, a3, &v9);
    a4 = v9;
    goto LABEL_4;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3) {
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CBF5FCCC(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD459808(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

void *sub_1CBF5FD98@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v14 = 0;
  uint64_t result = (void *)sub_1CBB07564(a1, a2, &v14);
  int v7 = v14;
  if (result)
  {
    uint64_t v12 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v13 = 16;
    }
    else
    {
      uint64_t v12 = *(void *)(a1 + 8);
      uint64_t v13 = *(unsigned int *)(a1 + 16);
    }
    char v11 = 0;
    uint64_t v10 = v12 + 8 * v13;
  }
  else
  {
    uint64_t result = sub_1CBF5FE54((_DWORD *)a1, (uint64_t)a2, a2, v14);
    int v7 = result;
    *uint64_t result = *a2;
    uint64_t v8 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v9 = 16;
    }
    else
    {
      uint64_t v8 = *(void *)(a1 + 8);
      uint64_t v9 = *(unsigned int *)(a1 + 16);
    }
    uint64_t v10 = v8 + 8 * v9;
    char v11 = 1;
  }
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v10;
  *(unsigned char *)(a3 + 16) = v11;
  return result;
}

void *sub_1CBF5FE54(_DWORD *a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *a1 >> 1;
  if (*a1) {
    unsigned int v7 = 16;
  }
  else {
    unsigned int v7 = a1[4];
  }
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - a1[1] > v7 >> 3)
  {
    goto LABEL_5;
  }
  sub_1CBF5FF18((uint64_t)a1, v7);
  uint64_t v9 = 0;
  sub_1CBB07564((uint64_t)a1, a3, &v9);
  a4 = v9;
LABEL_5:
  *a1 += 2;
  if (*a4 != -4096) {
    --a1[1];
  }
  return a4;
}

uint64_t sub_1CBF5FF18(uint64_t a1, unsigned int a2)
{
  v14[16] = *MEMORY[0x1E4F143B8];
  if (a2 >= 0x11)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    int v6 = *(void **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 <= 0x10)
    {
      *(_DWORD *)a1 |= 1u;
    }
    else
    {
      uint64_t v8 = a2;
      *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v8;
    }
    sub_1CBF60094(a1, v6, &v6[v7]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v9 = v14;
  for (uint64_t i = 8; i != 136; i += 8)
  {
    uint64_t v11 = *(void *)(a1 + i);
    if ((v11 | 0x1000) != 0xFFFFFFFFFFFFF000) {
      *v9++ = v11;
    }
  }
  if (a2 > 0x10)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v12 = a2;
    *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v12;
  }
  return sub_1CBF60094(a1, v14, v9);
}

uint64_t sub_1CBF60094(uint64_t result, void *a2, void *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 136);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_9;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[v7];
  }
  do
    *v8++ = -4096;
  while (v8 != v9);
LABEL_9:
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v10 = 0;
      uint64_t result = sub_1CBB07564((uint64_t)v5, a2, &v10);
      *uint64_t v10 = *a2;
      *v5 += 2;
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CBF60154()
{
  int v1 = 2;
  sub_1CD458B68(&v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCC3048, &dword_1CB82C000);
  int v1 = 2;
  sub_1CD458C60((llvm::cl::Option *)&unk_1EBCC3108, "print-no-aliases", &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC3108, &dword_1CB82C000);
  int v1 = 2;
  sub_1CD458D5C(&v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCC31C8, &dword_1CB82C000);
  int v1 = 2;
  sub_1CD458E54(&v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCC3288, &dword_1CB82C000);
  int v1 = 2;
  sub_1CD458F4C(&v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCC3348, &dword_1CB82C000);
  int v1 = 2;
  sub_1CD459044(&v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCC3408, &dword_1CB82C000);
  int v1 = 2;
  sub_1CD458C60((llvm::cl::Option *)&unk_1EBCC34C8, "print-ref", &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC34C8, &dword_1CB82C000);
  int v1 = 2;
  sub_1CD458C60((llvm::cl::Option *)&unk_1EBCC3588, "print-mod", &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC3588, &dword_1CB82C000);
  int v1 = 2;
  sub_1CD45913C(&v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCC3648, &dword_1CB82C000);
  int v1 = 2;
  sub_1CD459234(&v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCC3708, &dword_1CB82C000);
  int v1 = 2;
  sub_1CD458C60((llvm::cl::Option *)&unk_1EBCC37C8, "print-mustref", &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC37C8, &dword_1CB82C000);
  int v1 = 2;
  sub_1CD458C60((llvm::cl::Option *)&unk_1EBCC3888, "print-mustmod", &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC3888, &dword_1CB82C000);
  int v1 = 2;
  sub_1CD458C60((llvm::cl::Option *)&unk_1EBCC3948, "print-mustmodref", &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC3948, &dword_1CB82C000);
  int v1 = 2;
  sub_1CD45932C(&v1);

  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCC3A08, &dword_1CB82C000);
}

uint64_t llvm::cflaa::getAttrNone(llvm::cflaa *this)
{
  return 0;
}

uint64_t llvm::cflaa::hasUnknownAttr(unint64_t a1)
{
  return (a1 >> 1) & 1;
}

uint64_t llvm::cflaa::hasCallerAttr(unint64_t a1)
{
  return (a1 >> 8) & 1;
}

uint64_t llvm::cflaa::hasEscapedAttr(char a1)
{
  return a1 & 1;
}

uint64_t llvm::cflaa::instantiateInterfaceValue@<X0>(uint64_t result@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X8>)
{
  if (result) {
    a2 = *(_DWORD **)&a2[8 * (result - 1) + -8 * (a2[5] & 0x7FFFFFF)];
  }
  if (*(unsigned char *)(*(void *)a2 + 8) == 15)
  {
    *(void *)a3 = a2;
    *(_DWORD *)(a3 + 8) = HIDWORD(result);
    char v3 = 1;
  }
  else
  {
    char v3 = 0;
    *(unsigned char *)a3 = 0;
  }
  *(unsigned char *)(a3 + 16) = v3;
  return result;
}

void *llvm::AliasSet::mergeSetIn(llvm::AliasSet *this, llvm::AliasSet *a2, llvm::AliasSetTracker *a3)
{
  int v6 = *((_DWORD *)this + 16);
  int v7 = *((_DWORD *)a2 + 16) & 0x30000000 | v6;
  *((_DWORD *)this + 16) = v7;
  unsigned int v8 = *((_DWORD *)a2 + 16) | v6;
  unsigned int v9 = v7 & 0xBFFFFFFF | (((v8 >> 30) & 1) << 30);
  *((_DWORD *)this + 16) = v9;
  if ((v8 & 0x40000000) == 0)
  {
    uint64_t v10 = *(void *)a3;
    uint64_t v11 = (uint64_t *)*((void *)this + 2);
    uint64_t v12 = (uint64_t *)*((void *)a2 + 2);
    uint64_t v13 = *v11;
    uint64_t v14 = v11[4];
    sub_1CBF6066C(v37, (uint64_t)v11);
    v38[0] = v13;
    v38[1] = v14;
    long long v39 = v37[0];
    long long v40 = v37[1];
    uint64_t v15 = *v12;
    uint64_t v16 = v12[4];
    sub_1CBF6066C(v33, (uint64_t)v12);
    v34[0] = v15;
    v34[1] = v16;
    long long v35 = v33[0];
    long long v36 = v33[1];
    char v17 = llvm::AAResults::alias(v10, (uint64_t)v38, (uint64_t)v34);
    unsigned int v9 = *((_DWORD *)this + 16);
    if (v17 != 3)
    {
      v9 |= 0x40000000u;
      *((_DWORD *)this + 16) = v9;
    }
  }
  if ((v9 & 0x40000000) != 0)
  {
    if ((v6 & 0x40000000) == 0) {
      *((_DWORD *)a3 + 12) += *((_DWORD *)this + 17);
    }
    if ((*((unsigned char *)a2 + 67) & 0x40) == 0) {
      *((_DWORD *)a3 + 12) += *((_DWORD *)a2 + 17);
    }
  }
  unsigned __int8 v18 = (uint64_t *)*((void *)a2 + 5);
  unsigned int v19 = (uint64_t *)*((void *)a2 + 6);
  uint64_t v22 = *((void *)this + 5);
  uint64_t v21 = *((void *)this + 6);
  uint64_t result = (void *)((char *)this + 40);
  if (v22 == v21)
  {
    if (v18 != v19)
    {
      *((void *)this + 5) = v18;
      *((void *)a2 + 5) = v22;
      uint64_t v30 = *((void *)this + 6);
      *((void *)this + 6) = *((void *)a2 + 6);
      *((void *)a2 + 6) = v30;
      uint64_t v31 = *((void *)this + 7);
      *((void *)this + 7) = *((void *)a2 + 7);
      *((void *)a2 + 7) = v31;
      *((_DWORD *)this + 16) = *((_DWORD *)this + 16) & 0xF8000000 | (*((_DWORD *)this + 16) + 1) & 0x7FFFFFF;
    }
  }
  else if (v18 != v19)
  {
    BOOL v24 = (uint64_t *)*((void *)a2 + 5);
    uint64_t v25 = (uint64_t *)*((void *)a2 + 6);
    uint64_t result = sub_1CBF634D4(result, v21, v18, v19, 0xAAAAAAAAAAAAAAABLL * (v19 - v18));
    int v27 = (void *)*((void *)a2 + 5);
    uint64_t v26 = (void *)*((void *)a2 + 6);
    while (v26 != v27)
    {
      uint64_t v28 = *(v26 - 1);
      v26 -= 3;
      if (v28 != -8192 && v28 != -4096 && v28 != 0) {
        uint64_t result = llvm::ValueHandleBase::RemoveFromUseList(v26);
      }
    }
    *((void *)a2 + 6) = v27;
    unsigned __int8 v18 = v24;
    unsigned int v19 = v25;
  }
  *((void *)a2 + 4) = this;
  *((_DWORD *)this + 16) = *((_DWORD *)this + 16) & 0xF8000000 | (*((_DWORD *)this + 16) + 1) & 0x7FFFFFF;
  uint64_t v23 = *((void *)a2 + 2);
  if (v23)
  {
    *((_DWORD *)this + 17) += *((_DWORD *)a2 + 17);
    *((_DWORD *)a2 + 17) = 0;
    **((void **)this + 3) = v23;
    *(void *)(*((void *)a2 + 2) + 8) = *((void *)this + 3);
    *((void *)this + 3) = *((void *)a2 + 3);
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = (char *)a2 + 16;
  }
  if (v18 != v19)
  {
    int v32 = *((_DWORD *)a2 + 16);
    *((_DWORD *)a2 + 16) = v32 & 0xF8000000 | (v32 - 1) & 0x7FFFFFF;
    if (((v32 - 1) & 0x7FFFFFF) == 0) {
      return (void *)llvm::AliasSetTracker::removeAliasSet(a3, a2);
    }
  }
  return result;
}

double sub_1CBF6066C(long long *a1, uint64_t a2)
{
  uint64_t v2 = (long long *)(a2 + 40);
  uint64_t v3 = *(void *)(a2 + 40);
  if (v3 != -8192 && v3 != -4096 || *(void *)(a2 + 48) || *(void *)(a2 + 56) || *(void *)(a2 + 64))
  {
    long long v4 = *v2;
    long long v5 = *(_OWORD *)(a2 + 56);
    *a1 = *v2;
    a1[1] = v5;
  }
  else
  {
    *(void *)&long long v4 = 0;
    *a1 = 0u;
    a1[1] = 0u;
  }
  return *(double *)&v4;
}

uint64_t llvm::AliasSet::removeFromTracker(llvm::AliasSet *this, llvm::AliasSetTracker *a2)
{
  return llvm::AliasSetTracker::removeAliasSet(a2, this);
}

uint64_t llvm::AliasSet::addPointer(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, long long *a5, char a6, char a7)
{
  if ((*(unsigned char *)(a1 + 67) & 0x40) == 0)
  {
    uint64_t v12 = *(uint64_t **)(a1 + 16);
    if (v12)
    {
      if (a6)
      {
        if ((a7 & 1) == 0) {
          sub_1CBF60808(*(void **)(a1 + 16), a4, (uint64_t)a5);
        }
      }
      else
      {
        uint64_t v15 = *(void *)a2;
        uint64_t v16 = *v12;
        uint64_t v17 = v12[4];
        sub_1CBF6066C(v23, (uint64_t)v12);
        v24[0] = v16;
        v24[1] = v17;
        long long v25 = v23[0];
        long long v26 = v23[1];
        v20[0] = *a3;
        v20[1] = a4;
        long long v18 = a5[1];
        long long v21 = *a5;
        long long v22 = v18;
        if (llvm::AAResults::alias(v15, (uint64_t)v24, (uint64_t)v20) != 3)
        {
          int v19 = *(_DWORD *)(a1 + 68);
          *(_DWORD *)(a1 + 64) |= 0x40000000u;
          *(_DWORD *)(a2 + 48) += v19;
        }
      }
    }
  }
  a3[3] = a1;
  uint64_t result = sub_1CBF60808(a3, a4, (uint64_t)a5);
  ++*(_DWORD *)(a1 + 68);
  **(void **)(a1 + 24) = a3;
  a3[1] = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = a3 + 2;
  int v14 = *(_DWORD *)(a1 + 64);
  *(_DWORD *)(a1 + 64) = v14 & 0xF8000000 | (v14 + 1) & 0x7FFFFFF;
  if ((v14 & 0x40000000) != 0) {
    ++*(_DWORD *)(a2 + 48);
  }
  return result;
}

uint64_t sub_1CBF60808(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1[4];
  if (v3 == a2)
  {
    uint64_t v4 = 0;
  }
  else
  {
    if (v3 == -3)
    {
      uint64_t v5 = a2;
    }
    else
    {
      uint64_t v5 = -1;
      if (a2 != -1 && v3 != -1)
      {
        uint64_t v5 = -2;
        unint64_t v6 = v3 & 0x7FFFFFFFFFFFFFFFLL;
        if ((v3 & 0x7FFFFFFFFFFFFFFFuLL) <= (a2 & 0x7FFFFFFFFFFFFFFFuLL)) {
          unint64_t v6 = a2 & 0x7FFFFFFFFFFFFFFFLL;
        }
        unint64_t v7 = v6 | 0x8000000000000000;
        if (v6 > 0x7FFFFFFFFFFFFFFBLL) {
          unint64_t v7 = -2;
        }
        if (v6) {
          uint64_t v8 = v7;
        }
        else {
          uint64_t v8 = 0;
        }
        if (v3 == -2) {
          uint64_t v8 = -2;
        }
        if (a2 != -2) {
          uint64_t v5 = v8;
        }
      }
    }
    a1[4] = v5;
    uint64_t v4 = v3 != v5;
  }
  uint64_t v9 = a1[5];
  uint64_t v10 = a1[6];
  uint64_t v11 = a1[7];
  if (v9 == -4096 && v10 == 0)
  {
    if (!v11)
    {
      if (!a1[8])
      {
        long long v22 = *(_OWORD *)(a3 + 16);
        *(_OWORD *)(a1 + 5) = *(_OWORD *)a3;
        *(_OWORD *)(a1 + 7) = v22;
        return v4;
      }
      uint64_t v11 = 0;
    }
    uint64_t v10 = 0;
  }
  if (*(void *)a3 == v9) {
    uint64_t v13 = a1[5];
  }
  else {
    uint64_t v13 = 0;
  }
  if (*(void *)(a3 + 8) == v10) {
    uint64_t v14 = v10;
  }
  else {
    uint64_t v14 = 0;
  }
  if (*(void *)(a3 + 16) == v11) {
    uint64_t v15 = v11;
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t v16 = a1[8];
  if (*(void *)(a3 + 24) == v16) {
    uint64_t v17 = a1[8];
  }
  else {
    uint64_t v17 = 0;
  }
  if (v13 == v9 && v14 == v10 && v15 == v11 && v17 == v16) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = 1;
  }
  a1[5] = v13;
  a1[6] = v14;
  a1[7] = v15;
  a1[8] = v17;
  return v4;
}

uint64_t llvm::AliasSet::aliasesPointer(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5)
{
  int v5 = *(_DWORD *)(a1 + 64);
  if ((v5 & 0x8000000) != 0) {
    return 1;
  }
  uint64_t v11 = *(uint64_t **)(a1 + 16);
  if ((v5 & 0x40000000) == 0)
  {
    uint64_t v12 = *v11;
    uint64_t v13 = v11[4];
    sub_1CBF6066C(&v34, (uint64_t)v11);
    *(void *)&long long v26 = v12;
    *((void *)&v26 + 1) = v13;
    long long v27 = v34;
    long long v28 = v35;
    uint64_t v30 = a2;
    uint64_t v31 = a3;
    long long v14 = a4[1];
    long long v32 = *a4;
    long long v33 = v14;
    return llvm::AAResults::alias(a5, (uint64_t)&v26, (uint64_t)&v30);
  }
  if (!v11)
  {
LABEL_8:
    uint64_t v19 = *(void *)(a1 + 40);
    uint64_t v20 = *(void *)(a1 + 48);
    if (v19 == v20) {
      return 0;
    }
    uint64_t v21 = -1431655765 * ((unint64_t)(v20 - v19) >> 3);
    if (!v21) {
      return 0;
    }
    uint64_t v22 = 0;
    uint64_t v23 = 24 * v21;
    while (1)
    {
      BOOL v24 = *(llvm::Instruction **)(*(void *)(a1 + 40) + v22 + 16);
      if (v24)
      {
        long long v25 = a4[1];
        long long v27 = *a4;
        long long v28 = v25;
        *(void *)&long long v26 = a2;
        *((void *)&v26 + 1) = a3;
        char v29 = 1;
        if ((sub_1CBF5A248(a5, v24, &v26) & 3) != 0) {
          break;
        }
      }
      uint64_t result = 0;
      v22 += 24;
      if (v23 == v22) {
        return result;
      }
    }
    return 1;
  }
  while (1)
  {
    *(void *)&long long v26 = a2;
    *((void *)&v26 + 1) = a3;
    long long v16 = a4[1];
    long long v27 = *a4;
    long long v28 = v16;
    uint64_t v17 = *v11;
    uint64_t v18 = v11[4];
    sub_1CBF6066C(&v34, (uint64_t)v11);
    uint64_t v30 = v17;
    uint64_t v31 = v18;
    long long v32 = v34;
    long long v33 = v35;
    uint64_t result = llvm::AAResults::alias(a5, (uint64_t)&v26, (uint64_t)&v30);
    if ((_BYTE)result) {
      return result;
    }
    uint64_t v11 = (uint64_t *)v11[2];
    if (!v11) {
      goto LABEL_8;
    }
  }
}

BOOL llvm::AliasSet::aliasesUnknownInst(llvm::AliasSet *this, const llvm::Instruction *a2, llvm::AAResults *a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)this + 67) & 8) != 0) {
    return 1;
  }
  uint64_t v6 = -1431655765 * ((*((void *)this + 6) - *((void *)this + 5)) >> 3);
  if (v6)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 24 * v6;
    do
    {
      uint64_t v9 = *(unsigned __int8 **)(*((void *)this + 5) + v7 + 16);
      if (v9)
      {
        unsigned int v10 = v9[16] - 33;
        BOOL v11 = v10 > 0x33;
        uint64_t v12 = (1 << v10) & 0x8000000000041;
        if (v11 || v12 == 0) {
          uint64_t v9 = 0;
        }
        BOOL result = 1;
        unsigned int v15 = *((unsigned __int8 *)a2 + 16) - 33;
        if (v15 > 0x33 || ((1 << v15) & 0x8000000000041) == 0 || !v9) {
          return result;
        }
        if ((llvm::AAResults::getModRefInfo(a3, (const llvm::CallBase *)v9, a2) & 3) != 0
          || (llvm::AAResults::getModRefInfo(a3, a2, (const llvm::CallBase *)v9) & 3) != 0)
        {
          return 1;
        }
      }
      v7 += 24;
    }
    while (v8 != v7);
  }
  long long v16 = (uint64_t *)*((void *)this + 2);
  if (!v16) {
    return 0;
  }
  do
  {
    uint64_t v17 = *v16;
    uint64_t v18 = v16[4];
    sub_1CBF6066C(&v24, (uint64_t)v16);
    *(void *)&long long v23 = v17;
    *((void *)&v23 + 1) = v18;
    char v25 = 1;
    uint64_t v19 = 1;
    v26[0] = 1;
    do
    {
      uint64_t v20 = &v26[v19];
      *(_OWORD *)uint64_t v20 = xmmword_1CFAC3060;
      *((_OWORD *)v20 + 1) = xmmword_1CFAC3060;
      v19 += 5;
    }
    while (v20 + 5 != v27);
    v27[0] = &v31;
    v27[1] = 0;
    long long v28 = v30;
    uint64_t v29 = 0x400000000;
    uint64_t v31 = &unk_1F2600DB8;
    uint64_t v21 = 63;
    uint64_t v32 = 1;
    do
    {
      v26[v21] = -4096;
      v21 += 2;
    }
    while (v21 != 79);
    char ModRefInfo = llvm::AAResults::getModRefInfo((uint64_t)a3, a2, &v23, (uint64_t)v26);
    if ((v32 & 1) == 0) {
      MEMORY[0x1D25D9CD0](v33, 8);
    }
    if (v28 != v30) {
      free(v28);
    }
    if ((v26[0] & 1) == 0) {
      MEMORY[0x1D25D9CD0](v26[1], 8);
    }
    BOOL result = (ModRefInfo & 3) != 0;
    if ((ModRefInfo & 3) != 0) {
      break;
    }
    long long v16 = (uint64_t *)v16[2];
  }
  while (v16);
  return result;
}

uint64_t llvm::AliasSet::getUniqueInstruction(llvm::AliasSet *this)
{
  if ((*((unsigned char *)this + 67) & 8) == 0)
  {
    int v1 = (void *)*((void *)this + 2);
    if (v1)
    {
      if (*((void *)this + 5) == *((void *)this + 6) && !v1[2])
      {
        uint64_t v2 = *(void *)(*v1 + 8);
        if (!*(void *)(v2 + 8))
        {
          uint64_t v3 = v2 + 24;
          return *(void *)v3;
        }
      }
    }
    else
    {
      uint64_t v4 = *((void *)this + 5);
      if (*((void *)this + 6) - v4 == 24)
      {
        uint64_t v3 = v4 + 16;
        return *(void *)v3;
      }
    }
  }
  return 0;
}

void *llvm::AliasSetTracker::clear(llvm::AliasSetTracker *this)
{
  if (*((_DWORD *)this + 8))
  {
    uint64_t v2 = *((unsigned int *)this + 10);
    if (v2)
    {
      uint64_t v3 = 48 * v2;
      uint64_t v4 = *((void *)this + 3);
      while ((*(void *)(v4 + 24) | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v4 += 48;
        v3 -= 48;
        if (!v3) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v4 = *((void *)this + 3);
    }
    if (v4 != *((void *)this + 3) + 48 * v2) {
      sub_1CBF60E74(*(void **)(v4 + 40));
    }
  }
LABEL_6:
  sub_1CBF60EC0((void **)this + 3);
  int v5 = (void *)*((void *)this + 2);

  return sub_1CBF63AA4((uint64_t)this + 8, v5, (void *)this + 1);
}

void sub_1CBF60E74(void *a1)
{
  uint64_t v1 = a1[2];
  if (v1) {
    *(void *)(v1 + 8) = a1[1];
  }
  *(void *)a1[1] = v1;
  uint64_t v2 = a1[3];
  if (*(void **)(v2 + 24) == a1 + 2) {
    *(void *)(v2 + 24) = a1[1];
  }
  JUMPOUT(0x1D25D9CE0);
}

void **sub_1CBF60EC0(void **result)
{
  int v1 = *((_DWORD *)result + 2);
  if (v1 || *((_DWORD *)result + 3))
  {
    unsigned int v2 = *((_DWORD *)result + 4);
    if (v2 > 4 * v1 && v2 >= 0x41)
    {
      return sub_1CD45ADBC(result);
    }
    else
    {
      v30[0] = 2;
      v30[1] = 0;
      uint64_t v31 = -4096;
      uint64_t v32 = 0;
      uint64_t v28 = 0;
      uint64_t v29 = off_1F2600B28;
      v26[0] = 2;
      v26[1] = 0;
      uint64_t v27 = -8192;
      if (v2)
      {
        uint64_t v3 = *result;
        uint64_t v4 = (uint64_t)*result + 48 * v2;
        do
        {
          uint64_t v5 = v3[3];
          uint64_t v6 = v31;
          if (v5 != v31)
          {
            BOOL v7 = v5 == -4096 || v5 == 0;
            if (!v7 && v5 != -8192)
            {
              unint64_t v12 = v3[1] & 0xFFFFFFFFFFFFFFF8;
              *(void *)unint64_t v12 = v3[2];
              uint64_t v13 = (unint64_t *)v3[2];
              if (v13)
              {
                *uint64_t v13 = *v13 & 7 | v12;
              }
              else
              {
                uint64_t v14 = v3[3];
                unsigned int v15 = ***(int32x2_t ****)v14;
                unint64_t v16 = (unint64_t)v15[303];
                if (v16 <= v12)
                {
                  uint64_t v17 = v15[305].u32[0];
                  if (v16 + 16 * v17 > v12)
                  {
                    unsigned int v18 = v17 - 1;
                    LODWORD(v19) = v18 & ((v14 >> 4) ^ (v14 >> 9));
                    uint64_t v20 = (uint64_t *)(v16 + 16 * v19);
                    uint64_t v21 = *v20;
                    if (v14 == *v20)
                    {
LABEL_30:
                      *uint64_t v20 = -8192;
                      v15[304] = vadd_s32(v15[304], (int32x2_t)0x1FFFFFFFFLL);
                      uint64_t v14 = v3[3];
                    }
                    else
                    {
                      int v22 = 1;
                      while (v21 != -4096)
                      {
                        int v23 = v19 + v22++;
                        uint64_t v19 = v23 & v18;
                        uint64_t v21 = *(void *)(v16 + 16 * v19);
                        if (v14 == v21)
                        {
                          uint64_t v20 = (uint64_t *)(v16 + 16 * v19);
                          goto LABEL_30;
                        }
                      }
                    }
                    *(unsigned char *)(v14 + 17) &= ~1u;
                  }
                }
              }
              uint64_t v6 = v31;
            }
            v3[3] = v6;
            if (v6 != -4096 && v6 != -8192 && v6 != 0)
            {
              uint64_t v9 = v30[0];
              unsigned int v10 = (void *)(v30[0] & 0xFFFFFFFFFFFFFFF8);
              void v3[2] = *(void *)(v30[0] & 0xFFFFFFFFFFFFFFF8);
              *unsigned int v10 = v3 + 1;
              v3[1] = v9 & 0xFFFFFFFFFFFFFFF8 | v3[1] & 7;
              BOOL v11 = (unint64_t *)v3[2];
              if (v11) {
                *BOOL v11 = *v11 & 7 | (unint64_t)(v3 + 2);
              }
            }
          }
          v3[4] = v32;
          v3 += 6;
        }
        while (v3 != (void *)v4);
        uint64_t v24 = v27;
        result[1] = 0;
        if (v24 != -8192 && v24 != -4096 && v24 != 0) {
          BOOL result = (void **)llvm::ValueHandleBase::RemoveFromUseList(v26);
        }
      }
      else
      {
        result[1] = 0;
      }
      if (v31 != -4096 && v31 != -8192)
      {
        if (v31) {
          return (void **)llvm::ValueHandleBase::RemoveFromUseList(v30);
        }
      }
    }
  }
  return result;
}

llvm::AliasSet *llvm::AliasSetTracker::mergeAliasSetsForPointer(uint64_t *a1, uint64_t a2, uint64_t a3, long long *a4, unsigned char *a5)
{
  *a5 = 1;
  uint64_t v5 = a1 + 1;
  uint64_t v6 = (llvm::AliasSet *)a1[2];
  if (v6 == (llvm::AliasSet *)(a1 + 1)) {
    return 0;
  }
  unint64_t v12 = 0;
  do
  {
    uint64_t v13 = (uint64_t *)*((void *)v6 + 1);
    if (!*((void *)v6 + 4))
    {
      int v14 = llvm::AliasSet::aliasesPointer((uint64_t)v6, a2, a3, a4, *a1);
      if (v14)
      {
        if (v14 != 3) {
          *a5 = 0;
        }
        if (v12) {
          llvm::AliasSet::mergeSetIn(v12, v6, (llvm::AliasSetTracker *)a1);
        }
        else {
          unint64_t v12 = v6;
        }
      }
    }
    uint64_t v6 = (llvm::AliasSet *)v13;
  }
  while (v13 != v5);
  return v12;
}

llvm::AliasSet *llvm::AliasSetTracker::getAliasSetFor(llvm::AliasSetTracker *this, const llvm::MemoryLocation *a2)
{
  uint64_t v4 = *(void *)a2;
  uint64_t v3 = *((void *)a2 + 1);
  uint64_t v5 = (long long *)((char *)a2 + 16);
  uint64_t v6 = (void *)sub_1CBF613C4((uint64_t)this, *(void ****)a2);
  uint64_t v7 = *((void *)this + 7);
  if (v7)
  {
    if (v6[3]) {
      sub_1CBF60808(v6, v3, (uint64_t)v5);
    }
    else {
      llvm::AliasSet::addPointer(v7, (uint64_t)this, v6, v3, v5, 0, 0);
    }
    return (llvm::AliasSet *)*((void *)this + 7);
  }
  else
  {
    char v12 = 0;
    if (v6[3])
    {
      if (sub_1CBF60808(v6, v3, (uint64_t)v5)) {
        llvm::AliasSetTracker::mergeAliasSetsForPointer((uint64_t *)this, v4, v3, v5, &v12);
      }
      uint64_t v9 = sub_1CBF6176C((uint64_t)v6, this);
      return (llvm::AliasSet *)sub_1CBF617EC(v9, this);
    }
    else
    {
      uint64_t v8 = llvm::AliasSetTracker::mergeAliasSetsForPointer((uint64_t *)this, v4, v3, v5, &v12);
      if (!v8) {
        operator new();
      }
      unsigned int v10 = v8;
      llvm::AliasSet::addPointer((uint64_t)v8, (uint64_t)this, v6, v3, v5, v12, 0);
    }
  }
  return v10;
}

uint64_t sub_1CBF613C4(uint64_t a1, void ***a2)
{
  uint64_t v38 = 2;
  long long v39 = 0;
  long long v40 = a2;
  uint64_t v3 = a2;
  if (a2 != (void ***)-8192)
  {
    uint64_t v3 = a2;
    if (a2 != (void ***)-4096)
    {
      uint64_t v3 = a2;
      if (a2)
      {
        llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v38);
        uint64_t v3 = v40;
      }
    }
  }
  uint64_t v41 = a1;
  int v42 = 0;
  char v4 = sub_1CBF62778(*(void *)(a1 + 24), *(_DWORD *)(a1 + 40), (uint64_t)v3, &v42);
  uint64_t v5 = v42;
  if (v4) {
    goto LABEL_20;
  }
  int v6 = *(_DWORD *)(a1 + 32);
  unsigned int v7 = *(_DWORD *)(a1 + 40);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_50;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 36) <= v7 >> 3)
  {
LABEL_50:
    sub_1CBF62810(a1 + 24, v7);
    int v42 = 0;
    sub_1CBF62778(*(void *)(a1 + 24), *(_DWORD *)(a1 + 40), (uint64_t)v40, &v42);
    uint64_t v5 = v42;
  }
  ++*(_DWORD *)(a1 + 32);
  uint64_t v8 = (void ***)v5[3];
  if (v8 != (void ***)-4096) {
    --*(_DWORD *)(a1 + 36);
  }
  uint64_t v9 = v40;
  if (v8 != v40)
  {
    if (v8 != (void ***)-4096 && v8 && v8 != (void ***)-8192)
    {
      unint64_t v26 = v5[1] & 0xFFFFFFFFFFFFFFF8;
      *(void *)unint64_t v26 = v5[2];
      uint64_t v27 = (unint64_t *)v5[2];
      if (v27)
      {
        *uint64_t v27 = *v27 & 7 | v26;
      }
      else
      {
        uint64_t v28 = v5[3];
        uint64_t v29 = ***(int32x2_t ****)v28;
        unint64_t v30 = (unint64_t)v29[303];
        if (v30 <= v26)
        {
          uint64_t v31 = v29[305].u32[0];
          if (v30 + 16 * v31 > v26)
          {
            unsigned int v32 = v31 - 1;
            LODWORD(v33) = v32 & ((v28 >> 4) ^ (v28 >> 9));
            uint64_t v34 = (uint64_t *)(v30 + 16 * v33);
            uint64_t v35 = *v34;
            if (v28 == *v34)
            {
LABEL_47:
              *uint64_t v34 = -8192;
              v29[304] = vadd_s32(v29[304], (int32x2_t)0x1FFFFFFFFLL);
              uint64_t v28 = v5[3];
            }
            else
            {
              int v36 = 1;
              while (v35 != -4096)
              {
                int v37 = v33 + v36++;
                uint64_t v33 = v37 & v32;
                uint64_t v35 = *(void *)(v30 + 16 * v33);
                if (v28 == v35)
                {
                  uint64_t v34 = (uint64_t *)(v30 + 16 * v33);
                  goto LABEL_47;
                }
              }
            }
            *(unsigned char *)(v28 + 17) &= ~1u;
          }
        }
      }
      uint64_t v9 = v40;
    }
    v5[3] = v9;
    if (v9 != (void ***)-4096 && v9 != (void ***)-8192 && v9 != 0)
    {
      uint64_t v11 = v38;
      char v12 = (void *)(v38 & 0xFFFFFFFFFFFFFFF8);
      void v5[2] = *(void *)(v38 & 0xFFFFFFFFFFFFFFF8);
      *char v12 = v5 + 1;
      v5[1] = v11 & 0xFFFFFFFFFFFFFFF8 | v5[1] & 7;
      uint64_t v13 = (unint64_t *)v5[2];
      if (v13) {
        *uint64_t v13 = *v13 & 7 | (unint64_t)(v5 + 2);
      }
    }
  }
  v5[4] = v41;
  v5[5] = 0;
LABEL_20:
  if (v40 != (void ***)-8192 && v40 != (void ***)-4096 && v40)
  {
    unint64_t v14 = v38 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v38 & 0xFFFFFFFFFFFFFFF8) = v39;
    if (v39)
    {
      *long long v39 = *v39 & 7 | v14;
    }
    else
    {
      unsigned int v15 = v40;
      unint64_t v16 = (int32x2_t *)***v40;
      unint64_t v17 = (unint64_t)v16[303];
      if (v17 <= v14)
      {
        uint64_t v18 = v16[305].u32[0];
        if (v17 + 16 * v18 > v14)
        {
          unsigned int v19 = v18 - 1;
          LODWORD(v20) = v19 & ((v40 >> 4) ^ (v40 >> 9));
          uint64_t v21 = (void *)(v17 + 16 * v20);
          int v22 = (void ***)*v21;
          if (v40 == (void ***)*v21)
          {
LABEL_31:
            *uint64_t v21 = -8192;
            v16[304] = vadd_s32(v16[304], (int32x2_t)0x1FFFFFFFFLL);
            unsigned int v15 = v40;
          }
          else
          {
            int v23 = 1;
            while (v22 != (void ***)-4096)
            {
              int v24 = v20 + v23++;
              uint64_t v20 = v24 & v19;
              int v22 = *(void ****)(v17 + 16 * v20);
              if (v40 == v22)
              {
                uint64_t v21 = (void *)(v17 + 16 * v20);
                goto LABEL_31;
              }
            }
          }
          *((unsigned char *)v15 + 17) &= ~1u;
        }
      }
    }
  }
  uint64_t result = v5[5];
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t sub_1CBF6176C(uint64_t a1, llvm::AliasSetTracker *a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  if (*(void *)(v3 + 32))
  {
    uint64_t v6 = sub_1CBF617EC(*(void *)(a1 + 24), a2);
    *(void *)(a1 + 24) = v6;
    *(_DWORD *)(v6 + 64) = *(_DWORD *)(v6 + 64) & 0xF8000000 | (*(_DWORD *)(v6 + 64) + 1) & 0x7FFFFFF;
    int v7 = *(_DWORD *)(v3 + 64);
    *(_DWORD *)(v3 + 64) = v7 & 0xF8000000 | (v7 - 1) & 0x7FFFFFF;
    if (((v7 - 1) & 0x7FFFFFF) == 0) {
      llvm::AliasSetTracker::removeAliasSet(a2, (llvm::AliasSet *)v3);
    }
  }
  return *(void *)(a1 + 24);
}

uint64_t sub_1CBF617EC(uint64_t result, llvm::AliasSetTracker *a2)
{
  uint64_t v2 = result;
  if (*(void *)(result + 32))
  {
    uint64_t result = sub_1CBF617EC();
    if (result != *(void *)(v2 + 32))
    {
      uint64_t v6 = result;
      *(_DWORD *)(result + 64) = *(_DWORD *)(result + 64) & 0xF8000000 | (*(_DWORD *)(result + 64) + 1) & 0x7FFFFFF;
      char v4 = *(llvm::AliasSet **)(v2 + 32);
      int v5 = *((_DWORD *)v4 + 16);
      *((_DWORD *)v4 + 16) = v5 & 0xF8000000 | (v5 - 1) & 0x7FFFFFF;
      if (((v5 - 1) & 0x7FFFFFF) == 0) {
        llvm::AliasSetTracker::removeAliasSet(a2, v4);
      }
      uint64_t result = v6;
      *(void *)(v2 + 32) = v6;
    }
  }
  return result;
}

llvm::AliasSet *llvm::AliasSetTracker::add(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  v6[0] = a2;
  v6[1] = a3;
  long long v4 = a4[1];
  long long v7 = *a4;
  long long v8 = v4;
  return llvm::AliasSetTracker::addPointer(a1, (const llvm::MemoryLocation *)v6, 0);
}

llvm::AliasSet *llvm::AliasSetTracker::addPointer(uint64_t a1, const llvm::MemoryLocation *a2, char a3)
{
  uint64_t result = llvm::AliasSetTracker::getAliasSetFor((llvm::AliasSetTracker *)a1, a2);
  *((_DWORD *)result + 16) |= (a3 & 3) << 28;
  if (!*(void *)(a1 + 56) && *(_DWORD *)(a1 + 48) > dword_1EBD027B0)
  {
    llvm::AliasSetTracker::mergeAllAliasSets((llvm::AliasSetTracker *)a1);
  }
  return result;
}

llvm::AliasSet *llvm::AliasSetTracker::add(llvm::AliasSetTracker *this, llvm::LoadInst *a2)
{
  if ((((unint64_t)*((unsigned __int16 *)a2 + 9) >> 7) & 7) - 3 <= 4)
  {
    return (llvm::AliasSet *)llvm::AliasSetTracker::addUnknown(this, a2);
  }
  else
  {
    uint64_t v4 = *((void *)a2 - 4);
    uint64_t v5 = sub_1CB83544C(*(void *)(*(void *)(*((void *)a2 + 5) + 56) + 40) + 272, *(void *)a2);
    if (v6 == 1) {
      unint64_t v7 = -2;
    }
    else {
      unint64_t v7 = (unint64_t)(v5 + 7) >> 3;
    }
    llvm::Instruction::getAAMetadata((uint64_t ***)a2, v10);
    v9[0] = v4;
    v9[1] = v7;
    return llvm::AliasSetTracker::addPointer((uint64_t)this, (const llvm::MemoryLocation *)v9, 1);
  }
}

uint64_t llvm::AliasSetTracker::addUnknown(llvm::AliasSetTracker *this, llvm::Instruction *a2)
{
  uint64_t result = sub_1CBF63B28((uint64_t)a2);
  if (result) {
    return result;
  }
  unsigned int v5 = *((unsigned __int8 *)a2 + 16);
  if (v5 <= 0x3B)
  {
    if (v5 == 37) {
      goto LABEL_17;
    }
    if (v5 == 33 || v5 == 39) {
      goto LABEL_9;
    }
    goto LABEL_27;
  }
  if (v5 - 60 > 0x1C) {
    goto LABEL_27;
  }
  if (v5 == 84)
  {
    uint64_t v6 = *((void *)a2 - 4);
    if (v6 && !*(unsigned char *)(v6 + 16) && *(void *)(v6 + 24) == *((void *)a2 + 9) && (*(unsigned char *)(v6 + 33) & 0x20) != 0)
    {
      int v13 = *(_DWORD *)(v6 + 36);
      if (v13 > 243)
      {
        if (v13 == 244 || v13 == 272) {
          return result;
        }
      }
      else if (v13 == 7 || v13 == 126)
      {
        return result;
      }
    }
LABEL_9:
    uint64_t v7 = *((void *)a2 + 8);
    if (v7 && ((*(unsigned char *)(v7 + 20) & 4) != 0 || (*(unsigned char *)(v7 + 17) & 0x10) != 0)) {
      goto LABEL_15;
    }
    __int32 v22 = 7;
    if (!sub_1CC5CB59C((uint64_t)a2, &v22, 1uLL)
      || (uint64_t v14 = *((void *)a2 - 4)) != 0
      && !*(unsigned char *)(v14 + 16)
      && *(void *)(v14 + 24) == *((void *)a2 + 9)
      && *(_DWORD *)(v14 + 36) == 7)
    {
      uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a2, 66);
      if (result) {
        goto LABEL_15;
      }
      uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a2, 44);
      if (result) {
        goto LABEL_15;
      }
    }
    goto LABEL_17;
  }
  if (((1 << (v5 - 60)) & 0x10100039) != 0) {
    goto LABEL_17;
  }
  if (v5 != 61)
  {
LABEL_27:
    uint64_t v10 = v5 - 33;
    if (v10 > 0x37) {
      return result;
    }
    if (((1 << v10) & 0x8000000000041) != 0)
    {
      uint64_t v11 = *((void *)a2 + 8);
      if (v11 && (*(unsigned char *)(v11 + 17) & 0x30) != 0) {
        return result;
      }
      int v12 = *((_DWORD *)a2 + 5);
      if (v12 < 0
        && (unsigned int v15 = (char *)a2 - 32 * (v12 & 0x7FFFFFF), v18 = *((void *)v15 - 1), v16 = v15 - 8, (v17 = v18) != 0))
      {
        uint64_t v19 = -v17;
        while (1)
        {
          unsigned int v20 = *(_DWORD *)(*(void *)&v16[v19] + 8);
          if (v20 >= 2 && v20 != 7) {
            break;
          }
          v19 += 16;
          if (!v19) {
            goto LABEL_35;
          }
        }
      }
      else
      {
LABEL_35:
        uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a2, 45);
        if (result) {
          return result;
        }
        uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a2, 44);
        if (result) {
          return result;
        }
      }
    }
    else if (v10 == 27)
    {
      if ((*((_WORD *)a2 + 9) & 0x301) == 0) {
        return result;
      }
    }
    else if (((1 << v10) & 0x808001D0000010) == 0)
    {
      return result;
    }
    goto LABEL_17;
  }
  if ((*((_WORD *)a2 + 9) & 0x301) == 0)
  {
LABEL_15:
    unsigned int v5 = *((unsigned __int8 *)a2 + 16);
    goto LABEL_27;
  }
LABEL_17:
  AliasSetForUnknownInst = llvm::AliasSetTracker::findAliasSetForUnknownInst(this, a2);
  if (!AliasSetForUnknownInst) {
    operator new();
  }

  return llvm::AliasSet::addUnknownInst(AliasSetForUnknownInst, a2, v9);
}

llvm::AliasSet *llvm::AliasSetTracker::add(llvm::AliasSetTracker *this, llvm::StoreInst *a2)
{
  if ((((unint64_t)*((unsigned __int16 *)a2 + 9) >> 7) & 7) - 3 <= 4)
  {
    return (llvm::AliasSet *)llvm::AliasSetTracker::addUnknown(this, a2);
  }
  else
  {
    uint64_t v4 = *((void *)a2 - 4);
    uint64_t v5 = sub_1CB83544C(*(void *)(*(void *)(*((void *)a2 + 5) + 56) + 40) + 272, **((void **)a2 - 8));
    if (v6 == 1) {
      unint64_t v7 = -2;
    }
    else {
      unint64_t v7 = (unint64_t)(v5 + 7) >> 3;
    }
    llvm::Instruction::getAAMetadata((uint64_t ***)a2, v10);
    v9[0] = v4;
    v9[1] = v7;
    return llvm::AliasSetTracker::addPointer((uint64_t)this, (const llvm::MemoryLocation *)v9, 2);
  }
}

llvm::AliasSet *llvm::AliasSetTracker::add(llvm::AliasSetTracker *this, llvm::VAArgInst *a2)
{
  uint64_t v3 = *((void *)a2 - 4);
  llvm::Instruction::getAAMetadata((uint64_t ***)a2, v6);
  v5[0] = v3;
  v5[1] = -2;
  return llvm::AliasSetTracker::addPointer((uint64_t)this, (const llvm::MemoryLocation *)v5, 3);
}

llvm::AliasSet *llvm::AliasSetTracker::add(uint64_t a1, uint64_t a2)
{
  llvm::MemoryLocation::getForArgument(a2, 0, 0, (uint64_t)v4);
  return llvm::AliasSetTracker::addPointer(a1, (const llvm::MemoryLocation *)v4, 2);
}

{
  unsigned char v5[48];
  unsigned char v6[48];

  llvm::MemoryLocation::getForArgument(a2, 0, 0, (uint64_t)v6);
  llvm::AliasSetTracker::addPointer(a1, (const llvm::MemoryLocation *)v6, 2);
  llvm::MemoryLocation::getForSource(a2, (uint64_t)v5);
  return llvm::AliasSetTracker::addPointer(a1, (const llvm::MemoryLocation *)v5, 1);
}

uint64_t llvm::AliasSetTracker::add(llvm::AliasSetTracker *this, llvm::Instruction *a2)
{
  int v4 = *((unsigned __int8 *)a2 + 16);
  if (a2 && v4 == 60)
  {
    return (uint64_t)llvm::AliasSetTracker::add(this, a2);
  }
  if (a2 && v4 == 61)
  {
    return (uint64_t)llvm::AliasSetTracker::add(this, a2);
  }
  if (a2 && v4 == 88)
  {
    uint64_t v6 = *((void *)a2 - 4);
    llvm::Instruction::getAAMetadata((uint64_t ***)a2, v28);
    *(void *)&long long v27 = v6;
    *((void *)&v27 + 1) = -2;
    unint64_t v7 = this;
    char v8 = 3;
    return (uint64_t)llvm::AliasSetTracker::addPointer((uint64_t)v7, (const llvm::MemoryLocation *)&v27, v8);
  }
  if (sub_1CBF63B78((uint64_t)a2))
  {
    llvm::MemoryLocation::getForArgument((uint64_t)a2, 0, 0, (uint64_t)&v27);
    unint64_t v7 = this;
    char v8 = 2;
    return (uint64_t)llvm::AliasSetTracker::addPointer((uint64_t)v7, (const llvm::MemoryLocation *)&v27, v8);
  }
  if (sub_1CBF63BC8((uint64_t)a2))
  {
    return (uint64_t)llvm::AliasSetTracker::add((uint64_t)this, (uint64_t)a2);
  }
  else
  {
    unsigned int v9 = *((unsigned __int8 *)a2 + 16) - 33;
    if (v9 <= 0x33
      && ((1 << v9) & 0x8000000000041) != 0
      && ((uint64_t v10 = *((void *)a2 + 8)) != 0 && (*(unsigned char *)(v10 + 12) & 8) != 0
       || ((LODWORD(v27) = 7, !sub_1CC5CB59C((uint64_t)a2, (__int32 *)&v27, 1uLL))
        || (uint64_t v24 = *((void *)a2 - 4)) != 0
        && !*(unsigned char *)(v24 + 16)
        && *(void *)(v24 + 24) == *((void *)a2 + 9)
        && *(_DWORD *)(v24 + 36) == 7)
       && llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a2, 3)))
    {
      uint64_t result = llvm::AAResults::getModRefBehavior(*(void *)this, (uint64_t)a2);
      unsigned __int8 v11 = result & 7;
      int v12 = *((unsigned __int8 *)a2 + 16);
      if (*((void *)a2 + 1) || v12 != 84)
      {
        int v15 = *((_DWORD *)a2 + 5);
        if (v12 == 84)
        {
          uint64_t v14 = 0;
        }
        else if (v12 == 39)
        {
          uint64_t v14 = (*((_DWORD *)a2 + 20) + 1);
        }
        else
        {
          uint64_t v14 = 2;
        }
      }
      else
      {
        uint64_t v13 = *((void *)a2 - 4);
        if (v13
          && !*(unsigned char *)(v13 + 16)
          && *(void *)(v13 + 24) == *((void *)a2 + 9)
          && *(_DWORD *)(v13 + 36) == 164)
        {
          unsigned __int8 v11 = result & 5;
        }
        uint64_t v14 = 0;
        int v15 = *((_DWORD *)a2 + 5);
      }
      uint64_t v16 = v15 & 0x7FFFFFF;
      uint64_t v17 = (llvm::Instruction *)((char *)a2 - 32 * v16);
      if (v15 < 0 && (uint64_t v25 = *((void *)v17 - 1), (v25 & 0xFFFFFFFF0) != 0)) {
        uint64_t v18 = (*((_DWORD *)v17 - 3) - *(_DWORD *)((char *)v17 - v25));
      }
      else {
        uint64_t v18 = 0;
      }
      if (v17 != (llvm::Instruction *)((char *)a2 + -32 * v18 + -32 * v14 - 32))
      {
        uint64_t v19 = 0;
        unint64_t v20 = (32 * v14 + 32 * v18) ^ 0xFFFFFFFFFFFFFFE0;
        uint64_t v21 = -32 * v16;
        do
        {
          if (*(unsigned char *)(**(void **)((char *)a2 + v21) + 8) == 15)
          {
            llvm::MemoryLocation::getForArgument((uint64_t)a2, v19, 0, (uint64_t)&v27);
            uint64_t result = llvm::AAResults::getArgModRefInfo(*(llvm::AAResults **)this, a2, v19);
            if ((result & v11 & 3) != 0)
            {
              v26[0] = v27;
              v26[1] = v28[0];
              void v26[2] = v28[1];
              if ((result & v11 & 2) != 0) {
                char v22 = 2;
              }
              else {
                char v22 = result & v11 & 1;
              }
              if ((result & v11 & 3) == 3) {
                char v23 = 3;
              }
              else {
                char v23 = v22;
              }
              uint64_t result = (uint64_t)llvm::AliasSetTracker::addPointer((uint64_t)this, (const llvm::MemoryLocation *)v26, v23);
            }
          }
          uint64_t v19 = (v19 + 1);
          v21 += 32;
        }
        while (v20 != v21);
      }
    }
    else
    {
      return llvm::AliasSetTracker::addUnknown(this, a2);
    }
  }
  return result;
}

llvm::AliasSet *llvm::AliasSetTracker::add(llvm::AliasSet *this, const llvm::AliasSetTracker *a2)
{
  uint64_t v2 = (char *)a2 + 8;
  uint64_t v3 = *((void *)a2 + 2);
  if ((const llvm::AliasSetTracker *)v3 != (const llvm::AliasSetTracker *)((char *)a2 + 8))
  {
    int v4 = this;
    do
    {
      if (!*(void *)(v3 + 32))
      {
        uint64_t v5 = -1431655765 * ((*(void *)(v3 + 48) - *(void *)(v3 + 40)) >> 3);
        if (v5)
        {
          uint64_t v6 = 0;
          uint64_t v7 = 24 * v5;
          do
          {
            char v8 = *(llvm::Instruction **)(*(void *)(v3 + 40) + v6 + 16);
            if (v8) {
              this = (llvm::AliasSet *)llvm::AliasSetTracker::add(v4, v8);
            }
            v6 += 24;
          }
          while (v7 != v6);
        }
        for (uint64_t i = *(uint64_t **)(v3 + 16); i; uint64_t i = (uint64_t *)i[2])
        {
          uint64_t v10 = *i;
          uint64_t v11 = i[4];
          sub_1CBF6066C(&v13, (uint64_t)i);
          v12[0] = v10;
          v12[1] = v11;
          this = llvm::AliasSetTracker::addPointer((uint64_t)v4, (const llvm::MemoryLocation *)v12, (*(_DWORD *)(v3 + 64) >> 28) & 3);
        }
      }
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while ((char *)v3 != v2);
  }
  return this;
}

llvm::AliasSetTracker::ASTCallbackVH *llvm::AliasSetTracker::ASTCallbackVH::ASTCallbackVH(llvm::AliasSetTracker::ASTCallbackVH *this, llvm::Value *a2, llvm::AliasSetTracker *a3)
{
  *((void *)this + 1) = 2;
  *((void *)this + 2) = 0;
  uint64_t v5 = (llvm::AliasSetTracker::ASTCallbackVH *)((char *)this + 8);
  *((void *)v5 + 2) = a2;
  if (a2 != (llvm::Value *)-8192 && a2 != (llvm::Value *)-4096 && a2) {
    llvm::ValueHandleBase::AddToUseList(v5);
  }
  *(void *)this = off_1F2600B28;
  *((void *)this + 4) = a3;
  return this;
}

void *llvm::AliasSetTracker::ASTCallbackVH::ASTCallbackVH(void *this, llvm::Value *a2, llvm::AliasSetTracker *a3)
{
  this[1] = 2;
  this[2] = 0;
  this[3] = a2;
  if (a2 != (llvm::Value *)-8192 && a2 != (llvm::Value *)-4096 && a2)
  {
    uint64_t v3 = a3;
    int v4 = this;
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)(this + 1));
    a3 = v3;
    this = v4;
  }
  *this = off_1F2600B28;
  this[4] = a3;
  return this;
}

void *llvm::AliasSetTracker::ASTCallbackVH::operator=(void *a1, int32x2_t ****a2)
{
  uint64_t v3 = a1[4];
  uint64_t v35 = 2;
  int v36 = 0;
  int v37 = a2;
  if (a2 != (int32x2_t ****)-8192 && a2 != (int32x2_t ****)-4096 && a2)
  {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v35);
    a2 = v37;
  }
  uint64_t v38 = v3;
  int v4 = (int32x2_t ****)a1[3];
  if (v4 != a2)
  {
    BOOL v5 = v4 == (int32x2_t ****)-4096 || v4 == 0;
    if (!v5 && v4 != (int32x2_t ****)-8192)
    {
      unint64_t v23 = a1[1] & 0xFFFFFFFFFFFFFFF8;
      *(void *)unint64_t v23 = a1[2];
      uint64_t v24 = (unint64_t *)a1[2];
      if (v24)
      {
        *uint64_t v24 = *v24 & 7 | v23;
      }
      else
      {
        uint64_t v25 = a1[3];
        unint64_t v26 = ***(int32x2_t ****)v25;
        unint64_t v27 = (unint64_t)v26[303];
        if (v27 <= v23)
        {
          uint64_t v28 = v26[305].u32[0];
          if (v27 + 16 * v28 > v23)
          {
            unsigned int v29 = v28 - 1;
            LODWORD(v30) = v29 & ((v25 >> 4) ^ (v25 >> 9));
            uint64_t v31 = (uint64_t *)(v27 + 16 * v30);
            uint64_t v32 = *v31;
            if (v25 == *v31)
            {
LABEL_45:
              *uint64_t v31 = -8192;
              v26[304] = vadd_s32(v26[304], (int32x2_t)0x1FFFFFFFFLL);
              uint64_t v25 = a1[3];
            }
            else
            {
              int v33 = 1;
              while (v32 != -4096)
              {
                int v34 = v30 + v33++;
                uint64_t v30 = v34 & v29;
                uint64_t v32 = *(void *)(v27 + 16 * v30);
                if (v25 == v32)
                {
                  uint64_t v31 = (uint64_t *)(v27 + 16 * v30);
                  goto LABEL_45;
                }
              }
            }
            *(unsigned char *)(v25 + 17) &= ~1u;
          }
        }
      }
      a2 = v37;
    }
    a1[3] = a2;
    if (a2 != (int32x2_t ****)-4096 && a2 != (int32x2_t ****)-8192 && a2 != 0)
    {
      uint64_t v7 = v35;
      char v8 = (void *)(v35 & 0xFFFFFFFFFFFFFFF8);
      a1[2] = *(void *)(v35 & 0xFFFFFFFFFFFFFFF8);
      *char v8 = a1 + 1;
      a1[1] = v7 & 0xFFFFFFFFFFFFFFF8 | a1[1] & 7;
      unsigned int v9 = (unint64_t *)a1[2];
      if (v9) {
        *unsigned int v9 = *v9 & 7 | (unint64_t)(a1 + 2);
      }
      a2 = v37;
    }
  }
  a1[4] = v38;
  if (a2 != (int32x2_t ****)-8192 && a2 != (int32x2_t ****)-4096 && a2 != 0)
  {
    unint64_t v12 = v35 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v35 & 0xFFFFFFFFFFFFFFF8) = v36;
    if (v36)
    {
      *int v36 = *v36 & 7 | v12;
    }
    else
    {
      long long v13 = v37;
      uint64_t v14 = ***v37;
      unint64_t v15 = (unint64_t)v14[303];
      if (v15 <= v12)
      {
        uint64_t v16 = v14[305].u32[0];
        if (v15 + 16 * v16 > v12)
        {
          unsigned int v17 = v16 - 1;
          LODWORD(v18) = v17 & ((v37 >> 4) ^ (v37 >> 9));
          uint64_t v19 = (int32x2_t *****)(v15 + 16 * v18);
          unint64_t v20 = *v19;
          if (v37 == *v19)
          {
LABEL_34:
            *uint64_t v19 = (int32x2_t ****)-8192;
            v14[304] = vadd_s32(v14[304], (int32x2_t)0x1FFFFFFFFLL);
            long long v13 = v37;
          }
          else
          {
            int v21 = 1;
            while (v20 != (int32x2_t ****)-4096)
            {
              int v22 = v18 + v21++;
              uint64_t v18 = v22 & v17;
              unint64_t v20 = *(int32x2_t *****)(v15 + 16 * v18);
              if (v37 == v20)
              {
                uint64_t v19 = (int32x2_t *****)(v15 + 16 * v18);
                goto LABEL_34;
              }
            }
          }
          *((unsigned char *)v13 + 17) &= ~1u;
        }
      }
    }
  }
  return a1;
}

void llvm::initializeAliasSetPrinterPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC3AD0, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBF626CC;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC3AD0, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CBF626CC(llvm *a1, llvm::PassRegistry *a2)
{
}

void *llvm::AliasSetsPrinterPass::AliasSetsPrinterPass(void *result, uint64_t a2)
{
  *uint64_t result = a2;
  return result;
}

uint64_t sub_1CBF62778(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    uint64_t v6 = a1 + 48 * v5;
    uint64_t v7 = *(void *)(v6 + 24);
    if (v7 == a3)
    {
      uint64_t v12 = 1;
    }
    else
    {
      uint64_t v8 = 0;
      int v9 = 1;
      while (v7 != -4096)
      {
        if (v8) {
          BOOL v10 = 0;
        }
        else {
          BOOL v10 = v7 == -8192;
        }
        if (v10) {
          uint64_t v8 = v6;
        }
        unsigned int v11 = v5 + v9++;
        unsigned int v5 = v11 & v4;
        uint64_t v6 = a1 + 48 * (v11 & v4);
        uint64_t v7 = *(void *)(v6 + 24);
        uint64_t v12 = 1;
        if (v7 == a3) {
          goto LABEL_14;
        }
      }
      uint64_t v12 = 0;
      if (v8) {
        uint64_t v6 = v8;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v12 = 0;
  }
LABEL_14:
  *a4 = v6;
  return v12;
}

void *sub_1CBF62810(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  int v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  *(void *)a1 = operator new(48 * v8, (std::align_val_t)8uLL);
  if (v4)
  {
    sub_1CBF62A08(a1, v4, &v4[6 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }

  return sub_1CBF628D8((void *)a1);
}

void *sub_1CBF628D8(void *result)
{
  result[1] = 0;
  v10[0] = 2;
  v10[1] = 0;
  uint64_t v11 = -4096;
  uint64_t v12 = 0;
  uint64_t v1 = *((unsigned int *)result + 4);
  if (v1)
  {
    uint64_t v2 = result;
    uint64_t result = v10;
    uint64_t v3 = *v2;
    uint64_t v4 = 48 * v1;
    unint64_t v5 = (void *)(*v2 + 16);
    do
    {
      uint64_t v6 = v10[0] & 6;
      *(v5 - 1) = v6;
      *unint64_t v5 = 0;
      uint64_t v7 = v11;
      v5[1] = v11;
      if (v7 != -4096 && v7 != -8192 && v7 != 0)
      {
        unint64_t v9 = v10[0] & 0xFFFFFFFFFFFFFFF8;
        *unint64_t v5 = *(void *)(v10[0] & 0xFFFFFFFFFFFFFFF8);
        *(void *)unint64_t v9 = v5 - 1;
        *(v5 - 1) = v9 | v6;
        if (*v5) {
          *(void *)*unint64_t v5 = *(void *)*v5 & 7 | (v3 + 16);
        }
      }
      *(v5 - 2) = off_1F2600B28;
      void v5[2] = v12;
      v5 += 6;
      v3 += 48;
      v4 -= 48;
    }
    while (v4);
    if (v11 != -8192 && v11 != -4096)
    {
      if (v11) {
        return llvm::ValueHandleBase::RemoveFromUseList(v10);
      }
    }
  }
  return result;
}

void *sub_1CBF62A08(uint64_t a1, void *a2, void *a3)
{
  uint64_t result = sub_1CBF628D8((void *)a1);
  v46[0] = 2;
  v46[1] = 0;
  uint64_t v47 = -4096;
  uint64_t v48 = 0;
  uint64_t v44 = 0;
  uint64_t v45 = off_1F2600B28;
  v42[0] = 2;
  v42[1] = 0;
  uint64_t v43 = -8192;
  if (a2 != a3)
  {
    do
    {
      uint64_t v7 = a2[3];
      if (v7 != v47 && v7 != v43)
      {
        int v49 = 0;
        uint64_t result = (void *)sub_1CBF62778(*(void *)a1, *(_DWORD *)(a1 + 16), v7, &v49);
        unint64_t v9 = v49;
        uint64_t v10 = v49[3];
        uint64_t v11 = a2[3];
        if (v10 != v11)
        {
          BOOL v12 = v10 == -4096 || v10 == 0;
          if (!v12 && v10 != -8192)
          {
            unint64_t v29 = v49[1] & 0xFFFFFFFFFFFFFFF8;
            *(void *)unint64_t v29 = v49[2];
            uint64_t v30 = (unint64_t *)v9[2];
            if (v30)
            {
              *uint64_t v30 = *v30 & 7 | v29;
            }
            else
            {
              uint64_t v31 = v9[3];
              uint64_t v32 = ***(int32x2_t ****)v31;
              unint64_t v33 = (unint64_t)v32[303];
              if (v33 <= v29)
              {
                uint64_t v34 = v32[305].u32[0];
                if (v33 + 16 * v34 > v29)
                {
                  unsigned int v35 = v34 - 1;
                  LODWORD(v36) = v35 & ((v31 >> 4) ^ (v31 >> 9));
                  int v37 = (uint64_t *)(v33 + 16 * v36);
                  uint64_t v38 = *v37;
                  if (v31 == *v37)
                  {
LABEL_47:
                    *int v37 = -8192;
                    v32[304] = vadd_s32(v32[304], (int32x2_t)0x1FFFFFFFFLL);
                    uint64_t v31 = v9[3];
                  }
                  else
                  {
                    int v39 = 1;
                    while (v38 != -4096)
                    {
                      int v40 = v36 + v39++;
                      uint64_t v36 = v40 & v35;
                      uint64_t v38 = *(void *)(v33 + 16 * v36);
                      if (v31 == v38)
                      {
                        int v37 = (uint64_t *)(v33 + 16 * v36);
                        goto LABEL_47;
                      }
                    }
                  }
                  *(unsigned char *)(v31 + 17) &= ~1u;
                }
              }
            }
            uint64_t v11 = a2[3];
          }
          v9[3] = v11;
          if (v11 != -4096 && v11 != -8192 && v11 != 0)
          {
            uint64_t v14 = a2[1];
            void v9[2] = *(void *)(v14 & 0xFFFFFFFFFFFFFFF8);
            *(void *)(v14 & 0xFFFFFFFFFFFFFFF8) = v9 + 1;
            v9[1] = v14 & 0xFFFFFFFFFFFFFFF8 | v9[1] & 7;
            unint64_t v15 = (unint64_t *)v9[2];
            if (v15) {
              *unint64_t v15 = *v15 & 7 | (unint64_t)(v9 + 2);
            }
          }
        }
        void v9[4] = a2[4];
        v9[5] = a2[5];
        ++*(_DWORD *)(a1 + 8);
        uint64_t v7 = a2[3];
      }
      if (v7 != -4096 && v7 != -8192 && v7 != 0)
      {
        unint64_t v17 = a2[1] & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v17 = a2[2];
        uint64_t v18 = (unint64_t *)a2[2];
        if (v18)
        {
          *uint64_t v18 = *v18 & 7 | v17;
        }
        else
        {
          uint64_t v19 = a2[3];
          unint64_t v20 = ***(int32x2_t ****)v19;
          unint64_t v21 = (unint64_t)v20[303];
          if (v21 <= v17)
          {
            uint64_t v22 = v20[305].u32[0];
            if (v21 + 16 * v22 > v17)
            {
              unsigned int v23 = v22 - 1;
              LODWORD(v24) = v23 & ((v19 >> 4) ^ (v19 >> 9));
              uint64_t v25 = (uint64_t *)(v21 + 16 * v24);
              uint64_t v26 = *v25;
              if (v19 == *v25)
              {
LABEL_33:
                *uint64_t v25 = -8192;
                v20[304] = vadd_s32(v20[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v19 = a2[3];
              }
              else
              {
                int v27 = 1;
                while (v26 != -4096)
                {
                  int v28 = v24 + v27++;
                  uint64_t v24 = v28 & v23;
                  uint64_t v26 = *(void *)(v21 + 16 * v24);
                  if (v19 == v26)
                  {
                    uint64_t v25 = (uint64_t *)(v21 + 16 * v24);
                    goto LABEL_33;
                  }
                }
              }
              *(unsigned char *)(v19 + 17) &= ~1u;
            }
          }
        }
      }
      a2 += 6;
    }
    while (a2 != a3);
    if (v43 != -8192 && v43 != -4096 && v43 != 0) {
      uint64_t result = llvm::ValueHandleBase::RemoveFromUseList(v42);
    }
  }
  if (v47 != -4096 && v47 != -8192)
  {
    if (v47) {
      return llvm::ValueHandleBase::RemoveFromUseList(v46);
    }
  }
  return result;
}

unint64_t sub_1CBF62D84(unint64_t *a1, uint64_t *a2)
{
  unint64_t v2 = a1[2];
  unint64_t v3 = a2[2];
  if (v2 == v3) {
    return a1[2];
  }
  BOOL v4 = v2 == -4096 || v2 == 0;
  if (!v4 && v2 != -8192)
  {
    unint64_t v10 = *a1 & 0xFFFFFFFFFFFFFFF8;
    *(void *)unint64_t v10 = a1[1];
    uint64_t v11 = (unint64_t *)a1[1];
    if (v11)
    {
      *uint64_t v11 = *v11 & 7 | v10;
    }
    else
    {
      unint64_t v12 = a1[2];
      long long v13 = ***(int32x2_t ****)v12;
      unint64_t v14 = (unint64_t)v13[303];
      if (v14 <= v10)
      {
        uint64_t v15 = v13[305].u32[0];
        if (v14 + 16 * v15 > v10)
        {
          unsigned int v16 = v15 - 1;
          LODWORD(v17) = v16 & ((v12 >> 4) ^ (v12 >> 9));
          uint64_t v18 = (uint64_t *)(v14 + 16 * v17);
          uint64_t v19 = *v18;
          if (v12 == *v18)
          {
LABEL_25:
            *uint64_t v18 = -8192;
            v13[304] = vadd_s32(v13[304], (int32x2_t)0x1FFFFFFFFLL);
            unint64_t v12 = a1[2];
          }
          else
          {
            int v20 = 1;
            while (v19 != -4096)
            {
              int v21 = v17 + v20++;
              uint64_t v17 = v21 & v16;
              uint64_t v19 = *(void *)(v14 + 16 * v17);
              if (v12 == v19)
              {
                uint64_t v18 = (uint64_t *)(v14 + 16 * v17);
                goto LABEL_25;
              }
            }
          }
          *(unsigned char *)(v12 + 17) &= ~1u;
        }
      }
    }
    unint64_t v3 = a2[2];
  }
  a1[2] = v3;
  if (v3 != -4096 && v3 != -8192 && v3 != 0)
  {
    uint64_t v6 = *a2;
    uint64_t v7 = (unint64_t *)(*a2 & 0xFFFFFFFFFFFFFFF8);
    a1[1] = *v7;
    *uint64_t v7 = (unint64_t)a1;
    *a1 = v6 & 0xFFFFFFFFFFFFFFF8 | *a1 & 7;
    unsigned int v8 = (unint64_t *)a1[1];
    if (v8) {
      *unsigned int v8 = *v8 & 7 | (unint64_t)(a1 + 1);
    }
    return a1[2];
  }
  return v3;
}

void sub_1CBF62EE4()
{
}

void sub_1CBF62FB0(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBF62FE8(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  sub_1CB843600(a2, a2, (uint64_t)&llvm::AAResultsWrapperPass::ID);
}

uint64_t sub_1CBF63000(uint64_t a1, uint64_t ***a2)
{
  unint64_t v3 = *(uint64_t **)(a1 + 8);
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 == v5)
  {
LABEL_4:
    uint64_t v6 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v4 != &llvm::AAResultsWrapperPass::ID)
    {
      v4 += 16;
      if (v4 == v5) {
        goto LABEL_4;
      }
    }
    uint64_t v6 = *(void *)(v4 + 8);
  }
  uint64_t v7 = (llvm *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, &llvm::AAResultsWrapperPass::ID);
  uint64_t v33 = *((void *)v7 + 4);
  v34[0] = v34;
  uint64_t v37 = 0;
  v34[1] = v34;
  void v34[2] = 0;
  v34[3] = 0;
  int v36 = 0;
  int v35 = 0;
  unsigned int v8 = (llvm::raw_ostream *)llvm::errs(v7);
  unint64_t v9 = v8;
  unint64_t v10 = (void *)*((void *)v8 + 4);
  if (*((void *)v8 + 3) - (void)v10 > 0x18uLL)
  {
    qmemcpy(v10, "Alias sets for function '", 25);
    *((void *)v8 + 4) += 25;
  }
  else
  {
    llvm::raw_ostream::write(v8, "Alias sets for function '", 0x19uLL);
  }
  if ((*((unsigned char *)a2 + 23) & 0x10) == 0) {
    goto LABEL_18;
  }
  uint64_t v11 = ***a2;
  uint64_t v12 = *(void *)(v11 + 152);
  uint64_t v13 = *(unsigned int *)(v11 + 168);
  if (!v13) {
    goto LABEL_15;
  }
  LODWORD(v14) = (v13 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v15 = (uint64_t ****)(v12 + 16 * v14);
  unsigned int v16 = *v15;
  if (*v15 != a2)
  {
    int v17 = 1;
    while (v16 != (uint64_t ***)-4096)
    {
      int v18 = v14 + v17++;
      uint64_t v14 = v18 & (v13 - 1);
      unsigned int v16 = *(uint64_t ****)(v12 + 16 * v14);
      if (v16 == a2)
      {
        uint64_t v15 = (uint64_t ****)(v12 + 16 * v14);
        goto LABEL_16;
      }
    }
LABEL_15:
    uint64_t v15 = (uint64_t ****)(v12 + 16 * v13);
  }
LABEL_16:
  uint64_t v19 = (size_t *)v15[1];
  size_t v22 = *v19;
  int v20 = v19 + 2;
  size_t v21 = v22;
  unsigned int v23 = (llvm::raw_ostream *)*((void *)v9 + 4);
  if (v22 <= *((void *)v9 + 3) - (void)v23)
  {
    if (v21)
    {
      memcpy(v23, v20, v21);
      unsigned int v23 = (llvm::raw_ostream *)(*((void *)v9 + 4) + v21);
      *((void *)v9 + 4) = v23;
    }
    goto LABEL_21;
  }
  llvm::raw_ostream::write(v9, (const char *)v20, v21);
LABEL_18:
  unsigned int v23 = (llvm::raw_ostream *)*((void *)v9 + 4);
LABEL_21:
  if (*((void *)v9 + 3) - (void)v23 > 2uLL)
  {
    *((unsigned char *)v23 + 2) = 10;
    *(_WORD *)unsigned int v23 = 14887;
    *((void *)v9 + 4) += 3;
  }
  else
  {
    unsigned int v23 = llvm::raw_ostream::write(v9, "':\n", 3uLL);
  }
  uint64_t v24 = a2 + 9;
  for (uint64_t i = a2[10]; i != (uint64_t **)v24; uint64_t i = (uint64_t **)i[1])
  {
    uint64_t v26 = i - 3;
    if (!i) {
      uint64_t v26 = 0;
    }
    int v27 = v26[6];
    if (v27 != (uint64_t *)(v26 + 5))
    {
      while (1)
      {
        if (v27) {
          int v28 = (llvm::Instruction *)(v27 - 3);
        }
        else {
          int v28 = 0;
        }
        unsigned int v23 = (llvm::raw_ostream *)llvm::AliasSetTracker::add((llvm::AliasSetTracker *)&v33, v28);
        int v27 = (uint64_t *)v27[1];
        unint64_t v29 = i - 3;
        if (!i) {
          unint64_t v29 = 0;
        }
        if (v27 == (uint64_t *)(v29 + 5)) {
          break;
        }
LABEL_39:
        if (i == (uint64_t **)v24) {
          goto LABEL_40;
        }
      }
      while (1)
      {
        uint64_t i = (uint64_t **)i[1];
        if (i == (uint64_t **)v24) {
          goto LABEL_40;
        }
        uint64_t v30 = i - 3;
        if (!i) {
          uint64_t v30 = 0;
        }
        int v27 = v30[6];
        if (v27 != (uint64_t *)(v30 + 5)) {
          goto LABEL_39;
        }
      }
    }
  }
LABEL_40:
  uint64_t v31 = (llvm::raw_ostream *)llvm::errs(v23);
  llvm::AliasSetTracker::print((llvm::AliasSetTracker *)&v33, v31);
  sub_1CBF63354((uint64_t)&v33);
  return 0;
}

void **sub_1CBF632BC(void **result, int a2)
{
  unint64_t v2 = result;
  if (a2)
  {
    unint64_t v3 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    LODWORD(v4) = (((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8)) + 1;
    *((_DWORD *)result + 4) = v4;
    *uint64_t result = operator new(48 * v4, (std::align_val_t)8uLL);
    return (void **)sub_1CBF628D8(v2);
  }
  else
  {
    *uint64_t result = 0;
    result[1] = 0;
    *((_DWORD *)result + 4) = 0;
  }
  return result;
}

uint64_t sub_1CBF63354(uint64_t a1)
{
  return a1;
}

uint64_t *sub_1CBF633A0(uint64_t *result)
{
  uint64_t v1 = *((unsigned int *)result + 4);
  if (v1)
  {
    unint64_t v2 = result;
    uint64_t result = v19;
    v19[0] = 2;
    v19[1] = 0;
    uint64_t v20 = -4096;
    uint64_t v21 = 0;
    int v18 = off_1F2600B28;
    unint64_t v3 = v15;
    v15[0] = 2;
    v15[1] = 0;
    uint64_t v16 = -8192;
    uint64_t v17 = 0;
    uint64_t v4 = *v2;
    uint64_t v5 = 48 * v1;
    uint64_t v6 = (void *)(v4 + 24);
    do
    {
      uint64_t v7 = *v6;
      if (*v6 != -4096 && v7 != -8192 && v7 != 0)
      {
        uint64_t v11 = v5;
        uint64_t v12 = result;
        uint64_t v14 = v6;
        unint64_t v10 = v3;
        llvm::ValueHandleBase::RemoveFromUseList(v6 - 2);
        uint64_t result = v12;
        uint64_t v6 = v14;
        unint64_t v3 = v10;
        uint64_t v5 = v11;
      }
      v6 += 6;
      v5 -= 48;
    }
    while (v5);
    if (v16 != -8192 && v16 != -4096 && v16 != 0)
    {
      uint64_t v13 = result;
      llvm::ValueHandleBase::RemoveFromUseList(v3);
      uint64_t result = v13;
    }
    if (v20 != -4096 && v20 != -8192)
    {
      if (v20) {
        return llvm::ValueHandleBase::RemoveFromUseList(result);
      }
    }
  }
  return result;
}

void *sub_1CBF634D4(void *result, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  if (a5 < 1) {
    return result;
  }
  uint64_t v7 = (void *)a2;
  unsigned int v8 = result;
  uint64_t v9 = result[2];
  unint64_t v10 = result[1];
  if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - v10) >> 3)) < a5)
  {
    uint64_t v19 = *result;
    unint64_t v20 = a5 - 0x5555555555555555 * ((uint64_t)(v10 - *result) >> 3);
    if (v20 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((v9 - v19) >> 3);
    if (2 * v21 > v20) {
      unint64_t v20 = 2 * v21;
    }
    if (v21 >= 0x555555555555555) {
      unint64_t v22 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v22 = v20;
    }
    uint64_t v47 = result + 2;
    if (v22)
    {
      if (v22 > 0xAAAAAAAAAAAAAAALL) {
        sub_1CB833614();
      }
      unsigned int v23 = (char *)operator new(24 * v22);
    }
    else
    {
      unsigned int v23 = 0;
    }
    uint64_t v43 = v23;
    uint64_t v44 = &v23[8 * (((uint64_t)v7 - v19) >> 3)];
    uint64_t v45 = v44;
    int v46 = &v23[24 * v22];
    sub_1CD45AA98((uint64_t)&v43, (uint64_t)a3, a5);
    sub_1CD45AB24(v8, &v43, v7);
    return (void *)sub_1CD45AC84((uint64_t)&v43);
  }
  else
  {
    if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - a2) >> 3)) >= a5)
    {
      uint64_t v11 = &a3[3 * a5];
    }
    else
    {
      uint64_t v11 = &a3[(uint64_t)(v10 - a2) >> 3];
      if (v11 == a4)
      {
        unint64_t v18 = result[1];
      }
      else
      {
        uint64_t v12 = 0;
        do
        {
          uint64_t v13 = (unint64_t *)(v10 + v12 * 8);
          *uint64_t v13 = 4;
          v13[1] = 0;
          unint64_t v14 = v11[v12 + 2];
          void v13[2] = v14;
          if (v14 != -8192 && v14 != -4096 && v14 != 0)
          {
            unint64_t v16 = v11[v12] & 0xFFFFFFFFFFFFFFF8;
            v13[1] = *(void *)v16;
            *(void *)unint64_t v16 = v13;
            *uint64_t v13 = v16 | 4;
            uint64_t v17 = (unint64_t *)v13[1];
            if (v17) {
              *uint64_t v17 = *v17 & 7 | (v10 + v12 * 8 + 8);
            }
          }
          v12 += 3;
        }
        while (&v11[v12] != a4);
        unint64_t v18 = v10 + v12 * 8;
      }
      result[1] = v18;
      if ((uint64_t)(v10 - a2) < 1) {
        return result;
      }
    }
    for (uint64_t result = (void *)sub_1CD45A998((unint64_t)result, a2, v10, a2 + 24 * a5); a3 != v11; v7 += 3)
    {
      uint64_t v24 = v7[2];
      uint64_t v25 = a3[2];
      if (v24 != v25)
      {
        BOOL v26 = v24 == -4096 || v24 == 0;
        if (!v26 && v24 != -8192)
        {
          unint64_t v31 = *v7 & 0xFFFFFFFFFFFFFFF8;
          *(void *)unint64_t v31 = v7[1];
          uint64_t v32 = (unint64_t *)v7[1];
          if (v32)
          {
            *uint64_t v32 = *v32 & 7 | v31;
          }
          else
          {
            uint64_t v33 = v7[2];
            uint64_t v34 = ***(int32x2_t ****)v33;
            unint64_t v35 = (unint64_t)v34[303];
            if (v35 <= v31)
            {
              uint64_t v36 = v34[305].u32[0];
              if (v35 + 16 * v36 > v31)
              {
                unsigned int v37 = v36 - 1;
                LODWORD(v38) = v37 & ((v33 >> 4) ^ (v33 >> 9));
                int v39 = (uint64_t *)(v35 + 16 * v38);
                uint64_t v40 = *v39;
                if (v33 == *v39)
                {
LABEL_52:
                  *int v39 = -8192;
                  v34[304] = vadd_s32(v34[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v33 = v7[2];
                }
                else
                {
                  int v41 = 1;
                  while (v40 != -4096)
                  {
                    int v42 = v38 + v41++;
                    uint64_t v38 = v42 & v37;
                    uint64_t v40 = *(void *)(v35 + 16 * v38);
                    if (v33 == v40)
                    {
                      int v39 = (uint64_t *)(v35 + 16 * v38);
                      goto LABEL_52;
                    }
                  }
                }
                *(unsigned char *)(v33 + 17) &= ~1u;
              }
            }
          }
          uint64_t v25 = a3[2];
        }
        v7[2] = v25;
        if (v25 != -4096 && v25 != -8192 && v25 != 0)
        {
          uint64_t v28 = *a3;
          unint64_t v29 = (void *)(*a3 & 0xFFFFFFFFFFFFFFF8);
          v7[1] = *v29;
          *unint64_t v29 = v7;
          *uint64_t v7 = v28 & 0xFFFFFFFFFFFFFFF8 | *v7 & 7;
          uint64_t v30 = (unint64_t *)v7[1];
          if (v30) {
            *uint64_t v30 = *v30 & 7 | (unint64_t)(v7 + 1);
          }
        }
      }
      a3 += 3;
    }
  }
  return result;
}

void sub_1CBF6385C(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v3 = (char *)v1[1];
    uint64_t v4 = **a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *((void *)v3 - 1);
        if (v5 != -8192 && v5 != -4096 && v5 != 0)
        {
          unint64_t v7 = *((void *)v3 - 3) & 0xFFFFFFFFFFFFFFF8;
          *(void *)unint64_t v7 = *((void *)v3 - 2);
          unsigned int v8 = (unint64_t *)*((void *)v3 - 2);
          if (v8)
          {
            *unsigned int v8 = *v8 & 7 | v7;
          }
          else
          {
            uint64_t v9 = *((void *)v3 - 1);
            unint64_t v10 = ***(int32x2_t ****)v9;
            unint64_t v11 = (unint64_t)v10[303];
            if (v11 <= v7)
            {
              uint64_t v12 = v10[305].u32[0];
              if (v11 + 16 * v12 > v7)
              {
                unsigned int v13 = v12 - 1;
                LODWORD(v14) = v13 & ((v9 >> 4) ^ (v9 >> 9));
                uint64_t v15 = (uint64_t *)(v11 + 16 * v14);
                uint64_t v16 = *v15;
                if (v9 == *v15)
                {
LABEL_19:
                  *uint64_t v15 = -8192;
                  v10[304] = vadd_s32(v10[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v9 = *((void *)v3 - 1);
                }
                else
                {
                  int v17 = 1;
                  while (v16 != -4096)
                  {
                    int v18 = v14 + v17++;
                    uint64_t v14 = v18 & v13;
                    uint64_t v16 = *(void *)(v11 + 16 * v14);
                    if (v9 == v16)
                    {
                      uint64_t v15 = (uint64_t *)(v11 + 16 * v14);
                      goto LABEL_19;
                    }
                  }
                }
                *(unsigned char *)(v9 + 17) &= ~1u;
              }
            }
          }
        }
        v3 -= 24;
      }
      while (v3 != v2);
      uint64_t v4 = **a1;
    }
    v1[1] = v2;
    operator delete(v4);
  }
}

uint64_t sub_1CBF63988(uint64_t *a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * ((a1[2] - *a1) >> 3) > v3) {
    unint64_t v3 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= 0x555555555555555) {
    unint64_t v6 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v3;
  }
  v11[4] = a1 + 2;
  if (v6)
  {
    if (v6 > 0xAAAAAAAAAAAAAAALL) {
      sub_1CB833614();
    }
    unint64_t v7 = (char *)operator new(24 * v6);
  }
  else
  {
    unint64_t v7 = 0;
  }
  unsigned int v8 = (llvm::ValueHandleBase *)&v7[24 * v2];
  v11[0] = v7;
  v11[1] = v8;
  _OWORD v11[3] = &v7[24 * v6];
  *(void *)unsigned int v8 = 4;
  *((void *)v8 + 1) = 0;
  *((void *)v8 + 2) = a2;
  if (a2 != -8192 && a2 != -4096 && a2) {
    llvm::ValueHandleBase::AddToUseList(v8);
  }
  void v11[2] = (char *)v8 + 24;
  sub_1CD45ACEC(a1, v11);
  uint64_t v9 = a1[1];
  sub_1CD45AC84((uint64_t)v11);
  return v9;
}

void *sub_1CBF63AA4(uint64_t a1, void *a2, void *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    do
    {
      uint64_t v5 = *v4;
      unint64_t v6 = (void *)v4[1];
      *unint64_t v6 = *v4;
      *(void *)(v5 + 8) = v6;
      *uint64_t v4 = 0;
      v4[1] = 0;
      unsigned int v8 = (void **)(v4 + 5);
      sub_1CBF6385C(&v8);
      MEMORY[0x1D25D9CE0](v4, 0x10A0C40E86B5DE6);
      uint64_t v4 = v6;
    }
    while (v6 != a3);
  }
  return a3;
}

BOOL sub_1CBF63B28(uint64_t a1)
{
  return *(unsigned char *)(a1 + 16) == 84
      && (uint64_t v1 = *(void *)(a1 - 32)) != 0
      && !*(unsigned char *)(v1 + 16)
      && *(void *)(v1 + 24) == *(void *)(a1 + 72)
      && (*(unsigned char *)(v1 + 33) & 0x20) != 0
      && (*(_DWORD *)(v1 + 36) - 55) < 4;
}

BOOL sub_1CBF63B78(uint64_t a1)
{
  return *(unsigned char *)(a1 + 16) == 84
      && (uint64_t v1 = *(void *)(a1 - 32)) != 0
      && !*(unsigned char *)(v1 + 16)
      && *(void *)(v1 + 24) == *(void *)(a1 + 72)
      && (*(unsigned char *)(v1 + 33) & 0x20) != 0
      && (*(_DWORD *)(v1 + 36) - 199) < 2;
}

BOOL sub_1CBF63BC8(uint64_t a1)
{
  return *(unsigned char *)(a1 + 16) == 84
      && (uint64_t v1 = *(void *)(a1 - 32)) != 0
      && !*(unsigned char *)(v1 + 16)
      && *(void *)(v1 + 24) == *(void *)(a1 + 72)
      && (*(unsigned char *)(v1 + 33) & 0x20) != 0
      && (*(_DWORD *)(v1 + 36) - 194) < 5;
}

void *sub_1CBF63C18(void **a1, uint64_t a2)
{
  unint64_t v3 = (char *)*a1;
  unint64_t v2 = (char *)a1[1];
  uint64_t v4 = (v2 - (unsigned char *)*a1) >> 3;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 61) {
    abort();
  }
  uint64_t v8 = (unsigned char *)a1[2] - v3;
  if (v8 >> 2 > v5) {
    unint64_t v5 = v8 >> 2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  if (v9)
  {
    if (v9 >> 61) {
      sub_1CB833614();
    }
    unint64_t v10 = (char *)operator new(8 * v9);
  }
  else
  {
    unint64_t v10 = 0;
  }
  unint64_t v11 = &v10[8 * v4];
  *(void *)unint64_t v11 = a2;
  uint64_t v12 = v11 + 8;
  if (v2 != v3)
  {
    do
    {
      uint64_t v13 = *((void *)v2 - 1);
      v2 -= 8;
      *((void *)v11 - 1) = v13;
      v11 -= 8;
    }
    while (v2 != v3);
    unint64_t v2 = (char *)*a1;
  }
  *a1 = v11;
  a1[1] = v12;
  a1[2] = &v10[8 * v9];
  if (v2) {
    operator delete(v2);
  }
  return v12;
}

uint64_t sub_1CBF63CF0()
{
  int v4 = 1;
  int v2 = 250;
  unint64_t v3 = &v2;
  *(void *)&long long v1 = "The maximum number of pointers may-alias sets may contain before degradation";
  *((void *)&v1 + 1) = 76;
  sub_1CD45A86C((uint64_t)&unk_1EBD02730, "alias-set-saturation-threshold", &v4, &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBD02730, &dword_1CB82C000);
}

void llvm::initializeAnalysis(llvm *this, llvm::PassRegistry *a2)
{
  llvm::initializeAAEvalLegacyPassPass((uint64_t)this);
  llvm::initializeAliasSetPrinterPass((uint64_t)this);
  llvm::initializeBasicAAWrapperPassPass(this, v3);
  llvm::initializeBlockFrequencyInfoWrapperPassPass(this, v4);
  llvm::initializeBranchProbabilityInfoWrapperPassPass(this, v5);
  llvm::initializeCallGraphWrapperPassPass(this, v6);
  llvm::initializeCallGraphDOTPrinterPass((uint64_t)this);
  llvm::initializeCallGraphPrinterLegacyPassPass((uint64_t)this);
  llvm::initializeCallGraphViewerPass((uint64_t)this);
  llvm::initializeCostModelAnalysisPass((uint64_t)this);
  llvm::initializeCFGViewerLegacyPassPass((uint64_t)this);
  llvm::initializeCFGPrinterLegacyPassPass((uint64_t)this);
  llvm::initializeCFGOnlyViewerLegacyPassPass((uint64_t)this);
  llvm::initializeCFGOnlyPrinterLegacyPassPass((uint64_t)this);
  llvm::initializeCFLAndersAAWrapperPassPass(this, v7);
  llvm::initializeCFLSteensAAWrapperPassPass(this, v8);
  llvm::initializeCycleInfoWrapperPassPass((uint64_t)this);
  llvm::initializeDependenceAnalysisWrapperPassPass(this, v9);
  llvm::initializeDelinearizationPass((uint64_t)this);
  llvm::initializeDemandedBitsWrapperPassPass(this, v10);
  llvm::initializeDominanceFrontierWrapperPassPass(this, v11);
  llvm::initializeDomViewerPass((uint64_t)this);
  llvm::initializeDomPrinterPass((uint64_t)this);
  llvm::initializeDomOnlyViewerPass((uint64_t)this);
  llvm::initializePostDomViewerPass((uint64_t)this);
  llvm::initializeDomOnlyPrinterPass((uint64_t)this);
  llvm::initializePostDomPrinterPass((uint64_t)this);
  llvm::initializePostDomOnlyViewerPass((uint64_t)this);
  llvm::initializePostDomOnlyPrinterPass((uint64_t)this);
  llvm::initializeAAResultsWrapperPassPass(this, v12);
  llvm::initializeGlobalsAAWrapperPassPass(this, v13);
  llvm::initializeIVUsersWrapperPassPass(this, v14);
  llvm::initializeInstCountLegacyPassPass((uint64_t)this);
  llvm::initializeIntervalPartitionPass((uint64_t)this);
  llvm::initializeIRSimilarityIdentifierWrapperPassPass(this, v15);
  llvm::initializeLazyBranchProbabilityInfoPassPass((uint64_t)this);
  llvm::initializeLazyBlockFrequencyInfoPassPass(this, v16);
  llvm::initializeLazyValueInfoWrapperPassPass(this, v17);
  llvm::initializeLazyValueInfoPrinterPass((uint64_t)this);
  llvm::initializeLegacyDivergenceAnalysisPass(this, v18);
  llvm::initializeLintLegacyPassPass((uint64_t)this);
  llvm::initializeLoopInfoWrapperPassPass((uint64_t)this);
  llvm::initializeMemDepPrinterPass((uint64_t)this);
  llvm::initializeMemDerefPrinterPass((uint64_t)this);
  llvm::initializeMemoryDependenceWrapperPassPass(this, v19);
  llvm::initializeModuleDebugInfoLegacyPrinterPass((uint64_t)this);
  llvm::initializeModuleSummaryIndexWrapperPassPass(this, v20);
  llvm::initializeMustExecutePrinterPass((uint64_t)this);
  llvm::initializeMustBeExecutedContextPrinterPass((uint64_t)this);
  llvm::initializeObjCARCAAWrapperPassPass(this, v21);
  llvm::initializeOptimizationRemarkEmitterWrapperPassPass(this, v22);
  llvm::initializePhiValuesWrapperPassPass(this, v23);
  llvm::initializePostDominatorTreeWrapperPassPass((uint64_t)this);
  llvm::initializeRegionInfoPassPass(this, v24);
  llvm::initializeRegionViewerPass((uint64_t)this);
  llvm::initializeRegionPrinterPass((uint64_t)this);
  llvm::initializeRegionOnlyViewerPass((uint64_t)this);
  llvm::initializeRegionOnlyPrinterPass((uint64_t)this);
  llvm::initializeSCEVAAWrapperPassPass(this, v25);
  llvm::initializeScalarEvolutionWrapperPassPass(this, v26);
  llvm::initializeStackSafetyGlobalInfoWrapperPassPass(this, v27);
  llvm::initializeStackSafetyInfoWrapperPassPass(this, v28);
  llvm::initializeTargetTransformInfoWrapperPassPass((uint64_t)this);
  llvm::initializeFunctionGroupInfoWrapperPassPass((uint64_t)this);
  llvm::initializeTypeBasedAAWrapperPassPass(this, v29);
  llvm::initializeScopedNoAliasAAWrapperPassPass(this, v30);
  llvm::initializeGPUAAWrapperPassPass(this, v31);
  llvm::initializeLCSSAVerificationPassPass(this, v32);
  llvm::initializeMemorySSAWrapperPassPass(this, v33);
  llvm::initializeMemorySSAPrinterLegacyPassPass((uint64_t)this);

  llvm::initializeGPUFunctionCallInfoWrapperPass(this, v34);
}

uint64_t LLVMVerifyModule(llvm *a1, int a2, char **a3, BOOL *a4)
{
  if (a2 == 2) {
    unint64_t v7 = 0;
  }
  else {
    unint64_t v7 = (llvm::raw_ostream *)llvm::errs(a1);
  }
  v25[0] = 0;
  v25[1] = 0;
  uint64_t v26 = 0;
  int v17 = 0;
  char v21 = 0;
  uint64_t v22 = 0;
  uint64_t v24 = v25;
  int v23 = 0;
  if (a3) {
    uint64_t v8 = (const llvm::Module *)&v16;
  }
  else {
    uint64_t v8 = v7;
  }
  uint64_t v16 = &unk_1F2646F30;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v9 = llvm::verifyModule(a1, v8, 0, a4);
  if (a3 && v7)
  {
    char v10 = *((unsigned char *)v24 + 23);
    if (v10 >= 0) {
      unint64_t v11 = (const char *)v24;
    }
    else {
      unint64_t v11 = (const char *)*v24;
    }
    if (v10 >= 0) {
      size_t v12 = v10 & 0x7F;
    }
    else {
      size_t v12 = (size_t)v24[1];
    }
    llvm::raw_ostream::write(v7, v11, v12);
  }
  if (a2) {
    int v13 = 0;
  }
  else {
    int v13 = v9;
  }
  if (v13 == 1) {
    llvm::report_fatal_error((llvm *)"Broken module found, compilation aborted!", (const llvm::Twine *)1);
  }
  if (a3)
  {
    uint64_t v14 = (const char *)v24;
    if (*((char *)v24 + 23) < 0) {
      uint64_t v14 = (const char *)*v24;
    }
    *a3 = strdup(v14);
  }
  uint64_t v16 = &unk_1F2646B98;
  if (v23 == 1 && v18) {
    MEMORY[0x1D25D9CB0](v18, 0x1000C8077774924);
  }
  if (SHIBYTE(v26) < 0) {
    operator delete(v25[0]);
  }
  return v9;
}

llvm *LLVMVerifyFunction(uint64_t a1, int a2, llvm::raw_ostream *a3)
{
  if (a2 == 2) {
    return (llvm *)llvm::verifyFunction((uint64_t ***)a1, 0, a3);
  }
  unint64_t v6 = (const llvm::Function *)llvm::errs((llvm *)a1);
  uint64_t result = (llvm *)llvm::verifyFunction((uint64_t ***)a1, v6, v7);
  if (!a2)
  {
    if (result)
    {
      uint64_t v8 = (llvm::raw_ostream *)llvm::errs(result);
      sub_1CB8E509C(v8, "Verifier error:\n");
      llvm::Module::dump(*(llvm::Module **)(a1 + 40));
      llvm::report_fatal_error((llvm *)"Broken function found, compilation aborted!", (const llvm::Twine *)1);
    }
  }
  return result;
}

void LLVMViewFunctionCFG(llvm::Function *a1)
{
}

void LLVMViewFunctionCFGOnly(llvm::Function *a1)
{
}

uint64_t sub_1CBF64200(llvm::DebugCounter *a1, size_t a2, const void *a3, std::string::size_type a4)
{
  atomic_ullong v8 = llvm::DebugCounter::instance(a1);
  if (a2 > 0x7FFFFFFFFFFFFFF7) {
LABEL_22:
  }
    abort();
  uint64_t v9 = v8;
  if (a2 >= 0x17)
  {
    uint64_t v11 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17) {
      uint64_t v11 = a2 | 7;
    }
    uint64_t v12 = v11 + 1;
    char v10 = (void **)operator new(v11 + 1);
    __dst[1] = (void *)a2;
    unint64_t v20 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_8;
  }
  HIBYTE(v20) = a2;
  char v10 = __dst;
  if (a2) {
LABEL_8:
  }
    memmove(v10, a1, a2);
  *((unsigned char *)v10 + a2) = 0;
  if (a4 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_22;
  }
  if (a4 >= 0x17)
  {
    uint64_t v14 = (a4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a4 | 7) != 0x17) {
      uint64_t v14 = a4 | 7;
    }
    uint64_t v15 = v14 + 1;
    p_p = (std::string *)operator new(v14 + 1);
    __p.__r_.__value_.__l.__size_ = a4;
    __p.__r_.__value_.__r.__words[2] = v15 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)p_p;
    goto LABEL_16;
  }
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = a4;
  p_p = &__p;
  if (a4) {
LABEL_16:
  }
    memmove(p_p, a3, a4);
  p_p->__r_.__value_.__s.__data_[a4] = 0;
  uint64_t v16 = sub_1CBF64BD4(v9, (uint64_t)__dst, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(__dst[0]);
  }
  return v16;
}

uint64_t llvm::hasAttributeInAssume(uint64_t a1, uint64_t a2, const void *a3, size_t a4, void *a5)
{
  int v5 = *(_DWORD *)(a1 + 20);
  if ((v5 & 0x80000000) == 0) {
    return 0;
  }
  uint64_t v7 = a1 - 32 * (v5 & 0x7FFFFFF);
  uint64_t v8 = *(void *)(v7 - 8);
  if (!v8) {
    return 0;
  }
  uint64_t v9 = -v8;
  while (1)
  {
    char v10 = *(uint64_t **)(v7 + v9 - 8);
    uint64_t v12 = *v10;
    uint64_t v11 = v10 + 2;
    if (v12 == a4 && (!a4 || !memcmp(v11, a3, a4)))
    {
      if (!a2) {
        break;
      }
      uint64_t v13 = *(unsigned int *)(v7 + v9);
      if (*(_DWORD *)(v7 + v9 + 4) != v13 && *(void *)(v7 + 32 * v13) == a2) {
        break;
      }
    }
    uint64_t result = 0;
    v9 += 16;
    if (!v9) {
      return result;
    }
  }
  if (a5)
  {
    uint64_t v14 = *(void *)(v7 + 32 * *(unsigned int *)(v7 + v9) + 32);
    uint64_t v15 = (void *)(v14 + 24);
    if (*(_DWORD *)(v14 + 32) >= 0x41u) {
      uint64_t v15 = (void *)*v15;
    }
    *a5 = *v15;
  }
  return 1;
}

uint64_t llvm::fillMapFromAssume(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(result + 20);
  if (v2 < 0)
  {
    uint64_t v3 = v2 & 0x7FFFFFF;
    uint64_t v4 = result - 32 * v3;
    uint64_t v7 = *(void *)(v4 - 8);
    uint64_t v6 = v4 - 8;
    uint64_t v5 = v7;
    if (v7)
    {
      uint64_t v8 = -8 - (v5 + 32 * v3);
      uint64_t v28 = result;
      uint64_t v9 = result;
      do
      {
        uint64_t v10 = result + v8;
        int AttrKindFromName = llvm::Attribute::getAttrKindFromName(*(void *)(result + v8) + 16, **(void **)(result + v8));
        uint64_t v12 = 0;
        uint64_t v30 = 0;
        int v31 = AttrKindFromName;
        uint64_t v13 = *(unsigned int *)(v10 + 8);
        int v14 = *(_DWORD *)(v10 + 12);
        if (v14 != v13)
        {
          uint64_t v12 = *(void *)(v28 - 32 * (*(_DWORD *)(v28 + 20) & 0x7FFFFFF) + 32 * v13);
          uint64_t v30 = v12;
        }
        if (v12 || AttrKindFromName)
        {
          if ((v14 - v13) <= 1)
          {
            uint64_t v17 = sub_1CD45AFB0((uint64_t *)a2, &v30);
            uint64_t v32 = v28;
            uint64_t v18 = sub_1CD45B4B8(v17 + 16, &v32);
            v18[1] = 0;
            void v18[2] = 0;
          }
          else
          {
            uint64_t v15 = *(void *)(v28 - 32 * (*(_DWORD *)(v28 + 20) & 0x7FFFFFF) + 32 * v13 + 32);
            if (v15) {
              BOOL v16 = *(unsigned char *)(v15 + 16) == 16;
            }
            else {
              BOOL v16 = 0;
            }
            if (v16)
            {
              uint64_t v19 = (void *)(v15 + 24);
              if (*(_DWORD *)(v15 + 32) >= 0x41u) {
                uint64_t v19 = (void *)*v19;
              }
              unint64_t v20 = (void *)*v19;
              uint64_t v32 = 0;
              if (sub_1CD45B020((uint64_t *)a2, &v30, &v32)
                && v32 != *(void *)a2 + 40 * *(unsigned int *)(a2 + 16)
                && (uint64_t v21 = v32 + 16, (sub_1CD45B528(*(void *)(v32 + 16), *(_DWORD *)(v32 + 32), v28, &v32) & 1) != 0))
              {
                uint64_t v32 = v9;
                uint64_t v22 = sub_1CD45B4B8(v21, &v32);
                if (v22[1] >= (unint64_t)v20) {
                  int v23 = v20;
                }
                else {
                  int v23 = (void *)v22[1];
                }
                uint64_t v29 = v9;
                sub_1CD45B4B8(v21, &v29)[1] = v23;
                uint64_t v32 = v9;
                uint64_t v24 = sub_1CD45B4B8(v21, &v32);
                if ((unint64_t)v20 <= v24[2]) {
                  unint64_t v20 = (void *)v24[2];
                }
                uint64_t v29 = v9;
                uint64_t v25 = sub_1CD45B4B8(v21, &v29);
              }
              else
              {
                uint64_t v26 = sub_1CD45AFB0((uint64_t *)a2, &v30);
                uint64_t v32 = v28;
                uint64_t v25 = sub_1CD45B4B8(v26 + 16, &v32);
                v25[1] = v20;
              }
              v25[2] = v20;
            }
          }
        }
        v8 += 16;
        uint64_t result = v28;
      }
      while (v10 + 16 != v6);
    }
  }
  return result;
}

uint64_t llvm::getKnowledgeFromBundle@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 8) = 0;
  uint64_t v6 = (uint64_t *)(a3 + 8);
  *(void *)(a3 + 16) = 0;
  uint64_t result = llvm::Attribute::getAttrKindFromName(*(void *)a2 + 16, **(void **)a2);
  *(_DWORD *)a3 = result;
  uint64_t v8 = *(unsigned int *)(a2 + 8);
  int v9 = *(_DWORD *)(a2 + 12);
  if (v9 != v8) {
    *(void *)(a3 + 16) = *(void *)(a1 - 32 * (*(_DWORD *)(a1 + 20) & 0x7FFFFFF) + 32 * v8);
  }
  unsigned int v10 = v9 - v8;
  if (v10 >= 2)
  {
    uint64_t v11 = a1 - 32 * (*(_DWORD *)(a1 + 20) & 0x7FFFFFF) + 32 * v8;
    uint64_t v12 = *(void *)(v11 + 32);
    if (v12) {
      BOOL v13 = *(unsigned char *)(v12 + 16) == 16;
    }
    else {
      BOOL v13 = 0;
    }
    if (v13)
    {
      uint64_t v15 = (uint64_t *)(v12 + 24);
      if (*(_DWORD *)(v12 + 32) >= 0x41u) {
        uint64_t v15 = (uint64_t *)*v15;
      }
      uint64_t v14 = *v15;
    }
    else
    {
      uint64_t v14 = 1;
    }
    *uint64_t v6 = v14;
    if (result == 74 && v10 >= 3)
    {
      uint64_t v17 = *(void *)(v11 + 64);
      if (v17) {
        BOOL v18 = *(unsigned char *)(v17 + 16) == 16;
      }
      else {
        BOOL v18 = 0;
      }
      if (v18)
      {
        unint64_t v20 = (uint64_t *)(v17 + 24);
        if (*(_DWORD *)(v17 + 32) >= 0x41u) {
          unint64_t v20 = (uint64_t *)*v20;
        }
        uint64_t v19 = *v20;
      }
      else
      {
        uint64_t v19 = 1;
      }
      *uint64_t v6 = (v19 | v14) & -(v19 | v14);
    }
  }
  return result;
}

uint64_t llvm::getKnowledgeFromOperandInAssume@<X0>(char *a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  long long v6 = *(_OWORD *)llvm::CallBase::getBundleOpInfoForOperand(a1, a2);
  return llvm::getKnowledgeFromBundle((uint64_t)a1, (uint64_t)&v6, a3);
}

uint64_t llvm::isAssumeWithEmptyBundle(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 20);
  if ((v1 & 0x80000000) == 0) {
    return 1;
  }
  uint64_t v3 = a1 - 32 * (v1 & 0x7FFFFFF);
  uint64_t v6 = *(void *)(v3 - 8);
  uint64_t v4 = v3 - 8;
  uint64_t v5 = v6;
  if (!v6) {
    return 1;
  }
  uint64_t v7 = -v5;
  uint64_t result = 1;
  while (1)
  {
    uint64_t v8 = *(void *)(v4 + v7);
    if (*(void *)v8 != 6) {
      break;
    }
    int v9 = *(_DWORD *)(v8 + 16);
    int v10 = *(unsigned __int16 *)(v8 + 20);
    if (v9 != 1869506409 || v10 != 25970) {
      break;
    }
    v7 += 16;
    if (!v7) {
      return result;
    }
  }
  return 0;
}

char *sub_1CBF64840(char *a1)
{
  uint64_t v2 = *((void *)a1 + 3);
  if (!v2) {
    return 0;
  }
  if (*(unsigned char *)(v2 + 16) != 84) {
    return 0;
  }
  uint64_t v4 = *(void *)(v2 - 32);
  if (!v4) {
    return 0;
  }
  if (*(unsigned char *)(v4 + 16)) {
    return 0;
  }
  if (*(void *)(v4 + 24) != *(void *)(v2 + 72)) {
    return 0;
  }
  if (*(_DWORD *)(v4 + 36) != 7) {
    return 0;
  }
  int v5 = *(_DWORD *)(v2 + 20);
  uint64_t v6 = (char *)(v2 - 32 * (v5 & 0x7FFFFFF));
  if (*(void *)a1 == *(void *)v6) {
    return 0;
  }
  if ((v5 & 0x40000000) != 0) {
    uint64_t v6 = *(char **)(v2 - 8);
  }
  return llvm::CallBase::getBundleOpInfoForOperand((char *)v2, (unint64_t)(a1 - v6) >> 5);
}

void llvm::getKnowledgeForValue(uint64_t a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t (*a5)(uint64_t, long long *, uint64_t, uint64_t)@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  if (a4)
  {
    if (!*(unsigned char *)(a4 + 184)) {
      llvm::AssumptionCache::scanFunction((llvm::AssumptionCache *)a4);
    }
    uint64_t v14 = *(void *)(a4 + 160);
    unsigned int v15 = *(_DWORD *)(a4 + 176);
    if (v15)
    {
      unsigned int v17 = v15 - 1;
      unsigned int v18 = (v15 - 1) & ((a1 >> 4) ^ (a1 >> 9));
      uint64_t v16 = v14 + 88 * v18;
      uint64_t v19 = *(void *)(v16 + 24);
      if (v19 == a1) {
        goto LABEL_6;
      }
      int v20 = 1;
      while (v19 != -4096)
      {
        unsigned int v21 = v18 + v20++;
        unsigned int v18 = v21 & v17;
        uint64_t v16 = v14 + 88 * (v21 & v17);
        uint64_t v19 = *(void *)(v16 + 24);
        if (v19 == a1) {
          goto LABEL_6;
        }
      }
    }
    uint64_t v16 = v14 + 88 * v15;
LABEL_6:
    if (v16 != v14 + 88 * v15)
    {
      uint64_t v22 = *(unsigned int *)(v16 + 48);
      if (v22)
      {
        uint64_t v23 = *(void *)(v16 + 40);
        uint64_t v24 = v23 + 32 * v22;
        uint64_t v25 = 4 * a3;
        do
        {
          uint64_t v26 = *(void *)(v23 + 16);
          if (v26)
          {
            uint64_t v27 = *(unsigned int *)(v23 + 24);
            if (v27 != -1)
            {
              uint64_t v41 = v24;
              uint64_t v42 = v25;
              uint64_t v44 = *(void *)(v23 + 16);
              int v32 = *(_DWORD *)(v26 + 20);
              uint64_t v33 = v32 < 0 ? v26 - 32 * (v32 & 0x7FFFFFF) - 8 - *(void *)(v26 - 32 * (v32 & 0x7FFFFFF) - 8) : 0;
              llvm::getKnowledgeFromBundle(v26, v33 + 16 * v27, a7);
              uint64_t v24 = v41;
              uint64_t v25 = v42;
              if (*(_DWORD *)a7)
              {
                if (*(void *)(a7 + 16) == a1)
                {
                  if (a3)
                  {
                    uint64_t v34 = v42;
                    unint64_t v35 = a2;
                    while (*v35 != *(_DWORD *)a7)
                    {
                      ++v35;
                      v34 -= 4;
                      if (!v34)
                      {
                        unint64_t v35 = &a2[a3];
                        break;
                      }
                    }
                  }
                  else
                  {
                    unint64_t v35 = a2;
                  }
                  BOOL v36 = a3 == v35 - a2;
                  uint64_t v25 = v42;
                  uint64_t v24 = v41;
                  if (!v36)
                  {
                    int v37 = *(_DWORD *)(v44 + 20);
                    uint64_t v38 = v37 < 0
                        ? v44 - 32 * (v37 & 0x7FFFFFF) - 8 - *(void *)(v44 - 32 * (v37 & 0x7FFFFFF) - 8)
                        : 0;
                    uint64_t v39 = v38 + 16 * *(unsigned int *)(v23 + 24);
                    long long v45 = *(_OWORD *)a7;
                    uint64_t v46 = *(void *)(a7 + 16);
                    char v40 = a5(a6, &v45, v44, v39);
                    uint64_t v24 = v41;
                    uint64_t v25 = v42;
                    if (v40) {
                      return;
                    }
                  }
                }
              }
            }
          }
          v23 += 32;
        }
        while (v23 != v24);
      }
    }
LABEL_7:
    *(_DWORD *)a7 = 0;
    *(void *)(a7 + 8) = 0;
    *(void *)(a7 + 16) = 0;
    return;
  }
  uint64_t v28 = *(void *)(a1 + 8);
  if (!v28) {
    goto LABEL_7;
  }
  while (1)
  {
    uint64_t v29 = sub_1CBF64840((char *)v28);
    if (v29)
    {
      uint64_t v43 = v29;
      llvm::getKnowledgeFromBundle(*(void *)(v28 + 24), (uint64_t)v29, a7);
      if (*(_DWORD *)a7)
      {
        if (a3)
        {
          uint64_t v30 = 4 * a3;
          int v31 = a2;
          while (*v31 != *(_DWORD *)a7)
          {
            ++v31;
            v30 -= 4;
            if (!v30)
            {
              int v31 = &a2[a3];
              break;
            }
          }
        }
        else
        {
          int v31 = a2;
        }
        if (a3 != v31 - a2)
        {
          long long v45 = *(_OWORD *)a7;
          uint64_t v46 = *(void *)(a7 + 16);
          if (a5(a6, &v45, *(void *)(v28 + 24), (uint64_t)v43)) {
            break;
          }
        }
      }
    }
    uint64_t v28 = *(void *)(v28 + 8);
    if (!v28) {
      goto LABEL_7;
    }
  }
}

void llvm::getKnowledgeValidInContext(uint64_t a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v9 = a4;
  v7[0] = &v9;
  v7[1] = &v8;
  uint64_t v8 = a5;
  llvm::getKnowledgeForValue(a1, a2, a3, a6, (uint64_t (*)(uint64_t, long long *, uint64_t, uint64_t))sub_1CBF654EC, (uint64_t)v7, a7);
}

uint64_t sub_1CBF64BD4(uint64_t a1, uint64_t a2, const std::string *a3)
{
  unsigned int v10 = sub_1CBF64C6C((unint64_t *)(a1 + 24), a2);
  int v5 = sub_1CBF64FEC(a1, &v10);
  *((void *)v5 + 1) = 0;
  *((void *)v5 + 2) = 0;
  *((void *)v5 + 3) = -1;
  *((unsigned char *)v5 + 32) = 0;
  uint64_t v6 = v5 + 10;
  if (*((char *)v5 + 63) < 0)
  {
    uint64_t v9 = v5 + 10;
    operator delete(*(void **)v6);
    uint64_t v6 = v9;
  }
  *(void *)uint64_t v6 = 0;
  *((void *)v6 + 1) = 0;
  *((void *)v6 + 2) = 0;
  uint64_t v7 = sub_1CBF64FEC(a1, &v10);
  std::string::operator=((std::string *)(v7 + 10), a3);
  return v10;
}

uint64_t sub_1CBF64C6C(unint64_t *a1, uint64_t a2)
{
  unsigned int v10 = (long long *)a2;
  uint64_t v4 = sub_1CBF64D34((uint64_t)a1, (const void **)a2, (uint64_t)&std::piecewise_construct, &v10);
  uint64_t result = *((unsigned int *)v4 + 14);
  if (!result)
  {
    unint64_t v6 = a1[4];
    unint64_t v7 = a1[5];
    *((_DWORD *)v4 + 14) = -1431655765 * ((v6 - a1[3]) >> 3) + 1;
    if (v6 >= v7)
    {
      uint64_t v9 = sub_1CBF64E70(a1 + 3, a2);
    }
    else
    {
      if (*(char *)(a2 + 23) < 0)
      {
        sub_1CB8BDF7C(v6, *(const void **)a2, *(void *)(a2 + 8));
      }
      else
      {
        long long v8 = *(_OWORD *)a2;
        *(void *)(v6 + 16) = *(void *)(a2 + 16);
        *(_OWORD *)unint64_t v6 = v8;
      }
      uint64_t v9 = v6 + 24;
    }
    a1[4] = v9;
    return *((unsigned int *)v4 + 14);
  }
  return result;
}

uint64_t *sub_1CBF64D34(uint64_t a1, const void **a2, uint64_t a3, long long **a4)
{
  unint64_t v6 = (uint64_t **)sub_1CB835798(a1, &v12, a2);
  uint64_t result = *v6;
  if (!*v6)
  {
    sub_1CBF64DF8(a1, a4, (uint64_t)&v11);
    uint64_t v8 = v12;
    uint64_t v9 = v11;
    *uint64_t v11 = 0;
    v9[1] = 0;
    void v9[2] = v8;
    *unint64_t v6 = v9;
    uint64_t v10 = **(void **)a1;
    if (v10)
    {
      *(void *)a1 = v10;
      uint64_t v9 = *v6;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v9);
    ++*(void *)(a1 + 16);
    return v11;
  }
  return result;
}

_OWORD *sub_1CBF64DF8@<X0>(uint64_t a1@<X0>, long long **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  unint64_t v6 = (char *)operator new(0x40uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  uint64_t result = v6 + 32;
  uint64_t v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    uint64_t result = sub_1CB8BDF7C((uint64_t)result, *(const void **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    *((void *)v6 + 6) = *((void *)v8 + 2);
    *uint64_t result = v9;
  }
  *((_DWORD *)v6 + 14) = 0;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

uint64_t sub_1CBF64E70(unint64_t *a1, uint64_t a2)
{
  unint64_t v3 = *a1;
  unint64_t v2 = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v2 - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * ((uint64_t)(a1[2] - v3) >> 3) > v5) {
    unint64_t v5 = 0x5555555555555556 * ((uint64_t)(a1[2] - v3) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[2] - v3) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v5;
  }
  int v20 = a1 + 2;
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      sub_1CB833614();
    }
    long long v9 = operator new(24 * v8);
  }
  else
  {
    long long v9 = 0;
  }
  uint64_t v10 = (uint64_t)v9 + 24 * v4;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_1CB8BDF7C(v10, *(const void **)a2, *(void *)(a2 + 8));
    unint64_t v3 = *a1;
    unint64_t v2 = a1[1];
  }
  else
  {
    *(_OWORD *)uint64_t v10 = *(_OWORD *)a2;
    *(void *)(v10 + 16) = *(void *)(a2 + 16);
  }
  if (v2 == v3)
  {
    int64x2_t v13 = vdupq_n_s64(v3);
    unint64_t v11 = v10;
  }
  else
  {
    unint64_t v11 = v10;
    do
    {
      long long v12 = *(_OWORD *)(v2 - 24);
      *(void *)(v11 - 8) = *(void *)(v2 - 8);
      *(_OWORD *)(v11 - 24) = v12;
      v11 -= 24;
      *(void *)(v2 - 16) = 0;
      *(void *)(v2 - 8) = 0;
      *(void *)(v2 - 24) = 0;
      v2 -= 24;
    }
    while (v2 != v3);
    int64x2_t v13 = *(int64x2_t *)a1;
  }
  uint64_t v14 = v10 + 24;
  *a1 = v11;
  a1[1] = v14;
  int64x2_t v18 = v13;
  unint64_t v15 = a1[2];
  a1[2] = (unint64_t)v9 + 24 * v8;
  unint64_t v19 = v15;
  uint64_t v17 = v13.i64[0];
  sub_1CBF4EE0C((uint64_t)&v17);
  return v14;
}

_DWORD *sub_1CBF64FEC(uint64_t a1, _DWORD *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    uint64_t v10 = 0;
LABEL_8:
    unint64_t v6 = sub_1CBF650C4(a1, (uint64_t)a2, a2, v10);
    *unint64_t v6 = *a2;
    *(_OWORD *)(v6 + 6) = 0u;
    *(_OWORD *)(v6 + 2) = 0u;
    *((void *)v6 + 3) = -1;
    *((void *)v6 + 6) = 0;
    *((void *)v6 + 7) = 0;
    *((void *)v6 + 5) = 0;
    return v6;
  }
  unsigned int v4 = v3 - 1;
  uint64_t v5 = (37 * *a2) & (v3 - 1);
  unint64_t v6 = (_DWORD *)(*(void *)a1 + (v5 << 6));
  int v7 = *v6;
  if (*a2 != *v6)
  {
    unint64_t v8 = 0;
    int v9 = 1;
    while (v7 != -1)
    {
      if (v8) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        unint64_t v8 = v6;
      }
      int v13 = v5 + v9++;
      uint64_t v5 = v13 & v4;
      unint64_t v6 = (_DWORD *)(*(void *)a1 + (v5 << 6));
      int v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v8) {
      uint64_t v10 = v8;
    }
    else {
      uint64_t v10 = v6;
    }
    goto LABEL_8;
  }
  return v6;
}

_DWORD *sub_1CBF650C4(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 < 3 * v7)
  {
    if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3) {
      goto LABEL_3;
    }
    sub_1CBF65250(a1, v7);
    int v15 = *(_DWORD *)(a1 + 16);
    if (v15)
    {
      unsigned int v16 = v15 - 1;
      uint64_t v17 = (37 * *a3) & v16;
      a4 = (_DWORD *)(*(void *)a1 + (v17 << 6));
      int v18 = *a4;
      if (*a3 == *a4) {
        goto LABEL_3;
      }
      int v13 = 0;
      int v19 = 1;
      while (v18 != -1)
      {
        if (v13) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v18 == -2;
        }
        if (v20) {
          int v13 = a4;
        }
        int v21 = v17 + v19++;
        uint64_t v17 = v21 & v16;
        a4 = (_DWORD *)(*(void *)a1 + (v17 << 6));
        int v18 = *a4;
        if (*a3 == *a4) {
          goto LABEL_3;
        }
      }
      goto LABEL_10;
    }
LABEL_24:
    a4 = 0;
    goto LABEL_3;
  }
  sub_1CBF65250(a1, 2 * v7);
  int v9 = *(_DWORD *)(a1 + 16);
  if (!v9) {
    goto LABEL_24;
  }
  unsigned int v10 = v9 - 1;
  uint64_t v11 = (37 * *a3) & v10;
  a4 = (_DWORD *)(*(void *)a1 + (v11 << 6));
  int v12 = *a4;
  if (*a3 == *a4) {
    goto LABEL_3;
  }
  int v13 = 0;
  int v14 = 1;
  while (v12 != -1)
  {
    if (v13) {
      BOOL v22 = 0;
    }
    else {
      BOOL v22 = v12 == -2;
    }
    if (v22) {
      int v13 = a4;
    }
    int v23 = v11 + v14++;
    uint64_t v11 = v23 & v10;
    a4 = (_DWORD *)(*(void *)a1 + (v11 << 6));
    int v12 = *a4;
    if (*a3 == *a4) {
      goto LABEL_3;
    }
  }
LABEL_10:
  if (v13) {
    a4 = v13;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

_DWORD *sub_1CBF65250(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  unsigned int v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = llvm::allocate_buffer((unint64_t)v8 << 6, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CBF65328(a1, v4, &v4[16 * v3]);
    llvm::deallocate_buffer((llvm *)v4, (void *)(v3 << 6));
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = v10 << 6;
    do
    {
      *uint64_t result = -1;
      result += 16;
      v11 -= 64;
    }
    while (v11);
  }
  return result;
}

void sub_1CBF65328(uint64_t a1, int *a2, int *a3)
{
  unsigned int v4 = a2;
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(_DWORD **)a1;
    uint64_t v8 = v6 << 6;
    do
    {
      *int v7 = -1;
      v7 += 16;
      v8 -= 64;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      int v9 = *v4;
      if (*v4 <= 0xFFFFFFFD)
      {
        int v10 = *(_DWORD *)(a1 + 16);
        if (v10)
        {
          unsigned int v11 = v10 - 1;
          uint64_t v12 = (v10 - 1) & (37 * v9);
          int v13 = (int *)(*(void *)a1 + (v12 << 6));
          int v14 = *v13;
          if (v9 != *v13)
          {
            int v15 = 0;
            int v16 = 1;
            while (v14 != -1)
            {
              if (v15) {
                BOOL v17 = 0;
              }
              else {
                BOOL v17 = v14 == -2;
              }
              if (v17) {
                int v15 = v13;
              }
              int v18 = v12 + v16++;
              uint64_t v12 = v18 & v11;
              int v13 = (int *)(*(void *)a1 + (v12 << 6));
              int v14 = *v13;
              if (v9 == *v13) {
                goto LABEL_18;
              }
            }
            if (v15) {
              int v13 = v15;
            }
          }
        }
        else
        {
          int v13 = 0;
        }
LABEL_18:
        *int v13 = v9;
        long long v19 = *(_OWORD *)(v4 + 2);
        *(_OWORD *)((char *)v13 + 17) = *(_OWORD *)((char *)v4 + 17);
        *(_OWORD *)(v13 + 2) = v19;
        long long v20 = *(_OWORD *)(v4 + 10);
        *((void *)v13 + 7) = *((void *)v4 + 7);
        *(_OWORD *)(v13 + 10) = v20;
        *((void *)v4 + 6) = 0;
        *((void *)v4 + 7) = 0;
        *((void *)v4 + 5) = 0;
        ++*(_DWORD *)(a1 + 8);
        if (*((char *)v4 + 63) < 0) {
          operator delete(*((void **)v4 + 5));
        }
      }
      v4 += 16;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1CBF65470()
{
  int v0 = &unk_1EBCBE000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
  {
    int v2 = __cxa_guard_acquire(&qword_1EBCBE588);
    int v0 = &unk_1EBCBE000;
    if (v2)
    {
      unint64_t v3 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v3 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v3;
      __cxa_guard_release(&qword_1EBCBE588);
      int v0 = (void *)&unk_1EBCBE000;
    }
  }
  return v0[176];
}

uint64_t sub_1CBF654EC(const llvm::Instruction ***a1, int a2, llvm *this, const llvm::DominatorTree *a4)
{
  return llvm::isValidAssumeForContext(this, **a1, *a1[1], a4);
}

uint64_t sub_1CBF65504()
{
  uint64_t result = sub_1CBF64200((llvm::DebugCounter *)"assume-queries-counter", 0x16uLL, "Controls which assumes gets created", 0x23uLL);
  dword_1EBCC3AD8 = result;
  return result;
}

void *llvm::AssumptionCache::getOrInsertAffectedValues(llvm::AssumptionCache *this, llvm::Value *a2)
{
  v71[4] = *MEMORY[0x1E4F143B8];
  unsigned int v4 = (char *)this + 160;
  uint64_t v3 = *((void *)this + 20);
  unsigned int v5 = *((_DWORD *)this + 44);
  if (!v5)
  {
LABEL_2:
    uint64_t v6 = (void *)(v3 + 88 * v5);
    goto LABEL_3;
  }
  unsigned int v30 = (v5 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v6 = (void *)(v3 + 88 * v30);
  int v31 = (llvm::Value *)v6[3];
  if (v31 != a2)
  {
    int v32 = 1;
    while (v31 != (llvm::Value *)-4096)
    {
      unsigned int v33 = v30 + v32++;
      unsigned int v30 = v33 & (v5 - 1);
      uint64_t v6 = (void *)(v3 + 88 * v30);
      int v31 = (llvm::Value *)v6[3];
      if (v31 == a2) {
        goto LABEL_3;
      }
    }
    goto LABEL_2;
  }
LABEL_3:
  if (v6 != (void *)(v3 + 88 * v5)) {
    return v6 + 5;
  }
  uint64_t v8 = 2;
  uint64_t v58 = 2;
  unint64_t v59 = 0;
  unint64_t v60 = a2;
  if (a2 != (llvm::Value *)-8192 && a2 != (llvm::Value *)-4096 && a2)
  {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v58);
    uint64_t v8 = v58;
    a2 = v60;
  }
  int v61 = this;
  v63[0] = (char *)v64;
  v63[1] = (char *)0x100000000;
  unint64_t v65 = v8 & 6;
  uint64_t v66 = 0;
  unint64_t v67 = a2;
  if (a2 != (llvm::Value *)-8192 && a2 != (llvm::Value *)-4096)
  {
    if (a2)
    {
      uint64_t v66 = *(unint64_t **)(v8 & 0xFFFFFFFFFFFFFFF8);
      *(void *)(v8 & 0xFFFFFFFFFFFFFFF8) = &v65;
      unint64_t v65 = v8 & 0xFFFFFFFFFFFFFFFELL;
      if (v66) {
        *uint64_t v66 = *v66 & 7 | (unint64_t)&v66;
      }
    }
  }
  v64[4] = off_1F2600C98;
  BOOL v68 = v61;
  unint64_t v69 = (char *)v71;
  uint64_t v70 = 0x100000000;
  int v62 = 0;
  char v9 = sub_1CBF690C4(*((void *)this + 20), *((_DWORD *)this + 44), (uint64_t)v67, &v62);
  uint64_t v6 = v62;
  if ((v9 & 1) == 0)
  {
    int v10 = *((_DWORD *)this + 42);
    unsigned int v11 = *((_DWORD *)this + 44);
    if (4 * v10 + 4 >= 3 * v11)
    {
      v11 *= 2;
    }
    else if (v11 + ~v10 - *((_DWORD *)this + 43) > v11 >> 3)
    {
LABEL_17:
      ++*((_DWORD *)this + 42);
      uint64_t v12 = (llvm::Value *)v6[3];
      if (v12 != (llvm::Value *)-4096) {
        --*((_DWORD *)this + 43);
      }
      int v13 = v67;
      if (v12 != v67)
      {
        if (v12 != (llvm::Value *)-4096 && v12 && v12 != (llvm::Value *)-8192)
        {
          unint64_t v46 = v6[1] & 0xFFFFFFFFFFFFFFF8;
          *(void *)unint64_t v46 = v6[2];
          uint64_t v47 = (unint64_t *)v6[2];
          if (v47)
          {
            *uint64_t v47 = *v47 & 7 | v46;
          }
          else
          {
            uint64_t v48 = v6[3];
            int v49 = ***(int32x2_t ****)v48;
            unint64_t v50 = (unint64_t)v49[303];
            if (v50 <= v46)
            {
              uint64_t v51 = v49[305].u32[0];
              if (v50 + 16 * v51 > v46)
              {
                unsigned int v52 = v51 - 1;
                LODWORD(v53) = v52 & ((v48 >> 4) ^ (v48 >> 9));
                int v54 = (uint64_t *)(v50 + 16 * v53);
                uint64_t v55 = *v54;
                if (v48 == *v54)
                {
LABEL_75:
                  *int v54 = -8192;
                  v49[304] = vadd_s32(v49[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v48 = v6[3];
                }
                else
                {
                  int v56 = 1;
                  while (v55 != -4096)
                  {
                    int v57 = v53 + v56++;
                    uint64_t v53 = v57 & v52;
                    uint64_t v55 = *(void *)(v50 + 16 * v53);
                    if (v48 == v55)
                    {
                      int v54 = (uint64_t *)(v50 + 16 * v53);
                      goto LABEL_75;
                    }
                  }
                }
                *(unsigned char *)(v48 + 17) &= ~1u;
              }
            }
          }
          int v13 = v67;
        }
        v6[3] = v13;
        if (v13 != (llvm::Value *)-4096 && v13 != (llvm::Value *)-8192 && v13 != 0)
        {
          unint64_t v15 = v65;
          int v16 = (void *)(v65 & 0xFFFFFFFFFFFFFFF8);
          void v6[2] = *(void *)(v65 & 0xFFFFFFFFFFFFFFF8);
          *int v16 = v6 + 1;
          v6[1] = v15 & 0xFFFFFFFFFFFFFFF8 | v6[1] & 7;
          BOOL v17 = (unint64_t *)v6[2];
          if (v17) {
            *BOOL v17 = *v17 & 7 | (unint64_t)(v6 + 2);
          }
        }
      }
      int v18 = v68;
      v6[5] = v6 + 7;
      void v6[4] = v18;
      v6[6] = 0x100000000;
      if (v70) {
        sub_1CBF67AFC((uint64_t)(v6 + 5), (uint64_t *)&v69);
      }
      goto LABEL_30;
    }
    sub_1CBF6915C((uint64_t)v4, v11);
    int v62 = 0;
    sub_1CBF690C4(*((void *)this + 20), *((_DWORD *)this + 44), (uint64_t)v67, &v62);
    uint64_t v6 = v62;
    goto LABEL_17;
  }
LABEL_30:
  sub_1CBF68F7C(&v69);
  if (v67 != (llvm::Value *)-8192 && v67 != (llvm::Value *)-4096 && v67)
  {
    unint64_t v19 = v65 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v65 & 0xFFFFFFFFFFFFFFF8) = v66;
    if (v66)
    {
      *uint64_t v66 = *v66 & 7 | v19;
    }
    else
    {
      long long v20 = v67;
      int v21 = ***(int32x2_t ****)v67;
      unint64_t v22 = (unint64_t)v21[303];
      if (v22 <= v19)
      {
        uint64_t v23 = v21[305].u32[0];
        if (v22 + 16 * v23 > v19)
        {
          unsigned int v24 = v23 - 1;
          LODWORD(v25) = v24 & ((v67 >> 4) ^ (v67 >> 9));
          uint64_t v26 = (llvm::Value **)(v22 + 16 * v25);
          uint64_t v27 = *v26;
          if (v67 == *v26)
          {
LABEL_41:
            *uint64_t v26 = (llvm::Value *)-8192;
            v21[304] = vadd_s32(v21[304], (int32x2_t)0x1FFFFFFFFLL);
            long long v20 = v67;
          }
          else
          {
            int v28 = 1;
            while (v27 != (llvm::Value *)-4096)
            {
              int v29 = v25 + v28++;
              uint64_t v25 = v29 & v24;
              uint64_t v27 = *(llvm::Value **)(v22 + 16 * v25);
              if (v67 == v27)
              {
                uint64_t v26 = (llvm::Value **)(v22 + 16 * v25);
                goto LABEL_41;
              }
            }
          }
          *((unsigned char *)v20 + 17) &= ~1u;
        }
      }
    }
  }
  sub_1CBF68F7C(v63);
  if (v60 != (llvm::Value *)-8192 && v60 != (llvm::Value *)-4096 && v60 != 0)
  {
    unint64_t v35 = v58 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v58 & 0xFFFFFFFFFFFFFFF8) = v59;
    if (v59)
    {
      *unint64_t v59 = *v59 & 7 | v35;
    }
    else
    {
      BOOL v36 = v60;
      int v37 = ***(int32x2_t ****)v60;
      unint64_t v38 = (unint64_t)v37[303];
      if (v38 <= v35)
      {
        uint64_t v39 = v37[305].u32[0];
        if (v38 + 16 * v39 > v35)
        {
          unsigned int v40 = v39 - 1;
          LODWORD(v41) = v40 & ((v60 >> 4) ^ (v60 >> 9));
          uint64_t v42 = (llvm::Value **)(v38 + 16 * v41);
          uint64_t v43 = *v42;
          if (v60 == *v42)
          {
LABEL_62:
            *uint64_t v42 = (llvm::Value *)-8192;
            v37[304] = vadd_s32(v37[304], (int32x2_t)0x1FFFFFFFFLL);
            BOOL v36 = v60;
          }
          else
          {
            int v44 = 1;
            while (v43 != (llvm::Value *)-4096)
            {
              int v45 = v41 + v44++;
              uint64_t v41 = v45 & v40;
              uint64_t v43 = *(llvm::Value **)(v38 + 16 * v41);
              if (v60 == v43)
              {
                uint64_t v42 = (llvm::Value **)(v38 + 16 * v41);
                goto LABEL_62;
              }
            }
          }
          *((unsigned char *)v36 + 17) &= ~1u;
        }
      }
    }
  }
  return v6 + 5;
}

char **llvm::AssumptionCache::updateAffectedValues(llvm::AssumptionCache *a1, uint64_t a2)
{
  v29[64] = *MEMORY[0x1E4F143B8];
  uint64_t v27 = (char *)v29;
  uint64_t v28 = 0x1000000000;
  sub_1CBF65D5C(a2, *((void **)a1 + 1), (uint64_t)&v27);
  if (v28)
  {
    unsigned int v4 = v27;
    unsigned int v5 = &v27[32 * v28];
    do
    {
      uint64_t inserted = llvm::AssumptionCache::getOrInsertAffectedValues(a1, *((llvm::Value **)v4 + 2));
      uint64_t v7 = (uint64_t)inserted;
      uint64_t v8 = *((unsigned int *)inserted + 2);
      if (v8)
      {
        uint64_t v9 = 32 * v8;
        int v10 = (_DWORD *)(*inserted + 24);
        while (*((void *)v10 - 1) != a2 || *v10 != *((_DWORD *)v4 + 6))
        {
          v10 += 8;
          v9 -= 32;
          if (!v9) {
            goto LABEL_9;
          }
        }
      }
      else
      {
LABEL_9:
        uint64_t v23 = 4;
        unsigned int v24 = 0;
        uint64_t v25 = (int32x2_t ****)a2;
        if (a2 != -8192 && a2 != -4096 && a2) {
          llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v23);
        }
        int v26 = *((_DWORD *)v4 + 6);
        sub_1CBF65FA4(v7, (unint64_t)&v23);
        if (v25 != (int32x2_t ****)-8192 && v25 != (int32x2_t ****)-4096 && v25)
        {
          unint64_t v11 = v23 & 0xFFFFFFFFFFFFFFF8;
          *(void *)(v23 & 0xFFFFFFFFFFFFFFF8) = v24;
          if (v24)
          {
            *unsigned int v24 = *v24 & 7 | v11;
          }
          else
          {
            uint64_t v12 = v25;
            int v13 = ***v25;
            unint64_t v14 = (unint64_t)v13[303];
            if (v14 <= v11)
            {
              uint64_t v15 = v13[305].u32[0];
              if (v14 + 16 * v15 > v11)
              {
                unsigned int v22 = v15 - 1;
                LODWORD(v18) = v22 & ((v25 >> 4) ^ (v25 >> 9));
                long long v20 = (int32x2_t *****)(v14 + 16 * v18);
                unint64_t v19 = *v20;
                if (v25 == *v20)
                {
LABEL_23:
                  *long long v20 = (int32x2_t ****)-8192;
                  v13[304] = vadd_s32(v13[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v12 = v25;
                }
                else
                {
                  int v17 = 1;
                  while (v19 != (int32x2_t ****)-4096)
                  {
                    int v16 = v18 + v17++;
                    uint64_t v18 = v16 & v22;
                    unint64_t v19 = *(int32x2_t *****)(v14 + 16 * v18);
                    if (v25 == v19)
                    {
                      long long v20 = (int32x2_t *****)(v14 + 16 * v18);
                      goto LABEL_23;
                    }
                  }
                }
                *((unsigned char *)v12 + 17) &= ~1u;
              }
            }
          }
        }
      }
      v4 += 32;
    }
    while (v4 != v5);
  }
  return sub_1CBF695D0(&v27);
}

void sub_1CBF65D5C(uint64_t a1, void *a2, uint64_t a3)
{
  unsigned int v5 = 0;
  uint64_t v28 = a3;
  uint64_t v6 = a1 - 8;
  while (1)
  {
    int v7 = *(_DWORD *)(a1 + 20);
    unint64_t v8 = v7 < 0 ? *(void *)(v6 - 32 * (v7 & 0x7FFFFFF)) : 0;
    if (v5 == (v8 >> 4)) {
      break;
    }
    uint64_t v9 = a1 - 32 * (v7 & 0x7FFFFFF);
    uint64_t v10 = v9 - 8 - *(void *)(v9 - 8);
    uint64_t v11 = v10 + 16 * v5;
    uint64_t v12 = *(unsigned int *)(v11 + 8);
    if (*(_DWORD *)(v11 + 12) != v12)
    {
      uint64_t v13 = *(void *)(v10 + 16 * v5);
      if (*(void *)v13 != 6
        || ((int v14 = *(_DWORD *)(v13 + 16), v15 = *(unsigned __int16 *)(v13 + 20), v14 == 1869506409)
          ? (BOOL v16 = v15 == 25970)
          : (BOOL v16 = 0),
            !v16))
      {
        sub_1CBF68130(&v28, *(void *)(v9 + 32 * v12), v5);
      }
    }
    ++v5;
  }
  uint64_t v17 = *(void *)(a1 - 32 * (v7 & 0x7FFFFFF));
  sub_1CBF68130(&v28, v17, -1);
  if (v17)
  {
    if (*(unsigned char *)(v17 + 16) == 81)
    {
      uint64_t v18 = *(void *)(v17 - 64);
      if (v18)
      {
        uint64_t v19 = *(void *)(v17 - 32);
        if (v19)
        {
          int v20 = *(_WORD *)(v17 + 18) & 0x3F;
          sub_1CBF68130(&v28, *(void *)(v17 - 64), -1);
          sub_1CBF68130(&v28, v19, -1);
          if (v20 == 36)
          {
            int v21 = *(unsigned __int8 *)(v18 + 16);
            if (v21 == 5)
            {
              if (*(_WORD *)(v18 + 18) != 13) {
                goto LABEL_31;
              }
              unsigned int v24 = (uint64_t *)(v18 - 32 * (*(_DWORD *)(v18 + 20) & 0x7FFFFFF));
              uint64_t v22 = *v24;
              if (!*v24) {
                goto LABEL_31;
              }
              uint64_t v23 = v24[4];
            }
            else
            {
              if (v21 != 41) {
                goto LABEL_31;
              }
              uint64_t v22 = *(void *)(v18 - 64);
              if (!v22) {
                goto LABEL_31;
              }
              uint64_t v23 = *(void *)(v18 - 32);
            }
            if (*(unsigned char *)(v23 + 16) == 16 && *(unsigned char *)(v19 + 16) == 16) {
              sub_1CBF68130(&v28, v22, -1);
            }
          }
          else if (v20 == 32)
          {
            uint64_t v27 = &v28;
            sub_1CBF68544(&v27, v18);
            sub_1CBF68544(&v27, v19);
          }
        }
      }
    }
  }
LABEL_31:
  if (a2)
  {
    uint64_t v25 = (*(uint64_t (**)(void, uint64_t))(*(void *)*a2 + 160))(*a2, v17);
    if (v25)
    {
      uint64_t v26 = llvm::Value::stripInBoundsOffsets(v25, (void (*)(uint64_t, uint64_t))nullsub_1640, (uint64_t)&v27);
      sub_1CBF68130(&v28, v26, -1);
    }
  }
}

void sub_1CBF65FA4(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  unint64_t v5 = *(void *)a1;
  if (v4 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v11 = v4 + 1;
    unint64_t v12 = v5 + 32 * v4;
    if (v5 <= a2 && v12 > a2)
    {
      unint64_t v14 = a2 - v5;
      sub_1CBF67EE8(a1, v11);
      unint64_t v5 = *(void *)a1;
      a2 = *(void *)a1 + v14;
    }
    else
    {
      sub_1CBF67EE8(a1, v11);
      unint64_t v5 = *(void *)a1;
    }
  }
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  unint64_t v7 = v5 + 32 * v6;
  *(void *)unint64_t v7 = 4;
  *(void *)(v7 + 8) = 0;
  uint64_t v8 = *(void *)(a2 + 16);
  *(void *)(v7 + 16) = v8;
  if (v8)
  {
    if (v8 != -8192 && v8 != -4096)
    {
      unint64_t v9 = *(void *)a2 & 0xFFFFFFFFFFFFFFF8;
      *(void *)(v7 + 8) = *(void *)v9;
      *(void *)unint64_t v9 = v7;
      *(void *)unint64_t v7 = v9 | 4;
      uint64_t v10 = *(uint64_t **)(v7 + 8);
      if (v10) {
        *uint64_t v10 = *v10 & 7 | (v7 + 8);
      }
    }
  }
  *(_DWORD *)(v7 + 24) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 8) = v6 + 1;
}

void llvm::AssumptionCache::AffectedValueCallbackVH::deleted(llvm::AssumptionCache::AffectedValueCallbackVH *this)
{
  uint64_t v1 = *((void *)this + 3);
  uint64_t v2 = *((void *)this + 4) + 160;
  uint64_t v16 = 2;
  uint64_t v17 = 0;
  uint64_t v18 = (int32x2_t ****)v1;
  if (v1 != -8192 && v1 != -4096 && v1 != 0)
  {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v16);
    uint64_t v1 = (uint64_t)v18;
  }
  uint64_t v19 = 0;
  sub_1CBF661F4(v2, v1);
  if (v18 != (int32x2_t ****)-8192 && v18 != (int32x2_t ****)-4096 && v18 != 0)
  {
    unint64_t v5 = v16 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v16 & 0xFFFFFFFFFFFFFFF8) = v17;
    if (v17)
    {
      *uint64_t v17 = *v17 & 7 | v5;
    }
    else
    {
      uint64_t v6 = v18;
      unint64_t v7 = ***v18;
      unint64_t v8 = (unint64_t)v7[303];
      if (v8 <= v5)
      {
        uint64_t v9 = v7[305].u32[0];
        if (v8 + 16 * v9 > v5)
        {
          unsigned int v10 = v9 - 1;
          LODWORD(v11) = v10 & ((v18 >> 4) ^ (v18 >> 9));
          unint64_t v12 = (int32x2_t *****)(v8 + 16 * v11);
          uint64_t v13 = *v12;
          if (v18 == *v12)
          {
LABEL_20:
            *unint64_t v12 = (int32x2_t ****)-8192;
            v7[304] = vadd_s32(v7[304], (int32x2_t)0x1FFFFFFFFLL);
            uint64_t v6 = v18;
          }
          else
          {
            int v14 = 1;
            while (v13 != (int32x2_t ****)-4096)
            {
              int v15 = v11 + v14++;
              uint64_t v11 = v15 & v10;
              uint64_t v13 = *(int32x2_t *****)(v8 + 16 * v11);
              if (v18 == v13)
              {
                unint64_t v12 = (int32x2_t *****)(v8 + 16 * v11);
                goto LABEL_20;
              }
            }
          }
          *((unsigned char *)v6 + 17) &= ~1u;
        }
      }
    }
  }
}

int32x2_t sub_1CBF661F4(uint64_t a1, uint64_t a2)
{
  uint64_t v25 = 0;
  if (sub_1CBF690C4(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v25))
  {
    uint64_t v4 = v25;
    sub_1CBF68F7C((char **)v25 + 5);
    v26[0] = 2;
    v26[1] = 0;
    uint64_t v5 = -8192;
    uint64_t v27 = -8192;
    uint64_t v28 = 0;
    uint64_t v25 = off_1F2600C98;
    uint64_t v6 = v4[3];
    if (v6 != (uint64_t (*)(llvm::CallbackVH *__hidden))-8192)
    {
      if (v6 != (uint64_t (*)(llvm::CallbackVH *__hidden))-4096 && v6 != 0)
      {
        unint64_t v12 = (unint64_t)v4[1] & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v12 = v4[2];
        uint64_t v13 = (unint64_t *)v4[2];
        if (v13)
        {
          *uint64_t v13 = *v13 & 7 | v12;
        }
        else
        {
          int v14 = v4[3];
          int v15 = ***(int32x2_t ****)v14;
          unint64_t v16 = (unint64_t)v15[303];
          if (v16 <= v12)
          {
            uint64_t v17 = v15[305].u32[0];
            if (v16 + 16 * v17 > v12)
            {
              unsigned int v18 = v17 - 1;
              LODWORD(v19) = v18 & ((v14 >> 4) ^ (v14 >> 9));
              int v20 = (uint64_t (**)(llvm::CallbackVH *__hidden))(v16 + 16 * v19);
              int v21 = *v20;
              if (v14 == *v20)
              {
LABEL_27:
                *int v20 = (uint64_t (*)(llvm::CallbackVH *__hidden))-8192;
                v15[304] = vadd_s32(v15[304], (int32x2_t)0x1FFFFFFFFLL);
                int v14 = v4[3];
              }
              else
              {
                int v22 = 1;
                while (v21 != (uint64_t (*)(llvm::CallbackVH *__hidden))-4096)
                {
                  int v23 = v19 + v22++;
                  uint64_t v19 = v23 & v18;
                  int v21 = *(uint64_t (**)(llvm::CallbackVH *__hidden))(v16 + 16 * v19);
                  if (v14 == v21)
                  {
                    int v20 = (uint64_t (**)(llvm::CallbackVH *__hidden))(v16 + 16 * v19);
                    goto LABEL_27;
                  }
                }
              }
              *((unsigned char *)v14 + 17) &= ~1u;
            }
          }
        }
        uint64_t v5 = v27;
      }
      void v4[3] = (uint64_t (*)(llvm::CallbackVH *__hidden))v5;
      if (v5 != -4096 && v5 != -8192 && v5 != 0)
      {
        uint64_t v9 = v26[0];
        unsigned int v10 = (void *)(v26[0] & 0xFFFFFFFFFFFFFFF8);
        void v4[2] = *(uint64_t (**)(llvm::CallbackVH *__hidden))(v26[0] & 0xFFFFFFFFFFFFFFF8);
        *unsigned int v10 = v4 + 1;
        v4[1] = (uint64_t (*)(llvm::CallbackVH *__hidden))(v9 & 0xFFFFFFFFFFFFFFF8 | (unint64_t)v4[1] & 7);
        uint64_t v11 = (unint64_t *)v4[2];
        if (v11) {
          *uint64_t v11 = *v11 & 7 | (unint64_t)(v4 + 2);
        }
        uint64_t v5 = v27;
      }
    }
    v4[4] = v28;
    if (v5 != -8192 && v5 != -4096 && v5 != 0) {
      llvm::ValueHandleBase::RemoveFromUseList(v26);
    }
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + 8) = result;
  }
  return result;
}

void llvm::AssumptionCache::transferAffectedValuesInCache(llvm::AssumptionCache *this, llvm::Value *a2, llvm::Value *a3)
{
  uint64_t inserted = llvm::AssumptionCache::getOrInsertAffectedValues(this, a3);
  uint64_t v46 = 2;
  uint64_t v47 = 0;
  uint64_t v48 = a2;
  uint64_t v6 = a2;
  if (a2 != (llvm::Value *)-8192)
  {
    uint64_t v6 = a2;
    if (a2 != (llvm::Value *)-4096)
    {
      uint64_t v6 = a2;
      if (a2)
      {
        llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v46);
        uint64_t v6 = v48;
      }
    }
  }
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  if (sub_1CBF690C4(*((void *)this + 20), *((_DWORD *)this + 44), (uint64_t)v6, &v50)) {
    uint64_t v7 = v50;
  }
  else {
    uint64_t v7 = *((void *)this + 20) + 88 * *((unsigned int *)this + 44);
  }
  if (v48 != (llvm::Value *)-8192 && v48 != (llvm::Value *)-4096 && v48)
  {
    unint64_t v8 = v46 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v46 & 0xFFFFFFFFFFFFFFF8) = v47;
    if (v47)
    {
      *uint64_t v47 = *v47 & 7 | v8;
    }
    else
    {
      uint64_t v9 = v48;
      unsigned int v10 = ***(int32x2_t ****)v48;
      unint64_t v11 = (unint64_t)v10[303];
      if (v11 <= v8)
      {
        uint64_t v12 = v10[305].u32[0];
        if (v11 + 16 * v12 > v8)
        {
          unsigned int v13 = v12 - 1;
          LODWORD(v14) = v13 & ((v48 >> 4) ^ (v48 >> 9));
          int v15 = (llvm::Value **)(v11 + 16 * v14);
          unint64_t v16 = *v15;
          if (v48 == *v15)
          {
LABEL_18:
            *int v15 = (llvm::Value *)-8192;
            v10[304] = vadd_s32(v10[304], (int32x2_t)0x1FFFFFFFFLL);
            uint64_t v9 = v48;
          }
          else
          {
            int v17 = 1;
            while (v16 != (llvm::Value *)-4096)
            {
              int v18 = v14 + v17++;
              uint64_t v14 = v18 & v13;
              unint64_t v16 = *(llvm::Value **)(v11 + 16 * v14);
              if (v48 == v16)
              {
                int v15 = (llvm::Value **)(v11 + 16 * v14);
                goto LABEL_18;
              }
            }
          }
          *((unsigned char *)v9 + 17) &= ~1u;
        }
      }
    }
  }
  if (v7 != *((void *)this + 20) + 88 * *((unsigned int *)this + 44))
  {
    uint64_t v19 = (char *)this + 160;
    uint64_t v20 = *(unsigned int *)(v7 + 48);
    if (v20)
    {
      unint64_t v21 = *(void *)(v7 + 40);
      unint64_t v22 = v21 + 32 * v20;
      unsigned int v23 = *((_DWORD *)inserted + 2);
      do
      {
        unint64_t v24 = *inserted;
        uint64_t v25 = *inserted;
        if (v23)
        {
          uint64_t v44 = 32 * v23;
          uint64_t v25 = *inserted;
          while (*(void *)(v25 + 16) != *(void *)(v21 + 16))
          {
            v25 += 32;
            v44 -= 32;
            if (!v44)
            {
              uint64_t v25 = *inserted + 32 * v23;
              break;
            }
          }
        }
        if (v23 == (uint64_t)(v25 - v24) >> 5)
        {
          unint64_t v26 = v21;
          if (v23 >= *((_DWORD *)inserted + 3))
          {
            unint64_t v43 = v23 + 1;
            if (v24 <= v21 && *inserted + 32 * (unint64_t)v23 > v21)
            {
              unint64_t v45 = v21 - v24;
              sub_1CBF67EE8((uint64_t)inserted, v43);
              unint64_t v24 = *inserted;
              unint64_t v26 = *inserted + v45;
            }
            else
            {
              sub_1CBF67EE8((uint64_t)inserted, v43);
              unint64_t v24 = *inserted;
              unint64_t v26 = v21;
            }
          }
          uint64_t v27 = *((unsigned int *)inserted + 2);
          unint64_t v28 = v24 + 32 * v27;
          *(void *)unint64_t v28 = 4;
          *(void *)(v28 + 8) = 0;
          uint64_t v29 = *(void *)(v26 + 16);
          *(void *)(v28 + 16) = v29;
          if (v29)
          {
            if (v29 != -8192 && v29 != -4096)
            {
              unint64_t v30 = *(void *)v26 & 0xFFFFFFFFFFFFFFF8;
              *(void *)(v28 + 8) = *(void *)v30;
              *(void *)unint64_t v30 = v28;
              *(void *)unint64_t v28 = v30 | 4;
              int v31 = *(uint64_t **)(v28 + 8);
              if (v31) {
                *int v31 = *v31 & 7 | (v28 + 8);
              }
            }
          }
          *(_DWORD *)(v28 + 24) = *(_DWORD *)(v26 + 24);
          unsigned int v23 = v27 + 1;
          *((_DWORD *)inserted + 2) = v23;
        }
        v21 += 32;
      }
      while (v21 != v22);
    }
    uint64_t v46 = 2;
    uint64_t v47 = 0;
    uint64_t v48 = a2;
    if (a2 != (llvm::Value *)-8192 && a2 != (llvm::Value *)-4096 && a2)
    {
      llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v46);
      a2 = v48;
    }
    uint64_t v49 = 0;
    sub_1CBF661F4((uint64_t)v19, (uint64_t)a2);
    if (v48 != (llvm::Value *)-8192 && v48 != (llvm::Value *)-4096 && v48)
    {
      unint64_t v32 = v46 & 0xFFFFFFFFFFFFFFF8;
      *(void *)(v46 & 0xFFFFFFFFFFFFFFF8) = v47;
      if (v47)
      {
        *uint64_t v47 = *v47 & 7 | v32;
      }
      else
      {
        unsigned int v33 = v48;
        uint64_t v34 = ***(int32x2_t ****)v48;
        unint64_t v35 = (unint64_t)v34[303];
        if (v35 <= v32)
        {
          uint64_t v36 = v34[305].u32[0];
          if (v35 + 16 * v36 > v32)
          {
            unsigned int v37 = v36 - 1;
            LODWORD(v38) = v37 & ((v48 >> 4) ^ (v48 >> 9));
            uint64_t v39 = (llvm::Value **)(v35 + 16 * v38);
            unsigned int v40 = *v39;
            if (v48 == *v39)
            {
LABEL_49:
              *uint64_t v39 = (llvm::Value *)-8192;
              v34[304] = vadd_s32(v34[304], (int32x2_t)0x1FFFFFFFFLL);
              unsigned int v33 = v48;
            }
            else
            {
              int v41 = 1;
              while (v40 != (llvm::Value *)-4096)
              {
                int v42 = v38 + v41++;
                uint64_t v38 = v42 & v37;
                unsigned int v40 = *(llvm::Value **)(v35 + 16 * v38);
                if (v48 == v40)
                {
                  uint64_t v39 = (llvm::Value **)(v35 + 16 * v38);
                  goto LABEL_49;
                }
              }
            }
            *((unsigned char *)v33 + 17) &= ~1u;
          }
        }
      }
    }
  }
}

void llvm::AssumptionCache::AffectedValueCallbackVH::allUsesReplacedWith(llvm::AssumptionCache **this, llvm::Value *a2)
{
  unsigned int v2 = *((unsigned __int8 *)a2 + 16);
  if (v2 > 0x1B || v2 == 21) {
    llvm::AssumptionCache::transferAffectedValuesInCache(this[4], this[3], a2);
  }
}

void llvm::AssumptionCache::scanFunction(llvm::AssumptionCache *this)
{
  uint64_t v2 = *(void *)this + 72;
  for (uint64_t i = *(void *)(*(void *)this + 80); i != v2; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v4 = i - 24;
    if (!i) {
      uint64_t v4 = 0;
    }
    uint64_t v5 = v4 + 40;
    for (uint64_t j = *(void *)(v4 + 48); j != v5; uint64_t j = *(void *)(j + 8))
    {
      if (j) {
        uint64_t v7 = j - 24;
      }
      else {
        uint64_t v7 = 0;
      }
      if (sub_1CBF698E4(v7))
      {
        uint64_t v23 = 4;
        unint64_t v24 = 0;
        uint64_t v25 = (int32x2_t ****)v7;
        if (v7 != -8192 && v7 != -4096 && v7) {
          llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v23);
        }
        int v26 = -1;
        sub_1CBF65FA4((uint64_t)this + 16, (unint64_t)&v23);
        if (v25 != (int32x2_t ****)-8192 && v25 != (int32x2_t ****)-4096 && v25)
        {
          unint64_t v8 = v23 & 0xFFFFFFFFFFFFFFF8;
          *(void *)(v23 & 0xFFFFFFFFFFFFFFF8) = v24;
          if (v24)
          {
            *unint64_t v24 = *v24 & 7 | v8;
          }
          else
          {
            uint64_t v9 = v25;
            unsigned int v10 = ***v25;
            unint64_t v11 = (unint64_t)v10[303];
            if (v11 <= v8)
            {
              uint64_t v12 = v10[305].u32[0];
              if (v11 + 16 * v12 > v8)
              {
                unsigned int v13 = v12 - 1;
                LODWORD(v14) = v13 & ((v25 >> 4) ^ (v25 >> 9));
                int v15 = (int32x2_t *****)(v11 + 16 * v14);
                unint64_t v16 = *v15;
                if (v25 == *v15)
                {
LABEL_25:
                  *int v15 = (int32x2_t ****)-8192;
                  v10[304] = vadd_s32(v10[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v9 = v25;
                }
                else
                {
                  int v17 = 1;
                  while (v16 != (int32x2_t ****)-4096)
                  {
                    int v18 = v14 + v17++;
                    uint64_t v14 = v18 & v13;
                    unint64_t v16 = *(int32x2_t *****)(v11 + 16 * v14);
                    if (v25 == v16)
                    {
                      int v15 = (int32x2_t *****)(v11 + 16 * v14);
                      goto LABEL_25;
                    }
                  }
                }
                *((unsigned char *)v9 + 17) &= ~1u;
              }
            }
          }
        }
      }
    }
  }
  *((unsigned char *)this + 184) = 1;
  uint64_t v19 = *((unsigned int *)this + 6);
  if (v19)
  {
    uint64_t v20 = 32 * v19;
    unint64_t v21 = (uint64_t *)(*((void *)this + 2) + 16);
    do
    {
      uint64_t v22 = *v21;
      v21 += 4;
      llvm::AssumptionCache::updateAffectedValues(this, v22);
      v20 -= 32;
    }
    while (v20);
  }
}

char **llvm::AssumptionCache::registerAssumption(char **result, uint64_t a2)
{
  if (*((unsigned char *)result + 184))
  {
    uint64_t v3 = (llvm::AssumptionCache *)result;
    uint64_t v4 = (uint64_t)(result + 2);
    uint64_t v16 = 4;
    int v17 = 0;
    int v18 = (int32x2_t ****)a2;
    if (a2 != -8192 && a2 != -4096 && a2) {
      llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v16);
    }
    int v19 = -1;
    sub_1CBF65FA4(v4, (unint64_t)&v16);
    if (v18 != (int32x2_t ****)-8192 && v18 != (int32x2_t ****)-4096 && v18)
    {
      unint64_t v5 = v16 & 0xFFFFFFFFFFFFFFF8;
      *(void *)(v16 & 0xFFFFFFFFFFFFFFF8) = v17;
      if (v17)
      {
        *int v17 = *v17 & 7 | v5;
      }
      else
      {
        uint64_t v6 = v18;
        uint64_t v7 = ***v18;
        unint64_t v8 = (unint64_t)v7[303];
        if (v8 <= v5)
        {
          uint64_t v9 = v7[305].u32[0];
          if (v8 + 16 * v9 > v5)
          {
            unsigned int v10 = v9 - 1;
            LODWORD(v11) = v10 & ((v18 >> 4) ^ (v18 >> 9));
            uint64_t v12 = (int32x2_t *****)(v8 + 16 * v11);
            unsigned int v13 = *v12;
            if (v18 == *v12)
            {
LABEL_17:
              *uint64_t v12 = (int32x2_t ****)-8192;
              v7[304] = vadd_s32(v7[304], (int32x2_t)0x1FFFFFFFFLL);
              uint64_t v6 = v18;
            }
            else
            {
              int v14 = 1;
              while (v13 != (int32x2_t ****)-4096)
              {
                int v15 = v11 + v14++;
                uint64_t v11 = v15 & v10;
                unsigned int v13 = *(int32x2_t *****)(v8 + 16 * v11);
                if (v18 == v13)
                {
                  uint64_t v12 = (int32x2_t *****)(v8 + 16 * v11);
                  goto LABEL_17;
                }
              }
            }
            *((unsigned char *)v6 + 17) &= ~1u;
          }
        }
      }
    }
    return llvm::AssumptionCache::updateAffectedValues(v3, a2);
  }
  return result;
}

void llvm::AssumptionAnalysis::run()
{
}

int32x2_t llvm::AssumptionCacheTracker::FunctionCallbackVH::deleted(llvm::AssumptionCacheTracker::FunctionCallbackVH *this)
{
  uint64_t v1 = (int32x2_t *)*((void *)this + 4);
  int32x2_t v2 = v1[4];
  unsigned __int32 v3 = v1[6].u32[0];
  if (v3)
  {
    uint64_t v4 = *((void *)this + 3);
    unsigned int v5 = ((v4 >> 4) ^ (v4 >> 9)) & (v3 - 1);
    uint64_t v6 = (void *)(*(void *)&v2 + 48 * v5);
    uint64_t v7 = v6[3];
    if (v4 == v7) {
      goto LABEL_3;
    }
    int v29 = 1;
    while (v7 != -4096)
    {
      unsigned int v30 = v5 + v29++;
      unsigned int v5 = v30 & (v3 - 1);
      uint64_t v6 = (void *)(*(void *)&v2 + 48 * v5);
      uint64_t v7 = v6[3];
      if (v4 == v7) {
        goto LABEL_3;
      }
    }
  }
  uint64_t v6 = (void *)(*(void *)&v2 + 48 * v3);
LABEL_3:
  if ((void *)(*(void *)&v2 + 48 * v3) != v6)
  {
    uint64_t v8 = v6[5];
    v6[5] = 0;
    if (v8) {
      sub_1CBF699D0((uint64_t)(v6 + 5), v8);
    }
    v32[0] = 2;
    v32[1] = 0;
    uint64_t v9 = -8192;
    uint64_t v33 = -8192;
    uint64_t v34 = 0;
    uint64_t v10 = v6[3];
    if (v10 != -8192)
    {
      if (v10 != -4096 && v10 != 0)
      {
        unint64_t v17 = v6[1] & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v17 = v6[2];
        int v18 = (unint64_t *)v6[2];
        if (v18)
        {
          *int v18 = *v18 & 7 | v17;
        }
        else
        {
          uint64_t v19 = v6[3];
          uint64_t v20 = ***(int32x2_t ****)v19;
          unint64_t v21 = (unint64_t)v20[303];
          if (v21 <= v17)
          {
            uint64_t v22 = v20[305].u32[0];
            if (v21 + 16 * v22 > v17)
            {
              unsigned int v23 = v22 - 1;
              LODWORD(v24) = v23 & ((v19 >> 4) ^ (v19 >> 9));
              uint64_t v25 = (uint64_t *)(v21 + 16 * v24);
              uint64_t v26 = *v25;
              if (v19 == *v25)
              {
LABEL_31:
                *uint64_t v25 = -8192;
                v20[304] = vadd_s32(v20[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v19 = v6[3];
              }
              else
              {
                int v27 = 1;
                while (v26 != -4096)
                {
                  int v28 = v24 + v27++;
                  uint64_t v24 = v28 & v23;
                  uint64_t v26 = *(void *)(v21 + 16 * v24);
                  if (v19 == v26)
                  {
                    uint64_t v25 = (uint64_t *)(v21 + 16 * v24);
                    goto LABEL_31;
                  }
                }
              }
              *(unsigned char *)(v19 + 17) &= ~1u;
            }
          }
        }
        uint64_t v9 = v33;
      }
      v6[3] = v9;
      if (v9 != -4096 && v9 != -8192 && v9 != 0)
      {
        uint64_t v13 = v32[0];
        int v14 = (void *)(v32[0] & 0xFFFFFFFFFFFFFFF8);
        void v6[2] = *(void *)(v32[0] & 0xFFFFFFFFFFFFFFF8);
        *int v14 = v6 + 1;
        v6[1] = v13 & 0xFFFFFFFFFFFFFFF8 | v6[1] & 7;
        int v15 = (unint64_t *)v6[2];
        if (v15) {
          *int v15 = *v15 & 7 | (unint64_t)(v6 + 2);
        }
        uint64_t v9 = v33;
      }
    }
    void v6[4] = v34;
    if (v9 != -8192 && v9 != -4096 && v9 != 0) {
      llvm::ValueHandleBase::RemoveFromUseList(v32);
    }
    int32x2_t result = vadd_s32(v1[5], (int32x2_t)0x1FFFFFFFFLL);
    void v1[5] = result;
  }
  return result;
}

uint64_t llvm::AssumptionCacheTracker::getAssumptionCache(llvm::AssumptionCacheTracker *this, llvm::Function *a2)
{
  uint64_t v4 = *((void *)this + 4);
  unsigned int v5 = *((_DWORD *)this + 12);
  if (v5)
  {
    unsigned int v6 = (v5 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v7 = v4 + 48 * v6;
    uint64_t v8 = *(llvm::Function **)(v7 + 24);
    if (v8 == a2) {
      goto LABEL_3;
    }
    int v12 = 1;
    while (v8 != (llvm::Function *)-4096)
    {
      unsigned int v13 = v6 + v12++;
      unsigned int v6 = v13 & (v5 - 1);
      uint64_t v7 = v4 + 48 * v6;
      uint64_t v8 = *(llvm::Function **)(v7 + 24);
      if (v8 == a2) {
        goto LABEL_3;
      }
    }
  }
  uint64_t v7 = v4 + 48 * v5;
LABEL_3:
  if (v7 == v4 + 48 * v5)
  {
    uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*((void *)this + 1) + 24), &llvm::TargetTransformInfoWrapperPass::ID, 1);
    if (AnalysisPass)
    {
      uint64_t v11 = (llvm::TargetTransformInfoWrapperPass *)(*(uint64_t (**)(uint64_t, void *))(*(void *)AnalysisPass
                                                                                               + 96))(AnalysisPass, &llvm::TargetTransformInfoWrapperPass::ID);
      if (v11) {
        llvm::TargetTransformInfoWrapperPass::getTTI(v11, (const Function *)a2);
      }
    }
    v14[0] = 2;
    v14[1] = 0;
    v14[2] = a2;
    if (a2 != (llvm::Function *)-8192 && a2 != (llvm::Function *)-4096 && a2) {
      llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)v14);
    }
    v14[3] = this;
    operator new();
  }
  return *(void *)(v7 + 40);
}

void llvm::AssumptionCacheTracker::verifyAnalysis(llvm::AssumptionCacheTracker *this)
{
  if (!byte_1EBCC3B60) {
    return;
  }
  uint64_t v48 = v52;
  uint64_t v49 = v52;
  uint64_t v50 = 4;
  int v51 = 0;
  uint64_t v2 = sub_1CD45BC94((uint64_t *)this + 4);
  uint64_t v4 = *((void *)this + 4) + 48 * *((unsigned int *)this + 12);
  if (v4 == v2) {
    return;
  }
  uint64_t v5 = v2;
  uint64_t v6 = v3;
  do
  {
    uint64_t v7 = *(void *)(v5 + 40);
    if (!*(unsigned char *)(v7 + 184)) {
      llvm::AssumptionCache::scanFunction(*(llvm::AssumptionCache **)(v5 + 40));
    }
    uint64_t v8 = *(unsigned int *)(v7 + 24);
    if (v8)
    {
      uint64_t v9 = *(void *)(v7 + 16);
      uint64_t v10 = v9 + 32 * v8;
      do
      {
        uint64_t v11 = *(void *)(v9 + 16);
        if (v11)
        {
          int v12 = v49;
          uint64_t v13 = HIDWORD(v50);
          if (v49 != v48)
          {
            unsigned int v17 = v50;
LABEL_21:
            if (3 * v17 <= 4 * (HIDWORD(v50) - v51))
            {
              if (v17 >= 0x40) {
                v17 *= 2;
              }
              else {
                unsigned int v17 = 128;
              }
            }
            else if (v17 - HIDWORD(v50) >= v17 >> 3)
            {
              goto LABEL_23;
            }
            llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v48, v17);
            unsigned int v17 = v50;
            int v12 = v49;
LABEL_23:
            unsigned int v18 = v17 - 1;
            unsigned int v19 = (v17 - 1) & ((v11 >> 4) ^ (v11 >> 9));
            uint64_t v20 = &v12[8 * v19];
            uint64_t v21 = *(void *)v20;
            if (*(void *)v20 == -1)
            {
              uint64_t v22 = 0;
LABEL_35:
              if (v22) {
                uint64_t v26 = v22;
              }
              else {
                uint64_t v26 = v20;
              }
              if (*(void *)v26 != v11)
              {
                if (*(void *)v26 == -2) {
                  --v51;
                }
                else {
                  ++HIDWORD(v50);
                }
                *(void *)uint64_t v26 = v11;
              }
            }
            else
            {
              uint64_t v22 = 0;
              int v23 = 1;
              while (v21 != v11)
              {
                if (v22) {
                  BOOL v24 = 0;
                }
                else {
                  BOOL v24 = v21 == -2;
                }
                if (v24) {
                  uint64_t v22 = v20;
                }
                unsigned int v25 = v19 + v23++;
                unsigned int v19 = v25 & v18;
                uint64_t v20 = &v12[8 * (v25 & v18)];
                uint64_t v21 = *(void *)v20;
                if (*(void *)v20 == -1) {
                  goto LABEL_35;
                }
              }
            }
            goto LABEL_42;
          }
          if (HIDWORD(v50))
          {
            int v14 = 0;
            uint64_t v15 = 8 * HIDWORD(v50);
            uint64_t v16 = v49;
            while (*v16 != v11)
            {
              if (*v16 == -2) {
                int v14 = v16;
              }
              ++v16;
              v15 -= 8;
              if (!v15)
              {
                if (!v14) {
                  goto LABEL_18;
                }
                *int v14 = v11;
                --v51;
                goto LABEL_42;
              }
            }
            goto LABEL_42;
          }
LABEL_18:
          unsigned int v17 = v50;
          if (HIDWORD(v50) >= v50) {
            goto LABEL_21;
          }
          ++HIDWORD(v50);
          *(void *)&v49[8 * v13] = v11;
        }
LABEL_42:
        v9 += 32;
      }
      while (v9 != v10);
    }
    uint64_t v27 = *(void *)(v5 + 24);
    uint64_t v28 = v27 + 72;
    uint64_t v29 = *(void *)(v27 + 80);
    if (v29 != v28)
    {
      int v30 = v50 - 1;
      do
      {
        if (v29) {
          uint64_t v31 = v29 - 24;
        }
        else {
          uint64_t v31 = 0;
        }
        uint64_t v32 = v31 + 40;
        for (uint64_t i = *(void *)(v31 + 48); i != v32; uint64_t i = *(void *)(i + 8))
        {
          uint64_t v34 = i - 24;
          if (i)
          {
            if (*(unsigned char *)(i - 8) == 84)
            {
              uint64_t v35 = *(void *)(i - 56);
              if (v35)
              {
                if (!*(unsigned char *)(v35 + 16) && *(void *)(v35 + 24) == *(void *)(i + 48) && *(_DWORD *)(v35 + 36) == 7)
                {
                  if (v49 == v48)
                  {
                    if (HIDWORD(v50))
                    {
                      uint64_t v36 = 0;
                      while (*(void *)&v49[v36] != v34)
                      {
                        v36 += 8;
                        if (8 * HIDWORD(v50) == v36)
                        {
                          int v37 = HIDWORD(v50);
                          goto LABEL_83;
                        }
                      }
                      uint64_t v46 = &v49[v36];
                      int v37 = HIDWORD(v50);
                      uint64_t v47 = v49;
                    }
                    else
                    {
                      int v37 = 0;
LABEL_83:
                      uint64_t v47 = v49;
                      uint64_t v46 = &v49[8 * HIDWORD(v50)];
                    }
                  }
                  else
                  {
                    unsigned int v38 = v30 & ((v34 >> 4) ^ (v34 >> 9));
                    uint64_t v39 = &v49[8 * v38];
                    uint64_t v40 = *(void *)v39;
                    if (*(void *)v39 == -1)
                    {
                      int v41 = 0;
LABEL_85:
                      if (v41) {
                        uint64_t v39 = v41;
                      }
                      uint64_t v45 = *(void *)v39;
                    }
                    else
                    {
                      int v41 = 0;
                      int v42 = 1;
                      while (v40 != v34)
                      {
                        if (v41) {
                          BOOL v43 = 0;
                        }
                        else {
                          BOOL v43 = v40 == -2;
                        }
                        if (v43) {
                          int v41 = v39;
                        }
                        unsigned int v44 = v38 + v42++;
                        unsigned int v38 = v44 & v30;
                        uint64_t v39 = &v49[8 * (v44 & v30)];
                        uint64_t v40 = *(void *)v39;
                        if (*(void *)v39 == -1) {
                          goto LABEL_85;
                        }
                      }
                      uint64_t v45 = i - 24;
                    }
                    if (v45 == v34) {
                      uint64_t v46 = v39;
                    }
                    else {
                      uint64_t v46 = &v49[8 * v50];
                    }
                    int v37 = HIDWORD(v50);
                    uint64_t v47 = v48;
                  }
                  if (v49 != v47) {
                    int v37 = v50;
                  }
                  if (v46 == &v49[8 * v37]) {
                    llvm::report_fatal_error((llvm *)"Assumption in scanned function not in cache", (const llvm::Twine *)1);
                  }
                }
              }
            }
          }
        }
        uint64_t v29 = *(void *)(v29 + 8);
      }
      while (v29 != v28);
    }
    while (1)
    {
      v5 += 48;
      if (v5 == v6) {
        break;
      }
      if ((*(void *)(v5 + 24) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        goto LABEL_101;
      }
    }
    uint64_t v5 = v6;
LABEL_101:
    ;
  }
  while (v5 != v4);
  if (v49 != v48) {
    free(v49);
  }
}

void llvm::initializeAssumptionCacheTrackerPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC3BA0, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CBF677BC;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC3BA0, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::AssumptionCacheTracker::~AssumptionCacheTracker(llvm::AssumptionCacheTracker *this)
{
  *(void *)this = &unk_1F2600BF0;
  sub_1CBF68C24((uint64_t)this + 32);
  MEMORY[0x1D25D9CD0](*((void *)this + 4), 8);

  llvm::Pass::~Pass(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F2600BF0;
  sub_1CBF68C24((uint64_t)this + 32);
  MEMORY[0x1D25D9CD0](*((void *)this + 4), 8);

  llvm::Pass::~Pass(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F2600BF0;
  sub_1CBF68C24((uint64_t)this + 32);
  MEMORY[0x1D25D9CD0](*((void *)this + 4), 8);
  llvm::Pass::~Pass(this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CBF677BC()
{
}

uint64_t sub_1CBF6785C(uint64_t a1)
{
  return 0;
}

void sub_1CBF67898(uint64_t a1)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 120))(a1);
  uint64_t v2 = (void *)(a1 + 32);
  int v3 = *(_DWORD *)(a1 + 40);
  sub_1CBF68C24(a1 + 32);
  int v4 = 1 << (33 - __clz(v3 - 1));
  if (v4 <= 64) {
    int v4 = 64;
  }
  if (v3) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v5 == *(_DWORD *)(a1 + 48))
  {
    *(void *)(a1 + 40) = 0;
    v19[0] = 2;
    v19[1] = 0;
    uint64_t v20 = -4096;
    uint64_t v21 = 0;
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = 48 * v5;
      uint64_t v8 = (void *)(v6 + 16);
      do
      {
        uint64_t v9 = v19[0] & 6;
        *(v8 - 1) = v9;
        *uint64_t v8 = 0;
        uint64_t v10 = v20;
        v8[1] = v20;
        if (v10 != -4096 && v10 != -8192 && v10 != 0)
        {
          unint64_t v18 = v19[0] & 0xFFFFFFFFFFFFFFF8;
          *uint64_t v8 = *(void *)(v19[0] & 0xFFFFFFFFFFFFFFF8);
          *(void *)unint64_t v18 = v8 - 1;
          *(v8 - 1) = v18 | v9;
          if (*v8) {
            *(void *)*uint64_t v8 = *(void *)*v8 & 7 | (v6 + 16);
          }
        }
        *(v8 - 2) = off_1F2600CC0;
        v8[2] = v21;
        v8 += 6;
        v6 += 48;
        v7 -= 48;
      }
      while (v7);
      if (v20 != -8192 && v20 != -4096)
      {
        if (v20) {
          llvm::ValueHandleBase::RemoveFromUseList(v19);
        }
      }
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*v2, 8);
    if (v5)
    {
      unint64_t v11 = (4 * (int)v5 / 3u + 1) | ((unint64_t)(4 * (int)v5 / 3u + 1) >> 1);
      unint64_t v12 = v11 | (v11 >> 2) | ((v11 | (v11 >> 2)) >> 4);
      LODWORD(v12) = (((v12 | (v12 >> 8)) >> 16) | v12 | (v12 >> 8)) + 1;
      *(_DWORD *)(a1 + ++*(_DWORD *)(result + 48) = v12;
      uint64_t v13 = (char *)operator new(48 * v12, (std::align_val_t)8uLL);
      *(void *)(a1 + 32) = v13;
      *(void *)(a1 + 40) = 0;
      uint64_t v14 = *(unsigned int *)(a1 + 48);
      if (v14)
      {
        uint64_t v15 = 48 * v14;
        uint64_t v16 = v13 + 16;
        do
        {
          *(v16 - 1) = 2;
          *uint64_t v16 = 0;
          v16[1] = -4096;
          _WORD v16[2] = 0;
          *(v16 - 2) = off_1F2600CC0;
          v16 += 6;
          v13 += 48;
          v15 -= 48;
        }
        while (v15);
      }
    }
    else
    {
      *uint64_t v2 = 0;
      *(void *)(a1 + 40) = 0;
      *(_DWORD *)(a1 + ++*(_DWORD *)(result + 48) = 0;
    }
  }
}

uint64_t sub_1CBF67AFC(uint64_t result, uint64_t *a2)
{
  if ((uint64_t *)result != a2)
  {
    if ((uint64_t *)*a2 == a2 + 2)
    {
      unint64_t v2 = *((unsigned int *)a2 + 2);
      uint64_t v3 = *(unsigned int *)(result + 8);
      if (v3 >= v2)
      {
        uint64_t v57 = *((unsigned int *)a2 + 2);
        unint64_t v59 = a2;
        uint64_t v56 = result;
        uint64_t v32 = *(char **)result;
        if (v2)
        {
          uint64_t v33 = (char *)*a2;
          uint64_t v34 = 0;
          do
          {
            uint64_t v35 = &v33[v34];
            sub_1CBF62D84((unint64_t *)&v32[v34], (uint64_t *)&v33[v34]);
            *(_DWORD *)&v32[v34 + 24] = *(_DWORD *)&v33[v34 + 24];
            v34 += 32;
          }
          while (v35 + 32 != &v33[32 * v57]);
          uint64_t v3 = *(unsigned int *)(v56 + 8);
          uint64_t v36 = &v32[v34];
          uint64_t v32 = *(char **)v56;
        }
        else
        {
          uint64_t v36 = *(char **)result;
        }
        int v37 = &v32[32 * v3];
        while (v37 != v36)
        {
          uint64_t v38 = *((void *)v37 - 2);
          v37 -= 32;
          if (v38 != -8192 && v38 != -4096 && v38 != 0) {
            llvm::ValueHandleBase::RemoveFromUseList(v37);
          }
        }
        *(_DWORD *)(v56 + 8) = v57;
        uint64_t v51 = *((unsigned int *)v59 + 2);
        if (v51)
        {
          uint64_t v52 = *v59;
          uint64_t v53 = 32 * v51;
          do
          {
            uint64_t v54 = *(void *)(v52 + v53 - 16);
            if (v54 != -8192 && v54 != -4096 && v54 != 0) {
              llvm::ValueHandleBase::RemoveFromUseList((void *)(v52 + v53 - 32));
            }
            v53 -= 32;
          }
          while (v53);
        }
        *((_DWORD *)v59 + 2) = 0;
        return v56;
      }
      else
      {
        if (*(_DWORD *)(result + 12) < v2)
        {
          unint64_t v60 = a2;
          uint64_t v40 = result;
          if (v3)
          {
            int v41 = *(char **)result;
            uint64_t v42 = 32 * v3;
            do
            {
              uint64_t v43 = *(void *)&v41[v42 - 16];
              if (v43 != -8192 && v43 != -4096 && v43 != 0) {
                llvm::ValueHandleBase::RemoveFromUseList(&v41[v42 - 32]);
              }
              v42 -= 32;
            }
            while (v42);
          }
          *(_DWORD *)(v40 + 8) = 0;
          sub_1CBF67EE8(v40, v2);
          int32x2_t result = v40;
          uint64_t v4 = 0;
          a2 = v60;
        }
        else if (v3)
        {
          int v58 = *((_DWORD *)a2 + 2);
          uint64_t v45 = a2;
          uint64_t v46 = (uint64_t *)*a2;
          uint64_t v4 = *(unsigned int *)(result + 8);
          uint64_t v47 = *a2 + 32 * v3;
          uint64_t v48 = result;
          uint64_t v49 = *(char **)result;
          do
          {
            uint64_t v50 = v46;
            sub_1CBF62D84((unint64_t *)v49, v46);
            *((_DWORD *)v49 + 6) = *((_DWORD *)v50 + 6);
            v49 += 32;
            uint64_t v46 = v50 + 4;
          }
          while (v50 + 4 != (uint64_t *)v47);
          int32x2_t result = v48;
          a2 = v45;
          LODWORD(v2) = v58;
        }
        else
        {
          uint64_t v4 = 0;
        }
        uint64_t v5 = (char *)*a2;
        uint64_t v6 = *((unsigned int *)a2 + 2);
        if (v4 != v6)
        {
          uint64_t v7 = *(char **)result;
          uint64_t v8 = 32 * v4;
          uint64_t v9 = *(void *)result + 8;
          uint64_t v10 = 32 * v6;
          do
          {
            unint64_t v11 = &v7[v8];
            *(void *)unint64_t v11 = 4;
            *((void *)v11 + 1) = 0;
            uint64_t v12 = *(void *)&v5[v8 + 16];
            *((void *)v11 + 2) = v12;
            if (v12)
            {
              if (v12 != -8192 && v12 != -4096)
              {
                unint64_t v13 = *(void *)&v5[32 * v4] & 0xFFFFFFFFFFFFFFF8;
                *((void *)v11 + 1) = *(void *)v13;
                *(void *)unint64_t v13 = v11;
                *(void *)unint64_t v11 = v13 | 4;
                uint64_t v14 = (uint64_t *)*((void *)v11 + 1);
                if (v14) {
                  *uint64_t v14 = *v14 & 7 | (v8 + v9);
                }
              }
            }
            *((_DWORD *)v11 + 6) = *(_DWORD *)&v5[v8 + 24];
            v7 += 32;
            v5 += 32;
            v9 += 32;
            v10 -= 32;
          }
          while (v8 != v10);
          uint64_t v5 = (char *)*a2;
        }
        *(_DWORD *)(result + 8) = v2;
        uint64_t v15 = *((unsigned int *)a2 + 2);
        if (v15)
        {
          uint64_t v16 = &v5[32 * v15];
          do
          {
            uint64_t v17 = *((void *)v16 - 2);
            if (v17 != -8192 && v17 != -4096 && v17 != 0)
            {
              unint64_t v19 = *((void *)v16 - 4) & 0xFFFFFFFFFFFFFFF8;
              *(void *)unint64_t v19 = *((void *)v16 - 3);
              uint64_t v20 = (unint64_t *)*((void *)v16 - 3);
              if (v20)
              {
                *uint64_t v20 = *v20 & 7 | v19;
              }
              else
              {
                uint64_t v21 = *((void *)v16 - 2);
                uint64_t v22 = ***(int32x2_t ****)v21;
                unint64_t v23 = (unint64_t)v22[303];
                if (v23 <= v19)
                {
                  uint64_t v24 = v22[305].u32[0];
                  if (v23 + 16 * v24 > v19)
                  {
                    unsigned int v25 = v24 - 1;
                    LODWORD(v26) = v25 & ((v21 >> 4) ^ (v21 >> 9));
                    uint64_t v27 = (uint64_t *)(v23 + 16 * v26);
                    uint64_t v28 = *v27;
                    if (v21 == *v27)
                    {
LABEL_36:
                      *uint64_t v27 = -8192;
                      v22[304] = vadd_s32(v22[304], (int32x2_t)0x1FFFFFFFFLL);
                      uint64_t v21 = *((void *)v16 - 2);
                    }
                    else
                    {
                      int v29 = 1;
                      while (v28 != -4096)
                      {
                        int v30 = v26 + v29++;
                        uint64_t v26 = v30 & v25;
                        uint64_t v28 = *(void *)(v23 + 16 * v26);
                        if (v21 == v28)
                        {
                          uint64_t v27 = (uint64_t *)(v23 + 16 * v26);
                          goto LABEL_36;
                        }
                      }
                    }
                    *(unsigned char *)(v21 + 17) &= ~1u;
                  }
                }
              }
            }
            v16 -= 32;
          }
          while (v16 != v5);
        }
        *((_DWORD *)a2 + 2) = 0;
      }
    }
    else
    {
      uint64_t v31 = result;
      sub_1CD45BE74((char **)result, (char **)a2);
      return v31;
    }
  }
  return result;
}

void sub_1CBF67EE8(uint64_t a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  uint64_t v6 = malloc_type_malloc(32 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v7 = v6;
  sub_1CBF67FA4((uint64_t *)a1, (uint64_t)v6);
  if (*(void *)a1 != a1 + 16) {
    free(*(void **)a1);
  }
  *(void *)a1 = v7;
  *(_DWORD *)(a1 + 12) = v5;
}

uint64_t *sub_1CBF67FA4(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *((unsigned int *)result + 2);
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *result;
    do
    {
      uint64_t v5 = a2 + v3;
      *(void *)uint64_t v5 = 4;
      *(void *)(v5 + 8) = 0;
      uint64_t v6 = *(void *)(v4 + v3 + 16);
      *(void *)(v5 + 16) = v6;
      if (v6)
      {
        if (v6 != -8192 && v6 != -4096)
        {
          unint64_t v7 = *(void *)(v4 + v3) & 0xFFFFFFFFFFFFFFF8;
          *(void *)(v5 + 8) = *(void *)v7;
          *(void *)unint64_t v7 = v5;
          *(void *)uint64_t v5 = v7 | 4;
          uint64_t v8 = *(uint64_t **)(v5 + 8);
          if (v8) {
            *uint64_t v8 = *v8 & 7 | (a2 + 8 + v3);
          }
        }
      }
      *(_DWORD *)(v5 + 24) = *(_DWORD *)(v4 + v3 + 24);
      v3 += 32;
    }
    while (32 * v2 != v3);
    uint64_t v9 = *result;
    uint64_t v10 = *result + 32 * v2;
    do
    {
      uint64_t v11 = *(void *)(v10 - 16);
      if (v11 && v11 != -8192 && v11 != -4096)
      {
        unint64_t v12 = *(void *)(v10 - 32) & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v12 = *(void *)(v10 - 24);
        unint64_t v13 = *(unint64_t **)(v10 - 24);
        if (v13)
        {
          *unint64_t v13 = *v13 & 7 | v12;
        }
        else
        {
          uint64_t v14 = *(void *)(v10 - 16);
          uint64_t v15 = ***(int32x2_t ****)v14;
          unint64_t v16 = (unint64_t)v15[303];
          if (v16 <= v12)
          {
            uint64_t v17 = v15[305].u32[0];
            if (v16 + 16 * v17 > v12)
            {
              unsigned int v18 = v17 - 1;
              LODWORD(v19) = v18 & ((v14 >> 4) ^ (v14 >> 9));
              uint64_t v20 = (uint64_t *)(v16 + 16 * v19);
              uint64_t v21 = *v20;
              if (v14 == *v20)
              {
LABEL_21:
                *uint64_t v20 = -8192;
                v15[304] = vadd_s32(v15[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v14 = *(void *)(v10 - 16);
              }
              else
              {
                int v22 = 1;
                while (v21 != -4096)
                {
                  int v23 = v19 + v22++;
                  uint64_t v19 = v23 & v18;
                  uint64_t v21 = *(void *)(v16 + 16 * v19);
                  if (v14 == v21)
                  {
                    uint64_t v20 = (uint64_t *)(v16 + 16 * v19);
                    goto LABEL_21;
                  }
                }
              }
              *(unsigned char *)(v14 + 17) &= ~1u;
            }
          }
        }
      }
      v10 -= 32;
    }
    while (v10 != v9);
  }
  return result;
}

void sub_1CBF68130(uint64_t *a1, uint64_t a2, int a3)
{
  unsigned int v6 = *(unsigned __int8 *)(a2 + 16);
  if (v6 == 21)
  {
    uint64_t v7 = *a1;
    unint64_t v49 = 4;
    uint64_t v50 = 0;
    uint64_t v51 = (int32x2_t ****)a2;
    if (a2 != -8192 && a2 != -4096 && a2) {
      llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v49);
    }
    int v52 = a3;
    sub_1CBF65FA4(v7, (unint64_t)&v49);
    if (v51 == (int32x2_t ****)-8192 || v51 == (int32x2_t ****)-4096 || !v51) {
      return;
    }
    unint64_t v8 = v49 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v49 & 0xFFFFFFFFFFFFFFF8) = v50;
    uint64_t v9 = v50;
    if (!v50)
    {
      uint64_t v10 = v51;
      uint64_t v11 = ***v51;
      unint64_t v12 = (unint64_t)v11[303];
      if (v12 <= v8)
      {
        uint64_t v13 = v11[305].u32[0];
        if (v12 + 16 * v13 > v8)
        {
          unsigned int v14 = v13 - 1;
          LODWORD(v15) = v14 & ((v51 >> 4) ^ (v51 >> 9));
          unint64_t v16 = (int32x2_t *****)(v12 + 16 * v15);
          uint64_t v17 = *v16;
          if (v51 != *v16)
          {
            int v18 = 1;
            while (v17 != (int32x2_t ****)-4096)
            {
              int v19 = v15 + v18++;
              uint64_t v15 = v19 & v14;
              uint64_t v17 = *(int32x2_t *****)(v12 + 16 * v15);
              if (v51 == v17) {
                goto LABEL_16;
              }
            }
            goto LABEL_18;
          }
LABEL_17:
          *unint64_t v16 = (int32x2_t ****)-8192;
          v11[304] = vadd_s32(v11[304], (int32x2_t)0x1FFFFFFFFLL);
          uint64_t v10 = v51;
LABEL_18:
          *((unsigned char *)v10 + 17) &= ~1u;
          return;
        }
      }
      return;
    }
LABEL_73:
    *uint64_t v9 = *v9 & 7 | v8;
    return;
  }
  if (v6 < 0x1C) {
    return;
  }
  uint64_t v20 = *a1;
  unint64_t v49 = 4;
  uint64_t v50 = 0;
  uint64_t v51 = (int32x2_t ****)a2;
  if ((a2 | 0x1000) != 0xFFFFFFFFFFFFF000) {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v49);
  }
  int v52 = a3;
  sub_1CBF65FA4(v20, (unint64_t)&v49);
  if (v51 != (int32x2_t ****)-8192 && v51 != (int32x2_t ****)-4096 && v51)
  {
    unint64_t v21 = v49 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v49 & 0xFFFFFFFFFFFFFFF8) = v50;
    if (v50)
    {
      *uint64_t v50 = *v50 & 7 | v21;
    }
    else
    {
      int v22 = v51;
      int v23 = ***v51;
      unint64_t v24 = (unint64_t)v23[303];
      if (v24 <= v21)
      {
        uint64_t v25 = v23[305].u32[0];
        if (v24 + 16 * v25 > v21)
        {
          unsigned int v26 = v25 - 1;
          LODWORD(v27) = v26 & ((v51 >> 4) ^ (v51 >> 9));
          uint64_t v28 = (int32x2_t *****)(v24 + 16 * v27);
          int v29 = *v28;
          if (v51 == *v28)
          {
LABEL_33:
            *uint64_t v28 = (int32x2_t ****)-8192;
            v23[304] = vadd_s32(v23[304], (int32x2_t)0x1FFFFFFFFLL);
            int v22 = v51;
          }
          else
          {
            int v30 = 1;
            while (v29 != (int32x2_t ****)-4096)
            {
              int v31 = v27 + v30++;
              uint64_t v27 = v31 & v26;
              int v29 = *(int32x2_t *****)(v24 + 16 * v27);
              if (v51 == v29)
              {
                uint64_t v28 = (int32x2_t *****)(v24 + 16 * v27);
                goto LABEL_33;
              }
            }
          }
          *((unsigned char *)v22 + 17) &= ~1u;
        }
      }
    }
  }
  uint64_t v48 = 0;
  unsigned int v32 = *(unsigned __int8 *)(a2 + 16);
  unsigned int v33 = v32 - 28;
  unsigned int v34 = v32 - 28;
  if (v32 <= 0x1B) {
    unsigned int v34 = *(unsigned __int16 *)(a2 + 18);
  }
  if (v34 == 49)
  {
    int v35 = *(_DWORD *)(a2 + 20);
    uint64_t v36 = (v35 & 0x40000000) != 0 ? *(uint64_t **)(a2 - 8) : (uint64_t *)(a2 - 32 * (v35 & 0x7FFFFFF));
    uint64_t v37 = *v36;
    if (v37) {
      goto LABEL_50;
    }
  }
  if (v32 <= 0x1B) {
    unsigned int v33 = *(unsigned __int16 *)(a2 + 18);
  }
  if (v33 == 47
    && ((int v38 = *(_DWORD *)(a2 + 20), (v38 & 0x40000000) != 0)
      ? (uint64_t v39 = *(uint64_t **)(a2 - 8))
      : (uint64_t v39 = (uint64_t *)(a2 - 32 * (v38 & 0x7FFFFFF))),
        (uint64_t v37 = *v39) != 0))
  {
LABEL_50:
    uint64_t v48 = v37;
  }
  else
  {
    unint64_t v49 = (unint64_t)&v48;
    if (!sub_1CBF686A0((void **)&v49, 30, a2)) {
      return;
    }
    uint64_t v37 = v48;
  }
  unsigned int v40 = *(unsigned __int8 *)(v37 + 16);
  if (v40 > 0x1B || v40 == 21)
  {
    uint64_t v42 = *a1;
    unint64_t v49 = 4;
    uint64_t v50 = 0;
    uint64_t v51 = (int32x2_t ****)v37;
    if (v37 != -8192 && v37 != -4096 && v37) {
      llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v49);
    }
    int v52 = a3;
    sub_1CBF65FA4(v42, (unint64_t)&v49);
    if (v51 != (int32x2_t ****)-8192 && v51 != (int32x2_t ****)-4096 && v51)
    {
      unint64_t v8 = v49 & 0xFFFFFFFFFFFFFFF8;
      *(void *)(v49 & 0xFFFFFFFFFFFFFFF8) = v50;
      uint64_t v9 = v50;
      if (v50) {
        goto LABEL_73;
      }
      uint64_t v10 = v51;
      uint64_t v11 = ***v51;
      unint64_t v12 = (unint64_t)v11[303];
      if (v12 <= v8)
      {
        uint64_t v43 = v11[305].u32[0];
        if (v12 + 16 * v43 > v8)
        {
          unsigned int v44 = v43 - 1;
          LODWORD(v15) = v44 & ((v51 >> 4) ^ (v51 >> 9));
          unint64_t v16 = (int32x2_t *****)(v12 + 16 * v15);
          uint64_t v45 = *v16;
          if (v51 != *v16)
          {
            int v46 = 1;
            while (v45 != (int32x2_t ****)-4096)
            {
              int v47 = v15 + v46++;
              uint64_t v15 = v47 & v44;
              uint64_t v45 = *(int32x2_t *****)(v12 + 16 * v15);
              if (v51 == v45)
              {
LABEL_16:
                unint64_t v16 = (int32x2_t *****)(v12 + 16 * v15);
                goto LABEL_17;
              }
            }
            goto LABEL_18;
          }
          goto LABEL_17;
        }
      }
    }
  }
}

void sub_1CBF68544(uint64_t **a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v15 = 0;
  unsigned int v14 = &v15;
  if (sub_1CBF686A0(&v14, 30, a2))
  {
    sub_1CBF68130(*a1, v15, -1);
    uint64_t v2 = v15;
  }
  unsigned int v4 = *(unsigned __int8 *)(v2 + 16);
  if (!v2 || v4 < 0x1C)
  {
    if (v4 != 5) {
      return;
    }
    int v9 = *(unsigned __int16 *)(v2 + 18);
    if ((v9 - 28) <= 2)
    {
      int v5 = *(_DWORD *)(v2 + 20);
      goto LABEL_12;
    }
    if ((v9 - 25) > 2) {
      return;
    }
    int v11 = *(_DWORD *)(v2 + 20);
    goto LABEL_22;
  }
  if (v4 - 56 > 2)
  {
    if (v4 - 53 > 2) {
      return;
    }
    int v11 = *(_DWORD *)(v2 + 20);
    if ((v11 & 0x40000000) != 0)
    {
      unint64_t v12 = *(uint64_t **)(v2 - 8);
      uint64_t v10 = *v12;
      if (!*v12) {
        return;
      }
      uint64_t v15 = *v12;
      uint64_t v13 = *(uint64_t **)(v2 - 8);
      goto LABEL_24;
    }
LABEL_22:
    uint64_t v13 = (uint64_t *)(v2 - 32 * (v11 & 0x7FFFFFF));
    uint64_t v10 = *v13;
    if (!*v13) {
      return;
    }
    uint64_t v15 = *v13;
LABEL_24:
    if (*(unsigned char *)(v13[4] + 16) != 16) {
      return;
    }
    goto LABEL_25;
  }
  int v5 = *(_DWORD *)(v2 + 20);
  if ((v5 & 0x40000000) == 0)
  {
LABEL_12:
    unint64_t v8 = (uint64_t *)(v2 - 32 * (v5 & 0x7FFFFFF));
    uint64_t v7 = *v8;
    if (!*v8) {
      return;
    }
    uint64_t v15 = *v8;
    goto LABEL_14;
  }
  unsigned int v6 = *(uint64_t **)(v2 - 8);
  uint64_t v7 = *v6;
  if (!*v6) {
    return;
  }
  uint64_t v15 = *v6;
  unint64_t v8 = *(uint64_t **)(v2 - 8);
LABEL_14:
  uint64_t v10 = v8[4];
  if (!v10) {
    return;
  }
  sub_1CBF68130(*a1, v7, -1);
LABEL_25:
  sub_1CBF68130(*a1, v10, -1);
}

uint64_t sub_1CBF686A0(void **a1, int a2, uint64_t a3)
{
  int v5 = *(unsigned __int8 *)(a3 + 16);
  if (a2 + 28 == v5)
  {
    uint64_t v6 = *(void *)(a3 - 64);
    if (!v6 || (**a1 = v6, (sub_1CBF687D0((uint64_t)(a1 + 1), *(llvm::Constant **)(a3 - 32)) & 1) == 0))
    {
      uint64_t v7 = *(void *)(a3 - 32);
      if (v7)
      {
        **a1 = v7;
        unint64_t v8 = *(llvm::Constant **)(a3 - 64);
        return sub_1CBF687D0((uint64_t)(a1 + 1), v8);
      }
      return 0;
    }
    return 1;
  }
  if (v5 != 5 || *(unsigned __int16 *)(a3 + 18) != a2) {
    return 0;
  }
  uint64_t v10 = *(_DWORD *)(a3 + 20) & 0x7FFFFFF;
  uint64_t v11 = *(void *)(a3 - 32 * v10);
  if (v11)
  {
    **a1 = v11;
    if (sub_1CBF68974((uint64_t)(a1 + 1), *(llvm::Constant **)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF) + 32))) {
      return 1;
    }
    uint64_t v10 = *(_DWORD *)(a3 + 20) & 0x7FFFFFF;
  }
  uint64_t v12 = *(void *)(a3 - 32 * v10 + 32);
  if (!v12) {
    return 0;
  }
  **a1 = v12;
  uint64_t v13 = *(llvm::Constant **)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF));

  return sub_1CBF68974((uint64_t)(a1 + 1), v13);
}

uint64_t sub_1CBF687D0(uint64_t a1, llvm::Constant *a2)
{
  unsigned int v4 = *((unsigned __int8 *)a2 + 16);
  if (a2 && v4 == 16)
  {
    unsigned int v5 = *((_DWORD *)a2 + 8);
    if (v5)
    {
      uint64_t v6 = (llvm::Constant *)((char *)a2 + 24);
      if (v5 > 0x40) {
        return llvm::APInt::countTrailingOnesSlowCase(v6) == v5;
      }
      else {
        return *(void *)v6 == 0xFFFFFFFFFFFFFFFFLL >> -(char)v5;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    uint64_t v8 = *(void *)a2;
    if (*(void *)a2) {
      BOOL v9 = (*(_DWORD *)(*(void *)a2 + 8) & 0xFE) == 18;
    }
    else {
      BOOL v9 = 0;
    }
    BOOL v10 = !v9 || v4 > 0x14;
    int v11 = v10;
    if (!v10)
    {
      SplatValue = llvm::Constant::getSplatValue(a2, 0);
      if (SplatValue && *((unsigned char *)SplatValue + 16) == 16)
      {
        unsigned int v13 = SplatValue[8];
        if (v13)
        {
          unsigned int v14 = (llvm::APInt *)(SplatValue + 6);
          if (v13 > 0x40) {
            BOOL v15 = llvm::APInt::countTrailingOnesSlowCase(v14) == v13;
          }
          else {
            BOOL v15 = *(void *)v14 == 0xFFFFFFFFFFFFFFFFLL >> -(char)v13;
          }
          int v2 = v15;
        }
        else
        {
          int v2 = 1;
        }
      }
      else
      {
        if (*(unsigned char *)(v8 + 8) == 18)
        {
          int v17 = *(_DWORD *)(v8 + 32);
          if (v17)
          {
            int v18 = 0;
            int v2 = 0;
            while (1)
            {
              AggregateElement = llvm::Constant::getAggregateElement(a2, v18);
              if (!AggregateElement) {
                break;
              }
              int v20 = *((unsigned __int8 *)AggregateElement + 16);
              if ((v20 - 11) >= 2)
              {
                if (v20 != 16) {
                  break;
                }
                unsigned int v21 = *((_DWORD *)AggregateElement + 8);
                if (v21)
                {
                  int v22 = (llvm::APInt *)(AggregateElement + 3);
                  if (v21 > 0x40)
                  {
                    if (llvm::APInt::countTrailingOnesSlowCase(v22) != v21) {
                      break;
                    }
                  }
                  else if (*(void *)v22 != 0xFFFFFFFFFFFFFFFFLL >> -(char)v21)
                  {
                    break;
                  }
                }
                int v2 = 1;
              }
              int v18 = (llvm::Type *)(v18 + 1);
              if (v17 == v18) {
                return (v11 ^ 1) & v2;
              }
            }
          }
        }
        int v2 = 0;
      }
    }
    return (v11 ^ 1) & v2;
  }
}

uint64_t sub_1CBF68974(uint64_t a1, llvm::Constant *a2)
{
  if (a2 && *((unsigned char *)a2 + 16) == 16)
  {
    uint64_t v3 = *((unsigned int *)a2 + 8);
    if (v3)
    {
      unsigned int v4 = (llvm::Constant *)((char *)a2 + 24);
      if (v3 <= 0x40)
      {
        uint64_t v5 = *(void *)v4;
        uint64_t v6 = -v3;
LABEL_6:
        BOOL v7 = v5 == 0xFFFFFFFFFFFFFFFFLL >> v6;
        goto LABEL_34;
      }
      BOOL v7 = llvm::APInt::countTrailingOnesSlowCase(v4) == v3;
      goto LABEL_34;
    }
LABEL_17:
    char v13 = 1;
    return v13 & 1;
  }
  uint64_t v8 = *(void *)a2;
  if (*(void *)a2) {
    BOOL v9 = (*(_DWORD *)(*(void *)a2 + 8) & 0xFE) == 18;
  }
  else {
    BOOL v9 = 0;
  }
  if (!v9)
  {
LABEL_32:
    char v13 = 0;
    return v13 & 1;
  }
  SplatValue = llvm::Constant::getSplatValue(a2, 0);
  if (!SplatValue || SplatValue[16] != 16)
  {
    if (*(unsigned char *)(v8 + 8) == 18)
    {
      int v14 = *(_DWORD *)(v8 + 32);
      if (v14)
      {
        BOOL v15 = 0;
        char v13 = 0;
        while (1)
        {
          AggregateElement = llvm::Constant::getAggregateElement(a2, v15);
          if (!AggregateElement) {
            break;
          }
          int v17 = *((unsigned __int8 *)AggregateElement + 16);
          if ((v17 - 11) >= 2)
          {
            if (v17 != 16) {
              goto LABEL_32;
            }
            unsigned int v18 = *((_DWORD *)AggregateElement + 8);
            if (v18)
            {
              int v19 = (llvm::APInt *)(AggregateElement + 3);
              if (v18 > 0x40)
              {
                if (llvm::APInt::countTrailingOnesSlowCase(v19) != v18) {
                  goto LABEL_32;
                }
              }
              else if (*(void *)v19 != 0xFFFFFFFFFFFFFFFFLL >> -(char)v18)
              {
                goto LABEL_32;
              }
            }
            char v13 = 1;
          }
          BOOL v15 = (llvm::Type *)(v15 + 1);
          if (v14 == v15) {
            return v13 & 1;
          }
        }
      }
    }
    goto LABEL_32;
  }
  uint64_t v11 = *((unsigned int *)SplatValue + 8);
  if (!v11) {
    goto LABEL_17;
  }
  uint64_t v12 = (llvm::APInt *)(SplatValue + 24);
  if (v11 <= 0x40)
  {
    uint64_t v5 = *(void *)v12;
    uint64_t v6 = -v11;
    goto LABEL_6;
  }
  BOOL v7 = llvm::APInt::countTrailingOnesSlowCase(v12) == v11;
LABEL_34:
  char v13 = v7;
  return v13 & 1;
}

void *sub_1CBF68AF4(void *result)
{
  result[1] = 0;
  v10[0] = 2;
  v10[1] = 0;
  uint64_t v11 = -4096;
  uint64_t v12 = 0;
  unsigned int v1 = *((_DWORD *)result + 4);
  if (v1)
  {
    int v2 = result;
    int32x2_t result = v10;
    uint64_t v3 = *v2;
    uint64_t v4 = 88 * v1;
    uint64_t v5 = (void *)(*v2 + 16);
    do
    {
      uint64_t v6 = v10[0] & 6;
      *(v5 - 1) = v6;
      *uint64_t v5 = 0;
      uint64_t v7 = v11;
      v5[1] = v11;
      if (v7 != -4096 && v7 != -8192 && v7 != 0)
      {
        unint64_t v9 = v10[0] & 0xFFFFFFFFFFFFFFF8;
        *uint64_t v5 = *(void *)(v10[0] & 0xFFFFFFFFFFFFFFF8);
        *(void *)unint64_t v9 = v5 - 1;
        *(v5 - 1) = v9 | v6;
        if (*v5) {
          *(void *)*uint64_t v5 = *(void *)*v5 & 7 | (v3 + 16);
        }
      }
      *(v5 - 2) = off_1F2600C98;
      void v5[2] = v12;
      v5 += 11;
      v3 += 88;
      v4 -= 88;
    }
    while (v4);
    if (v11 != -8192 && v11 != -4096)
    {
      if (v11) {
        return llvm::ValueHandleBase::RemoveFromUseList(v10);
      }
    }
  }
  return result;
}

void sub_1CBF68C24(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 16);
  if (v1)
  {
    v25[0] = 2;
    v25[1] = 0;
    uint64_t v26 = -4096;
    uint64_t v27 = 0;
    uint64_t v23 = 0;
    unint64_t v24 = off_1F2600CC0;
    v21[0] = 2;
    v21[1] = 0;
    uint64_t v22 = -8192;
    int v2 = *(void **)a1;
    uint64_t v3 = *(void *)a1 + 48 * v1;
    do
    {
      uint64_t v4 = v2[3];
      if (v4 != v26 && v4 != v22)
      {
        uint64_t v19 = v2[5];
        v2[5] = 0;
        if (v19)
        {
          sub_1CBF699D0((uint64_t)(v2 + 5), v19);
          uint64_t v4 = v2[3];
        }
      }
      if (v4 != -4096 && v4 != -8192 && v4 != 0)
      {
        unint64_t v7 = v2[1] & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v7 = v2[2];
        uint64_t v8 = (unint64_t *)v2[2];
        if (v8)
        {
          *uint64_t v8 = *v8 & 7 | v7;
        }
        else
        {
          uint64_t v9 = v2[3];
          BOOL v10 = ***(int32x2_t ****)v9;
          unint64_t v11 = (unint64_t)v10[303];
          if (v11 <= v7)
          {
            uint64_t v12 = v10[305].u32[0];
            if (v11 + 16 * v12 > v7)
            {
              unsigned int v13 = v12 - 1;
              LODWORD(v14) = v13 & ((v9 >> 4) ^ (v9 >> 9));
              BOOL v15 = (uint64_t *)(v11 + 16 * v14);
              uint64_t v16 = *v15;
              if (v9 == *v15)
              {
LABEL_33:
                *BOOL v15 = -8192;
                v10[304] = vadd_s32(v10[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v9 = v2[3];
              }
              else
              {
                int v17 = 1;
                while (v16 != -4096)
                {
                  int v18 = v14 + v17++;
                  uint64_t v14 = v18 & v13;
                  uint64_t v16 = *(void *)(v11 + 16 * v14);
                  if (v9 == v16)
                  {
                    BOOL v15 = (uint64_t *)(v11 + 16 * v14);
                    goto LABEL_33;
                  }
                }
              }
              *(unsigned char *)(v9 + 17) &= ~1u;
            }
          }
        }
      }
      v2 += 6;
    }
    while (v2 != (void *)v3);
    if (v22 != -8192 && v22 != -4096 && v22 != 0) {
      llvm::ValueHandleBase::RemoveFromUseList(v21);
    }
    if (v26 != -4096 && v26 != -8192)
    {
      if (v26) {
        llvm::ValueHandleBase::RemoveFromUseList(v25);
      }
    }
  }
}

void *sub_1CBF68E4C(void *result)
{
  result[1] = 0;
  v10[0] = 2;
  v10[1] = 0;
  uint64_t v11 = -4096;
  uint64_t v12 = 0;
  uint64_t v1 = *((unsigned int *)result + 4);
  if (v1)
  {
    int v2 = result;
    int32x2_t result = v10;
    uint64_t v3 = *v2;
    uint64_t v4 = 48 * v1;
    uint64_t v5 = (void *)(*v2 + 16);
    do
    {
      uint64_t v6 = v10[0] & 6;
      *(v5 - 1) = v6;
      *uint64_t v5 = 0;
      uint64_t v7 = v11;
      v5[1] = v11;
      if (v7 != -4096 && v7 != -8192 && v7 != 0)
      {
        unint64_t v9 = v10[0] & 0xFFFFFFFFFFFFFFF8;
        *uint64_t v5 = *(void *)(v10[0] & 0xFFFFFFFFFFFFFFF8);
        *(void *)unint64_t v9 = v5 - 1;
        *(v5 - 1) = v9 | v6;
        if (*v5) {
          *(void *)*uint64_t v5 = *(void *)*v5 & 7 | (v3 + 16);
        }
      }
      *(v5 - 2) = off_1F2600CC0;
      void v5[2] = v12;
      v5 += 6;
      v3 += 48;
      v4 -= 48;
    }
    while (v4);
    if (v11 != -8192 && v11 != -4096)
    {
      if (v11) {
        return llvm::ValueHandleBase::RemoveFromUseList(v10);
      }
    }
  }
  return result;
}

char **sub_1CBF68F7C(char **a1)
{
  int v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v5 = &v2[32 * v3];
    do
    {
      uint64_t v6 = *((void *)v5 - 2);
      if (v6 && v6 != -8192 && v6 != -4096)
      {
        unint64_t v7 = *((void *)v5 - 4) & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v7 = *((void *)v5 - 3);
        uint64_t v8 = (unint64_t *)*((void *)v5 - 3);
        if (v8)
        {
          *uint64_t v8 = *v8 & 7 | v7;
        }
        else
        {
          uint64_t v9 = *((void *)v5 - 2);
          BOOL v10 = ***(int32x2_t ****)v9;
          unint64_t v11 = (unint64_t)v10[303];
          if (v11 <= v7)
          {
            uint64_t v12 = v10[305].u32[0];
            if (v11 + 16 * v12 > v7)
            {
              unsigned int v13 = v12 - 1;
              LODWORD(v14) = v13 & ((v9 >> 4) ^ (v9 >> 9));
              BOOL v15 = (uint64_t *)(v11 + 16 * v14);
              uint64_t v16 = *v15;
              if (v9 == *v15)
              {
LABEL_19:
                *BOOL v15 = -8192;
                v10[304] = vadd_s32(v10[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v9 = *((void *)v5 - 2);
              }
              else
              {
                int v17 = 1;
                while (v16 != -4096)
                {
                  int v18 = v14 + v17++;
                  uint64_t v14 = v18 & v13;
                  uint64_t v16 = *(void *)(v11 + 16 * v14);
                  if (v9 == v16)
                  {
                    BOOL v15 = (uint64_t *)(v11 + 16 * v14);
                    goto LABEL_19;
                  }
                }
              }
              *(unsigned char *)(v9 + 17) &= ~1u;
            }
          }
        }
      }
      v5 -= 32;
    }
    while (v5 != v2);
    int v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CBF690C4(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    uint64_t v6 = a1 + 88 * v5;
    uint64_t v7 = *(void *)(v6 + 24);
    if (v7 == a3)
    {
      uint64_t v12 = 1;
    }
    else
    {
      uint64_t v8 = 0;
      int v9 = 1;
      while (v7 != -4096)
      {
        if (v8) {
          BOOL v10 = 0;
        }
        else {
          BOOL v10 = v7 == -8192;
        }
        if (v10) {
          uint64_t v8 = v6;
        }
        unsigned int v11 = v5 + v9++;
        unsigned int v5 = v11 & v4;
        uint64_t v6 = a1 + 88 * (v11 & v4);
        uint64_t v7 = *(void *)(v6 + 24);
        uint64_t v12 = 1;
        if (v7 == a3) {
          goto LABEL_14;
        }
      }
      uint64_t v12 = 0;
      if (v8) {
        uint64_t v6 = v8;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v12 = 0;
  }
LABEL_14:
  *a4 = v6;
  return v12;
}

void *sub_1CBF6915C(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  *(void *)a1 = operator new(88 * v8, (std::align_val_t)8uLL);
  if (v4)
  {
    sub_1CBF69224(a1, v4, v4 + 88 * v3);
    JUMPOUT(0x1D25D9CD0);
  }

  return sub_1CBF68AF4((void *)a1);
}

void *sub_1CBF69224(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int32x2_t result = sub_1CBF68AF4((void *)a1);
  v48[0] = 2;
  v48[1] = 0;
  uint64_t v49 = -4096;
  uint64_t v50 = 0;
  uint64_t v46 = 0;
  int v47 = off_1F2600C98;
  v44[0] = 2;
  v44[1] = 0;
  uint64_t v45 = -8192;
  if (a2 != a3)
  {
    do
    {
      uint64_t v7 = *(void *)(a2 + 24);
      if (v7 != v49 && v7 != v45)
      {
        uint64_t v51 = 0;
        sub_1CBF690C4(*(void *)a1, *(_DWORD *)(a1 + 16), v7, &v51);
        int v9 = v51;
        uint64_t v10 = v51[3];
        uint64_t v11 = *(void *)(a2 + 24);
        if (v10 != v11)
        {
          BOOL v12 = v10 == -4096 || v10 == 0;
          if (!v12 && v10 != -8192)
          {
            unint64_t v31 = v51[1] & 0xFFFFFFFFFFFFFFF8;
            *(void *)unint64_t v31 = v51[2];
            unsigned int v32 = (unint64_t *)v9[2];
            if (v32)
            {
              *unsigned int v32 = *v32 & 7 | v31;
            }
            else
            {
              uint64_t v33 = v9[3];
              unsigned int v34 = ***(int32x2_t ****)v33;
              unint64_t v35 = (unint64_t)v34[303];
              if (v35 <= v31)
              {
                uint64_t v36 = v34[305].u32[0];
                if (v35 + 16 * v36 > v31)
                {
                  unsigned int v37 = v36 - 1;
                  LODWORD(v38) = v37 & ((v33 >> 4) ^ (v33 >> 9));
                  uint64_t v39 = (uint64_t *)(v35 + 16 * v38);
                  uint64_t v40 = *v39;
                  if (v33 == *v39)
                  {
LABEL_49:
                    *uint64_t v39 = -8192;
                    v34[304] = vadd_s32(v34[304], (int32x2_t)0x1FFFFFFFFLL);
                    uint64_t v33 = v9[3];
                  }
                  else
                  {
                    int v41 = 1;
                    while (v40 != -4096)
                    {
                      int v42 = v38 + v41++;
                      uint64_t v38 = v42 & v37;
                      uint64_t v40 = *(void *)(v35 + 16 * v38);
                      if (v33 == v40)
                      {
                        uint64_t v39 = (uint64_t *)(v35 + 16 * v38);
                        goto LABEL_49;
                      }
                    }
                  }
                  *(unsigned char *)(v33 + 17) &= ~1u;
                }
              }
            }
            uint64_t v11 = *(void *)(a2 + 24);
          }
          v9[3] = v11;
          if (v11 != -4096 && v11 != -8192 && v11 != 0)
          {
            uint64_t v14 = *(void *)(a2 + 8);
            void v9[2] = *(void *)(v14 & 0xFFFFFFFFFFFFFFF8);
            *(void *)(v14 & 0xFFFFFFFFFFFFFFF8) = v9 + 1;
            v9[1] = v14 & 0xFFFFFFFFFFFFFFF8 | v9[1] & 7;
            BOOL v15 = (unint64_t *)v9[2];
            if (v15) {
              *BOOL v15 = *v15 & 7 | (unint64_t)(v9 + 2);
            }
          }
        }
        uint64_t v16 = *(void *)(a2 + 32);
        v9[5] = v9 + 7;
        uint64_t v17 = (uint64_t)(v9 + 5);
        *(void *)(v17 - 8) = v16;
        *(void *)(v17 + 8) = 0x100000000;
        if (*(_DWORD *)(a2 + 48)) {
          sub_1CBF67AFC(v17, (uint64_t *)(a2 + 40));
        }
        ++*(_DWORD *)(a1 + 8);
        int32x2_t result = sub_1CBF68F7C((char **)(a2 + 40));
        uint64_t v7 = *(void *)(a2 + 24);
      }
      if (v7 != -4096 && v7 != -8192 && v7 != 0)
      {
        unint64_t v19 = *(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v19 = *(void *)(a2 + 16);
        int v20 = *(unint64_t **)(a2 + 16);
        if (v20)
        {
          *int v20 = *v20 & 7 | v19;
        }
        else
        {
          uint64_t v21 = *(void *)(a2 + 24);
          uint64_t v22 = ***(int32x2_t ****)v21;
          unint64_t v23 = (unint64_t)v22[303];
          if (v23 <= v19)
          {
            uint64_t v24 = v22[305].u32[0];
            if (v23 + 16 * v24 > v19)
            {
              unsigned int v25 = v24 - 1;
              LODWORD(v26) = v25 & ((v21 >> 4) ^ (v21 >> 9));
              uint64_t v27 = (uint64_t *)(v23 + 16 * v26);
              uint64_t v28 = *v27;
              if (v21 == *v27)
              {
LABEL_35:
                *uint64_t v27 = -8192;
                v22[304] = vadd_s32(v22[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v21 = *(void *)(a2 + 24);
              }
              else
              {
                int v29 = 1;
                while (v28 != -4096)
                {
                  int v30 = v26 + v29++;
                  uint64_t v26 = v30 & v25;
                  uint64_t v28 = *(void *)(v23 + 16 * v26);
                  if (v21 == v28)
                  {
                    uint64_t v27 = (uint64_t *)(v23 + 16 * v26);
                    goto LABEL_35;
                  }
                }
              }
              *(unsigned char *)(v21 + 17) &= ~1u;
            }
          }
        }
      }
      a2 += 88;
    }
    while (a2 != a3);
    if (v45 != -8192 && v45 != -4096 && v45 != 0) {
      int32x2_t result = llvm::ValueHandleBase::RemoveFromUseList(v44);
    }
  }
  if (v49 != -4096 && v49 != -8192)
  {
    if (v49) {
      return llvm::ValueHandleBase::RemoveFromUseList(v48);
    }
  }
  return result;
}

char **sub_1CBF695D0(char **result)
{
  uint64_t v1 = *result;
  uint64_t v2 = *((unsigned int *)result + 2);
  if (v2)
  {
    unsigned int v3 = &v1[32 * v2];
    do
    {
      uint64_t v4 = *((void *)v3 - 2);
      if (v4 != -8192 && v4 != -4096 && v4 != 0)
      {
        unint64_t v6 = *((void *)v3 - 4) & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v6 = *((void *)v3 - 3);
        uint64_t v7 = (unint64_t *)*((void *)v3 - 3);
        if (v7)
        {
          *uint64_t v7 = *v7 & 7 | v6;
        }
        else
        {
          uint64_t v8 = *((void *)v3 - 2);
          int v9 = ***(int32x2_t ****)v8;
          unint64_t v10 = (unint64_t)v9[303];
          if (v10 <= v6)
          {
            uint64_t v11 = v9[305].u32[0];
            if (v10 + 16 * v11 > v6)
            {
              unsigned int v12 = v11 - 1;
              LODWORD(v13) = v12 & ((v8 >> 4) ^ (v8 >> 9));
              uint64_t v14 = (uint64_t *)(v10 + 16 * v13);
              uint64_t v15 = *v14;
              if (v8 == *v14)
              {
LABEL_19:
                *uint64_t v14 = -8192;
                v9[304] = vadd_s32(v9[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v8 = *((void *)v3 - 2);
              }
              else
              {
                int v16 = 1;
                while (v15 != -4096)
                {
                  int v17 = v13 + v16++;
                  uint64_t v13 = v17 & v12;
                  uint64_t v15 = *(void *)(v10 + 16 * v13);
                  if (v8 == v15)
                  {
                    uint64_t v14 = (uint64_t *)(v10 + 16 * v13);
                    goto LABEL_19;
                  }
                }
              }
              *(unsigned char *)(v8 + 17) &= ~1u;
            }
          }
        }
      }
      v3 -= 32;
    }
    while (v3 != v1);
    uint64_t v1 = *result;
  }
  if (v1 != (char *)(result + 2))
  {
    int v18 = result;
    free(v1);
    return v18;
  }
  return result;
}

unint64_t *sub_1CBF6971C(unint64_t *a1, unint64_t *a2, void *a3)
{
  if (a1 != a2)
  {
    while (a1[2] != *a3)
    {
      a1 += 4;
      if (a1 == a2)
      {
        a1 = a2;
        break;
      }
    }
  }
  if (a1 == a2) {
    return a1;
  }
  unsigned int v3 = a1 + 4;
  if (a1 + 4 == a2) {
    return a1;
  }
  uint64_t v4 = a1;
  do
  {
    unint64_t v5 = v3;
    unint64_t v6 = a1[6];
    if (v6 != *a3)
    {
      unint64_t v7 = v4[2];
      if (v7 != v6)
      {
        BOOL v8 = v7 == -4096 || v7 == 0;
        if (!v8 && v7 != -8192)
        {
          unint64_t v13 = *v4 & 0xFFFFFFFFFFFFFFF8;
          *(void *)unint64_t v13 = v4[1];
          uint64_t v14 = (unint64_t *)v4[1];
          if (v14)
          {
            *uint64_t v14 = *v14 & 7 | v13;
          }
          else
          {
            unint64_t v15 = v4[2];
            int v16 = ***(int32x2_t ****)v15;
            unint64_t v17 = (unint64_t)v16[303];
            if (v17 <= v13)
            {
              uint64_t v18 = v16[305].u32[0];
              if (v17 + 16 * v18 > v13)
              {
                unsigned int v19 = v18 - 1;
                LODWORD(v20) = v19 & ((v15 >> 4) ^ (v15 >> 9));
                uint64_t v21 = (uint64_t *)(v17 + 16 * v20);
                uint64_t v22 = *v21;
                if (v15 == *v21)
                {
LABEL_34:
                  *uint64_t v21 = -8192;
                  v16[304] = vadd_s32(v16[304], (int32x2_t)0x1FFFFFFFFLL);
                  unint64_t v15 = v4[2];
                }
                else
                {
                  int v23 = 1;
                  while (v22 != -4096)
                  {
                    int v24 = v20 + v23++;
                    uint64_t v20 = v24 & v19;
                    uint64_t v22 = *(void *)(v17 + 16 * v20);
                    if (v15 == v22)
                    {
                      uint64_t v21 = (uint64_t *)(v17 + 16 * v20);
                      goto LABEL_34;
                    }
                  }
                }
                *(unsigned char *)(v15 + 17) &= ~1u;
              }
            }
          }
          unint64_t v6 = a1[6];
        }
        void v4[2] = v6;
        if (v6 != -4096 && v6 != -8192 && v6 != 0)
        {
          unint64_t v10 = *v5;
          uint64_t v11 = (unint64_t *)(*v5 & 0xFFFFFFFFFFFFFFF8);
          v4[1] = *v11;
          *uint64_t v11 = (unint64_t)v4;
          *uint64_t v4 = v10 & 0xFFFFFFFFFFFFFFF8 | *v4 & 7;
          unsigned int v12 = (uint64_t *)v4[1];
          if (v12) {
            *unsigned int v12 = *v12 & 7 | (unint64_t)(v4 + 1);
          }
        }
      }
      *((_DWORD *)v4 + 6) = *((_DWORD *)a1 + 14);
      v4 += 4;
    }
    unsigned int v3 = v5 + 4;
    a1 = v5;
  }
  while (v5 + 4 != a2);
  return v4;
}

BOOL sub_1CBF698E4(uint64_t a1)
{
  return *(unsigned char *)(a1 + 16) == 84
      && (uint64_t v1 = *(void *)(a1 - 32)) != 0
      && !*(unsigned char *)(v1 + 16)
      && *(void *)(v1 + 24) == *(void *)(a1 + 72)
      && (*(unsigned char *)(v1 + 33) & 0x20) != 0
      && *(_DWORD *)(v1 + 36) == 7;
}

uint64_t sub_1CBF69930(uint64_t *a1, void *a2, uint64_t *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    int v5 = v3 - 1;
    unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
    uint64_t v7 = *a1 + 48 * v6;
    uint64_t v8 = *(void *)(v7 + 24);
    if (*a2 == v8)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      uint64_t result = 1;
      while (v8 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v8 == -8192;
        }
        if (v12) {
          uint64_t v10 = v7;
        }
        unsigned int v13 = v6 + v11++;
        unsigned int v6 = v13 & v5;
        uint64_t v7 = v4 + 48 * (v13 & v5);
        uint64_t v8 = *(void *)(v7 + 24);
        if (*a2 == v8) {
          goto LABEL_4;
        }
      }
      uint64_t result = 0;
      if (v10) {
        uint64_t v7 = v10;
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t result = 0;
  }
LABEL_4:
  *a3 = v7;
  return result;
}

void sub_1CBF699D0(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_1CBF69A38((void *)(a2 + 160));
    MEMORY[0x1D25D9CD0](*(void *)(a2 + 160), 8);
    sub_1CBF69C4C((char **)(a2 + 16));
    JUMPOUT(0x1D25D9CE0);
  }
}

void *sub_1CBF69A38(void *result)
{
  unsigned int v1 = *((_DWORD *)result + 4);
  if (v1)
  {
    v24[0] = 2;
    v24[1] = 0;
    uint64_t v25 = -4096;
    uint64_t v26 = 0;
    uint64_t v22 = 0;
    int v23 = off_1F2600C98;
    v20[0] = 2;
    v20[1] = 0;
    uint64_t v21 = -8192;
    uint64_t v2 = *result;
    uint64_t v3 = *result + 88 * v1;
    do
    {
      uint64_t v4 = *(void *)(v2 + 24);
      if (v4 != v25 && v4 != v21)
      {
        uint64_t result = sub_1CBF68F7C((char **)(v2 + 40));
        uint64_t v4 = *(void *)(v2 + 24);
      }
      if (v4 != -4096 && v4 != -8192 && v4 != 0)
      {
        unint64_t v7 = *(void *)(v2 + 8) & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v7 = *(void *)(v2 + 16);
        uint64_t v8 = *(unint64_t **)(v2 + 16);
        if (v8)
        {
          *uint64_t v8 = *v8 & 7 | v7;
        }
        else
        {
          uint64_t v9 = *(void *)(v2 + 24);
          uint64_t v10 = ***(int32x2_t ****)v9;
          unint64_t v11 = (unint64_t)v10[303];
          if (v11 <= v7)
          {
            uint64_t v12 = v10[305].u32[0];
            if (v11 + 16 * v12 > v7)
            {
              unsigned int v13 = v12 - 1;
              LODWORD(v14) = v13 & ((v9 >> 4) ^ (v9 >> 9));
              unint64_t v15 = (uint64_t *)(v11 + 16 * v14);
              uint64_t v16 = *v15;
              if (v9 == *v15)
              {
LABEL_24:
                *unint64_t v15 = -8192;
                v10[304] = vadd_s32(v10[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v9 = *(void *)(v2 + 24);
              }
              else
              {
                int v17 = 1;
                while (v16 != -4096)
                {
                  int v18 = v14 + v17++;
                  uint64_t v14 = v18 & v13;
                  uint64_t v16 = *(void *)(v11 + 16 * v14);
                  if (v9 == v16)
                  {
                    unint64_t v15 = (uint64_t *)(v11 + 16 * v14);
                    goto LABEL_24;
                  }
                }
              }
              *(unsigned char *)(v9 + 17) &= ~1u;
            }
          }
        }
      }
      v2 += 88;
    }
    while (v2 != v3);
    if (v21 != -8192 && v21 != -4096 && v21 != 0) {
      uint64_t result = llvm::ValueHandleBase::RemoveFromUseList(v20);
    }
    if (v25 != -4096 && v25 != -8192)
    {
      if (v25) {
        return llvm::ValueHandleBase::RemoveFromUseList(v24);
      }
    }
  }
  return result;
}

char **sub_1CBF69C4C(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    int v5 = &v2[32 * v3];
    do
    {
      uint64_t v6 = *((void *)v5 - 2);
      if (v6 && v6 != -8192 && v6 != -4096)
      {
        unint64_t v7 = *((void *)v5 - 4) & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v7 = *((void *)v5 - 3);
        uint64_t v8 = (unint64_t *)*((void *)v5 - 3);
        if (v8)
        {
          *uint64_t v8 = *v8 & 7 | v7;
        }
        else
        {
          uint64_t v9 = *((void *)v5 - 2);
          uint64_t v10 = ***(int32x2_t ****)v9;
          unint64_t v11 = (unint64_t)v10[303];
          if (v11 <= v7)
          {
            uint64_t v12 = v10[305].u32[0];
            if (v11 + 16 * v12 > v7)
            {
              unsigned int v13 = v12 - 1;
              LODWORD(v14) = v13 & ((v9 >> 4) ^ (v9 >> 9));
              unint64_t v15 = (uint64_t *)(v11 + 16 * v14);
              uint64_t v16 = *v15;
              if (v9 == *v15)
              {
LABEL_19:
                *unint64_t v15 = -8192;
                v10[304] = vadd_s32(v10[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v9 = *((void *)v5 - 2);
              }
              else
              {
                int v17 = 1;
                while (v16 != -4096)
                {
                  int v18 = v14 + v17++;
                  uint64_t v14 = v18 & v13;
                  uint64_t v16 = *(void *)(v11 + 16 * v14);
                  if (v9 == v16)
                  {
                    unint64_t v15 = (uint64_t *)(v11 + 16 * v14);
                    goto LABEL_19;
                  }
                }
              }
              *(unsigned char *)(v9 + 17) &= ~1u;
            }
          }
        }
      }
      v5 -= 32;
    }
    while (v5 != v2);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CBF69D90@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v31 = 0;
  uint64_t result = sub_1CBF69F7C((uint64_t *)a1, (uint64_t)a2, &v31);
  uint64_t v9 = v31;
  if (result)
  {
    char v17 = 0;
  }
  else
  {
    uint64_t result = sub_1CBF6A01C(a1, (uint64_t)a2, (uint64_t)a2, v31);
    uint64_t v9 = result;
    uint64_t v10 = *(void *)(result + 24);
    uint64_t v11 = a2[3];
    if (v10 != v11)
    {
      BOOL v12 = v10 == -4096 || v10 == 0;
      if (!v12 && v10 != -8192)
      {
        unint64_t v19 = *(void *)(result + 8) & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v19 = *(void *)(result + 16);
        uint64_t v20 = *(unint64_t **)(result + 16);
        if (v20)
        {
          *uint64_t v20 = *v20 & 7 | v19;
        }
        else
        {
          uint64_t v21 = *(void *)(result + 24);
          uint64_t v22 = ***(int32x2_t ****)v21;
          unint64_t v23 = (unint64_t)v22[303];
          if (v23 <= v19)
          {
            uint64_t v24 = v22[305].u32[0];
            if (v23 + 16 * v24 > v19)
            {
              unsigned int v25 = v24 - 1;
              LODWORD(v26) = v25 & ((v21 >> 4) ^ (v21 >> 9));
              uint64_t v27 = (uint64_t *)(v23 + 16 * v26);
              uint64_t v28 = *v27;
              if (v21 == *v27)
              {
LABEL_26:
                *uint64_t v27 = -8192;
                v22[304] = vadd_s32(v22[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v21 = *(void *)(result + 24);
              }
              else
              {
                int v29 = 1;
                while (v28 != -4096)
                {
                  int v30 = v26 + v29++;
                  uint64_t v26 = v30 & v25;
                  uint64_t v28 = *(void *)(v23 + 16 * v26);
                  if (v21 == v28)
                  {
                    uint64_t v27 = (uint64_t *)(v23 + 16 * v26);
                    goto LABEL_26;
                  }
                }
              }
              *(unsigned char *)(v21 + 17) &= ~1u;
            }
          }
        }
        uint64_t v11 = a2[3];
      }
      *(void *)(result + 24) = v11;
      if (v11 != -4096 && v11 != -8192 && v11 != 0)
      {
        uint64_t v14 = a2[1];
        *(void *)(result + 16) = *(void *)(v14 & 0xFFFFFFFFFFFFFFF8);
        *(void *)(v14 & 0xFFFFFFFFFFFFFFF8) = result + 8;
        *(void *)(result + 8) = v14 & 0xFFFFFFFFFFFFFFF8 | *(void *)(result + 8) & 7;
        unint64_t v15 = *(uint64_t **)(result + 16);
        if (v15) {
          *unint64_t v15 = *v15 & 7 | (result + 16);
        }
      }
    }
    *(void *)(result + 32) = a2[4];
    uint64_t v16 = *a3;
    *a3 = 0;
    *(void *)(result + 40) = v16;
    char v17 = 1;
  }
  uint64_t v18 = *(void *)a1 + 48 * *(unsigned int *)(a1 + 16);
  *(void *)a4 = v9;
  *(void *)(a4 + 8) = v18;
  *(unsigned char *)(a4 + 16) = v17;
  return result;
}

uint64_t sub_1CBF69F7C(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    uint64_t v5 = *(void *)(a2 + 24);
    int v6 = v3 - 1;
    unsigned int v7 = ((v5 >> 4) ^ (v5 >> 9)) & (v3 - 1);
    uint64_t v8 = *a1 + 48 * v7;
    uint64_t v9 = *(void *)(v8 + 24);
    if (v5 == v9)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      uint64_t result = 1;
      while (v9 != -4096)
      {
        if (v10) {
          BOOL v13 = 0;
        }
        else {
          BOOL v13 = v9 == -8192;
        }
        if (v13) {
          uint64_t v10 = v8;
        }
        unsigned int v14 = v7 + v11++;
        unsigned int v7 = v14 & v6;
        uint64_t v8 = v4 + 48 * (v14 & v6);
        uint64_t v9 = *(void *)(v8 + 24);
        if (v5 == v9) {
          goto LABEL_7;
        }
      }
      uint64_t result = 0;
      if (v10) {
        uint64_t v8 = v10;
      }
    }
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t result = 0;
  }
LABEL_7:
  *a3 = v8;
  return result;
}

uint64_t sub_1CBF6A01C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CBF6A0D0(a1, v7);
  uint64_t v9 = 0;
  sub_1CBF69F7C((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*(void *)(a4 + 24) != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CBF6A0D0(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(48 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CBF6A29C(a1, v4, &v4[6 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  v17[0] = 2;
  v17[1] = 0;
  uint64_t v18 = -4096;
  uint64_t v19 = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 0;
    uint64_t v12 = 48 * v10;
    BOOL v13 = result + 2;
    do
    {
      uint64_t v14 = v17[0];
      uint64_t v15 = v18;
      *(v13 - 1) = v17[0] & 6;
      *BOOL v13 = 0;
      v13[1] = v15;
      if (v15 != -4096 && v15 != -8192 && v15 != 0)
      {
        *BOOL v13 = *(void *)(v14 & 0xFFFFFFFFFFFFFFF8);
        *(void *)(v14 & 0xFFFFFFFFFFFFFFF8) = v13 - 1;
        *(v13 - 1) = v14 & 0xFFFFFFFFFFFFFFFELL;
        if (*v13) {
          *(void *)*BOOL v13 = *(void *)*v13 & 7 | (unint64_t)(result + 2);
        }
        uint64_t v11 = v19;
      }
      *(v13 - 2) = off_1F2600CC0;
      void v13[2] = v11;
      v13 += 6;
      result += 6;
      v12 -= 48;
    }
    while (v12);
    if (v18 != -8192 && v18 != -4096)
    {
      if (v18) {
        return llvm::ValueHandleBase::RemoveFromUseList(v17);
      }
    }
  }
  return result;
}

void sub_1CBF6A29C(uint64_t a1, void *a2, void *a3)
{
  sub_1CBF68E4C((void *)a1);
  v48[0] = 2;
  v48[1] = 0;
  uint64_t v49 = -4096;
  uint64_t v50 = 0;
  uint64_t v46 = 0;
  int v47 = off_1F2600CC0;
  v44[0] = 2;
  v44[1] = 0;
  uint64_t v45 = -8192;
  if (a2 != a3)
  {
    do
    {
      uint64_t v6 = a2[3];
      if (v6 != v49 && v6 != v45)
      {
        uint64_t v51 = 0;
        sub_1CBF69F7C((uint64_t *)a1, (uint64_t)a2, (uint64_t *)&v51);
        unsigned int v8 = v51;
        uint64_t v9 = v51[3];
        uint64_t v10 = a2[3];
        if (v9 != v10)
        {
          BOOL v11 = v9 == -4096 || v9 == 0;
          if (!v11 && v9 != -8192)
          {
            unint64_t v31 = v51[1] & 0xFFFFFFFFFFFFFFF8;
            *(void *)unint64_t v31 = v51[2];
            unsigned int v32 = (unint64_t *)v8[2];
            if (v32)
            {
              *unsigned int v32 = *v32 & 7 | v31;
            }
            else
            {
              uint64_t v33 = v8[3];
              unsigned int v34 = ***(int32x2_t ****)v33;
              unint64_t v35 = (unint64_t)v34[303];
              if (v35 <= v31)
              {
                uint64_t v36 = v34[305].u32[0];
                if (v35 + 16 * v36 > v31)
                {
                  unsigned int v37 = v36 - 1;
                  LODWORD(v38) = v37 & ((v33 >> 4) ^ (v33 >> 9));
                  uint64_t v39 = (uint64_t *)(v35 + 16 * v38);
                  uint64_t v40 = *v39;
                  if (v33 == *v39)
                  {
LABEL_48:
                    *uint64_t v39 = -8192;
                    v34[304] = vadd_s32(v34[304], (int32x2_t)0x1FFFFFFFFLL);
                    uint64_t v33 = v8[3];
                  }
                  else
                  {
                    int v41 = 1;
                    while (v40 != -4096)
                    {
                      int v42 = v38 + v41++;
                      uint64_t v38 = v42 & v37;
                      uint64_t v40 = *(void *)(v35 + 16 * v38);
                      if (v33 == v40)
                      {
                        uint64_t v39 = (uint64_t *)(v35 + 16 * v38);
                        goto LABEL_48;
                      }
                    }
                  }
                  *(unsigned char *)(v33 + 17) &= ~1u;
                }
              }
            }
            uint64_t v10 = a2[3];
          }
          v8[3] = v10;
          if (v10 != -4096 && v10 != -8192 && v10 != 0)
          {
            uint64_t v13 = a2[1];
            v8[2] = *(void *)(v13 & 0xFFFFFFFFFFFFFFF8);
            *(void *)(v13 & 0xFFFFFFFFFFFFFFF8) = v8 + 1;
            v8[1] = v13 & 0xFFFFFFFFFFFFFFF8 | v8[1] & 7;
            uint64_t v14 = (unint64_t *)v8[2];
            if (v14) {
              *uint64_t v14 = *v14 & 7 | (unint64_t)(v8 + 2);
            }
          }
        }
        void v8[4] = a2[4];
        uint64_t v15 = a2[5];
        a2[5] = 0;
        v8[5] = v15;
        ++*(_DWORD *)(a1 + 8);
        uint64_t v16 = a2[5];
        a2[5] = 0;
        if (v16) {
          sub_1CBF699D0((uint64_t)(a2 + 5), v16);
        }
      }
      uint64_t v17 = a2[3];
      if (v17 != -4096 && v17 != -8192 && v17 != 0)
      {
        unint64_t v19 = a2[1] & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v19 = a2[2];
        uint64_t v20 = (unint64_t *)a2[2];
        if (v20)
        {
          *uint64_t v20 = *v20 & 7 | v19;
        }
        else
        {
          uint64_t v21 = a2[3];
          uint64_t v22 = ***(int32x2_t ****)v21;
          unint64_t v23 = (unint64_t)v22[303];
          if (v23 <= v19)
          {
            uint64_t v24 = v22[305].u32[0];
            if (v23 + 16 * v24 > v19)
            {
              unsigned int v25 = v24 - 1;
              LODWORD(v26) = v25 & ((v21 >> 4) ^ (v21 >> 9));
              uint64_t v27 = (uint64_t *)(v23 + 16 * v26);
              uint64_t v28 = *v27;
              if (v21 == *v27)
              {
LABEL_34:
                *uint64_t v27 = -8192;
                v22[304] = vadd_s32(v22[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v21 = a2[3];
              }
              else
              {
                int v29 = 1;
                while (v28 != -4096)
                {
                  int v30 = v26 + v29++;
                  uint64_t v26 = v30 & v25;
                  uint64_t v28 = *(void *)(v23 + 16 * v26);
                  if (v21 == v28)
                  {
                    uint64_t v27 = (uint64_t *)(v23 + 16 * v26);
                    goto LABEL_34;
                  }
                }
              }
              *(unsigned char *)(v21 + 17) &= ~1u;
            }
          }
        }
      }
      a2 += 6;
    }
    while (a2 != a3);
    if (v45 != -8192 && v45 != -4096 && v45 != 0) {
      llvm::ValueHandleBase::RemoveFromUseList(v44);
    }
  }
  if (v49 != -4096 && v49 != -8192)
  {
    if (v49) {
      llvm::ValueHandleBase::RemoveFromUseList(v48);
    }
  }
}

uint64_t sub_1CBF6A634()
{
  int v4 = 1;
  v3.n128_u64[0] = (unint64_t)"Enable verification of assumption cache";
  v3.n128_u64[1] = 39;
  char v1 = 0;
  uint64_t v2 = &v1;
  sub_1CD413E90((llvm::cl::Option *)&unk_1EBCC3AE0, "verify-assumption-cache", &v4, &v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC3AE0, &dword_1CB82C000);
}

BOOL llvm::BasicAAResult::invalidate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  return (sub_1CBF745FC(a4, (uint64_t)&llvm::AssumptionAnalysis::Key, a2, a3) & 1) != 0
      || *(void *)(a1 + 48)
      && (llvm::AnalysisManager<llvm::Function>::Invalidator::invalidate(a4, (uint64_t)&llvm::DominatorTreeAnalysis::Key, a2, a3) & 1) != 0|| *(void *)(a1 + 56) && (sub_1CBF745FC(a4, (uint64_t)&llvm::PhiValuesAnalysis::Key, a2, a3) & 1) != 0;
}

BOOL llvm::SimpleCaptureInfo::isNotCapturedBeforeOrAt(llvm::SimpleCaptureInfo *this, const llvm::Value *a2, const llvm::Instruction *a3)
{
  char v6 = *((unsigned char *)this + 8);
  unint64_t v5 = (char *)this + 8;
  uint64_t v21 = a2;
  char v22 = 0;
  if (v6)
  {
    int v7 = v5 + 8;
    int v8 = 8;
  }
  else
  {
    int v8 = *((_DWORD *)this + 6);
    if (!v8)
    {
      uint64_t v15 = 0;
      goto LABEL_9;
    }
    int v7 = (char *)*((void *)this + 2);
  }
  int v9 = v8 - 1;
  uint64_t v10 = (v8 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  BOOL v11 = (const llvm::Value **)&v7[16 * v10];
  uint64_t v12 = *v11;
  if (*v11 == a2) {
    return v7[16 * v10 + 8] != 0;
  }
  uint64_t v13 = 0;
  int v14 = 1;
  while (v12 != (const llvm::Value *)-4096)
  {
    if (v13) {
      BOOL v19 = 0;
    }
    else {
      BOOL v19 = v12 == (const llvm::Value *)-8192;
    }
    if (v19) {
      uint64_t v13 = v11;
    }
    int v20 = v10 + v14++;
    uint64_t v10 = v20 & v9;
    BOOL v11 = (const llvm::Value **)&v7[16 * v10];
    uint64_t v12 = *v11;
    if (*v11 == a2) {
      return v7[16 * v10 + 8] != 0;
    }
  }
  if (v13) {
    uint64_t v15 = v13;
  }
  else {
    uint64_t v15 = v11;
  }
LABEL_9:
  uint64_t v16 = sub_1CBFB3BE4((uint64_t)v5, (uint64_t)&v21, &v21, v15);
  *uint64_t v16 = v21;
  *((unsigned char *)v16 + 8) = v22;
  if ((llvm::isIdentifiedFunctionLocal(a2, v17) & 1) == 0) {
    return 0;
  }
  BOOL result = !llvm::PointerMayBeCaptured(a2, 0, 0, 0);
  *((unsigned char *)v16 + 8) = result;
  return result;
}

uint64_t llvm::EarliestEscapeInfo::isNotCapturedBeforeOrAt(llvm::EarliestEscapeInfo *this, const llvm::Value *a2, const llvm::Instruction *a3)
{
  uint64_t result = llvm::isIdentifiedFunctionLocal(a2, a2);
  if (result)
  {
    uint64_t v21 = a2;
    uint64_t v22 = 0;
    uint64_t v27 = 0;
    if (sub_1CB915048((uint64_t *)this + 3, &v21, &v27))
    {
      int v7 = v27[1];
      goto LABEL_4;
    }
    int v8 = sub_1CBF74714((uint64_t)this + 24, (uint64_t)&v21, &v21, v27);
    *int v8 = v21;
    v8[1] = v22;
    uint64_t v9 = *(void *)(*((void *)a3 + 5) + 56);
    uint64_t v10 = *((void *)this + 1);
    uint64_t v11 = *((void *)this + 9);
    uint64_t v21 = (const llvm::Value *)&unk_1F2601F38;
    uint64_t v22 = v11;
    unint64_t v23 = 0;
    uint64_t v24 = v10;
    __int16 v25 = 0;
    uint64_t v26 = v9;
    llvm::PointerMayBeCaptured(a2, (const llvm::Value *)&v21, 0);
    int v7 = v23;
    if (!v23)
    {
LABEL_11:
      v8[1] = v7;
LABEL_4:
      if (!v7) {
        return 1;
      }
      if (v7 == a3) {
        return 0;
      }
      return llvm::isPotentiallyReachable((uint64_t)v7, (uint64_t)a3, 0, *((void *)this + 1), *((void *)this + 2)) ^ 1;
    }
    uint64_t v20 = 0;
    uint64_t v21 = v23;
    uint64_t v22 = 0;
    uint64_t v12 = *((void *)this + 6);
    uint64_t v27 = 0;
    char v13 = sub_1CBF74894(v12, *((_DWORD *)this + 16), (uint64_t)v23, &v27);
    int v14 = v27;
    if (v13)
    {
LABEL_19:
      sub_1CBF749F4(&v22);
      sub_1CBF749F4(&v20);
      unint64_t v17 = (unint64_t)v14[1];
      if (v17 > 7)
      {
        if ((v17 & 4) == 0) {
          operator new();
        }
        unint64_t v18 = v17 & 0xFFFFFFFFFFFFFFF8;
        unsigned int v19 = *(_DWORD *)((v17 & 0xFFFFFFFFFFFFFFF8) + 8);
        if (v19 >= *(_DWORD *)(v18 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)v18 + 8 * v19) = a2;
        ++*(_DWORD *)(v18 + 8);
      }
      else
      {
        v14[1] = (const llvm::Instruction *)((unint64_t)a2 & 0xFFFFFFFFFFFFFFFBLL);
      }
      goto LABEL_11;
    }
    int v15 = *((_DWORD *)this + 14);
    unsigned int v16 = *((_DWORD *)this + 16);
    if (4 * v15 + 4 < 3 * v16)
    {
      if (v16 + ~v15 - *((_DWORD *)this + 15) > v16 >> 3) {
        goto LABEL_16;
      }
    }
    else
    {
      v16 *= 2;
    }
    sub_1CBF74928((uint64_t)this + 48, v16);
    uint64_t v27 = 0;
    sub_1CBF74894(*((void *)this + 6), *((_DWORD *)this + 16), (uint64_t)v7, &v27);
    int v14 = v27;
LABEL_16:
    ++*((_DWORD *)this + 14);
    if (*v14 != (const llvm::Instruction *)-4096) {
      --*((_DWORD *)this + 15);
    }
    *int v14 = v7;
    v14[1] = 0;
    uint64_t v22 = 0;
    goto LABEL_19;
  }
  return result;
}

uint64_t llvm::EarliestEscapeInfo::removeInstruction(llvm::EarliestEscapeInfo *this, llvm::Instruction *a2)
{
  uint64_t v9 = a2;
  uint64_t v10 = a2;
  __n128 v3 = (char *)this + 48;
  uint64_t v11 = 0;
  uint64_t result = sub_1CB87DF68((uint64_t)this + 48, &v10, &v11);
  if (result && v11 != (void *)(*((void *)this + 6) + 16 * *((unsigned int *)this + 16)))
  {
    char v6 = (llvm::Instruction **)(v11 + 1);
    unint64_t v5 = v11[1];
    if ((v5 & 4) != 0)
    {
      unint64_t v8 = v5 & 0xFFFFFFFFFFFFFFF8;
      char v6 = *(llvm::Instruction ***)v8;
      uint64_t v7 = *(void *)v8 + 8 * *(unsigned int *)(v8 + 8);
    }
    else
    {
      uint64_t v7 = (uint64_t)&v6[v5 > 7];
    }
    for (; v6 != (llvm::Instruction **)v7; ++v6)
    {
      uint64_t v10 = *v6;
      uint64_t v11 = 0;
      if (sub_1CB915048((uint64_t *)this + 3, &v10, &v11))
      {
        *uint64_t v11 = -8192;
        *((int32x2_t *)this + 4) = vadd_s32(*(int32x2_t *)((char *)this + 32), (int32x2_t)0x1FFFFFFFFLL);
      }
    }
    return sub_1CD45C0B8((uint64_t)v3, (uint64_t *)&v9);
  }
  return result;
}

uint64_t llvm::BasicAAResult::DecomposeGEPExpression@<X0>(uint64_t this@<X0>, const llvm::Value *a2@<X1>, const llvm::DataLayout *a3@<X2>, llvm::AssumptionCache *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v7 = this;
  if (*(unsigned __int8 *)(this + 16) <= 0x1Bu) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = this;
  }
  uint64_t v133 = (void *)v9;
  uint64_t v10 = *((unsigned int *)a2 + 60);
  if (v10)
  {
    unsigned int v11 = 0;
    uint64_t v12 = 16 * v10;
    char v13 = (unsigned int *)(*((void *)a2 + 29) + 4);
    do
    {
      unsigned int v14 = *v13;
      v13 += 4;
      unint64_t v15 = ((unint64_t)v14 + 7) >> 3;
      if (v11 <= v15) {
        unsigned int v11 = v15;
      }
      v12 -= 16;
    }
    while (v12);
    unsigned int v16 = 8 * v11;
  }
  else
  {
    unsigned int v16 = 0;
  }
  *(void *)(a5 + 8) = 0;
  unint64_t v17 = (unint64_t *)(a5 + 8);
  *(void *)(a5 + 24) = a5 + 40;
  uint64_t v136 = (uint64_t *)(a5 + 24);
  *(_DWORD *)(a5 + 16) = 1;
  *(void *)(a5 + 32) = 0x400000000;
  *(_WORD *)(a5 + 264) = 0;
  if (v16 >= 0x41) {
    operator new[]();
  }
  *(void *)(a5 + 8) = 0;
  int v18 = 6;
  *(_DWORD *)(a5 + 16) = v16;
  unsigned int v138 = v16;
  do
  {
    unsigned int v19 = *(unsigned __int8 *)(v7 + 16);
    unsigned int v20 = v19 - 28;
    BOOL v22 = v19 < 0x1C && v19 != 5;
    if (!v7 || v22)
    {
      if (v7)
      {
        if (v19 == 1)
        {
          this = llvm::GlobalValue::isInterposable((llvm::GlobalValue *)v7);
          if ((this & 1) == 0)
          {
            this = *(void *)(v7 - 32);
            goto LABEL_240;
          }
        }
      }
      break;
    }
    if (v19 <= 0x1B) {
      unsigned int v20 = *(unsigned __int16 *)(v7 + 18);
    }
    if (v20 == 49 || v20 == 50)
    {
      int v23 = *(_DWORD *)(v7 + 20);
      if ((v23 & 0x40000000) == 0)
      {
        uint64_t v24 = (uint64_t *)(v7 - 32 * (v23 & 0x7FFFFFF));
        goto LABEL_239;
      }
      goto LABEL_40;
    }
    if (v19 == 83)
    {
      int v25 = *(_DWORD *)(v7 + 20);
      if ((v25 & 0x7FFFFFF) != 1) {
        break;
      }
      if ((v25 & 0x40000000) == 0)
      {
        uint64_t v24 = (uint64_t *)(v7 - 32);
        goto LABEL_239;
      }
LABEL_40:
      uint64_t v24 = *(uint64_t **)(v7 - 8);
      goto LABEL_239;
    }
    if (v19 != 62)
    {
      if (v19 != 5)
      {
        if (v19 >= 0x1C)
        {
          unsigned int v26 = v19 - 33;
          if (v26 <= 0x33 && ((1 << v26) & 0x8000000000041) != 0)
          {
            this = llvm::getArgumentAliasingToReturnedPointer(v7, 0);
            if (this) {
              goto LABEL_240;
            }
          }
        }
        break;
      }
      if (*(_WORD *)(v7 + 18) != 34) {
        break;
      }
    }
    if (*(unsigned char *)(a5 + 265))
    {
      if ((*(unsigned char *)(v7 + 17) & 2) == 0)
      {
        *(unsigned char *)(a5 + 264) = 0;
        unsigned int v19 = *(unsigned __int8 *)(v7 + 16);
      }
    }
    else
    {
      *(unsigned char *)(a5 + 264) = (*(unsigned char *)(v7 + 17) & 2) != 0;
      *(unsigned char *)(a5 + 265) = 1;
    }
    if (v19 == 62) {
      uint64_t v27 = 64;
    }
    else {
      uint64_t v27 = 24;
    }
    uint64_t v28 = *(void *)(v7 + v27);
    if (*(unsigned char *)(v28 + 8) == 19) {
      break;
    }
    int v29 = *(_DWORD *)(v7 + 20);
    if ((v29 & 0x40000000) != 0) {
      int v30 = *(uint64_t ***)(v7 - 8);
    }
    else {
      int v30 = (uint64_t **)(v7 - 32 * (v29 & 0x7FFFFFF));
    }
    uint64_t v31 = **v30;
    unsigned int v32 = *(_DWORD *)(v31 + 8);
    if ((v32 & 0xFE) == 0x12) {
      unsigned int v32 = *(_DWORD *)(**(void **)(v31 + 16) + 8);
    }
    if ((v29 & 0x40000000) != 0) {
      uint64_t v33 = *(void *)(v7 - 8);
    }
    else {
      uint64_t v33 = v7 - 32 * (v29 & 0x7FFFFFF);
    }
    int v157 = (llvm::Constant **)(v33 + 32);
    uint64_t v158 = v28 | 4;
    if (v32 < 0x100) {
      goto LABEL_68;
    }
    unsigned int v34 = v32 >> 8;
    uint64_t v35 = *((unsigned int *)a2 + 60);
    uint64_t v36 = *((void *)a2 + 29);
    if (v35)
    {
      uint64_t v36 = *((void *)a2 + 29);
      unint64_t v37 = *((unsigned int *)a2 + 60);
      do
      {
        unint64_t v38 = v37 >> 1;
        uint64_t v39 = v36 + 16 * (v37 >> 1);
        unsigned int v40 = *(_DWORD *)(v39 + 8);
        uint64_t v41 = v39 + 16;
        v37 += ~(v37 >> 1);
        if (v40 < v34) {
          uint64_t v36 = v41;
        }
        else {
          unint64_t v37 = v38;
        }
      }
      while (v37);
    }
    if (v36 == *((void *)a2 + 29) + 16 * v35 || *(_DWORD *)(v36 + 8) != v34) {
LABEL_68:
    }
      uint64_t v36 = *((void *)a2 + 29);
    unsigned int v137 = *(_DWORD *)(v36 + 12);
    if ((v29 & 0x40000000) != 0)
    {
      uint64_t v43 = *(void *)(v7 - 8);
      uint64_t v42 = v29 & 0x7FFFFFF;
    }
    else
    {
      uint64_t v42 = v29 & 0x7FFFFFF;
      uint64_t v43 = v7 - 32 * v42;
    }
    if (v42 == 1)
    {
LABEL_232:
      sub_1CBF6CAF4((uint64_t)&v148, a5 + 8, v137);
      if (*(_DWORD *)(a5 + 16) >= 0x41u && *v17) {
        MEMORY[0x1D25D9CB0](*v17, 0x1000C8000313F17);
      }
      *(void *)(a5 + 8) = v148;
      *(_DWORD *)(a5 + 16) = DWORD2(v148);
      goto LABEL_236;
    }
    unsigned int v44 = (uint64_t *)(v43 + 32 * v42);
    uint64_t v45 = (uint64_t *)(v43 + 32);
    char v46 = 1;
    while (2)
    {
      char v132 = v46;
      while (1)
      {
        uint64_t v47 = *v45;
        uint64_t v48 = (llvm::Type *)(v158 & 0xFFFFFFFFFFFFFFF8);
        if ((v158 & 4) == 0 && v48)
        {
          uint64_t v49 = (unsigned int *)(v47 + 24);
          if (*(_DWORD *)(v47 + 32) >= 0x41u) {
            uint64_t v49 = *(unsigned int **)v49;
          }
          uint64_t v50 = *v49;
          if (*v49)
          {
            StructLayout = llvm::DataLayout::getStructLayout(a2, (llvm::StructType *)(v158 & 0xFFFFFFFFFFFFFFF8));
            llvm::APInt::operator+=(a5 + 8, *((void *)StructLayout + v50 + 2));
          }
          goto LABEL_118;
        }
        if (*(unsigned char *)(v47 + 16) != 16 || v47 == 0) {
          break;
        }
        uint64_t v53 = (void *)(v47 + 24);
        uint64_t v54 = *(unsigned int *)(v47 + 32);
        if (v54 > 0x40)
        {
          int v55 = 0;
          int64_t v56 = (unint64_t)(v54 + 63) >> 6;
          do
          {
            BOOL v57 = v56-- < 1;
            if (v57) {
              break;
            }
            unint64_t v58 = *(void *)(*v53 + 8 * v56);
            v55 += __clz(v58);
          }
          while (!v58);
          int v59 = v54 | 0xFFFFFFC0;
          if ((v54 & 0x3F) == 0) {
            int v59 = 0;
          }
          if (v55 + v59 == v54) {
            goto LABEL_118;
          }
LABEL_94:
          if ((v158 & 4) == 0 || !v48)
          {
            AggregateElement = *v157;
            if (*v157) {
              BOOL v61 = *((unsigned char *)*v157 + 16) == 16;
            }
            else {
              BOOL v61 = 0;
            }
            if (!v61) {
              AggregateElement = (llvm::Constant *)llvm::Constant::getAggregateElement(AggregateElement, 0);
            }
            BOOL v64 = (unsigned int *)*((void *)AggregateElement + 3);
            int v62 = (unsigned int *)((char *)AggregateElement + 24);
            unsigned int v63 = v64;
            if (v62[2] < 0x41) {
              unsigned int v63 = v62;
            }
            uint64_t v48 = *(llvm::Type **)(*((void *)v48 + 2) + 8 * *v63);
          }
          unint64_t v65 = (unint64_t)(sub_1CB83544C((uint64_t)a2, (uint64_t)v48) + 7) >> 3;
          char Alignment = llvm::DataLayout::getAlignment(a2, v48, 1);
          uint64_t v67 = ((1 << Alignment) + v65 - 1) & -(1 << Alignment);
          llvm::APInt::sextOrTrunc((uint64_t)v53, v138, (uint64_t)&v155);
          unsigned int v68 = v156;
          if (v156 <= 0x40)
          {
            int v155 = (llvm::APInt *)((void)v155 * v67);
            if (v156) {
              goto LABEL_106;
            }
LABEL_127:
            unint64_t v69 = 0;
            goto LABEL_107;
          }
          llvm::APInt::tcMultiplyPart(v155, (unint64_t *)v155, (const unint64_t *)v67, 0, ((unint64_t)v156 + 63) >> 6, ((unint64_t)v156 + 63) >> 6, 0);
          unsigned int v68 = v156;
          if (!v156) {
            goto LABEL_127;
          }
LABEL_106:
          unint64_t v69 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v68;
          if (v68 >= 0x41) {
            uint64_t v70 = (unint64_t *)((char *)v155 + 8 * (((unint64_t)v68 + 63) >> 6) - 8);
          }
          else {
LABEL_107:
          }
            uint64_t v70 = (unint64_t *)&v155;
          *v70 &= v69;
          unsigned int v71 = v156;
          uint64_t v72 = v155;
          unsigned int v156 = 0;
          uint64_t v73 = *(unsigned int *)(a5 + 16);
          if (v73 >= 0x41)
          {
            uint64_t v75 = 0;
            size_t v76 = (unint64_t *)*v17;
            unint64_t v77 = (unint64_t)(v73 + 63) >> 6;
            BOOL v78 = v155;
            unint64_t v79 = v77;
            do
            {
              uint64_t v80 = *(void *)v78;
              BOOL v78 = (llvm::APInt *)((char *)v78 + 8);
              unint64_t v81 = v80 + *v76;
              BOOL v82 = v81 + 1 <= *v76;
              if (v75)
              {
                ++v81;
                uint64_t v75 = v82;
              }
              else
              {
                uint64_t v75 = v81 < *v76;
              }
              *v76++ = v81;
              --v79;
            }
            while (v79);
            *(void *)(*v17 + 8 * (v77 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v73;
          }
          else
          {
            if (v73) {
              unint64_t v74 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v73;
            }
            else {
              unint64_t v74 = 0;
            }
            *unint64_t v17 = v74 & ((unint64_t)v155 + *v17);
          }
          if (v71 >= 0x41 && v72) {
            MEMORY[0x1D25D9CB0](v72, 0x1000C8000313F17);
          }
          if (v156 >= 0x41 && v155) {
            MEMORY[0x1D25D9CB0](v155, 0x1000C8000313F17);
          }
          goto LABEL_118;
        }
        if (*v53) {
          goto LABEL_94;
        }
LABEL_118:
        sub_1CB8460E4((uint64_t)&v157);
        v45 += 4;
        if (v45 == v44)
        {
          if ((v132 & 1) == 0) {
            goto LABEL_236;
          }
          goto LABEL_232;
        }
      }
      unsigned int v83 = *(_DWORD *)(*(void *)v47 + 8) >> 8;
      unsigned int v84 = v137 - v83;
      if (v137 < v83) {
        unsigned int v84 = 0;
      }
      BOOL v85 = v83 >= v137;
      unsigned int v86 = v83 - v137;
      *(void *)&long long v141 = *v45;
      if (v85) {
        unsigned int v87 = v86;
      }
      else {
        unsigned int v87 = 0;
      }
      DWORD2(v141) = 0;
      HIDWORD(v141) = v84;
      unsigned int v142 = v87;
      sub_1CBF6BB20((uint64_t)&v148, (unint64_t *)&v141, a2, 0, a3, a4);
      uint64_t v88 = (llvm::Type *)(v158 & 0xFFFFFFFFFFFFFFF8);
      if ((v158 & 4) == 0 || !v88)
      {
        uint64_t v89 = *v157;
        if (*v157) {
          BOOL v90 = *((unsigned char *)*v157 + 16) == 16;
        }
        else {
          BOOL v90 = 0;
        }
        if (!v90) {
          uint64_t v89 = (llvm::Constant *)llvm::Constant::getAggregateElement(v89, 0);
        }
        uint64_t v93 = (unsigned int *)*((void *)v89 + 3);
        char v91 = (unsigned int *)((char *)v89 + 24);
        uint64_t v92 = v93;
        if (v91[2] < 0x41) {
          uint64_t v92 = v91;
        }
        uint64_t v88 = *(llvm::Type **)(*((void *)v88 + 2) + 8 * *v92);
      }
      unint64_t v94 = (unint64_t)(sub_1CB83544C((uint64_t)a2, (uint64_t)v88) + 7) >> 3;
      char v95 = llvm::DataLayout::getAlignment(a2, v88, 1);
      uint64_t v96 = -(1 << v95) & ((1 << v95) + v94 - 1);
      unsigned int v140 = v137;
      if (v137 > 0x40) {
        operator new[]();
      }
      unint64_t v97 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v137;
      unsigned int v98 = v138;
      if (!v137) {
        unint64_t v97 = 0;
      }
      __src = (void *)(v97 & v96);
      sub_1CBF6C868((uint64_t)&v141, (uint64_t)&v148, (uint64_t)&__src, (*(unsigned __int8 *)(v7 + 17) >> 1) & 1);
      long long v148 = v141;
      unsigned int v149 = v142;
      if (v151 >= 0x41 && v150) {
        MEMORY[0x1D25D9CB0](v150, 0x1000C8000313F17);
      }
      unsigned int v99 = 0;
      __int16 v150 = v143;
      unsigned int v151 = v144;
      unsigned int v144 = 0;
      if (v153 >= 0x41)
      {
        if (v152)
        {
          MEMORY[0x1D25D9CB0](v152, 0x1000C8000313F17);
          unsigned int v99 = v144;
        }
        else
        {
          unsigned int v99 = 0;
        }
      }
      __int16 v152 = v145;
      unsigned int v153 = v146;
      unsigned int v146 = 0;
      char v154 = v147;
      if (v99 >= 0x41 && v143) {
        MEMORY[0x1D25D9CB0](v143, 0x1000C8000313F17);
      }
      if (v140 >= 0x41 && __src) {
        MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
      }
      if (v153 < v138)
      {
        llvm::APInt::sext((uint64_t)&v152, v138, (uint64_t)&v141);
      }
      else
      {
        DWORD2(v141) = v153;
        if (v153 > 0x40) {
          operator new[]();
        }
        *(void *)&long long v141 = v152;
      }
      uint64_t v100 = *(unsigned int *)(a5 + 16);
      if (v100 >= 0x41)
      {
        uint64_t v115 = 0;
        uint64_t v116 = (unint64_t *)*v17;
        int v117 = (uint64_t *)v141;
        unint64_t v118 = (unint64_t)(v100 + 63) >> 6;
        unint64_t v119 = v118;
        do
        {
          uint64_t v120 = *v117++;
          unint64_t v121 = v120 + *v116;
          BOOL v122 = v121 + 1 <= *v116;
          if (v115)
          {
            ++v121;
            uint64_t v115 = v122;
          }
          else
          {
            uint64_t v115 = v121 < *v116;
          }
          *v116++ = v121;
          --v119;
        }
        while (v119);
        *(void *)(*v17 + 8 * (v118 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v100;
        unsigned int v98 = v138;
      }
      else
      {
        if (v100) {
          unint64_t v101 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v100;
        }
        else {
          unint64_t v101 = 0;
        }
        *unint64_t v17 = v101 & (*v17 + v141);
      }
      if (DWORD2(v141) >= 0x41 && (void)v141) {
        MEMORY[0x1D25D9CB0](v141, 0x1000C8000313F17);
      }
      if (v151 < v98)
      {
        llvm::APInt::sext((uint64_t)&v150, v98, (uint64_t)&__src);
      }
      else
      {
        unsigned int v140 = v151;
        if (v151 > 0x40) {
          operator new[]();
        }
        __src = v150;
      }
      uint64_t v102 = *(unsigned int *)(a5 + 32);
      if (v102)
      {
        uint64_t v103 = 0;
        uint64_t v104 = *v136;
        uint64_t v105 = 56 * v102;
        while (1)
        {
          if (*(_OWORD *)(v104 + v103) == v148)
          {
            uint64_t v106 = v104 + v103;
            if (*(_DWORD *)(v104 + v103 + 16) == v149) {
              break;
            }
          }
          v103 += 56;
          if (v105 == v103) {
            goto LABEL_181;
          }
        }
        char v113 = v140;
        if (v140 >= 0x41)
        {
          uint64_t v123 = 0;
          int v124 = (unint64_t *)__src;
          uint64_t v125 = *(uint64_t **)(v106 + 24);
          unint64_t v126 = ((unint64_t)v140 + 63) >> 6;
          unint64_t v127 = v126;
          do
          {
            uint64_t v128 = *v125++;
            unint64_t v129 = v128 + *v124;
            BOOL v130 = v129 + 1 <= *v124;
            if (v123)
            {
              ++v129;
              uint64_t v123 = v130;
            }
            else
            {
              uint64_t v123 = v129 < *v124;
            }
            *v124++ = v129;
            --v127;
          }
          while (v127);
          *((void *)__src + (v126 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -v113;
          uint64_t v104 = *v136;
        }
        else
        {
          if (v140) {
            unint64_t v114 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v140;
          }
          else {
            unint64_t v114 = 0;
          }
          __src = (void *)(v114 & ((unint64_t)__src + *(void *)(v106 + 24)));
        }
        sub_1CBF6C9F4(v136, v104 + v103);
      }
LABEL_181:
      sub_1CBF6CAF4((uint64_t)&v141, (uint64_t)&__src, v137);
      if (v140 >= 0x41 && __src) {
        MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
      }
      size_t v107 = (void *)v141;
      __src = (void *)v141;
      unsigned int v108 = DWORD2(v141);
      unsigned int v140 = DWORD2(v141);
      if (DWORD2(v141) > 0x40)
      {
        int v109 = 0;
        int64_t v110 = ((unint64_t)DWORD2(v141) + 63) >> 6;
        do
        {
          BOOL v57 = v110-- < 1;
          if (v57) {
            break;
          }
          unint64_t v111 = *(void *)(v141 + 8 * v110);
          v109 += __clz(v111);
        }
        while (!v111);
        unsigned int v112 = DWORD2(v141) | 0xFFFFFFC0;
        if ((BYTE8(v141) & 0x3F) == 0) {
          unsigned int v112 = 0;
        }
        if (v109 + v112 != DWORD2(v141))
        {
          long long v141 = v148;
          unsigned int v142 = v149;
          unsigned int v144 = v108;
          operator new[]();
        }
LABEL_199:
        if (v107) {
          MEMORY[0x1D25D9CB0](v107, 0x1000C8000313F17);
        }
      }
      else if ((void)v141)
      {
        long long v141 = v148;
        unsigned int v142 = v149;
        unsigned int v144 = v108;
        uint64_t v143 = v107;
        uint64_t v145 = v133;
        LOBYTE(v146) = v154;
        sub_1CBF6CC78((uint64_t)v136, (char *)&v141);
        if (v144 >= 0x41 && v143) {
          MEMORY[0x1D25D9CB0](v143, 0x1000C8000313F17);
        }
        if (v140 >= 0x41)
        {
          size_t v107 = __src;
          goto LABEL_199;
        }
      }
      if (v153 >= 0x41 && v152) {
        MEMORY[0x1D25D9CB0](v152, 0x1000C8000313F17);
      }
      if (v151 >= 0x41 && v150) {
        MEMORY[0x1D25D9CB0](v150, 0x1000C8000313F17);
      }
      sub_1CB8460E4((uint64_t)&v157);
      char v46 = 0;
      v45 += 4;
      if (v45 != v44) {
        continue;
      }
      break;
    }
LABEL_236:
    int v131 = *(_DWORD *)(v7 + 20);
    if ((v131 & 0x40000000) != 0) {
      uint64_t v24 = *(uint64_t **)(v7 - 8);
    }
    else {
      uint64_t v24 = (uint64_t *)(v7 - 32 * (v131 & 0x7FFFFFF));
    }
LABEL_239:
    this = *v24;
LABEL_240:
    uint64_t v7 = this;
    --v18;
  }
  while (v18);
  *(void *)a5 = v7;
  return this;
}

void sub_1CBF6BB20(uint64_t a1, unint64_t *a2, const llvm::APInt *a3, int a4, const llvm::DataLayout *a5, const llvm::Instruction *a6)
{
  if (a4 == 6)
  {
LABEL_2:
    sub_1CBF73FC8(a1, (uint64_t)a2);
    return;
  }
  unint64_t v8 = *a2;
  unsigned int v9 = *(unsigned __int8 *)(*a2 + 16);
  if (*a2) {
    BOOL v10 = v9 == 16;
  }
  else {
    BOOL v10 = 0;
  }
  if (!v10)
  {
    if (v8) {
      BOOL v15 = v9 >= 0x1C;
    }
    else {
      BOOL v15 = 0;
    }
    BOOL v16 = v15 && v9 - 59 >= 0xFFFFFFEE;
    if (!v16 || ((uint64_t v17 = *(void *)(v8 - 32)) != 0 ? (v18 = *(unsigned char *)(v17 + 16) == 16) : (v18 = 0), !v18))
    {
      if (v9 == 68)
      {
        uint64_t v31 = *(llvm::Type ***)(v8 - 32);
        int PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits(*(llvm::Type **)v8);
        int v34 = v33;
        unsigned int v36 = PrimitiveSizeInBits - llvm::Type::getPrimitiveSizeInBits(*v31);
        if (v34 == 1) {
        unsigned int v37 = *((_DWORD *)a2 + 4);
        }
        unsigned int v28 = v37 - v36;
        if (v37 >= v36)
        {
          int v38 = *((_DWORD *)a2 + 3);
        }
        else
        {
          unsigned int v28 = 0;
          int v38 = v36 - v37 + *((_DWORD *)a2 + 3);
        }
        unsigned int v40 = *((_DWORD *)a2 + 2);
        *(void *)&long long v125 = v31;
        *((void *)&v125 + 1) = __PAIR64__(v38, v40);
      }
      else
      {
        if (v9 != 67) {
          goto LABEL_2;
        }
        unsigned int v19 = *(llvm::Type ***)(v8 - 32);
        int v20 = llvm::Type::getPrimitiveSizeInBits(*(llvm::Type **)v8);
        int v22 = v21;
        unsigned int v24 = v20 - llvm::Type::getPrimitiveSizeInBits(*v19);
        if (v22 == 1) {
        unsigned int v26 = *((_DWORD *)a2 + 3);
        }
        unsigned int v25 = *((_DWORD *)a2 + 4);
        unsigned int v27 = *((_DWORD *)a2 + 2);
        if (v24 > v25)
        {
          v27 += v24 - v25 + v26;
          unsigned int v26 = 0;
        }
        BOOL v15 = v25 >= v24;
        unsigned int v28 = v25 - v24;
        if (!v15) {
          unsigned int v28 = 0;
        }
        *(void *)&long long v125 = v19;
        *((void *)&v125 + 1) = __PAIR64__(v26, v27);
      }
      LODWORD(v126) = v28;
      sub_1CBF6BB20(a1, &v125, a3, (a4 + 1), a5, a6);
      return;
    }
    uint64_t v39 = (const llvm::Value *)(v17 + 24);
    unsigned int v133 = *(_DWORD *)(v17 + 32);
    if (v133 > 0x40) {
      operator new[]();
    }
    uint64_t v132 = *(void *)v39;
    sub_1CBF741A8((uint64_t)&v134, a2, (llvm::APInt *)&v132);
    if (v133 >= 0x41 && v132) {
      MEMORY[0x1D25D9CB0](v132, 0x1000C8000313F17);
    }
    HIDWORD(v42) = *(unsigned __int8 *)(v8 + 16) - 41;
    LODWORD(v42) = HIDWORD(v42);
    unsigned int v41 = v42 >> 1;
    BOOL v43 = v41 > 6;
    int v44 = (1 << v41) & 0x47;
    if (v43 || v44 == 0)
    {
      int v47 = 1;
    }
    else
    {
      unsigned int v46 = *(unsigned __int8 *)(v8 + 17);
      if ((v46 & 2) == 0 && *((_DWORD *)a2 + 2) || (int v47 = (v46 >> 2) & 1, (v46 & 4) == 0) && *((_DWORD *)a2 + 3))
      {
        sub_1CBF73FC8(a1, (uint64_t)a2);
LABEL_164:
        if (v135 >= 0x41 && v134) {
          MEMORY[0x1D25D9CB0](v134, 0x1000C8000313F17);
        }
        return;
      }
    }
    if (*((_DWORD *)a2 + 4)) {
      int v48 = 0;
    }
    else {
      int v48 = v47;
    }
    sub_1CBF73FC8((uint64_t)&v125, (uint64_t)a2);
    HIDWORD(v49) = *(unsigned __int8 *)(v8 + 16) - 41;
    LODWORD(v49) = HIDWORD(v49);
    switch((v49 >> 1))
    {
      case 0u:
        goto LABEL_96;
      case 1u:
        unint64_t v50 = a2[1];
        int v51 = *((_DWORD *)a2 + 4);
        uint64_t v111 = *(void *)(v8 - 64);
        unint64_t v112 = v50;
        int v113 = v51;
        sub_1CBF6BB20(&v118, &v111, a3, (a4 + 1), a5, a6);
        long long v125 = v118;
        LODWORD(v126) = v119;
        if (v128 >= 0x41 && v127) {
          MEMORY[0x1D25D9CB0](v127, 0x1000C8000313F17);
        }
        BOOL v52 = 0;
        unint64_t v127 = v120;
        unsigned int v128 = v121;
        unsigned int v121 = 0;
        if (v130 >= 0x41)
        {
          if (v129)
          {
            MEMORY[0x1D25D9CB0](v129, 0x1000C8000313F17);
            BOOL v52 = v121 > 0x40;
          }
          else
          {
            BOOL v52 = 0;
          }
        }
        unint64_t v129 = v122;
        unsigned int v68 = v123;
        unsigned int v130 = v123;
        unsigned int v123 = 0;
        char v131 = v124;
        if (v52 && v120)
        {
          MEMORY[0x1D25D9CB0](v120, 0x1000C8000313F17);
          unsigned int v68 = v130;
        }
        if (v68 >= 0x41)
        {
          uint64_t v78 = 0;
          unint64_t v79 = (unint64_t *)v129;
          uint64_t v80 = v134;
          unint64_t v81 = ((unint64_t)v68 + 63) >> 6;
          unint64_t v82 = v81;
          do
          {
            unint64_t v83 = *v80++;
            unint64_t v84 = *v79 - v83;
            BOOL v85 = *v79 < v83;
            unint64_t v86 = *v79 + ~v83;
            if (v78)
            {
              uint64_t v78 = v86 >= *v79;
            }
            else
            {
              unint64_t v86 = v84;
              uint64_t v78 = v85;
            }
            *v79++ = v86;
            --v82;
          }
          while (v82);
          goto LABEL_173;
        }
        unint64_t v69 = v129 - (void)v134;
        if (v68) {
          goto LABEL_109;
        }
        goto LABEL_132;
      case 2u:
        unint64_t v53 = a2[1];
        int v54 = *((_DWORD *)a2 + 4);
        v109[0] = *(void *)(v8 - 64);
        v109[1] = v53;
        int v110 = v54;
        sub_1CBF6BB20(&v111, v109, a3, (a4 + 1), a5, a6);
        sub_1CBF6C868((uint64_t)&v118, (uint64_t)&v111, (uint64_t)&v134, v48);
        long long v125 = v118;
        LODWORD(v126) = v119;
        if (v128 >= 0x41 && v127) {
          MEMORY[0x1D25D9CB0](v127, 0x1000C8000313F17);
        }
        BOOL v55 = 0;
        unint64_t v127 = v120;
        unsigned int v128 = v121;
        unsigned int v121 = 0;
        if (v130 >= 0x41)
        {
          if (v129)
          {
            MEMORY[0x1D25D9CB0](v129, 0x1000C8000313F17);
            BOOL v55 = v121 > 0x40;
          }
          else
          {
            BOOL v55 = 0;
          }
        }
        unint64_t v129 = v122;
        unsigned int v130 = v123;
        unsigned int v123 = 0;
        char v131 = v124;
        if (v55 && v120) {
          MEMORY[0x1D25D9CB0](v120, 0x1000C8000313F17);
        }
        if (v117 >= 0x41 && v116) {
          MEMORY[0x1D25D9CB0](v116, 0x1000C8000313F17);
        }
        if (v115 >= 0x41 && v114) {
          MEMORY[0x1D25D9CB0](v114, 0x1000C8000313F17);
        }
        char v71 = v131;
        goto LABEL_157;
      case 6u:
        uint64_t v108 = v135;
        if (v135 >= 0x41)
        {
          int v87 = 0;
          int64_t v88 = ((unint64_t)v135 + 63) >> 6;
          int64_t v56 = (unsigned int *)v134;
          do
          {
            BOOL v43 = v88-- < 1;
            if (v43) {
              break;
            }
            unint64_t v89 = v134[v88];
            v87 += __clz(v89);
          }
          while (!v89);
          unsigned int v90 = v135 | 0xFFFFFFC0;
          if ((v135 & 0x3F) == 0) {
            unsigned int v90 = 0;
          }
          if (v135 - v87 - v90 > 0x40) {
            unint64_t v57 = -1;
          }
          else {
            unint64_t v57 = *v134;
          }
        }
        else
        {
          int64_t v56 = (unsigned int *)v134;
          unint64_t v57 = (unint64_t)v134;
        }
        int v58 = llvm::Type::getPrimitiveSizeInBits(*(llvm::Type **)*a2);
        if (v59 == 1)
        {
          int v107 = v58;
          int v58 = v107;
        }
        unsigned int v61 = *((_DWORD *)a2 + 3);
        int v60 = *((_DWORD *)a2 + 4);
        unsigned int v62 = *((_DWORD *)a2 + 2);
        if (v57 > v58 - v60 + v62 + v61) {
          goto LABEL_102;
        }
        uint64_t v111 = *(void *)(v8 - 64);
        unint64_t v112 = __PAIR64__(v61, v62);
        int v113 = v60;
        sub_1CBF6BB20(&v118, &v111, a3, (a4 + 1), a5, a6);
        long long v125 = v118;
        LODWORD(v126) = v119;
        if (v128 >= 0x41 && v127) {
          MEMORY[0x1D25D9CB0](v127, 0x1000C8000313F17);
        }
        unsigned int v63 = 0;
        unint64_t v127 = v120;
        unsigned int v128 = v121;
        unsigned int v121 = 0;
        uint64_t v64 = v108;
        if (v130 >= 0x41)
        {
          if (v129)
          {
            MEMORY[0x1D25D9CB0](v129, 0x1000C8000313F17);
            unsigned int v63 = v121;
          }
          else
          {
            unsigned int v63 = 0;
          }
        }
        unint64_t v129 = v122;
        unsigned int v130 = v123;
        unsigned int v123 = 0;
        char v131 = v124;
        if (v63 >= 0x41 && v120) {
          MEMORY[0x1D25D9CB0](v120, 0x1000C8000313F17);
        }
        unsigned int v72 = v56;
        if (v108 >= 0x41)
        {
          int v91 = 0;
          int64_t v92 = (unint64_t)(v108 + 63) >> 6;
          do
          {
            BOOL v43 = v92-- < 1;
            if (v43) {
              break;
            }
            unint64_t v93 = *(void *)&v56[2 * v92];
            v91 += __clz(v93);
          }
          while (!v93);
          int v94 = v108 | 0xFFFFFFC0;
          if ((v108 & 0x3F) == 0) {
            int v94 = 0;
          }
          if ((v108 - v91 - v94) > 0x40) {
            unsigned int v72 = -1;
          }
          else {
            unsigned int v72 = *v56;
          }
          uint64_t v64 = v108;
        }
        if (v130 > 0x40)
        {
          llvm::APInt::shlSlowCase((llvm::APInt *)&v129, v72);
        }
        else
        {
          unint64_t v73 = v129 << v72;
          if (v130 == v72) {
            unint64_t v73 = 0;
          }
          if (v130) {
            unint64_t v74 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v130;
          }
          else {
            unint64_t v74 = 0;
          }
          unint64_t v129 = v74 & v73;
        }
        if (v64 >= 0x41)
        {
          int v95 = 0;
          int64_t v96 = (unint64_t)(v64 + 63) >> 6;
          do
          {
            BOOL v43 = v96-- < 1;
            if (v43) {
              break;
            }
            unint64_t v97 = *(void *)&v56[2 * v96];
            v95 += __clz(v97);
          }
          while (!v97);
          int v98 = v108 | 0xFFFFFFC0;
          if ((v108 & 0x3F) == 0) {
            int v98 = 0;
          }
          if ((v108 - v95 - v98) > 0x40) {
            LODWORD(v56) = -1;
          }
          else {
            LODWORD(v56) = *v56;
          }
        }
        if (v128 > 0x40)
        {
          llvm::APInt::shlSlowCase((llvm::APInt *)&v127, v56);
        }
        else
        {
          unint64_t v75 = v127 << (char)v56;
          if (v128 == v56) {
            unint64_t v75 = 0;
          }
          if (v128) {
            unint64_t v76 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v128;
          }
          else {
            unint64_t v76 = 0;
          }
          unint64_t v127 = v76 & v75;
        }
        if (v131) {
          char v71 = v48;
        }
        else {
          char v71 = 0;
        }
        char v131 = v71;
        goto LABEL_157;
      case 8u:
        if (!llvm::MaskedValueIsZero(*(llvm **)(v8 - 64), v39, a3, 0, a5, (llvm::AssumptionCache *)v8, a6, (const llvm::DominatorTree *)1, v106))goto LABEL_102; {
LABEL_96:
        }
        unint64_t v65 = a2[1];
        int v66 = *((_DWORD *)a2 + 4);
        uint64_t v111 = *(void *)(v8 - 64);
        unint64_t v112 = v65;
        int v113 = v66;
        sub_1CBF6BB20(&v118, &v111, a3, (a4 + 1), a5, a6);
        long long v125 = v118;
        LODWORD(v126) = v119;
        if (v128 >= 0x41 && v127) {
          MEMORY[0x1D25D9CB0](v127, 0x1000C8000313F17);
        }
        BOOL v67 = 0;
        unint64_t v127 = v120;
        unsigned int v128 = v121;
        unsigned int v121 = 0;
        if (v130 >= 0x41)
        {
          if (v129)
          {
            MEMORY[0x1D25D9CB0](v129, 0x1000C8000313F17);
            BOOL v67 = v121 > 0x40;
          }
          else
          {
            BOOL v67 = 0;
          }
        }
        unint64_t v129 = v122;
        unsigned int v68 = v123;
        unsigned int v130 = v123;
        unsigned int v123 = 0;
        char v131 = v124;
        if (v67 && v120)
        {
          MEMORY[0x1D25D9CB0](v120, 0x1000C8000313F17);
          unsigned int v68 = v130;
        }
        if (v68 >= 0x41)
        {
          uint64_t v99 = 0;
          uint64_t v100 = (unint64_t *)v129;
          unint64_t v101 = (uint64_t *)v134;
          unint64_t v81 = ((unint64_t)v68 + 63) >> 6;
          unint64_t v102 = v81;
          do
          {
            uint64_t v103 = *v101++;
            unint64_t v104 = v103 + *v100;
            BOOL v105 = v104 + 1 <= *v100;
            if (v99)
            {
              ++v104;
              uint64_t v99 = v105;
            }
            else
            {
              uint64_t v99 = v104 < *v100;
            }
            *v100++ = v104;
            --v102;
          }
          while (v102);
LABEL_173:
          *(void *)(v129 + 8 * (v81 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v68;
        }
        else
        {
          unint64_t v69 = (unint64_t)v134 + v129;
          if (v68) {
LABEL_109:
          }
            unint64_t v70 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v68;
          else {
LABEL_132:
          }
            unint64_t v70 = 0;
          unint64_t v129 = v70 & v69;
        }
        if (v131) {
          char v71 = v48;
        }
        else {
          char v71 = 0;
        }
        char v131 = v71;
LABEL_157:
        *(_OWORD *)a1 = v125;
        *(_DWORD *)(a1 + 32) = v128;
        unint64_t v77 = v127;
        *(void *)(a1 + 16) = v126;
        *(void *)(a1 + 24) = v77;
        *(_DWORD *)(a1 + ++*(_DWORD *)(result + 48) = v130;
        *(void *)(a1 + 40) = v129;
        unsigned int v128 = 0;
        unsigned int v130 = 0;
        *(unsigned char *)(a1 + 56) = v71;
LABEL_158:
        if (v130 >= 0x41 && v129) {
          MEMORY[0x1D25D9CB0](v129, 0x1000C8000313F17);
        }
        if (v128 >= 0x41 && v127) {
          MEMORY[0x1D25D9CB0](v127, 0x1000C8000313F17);
        }
        break;
      default:
LABEL_102:
        sub_1CBF73FC8(a1, (uint64_t)a2);
        goto LABEL_158;
    }
    goto LABEL_164;
  }
  int v30 = llvm::Type::getPrimitiveSizeInBits(*(llvm::Type **)v8);
  if (v29 == 1) {
  DWORD2(v125) = v30 - *((_DWORD *)a2 + 4) + *((_DWORD *)a2 + 2) + *((_DWORD *)a2 + 3);
  }
  if (DWORD2(v125) >= 0x41) {
    operator new[]();
  }
  *(void *)&long long v125 = 0;
  unsigned int v137 = *(_DWORD *)(v8 + 32);
  if (v137 > 0x40) {
    operator new[]();
  }
  uint64_t v136 = *(void *)(v8 + 24);
  sub_1CBF741A8((uint64_t)&v118, a2, (llvm::APInt *)&v136);
  sub_1CBF74408(a1, (long long *)a2, (uint64_t)&v125, (uint64_t)&v118, 1);
  if (DWORD2(v118) >= 0x41 && (void)v118) {
    MEMORY[0x1D25D9CB0](v118, 0x1000C8000313F17);
  }
  if (v137 >= 0x41 && v136) {
    MEMORY[0x1D25D9CB0](v136, 0x1000C8000313F17);
  }
}

uint64_t sub_1CBF6C868(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (*(unsigned char *)(a2 + 56))
  {
    uint64_t v7 = *(unsigned int *)(a3 + 8);
    if (v7 > 0x40)
    {
      int v10 = 0;
      int64_t v11 = (unint64_t)(v7 + 63) >> 6;
      do
      {
        BOOL v12 = v11-- < 1;
        if (v12) {
          break;
        }
        unint64_t v13 = *(void *)(*(void *)a3 + 8 * v11);
        v10 += __clz(v13);
      }
      while (!v13);
      int v14 = v7 | 0xFFFFFFC0;
      if ((v7 & 0x3F) == 0) {
        int v14 = 0;
      }
      BOOL v8 = v10 + v14 == v7 - 1;
    }
    else
    {
      BOOL v8 = *(void *)a3 == 1;
    }
    char v9 = v8;
    if ((v9 & 1) == 0 && a4)
    {
      uint64_t v15 = *(unsigned int *)(a2 + 48);
      if (v15 > 0x40)
      {
        int v17 = 0;
        int64_t v18 = (unint64_t)(v15 + 63) >> 6;
        do
        {
          BOOL v12 = v18-- < 1;
          if (v12) {
            break;
          }
          unint64_t v19 = *(void *)(*(void *)(a2 + 40) + 8 * v18);
          v17 += __clz(v19);
        }
        while (!v19);
        int v20 = v15 | 0xFFFFFFC0;
        if ((v15 & 0x3F) == 0) {
          int v20 = 0;
        }
        BOOL v16 = v17 + v20 == v15;
      }
      else
      {
        BOOL v16 = *(void *)(a2 + 40) == 0;
      }
      char v9 = v16;
    }
  }
  else
  {
    char v9 = 0;
  }
  llvm::APInt::operator*(a2 + 24, (void *)a3, (uint64_t)&v24);
  llvm::APInt::operator*(a2 + 40, (void *)a3, (uint64_t)&v22);
  uint64_t result = sub_1CBF74408(a1, (long long *)a2, (uint64_t)&v24, (uint64_t)&v22, v9);
  if (v23 >= 0x41)
  {
    uint64_t result = v22;
    if (v22) {
      uint64_t result = MEMORY[0x1D25D9CB0](v22, 0x1000C8000313F17);
    }
  }
  if (v25 >= 0x41)
  {
    uint64_t result = v24;
    if (v24) {
      return MEMORY[0x1D25D9CB0](v24, 0x1000C8000313F17);
    }
  }
  return result;
}

uint64_t sub_1CBF6C9F4(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  unsigned int v5 = *((_DWORD *)a1 + 2);
  uint64_t v6 = *a1 + 56 * v5;
  uint64_t v7 = a2 + 56;
  if (a2 + 56 != v6)
  {
    do
    {
      *(_OWORD *)(v7 - 56) = *(_OWORD *)v7;
      *(_DWORD *)(v7 - 40) = *(_DWORD *)(v7 + 16);
      if (*(_DWORD *)(v7 - 24) >= 0x41u)
      {
        uint64_t v8 = *(void *)(v7 - 32);
        if (v8) {
          MEMORY[0x1D25D9CB0](v8, 0x1000C8000313F17);
        }
      }
      *(void *)(v7 - 32) = *(void *)(v7 + 24);
      *(_DWORD *)(v7 - 24) = *(_DWORD *)(v7 + 32);
      *(_DWORD *)(v7 + 32) = 0;
      *(void *)(v7 - 16) = *(void *)(v7 + 40);
      *(unsigned char *)(v7 - 8) = *(unsigned char *)(v7 + 48);
      v7 += 56;
    }
    while (v7 != v6);
    unsigned int v5 = *((_DWORD *)a1 + 2);
    uint64_t v4 = *a1;
  }
  unsigned int v9 = v5 - 1;
  *((_DWORD *)a1 + 2) = v9;
  if (*(_DWORD *)(v4 + 56 * v9 + 32) >= 0x41u)
  {
    uint64_t v10 = *(void *)(v4 + 56 * v9 + 24);
    if (v10) {
      MEMORY[0x1D25D9CB0](v10, 0x1000C8000313F17);
    }
  }
  return a2;
}

uint64_t sub_1CBF6CAF4(uint64_t result, uint64_t a2, int a3)
{
  unsigned int v3 = *(_DWORD *)(a2 + 8);
  int v4 = v3 - a3;
  if (v3 > 0x40) {
    operator new[]();
  }
  uint64_t v5 = *(void *)a2 << v4;
  if (!a3) {
    uint64_t v5 = 0;
  }
  unint64_t v6 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v3;
  if (!v3) {
    unint64_t v6 = 0;
  }
  *(_DWORD *)(result + 8) = v3;
  uint64_t v7 = (uint64_t)((v6 & v5) << -(char)v3) >> -(char)v3;
  if (v3 == v4) {
    char v8 = 63;
  }
  else {
    char v8 = v3 - a3;
  }
  uint64_t v9 = v7 >> v8;
  if (v3) {
    unint64_t v10 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v3;
  }
  else {
    unint64_t v10 = 0;
  }
  *(void *)uint64_t result = v10 & v9;
  return result;
}

void sub_1CBF6CC78(uint64_t a1, char *a2)
{
  uint64_t v2 = a2;
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  uint64_t v4 = *(unsigned int *)(a1 + 12);
  unint64_t v6 = *(char **)a1;
  if (v5 >= v4)
  {
    unint64_t v12 = v5 + 1;
    BOOL v14 = v6 <= a2 && &v6[56 * v5] > a2;
    if (v14) {
      uint64_t v15 = 0x6DB6DB6DB6DB6DB7 * ((a2 - v6) >> 3);
    }
    else {
      uint64_t v15 = -1;
    }
    if (v5 == -1) {
      sub_1CD0A88F0(v12);
    }
    if (v4 == -1) {
      sub_1CD0A89A8(0xFFFFFFFFuLL);
    }
    unint64_t v16 = (2 * v4) | 1;
    if (v16 <= v12) {
      unint64_t v16 = v5 + 1;
    }
    if (v16 >= 0xFFFFFFFF) {
      uint64_t v17 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v17 = v16;
    }
    int64_t v18 = (char *)malloc_type_malloc(56 * v17, 0x4065EBACuLL);
    if (!v18) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    unint64_t v6 = v18;
    unint64_t v19 = *(char **)a1;
    unsigned int v20 = *(_DWORD *)(a1 + 8);
    if (v20)
    {
      int v21 = &v19[56 * v20];
      uint64_t v22 = v18;
      do
      {
        long long v23 = *(_OWORD *)v19;
        *((void *)v22 + 2) = *((void *)v19 + 2);
        *(_OWORD *)uint64_t v22 = v23;
        *((_DWORD *)v22 + 8) = *((_DWORD *)v19 + 8);
        *((void *)v22 + 3) = *((void *)v19 + 3);
        *((_DWORD *)v19 + 8) = 0;
        uint64_t v24 = *((void *)v19 + 5);
        v22[48] = v19[48];
        *((void *)v22 + 5) = v24;
        v19 += 56;
        v22 += 56;
      }
      while (v19 != v21);
      unint64_t v19 = *(char **)a1;
      uint64_t v25 = *(unsigned int *)(a1 + 8);
      if (v25)
      {
        uint64_t v26 = 56 * v25;
        do
        {
          if (*(_DWORD *)&v19[v26 - 24] >= 0x41u)
          {
            uint64_t v27 = *(void *)&v19[v26 - 32];
            if (v27) {
              MEMORY[0x1D25D9CB0](v27, 0x1000C8000313F17);
            }
          }
          v26 -= 56;
        }
        while (v26);
        unint64_t v19 = *(char **)a1;
      }
    }
    if (v19 != (char *)(a1 + 16)) {
      free(v19);
    }
    *(void *)a1 = v6;
    *(_DWORD *)(a1 + 12) = v17;
    if (v14) {
      uint64_t v2 = &v6[56 * v15];
    }
    LODWORD(v5) = *(_DWORD *)(a1 + 8);
  }
  uint64_t v7 = &v6[56 * v5];
  long long v8 = *(_OWORD *)v2;
  *((void *)v7 + 2) = *((void *)v2 + 2);
  *(_OWORD *)uint64_t v7 = v8;
  unsigned int v9 = *((_DWORD *)v2 + 8);
  *((_DWORD *)v7 + 8) = v9;
  if (v9 > 0x40) {
    operator new[]();
  }
  *((void *)v7 + 3) = *((void *)v2 + 3);
  unint64_t v10 = &v6[56 * v5];
  uint64_t v11 = *((void *)v2 + 5);
  v10[48] = v2[48];
  *((void *)v10 + 5) = v11;
  ++*(_DWORD *)(a1 + 8);
}

uint64_t llvm::BasicAAResult::pointsToConstantMemory(uint64_t a1, uint64_t **a2, uint64_t a3, int a4)
{
  v43[16] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = **a2;
  unsigned int v8 = *(_DWORD *)(v7 + 8);
  if ((v8 & 0xFE) == 0x12) {
    unsigned int v8 = *(_DWORD *)(**(void **)(v7 + 16) + 8);
  }
  if (!(*(unsigned int (**)(void, void))(***(void ***)(a1 + 32) + 1224))(**(void **)(a1 + 32), v8 >> 8))return 1; {
  unsigned int v40 = v43;
  }
  unsigned int v42 = 16;
  v43[0] = *a2;
  unsigned int v9 = 8;
  unsigned int v10 = 1;
  while (1)
  {
    uint64_t v11 = (llvm *)*((void *)v40 + v10 - 1);
    unsigned int v41 = v10 - 1;
    UnderlyingObject = llvm::getUnderlyingObject(v11, (const llvm::Value *)6);
    unint64_t v13 = *(void **)(a1 + 168);
    uint64_t v14 = *(unsigned int *)(a1 + 180);
    if (v13 != *(void **)(a1 + 160))
    {
      unsigned int v18 = *(_DWORD *)(a1 + 176);
      goto LABEL_24;
    }
    if (v14) {
      break;
    }
LABEL_13:
    unsigned int v18 = *(_DWORD *)(a1 + 176);
    if (v14 < v18)
    {
      *(_DWORD *)(a1 + 180) = v14 + 1;
      v13[v14] = UnderlyingObject;
      goto LABEL_15;
    }
LABEL_24:
    if (3 * v18 <= 4 * ((int)v14 - *(_DWORD *)(a1 + 184)))
    {
      if (v18 >= 0x40) {
        v18 *= 2;
      }
      else {
        unsigned int v18 = 128;
      }
LABEL_75:
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(a1 + 160), v18);
      unsigned int v18 = *(_DWORD *)(a1 + 176);
      unint64_t v13 = *(void **)(a1 + 168);
      goto LABEL_26;
    }
    if (v18 - v14 < v18 >> 3) {
      goto LABEL_75;
    }
LABEL_26:
    unsigned int v21 = v18 - 1;
    unsigned int v22 = (v18 - 1) & ((UnderlyingObject >> 4) ^ (UnderlyingObject >> 9));
    long long v23 = (llvm **)&v13[v22];
    uint64_t v24 = *v23;
    if (*v23 != (llvm *)-1)
    {
      uint64_t v25 = 0;
      int v26 = 1;
      while (v24 != UnderlyingObject)
      {
        if (v25) {
          BOOL v27 = 0;
        }
        else {
          BOOL v27 = v24 == (llvm *)-2;
        }
        if (v27) {
          uint64_t v25 = v23;
        }
        unsigned int v28 = v22 + v26++;
        unsigned int v22 = v28 & v21;
        long long v23 = (llvm **)&v13[v28 & v21];
        uint64_t v24 = *v23;
        if (*v23 == (llvm *)-1) {
          goto LABEL_36;
        }
      }
      goto LABEL_48;
    }
    uint64_t v25 = 0;
LABEL_36:
    if (v25) {
      long long v23 = v25;
    }
    if (*v23 == UnderlyingObject) {
      goto LABEL_48;
    }
    if (*v23 == (llvm *)-2) {
      --*(_DWORD *)(a1 + 184);
    }
    else {
      ++*(_DWORD *)(a1 + 180);
    }
    *long long v23 = UnderlyingObject;
LABEL_15:
    unsigned int v19 = *(_DWORD *)(*(void *)UnderlyingObject + 8);
    if ((v19 & 0xFE) == 0x12) {
      unsigned int v19 = *(_DWORD *)(**(void **)(*(void *)UnderlyingObject + 16) + 8);
    }
    if ((*(unsigned int (**)(void, void))(***(void ***)(a1 + 32) + 1224))(**(void **)(a1 + 32), v19 >> 8))
    {
      int v20 = *((unsigned __int8 *)UnderlyingObject + 16);
      if (!a4)
      {
        if (v20 != 3) {
          goto LABEL_20;
        }
        goto LABEL_42;
      }
      if (*((unsigned __int8 *)UnderlyingObject + 16) <= 0x3Au)
      {
        if (v20 != 3) {
          goto LABEL_43;
        }
LABEL_42:
        if ((*((unsigned char *)UnderlyingObject + 80) & 1) == 0) {
          goto LABEL_43;
        }
        goto LABEL_61;
      }
      if (v20 != 59)
      {
LABEL_20:
        if (v20 == 85)
        {
          if (v41 >= (unint64_t)v42) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v40 + v41) = *((void *)UnderlyingObject - 8);
          unsigned int v33 = v41 + 1;
          unsigned int v41 = v33;
          uint64_t v34 = *((void *)UnderlyingObject - 4);
          if (v33 >= v42) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v40 + v33) = v34;
          ++v41;
        }
        else
        {
          if (v20 != 83 || (int v36 = *((_DWORD *)UnderlyingObject + 5), v37 = v36 & 0x7FFFFFF, (v36 & 0x7FFFFFFu) > v9))
          {
LABEL_43:
            unint64_t v13 = *(void **)(a1 + 168);
            if (v13 == *(void **)(a1 + 160))
            {
LABEL_44:
              BOOL v29 = 0;
              *(_DWORD *)(a1 + 180) = 0;
              *(_DWORD *)(a1 + 184) = 0;
              goto LABEL_45;
            }
            uint64_t v31 = *(unsigned int *)(a1 + 176);
            if (v31 < 0x21 || 4 * (*(_DWORD *)(a1 + 180) - *(_DWORD *)(a1 + 184)) >= v31)
            {
LABEL_57:
              memset(v13, 255, 8 * v31);
              goto LABEL_44;
            }
            goto LABEL_76;
          }
          if ((v36 & 0x40000000) != 0)
          {
            int v38 = (char *)*((void *)UnderlyingObject - 1);
          }
          else
          {
            uint64_t v37 = v37;
            int v38 = (char *)UnderlyingObject - 32 * v37;
          }
          sub_1CBF74A6C((uint64_t)&v40, (uint64_t)v40 + 8 * v41, v38, &v38[32 * v37]);
        }
      }
    }
LABEL_61:
    unsigned int v10 = v41;
    if (v41)
    {
      if (--v9) {
        continue;
      }
    }
    uint64_t v35 = *(void **)(a1 + 168);
    if (v35 == *(void **)(a1 + 160)) {
      goto LABEL_64;
    }
    uint64_t v39 = *(unsigned int *)(a1 + 176);
    if (v39 >= 0x21 && 4 * (*(_DWORD *)(a1 + 180) - *(_DWORD *)(a1 + 184)) < v39)
    {
      llvm::SmallPtrSetImplBase::shrink_and_clear((void **)(a1 + 160));
    }
    else
    {
      memset(v35, 255, 8 * v39);
LABEL_64:
      *(_DWORD *)(a1 + 180) = 0;
      *(_DWORD *)(a1 + 184) = 0;
    }
    BOOL v29 = v41 == 0;
    goto LABEL_45;
  }
  uint64_t v15 = 0;
  unint64_t v16 = 0;
  while (1)
  {
    uint64_t v17 = (llvm *)v13[v15];
    if (v17 == UnderlyingObject) {
      break;
    }
    if (v17 == (llvm *)-2) {
      unint64_t v16 = (llvm **)&v13[v15];
    }
    if (v14 == ++v15)
    {
      if (!v16) {
        goto LABEL_13;
      }
      *unint64_t v16 = UnderlyingObject;
      --*(_DWORD *)(a1 + 184);
      goto LABEL_15;
    }
  }
LABEL_48:
  if (v13 == *(void **)(a1 + 160)) {
    goto LABEL_44;
  }
  uint64_t v31 = *(unsigned int *)(a1 + 176);
  if (v31 < 0x21 || 4 * (*(_DWORD *)(a1 + 180) - *(_DWORD *)(a1 + 184)) >= v31) {
    goto LABEL_57;
  }
LABEL_76:
  llvm::SmallPtrSetImplBase::shrink_and_clear((void **)(a1 + 160));
  BOOL v29 = 0;
LABEL_45:
  if (v40 != v43) {
    free(v40);
  }
  return v29;
}

uint64_t llvm::BasicAAResult::getModRefBehavior(llvm::BasicAAResult *this, const llvm::CallBase *a2)
{
  uint64_t v4 = *((void *)a2 + 8);
  if (v4 && (*(unsigned char *)(v4 + 17) & 0x10) != 0) {
    return 4;
  }
  __int32 v33 = 7;
  uint64_t hasFnAttrOnCalledFunction = sub_1CC5CB59C((uint64_t)a2, &v33, 1uLL);
  if ((hasFnAttrOnCalledFunction & 1) == 0
    || (uint64_t v19 = *((void *)a2 - 4)) != 0
    && !*(unsigned char *)(v19 + 16)
    && *(void *)(v19 + 24) == *((void *)a2 + 9)
    && *(_DWORD *)(v19 + 36) == 7)
  {
    uint64_t hasFnAttrOnCalledFunction = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a2, 44);
    if (hasFnAttrOnCalledFunction) {
      return 4;
    }
  }
  uint64_t v6 = *((void *)a2 + 8);
  if (!v6 || (*(unsigned char *)(v6 + 17) & 0x30) == 0)
  {
    int v7 = *((_DWORD *)a2 + 5);
    if (v7 < 0)
    {
      int v20 = (char *)a2 - 32 * (v7 & 0x7FFFFFF);
      uint64_t v23 = *((void *)v20 - 1);
      unsigned int v21 = v20 - 8;
      uint64_t v22 = v23;
      if (v23)
      {
        uint64_t v24 = -v22;
        do
        {
          unsigned int v25 = *(_DWORD *)(*(void *)&v21[v24] + 8);
          BOOL v26 = v25 > 7;
          int v27 = (1 << v25) & 0x83;
          if (v26 || v27 == 0) {
            goto LABEL_11;
          }
          v24 += 16;
        }
        while (v24);
      }
    }
    uint64_t hasFnAttrOnCalledFunction = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a2, 45);
    if ((hasFnAttrOnCalledFunction & 1) == 0)
    {
      uint64_t hasFnAttrOnCalledFunction = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a2, 44);
      if ((hasFnAttrOnCalledFunction & 1) == 0)
      {
        uint64_t v6 = *((void *)a2 + 8);
LABEL_11:
        if (v6 && ((*(unsigned char *)(v6 + 20) & 4) != 0 || (*(unsigned char *)(v6 + 17) & 0x10) != 0)
          || ((__int32 v33 = 7,
               uint64_t hasFnAttrOnCalledFunction = sub_1CC5CB59C((uint64_t)a2, &v33, 1uLL),
               (hasFnAttrOnCalledFunction & 1) == 0)
           || (uint64_t v32 = *((void *)a2 - 4)) != 0
           && !*(unsigned char *)(v32 + 16)
           && *(void *)(v32 + 24) == *((void *)a2 + 9)
           && *(_DWORD *)(v32 + 36) == 7)
          && ((uint64_t hasFnAttrOnCalledFunction = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a2, 66),
               (hasFnAttrOnCalledFunction & 1) != 0)
           || (uint64_t hasFnAttrOnCalledFunction = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a2, 44),
               hasFnAttrOnCalledFunction)))
        {
          uint64_t v8 = 62;
        }
        else
        {
          uint64_t v8 = 63;
        }
        goto LABEL_20;
      }
    }
  }
  uint64_t v8 = 61;
LABEL_20:
  uint64_t v9 = *((void *)a2 + 8);
  if (v9 && (*(unsigned char *)(v9 + 12) & 8) != 0
    || ((__int32 v33 = 7,
         uint64_t hasFnAttrOnCalledFunction = sub_1CC5CB59C((uint64_t)a2, &v33, 1uLL),
         (hasFnAttrOnCalledFunction & 1) == 0)
     || (uint64_t v29 = *((void *)a2 - 4)) != 0
     && !*(unsigned char *)(v29 + 16)
     && *(void *)(v29 + 24) == *((void *)a2 + 9)
     && *(_DWORD *)(v29 + 36) == 7)
    && (uint64_t hasFnAttrOnCalledFunction = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a2, 3),
        hasFnAttrOnCalledFunction))
  {
    v8 &= 0xFu;
  }
  else
  {
    uint64_t v10 = *((void *)a2 + 8);
    if (v10 && (*(unsigned char *)(v10 + 13) & 8) != 0
      || ((__int32 v33 = 7,
           uint64_t hasFnAttrOnCalledFunction = sub_1CC5CB59C((uint64_t)a2, &v33, 1uLL),
           (hasFnAttrOnCalledFunction & 1) == 0)
       || (uint64_t v30 = *((void *)a2 - 4)) != 0
       && !*(unsigned char *)(v30 + 16)
       && *(void *)(v30 + 24) == *((void *)a2 + 9)
       && *(_DWORD *)(v30 + 36) == 7)
      && (uint64_t hasFnAttrOnCalledFunction = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a2, 11),
          hasFnAttrOnCalledFunction))
    {
      v8 &= 0x17u;
    }
    else
    {
      uint64_t v11 = *((void *)a2 + 8);
      if (v11 && (*(unsigned char *)(v11 + 13) & 0x10) != 0
        || ((__int32 v33 = 7,
             uint64_t hasFnAttrOnCalledFunction = sub_1CC5CB59C((uint64_t)a2, &v33, 1uLL),
             (hasFnAttrOnCalledFunction & 1) == 0)
         || (uint64_t v31 = *((void *)a2 - 4)) != 0
         && !*(unsigned char *)(v31 + 16)
         && *(void *)(v31 + 24) == *((void *)a2 + 9)
         && *(_DWORD *)(v31 + 36) == 7)
        && (uint64_t hasFnAttrOnCalledFunction = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a2, 12),
            hasFnAttrOnCalledFunction))
      {
        v8 &= 0x1Fu;
      }
    }
  }
  int v12 = *((_DWORD *)a2 + 5);
  if ((v12 & 0x80000000) == 0 || (*((void *)a2 - 4 * (v12 & 0x7FFFFFF) - 1) & 0xFFFFFFFF0) == 0)
  {
    uint64_t v13 = *((void *)a2 - 4);
    if (v13)
    {
      if (!*(unsigned char *)(v13 + 16) && *(void *)(v13 + 24) == *((void *)a2 + 9))
      {
        uint64_t v14 = *(void *)this;
        if (*(void *)this)
        {
          uint64_t v15 = *(void **)(v14 + 8);
          unint64_t v16 = *(void **)(v14 + 16);
          int ModRefBehavior = 63;
          while (v15 != v16)
          {
            ModRefBehavior &= (*(uint64_t (**)(void, uint64_t))(*(void *)*v15 + 56))(*v15, v13);
            if (ModRefBehavior == 4) {
              break;
            }
            ++v15;
          }
        }
        else
        {
          int ModRefBehavior = llvm::BasicAAResult::getModRefBehavior((llvm::BasicAAResult *)hasFnAttrOnCalledFunction, *((const Function **)a2 - 4));
        }
        return ModRefBehavior & v8;
      }
    }
  }
  return v8;
}

uint64_t llvm::BasicAAResult::getModRefBehavior(llvm::BasicAAResult *this, const Function *a2)
{
  uint64_t v2 = (unsigned char *)*((void *)a2 + 14);
  if (!v2) {
    return 63;
  }
  if ((v2[17] & 0x10) != 0) {
    return 4;
  }
  if ((v2[17] & 0x20) != 0)
  {
    unsigned int v3 = 61;
  }
  else if ((v2[20] & 4) != 0)
  {
    unsigned int v3 = 62;
  }
  else
  {
    unsigned int v3 = 63;
  }
  if ((v2[12] & 8) != 0) {
    return v3 & 0xF;
  }
  char v4 = v2[13];
  if ((v4 & 8) != 0) {
    return v3 & 0x17;
  }
  if ((v4 & 0x10) != 0) {
    return v3 & 0x1F;
  }
  return v3;
}

uint64_t llvm::BasicAAResult::getArgModRefInfo(llvm::BasicAAResult *this, const llvm::CallBase *a2, int a3)
{
  uint64_t v5 = (uint64_t *)*((void *)this + 3);
  if (llvm::CallBase::paramHasAttr((uint64_t)a2, a3, 66)) {
    return 6;
  }
  int v8 = 0;
  uint64_t v6 = *((void *)a2 - 4);
  if (v6)
  {
    if (!*(unsigned char *)(v6 + 16)
      && *(void *)(v6 + 24) == *((void *)a2 + 9)
      && llvm::TargetLibraryInfoImpl::getLibFunc(*v5, (uint64_t ***)v6, &v8)
      && v8 == 327
      && (*(unsigned char *)(v5[1] + 40) & 0x80) == 0
      && !a3
      && *(unsigned __int8 *)(*v5 + 81) > 0x3Fu)
    {
      return 6;
    }
  }
  if (llvm::CallBase::paramHasAttr((uint64_t)a2, a3, 45)) {
    return 5;
  }
  if (llvm::CallBase::paramHasAttr((uint64_t)a2, a3, 44)) {
    return 4;
  }
  return 7;
}

uint64_t llvm::BasicAAResult::alias(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return llvm::BasicAAResult::aliasCheck(a1, *(llvm::Value **)a2, *(void *)(a2 + 8), *(llvm::Value **)a3, *(void *)(a3 + 8), a4);
}

uint64_t llvm::BasicAAResult::aliasCheck(uint64_t a1, llvm::Value *a2, unint64_t a3, llvm::Value *a4, unint64_t a5, uint64_t a6)
{
  int64_t v7 = a5;
  int64_t v9 = a3;
  unint64_t v12 = a3 & 0x7FFFFFFFFFFFFFFFLL;
  if (a3 <= 0xFFFFFFFFFFFFFFFDLL && !v12) {
    return 0;
  }
  unint64_t v13 = a5 & 0x7FFFFFFFFFFFFFFFLL;
  if (a5 <= 0xFFFFFFFFFFFFFFFDLL && !v13) {
    return 0;
  }
  if ((*(unsigned int (**)(void))(***(void ***)(a1 + 32) + 1208))(**(void **)(a1 + 32))
    && (unsigned int v14 = *(_DWORD *)(*(void *)a2 + 8), v14 == 15)
    && (unsigned int v15 = *(_DWORD *)(*(void *)a4 + 8), v15 == 15))
  {
    if ((v14 & 0xFE) == 0x12) {
      unsigned int v14 = *(_DWORD *)(**(void **)(*(void *)a2 + 16) + 8);
    }
    uint64_t v16 = v14 >> 8;
    if ((v15 & 0xFE) == 0x12) {
      unsigned int v15 = *(_DWORD *)(**(void **)(*(void *)a4 + 16) + 8);
    }
    uint64_t v17 = v15 >> 8;
    if (!(*(unsigned int (**)(void, uint64_t, uint64_t))(***(void ***)(a1 + 32) + 1216))(**(void **)(a1 + 32), v16, v17))return 0; {
  }
    }
  else
  {
    uint64_t v17 = 0;
    LODWORD(v16) = 0;
  }
  unsigned int v18 = llvm::Value::stripPointerCastsForAliasAnalysis(a2);
  uint64_t v19 = llvm::Value::stripPointerCastsForAliasAnalysis(a4);
  unsigned int v20 = *((unsigned __int8 *)v18 + 16);
  if (v20 - 11 < 2) {
    return 0;
  }
  unsigned int v21 = v19;
  if (*((unsigned __int8 *)v19 + 16) - 11 < 2) {
    return 0;
  }
  unsigned int v88 = v16;
  if (v18 != v19) {
    goto LABEL_18;
  }
  if (v20 < 0x1C) {
    return 3;
  }
  unsigned int v25 = *(_DWORD *)(a1 + 84) - *(_DWORD *)(a1 + 88);
  if (!v25) {
    return 3;
  }
  if (v25 <= 0x14)
  {
    uint64_t v76 = *(void *)(a1 + 72);
    uint64_t v77 = 80;
    if (v76 == *(void *)(a1 + 64)) {
      uint64_t v77 = 84;
    }
    uint64_t v78 = *(unsigned int *)(a1 + v77);
    if (v78)
    {
      uint64_t v79 = 8 * v78;
      uint64_t v87 = *(void *)(a1 + 72);
      uint64_t v26 = 3;
      while (*(void *)v87 >= 0xFFFFFFFFFFFFFFFELL)
      {
        v87 += 8;
        v79 -= 8;
        if (!v79) {
          return v26;
        }
      }
    }
    else
    {
      uint64_t v87 = *(void *)(a1 + 72);
    }
    uint64_t v82 = v76 + 8 * v78;
    if (v87 == v82) {
      return 3;
    }
    uint64_t v83 = *(void *)(*(void *)v87 + 48);
    uint64_t v84 = v83 ? v83 - 24 : 0;
    if ((llvm::isPotentiallyReachable(v84, (uint64_t)v18, 0, *(void *)(a1 + 48), 0) & 1) == 0)
    {
      while (1)
      {
        v87 += 8;
        if (v87 == v82) {
          return 3;
        }
        if (*(void *)v87 < 0xFFFFFFFFFFFFFFFELL)
        {
          uint64_t v85 = *(void *)(*(void *)v87 + 48);
          uint64_t v86 = v85 ? v85 - 24 : 0;
          if (llvm::isPotentiallyReachable(v86, (uint64_t)v18, 0, *(void *)(a1 + 48), 0)) {
            break;
          }
        }
      }
    }
  }
LABEL_18:
  if (*(unsigned char *)(*(void *)v18 + 8) != 15 || *(unsigned char *)(*(void *)v21 + 8) != 15) {
    return 0;
  }
  if ((*(unsigned int (**)(void))(***(void ***)(a1 + 32) + 1208))(**(void **)(a1 + 32)))
  {
    unsigned int v22 = *(_DWORD *)(*(void *)v18 + 8);
    if ((v22 & 0xFE) == 0x12) {
      unsigned int v22 = *(_DWORD *)(**(void **)(*(void *)v18 + 16) + 8);
    }
    uint64_t v23 = v22 >> 8;
    unsigned int v24 = *(_DWORD *)(*(void *)v21 + 8);
    if ((v24 & 0xFE) == 0x12) {
      unsigned int v24 = *(_DWORD *)(**(void **)(*(void *)v21 + 16) + 8);
    }
    if (v88 == v23)
    {
      if (v17 != v24 >> 8
        && !(*(unsigned int (**)(void, void))(***(void ***)(a1 + 32) + 1216))(**(void **)(a1 + 32), v88))
      {
        return 0;
      }
    }
    else
    {
      unsigned int v89 = v24 >> 8;
      if (!(*(unsigned int (**)(void, uint64_t, uint64_t))(***(void ***)(a1 + 32) + 1216))(**(void **)(a1 + 32), v23, v17)|| v17 != v89&& ((*(uint64_t (**)(void, uint64_t))(***(void ***)(a1 + 32) + 1216))(**(void **)(a1 + 32), v23) & 1) == 0)
      {
        return 0;
      }
    }
  }
  UnderlyingObject = (unsigned __int8 *)llvm::getUnderlyingObject(v18, (const llvm::Value *)6);
  unsigned int v28 = llvm::getUnderlyingObject(v21, (const llvm::Value *)6);
  uint64_t v30 = (unsigned __int8 *)v28;
  if (UnderlyingObject[16] == 19 && UnderlyingObject)
  {
    uint64_t v31 = *(void *)(a1 + 16);
    unsigned int v32 = *(_DWORD *)(*(void *)UnderlyingObject + 8);
    if (v31 && (uint64_t v33 = *(void *)(v31 + 112)) != 0)
    {
      if ((*(unsigned char *)(v33 + 17) & 1) == 0 && v32 <= 0xFF) {
        return 0;
      }
    }
    else if (v32 < 0x100)
    {
      return 0;
    }
  }
  if (*((unsigned char *)v28 + 16) != 19 || !v28) {
    goto LABEL_51;
  }
  uint64_t v34 = *(void *)(a1 + 16);
  unsigned int v35 = *(_DWORD *)(*(void *)v28 + 8);
  if (!v34 || (uint64_t v36 = *(void *)(v34 + 112)) == 0)
  {
    if (v35 >= 0x100) {
      goto LABEL_51;
    }
    return 0;
  }
  if ((*(unsigned char *)(v36 + 17) & 1) == 0 && v35 <= 0xFF) {
    return 0;
  }
LABEL_51:
  if (UnderlyingObject != (unsigned __int8 *)v28)
  {
    if (llvm::isIdentifiedObject((llvm *)UnderlyingObject, v29)
      && (llvm::isIdentifiedObject((llvm *)v30, v37) & 1) != 0)
    {
      return 0;
    }
    if (UnderlyingObject[16] <= 0x14u && llvm::isIdentifiedObject((llvm *)v30, v37))
    {
      if (v30[16] >= 0x15u) {
        return 0;
      }
    }
    else if (v30[16] >= 0x15u)
    {
      unsigned int v39 = UnderlyingObject[16];
      goto LABEL_63;
    }
    int isIdentifiedObject = llvm::isIdentifiedObject((llvm *)UnderlyingObject, v37);
    unsigned int v39 = UnderlyingObject[16];
    if (isIdentifiedObject)
    {
      if (v39 >= 0x15) {
        return 0;
      }
      goto LABEL_65;
    }
LABEL_63:
    if (v39 == 21 && (llvm::isIdentifiedFunctionLocal((llvm *)v30, v37) & 1) != 0) {
      return 0;
    }
LABEL_65:
    if (v30[16] == 21 && (llvm::isIdentifiedFunctionLocal((llvm *)UnderlyingObject, v37) & 1) != 0) {
      return 0;
    }
    unsigned int v40 = UnderlyingObject[16];
    if (v40 >= 0x1C)
    {
      unsigned int v41 = v40 - 33;
      if (v41 <= 0x33
        && ((1 << v41) & 0x8080008000041) != 0
        && ((*(uint64_t (**)(void, unsigned __int8 *, unsigned __int8 *))(**(void **)(a6 + 328) + 16))(*(void *)(a6 + 328), v30, UnderlyingObject) & 1) != 0)
      {
        return 0;
      }
    }
    unsigned int v42 = v30[16];
    if (v42 >= 0x1C)
    {
      unsigned int v43 = v42 - 33;
      if (v43 <= 0x33
        && ((1 << v43) & 0x8080008000041) != 0
        && ((*(uint64_t (**)(void, unsigned __int8 *, unsigned __int8 *))(**(void **)(a6 + 328) + 16))(*(void *)(a6 + 328), UnderlyingObject, v30) & 1) != 0)
      {
        return 0;
      }
    }
  }
  uint64_t v45 = *(void *)(a1 + 16);
  int v90 = 0;
  if (v45)
  {
    uint64_t v46 = *(void *)(v45 + 112);
    if (v46)
    {
      if (*(unsigned char *)(v46 + 17)) {
        int v90 = 1;
      }
    }
  }
  int v47 = *(const llvm::DataLayout **)(a1 + 8);
  v93[0] = 0;
  v91[0] = 0;
  uint64_t PointerDereferenceableBytes = llvm::Value::getPointerDereferenceableBytes((uint64_t ***)v18, v47, v93, v91);
  if ((v90 & v93[0]) != 0) {
    unint64_t v49 = 0;
  }
  else {
    unint64_t v49 = (const llvm::Value *)PointerDereferenceableBytes;
  }
  if ((unint64_t)v49 <= v12) {
    unint64_t v50 = (const llvm::Value *)v12;
  }
  else {
    unint64_t v50 = v49;
  }
  if (v9 >= 0) {
    int v51 = v50;
  }
  else {
    int v51 = v49;
  }
  BOOL v52 = v30;
  char v53 = sub_1CBF73550((llvm *)v30, v51, *(void *)(a1 + 8), *(void *)(a1 + 24), v90);
  uint64_t v26 = 0;
  if ((v53 & 1) == 0)
  {
    int v54 = *(const llvm::DataLayout **)(a1 + 8);
    v93[0] = 0;
    v91[0] = 0;
    uint64_t v55 = llvm::Value::getPointerDereferenceableBytes((uint64_t ***)v21, v54, v93, v91);
    unint64_t v56 = (v90 & v93[0]) != 0 ? 0 : v55;
    uint64_t v57 = v56 <= v13 ? v7 & 0x7FFFFFFFFFFFFFFFLL : v56;
    int v58 = (const llvm::Value *)(v7 >= 0 ? v57 : v56);
    uint64_t v26 = 0;
    if ((sub_1CBF73550((llvm *)UnderlyingObject, v58, *(void *)(a1 + 8), *(void *)(a1 + 24), v90) & 1) == 0)
    {
      if (v9 == -1 || v7 == -1)
      {
        int64_t v7 = -2;
        int64_t v9 = -2;
      }
      if (*(_DWORD *)(a6 + 336) <= 0x1FFu)
      {
        *(void *)unint64_t v93 = v18;
        *(void *)&v93[8] = v9;
        *(void *)&long long v94 = v21;
        *((void *)&v94 + 1) = v7;
        if (v18 > v21)
        {
          long long v60 = *(_OWORD *)v93;
          *(_OWORD *)unint64_t v93 = v94;
          long long v94 = v60;
        }
        *(void *)int v91 = 0;
        char v61 = sub_1CBF74C14(a6, (uint64_t *)v93, (uint64_t **)v91);
        uint64_t v62 = *(void *)v91;
        if (v61)
        {
          int v75 = *(_DWORD *)(*(void *)v91 + 36);
          if ((v75 & 0x80000000) == 0)
          {
            *(_DWORD *)(*(void *)v91 + 36) = v75 + 1;
            ++*(_DWORD *)(a6 + 340);
          }
          uint64_t v26 = *(unsigned int *)(v62 + 32);
          if (v18 > v21 && (v26 & 0x100) != 0 && !((((int)v26 >> 9) + 0x3FFFFF) >> 23)) {
            return (*(_DWORD *)(v62 + 32) - (*(_DWORD *)(v62 + 32) & 0xFFFFFE00)) | 0x100;
          }
        }
        else
        {
          unsigned int v63 = v52;
          uint64_t v64 = sub_1CBF74D5C((_DWORD *)a6, (uint64_t)v93, (uint64_t *)v93, *(uint64_t **)v91);
          *(_OWORD *)uint64_t v64 = *(_OWORD *)v93;
          *((_OWORD *)v64 + 1) = v94;
          v64[4] = 0;
          int v65 = *(_DWORD *)(a6 + 340);
          unsigned int v66 = *(_DWORD *)(a6 + 352);
          uint64_t v26 = llvm::BasicAAResult::aliasCheckRecursive((uint64_t *)a1, v18, v9, v21, v7, a6, UnderlyingObject, v63);
          *(void *)int v91 = 0;
          if (sub_1CBF74C14(a6, (uint64_t *)v93, (uint64_t **)v91))
          {
            uint64_t v67 = *(void *)v91;
          }
          else
          {
            if (*(_DWORD *)a6) {
              uint64_t v80 = a6 + 8;
            }
            else {
              uint64_t v80 = *(void *)(a6 + 8);
            }
            if (*(_DWORD *)a6) {
              unsigned int v81 = 8;
            }
            else {
              unsigned int v81 = *(_DWORD *)(a6 + 16);
            }
            uint64_t v67 = v80 + 40 * v81;
          }
          int v68 = *(_DWORD *)(v67 + 36);
          *(_DWORD *)(a6 + 340) -= v68;
          if (v68 >= 1 && (_BYTE)v26)
          {
            *(void *)(v67 + 32) = 0xFFFFFFFF00000001;
            unsigned int v69 = *(_DWORD *)(a6 + 352);
            uint64_t v26 = 1;
            while (v69 > v66)
            {
              uint64_t v70 = *(void *)(a6 + 344) + 32 * v69;
              long long v71 = *(_OWORD *)(v70 - 16);
              *(_OWORD *)int v91 = *(_OWORD *)(v70 - 32);
              long long v92 = v71;
              *(_DWORD *)(a6 + 352) = v69 - 1;
              sub_1CD45C138((_DWORD *)a6, (uint64_t *)v91);
              unsigned int v69 = *(_DWORD *)(a6 + 352);
            }
          }
          else
          {
            *(_DWORD *)(v67 + 32) = v26;
            if (v18 > v21 && (v26 & 0x100) != 0 && !((((int)v26 >> 9) + 0x3FFFFF) >> 23)) {
              *(_DWORD *)(v67 + 32) = (v26 - (v26 & 0xFFFFFE00)) | 0x100;
            }
            *(_DWORD *)(v67 + 36) = -1;
            if (v65 != *(_DWORD *)(a6 + 340) && v26 != 1)
            {
              unsigned int v72 = (_OWORD *)sub_1CB8968D4(a6 + 344, (unint64_t)v93, 1);
              unint64_t v73 = (_OWORD *)(*(void *)(a6 + 344) + 32 * *(unsigned int *)(a6 + 352));
              long long v74 = v72[1];
              *unint64_t v73 = *v72;
              v73[1] = v74;
              ++*(_DWORD *)(a6 + 352);
            }
          }
        }
      }
      else
      {
        return 1;
      }
    }
  }
  return v26;
}

uint64_t llvm::BasicAAResult::getModRefInfo(uint64_t a1, uint64_t a2, llvm **a3, uint64_t a4)
{
  UnderlyingObject = llvm::getUnderlyingObject(*a3, (const llvm::Value *)6);
  uint64_t v8 = (uint64_t)UnderlyingObject;
  unsigned int v9 = *((unsigned __int8 *)UnderlyingObject + 16);
  if (v9 == 59)
  {
    if (a2)
    {
      if (*(unsigned char *)(a2 + 16) == 84 && (*(_WORD *)(a2 + 18) & 3u) - 1 <= 1)
      {
        uint64_t v10 = *(void *)(a2 + 64);
        if (!v10 || (*(unsigned char *)(v10 + 32) & 0x20) == 0) {
          return 4;
        }
      }
    }
    if (*(unsigned char *)(*((void *)UnderlyingObject - 4) + 16) != 16
      || ((uint64_t v11 = *((void *)UnderlyingObject + 5), (v12 = *(void *)(*(void *)(v11 + 56) + 80)) != 0)
        ? (uint64_t v13 = v12 - 24)
        : (uint64_t v13 = 0),
          v11 != v13 || (*((_WORD *)UnderlyingObject + 9) & 0x40) != 0))
    {
      if (sub_1CBF6E97C(a2, 287)) {
        return 6;
      }
    }
  }
  long long v60 = a3;
  BOOL v15 = v8 != a2 && v9 >= 0x15;
  if (v15
    && (*(unsigned int (**)(void, uint64_t, uint64_t))(**(void **)(a4 + 328) + 16))(*(void *)(a4 + 328), v8, a2))
  {
    uint64_t v16 = *(_DWORD *)(a2 + 20) & 0x7FFFFFF;
    int v17 = *(unsigned __int8 *)(a2 + 16);
    if (v17 == 84)
    {
      uint64_t v18 = 0;
    }
    else if (v17 == 39)
    {
      uint64_t v18 = (*(_DWORD *)(a2 + 80) + 1);
    }
    else
    {
      uint64_t v18 = 2;
    }
    if (a2 - 32 * v16 == a2 - 32 - 32 * v18) {
      return 4;
    }
    unsigned int v19 = 0;
    uint64_t v20 = 32 * ~v18;
    int v21 = 4;
    char v22 = 1;
    uint64_t v23 = -32 * v16;
    do
    {
      if (*(unsigned char *)(**(void **)(a2 + v23) + 8) == 15)
      {
        if ((sub_1CBF5BC2C(a2, v19, 22) & 1) != 0
          || ((int v24 = *(unsigned __int8 *)(a2 + 16), v24 != 84)
            ? (v24 != 39
             ? (uint64_t v25 = 2)
             : (uint64_t v25 = (*(_DWORD *)(a2 + 80) + 1)))
            : (uint64_t v25 = 0),
              (int v26 = *(_DWORD *)(a2 + 20), (v26 & 0x80000000) == 0)
           || (uint64_t v30 = v26 & 0x7FFFFFF, (*(void *)(a2 - 8 - 32 * v30) & 0xFFFFFFFF0) == 0)
            ? (int v27 = 0, v28 = -(uint64_t)(v26 & 0x7FFFFFF))
            : (uint64_t v28 = -v30,
               int v27 = *(_DWORD *)(a2 - 32 * v30 - 12) - *(_DWORD *)(a2 - 32 * v30 - *(void *)(a2 - 32 * v30 - 8))),
              v19 >= ((-32 - 32 * v25 + 32 * (unint64_t)-v27 - 32 * v28) >> 5)
           || llvm::CallBase::paramHasAttr(a2, v19, 69)))
        {
          if ((sub_1CBF5BC2C(a2, v19, 44) & 1) == 0)
          {
            v70[0] = *(void *)a1;
            v70[1] = a1;
            uint64_t v66 = *(void *)(a2 + v23);
            uint64_t v67 = -1;
            long long v68 = 0u;
            long long v69 = 0u;
            uint64_t v62 = v8;
            uint64_t v63 = -1;
            long long v64 = 0u;
            long long v65 = 0u;
            int v29 = sub_1CBF6E9C8(v70, (uint64_t)&v66, (uint64_t)&v62, a4);
            v22 &= v29 == 3;
            if (v29)
            {
              if ((sub_1CBF5BC2C(a2, v19, 45) & 1) != 0 || sub_1CBF5BC2C(a2, v19, 44))
              {
                v21 |= 1u;
              }
              else
              {
                if (!sub_1CBF5BC2C(a2, v19, 66) && !sub_1CBF5BC2C(a2, v19, 44)) {
                  goto LABEL_58;
                }
                v21 |= 2u;
              }
            }
          }
        }
      }
      ++v19;
      v23 += 32;
    }
    while (v20 != v23);
    int v31 = v21 & 3;
    if ((v21 & 3) != 0 && v31 != 3)
    {
      if (v22) {
        return v21 & 3;
      }
      else {
        return v21 | 4u;
      }
    }
    if (v31 != 3) {
      return 4;
    }
  }
LABEL_58:
  unsigned int ModRefBehavior = llvm::BasicAAResult::getModRefBehavior((llvm::BasicAAResult *)a1, (const llvm::CallBase *)a2);
  if ((*(unsigned int (**)(void))(***(void ***)(a1 + 32) + 1208))(**(void **)(a1 + 32))) {
    BOOL v33 = ModRefBehavior > 0x1F;
  }
  else {
    BOOL v33 = 1;
  }
  if (!v33)
  {
    uint64_t v38 = *(void *)*v60;
    unsigned int v39 = *(_DWORD *)(v38 + 8);
    if ((v39 & 0xFE) == 0x12) {
      unsigned int v39 = *(_DWORD *)(**(void **)(v38 + 16) + 8);
    }
    uint64_t v40 = *(_DWORD *)(a2 + 20) & 0x7FFFFFF;
    int v41 = *(unsigned __int8 *)(a2 + 16);
    if (v41 == 84)
    {
      uint64_t v42 = 0;
    }
    else if (v41 == 39)
    {
      uint64_t v42 = (*(_DWORD *)(a2 + 80) + 1);
    }
    else
    {
      uint64_t v42 = 2;
    }
    if (a2 - 32 * v40 == a2 - 32 * v42 - 32) {
      return 4;
    }
    int v43 = 0;
    uint64_t v44 = v39 >> 8;
    uint64_t v45 = 32 * ~v42;
    uint64_t v46 = -32 * v40;
    while (1)
    {
      uint64_t v47 = **(void **)(a2 + v46);
      if (*(unsigned char *)(v47 + 8) == 15 && (sub_1CBF5BC2C(a2, v43, 44) & 1) == 0)
      {
        unsigned int v48 = *(_DWORD *)(v47 + 8);
        if ((v48 & 0xFE) == 0x12) {
          unsigned int v48 = *(_DWORD *)(**(void **)(v47 + 16) + 8);
        }
        if ((*(uint64_t (**)(void, void, uint64_t))(***(void ***)(a1 + 32) + 1216))(**(void **)(a1 + 32), v48 >> 8, v44))break; {
      }
        }
      ++v43;
      v46 += 32;
      if (v45 == v46) {
        return 4;
      }
    }
  }
  if (byte_1EBD04470) {
    int v34 = 11;
  }
  else {
    int v34 = 15;
  }
  sub_1CC095244(a2, v34, *(uint64_t **)(a1 + 24), &v66);
  if (BYTE8(v68))
  {
    uint64_t v62 = *(void *)a1;
    uint64_t v63 = a1;
    uint64_t v66 = a2;
    uint64_t v67 = -1;
    long long v68 = 0u;
    long long v69 = 0u;
    if (!sub_1CBF6E9C8(&v62, (uint64_t)&v66, (uint64_t)v60, a4)) {
      return 4;
    }
  }
  BOOL v35 = sub_1CBF63BC8(a2);
  if (a2 && v35)
  {
    uint64_t v62 = *(void *)a1;
    uint64_t v63 = a1;
    llvm::MemoryLocation::getForArgument(a2, 1u, 0, (uint64_t)&v66);
    char v36 = sub_1CBF6E9C8(&v62, (uint64_t)&v66, (uint64_t)v60, a4);
    uint64_t v62 = *(void *)a1;
    uint64_t v63 = a1;
    llvm::MemoryLocation::getForArgument(a2, 0, 0, (uint64_t)&v66);
    char v37 = sub_1CBF6E9C8(&v62, (uint64_t)&v66, (uint64_t)v60, a4);
    if (v36
      || (LODWORD(v66) = 7, sub_1CC5CB59C(a2, (__int32 *)&v66, 1uLL))
      && ((uint64_t v59 = *(void *)(a2 - 32)) == 0
       || *(unsigned char *)(v59 + 16)
       || *(void *)(v59 + 24) != *(void *)(a2 + 72)
       || *(_DWORD *)(v59 + 36) != 7))
    {
      unsigned __int8 v14 = 5;
    }
    else
    {
      unsigned __int8 v14 = 4;
    }
    if (v37)
    {
LABEL_98:
      v14 |= 2u;
      return v14;
    }
    int v50 = *(_DWORD *)(a2 + 20);
    if (v50 < 0)
    {
      uint64_t v51 = a2 - 32 * (v50 & 0x7FFFFFF);
      uint64_t v54 = *(void *)(v51 - 8);
      uint64_t v52 = v51 - 8;
      uint64_t v53 = v54;
      if (v54)
      {
        uint64_t v55 = -v53;
        while (1)
        {
          unsigned int v56 = *(_DWORD *)(*(void *)(v52 + v55) + 8);
          BOOL v33 = v56 > 7;
          int v57 = (1 << v56) & 0x83;
          if (v33 || v57 == 0) {
            break;
          }
          v55 += 16;
          if (!v55) {
            return v14;
          }
        }
        goto LABEL_98;
      }
    }
  }
  else if (sub_1CBF6E97C(a2, 125))
  {
    return 5;
  }
  else
  {
    unsigned __int8 v14 = 5;
    if (!sub_1CBF6E97C(a2, 119))
    {
      if (sub_1CBF6E97C(a2, 164)) {
        return 5;
      }
      else {
        return 7;
      }
    }
  }
  return v14;
}

BOOL sub_1CBF6E97C(uint64_t a1, int a2)
{
  return *(unsigned char *)(a1 + 16) == 84
      && (uint64_t v2 = *(void *)(a1 - 32)) != 0
      && !*(unsigned char *)(v2 + 16)
      && *(void *)(v2 + 24) == *(void *)(a1 + 72)
      && (*(unsigned char *)(v2 + 33) & 0x20) != 0
      && *(_DWORD *)(v2 + 36) == a2;
}

uint64_t sub_1CBF6E9C8(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *a1;
  if (*a1)
  {
    int v8 = *(_DWORD *)(a4 + 336);
    *(_DWORD *)(a4 + 336) = v8 + 1;
    uint64_t v9 = *(void *)(v7 + 8);
    uint64_t v10 = *(void *)(v7 + 16);
    if (v9 == v10)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v11 = v9 + 8;
      do
      {
        uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(v11 - 8) + 24))(*(void *)(v11 - 8), a2, a3, a4);
        BOOL v13 = result != 1 || v11 == v10;
        v11 += 8;
      }
      while (!v13);
      int v8 = *(_DWORD *)(a4 + 336) - 1;
    }
    *(_DWORD *)(a4 + 336) = v8;
  }
  else
  {
    uint64_t v14 = a1[1];
    BOOL v15 = *(llvm::Value **)a2;
    unint64_t v16 = *(void *)(a2 + 8);
    int v17 = *(llvm::Value **)a3;
    unint64_t v18 = *(void *)(a3 + 8);
    return llvm::BasicAAResult::aliasCheck(v14, v15, v16, v17, v18, a4);
  }
  return result;
}

uint64_t llvm::BasicAAResult::getModRefInfo(llvm::BasicAAResult *a1, uint64_t a2, const llvm::CallBase *a3)
{
  if (sub_1CBF6E97C(a2, 125))
  {
    unsigned int v6 = 5;
  }
  else
  {
    if (!sub_1CBF6E97C((uint64_t)a3, 125)) {
      return 7;
    }
    unsigned int v6 = 6;
    a3 = (const llvm::CallBase *)a2;
  }
  if ((llvm::BasicAAResult::getModRefBehavior(a1, a3) & 2) != 0) {
    return v6;
  }
  else {
    return 4;
  }
}

BOOL llvm::BasicAAResult::aliasGEP(uint64_t a1, llvm::BasicAAResult *this, unint64_t a3, uint64_t a4, unint64_t a5, unsigned __int8 *a6, unsigned __int8 *a7, uint64_t a8)
{
  unint64_t v9 = a5;
  uint64_t v262 = *MEMORY[0x1E4F143B8];
  if (a3 >= 0xFFFFFFFFFFFFFFFELL && a5 >= 0xFFFFFFFFFFFFFFFELL)
  {
    int v14 = *(unsigned __int8 *)(a4 + 16);
    if (v14 != 62 && (v14 != 5 || *(_WORD *)(a4 + 18) != 34)) {
      return 1;
    }
    uint64_t v15 = *(void *)a1;
    uint64_t v257 = a6;
    __src = (void *)-1;
    *(_OWORD *)v259 = 0u;
    long long v260 = 0u;
    v252 = a7;
    uint64_t v253 = -1;
    *(_OWORD *)v254 = 0u;
    long long v255 = 0u;
    if (v15)
    {
      int v16 = *(_DWORD *)(a8 + 336);
      *(_DWORD *)(a8 + 336) = v16 + 1;
      uint64_t v17 = *(void *)(v15 + 8);
      uint64_t v18 = *(void *)(v15 + 16);
      if (v17 == v18)
      {
        char v20 = 1;
      }
      else
      {
        uint64_t v19 = v17 + 8;
        do
        {
          char v20 = (*(uint64_t (**)(void, unsigned __int8 **, unsigned __int8 **, uint64_t))(**(void **)(v19 - 8) + 24))(*(void *)(v19 - 8), &v257, &v252, a8);
          BOOL v21 = v20 != 1 || v19 == v18;
          v19 += 8;
        }
        while (!v21);
        int v16 = *(_DWORD *)(a8 + 336) - 1;
      }
      *(_DWORD *)(a8 + 336) = v16;
    }
    else
    {
      char v20 = llvm::BasicAAResult::aliasCheck(a1);
    }
    return v20 != 0;
  }
  llvm::BasicAAResult::DecomposeGEPExpression((uint64_t)this, *(const llvm::Value **)(a1 + 8), *(const llvm::DataLayout **)(a1 + 40), *(llvm::AssumptionCache **)(a1 + 48), (uint64_t)&v257);
  llvm::BasicAAResult::DecomposeGEPExpression(a4, *(const llvm::Value **)(a1 + 8), *(const llvm::DataLayout **)(a1 + 40), *(llvm::AssumptionCache **)(a1 + 48), (uint64_t)&v252);
  if (v257 == (unsigned __int8 *)this && v252 == (unsigned __int8 *)a4) {
    goto LABEL_273;
  }
  llvm::BasicAAResult::subtractDecomposedGEPs(a1, (uint64_t)&v257, (uint64_t)&v252);
  int v23 = v260;
  if (v261 && !v260 && v9 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    if (LODWORD(v259[0]) >= 0x41)
    {
      uint64_t v193 = (uint64_t *)__src;
      int v194 = LODWORD(v259[0]) - 64;
      if ((*((void *)__src + ((LODWORD(v259[0]) - 1) >> 6)) >> (LOBYTE(v259[0]) - 1)))
      {
        if (v194 - llvm::APInt::countLeadingOnesSlowCase((llvm::APInt *)&__src) < 0xFFFFFFBF) {
          goto LABEL_28;
        }
      }
      else
      {
        int v195 = 0;
        int64_t v196 = ((unint64_t)LODWORD(v259[0]) + 63) >> 6;
        do
        {
          BOOL v35 = v196-- < 1;
          if (v35) {
            break;
          }
          unint64_t v197 = *((void *)__src + v196);
          v195 += __clz(v197);
        }
        while (!v197);
        if (((uint64_t)v259[0] & 0x3F) != 0) {
          unsigned int v198 = LODWORD(v259[0]) | 0xFFFFFFC0;
        }
        else {
          unsigned int v198 = 0;
        }
        if (v194 - v195 - v198 < 0xFFFFFFBF)
        {
LABEL_26:
          uint64_t v25 = 0;
          int v26 = v252[16];
          if (v26 == 3 || v26 == 59) {
            goto LABEL_274;
          }
          goto LABEL_28;
        }
      }
      uint64_t v24 = *v193;
    }
    else
    {
      uint64_t v24 = (uint64_t)((void)__src << -(uint64_t)LODWORD(v259[0])) >> -(uint64_t)LODWORD(v259[0]);
    }
    if (v24 < (uint64_t)(v9 & 0x7FFFFFFFFFFFFFFFLL)) {
      goto LABEL_28;
    }
    goto LABEL_26;
  }
LABEL_28:
  int v27 = *(unsigned __int8 *)(a4 + 16);
  if (v27 != 62 && (v27 != 5 || *(_WORD *)(a4 + 18) != 34) || !v256 || a3 > 0xFFFFFFFFFFFFFFFDLL || v23) {
    goto LABEL_39;
  }
  if (LODWORD(v259[0]) < 0x41)
  {
    uint64_t v28 = (uint64_t)((void)__src << -(uint64_t)LODWORD(v259[0])) >> -(uint64_t)LODWORD(v259[0]);
    goto LABEL_36;
  }
  unint64_t v199 = (uint64_t *)__src;
  int v200 = LODWORD(v259[0]) - 64;
  if (((*((void *)__src + ((LODWORD(v259[0]) - 1) >> 6)) >> (LOBYTE(v259[0]) - 1)) & 1) == 0)
  {
    int v201 = 0;
    int64_t v202 = ((unint64_t)LODWORD(v259[0]) + 63) >> 6;
    do
    {
      BOOL v35 = v202-- < 1;
      if (v35) {
        break;
      }
      unint64_t v203 = *((void *)__src + v202);
      v201 += __clz(v203);
    }
    while (!v203);
    if (((uint64_t)v259[0] & 0x3F) != 0) {
      unsigned int v204 = LODWORD(v259[0]) | 0xFFFFFFC0;
    }
    else {
      unsigned int v204 = 0;
    }
    if (v200 - v201 - v204 < 0xFFFFFFBF) {
      goto LABEL_39;
    }
    goto LABEL_578;
  }
  if (v200 - llvm::APInt::countLeadingOnesSlowCase((llvm::APInt *)&__src) >= 0xFFFFFFBF)
  {
LABEL_578:
    uint64_t v28 = *v199;
LABEL_36:
    if (v28 > -(uint64_t)(a3 & 0x7FFFFFFFFFFFFFFFLL)) {
      goto LABEL_39;
    }
  }
  uint64_t v25 = 0;
  int v29 = v257[16];
  if (v29 == 3 || v29 == 59) {
    goto LABEL_274;
  }
LABEL_39:
  if (LODWORD(v259[0]) > 0x40)
  {
    int v33 = 0;
    int64_t v34 = ((unint64_t)LODWORD(v259[0]) + 63) >> 6;
    p_src = __src;
    do
    {
      BOOL v35 = v34-- < 1;
      if (v35) {
        break;
      }
      unint64_t v36 = *((void *)__src + v34);
      v33 += __clz(v36);
    }
    while (!v36);
    unsigned int v37 = LODWORD(v259[0]) | 0xFFFFFFC0;
    if (((uint64_t)v259[0] & 0x3F) == 0) {
      unsigned int v37 = 0;
    }
    uint64_t v30 = v257;
    int v31 = v252;
    if (LODWORD(v259[0]) - v33 - v37 > 0x40) {
      goto LABEL_54;
    }
  }
  else
  {
    uint64_t v30 = v257;
    int v31 = v252;
    p_src = &__src;
  }
  if (*p_src) {
    BOOL v38 = 0;
  }
  else {
    BOOL v38 = v23 == 0;
  }
  if (v38)
  {
    uint64_t v46 = *(void *)a1;
    __s1 = v30;
    uint64_t v249 = a3;
    *(_OWORD *)uint64_t v250 = 0u;
    long long v251 = 0u;
    v244 = v31;
    *(void *)v245 = v9;
    long long v246 = 0u;
    long long v247 = 0u;
    if (v46)
    {
      int v47 = *(_DWORD *)(a8 + 336);
      *(_DWORD *)(a8 + 336) = v47 + 1;
      uint64_t v48 = *(void *)(v46 + 8);
      uint64_t v49 = *(void *)(v46 + 16);
      if (v48 == v49)
      {
        uint64_t v25 = 1;
      }
      else
      {
        uint64_t v50 = v48 + 8;
        do
        {
          uint64_t v51 = (*(uint64_t (**)(void, void **, void **, uint64_t))(**(void **)(v50 - 8) + 24))(*(void *)(v50 - 8), &__s1, &v244, a8);
          BOOL v52 = v51 != 1 || v50 == v49;
          v50 += 8;
        }
        while (!v52);
        uint64_t v25 = v51;
        int v47 = *(_DWORD *)(a8 + 336) - 1;
      }
      *(_DWORD *)(a8 + 336) = v47;
    }
    else
    {
      uint64_t v25 = llvm::BasicAAResult::aliasCheck(a1);
    }
    goto LABEL_274;
  }
LABEL_54:
  uint64_t v39 = *(void *)a1;
  __s1 = v30;
  uint64_t v249 = -1;
  *(_OWORD *)uint64_t v250 = 0u;
  long long v251 = 0u;
  v244 = v31;
  *(void *)v245 = -1;
  long long v246 = 0u;
  long long v247 = 0u;
  if (v39)
  {
    int v40 = *(_DWORD *)(a8 + 336);
    *(_DWORD *)(a8 + 336) = v40 + 1;
    uint64_t v41 = *(void *)(v39 + 8);
    uint64_t v42 = *(void *)(v39 + 16);
    if (v41 == v42)
    {
      uint64_t v25 = 1;
    }
    else
    {
      uint64_t v43 = v41 + 8;
      do
      {
        uint64_t v44 = (*(uint64_t (**)(void, void **, void **, uint64_t))(**(void **)(v43 - 8) + 24))(*(void *)(v43 - 8), &__s1, &v244, a8);
        BOOL v45 = v44 != 1 || v43 == v42;
        v43 += 8;
      }
      while (!v45);
      uint64_t v25 = v44;
      int v40 = *(_DWORD *)(a8 + 336) - 1;
    }
    *(_DWORD *)(a8 + 336) = v40;
  }
  else
  {
    uint64_t v25 = llvm::BasicAAResult::aliasCheck(a1);
  }
  if (v25 != 3) {
    goto LABEL_274;
  }
  if (!v260)
  {
    uint64_t v53 = (void **)((char *)__src + 8 * ((LODWORD(v259[0]) - 1) >> 6));
    if (LODWORD(v259[0]) < 0x41) {
      uint64_t v53 = &__src;
    }
    uint64_t v54 = (1 << (LOBYTE(v259[0]) - 1)) & (unint64_t)*v53;
    if (v54)
    {
      unsigned int v243 = v259[0];
      if (LODWORD(v259[0]) >= 0x41) {
        operator new[]();
      }
      if (LODWORD(v259[0])) {
        unint64_t v55 = 0xFFFFFFFFFFFFFFFFLL >> -LOBYTE(v259[0]);
      }
      else {
        unint64_t v55 = 0;
      }
      v242 = (void *)(v55 & ~(unint64_t)__src);
      llvm::APInt::operator++((uint64_t)&v242);
      unsigned int v56 = v243;
      int v57 = v242;
      unsigned int v243 = 0;
      if (LODWORD(v259[0]) > 0x40 && __src)
      {
        MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
        __src = v57;
        LODWORD(v259[0]) = v56;
        if (v243 >= 0x41 && v242) {
          MEMORY[0x1D25D9CB0](v242, 0x1000C8000313F17);
        }
      }
      else
      {
        __src = v242;
        LODWORD(v259[0]) = v56;
      }
      unint64_t v58 = a3;
    }
    else
    {
      unint64_t v58 = v9;
      unint64_t v9 = a3;
    }
    if (v58 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      unint64_t v85 = (unint64_t)__src;
      if (LODWORD(v259[0]) >= 0x41)
      {
        int v86 = 0;
        int64_t v87 = ((unint64_t)LODWORD(v259[0]) + 63) >> 6;
        do
        {
          BOOL v35 = v87-- < 1;
          if (v35) {
            break;
          }
          unint64_t v88 = *((void *)__src + v87);
          v86 += __clz(v88);
        }
        while (!v88);
        uint64_t v25 = 0;
        unsigned int v89 = LODWORD(v259[0]) | 0xFFFFFFC0;
        if (((uint64_t)v259[0] & 0x3F) == 0) {
          unsigned int v89 = 0;
        }
        if (LODWORD(v259[0]) - v86 - v89 > 0x40) {
          goto LABEL_274;
        }
        unint64_t v85 = *(void *)__src;
      }
      unint64_t v90 = v58 & 0x7FFFFFFFFFFFFFFFLL;
      if (v85 >= (v58 & 0x7FFFFFFFFFFFFFFFLL))
      {
        uint64_t v25 = 0;
        goto LABEL_274;
      }
      if (v9 > 0xFFFFFFFFFFFFFFFDLL) {
        goto LABEL_434;
      }
      unint64_t v91 = v85 >> 31;
      if (LODWORD(v259[0]) >= 0x41)
      {
        int v128 = 0;
        int64_t v129 = ((unint64_t)LODWORD(v259[0]) + 63) >> 6;
        do
        {
          BOOL v35 = v129-- < 1;
          if (v35) {
            break;
          }
          unint64_t v130 = *((void *)__src + v129);
          v128 += __clz(v130);
        }
        while (!v130);
        unsigned int v131 = LODWORD(v259[0]) | 0xFFFFFFC0;
        if (((uint64_t)v259[0] & 0x3F) == 0) {
          unsigned int v131 = 0;
        }
        uint64_t v25 = 2;
        if (!v91 && LODWORD(v259[0]) - v128 - v131 < 0x41)
        {
          unsigned int v241 = v259[0];
          operator new[]();
        }
        goto LABEL_274;
      }
      if (v91) {
        goto LABEL_434;
      }
      unsigned int v241 = v259[0];
      v240 = (unint64_t *)__src;
      llvm::APInt::operator+=((uint64_t)&v240, v9 & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v132 = v241;
      unsigned int v241 = 0;
      if (v132 < 0x41)
      {
        if ((unint64_t)v240 <= v90) {
          goto LABEL_436;
        }
LABEL_434:
        uint64_t v25 = 2;
        goto LABEL_274;
      }
      int v146 = 0;
      int64_t v147 = (unint64_t)(v132 + 63) >> 6;
      do
      {
        BOOL v35 = v147-- < 1;
        if (v35) {
          break;
        }
        unint64_t v148 = v240[v147];
        v146 += __clz(v148);
      }
      while (!v148);
      int v149 = v132 | 0xFFFFFFC0;
      if ((v132 & 0x3F) == 0) {
        int v149 = 0;
      }
      if ((v132 - v146 - v149) <= 0x40)
      {
        BOOL v150 = *v240 <= v90;
        if (!v240)
        {
          if (MEMORY[0] <= v90) {
            goto LABEL_436;
          }
          goto LABEL_434;
        }
      }
      else
      {
        if (!v240) {
          goto LABEL_434;
        }
        BOOL v150 = 0;
      }
      MEMORY[0x1D25D9CB0](v240, 0x1000C8000313F17);
      if (v241 >= 0x41 && v240)
      {
        MEMORY[0x1D25D9CB0](v240, 0x1000C8000313F17);
        if (!v150) {
          goto LABEL_434;
        }
      }
      else if (!v150)
      {
        goto LABEL_434;
      }
LABEL_436:
      if (LODWORD(v259[0]) > 0x40) {
        uint64_t v151 = *(void *)__src;
      }
      else {
        uint64_t v151 = (uint64_t)((void)__src << -(uint64_t)LODWORD(v259[0])) >> -(uint64_t)LODWORD(v259[0]);
      }
      unint64_t v152 = -(int)v151 + 0x400000;
      unsigned int v153 = 258 - (v151 << 9);
      if (v152 >= 0x800000) {
        int v154 = 2;
      }
      else {
        int v154 = v153;
      }
      if (!(((v154 >> 9) + 0x3FFFFF) >> 23)) {
        unsigned int v153 = 258 - (v154 & 0xFFFFFE00);
      }
      if ((v154 & 0x100) == 0) {
        unsigned int v153 = v154;
      }
      if (v54) {
        uint64_t v25 = v153;
      }
      else {
        uint64_t v25 = v154;
      }
      goto LABEL_274;
    }
LABEL_273:
    uint64_t v25 = 1;
    goto LABEL_274;
  }
  uint64_t v25 = 1;
  if (a3 <= 0xFFFFFFFFFFFFFFFDLL && v9 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    unint64_t v205 = a3;
    unsigned int v239 = 1;
    unint64_t v238 = 0;
    unint64_t v206 = v9;
    if (LODWORD(v259[0]) > 0x40) {
      operator new[]();
    }
    v245[0] = v259[0];
    v244 = __src;
    LODWORD(v249) = v259[0];
    __s1 = __src;
    llvm::APInt::operator+=((uint64_t)&__s1, 1uLL);
    DWORD2(v246) = v249;
    *(void *)&long long v246 = __s1;
    if (v260)
    {
      uint64_t v59 = 0;
      uint64_t v60 = 56 * v260;
      do
      {
        char v61 = (char *)v259[1];
        uint64_t v62 = (char *)v259[1] + v59;
        uint64_t v63 = (unint64_t **)((char *)v259[1] + v59 + 24);
        unsigned int v237 = *(_DWORD *)((char *)v259[1] + v59 + 32);
        if (v237 > 0x40) {
          operator new[]();
        }
        unint64_t v236 = *v63;
        long long v64 = (char *)v259[1] + v59;
        if (*((unsigned char *)v259[1] + v59 + 48))
        {
          if (!v59) {
            goto LABEL_122;
          }
        }
        else
        {
          unsigned int v65 = *((_DWORD *)v62 + 8);
          if (v65 > 0x40)
          {
            llvm::APInt::countTrailingZerosSlowCase(v63);
            operator new[]();
          }
          unsigned int v66 = __clz(__rbit64((unint64_t)*v63));
          if (v65 < v66) {
            LOBYTE(v66) = *((_DWORD *)v62 + 8);
          }
          unint64_t v236 = (unint64_t *)(1 << v66);
          unsigned int v237 = v65;
          if (!v59)
          {
LABEL_122:
            sub_1CBF71A98((const llvm::APInt *)&v236, (llvm::APInt *)&__s1);
            if (v239 >= 0x41 && v238) {
              MEMORY[0x1D25D9CB0](v238, 0x1000C8000313F17);
            }
            unint64_t v238 = __s1;
            unsigned int v239 = v249;
            goto LABEL_126;
          }
        }
        unsigned int v235 = v239;
        if (v239 > 0x40) {
          operator new[]();
        }
        uint64_t v234 = v238;
        sub_1CBF71A98((const llvm::APInt *)&v236, (llvm::APInt *)&v232);
        llvm::APIntOps::GreatestCommonDivisor((uint64_t)&v234, (uint64_t)&v232, (uint64_t)&__s1);
        if (v239 >= 0x41 && v238) {
          MEMORY[0x1D25D9CB0](v238, 0x1000C8000313F17);
        }
        unint64_t v238 = __s1;
        unsigned int v239 = v249;
        LODWORD(v249) = 0;
        if (v233 >= 0x41 && v232) {
          MEMORY[0x1D25D9CB0](v232, 0x1000C8000313F17);
        }
        if (v235 >= 0x41 && v234) {
          MEMORY[0x1D25D9CB0](v234, 0x1000C8000313F17);
        }
LABEL_126:
        llvm::computeConstantRange(*(llvm **)&v61[v59], 0, *(llvm::AssumptionCache **)&v61[v59 + 40], 0, 0, 1, *(void *)(a1 + 40), &v228);
        uint64_t v67 = *(void *)&v61[v59];
        long long v68 = *(void **)&v61[v59 + 40];
        uint64_t v70 = *(void *)(a1 + 40);
        long long v69 = *(void **)(a1 + 48);
        if (!v68 || !v68[5])
        {
          if (!v67 || *(unsigned __int8 *)(v67 + 16) < 0x1Cu || (long long v68 = *(void **)&v61[v59], !*(void *)(v67 + 40))) {
            long long v68 = 0;
          }
        }
        __s1 = *(void **)(a1 + 8);
        uint64_t v249 = v70;
        v250[0] = v68;
        v250[1] = v69;
        *(void *)&long long v251 = 0;
        BYTE8(v251) = 1;
        sub_1CC16089C((uint64_t *)v67, 0, (const llvm::DataLayout **)&__s1, (uint64_t)&v224);
        llvm::ConstantRange::fromKnownBits(&v224, 1, (uint64_t)&v220);
        llvm::ConstantRange::intersectWith((uint64_t)&v228, (llvm::ConstantRange *)&v220, 2, (uint64_t)&__s1);
        if (v229 >= 0x41 && v228) {
          MEMORY[0x1D25D9CB0](v228, 0x1000C8000313F17);
        }
        unsigned int v228 = __s1;
        unsigned int v229 = v249;
        LODWORD(v249) = 0;
        if (v231 >= 0x41 && v230)
        {
          MEMORY[0x1D25D9CB0](v230, 0x1000C8000313F17);
          uint64_t v230 = v250[0];
          unsigned int v231 = v250[1];
          LODWORD(v250[1]) = 0;
          if (v249 >= 0x41 && __s1) {
            MEMORY[0x1D25D9CB0](__s1, 0x1000C8000313F17);
          }
        }
        else
        {
          uint64_t v230 = v250[0];
          unsigned int v231 = v250[1];
          LODWORD(v250[1]) = 0;
        }
        if (v223 >= 0x41 && v222) {
          MEMORY[0x1D25D9CB0](v222, 0x1000C8000313F17);
        }
        if (v221 >= 0x41 && v220) {
          MEMORY[0x1D25D9CB0](v220, 0x1000C8000313F17);
        }
        unsigned int v71 = v229;
        unsigned int v217 = v229;
        if (v229 > 0x40) {
          operator new[]();
        }
        uint64_t v216 = v228;
        unsigned int v219 = v231;
        if (v231 > 0x40) {
          operator new[]();
        }
        unsigned int v218 = v230;
        int v72 = *(_DWORD *)&v61[v59 + 16];
        if (v72)
        {
          llvm::ConstantRange::truncate((uint64_t)&v216, v229 - v72, (uint64_t)&__s1);
          if (v217 >= 0x41 && v216) {
            MEMORY[0x1D25D9CB0](v216, 0x1000C8000313F17);
          }
          uint64_t v216 = __s1;
          unsigned int v217 = v249;
          LODWORD(v249) = 0;
          if (v219 >= 0x41 && v218)
          {
            MEMORY[0x1D25D9CB0](v218, 0x1000C8000313F17);
            unsigned int v218 = v250[0];
            unsigned int v219 = v250[1];
            LODWORD(v250[1]) = 0;
            if (v249 >= 0x41 && __s1) {
              MEMORY[0x1D25D9CB0](__s1, 0x1000C8000313F17);
            }
          }
          else
          {
            unsigned int v218 = v250[0];
            unsigned int v219 = v250[1];
          }
          unsigned int v71 = v217;
        }
        int v73 = *(_DWORD *)&v61[v59 + 12];
        if (v73)
        {
          llvm::ConstantRange::signExtend((llvm::ConstantRange *)&v216, v73 + v71, (uint64_t)&__s1);
          if (v217 >= 0x41 && v216) {
            MEMORY[0x1D25D9CB0](v216, 0x1000C8000313F17);
          }
          uint64_t v216 = __s1;
          unsigned int v217 = v249;
          LODWORD(v249) = 0;
          if (v219 >= 0x41 && v218)
          {
            MEMORY[0x1D25D9CB0](v218, 0x1000C8000313F17);
            unsigned int v218 = v250[0];
            unsigned int v219 = v250[1];
            LODWORD(v250[1]) = 0;
            if (v249 >= 0x41 && __s1) {
              MEMORY[0x1D25D9CB0](__s1, 0x1000C8000313F17);
            }
          }
          else
          {
            unsigned int v218 = v250[0];
            unsigned int v219 = v250[1];
          }
          unsigned int v71 = v217;
        }
        int v74 = *(_DWORD *)&v61[v59 + 8];
        if (v74)
        {
          llvm::ConstantRange::zeroExtend((uint64_t)&v216, v74 + v71, (uint64_t)&__s1);
          if (v217 >= 0x41 && v216) {
            MEMORY[0x1D25D9CB0](v216, 0x1000C8000313F17);
          }
          uint64_t v216 = __s1;
          unsigned int v217 = v249;
          LODWORD(v249) = 0;
          if (v219 >= 0x41 && v218)
          {
            MEMORY[0x1D25D9CB0](v218, 0x1000C8000313F17);
            unsigned int v218 = v250[0];
            unsigned int v219 = v250[1];
            LODWORD(v250[1]) = 0;
            if (v249 >= 0x41 && __s1) {
              MEMORY[0x1D25D9CB0](__s1, 0x1000C8000313F17);
            }
          }
          else
          {
            unsigned int v218 = v250[0];
            unsigned int v219 = v250[1];
          }
          unsigned int v71 = v217;
        }
        unsigned int v221 = v71;
        unint64_t v220 = (unint64_t)v216;
        unsigned int v223 = v219;
        uint64_t v222 = v218;
        unsigned int v217 = 0;
        unsigned int v219 = 0;
        llvm::ConstantRange::sextOrTrunc(&v220, v245[0], (uint64_t)&__s1);
        if (v229 >= 0x41 && v228) {
          MEMORY[0x1D25D9CB0](v228, 0x1000C8000313F17);
        }
        unsigned int v228 = __s1;
        unsigned int v229 = v249;
        LODWORD(v249) = 0;
        if (v231 >= 0x41 && v230)
        {
          MEMORY[0x1D25D9CB0](v230, 0x1000C8000313F17);
          uint64_t v230 = v250[0];
          unsigned int v231 = v250[1];
          LODWORD(v250[1]) = 0;
          if (v249 >= 0x41 && __s1) {
            MEMORY[0x1D25D9CB0](__s1, 0x1000C8000313F17);
          }
        }
        else
        {
          uint64_t v230 = v250[0];
          unsigned int v231 = v250[1];
          LODWORD(v250[1]) = 0;
        }
        if (v223 >= 0x41 && v222) {
          MEMORY[0x1D25D9CB0](v222, 0x1000C8000313F17);
        }
        if (v221 >= 0x41 && v220) {
          MEMORY[0x1D25D9CB0](v220, 0x1000C8000313F17);
        }
        if (v219 >= 0x41 && v218) {
          MEMORY[0x1D25D9CB0](v218, 0x1000C8000313F17);
        }
        if (v217 >= 0x41 && v216) {
          MEMORY[0x1D25D9CB0](v216, 0x1000C8000313F17);
        }
        if (v64[48])
        {
          unsigned int v75 = *((_DWORD *)v62 + 8);
          if (v75 > 0x40) {
            operator new[]();
          }
          uint64_t v76 = *v63;
          unsigned int v213 = *((_DWORD *)v62 + 8);
          unsigned int v212 = v76;
          LODWORD(v249) = v75;
          __s1 = v76;
          llvm::APInt::operator+=((uint64_t)&__s1, 1uLL);
          unsigned int v215 = v249;
          unsigned int v214 = __s1;
          llvm::ConstantRange::smul_sat((const void **)&v228, (const llvm::ConstantRange *)&v212, (uint64_t)&v220);
        }
        else
        {
          unsigned int v77 = *((_DWORD *)v62 + 8);
          if (v77 > 0x40) {
            operator new[]();
          }
          uint64_t v78 = *v63;
          unsigned int v213 = *((_DWORD *)v62 + 8);
          unsigned int v212 = v78;
          LODWORD(v249) = v77;
          __s1 = v78;
          llvm::APInt::operator+=((uint64_t)&__s1, 1uLL);
          unsigned int v215 = v249;
          unsigned int v214 = __s1;
          llvm::ConstantRange::smul_fast((llvm::ConstantRange *)&v228, (const void **)&v212, (uint64_t)&v220);
        }
        llvm::ConstantRange::add((uint64_t)&v244, (const llvm::ConstantRange *)&v220, (uint64_t)&__s1);
        if (v245[0] >= 0x41 && v244) {
          MEMORY[0x1D25D9CB0](v244, 0x1000C8000313F17);
        }
        v244 = __s1;
        v245[0] = v249;
        LODWORD(v249) = 0;
        if (DWORD2(v246) >= 0x41 && (void)v246)
        {
          MEMORY[0x1D25D9CB0](v246, 0x1000C8000313F17);
          *(void **)&long long v246 = v250[0];
          DWORD2(v246) = v250[1];
          LODWORD(v250[1]) = 0;
          if (v249 >= 0x41 && __s1) {
            MEMORY[0x1D25D9CB0](__s1, 0x1000C8000313F17);
          }
        }
        else
        {
          *(void **)&long long v246 = v250[0];
          DWORD2(v246) = v250[1];
          LODWORD(v250[1]) = 0;
        }
        if (v223 >= 0x41 && v222) {
          MEMORY[0x1D25D9CB0](v222, 0x1000C8000313F17);
        }
        if (v221 >= 0x41 && v220) {
          MEMORY[0x1D25D9CB0](v220, 0x1000C8000313F17);
        }
        if (v215 >= 0x41 && v214) {
          MEMORY[0x1D25D9CB0](v214, 0x1000C8000313F17);
        }
        if (v213 >= 0x41 && v212) {
          MEMORY[0x1D25D9CB0](v212, 0x1000C8000313F17);
        }
        if (v227 >= 0x41 && v226) {
          MEMORY[0x1D25D9CB0](v226, 0x1000C8000313F17);
        }
        if (v225 >= 0x41 && v224) {
          MEMORY[0x1D25D9CB0](v224, 0x1000C8000313F17);
        }
        if (v231 >= 0x41 && v230) {
          MEMORY[0x1D25D9CB0](v230, 0x1000C8000313F17);
        }
        if (v229 >= 0x41 && v228) {
          MEMORY[0x1D25D9CB0](v228, 0x1000C8000313F17);
        }
        if (v237 >= 0x41 && v236) {
          MEMORY[0x1D25D9CB0](v236, 0x1000C8000313F17);
        }
        v59 += 56;
      }
      while (v60 != v59);
    }
    llvm::APInt::srem((llvm::APInt *)&__src, (const llvm::APInt *)&v238, (uint64_t)&v212);
    unsigned int v79 = v213;
    uint64_t v80 = (unint64_t *)v212;
    unsigned int v81 = (void **)((char *)v212 + 8 * ((v213 - 1) >> 6));
    if (v213 < 0x41) {
      unsigned int v81 = &v212;
    }
    if (((unint64_t)*v81 >> (v213 - 1)))
    {
      unint64_t v82 = v206;
      if (v213 >= 0x41)
      {
        uint64_t v183 = 0;
        uint64_t v184 = (uint64_t *)v238;
        unint64_t v185 = ((unint64_t)v213 + 63) >> 6;
        unint64_t v186 = v185;
        do
        {
          uint64_t v187 = *v184++;
          unint64_t v188 = v187 + *v80;
          BOOL v189 = v188 + 1 <= *v80;
          if (v183)
          {
            ++v188;
            uint64_t v183 = v189;
          }
          else
          {
            uint64_t v183 = v188 < *v80;
          }
          *v80++ = v188;
          --v186;
        }
        while (v186);
        *((void *)v212 + (v185 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v79;
        unsigned int v79 = v213;
        uint64_t v84 = v212;
      }
      else
      {
        unint64_t v83 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v213;
        if (!v213) {
          unint64_t v83 = 0;
        }
        uint64_t v84 = (void *)(v83 & ((unint64_t)v212 + (void)v238));
        unsigned int v212 = v84;
      }
      uint64_t v80 = (unint64_t *)v84;
    }
    else
    {
      uint64_t v84 = v212;
      unint64_t v82 = v206;
    }
    unint64_t v99 = v82 & 0x7FFFFFFFFFFFFFFFLL;
    if (v79 >= 0x41)
    {
      int v100 = 0;
      int64_t v101 = ((unint64_t)v79 + 63) >> 6;
      do
      {
        BOOL v35 = v101-- < 1;
        if (v35) {
          break;
        }
        unint64_t v102 = v80[v101];
        v100 += __clz(v102);
      }
      while (!v102);
      unsigned int v103 = v79 | 0xFFFFFFC0;
      if ((v79 & 0x3F) == 0) {
        unsigned int v103 = 0;
      }
      if (v79 - v100 - v103 > 0x40) {
        goto LABEL_308;
      }
    }
    else
    {
      uint64_t v80 = (unint64_t *)&v212;
    }
    if (*v80 < v99)
    {
      unint64_t v104 = v205 & 0x7FFFFFFFFFFFFFFFLL;
      goto LABEL_315;
    }
LABEL_308:
    if (v239 >= 0x41) {
      operator new[]();
    }
    unint64_t v105 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v239;
    if (!v239) {
      unint64_t v105 = 0;
    }
    unint64_t v104 = v205 & 0x7FFFFFFFFFFFFFFFLL;
    if ((v105 & ((unsigned char *)v238 - (unsigned char *)v84)) >= (v205 & 0x7FFFFFFFFFFFFFFFLL))
    {
      uint64_t v25 = 0;
LABEL_364:
      if (v213 >= 0x41 && v212) {
        MEMORY[0x1D25D9CB0](v212, 0x1000C8000313F17);
      }
      if (DWORD2(v246) >= 0x41 && (void)v246) {
        MEMORY[0x1D25D9CB0](v246, 0x1000C8000313F17);
      }
      if (v245[0] >= 0x41 && v244) {
        MEMORY[0x1D25D9CB0](v244, 0x1000C8000313F17);
      }
      if (v239 >= 0x41 && v238) {
        MEMORY[0x1D25D9CB0](v238, 0x1000C8000313F17);
      }
      goto LABEL_274;
    }
LABEL_315:
    unsigned int v106 = v245[0];
    if (v245[0] > 0x40) {
      operator new[]();
    }
    if (v245[0]) {
      unint64_t v107 = 0xFFFFFFFFFFFFFFFFLL >> -LOBYTE(v245[0]);
    }
    else {
      unint64_t v107 = 0;
    }
    LODWORD(v249) = v245[0];
    __s1 = 0;
    LODWORD(v250[1]) = v245[0];
    v250[0] = (void *)(v107 & v104);
    llvm::ConstantRange::add((uint64_t)&v244, (const llvm::ConstantRange *)&__s1, (uint64_t)&v228);
    if (LODWORD(v250[1]) >= 0x41 && v250[0]) {
      MEMORY[0x1D25D9CB0](v250[0], 0x1000C8000313F17);
    }
    if (v249 >= 0x41 && __s1) {
      MEMORY[0x1D25D9CB0](__s1, 0x1000C8000313F17);
    }
    if (v106 > 0x40) {
      operator new[]();
    }
    if (v106) {
      unint64_t v108 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v106;
    }
    else {
      unint64_t v108 = 0;
    }
    unsigned int v225 = v106;
    uint64_t v224 = 0;
    unsigned int v227 = v106;
    unint64_t v226 = v108 & v99;
    llvm::ConstantRange::intersectWith((uint64_t)&v228, (llvm::ConstantRange *)&v224, 0, (uint64_t)&__s1);
    uint64_t v109 = v249;
    if (v249 > 0x40)
    {
      uint64_t v177 = __s1;
      int v110 = v250[0];
      if (memcmp(__s1, v250[0], (((unint64_t)v249 + 63) >> 3) & 0x3FFFFFF8))
      {
        char v112 = 0;
LABEL_328:
        if (LODWORD(v250[1]) >= 0x41 && v110 != 0)
        {
          MEMORY[0x1D25D9CB0](v110, 0x1000C8000313F17);
          LODWORD(v109) = v249;
        }
        if (v109 >= 0x41 && __s1) {
          MEMORY[0x1D25D9CB0](__s1, 0x1000C8000313F17);
        }
        if (v112)
        {
          uint64_t v25 = 0;
LABEL_358:
          if (v227 >= 0x41 && v226) {
            MEMORY[0x1D25D9CB0](v226, 0x1000C8000313F17);
          }
          if (v225 >= 0x41 && v224) {
            MEMORY[0x1D25D9CB0](v224, 0x1000C8000313F17);
          }
          if (v231 >= 0x41 && v230) {
            MEMORY[0x1D25D9CB0](v230, 0x1000C8000313F17);
          }
          if (v229 >= 0x41 && v228) {
            MEMORY[0x1D25D9CB0](v228, 0x1000C8000313F17);
          }
          goto LABEL_364;
        }
        if (v260 == 2)
        {
          uint64_t v126 = v259[1];
          unsigned int v127 = *((_DWORD *)v259[1] + 22);
          unsigned int v211 = v127;
          if (v127 > 0x40) {
            operator new[]();
          }
          if (v127) {
            unint64_t v133 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v127;
          }
          else {
            unint64_t v133 = 0;
          }
          __s2 = (void *)(v133 & ~*((void *)v259[1] + 10));
          uint64_t v134 = (const void **)((char *)v259[1] + 24);
          llvm::APInt::operator++((uint64_t)&__s2);
          LODWORD(v82) = v211;
          unsigned int v135 = __s2;
          unsigned int v211 = 0;
          uint64_t v136 = v126[8];
          if (v136 > 0x40) {
            BOOL v137 = memcmp(*v134, __s2, ((unint64_t)(v136 + 63) >> 3) & 0x3FFFFFF8) == 0;
          }
          else {
            BOOL v137 = *v134 == __s2;
          }
          BOOL v139 = v137 && v126[4] == 0;
          if (!v139
            || v126[2] != v126[16]
            || v126[3] != v126[17]
            || v126[18]
            || *(_DWORD *)(a1 + 84) != *(_DWORD *)(a1 + 88))
          {
            unint64_t v120 = 0;
            int v125 = 0;
            if (v82 >= 0x41)
            {
              if (v135)
              {
                MEMORY[0x1D25D9CB0](v135, 0x1000C8000313F17);
                unint64_t v120 = 0;
                int v125 = 0;
                if (v211 >= 0x41)
                {
                  uint64_t v124 = (uint64_t)__s2;
                  goto LABEL_502;
                }
              }
            }
LABEL_353:
            uint64_t v25 = !llvm::BasicAAResult::constantOffsetHeuristic(a1, (uint64_t)&v257, v205, v206, *(const llvm::DataLayout **)(a1 + 40), *(const llvm::Instruction **)(a1 + 48));
LABEL_354:
            if (v125 && v82 >= 0x41 && v120) {
              MEMORY[0x1D25D9CB0](v120, 0x1000C8000313F17);
            }
            goto LABEL_358;
          }
          uint64_t v140 = *(void *)v126;
          uint64_t v141 = *((void *)v126 + 7);
          uint64_t v143 = *(void *)(a1 + 40);
          unsigned int v142 = *(void **)(a1 + 48);
          if (!v141
            || *(unsigned __int8 *)(v141 + 16) < 0x1Cu
            || (unsigned int v144 = (void *)*((void *)v126 + 7), !*(void *)(v141 + 40)))
          {
            if (!v140 || *(unsigned __int8 *)(v140 + 16) < 0x1Cu || (unsigned int v144 = *(void **)v126, !*(void *)(v140 + 40))) {
              unsigned int v144 = 0;
            }
          }
          __s1 = *(void **)(a1 + 8);
          uint64_t v249 = v143;
          v250[0] = v144;
          v250[1] = v142;
          *(void *)&long long v251 = 0;
          BYTE8(v251) = 1;
          int v145 = sub_1CC1624EC((uint64_t *)v140, (uint64_t *)v141, 0, (uint64_t)&__s1);
          if (v82 >= 0x41 && v135) {
            MEMORY[0x1D25D9CB0](v135, 0x1000C8000313F17);
          }
          if (v211 >= 0x41 && __s2) {
            MEMORY[0x1D25D9CB0](__s2, 0x1000C8000313F17);
          }
          if (!v145)
          {
            int v125 = 0;
            unint64_t v120 = 0;
            goto LABEL_353;
          }
          sub_1CBF71A98((const llvm::APInt *)v134, (llvm::APInt *)&__s1);
          LODWORD(v82) = v249;
          unint64_t v120 = __s1;
        }
        else
        {
          if (v260 != 1) {
            goto LABEL_352;
          }
          uint64_t v114 = v259[1];
          if (*((_DWORD *)v259[1] + 4)) {
            goto LABEL_352;
          }
          uint64_t v115 = *(void *)v259[1];
          uint64_t v116 = (void *)*((void *)v259[1] + 5);
          uint64_t v118 = *(void *)(a1 + 40);
          unsigned int v117 = *(void **)(a1 + 48);
          if (!v116 || !v116[5])
          {
            if (!v115
              || *(unsigned __int8 *)(v115 + 16) < 0x1Cu
              || (uint64_t v116 = *(void **)v259[1], !*(void *)(v115 + 40)))
            {
              uint64_t v116 = 0;
            }
          }
          __s1 = *(void **)(a1 + 8);
          uint64_t v249 = v118;
          v250[0] = v116;
          v250[1] = v117;
          *(void *)&long long v251 = 0;
          BYTE8(v251) = 1;
          if (!sub_1CC1620B8(v115, 0, (uint64_t)&__s1))
          {
LABEL_352:
            int v125 = 0;
            unint64_t v120 = 0;
            goto LABEL_353;
          }
          LODWORD(v82) = v114[8];
          if (v82 > 0x40) {
            operator new[]();
          }
          unint64_t v119 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v82;
          if (!v82) {
            LOBYTE(v119) = 0;
          }
          unint64_t v120 = (unsigned char *)(v119 & 1);
          unsigned int v121 = (const llvm::APInt *)(v114 + 6);
          if (*((unsigned char *)v114 + 48)) {
            goto LABEL_346;
          }
          int v157 = **(llvm::Type ***)v114;
          int PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits(v157);
          if (v158 == 1)
          {
            int v157 = **(llvm::Type ***)v114;
          }
          int v161 = llvm::Type::getPrimitiveSizeInBits(v157);
          if (v160 == 1) {
          int v162 = v161 - (v114[4] + PrimitiveSizeInBits) + v114[2] + v114[3];
          }
          if (v162 >= 1)
          {
            unsigned int v221 = v161 - (v114[4] + PrimitiveSizeInBits) + v114[2] + v114[3];
            if (v162 > 0x40) {
              operator new[]();
            }
            unint64_t v220 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v162;
            unsigned int v163 = v114[8];
            if (v163 > 0x40)
            {
              if (v221 != v163) {
                operator new[]();
              }
              sub_1CD0463BC((uint64_t)&__s1, (uint64_t)&v220);
            }
            else
            {
              LODWORD(v249) = v114[8];
              unint64_t v164 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v163;
              if (!v163) {
                unint64_t v164 = 0;
              }
              __s1 = (void *)(v164 & v220);
            }
            uint64_t v165 = v114[8];
            if (v165 > 0x40)
            {
              uint64_t v166 = __s1;
              unint64_t v190 = ((unint64_t)(v165 + 63) >> 3) & 0x3FFFFFF8;
              do
              {
                if (!v190)
                {
                  int v167 = 0;
                  goto LABEL_467;
                }
                unint64_t v191 = *(void *)(*(void *)v121 - 8 + v190);
                unint64_t v192 = *(void *)((char *)__s1 + v190 - 8);
                v190 -= 8;
              }
              while (v191 == v192);
              int v167 = v191 > v192 ? 1 : -1;
            }
            else
            {
              uint64_t v166 = __s1;
              int v167 = *(void *)v121 < (unint64_t)__s1 ? -1 : *(void *)v121 > (unint64_t)__s1;
            }
LABEL_467:
            if (v249 >= 0x41 && v166 != 0) {
              MEMORY[0x1D25D9CB0]();
            }
            if (v221 >= 0x41 && v220) {
              MEMORY[0x1D25D9CB0](v220, 0x1000C8000313F17);
            }
            if (v167 <= 0)
            {
LABEL_346:
              sub_1CBF71A98(v121, (llvm::APInt *)&__s1);
              unint64_t v120 = __s1;
              LODWORD(v82) = v249;
            }
          }
        }
        unsigned int v122 = v259[0];
        if (LODWORD(v259[0]) >= 0x41) {
          operator new[]();
        }
        unint64_t v123 = 0xFFFFFFFFFFFFFFFFLL >> -LOBYTE(v259[0]);
        if (!LODWORD(v259[0])) {
          unint64_t v123 = 0;
        }
        uint64_t v124 = v123 & ((unsigned char *)__src - v120);
        if (LODWORD(v259[0])) {
          unint64_t v155 = 0xFFFFFFFFFFFFFFFFLL >> -LOBYTE(v259[0]);
        }
        else {
          unint64_t v155 = 0;
        }
        unint64_t v156 = v155 & (unint64_t)&v120[(void)__src];
        if ((v124 & (1 << (LOBYTE(v259[0]) - 1))) == 0)
        {
LABEL_501:
          int v125 = 1;
          if (v122 >= 0x41)
          {
LABEL_502:
            if (v124) {
              MEMORY[0x1D25D9CB0](v124, 0x1000C8000313F17);
            }
            goto LABEL_353;
          }
          goto LABEL_353;
        }
        char v207 = (char)v259[0];
        unsigned int v209 = v259[0];
        if (LODWORD(v259[0])) {
          unint64_t v169 = 0xFFFFFFFFFFFFFFFFLL >> -LOBYTE(v259[0]);
        }
        else {
          unint64_t v169 = 0;
        }
        unsigned int v208 = (void *)(v169 & ~v124);
        llvm::APInt::operator++((uint64_t)&v208);
        uint64_t v170 = v209;
        __s1 = v208;
        unsigned int v209 = 0;
        if (v170 >= 0x41)
        {
          int v172 = 0;
          int64_t v173 = (unint64_t)(v170 + 63) >> 6;
          do
          {
            BOOL v35 = v173-- < 1;
            if (v35) {
              break;
            }
            unint64_t v174 = *((void *)v208 + v173);
            v172 += __clz(v174);
          }
          while (!v174);
          int v175 = v170 | 0xFFFFFFC0;
          if ((v170 & 0x3F) == 0) {
            int v175 = 0;
          }
          unsigned int v176 = v170 - v172 - v175;
          p_s1 = (void **)v208;
          if (v176 > 0x40)
          {
LABEL_491:
            if ((v156 & (1 << (v207 - 1))) == 0)
            {
              BOOL v178 = v156 >= v99;
LABEL_494:
              if (v170 >= 0x41)
              {
                if (v208)
                {
                  MEMORY[0x1D25D9CB0]();
                  if (v209 >= 0x41)
                  {
                    if (v208) {
                      MEMORY[0x1D25D9CB0](v208, 0x1000C8000313F17);
                    }
                  }
                }
              }
              if (v178)
              {
                uint64_t v25 = 0;
                int v125 = 1;
                goto LABEL_354;
              }
              goto LABEL_501;
            }
LABEL_493:
            BOOL v178 = 0;
            goto LABEL_494;
          }
        }
        else
        {
          p_s1 = &__s1;
        }
        if ((unint64_t)*p_s1 < v104) {
          goto LABEL_493;
        }
        goto LABEL_491;
      }
      int v179 = 0;
      int64_t v180 = (unint64_t)(v109 + 63) >> 6;
      do
      {
        BOOL v35 = v180-- < 1;
        if (v35) {
          break;
        }
        unint64_t v181 = v177[v180];
        v179 += __clz(v181);
      }
      while (!v181);
      int v182 = v109 | 0xFFFFFFC0;
      if ((v109 & 0x3F) == 0) {
        int v182 = 0;
      }
      BOOL v111 = v179 + v182 == v109;
    }
    else
    {
      int v110 = v250[0];
      BOOL v111 = ((unint64_t)v250[0] | (unint64_t)__s1) == 0;
    }
    char v112 = v111;
    goto LABEL_328;
  }
LABEL_274:
  long long v92 = (char *)v254[1];
  if (v255)
  {
    uint64_t v93 = 56 * v255;
    do
    {
      if (*(_DWORD *)&v92[v93 - 24] >= 0x41u)
      {
        uint64_t v94 = *(void *)&v92[v93 - 32];
        if (v94) {
          MEMORY[0x1D25D9CB0](v94, 0x1000C8000313F17);
        }
      }
      v93 -= 56;
    }
    while (v93);
    long long v92 = (char *)v254[1];
  }
  if (v92 != (char *)&v255 + 8) {
    free(v92);
  }
  if (LODWORD(v254[0]) >= 0x41 && v253) {
    MEMORY[0x1D25D9CB0](v253, 0x1000C8000313F17);
  }
  int v95 = (char *)v259[1];
  if (v260)
  {
    uint64_t v96 = 56 * v260;
    do
    {
      if (*(_DWORD *)&v95[v96 - 24] >= 0x41u)
      {
        uint64_t v97 = *(void *)&v95[v96 - 32];
        if (v97) {
          MEMORY[0x1D25D9CB0](v97, 0x1000C8000313F17);
        }
      }
      v96 -= 56;
    }
    while (v96);
    int v95 = (char *)v259[1];
  }
  if (v95 != (char *)&v260 + 8) {
    free(v95);
  }
  if (LODWORD(v259[0]) >= 0x41 && __src) {
    MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
  }
  return v25;
}

void llvm::BasicAAResult::subtractDecomposedGEPs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(unsigned int *)(a2 + 16);
  if (v5 >= 0x41)
  {
    uint64_t v23 = 0;
    uint64_t v24 = *(unint64_t **)(a2 + 8);
    uint64_t v25 = *(unint64_t **)(a3 + 8);
    unint64_t v26 = (unint64_t)(v5 + 63) >> 6;
    unint64_t v27 = v26;
    do
    {
      unint64_t v28 = *v25++;
      unint64_t v29 = *v24 - v28;
      BOOL v30 = *v24 < v28;
      unint64_t v31 = *v24 + ~v28;
      if (v23)
      {
        uint64_t v23 = v31 >= *v24;
      }
      else
      {
        unint64_t v31 = v29;
        uint64_t v23 = v30;
      }
      *v24++ = v31;
      --v27;
    }
    while (v27);
    *(void *)(*(void *)(a2 + 8) + 8 * (v26 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -(char)v5;
  }
  else
  {
    if (v5) {
      unint64_t v6 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v5;
    }
    else {
      unint64_t v6 = 0;
    }
    *(void *)(a2 + 8) = v6 & (*(void *)(a2 + 8) - *(void *)(a3 + 8));
  }
  unsigned int v7 = *(_DWORD *)(a3 + 32);
  if (v7)
  {
    int v8 = *(long long **)(a3 + 24);
    unint64_t v9 = (long long *)((char *)v8 + 56 * v7);
    uint64_t v10 = (void *)(a2 + 24);
    do
    {
      unsigned int v11 = *(_DWORD *)(a2 + 32);
      if (!v11)
      {
LABEL_13:
        long long v16 = *v8;
        int v62 = *((_DWORD *)v8 + 4);
        long long v61 = v16;
        unsigned int v17 = *((_DWORD *)v8 + 8);
        unsigned int v60 = v17;
        if (v17 > 0x40) {
          operator new[]();
        }
        unint64_t v18 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v17;
        if (!v17) {
          unint64_t v18 = 0;
        }
        unint64_t v59 = v18 & ~*((void *)v8 + 3);
        llvm::APInt::operator++((uint64_t)&v59);
        unsigned int v64 = v60;
        unint64_t v63 = v59;
        unsigned int v60 = 0;
        uint64_t v65 = *((void *)v8 + 5);
        char v66 = *((unsigned char *)v8 + 48);
        sub_1CBF6CC78(a2 + 24, (char *)&v61);
        if (v64 >= 0x41)
        {
          if (v63) {
            MEMORY[0x1D25D9CB0](v63, 0x1000C8000313F17);
          }
        }
        goto LABEL_17;
      }
      uint64_t v12 = 0;
      uint64_t v13 = *(void *)(a2 + 24);
      uint64_t v14 = v13 + 56 * v11;
      while (1)
      {
        uint64_t v15 = *(void *)v13;
        if (*(void *)v13 == *(void *)v8)
        {
          if (v15) {
            BOOL v19 = *(unsigned __int8 *)(v15 + 16) >= 0x1Cu;
          }
          else {
            BOOL v19 = 0;
          }
          if (!v19) {
            goto LABEL_25;
          }
          unsigned int v20 = *(_DWORD *)(a1 + 84) - *(_DWORD *)(a1 + 88);
          if (!v20) {
            goto LABEL_25;
          }
          if (v20 <= 0x14) {
            break;
          }
        }
LABEL_12:
        v13 += 56;
        ++v12;
        if (v13 == v14) {
          goto LABEL_13;
        }
      }
      uint64_t v55 = v12;
      uint64_t v57 = v13;
      uint64_t v53 = *(void *)v13;
      uint64_t v33 = *(void *)(a1 + 72);
      uint64_t v34 = 80;
      if (v33 == *(void *)(a1 + 64)) {
        uint64_t v34 = 84;
      }
      uint64_t v35 = *(unsigned int *)(a1 + v34);
      if (v35)
      {
        uint64_t v36 = 8 * v35;
        unsigned int v37 = *(uint64_t **)(a1 + 72);
        while ((unint64_t)*v37 >= 0xFFFFFFFFFFFFFFFELL)
        {
          ++v37;
          v36 -= 8;
          uint64_t v12 = v55;
          uint64_t v13 = v57;
          if (!v36) {
            goto LABEL_25;
          }
        }
      }
      else
      {
        unsigned int v37 = *(uint64_t **)(a1 + 72);
      }
      BOOL v38 = (uint64_t *)(v33 + 8 * v35);
      uint64_t v12 = v55;
      uint64_t v13 = v57;
      if (v37 != v38)
      {
        uint64_t v39 = *v37;
LABEL_49:
        uint64_t v40 = *(void *)(v39 + 48);
        if (v40) {
          uint64_t v41 = v40 - 24;
        }
        else {
          uint64_t v41 = 0;
        }
        char isPotentiallyReachable = llvm::isPotentiallyReachable(v41, v53, 0, *(void *)(a1 + 48), 0);
        uint64_t v12 = v55;
        uint64_t v13 = v57;
        if (isPotentiallyReachable) {
          goto LABEL_12;
        }
        while (1)
        {
          ++v37;
          uint64_t v12 = v55;
          uint64_t v13 = v57;
          if (v37 == v38) {
            break;
          }
          uint64_t v39 = *v37;
          if ((unint64_t)*v37 < 0xFFFFFFFFFFFFFFFELL) {
            goto LABEL_49;
          }
        }
      }
LABEL_25:
      if (*(_DWORD *)(v13 + 8) != *((_DWORD *)v8 + 2)
        || *(_DWORD *)(v13 + 12) != *((_DWORD *)v8 + 3)
        || *(_DWORD *)(v13 + 16) != *((_DWORD *)v8 + 4))
      {
        goto LABEL_12;
      }
      uint64_t v21 = *(unsigned int *)(v13 + 32);
      if (v21 > 0x40)
      {
        uint64_t v43 = *(unint64_t **)(v13 + 24);
        unint64_t v44 = v21 + 63;
        unsigned int v56 = (unint64_t *)*((void *)v8 + 3);
        uint64_t v58 = v13;
        uint64_t v45 = v12;
        char v54 = *(_DWORD *)(v13 + 32);
        int v46 = memcmp(v43, v56, ((unint64_t)(v21 + 63) >> 3) & 0x3FFFFFF8);
        uint64_t v12 = v45;
        if (v46)
        {
          uint64_t v47 = 0;
          unint64_t v48 = v44 >> 6;
          do
          {
            unint64_t v49 = *v56++;
            unint64_t v50 = *v43 - v49;
            BOOL v51 = *v43 < v49;
            unint64_t v52 = *v43 + ~v49;
            if (v47)
            {
              uint64_t v47 = v52 >= *v43;
            }
            else
            {
              unint64_t v52 = v50;
              uint64_t v47 = v51;
            }
            *v43++ = v52;
            --v48;
          }
          while (v48);
          uint64_t v13 = v58;
          *(void *)(*(void *)(v58 + 24) + 8 * ((v44 >> 6) - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -v54;
          goto LABEL_40;
        }
LABEL_30:
        sub_1CBF6C9F4((uint64_t *)(a2 + 24), *v10 + 56 * v12);
      }
      else
      {
        uint64_t v22 = *(void *)(v13 + 24) - *((void *)v8 + 3);
        if (!v22) {
          goto LABEL_30;
        }
        unint64_t v32 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v21;
        if (!v21) {
          unint64_t v32 = 0;
        }
        *(void *)(v13 + 24) = v32 & v22;
LABEL_40:
        *(unsigned char *)(v13 + ++*(_DWORD *)(result + 48) = 0;
      }
LABEL_17:
      int v8 = (long long *)((char *)v8 + 56);
    }
    while (v8 != v9);
  }
}

const llvm::APInt *sub_1CBF71A98@<X0>(const llvm::APInt *result@<X0>, llvm::APInt *a2@<X8>)
{
  unsigned int v3 = *((_DWORD *)result + 2);
  unsigned int v4 = v3 - 1;
  if (v3 > 0x40)
  {
    if (((*(void *)(*(void *)result + 8 * (v4 >> 6)) >> v4) & 1) == 0)
    {
      *((_DWORD *)a2 + 2) = v3;
      llvm::APInt::initSlowCase(a2, result);
    }
    int v8 = *((_DWORD *)result + 2);
    operator new[]();
  }
  uint64_t v5 = *(void *)result;
  if ((*(void *)result >> v4))
  {
    int v8 = *((_DWORD *)result + 2);
    if (v3) {
      unint64_t v6 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v3;
    }
    else {
      unint64_t v6 = 0;
    }
    unint64_t v7 = v6 & ~v5;
    uint64_t result = (const llvm::APInt *)llvm::APInt::operator++((uint64_t)&v7);
    *((_DWORD *)a2 + 2) = v8;
    *(void *)a2 = v7;
    int v8 = 0;
  }
  else
  {
    *((_DWORD *)a2 + 2) = v3;
    *(void *)a2 = v5;
  }
  return result;
}

BOOL llvm::BasicAAResult::constantOffsetHeuristic(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, const llvm::DataLayout *a5, const llvm::Instruction *a6)
{
  if (*(_DWORD *)(a2 + 32) != 2 || a3 > 0xFFFFFFFFFFFFFFFDLL || a4 > 0xFFFFFFFFFFFFFFFDLL) {
    return 0;
  }
  uint64_t v9 = *(void *)(a2 + 24);
  if (*(_DWORD *)(v9 + 16)
    || *(_DWORD *)(v9 + 8) != *(_DWORD *)(v9 + 64)
    || *(_DWORD *)(v9 + 12) != *(_DWORD *)(v9 + 68)
    || *(_DWORD *)(v9 + 72))
  {
    return 0;
  }
  unsigned int v15 = *(_DWORD *)(v9 + 88);
  unsigned int v89 = v15;
  if (v15 > 0x40) {
    operator new[]();
  }
  if (v15) {
    unint64_t v16 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v15;
  }
  else {
    unint64_t v16 = 0;
  }
  unint64_t v88 = (const void *)(v16 & ~*(void *)(v9 + 80));
  unsigned int v17 = (const void **)(v9 + 24);
  llvm::APInt::operator++((uint64_t)&v88);
  unsigned int v18 = v89;
  BOOL v19 = v88;
  unsigned int v89 = 0;
  uint64_t v20 = *(unsigned int *)(v9 + 32);
  if (v20 > 0x40)
  {
    uint64_t v57 = v88;
    unsigned int v55 = v18;
    int v56 = memcmp(*v17, v88, ((unint64_t)(v20 + 63) >> 3) & 0x3FFFFFF8);
    unsigned int v18 = v55;
    BOOL v19 = v57;
    if (!v56) {
      goto LABEL_18;
    }
LABEL_113:
    BOOL v21 = 1;
    goto LABEL_19;
  }
  if (*v17 != v88) {
    goto LABEL_113;
  }
LABEL_18:
  BOOL v21 = **(void **)v9 != **(void **)(v9 + 56);
LABEL_19:
  if (v18 >= 0x41)
  {
    if (v19)
    {
      MEMORY[0x1D25D9CB0](v19, 0x1000C8000313F17);
      if (v89 >= 0x41)
      {
        if (v88) {
          MEMORY[0x1D25D9CB0](v88, 0x1000C8000313F17);
        }
      }
    }
  }
  if (v21) {
    return 0;
  }
  unsigned int v75 = *(void **)v9;
  v76[0] = 0;
  LODWORD(v76[1]) = 0;
  sub_1CBF6BB20((uint64_t)&v81, (unint64_t *)&v75, *(const llvm::APInt **)(a1 + 8), 0, a5, a6);
  __src = *(void **)(v9 + 56);
  uint64_t v73 = 0;
  int v74 = 0;
  sub_1CBF6BB20((uint64_t)&v75, (unint64_t *)&__src, *(const llvm::APInt **)(a1 + 8), 0, a5, a6);
  if (v85 > 0x40)
  {
    if (memcmp(v84, __s2, (((unint64_t)v85 + 63) >> 3) & 0x3FFFFFF8)) {
      goto LABEL_26;
    }
  }
  else if (v84 != __s2)
  {
    goto LABEL_26;
  }
  if (v82 != LODWORD(v76[0])) {
    goto LABEL_26;
  }
  if (v83 != *(void *)((char *)v76 + 4)) {
    goto LABEL_26;
  }
  uint64_t v22 = v81;
  if ((void *)v81 != v75) {
    goto LABEL_26;
  }
  if (!v81 || *(unsigned __int8 *)(v81 + 16) < 0x1Cu || (unsigned int v25 = *(_DWORD *)(a1 + 84) - *(_DWORD *)(a1 + 88)) == 0)
  {
LABEL_44:
    if (v87 >= 0x41) {
      operator new[]();
    }
    uint64_t v26 = v86 - v79;
    unint64_t v27 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v87;
    if (!v87) {
      unint64_t v27 = 0;
    }
    LODWORD(v73) = v87;
    unint64_t v28 = v27 & v26;
    __src = (void *)(v27 & v26);
    unsigned int v69 = v87;
    unint64_t v29 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v87;
    if (!v87) {
      unint64_t v29 = 0;
    }
    unint64_t v68 = v29 & ~v28;
    llvm::APInt::operator++((uint64_t)&v68);
    unsigned int v30 = v69;
    unsigned int v71 = v69;
    unint64_t v70 = v68;
    unsigned int v69 = 0;
    if (v73 > 0x40)
    {
      unint64_t v36 = (((unint64_t)v73 + 63) >> 3) & 0x3FFFFFF8;
      while (v36)
      {
        unint64_t v37 = *(void *)((char *)__src + v36 - 8);
        unint64_t v38 = *(void *)(v68 - 8 + v36);
        v36 -= 8;
        if (v37 != v38)
        {
          if (v37 <= v38)
          {
            p_src = &__src;
            goto LABEL_74;
          }
          break;
        }
      }
      p_src = (void **)&v70;
    }
    else
    {
      if ((unint64_t)__src >= v68) {
        p_src = (void **)&v70;
      }
      else {
        p_src = &__src;
      }
      if ((unint64_t)__src < v68) {
        unsigned int v30 = v73;
      }
      if (v30 < 0x41)
      {
        __src = *p_src;
        LODWORD(v73) = v30;
LABEL_57:
        unint64_t v32 = a3 & 0x7FFFFFFFFFFFFFFFLL;
        llvm::APInt::zextOrTrunc((uint64_t *)&__src, *(_DWORD *)(v9 + 32), (uint64_t)&v64);
        sub_1CBF71A98((const llvm::APInt *)(v9 + 24), (llvm::APInt *)&v62);
        llvm::APInt::operator*((uint64_t)&v64, &v62, (uint64_t)&v66);
        if (v63 >= 0x41 && v62) {
          MEMORY[0x1D25D9CB0](v62, 0x1000C8000313F17);
        }
        if (v65 >= 0x41 && v64) {
          MEMORY[0x1D25D9CB0](v64, 0x1000C8000313F17);
        }
        uint64_t v33 = (const llvm::APInt *)(a2 + 8);
        sub_1CBF71A98((const llvm::APInt *)(a2 + 8), (llvm::APInt *)&v60);
        llvm::APInt::operator+=((uint64_t)&v60, v32);
        unsigned int v34 = v61;
        unint64_t v35 = v60;
        unsigned int v61 = 0;
        if (v67 > 0x40)
        {
          unint64_t v39 = (((unint64_t)v67 + 63) >> 3) & 0x3FFFFFF8;
          while (v39)
          {
            unint64_t v40 = *(void *)(v66 - 8 + v39);
            unint64_t v41 = *(void *)(v60 - 8 + v39);
            v39 -= 8;
            if (v40 != v41)
            {
              if (v40 <= v41) {
                goto LABEL_61;
              }
              break;
            }
          }
        }
        else if (v66 < v60)
        {
LABEL_61:
          BOOL v23 = 0;
LABEL_62:
          if (v34 >= 0x41 && v35) {
            MEMORY[0x1D25D9CB0](v35, 0x1000C8000313F17);
          }
          if (v61 >= 0x41 && v60) {
            MEMORY[0x1D25D9CB0](v60, 0x1000C8000313F17);
          }
          if (v67 >= 0x41 && v66) {
            MEMORY[0x1D25D9CB0](v66, 0x1000C8000313F17);
          }
          if (v71 >= 0x41 && v70) {
            MEMORY[0x1D25D9CB0](v70, 0x1000C8000313F17);
          }
          if (v73 >= 0x41 && __src) {
            MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
          }
          goto LABEL_27;
        }
        sub_1CBF71A98(v33, (llvm::APInt *)&v58);
        llvm::APInt::operator+=((uint64_t)&v58, a4 & 0x7FFFFFFFFFFFFFFFLL);
        unsigned int v42 = v59;
        unsigned int v59 = 0;
        if (v67 > 0x40)
        {
          unint64_t v43 = (((unint64_t)v67 + 63) >> 3) & 0x3FFFFFF8;
          while (v43)
          {
            unint64_t v44 = *(void *)(v66 - 8 + v43);
            unint64_t v45 = *(void *)(v58 + v43 - 8);
            v43 -= 8;
            if (v44 != v45)
            {
              if (v44 > v45) {
                LODWORD(v43) = 1;
              }
              else {
                LODWORD(v43) = -1;
              }
              break;
            }
          }
        }
        else
        {
          LODWORD(v43) = v66 > v58;
          if (v66 < v58) {
            LODWORD(v43) = -1;
          }
        }
        BOOL v23 = (v43 & 0x80000000) == 0;
        if (v42 >= 0x41)
        {
          if (v58)
          {
            MEMORY[0x1D25D9CB0](v58, 0x1000C8000313F17);
            if (v59 >= 0x41)
            {
              if (v58) {
                MEMORY[0x1D25D9CB0](v58, 0x1000C8000313F17);
              }
            }
          }
        }
        goto LABEL_62;
      }
    }
LABEL_74:
    llvm::APInt::assignSlowCase((const llvm::APInt *)&__src, (const llvm::APInt *)p_src);
    goto LABEL_57;
  }
  if (v25 <= 0x14)
  {
    uint64_t v46 = *(void *)(a1 + 72);
    uint64_t v47 = 80;
    if (v46 == *(void *)(a1 + 64)) {
      uint64_t v47 = 84;
    }
    uint64_t v48 = *(unsigned int *)(a1 + v47);
    if (v48)
    {
      uint64_t v49 = 8 * v48;
      unint64_t v50 = *(uint64_t **)(a1 + 72);
      while ((unint64_t)*v50 >= 0xFFFFFFFFFFFFFFFELL)
      {
        ++v50;
        v49 -= 8;
        if (!v49) {
          goto LABEL_44;
        }
      }
    }
    else
    {
      unint64_t v50 = *(uint64_t **)(a1 + 72);
    }
    BOOL v51 = (uint64_t *)(v46 + 8 * v48);
    if (v50 != v51)
    {
      uint64_t v52 = *v50;
LABEL_102:
      uint64_t v53 = *(void *)(v52 + 48);
      if (v53) {
        uint64_t v54 = v53 - 24;
      }
      else {
        uint64_t v54 = 0;
      }
      if (llvm::isPotentiallyReachable(v54, v22, 0, *(void *)(a1 + 48), 0)) {
        goto LABEL_26;
      }
      while (++v50 != v51)
      {
        uint64_t v52 = *v50;
        if ((unint64_t)*v50 < 0xFFFFFFFFFFFFFFFELL) {
          goto LABEL_102;
        }
      }
    }
    goto LABEL_44;
  }
LABEL_26:
  BOOL v23 = 0;
LABEL_27:
  if (v80 >= 0x41 && v79) {
    MEMORY[0x1D25D9CB0](v79, 0x1000C8000313F17);
  }
  if (v78 >= 0x41 && __s2) {
    MEMORY[0x1D25D9CB0](__s2, 0x1000C8000313F17);
  }
  if (v87 >= 0x41 && v86) {
    MEMORY[0x1D25D9CB0](v86, 0x1000C8000313F17);
  }
  if (v85 >= 0x41 && v84) {
    MEMORY[0x1D25D9CB0](v84, 0x1000C8000313F17);
  }
  return v23;
}

uint64_t llvm::BasicAAResult::aliasSelect(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a4 && *(unsigned char *)(a4 + 16) == 85 && *(void *)(a2 - 96) == *(void *)(a4 - 96))
  {
    uint64_t v27 = *a1;
    uint64_t v45 = *(void *)(a2 - 64);
    uint64_t v46 = a3;
    long long v47 = 0u;
    long long v48 = 0u;
    uint64_t v41 = *(void *)(a4 - 64);
    uint64_t v42 = a5;
    long long v43 = 0u;
    long long v44 = 0u;
    if (v27)
    {
      int v28 = *(_DWORD *)(a6 + 336);
      *(_DWORD *)(a6 + 336) = v28 + 1;
      uint64_t v29 = *(void *)(v27 + 8);
      uint64_t v30 = *(void *)(v27 + 16);
      if (v29 == v30)
      {
        unsigned __int8 v19 = 1;
      }
      else
      {
        uint64_t v31 = v29 + 8;
        do
        {
          unsigned __int8 v32 = (*(uint64_t (**)(void, uint64_t *, uint64_t *, uint64_t))(**(void **)(v31 - 8) + 24))(*(void *)(v31 - 8), &v45, &v41, a6);
          BOOL v33 = v32 != 1 || v31 == v30;
          v31 += 8;
        }
        while (!v33);
        unsigned __int8 v19 = v32;
        int v28 = *(_DWORD *)(a6 + 336) - 1;
      }
      *(_DWORD *)(a6 + 336) = v28;
    }
    else
    {
      unsigned __int8 v19 = llvm::BasicAAResult::aliasCheck(a1);
    }
    if (v19 == 1) {
      return 1;
    }
    uint64_t v36 = *a1;
    uint64_t v45 = *(void *)(a2 - 32);
    uint64_t v46 = a3;
    long long v47 = 0u;
    long long v48 = 0u;
    uint64_t v41 = *(void *)(a4 - 32);
    uint64_t v42 = a5;
    long long v43 = 0u;
    long long v44 = 0u;
    if (v36)
    {
      int v22 = *(_DWORD *)(a6 + 336);
      *(_DWORD *)(a6 + 336) = v22 + 1;
      uint64_t v37 = *(void *)(v36 + 8);
      uint64_t v38 = *(void *)(v36 + 16);
      if (v37 != v38)
      {
        uint64_t v39 = v37 + 8;
        do
        {
          uint64_t result = (*(uint64_t (**)(void, uint64_t *, uint64_t *, uint64_t))(**(void **)(v39 - 8) + 24))(*(void *)(v39 - 8), &v45, &v41, a6);
          BOOL v40 = result != 1 || v39 == v38;
          v39 += 8;
        }
        while (!v40);
        goto LABEL_25;
      }
LABEL_63:
      uint64_t result = 1;
      goto LABEL_26;
    }
    unsigned int v34 = a1;
  }
  else
  {
    uint64_t v12 = *a1;
    uint64_t v45 = a4;
    uint64_t v46 = a5;
    long long v47 = 0u;
    long long v48 = 0u;
    uint64_t v41 = *(void *)(a2 - 64);
    uint64_t v42 = a3;
    long long v43 = 0u;
    long long v44 = 0u;
    if (v12)
    {
      int v13 = *(_DWORD *)(a6 + 336);
      *(_DWORD *)(a6 + 336) = v13 + 1;
      uint64_t v14 = *(void *)(v12 + 8);
      uint64_t v15 = *(void *)(v12 + 16);
      if (v14 == v15)
      {
        unsigned __int8 v19 = 1;
      }
      else
      {
        uint64_t v16 = v14 + 8;
        do
        {
          unsigned __int8 v17 = (*(uint64_t (**)(void, uint64_t *, uint64_t *, uint64_t))(**(void **)(v16 - 8) + 24))(*(void *)(v16 - 8), &v45, &v41, a6);
          BOOL v18 = v17 != 1 || v16 == v15;
          v16 += 8;
        }
        while (!v18);
        unsigned __int8 v19 = v17;
        int v13 = *(_DWORD *)(a6 + 336) - 1;
      }
      *(_DWORD *)(a6 + 336) = v13;
    }
    else
    {
      unsigned __int8 v19 = llvm::BasicAAResult::aliasCheck(a1);
    }
    if (v19 == 1) {
      return 1;
    }
    uint64_t v21 = *a1;
    uint64_t v45 = a4;
    uint64_t v46 = a5;
    long long v47 = 0u;
    long long v48 = 0u;
    uint64_t v41 = *(void *)(a2 - 32);
    uint64_t v42 = a3;
    long long v43 = 0u;
    long long v44 = 0u;
    if (v21)
    {
      int v22 = *(_DWORD *)(a6 + 336);
      *(_DWORD *)(a6 + 336) = v22 + 1;
      uint64_t v23 = *(void *)(v21 + 8);
      uint64_t v24 = *(void *)(v21 + 16);
      if (v23 != v24)
      {
        uint64_t v25 = v23 + 8;
        do
        {
          uint64_t result = (*(uint64_t (**)(void, uint64_t *, uint64_t *, uint64_t))(**(void **)(v25 - 8) + 24))(*(void *)(v25 - 8), &v45, &v41, a6);
          BOOL v26 = result != 1 || v25 == v24;
          v25 += 8;
        }
        while (!v26);
LABEL_25:
        int v22 = *(_DWORD *)(a6 + 336) - 1;
LABEL_26:
        *(_DWORD *)(a6 + 336) = v22;
        goto LABEL_39;
      }
      goto LABEL_63;
    }
    unsigned int v34 = a1;
  }
  uint64_t result = llvm::BasicAAResult::aliasCheck(v34);
LABEL_39:
  if (result != v19)
  {
    if (v19 == 3 && result == 2)
    {
      return 2;
    }
    else if (result == 3 && v19 == 2)
    {
      return 2;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t llvm::BasicAAResult::aliasPHI(uint64_t *a1, llvm::PHINode *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v152 = *MEMORY[0x1E4F143B8];
  int v6 = *((_DWORD *)a2 + 5);
  uint64_t v7 = v6 & 0x7FFFFFF;
  if ((v6 & 0x7FFFFFF) == 0) {
    return 0;
  }
  uint64_t v10 = a1;
  if (a4 && *(unsigned char *)(a4 + 16) == 83 && *(void *)(a4 + 40) == *((void *)a2 + 5))
  {
    uint64_t v36 = 0;
    uint64_t v14 = 0;
    long long v37 = 0uLL;
    for (char i = 1; ; char i = 0)
    {
      int v39 = *((_DWORD *)a2 + 5);
      if ((v39 & 0x40000000) != 0) {
        BOOL v40 = (char *)*((void *)a2 - 1);
      }
      else {
        BOOL v40 = (char *)a2 - 32 * (v39 & 0x7FFFFFF);
      }
      uint64_t v41 = *(void *)&v40[32 * v36];
      long long v142 = v37;
      v143[0] = v37;
      uint64_t v42 = *v10;
      uint64_t v140 = v41;
      uint64_t v141 = a3;
      int v149 = (uint64_t *)sub_1CBF73380(a4, *(void *)&v40[32 * *((unsigned int *)a2 + 15) + 8 * v36]);
      uint64_t v150 = a5;
      memset(v151, 0, sizeof(v151));
      if (v42)
      {
        int v43 = *(_DWORD *)(a6 + 336);
        *(_DWORD *)(a6 + 336) = v43 + 1;
        uint64_t v44 = *(void *)(v42 + 8);
        uint64_t v45 = *(void *)(v42 + 16);
        if (v44 == v45)
        {
          uint64_t v47 = 1;
        }
        else
        {
          uint64_t v46 = v44 + 8;
          do
          {
            uint64_t v47 = (*(uint64_t (**)(void, uint64_t *, uint64_t **, uint64_t))(**(void **)(v46 - 8) + 24))(*(void *)(v46 - 8), &v140, &v149, a6);
            BOOL v48 = v47 != 1 || v46 == v45;
            v46 += 8;
          }
          while (!v48);
          int v43 = *(_DWORD *)(a6 + 336) - 1;
          uint64_t v10 = a1;
        }
        *(_DWORD *)(a6 + 336) = v43;
        if (i)
        {
LABEL_85:
          uint64_t v14 = v47;
          long long v37 = 0uLL;
          goto LABEL_97;
        }
      }
      else
      {
        uint64_t v47 = llvm::BasicAAResult::aliasCheck(v10);
        if (i) {
          goto LABEL_85;
        }
      }
      long long v37 = 0uLL;
      if (v14 != v47)
      {
        if (v14 == 2 && v47 == 3)
        {
          uint64_t v14 = 2;
          goto LABEL_98;
        }
        if (v47 == 2 && v14 == 3) {
          uint64_t v14 = 2;
        }
        else {
          uint64_t v14 = 1;
        }
      }
LABEL_97:
      if (v14 == 1) {
        return v14;
      }
LABEL_98:
      if (++v36 == v7) {
        return v14;
      }
    }
  }
  unsigned int v11 = (uint64_t *)v151;
  int v149 = (uint64_t *)v151;
  uint64_t v150 = 0x400000000;
  uint64_t v12 = (llvm::PhiValues *)a1[7];
  if (v12)
  {
    ValuesForPhchar i = llvm::PhiValues::getValuesForPhi(v12, a2);
    uint64_t v51 = ValuesForPhi[12];
    if (v51 > 6) {
      goto LABEL_67;
    }
    if (v51)
    {
      int v128 = 0;
      uint64_t v52 = (llvm **)*((void *)ValuesForPhi + 5);
      uint64_t v53 = 8 * v51;
      do
      {
        uint64_t v54 = *v52;
        if (byte_1EBCC3C28 && llvm::getUnderlyingObject(*v52, (const llvm::Value *)6) == a2)
        {
          int v128 = 1;
        }
        else
        {
          if (v150 >= (unint64_t)HIDWORD(v150)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          v149[v150] = (uint64_t)v54;
          LODWORD(v150) = v150 + 1;
        }
        ++v52;
        v53 -= 8;
      }
      while (v53);
    }
    else
    {
      int v128 = 0;
    }
    goto LABEL_113;
  }
  uint64_t v140 = (uint64_t)v143;
  uint64_t v141 = (char *)v143;
  *(void *)&long long v142 = 4;
  DWORD2(v142) = 0;
  if ((v6 & 0x40000000) != 0) {
    int v13 = (llvm **)*((void *)a2 - 1);
  }
  else {
    int v13 = (llvm **)((char *)a2 - 32 * v7);
  }
  uint64_t v15 = 0;
  int v128 = 0;
  uint64_t v16 = &v13[4 * v7];
  do
  {
    unsigned __int8 v17 = v15;
    BOOL v18 = *v13;
    if (*((unsigned char *)*v13 + 16) == 83)
    {
      uint64_t v15 = *v13;
      if (v17)
      {
        uint64_t v15 = *v13;
        if (v17 != v18)
        {
          BOOL v34 = 1;
          goto LABEL_64;
        }
      }
    }
    if (byte_1EBCC3C28 && llvm::getUnderlyingObject(*v13, (const llvm::Value *)6) == a2)
    {
      int v128 = 1;
      goto LABEL_52;
    }
    unsigned __int8 v19 = v141;
    uint64_t v20 = DWORD1(v142);
    if (v141 == (char *)v140)
    {
      if (DWORD1(v142))
      {
        uint64_t v21 = 0;
        uint64_t v22 = 8 * DWORD1(v142);
        uint64_t v23 = (llvm **)v141;
        while (*v23 != v18)
        {
          if (*v23 == (llvm *)-2) {
            uint64_t v21 = v23;
          }
          ++v23;
          v22 -= 8;
          if (!v22)
          {
            if (!v21) {
              goto LABEL_25;
            }
            *uint64_t v21 = v18;
            --DWORD2(v142);
            goto LABEL_50;
          }
        }
        goto LABEL_52;
      }
LABEL_25:
      unsigned int v24 = v142;
      if (DWORD1(v142) < v142)
      {
        ++DWORD1(v142);
        *(void *)&v141[8 * v20] = v18;
LABEL_50:
        if (v150 >= (unint64_t)HIDWORD(v150)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        v149[v150] = (uint64_t)v18;
        LODWORD(v150) = v150 + 1;
        goto LABEL_52;
      }
    }
    else
    {
      unsigned int v24 = v142;
    }
    if (3 * v24 <= 4 * (DWORD1(v142) - DWORD2(v142)))
    {
      if (v24 >= 0x40) {
        v24 *= 2;
      }
      else {
        unsigned int v24 = 128;
      }
    }
    else if (v24 - DWORD1(v142) >= v24 >> 3)
    {
      goto LABEL_30;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v140, v24);
    unsigned int v24 = v142;
    unsigned __int8 v19 = v141;
LABEL_30:
    unsigned int v25 = v24 - 1;
    unsigned int v26 = (v24 - 1) & ((v18 >> 4) ^ (v18 >> 9));
    uint64_t v27 = &v19[8 * v26];
    int v28 = *(llvm **)v27;
    if (*(void *)v27 == -1)
    {
      uint64_t v29 = 0;
LABEL_43:
      if (v29) {
        BOOL v33 = (llvm **)v29;
      }
      else {
        BOOL v33 = (llvm **)v27;
      }
      if (*v33 != v18)
      {
        if (*v33 == (llvm *)-2) {
          --DWORD2(v142);
        }
        else {
          ++DWORD1(v142);
        }
        *BOOL v33 = v18;
        goto LABEL_50;
      }
    }
    else
    {
      uint64_t v29 = 0;
      int v30 = 1;
      while (v28 != v18)
      {
        if (v29) {
          BOOL v31 = 0;
        }
        else {
          BOOL v31 = v28 == (llvm *)-2;
        }
        if (v31) {
          uint64_t v29 = v27;
        }
        unsigned int v32 = v26 + v30++;
        unsigned int v26 = v32 & v25;
        uint64_t v27 = &v19[8 * (v32 & v25)];
        int v28 = *(llvm **)v27;
        if (*(void *)v27 == -1) {
          goto LABEL_43;
        }
      }
    }
LABEL_52:
    v13 += 4;
  }
  while (v13 != v16);
  if (v15) {
    BOOL v34 = (DWORD1(v142) - DWORD2(v142)) > 1;
  }
  else {
    BOOL v34 = 0;
  }
LABEL_64:
  if (v141 != (char *)v140) {
    free(v141);
  }
  if (v34)
  {
LABEL_67:
    uint64_t v14 = 1;
    goto LABEL_68;
  }
LABEL_113:
  if (!v150) {
    goto LABEL_67;
  }
  uint64_t v55 = (uint64_t)a3;
  if (v128) {
    uint64_t v55 = -1;
  }
  uint64_t v127 = v55;
  uint64_t v56 = v10[9];
  uint64_t v57 = *((void *)a2 + 5);
  unsigned int v59 = (unsigned int *)v10 + 21;
  uint64_t v58 = *((unsigned int *)v10 + 21);
  if (v56 == v10[8])
  {
    uint64_t v60 = a4;
    if (v58)
    {
      unsigned int v61 = 0;
      uint64_t v62 = 8 * v58;
      unsigned int v63 = (void *)v10[9];
      while (*v63 != v57)
      {
        if (*v63 == -2) {
          unsigned int v61 = v63;
        }
        ++v63;
        v62 -= 8;
        if (!v62)
        {
          if (!v61) {
            goto LABEL_124;
          }
          int v65 = 0;
          *unsigned int v61 = v57;
          --*((_DWORD *)v10 + 22);
          goto LABEL_149;
        }
      }
      goto LABEL_148;
    }
LABEL_124:
    unsigned int v64 = *((_DWORD *)v10 + 20);
    if (v58 < v64)
    {
      int v65 = 0;
      *unsigned int v59 = v58 + 1;
      *(void *)(v56 + 8 * v58) = v57;
      goto LABEL_149;
    }
  }
  else
  {
    unsigned int v64 = *((_DWORD *)v10 + 20);
    uint64_t v60 = a4;
  }
  if (3 * v64 <= 4 * ((int)v58 - *((_DWORD *)v10 + 22)))
  {
    if (v64 >= 0x40) {
      v64 *= 2;
    }
    else {
      unsigned int v64 = 128;
    }
  }
  else if (v64 - v58 >= v64 >> 3)
  {
    goto LABEL_129;
  }
  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(v10 + 8), v64);
  unsigned int v64 = *((_DWORD *)v10 + 20);
  uint64_t v56 = v10[9];
LABEL_129:
  unsigned int v66 = v64 - 1;
  unsigned int v67 = (v64 - 1) & ((v57 >> 4) ^ (v57 >> 9));
  unint64_t v68 = (void *)(v56 + 8 * v67);
  uint64_t v69 = *v68;
  if (*v68 != -1)
  {
    unint64_t v70 = 0;
    int v71 = 1;
    while (v69 != v57)
    {
      if (v70) {
        BOOL v72 = 0;
      }
      else {
        BOOL v72 = v69 == -2;
      }
      if (v72) {
        unint64_t v70 = v68;
      }
      unsigned int v73 = v67 + v71++;
      unsigned int v67 = v73 & v66;
      unint64_t v68 = (void *)(v56 + 8 * (v73 & v66));
      uint64_t v69 = *v68;
      if (*v68 == -1) {
        goto LABEL_141;
      }
    }
    goto LABEL_148;
  }
  unint64_t v70 = 0;
LABEL_141:
  if (v70) {
    int v74 = v70;
  }
  else {
    int v74 = v68;
  }
  if (*v74 == v57)
  {
LABEL_148:
    int v65 = 1;
  }
  else
  {
    if (*v74 == -2) {
      --*((_DWORD *)v10 + 22);
    }
    else {
      ++*v59;
    }
    int v65 = 0;
    *int v74 = v57;
  }
LABEL_149:
  uint64_t v75 = *(void *)(a6 + 328);
  uint64_t v140 = 1;
  uint64_t v76 = 8;
  do
  {
    unsigned int v77 = (char *)&v140 + v76;
    *(_OWORD *)unsigned int v77 = xmmword_1CFAC3060;
    *((_OWORD *)v77 + 1) = xmmword_1CFAC3060;
    v76 += 40;
  }
  while (v77 + 40 != (char *)&v144);
  uint64_t v78 = *v10;
  unsigned int v122 = (unsigned int *)(v10 + 10);
  uint64_t v144 = v75;
  uint64_t v79 = v145;
  v145[1] = 0;
  int v146 = v148;
  uint64_t v147 = 0x400000000;
  unsigned int v80 = v10;
  uint64_t v81 = (int *)(a6 + 336);
  v145[0] = *(_DWORD *)(a6 + 336);
  if (v65) {
    int v82 = (uint64_t *)a6;
  }
  else {
    int v82 = &v140;
  }
  uint64_t v136 = v60;
  uint64_t v137 = a5;
  long long v138 = 0u;
  long long v139 = 0u;
  uint64_t v83 = v127;
  uint64_t v132 = *v149;
  uint64_t v133 = v127;
  long long v134 = 0u;
  long long v135 = 0u;
  uint64_t v124 = v59;
  if (v78)
  {
    if (v65) {
      uint64_t v84 = v81;
    }
    else {
      uint64_t v84 = v145;
    }
    int v85 = (*v84)++;
    uint64_t v86 = *(void *)(v78 + 8);
    uint64_t v87 = *(void *)(v78 + 16);
    if (v86 == v87)
    {
      uint64_t v91 = 1;
    }
    else
    {
      uint64_t v88 = v86 + 8;
      do
      {
        uint64_t v89 = (*(uint64_t (**)(void, uint64_t *, uint64_t *, uint64_t *))(**(void **)(v88 - 8) + 24))(*(void *)(v88 - 8), &v136, &v132, v82);
        BOOL v90 = v89 != 1 || v88 == v87;
        v88 += 8;
      }
      while (!v90);
      uint64_t v91 = v89;
      int v85 = *v84 - 1;
      unsigned int v11 = (uint64_t *)v151;
      uint64_t v83 = v127;
    }
    *uint64_t v84 = v85;
    uint64_t v60 = a4;
  }
  else
  {
    uint64_t v91 = llvm::BasicAAResult::aliasCheck(v80);
  }
  BOOL v92 = v128 == 0;
  if (!(_BYTE)v91) {
    BOOL v92 = 1;
  }
  BOOL v93 = v91 == 1 || !v92;
  char v123 = v65;
  if (v93)
  {
    uint64_t v14 = 1;
    goto LABEL_178;
  }
  int v129 = v150;
  if (v150 != 1)
  {
    if (v65) {
      uint64_t v79 = v81;
    }
    uint64_t v102 = 1;
    while (1)
    {
      uint64_t v103 = v149[v102];
      uint64_t v104 = *a1;
      uint64_t v136 = v60;
      uint64_t v137 = a5;
      long long v138 = 0u;
      long long v139 = 0u;
      uint64_t v132 = v103;
      uint64_t v133 = v83;
      long long v134 = 0u;
      long long v135 = 0u;
      if (v104)
      {
        unint64_t v105 = v11;
        int v106 = (*v79)++;
        uint64_t v107 = *(void *)(v104 + 8);
        uint64_t v108 = *(void *)(v104 + 16);
        if (v107 == v108)
        {
          uint64_t v14 = 1;
        }
        else
        {
          uint64_t v109 = v107 + 8;
          do
          {
            uint64_t v110 = (*(uint64_t (**)(void, uint64_t *, uint64_t *, uint64_t *))(**(void **)(v109 - 8) + 24))(*(void *)(v109 - 8), &v136, &v132, v82);
            BOOL v111 = v110 != 1 || v109 == v108;
            v109 += 8;
          }
          while (!v111);
          uint64_t v14 = v110;
          int v106 = *v79 - 1;
          uint64_t v60 = a4;
        }
        *uint64_t v79 = v106;
        unsigned int v11 = v105;
        uint64_t v83 = v127;
      }
      else
      {
        uint64_t v14 = llvm::BasicAAResult::aliasCheck(a1);
      }
      if (v14 == v91) {
        goto LABEL_213;
      }
      if (v91 != 3 || v14 != 2) {
        break;
      }
      uint64_t v14 = 2;
LABEL_214:
      ++v102;
      LOBYTE(v91) = v14;
      if (v129 == v102) {
        goto LABEL_178;
      }
    }
    if (v14 == 3 && v91 == 2) {
      uint64_t v14 = 2;
    }
    else {
      uint64_t v14 = 1;
    }
LABEL_213:
    if (v14 == 1) {
      goto LABEL_178;
    }
    goto LABEL_214;
  }
  uint64_t v14 = v91;
LABEL_178:
  if (v146 != v148) {
    free(v146);
  }
  if ((v140 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v141, 8);
  }
  if ((v123 & 1) == 0)
  {
    uint64_t v94 = *((void *)a2 + 5);
    uint64_t v96 = a1[8];
    uint64_t v95 = a1[9];
    if (v95 == v96)
    {
      uint64_t v97 = *v124;
      int v98 = (void *)(v95 + 8 * v97);
      unint64_t v99 = v122;
      if (v97)
      {
        uint64_t v100 = 0;
        uint64_t v101 = 8 * v97;
        while (*(void *)(v95 + v100) != v94)
        {
          v100 += 8;
          if (v101 == v100) {
            goto LABEL_229;
          }
        }
        int v98 = (void *)(v95 + v100);
      }
LABEL_229:
      uint64_t v96 = a1[9];
    }
    else
    {
      unint64_t v99 = v122;
      uint64_t v113 = *v122;
      int v114 = v113 - 1;
      unsigned int v115 = (v113 - 1) & ((v94 >> 4) ^ (v94 >> 9));
      int v98 = (void *)(v95 + 8 * v115);
      uint64_t v116 = *v98;
      if (*v98 == -1)
      {
        unsigned int v117 = 0;
LABEL_236:
        if (v117) {
          int v98 = v117;
        }
        if (*v98 != v94) {
          int v98 = (void *)(v95 + 8 * v113);
        }
      }
      else
      {
        unsigned int v117 = 0;
        int v118 = 1;
        while (v116 != v94)
        {
          if (v117) {
            BOOL v119 = 0;
          }
          else {
            BOOL v119 = v116 == -2;
          }
          if (v119) {
            unsigned int v117 = v98;
          }
          unsigned int v120 = v115 + v118++;
          unsigned int v115 = v120 & v114;
          int v98 = (void *)(v95 + 8 * (v120 & v114));
          uint64_t v116 = *v98;
          if (*v98 == -1) {
            goto LABEL_236;
          }
        }
      }
    }
    if (v95 == v96) {
      unsigned int v121 = v124;
    }
    else {
      unsigned int v121 = v99;
    }
    if (v98 != (void *)(v95 + 8 * *v121))
    {
      *int v98 = -2;
      ++*((_DWORD *)a1 + 22);
    }
  }
LABEL_68:
  if (v149 != v11) {
    free(v149);
  }
  return v14;
}

uint64_t sub_1CBF73380(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 20);
  uint64_t v3 = v2 & 0x7FFFFFF;
  if ((v2 & 0x7FFFFFF) != 0)
  {
    uint64_t v4 = 0;
    while (1)
    {
      uint64_t v5 = a1 - 32 * v3;
      if ((v2 & 0x40000000) != 0) {
        uint64_t v5 = *(void *)(a1 - 8);
      }
      if (*(void *)(v5 + 32 * *(unsigned int *)(a1 + 60) + 8 * v4) == a2) {
        break;
      }
      if (v3 == ++v4) {
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    LODWORD(v4) = -1;
  }
  if ((v2 & 0x40000000) != 0) {
    uint64_t v6 = *(void *)(a1 - 8);
  }
  else {
    uint64_t v6 = a1 - 32 * v3;
  }
  return *(void *)(v6 + 32 * v4);
}

BOOL llvm::BasicAAResult::isValueEqualInPotentialCycles(llvm::BasicAAResult *this, const llvm::Value *a2, const llvm::Value *a3)
{
  if (a2 != a3) {
    return 0;
  }
  BOOL result = 1;
  if (a2 && *((unsigned __int8 *)a2 + 16) >= 0x1Cu)
  {
    unsigned int v5 = *((_DWORD *)this + 21) - *((_DWORD *)this + 22);
    if (!v5) {
      return 1;
    }
    unsigned __int8 v19 = (uint64_t *)this;
    if (v5 > 0x14) {
      return 0;
    }
    uint64_t v6 = *((void *)this + 9);
    uint64_t v7 = 80;
    if (v6 == v19[8]) {
      uint64_t v7 = 84;
    }
    uint64_t v8 = *(unsigned int *)((char *)v19 + v7);
    if (v8)
    {
      uint64_t v9 = 8 * v8;
      uint64_t v10 = v19[9];
      BOOL result = 1;
      while (*(void *)v10 >= 0xFFFFFFFFFFFFFFFELL)
      {
        v10 += 8;
        v9 -= 8;
        if (!v9) {
          return result;
        }
      }
    }
    else
    {
      uint64_t v10 = v19[9];
    }
    uint64_t v11 = v6 + 8 * v8;
    if (v10 == v11) {
      return 1;
    }
    uint64_t v12 = *(void *)(*(void *)v10 + 48);
    uint64_t v13 = v12 ? v12 - 24 : 0;
    if (llvm::isPotentiallyReachable(v13, (uint64_t)a2, 0, v19[6], 0)) {
      return 0;
    }
    for (uint64_t i = v10 + 8; i != v11; i += 8)
    {
      if (*(void *)i < 0xFFFFFFFFFFFFFFFELL)
      {
        uint64_t v15 = *(void *)(*(void *)i + 48);
        uint64_t v16 = v15 ? v15 - 24 : 0;
        char isPotentiallyReachable = llvm::isPotentiallyReachable(v16, (uint64_t)a2, 0, v19[6], 0);
        BOOL result = i == v11;
        if (isPotentiallyReachable) {
          return result;
        }
      }
    }
    return 1;
  }
  return result;
}

uint64_t sub_1CBF73550(llvm *a1, const llvm::Value *a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t result = llvm::isIdentifiedObject(a1, a2);
  if (result)
  {
    unint64_t v13 = 0;
    if (a5) {
      uint64_t v12 = 65792;
    }
    else {
      uint64_t v12 = 256;
    }
    LODWORD(result) = llvm::getObjectSize(a1, &v13, a3, a4, v12, 0, v11);
    if (v13 < (unint64_t)a2) {
      return result;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t llvm::BasicAAResult::aliasCheckRecursive(uint64_t *a1, llvm::BasicAAResult *this, unint64_t a3, llvm::BasicAAResult *a4, unint64_t a5, uint64_t a6, unsigned __int8 *a7, unsigned __int8 *a8)
{
  int v16 = *((unsigned __int8 *)this + 16);
  if (v16 == 62 || v16 == 5 && *((_WORD *)this + 9) == 34)
  {
    uint64_t result = llvm::BasicAAResult::aliasGEP((uint64_t)a1, this, a3, (uint64_t)a4, a5, a7, a8, a6);
  }
  else
  {
    int v18 = *((unsigned __int8 *)a4 + 16);
    if (v18 != 62 && (v18 != 5 || *((_WORD *)a4 + 9) != 34)) {
      goto LABEL_8;
    }
    LODWORD(result) = llvm::BasicAAResult::aliasGEP((uint64_t)a1, a4, a5, (uint64_t)this, a3, a8, a7, a6);
    if ((((int)result >> 9) + 0x3FFFFF) >> 23) {
      unsigned int v33 = result;
    }
    else {
      unsigned int v33 = (result - (result & 0xFFFFFE00)) | 0x100;
    }
    if ((result & 0x100) != 0) {
      uint64_t result = v33;
    }
    else {
      uint64_t result = result;
    }
  }
  if (result != 1) {
    return result;
  }
LABEL_8:
  if (*((unsigned char *)this + 16) == 83)
  {
    uint64_t result = llvm::BasicAAResult::aliasPHI(a1, this, (char *)a3, (uint64_t)a4, a5, a6);
  }
  else
  {
    if (!a4 || *((unsigned char *)a4 + 16) != 83) {
      goto LABEL_11;
    }
    LODWORD(result) = llvm::BasicAAResult::aliasPHI(a1, a4, (char *)a5, (uint64_t)this, a3, a6);
    if ((((int)result >> 9) + 0x3FFFFF) >> 23) {
      unsigned int v32 = result;
    }
    else {
      unsigned int v32 = (result - (result & 0xFFFFFE00)) | 0x100;
    }
    if ((result & 0x100) != 0) {
      uint64_t result = v32;
    }
    else {
      uint64_t result = result;
    }
  }
  if (result != 1) {
    return result;
  }
LABEL_11:
  if (*((unsigned char *)this + 16) == 85)
  {
    uint64_t result = llvm::BasicAAResult::aliasSelect(a1, (uint64_t)this, a3, (uint64_t)a4, a5, a6);
    goto LABEL_23;
  }
  if (a4 && *((unsigned char *)a4 + 16) == 85)
  {
    LODWORD(result) = llvm::BasicAAResult::aliasSelect(a1, (uint64_t)a4, a5, (uint64_t)this, a3, a6);
    if ((((int)result >> 9) + 0x3FFFFF) >> 23) {
      unsigned int v19 = result;
    }
    else {
      unsigned int v19 = (result - (result & 0xFFFFFE00)) | 0x100;
    }
    if ((result & 0x100) != 0) {
      uint64_t result = v19;
    }
    else {
      uint64_t result = result;
    }
LABEL_23:
    if (result != 1) {
      return result;
    }
  }
  if (a7 != a8) {
    return 1;
  }
  uint64_t v20 = a1[2];
  if (v20 && (uint64_t v21 = *(void *)(v20 + 112)) != 0 && (*(unsigned char *)(v21 + 17) & 1) != 0) {
    uint64_t v22 = 0x10000;
  }
  else {
    uint64_t v22 = 0;
  }
  if ((a3 & 0x8000000000000000) != 0 || (a5 & 0x8000000000000000) != 0) {
    return 1;
  }
  uint64_t v23 = a1[1];
  uint64_t v24 = a1[3];
  uint64_t v34 = 0;
  BOOL ObjectSize = llvm::getObjectSize((llvm::Value *)a7, &v34, v23, v24, v22, 0, (uint64_t)a7);
  uint64_t v27 = v34;
  if (!ObjectSize) {
    uint64_t v27 = -1;
  }
  if (v27 != -1 && v27 == a3) {
    return 2;
  }
  uint64_t v28 = a1[1];
  uint64_t v29 = a1[3];
  uint64_t v34 = 0;
  BOOL v30 = llvm::getObjectSize((llvm::Value *)a7, &v34, v28, v29, v22, 0, v26);
  uint64_t v31 = v34;
  if (!v30) {
    uint64_t v31 = -1;
  }
  if (v31 == -1 || v31 != a5) {
    return 1;
  }
  else {
    return 2;
  }
}

void llvm::BasicAA::run()
{
}

void sub_1CBF739F0(llvm *a1)
{
  llvm::initializeAssumptionCacheTrackerPass((uint64_t)a1);
  llvm::initializeDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializeTargetLibraryInfoWrapperPassPass((uint64_t)a1);
  llvm::initializePhiValuesWrapperPassPass(a1, v2);
  llvm::initializeTargetTransformInfoWrapperPassPass((uint64_t)a1);
  operator new();
}

void llvm::BasicAAWrapperPass::runOnFunction(llvm::BasicAAWrapperPass *this, llvm::Function *a2)
{
  uint64_t v3 = (uint64_t *)*((void *)this + 1);
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 == v5)
  {
LABEL_23:
    uint64_t v6 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v4 != &llvm::AssumptionCacheTracker::ID)
    {
      v4 += 16;
      if (v4 == v5) {
        goto LABEL_23;
      }
    }
    uint64_t v6 = *(void *)(v4 + 8);
  }
  (*(void (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, &llvm::AssumptionCacheTracker::ID);
  uint64_t v7 = (uint64_t *)*((void *)this + 1);
  uint64_t v8 = *v7;
  uint64_t v9 = v7[1];
  if (v8 == v9)
  {
LABEL_7:
    uint64_t v10 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v8 != &llvm::TargetLibraryInfoWrapperPass::ID)
    {
      v8 += 16;
      if (v8 == v9) {
        goto LABEL_7;
      }
    }
    uint64_t v10 = *(void *)(v8 + 8);
  }
  (*(void (**)(uint64_t, void *))(*(void *)v10 + 96))(v10, &llvm::TargetLibraryInfoWrapperPass::ID);
  uint64_t v11 = (uint64_t *)*((void *)this + 1);
  uint64_t v12 = *v11;
  uint64_t v13 = v11[1];
  if (v12 == v13)
  {
LABEL_12:
    uint64_t v14 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v12 != &llvm::TargetTransformInfoWrapperPass::ID)
    {
      v12 += 16;
      if (v12 == v13) {
        goto LABEL_12;
      }
    }
    uint64_t v14 = *(void *)(v12 + 8);
  }
  (*(void (**)(uint64_t, void *))(*(void *)v14 + 96))(v14, &llvm::TargetTransformInfoWrapperPass::ID);
  uint64_t v15 = (uint64_t *)*((void *)this + 1);
  uint64_t v16 = *v15;
  uint64_t v17 = v15[1];
  if (v16 == v17)
  {
LABEL_17:
    uint64_t v18 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v16 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v16 += 16;
      if (v16 == v17) {
        goto LABEL_17;
      }
    }
    uint64_t v18 = *(void *)(v16 + 8);
  }
  (*(void (**)(uint64_t, void *))(*(void *)v18 + 96))(v18, &llvm::DominatorTreeWrapperPass::ID);
  uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*((void *)this + 1) + 24), &llvm::PhiValuesWrapperPass::ID, 1);
  if (AnalysisPass) {
    (*(void (**)(uint64_t, void *))(*(void *)AnalysisPass + 96))(AnalysisPass, &llvm::PhiValuesWrapperPass::ID);
  }
  operator new();
}

void llvm::createLegacyPMBasicAAResult(llvm *this, llvm::Pass *a2, llvm::Function *a3)
{
  uint64_t v4 = (uint64_t *)*((void *)this + 1);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_4:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(char **)v5 != llvm::TargetLibraryInfoWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_4;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, char *, llvm::Function *))(*(void *)v7 + 96))(v7, llvm::TargetLibraryInfoWrapperPass::ID, a3);
  sub_1CBF5AC74(v8, (uint64_t)a2);
}

uint64_t sub_1CBF73FC8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 32) = 1;
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + ++*(_DWORD *)(result + 48) = 1;
  *(void *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 56) = 1;
  int PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits(**(llvm::Type ***)a2);
  if (v6 == 1)
  {
    int v13 = PrimitiveSizeInBits;
    int PrimitiveSizeInBits = v13;
  }
  unsigned int v7 = PrimitiveSizeInBits - *(_DWORD *)(a2 + 16) + *(_DWORD *)(a2 + 8) + *(_DWORD *)(a2 + 12);
  if (v7 > 0x40) {
    operator new[]();
  }
  unint64_t v8 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
  if (!v7) {
    LOBYTE(v8) = 0;
  }
  unint64_t v9 = v8 & 1;
  if (*(_DWORD *)(a1 + 32) >= 0x41u)
  {
    uint64_t v10 = *(void *)(a1 + 24);
    if (v10) {
      MEMORY[0x1D25D9CB0](v10, 0x1000C8000313F17);
    }
  }
  *(void *)(a1 + 24) = v9;
  *(_DWORD *)(a1 + 32) = v7;
  if (*(_DWORD *)(a1 + 48) >= 0x41u)
  {
    uint64_t v11 = *(void *)(a1 + 40);
    if (v11) {
      MEMORY[0x1D25D9CB0](v11, 0x1000C8000313F17);
    }
  }
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + ++*(_DWORD *)(result + 48) = v7;
  return a1;
}

uint64_t sub_1CBF741A8(uint64_t result, _DWORD *a2, llvm::APInt *this)
{
  uint64_t v5 = result;
  int v6 = a2[4];
  if (v6)
  {
    unsigned int v7 = *((_DWORD *)this + 2);
    int v8 = v7 - v6;
    if (v7 - v6 > 0x40) {
      operator new[]();
    }
    unint64_t v9 = this;
    if (v7 >= 0x41) {
      unint64_t v9 = *(llvm::APInt **)this;
    }
    uint64_t v10 = *(void *)v9;
    if (v7 == v6) {
      unint64_t v11 = 0;
    }
    else {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFFLL >> (v6 - v7);
    }
    unint64_t v12 = v11 & v10;
    if (*((_DWORD *)this + 2) >= 0x41u)
    {
      uint64_t result = *(void *)this;
      if (*(void *)this) {
        uint64_t result = MEMORY[0x1D25D9CB0](result, 0x1000C8000313F17);
      }
    }
    *(void *)this = v12;
    *((_DWORD *)this + 2) = v8;
  }
  int v13 = a2[3];
  if (v13)
  {
    uint64_t result = llvm::APInt::sext((uint64_t)this, *((_DWORD *)this + 2) + v13, (uint64_t)&v19);
    if (*((_DWORD *)this + 2) >= 0x41u)
    {
      uint64_t result = *(void *)this;
      if (*(void *)this) {
        uint64_t result = MEMORY[0x1D25D9CB0](result, 0x1000C8000313F17);
      }
    }
    *(void *)this = v19;
    *((_DWORD *)this + 2) = v20;
  }
  int v14 = a2[2];
  unsigned int v15 = *((_DWORD *)this + 2);
  if (v14)
  {
    unsigned int v16 = v15 + v14;
    if (v15 + v14 > 0x40) {
      operator new[]();
    }
    unint64_t v17 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v16;
    if (!v16) {
      unint64_t v17 = 0;
    }
    unint64_t v18 = v17 & *(void *)this;
    if (v15 >= 0x41)
    {
      uint64_t result = *(void *)this;
      if (*(void *)this) {
        uint64_t result = MEMORY[0x1D25D9CB0](result, 0x1000C8000313F17);
      }
    }
    *(void *)this = v18;
    unsigned int v15 = v16;
  }
  else
  {
    unint64_t v18 = *(void *)this;
  }
  *(_DWORD *)(v5 + 8) = v15;
  *(void *)uint64_t v5 = v18;
  *((_DWORD *)this + 2) = 0;
  return result;
}

uint64_t sub_1CBF74408(uint64_t result, long long *a2, uint64_t a3, uint64_t a4, char a5)
{
  long long v5 = *a2;
  *(void *)(result + 16) = *((void *)a2 + 2);
  *(_OWORD *)uint64_t result = v5;
  unsigned int v6 = *(_DWORD *)(a3 + 8);
  *(_DWORD *)(result + 32) = v6;
  if (v6 > 0x40) {
    operator new[]();
  }
  *(void *)(result + 24) = *(void *)a3;
  unsigned int v7 = *(_DWORD *)(a4 + 8);
  *(_DWORD *)(result + ++*(_DWORD *)(result + 48) = v7;
  if (v7 > 0x40) {
    operator new[]();
  }
  *(void *)(result + 40) = *(void *)a4;
  *(unsigned char *)(result + 56) = a5;
  return result;
}

int *sub_1CBF74504(int *result)
{
  int v1 = *result;
  *(void *)uint64_t result = *result & 1;
  if (v1)
  {
    uint64_t v3 = result + 2;
    uint64_t v4 = result + 82;
  }
  else
  {
    unsigned int v2 = result[4];
    if (!v2) {
      return result;
    }
    uint64_t v3 = (_OWORD *)*((void *)result + 1);
    uint64_t v4 = (_OWORD *)((char *)v3 + 40 * v2);
  }
  do
  {
    *uint64_t v3 = xmmword_1CFAC3060;
    v3[1] = xmmword_1CFAC3060;
    uint64_t v3 = (_OWORD *)((char *)v3 + 40);
  }
  while (v3 != v4);
  return result;
}

uint64_t sub_1CBF74550(uint64_t a1)
{
  return a1;
}

uint64_t *sub_1CBF74588(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v5 = 16 * v2;
    unsigned int v6 = (uint64_t *)(v3 + 8);
    do
    {
      uint64_t v7 = *(v6 - 1);
      if (v7 != -4096 && v7 != -8192) {
        unsigned int v6 = sub_1CBF749F4(v6);
      }
      v6 += 2;
      v5 -= 16;
    }
    while (v5);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

uint64_t sub_1CBF745FC(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = sub_1CBF5BF34(*a1, a2);
  uint64_t v9 = *a1;
  uint64_t v10 = *a1 + 8;
  if (*(unsigned char *)*a1)
  {
    uint64_t v11 = 8;
  }
  else
  {
    uint64_t v10 = *(void *)(v9 + 8);
    uint64_t v11 = *(unsigned int *)(v9 + 16);
  }
  if (v10 + 16 * v11 == v8)
  {
    uint64_t v13 = a1[1];
    v19[0] = a2;
    v19[1] = a3;
    uint64_t v17 = 0;
    if (sub_1CBF5C064((uint64_t *)v13, v19, &v17)) {
      uint64_t v14 = v17;
    }
    else {
      uint64_t v14 = *(void *)v13 + 24 * *(unsigned int *)(v13 + 16);
    }
    uint64_t v15 = *a1;
    char v16 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(*(void *)(v14 + 16) + 24)
                                                                         + 16))(*(void *)(*(void *)(v14 + 16) + 24), a3, a4, a1);
    uint64_t v17 = a2;
    v18[0] = v16;
    sub_1CBF5C150(v15, &v17, v18, (uint64_t)v19);
    uint64_t v8 = v19[0];
  }
  return *(unsigned __int8 *)(v8 + 8);
}

void *sub_1CBF74714(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CBF747C8(a1, v7);
  uint64_t v9 = 0;
  sub_1CB915048((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CBF747C8(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD45C668(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *uint64_t result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CBF74894(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    unint64_t v6 = (void *)(a1 + 16 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v12 = 1;
    }
    else
    {
      unsigned int v8 = 0;
      int v9 = 1;
      while (v7 != -4096)
      {
        if (v8) {
          BOOL v10 = 0;
        }
        else {
          BOOL v10 = v7 == -8192;
        }
        if (v10) {
          unsigned int v8 = v6;
        }
        unsigned int v11 = v5 + v9++;
        unsigned int v5 = v11 & v4;
        unint64_t v6 = (void *)(a1 + 16 * (v11 & v4));
        uint64_t v7 = *v6;
        uint64_t v12 = 1;
        if (*v6 == a3) {
          goto LABEL_14;
        }
      }
      uint64_t v12 = 0;
      if (v8) {
        unint64_t v6 = v8;
      }
    }
  }
  else
  {
    unint64_t v6 = 0;
    uint64_t v12 = 0;
  }
LABEL_14:
  *a4 = v6;
  return v12;
}

void *sub_1CBF74928(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD45C718((uint64_t *)a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *uint64_t result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t *sub_1CBF749F4(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if ((*a1 & 4) != 0)
  {
    uint64_t v3 = (void **)(v2 & 0xFFFFFFFFFFFFFFF8);
    if ((v2 & 0xFFFFFFFFFFFFFFF8) != 0)
    {
      if (*v3 != v3 + 2) {
        free(*v3);
      }
      MEMORY[0x1D25D9CE0]();
    }
  }
  return a1;
}

unsigned char *sub_1CBF74A6C(uint64_t a1, uint64_t a2, char *a3, char *a4)
{
  unint64_t v5 = a3;
  uint64_t v6 = *(void *)a1;
  uint64_t v7 = (a2 - *(void *)a1) >> 3;
  uint64_t v8 = *(unsigned int *)(a1 + 8);
  unint64_t v9 = *(unsigned int *)(a1 + 12);
  uint64_t v10 = a4 - a3;
  unint64_t v11 = v8 + ((a4 - a3) >> 5);
  if (*(void *)a1 + 8 * v8 == a2)
  {
    if (v11 > v9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    if (v5 != a4)
    {
      uint64_t v12 = (void *)(v6 + 8 * v8);
      do
      {
        uint64_t v13 = *(void *)v5;
        v5 += 32;
        *v12++ = v13;
      }
      while (v5 != a4);
      uint64_t v6 = *(void *)a1;
    }
    *(_DWORD *)(a1 + 8) = v8 + ((unint64_t)v10 >> 5);
    return (unsigned char *)(v6 + 8 * v7);
  }
  else
  {
    unint64_t v24 = v10;
    unint64_t v15 = v10 >> 5;
    if (v11 > v9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    char v16 = (char *)(v6 + 8 * v8);
    __src = (unsigned char *)(v6 + 8 * v7);
    unint64_t v17 = (v16 - __src) >> 3;
    if (v17 >= v15)
    {
      sub_1CD4570C8(a1, &v16[-8 * v15], (char *)(v6 + 8 * v8));
      if (&v16[-8 * v15] != __src) {
        memmove(&__src[8 * v15], __src, &v16[-8 * v15] - __src);
      }
      if (v5 != a4)
      {
        uint64_t v22 = __src;
        do
        {
          uint64_t v23 = *(void *)v5;
          v5 += 32;
          *v22++ = v23;
        }
        while (v5 != a4);
      }
    }
    else
    {
      unsigned int v18 = v8 + (v24 >> 5);
      *(_DWORD *)(a1 + 8) = v18;
      if (v7 != v8)
      {
        uint64_t v19 = (void *)(v6 + 8 * v7);
        memcpy((void *)(v6 + 8 * v18 - 8 * v17), __src, v16 - __src);
        do
        {
          uint64_t v20 = *(void *)v5;
          v5 += 32;
          *v19++ = v20;
          --v17;
        }
        while (v17);
      }
      while (v5 != a4)
      {
        uint64_t v21 = *(void *)v5;
        v5 += 32;
        *(void *)char v16 = v21;
        v16 += 8;
      }
    }
    return __src;
  }
}

uint64_t sub_1CBF74C14(uint64_t a1, uint64_t *a2, uint64_t **a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 8;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      unint64_t v17 = 0;
      uint64_t result = 0;
      goto LABEL_26;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  unint64_t v5 = 0;
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  uint64_t v8 = a2[2];
  uint64_t v9 = a2[3];
  uint64_t v10 = (v8 >> 4) ^ (v8 >> 9) ^ (37 * v9);
  unint64_t v11 = (v10 | ((unint64_t)((*a2 >> 4) ^ (*a2 >> 9) ^ (37 * v7)) << 32))
      + ~(v10 << 32);
  unint64_t v12 = (v11 ^ (v11 >> 22)) + ~((v11 ^ (v11 >> 22)) << 13);
  unint64_t v13 = (9 * (v12 ^ (v12 >> 8))) ^ ((9 * (v12 ^ (v12 >> 8))) >> 15);
  int v14 = v4 - 1;
  unsigned int v15 = v14 & (((v13 + ~(v13 << 27)) >> 31) ^ (v13 + ~(v13 << 27)));
  for (int i = 1; ; ++i)
  {
    unint64_t v17 = (uint64_t *)(v3 + 40 * v15);
    uint64_t v18 = *v17;
    uint64_t v19 = v17[1];
    if (v6 == *v17 && v7 == v19 && v8 == v17[2] && v9 == v17[3])
    {
      uint64_t result = 1;
      goto LABEL_26;
    }
    if (v18 == -4096 && v19 == -3) {
      break;
    }
    if (v18 != -8192 || v19 != -4) {
      goto LABEL_31;
    }
    BOOL v26 = v17[2] == -8192 && v17[3] == -4;
LABEL_32:
    if (v26 && v5 == 0) {
      unint64_t v5 = (uint64_t *)(v3 + 40 * v15);
    }
    unsigned int v27 = v15 + i;
    unsigned int v15 = v27 & v14;
  }
  if (v17[2] != -4096 || v17[3] != -3)
  {
LABEL_31:
    BOOL v26 = 0;
    goto LABEL_32;
  }
  uint64_t result = 0;
  if (v5) {
    unint64_t v17 = v5;
  }
LABEL_26:
  *a3 = v17;
  return result;
}

uint64_t *sub_1CBF74D5C(_DWORD *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  int v6 = *a1 >> 1;
  if (*a1) {
    unsigned int v7 = 8;
  }
  else {
    unsigned int v7 = a1[4];
  }
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - a1[1] > v7 >> 3)
  {
    goto LABEL_5;
  }
  sub_1CBF74E34((uint64_t)a1, v7);
  unint64_t v11 = 0;
  sub_1CBF74C14((uint64_t)a1, a3, &v11);
  a4 = v11;
LABEL_5:
  *a1 += 2;
  BOOL v8 = *a4 == -4096 && a4[1] == -3;
  if (!v8 || (a4[2] == -4096 ? (BOOL v9 = a4[3] == -3) : (BOOL v9 = 0), !v9)) {
    --a1[1];
  }
  return a4;
}

uint64_t sub_1CBF74E34(uint64_t a1, unsigned int a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
  int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
  if ((v5 + 1) > 0x40) {
    unsigned int v6 = v5 + 1;
  }
  else {
    unsigned int v6 = 64;
  }
  if (a2 >= 9) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = a2;
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v20 = *(void *)(a1 + 8);
    unsigned int v21 = *(_DWORD *)(a1 + 16);
    if (v7 <= 8)
    {
      *(_DWORD *)a1 |= 1u;
    }
    else
    {
      *(void *)(a1 + 8) = operator new(40 * v7, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v7;
    }
    sub_1CBF75020((int *)a1, v20, v20 + 40 * v21);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = 0;
  BOOL v9 = v23;
  do
  {
    uint64_t v10 = a1 + v8;
    uint64_t v11 = *(void *)(a1 + v8 + 8);
    uint64_t v12 = *(void *)(a1 + v8 + 16);
    if (v11 == -4096 && v12 == -3)
    {
      uint64_t v17 = *(void *)(v10 + 24);
      uint64_t v16 = *(void *)(v10 + 32);
      if (v17 != -4096 || v16 != -3)
      {
LABEL_17:
        long long v15 = *(_OWORD *)(a1 + v8 + 24);
        *(_OWORD *)BOOL v9 = *(_OWORD *)(a1 + v8 + 8);
        *((_OWORD *)v9 + 1) = v15;
        *((void *)v9 + 4) = *(void *)(a1 + v8 + 40);
        v9 += 40;
      }
    }
    else
    {
      if (v11 != -8192 || v12 != -4) {
        goto LABEL_17;
      }
      if (*(void *)(a1 + v8 + 24) != -8192 || *(void *)(a1 + v8 + 32) != -4) {
        goto LABEL_17;
      }
    }
    v8 += 40;
  }
  while (v8 != 320);
  if (v7 > 8)
  {
    *(_DWORD *)a1 &= ~1u;
    *(void *)(a1 + 8) = operator new(40 * v7, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v7;
  }
  return sub_1CBF75020((int *)a1, (uint64_t)v23, (uint64_t)v9);
}

uint64_t sub_1CBF75020(int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (uint64_t)sub_1CBF74504(a1);
  while (a2 != a3)
  {
    uint64_t v7 = *(void *)(a2 + 8);
    if (*(void *)a2 == -4096 && v7 == -3)
    {
      if (*(void *)(a2 + 16) != -4096 || *(void *)(a2 + 24) != -3)
      {
LABEL_11:
        unint64_t v13 = 0;
        uint64_t result = sub_1CBF74C14((uint64_t)a1, (uint64_t *)a2, &v13);
        uint64_t v10 = v13;
        *(_OWORD *)unint64_t v13 = *(_OWORD *)a2;
        *((_OWORD *)v10 + 1) = *(_OWORD *)(a2 + 16);
        void v10[4] = *(void *)(a2 + 32);
        *a1 += 2;
      }
    }
    else
    {
      if (*(void *)a2 != -8192 || v7 != -4) {
        goto LABEL_11;
      }
      if (*(void *)(a2 + 16) != -8192 || *(void *)(a2 + 24) != -4) {
        goto LABEL_11;
      }
    }
    a2 += 40;
  }
  return result;
}

void *sub_1CBF750EC(void *result)
{
  int v1 = (void *)result[21];
  if (v1 != (void *)result[20])
  {
    unint64_t v3 = result;
    free(v1);
    uint64_t result = v3;
  }
  uint64_t v2 = (void *)result[9];
  if (v2 != (void *)result[8])
  {
    unint64_t v4 = result;
    free(v2);
    return v4;
  }
  return result;
}

uint64_t sub_1CBF75148()
{
  int v3 = 1;
  char v1 = 1;
  uint64_t v2 = &v1;
  sub_1CD45C54C((uint64_t)&unk_1EBCC3BA8, "basic-aa-recphi", &v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC3BA8, &dword_1CB82C000);
}

void *llvm::BlockFrequencyInfo::BlockFrequencyInfo(void *this)
{
  *this = 0;
  return this;
}

{
  *this = 0;
  return this;
}

llvm::BlockFrequencyInfo *llvm::BlockFrequencyInfo::BlockFrequencyInfo(llvm::BlockFrequencyInfo *this, const llvm::Function *a2, const llvm::BranchProbabilityInfo *a3, const llvm::LoopInfo *a4)
{
  *(void *)this = 0;
  llvm::BlockFrequencyInfo::calculate(this, a2, a3, a4);
  return this;
}

{
  *(void *)this = 0;
  llvm::BlockFrequencyInfo::calculate(this, a2, a3, a4);
  return this;
}

void llvm::BlockFrequencyInfo::calculate(llvm::BlockFrequencyInfo *this, const llvm::Function *a2, const llvm::BranchProbabilityInfo *a3, const llvm::LoopInfo *a4)
{
  if (!*(void *)this) {
    operator new();
  }
  sub_1CBF75D84();
  if (dword_1EBCC3DB8)
  {
    int v7 = byte_1EBD02887;
    size_t v8 = byte_1EBD02887 >= 0 ? byte_1EBD02887 & 0x7F : qword_1EBD02878;
    if (!v8
      || (Name = llvm::Value::getName(a2), v9 == v8)
      && (v7 >= 0 ? (uint64_t v10 = &qword_1EBD02870) : (uint64_t v10 = (uint64_t *)qword_1EBD02870),
          Name = (char *)memcmp(Name, v10, v8),
          !Name))
    {
      unsigned int v21 = (uint64_t *)this;
      __int16 v20 = 261;
      v19[0] = "BlockFrequencyDAGs";
      v19[1] = 18;
      __int16 v18 = 257;
      sub_1CD45C944(&v21, (llvm::Twine *)v19, 0, (llvm::Twine *)v17, 0);
    }
  }
  if (byte_1EBCC3CF8)
  {
    int v11 = byte_1EBD02C87;
    size_t v12 = byte_1EBD02C87 >= 0 ? byte_1EBD02C87 & 0x7F : qword_1EBD02C78;
    if (!v12
      || (unint64_t v13 = llvm::Value::getName(a2), v14 == v12)
      && (v11 >= 0 ? (long long v15 = &qword_1EBD02C70) : (long long v15 = (uint64_t *)qword_1EBD02C70),
          Name = (char *)memcmp(v13, v15, v12),
          !Name))
    {
      uint64_t v16 = llvm::dbgs((llvm *)Name);
      if (*(void *)this) {
        (*(void (**)(void, llvm *))(**(void **)this + 24))(*(void *)this, v16);
      }
    }
  }
}

void *llvm::BlockFrequencyInfo::BlockFrequencyInfo(void *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  *uint64_t result = v2;
  return result;
}

{
  uint64_t v2;

  uint64_t v2 = *a2;
  *a2 = 0;
  *uint64_t result = v2;
  return result;
}

uint64_t *llvm::BlockFrequencyInfo::operator=(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a1;
  *a1 = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *a2;
  *a2 = 0;
  uint64_t v6 = *a1;
  *a1 = v5;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  return a1;
}

uint64_t llvm::BlockFrequencyInfo::releaseMemory(llvm::BlockFrequencyInfo *this)
{
  uint64_t result = *(void *)this;
  *(void *)this = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void llvm::BlockFrequencyInfo::~BlockFrequencyInfo(llvm::BlockFrequencyInfo *this)
{
  uint64_t v2 = *(void *)this;
  *(void *)this = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

{
  uint64_t v2;

  uint64_t v2 = *(void *)this;
  *(void *)this = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

BOOL llvm::BlockFrequencyInfo::invalidate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v18[0] = (void **)a3;
  v18[1] = (void **)&llvm::BlockFrequencyAnalysis::Key;
  uint64_t v4 = *(void *)(a3 + 48);
  uint64_t v3 = *(void *)(a3 + 56);
  if (v3 == v4)
  {
    uint64_t v5 = *(unsigned int *)(a3 + 68);
    uint64_t v6 = (void **)(v3 + 8 * v5);
    if (v5)
    {
      uint64_t v7 = 0;
      while (*(_UNKNOWN **)(v3 + v7) != &llvm::BlockFrequencyAnalysis::Key)
      {
        v7 += 8;
        if (8 * v5 == v7) {
          goto LABEL_6;
        }
      }
      uint64_t v6 = (void **)(v3 + v7);
    }
LABEL_6:
    uint64_t v4 = *(void *)(a3 + 56);
  }
  else
  {
    uint64_t v10 = *(unsigned int *)(a3 + 64);
    int v11 = v10 - 1;
    unsigned int v12 = (v10 - 1) & ((&llvm::BlockFrequencyAnalysis::Key >> 4) ^ (&llvm::BlockFrequencyAnalysis::Key >> 9));
    uint64_t v6 = (void **)(v3 + 8 * v12);
    unint64_t v13 = *v6;
    if (*v6 == (void *)-1)
    {
      uint64_t v14 = 0;
LABEL_27:
      if (v14) {
        uint64_t v6 = v14;
      }
      if (*v6 != &llvm::BlockFrequencyAnalysis::Key)
      {
        LODWORD(v5) = *(_DWORD *)(a3 + 68);
        uint64_t v6 = (void **)(v3 + 8 * v10);
        goto LABEL_7;
      }
    }
    else
    {
      uint64_t v14 = 0;
      int v15 = 1;
      while (v13 != &llvm::BlockFrequencyAnalysis::Key)
      {
        if (v14) {
          BOOL v16 = 0;
        }
        else {
          BOOL v16 = v13 == (void *)-2;
        }
        if (v16) {
          uint64_t v14 = v6;
        }
        unsigned int v17 = v12 + v15++;
        unsigned int v12 = v17 & v11;
        uint64_t v6 = (void **)(v3 + 8 * (v17 & v11));
        unint64_t v13 = *v6;
        if (*v6 == (void *)-1) {
          goto LABEL_27;
        }
      }
    }
    LODWORD(v5) = *(_DWORD *)(a3 + 68);
  }
LABEL_7:
  if (v3 == v4) {
    unsigned int v8 = v5;
  }
  else {
    unsigned int v8 = *(_DWORD *)(a3 + 64);
  }
  BOOL v19 = v6 != (void **)(v3 + 8 * v8);
  return !sub_1CBF75724(v18) && !sub_1CBF7593C((uint64_t)v18) && !sub_1CBF75B60((uint64_t)v18);
}

BOOL sub_1CBF75724(void ***a1)
{
  if (*((unsigned char *)a1 + 16)) {
    return 0;
  }
  char v1 = *a1;
  uint64_t v3 = **a1;
  uint64_t v2 = (*a1)[1];
  if (v2 != v3)
  {
    uint64_t v18 = *((unsigned int *)v1 + 4);
    int v19 = v18 - 1;
    unsigned int v20 = (v18 - 1) & ((&llvm::PreservedAnalyses::AllAnalysesKey >> 4) ^ (&llvm::PreservedAnalyses::AllAnalysesKey >> 9));
    uint64_t v7 = (void **)&v2[v20];
    unsigned int v21 = *v7;
    if (*v7 == (void *)-1)
    {
      uint64_t v22 = 0;
LABEL_48:
      if (v22) {
        uint64_t v7 = v22;
      }
      if (*v7 != &llvm::PreservedAnalyses::AllAnalysesKey) {
        uint64_t v7 = (void **)&v2[v18];
      }
    }
    else
    {
      uint64_t v22 = 0;
      int v23 = 1;
      while (v21 != &llvm::PreservedAnalyses::AllAnalysesKey)
      {
        if (v22) {
          BOOL v24 = 0;
        }
        else {
          BOOL v24 = v21 == (void *)-2;
        }
        if (v24) {
          uint64_t v22 = v7;
        }
        unsigned int v25 = v20 + v23++;
        unsigned int v20 = v25 & v19;
        uint64_t v7 = (void **)&v2[v25 & v19];
        unsigned int v21 = *v7;
        if (*v7 == (void *)-1) {
          goto LABEL_48;
        }
      }
    }
    unsigned int v8 = **a1;
    goto LABEL_8;
  }
  uint64_t v4 = (unsigned int *)v1 + 5;
  uint64_t v5 = *((unsigned int *)v1 + 5);
  if (v5)
  {
    uint64_t v6 = 0;
    uint64_t v7 = (void **)&v2[v5];
    while ((_UNKNOWN *)v2[v6] != &llvm::PreservedAnalyses::AllAnalysesKey)
    {
      if (v5 == ++v6) {
        goto LABEL_7;
      }
    }
    uint64_t v7 = (void **)&v2[v6];
LABEL_7:
    unsigned int v8 = (*a1)[1];
LABEL_8:
    BOOL v24 = v2 == v8;
    uint64_t v9 = 16;
    if (v24) {
      uint64_t v9 = 20;
    }
    if (v7 != &v2[*(unsigned int *)((char *)v1 + v9)]) {
      return 1;
    }
    uint64_t v4 = (unsigned int *)v1 + 5;
    uint64_t v10 = (unsigned int *)(v1 + 2);
    int v11 = a1[1];
    if (v2 == v3)
    {
      uint64_t v12 = *v4;
      unint64_t v13 = &v2[v12];
      if (v12)
      {
        unint64_t v14 = 0;
        uint64_t v15 = 8 * v12;
        while ((void **)v2[v14 / 8] != v11)
        {
          v14 += 8;
          if (v15 == v14) {
            goto LABEL_16;
          }
        }
        unint64_t v13 = &v2[v14 / 8];
      }
LABEL_16:
      uint64_t v3 = (*a1)[1];
    }
    else
    {
      uint64_t v26 = *v10;
      int v27 = v26 - 1;
      unsigned int v28 = (v26 - 1) & ((v11 >> 4) ^ (v11 >> 9));
      unint64_t v13 = &v2[v28];
      uint64_t v29 = (void **)*v13;
      if (*v13 == -1)
      {
        BOOL v30 = 0;
LABEL_54:
        if (v30) {
          unint64_t v13 = v30;
        }
        if ((void **)*v13 != v11) {
          unint64_t v13 = &v2[v26];
        }
      }
      else
      {
        BOOL v30 = 0;
        int v31 = 1;
        while (v29 != v11)
        {
          if (v30) {
            BOOL v32 = 0;
          }
          else {
            BOOL v32 = v29 == (void **)-2;
          }
          if (v32) {
            BOOL v30 = v13;
          }
          unsigned int v33 = v28 + v31++;
          unsigned int v28 = v33 & v27;
          unint64_t v13 = &v2[v33 & v27];
          uint64_t v29 = (void **)*v13;
          if (*v13 == -1) {
            goto LABEL_54;
          }
        }
      }
    }
    goto LABEL_17;
  }
  uint64_t v10 = (unsigned int *)(v1 + 2);
  uint64_t v3 = (*a1)[1];
  unint64_t v13 = v3;
LABEL_17:
  if (v2 == v3) {
    BOOL v16 = v4;
  }
  else {
    BOOL v16 = v10;
  }
  return v13 != &v2[*v16];
}

BOOL sub_1CBF7593C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16)) {
    return 0;
  }
  char v1 = *(void ****)a1;
  uint64_t v3 = **(void ****)a1;
  uint64_t v2 = *(void ***)(*(void *)a1 + 8);
  if (v2 == v3)
  {
    uint64_t v4 = (unsigned int *)v1 + 5;
    uint64_t v5 = *((unsigned int *)v1 + 5);
    if (!v5)
    {
      uint64_t v10 = (unsigned int *)(v1 + 2);
      uint64_t v3 = *(void ***)(*(void *)a1 + 8);
      uint64_t v12 = v3;
      goto LABEL_17;
    }
    uint64_t v6 = 0;
    uint64_t v7 = &v2[v5];
    while (v2[v6] != &llvm::PreservedAnalyses::AllAnalysesKey)
    {
      if (v5 == ++v6) {
        goto LABEL_7;
      }
    }
    uint64_t v7 = &v2[v6];
LABEL_7:
    unsigned int v8 = *(void ***)(*(void *)a1 + 8);
  }
  else
  {
    uint64_t v17 = *((unsigned int *)v1 + 4);
    int v18 = v17 - 1;
    unsigned int v19 = (v17 - 1) & ((&llvm::PreservedAnalyses::AllAnalysesKey >> 4) ^ (&llvm::PreservedAnalyses::AllAnalysesKey >> 9));
    uint64_t v7 = &v2[v19];
    unsigned int v20 = *v7;
    if (*v7 == (void *)-1)
    {
      unsigned int v21 = 0;
LABEL_47:
      if (v21) {
        uint64_t v7 = v21;
      }
      if (*v7 != &llvm::PreservedAnalyses::AllAnalysesKey) {
        uint64_t v7 = &v2[v17];
      }
    }
    else
    {
      unsigned int v21 = 0;
      int v22 = 1;
      while (v20 != &llvm::PreservedAnalyses::AllAnalysesKey)
      {
        if (v21) {
          BOOL v23 = 0;
        }
        else {
          BOOL v23 = v20 == (void *)-2;
        }
        if (v23) {
          unsigned int v21 = v7;
        }
        unsigned int v24 = v19 + v22++;
        unsigned int v19 = v24 & v18;
        uint64_t v7 = &v2[v24 & v18];
        unsigned int v20 = *v7;
        if (*v7 == (void *)-1) {
          goto LABEL_47;
        }
      }
    }
    unsigned int v8 = v3;
  }
  BOOL v23 = v2 == v8;
  uint64_t v9 = 16;
  if (v23) {
    uint64_t v9 = 20;
  }
  if (v7 != &v2[*(unsigned int *)((char *)v1 + v9)]) {
    return 1;
  }
  uint64_t v4 = (unsigned int *)v1 + 5;
  uint64_t v10 = (unsigned int *)(v1 + 2);
  if (v2 == v3)
  {
    uint64_t v11 = *v4;
    uint64_t v12 = &v2[v11];
    if (v11)
    {
      unint64_t v13 = 0;
      uint64_t v14 = 8 * v11;
      while (v2[v13 / 8] != &llvm::AllAnalysesOn<llvm::Function>::SetKey)
      {
        v13 += 8;
        if (v14 == v13) {
          goto LABEL_16;
        }
      }
      uint64_t v12 = &v2[v13 / 8];
    }
LABEL_16:
    uint64_t v3 = v2;
  }
  else
  {
    uint64_t v25 = *v10;
    int v26 = v25 - 1;
    unsigned int v27 = (v25 - 1) & ((&llvm::AllAnalysesOn<llvm::Function>::SetKey >> 4) ^ (&llvm::AllAnalysesOn<llvm::Function>::SetKey >> 9));
    uint64_t v12 = &v2[v27];
    unsigned int v28 = *v12;
    if (*v12 == (void *)-1)
    {
      uint64_t v29 = 0;
LABEL_53:
      if (v29) {
        uint64_t v12 = v29;
      }
      if (*v12 != &llvm::AllAnalysesOn<llvm::Function>::SetKey) {
        uint64_t v12 = &v2[v25];
      }
    }
    else
    {
      uint64_t v29 = 0;
      int v30 = 1;
      while (v28 != &llvm::AllAnalysesOn<llvm::Function>::SetKey)
      {
        if (v29) {
          BOOL v31 = 0;
        }
        else {
          BOOL v31 = v28 == (void *)-2;
        }
        if (v31) {
          uint64_t v29 = v12;
        }
        unsigned int v32 = v27 + v30++;
        unsigned int v27 = v32 & v26;
        uint64_t v12 = &v2[v32 & v26];
        unsigned int v28 = *v12;
        if (*v12 == (void *)-1) {
          goto LABEL_53;
        }
      }
    }
  }
LABEL_17:
  if (v2 == v3) {
    uint64_t v15 = v4;
  }
  else {
    uint64_t v15 = v10;
  }
  return v12 != &v2[*v15];
}

BOOL sub_1CBF75B60(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16)) {
    return 0;
  }
  char v1 = *(void ****)a1;
  uint64_t v3 = **(void ****)a1;
  uint64_t v2 = *(void ***)(*(void *)a1 + 8);
  if (v2 == v3)
  {
    uint64_t v4 = (unsigned int *)v1 + 5;
    uint64_t v5 = *((unsigned int *)v1 + 5);
    if (!v5)
    {
      uint64_t v10 = (unsigned int *)(v1 + 2);
      uint64_t v3 = *(void ***)(*(void *)a1 + 8);
      uint64_t v12 = v3;
      goto LABEL_17;
    }
    uint64_t v6 = 0;
    uint64_t v7 = &v2[v5];
    while (v2[v6] != &llvm::PreservedAnalyses::AllAnalysesKey)
    {
      if (v5 == ++v6) {
        goto LABEL_7;
      }
    }
    uint64_t v7 = &v2[v6];
LABEL_7:
    unsigned int v8 = *(void ***)(*(void *)a1 + 8);
  }
  else
  {
    uint64_t v17 = *((unsigned int *)v1 + 4);
    int v18 = v17 - 1;
    unsigned int v19 = (v17 - 1) & ((&llvm::PreservedAnalyses::AllAnalysesKey >> 4) ^ (&llvm::PreservedAnalyses::AllAnalysesKey >> 9));
    uint64_t v7 = &v2[v19];
    unsigned int v20 = *v7;
    if (*v7 == (void *)-1)
    {
      unsigned int v21 = 0;
LABEL_47:
      if (v21) {
        uint64_t v7 = v21;
      }
      if (*v7 != &llvm::PreservedAnalyses::AllAnalysesKey) {
        uint64_t v7 = &v2[v17];
      }
    }
    else
    {
      unsigned int v21 = 0;
      int v22 = 1;
      while (v20 != &llvm::PreservedAnalyses::AllAnalysesKey)
      {
        if (v21) {
          BOOL v23 = 0;
        }
        else {
          BOOL v23 = v20 == (void *)-2;
        }
        if (v23) {
          unsigned int v21 = v7;
        }
        unsigned int v24 = v19 + v22++;
        unsigned int v19 = v24 & v18;
        uint64_t v7 = &v2[v24 & v18];
        unsigned int v20 = *v7;
        if (*v7 == (void *)-1) {
          goto LABEL_47;
        }
      }
    }
    unsigned int v8 = v3;
  }
  BOOL v23 = v2 == v8;
  uint64_t v9 = 16;
  if (v23) {
    uint64_t v9 = 20;
  }
  if (v7 != &v2[*(unsigned int *)((char *)v1 + v9)]) {
    return 1;
  }
  uint64_t v4 = (unsigned int *)v1 + 5;
  uint64_t v10 = (unsigned int *)(v1 + 2);
  if (v2 == v3)
  {
    uint64_t v11 = *v4;
    uint64_t v12 = &v2[v11];
    if (v11)
    {
      unint64_t v13 = 0;
      uint64_t v14 = 8 * v11;
      while (v2[v13 / 8] != &llvm::CFGAnalyses::SetKey)
      {
        v13 += 8;
        if (v14 == v13) {
          goto LABEL_16;
        }
      }
      uint64_t v12 = &v2[v13 / 8];
    }
LABEL_16:
    uint64_t v3 = v2;
  }
  else
  {
    uint64_t v25 = *v10;
    int v26 = v25 - 1;
    unsigned int v27 = (v25 - 1) & ((&llvm::CFGAnalyses::SetKey >> 4) ^ (&llvm::CFGAnalyses::SetKey >> 9));
    uint64_t v12 = &v2[v27];
    unsigned int v28 = *v12;
    if (*v12 == (void *)-1)
    {
      uint64_t v29 = 0;
LABEL_53:
      if (v29) {
        uint64_t v12 = v29;
      }
      if (*v12 != &llvm::CFGAnalyses::SetKey) {
        uint64_t v12 = &v2[v25];
      }
    }
    else
    {
      uint64_t v29 = 0;
      int v30 = 1;
      while (v28 != &llvm::CFGAnalyses::SetKey)
      {
        if (v29) {
          BOOL v31 = 0;
        }
        else {
          BOOL v31 = v28 == (void *)-2;
        }
        if (v31) {
          uint64_t v29 = v12;
        }
        unsigned int v32 = v27 + v30++;
        unsigned int v27 = v32 & v26;
        uint64_t v12 = &v2[v32 & v26];
        unsigned int v28 = *v12;
        if (*v12 == (void *)-1) {
          goto LABEL_53;
        }
      }
    }
  }
LABEL_17:
  if (v2 == v3) {
    uint64_t v15 = v4;
  }
  else {
    uint64_t v15 = v10;
  }
  return v12 != &v2[*v15];
}

void sub_1CBF75D84()
{
  uint64_t v0 = MEMORY[0x1F4188790]();
  v438[24] = *MEMORY[0x1E4F143B8];
  *(void *)(v0 + 112) = v1;
  *(void *)(v0 + 120) = v2;
  uint64_t v260 = v3;
  *(void *)(v0 + 128) = v3;
  llvm::BlockFrequencyInfoImplBase::clear((llvm::BlockFrequencyInfoImplBase *)v0);
  *(void *)(v0 + 144) = *(void *)(v0 + 136);
  char v261 = (_DWORD *)(v0 + 160);
  uint64_t v262 = (char **)(v0 + 136);
  int v4 = *(_DWORD *)(v0 + 168);
  if (v4 || *(_DWORD *)(v0 + 172))
  {
    uint64_t v245 = *(unsigned int *)(v0 + 176);
    if (v245 > 4 * v4 && v245 >= 0x41)
    {
      sub_1CD45E338(v261);
      goto LABEL_3;
    }
    if (!v245)
    {
LABEL_587:
      *(void *)(v0 + 168) = 0;
      goto LABEL_3;
    }
    long long v246 = (void *)(*(void *)v261 + 24);
    uint64_t v247 = 56 * v245;
    while (1)
    {
      uint64_t v248 = *(v246 - 3);
      if (v248 == -8192) {
        goto LABEL_585;
      }
      if (v248 != -4096) {
        break;
      }
LABEL_586:
      v246 += 7;
      v247 -= 56;
      if (!v247) {
        goto LABEL_587;
      }
    }
    uint64_t v249 = v246[2];
    if (v249 != -8192 && v249 != -4096 && v249 != 0) {
      llvm::ValueHandleBase::RemoveFromUseList(v246);
    }
LABEL_585:
    *(v246 - 3) = -4096;
    goto LABEL_586;
  }
LABEL_3:
  uint64_t v5 = *(void *)(v0 + 128);
  uint64_t v6 = v5 + 72;
  uint64_t v7 = *(void *)(v5 + 80);
  unint64_t v8 = -1;
  uint64_t v9 = v6;
  do
  {
    uint64_t v9 = *(void *)(v9 + 8);
    ++v8;
  }
  while (v9 != v6);
  if (v7) {
    uint64_t v10 = v7 - 24;
  }
  else {
    uint64_t v10 = 0;
  }
  sub_1CBF7ACFC((uint64_t)v262, v8);
  sub_1CBF7B63C((llvm::SmallPtrSetImplBase *)&v270, v10);
  uint64_t v269 = 0;
  memset(v268, 0, sizeof(v268));
  v267[0] = 0;
  long long v266 = 0u;
  long long v265 = 0u;
  long long v264 = 0u;
  long long v263 = 0u;
  v267[1] = (char *)v268 + 8;
  DWORD1(v268[0]) = 8;
  uint64_t v11 = v290;
  v286 = v290;
  uint64_t v12 = v271;
  if (v271 == v270)
  {
    v287 = v290;
    unint64_t v13 = v271;
  }
  else
  {
    unsigned int v226 = v272;
    uint64_t v11 = malloc_type_malloc(8 * v272, 0x4065EBACuLL);
    if (!v11)
    {
      if (v226) {
        goto LABEL_639;
      }
      uint64_t v11 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v11) {
        goto LABEL_639;
      }
    }
    v287 = v11;
    unint64_t v13 = v270;
    uint64_t v12 = v271;
  }
  unsigned int v14 = v273;
  LODWORD(v288) = v272;
  if (v12 == v13) {
    unsigned int v15 = v273;
  }
  else {
    unsigned int v15 = v272;
  }
  if (v15)
  {
    memmove(v11, v12, 8 * v15);
    unsigned int v14 = v273;
  }
  unsigned int v16 = v276;
  HIDWORD(v288) = v14;
  int v289 = v274;
  v291 = v293;
  uint64_t v292 = 0x800000000;
  if (v276)
  {
    if (v276 >= 9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy(v293, __src, 24 * v276);
    LODWORD(v292) = v16;
  }
  uint64_t v278 = v282;
  v279 = v282;
  uint64_t v280 = 8;
  int v17 = v268[0];
  int v281 = v263;
  v283 = v285;
  uint64_t v284 = 0x800000000;
  if (LODWORD(v268[0]))
  {
    if (LODWORD(v268[0]) >= 9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy(v285, v267[1], 24 * LODWORD(v268[0]));
    LODWORD(v284) = v17;
  }
  unint64_t v311 = v315;
  if (v287 == v286)
  {
    v312 = v315;
    unsigned int v18 = HIDWORD(v288);
    if (HIDWORD(v288)) {
      memmove(v315, v287, 8 * HIDWORD(v288));
    }
  }
  else
  {
    v312 = v287;
    v287 = v286;
    unsigned int v18 = HIDWORD(v288);
  }
  unint64_t v313 = __PAIR64__(v18, v288);
  int v314 = v289;
  uint64_t v288 = 8;
  int v289 = 0;
  v316 = v318;
  uint64_t v317 = 0x800000000;
  int v19 = v292;
  if (v292)
  {
    if (v291 == v293)
    {
      if (v292 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v318, v293, 24 * v292);
      LODWORD(v317) = v19;
    }
    else
    {
      v316 = v291;
      uint64_t v317 = v292;
      v291 = v293;
      HIDWORD(v292) = 0;
    }
    LODWORD(v292) = 0;
  }
  v303 = v307;
  if (v279 == v278)
  {
    uint64_t v304 = v307;
    unsigned int v20 = HIDWORD(v280);
    if (HIDWORD(v280)) {
      memmove(v307, v279, 8 * HIDWORD(v280));
    }
  }
  else
  {
    uint64_t v304 = v279;
    v279 = v278;
    unsigned int v20 = HIDWORD(v280);
  }
  unint64_t v305 = __PAIR64__(v20, v280);
  int v306 = v281;
  uint64_t v280 = 8;
  int v281 = 0;
  v308 = v310;
  uint64_t v309 = 0x800000000;
  int v21 = v284;
  if (v284)
  {
    if (v283 == v285)
    {
      if (v284 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v310, v285, 24 * v284);
      LODWORD(v309) = v21;
    }
    else
    {
      v308 = v283;
      uint64_t v309 = v284;
      v283 = v285;
      HIDWORD(v284) = 0;
    }
    LODWORD(v284) = 0;
  }
  int v327 = v331;
  if (v312 == v311)
  {
    v328 = v331;
    unsigned int v22 = HIDWORD(v313);
    if (HIDWORD(v313)) {
      memmove(v331, v312, 8 * HIDWORD(v313));
    }
  }
  else
  {
    v328 = v312;
    v312 = v311;
    unsigned int v22 = HIDWORD(v313);
  }
  unint64_t v329 = __PAIR64__(v22, v313);
  int v330 = v314;
  unint64_t v313 = 8;
  int v314 = 0;
  int v332 = v334;
  uint64_t v333 = 0x800000000;
  int v23 = v317;
  if (v317)
  {
    if (v316 == v318)
    {
      if (v317 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v334, v318, 24 * v317);
      LODWORD(v333) = v23;
    }
    else
    {
      int v332 = v316;
      uint64_t v333 = v317;
      v316 = v318;
      HIDWORD(v317) = 0;
    }
    LODWORD(v317) = 0;
  }
  unint64_t v319 = v323;
  if (v304 == v303)
  {
    v320 = v323;
    unsigned int v24 = HIDWORD(v305);
    if (HIDWORD(v305)) {
      memmove(v323, v304, 8 * HIDWORD(v305));
    }
  }
  else
  {
    v320 = v304;
    uint64_t v304 = v303;
    unsigned int v24 = HIDWORD(v305);
  }
  unint64_t v321 = __PAIR64__(v24, v305);
  int v322 = v306;
  unint64_t v305 = 8;
  int v306 = 0;
  v324 = v326;
  uint64_t v325 = 0x800000000;
  int v25 = v309;
  if (v309)
  {
    if (v308 == v310)
    {
      if (v309 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v326, v310, 24 * v309);
      LODWORD(v325) = v25;
    }
    else
    {
      v324 = v308;
      uint64_t v325 = v309;
      v308 = v310;
      HIDWORD(v309) = 0;
    }
    LODWORD(v309) = 0;
  }
  int v26 = v397;
  v393 = v397;
  unsigned int v27 = v328;
  if (v328 != v327)
  {
    int v227 = v329;
    int v26 = malloc_type_malloc(8 * v329, 0x4065EBACuLL);
    if (v26 || !v227 && (int v26 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) != 0)
    {
      v394 = v26;
      unsigned int v28 = v327;
      unsigned int v27 = v328;
      goto LABEL_39;
    }
LABEL_639:
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  v394 = v397;
  unsigned int v28 = v328;
LABEL_39:
  int v29 = HIDWORD(v329);
  LODWORD(v395) = v329;
  if (v27 == v28) {
    unsigned int v30 = HIDWORD(v329);
  }
  else {
    unsigned int v30 = v329;
  }
  if (v30)
  {
    memmove(v26, v27, 8 * v30);
    int v29 = HIDWORD(v329);
  }
  int v31 = v333;
  HIDWORD(v395) = v29;
  int v396 = v330;
  v398 = v400;
  uint64_t v399 = 0x800000000;
  if (v333)
  {
    if (v333 >= 9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy(v400, v332, 24 * v333);
    LODWORD(v399) = v31;
  }
  v385 = v389;
  if (v320 == v319)
  {
    v386 = v389;
    unsigned int v32 = HIDWORD(v321);
    if (HIDWORD(v321)) {
      memmove(v389, v320, 8 * HIDWORD(v321));
    }
  }
  else
  {
    v386 = v320;
    v320 = v319;
    unsigned int v32 = HIDWORD(v321);
  }
  unint64_t v387 = __PAIR64__(v32, v321);
  int v388 = v322;
  unint64_t v321 = 8;
  int v322 = 0;
  v390 = v392;
  uint64_t v391 = 0x800000000;
  int v33 = v325;
  if (v325)
  {
    if (v324 == v326)
    {
      if (v325 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v392, v326, 24 * v325);
      LODWORD(v391) = v33;
    }
    else
    {
      v390 = v324;
      uint64_t v391 = v325;
      v324 = v326;
      HIDWORD(v325) = 0;
    }
    LODWORD(v325) = 0;
  }
  v294 = v299;
  if (v394 == v393)
  {
    v295 = v299;
    int v34 = HIDWORD(v395);
    if (HIDWORD(v395)) {
      memmove(v299, v394, 8 * HIDWORD(v395));
    }
  }
  else
  {
    v295 = v394;
    v394 = v393;
    int v34 = HIDWORD(v395);
  }
  int v296 = v395;
  int v297 = v34;
  int v298 = v396;
  uint64_t v395 = 8;
  int v396 = 0;
  v300 = v302;
  uint64_t v301 = 0x800000000;
  int v35 = v399;
  if (v399)
  {
    if (v398 == v400)
    {
      if (v399 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v302, v400, 24 * v399);
      LODWORD(v301) = v35;
    }
    else
    {
      v300 = v398;
      uint64_t v301 = v399;
      v398 = v400;
      HIDWORD(v399) = 0;
    }
    LODWORD(v399) = 0;
  }
  sub_1CBF7AEB8((uint64_t)&v376, (uint64_t)&v294);
  v423 = v427;
  if (v386 == v385)
  {
    v424 = v427;
    unsigned int v36 = HIDWORD(v387);
    if (HIDWORD(v387)) {
      memmove(v427, v386, 8 * HIDWORD(v387));
    }
  }
  else
  {
    v424 = v386;
    v386 = v385;
    unsigned int v36 = HIDWORD(v387);
  }
  unint64_t v425 = __PAIR64__(v36, v387);
  int v426 = v388;
  unint64_t v387 = 8;
  int v388 = 0;
  v428 = v430;
  uint64_t v429 = 0x800000000;
  int v37 = v391;
  if (v391)
  {
    if (v390 == v392)
    {
      if (v391 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v430, v392, 24 * v391);
      LODWORD(v429) = v37;
    }
    else
    {
      v428 = v390;
      uint64_t v429 = v391;
      v390 = v392;
      HIDWORD(v391) = 0;
    }
    LODWORD(v391) = 0;
  }
  sub_1CBF7AEB8((uint64_t)&v431, (uint64_t)&v423);
  __p[0] = v403;
  if (v377 == v376)
  {
    __p[1] = v403;
    unsigned int v38 = HIDWORD(v378);
    if (HIDWORD(v378)) {
      memmove(v403, v377, 8 * HIDWORD(v378));
    }
  }
  else
  {
    __p[1] = v377;
    v377 = v376;
    unsigned int v38 = HIDWORD(v378);
  }
  *(void *)&long long v402 = __PAIR64__(v38, v378);
  DWORD2(v402) = v379;
  unint64_t v378 = 8;
  LODWORD(v379) = 0;
  v404 = v406;
  uint64_t v405 = 0x800000000;
  int v39 = v382;
  if (v382)
  {
    if (v381 == v383)
    {
      if (v382 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v406, v381, 24 * v382);
      LODWORD(v405) = v39;
    }
    else
    {
      v404 = v381;
      uint64_t v405 = v382;
      v381 = v383;
      HIDWORD(v382) = 0;
    }
    LODWORD(v382) = 0;
  }
  v407 = v411;
  if (v432 == v431)
  {
    v408 = v411;
    unsigned int v40 = HIDWORD(v433);
    if (HIDWORD(v433)) {
      memmove(v411, v432, 8 * HIDWORD(v433));
    }
  }
  else
  {
    v408 = v432;
    v432 = v431;
    unsigned int v40 = HIDWORD(v433);
  }
  unint64_t v409 = __PAIR64__(v40, v433);
  int v410 = v434;
  unint64_t v433 = 8;
  int v434 = 0;
  v412 = v414;
  uint64_t v413 = 0x800000000;
  int v41 = v437;
  if (v437)
  {
    if (v436 == v438)
    {
      if (v437 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v414, v436, 24 * v437);
      LODWORD(v413) = v41;
    }
    else
    {
      v412 = v436;
      uint64_t v413 = v437;
      v436 = v438;
      HIDWORD(v437) = 0;
    }
    LODWORD(v437) = 0;
  }
  if (v436 != v438) {
    free(v436);
  }
  if (v432 != v431) {
    free(v432);
  }
  if (v428 != v430) {
    free(v428);
  }
  if (v424 != v423) {
    free(v424);
  }
  if (v381 != v383) {
    free(v381);
  }
  if (v377 != v376) {
    free(v377);
  }
  if (v300 != v302) {
    free(v300);
  }
  if (v295 != v294) {
    free(v295);
  }
  if (v390 != v392) {
    free(v390);
  }
  if (v386 != v385) {
    free(v386);
  }
  if (v398 != v400) {
    free(v398);
  }
  if (v394 != v393) {
    free(v394);
  }
  v368 = v372;
  if (__p[1] == __p[0])
  {
    v369 = v372;
    unsigned int v42 = DWORD1(v402);
    if (DWORD1(v402)) {
      memmove(v372, __p[1], 8 * DWORD1(v402));
    }
  }
  else
  {
    v369 = __p[1];
    __p[1] = __p[0];
    unsigned int v42 = DWORD1(v402);
  }
  unint64_t v370 = __PAIR64__(v42, v402);
  int v371 = DWORD2(v402);
  *(void *)&long long v402 = 8;
  DWORD2(v402) = 0;
  v373 = v375;
  uint64_t v374 = 0x800000000;
  int v43 = v405;
  if (v405)
  {
    if (v404 == v406)
    {
      if (v405 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v375, v406, 24 * v405);
      LODWORD(v374) = v43;
    }
    else
    {
      v373 = v404;
      uint64_t v374 = v405;
      v404 = v406;
      HIDWORD(v405) = 0;
    }
    LODWORD(v405) = 0;
  }
  v359 = v364;
  if (v408 == v407)
  {
    v360 = v364;
    int v44 = HIDWORD(v409);
    if (HIDWORD(v409)) {
      memmove(v364, v408, 8 * HIDWORD(v409));
    }
  }
  else
  {
    v360 = v408;
    v408 = v407;
    int v44 = HIDWORD(v409);
  }
  int v361 = v409;
  int v362 = v44;
  int v363 = v410;
  unint64_t v409 = 8;
  int v410 = 0;
  v365 = v367;
  uint64_t v366 = 0x800000000;
  unsigned int v45 = v413;
  if (v413)
  {
    if (v412 == v414)
    {
      if (v413 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v367, v414, 24 * v413);
      LODWORD(v366) = v45;
    }
    else
    {
      v365 = v412;
      uint64_t v366 = v413;
      v412 = v414;
      HIDWORD(v413) = 0;
    }
    LODWORD(v413) = 0;
  }
  while (1)
  {
    uint64_t v46 = v374;
    uint64_t v47 = v373;
    if (v374 != v45) {
      goto LABEL_109;
    }
    if (!v45) {
      break;
    }
    BOOL v48 = v365;
    uint64_t v49 = v373;
    while (*(void *)v49 == *(void *)v48 && v49[4] == v48[4])
    {
      v49 += 6;
      v48 += 6;
      if (v49 == (_DWORD *)((char *)v373 + 24 * v374)) {
        goto LABEL_129;
      }
    }
LABEL_109:
    uint64_t v51 = (char *)v373 + 24 * v374;
    uint64_t v53 = *(char **)(v0 + 144);
    unint64_t v52 = *(void *)(v0 + 152);
    if ((unint64_t)v53 >= v52)
    {
      uint64_t v55 = *v262;
      uint64_t v56 = (v53 - *v262) >> 3;
      unint64_t v57 = v56 + 1;
      if ((unint64_t)(v56 + 1) >> 61) {
        abort();
      }
      uint64_t v58 = v52 - (void)v55;
      if (v58 >> 2 > v57) {
        unint64_t v57 = v58 >> 2;
      }
      if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v59 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v59 = v57;
      }
      if (v59)
      {
        if (v59 >> 61) {
          sub_1CB833614();
        }
        uint64_t v60 = (char *)operator new(8 * v59);
      }
      else
      {
        uint64_t v60 = 0;
      }
      unsigned int v61 = &v60[8 * v56];
      *(void *)unsigned int v61 = *((void *)v51 - 3);
      uint64_t v54 = v61 + 8;
      if (v53 != v55)
      {
        do
        {
          uint64_t v62 = *((void *)v53 - 1);
          v53 -= 8;
          *((void *)v61 - 1) = v62;
          v61 -= 8;
        }
        while (v53 != v55);
        uint64_t v53 = *v262;
      }
      *(void *)(v0 + 136) = v61;
      *(void *)(v0 + 144) = v54;
      *(void *)(v0 + 152) = &v60[8 * v59];
      if (v53)
      {
        operator delete(v53);
        LODWORD(v46) = v374;
      }
    }
    else
    {
      *(void *)uint64_t v53 = *((void *)v51 - 3);
      uint64_t v54 = v53 + 8;
    }
    *(void *)(v0 + 144) = v54;
    LODWORD(v374) = v46 - 1;
    if (v46 != 1) {
      sub_1CBF7B148((llvm::SmallPtrSetImplBase *)&v368);
    }
    unsigned int v45 = v366;
  }
LABEL_129:
  v376 = v380;
  if (v369 == v368)
  {
    v377 = v380;
    unsigned int v63 = HIDWORD(v370);
    if (HIDWORD(v370)) {
      memmove(v380, v369, 8 * HIDWORD(v370));
    }
  }
  else
  {
    v377 = v369;
    v369 = v368;
    unsigned int v63 = HIDWORD(v370);
  }
  unint64_t v378 = __PAIR64__(v63, v370);
  LODWORD(v379) = v371;
  unint64_t v370 = 8;
  int v371 = 0;
  v381 = v383;
  unint64_t v382 = 0x800000000;
  if (v45)
  {
    if (v47 == v375)
    {
      if (v45 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v383, v375, 24 * v46);
      LODWORD(v382) = v45;
    }
    else
    {
      v381 = v47;
      unint64_t v382 = __PAIR64__(HIDWORD(v374), v45);
      v373 = v375;
      HIDWORD(v374) = 0;
    }
    LODWORD(v374) = 0;
  }
  uint64_t v384 = v0 + 136;
  if (v365 != v367) {
    free(v365);
  }
  if (v360 != v359) {
    free(v360);
  }
  if (v373 != v375) {
    free(v373);
  }
  if (v369 != v368) {
    free(v369);
  }
  v343 = v347;
  if (v328 == v327)
  {
    unint64_t v344 = v347;
    unsigned int v64 = HIDWORD(v329);
    if (HIDWORD(v329)) {
      memmove(v347, v328, 8 * HIDWORD(v329));
    }
  }
  else
  {
    unint64_t v344 = v328;
    v328 = v327;
    unsigned int v64 = HIDWORD(v329);
  }
  unint64_t v345 = __PAIR64__(v64, v329);
  int v346 = v330;
  unint64_t v329 = 8;
  int v330 = 0;
  int v348 = v350;
  uint64_t v349 = 0x800000000;
  int v65 = v333;
  if (v333)
  {
    if (v332 == v334)
    {
      if (v333 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v350, v334, 24 * v333);
      LODWORD(v349) = v65;
    }
    else
    {
      int v348 = v332;
      uint64_t v349 = v333;
      int v332 = v334;
      HIDWORD(v333) = 0;
    }
    LODWORD(v333) = 0;
  }
  uint64_t v335 = v339;
  if (v377 == v376)
  {
    v336 = v339;
    unsigned int v66 = HIDWORD(v378);
    if (HIDWORD(v378)) {
      memmove(v339, v377, 8 * HIDWORD(v378));
    }
  }
  else
  {
    v336 = v377;
    v377 = v376;
    unsigned int v66 = HIDWORD(v378);
  }
  unint64_t v337 = __PAIR64__(v66, v378);
  int v338 = (int)v379;
  unint64_t v378 = 8;
  LODWORD(v379) = 0;
  uint64_t v340 = v342;
  uint64_t v341 = 0x800000000;
  int v67 = v382;
  if (v382)
  {
    if (v381 == v383)
    {
      if (v382 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v342, v383, 24 * v382);
      LODWORD(v341) = v67;
    }
    else
    {
      uint64_t v340 = v381;
      uint64_t v341 = v382;
      v381 = v383;
      HIDWORD(v382) = 0;
    }
    LODWORD(v382) = 0;
  }
  v423 = v427;
  if (v344 == v343)
  {
    v424 = v427;
    unsigned int v68 = HIDWORD(v345);
    if (HIDWORD(v345)) {
      memmove(v427, v344, 8 * HIDWORD(v345));
    }
  }
  else
  {
    v424 = v344;
    unint64_t v344 = v343;
    unsigned int v68 = HIDWORD(v345);
  }
  unint64_t v425 = __PAIR64__(v68, v345);
  int v426 = v346;
  unint64_t v345 = 8;
  int v346 = 0;
  v428 = v430;
  uint64_t v429 = 0x800000000;
  int v69 = v349;
  if (v349)
  {
    if (v348 == v350)
    {
      if (v349 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v430, v350, 24 * v349);
      LODWORD(v429) = v69;
    }
    else
    {
      v428 = v348;
      uint64_t v429 = v349;
      int v348 = v350;
      HIDWORD(v349) = 0;
    }
    LODWORD(v349) = 0;
  }
  v415 = v419;
  if (v336 == v335)
  {
    v416 = v419;
    unsigned int v70 = HIDWORD(v337);
    if (HIDWORD(v337)) {
      memmove(v419, v336, 8 * HIDWORD(v337));
    }
  }
  else
  {
    v416 = v336;
    v336 = v335;
    unsigned int v70 = HIDWORD(v337);
  }
  unint64_t v417 = __PAIR64__(v70, v337);
  int v418 = v338;
  unint64_t v337 = 8;
  int v338 = 0;
  v420 = v422;
  uint64_t v421 = 0x800000000;
  int v71 = v341;
  if (v341)
  {
    if (v340 == v342)
    {
      if (v341 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v422, v342, 24 * v341);
      LODWORD(v421) = v71;
    }
    else
    {
      v420 = v340;
      uint64_t v421 = v341;
      uint64_t v340 = v342;
      HIDWORD(v341) = 0;
    }
    LODWORD(v341) = 0;
  }
  v294 = v299;
  if (v424 == v423)
  {
    v295 = v299;
    int v72 = HIDWORD(v425);
    if (HIDWORD(v425)) {
      memmove(v299, v424, 8 * HIDWORD(v425));
    }
  }
  else
  {
    v295 = v424;
    v424 = v423;
    int v72 = HIDWORD(v425);
  }
  int v296 = v425;
  int v297 = v72;
  int v298 = v426;
  unint64_t v425 = 8;
  int v426 = 0;
  v300 = v302;
  uint64_t v301 = 0x800000000;
  int v73 = v429;
  if (v429)
  {
    if (v428 == v430)
    {
      if (v429 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v302, v430, 24 * v429);
      LODWORD(v301) = v73;
    }
    else
    {
      v300 = v428;
      uint64_t v301 = v429;
      v428 = v430;
      HIDWORD(v429) = 0;
    }
    LODWORD(v429) = 0;
  }
  int v74 = v435;
  v431 = v435;
  uint64_t v75 = v416;
  if (v416 == v415)
  {
    v432 = v435;
    unsigned int v76 = HIDWORD(v417);
    if (HIDWORD(v417)) {
      memmove(v435, v416, 8 * HIDWORD(v417));
    }
    uint64_t v75 = v435;
  }
  else
  {
    v432 = v416;
    v416 = v415;
    unsigned int v76 = HIDWORD(v417);
  }
  unint64_t v433 = __PAIR64__(v76, v417);
  int v434 = v418;
  unint64_t v417 = 8;
  int v418 = 0;
  v436 = v438;
  uint64_t v437 = 0x800000000;
  uint64_t v77 = v421;
  if (v421)
  {
    if (v420 == v422)
    {
      if (v421 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v438, v422, 24 * v421);
      LODWORD(v437) = v77;
      uint64_t v75 = v432;
      int v74 = v431;
    }
    else
    {
      v436 = v420;
      uint64_t v437 = v421;
      v420 = v422;
      HIDWORD(v421) = 0;
    }
    LODWORD(v421) = 0;
  }
  uint64_t v351 = v355;
  if (v75 == v74)
  {
    v352 = v355;
    unsigned int v78 = HIDWORD(v433);
    if (HIDWORD(v433)) {
      memmove(v355, v74, 8 * HIDWORD(v433));
    }
  }
  else
  {
    v352 = v75;
    v432 = v74;
    unsigned int v78 = HIDWORD(v433);
  }
  unint64_t v353 = __PAIR64__(v78, v433);
  int v354 = v434;
  unint64_t v433 = 8;
  int v434 = 0;
  uint64_t v356 = v358;
  unint64_t v357 = 0x800000000;
  uint64_t v79 = v436;
  if (v77)
  {
    if (v436 == v438)
    {
      if (v77 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v358, v438, 24 * v77);
      LODWORD(v357) = v77;
      uint64_t v79 = v436;
    }
    else
    {
      uint64_t v356 = v436;
      unint64_t v357 = __PAIR64__(HIDWORD(v437), v77);
      v436 = v438;
      HIDWORD(v437) = 0;
      uint64_t v79 = v438;
    }
    LODWORD(v437) = 0;
  }
  if (v79 != v438) {
    free(v79);
  }
  if (v432 != v431) {
    free(v432);
  }
  if (v300 != v302) {
    free(v300);
  }
  if (v295 != v294) {
    free(v295);
  }
  if (v420 != v422) {
    free(v420);
  }
  if (v416 != v415) {
    free(v416);
  }
  if (v428 != v430) {
    free(v428);
  }
  if (v424 != v423) {
    free(v424);
  }
  uint64_t v80 = v384;
  v294 = v299;
  if (v352 == v351)
  {
    v295 = v299;
    int v81 = HIDWORD(v353);
    if (HIDWORD(v353)) {
      memmove(v299, v352, 8 * HIDWORD(v353));
    }
  }
  else
  {
    v295 = v352;
    v352 = v351;
    int v81 = HIDWORD(v353);
  }
  int v296 = v353;
  int v297 = v81;
  int v298 = v354;
  unint64_t v353 = 8;
  int v354 = 0;
  v300 = v302;
  uint64_t v301 = 0x800000000;
  int v82 = v357;
  uint64_t v83 = v356;
  if (v357)
  {
    if (v356 == v358)
    {
      if (v357 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v302, v358, 24 * v357);
      LODWORD(v301) = v82;
      uint64_t v83 = v356;
    }
    else
    {
      v300 = v356;
      uint64_t v301 = v357;
      uint64_t v356 = v358;
      HIDWORD(v357) = 0;
      uint64_t v83 = v358;
    }
    LODWORD(v357) = 0;
  }
  v302[24] = v80;
  if (v83 != v358) {
    free(v83);
  }
  if (v352 != v351) {
    free(v352);
  }
  if (v340 != v342) {
    free(v340);
  }
  if (v336 != v335) {
    free(v336);
  }
  if (v348 != v350) {
    free(v348);
  }
  if (v344 != v343) {
    free(v344);
  }
  if (v381 != v383) {
    free(v381);
  }
  if (v377 != v376) {
    free(v377);
  }
  if (v412 != v414) {
    free(v412);
  }
  if (v408 != v407) {
    free(v408);
  }
  if (v404 != v406) {
    free(v404);
  }
  if (__p[1] != __p[0]) {
    free(__p[1]);
  }
  if (v324 != v326) {
    free(v324);
  }
  if (v320 != v319) {
    free(v320);
  }
  if (v332 != v334) {
    free(v332);
  }
  if (v328 != v327) {
    free(v328);
  }
  if (v308 != v310) {
    free(v308);
  }
  if (v304 != v303) {
    free(v304);
  }
  if (v316 != v318) {
    free(v316);
  }
  if (v312 != v311) {
    free(v312);
  }
  if (v300 != v302) {
    free(v300);
  }
  if (v295 != v294) {
    free(v295);
  }
  if (v283 != v285) {
    free(v283);
  }
  if (v279 != v278) {
    free(v279);
  }
  if (v291 != v293) {
    free(v291);
  }
  if (v287 != v286) {
    free(v287);
  }
  if (v267[1] != (char *)v268 + 8) {
    free(v267[1]);
  }
  if (__src != &v277) {
    free(__src);
  }
  if (v271 != v270) {
    free(v271);
  }
  int v85 = *(uint64_t **)(v0 + 136);
  uint64_t v84 = *(uint64_t **)(v0 + 144);
  if (v85 != v84)
  {
    uint64_t v86 = v84 - 1;
    if (v85 < v84 - 1)
    {
      uint64_t v87 = v85 + 1;
      do
      {
        uint64_t v88 = *(v87 - 1);
        *(v87 - 1) = *v86;
        *v86-- = v88;
      }
      while (v87++ < v86);
      int v85 = *(uint64_t **)(v0 + 136);
      uint64_t v84 = *(uint64_t **)(v0 + 144);
    }
  }
  if (v85 != v84)
  {
    while (1)
    {
      BOOL v90 = *v262;
      uint64_t v91 = *v85;
      v377 = (void *)2;
      unint64_t v378 = 0;
      v379 = (int32x2_t ****)v91;
      if (v91 == -8192)
      {
        uint64_t v93 = 2;
      }
      else
      {
        BOOL v92 = v91 == -4096 || v91 == 0;
        uint64_t v93 = 2;
        if (!v92)
        {
          llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v377);
          uint64_t v93 = (uint64_t)v377;
          uint64_t v91 = (uint64_t)v379;
        }
      }
      v376 = &unk_1F26010A0;
      v380[0] = v0;
      unint64_t v94 = (unint64_t)((char *)v85 - v90) >> 3;
      LODWORD(__p[0]) = v94;
      long long v402 = v93 & 6;
      *(void *)&v403[0] = v91;
      uint64_t v95 = v0;
      if (v91 != -8192)
      {
        uint64_t v95 = v0;
        if (v91 != -4096)
        {
          uint64_t v95 = v0;
          if (v91)
          {
            *((void *)&v402 + 1) = *(void *)(v93 & 0xFFFFFFFFFFFFFFF8);
            *(void *)(v93 & 0xFFFFFFFFFFFFFFF8) = &v402;
            *(void *)&long long v402 = v93 & 0xFFFFFFFFFFFFFFFELL;
            if (*((void *)&v402 + 1)) {
              **((void **)&v402 + 1) = **((void **)&v402 + 1) & 7 | ((unint64_t)&v402 + 8);
            }
            uint64_t v95 = v380[0];
          }
        }
      }
      __p[1] = &unk_1F26010A0;
      *((void *)&v403[0] + 1) = v95;
      uint64_t v96 = *v85;
      v294 = (unsigned char *)*v85;
      int v97 = *(_DWORD *)(v0 + 176);
      if (!v97) {
        break;
      }
      uint64_t v98 = *(void *)(v0 + 160);
      int v99 = v97 - 1;
      unsigned int v100 = ((v96 >> 4) ^ (v96 >> 9)) & v99;
      uint64_t v101 = (uint64_t *)(v98 + 56 * v100);
      uint64_t v102 = *v101;
      if (v96 != *v101)
      {
        uint64_t v103 = 0;
        int v104 = 1;
        while (v102 != -4096)
        {
          if (v103) {
            BOOL v105 = 0;
          }
          else {
            BOOL v105 = v102 == -8192;
          }
          if (v105) {
            uint64_t v103 = v101;
          }
          unsigned int v106 = v100 + v104++;
          unsigned int v100 = v106 & v99;
          uint64_t v101 = (uint64_t *)(v98 + 56 * v100);
          uint64_t v102 = *v101;
          if (v96 == *v101) {
            goto LABEL_282;
          }
        }
        if (v103) {
          uint64_t v107 = v103;
        }
        else {
          uint64_t v107 = v101;
        }
        goto LABEL_281;
      }
LABEL_282:
      *((_DWORD *)v101 + 2) = v94;
      uint64_t v108 = v101[5];
      uint64_t v109 = *(void *)&v403[0];
      if (v108 == *(void *)&v403[0])
      {
        uint64_t v109 = v101[5];
      }
      else
      {
        BOOL v110 = v108 == -4096 || v108 == 0;
        if (!v110 && v108 != -8192)
        {
          unint64_t v139 = v101[3] & 0xFFFFFFFFFFFFFFF8;
          *(void *)unint64_t v139 = v101[4];
          uint64_t v140 = (unint64_t *)v101[4];
          if (v140)
          {
            *uint64_t v140 = *v140 & 7 | v139;
          }
          else
          {
            uint64_t v141 = v101[5];
            long long v142 = ***(int32x2_t ****)v141;
            unint64_t v143 = (unint64_t)v142[303];
            if (v143 <= v139)
            {
              uint64_t v144 = v142[305].u32[0];
              if (v143 + 16 * v144 > v139)
              {
                unsigned int v145 = v144 - 1;
                LODWORD(v146) = v145 & ((v141 >> 4) ^ (v141 >> 9));
                uint64_t v147 = (uint64_t *)(v143 + 16 * v146);
                uint64_t v148 = *v147;
                if (v141 == *v147)
                {
LABEL_343:
                  uint64_t *v147 = -8192;
                  v142[304] = vadd_s32(v142[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v141 = v101[5];
                }
                else
                {
                  int v149 = 1;
                  while (v148 != -4096)
                  {
                    int v150 = v146 + v149++;
                    uint64_t v146 = v150 & v145;
                    uint64_t v148 = *(void *)(v143 + 16 * v146);
                    if (v141 == v148)
                    {
                      uint64_t v147 = (uint64_t *)(v143 + 16 * v146);
                      goto LABEL_343;
                    }
                  }
                }
                *(unsigned char *)(v141 + 17) &= ~1u;
              }
            }
          }
          uint64_t v109 = *(void *)&v403[0];
        }
        v101[5] = v109;
        if (v109 != -4096 && v109 != -8192 && v109 != 0)
        {
          uint64_t v112 = v402;
          uint64_t v113 = (void *)(v402 & 0xFFFFFFFFFFFFFFF8);
          v101[4] = *(void *)(v402 & 0xFFFFFFFFFFFFFFF8);
          *uint64_t v113 = v101 + 3;
          v101[3] = v112 & 0xFFFFFFFFFFFFFFF8 | v101[3] & 7;
          int v114 = (unint64_t *)v101[4];
          if (v114) {
            *int v114 = *v114 & 7 | (unint64_t)(v101 + 4);
          }
          uint64_t v109 = *(void *)&v403[0];
        }
      }
      v101[6] = *((void *)&v403[0] + 1);
      if (v109 != -8192 && v109 != -4096 && v109 != 0)
      {
        unint64_t v116 = v402 & 0xFFFFFFFFFFFFFFF8;
        *(void *)(v402 & 0xFFFFFFFFFFFFFFF8) = *((void *)&v402 + 1);
        if (*((void *)&v402 + 1))
        {
          **((void **)&v402 + 1) = **((void **)&v402 + 1) & 7 | v116;
        }
        else
        {
          uint64_t v117 = *(void *)&v403[0];
          int v118 = ****(int32x2_t *****)&v403[0];
          unint64_t v119 = (unint64_t)v118[303];
          if (v119 <= v116)
          {
            uint64_t v120 = v118[305].u32[0];
            if (v119 + 16 * v120 > v116)
            {
              unsigned int v121 = v120 - 1;
              LODWORD(v122) = v121 & ((LODWORD(v403[0]) >> 4) ^ (LODWORD(v403[0]) >> 9));
              char v123 = (uint64_t *)(v119 + 16 * v122);
              uint64_t v124 = *v123;
              if (*(void *)&v403[0] == *v123)
              {
LABEL_309:
                uint64_t *v123 = -8192;
                v118[304] = vadd_s32(v118[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v117 = *(void *)&v403[0];
              }
              else
              {
                int v125 = 1;
                while (v124 != -4096)
                {
                  int v126 = v122 + v125++;
                  uint64_t v122 = v126 & v121;
                  uint64_t v124 = *(void *)(v119 + 16 * v122);
                  if (*(void *)&v403[0] == v124)
                  {
                    char v123 = (uint64_t *)(v119 + 16 * v122);
                    goto LABEL_309;
                  }
                }
              }
              *(unsigned char *)(v117 + 17) &= ~1u;
            }
          }
        }
      }
      if (v379 != (int32x2_t ****)-8192 && v379 != (int32x2_t ****)-4096 && v379 != 0)
      {
        unint64_t v128 = (unint64_t)v377 & 0xFFFFFFFFFFFFFFF8;
        *(void *)((unint64_t)v377 & 0xFFFFFFFFFFFFFFF8) = v378;
        if (v378)
        {
          *(void *)unint64_t v378 = *(void *)v378 & 7 | v128;
        }
        else
        {
          int v129 = v379;
          unint64_t v130 = ***v379;
          unint64_t v131 = (unint64_t)v130[303];
          if (v131 <= v128)
          {
            uint64_t v132 = v130[305].u32[0];
            if (v131 + 16 * v132 > v128)
            {
              unsigned int v133 = v132 - 1;
              LODWORD(v134) = v133 & ((v379 >> 4) ^ (v379 >> 9));
              long long v135 = (int32x2_t *****)(v131 + 16 * v134);
              uint64_t v136 = *v135;
              if (v379 == *v135)
              {
LABEL_325:
                *long long v135 = (int32x2_t ****)-8192;
                v130[304] = vadd_s32(v130[304], (int32x2_t)0x1FFFFFFFFLL);
                int v129 = v379;
              }
              else
              {
                int v137 = 1;
                while (v136 != (int32x2_t ****)-4096)
                {
                  int v138 = v134 + v137++;
                  uint64_t v134 = v138 & v133;
                  uint64_t v136 = *(int32x2_t *****)(v131 + 16 * v134);
                  if (v379 == v136)
                  {
                    long long v135 = (int32x2_t *****)(v131 + 16 * v134);
                    goto LABEL_325;
                  }
                }
              }
              *((unsigned char *)v129 + 17) &= ~1u;
            }
          }
        }
      }
      if (++v85 == v84)
      {
        uint64_t v84 = *(uint64_t **)(v0 + 136);
        uint64_t v151 = *(uint64_t **)(v0 + 144);
        goto LABEL_345;
      }
    }
    uint64_t v107 = 0;
LABEL_281:
    uint64_t v101 = sub_1CBF7B6D8((uint64_t)v261, (uint64_t *)&v294, v107);
    *uint64_t v101 = v96;
    *((_DWORD *)v101 + 2) = -1;
    v101[5] = 0;
    v101[6] = 0;
    v101[3] = 2;
    v101[4] = 0;
    v101[2] = (uint64_t)&unk_1F26010A0;
    LODWORD(v94) = __p[0];
    goto LABEL_282;
  }
  uint64_t v151 = v84;
LABEL_345:
  sub_1CBF7ADB4(v0 + 64, v151 - v84);
  __p[0] = 0;
  uint64_t v153 = *(void *)(v0 + 136);
  uint64_t v152 = *(void *)(v0 + 144);
  if (v152 == v153)
  {
    unint64_t v156 = (v152 - v153) >> 3;
  }
  else
  {
    unint64_t v154 = 0;
    unint64_t v155 = *(char **)(v0 + 72);
    do
    {
      if ((unint64_t)v155 >= *(void *)(v0 + 80))
      {
        unint64_t v155 = sub_1CBF7BB20((char **)(v0 + 64), __p);
        unint64_t v154 = (unint64_t)__p[0];
        uint64_t v153 = *(void *)(v0 + 136);
        uint64_t v152 = *(void *)(v0 + 144);
      }
      else
      {
        *(_DWORD *)unint64_t v155 = v154;
        *((void *)v155 + 1) = 0;
        *((void *)v155 + 2) = 0;
        v155 += 24;
      }
      *(void *)(v0 + 72) = v155;
      __p[0] = (void *)++v154;
    }
    while (v154 < (v152 - v153) >> 3);
    unint64_t v156 = (v152 - v153) >> 3;
  }
  uint64_t v157 = *(void *)(v0 + 8);
  unint64_t v158 = 0xAAAAAAAAAAAAAAABLL * ((*(void *)(v0 + 16) - v157) >> 3);
  if (v156 <= v158)
  {
    if (v156 < v158) {
      *(void *)(v0 + 16) = v157 + 24 * v156;
    }
  }
  else
  {
    sub_1CBF7BC34((char **)(v0 + 8), v156 - v158);
  }
  uint64_t v159 = *(void *)(v0 + 120);
  int v160 = *(uint64_t **)(v159 + 24);
  int v161 = *(uint64_t **)(v159 + 32);
  if (v160 != v161)
  {
    uint64_t v162 = 0;
    uint64_t v163 = 0;
    unint64_t v164 = 0;
    uint64_t v165 = 0;
    v403[0] = 0u;
    long long v402 = 0u;
    *(_OWORD *)std::string __p = 0u;
    do
    {
      uint64_t v166 = *v160;
      if (v165 == v164) {
        uint64_t v167 = 0;
      }
      else {
        uint64_t v167 = 32 * (v165 - v164) - 1;
      }
      unint64_t v168 = v163 + v162;
      if (v167 == v163 + v162)
      {
        sub_1CBF7BE74((uint64_t)__p);
        unint64_t v164 = (char *)__p[1];
        uint64_t v165 = (unsigned char *)v402;
        uint64_t v162 = *((void *)&v403[0] + 1);
        uint64_t v163 = *(void *)&v403[0];
        unint64_t v168 = *(void *)&v403[0] + *((void *)&v403[0] + 1);
      }
      unint64_t v169 = (void *)(*(void *)&v164[(v168 >> 5) & 0x7FFFFFFFFFFFFF8] + 16 * v168);
      *unint64_t v169 = v166;
      v169[1] = 0;
      *((void *)&v403[0] + 1) = ++v162;
      ++v160;
    }
    while (v160 != v161);
    if (v162)
    {
      uint64_t v170 = (uint64_t *)(v0 + 88);
      do
      {
        uint64_t v171 = (uint64_t *)(*(void *)((char *)__p[1] + ((*(void *)&v403[0] >> 5) & 0x7FFFFFFFFFFFFF8))
                         + 16 * LOBYTE(v403[0]));
        int64_t v173 = (uint64_t **)*v171;
        uint64_t v172 = v171[1];
        *((void *)&v403[0] + 1) = v162 - 1;
        if (++*(void *)&v403[0] >= 0x200uLL)
        {
          operator delete(*(void **)__p[1]);
          __p[1] = (char *)__p[1] + 8;
          *(void *)&v403[0] -= 256;
        }
        LODWORD(v376) = sub_1CBF7A45C(v0, *v173[4]);
        unint64_t v174 = operator new(0xC0uLL);
        *unint64_t v174 = 0;
        v174[1] = 0;
        uint64_t v175 = sub_1CBF7C050((uint64_t)(v174 + 2), v172, (int *)&v376);
        uint64_t v176 = *(void *)(v0 + 88);
        *unint64_t v174 = v176;
        v174[1] = v170;
        *(void *)(v176 + 8) = v174;
        *(void *)(v0 + 88) = v174;
        ++*(void *)(v0 + 104);
        *(void *)(*(void *)(v0 + 64) + 24 * v376 + 8) = v175;
        uint64_t v177 = v173[1];
        BOOL v178 = v173[2];
        uint64_t v162 = *((void *)&v403[0] + 1);
        if (v177 != v178)
        {
          int v179 = (unsigned char *)v402;
          int64_t v180 = (char *)__p[1];
          uint64_t v181 = *(void *)&v403[0];
          do
          {
            uint64_t v182 = *v177;
            uint64_t v183 = *v170;
            if (v179 == v180) {
              uint64_t v184 = 0;
            }
            else {
              uint64_t v184 = 32 * (v179 - v180) - 1;
            }
            unint64_t v185 = v181 + v162;
            if (v184 == v181 + v162)
            {
              sub_1CBF7BE74((uint64_t)__p);
              int64_t v180 = (char *)__p[1];
              int v179 = (unsigned char *)v402;
              uint64_t v162 = *((void *)&v403[0] + 1);
              uint64_t v181 = *(void *)&v403[0];
              unint64_t v185 = *(void *)&v403[0] + *((void *)&v403[0] + 1);
            }
            unint64_t v186 = (void *)(*(void *)&v180[(v185 >> 5) & 0x7FFFFFFFFFFFFF8] + 16 * v185);
            *unint64_t v186 = v182;
            v186[1] = v183 + 16;
            *((void *)&v403[0] + 1) = ++v162;
            ++v177;
          }
          while (v177 != v178);
        }
      }
      while (v162);
    }
    uint64_t v188 = *(void *)(v0 + 136);
    uint64_t v187 = *(void *)(v0 + 144);
    if (v187 != v188)
    {
      for (unint64_t i = 0; i < (v187 - v188) >> 3; ++i)
      {
        uint64_t v190 = *(void *)(v0 + 64) + 24 * i;
        unint64_t v192 = (uint64_t *)(v190 + 8);
        unint64_t v191 = *(uint64_t **)(v190 + 8);
        if (!v191)
        {
LABEL_377:
          uint64_t v193 = *(uint64_t **)(v0 + 120);
          int v194 = *((_DWORD *)v193 + 4);
          if (v194)
          {
            uint64_t v195 = *(void *)(v188 + 8 * i);
            uint64_t v196 = *v193;
            unsigned int v197 = v194 - 1;
            uint64_t v198 = ((v195 >> 4) ^ (v195 >> 9)) & (v194 - 1);
            uint64_t v199 = *(void *)(v196 + 16 * v198);
            if (v195 != v199)
            {
              int v200 = 1;
              while (v199 != -4096)
              {
                int v201 = v198 + v200++;
                uint64_t v198 = v201 & v197;
                uint64_t v199 = *(void *)(v196 + 16 * v198);
                if (v195 == v199) {
                  goto LABEL_382;
                }
              }
              continue;
            }
LABEL_382:
            uint64_t v202 = *(void *)(v196 + 16 * v198 + 8);
            if (v202)
            {
              unsigned int v203 = sub_1CBF7A45C(v0, **(void **)(v202 + 32));
              uint64_t v204 = *(void *)(v0 + 64);
              uint64_t v205 = v204 + 24 * v203;
              *(void *)(v204 + 24 * i + 8) = *(void *)(v205 + 8);
              uint64_t v206 = *(void *)(v205 + 8);
              char v207 = (void *)(v206 + 96);
              unsigned int v209 = (_DWORD *)(v206 + 104);
              unint64_t v208 = *(unsigned int *)(v206 + 104);
              unint64_t v210 = *(unsigned int *)(v206 + 108);
LABEL_384:
              if (v208 >= v210) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(_DWORD *)(*v207 + 4 * v208) = i;
              ++*v209;
              uint64_t v188 = *(void *)(v0 + 136);
              uint64_t v187 = *(void *)(v0 + 144);
              continue;
            }
          }
          continue;
        }
        unint64_t v211 = *((unsigned int *)v191 + 3);
        unsigned int v212 = (unsigned int *)v191[12];
        if (v211 >= 2)
        {
          unsigned int v213 = *(_DWORD *)v190;
          unsigned int v228 = (unsigned int *)v191[12];
          unint64_t v229 = *((unsigned int *)v191 + 3);
          do
          {
            unint64_t v230 = v229 >> 1;
            unsigned int v231 = &v228[v229 >> 1];
            unsigned int v233 = *v231;
            uint64_t v232 = v231 + 1;
            v229 += ~(v229 >> 1);
            if (v233 < v213) {
              unsigned int v228 = v232;
            }
            else {
              unint64_t v229 = v230;
            }
          }
          while (v229);
          uint64_t v234 = &v212[v211];
          if (v228 == v234 || v213 < *v228) {
            goto LABEL_377;
          }
          unsigned int v235 = (unsigned int *)v191[12];
          unint64_t v236 = *((unsigned int *)v191 + 3);
          do
          {
            unint64_t v237 = v236 >> 1;
            unint64_t v238 = &v235[v236 >> 1];
            unsigned int v240 = *v238;
            unsigned int v239 = v238 + 1;
            v236 += ~(v236 >> 1);
            if (v240 < v213) {
              unsigned int v235 = v239;
            }
            else {
              unint64_t v236 = v237;
            }
          }
          while (v236);
          if (v235 == v234 || v213 < *v235) {
            goto LABEL_393;
          }
          do
          {
            unint64_t v241 = v211 >> 1;
            v242 = &v212[v211 >> 1];
            unsigned int v244 = *v242;
            unsigned int v243 = v242 + 1;
            v211 += ~(v211 >> 1);
            if (v244 < v213) {
              unsigned int v212 = v243;
            }
            else {
              unint64_t v211 = v241;
            }
          }
          while (v211);
          if (v212 == v234 || v213 < *v212) {
            goto LABEL_392;
          }
        }
        else
        {
          unsigned int v213 = *(_DWORD *)v190;
          if (v213 != *v212) {
            goto LABEL_377;
          }
        }
        uint64_t v214 = *v191;
        if (!*v191) {
          continue;
        }
        uint64_t v215 = *(unsigned int *)(v214 + 12);
        if (v215 < 2)
        {
LABEL_392:
          unint64_t v192 = v191;
          goto LABEL_393;
        }
        long long v251 = *(unsigned int **)(v214 + 96);
        unint64_t v252 = *(unsigned int *)(v214 + 12);
        do
        {
          unint64_t v253 = v252 >> 1;
          v254 = &v251[v252 >> 1];
          unsigned int v256 = *v254;
          long long v255 = v254 + 1;
          v252 += ~(v252 >> 1);
          if (v256 < v213) {
            long long v251 = v255;
          }
          else {
            unint64_t v252 = v253;
          }
        }
        while (v252);
        uint64_t v257 = *(void *)(v214 + 96) + 4 * v215;
        unint64_t v192 = v191;
        if (v251 != (unsigned int *)v257)
        {
          if (v213 >= *v251) {
            unint64_t v192 = (uint64_t *)*v191;
          }
          else {
            unint64_t v192 = v191;
          }
        }
LABEL_393:
        uint64_t v216 = *v192;
        if (*v192)
        {
          unsigned int v209 = (_DWORD *)(v216 + 104);
          unint64_t v208 = *(unsigned int *)(v216 + 104);
          char v207 = (void *)(v216 + 96);
          unint64_t v210 = *(unsigned int *)(v216 + 108);
          goto LABEL_384;
        }
      }
    }
    unsigned int v217 = (void **)__p[1];
    unsigned int v218 = (void **)v402;
    *((void *)&v403[0] + 1) = 0;
    unint64_t v219 = v402 - (unint64_t)__p[1];
    if ((unint64_t)v402 - (unint64_t)__p[1] >= 0x11)
    {
      do
      {
        operator delete(*v217);
        unsigned int v218 = (void **)v402;
        unsigned int v217 = (void **)((char *)__p[1] + 8);
        __p[1] = v217;
        unint64_t v219 = v402 - (void)v217;
      }
      while ((void)v402 - (void)v217 > 0x10uLL);
    }
    unint64_t v220 = v219 >> 3;
    if (v220 == 1)
    {
      uint64_t v221 = 128;
    }
    else
    {
      if (v220 != 2)
      {
LABEL_399:
        if (v217 != v218)
        {
          do
          {
            uint64_t v222 = *v217++;
            operator delete(v222);
          }
          while (v217 != v218);
          if ((void *)v402 != __p[1]) {
            *(void *)&long long v402 = v402 + (((unint64_t)__p[1] - v402 + 7) & 0xFFFFFFFFFFFFFFF8);
          }
        }
        if (__p[0]) {
          operator delete(__p[0]);
        }
        goto LABEL_405;
      }
      uint64_t v221 = 256;
    }
    *(void *)&v403[0] = v221;
    goto LABEL_399;
  }
LABEL_405:
  uint64_t v223 = v0 + 88;
  uint64_t v224 = *(uint64_t **)(v0 + 96);
  if ((uint64_t *)(v0 + 88) != v224)
  {
    unsigned int v225 = (uint64_t *)(v0 + 88);
    do
    {
      if ((sub_1CBF7C250((uint64_t *)v0, *v225 + 16) & 1) == 0) {
        sub_1CD45E3EC(v0, *v225 + 16, v225);
      }
      unsigned int v225 = (uint64_t *)*v225;
    }
    while (v225 != v224);
  }
  if ((sub_1CBF7CE4C((void *)v0) & 1) == 0) {
    sub_1CD45E3EC(v0, 0, *(uint64_t **)(v0 + 96));
  }
  llvm::BlockFrequencyInfoImplBase::unwrapLoops((void *)v0);
  if (byte_1EBD02E18)
  {
    llvm::Function::getEntryCount(*(uint64_t ****)(v0 + 128), 0, (uint64_t)__p);
    if ((_BYTE)v402)
    {
      while (v223 != *(void *)(v0 + 96))
      {
        uint64_t v223 = *(void *)v223;
        if (*(_DWORD *)(v223 + 28) >= 2u)
        {
          sub_1CD45E088(v0);
          break;
        }
      }
    }
  }
  llvm::BlockFrequencyInfoImplBase::finalizeMetrics((llvm::BlockFrequencyInfoImplBase *)v0);
  if (byte_1EBD02D58)
  {
    for (uint64_t j = *(void *)(v260 + 80); j != v260 + 72; uint64_t j = *(void *)(j + 8))
    {
      if (j) {
        uint64_t v259 = j - 24;
      }
      else {
        uint64_t v259 = 0;
      }
      __p[0] = 0;
      if ((sub_1CBF7A634(*(void *)(v0 + 160), *(_DWORD *)(v0 + 176), v259, __p) & 1) == 0) {
        sub_1CBF7889C(v0, v259, 0);
      }
    }
  }
}

uint64_t llvm::BlockFrequencyInfo::getBlockFreq(llvm::BlockFrequencyInfo *this, const llvm::BasicBlock *a2)
{
  uint64_t v2 = *(void *)this;
  if (!*(void *)this) {
    return 0;
  }
  unsigned int v3 = sub_1CBF7A45C(*(void *)this, (uint64_t)a2);
  if (v3 == -1) {
    return 0;
  }
  else {
    return *(void *)(*(void *)(v2 + 8) + 24 * v3 + 16);
  }
}

uint64_t llvm::BlockFrequencyInfo::getFunction(llvm::BlockFrequencyInfo *this)
{
  if (*(void *)this) {
    return *(void *)(*(void *)this + 128);
  }
  else {
    return 0;
  }
}

void llvm::BlockFrequencyInfo::setBlockFreq(llvm::BlockFrequencyInfo *this, const llvm::BasicBlock *a2, uint64_t a3)
{
}

void sub_1CBF7889C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = a1 + 160;
  uint64_t v6 = *(void *)(a1 + 160);
  int v8 = *(_DWORD *)(a1 + 176);
  unsigned int v9 = a2 >> 4;
  if (v8)
  {
    int v10 = v8 - 1;
    unsigned int v11 = v10 & (v9 ^ (a2 >> 9));
    uint64_t v12 = *(void *)(v6 + 56 * v11);
    if (v12 == a2)
    {
LABEL_6:
      unsigned int v15 = (void *)(a1 + 8);
      unsigned int v16 = sub_1CBF7A45C(a1, a2);
      goto LABEL_7;
    }
    int v13 = 1;
    while (v12 != -4096)
    {
      unsigned int v14 = v11 + v13++;
      unsigned int v11 = v14 & v10;
      uint64_t v12 = *(void *)(v6 + 56 * v11);
      if (v12 == a2) {
        goto LABEL_6;
      }
    }
  }
  unsigned int v15 = (void *)(a1 + 8);
  unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
  uint64_t v18 = 2;
  uint64_t v88 = 2;
  uint64_t v89 = 0;
  BOOL v90 = (int32x2_t ****)a2;
  if (a2 == -8192 || a2 == -4096)
  {
    int v19 = (int32x2_t ****)a2;
  }
  else
  {
    int v19 = (int32x2_t ****)a2;
    if (a2)
    {
      llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v88);
      uint64_t v18 = v88;
      int v19 = v90;
    }
  }
  v87[1] = (uint64_t)&unk_1F26010A0;
  uint64_t v91 = a1;
  int v92 = v17;
  unint64_t v94 = v18 & 6;
  uint64_t v95 = 0;
  uint64_t v96 = v19;
  uint64_t v20 = a1;
  if (v19 != (int32x2_t ****)-8192)
  {
    uint64_t v20 = a1;
    if (v19 != (int32x2_t ****)-4096)
    {
      uint64_t v20 = a1;
      if (v19)
      {
        uint64_t v95 = *(unint64_t **)(v18 & 0xFFFFFFFFFFFFFFF8);
        *(void *)(v18 & 0xFFFFFFFFFFFFFFF8) = &v94;
        unint64_t v94 = v18 & 0xFFFFFFFFFFFFFFFELL;
        if (v95) {
          *uint64_t v95 = *v95 & 7 | (unint64_t)&v95;
        }
        uint64_t v20 = v91;
      }
    }
  }
  uint64_t v93 = &unk_1F26010A0;
  uint64_t v97 = v20;
  v87[0] = a2;
  int v21 = *(_DWORD *)(a1 + 176);
  if (!v21)
  {
    uint64_t v51 = 0;
LABEL_61:
    int v25 = sub_1CBF7B6D8(v7, v87, v51);
    *int v25 = a2;
    *((_DWORD *)v25 + 2) = -1;
    v25[5] = 0;
    v25[6] = 0;
    v25[3] = 2;
    v25[4] = 0;
    void v25[2] = (uint64_t)&unk_1F26010A0;
    int v31 = v92;
    goto LABEL_29;
  }
  uint64_t v22 = *(void *)(a1 + 160);
  int v23 = v21 - 1;
  unsigned int v24 = v23 & (v9 ^ (a2 >> 9));
  int v25 = (uint64_t *)(v22 + 56 * v24);
  uint64_t v26 = *v25;
  if (*v25 != a2)
  {
    unsigned int v27 = 0;
    int v28 = 1;
    while (v26 != -4096)
    {
      if (v27) {
        BOOL v29 = 0;
      }
      else {
        BOOL v29 = v26 == -8192;
      }
      if (v29) {
        unsigned int v27 = v25;
      }
      unsigned int v30 = v24 + v28++;
      unsigned int v24 = v30 & v23;
      int v25 = (uint64_t *)(v22 + 56 * v24);
      uint64_t v26 = *v25;
      if (*v25 == a2) {
        goto LABEL_28;
      }
    }
    if (v27) {
      uint64_t v51 = v27;
    }
    else {
      uint64_t v51 = v25;
    }
    goto LABEL_61;
  }
LABEL_28:
  int v31 = v17;
LABEL_29:
  *((_DWORD *)v25 + 2) = v31;
  unsigned int v32 = (int32x2_t ****)v25[5];
  int v33 = v96;
  if (v32 == v96)
  {
    int v33 = (int32x2_t ****)v25[5];
  }
  else
  {
    BOOL v34 = v32 == (int32x2_t ****)-4096 || v32 == 0;
    if (!v34 && v32 != (int32x2_t ****)-8192)
    {
      unint64_t v67 = v25[3] & 0xFFFFFFFFFFFFFFF8;
      *(void *)unint64_t v67 = v25[4];
      unsigned int v68 = (unint64_t *)v25[4];
      if (v68)
      {
        *unsigned int v68 = *v68 & 7 | v67;
      }
      else
      {
        uint64_t v69 = v25[5];
        unsigned int v70 = ***(int32x2_t ****)v69;
        unint64_t v71 = (unint64_t)v70[303];
        if (v71 <= v67)
        {
          uint64_t v72 = v70[305].u32[0];
          if (v71 + 16 * v72 > v67)
          {
            unsigned int v73 = v72 - 1;
            LODWORD(v74) = v73 & ((v69 >> 4) ^ (v69 >> 9));
            uint64_t v75 = (uint64_t *)(v71 + 16 * v74);
            uint64_t v76 = *v75;
            if (v69 == *v75)
            {
LABEL_91:
              *uint64_t v75 = -8192;
              v70[304] = vadd_s32(v70[304], (int32x2_t)0x1FFFFFFFFLL);
              uint64_t v69 = v25[5];
            }
            else
            {
              int v77 = 1;
              while (v76 != -4096)
              {
                int v78 = v74 + v77++;
                uint64_t v74 = v78 & v73;
                uint64_t v76 = *(void *)(v71 + 16 * v74);
                if (v69 == v76)
                {
                  uint64_t v75 = (uint64_t *)(v71 + 16 * v74);
                  goto LABEL_91;
                }
              }
            }
            *(unsigned char *)(v69 + 17) &= ~1u;
          }
        }
      }
      int v33 = v96;
    }
    v25[5] = (uint64_t)v33;
    if (v33 != (int32x2_t ****)-4096 && v33 != (int32x2_t ****)-8192 && v33 != 0)
    {
      unint64_t v36 = v94;
      int v37 = (void *)(v94 & 0xFFFFFFFFFFFFFFF8);
      v25[4] = *(void *)(v94 & 0xFFFFFFFFFFFFFFF8);
      *int v37 = v25 + 3;
      v25[3] = v36 & 0xFFFFFFFFFFFFFFF8 | v25[3] & 7;
      unsigned int v38 = (unint64_t *)v25[4];
      if (v38) {
        *unsigned int v38 = *v38 & 7 | (unint64_t)(v25 + 4);
      }
      int v33 = v96;
    }
  }
  v25[6] = v97;
  if (v33 != (int32x2_t ****)-8192 && v33 != (int32x2_t ****)-4096 && v33 != 0)
  {
    unint64_t v40 = v94 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v94 & 0xFFFFFFFFFFFFFFF8) = v95;
    if (v95)
    {
      *uint64_t v95 = *v95 & 7 | v40;
    }
    else
    {
      int v41 = v96;
      unsigned int v42 = ***v96;
      unint64_t v43 = (unint64_t)v42[303];
      if (v43 <= v40)
      {
        uint64_t v44 = v42[305].u32[0];
        if (v43 + 16 * v44 > v40)
        {
          unsigned int v45 = v44 - 1;
          LODWORD(v46) = v45 & ((v96 >> 4) ^ (v96 >> 9));
          uint64_t v47 = (int32x2_t *****)(v43 + 16 * v46);
          BOOL v48 = *v47;
          if (v96 == *v47)
          {
LABEL_56:
            *uint64_t v47 = (int32x2_t ****)-8192;
            v42[304] = vadd_s32(v42[304], (int32x2_t)0x1FFFFFFFFLL);
            int v41 = v96;
          }
          else
          {
            int v49 = 1;
            while (v48 != (int32x2_t ****)-4096)
            {
              int v50 = v46 + v49++;
              uint64_t v46 = v50 & v45;
              BOOL v48 = *(int32x2_t *****)(v43 + 16 * v46);
              if (v96 == v48)
              {
                uint64_t v47 = (int32x2_t *****)(v43 + 16 * v46);
                goto LABEL_56;
              }
            }
          }
          *((unsigned char *)v41 + 17) &= ~1u;
        }
      }
    }
  }
  if (v90 != (int32x2_t ****)-8192 && v90 != (int32x2_t ****)-4096 && v90 != 0)
  {
    unint64_t v53 = v88 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v88 & 0xFFFFFFFFFFFFFFF8) = v89;
    if (v89)
    {
      *uint64_t v89 = *v89 & 7 | v53;
    }
    else
    {
      uint64_t v54 = v90;
      uint64_t v55 = ***v90;
      unint64_t v56 = (unint64_t)v55[303];
      if (v56 <= v53)
      {
        uint64_t v57 = v55[305].u32[0];
        if (v56 + 16 * v57 > v53)
        {
          unsigned int v58 = v57 - 1;
          LODWORD(v59) = v58 & ((v90 >> 4) ^ (v90 >> 9));
          uint64_t v60 = (int32x2_t *****)(v56 + 16 * v59);
          unsigned int v61 = *v60;
          if (v90 == *v60)
          {
LABEL_76:
            *uint64_t v60 = (int32x2_t ****)-8192;
            v55[304] = vadd_s32(v55[304], (int32x2_t)0x1FFFFFFFFLL);
            uint64_t v54 = v90;
          }
          else
          {
            int v62 = 1;
            while (v61 != (int32x2_t ****)-4096)
            {
              int v63 = v59 + v62++;
              uint64_t v59 = v63 & v58;
              unsigned int v61 = *(int32x2_t *****)(v56 + 16 * v59);
              if (v90 == v61)
              {
                uint64_t v60 = (int32x2_t *****)(v56 + 16 * v59);
                goto LABEL_76;
              }
            }
          }
          *((unsigned char *)v54 + 17) &= ~1u;
        }
      }
    }
  }
  int v65 = *(void **)(a1 + 16);
  unint64_t v64 = *(void *)(a1 + 24);
  if ((unint64_t)v65 >= v64)
  {
    uint64_t v79 = (void *)*v15;
    unint64_t v80 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v65 - *v15) >> 3);
    unint64_t v81 = v80 + 1;
    if (v80 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v82 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64 - (void)v79) >> 3);
    if (2 * v82 > v81) {
      unint64_t v81 = 2 * v82;
    }
    if (v82 >= 0x555555555555555) {
      unint64_t v83 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v83 = v81;
    }
    if (v83)
    {
      if (v83 > 0xAAAAAAAAAAAAAAALL) {
        sub_1CB833614();
      }
      uint64_t v84 = (char *)operator new(24 * v83);
    }
    else
    {
      uint64_t v84 = 0;
    }
    int v85 = &v84[24 * v80];
    unsigned int v66 = v85 + 24;
    *(void *)int v85 = 0;
    *((void *)v85 + 1) = 0;
    *((void *)v85 + 2) = 0;
    if (v65 != v79)
    {
      do
      {
        long long v86 = *(_OWORD *)(v65 - 3);
        *((void *)v85 - 1) = *(v65 - 1);
        *(_OWORD *)(v85 - 24) = v86;
        v85 -= 24;
        v65 -= 3;
      }
      while (v65 != v79);
      int v65 = (void *)*v15;
    }
    *(void *)(a1 + 8) = v85;
    *(void *)(a1 + 16) = v66;
    *(void *)(a1 + 24) = &v84[24 * v83];
    if (v65) {
      operator delete(v65);
    }
  }
  else
  {
    unsigned int v66 = v65 + 3;
    *int v65 = 0;
    v65[1] = 0;
    v65[2] = 0;
  }
  *(void *)(a1 + 16) = v66;
  unsigned int v16 = v17;
LABEL_7:
  *(void *)(*v15 + 24 * v16 + 16) = a3;
}

void llvm::BlockFrequencyInfo::setBlockFreqAndScale()
{
  int v0 = 128;
  operator new[]();
}

uint64_t llvm::BlockFrequencyInfo::getBPI(llvm::BlockFrequencyInfo *this)
{
  if (*(void *)this) {
    return *(void *)(*(void *)this + 112);
  }
  else {
    return 0;
  }
}

llvm::ScaledNumberBase *llvm::BlockFrequencyInfo::printBlockFreq(uint64_t *a1, llvm::ScaledNumberBase *a2, uint64_t a3)
{
  uint64_t v5 = a3;
  uint64_t v3 = *a1;
  if (v3) {
    return llvm::BlockFrequencyInfoImplBase::printBlockFreq(v3, a2, &v5);
  }
  return a2;
}

llvm::ScaledNumberBase *llvm::BlockFrequencyInfo::printBlockFreq(llvm::BlockFrequencyInfo *this, llvm::raw_ostream *a2, const llvm::BasicBlock *a3)
{
  uint64_t v4 = *(void *)this;
  if (!*(void *)this) {
    return a2;
  }
  unsigned int v6 = sub_1CBF7A45C(*(void *)this, (uint64_t)a3);
  if (v6 == -1)
  {
    uint64_t v7 = 0;
    __int16 v8 = 0;
  }
  else
  {
    uint64_t v9 = *(void *)(v4 + 8) + 24 * v6;
    uint64_t v7 = *(llvm::raw_ostream **)v9;
    __int16 v8 = *(_WORD *)(v9 + 8);
  }

  return llvm::ScaledNumberBase::print(a2, v7, v8, 64, 0xAu);
}

llvm *llvm::BlockFrequencyInfo::verifyMatch(llvm *this, llvm::BlockFrequencyInfo *a2)
{
  uint64_t v2 = *(void *)this;
  if (*(void *)this)
  {
    uint64_t v3 = *(void *)a2;
    uint64_t v111 = 0;
    uint64_t v112 = 0;
    unsigned int v113 = 0;
    uint64_t v108 = 0;
    uint64_t v109 = 0;
    int v110 = 0;
    uint64_t v4 = *(void *)(v2 + 160);
    uint64_t v5 = *(unsigned int *)(v2 + 176);
    uint64_t v6 = v4 + 56 * v5;
    if (*(_DWORD *)(v2 + 168))
    {
      if (v5)
      {
        uint64_t v7 = 56 * v5;
        uint64_t v8 = *(void *)(v2 + 160);
        while ((*(void *)v8 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v8 += 56;
          v7 -= 56;
          if (!v7) {
            goto LABEL_7;
          }
        }
      }
      else
      {
        uint64_t v8 = *(void *)(v2 + 160);
      }
    }
    else
    {
LABEL_7:
      uint64_t v8 = v4 + 56 * v5;
    }
    uint64_t v9 = v4 + 56 * v5;
LABEL_10:
    while (v8 != v9)
    {
      long long __dst = 0;
      long long __dst = *(void ***)v8;
      if (__dst)
      {
        this = (llvm *)sub_1CBF7FBBC((uint64_t)&v111, (uint64_t *)&__dst);
        *((_DWORD *)this + 2) = *(_DWORD *)(v8 + 8);
      }
      uint64_t v10 = v8 + 56;
      uint64_t v8 = v6;
      if (v10 != v6)
      {
        uint64_t v8 = v10;
        while ((*(void *)v8 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v8 += 56;
          if (v8 == v6)
          {
            uint64_t v8 = v6;
            goto LABEL_10;
          }
        }
      }
    }
    uint64_t v11 = *(void *)(v3 + 160);
    uint64_t v12 = *(unsigned int *)(v3 + 176);
    uint64_t v13 = v11 + 56 * v12;
    if (*(_DWORD *)(v3 + 168))
    {
      if (v12)
      {
        uint64_t v14 = 56 * v12;
        uint64_t v15 = *(void *)(v3 + 160);
        while ((*(void *)v15 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v15 += 56;
          v14 -= 56;
          if (!v14) {
            goto LABEL_23;
          }
        }
      }
      else
      {
        uint64_t v15 = *(void *)(v3 + 160);
      }
    }
    else
    {
LABEL_23:
      uint64_t v15 = v11 + 56 * v12;
    }
    uint64_t v16 = v11 + 56 * v12;
    uint64_t v103 = (void *)v2;
    if (v15 == v16)
    {
      unsigned int v19 = v112;
      if (!v112)
      {
        uint64_t v20 = v111;
        unsigned int v21 = v113;
        uint64_t v22 = v111 + 16 * v113;
        goto LABEL_43;
      }
      unsigned int v18 = 0;
    }
    else
    {
      do
      {
        long long __dst = 0;
        long long __dst = *(void ***)v15;
        if (__dst)
        {
          this = (llvm *)sub_1CBF7FBBC((uint64_t)&v108, (uint64_t *)&__dst);
          *((_DWORD *)this + 2) = *(_DWORD *)(v15 + 8);
        }
        uint64_t v17 = v15 + 56;
        uint64_t v15 = v13;
        if (v17 != v13)
        {
          uint64_t v15 = v17;
          while ((*(void *)v15 | 0x1000) == 0xFFFFFFFFFFFFF000)
          {
            v15 += 56;
            if (v15 == v13)
            {
              uint64_t v15 = v13;
              break;
            }
          }
        }
      }
      while (v15 != v16);
      unsigned int v18 = v109;
      unsigned int v19 = v112;
      if (v112 == v109)
      {
        uint64_t v20 = v111;
        unsigned int v21 = v113;
        uint64_t v22 = v111 + 16 * v113;
        if (v109)
        {
          if (v113)
          {
            uint64_t v23 = 0;
            while ((*(void *)(v111 + v23) | 0x1000) == 0xFFFFFFFFFFFFF000)
            {
              v23 += 16;
              if (16 * v113 == v23) {
                goto LABEL_43;
              }
            }
            uint64_t v24 = v111 + v23;
          }
          else
          {
            uint64_t v24 = v111;
          }
          goto LABEL_44;
        }
LABEL_43:
        uint64_t v24 = v22;
LABEL_44:
        uint64_t v25 = v20 + 16 * v21;
        if (v24 == v25) {
          goto LABEL_133;
        }
        char v26 = 1;
        uint64_t v102 = v3;
        while (1)
        {
          uint64_t v107 = 0;
          unsigned int v27 = *(uint64_t ****)v24;
          uint64_t v107 = *(uint64_t ****)v24;
          unint64_t v28 = *(unsigned int *)(v24 + 8);
          if (!v110) {
            goto LABEL_95;
          }
          unsigned int v29 = (v27 >> 4) ^ (v27 >> 9);
          unsigned int v30 = (v110 - 1) & v29;
          int v31 = *(uint64_t ****)(v108 + 16 * v30);
          if (v27 != v31) {
            break;
          }
LABEL_48:
          this = (llvm *)sub_1CBF7FBBC((uint64_t)&v108, (uint64_t *)&v107);
          uint64_t v32 = v103[1] + 24 * v28;
          uint64_t v35 = *(void *)(v32 + 16);
          BOOL v34 = (unint64_t *)(v32 + 16);
          uint64_t v33 = v35;
          uint64_t v36 = *(void *)(v3 + 8) + 24 * *((unsigned int *)this + 2);
          uint64_t v38 = *(void *)(v36 + 16);
          int v37 = (unint64_t *)(v36 + 16);
          if (v33 != v38)
          {
            unint64_t v40 = llvm::dbgs(this);
            int v41 = v40;
            unsigned int v42 = (void *)*((void *)v40 + 4);
            if (*((void *)v40 + 3) - (void)v42 > 0xEuLL)
            {
              qmemcpy(v42, "Freq mismatch: ", 15);
              *((void *)v40 + 4) += 15;
            }
            else
            {
              llvm::raw_ostream::write(v40, "Freq mismatch: ", 0xFuLL);
            }
            if ((*((unsigned char *)v27 + 23) & 0x10) == 0)
            {
              size_t v52 = 0;
              HIBYTE(v106) = 0;
              p_dst = (void **)&__dst;
              goto LABEL_74;
            }
            uint64_t v43 = ***v27;
            uint64_t v44 = *(void *)(v43 + 152);
            uint64_t v45 = *(unsigned int *)(v43 + 168);
            if (!v45) {
              goto LABEL_65;
            }
            LODWORD(v46) = (v45 - 1) & v29;
            uint64_t v47 = (uint64_t ****)(v44 + 16 * v46);
            BOOL v48 = *v47;
            if (*v47 != v27)
            {
              int v49 = 1;
              while (v48 != (uint64_t ***)-4096)
              {
                int v50 = v46 + v49++;
                uint64_t v46 = v50 & (v45 - 1);
                BOOL v48 = *(uint64_t ****)(v44 + 16 * v46);
                if (v48 == v27)
                {
                  uint64_t v47 = (uint64_t ****)(v44 + 16 * v46);
                  goto LABEL_66;
                }
              }
LABEL_65:
              uint64_t v47 = (uint64_t ****)(v44 + 16 * v45);
            }
LABEL_66:
            uint64_t v51 = (unint64_t *)v47[1];
            unint64_t v54 = *v51;
            unint64_t v53 = v51 + 2;
            size_t v52 = v54;
            if (v54 > 0x7FFFFFFFFFFFFFF7) {
              goto LABEL_154;
            }
            if (v52 >= 0x17)
            {
              uint64_t v56 = (v52 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v52 | 7) != 0x17) {
                uint64_t v56 = v52 | 7;
              }
              uint64_t v57 = v56 + 1;
              p_dst = (void **)operator new(v56 + 1);
              size_t v105 = v52;
              int64_t v106 = v57 | 0x8000000000000000;
              long long __dst = p_dst;
            }
            else
            {
              HIBYTE(v106) = v52;
              p_dst = (void **)&__dst;
              if (!v52)
              {
LABEL_74:
                *((unsigned char *)p_dst + v52) = 0;
                if (v106 >= 0) {
                  unsigned int v58 = (const char *)&__dst;
                }
                else {
                  unsigned int v58 = (const char *)__dst;
                }
                if (v106 >= 0) {
                  size_t v59 = HIBYTE(v106) & 0x7F;
                }
                else {
                  size_t v59 = v105;
                }
                llvm::raw_ostream::write(v41, v58, v59);
                uint64_t v60 = (unsigned char *)*((void *)v41 + 4);
                if (*((unsigned char **)v41 + 3) == v60)
                {
                  llvm::raw_ostream::write(v41, " ", 1uLL);
                }
                else
                {
                  *uint64_t v60 = 32;
                  ++*((void *)v41 + 4);
                }
                uint64_t v3 = v102;
                sub_1CD098D14(v41, *v34, 0, 0, 0);
                unsigned int v61 = (_DWORD *)*((void *)v41 + 4);
                if (*((void *)v41 + 3) - (void)v61 > 3uLL)
                {
                  *unsigned int v61 = 544437792;
                  *((void *)v41 + 4) += 4;
                }
                else
                {
                  llvm::raw_ostream::write(v41, " vs ", 4uLL);
                }
                this = sub_1CD098D14(v41, *v37, 0, 0, 0);
                int v62 = (unsigned char *)*((void *)v41 + 4);
                if (*((unsigned char **)v41 + 3) == v62)
                {
                  int v63 = v41;
                  unint64_t v64 = "\n";
                  size_t v65 = 1;
                  goto LABEL_124;
                }
                *int v62 = 10;
                ++*((void *)v41 + 4);
LABEL_125:
                if (SHIBYTE(v106) < 0) {
                  operator delete(__dst);
                }
                char v26 = 0;
                goto LABEL_49;
              }
            }
            memmove(p_dst, v53, v52);
            goto LABEL_74;
          }
LABEL_49:
          uint64_t v39 = v24 + 16;
          uint64_t v24 = v22;
          if (v39 != v22)
          {
            uint64_t v24 = v39;
            while ((*(void *)v24 | 0x1000) == 0xFFFFFFFFFFFFF000)
            {
              v24 += 16;
              if (v24 == v22)
              {
                uint64_t v24 = v22;
                break;
              }
            }
          }
          if (v24 == v25)
          {
            if (v26) {
              goto LABEL_133;
            }
            goto LABEL_144;
          }
        }
        int v66 = 1;
        while (v31 != (uint64_t ***)-4096)
        {
          unsigned int v67 = v30 + v66++;
          unsigned int v30 = v67 & (v110 - 1);
          int v31 = *(uint64_t ****)(v108 + 16 * v30);
          if (v27 == v31) {
            goto LABEL_48;
          }
        }
LABEL_95:
        unsigned int v68 = llvm::dbgs(this);
        uint64_t v69 = v68;
        uint64_t v70 = *((void *)v68 + 4);
        if ((unint64_t)(*((void *)v68 + 3) - v70) > 5)
        {
          *(_WORD *)(v70 + 4) = 8299;
          *(_DWORD *)uint64_t v70 = 1668246594;
          *((void *)v68 + 4) += 6;
        }
        else
        {
          llvm::raw_ostream::write(v68, "Block ", 6uLL);
        }
        if ((*((unsigned char *)v27 + 23) & 0x10) == 0)
        {
          size_t v80 = 0;
          HIBYTE(v106) = 0;
          unint64_t v83 = (void **)&__dst;
LABEL_114:
          *((unsigned char *)v83 + v80) = 0;
          if (v106 >= 0) {
            long long v86 = (const char *)&__dst;
          }
          else {
            long long v86 = (const char *)__dst;
          }
          if (v106 >= 0) {
            size_t v87 = HIBYTE(v106) & 0x7F;
          }
          else {
            size_t v87 = v105;
          }
          llvm::raw_ostream::write(v69, v86, v87);
          uint64_t v88 = (_DWORD *)*((void *)v69 + 4);
          if (*((void *)v69 + 3) - (void)v88 > 6uLL)
          {
            *(_DWORD *)((char *)v88 + 3) = 544761188;
            *uint64_t v88 = 1684957472;
            *((void *)v69 + 4) += 7;
          }
          else
          {
            llvm::raw_ostream::write(v69, " index ", 7uLL);
          }
          this = sub_1CD098D14(v69, v28, 0, 0, 0);
          uint64_t v89 = (void *)*((void *)v69 + 4);
          if (*((void *)v69 + 3) - (void)v89 > 0x19uLL)
          {
            qmemcpy(v89, " does not exist in Other.\n", 26);
            *((void *)v69 + 4) += 26;
          }
          else
          {
            int v63 = v69;
            unint64_t v64 = " does not exist in Other.\n";
            size_t v65 = 26;
LABEL_124:
            this = llvm::raw_ostream::write(v63, v64, v65);
          }
          goto LABEL_125;
        }
        uint64_t v71 = ***v27;
        uint64_t v72 = *(void *)(v71 + 152);
        uint64_t v73 = *(unsigned int *)(v71 + 168);
        if (v73)
        {
          LODWORD(v74) = (v73 - 1) & ((v27 >> 4) ^ (v27 >> 9));
          uint64_t v75 = (uint64_t ****)(v72 + 16 * v74);
          uint64_t v76 = *v75;
          if (*v75 == v27) {
            goto LABEL_105;
          }
          int v77 = 1;
          while (v76 != (uint64_t ***)-4096)
          {
            int v78 = v74 + v77++;
            uint64_t v74 = v78 & (v73 - 1);
            uint64_t v76 = *(uint64_t ****)(v72 + 16 * v74);
            if (v76 == v27)
            {
              uint64_t v75 = (uint64_t ****)(v72 + 16 * v74);
              goto LABEL_105;
            }
          }
        }
        uint64_t v75 = (uint64_t ****)(v72 + 16 * v73);
LABEL_105:
        uint64_t v79 = (unint64_t *)v75[1];
        unint64_t v82 = *v79;
        unint64_t v81 = v79 + 2;
        size_t v80 = v82;
        if (v82 > 0x7FFFFFFFFFFFFFF7) {
LABEL_154:
        }
          abort();
        if (v80 >= 0x17)
        {
          uint64_t v84 = (v80 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v80 | 7) != 0x17) {
            uint64_t v84 = v80 | 7;
          }
          uint64_t v85 = v84 + 1;
          unint64_t v83 = (void **)operator new(v84 + 1);
          size_t v105 = v80;
          int64_t v106 = v85 | 0x8000000000000000;
          long long __dst = v83;
        }
        else
        {
          HIBYTE(v106) = v80;
          unint64_t v83 = (void **)&__dst;
          if (!v80) {
            goto LABEL_113;
          }
        }
        memmove(v83, v81, v80);
LABEL_113:
        uint64_t v3 = v102;
        goto LABEL_114;
      }
    }
    BOOL v90 = llvm::dbgs(this);
    uint64_t v91 = v90;
    int v92 = (void *)*((void *)v90 + 4);
    if (*((void *)v90 + 3) - (void)v92 > 0x1AuLL)
    {
      qmemcpy(v92, "Number of blocks mismatch: ", 27);
      *((void *)v90 + 4) += 27;
    }
    else
    {
      llvm::raw_ostream::write(v90, "Number of blocks mismatch: ", 0x1BuLL);
    }
    sub_1CD098D14(v91, v19, 0, 0, 0);
    uint64_t v93 = (_DWORD *)*((void *)v91 + 4);
    if (*((void *)v91 + 3) - (void)v93 > 3uLL)
    {
      *uint64_t v93 = 544437792;
      *((void *)v91 + 4) += 4;
    }
    else
    {
      llvm::raw_ostream::write(v91, " vs ", 4uLL);
    }
    this = sub_1CD098D14(v91, v18, 0, 0, 0);
    unint64_t v94 = (unsigned char *)*((void *)v91 + 4);
    if (*((unsigned char **)v91 + 3) == v94)
    {
      this = llvm::raw_ostream::write(v91, "\n", 1uLL);
    }
    else
    {
      *unint64_t v94 = 10;
      ++*((void *)v91 + 4);
    }
LABEL_144:
    uint64_t v95 = llvm::dbgs(this);
    uint64_t v96 = *((void *)v95 + 4);
    if ((unint64_t)(*((void *)v95 + 3) - v96) > 4)
    {
      *(unsigned char *)(v96 + 4) = 10;
      *(_DWORD *)uint64_t v96 = 1936287828;
      *((void *)v95 + 4) += 5;
    }
    else
    {
      uint64_t v95 = llvm::raw_ostream::write(v95, "This\n", 5uLL);
    }
    uint64_t v97 = llvm::dbgs(v95);
    uint64_t v98 = (llvm *)(*(uint64_t (**)(void *, llvm *))(*v103 + 24))(v103, v97);
    int v99 = llvm::dbgs(v98);
    uint64_t v100 = *((void *)v99 + 4);
    if ((unint64_t)(*((void *)v99 + 3) - v100) > 5)
    {
      *(_WORD *)(v100 + 4) = 2674;
      *(_DWORD *)uint64_t v100 = 1701344335;
      *((void *)v99 + 4) += 6;
    }
    else
    {
      int v99 = llvm::raw_ostream::write(v99, "Other\n", 6uLL);
    }
    uint64_t v101 = llvm::dbgs(v99);
    (*(void (**)(uint64_t, llvm *))(*(void *)v3 + 24))(v3, v101);
LABEL_133:
    MEMORY[0x1D25D9CD0](v108, 8);
    return (llvm *)MEMORY[0x1D25D9CD0](v111, 8);
  }
  return this;
}

void sub_1CBF79D60(llvm *a1, llvm::PassRegistry *a2)
{
}

void llvm::BlockFrequencyInfoWrapperPass::~BlockFrequencyInfoWrapperPass(llvm::BlockFrequencyInfoWrapperPass *this)
{
  *(void *)this = &unk_1F2600DE0;
  uint64_t v2 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  llvm::Pass::~Pass(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F2600DE0;
  uint64_t v2 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  llvm::Pass::~Pass(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F2600DE0;
  uint64_t v2 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  llvm::Pass::~Pass(this);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t llvm::BlockFrequencyInfoWrapperPass::releaseMemory(llvm::BlockFrequencyInfoWrapperPass *this)
{
  uint64_t result = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t llvm::BlockFrequencyInfoWrapperPass::runOnFunction(llvm::BlockFrequencyInfoWrapperPass *this, llvm::Function *a2)
{
  uint64_t v4 = (uint64_t *)*((void *)this + 1);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_11:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::BranchProbabilityInfoWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_11;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::BranchProbabilityInfoWrapperPass::ID);
  uint64_t v9 = (uint64_t *)*((void *)this + 1);
  uint64_t v10 = *v9;
  uint64_t v11 = v9[1];
  if (v10 == v11)
  {
LABEL_7:
    uint64_t v12 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v10 != &llvm::LoopInfoWrapperPass::ID)
    {
      v10 += 16;
      if (v10 == v11) {
        goto LABEL_7;
      }
    }
    uint64_t v12 = *(void *)(v10 + 8);
  }
  uint64_t v13 = (const llvm::BranchProbabilityInfo *)(v8 + 32);
  uint64_t v14 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v12 + 96))(v12, &llvm::LoopInfoWrapperPass::ID);
  llvm::BlockFrequencyInfo::calculate((llvm::BlockFrequencyInfoWrapperPass *)((char *)this + 32), a2, v13, (const llvm::LoopInfo *)(v14 + 32));
  return 0;
}

void llvm::BlockFrequencyAnalysis::run(void *a1@<X8>)
{
  *a1 = 0;
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

void sub_1CBF7A064(void *a1)
{
  *a1 = &unk_1F2601070;
  sub_1CBF7A338((uint64_t)(a1 + 20));
  MEMORY[0x1D25D9CD0](a1[20], 8);
  uint64_t v2 = (void *)a1[17];
  if (v2)
  {
    a1[18] = v2;
    operator delete(v2);
  }
  sub_1CBF7A1F4(a1);

  JUMPOUT(0x1D25D9CE0);
}

_DWORD *sub_1CBF7A0E8(_DWORD *result, int a2)
{
  uint64_t v2 = result;
  if (a2)
  {
    unint64_t v3 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    LODWORD(v4) = (((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8)) + 1;
    result[4] = v4;
    uint64_t result = operator new(56 * v4, (std::align_val_t)8uLL);
    *(void *)uint64_t v2 = result;
    *((void *)v2 + 1) = 0;
    uint64_t v5 = v2[4];
    if (v5)
    {
      uint64_t v6 = 56 * v5;
      do
      {
        *(void *)uint64_t result = -4096;
        result += 14;
        v6 -= 56;
      }
      while (v6);
    }
  }
  else
  {
    *(void *)uint64_t result = 0;
    *((void *)result + 1) = 0;
    result[4] = 0;
  }
  return result;
}

void *sub_1CBF7A184(void *a1)
{
  *a1 = &unk_1F2601070;
  sub_1CBF7A338((uint64_t)(a1 + 20));
  MEMORY[0x1D25D9CD0](a1[20], 8);
  uint64_t v2 = (void *)a1[17];
  if (v2)
  {
    a1[18] = v2;
    operator delete(v2);
  }

  return sub_1CBF7A1F4(a1);
}

void *sub_1CBF7A1F4(void *a1)
{
  *a1 = &unk_1F2601168;
  if (a1[13])
  {
    uint64_t v5 = a1 + 11;
    uint64_t v6 = a1[11];
    uint64_t v7 = (uint64_t *)a1[12];
    uint64_t v8 = *v7;
    *(void *)(v8 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v8;
    a1[13] = 0;
    if (v7 != a1 + 11)
    {
      do
      {
        uint64_t v9 = (uint64_t *)v7[1];
        uint64_t v10 = (uint64_t *)v7[18];
        if (v10 != v7 + 20) {
          free(v10);
        }
        uint64_t v11 = (uint64_t *)v7[14];
        if (v11 != v7 + 16) {
          free(v11);
        }
        uint64_t v12 = (uint64_t *)v7[4];
        if (v12 != v7 + 6) {
          free(v12);
        }
        operator delete(v7);
        uint64_t v7 = v9;
      }
      while (v9 != v5);
    }
  }
  uint64_t v2 = (void *)a1[8];
  if (v2)
  {
    a1[9] = v2;
    operator delete(v2);
  }
  if (a1[6])
  {
    uint64_t v14 = a1[4];
    uint64_t v13 = (uint64_t *)a1[5];
    uint64_t v15 = *v13;
    *(void *)(v15 + 8) = *(void *)(v14 + 8);
    **(void **)(v14 + 8) = v15;
    a1[6] = 0;
    if (v13 != a1 + 4)
    {
      do
      {
        uint64_t v16 = (uint64_t *)v13[1];
        operator delete(v13);
        uint64_t v13 = v16;
      }
      while (v16 != a1 + 4);
    }
  }
  unint64_t v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t sub_1CBF7A338(uint64_t result)
{
  unsigned int v1 = *(_DWORD *)(result + 16);
  if (v1)
  {
    uint64_t v2 = *(void **)result;
    uint64_t v3 = *(void *)result + 56 * v1;
    do
    {
      if (*v2 != -4096 && *v2 != -8192)
      {
        uint64_t v4 = v2[5];
        if (v4 != -8192 && v4 != -4096 && v4 != 0)
        {
          unint64_t v6 = v2[3] & 0xFFFFFFFFFFFFFFF8;
          *(void *)unint64_t v6 = v2[4];
          uint64_t v7 = (unint64_t *)v2[4];
          if (v7)
          {
            *uint64_t v7 = *v7 & 7 | v6;
          }
          else
          {
            uint64_t v8 = v2[5];
            uint64_t v9 = ***(int32x2_t ****)v8;
            unint64_t v10 = (unint64_t)v9[303];
            if (v10 <= v6)
            {
              uint64_t v11 = v9[305].u32[0];
              if (v10 + 16 * v11 > v6)
              {
                unsigned int v12 = v11 - 1;
                LODWORD(v13) = v12 & ((v8 >> 4) ^ (v8 >> 9));
                uint64_t v14 = (uint64_t *)(v10 + 16 * v13);
                uint64_t v15 = *v14;
                if (v8 == *v14)
                {
LABEL_20:
                  *uint64_t v14 = -8192;
                  v9[304] = vadd_s32(v9[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v8 = v2[5];
                }
                else
                {
                  int v16 = 1;
                  while (v15 != -4096)
                  {
                    int v17 = v13 + v16++;
                    uint64_t v13 = v17 & v12;
                    uint64_t v15 = *(void *)(v10 + 16 * v13);
                    if (v8 == v15)
                    {
                      uint64_t v14 = (uint64_t *)(v10 + 16 * v13);
                      goto LABEL_20;
                    }
                  }
                }
                *(unsigned char *)(v8 + 17) &= ~1u;
              }
            }
          }
        }
      }
      v2 += 7;
    }
    while (v2 != (void *)v3);
  }
  return result;
}

uint64_t sub_1CBF7A45C(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 176);
  if (!v2)
  {
LABEL_28:
    unint64_t v10 = 0;
    uint64_t v13 = 0;
    unint64_t v28 = 0;
    uint64_t v29 = 0;
    unint64_t v26 = 2;
    unsigned int v27 = 0;
    uint64_t result = 0xFFFFFFFFLL;
    goto LABEL_15;
  }
  uint64_t v3 = *(void *)(a1 + 160);
  int v4 = v2 - 1;
  unsigned int v5 = (v2 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  unint64_t v6 = (uint64_t *)(v3 + 56 * v5);
  uint64_t v7 = *v6;
  if (*v6 != a2)
  {
    int v8 = 1;
    while (v7 != -4096)
    {
      unsigned int v9 = v5 + v8++;
      unsigned int v5 = v9 & v4;
      unint64_t v6 = (uint64_t *)(v3 + 56 * (v9 & v4));
      uint64_t v7 = *v6;
      if (*v6 == a2) {
        goto LABEL_6;
      }
    }
    goto LABEL_28;
  }
LABEL_6:
  unint64_t v10 = 0;
  uint64_t result = *((unsigned int *)v6 + 2);
  uint64_t v12 = v6[3];
  unint64_t v26 = v12 & 6;
  unsigned int v27 = 0;
  uint64_t v13 = (int32x2_t ****)v6[5];
  unint64_t v28 = v13;
  if (v13 != (int32x2_t ****)-8192 && v13 != (int32x2_t ****)-4096 && v13 != 0)
  {
    unsigned int v27 = *(unint64_t **)(v12 & 0xFFFFFFFFFFFFFFF8);
    *(void *)(v12 & 0xFFFFFFFFFFFFFFF8) = &v26;
    unint64_t v26 = v12 & 0xFFFFFFFFFFFFFFFELL;
    unint64_t v10 = v27;
    if (v27) {
      *unsigned int v27 = *v27 & 7 | (unint64_t)&v27;
    }
    uint64_t v13 = v28;
  }
  uint64_t v29 = v6[6];
LABEL_15:
  if (v13 != (int32x2_t ****)-8192 && v13 != (int32x2_t ****)-4096 && v13)
  {
    unint64_t v15 = v26 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v26 & 0xFFFFFFFFFFFFFFF8) = v10;
    if (v27)
    {
      *unsigned int v27 = *v27 & 7 | v15;
    }
    else
    {
      int v16 = v28;
      int v17 = ***v28;
      unint64_t v18 = (unint64_t)v17[303];
      if (v18 <= v15)
      {
        uint64_t v19 = v17[305].u32[0];
        if (v18 + 16 * v19 > v15)
        {
          unsigned int v20 = v19 - 1;
          LODWORD(v21) = v20 & ((v28 >> 4) ^ (v28 >> 9));
          uint64_t v22 = (int32x2_t *****)(v18 + 16 * v21);
          uint64_t v23 = *v22;
          if (v28 == *v22)
          {
LABEL_26:
            *uint64_t v22 = (int32x2_t ****)-8192;
            v17[304] = vadd_s32(v17[304], (int32x2_t)0x1FFFFFFFFLL);
            int v16 = v28;
          }
          else
          {
            int v24 = 1;
            while (v23 != (int32x2_t ****)-4096)
            {
              int v25 = v21 + v24++;
              uint64_t v21 = v25 & v20;
              uint64_t v23 = *(int32x2_t *****)(v18 + 16 * v21);
              if (v28 == v23)
              {
                uint64_t v22 = (int32x2_t *****)(v18 + 16 * v21);
                goto LABEL_26;
              }
            }
          }
          *((unsigned char *)v16 + 17) &= ~1u;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1CBF7A634(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    unint64_t v6 = (void *)(a1 + 56 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
LABEL_11:
      uint64_t result = 1;
    }
    else
    {
      int v8 = 0;
      int v9 = 1;
      while (v7 != -4096)
      {
        if (v8) {
          BOOL v10 = 0;
        }
        else {
          BOOL v10 = v7 == -8192;
        }
        if (v10) {
          int v8 = v6;
        }
        unsigned int v11 = v5 + v9++;
        unsigned int v5 = v11 & v4;
        unint64_t v6 = (void *)(a1 + 56 * (v11 & v4));
        uint64_t v7 = *v6;
        if (*v6 == a3) {
          goto LABEL_11;
        }
      }
      uint64_t result = 0;
      if (v8) {
        unint64_t v6 = v8;
      }
    }
  }
  else
  {
    unint64_t v6 = 0;
    uint64_t result = 0;
  }
  *a4 = v6;
  return result;
}

int32x2_t sub_1CBF7A6C0(uint64_t a1)
{
  unsigned int v1 = *(int32x2_t **)(a1 + 32);
  __int32 v2 = v1[22].i32[0];
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    int32x2_t v4 = v1[20];
    __int32 v5 = v2 - 1;
    unsigned int v6 = ((v3 >> 4) ^ (v3 >> 9)) & (v2 - 1);
    uint64_t v7 = (uint64_t *)(*(void *)&v4 + 56 * v6);
    uint64_t v8 = *v7;
    if (v3 == *v7)
    {
LABEL_6:
      uint64_t v11 = v7[5];
      if (v11 != -8192 && v11 != -4096 && v11 != 0)
      {
        unint64_t v13 = v7[3] & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v13 = v7[4];
        uint64_t v14 = (unint64_t *)v7[4];
        if (v14)
        {
          *uint64_t v14 = *v14 & 7 | v13;
        }
        else
        {
          uint64_t v15 = v7[5];
          int v16 = ***(int32x2_t ****)v15;
          unint64_t v17 = (unint64_t)v16[303];
          if (v17 <= v13)
          {
            uint64_t v18 = v16[305].u32[0];
            if (v17 + 16 * v18 > v13)
            {
              unsigned int v19 = v18 - 1;
              LODWORD(v20) = v19 & ((v15 >> 4) ^ (v15 >> 9));
              uint64_t v21 = (uint64_t *)(v17 + 16 * v20);
              uint64_t v22 = *v21;
              if (v15 == *v21)
              {
LABEL_19:
                *uint64_t v21 = -8192;
                v16[304] = vadd_s32(v16[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v15 = v7[5];
              }
              else
              {
                int v23 = 1;
                while (v22 != -4096)
                {
                  int v24 = v20 + v23++;
                  uint64_t v20 = v24 & v19;
                  uint64_t v22 = *(void *)(v17 + 16 * v20);
                  if (v15 == v22)
                  {
                    uint64_t v21 = (uint64_t *)(v17 + 16 * v20);
                    goto LABEL_19;
                  }
                }
              }
              *(unsigned char *)(v15 + 17) &= ~1u;
            }
          }
        }
      }
      *uint64_t v7 = -8192;
      int32x2_t result = vadd_s32(v1[21], (int32x2_t)0x1FFFFFFFFLL);
      v1[21] = result;
    }
    else
    {
      int v9 = 1;
      while (v8 != -4096)
      {
        unsigned int v10 = v6 + v9++;
        unsigned int v6 = v10 & v5;
        uint64_t v7 = (uint64_t *)(*(void *)&v4 + 56 * (v10 & v5));
        uint64_t v8 = *v7;
        if (v3 == *v7) {
          goto LABEL_6;
        }
      }
    }
  }
  return result;
}

void sub_1CBF7A820(uint64_t *a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    uint64_t v3 = *a1;
    uint64_t v4 = *a1 + 40 * v2;
    uint64_t v5 = a2 + 152;
    do
    {
      sub_1CBF7A87C(v5, *(unsigned __int8 **)v3, *(void *)(v3 + 8), (int *)(v3 + 16), *(void *)(v3 + 24), *(void *)(v3 + 32));
      v3 += 40;
    }
    while (v3 != v4);
  }
}

void sub_1CBF7A87C(uint64_t a1, unsigned __int8 *a2, size_t a3, int *a4, uint64_t a5, uint64_t a6)
{
  int v9 = *a4;
  v14[0] = a2;
  v14[1] = a3;
  v14[2] = a5;
  v14[3] = a6;
  void v14[4] = &unk_1F2600F38;
  char v16 = 1;
  int v15 = v9;
  unint64_t v10 = sub_1CBF7A980(a1 + 16, (unint64_t)v14, 1);
  uint64_t v11 = *(void *)(a1 + 16) + 48 * *(unsigned int *)(a1 + 24);
  long long v12 = *(_OWORD *)(v10 + 16);
  *(_OWORD *)uint64_t v11 = *(_OWORD *)v10;
  *(_OWORD *)(v11 + 16) = v12;
  *(void *)(v11 + 32) = &unk_1F2600F58;
  char v13 = *(unsigned char *)(v10 + 44);
  *(_DWORD *)(v11 + 40) = *(_DWORD *)(v10 + 40);
  *(unsigned char *)(v11 + 44) = v13;
  *(void *)(v11 + 32) = &unk_1F2600F38;
  ++*(_DWORD *)(a1 + 24);
  llvm::cl::AddLiteralOption(*(void *)(a1 + 8), a2, a3);
}

unint64_t sub_1CBF7A980(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3 + a3 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    unint64_t v5 = *(void *)a1 + 48 * v3;
    if (*(void *)a1 > a2 || v5 <= a2) {
      sub_1CD45DBA8();
    }
    sub_1CD45DBA8();
  }
  return a2;
}

uint64_t sub_1CBF7A9F8(uint64_t a1, char *a2, int **a3, _WORD *a4, _OWORD *a5)
{
  uint64_t v10 = sub_1CB883A14(a1, 0, 0);
  *(_DWORD *)(v10 + 128) = 0;
  *(void *)(v10 + 136) = &unk_1F25EA1B0;
  *(void *)(v10 + 144) = 0;
  *(void *)uint64_t v10 = &unk_1F2643F00;
  *(void *)(v10 + 152) = &unk_1F2643DB0;
  *(void *)(v10 + 160) = &unk_1F25EA168;
  *(void *)(v10 + 184) = v10 + 160;
  size_t v11 = strlen(a2);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)a2, v11);
  int v12 = **a3;
  *(_DWORD *)(a1 + 128) = v12;
  *(unsigned char *)(a1 + 1++*(_DWORD *)(result + 48) = 1;
  *(_DWORD *)(a1 + 144) = v12;
  *(_WORD *)(a1 + 10) = (32 * (*a4 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  *(_OWORD *)(a1 + 32) = *a5;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void sub_1CBF7AB24(uint64_t *a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    uint64_t v3 = *a1;
    uint64_t v4 = *a1 + 40 * v2;
    uint64_t v5 = a2 + 152;
    do
    {
      sub_1CBF7AB80(v5, *(unsigned __int8 **)v3, *(void *)(v3 + 8), (int *)(v3 + 16), *(void *)(v3 + 24), *(void *)(v3 + 32));
      v3 += 40;
    }
    while (v3 != v4);
  }
}

void sub_1CBF7AB80(uint64_t a1, unsigned __int8 *a2, size_t a3, int *a4, uint64_t a5, uint64_t a6)
{
  int v9 = *a4;
  v14[0] = a2;
  v14[1] = a3;
  v14[2] = a5;
  v14[3] = a6;
  void v14[4] = &unk_1F2601030;
  char v16 = 1;
  int v15 = v9;
  unint64_t v10 = sub_1CBF7AC84(a1 + 16, (unint64_t)v14, 1);
  uint64_t v11 = *(void *)(a1 + 16) + 48 * *(unsigned int *)(a1 + 24);
  long long v12 = *(_OWORD *)(v10 + 16);
  *(_OWORD *)uint64_t v11 = *(_OWORD *)v10;
  *(_OWORD *)(v11 + 16) = v12;
  *(void *)(v11 + 32) = &unk_1F2601050;
  char v13 = *(unsigned char *)(v10 + 44);
  *(_DWORD *)(v11 + 40) = *(_DWORD *)(v10 + 40);
  *(unsigned char *)(v11 + 44) = v13;
  *(void *)(v11 + 32) = &unk_1F2601030;
  ++*(_DWORD *)(a1 + 24);
  llvm::cl::AddLiteralOption(*(void *)(a1 + 8), a2, a3);
}

unint64_t sub_1CBF7AC84(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3 + a3 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    unint64_t v5 = *(void *)a1 + 48 * v3;
    if (*(void *)a1 > a2 || v5 <= a2) {
      sub_1CD45DFA4();
    }
    sub_1CD45DFA4();
  }
  return a2;
}

void sub_1CBF7ACFC(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(unsigned char **)a1;
  if (a2 > (uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3)
  {
    if (a2 >> 61) {
      abort();
    }
    unint64_t v5 = *(unsigned char **)(a1 + 8);
    unsigned int v6 = (char *)operator new(8 * a2);
    uint64_t v7 = &v6[(v5 - v2) & 0xFFFFFFFFFFFFFFF8];
    uint64_t v8 = v7;
    if (v5 != v2)
    {
      uint64_t v8 = &v6[(v5 - v2) & 0xFFFFFFFFFFFFFFF8];
      do
      {
        uint64_t v9 = *((void *)v5 - 1);
        v5 -= 8;
        *((void *)v8 - 1) = v9;
        v8 -= 8;
      }
      while (v5 != v2);
    }
    *(void *)a1 = v8;
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = &v6[8 * a2];
    if (v2)
    {
      operator delete(v2);
    }
  }
}

void sub_1CBF7ADB4(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(unsigned char **)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v4 = *(unsigned char **)(a1 + 8);
    uint64_t v5 = 3 * a2;
    unsigned int v6 = (char *)operator new(24 * a2);
    uint64_t v7 = &v6[24 * ((v4 - v2) / 24)];
    uint64_t v8 = v7;
    if (v4 != v2)
    {
      uint64_t v9 = &v6[24 * ((v4 - v2) / 24)];
      do
      {
        long long v10 = *(_OWORD *)(v4 - 24);
        uint64_t v8 = v9 - 24;
        *((void *)v9 - 1) = *((void *)v4 - 1);
        *(_OWORD *)(v9 - 24) = v10;
        v4 -= 24;
        v9 -= 24;
      }
      while (v4 != v2);
    }
    *(void *)a1 = v8;
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = &v6[8 * v5];
    if (v2)
    {
      operator delete(v2);
    }
  }
}

void sub_1CBF7AEB8(uint64_t a1, uint64_t a2)
{
  v27[24] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = v24;
  uint64_t v20 = v24;
  uint64_t v5 = *(unsigned char **)(a2 + 8);
  if (v5 == *(unsigned char **)a2)
  {
    uint64_t v21 = v24;
    unsigned int v6 = v5;
  }
  else
  {
    uint64_t v19 = *(unsigned int *)(a2 + 16);
    uint64_t v4 = malloc_type_malloc(8 * v19, 0x4065EBACuLL);
    if (!v4 && (v19 || (uint64_t v4 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    uint64_t v21 = v4;
    unsigned int v6 = *(unsigned char **)a2;
    uint64_t v5 = *(unsigned char **)(a2 + 8);
  }
  unsigned int v8 = *(_DWORD *)(a2 + 16);
  unsigned int v7 = *(_DWORD *)(a2 + 20);
  LODWORD(v22) = v8;
  if (v5 == v6) {
    unsigned int v9 = v7;
  }
  else {
    unsigned int v9 = v8;
  }
  if (v9)
  {
    memmove(v4, v5, 8 * v9);
    unsigned int v7 = *(_DWORD *)(a2 + 20);
  }
  int v10 = *(_DWORD *)(a2 + 24);
  HIDWORD(v22) = v7;
  int v23 = v10;
  int v25 = v27;
  uint64_t v26 = 0x800000000;
  unsigned int v11 = *(_DWORD *)(a2 + 104);
  if (v11)
  {
    if (&v20 == (unsigned char **)a2)
    {
      unsigned int v11 = 0;
    }
    else
    {
      if (v11 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v27, *(const void **)(a2 + 96), 24 * *(unsigned int *)(a2 + 104));
      LODWORD(v26) = v11;
    }
  }
  long long v12 = (void *)(a1 + 32);
  *(void *)a1 = a1 + 32;
  uint64_t v14 = v20;
  char v13 = v21;
  if (v21 == v20)
  {
    *(void *)(a1 + 8) = v12;
    int v15 = HIDWORD(v22);
    if (HIDWORD(v22)) {
      memmove(v12, v13, 8 * HIDWORD(v22));
    }
  }
  else
  {
    *(void *)(a1 + 8) = v21;
    uint64_t v21 = v14;
    int v15 = HIDWORD(v22);
  }
  int v16 = v23;
  *(_DWORD *)(a1 + 16) = v22;
  *(_DWORD *)(a1 + 20) = v15;
  *(_DWORD *)(a1 + 24) = v16;
  uint64_t v22 = 8;
  *(void *)(a1 + 96) = a1 + 112;
  int v23 = 0;
  *(void *)(a1 + 104) = 0x800000000;
  unint64_t v17 = v25;
  if (v11 && &v20 != (unsigned char **)a1)
  {
    if (v25 == v27)
    {
      memcpy((void *)(a1 + 112), v27, 24 * v11);
      *(_DWORD *)(a1 + 104) = v11;
      unint64_t v17 = v25;
    }
    else
    {
      *(void *)(a1 + 96) = v25;
      int v18 = HIDWORD(v26);
      *(_DWORD *)(a1 + 104) = v11;
      *(_DWORD *)(a1 + 108) = v18;
      int v25 = v27;
      HIDWORD(v26) = 0;
      unint64_t v17 = v27;
    }
    LODWORD(v26) = 0;
  }
  if (v17 != v27) {
    free(v17);
  }
  if (v21 != v20) {
    free(v21);
  }
}

void sub_1CBF7B148(llvm::SmallPtrSetImplBase *this)
{
  while (1)
  {
LABEL_1:
    uint64_t v2 = *((void *)this + 12) + 24 * *((unsigned int *)this + 26);
    uint64_t v3 = *(void *)(v2 - 24);
    uint64_t v4 = *(void *)(v3 + 40);
    if (v4 == v3 + 40)
    {
LABEL_68:
      int v35 = 0;
    }
    else
    {
      uint64_t v5 = v4 - 24;
      if (!v4) {
        uint64_t v5 = 0;
      }
      int v6 = *(unsigned __int8 *)(v5 + 16);
      int v7 = v6 - 29;
      if (v6 == 30)
      {
        int v35 = (*(_DWORD *)(v5 + 20) & 0x7FFFFFF) == 3 ? 2 : 1;
      }
      else
      {
        int v35 = 0;
        switch(v7)
        {
          case 0:
          case 5:
          case 6:
            break;
          case 1:
LABEL_80:
            __break(1u);
            goto LABEL_81;
          case 2:
            int v35 = (*(_DWORD *)(v5 + 20) >> 1) & 0x3FFFFFF;
            break;
          case 3:
          case 9:
            int v35 = (*(_DWORD *)(v5 + 20) & 0x7FFFFFF) - 1;
            break;
          case 4:
            int v35 = 2;
            break;
          case 7:
            int v35 = *(_WORD *)(v5 + 18) & 1;
            break;
          case 8:
LABEL_81:
            int v35 = 1;
            break;
          case 10:
            int v35 = *(_DWORD *)(v5 + 80) + 1;
            break;
          default:
            goto LABEL_68;
        }
      }
    }
    if (*(_DWORD *)(v2 - 8) == v35) {
      break;
    }
    uint64_t v8 = *(void *)(v2 - 16);
    uint64_t v9 = *(void *)(v2 - 8);
    uint64_t v10 = (v9 + 1);
    *(_DWORD *)(v2 - 8) = v10;
    uint64_t v2 = *(unsigned __int8 *)(v8 + 16);
    if (v2 == 30)
    {
      uint64_t v11 = v8 - 32 * v9;
LABEL_12:
      long long v12 = (uint64_t *)(v11 - 32);
    }
    else
    {
      switch(*(unsigned char *)(v8 + 16))
      {
        case ' ':
        case '&':
          int v42 = *(_DWORD *)(v8 + 20);
          if ((v42 & 0x40000000) != 0) {
            uint64_t v43 = *(void *)(v8 - 8);
          }
          else {
            uint64_t v43 = v8 - 32 * (v42 & 0x7FFFFFF);
          }
          long long v12 = (uint64_t *)(v43 + 32 * v10);
          break;
        case '!':
          uint64_t v44 = -64;
          if (!v9) {
            uint64_t v44 = -96;
          }
          long long v12 = (uint64_t *)(v8 + v44);
          break;
        case '""':
        case '#':
          goto LABEL_80;
        case '$':
          if ((*(_WORD *)(v8 + 18) & 1) == 0)
          {
            uint64_t v13 = 0;
            goto LABEL_14;
          }
          uint64_t v38 = v8 - 32 * (*(_DWORD *)(v8 + 20) & 0x7FFFFFF);
LABEL_59:
          long long v12 = (uint64_t *)(v38 + 32);
          break;
        case '%':
          long long v12 = (uint64_t *)(v8 - 32);
          break;
        case '\'':
          if (v9)
          {
            uint64_t v11 = v8 - 32 * *(unsigned int *)(v8 + 80) + 32 * (v9 - 1);
            goto LABEL_12;
          }
          long long v12 = (uint64_t *)(v8 - 32 * *(unsigned int *)(v8 + 80) - 64);
          break;
        default:
          int v36 = *(_DWORD *)(v8 + 20);
          if ((v36 & 0x40000000) != 0) {
            uint64_t v37 = *(void *)(v8 - 8);
          }
          else {
            uint64_t v37 = v8 - 32 * (v36 & 0x7FFFFFF);
          }
          uint64_t v38 = v37 + 32 * (2 * v9);
          goto LABEL_59;
      }
    }
    uint64_t v13 = *v12;
LABEL_14:
    uint64_t v14 = *((void *)this + 1);
    uint64_t v15 = *((unsigned int *)this + 5);
    if (v14 == *(void *)this)
    {
      if (v15)
      {
        int v16 = 0;
        uint64_t v17 = 8 * v15;
        int v18 = (void *)*((void *)this + 1);
        do
        {
          if (*v18 == v13) {
            goto LABEL_1;
          }
          if (*v18 == -2) {
            int v16 = v18;
          }
          ++v18;
          v17 -= 8;
        }
        while (v17);
        if (v16)
        {
          *int v16 = v13;
          --*((_DWORD *)this + 6);
          goto LABEL_25;
        }
      }
      unsigned int v25 = *((_DWORD *)this + 4);
      if (v15 < v25)
      {
        *((_DWORD *)this + 5) = v15 + 1;
        *(void *)(v14 + 8 * v15) = v13;
        goto LABEL_25;
      }
    }
    else
    {
      unsigned int v25 = *((_DWORD *)this + 4);
    }
    if (3 * v25 <= 4 * ((int)v15 - *((_DWORD *)this + 6)))
    {
      if (v25 >= 0x40) {
        v25 *= 2;
      }
      else {
        unsigned int v25 = 128;
      }
LABEL_67:
      llvm::SmallPtrSetImplBase::Grow(this, v25);
      unsigned int v25 = *((_DWORD *)this + 4);
      uint64_t v14 = *((void *)this + 1);
      goto LABEL_34;
    }
    if (v25 - v15 < v25 >> 3) {
      goto LABEL_67;
    }
LABEL_34:
    unsigned int v26 = v25 - 1;
    unsigned int v27 = (v25 - 1) & ((v13 >> 4) ^ (v13 >> 9));
    unint64_t v28 = (void *)(v14 + 8 * v27);
    uint64_t v29 = *v28;
    if (*v28 == -1)
    {
      uint64_t v33 = 0;
LABEL_45:
      if (v33) {
        BOOL v34 = v33;
      }
      else {
        BOOL v34 = v28;
      }
      if (*v34 != v13)
      {
        if (*v34 == -2) {
          --*((_DWORD *)this + 6);
        }
        else {
          ++*((_DWORD *)this + 5);
        }
        *BOOL v34 = v13;
LABEL_25:
        uint64_t v19 = *(void *)(v13 + 40);
        if (v19 == v13 + 40 || !v19)
        {
          if (v19 == v13 + 40)
          {
            uint64_t v45 = 0;
          }
          else
          {
            if (v19) {
              uint64_t v45 = v19 - 24;
            }
            else {
              uint64_t v45 = 0;
            }
            if (*(unsigned __int8 *)(v45 + 16) - 29 >= 0xB) {
              uint64_t v45 = 0;
            }
          }
          *(void *)&long long v46 = v13;
          *((void *)&v46 + 1) = v45;
          uint64_t v47 = 0;
          unsigned int v40 = *((_DWORD *)this + 26);
          unint64_t v22 = *((void *)this + 12);
          if (v40 >= *((_DWORD *)this + 27))
          {
            BOOL v41 = v22 + 24 * v40 > (unint64_t)&v46;
            if (v22 <= (unint64_t)&v46 && v41) {
LABEL_79:
            }
              llvm::SmallVectorBase<unsigned int>::grow_pod();
LABEL_63:
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
        }
        else
        {
          if (*(unsigned __int8 *)(v19 - 8) - 29 >= 0xB) {
            uint64_t v20 = 0;
          }
          else {
            uint64_t v20 = v19 - 24;
          }
          *(void *)&long long v46 = v13;
          *((void *)&v46 + 1) = v20;
          uint64_t v47 = 0;
          unsigned int v21 = *((_DWORD *)this + 26);
          unint64_t v22 = *((void *)this + 12);
          if (v21 >= *((_DWORD *)this + 27))
          {
            BOOL v39 = v22 + 24 * v21 > (unint64_t)&v46;
            if (v22 <= (unint64_t)&v46 && v39) {
              goto LABEL_79;
            }
            goto LABEL_63;
          }
        }
        uint64_t v23 = v22 + 24 * *((unsigned int *)this + 26);
        long long v24 = v46;
        *(void *)(v23 + 16) = v47;
        *(_OWORD *)uint64_t v23 = v24;
        ++*((_DWORD *)this + 26);
      }
    }
    else
    {
      uint64_t v33 = 0;
      int v30 = 1;
      while (v29 != v13)
      {
        if (v33) {
          BOOL v31 = 0;
        }
        else {
          BOOL v31 = v29 == -2;
        }
        if (v31) {
          uint64_t v33 = v28;
        }
        unsigned int v32 = v27 + v30++;
        unsigned int v27 = v32 & v26;
        unint64_t v28 = (void *)(v14 + 8 * (v32 & v26));
        uint64_t v29 = *v28;
        if (*v28 == -1) {
          goto LABEL_45;
        }
      }
    }
  }
}

llvm::SmallPtrSetImplBase *sub_1CBF7B63C(llvm::SmallPtrSetImplBase *this, uint64_t a2)
{
  *((void *)this + 4) = a2;
  *(void *)this = (char *)this + 32;
  *((void *)this + 1) = (char *)this + 32;
  *((_DWORD *)this + 6) = 0;
  *((void *)this + 12) = (char *)this + 112;
  *((_DWORD *)this + 27) = 8;
  *((void *)this + 2) = 0x100000008;
  uint64_t v3 = *(void *)(a2 + 40);
  if (v3 == a2 + 40)
  {
    uint64_t v4 = 0;
  }
  else
  {
    if (v3) {
      uint64_t v4 = v3 - 24;
    }
    else {
      uint64_t v4 = 0;
    }
    if (*(unsigned __int8 *)(v4 + 16) - 29 >= 0xB) {
      uint64_t v4 = 0;
    }
  }
  *((void *)this + 14) = a2;
  *((void *)this + 15) = v4;
  *((void *)this + 16) = 0;
  *((_DWORD *)this + 26) = 1;
  sub_1CBF7B148(this);
  return this;
}

uint64_t *sub_1CBF7B6D8(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) <= v6 >> 3)
    {
      sub_1CBF7B814((uint64_t *)a1, v6);
      int v16 = 0;
      sub_1CBF7A634(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v16);
      a3 = v16;
    }
LABEL_4:
    uint64_t v7 = *a3;
    goto LABEL_5;
  }
  sub_1CBF7B814((uint64_t *)a1, 2 * v6);
  uint64_t v7 = *a2;
  int v9 = *(_DWORD *)(a1 + 16) - 1;
  unsigned int v10 = ((*a2 >> 4) ^ (*a2 >> 9)) & v9;
  a3 = (uint64_t *)(*(void *)a1 + 56 * v10);
  uint64_t v11 = *a3;
  if (*a2 != *a3)
  {
    long long v12 = 0;
    int v13 = 1;
    while (v11 != -4096)
    {
      if (v12) {
        BOOL v14 = 0;
      }
      else {
        BOOL v14 = v11 == -8192;
      }
      if (v14) {
        long long v12 = a3;
      }
      unsigned int v15 = v10 + v13++;
      unsigned int v10 = v15 & v9;
      a3 = (uint64_t *)(*(void *)a1 + 56 * v10);
      uint64_t v11 = *a3;
      if (v7 == *a3) {
        goto LABEL_5;
      }
    }
    if (v12) {
      a3 = v12;
    }
    goto LABEL_4;
  }
LABEL_5:
  ++*(_DWORD *)(a1 + 8);
  if (v7 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CBF7B814(uint64_t *a1, int a2)
{
  unsigned int v3 = *((_DWORD *)a1 + 4);
  uint64_t v4 = (uint64_t *)*a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *((_DWORD *)a1 + 4) = v8;
  int32x2_t result = operator new(56 * v8, (std::align_val_t)8uLL);
  *a1 = (uint64_t)result;
  if (v4)
  {
    a1[1] = 0;
    uint64_t v12 = *((unsigned int *)a1 + 4);
    if (v12)
    {
      uint64_t v13 = 56 * v12;
      do
      {
        *int32x2_t result = -4096;
        result += 7;
        v13 -= 56;
      }
      while (v13);
    }
    if (v3)
    {
      BOOL v14 = v4;
      do
      {
        uint64_t v15 = *v14;
        if ((*v14 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          int v16 = *((_DWORD *)a1 + 4) - 1;
          unsigned int v17 = v16 & ((v15 >> 4) ^ (v15 >> 9));
          uint64_t v18 = *a1 + 56 * v17;
          uint64_t v19 = *(void *)v18;
          if (v15 != *(void *)v18)
          {
            uint64_t v20 = 0;
            int v21 = 1;
            while (v19 != -4096)
            {
              if (v20) {
                BOOL v22 = 0;
              }
              else {
                BOOL v22 = v19 == -8192;
              }
              if (v22) {
                uint64_t v20 = v18;
              }
              unsigned int v23 = v17 + v21++;
              unsigned int v17 = v23 & v16;
              uint64_t v18 = *a1 + 56 * (v23 & v16);
              uint64_t v19 = *(void *)v18;
              if (v15 == *(void *)v18) {
                goto LABEL_27;
              }
            }
            if (v20) {
              uint64_t v18 = v20;
            }
          }
LABEL_27:
          *(void *)uint64_t v18 = v15;
          *(_DWORD *)(v18 + 8) = *((_DWORD *)v14 + 2);
          uint64_t v24 = v14[3] & 6;
          *(void *)(v18 + 24) = v24;
          unsigned int v25 = (unint64_t *)(v18 + 24);
          *(void *)(v18 + 32) = 0;
          unint64_t v26 = v18 + 32;
          uint64_t v27 = v14[5];
          *(void *)(v18 + 40) = v27;
          if (v27 != -8192 && v27 != -4096)
          {
            if (v27)
            {
              unint64_t v28 = v14[3] & 0xFFFFFFFFFFFFFFF8;
              *(void *)unint64_t v26 = *(void *)v28;
              *(void *)unint64_t v28 = v25;
              *unsigned int v25 = v28 | v24;
              if (*(void *)v26) {
                **(void **)unint64_t v26 = **(void **)v26 & 7 | v26;
              }
            }
          }
          *(void *)(v18 + 16) = &unk_1F26010A0;
          uint64_t v29 = v14[5];
          *(void *)(v18 + ++*(_DWORD *)(result + 48) = v14[6];
          ++*((_DWORD *)a1 + 2);
          if (v29 != -8192 && v29 != -4096 && v29)
          {
            unint64_t v30 = v14[3] & 0xFFFFFFFFFFFFFFF8;
            *(void *)unint64_t v30 = v14[4];
            BOOL v31 = (unint64_t *)v14[4];
            if (v31)
            {
              *BOOL v31 = *v31 & 7 | v30;
            }
            else
            {
              uint64_t v32 = v14[5];
              uint64_t v33 = ***(int32x2_t ****)v32;
              unint64_t v34 = (unint64_t)v33[303];
              if (v34 <= v30)
              {
                uint64_t v35 = v33[305].u32[0];
                if (v34 + 16 * v35 > v30)
                {
                  unsigned int v36 = v35 - 1;
                  LODWORD(v37) = v36 & ((v32 >> 4) ^ (v32 >> 9));
                  uint64_t v38 = (uint64_t *)(v34 + 16 * v37);
                  uint64_t v39 = *v38;
                  if (v32 != *v38)
                  {
                    int v40 = 1;
                    do
                    {
                      if (v39 == -4096) {
                        goto LABEL_44;
                      }
                      int v41 = v37 + v40++;
                      uint64_t v37 = v41 & v36;
                      uint64_t v39 = *(void *)(v34 + 16 * v37);
                    }
                    while (v32 != v39);
                    uint64_t v38 = (uint64_t *)(v34 + 16 * v37);
                  }
                  *uint64_t v38 = -8192;
                  v33[304] = vadd_s32(v33[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v32 = v14[5];
LABEL_44:
                  *(unsigned char *)(v32 + 17) &= ~1u;
                }
              }
            }
          }
        }
        v14 += 7;
      }
      while (v14 != &v4[7 * v3]);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  a1[1] = 0;
  uint64_t v10 = *((unsigned int *)a1 + 4);
  if (v10)
  {
    uint64_t v11 = 56 * v10;
    do
    {
      *int32x2_t result = -4096;
      result += 7;
      v11 -= 56;
    }
    while (v11);
  }
  return result;
}

char *sub_1CBF7BB20(char **a1, void *a2)
{
  uint64_t v2 = *a1;
  unsigned int v3 = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * ((a1[2] - v2) >> 3) > v5) {
    unint64_t v5 = 0x5555555555555556 * ((a1[2] - v2) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - v2) >> 3) >= 0x555555555555555) {
    unint64_t v5 = 0xAAAAAAAAAAAAAAALL;
  }
  if (v5 > 0xAAAAAAAAAAAAAAALL) {
    sub_1CB833614();
  }
  uint64_t v8 = 3 * v5;
  int v9 = (char *)operator new(24 * v5);
  uint64_t v10 = &v9[24 * v4];
  *(_DWORD *)uint64_t v10 = *a2;
  uint64_t v11 = v10 + 24;
  *((void *)v10 + 1) = 0;
  *((void *)v10 + 2) = 0;
  if (v3 == v2)
  {
    uint64_t v13 = &v9[24 * v4];
  }
  else
  {
    do
    {
      long long v12 = *(_OWORD *)(v3 - 24);
      uint64_t v13 = v10 - 24;
      *((void *)v10 - 1) = *((void *)v3 - 1);
      *(_OWORD *)(v10 - 24) = v12;
      v3 -= 24;
      v10 -= 24;
    }
    while (v3 != v2);
  }
  *a1 = v13;
  a1[1] = v11;
  a1[2] = &v9[8 * v8];
  if (v2) {
    operator delete(v2);
  }
  return v11;
}

void sub_1CBF7BC34(char **a1, unint64_t a2)
{
  unint64_t v5 = a1[1];
  unint64_t v4 = a1[2];
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - v5) >> 3) >= a2)
  {
    if (a2)
    {
      bzero(a1[1], 24 * ((24 * a2 - 24) / 0x18) + 24);
      v5 += 24 * a2;
    }
    a1[1] = v5;
  }
  else
  {
    unint64_t v6 = *a1;
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v4 - v6) >> 3);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x555555555555555) {
      unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0xAAAAAAAAAAAAAAALL) {
        sub_1CB833614();
      }
      uint64_t v11 = (char *)operator new(24 * v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    long long v12 = &v11[24 * v7];
    uint64_t v13 = &v11[24 * v10];
    uint64_t v14 = 3 * a2;
    bzero(v12, 24 * ((8 * v14 - 24) / 0x18uLL) + 24);
    uint64_t v15 = &v12[8 * v14];
    if (v5 != v6)
    {
      do
      {
        long long v16 = *(_OWORD *)(v5 - 24);
        *((void *)v12 - 1) = *((void *)v5 - 1);
        *(_OWORD *)(v12 - 24) = v16;
        v12 -= 24;
        v5 -= 24;
      }
      while (v5 != v6);
      unint64_t v5 = *a1;
    }
    *a1 = v12;
    a1[1] = v15;
    a1[2] = v13;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

BOOL sub_1CBF7BDF0(int *a1)
{
  uint64_t v1 = *((void *)a1 + 1);
  if (!v1) {
    return 0;
  }
  unint64_t v3 = *(unsigned int *)(v1 + 12);
  unint64_t v4 = *(unsigned int **)(v1 + 96);
  if (v3 < 2) {
    return *a1 == *v4;
  }
  unsigned int v5 = *a1;
  unint64_t v6 = v4;
  unint64_t v7 = v3;
  do
  {
    unint64_t v8 = v7 >> 1;
    unint64_t v9 = &v6[v7 >> 1];
    unsigned int v11 = *v9;
    unint64_t v10 = v9 + 1;
    v7 += ~(v7 >> 1);
    if (v11 < v5) {
      unint64_t v6 = v10;
    }
    else {
      unint64_t v7 = v8;
    }
  }
  while (v7);
  if (v6 == &v4[v3]) {
    return 0;
  }
  return v5 >= *v6;
}

void sub_1CBF7BE74(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    goto LABEL_13;
  }
  unint64_t v6 = *(char **)(a1 + 8);
  unsigned int v5 = *(char **)(a1 + 16);
  uint64_t v7 = v5 - v6;
  unint64_t v8 = *(char **)(a1 + 24);
  uint64_t v9 = (uint64_t)&v8[-*(void *)a1];
  if (v5 - v6 < (unint64_t)v9)
  {
    if (v8 != v5)
    {
      unsigned int v23 = (char *)operator new(0x1000uLL);
      sub_1CD3F23B4(a1, &v23);
      return;
    }
    unsigned int v23 = (char *)operator new(0x1000uLL);
    sub_1CD3F24DC((void **)a1, &v23);
LABEL_13:
    uint64_t v18 = *(void ***)(a1 + 8);
    unsigned int v23 = (char *)*v18;
    *(void *)(a1 + 8) = v18 + 1;
    sub_1CB904CD8(a1, &v23);
    return;
  }
  uint64_t v10 = v9 >> 2;
  if (v8 == *(char **)a1) {
    unint64_t v11 = 1;
  }
  else {
    unint64_t v11 = v10;
  }
  uint64_t v27 = a1 + 24;
  if (v11 >> 61) {
    goto LABEL_27;
  }
  long long v12 = (char *)operator new(8 * v11);
  uint64_t v13 = &v12[v7];
  unsigned int v23 = v12;
  uint64_t v24 = &v12[v7];
  uint64_t v14 = &v12[8 * v11];
  unint64_t v26 = v14;
  uint64_t v15 = operator new(0x1000uLL);
  if (v11 == v7 >> 3)
  {
    BOOL v22 = v15;
    if (v7 >= 1)
    {
      v13 -= (4 * v11 + 4) & 0xFFFFFFFFFFFFFFF8;
      uint64_t v24 = v13;
LABEL_18:
      uint64_t v15 = v22;
      goto LABEL_8;
    }
    if (v5 == v6) {
      unint64_t v19 = 1;
    }
    else {
      unint64_t v19 = v7 >> 2;
    }
    if (!(v19 >> 61))
    {
      uint64_t v20 = (char *)operator new(8 * v19);
      int v21 = &v20[8 * (v19 >> 2)];
      uint64_t v14 = &v20[8 * v19];
      unsigned int v23 = v20;
      uint64_t v24 = v21;
      unint64_t v26 = v14;
      operator delete(v12);
      unint64_t v6 = *(char **)(a1 + 8);
      unsigned int v5 = *(char **)(a1 + 16);
      long long v12 = v20;
      uint64_t v13 = v21;
      goto LABEL_18;
    }
LABEL_27:
    sub_1CB833614();
  }
LABEL_8:
  *(void *)uint64_t v13 = v15;
  long long v16 = v13 + 8;
  unsigned int v25 = v13 + 8;
  if (v5 != v6)
  {
    do
    {
      v5 -= 8;
      sub_1CD3F24DC((void **)&v23, v5);
    }
    while (v5 != *(char **)(a1 + 8));
    long long v12 = v23;
    uint64_t v13 = v24;
    long long v16 = v25;
    uint64_t v14 = v26;
  }
  unsigned int v17 = *(void **)a1;
  *(void *)a1 = v12;
  *(void *)(a1 + 8) = v13;
  *(void *)(a1 + 16) = v16;
  *(void *)(a1 + 24) = v14;
  if (v17) {
    operator delete(v17);
  }
}

uint64_t sub_1CBF7C050(uint64_t a1, uint64_t a2, int *a3)
{
  *(void *)a1 = a2;
  *(unsigned char *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 1;
  *(void *)(a1 + 16) = a1 + 32;
  *(void *)(a1 + 24) = 0x400000000;
  *(void *)(a1 + 96) = a1 + 112;
  *(void *)(a1 + 104) = 0x400000000;
  sub_1CBF7C0DC(a1 + 96, 1uLL, *a3);
  *(void *)(a1 + 128) = a1 + 144;
  *(void *)(a1 + 136) = 0x100000000;
  sub_1CBF7C198(a1 + 128, 1uLL, 0);
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(_WORD *)(a1 + 168) = 0;
  return a1;
}

_DWORD *sub_1CBF7C0DC(uint64_t a1, unint64_t a2, int a3)
{
  if (*(unsigned int *)(a1 + 12) < a2)
  {
    *(_DWORD *)(a1 + 8) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  BOOL v3 = *(_DWORD **)a1;
  unsigned int v6 = *(_DWORD *)(a1 + 8);
  int32x2_t result = (_DWORD *)(a1 + 8);
  unint64_t v5 = v6;
  if (v6 >= a2) {
    unint64_t v7 = a2;
  }
  else {
    unint64_t v7 = v5;
  }
  if (v7)
  {
    unint64_t v11 = v3;
    do
    {
      *v11++ = a3;
      --v7;
    }
    while (v7);
    unint64_t v5 = *result;
  }
  unint64_t v8 = v5 - a2;
  if (v5 < a2)
  {
    uint64_t v9 = &v3[v5];
    do
      *v9++ = a3;
    while (!__CFADD__(v8++, 1));
  }
  *int32x2_t result = a2;
  return result;
}

_DWORD *sub_1CBF7C198(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (*(unsigned int *)(a1 + 12) < a2)
  {
    *(_DWORD *)(a1 + 8) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  BOOL v3 = *(void **)a1;
  unsigned int v6 = *(_DWORD *)(a1 + 8);
  int32x2_t result = (_DWORD *)(a1 + 8);
  unint64_t v5 = v6;
  if (v6 >= a2) {
    unint64_t v7 = a2;
  }
  else {
    unint64_t v7 = v5;
  }
  if (v7)
  {
    unint64_t v11 = v3;
    do
    {
      *v11++ = a3;
      --v7;
    }
    while (v7);
  }
  unint64_t v8 = v5 - a2;
  if (v5 < a2)
  {
    uint64_t v9 = &v3[v5];
    do
      *v9++ = a3;
    while (!__CFADD__(v8++, 1));
  }
  *int32x2_t result = a2;
  return result;
}

uint64_t sub_1CBF7C250(uint64_t *a1, uint64_t a2)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = *(_DWORD *)(a2 + 12);
  if (v4 >= 2)
  {
    v62[0] = v63;
    v62[1] = (void *)0x400000000;
    v63[8] = 0;
    char v64 = 0;
    unsigned int v58 = 0;
    uint64_t v59 = 0;
    unsigned int v60 = 0;
    sub_1CD45E50C(&v58, v4);
    unsigned int v57 = 0;
    if (*(_DWORD *)(a2 + 12))
    {
      int v20 = 0;
      unsigned int v21 = 0;
      char v22 = 0;
      unint64_t v23 = 0;
      do
      {
        uint64_t v24 = (unsigned int *)(*(void *)(a2 + 96) + 4 * v21);
        uint64_t v25 = *v24;
        unint64_t v26 = *(llvm::BasicBlock **)(a1[17] + 8 * v25);
        sub_1CBF7C6A8(a1 + 4, v25);
        unint64_t IrrLoopHeaderWeight = llvm::BasicBlock::getIrrLoopHeaderWeight(v26);
        if (v28)
        {
          ++v20;
          if (v22) {
            BOOL v29 = IrrLoopHeaderWeight >= v23;
          }
          else {
            BOOL v29 = 0;
          }
          if (!v29)
          {
            unint64_t v23 = IrrLoopHeaderWeight;
            char v22 = 1;
          }
          if (IrrLoopHeaderWeight) {
            llvm::BlockFrequencyInfoImplBase::Distribution::add((uint64_t)v62, v24, IrrLoopHeaderWeight, 0);
          }
        }
        else
        {
          sub_1CBF7CCE0((uint64_t)&v58, (int *)&v57, (uint64_t)v61);
        }
        unsigned int v21 = v57 + 1;
        unsigned int v57 = v21;
      }
      while (v21 < *(_DWORD *)(a2 + 12));
      if (v22) {
        goto LABEL_51;
      }
    }
    else
    {
      int v20 = 0;
    }
    unint64_t v23 = 1;
LABEL_51:
    int v42 = &v58[v60];
    if (v59)
    {
      if (v60)
      {
        uint64_t v43 = 4 * v60;
        uint64_t v44 = v58;
        while (*v44 >= 0xFFFFFFFE)
        {
          ++v44;
          v43 -= 4;
          if (!v43) {
            goto LABEL_56;
          }
        }
      }
      else
      {
        uint64_t v44 = v58;
      }
    }
    else
    {
LABEL_56:
      uint64_t v44 = &v58[v60];
    }
    uint64_t v45 = &v58[v60];
LABEL_58:
    while (v44 != v45)
    {
      if (v23) {
        llvm::BlockFrequencyInfoImplBase::Distribution::add((uint64_t)v62, (unsigned int *)(*(void *)(a2 + 96) + 4 * *v44), v23, 0);
      }
      long long v46 = v44 + 1;
      while (v46 != v42)
      {
        unsigned int v47 = *v46++;
        if (v47 <= 0xFFFFFFFD)
        {
          uint64_t v44 = v46 - 1;
          goto LABEL_58;
        }
      }
      uint64_t v44 = v42;
    }
    llvm::BlockFrequencyInfoImplBase::distributeIrrLoopHeaderMass((llvm::BlockFrequencyInfoImplBase *)a1, (llvm::BlockFrequencyInfoImplBase::Distribution *)v62);
    uint64_t v48 = *(unsigned int *)(a2 + 104);
    if (v48)
    {
      int v49 = *(unsigned int **)(a2 + 96);
      uint64_t v50 = 4 * v48;
      do
      {
        sub_1CBF7C794(a1, a2, v49++);
        v50 -= 4;
      }
      while (v50);
    }
    if (!v20) {
      llvm::BlockFrequencyInfoImplBase::adjustLoopHeaderMass((uint64_t)a1, a2);
    }
    MEMORY[0x1D25D9CD0](v58, 4);
    if (v62[0] != v63) {
      free(v62[0]);
    }
    goto LABEL_8;
  }
  unsigned int v5 = **(_DWORD **)(a2 + 96);
  uint64_t v6 = a1[8];
  uint64_t v7 = v6 + 24 * v5;
  unint64_t v8 = *(uint64_t **)(v7 + 8);
  if (!v8)
  {
LABEL_3:
    uint64_t v9 = (void *)(v6 + 24 * v5 + 16);
    goto LABEL_4;
  }
  unint64_t v15 = *((unsigned int *)v8 + 3);
  long long v16 = (unsigned int *)v8[12];
  if (v15 >= 2)
  {
    unsigned int v17 = *(_DWORD *)v7;
    BOOL v31 = (unsigned int *)v8[12];
    unint64_t v32 = *((unsigned int *)v8 + 3);
    do
    {
      unint64_t v33 = v32 >> 1;
      unint64_t v34 = &v31[v32 >> 1];
      unsigned int v36 = *v34;
      uint64_t v35 = v34 + 1;
      v32 += ~(v32 >> 1);
      if (v36 < v17) {
        BOOL v31 = v35;
      }
      else {
        unint64_t v32 = v33;
      }
    }
    while (v32);
    uint64_t v37 = &v16[v15];
    if (v31 == v37 || v17 < *v31 || !*((unsigned char *)v8 + 8)) {
      goto LABEL_3;
    }
    do
    {
      unint64_t v38 = v15 >> 1;
      uint64_t v39 = &v16[v15 >> 1];
      unsigned int v41 = *v39;
      int v40 = v39 + 1;
      v15 += ~(v15 >> 1);
      if (v41 < v17) {
        long long v16 = v40;
      }
      else {
        unint64_t v15 = v38;
      }
    }
    while (v15);
    if (v16 == v37 || v17 < *v16) {
      goto LABEL_14;
    }
  }
  else
  {
    unsigned int v17 = *(_DWORD *)v7;
    if (v17 != *v16 || !*((unsigned char *)v8 + 8)) {
      goto LABEL_3;
    }
  }
  uint64_t v18 = *v8;
  if (!*v8) {
    goto LABEL_14;
  }
  uint64_t v19 = *(unsigned int *)(v18 + 12);
  if (v19 < 2) {
    goto LABEL_14;
  }
  uint64_t v51 = *(unsigned int **)(v18 + 96);
  unint64_t v52 = *(unsigned int *)(v18 + 12);
  do
  {
    unint64_t v53 = v52 >> 1;
    unint64_t v54 = &v51[v52 >> 1];
    unsigned int v56 = *v54;
    uint64_t v55 = v54 + 1;
    v52 += ~(v52 >> 1);
    if (v56 < v17) {
      uint64_t v51 = v55;
    }
    else {
      unint64_t v52 = v53;
    }
  }
  while (v52);
  if (v51 == (unsigned int *)(*(void *)(v18 + 96) + 4 * v19) || v17 < *v51 || !*(unsigned char *)(v18 + 8))
  {
LABEL_14:
    uint64_t v9 = v8 + 19;
    goto LABEL_4;
  }
  uint64_t v9 = (void *)(v18 + 152);
LABEL_4:
  *uint64_t v9 = -1;
  LODWORD(v62[0]) = v5;
  sub_1CBF7C794(a1, a2, (unsigned int *)v62);
  uint64_t v10 = *(unsigned int *)(a2 + 12);
  uint64_t v11 = *(unsigned int *)(a2 + 104);
  if (v10 == v11)
  {
LABEL_8:
    llvm::BlockFrequencyInfoImplBase::computeLoopScale((uint64_t)a1, a2);
    llvm::BlockFrequencyInfoImplBase::packageLoop((uint64_t)a1, a2);
    return 1;
  }
  long long v12 = (unsigned int *)(*(void *)(a2 + 96) + 4 * v10);
  uint64_t v13 = 4 * v11 - 4 * v10;
  while ((sub_1CBF7C794(a1, a2, v12) & 1) != 0)
  {
    ++v12;
    v13 -= 4;
    if (!v13) {
      goto LABEL_8;
    }
  }
  return 0;
}

uint64_t *sub_1CBF7C6A8(uint64_t *a1, unsigned int a2)
{
  unsigned int v4 = a2 >> 7;
  if (!a1[2])
  {
    int32x2_t result = (uint64_t *)operator new(0x28uLL);
    *((_DWORD *)result + 4) = v4;
    result[3] = 0;
    result[4] = 0;
    uint64_t v9 = *a1;
    *(void *)(v9 + 8) = result;
    *a1 = (uint64_t)result;
    *int32x2_t result = v9;
    result[1] = (uint64_t)a1;
    uint64_t v10 = 1;
LABEL_6:
    a1[2] = v10;
    goto LABEL_4;
  }
  int32x2_t result = sub_1CBF7CC48(a1, a2 >> 7);
  uint64_t v6 = a1;
  if (result == a1)
  {
LABEL_9:
    int32x2_t result = (uint64_t *)operator new(0x28uLL);
    *int32x2_t result = 0;
    result[1] = 0;
    *((_DWORD *)result + 4) = v4;
    result[3] = 0;
    result[4] = 0;
    uint64_t v11 = *v6;
    *(void *)(v11 + 8) = result;
    *int32x2_t result = v11;
    *uint64_t v6 = (uint64_t)result;
    result[1] = (uint64_t)v6;
    uint64_t v10 = a1[2] + 1;
    goto LABEL_6;
  }
  unsigned int v7 = *((_DWORD *)result + 4);
  if (v7 != v4)
  {
    uint64_t v6 = result;
    if (v7 < v4) {
      uint64_t v6 = (uint64_t *)result[1];
    }
    goto LABEL_9;
  }
LABEL_4:
  a1[3] = (uint64_t)result;
  unint64_t v8 = &result[(a2 >> 6) & 1];
  v8[3] |= 1 << a2;
  return result;
}

uint64_t sub_1CBF7C794(void *a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  v31[0] = v32;
  v31[1] = (void *)0x400000000;
  v32[8] = 0;
  char v33 = 0;
  uint64_t v8 = *a3;
  uint64_t v9 = *(void *)(a1[8] + 24 * v8 + 8);
  if (!v9 || !*(unsigned char *)(v9 + 8))
  {
    uint64_t v10 = *(void *)(a1[17] + 8 * v8);
    uint64_t v11 = *(void *)(v10 + 40);
    if (v11 != v10 + 40)
    {
      if (v11) {
        uint64_t v12 = v11 - 24;
      }
      else {
        uint64_t v12 = 0;
      }
      unsigned int v13 = *(unsigned __int8 *)(v12 + 16);
      if (v13 - 29 >= 0xB) {
        uint64_t v14 = 0;
      }
      else {
        uint64_t v14 = v12;
      }
      if (v13 == 30)
      {
        if ((*(_DWORD *)(v12 + 20) & 0x7FFFFFF) == 3) {
          int v15 = 2;
        }
        else {
          int v15 = 1;
        }
        goto LABEL_14;
      }
      int v15 = 2;
      switch(*(unsigned char *)(v12 + 16))
      {
        case 0x1E:
LABEL_37:
          __break(1u);
LABEL_38:
          int v27 = *(_DWORD *)(v12 + 20);
          if ((v27 & 0x40000000) != 0) {
            uint64_t v24 = *(void *)(v12 - 8);
          }
          else {
            uint64_t v24 = v14 - 32 * (v27 & 0x7FFFFFF);
          }
          uint64_t v25 = v13 + 1;
LABEL_28:
          unsigned int v17 = (uint64_t *)(v24 + 32 * v25);
          goto LABEL_17;
        case 0x1F:
          int v15 = (*(_DWORD *)(v12 + 20) >> 1) & 0x3FFFFFF;
          break;
        case 0x20:
        case 0x26:
          int v15 = (*(_DWORD *)(v12 + 20) & 0x7FFFFFF) - 1;
          break;
        case 0x21:
          goto LABEL_14;
        case 0x24:
          int v15 = *(_WORD *)(v12 + 18) & 1;
          break;
        case 0x25:
          int v15 = 1;
          goto LABEL_14;
        case 0x27:
          int v15 = *(_DWORD *)(v12 + 80) + 1;
          break;
        default:
          goto LABEL_20;
      }
      if (v15)
      {
LABEL_14:
        unsigned int v13 = 0;
        int v3 = 0;
        unsigned int v4 = (uint64_t *)(v12 - 32);
        do
        {
          int v16 = *(unsigned __int8 *)(v12 + 16);
          if (v16 == 30)
          {
            unsigned int v17 = &v4[-4 * v13];
          }
          else
          {
            uint64_t v22 = (v16 - 31);
            unsigned int v17 = v4;
            switch(v22)
            {
              case 1:
              case 7:
                goto LABEL_38;
              case 2:
                BOOL v28 = v13 == 0;
                uint64_t v29 = -64;
                if (v28) {
                  uint64_t v29 = -96;
                }
                unsigned int v17 = (uint64_t *)(v14 + v29);
                break;
              case 3:
              case 4:
                goto LABEL_37;
              case 5:
                if ((*(_WORD *)(v12 + 18) & 1) == 0)
                {
                  uint64_t v18 = 0;
                  goto LABEL_18;
                }
                unsigned int v17 = (uint64_t *)(v12 - 32 * (*(_DWORD *)(v12 + 20) & 0x7FFFFFF) + 32);
                break;
              case 6:
                break;
              case 8:
                unsigned int v17 = (uint64_t *)(v12 - 32 * *(unsigned int *)(v12 + 80) - 64);
                if (v13) {
                  unsigned int v17 = &v4[4 * v13 - 4 + -4 * *(unsigned int *)(v12 + 80)];
                }
                break;
              default:
                int v23 = *(_DWORD *)(v12 + 20);
                if ((v23 & 0x40000000) != 0) {
                  uint64_t v24 = *(void *)(v12 - 8);
                }
                else {
                  uint64_t v24 = v14 - 32 * (v23 & 0x7FFFFFF);
                }
                uint64_t v25 = (2 * v13) | 1;
                goto LABEL_28;
            }
          }
LABEL_17:
          uint64_t v18 = *v17;
LABEL_18:
          unsigned int v30 = sub_1CBF7A45C((uint64_t)a1, v18);
          unsigned int EdgeProbability = llvm::BranchProbabilityInfo::getEdgeProbability(a1[14], v10, v3);
          if (!llvm::BlockFrequencyInfoImplBase::addToDist((uint64_t)a1, (uint64_t)v31, a2, a3, &v30, EdgeProbability))goto LABEL_36; {
          unsigned int v13 = ++v3;
          }
        }
        while (v15 != v3);
      }
    }
LABEL_20:
    llvm::BlockFrequencyInfoImplBase::distributeMass((uint64_t)a1, a3, a2, (llvm::BlockFrequencyInfoImplBase::Distribution *)v31);
    uint64_t v20 = 1;
    goto LABEL_21;
  }
  do
  {
    uint64_t v26 = v9;
    uint64_t v9 = *(void *)v9;
  }
  while (v9 && *(unsigned char *)(v9 + 8));
  if (llvm::BlockFrequencyInfoImplBase::addLoopSuccessorsToDist((uint64_t)a1, a2, v26, (uint64_t)v31)) {
    goto LABEL_20;
  }
LABEL_36:
  uint64_t v20 = 0;
LABEL_21:
  if (v31[0] != v32) {
    free(v31[0]);
  }
  return v20;
}

uint64_t *sub_1CBF7CB04(int *a1)
{
  uint64_t v1 = (uint64_t *)*((void *)a1 + 1);
  if (!v1) {
    return (uint64_t *)(a1 + 4);
  }
  unint64_t v3 = *((unsigned int *)v1 + 3);
  unsigned int v4 = (unsigned int *)v1[12];
  if (v3 >= 2)
  {
    unsigned int v5 = *a1;
    uint64_t v8 = (unsigned int *)v1[12];
    unint64_t v9 = *((unsigned int *)v1 + 3);
    do
    {
      unint64_t v10 = v9 >> 1;
      uint64_t v11 = &v8[v9 >> 1];
      unsigned int v13 = *v11;
      uint64_t v12 = v11 + 1;
      v9 += ~(v9 >> 1);
      if (v13 < v5) {
        uint64_t v8 = v12;
      }
      else {
        unint64_t v9 = v10;
      }
    }
    while (v9);
    uint64_t v14 = &v4[v3];
    if (v8 == v14 || v5 < *v8 || !*((unsigned char *)v1 + 8)) {
      return (uint64_t *)(a1 + 4);
    }
    do
    {
      unint64_t v15 = v3 >> 1;
      int v16 = &v4[v3 >> 1];
      unsigned int v18 = *v16;
      unsigned int v17 = v16 + 1;
      v3 += ~(v3 >> 1);
      if (v18 < v5) {
        unsigned int v4 = v17;
      }
      else {
        unint64_t v3 = v15;
      }
    }
    while (v3);
    if (v4 == v14 || v5 < *v4) {
      return v1 + 19;
    }
  }
  else
  {
    unsigned int v5 = *a1;
    if (*a1 != *v4 || !*((unsigned char *)v1 + 8)) {
      return (uint64_t *)(a1 + 4);
    }
  }
  uint64_t v6 = *v1;
  if (!*v1) {
    return v1 + 19;
  }
  uint64_t v7 = *(unsigned int *)(v6 + 12);
  if (v7 < 2) {
    return v1 + 19;
  }
  uint64_t v19 = *(unsigned int **)(v6 + 96);
  unint64_t v20 = *(unsigned int *)(v6 + 12);
  do
  {
    unint64_t v21 = v20 >> 1;
    uint64_t v22 = &v19[v20 >> 1];
    unsigned int v24 = *v22;
    int v23 = v22 + 1;
    v20 += ~(v20 >> 1);
    if (v24 < v5) {
      uint64_t v19 = v23;
    }
    else {
      unint64_t v20 = v21;
    }
  }
  while (v20);
  if (v19 == (unsigned int *)(*(void *)(v6 + 96) + 4 * v7) || v5 < *v19 || !*(unsigned char *)(v6 + 8)) {
    return v1 + 19;
  }
  return (uint64_t *)(v6 + 152);
}

uint64_t *sub_1CBF7CC48(uint64_t *a1, unsigned int a2)
{
  unint64_t v2 = (uint64_t *)a1[1];
  if (!a1[2]) {
    goto LABEL_17;
  }
  unint64_t v3 = (uint64_t *)a1[3];
  if (v3 == a1)
  {
    unint64_t v3 = (uint64_t *)*a1;
    a1[3] = *a1;
  }
  unsigned int v4 = *((_DWORD *)v3 + 4);
  if (v4 != a2)
  {
    if (v4 <= a2)
    {
      unint64_t v2 = a1;
      if (v3 != a1)
      {
        while (*((_DWORD *)v3 + 4) < a2)
        {
          unint64_t v3 = (uint64_t *)v3[1];
          if (v3 == a1)
          {
            unint64_t v2 = a1;
            goto LABEL_17;
          }
        }
        goto LABEL_16;
      }
    }
    else if (v2 != v3)
    {
      while (*((_DWORD *)v3 + 4) > a2)
      {
        unint64_t v3 = (uint64_t *)*v3;
        if (v3 == v2) {
          goto LABEL_17;
        }
      }
LABEL_16:
      unint64_t v2 = v3;
    }
LABEL_17:
    a1[3] = (uint64_t)v2;
    return v2;
  }
  return v3;
}

int *sub_1CBF7CCE0@<X0>(uint64_t a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    uint64_t v7 = *(void *)a1;
    unsigned int v8 = (37 * *a2) & (v6 - 1);
    int32x2_t result = (int *)(*(void *)a1 + 4 * v8);
    int v10 = *result;
    if (*a2 == *result)
    {
LABEL_17:
      char v14 = 0;
      goto LABEL_9;
    }
    uint64_t v11 = 0;
    int v12 = 1;
    while (v10 != -1)
    {
      if (v11) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v10 == -2;
      }
      if (v15) {
        uint64_t v11 = result;
      }
      unsigned int v16 = v8 + v12++;
      unsigned int v8 = v16 & (v6 - 1);
      int32x2_t result = (int *)(v7 + 4 * v8);
      int v10 = *result;
      if (*a2 == *result) {
        goto LABEL_17;
      }
    }
    if (v11) {
      unsigned int v13 = v11;
    }
    else {
      unsigned int v13 = result;
    }
  }
  else
  {
    unsigned int v13 = 0;
  }
  int32x2_t result = sub_1CBB29C30(a1, (uint64_t)a2, a2, v13);
  *int32x2_t result = *a2;
  uint64_t v7 = *(void *)a1;
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  char v14 = 1;
LABEL_9:
  *(void *)a3 = result;
  *(void *)(a3 + 8) = v7 + 4 * v6;
  *(unsigned char *)(a3 + 16) = v14;
  return result;
}

void sub_1CBF7CDC4(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (void **)**a1;
  if (v2)
  {
    unsigned int v4 = (void **)v1[1];
    unsigned int v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unsigned int v6 = v4 - 7;
        sub_1CB904DFC(v4 - 6);
        unsigned int v4 = v6;
      }
      while (v6 != v2);
      unsigned int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1CBF7CE4C(void *a1)
{
  unint64_t v2 = (int *)a1[8];
  unint64_t v3 = (uint64_t *)*((void *)v2 + 1);
  if (!v3) {
    goto LABEL_2;
  }
  unint64_t v12 = *((unsigned int *)v3 + 3);
  unsigned int v13 = (unsigned int *)v3[12];
  if (v12 >= 2)
  {
    unsigned int v14 = *v2;
    unsigned int v17 = (unsigned int *)v3[12];
    unint64_t v18 = *((unsigned int *)v3 + 3);
    do
    {
      unint64_t v19 = v18 >> 1;
      unint64_t v20 = &v17[v18 >> 1];
      unsigned int v22 = *v20;
      unint64_t v21 = v20 + 1;
      v18 += ~(v18 >> 1);
      if (v22 < v14) {
        unsigned int v17 = v21;
      }
      else {
        unint64_t v18 = v19;
      }
    }
    while (v18);
    int v23 = &v13[v12];
    if (v17 == v23 || v14 < *v17 || !*((unsigned char *)v3 + 8)) {
      goto LABEL_2;
    }
    do
    {
      unint64_t v24 = v12 >> 1;
      uint64_t v25 = &v13[v12 >> 1];
      unsigned int v27 = *v25;
      uint64_t v26 = v25 + 1;
      v12 += ~(v12 >> 1);
      if (v27 < v14) {
        unsigned int v13 = v26;
      }
      else {
        unint64_t v12 = v24;
      }
    }
    while (v12);
    if (v13 == v23 || v14 < *v13) {
      goto LABEL_19;
    }
  }
  else
  {
    unsigned int v14 = *v2;
    if (*v2 != *v13 || !*((unsigned char *)v3 + 8))
    {
LABEL_2:
      unsigned int v4 = v2 + 4;
      goto LABEL_3;
    }
  }
  uint64_t v15 = *v3;
  if (!*v3) {
    goto LABEL_19;
  }
  uint64_t v16 = *(unsigned int *)(v15 + 12);
  if (v16 < 2) {
    goto LABEL_19;
  }
  BOOL v28 = *(unsigned int **)(v15 + 96);
  unint64_t v29 = *(unsigned int *)(v15 + 12);
  do
  {
    unint64_t v30 = v29 >> 1;
    BOOL v31 = &v28[v29 >> 1];
    unsigned int v33 = *v31;
    unint64_t v32 = v31 + 1;
    v29 += ~(v29 >> 1);
    if (v33 < v14) {
      BOOL v28 = v32;
    }
    else {
      unint64_t v29 = v30;
    }
  }
  while (v29);
  if (v28 == (unsigned int *)(*(void *)(v15 + 96) + 4 * v16) || v14 < *v28 || !*(unsigned char *)(v15 + 8))
  {
LABEL_19:
    unsigned int v4 = v3 + 19;
    goto LABEL_3;
  }
  unsigned int v4 = (void *)(v15 + 152);
LABEL_3:
  *unsigned int v4 = -1;
  uint64_t v5 = a1[17];
  uint64_t v6 = a1[18];
  if (v5 == v6) {
    return 1;
  }
  while (1)
  {
    unsigned int v34 = (unint64_t)(v5 - a1[17]) >> 3;
    uint64_t v7 = a1[8] + 24 * v34;
    unsigned int v8 = *(uint64_t **)(v7 + 8);
    unint64_t v9 = (_DWORD *)v7;
    if (v8)
    {
      unint64_t v9 = (_DWORD *)(a1[8] + 24 * v34);
      if (*((unsigned char *)v8 + 8))
      {
        do
        {
          int v10 = v8;
          unsigned int v8 = (uint64_t *)*v8;
        }
        while (v8 && *((unsigned char *)v8 + 8));
        unint64_t v9 = (_DWORD *)v10[12];
      }
    }
    if (*v9 == *(_DWORD *)v7)
    {
      uint64_t result = sub_1CBF7C794(a1, 0, &v34);
      if (!result) {
        break;
      }
    }
    v5 += 8;
    if (v5 == v6) {
      return 1;
    }
  }
  return result;
}

void sub_1CBF7D058(uint64_t a1, char **a2)
{
  long long v175 = 0u;
  long long v176 = 0u;
  long long v174 = 0u;
  unint64_t v169 = v173;
  uint64_t v170 = v173;
  uint64_t v171 = 8;
  int v172 = 0;
  uint64_t v4 = *(void *)(*(void *)(a1 + 128) + 80);
  if (v4) {
    uint64_t v5 = v4 - 24;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v168 = v5;
  sub_1CD45F140(&v174, &v168);
  uint64_t v6 = v170;
  uint64_t v7 = HIDWORD(v171);
  if (v170 != v169)
  {
    unsigned int v11 = v171;
    goto LABEL_15;
  }
  if (!HIDWORD(v171))
  {
LABEL_12:
    unsigned int v11 = v171;
    if (HIDWORD(v171) < v171)
    {
      ++HIDWORD(v171);
      *(void *)&v170[8 * v7] = v5;
      goto LABEL_36;
    }
LABEL_15:
    if (3 * v11 <= 4 * (HIDWORD(v171) - v172))
    {
      if (v11 >= 0x40) {
        v11 *= 2;
      }
      else {
        unsigned int v11 = 128;
      }
    }
    else if (v11 - HIDWORD(v171) >= v11 >> 3)
    {
      goto LABEL_17;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v169, v11);
    unsigned int v11 = v171;
    uint64_t v6 = v170;
LABEL_17:
    unsigned int v12 = v11 - 1;
    unsigned int v13 = (v11 - 1) & ((v5 >> 4) ^ (v5 >> 9));
    unsigned int v14 = &v6[8 * v13];
    uint64_t v15 = *(void *)v14;
    if (*(void *)v14 == -1)
    {
      uint64_t v16 = 0;
LABEL_29:
      if (v16) {
        unint64_t v20 = v16;
      }
      else {
        unint64_t v20 = v14;
      }
      if (*(void *)v20 != v5)
      {
        if (*(void *)v20 == -2) {
          --v172;
        }
        else {
          ++HIDWORD(v171);
        }
        *(void *)unint64_t v20 = v5;
      }
    }
    else
    {
      uint64_t v16 = 0;
      int v17 = 1;
      while (v15 != v5)
      {
        if (v16) {
          BOOL v18 = 0;
        }
        else {
          BOOL v18 = v15 == -2;
        }
        if (v18) {
          uint64_t v16 = v14;
        }
        unsigned int v19 = v13 + v17++;
        unsigned int v13 = v19 & v12;
        unsigned int v14 = &v6[8 * (v19 & v12)];
        uint64_t v15 = *(void *)v14;
        if (*(void *)v14 == -1) {
          goto LABEL_29;
        }
      }
    }
    goto LABEL_36;
  }
  unsigned int v8 = 0;
  uint64_t v9 = 8 * HIDWORD(v171);
  int v10 = v170;
  while (*v10 != v5)
  {
    if (*v10 == -2) {
      unsigned int v8 = v10;
    }
    ++v10;
    v9 -= 8;
    if (!v9)
    {
      if (!v8) {
        goto LABEL_12;
      }
      *unsigned int v8 = v5;
      --v172;
      break;
    }
  }
LABEL_36:
  int v161 = a2;
  uint64_t v21 = *((void *)&v176 + 1);
  if (*((void *)&v176 + 1))
  {
    while (1)
    {
      uint64_t v57 = *(void *)(*(void *)(*((void *)&v174 + 1) + (((unint64_t)v176 >> 6) & 0x3FFFFFFFFFFFFF8))
                      + 8 * (v176 & 0x1FF));
      *(void *)&long long v176 = v176 + 1;
      *((void *)&v176 + 1) = v21 - 1;
      if ((unint64_t)v176 >= 0x400)
      {
        operator delete(**((void ***)&v174 + 1));
        *((void *)&v174 + 1) += 8;
        *(void *)&long long v176 = v176 - 512;
      }
      uint64_t v58 = *(void *)(v57 + 40);
      if (v58 != v57 + 40) {
        break;
      }
LABEL_202:
      uint64_t v21 = *((void *)&v176 + 1);
      if (!*((void *)&v176 + 1)) {
        goto LABEL_37;
      }
    }
    if (v58) {
      uint64_t v59 = v58 - 24;
    }
    else {
      uint64_t v59 = 0;
    }
    int v60 = *(unsigned __int8 *)(v59 + 16);
    int v61 = v60 - 29;
    if (v60 != 30)
    {
      unsigned int v90 = 2;
      switch(v61)
      {
        case 1:
LABEL_381:
          __break(1u);
          JUMPOUT(0x1CBF7DEBCLL);
        case 2:
          unsigned int v90 = (*(_DWORD *)(v59 + 20) >> 1) & 0x3FFFFFF;
          goto LABEL_205;
        case 3:
        case 9:
          unsigned int v90 = (*(_DWORD *)(v59 + 20) & 0x7FFFFFF) - 1;
          goto LABEL_205;
        case 4:
          goto LABEL_135;
        case 7:
          unsigned int v90 = *(_WORD *)(v59 + 18) & 1;
          goto LABEL_205;
        case 8:
          unsigned int v90 = 1;
          goto LABEL_135;
        case 10:
          unsigned int v90 = *(_DWORD *)(v59 + 80) + 1;
LABEL_205:
          if (!v90) {
            goto LABEL_202;
          }
          goto LABEL_135;
        default:
          goto LABEL_202;
      }
    }
    if ((*(_DWORD *)(v59 + 20) & 0x7FFFFFF) == 3) {
      unsigned int v90 = 2;
    }
    else {
      unsigned int v90 = 1;
    }
LABEL_135:
    uint64_t v62 = 0;
    uint64_t v63 = v59 - 32;
    uint64_t v64 = v90;
    while (1)
    {
      uint64_t v163 = 0;
      int v65 = *(unsigned __int8 *)(v59 + 16);
      if (v65 == 30)
      {
        unint64_t v83 = (uint64_t *)(v63 - 32 * v62);
      }
      else
      {
        uint64_t v82 = (v65 - 31);
        unint64_t v83 = (uint64_t *)(v59 - 32);
        switch(v82)
        {
          case 1:
          case 7:
            int v87 = *(_DWORD *)(v59 + 20);
            if ((v87 & 0x40000000) != 0) {
              uint64_t v88 = *(void *)(v59 - 8);
            }
            else {
              uint64_t v88 = v59 - 32 * (v87 & 0x7FFFFFF);
            }
            uint64_t v86 = v88 + 32 * v62;
            goto LABEL_180;
          case 2:
            uint64_t v89 = -64;
            if (!v62) {
              uint64_t v89 = -96;
            }
            unint64_t v83 = (uint64_t *)(v59 + v89);
            break;
          case 3:
          case 4:
            goto LABEL_381;
          case 5:
            if ((*(_WORD *)(v59 + 18) & 1) == 0)
            {
              uint64_t v66 = 0;
              goto LABEL_140;
            }
            unint64_t v83 = (uint64_t *)(v59 + 32 - 32 * (*(_DWORD *)(v59 + 20) & 0x7FFFFFF));
            break;
          case 6:
            break;
          case 8:
            if (v62) {
              unint64_t v83 = (uint64_t *)(v63 - 32 * *(unsigned int *)(v59 + 80) + 32 * v62 - 32);
            }
            else {
              unint64_t v83 = (uint64_t *)(v59 - 64 - 32 * *(unsigned int *)(v59 + 80));
            }
            break;
          default:
            int v84 = *(_DWORD *)(v59 + 20);
            if ((v84 & 0x40000000) != 0) {
              uint64_t v85 = *(void *)(v59 - 8);
            }
            else {
              uint64_t v85 = v59 - 32 * (v84 & 0x7FFFFFF);
            }
            uint64_t v86 = v85 + 32 * (2 * v62);
LABEL_180:
            unint64_t v83 = (uint64_t *)(v86 + 32);
            break;
        }
      }
      uint64_t v66 = *v83;
LABEL_140:
      uint64_t v163 = (char *)v66;
      if (!llvm::BranchProbabilityInfo::getEdgeProbability(*(void *)(a1 + 112), v57, v66)) {
        goto LABEL_174;
      }
      unsigned int v67 = v170;
      uint64_t v68 = HIDWORD(v171);
      if (v170 != v169) {
        break;
      }
      if (HIDWORD(v171))
      {
        uint64_t v69 = 0;
        uint64_t v70 = 8 * HIDWORD(v171);
        uint64_t v71 = (uint64_t *)v170;
        while (*v71 != v66)
        {
          if (*v71 == -2) {
            uint64_t v69 = v71;
          }
          ++v71;
          v70 -= 8;
          if (!v70)
          {
            if (!v69) {
              goto LABEL_149;
            }
            *uint64_t v69 = v66;
            --v172;
            goto LABEL_173;
          }
        }
        goto LABEL_174;
      }
LABEL_149:
      unsigned int v72 = v171;
      if (HIDWORD(v171) >= v171) {
        goto LABEL_152;
      }
      ++HIDWORD(v171);
      *(void *)&v170[8 * v68] = v66;
LABEL_173:
      sub_1CD45F140(&v174, &v163);
LABEL_174:
      if (++v62 == v64) {
        goto LABEL_202;
      }
    }
    unsigned int v72 = v171;
LABEL_152:
    if (3 * v72 <= 4 * (HIDWORD(v171) - v172))
    {
      if (v72 >= 0x40) {
        v72 *= 2;
      }
      else {
        unsigned int v72 = 128;
      }
    }
    else if (v72 - HIDWORD(v171) >= v72 >> 3)
    {
LABEL_154:
      unsigned int v73 = v72 - 1;
      unsigned int v74 = (v72 - 1) & ((v66 >> 4) ^ (v66 >> 9));
      uint64_t v75 = &v67[8 * v74];
      uint64_t v76 = *(void *)v75;
      if (*(void *)v75 != -1)
      {
        int v77 = 0;
        int v78 = 1;
        while (v76 != v66)
        {
          if (v77) {
            BOOL v79 = 0;
          }
          else {
            BOOL v79 = v76 == -2;
          }
          if (v79) {
            int v77 = (uint64_t *)v75;
          }
          unsigned int v80 = v74 + v78++;
          unsigned int v74 = v80 & v73;
          uint64_t v75 = &v67[8 * (v80 & v73)];
          uint64_t v76 = *(void *)v75;
          if (*(void *)v75 == -1) {
            goto LABEL_166;
          }
        }
        goto LABEL_174;
      }
      int v77 = 0;
LABEL_166:
      if (v77) {
        unint64_t v81 = v77;
      }
      else {
        unint64_t v81 = (uint64_t *)v75;
      }
      if (*v81 == v66) {
        goto LABEL_174;
      }
      if (*v81 == -2) {
        --v172;
      }
      else {
        ++HIDWORD(v171);
      }
      *unint64_t v81 = v66;
      goto LABEL_173;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v169, v72);
    unsigned int v72 = v171;
    unsigned int v67 = v170;
    goto LABEL_154;
  }
LABEL_37:
  uint64_t v163 = v167;
  unint64_t v164 = v167;
  uint64_t v165 = 8;
  int v166 = 0;
  uint64_t v22 = *(void *)(a1 + 128);
  uint64_t v23 = v22 + 72;
  uint64_t v24 = *(void *)(v22 + 80);
  uint64_t v25 = v161;
  if (v24 != v22 + 72)
  {
    while (1)
    {
      if (v24) {
        uint64_t v26 = v24 - 24;
      }
      else {
        uint64_t v26 = 0;
      }
      uint64_t v27 = *(void *)(v26 + 40);
      if (v27 == v26 + 40)
      {
LABEL_47:
        unint64_t v29 = v169;
        if (v170 == v169)
        {
          int v30 = HIDWORD(v171);
          BOOL v31 = &v170[8 * HIDWORD(v171)];
          if (HIDWORD(v171))
          {
            uint64_t v32 = 0;
            while (*(void *)&v170[v32] != v26)
            {
              v32 += 8;
              if (8 * HIDWORD(v171) == v32) {
                goto LABEL_67;
              }
            }
            BOOL v31 = &v170[v32];
          }
LABEL_67:
          unint64_t v29 = v170;
        }
        else
        {
          int v33 = v171 - 1;
          unsigned int v34 = (v171 - 1) & ((v26 >> 4) ^ (v26 >> 9));
          BOOL v31 = &v170[8 * v34];
          uint64_t v35 = *(void *)v31;
          if (*(void *)v31 == -1)
          {
            int v40 = 0;
LABEL_75:
            if (v40) {
              BOOL v31 = v40;
            }
            int v30 = HIDWORD(v171);
            if (*(void *)v31 != v26) {
              BOOL v31 = &v170[8 * v171];
            }
          }
          else
          {
            int v40 = 0;
            int v36 = 1;
            while (v35 != v26)
            {
              if (v40) {
                BOOL v37 = 0;
              }
              else {
                BOOL v37 = v35 == -2;
              }
              if (v37) {
                int v40 = v31;
              }
              unsigned int v38 = v34 + v36++;
              unsigned int v34 = v38 & v33;
              BOOL v31 = &v170[8 * (v38 & v33)];
              uint64_t v35 = *(void *)v31;
              if (*(void *)v31 == -1) {
                goto LABEL_75;
              }
            }
            int v30 = HIDWORD(v171);
          }
        }
        if (v170 == v29) {
          int v39 = v30;
        }
        else {
          int v39 = v171;
        }
        if (v31 == &v170[8 * v39]) {
          goto LABEL_73;
        }
        uint64_t v162 = v26;
        sub_1CD45F140(&v174, &v162);
        unsigned int v41 = v164;
        uint64_t v42 = HIDWORD(v165);
        if (v164 != v163)
        {
          unsigned int v46 = v165;
LABEL_91:
          if (3 * v46 <= 4 * (HIDWORD(v165) - v166))
          {
            if (v46 >= 0x40) {
              v46 *= 2;
            }
            else {
              unsigned int v46 = 128;
            }
          }
          else if (v46 - HIDWORD(v165) >= v46 >> 3)
          {
            goto LABEL_93;
          }
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v163, v46);
          unsigned int v46 = v165;
          unsigned int v41 = v164;
LABEL_93:
          unsigned int v47 = v46 - 1;
          unsigned int v48 = (v46 - 1) & ((v26 >> 4) ^ (v26 >> 9));
          int v49 = &v41[8 * v48];
          uint64_t v50 = *(void *)v49;
          if (*(void *)v49 == -1)
          {
            uint64_t v51 = 0;
LABEL_108:
            if (v51) {
              unsigned int v56 = v51;
            }
            else {
              unsigned int v56 = v49;
            }
            if (*v56 != v26)
            {
              if (*v56 == -2) {
                --v166;
              }
              else {
                ++HIDWORD(v165);
              }
              *unsigned int v56 = v26;
            }
          }
          else
          {
            uint64_t v51 = 0;
            int v52 = 1;
            while (v50 != v26)
            {
              if (v51) {
                BOOL v53 = 0;
              }
              else {
                BOOL v53 = v50 == -2;
              }
              if (v53) {
                uint64_t v51 = v49;
              }
              unsigned int v54 = v48 + v52++;
              unsigned int v48 = v54 & v47;
              int v49 = &v41[8 * (v54 & v47)];
              uint64_t v50 = *(void *)v49;
              if (*(void *)v49 == -1) {
                goto LABEL_108;
              }
            }
          }
          goto LABEL_73;
        }
        if (HIDWORD(v165))
        {
          uint64_t v43 = 0;
          uint64_t v44 = 8 * HIDWORD(v165);
          uint64_t v45 = (uint64_t *)v164;
          while (*v45 != v26)
          {
            if (*v45 == -2) {
              uint64_t v43 = v45;
            }
            ++v45;
            v44 -= 8;
            if (!v44)
            {
              if (!v43) {
                goto LABEL_88;
              }
              *uint64_t v43 = v26;
              --v166;
              goto LABEL_73;
            }
          }
          goto LABEL_73;
        }
LABEL_88:
        unsigned int v46 = v165;
        if (HIDWORD(v165) >= v165) {
          goto LABEL_91;
        }
        ++HIDWORD(v165);
        *(void *)&v164[8 * v42] = v26;
      }
      else
      {
        if (v27) {
          uint64_t v28 = v27 - 24;
        }
        else {
          uint64_t v28 = 0;
        }
        if (*(unsigned char *)(v28 + 16) != 30)
        {
          switch(*(unsigned char *)(v28 + 16))
          {
            case 0x1E:
              goto LABEL_381;
            case 0x1F:
              int v55 = (*(_DWORD *)(v28 + 20) >> 1) & 0x3FFFFFF;
              goto LABEL_105;
            case 0x20:
            case 0x26:
              int v55 = (*(_DWORD *)(v28 + 20) & 0x7FFFFFF) - 1;
              goto LABEL_105;
            case 0x21:
            case 0x25:
              break;
            case 0x24:
              int v55 = *(_WORD *)(v28 + 18) & 1;
              goto LABEL_105;
            case 0x27:
              int v55 = *(_DWORD *)(v28 + 80) + 1;
LABEL_105:
              if (!v55) {
                goto LABEL_47;
              }
              break;
            default:
              goto LABEL_47;
          }
        }
      }
LABEL_73:
      uint64_t v24 = *(void *)(v24 + 8);
      if (v24 == v23)
      {
        uint64_t v91 = *((void *)&v176 + 1);
        if (!*((void *)&v176 + 1)) {
          break;
        }
LABEL_310:
        uint64_t v136 = *(void *)(*(void *)(*((void *)&v174 + 1) + (((unint64_t)v176 >> 6) & 0x3FFFFFFFFFFFFF8))
                         + 8 * (v176 & 0x1FF));
        *(void *)&long long v176 = v176 + 1;
        *((void *)&v176 + 1) = v91 - 1;
        if ((unint64_t)v176 >= 0x400)
        {
          operator delete(**((void ***)&v174 + 1));
          *((void *)&v174 + 1) += 8;
          *(void *)&long long v176 = v176 - 512;
        }
        uint64_t v137 = *(void *)(v136 + 8);
        if (v137)
        {
          while (1)
          {
            uint64_t v138 = *(void *)(v137 + 24);
            unsigned int v139 = *(unsigned __int8 *)(v138 + 16);
            BOOL v140 = v138 && v139 >= 0x1C;
            if (v140 && v139 - 29 <= 0xA) {
              break;
            }
            uint64_t v137 = *(void *)(v137 + 8);
            if (!v137) {
              goto LABEL_322;
            }
          }
LABEL_324:
          uint64_t v142 = *(void *)(v138 + 40);
          uint64_t v162 = v142;
          if (!llvm::BranchProbabilityInfo::getEdgeProbability(*(void *)(a1 + 112), v142, v136)) {
            goto LABEL_358;
          }
          unint64_t v143 = v164;
          uint64_t v144 = HIDWORD(v165);
          if (v164 == v163)
          {
            if (HIDWORD(v165))
            {
              unsigned int v145 = 0;
              uint64_t v146 = 8 * HIDWORD(v165);
              uint64_t v147 = (uint64_t *)v164;
              do
              {
                if (*v147 == v142) {
                  goto LABEL_358;
                }
                if (*v147 == -2) {
                  unsigned int v145 = v147;
                }
                ++v147;
                v146 -= 8;
              }
              while (v146);
              if (v145)
              {
                *unsigned int v145 = v142;
                --v166;
                goto LABEL_357;
              }
            }
            unsigned int v148 = v165;
            if (HIDWORD(v165) < v165)
            {
              ++HIDWORD(v165);
              *(void *)&v164[8 * v144] = v142;
LABEL_357:
              sub_1CD45F140(&v174, &v162);
              goto LABEL_358;
            }
          }
          else
          {
            unsigned int v148 = v165;
          }
          if (3 * v148 <= 4 * (HIDWORD(v165) - v166))
          {
            if (v148 >= 0x40) {
              v148 *= 2;
            }
            else {
              unsigned int v148 = 128;
            }
          }
          else if (v148 - HIDWORD(v165) >= v148 >> 3)
          {
            goto LABEL_338;
          }
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v163, v148);
          unsigned int v148 = v165;
          unint64_t v143 = v164;
LABEL_338:
          unsigned int v149 = v148 - 1;
          unsigned int v150 = (v148 - 1) & ((v142 >> 4) ^ (v142 >> 9));
          uint64_t v151 = &v143[8 * v150];
          uint64_t v152 = *(void *)v151;
          if (*(void *)v151 == -1)
          {
            uint64_t v153 = 0;
          }
          else
          {
            uint64_t v153 = 0;
            int v154 = 1;
            do
            {
              if (v152 == v142) {
                goto LABEL_358;
              }
              if (v153) {
                BOOL v155 = 0;
              }
              else {
                BOOL v155 = v152 == -2;
              }
              if (v155) {
                uint64_t v153 = (uint64_t *)v151;
              }
              unsigned int v156 = v150 + v154++;
              unsigned int v150 = v156 & v149;
              uint64_t v151 = &v143[8 * (v156 & v149)];
              uint64_t v152 = *(void *)v151;
            }
            while (*(void *)v151 != -1);
          }
          if (v153) {
            uint64_t v157 = v153;
          }
          else {
            uint64_t v157 = (uint64_t *)v151;
          }
          if (*v157 != v142)
          {
            if (*v157 == -2) {
              --v166;
            }
            else {
              ++HIDWORD(v165);
            }
            *uint64_t v157 = v142;
            goto LABEL_357;
          }
LABEL_358:
          while (1)
          {
            uint64_t v137 = *(void *)(v137 + 8);
            if (!v137) {
              break;
            }
            uint64_t v138 = *(void *)(v137 + 24);
            unsigned int v158 = *(unsigned __int8 *)(v138 + 16);
            if (v138) {
              BOOL v159 = v158 >= 0x1C;
            }
            else {
              BOOL v159 = 0;
            }
            if (v159 && v158 - 29 < 0xB) {
              goto LABEL_324;
            }
          }
        }
LABEL_322:
        uint64_t v91 = *((void *)&v176 + 1);
        if (!*((void *)&v176 + 1)) {
          break;
        }
        goto LABEL_310;
      }
    }
  }
  unint64_t v92 = -1;
  uint64_t v93 = *(void *)(a1 + 128) + 72;
  do
  {
    uint64_t v93 = *(void *)(v93 + 8);
    ++v92;
  }
  while (v93 != *(void *)(a1 + 128) + 72);
  sub_1CBF7ACFC((uint64_t)v161, v92);
  uint64_t v94 = *(void *)(a1 + 128);
  uint64_t v95 = v94 + 72;
  uint64_t v96 = *(void *)(v94 + 80);
  if (v96 != v94 + 72)
  {
    do
    {
      if (v96) {
        uint64_t v100 = v96 - 24;
      }
      else {
        uint64_t v100 = 0;
      }
      uint64_t v101 = v169;
      if (v170 == v169)
      {
        int v102 = HIDWORD(v171);
        uint64_t v103 = &v170[8 * HIDWORD(v171)];
        if (HIDWORD(v171))
        {
          uint64_t v104 = 0;
          while (*(void *)&v170[v104] != v100)
          {
            v104 += 8;
            if (8 * HIDWORD(v171) == v104) {
              goto LABEL_248;
            }
          }
          uint64_t v103 = &v170[v104];
        }
LABEL_248:
        uint64_t v101 = v170;
      }
      else
      {
        int v105 = v171 - 1;
        unsigned int v106 = (v171 - 1) & ((v100 >> 4) ^ (v100 >> 9));
        uint64_t v103 = &v170[8 * v106];
        uint64_t v107 = *(void *)v103;
        if (*(void *)v103 == -1)
        {
          uint64_t v108 = 0;
LABEL_289:
          if (v108) {
            uint64_t v103 = v108;
          }
          int v102 = HIDWORD(v171);
          if (*(void *)v103 != v100) {
            uint64_t v103 = &v170[8 * v171];
          }
        }
        else
        {
          uint64_t v108 = 0;
          int v109 = 1;
          while (v107 != v100)
          {
            if (v108) {
              BOOL v110 = 0;
            }
            else {
              BOOL v110 = v107 == -2;
            }
            if (v110) {
              uint64_t v108 = v103;
            }
            unsigned int v111 = v106 + v109++;
            unsigned int v106 = v111 & v105;
            uint64_t v103 = &v170[8 * (v111 & v105)];
            uint64_t v107 = *(void *)v103;
            if (*(void *)v103 == -1) {
              goto LABEL_289;
            }
          }
          int v102 = HIDWORD(v171);
        }
      }
      if (v170 == v101) {
        int v112 = v102;
      }
      else {
        int v112 = v171;
      }
      if (v103 != &v170[8 * v112])
      {
        unsigned int v113 = v163;
        if (v164 == v163)
        {
          int v114 = HIDWORD(v165);
          unsigned int v115 = &v164[8 * HIDWORD(v165)];
          if (HIDWORD(v165))
          {
            uint64_t v116 = 0;
            while (*(void *)&v164[v116] != v100)
            {
              v116 += 8;
              if (8 * HIDWORD(v165) == v116) {
                goto LABEL_272;
              }
            }
            unsigned int v115 = &v164[v116];
          }
LABEL_272:
          unsigned int v113 = v164;
        }
        else
        {
          int v117 = v165 - 1;
          unsigned int v118 = (v165 - 1) & ((v100 >> 4) ^ (v100 >> 9));
          unsigned int v115 = &v164[8 * v118];
          uint64_t v119 = *(void *)v115;
          if (*(void *)v115 == -1)
          {
            uint64_t v120 = 0;
LABEL_305:
            if (v120) {
              unsigned int v115 = v120;
            }
            int v114 = HIDWORD(v165);
            if (*(void *)v115 != v100) {
              unsigned int v115 = &v164[8 * v165];
            }
          }
          else
          {
            uint64_t v120 = 0;
            int v121 = 1;
            while (v119 != v100)
            {
              if (v120) {
                BOOL v122 = 0;
              }
              else {
                BOOL v122 = v119 == -2;
              }
              if (v122) {
                uint64_t v120 = v115;
              }
              unsigned int v123 = v118 + v121++;
              unsigned int v118 = v123 & v117;
              unsigned int v115 = &v164[8 * (v123 & v117)];
              uint64_t v119 = *(void *)v115;
              if (*(void *)v115 == -1) {
                goto LABEL_305;
              }
            }
            int v114 = HIDWORD(v165);
          }
        }
        if (v164 == v113) {
          int v124 = v114;
        }
        else {
          int v124 = v165;
        }
        if (v115 != &v164[8 * v124])
        {
          int v126 = v25[1];
          unint64_t v125 = (unint64_t)v25[2];
          if ((unint64_t)v126 >= v125)
          {
            unint64_t v128 = *v25;
            uint64_t v129 = (v126 - v128) >> 3;
            unint64_t v130 = v129 + 1;
            if ((unint64_t)(v129 + 1) >> 61) {
              abort();
            }
            uint64_t v131 = v125 - (void)v128;
            if (v131 >> 2 > v130) {
              unint64_t v130 = v131 >> 2;
            }
            if ((unint64_t)v131 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v132 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v132 = v130;
            }
            if (v132)
            {
              if (v132 >> 61) {
                sub_1CB833614();
              }
              unsigned int v133 = (char *)operator new(8 * v132);
            }
            else
            {
              unsigned int v133 = 0;
            }
            uint64_t v134 = &v133[8 * v129];
            *(void *)uint64_t v134 = v100;
            uint64_t v127 = v134 + 8;
            if (v126 == v128)
            {
              uint64_t v25 = v161;
            }
            else
            {
              do
              {
                uint64_t v135 = *((void *)v126 - 1);
                v126 -= 8;
                *((void *)v134 - 1) = v135;
                v134 -= 8;
              }
              while (v126 != v128);
              uint64_t v25 = v161;
              int v126 = *v161;
            }
            *uint64_t v25 = v134;
            v25[1] = v127;
            void v25[2] = &v133[8 * v132];
            if (v126) {
              operator delete(v126);
            }
          }
          else
          {
            *(void *)int v126 = v100;
            uint64_t v127 = v126 + 8;
          }
          v25[1] = v127;
        }
      }
      uint64_t v96 = *(void *)(v96 + 8);
    }
    while (v96 != v95);
  }
  if (v164 != v163) {
    free(v164);
  }
  if (v170 != v169) {
    free(v170);
  }
  sub_1CD3F260C(&v174);
  uint64_t v97 = (void **)*((void *)&v174 + 1);
  uint64_t v98 = (void **)v175;
  if (*((void *)&v174 + 1) != (void)v175)
  {
    do
    {
      int v99 = *v97++;
      operator delete(v99);
    }
    while (v97 != v98);
    if ((void)v175 != *((void *)&v174 + 1)) {
      *(void *)&long long v175 = v175 + ((*((void *)&v174 + 1) - v175 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if ((void)v174) {
    operator delete((void *)v174);
  }
}

uint64_t sub_1CBF7DF38(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)a1;
  if (!v3) {
    return a1;
  }
  if (!*(void *)a2) {
    goto LABEL_19;
  }
  int v4 = *(unsigned __int16 *)(a1 + 8);
  int v5 = *(unsigned __int16 *)(a2 + 8);
  unint64_t v6 = llvm::ScaledNumbers::divide64(v3, *(void *)a2);
  __int16 v8 = v4 - v5;
  *(void *)a1 = v6;
  *(_WORD *)(a1 + 8) = v7;
  if (v4 != v5 && v6 != 0)
  {
    if (v8 < 0)
    {
      int v10 = -v8;
      int v11 = v7 + 16382;
      if (v11 >= v10) {
        int v12 = -v8;
      }
      else {
        int v12 = v7 + 16382;
      }
      *(_WORD *)(a1 + 8) = v7 - v12;
      if (v11 >= v10) {
        return a1;
      }
      int v16 = v10 - v12;
      if (v16 >= 64)
      {
        *(void *)a1 = 0;
        *(_WORD *)(a1 + 8) = 0;
        return a1;
      }
      unint64_t v17 = v6 >> v16;
LABEL_23:
      *(void *)a1 = v17;
      return a1;
    }
    int v14 = 0x3FFF - v7;
    BOOL v15 = v14 < v8;
    if (v14 >= v8) {
      int v14 = v8;
    }
    *(_WORD *)(a1 + 8) = v14 + v7;
    if (v15)
    {
      int v18 = v14;
      int v19 = v8;
      if (sub_1CBF7ECD0(v6, (__int16)(v14 + v7), 0xFFFFFFFFFFFFFFFFLL, 0x3FFF))
      {
        if (v19 - v18 <= (int)__clz(*(void *)a1))
        {
          unint64_t v17 = *(void *)a1 << (v19 - v18);
          goto LABEL_23;
        }
LABEL_19:
        *(void *)a1 = -1;
        *(_WORD *)(a1 + 8) = 0x3FFF;
      }
    }
  }
  return a1;
}

void sub_1CBF7E058(void *a1, uint64_t *a2)
{
  uint64_t v166 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = (unint64_t)(1.0 / *(double *)&xmmword_1EBD02F98);
  if (v2)
  {
    unint64_t v153 = llvm::ScaledNumbers::divide64(1uLL, v2);
    __int16 v151 = v3;
  }
  else
  {
    unint64_t v153 = -1;
    __int16 v151 = 0x3FFF;
  }
  uint64_t v4 = dword_1EBD02ED8;
  unint64_t v5 = (a2[1] - *a2) >> 4;
  sub_1CD45F678(v161, v5);
  uint64_t v7 = *a2;
  uint64_t v6 = a2[1];
  if (v6 == *a2)
  {
    uint64_t v162 = v164;
    uint64_t v163 = 0x600000000;
    int v165 = 0;
    long long v159 = 0u;
    long long v160 = 0u;
    long long v158 = 0u;
    goto LABEL_246;
  }
  unint64_t v8 = 0;
  unint64_t v152 = v5 * v4;
  do
  {
    uint64_t v9 = *a1 + 24 * v8;
    int v11 = *(void **)v9;
    int v10 = *(void **)(v9 + 8);
    if (*(void **)v9 != v10)
    {
      do
      {
        uint64_t v12 = v161[0] + 24 * *v11;
        BOOL v15 = *(unint64_t **)(v12 + 8);
        int v14 = (void *)(v12 + 8);
        unsigned int v13 = v15;
        unint64_t v16 = v14[1];
        if ((unint64_t)v15 >= v16)
        {
          int v18 = (void **)(v161[0] + 24 * *v11);
          int v19 = (unint64_t *)*v18;
          uint64_t v20 = ((char *)v13 - (unsigned char *)*v18) >> 3;
          unint64_t v21 = v20 + 1;
          if ((unint64_t)(v20 + 1) >> 61) {
            abort();
          }
          uint64_t v22 = v16 - (void)v19;
          if (v22 >> 2 > v21) {
            unint64_t v21 = v22 >> 2;
          }
          if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v23 = v21;
          }
          if (v23)
          {
            if (v23 >> 61) {
              sub_1CB833614();
            }
            uint64_t v24 = (char *)operator new(8 * v23);
          }
          else
          {
            uint64_t v24 = 0;
          }
          uint64_t v25 = (unint64_t *)&v24[8 * v20];
          *uint64_t v25 = v8;
          unint64_t v17 = v25 + 1;
          while (v13 != v19)
          {
            unint64_t v26 = *--v13;
            *--uint64_t v25 = v26;
          }
          *int v18 = v25;
          *int v14 = v17;
          v14[1] = &v24[8 * v23];
          if (v19) {
            operator delete(v19);
          }
        }
        else
        {
          *unsigned int v13 = v8;
          unint64_t v17 = v13 + 1;
        }
        *int v14 = v17;
        v11 += 3;
      }
      while (v11 != v10);
      uint64_t v7 = *a2;
      uint64_t v6 = a2[1];
    }
    ++v8;
    unint64_t v27 = v6 - v7;
  }
  while (v8 < (v6 - v7) >> 4);
  unint64_t v28 = v27 >> 4;
  uint64_t v29 = ((v27 >> 4) + 63) >> 6;
  uint64_t v162 = v164;
  HIDWORD(v163) = 6;
  if (v29 >= 7)
  {
    LODWORD(v163) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (((v27 >> 4) + 63) >> 6) {
    bzero(v164, 8 * v29);
  }
  LODWORD(v163) = v29;
  int v165 = v28;
  long long v159 = 0u;
  long long v160 = 0u;
  long long v158 = 0u;
  unint64_t v157 = 0;
  if (v6 != v7)
  {
    unint64_t v30 = 0;
    do
    {
      if (*(void *)(v7 + 16 * v30))
      {
        sub_1CD45F78C(&v158, &v157);
        *((void *)v162 + (v157 >> 6)) |= 1 << v157;
        unint64_t v30 = v157;
        uint64_t v7 = *a2;
        uint64_t v6 = a2[1];
      }
      unint64_t v157 = ++v30;
    }
    while (v30 < (v6 - v7) >> 4);
    if (v152)
    {
      uint64_t v31 = *((void *)&v160 + 1);
      if (*((void *)&v160 + 1))
      {
        int v32 = __clz(v153);
        unint64_t v33 = (v32 ^ 0x3Fu) + v151;
        uint64_t v34 = 1 << (v32 ^ 0x3Fu);
        uint64_t v35 = 1 << (62 - v32);
        BOOL v36 = (v35 & v153) == 0;
        if ((v35 & v153) != 0) {
          uint64_t v37 = (v33 + 1);
        }
        else {
          uint64_t v37 = v33;
        }
        unint64_t v38 = 0x100000000;
        if (v36) {
          unint64_t v38 = 0xFFFFFFFF00000000;
        }
        unint64_t v39 = v38 | v37;
        if (v34 == v153) {
          unint64_t v39 = v33;
        }
        int v150 = v39 - (SHIDWORD(v39) > 0);
        unint64_t v40 = 1;
        while (1)
        {
          unint64_t v157 = 0;
          unint64_t v41 = *(void *)(*(void *)(*((void *)&v158 + 1) + (((unint64_t)v160 >> 6) & 0x3FFFFFFFFFFFFF8))
                          + 8 * (v160 & 0x1FF));
          unint64_t v157 = v41;
          *(void *)&long long v160 = v160 + 1;
          *((void *)&v160 + 1) = v31 - 1;
          if ((unint64_t)v160 >= 0x400)
          {
            operator delete(**((void ***)&v158 + 1));
            *((void *)&v158 + 1) += 8;
            *(void *)&long long v160 = v160 - 512;
            LODWORD(v41) = v157;
          }
          *((void *)v162 + (v41 >> 6)) &= ~(1 << v41);
          uint64_t v42 = (uint64_t *)(*a1 + 24 * v157);
          uint64_t v44 = *v42;
          uint64_t v43 = v42[1];
          if (*v42 == v43)
          {
            __int16 v45 = 0;
            unint64_t v46 = 0;
            LOWORD(v47) = 0;
            unint64_t v48 = 1;
            goto LABEL_127;
          }
          __int16 v45 = 0;
          unint64_t v46 = 0;
          LOWORD(v47) = 0;
          unint64_t v48 = 1;
          do
          {
            if (*(void *)v44 == v157)
            {
              unint64_t v48 = sub_1CD45F81C(v48, v45, *(void *)(v44 + 8), *(_WORD *)(v44 + 16));
              __int16 v45 = v49;
              goto LABEL_84;
            }
            uint64_t v50 = *a2 + 16 * *(void *)v44;
            unint64_t v51 = *(void *)v50;
            __int16 v52 = *(_WORD *)(v50 + 8);
            if (v51)
            {
              uint64_t v53 = *(void *)(v44 + 8);
              if (v53)
              {
                unint64_t v54 = v53 * v51;
                if ((v53 | v51) >> 32)
                {
                  unint64_t v56 = v53 * (unint64_t)v51
                      + ((v53 * (unint64_t)HIDWORD(v51)) << 32);
                  unint64_t v55 = (__PAIR128__((HIDWORD(v53) * (unint64_t)v51) >> 32, v53 * (unint64_t)v51)+ __PAIR128__(((v53 * (unint64_t)HIDWORD(v51)) >> 32)+ HIDWORD(v53) * (unint64_t)HIDWORD(v51), (v53 * (unint64_t)HIDWORD(v51)) << 32)) >> 64;
                  if (v54 < v56) {
                    ++v55;
                  }
                  if (v55)
                  {
                    int v57 = __clz(v55);
                    unsigned __int16 v58 = 64 - v57;
                    if (v57) {
                      unint64_t v55 = (v54 >> -(char)v57) | (v55 << v57);
                    }
                    if ((v54 >> (v57 ^ 0x3Fu)))
                    {
                      BOOL v59 = __CFADD__(v55, 1);
                      unint64_t v60 = v55 + 1;
                      if (v59) {
                        unint64_t v54 = 0x8000000000000000;
                      }
                      else {
                        unint64_t v54 = v60;
                      }
                      if (v59) {
                        unsigned __int16 v58 = 65 - v57;
                      }
                    }
                    else
                    {
                      unint64_t v54 = v55;
                    }
                  }
                  else
                  {
                    unsigned __int16 v58 = 0;
                  }
                  int v61 = v58;
                }
                else
                {
                  int v61 = 0;
                }
                __int16 v62 = *(_WORD *)(v44 + 16) + v52;
                int v63 = v62;
                if (v62 && v54)
                {
                  if (v62 < 0)
                  {
                    int v64 = -v62;
                    if (v61 + 16382 >= v64) {
                      int v65 = -v62;
                    }
                    else {
                      int v65 = v61 + 16382;
                    }
                    __int16 v52 = v61 - v65;
                    if (v61 + 16382 < v64)
                    {
                      int v80 = v64 - v65;
                      BOOL v81 = v80 <= 63;
                      unint64_t v82 = v54 >> v80;
                      unint64_t v54 = v81 ? v82 : 0;
                      if (!v81) {
                        __int16 v52 = 0;
                      }
                    }
                  }
                  else
                  {
                    if (0x3FFF - v61 >= v62) {
                      int v68 = v62;
                    }
                    else {
                      int v68 = 0x3FFF - v61;
                    }
                    __int16 v52 = v68 + v61;
                    if (0x3FFF - v61 < v63)
                    {
                      int v69 = __clz(v54);
                      unsigned int v70 = (v69 ^ 0x3F) + v52;
                      uint64_t v71 = 1 << (62 - v69);
                      BOOL v72 = (v71 & v54) == 0;
                      if ((v71 & v54) != 0) {
                        uint64_t v73 = v70 + 1;
                      }
                      else {
                        uint64_t v73 = v70;
                      }
                      if (v72) {
                        unint64_t v74 = 0xFFFFFFFF00000000;
                      }
                      else {
                        unint64_t v74 = 0x100000000;
                      }
                      unint64_t v75 = v74 | v73;
                      if (1 << (v69 ^ 0x3Fu) == v54) {
                        unint64_t v76 = (v69 ^ 0x3Fu) + v52;
                      }
                      else {
                        unint64_t v76 = v75;
                      }
                      if (v76 - (SHIDWORD(v76) > 0) != 16446)
                      {
LABEL_100:
                        int v77 = v63 - v68;
                        BOOL v78 = v77 <= v69;
                        unint64_t v79 = v54 << v77;
                        if (v78) {
                          unint64_t v54 = v79;
                        }
                        else {
                          unint64_t v54 = -1;
                        }
                        if (!v78) {
                          __int16 v52 = 0x3FFF;
                        }
                        goto LABEL_78;
                      }
                      if (v52 <= 16382)
                      {
                        if (v54 >> ~(_BYTE)v52 != -1 || -1 << (-1 - v52) < v54) {
                          goto LABEL_100;
                        }
                      }
                      else
                      {
                        if (0xFFFFFFFFFFFFFFFFLL >> (v52 + 1) != v54) {
                          goto LABEL_100;
                        }
                        if (0xFFFFFFFFFFFFFFFFLL >> (v52 + 1) << (v52 + 1) == -1
                           ? 0
                           : -1)
                        {
                          goto LABEL_100;
                        }
                      }
                    }
                  }
                }
                else
                {
                  __int16 v52 = v61;
                }
              }
              else
              {
                unint64_t v54 = 0;
                __int16 v52 = *(_WORD *)(v44 + 16);
              }
            }
            else
            {
              unint64_t v54 = 0;
            }
LABEL_78:
            unint64_t v66 = sub_1CD45F614(v46, v47, v54, v52);
            if (v67 >= 0x3FFF) {
              LOWORD(v47) = 0x3FFF;
            }
            else {
              LOWORD(v47) = v67;
            }
            if (v67 >= 0x4000) {
              unint64_t v46 = -1;
            }
            else {
              unint64_t v46 = v66;
            }
LABEL_84:
            v44 += 24;
          }
          while (v44 != v43);
          if (!v48)
          {
            if (v46)
            {
              LOWORD(v47) = 0x3FFF;
              unint64_t v46 = -1;
            }
            else
            {
              unint64_t v46 = 0;
            }
            goto LABEL_147;
          }
LABEL_127:
          int v84 = __clz(v48);
          unint64_t v85 = (v84 ^ 0x3Fu) + v45;
          uint64_t v86 = 1 << (v84 ^ 0x3Fu);
          uint64_t v87 = 1 << (62 - v84);
          BOOL v88 = (v87 & v48) == 0;
          if ((v87 & v48) != 0) {
            uint64_t v89 = (v85 + 1);
          }
          else {
            uint64_t v89 = v85;
          }
          if (v88) {
            unint64_t v90 = 0xFFFFFFFF00000000;
          }
          else {
            unint64_t v90 = 0x100000000;
          }
          unint64_t v91 = v90 | v89;
          if (v86 == v48) {
            unint64_t v91 = v85;
          }
          if (SHIDWORD(v91) <= 0) {
            int v92 = 0;
          }
          else {
            int v92 = -1;
          }
          if (v92 + v91)
          {
LABEL_139:
            if (!v46) {
              goto LABEL_147;
            }
            unint64_t v93 = llvm::ScaledNumbers::divide64(v46, v48);
            unint64_t v46 = v93;
            if ((unsigned __int16)v47 == (unsigned __int16)v45 || !v93)
            {
              LOWORD(v47) = v94;
              goto LABEL_147;
            }
            int v95 = (__int16)(v47 - v45);
            if (v95 < 0)
            {
              int v96 = -v95;
              int v97 = v94 + 16382;
              if (v97 >= -v95) {
                int v98 = -v95;
              }
              else {
                int v98 = v94 + 16382;
              }
              LOWORD(v47) = v94 - v98;
              if (v97 < v96)
              {
                int v147 = v96 - v98;
                if (v147 <= 63)
                {
                  unint64_t v46 = v93 >> v147;
                }
                else
                {
                  LOWORD(v47) = 0;
                  unint64_t v46 = 0;
                }
              }
            }
            else
            {
              int v119 = 0x3FFF - v94;
              BOOL v120 = v119 < v95;
              if (v119 >= v95) {
                int v119 = (__int16)(v47 - v45);
              }
              int v47 = (__int16)(v119 + v94);
              if (v120)
              {
                int v121 = __clz(v93);
                uint64_t v122 = (v121 ^ 0x3Fu) + v47;
                if (1 << (v121 ^ 0x3Fu) != v93)
                {
                  uint64_t v123 = 1 << (62 - v121);
                  if ((v123 & v93) != 0) {
                    uint64_t v122 = (v122 + 1);
                  }
                  else {
                    uint64_t v122 = v122;
                  }
                  if ((v123 & v93) != 0) {
                    unint64_t v124 = 0x100000000;
                  }
                  else {
                    unint64_t v124 = 0xFFFFFFFF00000000;
                  }
                  v122 |= v124;
                }
                if (v122 - (SHIDWORD(v122) > 0) == 16446)
                {
                  if (v47 <= 16382)
                  {
                    if (v93 >> ~(v119 + v94) == -1
                      && -1 << (-1 - (v119 + v94)) >= v93)
                    {
                      goto LABEL_147;
                    }
                  }
                  else
                  {
                    unint64_t v148 = 0xFFFFFFFFFFFFFFFFLL >> (v119 + v94 + 1);
                    if (v148 == v93 && !(v148 << (v119 + v94 + 1) == -1 ? 0 : -1)) {
                      goto LABEL_147;
                    }
                  }
                }
                int v125 = v95 - v119;
                if (v125 <= v121)
                {
                  unint64_t v46 = v93 << v125;
                }
                else
                {
                  unint64_t v46 = -1;
                  LOWORD(v47) = 0x3FFF;
                }
              }
            }
          }
          else if (v45 < 0)
          {
            if (v48 >> -(char)v45 != 1 || 1 << -v45 < v48) {
              goto LABEL_139;
            }
          }
          else
          {
            if (v45) {
              int v126 = -1;
            }
            else {
              int v126 = 0;
            }
            if (1uLL >> v45 < v48 || v126) {
              goto LABEL_139;
            }
          }
LABEL_147:
          uint64_t v99 = *a2 + 16 * v157;
          unint64_t v100 = *(void *)v99;
          int v101 = *(__int16 *)(v99 + 8);
          unsigned __int16 v102 = v47;
          if (!v100)
          {
            BOOL v128 = v46 != 0;
LABEL_196:
            if (v128) {
              goto LABEL_197;
            }
LABEL_167:
            unint64_t v117 = v100;
            __int16 v118 = v101;
            unint64_t v100 = v46;
            goto LABEL_198;
          }
          if (!v46) {
            goto LABEL_167;
          }
          int v103 = __clz(v100);
          unint64_t v104 = (v103 ^ 0x3Fu) + v101;
          uint64_t v105 = 1 << (v103 ^ 0x3Fu);
          uint64_t v106 = 1 << (62 - v103);
          BOOL v107 = (v106 & v100) == 0;
          if ((v106 & v100) != 0) {
            uint64_t v108 = (v104 + 1);
          }
          else {
            uint64_t v108 = v104;
          }
          if (v107) {
            unint64_t v109 = 0xFFFFFFFF00000000;
          }
          else {
            unint64_t v109 = 0x100000000;
          }
          unint64_t v110 = v109 | v108;
          if (v105 == v100) {
            unint64_t v110 = v104;
          }
          int v111 = __clz(v46);
          uint64_t v112 = (v111 ^ 0x3Fu) + (__int16)v47;
          if (1 << (v111 ^ 0x3Fu) != v46)
          {
            uint64_t v113 = 1 << (62 - v111);
            if ((v113 & v46) != 0) {
              uint64_t v112 = (v112 + 1);
            }
            else {
              uint64_t v112 = v112;
            }
            if ((v113 & v46) != 0) {
              unint64_t v114 = 0x100000000;
            }
            else {
              unint64_t v114 = 0xFFFFFFFF00000000;
            }
            v112 |= v114;
          }
          int v115 = v110 - (SHIDWORD(v110) > 0);
          int v116 = v112 - (SHIDWORD(v112) > 0);
          if (v115 == v116)
          {
            if (v101 < (__int16)v47)
            {
              if (v100 >> (v47 - v101) < v46) {
                goto LABEL_197;
              }
            }
            else
            {
              unint64_t v127 = v46 >> (v101 - v47);
              if (v127 >= v100)
              {
                if (v127 > v100) {
                  goto LABEL_197;
                }
                BOOL v128 = v127 << (v101 - v47) < v46;
                goto LABEL_196;
              }
            }
            goto LABEL_167;
          }
          if (v115 >= v116) {
            goto LABEL_167;
          }
LABEL_197:
          unint64_t v117 = v46;
          __int16 v118 = v47;
          unsigned __int16 v102 = v101;
LABEL_198:
          unint64_t v129 = sub_1CD45F81C(v117, v118, v100, v102);
          if (v129)
          {
            if (v153)
            {
              int v131 = __clz(v129);
              unint64_t v132 = (v131 ^ 0x3Fu) + v130;
              uint64_t v133 = 1 << (v131 ^ 0x3Fu);
              uint64_t v134 = 1 << (62 - v131);
              BOOL v135 = (v134 & v129) == 0;
              if ((v134 & v129) != 0) {
                uint64_t v136 = (v132 + 1);
              }
              else {
                uint64_t v136 = v132;
              }
              if (v135) {
                unint64_t v137 = 0xFFFFFFFF00000000;
              }
              else {
                unint64_t v137 = 0x100000000;
              }
              unint64_t v138 = v137 | v136;
              if (v133 == v129) {
                unint64_t v138 = v132;
              }
              int v139 = v138 - (SHIDWORD(v138) > 0);
              if (v139 == v150)
              {
                if (v130 < v151)
                {
                  char v146 = v151 - v130;
                  if (v129 >> (v151 - v130) < v153) {
                    goto LABEL_218;
                  }
                  if (v129 >> v146 > v153) {
                    goto LABEL_210;
                  }
                  unint64_t v144 = v129 >> v146 << v146;
                }
                else
                {
                  unint64_t v144 = v153 >> (v130 - v151);
                }
                if (v144 < v129) {
                  goto LABEL_210;
                }
              }
              else if (v139 >= v150)
              {
                goto LABEL_210;
              }
            }
            else
            {
LABEL_210:
              sub_1CD45F78C(&v158, &v157);
              BOOL v140 = v162;
              *((void *)v162 + (v157 >> 6)) |= 1 << v157;
              uint64_t v141 = v161[0] + 24 * v157;
              uint64_t v142 = *(uint64_t **)v141;
              unint64_t v143 = *(uint64_t **)(v141 + 8);
              while (v142 != v143)
              {
                uint64_t v156 = 0;
                uint64_t v156 = *v142;
                if (((v140[v156 >> 6] >> v156) & 1) == 0)
                {
                  sub_1CD45F78C(&v158, &v156);
                  BOOL v140 = v162;
                  *((void *)v162 + (v156 >> 6)) |= 1 << v156;
                }
                ++v142;
              }
            }
          }
LABEL_218:
          uint64_t v145 = *a2 + 16 * v157;
          *(void *)uint64_t v145 = v46;
          *(_WORD *)(v145 + 8) = v47;
          if (v40 < v152)
          {
            ++v40;
            uint64_t v31 = *((void *)&v160 + 1);
            if (*((void *)&v160 + 1)) {
              continue;
            }
          }
          break;
        }
      }
    }
  }
LABEL_246:
  sub_1CB904DFC((void **)&v158);
  if (v162 != v164) {
    free(v162);
  }
  uint64_t v162 = v161;
  sub_1CBF7EDF0((void ***)&v162);
}

uint64_t sub_1CBF7EC1C(unint64_t *a1, __int16 *a2, unint64_t *a3, __int16 *a4)
{
  LOWORD(v4) = *a2;
  do
  {
    unint64_t v5 = a4;
    uint64_t v6 = a3;
    a4 = a2;
    a3 = a1;
    unsigned __int16 v7 = v4;
    int v4 = *v5;
    a1 = v6;
    a2 = v5;
  }
  while (v4 > (__int16)v7);
  unint64_t v8 = *a3;
  if (*a3)
  {
    if (v7 == (unsigned __int16)v4 || *v6 == 0)
    {
      LOWORD(v4) = v7;
    }
    else
    {
      int v10 = (__int16)v7 - v4;
      if (v10 >= 128) {
        goto LABEL_15;
      }
      int v11 = __clz(v8);
      if (v10 < v11) {
        int v11 = v10;
      }
      int v12 = v10 - v11;
      if (v12 >= 64)
      {
LABEL_15:
        *uint64_t v6 = 0;
      }
      else
      {
        *a3 = v8 << v11;
        *v6 >>= v12;
        *a4 = v7 - v11;
        *v5 += v12;
      }
      LOWORD(v4) = *a4;
    }
  }
  return (__int16)v4;
}

uint64_t sub_1CBF7ECD0(unint64_t a1, int a2, unint64_t a3, int a4)
{
  if (a1)
  {
    if (a3)
    {
      int v4 = __clz(a1);
      unint64_t v5 = (v4 ^ 0x3Fu) + a2;
      uint64_t v6 = 1 << (v4 ^ 0x3Fu);
      uint64_t v7 = 1 << (62 - v4);
      BOOL v8 = (v7 & a1) == 0;
      if ((v7 & a1) != 0) {
        uint64_t v9 = (v5 + 1);
      }
      else {
        uint64_t v9 = v5;
      }
      if (v8) {
        unint64_t v10 = 0xFFFFFFFF00000000;
      }
      else {
        unint64_t v10 = 0x100000000;
      }
      unint64_t v11 = v10 | v9;
      if (v6 == a1) {
        unint64_t v11 = v5;
      }
      int v12 = v11 - (SHIDWORD(v11) > 0);
      int v13 = __clz(a3);
      unint64_t v14 = (v13 ^ 0x3Fu) + a4;
      uint64_t v15 = 1 << (v13 ^ 0x3Fu);
      uint64_t v16 = 1 << (62 - v13);
      BOOL v17 = (v16 & a3) == 0;
      if ((v16 & a3) != 0) {
        uint64_t v18 = (v14 + 1);
      }
      else {
        uint64_t v18 = v14;
      }
      if (v17) {
        unint64_t v19 = 0xFFFFFFFF00000000;
      }
      else {
        unint64_t v19 = 0x100000000;
      }
      unint64_t v20 = v19 | v18;
      if (v15 == a3) {
        unint64_t v20 = v14;
      }
      int v21 = v20 - (SHIDWORD(v20) > 0);
      if (v12 != v21)
      {
        if (v12 < v21) {
          return 0xFFFFFFFFLL;
        }
        else {
          return 1;
        }
      }
      if (a2 < a4)
      {
        unint64_t v24 = a1 >> (a4 - a2);
        if (v24 < a3) {
          return 0xFFFFFFFFLL;
        }
        if (v24 <= a3) {
          return v24 << (a4 - a2) < a1;
        }
      }
      else
      {
        unint64_t v23 = a3 >> (a2 - a4);
        if (v23 >= a1)
        {
          if (v23 <= a1)
          {
            if (v23 << (a2 - a4) >= a3) {
              return 0;
            }
            else {
              return 0xFFFFFFFFLL;
            }
          }
          return 0xFFFFFFFFLL;
        }
      }
    }
    return 1;
  }
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

void sub_1CBF7EDF0(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (char *)**a1;
  if (v2)
  {
    int v4 = (char *)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = (char *)v1[1];
      do
      {
        BOOL v8 = (void *)*((void *)v6 - 3);
        v6 -= 24;
        uint64_t v7 = v8;
        if (v8)
        {
          *((void *)v4 - 2) = v7;
          operator delete(v7);
        }
        int v4 = v6;
      }
      while (v6 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1CBF7EE80(uint64_t a1, uint64_t **a2, llvm::Twine *this, char a4, llvm::Twine *a5, uint64_t a6)
{
  if (*(char *)(a6 + 23) < 0) {
    uint64_t v11 = *(void *)(a6 + 8);
  }
  else {
    uint64_t v11 = *(unsigned __int8 *)(a6 + 23);
  }
  int v49 = 0;
  if (v11)
  {
    __int16 v44 = 260;
    uint64_t v42 = a6;
    *(void *)&long long v47 = llvm::sys::fs::openFile((unsigned __int8 *)&v42, &v49, 0, 2, 1, 438);
    *((void *)&v47 + 1) = v12;
    int v13 = std::generic_category();
    uint64_t v42 = 17;
    uint64_t v43 = v13;
    unint64_t v14 = (llvm *)(*(uint64_t (**)(void, void, uint64_t *))(**((void **)&v47 + 1) + 32))(*((void *)&v47 + 1), v47, &v42);
    if (v14
      || (unint64_t v14 = (llvm *)((uint64_t (*)(const std::error_category *, long long *, void))v43->equivalent_0)(v43, &v47, v42), v14))
    {
      unint64_t v20 = (llvm::raw_ostream *)llvm::errs(v14);
      int v21 = (void *)*((void *)v20 + 4);
      if (*((void *)v20 + 3) - (void)v21 > 0x17uLL)
      {
        qmemcpy(v21, "file exists, overwriting", 24);
        uint64_t v22 = (unsigned char *)(*((void *)v20 + 4) + 24);
        *((void *)v20 + 4) = v22;
      }
      else
      {
        unint64_t v20 = llvm::raw_ostream::write(v20, "file exists, overwriting", 0x18uLL);
        uint64_t v22 = (unsigned char *)*((void *)v20 + 4);
      }
      unint64_t v23 = (unsigned char *)*((void *)v20 + 3);
    }
    else
    {
      int v15 = v47;
      uint64_t v16 = (llvm::raw_ostream *)llvm::errs(v14);
      BOOL v17 = (char *)*((void *)v16 + 4);
      unint64_t v18 = *((void *)v16 + 3) - (void)v17;
      if (v15)
      {
        if (v18 > 0x16)
        {
          qmemcpy(v17, "error writing into file", 23);
          unint64_t v19 = (unsigned char *)(*((void *)v16 + 4) + 23);
          *((void *)v16 + 4) = v19;
        }
        else
        {
          uint64_t v16 = llvm::raw_ostream::write(v16, "error writing into file", 0x17uLL);
          unint64_t v19 = (unsigned char *)*((void *)v16 + 4);
        }
        if (*((unsigned char **)v16 + 3) == v19)
        {
          llvm::raw_ostream::write(v16, "\n", 1uLL);
        }
        else
        {
          *unint64_t v19 = 10;
          ++*((void *)v16 + 4);
        }
        *(unsigned char *)(a1 + 23) = 0;
        *(unsigned char *)a1 = 0;
        return;
      }
      if (v18 > 0x21)
      {
        qmemcpy(v17, "writing to the newly created file ", 34);
        *((void *)v16 + 4) += 34;
      }
      else
      {
        uint64_t v16 = llvm::raw_ostream::write(v16, "writing to the newly created file ", 0x22uLL);
      }
      char v24 = *(unsigned char *)(a6 + 23);
      BOOL v25 = v24 < 0;
      if (v24 >= 0) {
        unint64_t v26 = (const char *)a6;
      }
      else {
        unint64_t v26 = *(const char **)a6;
      }
      size_t v27 = v24 & 0x7F;
      if (v25) {
        size_t v28 = *(void *)(a6 + 8);
      }
      else {
        size_t v28 = v27;
      }
      unint64_t v20 = llvm::raw_ostream::write(v16, v26, v28);
      unint64_t v23 = (unsigned char *)*((void *)v20 + 3);
      uint64_t v22 = (unsigned char *)*((void *)v20 + 4);
    }
    if (v23 == v22)
    {
      llvm::raw_ostream::write(v20, "\n", 1uLL);
    }
    else
    {
      *uint64_t v22 = 10;
      ++*((void *)v20 + 4);
    }
  }
  else
  {
    llvm::Twine::str(this, __p);
    __int16 v44 = 260;
    uint64_t v42 = (uint64_t)__p;
    llvm::createGraphFilename((llvm *)&v42, (const llvm::Twine *)&v49, (uint64_t)&v47);
    if (*(char *)(a6 + 23) < 0) {
      operator delete(*(void **)a6);
    }
    *(_OWORD *)a6 = v47;
    *(void *)(a6 + 16) = v48;
    HIBYTE(v++*(_DWORD *)(result + 48) = 0;
    LOBYTE(v47) = 0;
    if (v46 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v29 = (llvm *)llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v42, v49, 1, 0, 0);
  if (v49 == -1)
  {
    unint64_t v30 = (llvm::raw_ostream *)llvm::errs(v29);
    uint64_t v31 = *((void *)v30 + 4);
    if ((unint64_t)(*((void *)v30 + 3) - v31) > 0x13)
    {
      *(_DWORD *)(v31 + 16) = 656434540;
      *(_OWORD *)uint64_t v31 = *(_OWORD *)"error opening file '";
      *((void *)v30 + 4) += 20;
    }
    else
    {
      unint64_t v30 = llvm::raw_ostream::write(v30, "error opening file '", 0x14uLL);
    }
    char v32 = *(unsigned char *)(a6 + 23);
    BOOL v33 = v32 < 0;
    if (v32 >= 0) {
      uint64_t v34 = (const char *)a6;
    }
    else {
      uint64_t v34 = *(const char **)a6;
    }
    size_t v35 = v32 & 0x7F;
    if (v33) {
      size_t v36 = *(void *)(a6 + 8);
    }
    else {
      size_t v36 = v35;
    }
    uint64_t v37 = llvm::raw_ostream::write(v30, v34, v36);
    unint64_t v38 = (void *)*((void *)v37 + 4);
    if (*((void *)v37 + 3) - (void)v38 > 0xEuLL)
    {
      qmemcpy(v38, "' for writing!\n", 15);
      *((void *)v37 + 4) += 15;
    }
    else
    {
      llvm::raw_ostream::write(v37, "' for writing!\n", 0xFuLL);
    }
    *(unsigned char *)(a1 + 23) = 0;
    *(unsigned char *)a1 = 0;
  }
  else
  {
    unint64_t v39 = sub_1CD45F910((uint64_t **)&v42, a2, a4, a5);
    unint64_t v40 = (llvm::raw_ostream *)llvm::errs((llvm *)v39);
    unint64_t v41 = (void *)*((void *)v40 + 4);
    if (*((void *)v40 + 3) - (void)v41 > 7uLL)
    {
      *unint64_t v41 = 0xA202E656E6F6420;
      *((void *)v40 + 4) += 8;
    }
    else
    {
      llvm::raw_ostream::write(v40, " done. \n", 8uLL);
    }
    *(_OWORD *)a1 = *(_OWORD *)a6;
    *(void *)(a1 + 16) = *(void *)(a6 + 16);
    *(void *)(a6 + 8) = 0;
    *(void *)(a6 + 16) = 0;
    *(void *)a6 = 0;
  }
  llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v42);
}

void sub_1CBF7F2D4(uint64_t ***a1, llvm::Value *a2)
{
  sub_1CD45FD1C(v75, (uint64_t)(a1 + 3), (uint64_t)a2, *a1[1], dword_1EBD02958);
  int v4 = (llvm::raw_ostream *)*a1;
  unint64_t v5 = (*a1)[4];
  if ((unint64_t)((char *)(*a1)[3] - (char *)v5) > 4)
  {
    *((unsigned char *)v5 + 4) = 101;
    *(_DWORD *)unint64_t v5 = 1685016073;
    *((void *)v4 + 4) += 5;
  }
  else
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)*a1, "\tNode", 5uLL);
  }
  llvm::write_hex(v4, (unint64_t)a2, 3, 0, 0);
  uint64_t v6 = (void *)*((void *)v4 + 4);
  if (*((void *)v4 + 3) - (void)v6 > 7uLL)
  {
    *uint64_t v6 = 0x3D65706168735B20;
    *((void *)v4 + 4) += 8;
  }
  else
  {
    llvm::raw_ostream::write(v4, " [shape=", 8uLL);
  }
  uint64_t v7 = (llvm::raw_ostream *)*a1;
  BOOL v8 = (*a1)[4];
  unint64_t v9 = (char *)(*a1)[3] - (char *)v8;
  if (*((unsigned char *)a1 + 16))
  {
    if (v9 <= 4)
    {
      unint64_t v10 = "none,";
      size_t v11 = 5;
      goto LABEL_10;
    }
    *((unsigned char *)v8 + 4) = 44;
    *(_DWORD *)BOOL v8 = 1701736302;
    uint64_t v26 = *((void *)v7 + 4) + 5;
  }
  else
  {
    if (v9 <= 6)
    {
      unint64_t v10 = "record,";
      size_t v11 = 7;
LABEL_10:
      llvm::raw_ostream::write(v7, v10, v11);
      goto LABEL_11;
    }
    *(_DWORD *)((char *)v8 + 3) = 744780399;
    *(_DWORD *)BOOL v8 = 1868785010;
    uint64_t v26 = *((void *)v7 + 4) + 7;
  }
  *((void *)v7 + 4) = v26;
LABEL_11:
  if (v76 >= 0) {
    size_t v12 = v76 & 0x7F;
  }
  else {
    size_t v12 = (size_t)v75[1];
  }
  if (v12)
  {
    if (v76 >= 0) {
      int v13 = (const char *)v75;
    }
    else {
      int v13 = (const char *)v75[0];
    }
    unint64_t v14 = llvm::raw_ostream::write((llvm::raw_ostream *)*a1, v13, v12);
    int v15 = (unsigned char *)*((void *)v14 + 4);
    if (*((unsigned char **)v14 + 3) == v15)
    {
      llvm::raw_ostream::write(v14, ",", 1uLL);
    }
    else
    {
      *int v15 = 44;
      ++*((void *)v14 + 4);
    }
  }
  uint64_t v16 = (llvm::raw_ostream *)*a1;
  BOOL v17 = (*a1)[4];
  if ((unint64_t)((char *)(*a1)[3] - (char *)v17) > 5)
  {
    *((_WORD *)v17 + 2) = 15724;
    *(_DWORD *)BOOL v17 = 1700946284;
    *((void *)v16 + 4) += 6;
  }
  else
  {
    llvm::raw_ostream::write(v16, "label=", 6uLL);
  }
  if (!*((unsigned char *)a1 + 16))
  {
    unint64_t v18 = (llvm::raw_ostream *)*a1;
    unint64_t v19 = (char *)(*a1)[4];
    if ((unint64_t)((char *)(*a1)[3] - v19) > 1)
    {
      *(_WORD *)unint64_t v19 = 31522;
      *((void *)v18 + 4) += 2;
      goto LABEL_61;
    }
    unint64_t v20 = "\"{";
    goto LABEL_60;
  }
  int v21 = (void *)*((void *)a2 + 5);
  if (v21 == (void *)((char *)a2 + 40))
  {
LABEL_48:
    unsigned int v28 = 0;
    BOOL v29 = 0;
  }
  else
  {
    if (v21) {
      uint64_t v22 = v21 - 3;
    }
    else {
      uint64_t v22 = 0;
    }
    int v23 = *((unsigned __int8 *)v22 + 16);
    int v24 = v23 - 29;
    if (v23 != 30)
    {
      uint64_t v27 = 2;
      unsigned int v28 = 0;
      BOOL v29 = 0;
      switch(v24)
      {
        case 0:
        case 5:
        case 6:
          goto LABEL_49;
        case 1:
LABEL_139:
          __break(1u);
LABEL_140:
          int v54 = (*(_DWORD *)(v27 + 20) & 0x7FFFFFF) - 1;
LABEL_120:
          if (v54) {
            goto LABEL_110;
          }
LABEL_121:
          int v60 = 0;
          goto LABEL_122;
        case 2:
          LODWORD(v27) = (*((_DWORD *)v22 + 5) >> 1) & 0x3FFFFFF;
          goto LABEL_47;
        case 3:
        case 9:
          LODWORD(v27) = (*((_DWORD *)v22 + 5) & 0x7FFFFFF) - 1;
          goto LABEL_47;
        case 4:
          goto LABEL_34;
        case 7:
          LODWORD(v27) = *((_WORD *)v22 + 9) & 1;
          goto LABEL_47;
        case 8:
          LODWORD(v27) = 1;
          goto LABEL_34;
        case 10:
          LODWORD(v27) = *((_DWORD *)v22 + 20) + 1;
LABEL_47:
          if (!v27) {
            goto LABEL_48;
          }
          goto LABEL_34;
        default:
          goto LABEL_48;
      }
    }
    if ((*((_DWORD *)v22 + 5) & 0x7FFFFFF) == 3) {
      LODWORD(v27) = 2;
    }
    else {
      LODWORD(v27) = 1;
    }
LABEL_34:
    int v25 = v27 - 1;
    if ((v27 - 1) >= 0x3F) {
      int v25 = 63;
    }
    unsigned int v28 = v25 + 1;
    BOOL v29 = v27 != v28;
  }
LABEL_49:
  if (v28 <= 1) {
    int v30 = 1;
  }
  else {
    int v30 = v28;
  }
  uint64_t v31 = (llvm::raw_ostream *)*a1;
  char v32 = (*a1)[4];
  if ((unint64_t)((char *)(*a1)[3] - (char *)v32) <= 0x30)
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)*a1, "<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"", 0x31uLL);
    int v63 = (void *)*((void *)v31 + 4);
  }
  else
  {
    qmemcpy(v32, "<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"", 49);
    int v63 = (void *)(*((void *)v31 + 4) + 49);
    *((void *)v31 + 4) = v63;
  }
  unint64_t v33 = (v30 + v29);
  if (*((void *)v31 + 3) - (void)v63 <= 0x2EuLL)
  {
    llvm::raw_ostream::write(v31, " cellpadding=\"0\"><tr><td align=\"text\" colspan=\"", 0x2FuLL);
  }
  else
  {
    qmemcpy(v63, " cellpadding=\"0\"><tr><td align=\"text\" colspan=\"", 47);
    *((void *)v31 + 4) += 47;
  }
  sub_1CD098D14(v31, v33, 0, 0, 0);
  uint64_t v34 = (_WORD *)*((void *)v31 + 4);
  if (*((void *)v31 + 3) - (void)v34 <= 1uLL)
  {
    unint64_t v20 = "\">";
    unint64_t v18 = v31;
LABEL_60:
    llvm::raw_ostream::write(v18, v20, 2uLL);
    goto LABEL_61;
  }
  *uint64_t v34 = 15906;
  *((void *)v31 + 4) += 2;
LABEL_61:
  size_t v35 = (llvm::raw_ostream *)*a1;
  if (*((unsigned char *)a1 + 16))
  {
    if (dword_1EBD02A18 == 1) {
      int v40 = 3;
    }
    else {
      int v40 = dword_1EBCC3DB8;
    }
    sub_1CD45FEDC(&__p, a2, (llvm::BlockFrequencyInfoImplBase **)*a1[1], v40);
    if (v66 >= 0) {
      p_p = (const char *)&__p;
    }
    else {
      p_p = (const char *)__p;
    }
    if (v66 >= 0) {
      size_t v42 = HIBYTE(v66) & 0x7F;
    }
    else {
      size_t v42 = v65;
    }
    llvm::raw_ostream::write(v35, p_p, v42);
    uint64_t v43 = *((void *)v35 + 4);
    if ((unint64_t)(*((void *)v35 + 3) - v43) > 4)
    {
      *(unsigned char *)(v43 + 4) = 62;
      *(_DWORD *)uint64_t v43 = 1685335868;
      *((void *)v35 + 4) += 5;
    }
    else
    {
      llvm::raw_ostream::write(v35, "</td>", 5uLL);
    }
    if (SHIBYTE(v66) < 0)
    {
      unint64_t v39 = __p;
      goto LABEL_88;
    }
  }
  else
  {
    if (dword_1EBD02A18 == 1) {
      int v36 = 3;
    }
    else {
      int v36 = dword_1EBCC3DB8;
    }
    sub_1CD45FEDC(v73, a2, (llvm::BlockFrequencyInfoImplBase **)*a1[1], v36);
    llvm::DOT::EscapeString((char *)v73, (uint64_t)&__p);
    if (v66 >= 0) {
      uint64_t v37 = (const char *)&__p;
    }
    else {
      uint64_t v37 = (const char *)__p;
    }
    if (v66 >= 0) {
      size_t v38 = HIBYTE(v66) & 0x7F;
    }
    else {
      size_t v38 = v65;
    }
    llvm::raw_ostream::write(v35, v37, v38);
    if (SHIBYTE(v66) < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v74) < 0)
    {
      unint64_t v39 = v73[0];
LABEL_88:
      operator delete(v39);
    }
  }
  v73[0] = 0;
  v73[1] = 0;
  uint64_t v74 = 0;
  LODWORD(v65) = 0;
  char v69 = 0;
  uint64_t v70 = 0;
  BOOL v72 = v73;
  int v71 = 0;
  std::string __p = &unk_1F2646F30;
  uint64_t v66 = 0;
  uint64_t v67 = 0;
  uint64_t v68 = 0;
  if (*((unsigned char *)a1 + 16))
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&__p, "</tr><tr>", 9uLL);
    __int16 v44 = (llvm::raw_ostream *)*a1;
    __int16 v45 = (uint64_t *)(*a1 + 4);
    char v46 = (char *)*v45;
    unint64_t v47 = (unint64_t)(*a1)[3] - *v45;
    if (*((unsigned char *)a1 + 16))
    {
      if (v47 <= 0xD)
      {
        uint64_t v48 = "</tr></table>>";
        size_t v49 = 14;
LABEL_96:
        llvm::raw_ostream::write(v44, v48, v49);
        goto LABEL_97;
      }
      qmemcpy(v46, "</tr></table>>", 14);
      uint64_t v62 = *v45 + 14;
      goto LABEL_136;
    }
  }
  else
  {
    __int16 v44 = (llvm::raw_ostream *)*a1;
    __int16 v45 = (uint64_t *)(*a1 + 4);
    char v46 = (char *)*v45;
    unint64_t v47 = (unint64_t)(*a1)[3] - *v45;
  }
  if (v47 <= 1)
  {
    uint64_t v48 = "}\"";
    size_t v49 = 2;
    goto LABEL_96;
  }
  *(_WORD *)char v46 = 8829;
  uint64_t v62 = *v45 + 2;
LABEL_136:
  *__int16 v45 = v62;
LABEL_97:
  uint64_t v50 = (llvm::raw_ostream *)*a1;
  unint64_t v51 = (*a1)[4];
  if ((unint64_t)((char *)(*a1)[3] - (char *)v51) > 2)
  {
    *((unsigned char *)v51 + 2) = 10;
    *(_WORD *)unint64_t v51 = 15197;
    *((void *)v50 + 4) += 3;
  }
  else
  {
    llvm::raw_ostream::write(v50, "];\n", 3uLL);
  }
  __int16 v52 = (void *)*((void *)a2 + 5);
  if (v52 == (void *)((char *)a2 + 40))
  {
    int v60 = 0;
    int v4 = 0;
LABEL_122:
    unint64_t v55 = 0;
  }
  else
  {
    if (v52) {
      uint64_t v27 = (uint64_t)(v52 - 3);
    }
    else {
      uint64_t v27 = 0;
    }
    int v53 = *(unsigned __int8 *)(v27 + 16);
    if ((v53 - 29) >= 0xB) {
      int v4 = 0;
    }
    else {
      int v4 = (llvm::raw_ostream *)v27;
    }
    if (v53 == 30)
    {
      if ((*(_DWORD *)(v27 + 20) & 0x7FFFFFF) == 3) {
        int v54 = 2;
      }
      else {
        int v54 = 1;
      }
LABEL_110:
      unint64_t v55 = 0;
      int v56 = 63;
      do
      {
        sub_1CD45FC60((uint64_t)a1, (unint64_t)a2, v4, v55);
        int v57 = v55 + 1;
        unint64_t v55 = v55 & 0xFFFFFFFF00000000 | (v55 + 1);
        BOOL v59 = v56-- != 0;
      }
      while (v54 != v57 && v59);
      int v60 = v54;
    }
    else
    {
      int v54 = 2;
      unint64_t v55 = 0;
      int v60 = 0;
      switch(*(unsigned char *)(v27 + 16))
      {
        case 0x1D:
        case 0x22:
        case 0x23:
          break;
        case 0x1E:
          goto LABEL_139;
        case 0x1F:
          int v54 = (*(_DWORD *)(v27 + 20) >> 1) & 0x3FFFFFF;
          goto LABEL_120;
        case 0x20:
        case 0x26:
          goto LABEL_140;
        case 0x21:
          goto LABEL_110;
        case 0x24:
          int v54 = *(_WORD *)(v27 + 18) & 1;
          goto LABEL_120;
        case 0x25:
          int v54 = 1;
          goto LABEL_110;
        case 0x27:
          int v54 = *(_DWORD *)(v27 + 80) + 1;
          goto LABEL_120;
        default:
          goto LABEL_121;
      }
    }
  }
  if (v60 != v55)
  {
    do
    {
      sub_1CD45FC60((uint64_t)a1, (unint64_t)a2, v4, v55);
      int v61 = v55 + 1;
      unint64_t v55 = v55 & 0xFFFFFFFF00000000 | (v55 + 1);
    }
    while (v60 != v61);
  }
  std::string __p = &unk_1F2646B98;
  if (v71 == 1 && v66) {
    MEMORY[0x1D25D9CB0](v66, 0x1000C8077774924);
  }
  if (SHIBYTE(v74) < 0) {
    operator delete(v73[0]);
  }
  if (v76 < 0) {
    operator delete(v75[0]);
  }
}

uint64_t sub_1CBF7FBBC(uint64_t a1, uint64_t *a2)
{
  uint64_t v8 = 0;
  char v4 = sub_1CBB0BF40(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  uint64_t result = v8;
  if (v4) {
    return result;
  }
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_9;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
  {
LABEL_9:
    sub_1CBF7FCA0(a1, v7);
    uint64_t v8 = 0;
    sub_1CBB0BF40(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
    uint64_t result = v8;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*(void *)result != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  *(void *)uint64_t result = *a2;
  *(_DWORD *)(result + 8) = -1;
  return result;
}

void *sub_1CBF7FCA0(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      uint64_t v11 = 16 * v10;
      do
      {
        *uint64_t result = -4096;
        result += 2;
        v11 -= 16;
      }
      while (v11);
    }
    if (v3)
    {
      uint64_t v12 = 16 * v3;
      uint64_t v13 = v4;
      do
      {
        uint64_t v14 = *(void *)v13;
        if ((*(void *)v13 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          unint64_t v18 = 0;
          sub_1CBB0BF40(*(void *)a1, *(_DWORD *)(a1 + 16), v14, &v18);
          int v15 = v18;
          *unint64_t v18 = *(void *)v13;
          *((_DWORD *)v15 + 2) = *(_DWORD *)(v13 + 8);
          ++*(_DWORD *)(a1 + 8);
        }
        v13 += 16;
        v12 -= 16;
      }
      while (v12);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v16 = *(unsigned int *)(a1 + 16);
  if (v16)
  {
    uint64_t v17 = 16 * v16;
    do
    {
      *uint64_t result = -4096;
      result += 2;
      v17 -= 16;
    }
    while (v17);
  }
  return result;
}

uint64_t sub_1CBF7FDE4()
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  int v3 = 1;
  *(void *)&long long v2 = "Pop up a window to show a dag displaying how block frequencies propagation through the CFG.";
  *((void *)&v2 + 1) = 91;
  v4.n128_u64[0] = (unint64_t)&v5;
  unint64_t v5 = "none";
  uint64_t v6 = 4;
  int v7 = 0;
  unsigned int v8 = "do not display graphs.";
  uint64_t v9 = 22;
  uint64_t v10 = "fraction";
  uint64_t v11 = 8;
  int v12 = 1;
  uint64_t v13 = "display a graph using the fractional block frequency representation.";
  uint64_t v14 = 68;
  int v15 = "integer";
  uint64_t v16 = 7;
  unint64_t v18 = "display a graph using the raw integer fractional block frequency representation.";
  uint64_t v19 = 80;
  unint64_t v20 = "count";
  uint64_t v21 = 5;
  int v17 = 2;
  int v22 = 3;
  int v23 = "display a graph using the real profile count if available.";
  uint64_t v24 = 58;
  v4.n128_u64[1] = 0x400000004;
  sub_1CD45D9A4(&v3, &v2, (uint64_t *)&v4);
  if ((const char **)v4.n128_u64[0] != &v5) {
    free((void *)v4.n128_u64[0]);
  }
  __cxa_atexit((void (*)(void *))sub_1CD45C7DC, &qword_1EBCC3D38, &dword_1CB82C000);
  LODWORD(v2) = 1;
  v4.n128_u64[0] = (unint64_t)"The option to specify the name of the function whose CFG will be displayed.";
  v4.n128_u64[1] = 75;
  sub_1CD45DC8C((uint64_t)&llvm::ViewBlockFreqFuncName, "view-bfi-func-name", &v2, &v4);
  __cxa_atexit((void (*)(void *))sub_1CD41C8DC, &llvm::ViewBlockFreqFuncName, &dword_1CB82C000);
  int v3 = 10;
  *(void *)&long long v2 = &v3;
  int v1 = 1;
  v4.n128_u64[0] = (unint64_t)"An integer in percent used to specify the hot blocks/edges to be displayed in red: "
                                     "a block or edge whose frequency is no less than the max frequency of the function m"
                                     "ultiplied by this percent.";
  v4.n128_u64[1] = 192;
  sub_1CBF7A9F8((uint64_t)&llvm::ViewHotFreqPercent, "view-hot-freq-percent", (int **)&v2, &v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &llvm::ViewHotFreqPercent, &dword_1CB82C000);
  int v3 = 1;
  *(void *)&long long v2 = "A BOOLean option to show CFG dag or text with block profile counts and branch probabilities right aft"
                   "er PGO profile annotation step. The profile counts are computed using branch probabilities from the r"
                   "untime profile data and block frequency propagation algorithm. To view the raw counts from the profil"
                   "e, use option -pgo-view-raw-counts instead. To limit graph display to only one function, use filterin"
                   "g option -view-bfi-func-name.";
  *((void *)&v2 + 1) = 433;
  v4.n128_u64[0] = (unint64_t)&v5;
  unint64_t v5 = "none";
  uint64_t v6 = 4;
  int v7 = 0;
  unsigned int v8 = "do not show.";
  uint64_t v9 = 12;
  uint64_t v10 = "graph";
  uint64_t v11 = 5;
  int v12 = 1;
  uint64_t v13 = "show a graph.";
  uint64_t v14 = 13;
  int v15 = "text";
  uint64_t v16 = 4;
  int v17 = 2;
  unint64_t v18 = "show in text.";
  uint64_t v19 = 13;
  v4.n128_u64[1] = 0x400000003;
  sub_1CD45DDA0(&v3, &v2, (uint64_t *)&v4);
  if ((const char **)v4.n128_u64[0] != &v5) {
    free((void *)v4.n128_u64[0]);
  }
  __cxa_atexit((void (*)(void *))sub_1CD45C7E0, &llvm::PGOViewCounts, &dword_1CB82C000);
  LOBYTE(v1) = 0;
  *(void *)&long long v2 = &v1;
  int v3 = 1;
  v4.n128_u64[0] = (unint64_t)"Print the block frequency info.";
  v4.n128_u64[1] = 31;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCC3C78, "print-bfi", (unsigned char **)&v2, &v3, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCC3C78, &dword_1CB82C000);
  LODWORD(v2) = 1;
  v4.n128_u64[0] = (unint64_t)"The option to specify the name of the function whose block frequency info is printed.";
  v4.n128_u64[1] = 85;
  sub_1CD45DC8C((uint64_t)&llvm::PrintBlockFreqFuncName, "print-bfi-func-name", &v2, &v4);
  return __cxa_atexit((void (*)(void *))sub_1CD41C8DC, &llvm::PrintBlockFreqFuncName, &dword_1CB82C000);
}

void *sub_1CBF801A0(void *a1)
{
  *a1 = &unk_1F2601198;
  long long v2 = a1 + 21;
  int v3 = (void *)a1[24];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }

  return sub_1CB87DD48(a1);
}

uint64_t llvm::bfi_detail::BlockMass::toScaled(llvm::bfi_detail::BlockMass *this)
{
  if (*(void *)this == -1) {
    return 1;
  }
  else {
    return *(void *)this + 1;
  }
}

uint64_t llvm::BlockFrequencyInfoImplBase::Distribution::add(uint64_t result, unsigned int *a2, unint64_t a3, unsigned int a4)
{
  uint64_t v4 = *(void *)(result + 80);
  BOOL v5 = __CFADD__(v4, a3);
  uint64_t v6 = v4 + a3;
  char v7 = v5;
  *(unsigned char *)(result + 88) |= v7;
  *(void *)(result + 80) = v6;
  unsigned int v8 = *(_DWORD *)(result + 8);
  if (v8 >= *(_DWORD *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v9 = (unint64_t *)(*(void *)result + 16 * v8);
  *uint64_t v9 = a4 | ((unint64_t)*a2 << 32);
  v9[1] = a3;
  ++*(_DWORD *)(result + 8);
  return result;
}

void llvm::BlockFrequencyInfoImplBase::Distribution::normalize(llvm::BlockFrequencyInfoImplBase::Distribution *this)
{
  unint64_t v1 = *((unsigned int *)this + 2);
  if (v1)
  {
    if (v1 == 1) {
      goto LABEL_3;
    }
    if (v1 >= 0x81)
    {
      unint64_t v22 = v1 | (2 * v1) | ((v1 | (2 * v1)) >> 2);
      unint64_t v23 = v22 | (v22 >> 4) | ((v22 | (v22 >> 4)) >> 8);
      sub_1CBF82310(&v39, (((v23 | (v23 >> 16)) >> 32) | v23 | (v23 >> 16)) + 1);
      uint64_t v24 = *((unsigned int *)this + 2);
      if (v24)
      {
        uint64_t v25 = 16 * v24;
        uint64_t v26 = *(void *)this + 4;
        do
        {
          uint64_t v27 = sub_1CBF823AC((uint64_t *)&v39, (_DWORD *)v26);
          uint64_t v28 = *((void *)v27 + 2);
          if (v28)
          {
            uint64_t v30 = *(void *)(v26 + 4);
            BOOL v20 = __CFADD__(v30, v28);
            uint64_t v31 = v30 + v28;
            if (v20) {
              uint64_t v31 = -1;
            }
            *((void *)v27 + 2) = v31;
          }
          else
          {
            *(_OWORD *)(v27 + 2) = *(_OWORD *)(v26 - 4);
          }
          v26 += 16;
          v25 -= 16;
        }
        while (v25);
        LODWORD(v24) = *((_DWORD *)this + 2);
      }
      unsigned int v29 = v40;
      if (v24 != v40)
      {
        *((_DWORD *)this + 2) = 0;
        if (*((_DWORD *)this + 3) < v29) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        char v32 = (llvm *)((char *)v39 + 24 * v41);
        if (v29)
        {
          if (v41)
          {
            uint64_t v33 = 24 * v41;
            uint64_t v34 = v39;
            while (*(_DWORD *)v34 >= 0xFFFFFFFE)
            {
              uint64_t v34 = (llvm *)((char *)v34 + 24);
              v33 -= 24;
              if (!v33) {
                goto LABEL_52;
              }
            }
          }
          else
          {
            uint64_t v34 = v39;
          }
        }
        else
        {
LABEL_52:
          uint64_t v34 = (llvm *)((char *)v39 + 24 * v41);
        }
        size_t v35 = (llvm *)((char *)v39 + 24 * v41);
        if (v34 != v35)
        {
          unsigned int v36 = *((_DWORD *)this + 2);
          do
          {
            if (v36 >= *((_DWORD *)this + 3)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(_OWORD *)(*(void *)this + 16 * v36) = *(_OWORD *)((char *)v34 + 8);
            unsigned int v36 = *((_DWORD *)this + 2) + 1;
            *((_DWORD *)this + 2) = v36;
            uint64_t v37 = (unsigned int *)((char *)v34 + 24);
            while (v37 != (unsigned int *)v32)
            {
              unsigned int v38 = *v37;
              v37 += 6;
              if (v38 <= 0xFFFFFFFD)
              {
                uint64_t v34 = (llvm *)(v37 - 6);
                goto LABEL_61;
              }
            }
            uint64_t v34 = v32;
LABEL_61:
            ;
          }
          while (v34 != v35);
        }
      }
      llvm::deallocate_buffer(v39, (void *)(24 * v41));
    }
    sub_1CBF8256C(*(void *)this, (long long *)(*(void *)this + 16 * v1), 126 - 2 * __clz(v1), 1);
    uint64_t v3 = *(void *)this;
    uint64_t v4 = *((unsigned int *)this + 2);
    if (v4)
    {
      uint64_t v5 = v3 + 16 * v4;
      uint64_t v6 = *(void *)this;
      while (2)
      {
        *(_OWORD *)uint64_t v6 = *(_OWORD *)v3;
        for (uint64_t i = v3 + 16; ; i += 16)
        {
          if (i == v5)
          {
            v6 += 16;
            goto LABEL_14;
          }
          if (*(_DWORD *)(v3 + 4) != *(_DWORD *)(i + 4)) {
            break;
          }
          uint64_t v18 = *(void *)(v6 + 8);
          if (v18)
          {
            uint64_t v19 = *(void *)(i + 8);
            BOOL v20 = __CFADD__(v19, v18);
            uint64_t v21 = v19 + v18;
            if (v20) {
              uint64_t v21 = -1;
            }
            *(void *)(v6 + 8) = v21;
          }
          else
          {
            *(_OWORD *)uint64_t v6 = *(_OWORD *)i;
          }
        }
        v6 += 16;
        uint64_t v3 = i;
        if (i != v5) {
          continue;
        }
        break;
      }
LABEL_14:
      uint64_t v3 = *(void *)this;
    }
    else
    {
      uint64_t v6 = *(void *)this;
    }
    unint64_t v8 = (unint64_t)(v6 - v3) >> 4;
    *((_DWORD *)this + 2) = v8;
    if (v8 == 1)
    {
LABEL_3:
      *((void *)this + 10) = 1;
      *(void *)(*(void *)this + 8) = 1;
      return;
    }
    if (*((unsigned char *)this + 88))
    {
      char v10 = 33;
    }
    else
    {
      unint64_t v9 = *((void *)this + 10);
      if (!HIDWORD(v9)) {
        return;
      }
      char v10 = 33 - __clz(v9);
    }
    *((void *)this + 10) = 0;
    if (v8)
    {
      uint64_t v11 = 0;
      uint64_t v12 = v8;
      char v13 = v10;
      char v14 = v10 - 1;
      uint64_t v15 = 16 * v12;
      uint64_t v16 = (unint64_t *)(*(void *)this + 8);
      do
      {
        unint64_t v17 = ((*v16 >> v14) & 1) + (*v16 >> v13);
        if (v17 <= 1) {
          unint64_t v17 = 1;
        }
        *uint64_t v16 = v17;
        v16 += 2;
        v11 += v17;
        v15 -= 16;
      }
      while (v15);
      *((void *)this + 10) = v11;
    }
  }
}

void llvm::BlockFrequencyInfoImplBase::clear(llvm::BlockFrequencyInfoImplBase *this)
{
  long long v2 = (void *)*((void *)this + 1);
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 1) = 0;
  if (v2) {
    operator delete(v2);
  }
  if (*((void *)this + 6))
  {
    uint64_t v13 = *((void *)this + 4);
    uint64_t v12 = (llvm::BlockFrequencyInfoImplBase *)*((void *)this + 5);
    uint64_t v14 = *(void *)v12;
    *(void *)(v14 + 8) = *(void *)(v13 + 8);
    **(void **)(v13 + 8) = v14;
    *((void *)this + 6) = 0;
    if (v12 != (llvm::BlockFrequencyInfoImplBase *)((char *)this + 32))
    {
      do
      {
        uint64_t v15 = (llvm::BlockFrequencyInfoImplBase *)*((void *)v12 + 1);
        operator delete(v12);
        uint64_t v12 = v15;
      }
      while (v15 != (llvm::BlockFrequencyInfoImplBase *)((char *)this + 32));
    }
  }
  uint64_t v3 = (void *)*((void *)this + 8);
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 8) = 0;
  if (v3) {
    operator delete(v3);
  }
  if (*((void *)this + 13))
  {
    uint64_t v4 = (char *)this + 88;
    uint64_t v5 = *((void *)this + 11);
    uint64_t v6 = (char *)*((void *)this + 12);
    uint64_t v7 = *(void *)v6;
    *(void *)(v7 + 8) = *(void *)(v5 + 8);
    **(void **)(v5 + 8) = v7;
    *((void *)this + 13) = 0;
    if (v6 != (char *)this + 88)
    {
      do
      {
        unint64_t v8 = (char *)*((void *)v6 + 1);
        unint64_t v9 = (char *)*((void *)v6 + 18);
        if (v9 != v6 + 160) {
          free(v9);
        }
        char v10 = (char *)*((void *)v6 + 14);
        if (v10 != v6 + 128) {
          free(v10);
        }
        uint64_t v11 = (char *)*((void *)v6 + 4);
        if (v11 != v6 + 48) {
          free(v11);
        }
        operator delete(v6);
        uint64_t v6 = v8;
      }
      while (v8 != v4);
    }
  }
}

uint64_t llvm::BlockFrequencyInfoImplBase::addToDist(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4, unsigned int *a5, unint64_t a6)
{
  if (a6 <= 1) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = a6;
  }
  uint64_t v7 = *(void *)(a1 + 64);
  unint64_t v8 = (unsigned int *)(v7 + 24 * *a5);
  unint64_t v9 = (uint64_t *)*((void *)v8 + 1);
  if (v9 && *((unsigned char *)v9 + 8))
  {
    do
    {
      char v10 = v9;
      unint64_t v9 = (uint64_t *)*v9;
    }
    while (v9 && *((unsigned char *)v9 + 8));
    unint64_t v8 = (unsigned int *)v10[12];
  }
  uint64_t v11 = *v8;
  if (a3)
  {
    uint64_t v12 = *(unsigned int *)(a3 + 12);
    uint64_t v13 = *(_DWORD **)(a3 + 96);
    if (v12 < 2)
    {
      if (v11 == *v13)
      {
LABEL_18:
        uint64_t v21 = (_DWORD *)(a2 + 8);
        unsigned int v20 = *(_DWORD *)(a2 + 8);
        uint64_t v22 = *(void *)(a2 + 80);
        BOOL v23 = __CFADD__(v22, v6);
        uint64_t v24 = v22 + v6;
        char v25 = v23;
        *(unsigned char *)(a2 + 88) |= v25;
        *(void *)(a2 + 80) = v24;
        if (v20 >= *(_DWORD *)(a2 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        uint64_t v26 = 2;
LABEL_36:
        uint64_t v38 = v26 | (v11 << 32);
LABEL_37:
        unint64_t v39 = (uint64_t *)(*(void *)a2 + 16 * v20);
        *unint64_t v39 = v38;
        v39[1] = v6;
        ++*v21;
        return 1;
      }
    }
    else
    {
      uint64_t v14 = *(_DWORD **)(a3 + 96);
      unint64_t v15 = *(unsigned int *)(a3 + 12);
      do
      {
        unint64_t v16 = v15 >> 1;
        unint64_t v17 = &v14[v15 >> 1];
        unsigned int v19 = *v17;
        uint64_t v18 = v17 + 1;
        v15 += ~(v15 >> 1);
        if (v19 < v11) {
          uint64_t v14 = v18;
        }
        else {
          unint64_t v15 = v16;
        }
      }
      while (v15);
      if (v14 != &v13[v12] && v11 >= *v14) {
        goto LABEL_18;
      }
    }
  }
  uint64_t v27 = (int *)(v7 + 24 * v11);
  unsigned int v29 = v27 + 2;
  uint64_t v28 = (uint64_t *)*((void *)v27 + 1);
  if (v28)
  {
    unint64_t v30 = *((unsigned int *)v28 + 3);
    uint64_t v31 = (unsigned int *)v28[12];
    if (v30 >= 2)
    {
      unsigned int v32 = *v27;
      int v53 = (unsigned int *)v28[12];
      unint64_t v54 = *((unsigned int *)v28 + 3);
      do
      {
        unint64_t v55 = v54 >> 1;
        int v56 = &v53[v54 >> 1];
        unsigned int v58 = *v56;
        int v57 = v56 + 1;
        v54 += ~(v54 >> 1);
        if (v58 < v32) {
          int v53 = v57;
        }
        else {
          unint64_t v54 = v55;
        }
      }
      while (v54);
      BOOL v59 = &v31[v30];
      if (v53 == v59 || v32 < *v53) {
        goto LABEL_30;
      }
      do
      {
        unint64_t v60 = v30 >> 1;
        int v61 = &v31[v30 >> 1];
        unsigned int v63 = *v61;
        uint64_t v62 = v61 + 1;
        v30 += ~(v30 >> 1);
        if (v63 < v32) {
          uint64_t v31 = v62;
        }
        else {
          unint64_t v30 = v60;
        }
      }
      while (v30);
      if (v31 == v59 || v32 < *v31) {
        goto LABEL_29;
      }
    }
    else
    {
      unsigned int v32 = *v27;
      if (v32 != *v31) {
        goto LABEL_30;
      }
    }
    uint64_t v33 = *v28;
    if (!*v28 || (uint64_t v34 = *(unsigned int *)(v33 + 12), v34 < 2))
    {
LABEL_29:
      unsigned int v29 = v28;
      goto LABEL_30;
    }
    int v64 = *(unsigned int **)(v33 + 96);
    unint64_t v65 = *(unsigned int *)(v33 + 12);
    do
    {
      unint64_t v66 = v65 >> 1;
      uint64_t v67 = &v64[v65 >> 1];
      unsigned int v69 = *v67;
      uint64_t v68 = v67 + 1;
      v65 += ~(v65 >> 1);
      if (v69 < v32) {
        int v64 = v68;
      }
      else {
        unint64_t v65 = v66;
      }
    }
    while (v65);
    uint64_t v70 = *(void *)(v33 + 96) + 4 * v34;
    unsigned int v29 = v28;
    if (v64 != (unsigned int *)v70)
    {
      if (v32 >= *v64) {
        unsigned int v29 = (void *)*v28;
      }
      else {
        unsigned int v29 = v28;
      }
    }
  }
LABEL_30:
  if (*v29 != a3)
  {
    uint64_t v21 = (_DWORD *)(a2 + 8);
    unsigned int v20 = *(_DWORD *)(a2 + 8);
    uint64_t v35 = *(void *)(a2 + 80);
    BOOL v23 = __CFADD__(v35, v6);
    uint64_t v36 = v35 + v6;
    char v37 = v23;
    *(unsigned char *)(a2 + 88) |= v37;
    *(void *)(a2 + 80) = v36;
    if (v20 >= *(_DWORD *)(a2 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v26 = 1;
    goto LABEL_36;
  }
  unsigned int v41 = *a4;
  if (v11 >= *a4) {
    goto LABEL_48;
  }
  if (!a3) {
    return 0;
  }
  uint64_t v42 = *(unsigned int *)(a3 + 12);
  uint64_t v43 = *(_DWORD **)(a3 + 96);
  if (v42 < 2)
  {
    if (v41 != *v43) {
      return 0;
    }
LABEL_48:
    uint64_t v21 = (_DWORD *)(a2 + 8);
    unsigned int v20 = *(_DWORD *)(a2 + 8);
    uint64_t v50 = *(void *)(a2 + 80);
    BOOL v23 = __CFADD__(v50, v6);
    uint64_t v51 = v50 + v6;
    char v52 = v23;
    *(unsigned char *)(a2 + 88) |= v52;
    *(void *)(a2 + 80) = v51;
    if (v20 >= *(_DWORD *)(a2 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v38 = v11 << 32;
    goto LABEL_37;
  }
  __int16 v44 = *(unsigned int **)(a3 + 96);
  unint64_t v45 = *(unsigned int *)(a3 + 12);
  do
  {
    unint64_t v46 = v45 >> 1;
    unint64_t v47 = &v44[v45 >> 1];
    unsigned int v49 = *v47;
    uint64_t v48 = v47 + 1;
    v45 += ~(v45 >> 1);
    if (v49 < v41) {
      __int16 v44 = v48;
    }
    else {
      unint64_t v45 = v46;
    }
  }
  while (v45);
  if (v44 != &v43[v42] && v41 >= *v44) {
    goto LABEL_48;
  }
  return 0;
}

uint64_t llvm::BlockFrequencyInfoImplBase::addLoopSuccessorsToDist(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(unsigned int *)(a3 + 24);
  if (!v4) {
    return 1;
  }
  uint64_t v9 = *(void *)(a3 + 16);
  uint64_t v10 = 16 * v4 - 16;
  do
  {
    unsigned int v13 = **(_DWORD **)(a3 + 96);
    uint64_t result = llvm::BlockFrequencyInfoImplBase::addToDist(a1, a4, a2, &v13, (unsigned int *)v9, *(void *)(v9 + 8));
    v9 += 16;
    if (result) {
      BOOL v12 = v10 == 0;
    }
    else {
      BOOL v12 = 1;
    }
    v10 -= 16;
  }
  while (!v12);
  return result;
}

unint64_t llvm::BlockFrequencyInfoImplBase::computeLoopScale(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a2 + 136);
  if (!v3)
  {
    __int16 v4 = 0;
LABEL_3:
    unint64_t result = 1;
    goto LABEL_4;
  }
  uint64_t v6 = 0;
  uint64_t v7 = *(uint64_t **)(a2 + 128);
  uint64_t v8 = 8 * v3;
  do
  {
    uint64_t v9 = *v7++;
    uint64_t v10 = v6 + v9;
    if (__CFADD__(v6, v9)) {
      uint64_t v6 = -1;
    }
    else {
      uint64_t v6 = v10;
    }
    v8 -= 8;
  }
  while (v8);
  if (v6 == -1)
  {
    __int16 v4 = 12;
    goto LABEL_3;
  }
  if (v6) {
    unint64_t v11 = -v6;
  }
  else {
    unint64_t v11 = 1;
  }
  if (!v11)
  {
LABEL_23:
    unint64_t result = -1;
    __int16 v4 = 0x3FFF;
    goto LABEL_4;
  }
  unint64_t result = llvm::ScaledNumbers::divide64(1uLL, v11);
  __int16 v4 = v12;
  if (v6 && result)
  {
    int v13 = 0x3FFF - v12 >= 64 ? 64 : 0x3FFF - v12;
    __int16 v4 = v13 + v12;
    if (v12 >= 16320)
    {
      int v15 = v13;
      __int16 v16 = v13 + v12;
      unint64_t v14 = result;
      if (sub_1CBF7ECD0(result, v4, 0xFFFFFFFFFFFFFFFFLL, 0x3FFF))
      {
        if (64 - v15 > __clz(v14)) {
          goto LABEL_23;
        }
        unint64_t result = v14 << (64 - v15);
      }
      else
      {
        unint64_t result = v14;
      }
      __int16 v4 = v16;
    }
  }
LABEL_4:
  *(void *)(a2 + 160) = result;
  *(_WORD *)(a2 + 168) = v4;
  return result;
}

uint64_t llvm::BlockFrequencyInfoImplBase::packageLoop(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 104);
  if (v2)
  {
    uint64_t v3 = *(unsigned int **)(a2 + 96);
    __int16 v4 = &v3[v2];
    uint64_t v5 = *(void *)(result + 64);
    do
    {
      uint64_t v6 = *(uint64_t **)(v5 + 24 * *v3 + 8);
      if (v6 && *((unsigned char *)v6 + 8))
      {
        do
        {
          uint64_t v7 = v6;
          uint64_t v6 = (uint64_t *)*v6;
        }
        while (v6 && *((unsigned char *)v6 + 8));
        *((_DWORD *)v7 + 6) = 0;
      }
      ++v3;
    }
    while (v3 != v4);
  }
  *(unsigned char *)(a2 + 8) = 1;
  return result;
}

void llvm::BlockFrequencyInfoImplBase::distributeMass(uint64_t a1, unsigned int *a2, uint64_t a3, llvm::BlockFrequencyInfoImplBase::Distribution *this)
{
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v8 = (int *)(v7 + 24 * *a2);
  uint64_t v9 = (uint64_t *)*((void *)v8 + 1);
  if (!v9) {
    goto LABEL_2;
  }
  unint64_t v34 = *((unsigned int *)v9 + 3);
  uint64_t v35 = (unsigned int *)v9[12];
  if (v34 >= 2)
  {
    unsigned int v36 = *v8;
    int v57 = (unsigned int *)v9[12];
    unint64_t v58 = *((unsigned int *)v9 + 3);
    do
    {
      unint64_t v59 = v58 >> 1;
      unint64_t v60 = &v57[v58 >> 1];
      unsigned int v62 = *v60;
      int v61 = v60 + 1;
      v58 += ~(v58 >> 1);
      if (v62 < v36) {
        int v57 = v61;
      }
      else {
        unint64_t v58 = v59;
      }
    }
    while (v58);
    unsigned int v63 = &v35[v34];
    if (v57 == v63 || v36 < *v57 || !*((unsigned char *)v9 + 8)) {
      goto LABEL_2;
    }
    do
    {
      unint64_t v64 = v34 >> 1;
      unint64_t v65 = &v35[v34 >> 1];
      unsigned int v67 = *v65;
      unint64_t v66 = v65 + 1;
      v34 += ~(v34 >> 1);
      if (v67 < v36) {
        uint64_t v35 = v66;
      }
      else {
        unint64_t v34 = v64;
      }
    }
    while (v34);
    if (v35 == v63 || v36 < *v35) {
      goto LABEL_35;
    }
  }
  else
  {
    unsigned int v36 = *v8;
    if (v36 != *v35 || !*((unsigned char *)v9 + 8))
    {
LABEL_2:
      uint64_t v10 = (unint64_t *)(v7 + 24 * *a2 + 16);
      goto LABEL_3;
    }
  }
  uint64_t v37 = *v9;
  if (!*v9) {
    goto LABEL_35;
  }
  uint64_t v38 = *(unsigned int *)(v37 + 12);
  if (v38 < 2) {
    goto LABEL_35;
  }
  BOOL v81 = *(unsigned int **)(v37 + 96);
  unint64_t v82 = *(unsigned int *)(v37 + 12);
  do
  {
    unint64_t v83 = v82 >> 1;
    int v84 = &v81[v82 >> 1];
    unsigned int v86 = *v84;
    unint64_t v85 = v84 + 1;
    v82 += ~(v82 >> 1);
    if (v86 < v36) {
      BOOL v81 = v85;
    }
    else {
      unint64_t v82 = v83;
    }
  }
  while (v82);
  if (v81 == (unsigned int *)(*(void *)(v37 + 96) + 4 * v38) || v36 < *v81 || !*(unsigned char *)(v37 + 8))
  {
LABEL_35:
    uint64_t v10 = (unint64_t *)(v9 + 19);
    goto LABEL_3;
  }
  uint64_t v10 = (unint64_t *)(v37 + 152);
LABEL_3:
  unint64_t v11 = *v10;
  llvm::BlockFrequencyInfoImplBase::Distribution::normalize(this);
  uint64_t v12 = *((unsigned int *)this + 2);
  if (v12)
  {
    uint64_t v13 = *(void *)this;
    uint64_t v14 = *(void *)this + 16 * v12;
    unsigned int v15 = *((_DWORD *)this + 20);
    do
    {
      uint64_t v16 = *(void *)(v13 + 8);
      LODWORD(v17) = v16;
      if (v15 != 0x80000000) {
        unint64_t v17 = ((v15 >> 1) | ((unint64_t)v16 << 31)) / v15;
      }
      unint64_t v18 = v11;
      if (v11)
      {
        unint64_t v18 = v11;
        if (v17 != 0x80000000)
        {
          unint64_t v19 = v11 * (unint64_t)v17;
          unint64_t v20 = HIDWORD(v19) + HIDWORD(v11) * (unint64_t)v17;
          unint64_t v21 = (((unint64_t)(v20 < HIDWORD(v11) * (int)v17) << 32)
               + HIDWORD(v11) * (unint64_t)v17) & 0xFFFFFFFF00000000 | v20;
          if ((v21 & 0x8000000000000000) != 0) {
            unint64_t v18 = -1;
          }
          else {
            unint64_t v18 = ((v19 & 0x80000000 | ((v20 & 0x7FFFFFFF) << 32)) >> 31) | ((unint64_t)(v21 >> 31) << 32);
          }
        }
      }
      if (v11 >= v18) {
        v11 -= v18;
      }
      else {
        unint64_t v11 = 0;
      }
      if (*(_DWORD *)v13)
      {
        if (*(_DWORD *)v13 == 2)
        {
          unint64_t v41 = *(unsigned int *)(a3 + 12);
          if (v41 >= 2)
          {
            uint64_t v68 = v13;
            unsigned int v69 = *(_DWORD *)(v13 + 4);
            uint64_t v70 = *(_DWORD **)(a3 + 96);
            do
            {
              unint64_t v71 = v41 >> 1;
              BOOL v72 = &v70[v41 >> 1];
              unsigned int v74 = *v72;
              uint64_t v73 = v72 + 1;
              v41 += ~(v41 >> 1);
              if (v74 < v69) {
                uint64_t v70 = v73;
              }
              else {
                unint64_t v41 = v71;
              }
            }
            while (v41);
            uint64_t v42 = ((uint64_t)v70 - *(void *)(a3 + 96)) >> 2;
            uint64_t v13 = v68;
          }
          else
          {
            uint64_t v42 = 0;
          }
          uint64_t v43 = *(void *)(a3 + 128);
          uint64_t v44 = *(void *)(v43 + 8 * v42);
          BOOL v27 = __CFADD__(v44, v18);
          uint64_t v45 = v44 + v18;
          if (v27) {
            uint64_t v45 = -1;
          }
          *(void *)(v43 + 8 * v42) = v45;
        }
        else
        {
          unint64_t v39 = *(unsigned int *)(a3 + 24);
          if (v39 >= *(unsigned int *)(a3 + 28)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          unsigned int v40 = (void *)(*(void *)(a3 + 16) + 16 * v39);
          *unsigned int v40 = *(unsigned int *)(v13 + 4);
          v40[1] = v18;
          ++*(_DWORD *)(a3 + 24);
        }
        goto LABEL_21;
      }
      unsigned int v22 = *(_DWORD *)(v13 + 4);
      uint64_t v23 = *(void *)(a1 + 64);
      uint64_t v24 = (int *)(v23 + 24 * v22);
      char v25 = (uint64_t *)*((void *)v24 + 1);
      if (v25)
      {
        unint64_t v29 = *((unsigned int *)v25 + 3);
        unint64_t v30 = (unsigned int *)v25[12];
        if (v29 >= 2)
        {
          unsigned int v31 = *v24;
          unint64_t v46 = (unsigned int *)v25[12];
          unint64_t v47 = *((unsigned int *)v25 + 3);
          do
          {
            unint64_t v48 = v47 >> 1;
            unsigned int v49 = &v46[v47 >> 1];
            unsigned int v51 = *v49;
            uint64_t v50 = v49 + 1;
            v47 += ~(v47 >> 1);
            if (v51 < v31) {
              unint64_t v46 = v50;
            }
            else {
              unint64_t v47 = v48;
            }
          }
          while (v47);
          char v52 = &v30[v29];
          if (v46 != v52 && v31 >= *v46 && *((unsigned char *)v25 + 8))
          {
            do
            {
              unint64_t v53 = v29 >> 1;
              unint64_t v54 = &v30[v29 >> 1];
              unsigned int v56 = *v54;
              unint64_t v55 = v54 + 1;
              v29 += ~(v29 >> 1);
              if (v56 < v31) {
                unint64_t v30 = v55;
              }
              else {
                unint64_t v29 = v53;
              }
            }
            while (v29);
            if (v30 != v52 && v31 >= *v30)
            {
LABEL_26:
              uint64_t v32 = *v25;
              if (*v25)
              {
                uint64_t v33 = *(unsigned int *)(v32 + 12);
                if (v33 >= 2)
                {
                  unint64_t v75 = *(unsigned int **)(v32 + 96);
                  unint64_t v76 = *(unsigned int *)(v32 + 12);
                  do
                  {
                    unint64_t v77 = v76 >> 1;
                    BOOL v78 = &v75[v76 >> 1];
                    unsigned int v80 = *v78;
                    unint64_t v79 = v78 + 1;
                    v76 += ~(v76 >> 1);
                    if (v80 < v31) {
                      unint64_t v75 = v79;
                    }
                    else {
                      unint64_t v76 = v77;
                    }
                  }
                  while (v76);
                  if (v75 != (unsigned int *)(*(void *)(v32 + 96) + 4 * v33) && v31 >= *v75 && *(unsigned char *)(v32 + 8))
                  {
                    uint64_t v26 = (uint64_t *)(v32 + 152);
                    goto LABEL_17;
                  }
                }
              }
            }
            uint64_t v26 = v25 + 19;
            goto LABEL_17;
          }
        }
        else
        {
          unsigned int v31 = *v24;
          if (v31 == *v30 && *((unsigned char *)v25 + 8)) {
            goto LABEL_26;
          }
        }
      }
      uint64_t v26 = (uint64_t *)(v23 + 24 * v22 + 16);
LABEL_17:
      BOOL v27 = __CFADD__(*v26, v18);
      uint64_t v28 = *v26 + v18;
      if (v27) {
        uint64_t v28 = -1;
      }
      *uint64_t v26 = v28;
LABEL_21:
      v15 -= v16;
      v13 += 16;
    }
    while (v13 != v14);
  }
}

void *llvm::BlockFrequencyInfoImplBase::unwrapLoops(void *this)
{
  uint64_t v1 = this[8];
  if (this[9] != v1)
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    do
    {
      uint64_t v4 = *(void *)(v1 + v2 + 16);
      BOOL v5 = __CFADD__(v4, 1);
      uint64_t v6 = v4 + 1;
      if (v5) {
        uint64_t v6 = 1;
      }
      uint64_t v7 = this[1] + v2;
      *(void *)uint64_t v7 = v6;
      if (v5) {
        __int16 v8 = 0;
      }
      else {
        __int16 v8 = -64;
      }
      *(_WORD *)(v7 + 8) = v8;
      ++v3;
      uint64_t v1 = this[8];
      v2 += 24;
    }
    while (v3 < 0xAAAAAAAAAAAAAAABLL * ((this[9] - v1) >> 3));
  }
  uint64_t v9 = this + 11;
  uint64_t v10 = this[12];
  if ((void *)v10 != this + 11)
  {
    while (1)
    {
      uint64_t v12 = *(void *)(v10 + 168);
      unint64_t v11 = *(void *)(v10 + 176);
      if (v12 == -1) {
        uint64_t v13 = 1;
      }
      else {
        uint64_t v13 = v12 + 1;
      }
      if (v11)
      {
        if (v12 == -1) {
          __int16 v14 = 0;
        }
        else {
          __int16 v14 = -64;
        }
        if (v13)
        {
          unint64_t v15 = (v13 | v11) >> 32;
          if (v15)
          {
            unint64_t v16 = HIDWORD(v11);
            unint64_t v17 = v13 * (unint64_t)HIDWORD(v11);
            unint64_t v18 = HIDWORD(v13) * (unint64_t)v11;
            unint64_t v19 = v13 * (unint64_t)v11;
            unint64_t v20 = v13 * v11;
            if (v20 >= v19 + (v17 << 32)) {
              unint64_t v21 = (__PAIR128__(HIDWORD(v17) + HIDWORD(v13) * (unint64_t)v16, v19)
            }
                   + __PAIR128__(HIDWORD(v18), v17 << 32)) >> 64;
            else {
              unint64_t v21 = ((__PAIR128__(HIDWORD(v17) + HIDWORD(v13) * (unint64_t)v16, v19)
            }
                    + __PAIR128__(HIDWORD(v18), v17 << 32)) >> 64)
                  + 1;
            if (v21)
            {
              int v22 = __clz(v21);
              LOWORD(v15) = 64 - v22;
              if (v22) {
                unint64_t v21 = (v20 >> -(char)v22) | (v21 << v22);
              }
              if ((v20 >> (v22 ^ 0x3Fu)))
              {
                unint64_t v20 = v21 + 1;
                if (v21 == -1)
                {
                  unint64_t v20 = 0x8000000000000000;
                  LOWORD(v15) = 65 - v22;
                }
              }
              else
              {
                unint64_t v20 = v21;
              }
            }
            else
            {
              LOWORD(v15) = 0;
            }
          }
          else
          {
            unint64_t v20 = v13 * v11;
          }
          unsigned __int16 v23 = *(_WORD *)(v10 + 184) + v14;
          *(void *)(v10 + 176) = v20;
          *(_WORD *)(v10 + 184) = v15;
          if (v23 && v20)
          {
            int v24 = (__int16)v23;
            if ((v23 & 0x8000) != 0)
            {
              int v25 = -(__int16)v23;
              int v26 = (unsigned __int16)(v15 + 16382);
              if (v26 >= -v24) {
                int v27 = -v24;
              }
              else {
                int v27 = (unsigned __int16)(v15 + 16382);
              }
              *(_WORD *)(v10 + 184) = v15 - v27;
              if (v26 < v25)
              {
                if (v25 - v27 < 64)
                {
                  *(void *)(v10 + 176) = v20 >> (v25 - v27);
                }
                else
                {
                  *(void *)(v10 + 176) = 0;
                  *(_WORD *)(v10 + 184) = 0;
                }
              }
            }
            else
            {
              unsigned int v52 = (unsigned __int16)(0x3FFF - v15);
              int v53 = (__int16)(0x3FFF - v15);
              if (v53 >= (__int16)v23) {
                LOWORD(v53) = v23;
              }
              __int16 v54 = v53 + v15;
              *(_WORD *)(v10 + 184) = v54;
              if (v52 < v23)
              {
                unsigned int v74 = this;
                unsigned __int16 v80 = v53;
                unint64_t v76 = v9;
                uint64_t v78 = v10;
                int v72 = (__int16)v23;
                int v55 = sub_1CBF7ECD0(v20, v54, 0xFFFFFFFFFFFFFFFFLL, 0x3FFF);
                uint64_t v9 = v76;
                uint64_t v10 = v78;
                int v56 = v55;
                this = v74;
                if (v56)
                {
                  unint64_t v57 = *(void *)(v78 + 176);
                  if (v72 - v80 <= (int)__clz(v57))
                  {
                    unint64_t v66 = v57 << (v72 - v80);
                    uint64_t v9 = v76;
                    uint64_t v10 = v78;
                    *(void *)(v78 + 176) = v66;
                  }
                  else
                  {
                    uint64_t v9 = v76;
                    uint64_t v10 = v78;
                    *(void *)(v78 + 176) = -1;
                    *(_WORD *)(v78 + 184) = 0x3FFF;
                  }
                  this = v74;
                }
              }
            }
          }
        }
        else
        {
          *(void *)(v10 + 176) = 0;
          *(_WORD *)(v10 + 184) = v14;
        }
      }
      *(unsigned char *)(v10 + 24) = 0;
      uint64_t v28 = *(unsigned int *)(v10 + 120);
      if (v28) {
        break;
      }
LABEL_78:
      uint64_t v10 = *(void *)(v10 + 8);
      if ((void *)v10 == v9) {
        return this;
      }
    }
    unint64_t v29 = *(unsigned int **)(v10 + 112);
    unint64_t v30 = &v29[v28];
    while (1)
    {
      uint64_t v31 = this[8] + 24 * *v29;
      uint64_t v32 = *(uint64_t **)(v31 + 8);
      if (!v32) {
        break;
      }
      uint64_t v48 = *((unsigned int *)v32 + 3);
      unsigned int v49 = (_DWORD *)v32[12];
      if (v48 >= 2)
      {
        unsigned int v58 = *(_DWORD *)v31;
        unint64_t v59 = (unsigned int *)v32[12];
        unint64_t v60 = *((unsigned int *)v32 + 3);
        do
        {
          unint64_t v61 = v60 >> 1;
          unsigned int v62 = &v59[v60 >> 1];
          unsigned int v64 = *v62;
          unsigned int v63 = v62 + 1;
          v60 += ~(v60 >> 1);
          if (v64 < v58) {
            unint64_t v59 = v63;
          }
          else {
            unint64_t v60 = v61;
          }
        }
        while (v60);
        if (v59 == &v49[v48] || v58 < *v59) {
          break;
        }
      }
      else if (*(_DWORD *)v31 != *v49)
      {
        break;
      }
      if (!*((unsigned char *)v32 + 8)) {
        break;
      }
      do
      {
        uint64_t v50 = v32;
        uint64_t v32 = (uint64_t *)*v32;
      }
      while (v32 && *((unsigned char *)v32 + 8));
      uint64_t v33 = (uint64_t)(v50 + 20);
LABEL_40:
      unint64_t v34 = *(void *)(v10 + 176);
      __int16 v35 = *(_WORD *)(v10 + 184);
      if (v34)
      {
        uint64_t v36 = *(void *)v33;
        if (*(void *)v33)
        {
          unint64_t v37 = (v36 | v34) >> 32;
          if (v37)
          {
            unint64_t v38 = HIDWORD(v34);
            unint64_t v39 = v36 * (unint64_t)HIDWORD(v34);
            unint64_t v40 = HIDWORD(v36) * (unint64_t)v34;
            unint64_t v41 = v36 * (unint64_t)v34;
            v34 *= v36;
            if (v34 >= v41 + (v39 << 32)) {
              unint64_t v42 = (__PAIR128__(HIDWORD(v39) + HIDWORD(v36) * (unint64_t)v38, v41)
            }
                   + __PAIR128__(HIDWORD(v40), v39 << 32)) >> 64;
            else {
              unint64_t v42 = ((__PAIR128__(HIDWORD(v39) + HIDWORD(v36) * (unint64_t)v38, v41)
            }
                    + __PAIR128__(HIDWORD(v40), v39 << 32)) >> 64)
                  + 1;
            if (v42)
            {
              int v43 = __clz(v42);
              LOWORD(v37) = 64 - v43;
              if (v43) {
                unint64_t v42 = (v34 >> -(char)v43) | (v42 << v43);
              }
              if ((v34 >> (v43 ^ 0x3Fu)))
              {
                unint64_t v34 = v42 + 1;
                if (v42 == -1)
                {
                  unint64_t v34 = 0x8000000000000000;
                  LOWORD(v37) = 65 - v43;
                }
              }
              else
              {
                unint64_t v34 = v42;
              }
            }
            else
            {
              LOWORD(v37) = 0;
            }
            LODWORD(v37) = (unsigned __int16)v37;
          }
          else
          {
            v34 *= v36;
          }
          __int16 v44 = *(_WORD *)(v33 + 8) + v35;
          int v45 = v44;
          if (v44 && v34)
          {
            if (v44 < 0)
            {
              int v46 = -v44;
              if ((int)v37 + 16382 >= v46) {
                int v47 = -v44;
              }
              else {
                int v47 = v37 + 16382;
              }
              __int16 v35 = v37 - v47;
              if ((int)v37 + 16382 < v46)
              {
                if (v46 - v47 <= 63)
                {
                  v34 >>= v46 - v47;
                }
                else
                {
                  __int16 v35 = 0;
                  unint64_t v34 = 0;
                }
              }
              goto LABEL_59;
            }
            if (0x3FFF - (int)v37 >= v44) {
              int v51 = v44;
            }
            else {
              int v51 = 0x3FFF - v37;
            }
            __int16 v35 = v51 + v37;
            if (0x3FFF - (int)v37 >= v45) {
              goto LABEL_59;
            }
            int v67 = v45;
            int v68 = v51;
            unint64_t v71 = v30;
            uint64_t v73 = v33;
            uint64_t v70 = v29;
            unint64_t v77 = v9;
            uint64_t v79 = v10;
            unint64_t v75 = this;
            __int16 v69 = v51 + v37;
            unint64_t v81 = v34;
            if (!sub_1CBF7ECD0(v34, v35, 0xFFFFFFFFFFFFFFFFLL, 0x3FFF))
            {
              this = v75;
              unint64_t v34 = v81;
LABEL_111:
              uint64_t v9 = v77;
              uint64_t v10 = v79;
              unint64_t v29 = v70;
              unint64_t v30 = v71;
              uint64_t v33 = v73;
              __int16 v35 = v69;
              goto LABEL_59;
            }
            if (v67 - v68 <= (int)__clz(v81))
            {
              unint64_t v34 = v81 << (v67 - v68);
              this = v75;
              goto LABEL_111;
            }
            unint64_t v34 = -1;
            __int16 v35 = 0x3FFF;
            uint64_t v33 = v73;
            this = v75;
            uint64_t v9 = v77;
            uint64_t v10 = v79;
            unint64_t v29 = v70;
            unint64_t v30 = v71;
          }
          else
          {
            __int16 v35 = v37;
          }
        }
        else
        {
          unint64_t v34 = 0;
          __int16 v35 = *(_WORD *)(v33 + 8);
        }
      }
LABEL_59:
      *(void *)uint64_t v33 = v34;
      *(_WORD *)(v33 + 8) = v35;
      if (++v29 == v30) {
        goto LABEL_78;
      }
    }
    uint64_t v33 = this[1] + 24 * *v29;
    goto LABEL_40;
  }
  return this;
}

uint64_t *llvm::BlockFrequencyInfoImplBase::finalizeMetrics(llvm::BlockFrequencyInfoImplBase *this)
{
  uint64_t v2 = this;
  *(_OWORD *)unint64_t v127 = xmmword_1CFAC30B0;
  int v125 = 0;
  uint64_t v126 = 0;
  uint64_t v3 = *((void *)this + 9) - *((void *)this + 8);
  if (!v3) {
    goto LABEL_185;
  }
  uint64_t v4 = *((void *)this + 1);
  unint64_t v5 = v3 / 24;
  if (v5 <= 1) {
    unint64_t v5 = 1;
  }
  do
  {
    unint64_t v6 = *(void *)v4;
    int v7 = *(__int16 *)(v4 + 8);
    int v8 = __clz(*(void *)v4);
    if (*(void *)v4)
    {
      if (!v127[0]) {
        goto LABEL_25;
      }
      unsigned int v9 = (v8 ^ 0x3F) + v7;
      uint64_t v10 = 1 << (62 - v8);
      BOOL v11 = (v10 & v6) == 0;
      if ((v10 & v6) != 0) {
        uint64_t v12 = v9 + 1;
      }
      else {
        uint64_t v12 = v9;
      }
      if (v11) {
        unint64_t v13 = 0xFFFFFFFF00000000;
      }
      else {
        unint64_t v13 = 0x100000000;
      }
      unint64_t v14 = v13 | v12;
      if (1 << (v8 ^ 0x3Fu) == v6) {
        unint64_t v15 = (v8 ^ 0x3Fu) + v7;
      }
      else {
        unint64_t v15 = v14;
      }
      int v16 = v15 - (SHIDWORD(v15) > 0);
      int v17 = __clz(v127[0]);
      unint64_t v18 = (v17 ^ 0x3Fu) + SLOWORD(v127[1]);
      uint64_t v19 = 1 << (v17 ^ 0x3Fu);
      uint64_t v20 = 1 << (62 - v17);
      BOOL v21 = (v20 & v127[0]) == 0;
      if ((v20 & v127[0]) != 0) {
        uint64_t v22 = (v18 + 1);
      }
      else {
        uint64_t v22 = v18;
      }
      if (v21) {
        unint64_t v23 = 0xFFFFFFFF00000000;
      }
      else {
        unint64_t v23 = 0x100000000;
      }
      unint64_t v24 = v23 | v22;
      if (v19 == v127[0]) {
        unint64_t v24 = v18;
      }
      int v25 = v24 - (SHIDWORD(v24) > 0);
      if (v16 != v25)
      {
        if (v16 >= v25) {
          goto LABEL_25;
        }
        goto LABEL_56;
      }
      char v47 = v7 - LOBYTE(v127[1]);
      if (v7 < SLOWORD(v127[1]))
      {
        char v107 = LOBYTE(v127[1]) - v7;
        if (v6 >> (LOBYTE(v127[1]) - v7) < v127[0]) {
          goto LABEL_56;
        }
        if (v6 >> v107 > v127[0])
        {
LABEL_25:
          int v26 = v127;
          goto LABEL_26;
        }
        int v48 = v6 >> v107 << v107 < v6;
      }
      else
      {
        if (v127[0] >> v47 < v6) {
          goto LABEL_25;
        }
        if (v127[0] >> v47 > v6) {
          goto LABEL_56;
        }
        if (v127[0] >> v47 << v47 >= v127[0]) {
          int v48 = 0;
        }
        else {
          int v48 = -1;
        }
      }
    }
    else if (v127[0])
    {
      int v48 = -1;
    }
    else
    {
      int v48 = 0;
    }
    if ((v48 & 0x80000000) == 0) {
      goto LABEL_25;
    }
LABEL_56:
    int v26 = (unint64_t *)v4;
LABEL_26:
    unint64_t v27 = *v26;
    LOWORD(v127[1]) = *((_WORD *)v26 + 4);
    v127[0] = v27;
    if (v125)
    {
      if (!v6) {
        goto LABEL_46;
      }
      int v28 = __clz((unint64_t)v125);
      unint64_t v29 = (v28 ^ 0x3Fu) + (__int16)v126;
      unint64_t v30 = (llvm::ScaledNumbers *)(1 << (v28 ^ 0x3Fu));
      uint64_t v31 = 1 << (62 - v28);
      BOOL v32 = (v31 & (unint64_t)v125) == 0;
      if ((v31 & (unint64_t)v125) != 0) {
        uint64_t v33 = (v29 + 1);
      }
      else {
        uint64_t v33 = v29;
      }
      if (v32) {
        unint64_t v34 = 0xFFFFFFFF00000000;
      }
      else {
        unint64_t v34 = 0x100000000;
      }
      unint64_t v35 = v34 | v33;
      if (v30 == v125) {
        unint64_t v35 = v29;
      }
      int v36 = v35 - (SHIDWORD(v35) > 0);
      unint64_t v37 = (v8 ^ 0x3Fu) + v7;
      uint64_t v38 = 1 << (v8 ^ 0x3Fu);
      uint64_t v39 = 1 << (62 - v8);
      BOOL v40 = (v39 & v6) == 0;
      if ((v39 & v6) != 0) {
        uint64_t v41 = (v37 + 1);
      }
      else {
        uint64_t v41 = v37;
      }
      if (v40) {
        unint64_t v42 = 0xFFFFFFFF00000000;
      }
      else {
        unint64_t v42 = 0x100000000;
      }
      unint64_t v43 = v42 | v41;
      if (v38 == v6) {
        unint64_t v43 = v37;
      }
      int v44 = v43 - (SHIDWORD(v43) > 0);
      if (v36 != v44)
      {
        if (v36 >= v44) {
          goto LABEL_46;
        }
        goto LABEL_64;
      }
      if ((__int16)v126 < v7)
      {
        char v108 = v7 - v126;
        if ((unint64_t)v125 >> v108 < v6) {
          goto LABEL_64;
        }
        if ((unint64_t)v125 >> v108 > v6)
        {
LABEL_46:
          int v45 = &v125;
          goto LABEL_47;
        }
        int v50 = (unint64_t)v125 >> v108 << v108 < (unint64_t)v125;
      }
      else
      {
        char v49 = v126 - v7;
        if (v6 >> v49 < (unint64_t)v125) {
          goto LABEL_46;
        }
        if (v6 >> v49 > (unint64_t)v125) {
          goto LABEL_64;
        }
        if (v6 >> v49 << v49 >= v6) {
          int v50 = 0;
        }
        else {
          int v50 = -1;
        }
      }
    }
    else if (v6)
    {
      int v50 = -1;
    }
    else
    {
      int v50 = 0;
    }
    if ((v50 & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_64:
    int v45 = (llvm::ScaledNumbers **)v4;
LABEL_47:
    int v46 = *v45;
    LOWORD(v126) = *((_WORD *)v45 + 4);
    int v125 = v46;
    v4 += 24;
    --v5;
  }
  while (v5);
  if (!v125) {
    goto LABEL_185;
  }
  unint64_t v51 = v127[0];
  if (!v127[0])
  {
LABEL_149:
    unint64_t v54 = -1;
    __int16 v56 = 0x3FFF;
    goto LABEL_150;
  }
  int v52 = (unsigned __int16)v126;
  int v53 = LOWORD(v127[1]);
  unint64_t v54 = llvm::ScaledNumbers::divide64((unint64_t)v125, v127[0]);
  __int16 v56 = v55;
  __int16 v57 = v52 - v53;
  if (v52 == v53 || !v54) {
    goto LABEL_198;
  }
  int v58 = v57;
  uint64_t v2 = this;
  if (v57 < 0)
  {
    int v59 = -v57;
    int v60 = v55 + 16382;
    if (v60 >= -v58) {
      int v61 = -v58;
    }
    else {
      int v61 = v55 + 16382;
    }
    __int16 v56 = v55 - v61;
    if (v60 >= v59) {
      goto LABEL_80;
    }
    int v119 = v59 - v61;
    if (v119 > 63)
    {
LABEL_185:
      uint64_t v128 = 1;
      LOWORD(v129) = 64;
      uint64_t v120 = sub_1CBF7DF38((uint64_t)&v128, (uint64_t)&v125);
      unint64_t v67 = *(void *)v120;
      __int16 v68 = *(_WORD *)(v120 + 8);
      goto LABEL_95;
    }
    v54 >>= v119;
LABEL_199:
    if (v54) {
      goto LABEL_80;
    }
    goto LABEL_185;
  }
  int v102 = 0x3FFF - v55;
  if (v102 >= v58) {
    int v103 = v58;
  }
  else {
    int v103 = 0x3FFF - v55;
  }
  __int16 v56 = v103 + v55;
  if (v102 < v58)
  {
    unint64_t v104 = v54;
    if (sub_1CBF7ECD0(v54, v56, 0xFFFFFFFFFFFFFFFFLL, 0x3FFF))
    {
      if (v58 - v103 > (int)__clz(v104)) {
        goto LABEL_149;
      }
      unint64_t v54 = v104 << (v58 - v103);
LABEL_198:
      uint64_t v2 = this;
      goto LABEL_199;
    }
    unint64_t v54 = v104;
LABEL_150:
    uint64_t v2 = this;
  }
LABEL_80:
  int v62 = __clz(v54);
  unsigned int v63 = (v62 ^ 0x3F) + v56;
  if (1 << (v62 ^ 0x3Fu) != v54) {
    v63 += (v54 >> (62 - v62)) & 1;
  }
  if (v63 > 0x3D) {
    goto LABEL_185;
  }
  if (!v51) {
    goto LABEL_157;
  }
  int v64 = LOWORD(v127[1]);
  unint64_t v65 = llvm::ScaledNumbers::divide64(1uLL, v51);
  unint64_t v67 = v65;
  __int16 v68 = v66;
  if (!v64 || !v65) {
    goto LABEL_193;
  }
  int v69 = (__int16)-(__int16)v64;
  if ((v69 & 0x80000000) == 0)
  {
    int v105 = 0x3FFF - v66;
    if (v105 >= v69) {
      int v106 = (__int16)-(__int16)v64;
    }
    else {
      int v106 = 0x3FFF - v66;
    }
    __int16 v68 = v106 + v66;
    uint64_t v2 = this;
    if (v105 >= v69)
    {
LABEL_91:
      int v73 = v68;
      if (0x3FFF - v68 >= 3) {
        int v74 = 3;
      }
      else {
        int v74 = 0x3FFF - v68;
      }
      v68 += v74;
      if (v73 >= 16381)
      {
        if (sub_1CBF7ECD0(v67, v68, 0xFFFFFFFFFFFFFFFFLL, 0x3FFF))
        {
          if (3 - v74 <= __clz(v67))
          {
            v67 <<= 3 - v74;
          }
          else
          {
            unint64_t v67 = -1;
            __int16 v68 = 0x3FFF;
          }
        }
LABEL_188:
        uint64_t v2 = this;
      }
      goto LABEL_95;
    }
    if (!sub_1CBF7ECD0(v65, v68, 0xFFFFFFFFFFFFFFFFLL, 0x3FFF))
    {
LABEL_158:
      uint64_t v2 = this;
      goto LABEL_91;
    }
    if (v69 - v106 <= (int)__clz(v67))
    {
      v67 <<= v69 - v106;
      goto LABEL_193;
    }
LABEL_157:
    unint64_t v67 = -1;
    __int16 v68 = 0x3FFF;
    goto LABEL_158;
  }
  int v70 = -v69;
  int v71 = v66 + 16382;
  if (v71 >= -v69) {
    int v72 = -v69;
  }
  else {
    int v72 = v66 + 16382;
  }
  __int16 v68 = v66 - v72;
  uint64_t v2 = this;
  if (v71 >= v70) {
    goto LABEL_91;
  }
  int v121 = v70 - v72;
  if (v121 > 63)
  {
    __int16 v68 = 0;
    unint64_t v67 = 0;
    goto LABEL_188;
  }
  unint64_t v67 = v65 >> v121;
LABEL_193:
  uint64_t v2 = this;
  if (v67) {
    goto LABEL_91;
  }
LABEL_95:
  uint64_t v77 = *((void *)v2 + 1);
  uint64_t v76 = *((void *)v2 + 2);
  unint64_t v75 = (void *)((char *)v2 + 8);
  if (v76 != v77)
  {
    uint64_t v123 = (void *)((char *)v2 + 8);
    uint64_t v78 = 0;
    unint64_t v79 = 0;
    while (1)
    {
      uint64_t v80 = *(void *)(v77 + v78);
      uint64_t v81 = *(unsigned __int16 *)(v77 + v78 + 8);
      unint64_t v82 = v1 & 0xFFFFFFFFFFFF0000;
      if (v80)
      {
        if (v67)
        {
          unint64_t v83 = (v80 | v67) >> 32;
          if (v83)
          {
            unint64_t v84 = v80 * v67;
            if (v80 * v67 >= v80 * (unint64_t)v67
                            + ((HIDWORD(v80) * (unint64_t)v67) << 32))
              unint64_t v85 = (__PAIR128__(((HIDWORD(v80) * (unint64_t)v67) >> 32)+ HIDWORD(v80) * (unint64_t)HIDWORD(v67), v80 * (unint64_t)v67)+ __PAIR128__((v80 * (unint64_t)HIDWORD(v67)) >> 32, (HIDWORD(v80) * (unint64_t)v67) << 32)) >> 64;
            else {
              unint64_t v85 = ((__PAIR128__(((HIDWORD(v80) * (unint64_t)v67) >> 32)+ HIDWORD(v80) * (unint64_t)HIDWORD(v67), v80 * (unint64_t)v67)+ __PAIR128__((v80 * (unint64_t)HIDWORD(v67)) >> 32, (HIDWORD(v80) * (unint64_t)v67) << 32)) >> 64)+ 1;
            }
            if (v85)
            {
              int v86 = __clz(v85);
              LOWORD(v83) = 64 - v86;
              if (v86) {
                unint64_t v85 = (v84 >> -(char)v86) | (v85 << v86);
              }
              if ((v84 >> (v86 ^ 0x3Fu)))
              {
                BOOL v94 = __CFADD__(v85, 1);
                unint64_t v95 = v85 + 1;
                if (v94) {
                  unint64_t v84 = 0x8000000000000000;
                }
                else {
                  unint64_t v84 = v95;
                }
                if (v94) {
                  LOWORD(v83) = 65 - v86;
                }
              }
              else
              {
                unint64_t v84 = v85;
              }
            }
            else
            {
              LOWORD(v83) = 0;
            }
            unint64_t v83 = (unsigned __int16)v83;
          }
          else
          {
            unint64_t v84 = v80 * v67;
          }
          __int16 v87 = v81 + v68;
          int v88 = v87;
          if (v87) {
            BOOL v89 = v84 == 0;
          }
          else {
            BOOL v89 = 1;
          }
          if (v89)
          {
            uint64_t v1 = v83 | v82;
          }
          else if (v87 < 0)
          {
            int v90 = -v87;
            if ((int)v83 + 16382 >= -v88) {
              int v91 = -v88;
            }
            else {
              int v91 = v83 + 16382;
            }
            uint64_t v1 = (unsigned __int16)(v83 - v91) | v82;
            if ((int)v83 + 16382 < v90)
            {
              int v109 = v90 - v91;
              BOOL v110 = v109 <= 63;
              unint64_t v111 = v84 >> v109;
              unint64_t v84 = v110 ? v111 : 0;
              if (!v110) {
                uint64_t v1 = v82;
              }
            }
          }
          else
          {
            if (0x3FFF - (int)v83 >= v87) {
              int v96 = v87;
            }
            else {
              int v96 = 0x3FFF - v83;
            }
            uint64_t v1 = v82 | (unsigned __int16)(v96 + v83);
            if (0x3FFF - (int)v83 < v87)
            {
              unint64_t v122 = v84;
              if (sub_1CBF7ECD0(v84, (__int16)(v96 + v83), 0xFFFFFFFFFFFFFFFFLL, 0x3FFF))
              {
                if (v88 - v96 <= (int)__clz(v122))
                {
                  unint64_t v84 = v122 << (v88 - v96);
                }
                else
                {
                  uint64_t v1 = v82 | 0x3FFF;
                  unint64_t v84 = -1;
                }
              }
              else
              {
                unint64_t v84 = v122;
              }
            }
            uint64_t v2 = this;
          }
          goto LABEL_118;
        }
        unint64_t v84 = 0;
        uint64_t v81 = (unsigned __int16)v68;
      }
      else
      {
        unint64_t v84 = 0;
      }
      uint64_t v1 = v82 | v81;
LABEL_118:
      uint64_t v128 = v84;
      unint64_t v129 = (uint64_t *)v1;
      unint64_t v92 = sub_1CBF830A4((uint64_t)&v128);
      if (v92 <= 1) {
        uint64_t v93 = 1;
      }
      else {
        uint64_t v93 = v92;
      }
      uint64_t v77 = *((void *)v2 + 1);
      *(void *)(v77 + v78 + 16) = v93;
      ++v79;
      uint64_t v76 = *((void *)v2 + 2);
      v78 += 24;
      if (v79 >= 0xAAAAAAAAAAAAAAABLL * ((v76 - v77) >> 3))
      {
        unint64_t v75 = v123;
        goto LABEL_137;
      }
    }
  }
  uint64_t v77 = *((void *)v2 + 2);
LABEL_137:
  uint64_t v97 = *((void *)v2 + 3);
  *unint64_t v75 = 0;
  v75[1] = 0;
  v75[2] = 0;
  int v98 = &v128;
  uint64_t v128 = (uint64_t)&v128;
  unint64_t v129 = &v128;
  uint64_t v130 = 0;
  uint64_t v99 = *((void *)v2 + 6);
  if (v99)
  {
    uint64_t v113 = *((void *)v2 + 4);
    uint64_t v112 = (uint64_t *)*((void *)v2 + 5);
    uint64_t v114 = *v112;
    *(void *)(v114 + 8) = *(void *)(v113 + 8);
    **(void **)(v113 + 8) = v114;
    uint64_t v115 = v128;
    *(void *)(v128 + 8) = v112;
    uint64_t *v112 = v115;
    *(void *)(v113 + 8) = &v128;
    uint64_t v128 = v113;
    uint64_t v130 = v99;
    *((void *)v2 + 6) = 0;
    int v98 = v129;
  }
  int v131 = v98;
  llvm::BlockFrequencyInfoImplBase::clear(v2);
  unint64_t v100 = (void *)*((void *)v2 + 1);
  if (v100)
  {
    *((void *)v2 + 2) = v100;
    operator delete(v100);
  }
  *((void *)v2 + 1) = v77;
  *((void *)v2 + 2) = v76;
  *((void *)v2 + 3) = v97;
  unint64_t result = sub_1CBF831E8((uint64_t *)v2 + 4, &v128);
  *((void *)v2 + 7) = *((void *)v2 + 5);
  if (v130)
  {
    uint64_t v116 = v128;
    unint64_t result = v129;
    uint64_t v117 = *v129;
    *(void *)(v117 + 8) = *(void *)(v128 + 8);
    **(void **)(v116 + 8) = v117;
    uint64_t v130 = 0;
    if (result != &v128)
    {
      do
      {
        __int16 v118 = (uint64_t *)result[1];
        operator delete(result);
        unint64_t result = v118;
      }
      while (v118 != &v128);
    }
  }
  return result;
}

uint64_t llvm::BlockFrequencyInfoImplBase::getBlockFreq(uint64_t a1, _DWORD *a2)
{
  if (*a2 == -1) {
    return 0;
  }
  else {
    return *(void *)(*(void *)(a1 + 8) + 24 * *a2 + 16);
  }
}

void *sub_1CBF82054(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2 < 0x41)
  {
    uint64_t v3 = *(void **)a1;
    goto LABEL_3;
  }
  int v5 = 0;
  int64_t v6 = (unint64_t)(v2 + 63) >> 6;
  do
  {
    if (v6-- < 1) {
      break;
    }
    unint64_t v8 = *(void *)(*(void *)a1 + 8 * v6);
    v5 += __clz(v8);
  }
  while (!v8);
  int v9 = v2 | 0xFFFFFFC0;
  if ((v2 & 0x3F) == 0) {
    int v9 = 0;
  }
  if ((v2 - v5 - v9) <= 0x40)
  {
    uint64_t v3 = **(void ***)a1;
LABEL_3:
    if ((unint64_t)v3 <= a2) {
      return v3;
    }
  }
  return (void *)a2;
}

uint64_t llvm::BlockFrequencyInfoImplBase::setBlockFreq(uint64_t result, unsigned int *a2, uint64_t a3)
{
  *(void *)(*(void *)(result + 8) + 24 * *a2 + 16) = a3;
  return result;
}

void llvm::BlockFrequencyInfoImplBase::getLoopName(uint64_t a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  (*(void (**)(std::string *__return_ptr))(*(void *)a1 + 16))(&v7);
  if (*(_DWORD *)(a2 + 12) <= 1u) {
    int v5 = "*";
  }
  else {
    int v5 = "**";
  }
  int64_t v6 = std::string::append(&v7, v5);
  *a3 = *v6;
  v6->__r_.__value_.__r.__words[0] = 0;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
}

llvm::ScaledNumberBase *llvm::BlockFrequencyInfoImplBase::printBlockFreq(uint64_t a1, llvm::ScaledNumberBase *a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  uint64_t v7 = *(void *)(*(void *)(a1 + 8) + 16);
  __int16 v8 = 0;
  uint64_t v9 = v4;
  __int16 v10 = 0;
  uint64_t v5 = sub_1CBF7DF38((uint64_t)&v9, (uint64_t)&v7);
  return llvm::ScaledNumberBase::print(a2, *(llvm::raw_ostream **)v5, *(__int16 *)(v5 + 8), 64, 0xAu);
}

void *llvm::bfi_detail::IrreducibleGraph::indexNodes(void *this)
{
  uint64_t v1 = (_DWORD *)this[3];
  uint64_t v2 = (_DWORD *)this[4];
  if (v1 != v2)
  {
    uint64_t v3 = this + 6;
    do
    {
      this = sub_1CD45E940(v3, v1);
      this[1] = v1;
      v1 += 14;
    }
    while (v1 != v2);
  }
  return this;
}

void sub_1CBF82248(void *a1)
{
  *a1 = &unk_1F2601198;
  uint64_t v2 = a1 + 21;
  uint64_t v3 = (void *)a1[24];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  sub_1CB87DD48(a1);

  JUMPOUT(0x1D25D9CE0);
}

_DWORD *sub_1CBF82310(_DWORD *result, int a2)
{
  uint64_t v2 = result;
  if (a2)
  {
    unint64_t v3 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    LODWORD(v4) = (((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8)) + 1;
    result[4] = v4;
    unint64_t result = operator new(24 * v4, (std::align_val_t)8uLL);
    *(void *)uint64_t v2 = result;
    *((void *)v2 + 1) = 0;
    uint64_t v5 = v2[4];
    if (v5)
    {
      uint64_t v6 = 24 * v5;
      do
      {
        *unint64_t result = -1;
        result += 6;
        v6 -= 24;
      }
      while (v6);
    }
  }
  else
  {
    *(void *)unint64_t result = 0;
    *((void *)result + 1) = 0;
    result[4] = 0;
  }
  return result;
}

_DWORD *sub_1CBF823AC(uint64_t *a1, _DWORD *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CBF82418(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CBF824BC(a1, (uint64_t)a2, a2, v7);
    *uint64_t v5 = *a2;
    *(_OWORD *)(v5 + 2) = xmmword_1CFAC30C0;
  }
  return v5;
}

uint64_t sub_1CBF82418(uint64_t *a1, _DWORD *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    int v5 = v3 - 1;
    unsigned int v6 = (37 * *a2) & (v3 - 1);
    uint64_t v7 = (_DWORD *)(*a1 + 24 * v6);
    int v8 = *v7;
    if (*a2 == *v7)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v9 = 0;
      int v10 = 1;
      uint64_t result = 1;
      while (v8 != -1)
      {
        if (v9) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v8 == -2;
        }
        if (v12) {
          uint64_t v9 = v7;
        }
        unsigned int v13 = v6 + v10++;
        unsigned int v6 = v13 & v5;
        uint64_t v7 = (_DWORD *)(v4 + 24 * (v13 & v5));
        int v8 = *v7;
        if (*a2 == *v7) {
          goto LABEL_7;
        }
      }
      uint64_t result = 0;
      if (v9) {
        uint64_t v7 = v9;
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t result = 0;
  }
LABEL_7:
  *a3 = v7;
  return result;
}

_DWORD *sub_1CBF824BC(uint64_t *a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  int v4 = *((_DWORD *)a1 + 2);
  unsigned int v5 = *((_DWORD *)a1 + 4);
  if (4 * v4 + 4 >= 3 * v5)
  {
    v5 *= 2;
  }
  else if (v5 + ~v4 - *((_DWORD *)a1 + 3) > v5 >> 3)
  {
    goto LABEL_3;
  }
  int v8 = a1;
  sub_1CD4616F4((uint64_t)a1, v5);
  uint64_t v9 = 0;
  sub_1CBF82418(v8, a3, &v9);
  a1 = v8;
  a4 = v9;
LABEL_3:
  ++*((_DWORD *)a1 + 2);
  if (*a4 != -1) {
    --*((_DWORD *)a1 + 3);
  }
  return a4;
}

void sub_1CBF8256C(unint64_t a1, long long *a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          uint64_t v12 = (uint64_t)((uint64_t)a2 - v10) >> 4;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0:
              case 1:
                return;
              case 2:
                if (*((_DWORD *)a2 - 3) < *(_DWORD *)(a1 + 4))
                {
                  long long v85 = *(_OWORD *)a1;
                  *(_OWORD *)a1 = *(a2 - 1);
                  *(a2 - 1) = v85;
                }
                break;
              case 3:
                sub_1CBF82C64((long long *)a1, (long long *)(a1 + 16), a2 - 1);
                break;
              case 4:
                sub_1CBF82F3C(a1, a1 + 16, a1 + 32, (uint64_t)(a2 - 1));
                break;
              case 5:
                uint64_t v41 = (long long *)(a1 + 16);
                unint64_t v42 = (long long *)(a1 + 32);
                unint64_t v43 = (long long *)(a1 + 48);
                sub_1CBF82F3C(a1, a1 + 16, a1 + 32, a1 + 48);
                if (*((_DWORD *)a2 - 3) < *(_DWORD *)(a1 + 52))
                {
                  long long v44 = *v43;
                  *unint64_t v43 = *(a2 - 1);
                  *(a2 - 1) = v44;
                  if (*(_DWORD *)(a1 + 52) < *(_DWORD *)(a1 + 36))
                  {
                    long long v45 = *v42;
                    *unint64_t v42 = *v43;
                    *unint64_t v43 = v45;
                    if (*(_DWORD *)(a1 + 36) < *(_DWORD *)(a1 + 20))
                    {
                      long long v46 = *v41;
                      *uint64_t v41 = *v42;
                      *unint64_t v42 = v46;
                      if (*(_DWORD *)(a1 + 20) < *(_DWORD *)(a1 + 4))
                      {
                        long long v86 = *(_OWORD *)a1;
                        *(_OWORD *)a1 = *v41;
                        *uint64_t v41 = v86;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 383)
          {
            char v47 = (long long *)(a1 + 16);
            BOOL v49 = (long long *)a1 == a2 || v47 == a2;
            if (a4)
            {
              if (!v49)
              {
                uint64_t v50 = 0;
                unint64_t v51 = (_DWORD *)a1;
                do
                {
                  int v52 = v47;
                  unsigned int v53 = v51[5];
                  if (v53 < v51[1])
                  {
                    int v54 = *(_DWORD *)v52;
                    uint64_t v55 = *((void *)v51 + 3);
                    uint64_t v56 = v50;
                    while (1)
                    {
                      *(_OWORD *)(a1 + v56 + 16) = *(_OWORD *)(a1 + v56);
                      if (!v56) {
                        break;
                      }
                      unsigned int v57 = *(_DWORD *)(a1 + v56 - 12);
                      v56 -= 16;
                      if (v53 >= v57)
                      {
                        uint64_t v58 = a1 + v56 + 16;
                        goto LABEL_84;
                      }
                    }
                    uint64_t v58 = a1;
LABEL_84:
                    *(_DWORD *)uint64_t v58 = v54;
                    *(_DWORD *)(v58 + 4) = v53;
                    *(void *)(v58 + 8) = v55;
                  }
                  char v47 = v52 + 1;
                  v50 += 16;
                  unint64_t v51 = v52;
                }
                while (v52 + 1 != a2);
              }
            }
            else if (!v49)
            {
              do
              {
                uint64_t v76 = v47;
                unsigned int v77 = *(_DWORD *)(a1 + 20);
                if (v77 < *(_DWORD *)(a1 + 4))
                {
                  int v78 = *(_DWORD *)v47;
                  uint64_t v79 = *(void *)(a1 + 24);
                  uint64_t v80 = v76;
                  do
                  {
                    *uint64_t v80 = *(v80 - 1);
                    unsigned int v81 = *((_DWORD *)v80-- - 7);
                  }
                  while (v77 < v81);
                  *(_DWORD *)uint64_t v80 = v78;
                  *((_DWORD *)v80 + 1) = v77;
                  *((void *)v80 + 1) = v79;
                }
                char v47 = v76 + 1;
                a1 = (unint64_t)v76;
              }
              while (v76 + 1 != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((long long *)a1 != a2)
            {
              unint64_t v59 = (unint64_t)(v12 - 2) >> 1;
              unint64_t v60 = v59 + 1;
              int v61 = (int *)(a1 + 16 * v59);
              do
              {
                sub_1CBF82FDC(a1, v12, v61);
                v61 -= 4;
                --v60;
              }
              while (v60);
              do
              {
                uint64_t v62 = 0;
                long long v87 = *(_OWORD *)a1;
                unsigned int v63 = (_OWORD *)a1;
                do
                {
                  int v64 = &v63[v62 + 1];
                  uint64_t v65 = (2 * v62) | 1;
                  uint64_t v66 = 2 * v62 + 2;
                  if (v66 < v12)
                  {
                    unsigned int v67 = *((_DWORD *)v64 + 1);
                    unsigned int v68 = *((_DWORD *)v64 + 5);
                    v64 += v67 < v68;
                    if (v67 < v68) {
                      uint64_t v65 = v66;
                    }
                  }
                  *unsigned int v63 = *v64;
                  unsigned int v63 = v64;
                  uint64_t v62 = v65;
                }
                while (v65 <= (uint64_t)((unint64_t)(v12 - 2) >> 1));
                if (v64 == --a2)
                {
                  *int v64 = v87;
                }
                else
                {
                  *int v64 = *a2;
                  *a2 = v87;
                  uint64_t v69 = (uint64_t)v64 - a1 + 16;
                  if (v69 >= 17)
                  {
                    unint64_t v70 = (((unint64_t)v69 >> 4) - 2) >> 1;
                    unsigned int v71 = *((_DWORD *)v64 + 1);
                    if (*(_DWORD *)(a1 + 16 * v70 + 4) < v71)
                    {
                      int v72 = *(_DWORD *)v64;
                      uint64_t v73 = *((void *)v64 + 1);
                      do
                      {
                        int v74 = v64;
                        int v64 = (long long *)(a1 + 16 * v70);
                        *int v74 = *v64;
                        if (!v70) {
                          break;
                        }
                        unint64_t v70 = (v70 - 1) >> 1;
                      }
                      while (*(_DWORD *)(a1 + 16 * v70 + 4) < v71);
                      *(_DWORD *)int v64 = v72;
                      *((_DWORD *)v64 + 1) = v71;
                      *((void *)v64 + 1) = v73;
                    }
                  }
                }
              }
              while (v12-- > 2);
            }
            return;
          }
          unint64_t v13 = (unint64_t)v12 >> 1;
          unint64_t v14 = (long long *)(a1 + 16 * ((unint64_t)v12 >> 1));
          if ((unint64_t)v11 < 0x801)
          {
            sub_1CBF82C64(v14, (long long *)a1, a2 - 1);
          }
          else
          {
            sub_1CBF82C64((long long *)a1, v14, a2 - 1);
            sub_1CBF82C64((long long *)(a1 + 16), v14 - 1, a2 - 2);
            sub_1CBF82C64((long long *)(a1 + 32), (long long *)(a1 + 16 + 16 * v13), a2 - 3);
            sub_1CBF82C64(v14 - 1, v14, (long long *)(a1 + 16 + 16 * v13));
            long long v82 = *(_OWORD *)a1;
            *(_OWORD *)a1 = *v14;
            *unint64_t v14 = v82;
          }
          --a3;
          if (a4) {
            break;
          }
          unsigned int v15 = *(_DWORD *)(a1 + 4);
          if (*(_DWORD *)(a1 - 12) < v15) {
            goto LABEL_12;
          }
          if (v15 >= *((_DWORD *)a2 - 3))
          {
            unint64_t v32 = a1 + 16;
            do
            {
              unint64_t v10 = v32;
              if (v32 >= (unint64_t)a2) {
                break;
              }
              unsigned int v33 = *(_DWORD *)(v32 + 4);
              v32 += 16;
            }
            while (v15 >= v33);
          }
          else
          {
            unint64_t v30 = a1;
            do
            {
              unint64_t v10 = v30 + 16;
              unsigned int v31 = *(_DWORD *)(v30 + 20);
              v30 += 16;
            }
            while (v15 >= v31);
          }
          unint64_t v34 = a2;
          if (v10 < (unint64_t)a2)
          {
            unint64_t v35 = a2;
            do
            {
              unint64_t v34 = v35 - 1;
              unsigned int v36 = *((_DWORD *)v35-- - 3);
            }
            while (v15 < v36);
          }
          int v37 = *(_DWORD *)a1;
          uint64_t v38 = *(void *)(a1 + 8);
          while (v10 < (unint64_t)v34)
          {
            long long v84 = *(_OWORD *)v10;
            *(_OWORD *)unint64_t v10 = *v34;
            *unint64_t v34 = v84;
            do
            {
              unsigned int v39 = *(_DWORD *)(v10 + 20);
              v10 += 16;
            }
            while (v15 >= v39);
            do
              unsigned int v40 = *((_DWORD *)v34-- - 3);
            while (v15 < v40);
          }
          BOOL v4 = v10 - 16 >= a1;
          BOOL v5 = v10 - 16 == a1;
          if (v10 - 16 != a1) {
            *(_OWORD *)a1 = *(_OWORD *)(v10 - 16);
          }
          a4 = 0;
          *(_DWORD *)(v10 - 16) = v37;
          *(_DWORD *)(v10 - 12) = v15;
          *(void *)(v10 - 8) = v38;
        }
        unsigned int v15 = *(_DWORD *)(a1 + 4);
LABEL_12:
        uint64_t v16 = 0;
        int v17 = *(_DWORD *)a1;
        uint64_t v18 = *(void *)(a1 + 8);
        do
        {
          unsigned int v19 = *(_DWORD *)(a1 + v16 + 20);
          v16 += 16;
        }
        while (v19 < v15);
        unint64_t v20 = a1 + v16;
        BOOL v21 = a2;
        if (v16 == 16)
        {
          unint64_t v24 = a2;
          while (v20 < (unint64_t)v24)
          {
            uint64_t v22 = v24 - 1;
            unsigned int v25 = *((_DWORD *)v24-- - 3);
            if (v25 < v15) {
              goto LABEL_22;
            }
          }
          uint64_t v22 = v24;
        }
        else
        {
          do
          {
            uint64_t v22 = v21 - 1;
            unsigned int v23 = *((_DWORD *)v21-- - 3);
          }
          while (v23 >= v15);
        }
LABEL_22:
        unint64_t v10 = v20;
        if (v20 < (unint64_t)v22)
        {
          int v26 = v22;
          do
          {
            long long v83 = *(_OWORD *)v10;
            *(_OWORD *)unint64_t v10 = *v26;
            *int v26 = v83;
            do
            {
              unsigned int v27 = *(_DWORD *)(v10 + 20);
              v10 += 16;
            }
            while (v27 < v15);
            do
              unsigned int v28 = *((_DWORD *)v26-- - 3);
            while (v28 >= v15);
          }
          while (v10 < (unint64_t)v26);
        }
        if (v10 - 16 != a1) {
          *(_OWORD *)a1 = *(_OWORD *)(v10 - 16);
        }
        *(_DWORD *)(v10 - 16) = v17;
        *(_DWORD *)(v10 - 12) = v15;
        *(void *)(v10 - 8) = v18;
        if (v20 >= (unint64_t)v22) {
          break;
        }
LABEL_33:
        sub_1CBF8256C(a1, v10 - 16, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v29 = sub_1CBF82D08(a1, v10 - 16);
      if (sub_1CBF82D08(v10, (uint64_t)a2)) {
        break;
      }
      if (!v29) {
        goto LABEL_33;
      }
    }
    a2 = (long long *)(v10 - 16);
    if (!v29) {
      continue;
    }
    break;
  }
}

long long *sub_1CBF82C64(long long *result, long long *a2, long long *a3)
{
  unsigned int v3 = *((_DWORD *)a2 + 1);
  unsigned int v4 = *((_DWORD *)a3 + 1);
  if (v3 >= *((_DWORD *)result + 1))
  {
    if (v4 < v3)
    {
      long long v6 = *a2;
      *a2 = *a3;
      *a3 = v6;
      if (*((_DWORD *)a2 + 1) < *((_DWORD *)result + 1))
      {
        long long v7 = *result;
        *uint64_t result = *a2;
        *a2 = v7;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      long long v8 = *result;
      *uint64_t result = *a2;
      *a2 = v8;
      if (*((_DWORD *)a3 + 1) >= *((_DWORD *)a2 + 1)) {
        return result;
      }
      long long v5 = *a2;
      *a2 = *a3;
    }
    else
    {
      long long v5 = *result;
      *uint64_t result = *a3;
    }
    *a3 = v5;
  }
  return result;
}

BOOL sub_1CBF82D08(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(_DWORD *)(a2 - 12) < *(_DWORD *)(a1 + 4))
      {
        long long v6 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 16);
        *(_OWORD *)(a2 - 16) = v6;
      }
      return result;
    case 3:
      sub_1CBF82C64((long long *)a1, (long long *)(a1 + 16), (long long *)(a2 - 16));
      return 1;
    case 4:
      sub_1CBF82F3C(a1, a1 + 16, a1 + 32, a2 - 16);
      return 1;
    case 5:
      int v17 = (long long *)(a1 + 16);
      uint64_t v18 = (long long *)(a1 + 32);
      unsigned int v19 = (long long *)(a1 + 48);
      sub_1CBF82F3C(a1, a1 + 16, a1 + 32, a1 + 48);
      if (*(_DWORD *)(a2 - 12) < *(_DWORD *)(a1 + 52))
      {
        long long v20 = *v19;
        *unsigned int v19 = *(_OWORD *)(a2 - 16);
        *(_OWORD *)(a2 - 16) = v20;
        if (*(_DWORD *)(a1 + 52) < *(_DWORD *)(a1 + 36))
        {
          long long v21 = *v18;
          *uint64_t v18 = *v19;
          *unsigned int v19 = v21;
          if (*(_DWORD *)(a1 + 36) < *(_DWORD *)(a1 + 20))
          {
            long long v22 = *v17;
            *int v17 = *v18;
            *uint64_t v18 = v22;
            if (*(_DWORD *)(a1 + 20) < *(_DWORD *)(a1 + 4))
            {
              long long v23 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *v17;
              *int v17 = v23;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v7 = a1 + 32;
      sub_1CBF82C64((long long *)a1, (long long *)(a1 + 16), (long long *)(a1 + 32));
      uint64_t v8 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v9 = 0;
      int v10 = 0;
      break;
  }
  while (1)
  {
    unsigned int v11 = *(_DWORD *)(v8 + 4);
    if (v11 < *(_DWORD *)(v7 + 4))
    {
      int v12 = *(_DWORD *)v8;
      uint64_t v13 = *(void *)(v8 + 8);
      uint64_t v14 = v9;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + ++*(_DWORD *)(result + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32) {
          break;
        }
        unsigned int v15 = *(_DWORD *)(a1 + v14 + 20);
        v14 -= 16;
        if (v11 >= v15)
        {
          uint64_t v16 = a1 + v14 + 48;
          goto LABEL_13;
        }
      }
      uint64_t v16 = a1;
LABEL_13:
      *(_DWORD *)uint64_t v16 = v12;
      *(_DWORD *)(v16 + 4) = v11;
      *(void *)(v16 + 8) = v13;
      if (++v10 == 8) {
        return v8 + 16 == a2;
      }
    }
    uint64_t v7 = v8;
    v9 += 16;
    v8 += 16;
    if (v8 == a2) {
      return 1;
    }
  }
}

__n128 sub_1CBF82F3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1CBF82C64((long long *)a1, (long long *)a2, (long long *)a3);
  if (*(_DWORD *)(a4 + 4) < *(_DWORD *)(a3 + 4))
  {
    __n128 result = *(__n128 *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(__n128 *)a4 = result;
    if (*(_DWORD *)(a3 + 4) < *(_DWORD *)(a2 + 4))
    {
      __n128 result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      if (*(_DWORD *)(a2 + 4) < *(_DWORD *)(a1 + 4))
      {
        __n128 result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

uint64_t sub_1CBF82FDC(uint64_t result, uint64_t a2, int *a3)
{
  if (a2 >= 2)
  {
    uint64_t v3 = (uint64_t)a3 - result;
    int64_t v4 = (unint64_t)(a2 - 2) >> 1;
    if (v4 >= ((uint64_t)a3 - result) >> 4)
    {
      uint64_t v5 = v3 >> 3;
      uint64_t v6 = (v3 >> 3) + 1;
      uint64_t v7 = (int *)(result + 16 * v6);
      uint64_t v8 = v5 + 2;
      if (v8 < a2)
      {
        unsigned int v9 = v7[1];
        unsigned int v10 = v7[5];
        v7 += 4 * (v9 < v10);
        if (v9 < v10) {
          uint64_t v6 = v8;
        }
      }
      unsigned int v11 = a3[1];
      if (v7[1] >= v11)
      {
        int v12 = *a3;
        uint64_t v13 = *((void *)a3 + 1);
        do
        {
          uint64_t v14 = a3;
          a3 = v7;
          *uint64_t v14 = *(_OWORD *)v7;
          if (v4 < v6) {
            break;
          }
          uint64_t v15 = (2 * v6) | 1;
          uint64_t v7 = (int *)(result + 16 * v15);
          uint64_t v16 = 2 * v6 + 2;
          if (v16 < a2)
          {
            unsigned int v17 = v7[1];
            unsigned int v18 = v7[5];
            v7 += 4 * (v17 < v18);
            if (v17 < v18) {
              uint64_t v15 = v16;
            }
          }
          uint64_t v6 = v15;
        }
        while (v7[1] >= v11);
        *a3 = v12;
        a3[1] = v11;
        *((void *)a3 + 1) = v13;
      }
    }
  }
  return result;
}

uint64_t sub_1CBF830A4(uint64_t a1)
{
  unint64_t v1 = *(void *)a1;
  if (!*(void *)a1) {
    return 0;
  }
  int v2 = *(__int16 *)(a1 + 8);
  int v3 = __clz(v1);
  unint64_t v4 = (v3 ^ 0x3Fu) + v2;
  uint64_t v5 = 1 << (v3 ^ 0x3Fu);
  uint64_t v6 = 1 << (62 - v3);
  BOOL v7 = (v6 & v1) == 0;
  if ((v6 & v1) != 0) {
    uint64_t v8 = (v4 + 1);
  }
  else {
    uint64_t v8 = v4;
  }
  unint64_t v9 = 0x100000000;
  if (v7) {
    unint64_t v9 = 0xFFFFFFFF00000000;
  }
  unint64_t v10 = v9 | v8;
  if (v5 == v1) {
    unint64_t v10 = (v3 ^ 0x3Fu) + v2;
  }
  int v11 = v10 - (SHIDWORD(v10) > 0);
  if (v11)
  {
    if ((v11 & 0x80000000) == 0) {
      goto LABEL_11;
    }
    return 0;
  }
  if ((v2 & 0x80000000) == 0)
  {
    if (1uLL >> v2 < v1 || !*(_WORD *)(a1 + 8)) {
      goto LABEL_11;
    }
    return 0;
  }
  if (!(v1 >> -(char)v2)) {
    return 0;
  }
LABEL_11:
  uint64_t v12 = 1 << (62 - v3);
  BOOL v13 = (v12 & v1) == 0;
  if ((v12 & v1) != 0) {
    uint64_t v14 = (v4 + 1);
  }
  else {
    uint64_t v14 = v4;
  }
  unint64_t v15 = 0x100000000;
  if (v13) {
    unint64_t v15 = 0xFFFFFFFF00000000;
  }
  unint64_t v16 = v15 | v14;
  if (v5 != v1) {
    unint64_t v4 = v16;
  }
  int v17 = v4 - (SHIDWORD(v4) > 0);
  if (v17 != 63)
  {
    if (v17 >= 63) {
      return -1;
    }
LABEL_29:
    if (v2 >= 1) {
      return v1 << v2;
    }
    if (v2 < 0) {
      return v1 >> -(char)v2;
    }
    return v1;
  }
  if (v2 < 0) {
    return v1 >> -(char)v2;
  }
  uint64_t result = -1;
  unint64_t v19 = 0xFFFFFFFFFFFFFFFFLL >> v2;
  if (0xFFFFFFFFFFFFFFFFLL >> v2 >= v1 && (v19 > v1 || v19 << v2 != -1)) {
    goto LABEL_29;
  }
  return result;
}

uint64_t *sub_1CBF831E8(uint64_t *result, void *a2)
{
  if (result[2])
  {
    uint64_t v4 = *result;
    int v3 = (uint64_t *)result[1];
    uint64_t v5 = *v3;
    *(void *)(v5 + 8) = *(void *)(*result + 8);
    **(void **)(v4 + 8) = v5;
    result[2] = 0;
    if (v3 != result)
    {
      int v11 = a2;
      uint64_t v12 = result;
      do
      {
        uint64_t v6 = (uint64_t *)v3[1];
        operator delete(v3);
        a2 = v11;
        uint64_t result = v12;
        int v3 = v6;
      }
      while (v6 != v12);
    }
  }
  uint64_t v2 = a2[2];
  if (v2)
  {
    uint64_t v8 = *a2;
    BOOL v7 = (uint64_t *)a2[1];
    uint64_t v9 = *v7;
    *(void *)(v9 + 8) = *(void *)(*a2 + 8);
    **(void **)(v8 + 8) = v9;
    uint64_t v10 = *result;
    *(void *)(v10 + 8) = v7;
    *BOOL v7 = v10;
    *uint64_t result = v8;
    *(void *)(v8 + 8) = result;
    result[2] += v2;
    a2[2] = 0;
  }
  return result;
}

uint64_t sub_1CBF832A4(uint64_t *a1, int a2)
{
  uint64_t v2 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 3);
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) > 0x492492492492492) {
    abort();
  }
  if (0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 3) > v3) {
    unint64_t v3 = 0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 3);
  }
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((a1[2] - *a1) >> 3)) >= 0x249249249249249) {
    unint64_t v5 = 0x492492492492492;
  }
  else {
    unint64_t v5 = v3;
  }
  unint64_t v19 = a1 + 2;
  if (v5 > 0x492492492492492) {
    sub_1CB833614();
  }
  uint64_t v7 = 56 * v5;
  uint64_t v8 = (char *)operator new(56 * v5);
  uint64_t v9 = &v8[56 * v2];
  std::string __p = v8;
  unint64_t v16 = v9;
  *(_DWORD *)uint64_t v9 = a2;
  *(_OWORD *)(v9 + 4) = 0u;
  *(_OWORD *)(v9 + 20) = 0u;
  *(_OWORD *)(v9 + 36) = 0u;
  *((_DWORD *)v9 + 13) = 0;
  int v17 = v9 + 56;
  unsigned int v18 = &v8[v7];
  sub_1CD461884(a1, &__p);
  uint64_t v10 = a1[1];
  uint64_t v12 = v16;
  int v11 = v17;
  if (v17 != v16)
  {
    do
    {
      BOOL v13 = v11 - 56;
      sub_1CB904DFC((void **)v11 - 6);
      int v11 = v13;
    }
    while (v13 != v12);
  }
  if (__p) {
    operator delete(__p);
  }
  return v10;
}

_OWORD *sub_1CBF833E4(void **a1, _OWORD *a2)
{
  unint64_t v3 = (char *)*a1;
  uint64_t v2 = (char *)a1[1];
  uint64_t v4 = (v2 - (unsigned char *)*a1) >> 5;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 59) {
    abort();
  }
  uint64_t v8 = (unsigned char *)a1[2] - v3;
  if (v8 >> 4 > v5) {
    unint64_t v5 = v8 >> 4;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v9 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  if (v9)
  {
    if (v9 >> 59) {
      sub_1CB833614();
    }
    uint64_t v10 = (char *)operator new(32 * v9);
  }
  else
  {
    uint64_t v10 = 0;
  }
  int v11 = &v10[32 * v4];
  long long v12 = a2[1];
  *(_OWORD *)int v11 = *a2;
  *((_OWORD *)v11 + 1) = v12;
  BOOL v13 = v11 + 32;
  if (v2 != v3)
  {
    do
    {
      long long v14 = *((_OWORD *)v2 - 2);
      *(_OWORD *)(v11 - 20) = *(_OWORD *)(v2 - 20);
      *((_OWORD *)v11 - 2) = v14;
      v11 -= 32;
      v2 -= 32;
    }
    while (v2 != v3);
    uint64_t v2 = (char *)*a1;
  }
  *a1 = v11;
  a1[1] = v13;
  a1[2] = &v10[32 * v9];
  if (v2) {
    operator delete(v2);
  }
  return v13;
}

uint64_t sub_1CBF834D4()
{
  LOBYTE(v3) = 0;
  unint64_t v5 = (char *)&v3;
  LODWORD(v4) = 1;
  v2.n128_u64[0] = (unint64_t)"Check if block frequency is queried for an unknown block for debugging missed BFI updates";
  v2.n128_u64[1] = 89;
  sub_1CBA9E5B0((llvm::cl::Option *)&llvm::CheckBFIUnknownBlockQueries, "check-bfi-unknown-block-queries", &v5, &v4, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &llvm::CheckBFIUnknownBlockQueries, &dword_1CB82C000);
  char v1 = 0;
  unint64_t v5 = &v1;
  int v3 = 1;
  LODWORD(v4) = 1;
  v2.n128_u64[0] = (unint64_t)"Apply an iterative post-processing to infer correct BFI counts";
  v2.n128_u64[1] = 62;
  sub_1CD462280((llvm::cl::Option *)&llvm::UseIterativeBFIInference, "use-iterative-bfi-inference", &v5, &v4, &v3, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &llvm::UseIterativeBFIInference, &dword_1CB82C000);
  int v3 = 1;
  LODWORD(v4) = 1000;
  unint64_t v5 = (char *)&v4;
  v2.n128_u64[0] = (unint64_t)"Iterative inference: maximum number of update iterations per block";
  v2.n128_u64[1] = 66;
  sub_1CBF7A9F8((uint64_t)&llvm::IterativeBFIMaxIterationsPerBlock, "iterative-bfi-max-iterations-per-block", (int **)&v5, &v3, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &llvm::IterativeBFIMaxIterationsPerBlock, &dword_1CB82C000);
  uint64_t v4 = 0x3D719799812DEA11;
  unint64_t v5 = (char *)&v4;
  int v3 = 1;
  v2.n128_u64[0] = (unint64_t)"Iterative inference: delta convergence precision; smaller values typically lead to "
                                     "better results at the cost of worsen runtime";
  v2.n128_u64[1] = 127;
  sub_1CD462414((uint64_t **)&v5, &v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CBF801A0, &llvm::IterativeBFIPrecision, &dword_1CB82C000);
}

void sub_1CBF83688(uint64_t a1)
{
}

uint64_t sub_1CBF83748(uint64_t a1)
{
  return a1;
}

llvm::BranchProbabilityInfo::SccInfo *llvm::BranchProbabilityInfo::SccInfo::SccInfo(llvm::BranchProbabilityInfo::SccInfo *this, const llvm::Function *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 3) = 0;
  uint64_t v3 = *((void *)a2 + 10);
  if (v3) {
    uint64_t v4 = v3 - 24;
  }
  else {
    uint64_t v4 = 0;
  }
  LODWORD(v28) = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  int v31 = 0;
  *(_OWORD *)unint64_t v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  *(_OWORD *)std::string __p = 0u;
  uint64_t v36 = 0;
  sub_1CBF8B370((int *)&v28, v4);
  sub_1CBF8B648(&v28);
  unint64_t v5 = (const llvm::BasicBlock **)*((void *)&v33 + 1);
  uint64_t v6 = (const llvm::BasicBlock **)v34;
  if (*((void *)&v33 + 1) != (void)v34)
  {
    int v7 = 0;
    while (v6 == v5 || (char *)v6 - (char *)v5 == 8)
    {
LABEL_8:
      sub_1CBF8B648(&v28);
      ++v7;
      unint64_t v5 = (const llvm::BasicBlock **)*((void *)&v33 + 1);
      uint64_t v6 = (const llvm::BasicBlock **)v34;
      if (*((void *)&v33 + 1) == (void)v34) {
        goto LABEL_46;
      }
    }
    while (1)
    {
      unint64_t v16 = *v5;
      unsigned int v17 = *((_DWORD *)this + 4);
      if (!v17)
      {
        uint64_t v8 = 0;
        goto LABEL_37;
      }
      unsigned int v18 = v17 - 1;
      unsigned int v19 = ((v16 >> 4) ^ (v16 >> 9)) & (v17 - 1);
      uint64_t v8 = *(void *)this + 16 * v19;
      long long v20 = *(const llvm::BasicBlock **)v8;
      if (v16 != *(const llvm::BasicBlock **)v8) {
        break;
      }
LABEL_44:
      *(_DWORD *)(v8 + 8) = v7;
      llvm::BranchProbabilityInfo::SccInfo::calculateSccBlockType(this, v16, v7);
      if (++v5 == v6) {
        goto LABEL_8;
      }
    }
    uint64_t v21 = 0;
    int v22 = 1;
    while (v20 != (const llvm::BasicBlock *)-4096)
    {
      if (v21) {
        BOOL v23 = 0;
      }
      else {
        BOOL v23 = v20 == (const llvm::BasicBlock *)-8192;
      }
      if (v23) {
        uint64_t v21 = v8;
      }
      unsigned int v24 = v19 + v22++;
      unsigned int v19 = v24 & v18;
      uint64_t v8 = *(void *)this + 16 * (v24 & v18);
      long long v20 = *(const llvm::BasicBlock **)v8;
      if (v16 == *(const llvm::BasicBlock **)v8) {
        goto LABEL_44;
      }
    }
    if (v21) {
      uint64_t v8 = v21;
    }
LABEL_37:
    int v25 = *((_DWORD *)this + 2);
    if (4 * v25 + 4 >= 3 * v17)
    {
      sub_1CBF8BE34((uint64_t *)this, 2 * v17);
      int v9 = *((_DWORD *)this + 4) - 1;
      unsigned int v10 = v9 & ((v16 >> 4) ^ (v16 >> 9));
      uint64_t v8 = *(void *)this + 16 * v10;
      int v11 = *(const llvm::BasicBlock **)v8;
      if (v16 == *(const llvm::BasicBlock **)v8)
      {
LABEL_53:
        int v26 = v16;
        goto LABEL_41;
      }
      uint64_t v12 = 0;
      int v13 = 1;
      while (v11 != (const llvm::BasicBlock *)-4096)
      {
        if (v12) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v11 == (const llvm::BasicBlock *)-8192;
        }
        if (v14) {
          uint64_t v12 = v8;
        }
        unsigned int v15 = v10 + v13++;
        unsigned int v10 = v15 & v9;
        uint64_t v8 = *(void *)this + 16 * (v15 & v9);
        int v11 = *(const llvm::BasicBlock **)v8;
        if (v16 == *(const llvm::BasicBlock **)v8) {
          goto LABEL_53;
        }
      }
      if (v12) {
        uint64_t v8 = v12;
      }
    }
    else if (v17 + ~v25 - *((_DWORD *)this + 3) <= v17 >> 3)
    {
      sub_1CBF8BE34((uint64_t *)this, v17);
      uint64_t v37 = 0;
      sub_1CBF8BDAC(*(void *)this, *((_DWORD *)this + 4), (uint64_t)v16, &v37);
      uint64_t v8 = v37;
    }
    int v26 = *(const llvm::BasicBlock **)v8;
LABEL_41:
    ++*((_DWORD *)this + 2);
    if (v26 != (const llvm::BasicBlock *)-4096) {
      --*((_DWORD *)this + 3);
    }
    *(void *)uint64_t v8 = v16;
    *(_DWORD *)(v8 + 8) = 0;
    goto LABEL_44;
  }
LABEL_46:
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
    unint64_t v5 = (const llvm::BasicBlock **)*((void *)&v33 + 1);
  }
  if (v5)
  {
    *(void *)&long long v34 = v5;
    operator delete(v5);
  }
  if (v32[0])
  {
    v32[1] = v32[0];
    operator delete(v32[0]);
  }
  MEMORY[0x1D25D9CD0](v29, 8);
  return this;
}

void llvm::BranchProbabilityInfo::SccInfo::calculateSccBlockType(llvm::BranchProbabilityInfo::SccInfo *this, const llvm::BasicBlock *a2, int a3)
{
  uint64_t v9 = *((void *)a2 + 1);
  if (!v9)
  {
LABEL_11:
    unsigned int v14 = 0;
    goto LABEL_12;
  }
  while (1)
  {
    uint64_t v10 = *(void *)(v9 + 24);
    unsigned int v11 = *(unsigned __int8 *)(v10 + 16);
    BOOL v12 = v10 && v11 >= 0x1C;
    if (v12 && v11 - 29 < 0xB) {
      break;
    }
    uint64_t v9 = *(void *)(v9 + 8);
    if (!v9) {
      goto LABEL_11;
    }
  }
  uint64_t v52 = *(void *)this;
  uint64_t v53 = *((unsigned int *)this + 4);
  unsigned int v54 = v53 - 1;
LABEL_77:
  if (v53)
  {
    uint64_t v55 = *(void *)(v10 + 40);
    LODWORD(v56) = ((v55 >> 4) ^ (v55 >> 9)) & v54;
    unsigned int v57 = (uint64_t *)(v52 + 16 * v56);
    uint64_t v58 = *v57;
    if (v55 == *v57)
    {
LABEL_83:
      if (v57 != (uint64_t *)(*(void *)this + 16 * v53))
      {
        int v61 = *((_DWORD *)v57 + 2);
        goto LABEL_86;
      }
    }
    else
    {
      int v59 = 1;
      while (v58 != -4096)
      {
        int v60 = v56 + v59++;
        uint64_t v56 = v60 & v54;
        uint64_t v58 = *(void *)(v52 + 16 * v56);
        if (v55 == v58)
        {
          unsigned int v57 = (uint64_t *)(v52 + 16 * v56);
          goto LABEL_83;
        }
      }
    }
  }
  int v61 = -1;
LABEL_86:
  if (v61 == a3)
  {
    while (1)
    {
      uint64_t v9 = *(void *)(v9 + 8);
      if (!v9) {
        goto LABEL_11;
      }
      uint64_t v10 = *(void *)(v9 + 24);
      unsigned int v62 = *(unsigned __int8 *)(v10 + 16);
      if (v10) {
        BOOL v63 = v62 >= 0x1C;
      }
      else {
        BOOL v63 = 0;
      }
      if (v63 && v62 - 29 < 0xB) {
        goto LABEL_77;
      }
    }
  }
  unsigned int v14 = 1;
LABEL_12:
  unsigned int v15 = (const llvm::BasicBlock *)*((void *)a2 + 5);
  if (v15 == (const llvm::BasicBlock *)((char *)a2 + 40)) {
    goto LABEL_60;
  }
  if (v15) {
    unint64_t v16 = (char *)v15 - 24;
  }
  else {
    unint64_t v16 = 0;
  }
  unsigned int v17 = v16[16];
  BOOL v18 = v17 >= 0x1E;
  if (v17 == 30)
  {
    if ((*((_DWORD *)v16 + 5) & 0x7FFFFFF) == 3) {
      int v67 = 2;
    }
    else {
      int v67 = 1;
    }
LABEL_21:
    uint64_t v19 = 0;
    long long v20 = v16 - 32;
    while (1)
    {
      BOOL v18 = v17 >= 0x1E;
      if (v17 == 30)
      {
        uint64_t v30 = &v20[-32 * v19];
      }
      else
      {
        uint64_t v30 = v16 - 32;
        switch(v16[16])
        {
          case ' ':
          case '&':
            int v34 = *((_DWORD *)v16 + 5);
            if ((v34 & 0x40000000) != 0) {
              unint64_t v35 = (char *)*((void *)v16 - 1);
            }
            else {
              unint64_t v35 = &v16[-32 * (v34 & 0x7FFFFFF)];
            }
            long long v33 = &v35[32 * v19];
            goto LABEL_43;
          case '!':
            if (v19) {
              uint64_t v36 = -64;
            }
            else {
              uint64_t v36 = -96;
            }
            uint64_t v30 = &v16[v36];
            break;
          case '""':
          case '#':
            goto LABEL_125;
          case '$':
            if ((*((_WORD *)v16 + 9) & 1) == 0)
            {
              uint64_t v21 = 0;
              goto LABEL_26;
            }
            uint64_t v30 = &v16[-32 * (*((_DWORD *)v16 + 5) & 0x7FFFFFF) + 32];
            break;
          case '%':
            break;
          case '\'':
            if (v19) {
              uint64_t v30 = &v20[32 * (v19 - 1) + -32 * *((unsigned int *)v16 + 20)];
            }
            else {
              uint64_t v30 = &v16[-32 * *((unsigned int *)v16 + 20) - 64];
            }
            break;
          default:
            int v31 = *((_DWORD *)v16 + 5);
            if ((v31 & 0x40000000) != 0) {
              unint64_t v32 = (char *)*((void *)v16 - 1);
            }
            else {
              unint64_t v32 = &v16[-32 * (v31 & 0x7FFFFFF)];
            }
            long long v33 = &v32[64 * v19];
LABEL_43:
            uint64_t v30 = v33 + 32;
            break;
        }
      }
      uint64_t v21 = *(void *)v30;
LABEL_26:
      uint64_t v22 = *(void *)this;
      uint64_t v23 = *((unsigned int *)this + 4);
      if (v23)
      {
        LODWORD(v24) = ((v21 >> 4) ^ (v21 >> 9)) & (v23 - 1);
        int v25 = (uint64_t *)(v22 + 16 * v24);
        uint64_t v26 = *v25;
        if (v21 == *v25) {
          goto LABEL_33;
        }
        int v27 = 1;
        while (v26 != -4096)
        {
          int v28 = v24 + v27++;
          uint64_t v24 = v28 & (v23 - 1);
          uint64_t v26 = *(void *)(v22 + 16 * v24);
          if (v21 == v26)
          {
            int v25 = (uint64_t *)(v22 + 16 * v24);
            goto LABEL_33;
          }
        }
      }
      int v25 = (uint64_t *)(v22 + 16 * v23);
LABEL_33:
      if (v25 == (uint64_t *)(v22 + 16 * v23)) {
        int v29 = -1;
      }
      else {
        int v29 = *((_DWORD *)v25 + 2);
      }
      if (v29 != a3)
      {
        v14 |= 2u;
        goto LABEL_60;
      }
      if (++v19 == v67) {
        goto LABEL_60;
      }
    }
  }
  int v67 = 2;
  switch(v16[16])
  {
    case 30:
LABEL_125:
      __break(1u);
      goto LABEL_126;
    case 31:
      int v67 = (*((_DWORD *)v16 + 5) >> 1) & 0x3FFFFFF;
      break;
    case 32:
    case 38:
      int v67 = (*((_DWORD *)v16 + 5) & 0x7FFFFFF) - 1;
      break;
    case 33:
      goto LABEL_21;
    case 36:
      int v67 = *((_WORD *)v16 + 9) & 1;
      break;
    case 37:
      int v67 = 1;
      goto LABEL_21;
    case 39:
      int v67 = *((_DWORD *)v16 + 20) + 1;
      break;
    default:
      goto LABEL_60;
  }
  if (v67) {
    goto LABEL_21;
  }
LABEL_60:
  uint64_t v4 = (unsigned char *)*((void *)this + 3);
  uint64_t v3 = (char *)*((void *)this + 4);
  unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((v3 - v4) >> 3);
  if (v37 <= a3)
  {
    unint64_t v5 = a3 + 1;
    BOOL v18 = v5 >= v37;
    unint64_t v38 = v5 - v37;
    if (v5 <= v37)
    {
LABEL_126:
      if (!v18)
      {
        uint64_t v80 = &v4[24 * v5];
        while (v3 != v80)
        {
          uint64_t v81 = *((void *)v3 - 3);
          v3 -= 24;
          MEMORY[0x1D25D9CD0](v81, 8);
        }
        *((void *)this + 4) = v80;
      }
    }
    else
    {
      uint64_t v39 = *((void *)this + 5);
      if (0xAAAAAAAAAAAAAAABLL * ((v39 - (uint64_t)v3) >> 3) >= v38)
      {
        uint64_t v65 = &v3[24 * v38];
        uint64_t v66 = 24 * v5 - 8 * ((v3 - v4) >> 3);
        do
        {
          *(void *)uint64_t v3 = 0;
          *((void *)v3 + 1) = 0;
          *((_DWORD *)v3 + 4) = 0;
          v3 += 24;
          v66 -= 24;
        }
        while (v66);
        *((void *)this + 4) = v65;
      }
      else
      {
        if (a3 <= -2) {
          abort();
        }
        unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((v39 - (uint64_t)v4) >> 3);
        unint64_t v41 = 0x5555555555555556 * ((v39 - (uint64_t)v4) >> 3);
        if (v41 <= v5) {
          unint64_t v41 = a3 + 1;
        }
        if (v40 >= 0x555555555555555) {
          unint64_t v42 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v42 = v41;
        }
        if (v42 > 0xAAAAAAAAAAAAAAALL) {
          sub_1CB833614();
        }
        unint64_t v43 = (char *)operator new(24 * v42);
        long long v44 = &v43[8 * ((v3 - v4) >> 3)];
        long long v45 = &v43[24 * v5];
        long long v46 = v44;
        uint64_t v47 = 24 * v5 - 8 * ((v3 - v4) >> 3);
        do
        {
          *(void *)long long v46 = 0;
          *((void *)v46 + 1) = 0;
          *((_DWORD *)v46 + 4) = 0;
          v46 += 24;
          v47 -= 24;
        }
        while (v47);
        int v48 = &v43[24 * v42];
        if (v3 == v4)
        {
          *((void *)this + 3) = v44;
          *((void *)this + 4) = v45;
          *((void *)this + 5) = v48;
        }
        else
        {
          do
          {
            uint64_t v49 = *((void *)v3 - 3);
            v3 -= 24;
            *((void *)v44 - 3) = v49;
            v44 -= 24;
            *(void *)uint64_t v3 = 0;
            *((_DWORD *)v44 + 2) = *((_DWORD *)v3 + 2);
            *((_DWORD *)v3 + 2) = 0;
            *((_DWORD *)v44 + 3) = *((_DWORD *)v3 + 3);
            *((_DWORD *)v3 + 3) = 0;
            *((_DWORD *)v44 + 4) = *((_DWORD *)v3 + 4);
            *((_DWORD *)v3 + 4) = 0;
          }
          while (v3 != v4);
          uint64_t v3 = (char *)*((void *)this + 3);
          uint64_t v50 = (char *)*((void *)this + 4);
          *((void *)this + 3) = v44;
          *((void *)this + 4) = v45;
          *((void *)this + 5) = v48;
          while (v50 != v3)
          {
            uint64_t v51 = *((void *)v50 - 3);
            v50 -= 24;
            MEMORY[0x1D25D9CD0](v51, 8);
          }
        }
        if (v3) {
          operator delete(v3);
        }
      }
    }
  }
  if (v14)
  {
    uint64_t v68 = *((void *)this + 3) + 24 * a3;
    long long v82 = a2;
    uint64_t v83 = v14;
    int v69 = *(_DWORD *)(v68 + 16);
    if (v69)
    {
      int v70 = v69 - 1;
      unsigned int v71 = v70 & ((a2 >> 4) ^ (a2 >> 9));
      int v72 = (const llvm::BasicBlock **)(*(void *)v68 + 16 * v71);
      uint64_t v73 = *v72;
      if (*v72 == a2) {
        return;
      }
      int v74 = 0;
      int v75 = 1;
      while (v73 != (const llvm::BasicBlock *)-4096)
      {
        if (v74) {
          BOOL v76 = 0;
        }
        else {
          BOOL v76 = v73 == (const llvm::BasicBlock *)-8192;
        }
        if (v76) {
          int v74 = (uint64_t *)v72;
        }
        unsigned int v77 = v71 + v75++;
        unsigned int v71 = v77 & v70;
        int v72 = (const llvm::BasicBlock **)(*(void *)v68 + 16 * v71);
        uint64_t v73 = *v72;
        if (*v72 == a2) {
          return;
        }
      }
      if (v74) {
        int v78 = v74;
      }
      else {
        int v78 = (uint64_t *)v72;
      }
    }
    else
    {
      int v78 = 0;
    }
    uint64_t v79 = sub_1CBF8BBE8(v68, (uint64_t)&v82, (uint64_t *)&v82, v78);
    *uint64_t v79 = (uint64_t)v82;
    *((_DWORD *)v79 + 2) = v83;
  }
}

uint64_t llvm::BranchProbabilityInfo::SccInfo::getSCCNum(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 4);
  if (v3)
  {
    LODWORD(v4) = (v3 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    unint64_t v5 = (uint64_t *)(v2 + 16 * v4);
    uint64_t v6 = *v5;
    if (*v5 == a2) {
      goto LABEL_8;
    }
    int v7 = 1;
    while (v6 != -4096)
    {
      int v8 = v4 + v7++;
      uint64_t v4 = v8 & (v3 - 1);
      uint64_t v6 = *(void *)(v2 + 16 * v4);
      if (v6 == a2)
      {
        unint64_t v5 = (uint64_t *)(v2 + 16 * v4);
        goto LABEL_8;
      }
    }
  }
  unint64_t v5 = (uint64_t *)(v2 + 16 * v3);
LABEL_8:
  if (v5 == (uint64_t *)(v2 + 16 * v3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *((unsigned int *)v5 + 2);
  }
}

uint64_t llvm::BranchProbabilityInfo::SccInfo::getSccEnterBlocks(uint64_t this, int a2, uint64_t a3)
{
  unint64_t v5 = (unsigned int *)this;
  uint64_t v6 = *(void *)(this + 24) + 24 * a2;
  int v7 = *(_DWORD *)(v6 + 8);
  int v8 = *(const llvm::BasicBlock ***)v6;
  uint64_t v9 = *(unsigned int *)(v6 + 16);
  uint64_t v10 = &v8[2 * v9];
  if (v7)
  {
    if (v9)
    {
      uint64_t v11 = 16 * v9;
      BOOL v12 = v8;
      while (((unint64_t)*v12 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v12 += 2;
        v11 -= 16;
        if (!v11) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      BOOL v12 = v8;
    }
  }
  else
  {
LABEL_6:
    BOOL v12 = &v8[2 * v9];
  }
  int v13 = &v8[2 * v9];
  if (v12 != v13)
  {
    while (1)
    {
      unsigned int v14 = *v12;
      this = llvm::BranchProbabilityInfo::SccInfo::getSccBlockType((llvm::BranchProbabilityInfo::SccInfo *)v5, *v12, a2);
      if (this)
      {
        uint64_t v15 = *((void *)v14 + 1);
        if (v15) {
          break;
        }
      }
LABEL_20:
      long long v20 = v12 + 2;
      BOOL v12 = v10;
      if (v20 != v10)
      {
        BOOL v12 = v20;
        while (((unint64_t)*v12 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v12 += 2;
          if (v12 == v10)
          {
            BOOL v12 = v10;
            break;
          }
        }
      }
      if (v12 == v13) {
        return this;
      }
    }
    while (1)
    {
      uint64_t v16 = *(void *)(v15 + 24);
      unsigned int v17 = *(unsigned __int8 *)(v16 + 16);
      BOOL v18 = v16 && v17 >= 0x1C;
      if (v18 && v17 - 29 < 0xB) {
        break;
      }
      uint64_t v15 = *(void *)(v15 + 8);
      if (!v15) {
        goto LABEL_20;
      }
    }
LABEL_27:
    uint64_t v21 = *(void *)v5;
    uint64_t v22 = v5[4];
    if (v22)
    {
      uint64_t v23 = *(void *)(v16 + 40);
      LODWORD(v24) = ((v23 >> 4) ^ (v23 >> 9)) & (v22 - 1);
      int v25 = (uint64_t *)(v21 + 16 * v24);
      uint64_t v26 = *v25;
      if (v23 == *v25)
      {
LABEL_34:
        if (v25 == (uint64_t *)(v21 + 16 * v22)) {
          int v29 = -1;
        }
        else {
          int v29 = *((_DWORD *)v25 + 2);
        }
        if (v29 != a2)
        {
          unint64_t v30 = *(unsigned int *)(a3 + 8);
          if (v30 >= *(unsigned int *)(a3 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)a3 + 8 * v30) = v14;
          ++*(_DWORD *)(a3 + 8);
        }
        while (1)
        {
          uint64_t v15 = *(void *)(v15 + 8);
          if (!v15) {
            goto LABEL_20;
          }
          uint64_t v16 = *(void *)(v15 + 24);
          unsigned int v31 = *(unsigned __int8 *)(v16 + 16);
          if (v16) {
            BOOL v32 = v31 >= 0x1C;
          }
          else {
            BOOL v32 = 0;
          }
          if (v32 && v31 - 29 < 0xB) {
            goto LABEL_27;
          }
        }
      }
      int v27 = 1;
      while (v26 != -4096)
      {
        int v28 = v24 + v27++;
        uint64_t v24 = v28 & (v22 - 1);
        uint64_t v26 = *(void *)(v21 + 16 * v24);
        if (v23 == v26)
        {
          int v25 = (uint64_t *)(v21 + 16 * v24);
          goto LABEL_34;
        }
      }
    }
    int v25 = (uint64_t *)(v21 + 16 * v22);
    goto LABEL_34;
  }
  return this;
}

uint64_t llvm::BranchProbabilityInfo::LoopBlock::LoopBlock(uint64_t result, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  *(void *)uint64_t result = a2;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = -1;
  int v4 = *((_DWORD *)a3 + 4);
  unsigned int v5 = a2 >> 4;
  if (v4)
  {
    uint64_t v6 = *a3;
    unsigned int v7 = v4 - 1;
    uint64_t v8 = (v4 - 1) & (v5 ^ (a2 >> 9));
    uint64_t v9 = *(void *)(*a3 + 16 * v8);
    if (v9 == a2)
    {
LABEL_6:
      uint64_t v12 = *(void *)(v6 + 16 * v8 + 8);
      *(void *)(result + 8) = v12;
      if (v12) {
        return result;
      }
    }
    else
    {
      int v10 = 1;
      while (v9 != -4096)
      {
        int v11 = v8 + v10++;
        uint64_t v8 = v11 & v7;
        uint64_t v9 = *(void *)(v6 + 16 * v8);
        if (v9 == a2) {
          goto LABEL_6;
        }
      }
    }
  }
  uint64_t v13 = *((unsigned int *)a4 + 4);
  if (v13)
  {
    uint64_t v14 = *a4;
    LODWORD(v15) = (v13 - 1) & (v5 ^ (a2 >> 9));
    uint64_t v16 = *a4 + 16 * v15;
    uint64_t v17 = *(void *)v16;
    if (*(void *)v16 == a2)
    {
LABEL_13:
      if (v16 != v14 + 16 * v13)
      {
        int v20 = *(_DWORD *)(v16 + 8);
        goto LABEL_15;
      }
    }
    else
    {
      int v18 = 1;
      while (v17 != -4096)
      {
        int v19 = v15 + v18++;
        uint64_t v15 = v19 & (v13 - 1);
        uint64_t v17 = *(void *)(v14 + 16 * v15);
        if (v17 == a2)
        {
          uint64_t v16 = v14 + 16 * v15;
          goto LABEL_13;
        }
      }
    }
  }
  int v20 = -1;
LABEL_15:
  *(_DWORD *)(result + 16) = v20;
  return result;
}

{
  int v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;

  *(void *)uint64_t result = a2;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = -1;
  int v4 = *((_DWORD *)a3 + 4);
  unsigned int v5 = a2 >> 4;
  if (v4)
  {
    uint64_t v6 = *a3;
    unsigned int v7 = v4 - 1;
    uint64_t v8 = (v4 - 1) & (v5 ^ (a2 >> 9));
    uint64_t v9 = *(void *)(*a3 + 16 * v8);
    if (v9 == a2)
    {
LABEL_6:
      uint64_t v12 = *(void *)(v6 + 16 * v8 + 8);
      *(void *)(result + 8) = v12;
      if (v12) {
        return result;
      }
    }
    else
    {
      int v10 = 1;
      while (v9 != -4096)
      {
        int v11 = v8 + v10++;
        uint64_t v8 = v11 & v7;
        uint64_t v9 = *(void *)(v6 + 16 * v8);
        if (v9 == a2) {
          goto LABEL_6;
        }
      }
    }
  }
  uint64_t v13 = *((unsigned int *)a4 + 4);
  if (v13)
  {
    uint64_t v14 = *a4;
    LODWORD(v15) = (v13 - 1) & (v5 ^ (a2 >> 9));
    uint64_t v16 = *a4 + 16 * v15;
    uint64_t v17 = *(void *)v16;
    if (*(void *)v16 == a2)
    {
LABEL_13:
      if (v16 != v14 + 16 * v13)
      {
        int v20 = *(_DWORD *)(v16 + 8);
        goto LABEL_15;
      }
    }
    else
    {
      int v18 = 1;
      while (v17 != -4096)
      {
        int v19 = v15 + v18++;
        uint64_t v15 = v19 & (v13 - 1);
        uint64_t v17 = *(void *)(v14 + 16 * v15);
        if (v17 == a2)
        {
          uint64_t v16 = v14 + 16 * v15;
          goto LABEL_13;
        }
      }
    }
  }
  int v20 = -1;
LABEL_15:
  *(_DWORD *)(result + 16) = v20;
  return result;
}

BOOL llvm::BranchProbabilityInfo::isLoopEnteringEdge(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  int v4 = *(void **)(v3 + 8);
  if (v4)
  {
    for (uint64_t i = *(void **)(v2 + 8); i != v4; uint64_t i = (void *)*i)
    {
      if (!i) {
        return 1;
      }
    }
  }
  int v6 = *(_DWORD *)(v3 + 16);
  return v6 != -1 && *(_DWORD *)(v2 + 16) != v6;
}

BOOL llvm::BranchProbabilityInfo::isLoopExitingEdge(uint64_t a1, void *a2)
{
  uint64_t v2 = a2[1];
  uint64_t v3 = *(void **)(*a2 + 8);
  if (v3)
  {
    for (uint64_t i = *(void **)(v2 + 8); i != v3; uint64_t i = (void *)*i)
    {
      if (!i) {
        return 1;
      }
    }
  }
  int v5 = *(_DWORD *)(*a2 + 16);
  return v5 != -1 && *(_DWORD *)(v2 + 16) != v5;
}

BOOL llvm::BranchProbabilityInfo::isLoopEnteringExitingEdge(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  int v4 = *(void **)(v3 + 8);
  if (v4)
  {
    for (uint64_t i = *(void **)(v2 + 8); i != v4; uint64_t i = (void *)*i)
    {
      if (!i) {
        return 1;
      }
    }
  }
  int v5 = *(_DWORD *)(v3 + 16);
  if (v5 != -1 && *(_DWORD *)(v2 + 16) != v5) {
    return 1;
  }
  int v6 = *(void **)(v2 + 8);
  if (v6) {
    BOOL v7 = v4 == v6;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    while (v4)
    {
      int v4 = (void *)*v4;
      if (v4 == v6) {
        goto LABEL_8;
      }
    }
    return 1;
  }
LABEL_8:
  int v8 = *(_DWORD *)(v2 + 16);
  return v8 != -1 && v5 != v8;
}

uint64_t llvm::BranchProbabilityInfo::isLoopBackEdge(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  uint64_t v4 = *(void *)(v2 + 8);
  if (v4 && *(void *)(v3 + 8) == v4) {
    goto LABEL_6;
  }
  int v5 = *(_DWORD *)(v2 + 16);
  if (v5 == -1 || *(_DWORD *)(v3 + 16) != v5) {
    return 0;
  }
  if (v4)
  {
LABEL_6:
    int v6 = *(const llvm::BasicBlock **)v2;
    if (**(void **)(v4 + 32) == *(void *)v2) {
      return 1;
    }
    int v5 = *(_DWORD *)(v2 + 16);
    if (v5 == -1) {
      return 0;
    }
  }
  else
  {
    int v6 = *(const llvm::BasicBlock **)v2;
  }
  return llvm::BranchProbabilityInfo::SccInfo::getSccBlockType(*(llvm::BranchProbabilityInfo::SccInfo **)(a1 + 64), v6, v5) & 1;
}

uint64_t llvm::BranchProbabilityInfo::getLoopEnterBlocks(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (!v3) {
    return llvm::BranchProbabilityInfo::SccInfo::getSccEnterBlocks(*(void *)(a1 + 64), *(_DWORD *)(a2 + 16), a3);
  }
  for (uint64_t i = *(void *)(**(void **)(v3 + 32) + 8); i; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v5 = *(void *)(i + 24);
    unsigned int v6 = *(unsigned __int8 *)(v5 + 16);
    if (v5) {
      BOOL v7 = v6 >= 0x1C;
    }
    else {
      BOOL v7 = 0;
    }
    if (v7 && v6 - 29 < 0xB) {
      break;
    }
  }
  return sub_1CBF846A4(a3, i, 0);
}

uint64_t sub_1CBF846A4(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a2;
  if (a2 == a3)
  {
    uint64_t v4 = 0;
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v5 = a2;
    do
    {
      ++v4;
      do
      {
        uint64_t v5 = *(void *)(v5 + 8);
        if (!v5) {
          break;
        }
        uint64_t v6 = *(void *)(v5 + 24);
        unsigned int v7 = *(unsigned __int8 *)(v6 + 16);
        BOOL v8 = v6 && v7 >= 0x1C;
      }
      while (!v8 || v7 - 29 > 0xA);
    }
    while (v5 != a3);
  }
  uint64_t v10 = *(unsigned int *)(result + 8);
  if (v4 + v10 > (unint64_t)*(unsigned int *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (a2 != a3)
  {
    int v11 = (void *)(*(void *)result + 8 * v10);
    do
    {
      *int v11 = *(void *)(*(void *)(v3 + 24) + 40);
      do
      {
        uint64_t v3 = *(void *)(v3 + 8);
        if (!v3) {
          break;
        }
        uint64_t v12 = *(void *)(v3 + 24);
        unsigned int v13 = *(unsigned __int8 *)(v12 + 16);
        BOOL v14 = v12 && v13 >= 0x1C;
      }
      while (!v14 || v13 - 29 > 0xA);
      ++v11;
    }
    while (v3 != a3);
  }
  *(_DWORD *)(result + 8) = v10 + v4;
  return result;
}

uint64_t llvm::BranchProbabilityInfo::getLoopExitBlocks(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a2 + 8)) {
    llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getExitBlocks();
  }
  return llvm::BranchProbabilityInfo::SccInfo::getSccExitBlocks(*(void *)(a1 + 64), *(_DWORD *)(a2 + 16), a3);
}

uint64_t llvm::BranchProbabilityInfo::calcMetadataWeights(llvm::BranchProbabilityInfo *this, const llvm::BasicBlock *a2)
{
  v151[1] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (const llvm::BasicBlock *)*((void *)a2 + 5);
  if (v5 == (const llvm::BasicBlock *)((char *)a2 + 40) || v5 == 0)
  {
    if (v5 == (const llvm::BasicBlock *)((char *)a2 + 40))
    {
      uint64_t v9 = 0;
      goto LABEL_9;
    }
    unsigned int v7 = (char *)v5 - 24;
    if (!v5) {
      unsigned int v7 = 0;
    }
    BOOL v8 = (unsigned __int8 *)(v7 + 16);
  }
  else
  {
    unsigned int v7 = (char *)v5 - 24;
    BOOL v8 = (unsigned __int8 *)v5 - 8;
  }
  if (*v8 - 29 >= 0xB) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = v7;
  }
LABEL_9:
  if (v9[16] - 30 > 3 || (v9[23] & 0x20) == 0) {
    return 0;
  }
  uint64_t v12 = ***(void ***)v9;
  __b = v9;
  int v13 = *(_DWORD *)(v12 + 2496);
  if (v13)
  {
    uint64_t v14 = *(void *)(v12 + 2480);
    int v15 = v13 - 1;
    unsigned int v16 = v15 & ((v9 >> 4) ^ (v9 >> 9));
    uint64_t v17 = 40;
    int v18 = (char **)(v14 + 40 * v16);
    int v19 = *v18;
    if (*v18 == v9) {
      goto LABEL_15;
    }
    uint64_t v23 = 0;
    int v24 = 1;
    while (v19 != (char *)-4096)
    {
      if (v23) {
        BOOL v25 = 0;
      }
      else {
        BOOL v25 = v19 == (char *)-8192;
      }
      if (v25) {
        uint64_t v23 = v18;
      }
      unsigned int v26 = v16 + v24++;
      unsigned int v16 = v26 & v15;
      int v18 = (char **)(v14 + 40 * v16);
      int v19 = *v18;
      if (*v18 == v9) {
        goto LABEL_15;
      }
    }
    if (v23) {
      long long v86 = v23;
    }
    else {
      long long v86 = v18;
    }
  }
  else
  {
    long long v86 = 0;
  }
  int v18 = (char **)sub_1CC609054(v12 + 2480, (uint64_t)&__b, (uint64_t *)&__b, v86);
  long long v87 = (char *)__b;
  long long v18[3] = 0;
  v18[4] = 0;
  *int v18 = v87;
  v18[1] = (char *)(v18 + 3);
  void v18[2] = (char *)0x100000000;
LABEL_15:
  uint64_t v20 = *((unsigned int *)v18 + 4);
  if (!v20) {
    return 0;
  }
  uint64_t v21 = (uint64_t *)(v18[1] + 8);
  uint64_t v22 = 16 * v20;
  while (*((_DWORD *)v21 - 2) != 2)
  {
    uint64_t v10 = 0;
    v21 += 2;
    v22 -= 16;
    if (!v22) {
      return v10;
    }
  }
  uint64_t v10 = *v21;
  if (*v21)
  {
    int v27 = *(_DWORD *)(v10 + 8);
    int v28 = v9[16];
    if (v28 != 30)
    {
      int v29 = 0;
      switch(v9[16])
      {
        case 30:
LABEL_186:
          __break(1u);
          goto LABEL_187;
        case 31:
          int v29 = (*((_DWORD *)v9 + 5) >> 1) & 0x3FFFFFF;
          goto LABEL_34;
        case 32:
        case 38:
          int v29 = (*((_DWORD *)v9 + 5) & 0x7FFFFFF) - 1;
          goto LABEL_34;
        case 33:
          int v29 = 2;
          goto LABEL_34;
        case 36:
          int v29 = *((_WORD *)v9 + 9) & 1;
          goto LABEL_34;
        case 37:
          int v29 = 1;
          goto LABEL_34;
        case 39:
          int v29 = *((_DWORD *)v9 + 20) + 1;
          goto LABEL_34;
        default:
          goto LABEL_34;
      }
    }
    if ((*((_DWORD *)v9 + 5) & 0x7FFFFFF) == 3) {
      int v29 = 2;
    }
    else {
      int v29 = 1;
    }
LABEL_34:
    if (v27 != v29 + 1) {
      return 0;
    }
    int v139 = v151;
    __b = v151;
    uint64_t v150 = 0x200000000;
    unint64_t v138 = &v148;
    char v146 = &v148;
    uint64_t v147 = 0x200000000;
    unint64_t v137 = &v145;
    unint64_t v143 = &v145;
    uint64_t v144 = 0x200000000;
    if ((v28 - 29) >= 2)
    {
      switch(v28)
      {
        case ' ':
        case '&':
          unsigned int v99 = (*((_DWORD *)v9 + 5) & 0x7FFFFFF) - 1;
          goto LABEL_150;
        case '!':
        case '""':
        case '#':
        case '$':
        case '%':
          break;
        case '\'':
          unsigned int v99 = *((_DWORD *)v9 + 20) + 1;
          goto LABEL_150;
        default:
          unsigned int v99 = (*((_DWORD *)v9 + 5) >> 1) & 0x3FFFFFF;
LABEL_150:
          if (v99 >= 3) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          return result;
      }
    }
    if (v27 == 1) {
      goto LABEL_170;
    }
    unint64_t v30 = 0;
    unsigned int v31 = (a2 >> 4) ^ (a2 >> 9);
    BOOL v32 = v9 - 32;
    unsigned int v33 = 1;
    while (1)
    {
      uint64_t v34 = *(void *)(v10 - 8 * *(unsigned int *)(v10 + 8) + 8 * v33);
      if (*(unsigned char *)v34 != 1 || (uint64_t v35 = *(void *)(v34 + 128), *(unsigned char *)(v35 + 16) != 16))
      {
        uint64_t v10 = 0;
        goto LABEL_129;
      }
      uint64_t v36 = (void *)(v35 + 24);
      if (*(_DWORD *)(v35 + 32) >= 0x41u) {
        uint64_t v36 = (void *)*v36;
      }
      if (v150 >= (unint64_t)HIDWORD(v150)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)__b + v150) = *(_DWORD *)v36;
      LODWORD(v150) = v150 + 1;
      uint64_t v37 = *((unsigned int *)__b + v150 - 1);
      uint64_t v39 = (uint64_t *)*((void *)this + 7);
      unint64_t v38 = (uint64_t *)*((void *)this + 8);
      uint64_t v40 = *v39;
      uint64_t v17 = *((unsigned int *)v39 + 4);
      if (v17)
      {
        uint64_t v41 = (v17 - 1) & v31;
        unint64_t v42 = *(const llvm::BasicBlock **)(v40 + 16 * v41);
        if (v42 == a2)
        {
LABEL_48:
          long long v45 = *(void **)(v40 + 16 * v41 + 8);
          if (v45) {
            goto LABEL_57;
          }
        }
        else
        {
          int v43 = 1;
          while (v42 != (const llvm::BasicBlock *)-4096)
          {
            int v44 = v41 + v43++;
            uint64_t v41 = v44 & (v17 - 1);
            unint64_t v42 = *(const llvm::BasicBlock **)(v40 + 16 * v41);
            if (v42 == a2) {
              goto LABEL_48;
            }
          }
        }
      }
      uint64_t v46 = *((unsigned int *)v38 + 4);
      if (!v46) {
        goto LABEL_56;
      }
      uint64_t v47 = *v38;
      LODWORD(v++*(_DWORD *)(result + 48) = (v46 - 1) & v31;
      uint64_t v49 = *v38 + 16 * v48;
      uint64_t v50 = *(const llvm::BasicBlock **)v49;
      if (*(const llvm::BasicBlock **)v49 != a2) {
        break;
      }
LABEL_55:
      if (v49 == v47 + 16 * v46) {
        goto LABEL_56;
      }
      long long v45 = 0;
      int v53 = *(_DWORD *)(v49 + 8);
LABEL_58:
      uint64_t v54 = v33 - 1;
      int v55 = v9[16];
      if (v55 == 30)
      {
        uint64_t v56 = &v32[-32 * v54];
      }
      else
      {
        uint64_t v96 = (v55 - 31);
        uint64_t v56 = v32;
        switch(v96)
        {
          case 1:
          case 7:
            int v128 = *((_DWORD *)v9 + 5);
            if ((v128 & 0x40000000) != 0) {
              unint64_t v129 = (char *)*((void *)v9 - 1);
            }
            else {
              unint64_t v129 = &v9[-32 * (v128 & 0x7FFFFFF)];
            }
            uint64_t v56 = &v129[32 * v33];
            break;
          case 2:
            uint64_t v130 = -64;
            if (v33 == 1) {
              uint64_t v130 = -96;
            }
            uint64_t v56 = &v9[v130];
            break;
          case 3:
          case 4:
            goto LABEL_186;
          case 5:
            if ((*((_WORD *)v9 + 9) & 1) == 0)
            {
              uint64_t v57 = 0;
              goto LABEL_61;
            }
            uint64_t v56 = &v9[-32 * (*((_DWORD *)v9 + 5) & 0x7FFFFFF) + 32];
            break;
          case 6:
            break;
          case 8:
            uint64_t v56 = &v9[-32 * *((unsigned int *)v9 + 20) - 64];
            if (v33 != 1) {
              uint64_t v56 = &v32[32 * v33 - 64 + -32 * *((unsigned int *)v9 + 20)];
            }
            break;
          default:
            int v97 = *((_DWORD *)v9 + 5);
            if ((v97 & 0x40000000) != 0) {
              int v98 = (char *)*((void *)v9 - 1);
            }
            else {
              int v98 = &v9[-32 * (v97 & 0x7FFFFFF)];
            }
            uint64_t v56 = &v98[32 * ((2 * v54) | 1)];
            break;
        }
      }
      uint64_t v57 = *(void *)v56;
LABEL_61:
      unint64_t v58 = v2 | 0xFFFFFFFF;
      unsigned int v59 = v57 >> 4;
      if (!v17) {
        goto LABEL_70;
      }
      unsigned int v60 = v17 - 1;
      uint64_t v17 = (v59 ^ (v57 >> 9)) & (v17 - 1);
      uint64_t v61 = *(void *)(v40 + 16 * v17);
      if (v61 != v57)
      {
        int v62 = 1;
        while (v61 != -4096)
        {
          int v63 = v17 + v62++;
          uint64_t v17 = v63 & v60;
          uint64_t v61 = *(void *)(v40 + 16 * v17);
          if (v61 == v57) {
            goto LABEL_66;
          }
        }
LABEL_70:
        uint64_t v65 = *((unsigned int *)v38 + 4);
        if (!v65)
        {
          int v64 = 0;
          goto LABEL_79;
        }
        uint64_t v66 = *v38;
        LODWORD(v67) = (v65 - 1) & (v59 ^ (v57 >> 9));
        uint64_t v68 = (uint64_t *)(v66 + 16 * v67);
        uint64_t v69 = *v68;
        if (*v68 == v57)
        {
LABEL_76:
          if (v68 == (uint64_t *)(v66 + 16 * v65)) {
            goto LABEL_77;
          }
          uint64_t v72 = *((unsigned int *)v68 + 2);
        }
        else
        {
          int v70 = 1;
          while (v69 != -4096)
          {
            int v71 = v67 + v70++;
            uint64_t v67 = v71 & (v65 - 1);
            uint64_t v69 = *(void *)(v66 + 16 * v67);
            if (v69 == v57)
            {
              uint64_t v68 = (uint64_t *)(v66 + 16 * v67);
              goto LABEL_76;
            }
          }
LABEL_77:
          uint64_t v72 = 0xFFFFFFFFLL;
        }
        int v64 = 0;
        uint64_t v17 = v2 & 0xFFFFFFFF00000000;
        unint64_t v58 = v2 & 0xFFFFFFFF00000000 | v72;
        goto LABEL_79;
      }
LABEL_66:
      int v64 = *(void **)(v40 + 16 * v17 + 8);
      if (!v64) {
        goto LABEL_70;
      }
      while (v45 != v64)
      {
        if (!v45) {
          goto LABEL_99;
        }
        long long v45 = (void *)*v45;
      }
LABEL_79:
      if (v58 != -1 && v53 != v58)
      {
LABEL_99:
        uint64_t v133 = *((unsigned int *)__b + v150 - 1);
        uint64_t v134 = v32;
        unsigned int v135 = v31;
        int v136 = v27;
        BOOL v140 = v64;
        uint64_t v141 = v58;
        uint64_t EstimatedLoopWeight = llvm::BranchProbabilityInfo::getEstimatedLoopWeight((uint64_t)this, (uint64_t)&v140);
        goto LABEL_100;
      }
      int v73 = *((_DWORD *)this + 18);
      if (v73)
      {
        int v74 = 4;
        int v75 = (char *)this + 80;
      }
      else
      {
        int v75 = (char *)*((void *)this + 10);
        int v74 = *((_DWORD *)this + 22);
        if (!v74)
        {
          uint64_t v80 = 0;
LABEL_87:
          unsigned int v77 = &v75[16 * v80];
          goto LABEL_88;
        }
      }
      int v76 = v74 - 1;
      uint64_t v17 = (v74 - 1) & (v59 ^ (v57 >> 9));
      unsigned int v77 = &v75[16 * v17];
      uint64_t v78 = *(void *)v77;
      if (*(void *)v77 != v57)
      {
        int v79 = 1;
        while (v78 != -4096)
        {
          int v100 = v17 + v79++;
          uint64_t v17 = v100 & v76;
          uint64_t v78 = *(void *)&v75[16 * v17];
          if (v78 == v57)
          {
            unsigned int v77 = &v75[16 * v17];
            goto LABEL_88;
          }
        }
        if (v73)
        {
          int v75 = (char *)this + 80;
          uint64_t v80 = 4;
        }
        else
        {
          int v75 = (char *)*((void *)this + 10);
          uint64_t v80 = *((unsigned int *)this + 22);
        }
        goto LABEL_87;
      }
LABEL_88:
      if (v73)
      {
        uint64_t v81 = (char *)this + 80;
        uint64_t v82 = 4;
      }
      else
      {
        uint64_t v81 = (char *)*((void *)this + 10);
        uint64_t v82 = *((unsigned int *)this + 22);
      }
      if (&v81[16 * v82] == v77) {
        goto LABEL_91;
      }
      uint64_t v133 = *((unsigned int *)__b + v150 - 1);
      uint64_t v134 = v32;
      unsigned int v135 = v31;
      int v136 = v27;
      uint64_t EstimatedLoopWeight = *((unsigned int *)v77 + 2) | 0x100000000;
LABEL_100:
      if ((EstimatedLoopWeight & 0xFF00000000) == 0 || EstimatedLoopWeight)
      {
        unsigned int v31 = v135;
        int v27 = v136;
        uint64_t v37 = v133;
        BOOL v32 = v134;
LABEL_91:
        uint64_t v83 = v144;
        if (v144 >= (unint64_t)HIDWORD(v144)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        long long v84 = &v143;
        goto LABEL_93;
      }
      uint64_t v83 = v147;
      if (v147 >= (unint64_t)HIDWORD(v147)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      long long v84 = &v146;
      unsigned int v31 = v135;
      int v27 = v136;
      uint64_t v37 = v133;
      BOOL v32 = v134;
LABEL_93:
      v30 += v37;
      *((_DWORD *)*v84 + v83) = v54;
      ++*((_DWORD *)v84 + 2);
      ++v33;
      unint64_t v2 = v58;
      if (v33 == v27)
      {
        if (!HIDWORD(v30)) {
          goto LABEL_110;
        }
        unsigned int NumSuccessors = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v9);
        if (NumSuccessors)
        {
          unint64_t v102 = v30 / 0xFFFFFFFF + 1;
          int v103 = __b;
          uint64_t v104 = NumSuccessors;
          unint64_t v30 = 0;
          do
          {
            uint64_t v17 = *v103 / v102;
            *v103++ = v17;
            v30 += v17;
            --v104;
          }
          while (v104);
LABEL_110:
          if (v30) {
            BOOL v88 = v144 == 0;
          }
          else {
            BOOL v88 = 1;
          }
          if (!v88)
          {
            int v89 = v9[16];
            goto LABEL_115;
          }
        }
LABEL_170:
        int v89 = v9[16];
        if (v89 == 30)
        {
          if ((*((_DWORD *)v9 + 5) & 0x7FFFFFF) == 3) {
            unsigned int v105 = 2;
          }
          else {
            unsigned int v105 = 1;
          }
          goto LABEL_174;
        }
        unsigned int v105 = 2;
        int v106 = 0;
        switch(v9[16])
        {
          case 30:
            goto LABEL_186;
          case 31:
            unsigned int v105 = (*((_DWORD *)v9 + 5) >> 1) & 0x3FFFFFF;
            break;
          case 32:
          case 38:
            unsigned int v105 = (*((_DWORD *)v9 + 5) & 0x7FFFFFF) - 1;
            break;
          case 33:
            goto LABEL_174;
          case 36:
            unsigned int v105 = *((_WORD *)v9 + 9) & 1;
            break;
          case 37:
            unsigned int v105 = 1;
            goto LABEL_174;
          case 39:
            unsigned int v105 = *((_DWORD *)v9 + 20) + 1;
            break;
          default:
            goto LABEL_179;
        }
        if (v105) {
LABEL_174:
        }
          memset_pattern16(__b, &unk_1CFAC30F0, 4 * v105);
        if (v89 == 30)
        {
          if ((*((_DWORD *)v9 + 5) & 0x7FFFFFF) == 3) {
            int v106 = 2;
          }
          else {
            int v106 = 1;
          }
        }
        else
        {
          int v106 = 0;
          switch(v89)
          {
            case ' ':
            case '&':
              int v106 = (*((_DWORD *)v9 + 5) & 0x7FFFFFF) - 1;
              break;
            case '!':
              int v106 = 2;
              break;
            case '""':
            case '#':
              break;
            case '$':
              int v106 = *((_WORD *)v9 + 9) & 1;
              break;
            case '%':
              int v106 = 1;
              break;
            case '\'':
              int v106 = *((_DWORD *)v9 + 20) + 1;
              break;
            default:
              int v106 = (*((_DWORD *)v9 + 5) >> 1) & 0x3FFFFFF;
              break;
          }
        }
LABEL_179:
        LODWORD(v30) = v106;
LABEL_115:
        uint64_t v10 = (uint64_t)&v142;
        BOOL v140 = &v142;
        uint64_t v141 = 0x200000000;
        if (v89 == 30)
        {
          if ((*((_DWORD *)v9 + 5) & 0x7FFFFFF) == 3) {
            int v90 = 2;
          }
          else {
            int v90 = 1;
          }
          goto LABEL_119;
        }
        int v90 = 2;
        switch(v89)
        {
          case 30:
            goto LABEL_186;
          case 31:
            int v90 = (*((_DWORD *)v9 + 5) >> 1) & 0x3FFFFFF;
            break;
          case 32:
          case 38:
            int v90 = (*((_DWORD *)v9 + 5) & 0x7FFFFFF) - 1;
            break;
          case 33:
            goto LABEL_119;
          case 36:
            int v90 = *((_WORD *)v9 + 9) & 1;
            break;
          case 37:
            int v90 = 1;
            goto LABEL_119;
          case 39:
            int v90 = *((_DWORD *)v9 + 20) + 1;
            break;
          default:
            goto LABEL_124;
        }
        if (v90)
        {
LABEL_119:
          unsigned int v91 = 0;
          uint64_t v92 = 0;
          unint64_t v93 = v30;
          uint64_t v94 = v30 >> 1;
          do
          {
            unint64_t v95 = *((unsigned int *)__b + v92);
            if (v93 != 0x80000000) {
              unint64_t v95 = (v94 | (v95 << 31)) / v93;
            }
            if (v91 >= HIDWORD(v141)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((_DWORD *)v140 + v91) = v95;
            unsigned int v91 = v141 + 1;
            LODWORD(v141) = v141 + 1;
            ++v92;
          }
          while (v90 != v92);
        }
LABEL_124:
        uint64_t v17 = v147;
        if (v147 && v144)
        {
LABEL_187:
          unsigned int v107 = qword_1EBCC3F98;
          char v108 = (int *)v146;
          int v109 = v140;
          uint64_t v110 = 4 * v17;
          unint64_t v111 = (unsigned int *)v146;
          do
          {
            uint64_t v112 = *v111;
            if (v107 < v109[v112]) {
              v109[v112] = v107;
            }
            ++v111;
            v110 -= 4;
          }
          while (v110);
          if (v147)
          {
            unsigned int v113 = 0;
            uint64_t v114 = 4 * v147;
            do
            {
              int v115 = *v108++;
              uint64_t v116 = v109[v115];
              unint64_t v117 = v116 + v113;
              v113 += v116;
              if (v117 > 0x80000000) {
                unsigned int v113 = 0x80000000;
              }
              v114 -= 4;
            }
            while (v114);
          }
          else
          {
            unsigned int v113 = 0;
          }
          if (v113 <= 0x80000000) {
            unsigned int v118 = 0x80000000 - v113;
          }
          else {
            unsigned int v118 = 0;
          }
          if (v144)
          {
            LODWORD(v119) = 0;
            uint64_t v120 = (int *)v143;
            uint64_t v121 = 4 * v144;
            uint64_t v122 = v121;
            uint64_t v123 = (int *)v143;
            do
            {
              int v124 = *v123++;
              uint64_t v125 = v109[v124];
              unint64_t v126 = v125 + v119;
              LODWORD(v119) = v125 + v119;
              if (v126 <= 0x80000000) {
                unint64_t v119 = v119;
              }
              else {
                unint64_t v119 = 0x80000000;
              }
              v122 -= 4;
            }
            while (v122);
            if (v119 != v118)
            {
              if (v119)
              {
                do
                {
                  int v127 = *v120++;
                  v109[v127] = ((v119 >> 1) + v109[v127] * (unint64_t)v118) / v119;
                  v121 -= 4;
                }
                while (v121);
              }
              else
              {
                unsigned int v131 = v118 / v144;
                do
                {
                  int v132 = *v120++;
                  v109[v132] = v131;
                  v121 -= 4;
                }
                while (v121);
              }
            }
          }
        }
        llvm::BranchProbabilityInfo::setEdgeProbability((uint64_t)this, a2, (uint64_t *)&v140);
        if (v140 != (void *)v10) {
          free(v140);
        }
        uint64_t v10 = 1;
LABEL_129:
        if (v143 != v137) {
          free(v143);
        }
        if (v146 != v138) {
          free(v146);
        }
        if (__b != v139) {
          free(__b);
        }
        return v10;
      }
    }
    int v51 = 1;
    while (v50 != (const llvm::BasicBlock *)-4096)
    {
      int v52 = v48 + v51++;
      uint64_t v48 = v52 & (v46 - 1);
      uint64_t v50 = *(const llvm::BasicBlock **)(v47 + 16 * v48);
      if (v50 == a2)
      {
        uint64_t v49 = v47 + 16 * v48;
        goto LABEL_55;
      }
    }
LABEL_56:
    long long v45 = 0;
LABEL_57:
    int v53 = -1;
    goto LABEL_58;
  }
  return v10;
}

uint64_t llvm::BranchProbabilityInfo::getEstimatedEdgeWeight(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  unint64_t v2 = (uint64_t *)a2[1];
  uint64_t v4 = (void *)v2[1];
  if (v4)
  {
    for (uint64_t i = *(void **)(v3 + 8); i != v4; uint64_t i = (void *)*i)
    {
      if (!i) {
        goto LABEL_27;
      }
    }
  }
  int v5 = *((_DWORD *)v2 + 4);
  if (v5 != -1 && *(_DWORD *)(v3 + 16) != v5)
  {
LABEL_27:
    uint64_t v21 = v2[2];
    v22[0] = v4;
    v22[1] = v21;
    return llvm::BranchProbabilityInfo::getEstimatedLoopWeight(a1, (uint64_t)v22);
  }
  uint64_t v6 = *v2;
  int v7 = *(_DWORD *)(a1 + 72);
  uint64_t v8 = a1 + 80;
  if (v7)
  {
    int v9 = 4;
    uint64_t v10 = a1 + 80;
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 80);
    int v9 = *(_DWORD *)(a1 + 88);
    if (!v9)
    {
      uint64_t v16 = 0;
LABEL_10:
      uint64_t v13 = v10 + 16 * v16;
      goto LABEL_11;
    }
  }
  int v11 = v9 - 1;
  LODWORD(v12) = (v9 - 1) & ((v6 >> 4) ^ (v6 >> 9));
  uint64_t v13 = v10 + 16 * v12;
  uint64_t v14 = *(void *)v13;
  if (*(void *)v13 != v6)
  {
    int v15 = 1;
    while (v14 != -4096)
    {
      int v20 = v12 + v15++;
      uint64_t v12 = v20 & v11;
      uint64_t v14 = *(void *)(v10 + 16 * v12);
      if (v14 == v6)
      {
        uint64_t v13 = v10 + 16 * v12;
        goto LABEL_11;
      }
    }
    if (v7)
    {
      uint64_t v16 = 4;
      uint64_t v10 = a1 + 80;
    }
    else
    {
      uint64_t v10 = *(void *)(a1 + 80);
      uint64_t v16 = *(unsigned int *)(a1 + 88);
    }
    goto LABEL_10;
  }
LABEL_11:
  if (v7)
  {
    uint64_t v17 = 4;
  }
  else
  {
    uint64_t v8 = *(void *)(a1 + 80);
    uint64_t v17 = *(unsigned int *)(a1 + 88);
  }
  if (v8 + 16 * v17 == v13) {
    return 0;
  }
  else {
    return *(unsigned int *)(v13 + 8) | 0x100000000;
  }
}

uint64_t llvm::BranchProbabilityInfo::setEdgeProbability(uint64_t a1, const llvm::BasicBlock *a2, uint64_t *a3)
{
  uint64_t result = llvm::BranchProbabilityInfo::eraseBlock(a1, a2);
  if (*((_DWORD *)a3 + 2))
  {
    uint64_t v38 = 2;
    uint64_t v39 = 0;
    uint64_t v40 = (int32x2_t ****)a2;
    if (a2 != (const llvm::BasicBlock *)-8192 && a2 != (const llvm::BasicBlock *)-4096 && a2) {
      llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v38);
    }
    uint64_t v37 = (const llvm::BasicBlock *)&unk_1F2601308;
    uint64_t v41 = a1;
    uint64_t result = sub_1CBF8F26C(a1, &v37, (uint64_t)v42);
    if (v40 != (int32x2_t ****)-8192 && v40 != (int32x2_t ****)-4096 && v40)
    {
      unint64_t v7 = v38 & 0xFFFFFFFFFFFFFFF8;
      *(void *)(v38 & 0xFFFFFFFFFFFFFFF8) = v39;
      if (v39)
      {
        *uint64_t v39 = *v39 & 7 | v7;
      }
      else
      {
        uint64_t v8 = v40;
        int v9 = ***v40;
        unint64_t v10 = (unint64_t)v9[303];
        if (v10 <= v7)
        {
          uint64_t v11 = v9[305].u32[0];
          if (v10 + 16 * v11 > v7)
          {
            unsigned int v12 = v11 - 1;
            LODWORD(v13) = v12 & ((v40 >> 4) ^ (v40 >> 9));
            uint64_t v14 = (int32x2_t *****)(v10 + 16 * v13);
            int v15 = *v14;
            if (v40 == *v14)
            {
LABEL_17:
              *uint64_t v14 = (int32x2_t ****)-8192;
              v9[304] = vadd_s32(v9[304], (int32x2_t)0x1FFFFFFFFLL);
              uint64_t v8 = v40;
            }
            else
            {
              int v16 = 1;
              while (v15 != (int32x2_t ****)-4096)
              {
                int v17 = v13 + v16++;
                uint64_t v13 = v17 & v12;
                int v15 = *(int32x2_t *****)(v10 + 16 * v13);
                if (v40 == v15)
                {
                  uint64_t v14 = (int32x2_t *****)(v10 + 16 * v13);
                  goto LABEL_17;
                }
              }
            }
            *((unsigned char *)v8 + 17) &= ~1u;
          }
        }
      }
    }
    if (*((_DWORD *)a3 + 2))
    {
      for (unint64_t i = 0; i < *((unsigned int *)a3 + 2); ++i)
      {
        uint64_t v19 = *a3;
        uint64_t v37 = a2;
        uint64_t v38 = i;
        int v20 = *(_DWORD *)(a1 + 40);
        if (v20)
        {
          uint64_t v21 = *(void *)(a1 + 24);
          unint64_t v22 = (((unint64_t)((a2 >> 4) ^ (a2 >> 9)) << 32) | (37 * i))
              + ~((unint64_t)(37 * i) << 32);
          unint64_t v23 = (v22 ^ (v22 >> 22)) + ~((v22 ^ (v22 >> 22)) << 13);
          unint64_t v24 = (9 * (v23 ^ (v23 >> 8))) ^ ((9 * (v23 ^ (v23 >> 8))) >> 15);
          int v25 = v20 - 1;
          unsigned int v26 = v25 & (((v24 + ~(v24 << 27)) >> 31) ^ (v24 + ~(v24 << 27)));
          uint64_t result = v21 + 24 * v26;
          uint64_t v27 = *(void *)result;
          uint64_t v28 = *(unsigned int *)(result + 8);
          if (*(const llvm::BasicBlock **)result == a2 && i == v28) {
            goto LABEL_48;
          }
          uint64_t v30 = 0;
          int v31 = 1;
          while (v27 != -4096 || v28 != -1)
          {
            if (v30) {
              BOOL v32 = 0;
            }
            else {
              BOOL v32 = v28 == -2;
            }
            if (v32 && v27 == -8192) {
              uint64_t v30 = result;
            }
            unsigned int v34 = v26 + v31++;
            unsigned int v26 = v34 & v25;
            uint64_t result = v21 + 24 * v26;
            uint64_t v27 = *(void *)result;
            uint64_t v28 = *(unsigned int *)(result + 8);
            if (*(const llvm::BasicBlock **)result == a2 && i == v28) {
              goto LABEL_48;
            }
          }
          if (v30) {
            uint64_t v36 = v30;
          }
          else {
            uint64_t v36 = result;
          }
        }
        else
        {
          uint64_t v36 = 0;
        }
        uint64_t result = sub_1CBF8FAE4(a1 + 24, (uint64_t)&v37, v36);
        *(void *)uint64_t result = v37;
        *(_DWORD *)(result + 8) = v38;
        *(_DWORD *)(result + 16) = -1;
LABEL_48:
        *(_DWORD *)(result + 16) = *(_DWORD *)(v19 + 4 * i);
      }
    }
  }
  return result;
}

uint64_t llvm::BranchProbabilityInfo::calcPointerHeuristics(llvm::BranchProbabilityInfo *this, const llvm::BasicBlock *a2)
{
  unint64_t v2 = (const llvm::BasicBlock *)*((void *)a2 + 5);
  if (v2 == (const llvm::BasicBlock *)((char *)a2 + 40)) {
    return 0;
  }
  uint64_t v3 = 0;
  uint64_t v4 = (char *)v2 - 24;
  if (!v2) {
    uint64_t v4 = 0;
  }
  unsigned int v5 = v4[16] - 40;
  if (v5 < 0xFFFFFFF5) {
    uint64_t v4 = 0;
  }
  if (v2)
  {
    if (v4[16] == 30 && v5 >= 0xFFFFFFF5)
    {
      if ((*((_DWORD *)v4 + 5) & 0x7FFFFFF) == 3)
      {
        uint64_t v3 = 0;
        uint64_t v7 = *((void *)v4 - 12);
        if (!v7 || *(unsigned char *)(v7 + 16) != 81) {
          return v3;
        }
        __int16 v8 = *(_WORD *)(v7 + 18);
        if ((v8 & 0x3E) == 0x20 && *(unsigned char *)(**(void **)(v7 - 64) + 8) == 15)
        {
          uint64_t v9 = qword_1EBCC3FC8;
          if (qword_1EBCC3FC8)
          {
            unsigned int v10 = v8 & 0x3F;
            uint64_t v11 = &qword_1EBCC3FC8;
            do
            {
              unsigned int v12 = *(_DWORD *)(v9 + 32);
              BOOL v13 = v12 >= v10;
              if (v12 >= v10) {
                uint64_t v14 = (uint64_t *)v9;
              }
              else {
                uint64_t v14 = (uint64_t *)(v9 + 8);
              }
              if (v13) {
                uint64_t v11 = (uint64_t *)v9;
              }
              uint64_t v9 = *v14;
            }
            while (*v14);
            if (v11 != &qword_1EBCC3FC8 && *((_DWORD *)v11 + 8) <= v10)
            {
              llvm::BranchProbabilityInfo::setEdgeProbability((uint64_t)this, a2, v11 + 5);
              return 1;
            }
          }
        }
      }
      return 0;
    }
  }
  return v3;
}

uint64_t llvm::BranchProbabilityInfo::getEstimatedBlockWeight(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 72);
  uint64_t v3 = a1 + 80;
  if (v2)
  {
    int v4 = 4;
    uint64_t v5 = a1 + 80;
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 80);
    int v4 = *(_DWORD *)(a1 + 88);
    if (!v4)
    {
      uint64_t v11 = 0;
      goto LABEL_8;
    }
  }
  int v6 = v4 - 1;
  LODWORD(v7) = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  __int16 v8 = (uint64_t *)(v5 + 16 * v7);
  uint64_t v9 = *v8;
  if (*v8 == a2) {
    goto LABEL_9;
  }
  int v10 = 1;
  while (v9 != -4096)
  {
    int v14 = v7 + v10++;
    uint64_t v7 = v14 & v6;
    uint64_t v9 = *(void *)(v5 + 16 * v7);
    if (v9 == a2)
    {
      __int16 v8 = (uint64_t *)(v5 + 16 * v7);
      goto LABEL_9;
    }
  }
  if (v2)
  {
    uint64_t v11 = 4;
    uint64_t v5 = a1 + 80;
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 80);
    uint64_t v11 = *(unsigned int *)(a1 + 88);
  }
LABEL_8:
  __int16 v8 = (uint64_t *)(v5 + 16 * v11);
LABEL_9:
  if (v2)
  {
    uint64_t v12 = 4;
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 80);
    uint64_t v12 = *(unsigned int *)(a1 + 88);
  }
  if ((uint64_t *)(v3 + 16 * v12) == v8) {
    return 0;
  }
  else {
    return *((unsigned int *)v8 + 2) | 0x100000000;
  }
}

uint64_t llvm::BranchProbabilityInfo::getEstimatedLoopWeight(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)(a1 + 144);
  uint64_t v4 = *(void *)a2;
  int v5 = *(_DWORD *)(a2 + 8);
  uint64_t v13 = 0;
  if (sub_1CBF8BFC0(a1 + 144, v4, v5, &v13))
  {
    uint64_t v9 = v13;
    int v6 = *v3;
  }
  else
  {
    int v6 = *(_DWORD *)(a1 + 144);
    if (v6)
    {
      uint64_t v7 = a1 + 152;
      unsigned int v8 = 4;
    }
    else
    {
      uint64_t v7 = *(void *)(a1 + 152);
      unsigned int v8 = *(_DWORD *)(a1 + 160);
    }
    uint64_t v9 = v7 + 24 * v8;
  }
  if (v6)
  {
    uint64_t v10 = a1 + 152;
    unsigned int v11 = 4;
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 152);
    unsigned int v11 = *(_DWORD *)(a1 + 160);
  }
  if (v10 + 24 * v11 == v9) {
    return 0;
  }
  else {
    return *(unsigned int *)(v9 + 16) | 0x100000000;
  }
}

uint64_t llvm::BranchProbabilityInfo::updateEstimatedBlockWeight(uint64_t a1, void *a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = a2;
  uint64_t v9 = *a2;
  unsigned int v11 = (unsigned int *)(a1 + 72);
  unsigned int v10 = *(_DWORD *)(a1 + 72);
  int v12 = v10 & 1;
  uint64_t v13 = a1 + 80;
  unsigned int v14 = *a2 >> 4;
  if (v10)
  {
    int v15 = 4;
    uint64_t v16 = a1 + 80;
  }
  else
  {
    int v15 = *(_DWORD *)(a1 + 88);
    if (!v15)
    {
      unsigned int v26 = 0;
      unsigned int v27 = 0;
      goto LABEL_21;
    }
    uint64_t v16 = *(void *)(a1 + 80);
  }
  int v17 = v15 - 1;
  unsigned int v18 = v17 & (v14 ^ (v9 >> 9));
  uint64_t v19 = (void *)(v16 + 16 * v18);
  uint64_t v20 = *v19;
  if (v9 == *v19) {
    return 0;
  }
  uint64_t v21 = 0;
  int v22 = 1;
  while (v20 != -4096)
  {
    if (v21) {
      BOOL v23 = 0;
    }
    else {
      BOOL v23 = v20 == -8192;
    }
    if (v23) {
      uint64_t v21 = v19;
    }
    unsigned int v24 = v18 + v22++;
    unsigned int v18 = v24 & v17;
    uint64_t v19 = (void *)(v16 + 16 * v18);
    uint64_t v20 = *v19;
    if (v9 == *v19) {
      return 0;
    }
  }
  if (v21) {
    unsigned int v26 = v21;
  }
  else {
    unsigned int v26 = v19;
  }
  if (v10) {
    unsigned int v27 = 4;
  }
  else {
    unsigned int v27 = *(_DWORD *)(a1 + 88);
  }
LABEL_21:
  if (4 * (v10 >> 1) + 4 < 3 * v27)
  {
    if (v27 + ~(v10 >> 1) - *(_DWORD *)(a1 + 76) > v27 >> 3) {
      goto LABEL_23;
    }
    uint64_t v94 = v7;
    uint64_t v95 = a1 + 80;
    uint64_t v96 = a5;
    sub_1CBF8C0D8(a1 + 72, v27);
    unsigned int v10 = *v11;
    if (*v11)
    {
      int v97 = 4;
      uint64_t v98 = v95;
    }
    else
    {
      int v97 = *(_DWORD *)(a1 + 88);
      if (!v97)
      {
        int v12 = 0;
        unsigned int v26 = 0;
LABEL_117:
        a5 = v96;
        uint64_t v13 = v95;
        uint64_t v7 = v94;
        goto LABEL_23;
      }
      uint64_t v98 = *(void *)(a1 + 80);
    }
    int v12 = *v11 & 1;
    int v99 = v97 - 1;
    unsigned int v100 = (v97 - 1) & (v14 ^ (v9 >> 9));
    unsigned int v26 = (void *)(v98 + 16 * v100);
    uint64_t v101 = *v26;
    if (*v26 != v9)
    {
      unint64_t v102 = 0;
      int v103 = 1;
      while (v101 != -4096)
      {
        if (v102) {
          BOOL v104 = 0;
        }
        else {
          BOOL v104 = v101 == -8192;
        }
        if (v104) {
          unint64_t v102 = v26;
        }
        unsigned int v105 = v100 + v103++;
        unsigned int v100 = v105 & v99;
        unsigned int v26 = (void *)(v98 + 16 * (v105 & v99));
        uint64_t v101 = *v26;
        if (*v26 == v9) {
          goto LABEL_117;
        }
      }
      if (v102) {
        unsigned int v26 = v102;
      }
    }
    goto LABEL_117;
  }
  uint64_t v82 = v7;
  uint64_t v83 = a1 + 80;
  uint64_t v84 = a5;
  sub_1CBF8C0D8(a1 + 72, 2 * v27);
  unsigned int v10 = *v11;
  if (*v11)
  {
    int v85 = 4;
    uint64_t v13 = v83;
    uint64_t v86 = v83;
  }
  else
  {
    int v85 = *(_DWORD *)(a1 + 88);
    uint64_t v13 = v83;
    if (!v85)
    {
      int v12 = 0;
      unsigned int v26 = 0;
      a5 = v84;
      uint64_t v7 = v82;
      goto LABEL_23;
    }
    uint64_t v86 = *(void *)(a1 + 80);
  }
  a5 = v84;
  uint64_t v7 = v82;
  int v12 = *v11 & 1;
  int v87 = v85 - 1;
  unsigned int v88 = (v85 - 1) & (v14 ^ (v9 >> 9));
  unsigned int v26 = (void *)(v86 + 16 * v88);
  uint64_t v89 = *v26;
  if (*v26 != v9)
  {
    int v90 = 0;
    int v91 = 1;
    while (v89 != -4096)
    {
      if (v90) {
        BOOL v92 = 0;
      }
      else {
        BOOL v92 = v89 == -8192;
      }
      if (v92) {
        int v90 = v26;
      }
      unsigned int v93 = v88 + v91++;
      unsigned int v88 = v93 & v87;
      unsigned int v26 = (void *)(v86 + 16 * (v93 & v87));
      uint64_t v89 = *v26;
      if (*v26 == v9) {
        goto LABEL_23;
      }
    }
    if (v90) {
      unsigned int v26 = v90;
    }
  }
LABEL_23:
  *unsigned int v11 = (v10 & 0xFFFFFFFE | v12) + 2;
  if (*v26 != -4096) {
    --*(_DWORD *)(a1 + 76);
  }
  *unsigned int v26 = v9;
  *((_DWORD *)v26 + 2) = a3;
  uint64_t v28 = *(void *)(v9 + 8);
  if (v28)
  {
    while (1)
    {
      uint64_t v29 = *(void *)(v28 + 24);
      unsigned int v30 = *(unsigned __int8 *)(v29 + 16);
      BOOL v31 = v29 && v30 >= 0x1C;
      if (v31 && v30 - 29 < 0xB) {
        break;
      }
      uint64_t v28 = *(void *)(v28 + 8);
      if (!v28) {
        return 1;
      }
    }
    unsigned int v33 = (_DWORD *)(a4 + 8);
    uint64_t v34 = a4 + 16;
    uint64_t v35 = a1 + 144;
    uint64_t v36 = (_DWORD *)(a5 + 8);
LABEL_36:
    uint64_t v37 = *(void *)(v29 + 40);
    uint64_t v39 = *(uint64_t **)(a1 + 56);
    uint64_t v38 = *(uint64_t **)(a1 + 64);
    uint64_t v107 = v37;
    uint64_t v108 = 0;
    int v109 = -1;
    int v40 = *((_DWORD *)v39 + 4);
    unsigned int v41 = v37 >> 4;
    if (v40)
    {
      uint64_t v42 = *v39;
      unsigned int v43 = v40 - 1;
      uint64_t v44 = (v40 - 1) & (v41 ^ (v37 >> 9));
      uint64_t v45 = *(void *)(v42 + 16 * v44);
      if (v45 == v37)
      {
LABEL_41:
        uint64_t v48 = *(void *)(v42 + 16 * v44 + 8);
        uint64_t v108 = v48;
        if (v48)
        {
          for (unint64_t i = (void *)v7[1]; i != (void *)v48; unint64_t i = (void *)*i)
          {
            if (!i) {
              goto LABEL_80;
            }
          }
          goto LABEL_55;
        }
LABEL_47:
        uint64_t v50 = *((unsigned int *)v38 + 4);
        if (!v50) {
          goto LABEL_54;
        }
        uint64_t v51 = *v38;
        LODWORD(v52) = (v50 - 1) & (v41 ^ (v37 >> 9));
        int v53 = (uint64_t *)(v51 + 16 * v52);
        uint64_t v54 = *v53;
        if (*v53 != v37)
        {
          int v55 = 1;
          do
          {
            if (v54 == -4096) {
              goto LABEL_54;
            }
            int v56 = v52 + v55++;
            uint64_t v52 = v56 & (v50 - 1);
            uint64_t v54 = *(void *)(v51 + 16 * v52);
          }
          while (v54 != v37);
          int v53 = (uint64_t *)(v51 + 16 * v52);
        }
        if (v53 != (uint64_t *)(v51 + 16 * v50))
        {
          int v70 = *((_DWORD *)v53 + 2);
          int v109 = v70;
          if (v70 != -1 && *((_DWORD *)v7 + 4) != v70)
          {
LABEL_80:
            int v106 = v33;
            uint64_t v72 = v13;
            uint64_t v73 = v34;
            uint64_t v74 = v35;
            int v75 = v36;
            uint64_t v76 = a5;
            unsigned int v77 = v7;
            char v78 = sub_1CBF8BFC0(v35, v48, v109, &v110);
            uint64_t v7 = v77;
            uint64_t v13 = v72;
            unsigned int v33 = v106;
            a5 = v76;
            uint64_t v36 = v75;
            uint64_t v35 = v74;
            uint64_t v34 = v73;
            if (v78) {
              goto LABEL_67;
            }
            unint64_t v79 = sub_1CD46398C(v76, (unint64_t)&v107);
            uint64_t v7 = v77;
            uint64_t v13 = v72;
            unsigned int v33 = v106;
            a5 = v76;
            uint64_t v36 = v75;
            uint64_t v35 = v74;
            uint64_t v34 = v73;
            uint64_t v80 = *(void *)v76 + 24 * *(unsigned int *)(v76 + 8);
            long long v81 = *(_OWORD *)v79;
            *(void *)(v80 + 16) = *(void *)(v79 + 16);
            *(_OWORD *)uint64_t v80 = v81;
            uint64_t v66 = v75;
            goto LABEL_66;
          }
        }
        else
        {
LABEL_54:
          int v109 = -1;
        }
LABEL_55:
        if (*(unsigned char *)v11)
        {
          int v57 = 4;
          uint64_t v58 = v13;
          goto LABEL_59;
        }
        int v57 = *(_DWORD *)(a1 + 88);
        if (v57)
        {
          uint64_t v58 = *(void *)(a1 + 80);
LABEL_59:
          unsigned int v59 = v41 ^ (v37 >> 9);
          int v60 = v57 - 1;
          unsigned int v61 = v60 & v59;
          uint64_t v62 = *(void *)(v58 + 16 * (v60 & v59));
          if (v37 == v62) {
            goto LABEL_67;
          }
          int v63 = 1;
          do
          {
            if (v62 == -4096) {
              goto LABEL_64;
            }
            unsigned int v64 = v61 + v63++;
            unsigned int v61 = v64 & v60;
            uint64_t v62 = *(void *)(v58 + 16 * v61);
          }
          while (v37 != v62);
LABEL_67:
          while (1)
          {
            uint64_t v28 = *(void *)(v28 + 8);
            if (!v28) {
              return 1;
            }
            uint64_t v29 = *(void *)(v28 + 24);
            unsigned int v67 = *(unsigned __int8 *)(v29 + 16);
            if (v29) {
              BOOL v68 = v67 >= 0x1C;
            }
            else {
              BOOL v68 = 0;
            }
            if (v68 && v67 - 29 < 0xB) {
              goto LABEL_36;
            }
          }
        }
LABEL_64:
        unint64_t v65 = *(unsigned int *)(a4 + 8);
        if (v65 >= *(unsigned int *)(a4 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a4 + 8 * v65) = v37;
        uint64_t v66 = v33;
LABEL_66:
        ++*v66;
        goto LABEL_67;
      }
      int v46 = 1;
      while (v45 != -4096)
      {
        int v47 = v44 + v46++;
        uint64_t v44 = v47 & v43;
        uint64_t v45 = *(void *)(v42 + 16 * v44);
        if (v45 == v37) {
          goto LABEL_41;
        }
      }
    }
    uint64_t v48 = 0;
    goto LABEL_47;
  }
  return 1;
}

uint64_t llvm::BranchProbabilityInfo::propagateEstimatedBlockWeight(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = result;
  uint64_t v11 = *(void *)a2;
  uint64_t v12 = *(void *)(a3 + 24);
  uint64_t v13 = *(unsigned int *)(a3 + 40);
  unsigned int v14 = *(void *)a2 >> 4;
  if (v13)
  {
    LODWORD(v15) = (v14 ^ (v11 >> 9)) & (v13 - 1);
    uint64_t v16 = (uint64_t *)(v12 + 16 * v15);
    uint64_t v17 = *v16;
    if (v11 == *v16) {
      goto LABEL_3;
    }
    int v57 = 1;
    while (v17 != -4096)
    {
      int v58 = v15 + v57++;
      uint64_t v15 = v58 & (v13 - 1);
      uint64_t v17 = *(void *)(v12 + 16 * v15);
      if (v11 == v17)
      {
        uint64_t v16 = (uint64_t *)(v12 + 16 * v15);
        goto LABEL_3;
      }
    }
  }
  uint64_t v16 = (uint64_t *)(v12 + 16 * v13);
LABEL_3:
  if (v16 == (uint64_t *)(v12 + 16 * v13)) {
    unsigned int v18 = 0;
  }
  else {
    unsigned int v18 = (uint64_t *)v16[1];
  }
  uint64_t v19 = *(void *)(a4 + 48);
  uint64_t v20 = *(unsigned int *)(a4 + 64);
  if (v20)
  {
    LODWORD(v21) = (v20 - 1) & (v14 ^ (v11 >> 9));
    int v22 = (uint64_t *)(v19 + 16 * v21);
    uint64_t v23 = *v22;
    if (v11 == *v22) {
      goto LABEL_7;
    }
    int v59 = 1;
    while (v23 != -4096)
    {
      int v60 = v21 + v59++;
      uint64_t v21 = v60 & (v20 - 1);
      uint64_t v23 = *(void *)(v19 + 16 * v21);
      if (v11 == v23)
      {
        int v22 = (uint64_t *)(v19 + 16 * v21);
        goto LABEL_7;
      }
    }
  }
  int v22 = (uint64_t *)(v19 + 16 * v20);
LABEL_7:
  if (v22 == (uint64_t *)(v19 + 16 * v20)) {
    uint64_t v24 = 0;
  }
  else {
    uint64_t v24 = v22[1];
  }
  while (v18)
  {
    uint64_t v25 = *v18;
    uint64_t v26 = *(void *)(a4 + 48);
    uint64_t v27 = *(unsigned int *)(a4 + 64);
    unsigned int v28 = *v18 >> 4;
    if (v27)
    {
      LODWORD(v29) = (v28 ^ (v25 >> 9)) & (v27 - 1);
      unsigned int v30 = (uint64_t *)(v26 + 16 * v29);
      uint64_t v31 = *v30;
      if (v25 == *v30) {
        goto LABEL_12;
      }
      int v48 = 1;
      while (v31 != -4096)
      {
        int v49 = v29 + v48++;
        uint64_t v29 = v49 & (v27 - 1);
        uint64_t v31 = *(void *)(v26 + 16 * v29);
        if (v25 == v31)
        {
          unsigned int v30 = (uint64_t *)(v26 + 16 * v29);
          goto LABEL_12;
        }
      }
    }
    unsigned int v30 = (uint64_t *)(v26 + 16 * v27);
LABEL_12:
    if (v30 != (uint64_t *)(v26 + 16 * v27))
    {
      uint64_t v32 = v30[1];
      if (v32 != v24 && v32 != 0)
      {
        if (!v24) {
          return result;
        }
        if (*(void *)(v32 + 8) != v24)
        {
          if (*(void *)(v24 + 8) == v32) {
            return result;
          }
          unsigned int v34 = *(_DWORD *)(v24 + 16);
          if (v34 >= *(_DWORD *)(v32 + 16)) {
            return result;
          }
          if (*(unsigned char *)(a4 + 88))
          {
            if (*(_DWORD *)(v32 + 72) < *(_DWORD *)(v24 + 72) || *(_DWORD *)(v32 + 76) > *(_DWORD *)(v24 + 76)) {
              return result;
            }
          }
          else
          {
            unsigned int v35 = *(_DWORD *)(a4 + 92) + 1;
            *(_DWORD *)(a4 + 92) = v35;
            if (v35 > 0x20) {
              llvm::DominatorTreeBase<llvm::BasicBlock,true>::updateDFSNumbers();
            }
            do
            {
              uint64_t v36 = v32;
              uint64_t v32 = *(void *)(v32 + 8);
            }
            while (v32 && *(_DWORD *)(v32 + 16) >= v34);
            if (v36 != v24) {
              return result;
            }
          }
        }
      }
    }
    uint64_t v38 = *(uint64_t **)(v10 + 56);
    uint64_t v37 = *(uint64_t **)(v10 + 64);
    uint64_t v67 = v25;
    BOOL v68 = 0;
    int v69 = -1;
    int v39 = *((_DWORD *)v38 + 4);
    if (!v39) {
      goto LABEL_37;
    }
    uint64_t v40 = *v38;
    unsigned int v41 = v39 - 1;
    uint64_t v42 = (v39 - 1) & (v28 ^ (v25 >> 9));
    uint64_t v43 = *(void *)(v40 + 16 * v42);
    if (v43 != v25)
    {
      int v44 = 1;
      while (v43 != -4096)
      {
        int v45 = v42 + v44++;
        uint64_t v42 = v45 & v41;
        uint64_t v43 = *(void *)(v40 + 16 * v42);
        if (v43 == v25) {
          goto LABEL_31;
        }
      }
LABEL_37:
      uint64_t v50 = *((unsigned int *)v37 + 4);
      if (v50)
      {
        uint64_t v51 = *v37;
        LODWORD(v52) = (v50 - 1) & (v28 ^ (v25 >> 9));
        int v53 = (uint64_t *)(v51 + 16 * v52);
        uint64_t v54 = *v53;
        if (*v53 != v25)
        {
          int v55 = 1;
          while (v54 != -4096)
          {
            int v56 = v52 + v55++;
            uint64_t v52 = v56 & (v50 - 1);
            uint64_t v54 = *(void *)(v51 + 16 * v52);
            if (v54 == v25)
            {
              int v53 = (uint64_t *)(v51 + 16 * v52);
              goto LABEL_63;
            }
          }
          goto LABEL_43;
        }
LABEL_63:
        if (v53 == (uint64_t *)(v51 + 16 * v50)) {
          goto LABEL_43;
        }
        int v47 = *((_DWORD *)v53 + 2);
      }
      else
      {
LABEL_43:
        int v47 = -1;
      }
      int v46 = 0;
      int v69 = v47;
      goto LABEL_45;
    }
LABEL_31:
    int v46 = *(void **)(v40 + 16 * v42 + 8);
    BOOL v68 = v46;
    if (!v46) {
      goto LABEL_37;
    }
    int v47 = -1;
LABEL_45:
    v66[0] = (uint64_t)&v67;
    v66[1] = a2;
    uint64_t result = llvm::BranchProbabilityInfo::isLoopEnteringExitingEdge(result, v66);
    if (result)
    {
      if (v46)
      {
        for (unint64_t i = *(void **)(a2 + 8); i != v46; unint64_t i = (void *)*i)
        {
          if (!i) {
            goto LABEL_73;
          }
        }
      }
      if (v47 != -1 && *(_DWORD *)(a2 + 16) != v47)
      {
LABEL_73:
        uint64_t result = sub_1CD46398C(a7, (unint64_t)&v67);
        uint64_t v62 = *(void *)a7 + 24 * *(unsigned int *)(a7 + 8);
        long long v63 = *(_OWORD *)result;
        *(void *)(v62 + 16) = *(void *)(result + 16);
        *(_OWORD *)uint64_t v62 = v63;
        ++*(_DWORD *)(a7 + 8);
      }
    }
    else
    {
      uint64_t result = llvm::BranchProbabilityInfo::updateEstimatedBlockWeight(v10, &v67, a5, a6, a7);
      if ((result & 1) == 0) {
        return result;
      }
    }
    unsigned int v18 = (uint64_t *)v18[1];
  }
  return result;
}

uint64_t llvm::BranchProbabilityInfo::getInitialEstimatedBlockWeight(llvm::BranchProbabilityInfo *this, const llvm::BasicBlock *a2)
{
  int v2 = (char *)a2 + 40;
  uint64_t v3 = (char *)*((void *)a2 + 5);
  uint64_t v4 = v3 - 24;
  if (!v3) {
    uint64_t v4 = 0;
  }
  if (v4[16] - 29 >= 0xB) {
    uint64_t v4 = 0;
  }
  if (v4[16] == 35 || llvm::BasicBlock::getTerminatingDeoptimizeCall(a2))
  {
    uint64_t v6 = 1;
    while (1)
    {
      uint64_t v7 = v3 ? (uint64_t)(v3 - 24) : 0;
      if (v3 && *(unsigned char *)(v7 + 16) == 84)
      {
        uint64_t v8 = *(void *)(v7 + 64);
        if (v8)
        {
          if (*(unsigned char *)(v8 + 16)) {
            break;
          }
        }
        if (llvm::CallBase::hasFnAttrOnCalledFunction(v7, 32)) {
          break;
        }
      }
      uint64_t v3 = *(char **)v3;
      if (v3 == v2)
      {
        uint64_t v6 = 0;
        break;
      }
    }
LABEL_18:
    uint64_t v9 = 0;
    goto LABEL_19;
  }
  uint64_t v12 = *((void *)a2 + 1);
  if (v12)
  {
    while (1)
    {
      uint64_t v13 = *(void *)(v12 + 24);
      unsigned int v14 = *(unsigned __int8 *)(v13 + 16);
      BOOL v15 = v13 && v14 >= 0x1C;
      if (v15 && v14 - 29 <= 0xA) {
        break;
      }
      uint64_t v12 = *(void *)(v12 + 8);
      if (!v12) {
        goto LABEL_31;
      }
    }
    uint64_t v6 = 1;
LABEL_43:
    uint64_t v20 = *(void *)(v13 + 40);
    if (v20)
    {
      uint64_t v21 = *(void *)(v20 + 40);
      if (v21 != v20 + 40)
      {
        uint64_t v22 = v21 - 24;
        if (!v21) {
          uint64_t v22 = 0;
        }
        unsigned int v23 = *(unsigned __int8 *)(v22 + 16) - 40;
        if (v23 < 0xFFFFFFF5) {
          uint64_t v22 = 0;
        }
        if (v21)
        {
          BOOL v24 = *(unsigned char *)(v22 + 16) == 33 && v23 >= 0xFFFFFFF5;
          if (v24 && *(const llvm::BasicBlock **)(v22 - 64) == a2) {
            goto LABEL_18;
          }
        }
      }
    }
    while (1)
    {
      uint64_t v12 = *(void *)(v12 + 8);
      if (!v12) {
        break;
      }
      uint64_t v13 = *(void *)(v12 + 24);
      unsigned int v25 = *(unsigned __int8 *)(v13 + 16);
      if (v13) {
        BOOL v26 = v25 >= 0x1C;
      }
      else {
        BOOL v26 = 0;
      }
      if (v26 && v25 - 29 < 0xB) {
        goto LABEL_43;
      }
    }
  }
LABEL_31:
  uint64_t v17 = *((void *)a2 + 6);
  if ((char *)v17 == v2)
  {
LABEL_42:
    uint64_t v10 = 0;
    uint64_t v6 = 0;
    uint64_t v9 = 0;
    return v6 | v10 | v9;
  }
  uint64_t v9 = 65280;
  uint64_t v6 = 255;
  while (1)
  {
    uint64_t v18 = v17 ? v17 - 24 : 0;
    if (v17 && *(unsigned char *)(v18 + 16) == 84)
    {
      uint64_t v19 = *(void *)(v18 + 64);
      if (v19)
      {
        if ((*(unsigned char *)(v19 + 12) & 0x20) != 0) {
          break;
        }
      }
      if (llvm::CallBase::hasFnAttrOnCalledFunction(v18, 5)) {
        break;
      }
    }
    uint64_t v17 = *(void *)(v17 + 8);
    if ((char *)v17 == v2) {
      goto LABEL_42;
    }
  }
LABEL_19:
  uint64_t v10 = 0x100000000;
  return v6 | v10 | v9;
}

void llvm::BranchProbabilityInfo::computeEestimateBlockWeight(llvm::BranchProbabilityInfo *this, const llvm::Function *a2, llvm::DominatorTree *a3, llvm::PostDominatorTree *a4)
{
  v143[8] = *MEMORY[0x1E4F143B8];
  uint64_t v141 = v143;
  uint64_t v142 = 0x800000000;
  unint64_t v138 = v140;
  uint64_t v139 = 0x800000000;
  uint64_t v134 = 0;
  unsigned int v135 = a2;
  std::string __p = 0;
  uint64_t v133 = 0;
  sub_1CBF8C36C((char **)&__p, (uint64_t)&v135);
  uint64_t v7 = (char *)__p;
  uint64_t v6 = v133;
  if (v133 != __p)
  {
    while (1)
    {
      uint64_t v9 = (const llvm::BasicBlock *)*((void *)v6 - 1);
      v6 -= 8;
      uint64_t v8 = v9;
      unint64_t InitialEstimatedBlockWeight = llvm::BranchProbabilityInfo::getInitialEstimatedBlockWeight((llvm::BranchProbabilityInfo *)InitialEstimatedBlockWeight, v9);
      if (HIDWORD(InitialEstimatedBlockWeight)) {
        break;
      }
LABEL_19:
      if (v6 == v7) {
        goto LABEL_22;
      }
    }
    uint64_t v11 = (uint64_t *)*((void *)this + 7);
    uint64_t v10 = (uint64_t *)*((void *)this + 8);
    unsigned int v135 = v8;
    uint64_t v136 = 0;
    v137[0] = -1;
    int v12 = *((_DWORD *)v11 + 4);
    unsigned int v13 = v8 >> 4;
    if (v12)
    {
      uint64_t v14 = *v11;
      unsigned int v15 = v12 - 1;
      uint64_t v16 = (v12 - 1) & (v13 ^ (v8 >> 9));
      uint64_t v17 = *(const llvm::BasicBlock **)(v14 + 16 * v16);
      if (v17 == v8)
      {
LABEL_8:
        uint64_t v136 = *(void *)(v14 + 16 * v16 + 8);
        if (v136)
        {
LABEL_18:
          unint64_t InitialEstimatedBlockWeight = llvm::BranchProbabilityInfo::propagateEstimatedBlockWeight((uint64_t)this, (uint64_t)&v135, (uint64_t)a3, (uint64_t)a4, InitialEstimatedBlockWeight, (uint64_t)&v141, (uint64_t)&v138);
          goto LABEL_19;
        }
      }
      else
      {
        int v18 = 1;
        while (v17 != (const llvm::BasicBlock *)-4096)
        {
          int v19 = v16 + v18++;
          uint64_t v16 = v19 & v15;
          uint64_t v17 = *(const llvm::BasicBlock **)(v14 + 16 * v16);
          if (v17 == v8) {
            goto LABEL_8;
          }
        }
      }
    }
    uint64_t v20 = *((unsigned int *)v10 + 4);
    if (v20)
    {
      uint64_t v21 = *v10;
      LODWORD(v22) = (v20 - 1) & (v13 ^ (v8 >> 9));
      uint64_t v23 = v21 + 16 * v22;
      BOOL v24 = *(const llvm::BasicBlock **)v23;
      if (*(const llvm::BasicBlock **)v23 == v8)
      {
LABEL_15:
        if (v23 != v21 + 16 * v20)
        {
          int v27 = *(_DWORD *)(v23 + 8);
          goto LABEL_17;
        }
      }
      else
      {
        int v25 = 1;
        while (v24 != (const llvm::BasicBlock *)-4096)
        {
          int v26 = v22 + v25++;
          uint64_t v22 = v26 & (v20 - 1);
          BOOL v24 = *(const llvm::BasicBlock **)(v21 + 16 * v22);
          if (v24 == v8)
          {
            uint64_t v23 = v21 + 16 * v22;
            goto LABEL_15;
          }
        }
      }
    }
    int v27 = -1;
LABEL_17:
    v137[0] = v27;
    goto LABEL_18;
  }
LABEL_22:
  int v127 = (char *)this + 144;
  unsigned int v28 = (char *)this + 80;
  unsigned int v29 = v139;
LABEL_23:
  while (v29)
  {
    unsigned int v30 = (char *)v138 + 24 * v29;
    uint64_t v31 = *((void *)v30 - 1);
    *(_OWORD *)unsigned int v131 = *(_OWORD *)(v30 - 24);
    *(void *)&v131[16] = v31;
    LODWORD(v139) = v29 - 1;
    if ((sub_1CBF8BFC0((uint64_t)v127, *(uint64_t *)&v131[8], v31, &v135) & 1) == 0)
    {
      unsigned int v135 = v137;
      uint64_t v136 = 0x400000000;
      if (*(void *)&v131[8]) {
        llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getExitBlocks();
      }
      llvm::BranchProbabilityInfo::SccInfo::getSccExitBlocks(*((void *)this + 8), *(int *)&v131[16], (uint64_t)&v135);
      unint64_t v121 = sub_1CD463090((uint64_t)this, (uint64_t)v131, (uint64_t *)v135, (uint64_t *)v135 + v136);
      if (HIDWORD(v121))
      {
        if (v121 <= 1) {
          int v122 = 1;
        }
        else {
          int v122 = v121;
        }
        long long v129 = *(_OWORD *)&v131[8];
        v130[0] = v122;
        sub_1CD463A18((uint64_t)v128, (uint64_t)v127, (uint64_t)&v129, v130);
        llvm::BranchProbabilityInfo::getLoopEnterBlocks((uint64_t)this, (uint64_t)v131, (uint64_t)&v141);
      }
      if (v135 != v137) {
        free(v135);
      }
    }
    unsigned int v29 = v139;
  }
  unsigned int v32 = v142;
  if (v142)
  {
    while (1)
    {
      unint64_t v33 = v141[--v32];
      LODWORD(v142) = v32;
      unsigned int v34 = v33 >> 4;
      if (*((unsigned char *)this + 72))
      {
        int v35 = 4;
        uint64_t v36 = v28;
      }
      else
      {
        int v35 = *((_DWORD *)this + 22);
        if (!v35) {
          goto LABEL_38;
        }
        uint64_t v36 = (char *)*((void *)this + 10);
      }
      int v37 = v35 - 1;
      unsigned int v38 = v37 & (v34 ^ (v33 >> 9));
      uint64_t v39 = *(void *)&v36[16 * v38];
      if (v33 == v39) {
        goto LABEL_148;
      }
      int v40 = 1;
      while (v39 != -4096)
      {
        unsigned int v41 = v38 + v40++;
        unsigned int v38 = v41 & v37;
        uint64_t v39 = *(void *)&v36[16 * v38];
        if (v33 == v39) {
          goto LABEL_148;
        }
      }
LABEL_38:
      uint64_t v43 = (uint64_t *)*((void *)this + 7);
      uint64_t v42 = (uint64_t *)*((void *)this + 8);
      *(_OWORD *)unsigned int v131 = v33;
      *(_DWORD *)&v131[16] = -1;
      int v44 = *((_DWORD *)v43 + 4);
      if (v44)
      {
        uint64_t v45 = *v43;
        unsigned int v46 = v44 - 1;
        uint64_t v47 = (v44 - 1) & (v34 ^ (v33 >> 9));
        uint64_t v48 = *(void *)(v45 + 16 * v47);
        if (v48 == v33)
        {
LABEL_43:
          *(void *)&v131[8] = *(void *)(v45 + 16 * v47 + 8);
          if (*(void *)&v131[8]) {
            goto LABEL_54;
          }
        }
        else
        {
          int v49 = 1;
          while (v48 != -4096)
          {
            int v50 = v47 + v49++;
            uint64_t v47 = v50 & v46;
            uint64_t v48 = *(void *)(v45 + 16 * v47);
            if (v48 == v33) {
              goto LABEL_43;
            }
          }
        }
      }
      uint64_t v51 = *((unsigned int *)v42 + 4);
      if (!v51) {
        goto LABEL_52;
      }
      uint64_t v52 = *v42;
      LODWORD(v53) = (v51 - 1) & (v34 ^ (v33 >> 9));
      uint64_t v54 = (uint64_t *)(v52 + 16 * v53);
      uint64_t v55 = *v54;
      if (*v54 != v33)
      {
        int v56 = 1;
        while (v55 != -4096)
        {
          int v57 = v53 + v56++;
          uint64_t v53 = v57 & (v51 - 1);
          uint64_t v55 = *(void *)(v52 + 16 * v53);
          if (v55 == v33)
          {
            uint64_t v54 = (uint64_t *)(v52 + 16 * v53);
            goto LABEL_50;
          }
        }
LABEL_52:
        int v119 = -1;
        goto LABEL_53;
      }
LABEL_50:
      if (v54 == (uint64_t *)(v52 + 16 * v51)) {
        goto LABEL_52;
      }
      int v119 = *((_DWORD *)v54 + 2);
LABEL_53:
      *(_DWORD *)&v131[16] = v119;
LABEL_54:
      uint64_t v58 = *(void *)(v33 + 40);
      if (v58 == v33 + 40)
      {
LABEL_138:
        LODWORD(v65) = 0;
        unsigned int v66 = 0;
        uint64_t v114 = 0;
        unsigned int v135 = v137;
        uint64_t v136 = 0x400000000;
        goto LABEL_143;
      }
      uint64_t v59 = v58 - 24;
      if (v58) {
        uint64_t v60 = v58 - 24;
      }
      else {
        uint64_t v60 = 0;
      }
      int v61 = *(unsigned __int8 *)(v60 + 16);
      int v62 = v61 - 29;
      if (v61 == 30)
      {
        BOOL v63 = (*(_DWORD *)(v60 + 20) & 0x7FFFFFF) == 3;
        uint64_t v60 = 1;
        if (v63) {
          unsigned int v118 = 2;
        }
        else {
          unsigned int v118 = 1;
        }
LABEL_63:
        unsigned int v135 = v137;
        uint64_t v136 = 0x400000000;
LABEL_64:
        uint64_t v64 = 0;
        uint64_t v65 = 0;
        unsigned int v66 = 0;
        uint64_t v67 = (uint64_t *)(v58 - 56);
        uint64_t v68 = v58 - 88;
        char v69 = 1;
        uint64_t v70 = v118;
        while (1)
        {
          int v71 = *(unsigned __int8 *)(v58 - 8);
          if (v71 == 30)
          {
            uint64_t v108 = &v67[-4 * v64];
          }
          else
          {
            uint64_t v107 = (v71 - 31);
            uint64_t v108 = v67;
            switch(v107)
            {
              case 1:
              case 7:
                int v115 = *(_DWORD *)(v58 - 4);
                if ((v115 & 0x40000000) != 0) {
                  uint64_t v116 = *(void *)(v58 - 32);
                }
                else {
                  uint64_t v116 = v59 - 32 * (v115 & 0x7FFFFFF);
                }
                uint64_t v108 = (uint64_t *)(v116 + 32 * v64 + 32);
                goto LABEL_136;
              case 2:
                uint64_t v117 = -64;
                if (!v64) {
                  uint64_t v117 = -96;
                }
                uint64_t v108 = (uint64_t *)(v59 + v117);
                break;
              case 3:
              case 4:
                goto LABEL_171;
              case 5:
                if ((*(_WORD *)(v58 - 6) & 1) == 0)
                {
                  uint64_t v72 = 0;
                  unsigned int v28 = (char *)this + 80;
                  goto LABEL_69;
                }
                uint64_t v108 = (uint64_t *)(v58 + 8 - 32 * (*(_DWORD *)(v58 - 4) & 0x7FFFFFF));
LABEL_136:
                unsigned int v28 = (char *)this + 80;
                break;
              case 6:
                break;
              case 8:
                if (v64) {
                  uint64_t v108 = &v67[4 * v64 - 4 + -4 * *(unsigned int *)(v58 + 56)];
                }
                else {
                  uint64_t v108 = (uint64_t *)(v68 - 32 * *(unsigned int *)(v58 + 56));
                }
                goto LABEL_136;
              default:
                int v109 = *(_DWORD *)(v58 - 4);
                if ((v109 & 0x40000000) != 0) {
                  uint64_t v110 = *(void *)(v58 - 32);
                }
                else {
                  uint64_t v110 = v59 - 32 * (v109 & 0x7FFFFFF);
                }
                uint64_t v108 = (uint64_t *)(v110 + 32 * (2 * v64) + 32);
                break;
            }
          }
          uint64_t v72 = *v108;
LABEL_69:
          uint64_t v74 = (uint64_t *)*((void *)this + 7);
          uint64_t v73 = (uint64_t *)*((void *)this + 8);
          unint64_t v75 = v60 | 0xFFFFFFFFLL;
          int v76 = *((_DWORD *)v74 + 4);
          unsigned int v77 = v72 >> 4;
          if (!v76) {
            goto LABEL_79;
          }
          uint64_t v78 = *v74;
          unsigned int v79 = v76 - 1;
          uint64_t v80 = (v76 - 1) & (v77 ^ (v72 >> 9));
          uint64_t v81 = *(void *)(v78 + 16 * v80);
          if (v81 != v72) {
            break;
          }
LABEL_74:
          uint64_t v84 = *(void **)(v78 + 16 * v80 + 8);
          if (!v84) {
            goto LABEL_79;
          }
          for (unint64_t i = *(void **)&v131[8]; i != v84; unint64_t i = (void *)*i)
          {
            if (!i) {
              goto LABEL_113;
            }
          }
LABEL_88:
          if (v75 == -1 || *(_DWORD *)&v131[16] == v75)
          {
            int v94 = *((_DWORD *)this + 18);
            if (v94)
            {
              int v95 = 4;
              uint64_t v96 = v28;
              goto LABEL_92;
            }
            uint64_t v96 = (char *)*((void *)this + 10);
            int v95 = *((_DWORD *)this + 22);
            if (v95)
            {
LABEL_92:
              int v97 = v95 - 1;
              LODWORD(v98) = (v95 - 1) & (v77 ^ (v72 >> 9));
              int v99 = &v96[16 * v98];
              uint64_t v100 = *(void *)v99;
              if (*(void *)v99 != v72)
              {
                int v101 = 1;
                while (v100 != -4096)
                {
                  int v102 = v98 + v101++;
                  uint64_t v98 = v102 & v97;
                  uint64_t v100 = *(void *)&v96[16 * v98];
                  if (v100 == v72)
                  {
                    int v99 = &v96[16 * v98];
                    goto LABEL_101;
                  }
                }
                if (v94)
                {
                  uint64_t v96 = v28;
                  uint64_t v103 = 4;
                }
                else
                {
                  uint64_t v96 = (char *)*((void *)this + 10);
                  uint64_t v103 = *((unsigned int *)this + 22);
                }
LABEL_100:
                int v99 = &v96[16 * v103];
              }
LABEL_101:
              if (v94)
              {
                BOOL v104 = v28;
                uint64_t v105 = 4;
              }
              else
              {
                BOOL v104 = (char *)*((void *)this + 10);
                uint64_t v105 = *((unsigned int *)this + 22);
              }
              if (&v104[16 * v105] == v99) {
                goto LABEL_142;
              }
              uint64_t EstimatedLoopWeight = *((unsigned int *)v99 + 2) | 0x100000000;
              uint64_t v60 = v75;
              goto LABEL_114;
            }
            uint64_t v103 = 0;
            goto LABEL_100;
          }
LABEL_113:
          char v123 = v69;
          int v124 = v67;
          uint64_t v111 = v65;
          uint64_t v112 = v59;
          uint64_t v113 = v68;
          *(void *)&long long v129 = v84;
          *((void *)&v129 + 1) = v75;
          uint64_t EstimatedLoopWeight = llvm::BranchProbabilityInfo::getEstimatedLoopWeight((uint64_t)this, (uint64_t)&v129);
          uint64_t v60 = v75;
          uint64_t v68 = v113;
          unsigned int v28 = (char *)this + 80;
          uint64_t v59 = v112;
          uint64_t v65 = v111;
          uint64_t v67 = v124;
          char v69 = v123;
LABEL_114:
          if ((EstimatedLoopWeight & 0xFF00000000) == 0) {
            goto LABEL_142;
          }
          if ((v69 & 1) != 0 || (v66 | (v65 << 8)) < EstimatedLoopWeight)
          {
            unsigned int v66 = EstimatedLoopWeight;
            uint64_t v65 = EstimatedLoopWeight >> 8;
          }
          char v69 = 0;
          ++v64;
          uint64_t v114 = 0x100000000;
          if (v64 == v70) {
            goto LABEL_143;
          }
        }
        int v82 = 1;
        while (v81 != -4096)
        {
          int v83 = v80 + v82++;
          uint64_t v80 = v83 & v79;
          uint64_t v81 = *(void *)(v78 + 16 * v80);
          if (v81 == v72) {
            goto LABEL_74;
          }
        }
LABEL_79:
        uint64_t v86 = *((unsigned int *)v73 + 4);
        if (!v86)
        {
          uint64_t v84 = 0;
          goto LABEL_88;
        }
        uint64_t v87 = *v73;
        LODWORD(v88) = (v86 - 1) & (v77 ^ (v72 >> 9));
        uint64_t v89 = (uint64_t *)(v87 + 16 * v88);
        uint64_t v90 = *v89;
        if (*v89 == v72)
        {
LABEL_85:
          if (v89 == (uint64_t *)(v87 + 16 * v86)) {
            goto LABEL_86;
          }
          uint64_t v93 = *((unsigned int *)v89 + 2);
        }
        else
        {
          int v91 = 1;
          while (v90 != -4096)
          {
            int v92 = v88 + v91++;
            uint64_t v88 = v92 & (v86 - 1);
            uint64_t v90 = *(void *)(v87 + 16 * v88);
            if (v90 == v72)
            {
              uint64_t v89 = (uint64_t *)(v87 + 16 * v88);
              goto LABEL_85;
            }
          }
LABEL_86:
          uint64_t v93 = 0xFFFFFFFFLL;
        }
        uint64_t v84 = 0;
        unint64_t v75 = v60 & 0xFFFFFFFF00000000 | v93;
        goto LABEL_88;
      }
      unsigned int v118 = 2;
      switch(v62)
      {
        case 1:
LABEL_171:
          __break(1u);
          JUMPOUT(0x1CBF870F8);
        case 2:
          uint64_t v60 = *(unsigned int *)(v60 + 20);
          unsigned int v118 = (v60 >> 1) & 0x3FFFFFF;
          goto LABEL_140;
        case 3:
        case 9:
          uint64_t v60 = *(_DWORD *)(v60 + 20) & 0x7FFFFFF;
          unsigned int v118 = v60 - 1;
          goto LABEL_140;
        case 4:
          goto LABEL_63;
        case 7:
          uint64_t v60 = *(unsigned __int16 *)(v60 + 18);
          unsigned int v118 = v60 & 1;
          goto LABEL_140;
        case 8:
          unsigned int v118 = 1;
          goto LABEL_63;
        case 10:
          uint64_t v60 = *(unsigned int *)(v60 + 80);
          unsigned int v118 = v60 + 1;
LABEL_140:
          unsigned int v135 = v137;
          uint64_t v136 = 0x400000000;
          if (v118) {
            goto LABEL_64;
          }
          LODWORD(v65) = 0;
          break;
        default:
          goto LABEL_138;
      }
LABEL_142:
      unsigned int v66 = 0;
      uint64_t v114 = 0;
LABEL_143:
      if (v135 != v137) {
        free(v135);
      }
      unint64_t v120 = v114 | ((unint64_t)v65 << 8);
      if (HIDWORD(v120)) {
        llvm::BranchProbabilityInfo::propagateEstimatedBlockWeight((uint64_t)this, (uint64_t)v131, (uint64_t)a3, (uint64_t)a4, v120 | v66, (uint64_t)&v141, (uint64_t)&v138);
      }
      unsigned int v32 = v142;
LABEL_148:
      if (!v32)
      {
        unsigned int v29 = v139;
        if (!v139) {
          break;
        }
        goto LABEL_23;
      }
    }
  }
  if (__p)
  {
    uint64_t v133 = (char *)__p;
    operator delete(__p);
  }
  if (v138 != v140) {
    free(v138);
  }
  if (v141 != v143) {
    free(v141);
  }
}

uint64_t llvm::BranchProbabilityInfo::calcEstimatedHeuristics(uint64_t **this, const llvm::BasicBlock *a2)
{
  uint64_t v4 = (uint64_t)a2;
  int v5 = (llvm::BranchProbabilityInfo *)this;
  v289[2] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = this[7];
  uint64_t v6 = this[8];
  int v8 = *((_DWORD *)v7 + 4);
  unsigned int v9 = a2 >> 4;
  if (!v8) {
    goto LABEL_37;
  }
  uint64_t v10 = *v7;
  unsigned int v11 = v8 - 1;
  uint64_t v12 = (v8 - 1) & (v9 ^ (a2 >> 9));
  unsigned int v13 = *(const llvm::BasicBlock **)(v10 + 16 * v12);
  if (v13 != a2)
  {
    int v14 = 1;
    while (v13 != (const llvm::BasicBlock *)-4096)
    {
      int v15 = v12 + v14++;
      uint64_t v12 = v15 & v11;
      unsigned int v13 = *(const llvm::BasicBlock **)(v10 + 16 * v12);
      if (v13 == a2) {
        goto LABEL_6;
      }
    }
LABEL_37:
    uint64_t v37 = *((unsigned int *)v6 + 4);
    if (!v37)
    {
      uint64_t v16 = 0;
      long long v266 = v270;
      v267 = v270;
      uint64_t v268 = 8;
      int v269 = 0;
      LODWORD(v21) = -1;
      goto LABEL_46;
    }
    uint64_t v38 = *v6;
    LODWORD(v39) = (v37 - 1) & (v9 ^ (a2 >> 9));
    uint64_t v40 = v38 + 16 * v39;
    unsigned int v41 = *(const llvm::BasicBlock **)v40;
    if (*(const llvm::BasicBlock **)v40 == a2)
    {
LABEL_43:
      if (v40 != v38 + 16 * v37)
      {
        LODWORD(v21) = *(_DWORD *)(v40 + 8);
        goto LABEL_45;
      }
    }
    else
    {
      int v42 = 1;
      while (v41 != (const llvm::BasicBlock *)-4096)
      {
        int v43 = v39 + v42++;
        uint64_t v39 = v43 & (v37 - 1);
        unsigned int v41 = *(const llvm::BasicBlock **)(v38 + 16 * v39);
        if (v41 == a2)
        {
          uint64_t v40 = v38 + 16 * v39;
          goto LABEL_43;
        }
      }
    }
    LODWORD(v21) = -1;
LABEL_45:
    uint64_t v16 = 0;
    long long v266 = v270;
    v267 = v270;
    uint64_t v268 = 8;
    int v269 = 0;
LABEL_46:
    unsigned int v18 = 1;
    goto LABEL_328;
  }
LABEL_6:
  uint64_t v16 = *(void *)(v10 + 16 * v12 + 8);
  if (!v16) {
    goto LABEL_37;
  }
  long long v266 = v270;
  v267 = v270;
  uint64_t v268 = 8;
  int v269 = 0;
  uint64_t v17 = (const llvm::BasicBlock *)*((void *)a2 + 5);
  if (v17 == (const llvm::BasicBlock *)((char *)a2 + 40)) {
    goto LABEL_327;
  }
  unsigned int v18 = 0;
  if (v17) {
    int v19 = (char *)v17 - 24;
  }
  else {
    int v19 = 0;
  }
  unsigned int v20 = v19[16] - 40;
  if (v20 < 0xFFFFFFF5) {
    int v19 = 0;
  }
  LODWORD(v21) = -1;
  if (v17)
  {
    if (v19[16] == 30 && v20 >= 0xFFFFFFF5)
    {
      if ((*((_DWORD *)v19 + 5) & 0x7FFFFFF) != 3
        || ((uint64_t v23 = *((void *)v19 - 12), v24 = *(unsigned __int8 *)(v23 + 16), v23) ? (v25 = v24 >= 0x1C) : (v25 = 0),
            v25 ? (BOOL v26 = v24 - 83 >= 0xFFFFFFFE) : (BOOL v26 = 0),
            !v26
         || (uint64_t v27 = *(void *)(v23 - 64), v28 = *(unsigned __int8 *)(v27 + 16), v28 < 0x1C)
         || (uint64_t v255 = *(void *)(v23 - 32), *(unsigned __int8 *)(v255 + 16) > 0x14u)))
      {
        unsigned int v18 = 0;
        goto LABEL_328;
      }
      long long v251 = v19;
      uint64_t v253 = *((void *)v19 - 12);
      uint64_t v257 = (void *)(v4 + 40);
      v286 = &v288;
      uint64_t v287 = 0x100000000;
      uint64_t v29 = v16;
      if (v28 == 83)
      {
LABEL_31:
        uint64_t v30 = *(void *)(v27 + 40);
        uint64_t v32 = *(void *)(v16 + 56);
        uint64_t v31 = *(void *)(v16 + 64);
        if (v31 == v32)
        {
          uint64_t v33 = *(unsigned int *)(v16 + 76);
          unsigned int v34 = (void *)(v31 + 8 * v33);
          if (v33)
          {
            uint64_t v35 = 0;
            uint64_t v36 = 8 * v33;
            while (*(void *)(v31 + v35) != v30)
            {
              v35 += 8;
              if (v36 == v35) {
                goto LABEL_108;
              }
            }
            unsigned int v34 = (void *)(v31 + v35);
          }
LABEL_108:
          uint64_t v32 = *(void *)(v16 + 64);
        }
        else
        {
          uint64_t v66 = *(unsigned int *)(v16 + 72);
          int v67 = v66 - 1;
          unsigned int v68 = (v66 - 1) & ((v30 >> 4) ^ (v30 >> 9));
          unsigned int v34 = (void *)(v31 + 8 * v68);
          uint64_t v69 = *v34;
          if (*v34 == -1)
          {
            uint64_t v70 = 0;
LABEL_507:
            if (v70) {
              unsigned int v34 = v70;
            }
            if (*v34 != v30) {
              unsigned int v34 = (void *)(v31 + 8 * v66);
            }
          }
          else
          {
            uint64_t v70 = 0;
            int v71 = 1;
            while (v69 != v30)
            {
              if (v70) {
                BOOL v72 = 0;
              }
              else {
                BOOL v72 = v69 == -2;
              }
              if (v72) {
                uint64_t v70 = v34;
              }
              unsigned int v73 = v68 + v71++;
              unsigned int v68 = v73 & v67;
              unsigned int v34 = (void *)(v31 + 8 * (v73 & v67));
              uint64_t v69 = *v34;
              if (*v34 == -1) {
                goto LABEL_507;
              }
            }
          }
        }
        BOOL v60 = v31 == v32;
        uint64_t v74 = 72;
        if (v60) {
          uint64_t v74 = 76;
        }
        if (v34 != (void *)(v31 + 8 * *(unsigned int *)(v16 + v74)))
        {
          unint64_t v75 = (unsigned int *)(v16 + 76);
          long long v264 = (unsigned int *)(v16 + 72);
          int v281 = v285;
          uint64_t v282 = (uint64_t)v285;
          int v284 = 0;
          uint64_t v278 = v280;
          HIDWORD(v279) = 8;
          v280[0] = v27;
          uint64_t v283 = 0x100000008;
          v285[0] = v27;
          unsigned int v76 = 1;
          while (1)
          {
            while (1)
            {
              uint64_t v77 = *((void *)v278 + --v76);
              LODWORD(v279) = v76;
              int v78 = *(_DWORD *)(v77 + 20);
              if ((v78 & 0x40000000) == 0) {
                break;
              }
              uint64_t v80 = *(void *)(v77 - 8);
              uint64_t v79 = v78 & 0x7FFFFFF;
              if (v79) {
                goto LABEL_115;
              }
LABEL_319:
              if (!v76) {
                goto LABEL_320;
              }
            }
            uint64_t v79 = v78 & 0x7FFFFFF;
            uint64_t v80 = v77 - 32 * v79;
            if (!v79) {
              goto LABEL_319;
            }
LABEL_115:
            uint64_t v81 = (uint64_t *)(v80 + 32 * *(unsigned int *)(v77 + 60));
            uint64_t v259 = v77;
            char v261 = &v81[v79];
            do
            {
              uint64_t v21 = *v81;
              uint64_t v83 = *(void *)(v16 + 56);
              uint64_t v82 = *(void *)(v16 + 64);
              if (v82 == v83)
              {
                uint64_t v84 = *v75;
                int v85 = (void *)(v82 + 8 * v84);
                if (v84)
                {
                  uint64_t v86 = 0;
                  uint64_t v87 = 8 * v84;
                  while (*(void *)(v82 + v86) != v21)
                  {
                    v86 += 8;
                    if (v87 == v86) {
                      goto LABEL_134;
                    }
                  }
                  int v85 = (void *)(v82 + v86);
                }
LABEL_134:
                uint64_t v83 = *(void *)(v16 + 64);
              }
              else
              {
                uint64_t v88 = *v264;
                int v89 = v88 - 1;
                unsigned int v90 = (v88 - 1) & ((v21 >> 4) ^ (v21 >> 9));
                int v85 = (void *)(v82 + 8 * v90);
                uint64_t v91 = *v85;
                if (*v85 == -1)
                {
                  int v92 = 0;
LABEL_202:
                  if (v92) {
                    int v85 = v92;
                  }
                  if (*v85 != v21) {
                    int v85 = (void *)(v82 + 8 * v88);
                  }
                }
                else
                {
                  int v92 = 0;
                  int v93 = 1;
                  while (v91 != v21)
                  {
                    if (v92) {
                      BOOL v94 = 0;
                    }
                    else {
                      BOOL v94 = v91 == -2;
                    }
                    if (v94) {
                      int v92 = v85;
                    }
                    unsigned int v95 = v90 + v93++;
                    unsigned int v90 = v95 & v89;
                    int v85 = (void *)(v82 + 8 * (v95 & v89));
                    uint64_t v91 = *v85;
                    if (*v85 == -1) {
                      goto LABEL_202;
                    }
                  }
                }
              }
              BOOL v60 = v82 == v83;
              uint64_t v96 = v264;
              if (v60) {
                uint64_t v96 = v75;
              }
              if (v85 == (void *)(v82 + 8 * *v96)) {
                goto LABEL_226;
              }
              uint64_t v97 = sub_1CBF73380(v259, *v81);
              uint64_t v100 = (llvm::Constant *)v97;
              unsigned int v101 = *(unsigned __int8 *)(v97 + 16);
              if (v97 && v101 == 83)
              {
                uint64_t v102 = v282;
                uint64_t v103 = HIDWORD(v283);
                if ((uint64_t *)v282 == v281)
                {
                  uint64_t v16 = v29;
                  if (HIDWORD(v283))
                  {
                    BOOL v104 = 0;
                    uint64_t v105 = 8 * HIDWORD(v283);
                    int v106 = (uint64_t *)v282;
                    while (*v106 != v97)
                    {
                      if (*v106 == -2) {
                        BOOL v104 = v106;
                      }
                      ++v106;
                      v105 -= 8;
                      if (!v105)
                      {
                        if (!v104) {
                          goto LABEL_148;
                        }
                        *BOOL v104 = v97;
                        --v284;
                        goto LABEL_224;
                      }
                    }
                    goto LABEL_226;
                  }
LABEL_148:
                  unsigned int v107 = v283;
                  if (HIDWORD(v283) < v283)
                  {
                    ++HIDWORD(v283);
                    *(void *)(v282 + 8 * v103) = v97;
LABEL_224:
                    if (v279 >= (unint64_t)HIDWORD(v279)) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    *((void *)v278 + v279) = v100;
                    LODWORD(v279) = v279 + 1;
                    goto LABEL_226;
                  }
                }
                else
                {
                  unsigned int v107 = v283;
                }
                if (3 * v107 <= 4 * (HIDWORD(v283) - v284))
                {
                  if (v107 >= 0x40) {
                    v107 *= 2;
                  }
                  else {
                    unsigned int v107 = 128;
                  }
                }
                else
                {
                  uint64_t v16 = v29;
                  if (v107 - HIDWORD(v283) >= v107 >> 3) {
                    goto LABEL_190;
                  }
                }
                llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v281, v107);
                uint64_t v16 = v29;
                unsigned int v107 = v283;
                uint64_t v102 = v282;
LABEL_190:
                unsigned int v119 = v107 - 1;
                unsigned int v120 = (v107 - 1) & ((v100 >> 4) ^ (v100 >> 9));
                unint64_t v121 = (llvm::Constant **)(v102 + 8 * v120);
                int v122 = *v121;
                if (*v121 == (llvm::Constant *)-1)
                {
                  char v123 = 0;
LABEL_217:
                  if (v123) {
                    uint64_t v136 = v123;
                  }
                  else {
                    uint64_t v136 = v121;
                  }
                  if (*v136 != v100)
                  {
                    if (*v136 == (llvm::Constant *)-2) {
                      --v284;
                    }
                    else {
                      ++HIDWORD(v283);
                    }
                    *uint64_t v136 = v100;
                    goto LABEL_224;
                  }
                }
                else
                {
                  char v123 = 0;
                  int v124 = 1;
                  while (v122 != v100)
                  {
                    if (v123) {
                      BOOL v125 = 0;
                    }
                    else {
                      BOOL v125 = v122 == (llvm::Constant *)-2;
                    }
                    if (v125) {
                      char v123 = v121;
                    }
                    unsigned int v126 = v120 + v124++;
                    unsigned int v120 = v126 & v119;
                    unint64_t v121 = (llvm::Constant **)(v102 + 8 * (v126 & v119));
                    int v122 = *v121;
                    if (*v121 == (llvm::Constant *)-1) {
                      goto LABEL_217;
                    }
                  }
                }
                goto LABEL_226;
              }
              uint64_t v16 = v29;
              if (!v97) {
                goto LABEL_226;
              }
              if (v101 > 0x14) {
                goto LABEL_226;
              }
              uint64_t v108 = (void *)*v257;
              if ((void *)*v257 == v257) {
                goto LABEL_226;
              }
              if (v108) {
                int v109 = v108 - 3;
              }
              else {
                int v109 = 0;
              }
              int v110 = *((unsigned __int8 *)v109 + 16);
              if (v110 == 30)
              {
                if ((*((_DWORD *)v109 + 5) & 0x7FFFFFF) == 3) {
                  int v141 = 2;
                }
                else {
                  int v141 = 1;
                }
              }
              else
              {
                int v141 = 2;
                switch(*((unsigned char *)v109 + 16))
                {
                  case 0x1E:
LABEL_511:
                    __break(1u);
LABEL_512:
                    unsigned int v247 = (*(_DWORD *)(v98 + 20) & 0x7FFFFFF) - 1;
LABEL_504:
                    if (!v247) {
                      goto LABEL_505;
                    }
                    goto LABEL_337;
                  case 0x1F:
                    int v141 = (*((_DWORD *)v109 + 5) >> 1) & 0x3FFFFFF;
                    break;
                  case 0x20:
                  case 0x26:
                    int v141 = (*((_DWORD *)v109 + 5) & 0x7FFFFFF) - 1;
                    break;
                  case 0x21:
                    goto LABEL_161;
                  case 0x24:
                    int v141 = *((_WORD *)v109 + 9) & 1;
                    break;
                  case 0x25:
                    int v141 = 1;
                    goto LABEL_161;
                  case 0x27:
                    int v141 = *((_DWORD *)v109 + 20) + 1;
                    break;
                  default:
                    goto LABEL_226;
                }
                if (!v141) {
                  goto LABEL_226;
                }
              }
LABEL_161:
              uint64_t v99 = 0;
              uint64_t v111 = v109 - 4;
              while (1)
              {
                uint64_t v112 = v111;
                if (v110 != 30)
                {
                  uint64_t v112 = v109 - 4;
                  switch(*((unsigned char *)v109 + 16))
                  {
                    case ' ':
                    case '&':
                      int v116 = *((_DWORD *)v109 + 5);
                      if ((v116 & 0x40000000) != 0) {
                        uint64_t v117 = (void *)*(v109 - 1);
                      }
                      else {
                        uint64_t v117 = &v109[-4 * (v116 & 0x7FFFFFF)];
                      }
                      uint64_t v112 = &v117[4 * v99 + 4];
                      goto LABEL_186;
                    case '!':
                      uint64_t v118 = 0x1FFFFFFFFFFFFFF8;
                      if (!v99) {
                        uint64_t v118 = 0x1FFFFFFFFFFFFFF4;
                      }
                      uint64_t v112 = &v109[v118];
                      break;
                    case '""':
                    case '#':
                      goto LABEL_511;
                    case '$':
                      if ((*((_WORD *)v109 + 9) & 1) == 0)
                      {
                        uint64_t v113 = 0;
                        uint64_t v16 = v29;
                        goto LABEL_165;
                      }
                      uint64_t v112 = &v109[-4 * (*((_DWORD *)v109 + 5) & 0x7FFFFFF) + 4];
LABEL_186:
                      uint64_t v16 = v29;
                      break;
                    case '%':
                      break;
                    case '\'':
                      if (v99) {
                        uint64_t v112 = &v109[4 * (v99 - 1) - 4 + -4 * *((unsigned int *)v109 + 20)];
                      }
                      else {
                        uint64_t v112 = &v109[-4 * *((unsigned int *)v109 + 20) - 8];
                      }
                      goto LABEL_186;
                    default:
                      int v114 = *((_DWORD *)v109 + 5);
                      if ((v114 & 0x40000000) != 0) {
                        int v115 = (void *)*(v109 - 1);
                      }
                      else {
                        int v115 = &v109[-4 * (v114 & 0x7FFFFFF)];
                      }
                      uint64_t v112 = &v115[8 * v99 + 4];
                      break;
                  }
                }
                uint64_t v113 = *v112;
LABEL_165:
                if (v113 == v21) {
                  break;
                }
                ++v99;
                v111 -= 4;
                if (v141 == v99) {
                  goto LABEL_226;
                }
              }
              int v127 = (char *)(v286 - 1);
              uint64_t v2 = 8 * v287;
              while (v2)
              {
                uint64_t v128 = *(void *)&v127[v2];
                int v129 = *(_DWORD *)(v128 + 20);
                if ((v129 & 0x40000000) != 0) {
                  uint64_t v130 = *(void *)(v128 - 8);
                }
                else {
                  uint64_t v130 = v128 - 32 * (v129 & 0x7FFFFFF);
                }
                unsigned __int8 v131 = *(unsigned char *)(v128 + 16) - 28;
                int v132 = *(llvm::Constant **)(v130 + 32);
                uint64_t v133 = (uint64_t)llvm::ConstantFoldBinaryInstruction((llvm *)(*(unsigned __int8 *)(v128 + 16) - 28), v100, v132, (llvm::Constant *)v16);
                if (!v133)
                {
                  uint64_t v134 = *(void ***)v100;
                  if (!*(void *)v100)
                  {
                    uint64_t v16 = v29;
                    goto LABEL_226;
                  }
                  v289[0] = v100;
                  v289[1] = v132;
                  uint64_t v135 = **v134 + 1512;
                  v271[0] = v131;
                  v271[1] = 1;
                  __int16 v272 = 0;
                  unsigned int v273 = v289;
                  uint64_t v274 = 2;
                  long long v275 = 0u;
                  long long v276 = 0u;
                  uint64_t v277 = 0;
                  uint64_t v133 = sub_1CC56C20C(v135, (uint64_t)v134, v271);
                }
                v2 -= 8;
                uint64_t v100 = (llvm::Constant *)v133;
                uint64_t v16 = v29;
                if (!v133) {
                  goto LABEL_226;
                }
              }
              unint64_t v137 = llvm::ConstantFoldCompareInstruction(*(_WORD *)(v253 + 18) & 0x3F, v100, v255, (llvm::Constant *)v16, v98);
              uint64_t v16 = v29;
              if (!v137) {
                goto LABEL_226;
              }
              uint64_t v138 = (uint64_t)v137;
              if (*((unsigned char *)v137 + 16) == 17)
              {
                if ((_UNKNOWN *)v137[4] == &unk_1CFB2E344) {
                  uint64_t v166 = (void *)v137[5];
                }
                else {
                  uint64_t v166 = v137 + 3;
                }
LABEL_304:
                BOOL v165 = (*((unsigned char *)v166 + 28) & 7) == 3;
LABEL_300:
                uint64_t v16 = v29;
                if (!v165) {
                  goto LABEL_246;
                }
                goto LABEL_234;
              }
              if ((*(_DWORD *)(*v137 + 8) & 0xFE) == 0x12)
              {
                SplatValue = llvm::Constant::getSplatValue((llvm::Constant *)v137, 0);
                uint64_t v16 = v29;
                if (SplatValue)
                {
                  if (*((unsigned char *)SplatValue + 16) == 17)
                  {
                    if ((_UNKNOWN *)SplatValue[4] == &unk_1CFB2E344) {
                      uint64_t v166 = (void *)SplatValue[5];
                    }
                    else {
                      uint64_t v166 = SplatValue + 3;
                    }
                    goto LABEL_304;
                  }
                }
              }
              int v139 = *(unsigned __int8 *)(v138 + 16);
              if (v139 == 16)
              {
                uint64_t v140 = *(unsigned int *)(v138 + 32);
                if (v140 < 0x41)
                {
                  if (*(void *)(v138 + 24)) {
                    goto LABEL_246;
                  }
                  goto LABEL_234;
                }
                int v160 = 0;
                int64_t v161 = (unint64_t)(v140 + 63) >> 6;
                do
                {
                  if (v161-- < 1) {
                    break;
                  }
                  unint64_t v163 = *(void *)(*(void *)(v138 + 24) + 8 * v161);
                  v160 += __clz(v163);
                }
                while (!v163);
                int v164 = v140 | 0xFFFFFFC0;
                if ((v140 & 0x3F) == 0) {
                  int v164 = 0;
                }
                BOOL v165 = v160 + v164 == v140;
                goto LABEL_300;
              }
              if (v139 == 17)
              {
                char v159 = sub_1CB844168(v138, 0.0);
                uint64_t v16 = v29;
                if ((v159 & 1) == 0) {
                  goto LABEL_246;
                }
              }
              else if ((v139 - 18) >= 3 && v139 != 13)
              {
LABEL_246:
                unsigned int v143 = llvm::Constant::isOneValue((llvm::Constant *)v138);
                uint64_t v16 = v29;
                if (!v143 || v21 != *((void *)v251 - 8)) {
                  goto LABEL_226;
                }
                goto LABEL_248;
              }
LABEL_234:
              if (v21 != *((void *)v251 - 4)) {
                goto LABEL_246;
              }
LABEL_248:
              uint64_t v144 = v267;
              uint64_t v145 = HIDWORD(v268);
              if (v267 != v266)
              {
                unsigned int v149 = v268;
                goto LABEL_259;
              }
              if (!HIDWORD(v268))
              {
LABEL_256:
                unsigned int v149 = v268;
                if (HIDWORD(v268) < v268)
                {
                  ++HIDWORD(v268);
                  *(void *)&v267[8 * v145] = v21;
                  goto LABEL_226;
                }
LABEL_259:
                if (3 * v149 <= 4 * (HIDWORD(v268) - v269))
                {
                  if (v149 >= 0x40) {
                    v149 *= 2;
                  }
                  else {
                    unsigned int v149 = 128;
                  }
                }
                else if (v149 - HIDWORD(v268) >= v149 >> 3)
                {
                  goto LABEL_261;
                }
                llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v266, v149);
                uint64_t v16 = v29;
                unsigned int v149 = v268;
                uint64_t v144 = v267;
LABEL_261:
                unsigned int v150 = v149 - 1;
                unsigned int v151 = (v149 - 1) & ((v21 >> 4) ^ (v21 >> 9));
                unint64_t v152 = &v144[8 * v151];
                uint64_t v153 = *(void *)v152;
                if (*(void *)v152 == -1)
                {
                  int v154 = 0;
LABEL_278:
                  if (v154) {
                    long long v158 = v154;
                  }
                  else {
                    long long v158 = (uint64_t *)v152;
                  }
                  if (*v158 != v21)
                  {
                    if (*v158 == -2) {
                      --v269;
                    }
                    else {
                      ++HIDWORD(v268);
                    }
                    *long long v158 = v21;
                  }
                }
                else
                {
                  int v154 = 0;
                  int v155 = 1;
                  while (v153 != v21)
                  {
                    if (v154) {
                      BOOL v156 = 0;
                    }
                    else {
                      BOOL v156 = v153 == -2;
                    }
                    if (v156) {
                      int v154 = (uint64_t *)v152;
                    }
                    unsigned int v157 = v151 + v155++;
                    unsigned int v151 = v157 & v150;
                    unint64_t v152 = &v144[8 * (v157 & v150)];
                    uint64_t v153 = *(void *)v152;
                    if (*(void *)v152 == -1) {
                      goto LABEL_278;
                    }
                  }
                }
                goto LABEL_226;
              }
              char v146 = 0;
              uint64_t v147 = 8 * HIDWORD(v268);
              uint64_t v148 = (uint64_t *)v267;
              while (*v148 != v21)
              {
                if (*v148 == -2) {
                  char v146 = v148;
                }
                ++v148;
                v147 -= 8;
                if (!v147)
                {
                  if (!v146) {
                    goto LABEL_256;
                  }
                  *char v146 = v21;
                  --v269;
                  break;
                }
              }
LABEL_226:
              ++v81;
            }
            while (v81 != v261);
            unsigned int v76 = v279;
            if (!v279)
            {
LABEL_320:
              if (v278 != v280)
              {
                free(v278);
                uint64_t v16 = v29;
              }
              if ((uint64_t *)v282 != v281)
              {
                free((void *)v282);
                uint64_t v16 = v29;
              }
              int v5 = (llvm::BranchProbabilityInfo *)this;
              break;
            }
          }
        }
      }
      else
      {
        unsigned int v44 = 0;
        uint64_t v2 = v16 + 76;
        while (v28 - 41 <= 0x11)
        {
          int v45 = *(_DWORD *)(v27 + 20);
          uint64_t v46 = (v45 & 0x40000000) != 0 ? *(void *)(v27 - 8) : v27 - 32 * (v45 & 0x7FFFFFF);
          if (*(unsigned __int8 *)(*(void *)(v46 + 32) + 16) > 0x14u) {
            break;
          }
          uint64_t v47 = *(void *)(v27 + 40);
          uint64_t v49 = *(void *)(v16 + 56);
          uint64_t v48 = *(void *)(v16 + 64);
          if (v48 == v49)
          {
            uint64_t v50 = *(unsigned int *)v2;
            uint64_t v51 = (void *)(v48 + 8 * v50);
            if (v50)
            {
              uint64_t v52 = 0;
              uint64_t v53 = 8 * v50;
              while (*(void *)(v48 + v52) != v47)
              {
                v52 += 8;
                if (v53 == v52) {
                  goto LABEL_74;
                }
              }
              uint64_t v51 = (void *)(v48 + v52);
            }
LABEL_74:
            uint64_t v49 = *(void *)(v16 + 64);
          }
          else
          {
            uint64_t v54 = *(unsigned int *)(v16 + 72);
            int v55 = v54 - 1;
            unsigned int v56 = (v54 - 1) & ((v47 >> 4) ^ (v47 >> 9));
            uint64_t v51 = (void *)(v48 + 8 * v56);
            uint64_t v57 = *v51;
            if (*v51 == -1)
            {
              uint64_t v58 = 0;
LABEL_91:
              if (v58) {
                uint64_t v51 = v58;
              }
              if (*v51 != v47) {
                uint64_t v51 = (void *)(v48 + 8 * v54);
              }
            }
            else
            {
              uint64_t v58 = 0;
              int v59 = 1;
              while (v57 != v47)
              {
                if (v58) {
                  BOOL v60 = 0;
                }
                else {
                  BOOL v60 = v57 == -2;
                }
                if (v60) {
                  uint64_t v58 = v51;
                }
                unsigned int v61 = v56 + v59++;
                unsigned int v56 = v61 & v55;
                uint64_t v51 = (void *)(v48 + 8 * (v61 & v55));
                uint64_t v57 = *v51;
                if (*v51 == -1) {
                  goto LABEL_91;
                }
              }
            }
          }
          int v62 = (unsigned int *)(v48 == v49 ? v16 + 76 : v16 + 72);
          if (v51 == (void *)(v48 + 8 * *v62)) {
            break;
          }
          if (v44 >= HIDWORD(v287)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          v286[v44] = v27;
          unsigned int v44 = v287 + 1;
          LODWORD(v287) = v287 + 1;
          int v63 = *(_DWORD *)(v27 + 20);
          uint64_t v64 = (v63 & 0x40000000) != 0 ? *(uint64_t **)(v27 - 8) : (uint64_t *)(v27 - 32 * (v63 & 0x7FFFFFF));
          uint64_t v27 = *v64;
          unsigned int v28 = *(unsigned __int8 *)(*v64 + 16);
          if (!v27 || v28 < 0x1C) {
            break;
          }
          if (v28 == 83) {
            goto LABEL_31;
          }
        }
      }
      if (v286 != &v288)
      {
        free(v286);
        uint64_t v16 = v29;
        int v5 = (llvm::BranchProbabilityInfo *)this;
      }
LABEL_327:
      unsigned int v18 = 0;
      LODWORD(v21) = -1;
    }
  }
LABEL_328:
  uint64_t v99 = (uint64_t)&v283;
  int v281 = &v283;
  uint64_t v3 = 0x400000000;
  uint64_t v282 = 0x400000000;
  uint64_t v168 = *(void *)(v4 + 40);
  if (v168 == v4 + 40)
  {
LABEL_505:
    uint64_t v248 = 0;
    goto LABEL_497;
  }
  if (v168) {
    uint64_t v98 = v168 - 24;
  }
  else {
    uint64_t v98 = 0;
  }
  int v169 = *(unsigned __int8 *)(v98 + 16);
  int v170 = v169 - 29;
  if (v169 == 30)
  {
    if ((*(_DWORD *)(v98 + 20) & 0x7FFFFFF) == 3) {
      unsigned int v247 = 2;
    }
    else {
      unsigned int v247 = 1;
    }
LABEL_337:
    unint64_t v252 = (const llvm::BasicBlock *)v4;
    uint64_t v254 = v99;
    uint64_t v171 = 0;
    uint64_t v4 = 0;
    unint64_t v172 = 0;
    int64_t v173 = (char *)v5 + 80;
    long long v174 = (uint64_t *)(v98 - 32);
    uint64_t v249 = v98 - 64;
    uint64_t v250 = v98 + 32;
    uint64_t v175 = v247;
    int v256 = v21;
    unsigned int v262 = v18;
    v258 = (uint64_t *)(v98 - 32);
    uint64_t v260 = v98;
    uint64_t v265 = v247;
    while (1)
    {
      int v176 = *(unsigned __int8 *)(v98 + 16);
      if (v176 == 30)
      {
        int v227 = &v174[-4 * v171];
      }
      else
      {
        uint64_t v226 = (v176 - 31);
        int v227 = v174;
        switch(v226)
        {
          case 1:
          case 7:
            int v234 = *(_DWORD *)(v98 + 20);
            if ((v234 & 0x40000000) != 0) {
              uint64_t v235 = *(void *)(v260 - 8);
            }
            else {
              uint64_t v235 = v260 - 32 * (v234 & 0x7FFFFFF);
            }
            int v227 = (uint64_t *)(v235 + 32 * (v171 + 1));
            int v5 = (llvm::BranchProbabilityInfo *)this;
            LODWORD(v21) = v256;
            unsigned int v18 = v262;
            uint64_t v98 = v260;
            goto LABEL_476;
          case 2:
            uint64_t v236 = -64;
            if (!v171) {
              uint64_t v236 = -96;
            }
            int v227 = (uint64_t *)(v98 + v236);
            break;
          case 3:
          case 4:
            goto LABEL_511;
          case 5:
            if ((*(_WORD *)(v98 + 18) & 1) == 0)
            {
              uint64_t v177 = 0;
              int v5 = (llvm::BranchProbabilityInfo *)this;
              uint64_t v175 = v265;
              LODWORD(v21) = v256;
              unsigned int v18 = v262;
              long long v174 = v258;
              uint64_t v98 = v260;
              goto LABEL_342;
            }
            uint64_t v98 = v260;
            uint64_t v237 = *(_DWORD *)(v260 + 20) & 0x7FFFFFF;
            uint64_t v238 = v250;
            goto LABEL_475;
          case 6:
            break;
          case 8:
            if (v171)
            {
              long long v174 = v258;
              uint64_t v98 = v260;
              int v227 = &v258[4 * v171 - 4 + -4 * *(unsigned int *)(v260 + 80)];
              int v5 = (llvm::BranchProbabilityInfo *)this;
              LODWORD(v21) = v256;
              unsigned int v18 = v262;
            }
            else
            {
              uint64_t v98 = v260;
              uint64_t v237 = *(unsigned int *)(v260 + 80);
              uint64_t v238 = v249;
LABEL_475:
              int v227 = (uint64_t *)(v238 - 32 * v237);
              int v5 = (llvm::BranchProbabilityInfo *)this;
              LODWORD(v21) = v256;
              unsigned int v18 = v262;
LABEL_476:
              long long v174 = v258;
            }
            uint64_t v175 = v265;
            break;
          default:
            int v228 = *(_DWORD *)(v98 + 20);
            if ((v228 & 0x40000000) != 0) {
              uint64_t v229 = *(void *)(v98 - 8);
            }
            else {
              uint64_t v229 = v98 - 32 * (v228 & 0x7FFFFFF);
            }
            int v227 = (uint64_t *)(v229 + 32 * (2 * v171) + 32);
            break;
        }
      }
      uint64_t v177 = *v227;
LABEL_342:
      int v179 = (uint64_t *)*((void *)v5 + 7);
      BOOL v178 = (uint64_t *)*((void *)v5 + 8);
      unint64_t v180 = v2 | 0xFFFFFFFFLL;
      int v181 = *((_DWORD *)v179 + 4);
      unsigned int v182 = v177 >> 4;
      if (!v181) {
        goto LABEL_350;
      }
      uint64_t v183 = *v179;
      unsigned int v184 = v181 - 1;
      uint64_t v185 = (v181 - 1) & (v182 ^ (v177 >> 9));
      uint64_t v186 = *(void *)(v183 + 16 * v185);
      if (v186 != v177) {
        break;
      }
LABEL_347:
      BOOL v189 = *(void **)(v183 + 16 * v185 + 8);
      if (!v189) {
        goto LABEL_350;
      }
      uint64_t v190 = (void *)v16;
      if ((void *)v16 != v189)
      {
        while (v190)
        {
          uint64_t v190 = (void *)*v190;
          if (v190 == v189)
          {
            unint64_t v191 = v189;
            goto LABEL_366;
          }
        }
        uint64_t v21 = v16;
        unint64_t v191 = v189;
        goto LABEL_364;
      }
      unint64_t v191 = (void *)v16;
LABEL_366:
      if (v180 != -1 && v21 != v180)
      {
        uint64_t v21 = v16;
LABEL_364:
        uint64_t v278 = v189;
        unint64_t v279 = v180;
        unint64_t EstimatedLoopWeight = llvm::BranchProbabilityInfo::getEstimatedLoopWeight((uint64_t)v5, (uint64_t)&v278);
        int v5 = (llvm::BranchProbabilityInfo *)this;
        uint64_t v175 = v265;
        uint64_t v2 = v180;
        uint64_t v16 = v21;
        LODWORD(v21) = v256;
        unsigned int v18 = v262;
        long long v174 = v258;
        uint64_t v98 = v260;
        goto LABEL_386;
      }
      int v200 = *((_DWORD *)v5 + 18);
      if (v200)
      {
        int v201 = 4;
        uint64_t v202 = v173;
      }
      else
      {
        uint64_t v202 = (char *)*((void *)v5 + 10);
        int v201 = *((_DWORD *)v5 + 22);
        if (!v201)
        {
          uint64_t v204 = 0;
LABEL_378:
          uint64_t v205 = &v202[16 * v204];
          goto LABEL_379;
        }
      }
      int v203 = v201 - 1;
      LODWORD(v204) = (v201 - 1) & (v182 ^ (v177 >> 9));
      uint64_t v205 = &v202[16 * v204];
      uint64_t v206 = *(void *)v205;
      if (*(void *)v205 != v177)
      {
        int v207 = 1;
        while (v206 != -4096)
        {
          int v208 = v204 + v207++;
          uint64_t v204 = v208 & v203;
          uint64_t v206 = *(void *)&v202[16 * v204];
          if (v206 == v177) {
            goto LABEL_378;
          }
        }
        if (v200)
        {
          uint64_t v202 = v173;
          uint64_t v204 = 4;
        }
        else
        {
          uint64_t v202 = (char *)*((void *)v5 + 10);
          uint64_t v204 = *((unsigned int *)v5 + 22);
        }
        goto LABEL_378;
      }
LABEL_379:
      if (v200)
      {
        unsigned int v209 = v173;
        uint64_t v210 = 4;
      }
      else
      {
        unsigned int v209 = (char *)*((void *)v5 + 10);
        uint64_t v210 = *((unsigned int *)v5 + 22);
      }
      if (&v209[16 * v210] == v205) {
        unint64_t EstimatedLoopWeight = 0;
      }
      else {
        unint64_t EstimatedLoopWeight = *((unsigned int *)v205 + 2) | 0x100000000;
      }
      uint64_t v2 = v180;
LABEL_386:
      unint64_t v211 = HIDWORD(EstimatedLoopWeight);
      if (v191 == (void *)v16) {
        uint64_t v99 = 1;
      }
      else {
        uint64_t v99 = v18;
      }
      unsigned int v212 = EstimatedLoopWeight >> 8;
      if (v99)
      {
LABEL_390:
        if (v21 == -1 || v21 == v2) {
          goto LABEL_405;
        }
      }
      else
      {
        while (v191)
        {
          unint64_t v191 = (void *)*v191;
          if (v191 == (void *)v16) {
            goto LABEL_390;
          }
        }
      }
      uint64_t v99 = BYTE4(EstimatedLoopWeight);
      if (!BYTE4(EstimatedLoopWeight) || EstimatedLoopWeight)
      {
        unsigned int v213 = EstimatedLoopWeight / 0x1F;
        if (EstimatedLoopWeight / 0x1F <= 1) {
          unsigned int v213 = 1;
        }
        if (BYTE4(EstimatedLoopWeight)) {
          unsigned int v214 = v213;
        }
        else {
          unsigned int v214 = 33825;
        }
        unsigned int v212 = v214 >> 8;
        uint64_t v99 = 33;
        if (BYTE4(EstimatedLoopWeight)) {
          LOBYTE(EstimatedLoopWeight) = v214;
        }
        else {
          LOBYTE(EstimatedLoopWeight) = 33;
        }
        if (!BYTE4(EstimatedLoopWeight)) {
          unsigned int v212 = 132;
        }
      }
      LOBYTE(v211) = 1;
LABEL_405:
      unsigned int v215 = EstimatedLoopWeight | (v212 << 8);
      if (v18) {
        goto LABEL_445;
      }
      uint64_t v216 = v266;
      if (v267 == v266)
      {
        uint64_t v99 = (uint64_t)&v267[8 * HIDWORD(v268)];
        if (HIDWORD(v268))
        {
          uint64_t v217 = 0;
          while (*(void *)&v267[v217] != v177)
          {
            v217 += 8;
            if (8 * HIDWORD(v268) == v217) {
              goto LABEL_427;
            }
          }
          uint64_t v99 = (uint64_t)&v267[v217];
        }
LABEL_427:
        uint64_t v216 = v267;
      }
      else
      {
        int v218 = v268 - 1;
        unsigned int v219 = (v268 - 1) & (v182 ^ (v177 >> 9));
        uint64_t v99 = (uint64_t)&v267[8 * v219];
        uint64_t v220 = *(void *)v99;
        if (*(void *)v99 == -1)
        {
          uint64_t v221 = 0;
LABEL_433:
          if (v221) {
            uint64_t v99 = v221;
          }
          if (*(void *)v99 != v177) {
            uint64_t v99 = (uint64_t)&v267[8 * v268];
          }
        }
        else
        {
          uint64_t v221 = 0;
          int v222 = 1;
          while (v220 != v177)
          {
            if (v221) {
              BOOL v223 = 0;
            }
            else {
              BOOL v223 = v220 == -2;
            }
            if (v223) {
              uint64_t v221 = v99;
            }
            unsigned int v224 = v219 + v222++;
            unsigned int v219 = v224 & v218;
            uint64_t v99 = (uint64_t)&v267[8 * (v224 & v218)];
            uint64_t v220 = *(void *)v99;
            if (*(void *)v99 == -1) {
              goto LABEL_433;
            }
          }
        }
        uint64_t v175 = v265;
      }
      unint64_t v230 = v267 == v216 ? (uint64_t *)((char *)&v268 + 4) : &v268;
      if ((char *)v99 == &v267[8 * *(unsigned int *)v230])
      {
LABEL_445:
        uint64_t v4 = (v211 != 0) | v4;
        if ((_BYTE)v211) {
          unsigned int v231 = v215;
        }
        else {
          unsigned int v231 = 0xFFFFF;
        }
      }
      else
      {
        if (!(_BYTE)v211 || v215)
        {
          int v232 = v215 >> 1;
          if (v215 >> 1 <= 1) {
            int v232 = 1;
          }
          if ((_BYTE)v211) {
            unsigned int v231 = v232;
          }
          else {
            unsigned int v231 = 0x7FFFF;
          }
        }
        else
        {
          unsigned int v231 = 0;
        }
        uint64_t v4 = 1;
      }
      if (v282 >= (unint64_t)HIDWORD(v282)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v281 + v282) = v231;
      v172 += v231;
      unint64_t v233 = (v282 + 1);
      LODWORD(v282) = v282 + 1;
      if (++v171 == v175)
      {
        if ((v4 & (v172 != 0)) != 0)
        {
          if (HIDWORD(v172))
          {
            if (v233)
            {
              uint64_t v239 = 0;
              unint64_t v240 = v172 / 0xFFFFFFFF + 1;
              LODWORD(v172) = 0;
              do
              {
                unint64_t v241 = *(unsigned int *)((char *)v281 + v239) / v240;
                if (v241 <= 1) {
                  LODWORD(v241) = 1;
                }
                *(_DWORD *)((char *)v281 + v239) = v241;
                LODWORD(v172) = v172 + v241;
                v239 += 4;
              }
              while (4 * v233 != v239);
            }
            else
            {
              LODWORD(v172) = 0;
            }
          }
          uint64_t v278 = v280;
          unint64_t v279 = v3;
          sub_1CBF8EBE4((uint64_t)&v278, v233, -1);
          if (v233)
          {
            v242 = v281;
            unsigned int v243 = v278;
            do
            {
              unsigned int v245 = *(_DWORD *)v242;
              v242 = (uint64_t *)((char *)v242 + 4);
              unint64_t v244 = v245;
              if (v172 != 0x80000000) {
                unint64_t v244 = ((v172 >> 1) | (v244 << 31)) / v172;
              }
              *v243++ = v244;
              --v233;
            }
            while (v233);
          }
          llvm::BranchProbabilityInfo::setEdgeProbability((uint64_t)this, v252, (uint64_t *)&v278);
          if (v278 != v280) {
            free(v278);
          }
          uint64_t v248 = 1;
        }
        else
        {
          uint64_t v248 = 0;
        }
        uint64_t v99 = v254;
        goto LABEL_497;
      }
    }
    int v187 = 1;
    while (v186 != -4096)
    {
      int v188 = v185 + v187++;
      uint64_t v185 = v188 & v184;
      uint64_t v186 = *(void *)(v183 + 16 * v185);
      if (v186 == v177) {
        goto LABEL_347;
      }
    }
LABEL_350:
    uint64_t v192 = *((unsigned int *)v178 + 4);
    if (!v192)
    {
      BOOL v189 = 0;
      unint64_t v191 = 0;
      goto LABEL_366;
    }
    uint64_t v193 = *v178;
    LODWORD(v194) = (v192 - 1) & (v182 ^ (v177 >> 9));
    uint64_t v195 = (uint64_t *)(v193 + 16 * v194);
    uint64_t v196 = *v195;
    if (*v195 == v177)
    {
LABEL_356:
      if (v195 != (uint64_t *)(v193 + 16 * v192))
      {
        uint64_t v225 = *((unsigned int *)v195 + 2);
LABEL_359:
        BOOL v189 = 0;
        unint64_t v191 = 0;
        unint64_t v180 = v2 & 0xFFFFFFFF00000000 | v225;
        goto LABEL_366;
      }
    }
    else
    {
      int v197 = 1;
      while (v196 != -4096)
      {
        int v198 = v194 + v197++;
        uint64_t v194 = v198 & (v192 - 1);
        uint64_t v196 = *(void *)(v193 + 16 * v194);
        if (v196 == v177)
        {
          uint64_t v195 = (uint64_t *)(v193 + 16 * v194);
          goto LABEL_356;
        }
      }
    }
    uint64_t v225 = 0xFFFFFFFFLL;
    goto LABEL_359;
  }
  unsigned int v247 = 2;
  uint64_t v248 = 0;
  switch(v170)
  {
    case 0:
    case 5:
    case 6:
      break;
    case 1:
      goto LABEL_511;
    case 2:
      unsigned int v247 = (*(_DWORD *)(v98 + 20) >> 1) & 0x3FFFFFF;
      goto LABEL_504;
    case 3:
    case 9:
      goto LABEL_512;
    case 4:
      goto LABEL_337;
    case 7:
      unsigned int v247 = *(_WORD *)(v98 + 18) & 1;
      goto LABEL_504;
    case 8:
      unsigned int v247 = 1;
      goto LABEL_337;
    case 10:
      unsigned int v247 = *(_DWORD *)(v98 + 80) + 1;
      goto LABEL_504;
    default:
      goto LABEL_505;
  }
LABEL_497:
  if (v281 != (uint64_t *)v99) {
    free(v281);
  }
  if (v267 != v266) {
    free(v267);
  }
  return v248;
}

uint64_t llvm::BranchProbabilityInfo::calcZeroHeuristics(uint64_t a1, const llvm::BasicBlock *a2, uint64_t *a3)
{
  uint64_t v3 = (void *)*((void *)a2 + 5);
  if (v3 == (void *)((char *)a2 + 40)) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v6 = v3 - 3;
  if (!v3) {
    uint64_t v6 = 0;
  }
  unsigned int v7 = *((unsigned __int8 *)v6 + 16) - 40;
  if (v7 < 0xFFFFFFF5) {
    uint64_t v6 = 0;
  }
  if (v3)
  {
    if (*((unsigned char *)v6 + 16) == 30 && v7 >= 0xFFFFFFF5)
    {
      if ((*((_DWORD *)v6 + 5) & 0x7FFFFFF) != 3) {
        return 0;
      }
      uint64_t result = 0;
      uint64_t v9 = *(v6 - 12);
      if (!v9 || *(unsigned char *)(v9 + 16) != 81) {
        return result;
      }
      uint64_t v11 = *(void *)(v9 - 32);
      int v12 = *(unsigned __int8 *)(v11 + 16);
      if (v11 && v12 == 77)
      {
        uint64_t v11 = *(void *)(v11 - 32);
        int v12 = *(unsigned __int8 *)(v11 + 16);
      }
      if (v12 != 16) {
        return 0;
      }
      uint64_t v13 = *(void *)(v9 - 64);
      int v14 = *(unsigned __int8 *)(v13 + 16);
      if (v13 && v14 == 56)
      {
        int v15 = *(_DWORD *)(v13 + 20);
        if ((v15 & 0x40000000) != 0) {
          uint64_t v16 = *(void *)(v13 - 8);
        }
        else {
          uint64_t v16 = v13 - 32 * (v15 & 0x7FFFFFF);
        }
        BOOL v26 = *(int8x8_t **)(v16 + 32);
        int v27 = v26[2].u8[0];
        if (v26 && v27 == 77)
        {
          BOOL v26 = (int8x8_t *)v26[-4];
          int v27 = v26[2].u8[0];
        }
        if (v27 == 16)
        {
          uint64_t v28 = v26[4].u32[0];
          if (v28 > 0x40)
          {
            int v30 = 0;
            unint64_t v31 = (unint64_t)(v28 + 63) >> 6;
            uint64_t v32 = (int8x8_t *)v26[3];
            do
            {
              int8x8_t v33 = *v32++;
              uint8x8_t v34 = (uint8x8_t)vcnt_s8(v33);
              v34.i16[0] = vaddlv_u8(v34);
              v30 += v34.i32[0];
              --v31;
            }
            while (v31);
            if (v30 == 1) {
              return 0;
            }
          }
          else
          {
            uint8x8_t v29 = (uint8x8_t)vcnt_s8(v26[3]);
            v29.i16[0] = vaddlv_u8(v29);
            if (v29.u32[0] == 1) {
              return 0;
            }
          }
        }
      }
      else
      {
        int v56 = 468;
        if (v13) {
          BOOL v17 = a3 == 0;
        }
        else {
          BOOL v17 = 1;
        }
        if (!v17 && v14 == 84)
        {
          uint64_t v18 = *(void *)(v13 - 32);
          if (v18)
          {
            if (!*(unsigned char *)(v18 + 16) && *(void *)(v18 + 24) == *(void *)(v13 + 72))
            {
              if ((llvm::TargetLibraryInfoImpl::getLibFunc(*a3, (uint64_t ***)v18, &v56),
                    (v56 - 403) <= 0xD)
                && ((1 << (v56 + 109)) & 0x2809) != 0
                || v56 == 321
                || v56 == 168)
              {
                uint64_t v19 = qword_1EBCC4028;
                if (!qword_1EBCC4028) {
                  return 0;
                }
                unsigned int v20 = *(_WORD *)(v9 + 18) & 0x3F;
                uint64_t v21 = &qword_1EBCC4028;
                uint64_t v22 = &qword_1EBCC4028;
                do
                {
                  unsigned int v23 = *(_DWORD *)(v19 + 32);
                  BOOL v24 = v23 >= v20;
                  if (v23 >= v20) {
                    BOOL v25 = (uint64_t *)v19;
                  }
                  else {
                    BOOL v25 = (uint64_t *)(v19 + 8);
                  }
                  if (v24) {
                    uint64_t v22 = (uint64_t *)v19;
                  }
                  uint64_t v19 = *v25;
                }
                while (*v25);
                goto LABEL_99;
              }
            }
          }
        }
      }
      uint64_t v35 = (llvm::APInt *)(v11 + 24);
      uint64_t v36 = *(unsigned int *)(v11 + 32);
      if (v36 > 0x40)
      {
        int v38 = 0;
        int64_t v39 = (unint64_t)(v36 + 63) >> 6;
        do
        {
          if (v39-- < 1) {
            break;
          }
          unint64_t v41 = *(void *)(*(void *)v35 + 8 * v39);
          v38 += __clz(v41);
        }
        while (!v41);
        int v42 = v36 | 0xFFFFFFC0;
        if ((v36 & 0x3F) == 0) {
          int v42 = 0;
        }
        int v43 = v38 + v42;
        if (v43 != v36)
        {
          if (v43 != v36 - 1)
          {
            if (llvm::APInt::countTrailingOnesSlowCase(v35) != v36) {
              return 0;
            }
            goto LABEL_90;
          }
          goto LABEL_79;
        }
      }
      else
      {
        uint64_t v37 = *(void *)v35;
        if (*(void *)v35)
        {
          if (v37 != 1)
          {
            if (v36 && v37 != 0xFFFFFFFFFFFFFFFFLL >> -(char)v36) {
              return 0;
            }
LABEL_90:
            uint64_t v52 = qword_1EBCC3FF8;
            if (qword_1EBCC3FF8)
            {
              unsigned int v20 = *(_WORD *)(v9 + 18) & 0x3F;
              uint64_t v21 = &qword_1EBCC3FF8;
              uint64_t v22 = &qword_1EBCC3FF8;
              do
              {
                unsigned int v53 = *(_DWORD *)(v52 + 32);
                BOOL v54 = v53 >= v20;
                if (v53 >= v20) {
                  int v55 = (uint64_t *)v52;
                }
                else {
                  int v55 = (uint64_t *)(v52 + 8);
                }
                if (v54) {
                  uint64_t v22 = (uint64_t *)v52;
                }
                uint64_t v52 = *v55;
              }
              while (*v55);
              goto LABEL_99;
            }
            return 0;
          }
LABEL_79:
          uint64_t v48 = qword_1EBCC4010;
          if (!qword_1EBCC4010) {
            return 0;
          }
          unsigned int v20 = *(_WORD *)(v9 + 18) & 0x3F;
          uint64_t v21 = &qword_1EBCC4010;
          uint64_t v22 = &qword_1EBCC4010;
          do
          {
            unsigned int v49 = *(_DWORD *)(v48 + 32);
            BOOL v50 = v49 >= v20;
            if (v49 >= v20) {
              uint64_t v51 = (uint64_t *)v48;
            }
            else {
              uint64_t v51 = (uint64_t *)(v48 + 8);
            }
            if (v50) {
              uint64_t v22 = (uint64_t *)v48;
            }
            uint64_t v48 = *v51;
          }
          while (*v51);
          goto LABEL_99;
        }
      }
      uint64_t v44 = qword_1EBCC3FE0;
      if (!qword_1EBCC3FE0) {
        return 0;
      }
      unsigned int v20 = *(_WORD *)(v9 + 18) & 0x3F;
      uint64_t v21 = &qword_1EBCC3FE0;
      uint64_t v22 = &qword_1EBCC3FE0;
      do
      {
        unsigned int v45 = *(_DWORD *)(v44 + 32);
        BOOL v46 = v45 >= v20;
        if (v45 >= v20) {
          uint64_t v47 = (uint64_t *)v44;
        }
        else {
          uint64_t v47 = (uint64_t *)(v44 + 8);
        }
        if (v46) {
          uint64_t v22 = (uint64_t *)v44;
        }
        uint64_t v44 = *v47;
      }
      while (*v47);
LABEL_99:
      if (v22 != v21 && *((_DWORD *)v22 + 8) <= v20)
      {
        llvm::BranchProbabilityInfo::setEdgeProbability(a1, a2, v22 + 5);
        return 1;
      }
      return 0;
    }
  }
  return result;
}

uint64_t llvm::BranchProbabilityInfo::calcFloatingPointHeuristics(llvm::BranchProbabilityInfo *this, const llvm::BasicBlock *a2)
{
  v21[6] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (const llvm::BasicBlock *)*((void *)a2 + 5);
  if (v2 == (const llvm::BasicBlock *)((char *)a2 + 40)) {
    return 0;
  }
  uint64_t result = 0;
  int v5 = (char *)v2 - 24;
  if (!v2) {
    int v5 = 0;
  }
  unsigned int v6 = v5[16] - 40;
  if (v6 < 0xFFFFFFF5) {
    int v5 = 0;
  }
  if (v2)
  {
    if (v5[16] == 30 && v6 >= 0xFFFFFFF5)
    {
      if ((*((_DWORD *)v5 + 5) & 0x7FFFFFF) == 3)
      {
        uint64_t result = 0;
        uint64_t v8 = *((void *)v5 - 12);
        if (!v8 || *(unsigned char *)(v8 + 16) != 82) {
          return result;
        }
        uint64_t v19 = v21;
        uint64_t v20 = 0xC00000000;
        uint64_t v10 = &dword_1EBCC3FB4;
        uint64_t v11 = &dword_1EBCC3FB8;
        unsigned int v12 = *(_WORD *)(v8 + 18) & 0x3F;
        if ((int)v12 > 8)
        {
          if (v12 == 9)
          {
            uint64_t v11 = &dword_1EBCC3FB4;
            uint64_t v10 = &dword_1EBCC3FB8;
          }
          else if (v12 != 14)
          {
            goto LABEL_23;
          }
        }
        else if (v12 != 1 && v12 != 6)
        {
LABEL_23:
          uint64_t v14 = qword_1EBCC4040;
          if (!qword_1EBCC4040) {
            return 0;
          }
          int v15 = &qword_1EBCC4040;
          do
          {
            unsigned int v16 = *(_DWORD *)(v14 + 32);
            BOOL v17 = v16 >= v12;
            if (v16 >= v12) {
              uint64_t v18 = (uint64_t *)v14;
            }
            else {
              uint64_t v18 = (uint64_t *)(v14 + 8);
            }
            if (v17) {
              int v15 = (uint64_t *)v14;
            }
            uint64_t v14 = *v18;
          }
          while (*v18);
          if (v15 == &qword_1EBCC4040 || *((_DWORD *)v15 + 8) > v12) {
            return 0;
          }
          sub_1CD41B6B0((uint64_t)&v19, (uint64_t)(v15 + 5));
LABEL_38:
          llvm::BranchProbabilityInfo::setEdgeProbability((uint64_t)this, a2, (uint64_t *)&v19);
          if (v19 != v21) {
            free(v19);
          }
          return 1;
        }
        v21[0] = *v10 | ((unint64_t)*v11 << 32);
        LODWORD(v20) = 2;
        goto LABEL_38;
      }
      return 0;
    }
  }
  return result;
}

uint64_t *llvm::BranchProbabilityInfo::releaseMemory(llvm::BranchProbabilityInfo *this)
{
  sub_1CBF88DE0((_DWORD *)this + 6);

  return sub_1CBF8ECA0((uint64_t *)this);
}

_DWORD *sub_1CBF88DE0(_DWORD *result)
{
  char v1 = result;
  int v2 = result[2];
  if (v2)
  {
    unsigned int v3 = result[4];
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      int v4 = 1 << (33 - __clz(v2 - 1));
      if (v4 <= 64) {
        int v5 = 64;
      }
      else {
        int v5 = v4;
      }
LABEL_9:
      if (v5 == v3)
      {
        *((void *)result + 1) = 0;
        unsigned int v12 = *(_OWORD **)result;
        uint64_t v13 = 24 * v3;
        do
        {
          *unsigned int v12 = xmmword_1CFAC30E0;
          unsigned int v12 = (_OWORD *)((char *)v12 + 24);
          v13 -= 24;
        }
        while (v13);
      }
      else
      {
        uint64_t result = (_DWORD *)MEMORY[0x1D25D9CD0](*(void *)result, 8);
        if (v5)
        {
          unint64_t v6 = (4 * v5 / 3u + 1) | ((unint64_t)(4 * v5 / 3u + 1) >> 1);
          unint64_t v7 = v6 | (v6 >> 2) | ((v6 | (v6 >> 2)) >> 4);
          LODWORD(v7) = (((v7 | (v7 >> 8)) >> 16) | v7 | (v7 >> 8)) + 1;
          v1[4] = v7;
          uint64_t result = operator new(24 * v7, (std::align_val_t)8uLL);
          *(void *)char v1 = result;
          *((void *)v1 + 1) = 0;
          uint64_t v8 = v1[4];
          if (v8)
          {
            uint64_t v9 = 24 * v8;
            do
            {
              *(_OWORD *)uint64_t result = xmmword_1CFAC30E0;
              result += 6;
              v9 -= 24;
            }
            while (v9);
          }
        }
        else
        {
          *(void *)char v1 = 0;
          *((void *)v1 + 1) = 0;
          v1[4] = 0;
        }
      }
      return result;
    }
  }
  else
  {
    if (!result[3]) {
      return result;
    }
    unsigned int v3 = result[4];
    if (v3 > 0x40)
    {
      int v5 = 0;
      goto LABEL_9;
    }
  }
  if (v3)
  {
    uint64_t v10 = *(void *)result;
    uint64_t v11 = *(void *)result + 24 * v3;
    do
    {
      *(void *)uint64_t v10 = -4096;
      *(_DWORD *)(v10 + 8) = -1;
      v10 += 24;
    }
    while (v10 != v11);
  }
  *((void *)result + 1) = 0;
  return result;
}

BOOL llvm::BranchProbabilityInfo::invalidate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v18[0] = (void **)a3;
  v18[1] = (void **)&llvm::BranchProbabilityAnalysis::Key;
  uint64_t v4 = *(void *)(a3 + 48);
  uint64_t v3 = *(void *)(a3 + 56);
  if (v3 == v4)
  {
    uint64_t v5 = *(unsigned int *)(a3 + 68);
    unint64_t v6 = (void **)(v3 + 8 * v5);
    if (v5)
    {
      uint64_t v7 = 0;
      while (*(_UNKNOWN **)(v3 + v7) != &llvm::BranchProbabilityAnalysis::Key)
      {
        v7 += 8;
        if (8 * v5 == v7) {
          goto LABEL_6;
        }
      }
      unint64_t v6 = (void **)(v3 + v7);
    }
LABEL_6:
    uint64_t v4 = *(void *)(a3 + 56);
  }
  else
  {
    uint64_t v10 = *(unsigned int *)(a3 + 64);
    int v11 = v10 - 1;
    unsigned int v12 = (v10 - 1) & ((&llvm::BranchProbabilityAnalysis::Key >> 4) ^ (&llvm::BranchProbabilityAnalysis::Key >> 9));
    unint64_t v6 = (void **)(v3 + 8 * v12);
    uint64_t v13 = *v6;
    if (*v6 == (void *)-1)
    {
      uint64_t v14 = 0;
LABEL_27:
      if (v14) {
        unint64_t v6 = v14;
      }
      if (*v6 != &llvm::BranchProbabilityAnalysis::Key)
      {
        LODWORD(v5) = *(_DWORD *)(a3 + 68);
        unint64_t v6 = (void **)(v3 + 8 * v10);
        goto LABEL_7;
      }
    }
    else
    {
      uint64_t v14 = 0;
      int v15 = 1;
      while (v13 != &llvm::BranchProbabilityAnalysis::Key)
      {
        if (v14) {
          BOOL v16 = 0;
        }
        else {
          BOOL v16 = v13 == (void *)-2;
        }
        if (v16) {
          uint64_t v14 = v6;
        }
        unsigned int v17 = v12 + v15++;
        unsigned int v12 = v17 & v11;
        unint64_t v6 = (void **)(v3 + 8 * (v17 & v11));
        uint64_t v13 = *v6;
        if (*v6 == (void *)-1) {
          goto LABEL_27;
        }
      }
    }
    LODWORD(v5) = *(_DWORD *)(a3 + 68);
  }
LABEL_7:
  if (v3 == v4) {
    unsigned int v8 = v5;
  }
  else {
    unsigned int v8 = *(_DWORD *)(a3 + 64);
  }
  BOOL v19 = v6 != (void **)(v3 + 8 * v8);
  return !sub_1CBF75724(v18) && !sub_1CBF7593C((uint64_t)v18) && !sub_1CBF75B60((uint64_t)v18);
}

BOOL llvm::BranchProbabilityInfo::isEdgeHot(llvm::BranchProbabilityInfo *this, const llvm::BasicBlock *a2, const llvm::BasicBlock *a3)
{
  return llvm::BranchProbabilityInfo::getEdgeProbability((uint64_t)this, (uint64_t)a2, (uint64_t)a3) > 0x66666666;
}

uint64_t llvm::BranchProbabilityInfo::getEdgeProbability(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(_DWORD *)(a1 + 40);
  if (!v3) {
    goto LABEL_49;
  }
  uint64_t v4 = *(void *)(a1 + 24);
  unint64_t v5 = (unint64_t)((a2 >> 4) ^ (a2 >> 9)) << 32;
  unint64_t v6 = ((v5 - 1) ^ ((v5 - 1) >> 22)) + ~(((v5 - 1) ^ ((v5 - 1) >> 22)) << 13);
  unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
  int v8 = ((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27));
  unsigned int v9 = v3 - 1;
  unsigned int v10 = (v3 - 1) & v8;
  int v11 = (uint64_t *)(v4 + 24 * v10);
  uint64_t v12 = *v11;
  int v13 = *((_DWORD *)v11 + 2);
  if (v12 != a2 || v13 != 0)
  {
    int v15 = 1;
    while (v12 != -4096 || v13 != -1)
    {
      unsigned int v16 = v10 + v15++;
      unsigned int v10 = v16 & v9;
      unsigned int v17 = (uint64_t *)(v4 + 24 * v10);
      uint64_t v12 = *v17;
      int v13 = *((_DWORD *)v17 + 2);
      if (v12 == a2 && v13 == 0) {
        goto LABEL_14;
      }
    }
LABEL_49:
    uint64_t v46 = *(void *)(a2 + 40);
    if (v46 == a2 + 40)
    {
LABEL_93:
      unsigned int v57 = 0;
      LODWORD(result) = 0;
      return ((v57 >> 1) | ((unint64_t)result << 31)) / v57;
    }
    uint64_t v47 = v46 - 24;
    if (!v46) {
      uint64_t v47 = 0;
    }
    int v48 = *(unsigned __int8 *)(v47 + 16);
    if (v48 == 30)
    {
      if ((*(_DWORD *)(v47 + 20) & 0x7FFFFFF) == 3) {
        int v56 = 2;
      }
      else {
        int v56 = 1;
      }
    }
    else
    {
      int v56 = 2;
      uint64_t result = 0;
      switch(*(unsigned char *)(v47 + 16))
      {
        case 0x1D:
        case 0x22:
        case 0x23:
          goto LABEL_65;
        case 0x1E:
LABEL_92:
          __break(1u);
          goto LABEL_93;
        case 0x1F:
          int v56 = (*(_DWORD *)(v47 + 20) >> 1) & 0x3FFFFFF;
          break;
        case 0x20:
        case 0x26:
          int v56 = (*(_DWORD *)(v47 + 20) & 0x7FFFFFF) - 1;
          break;
        case 0x21:
          goto LABEL_57;
        case 0x24:
          int v56 = *(_WORD *)(v47 + 18) & 1;
          break;
        case 0x25:
          int v56 = 1;
          goto LABEL_57;
        case 0x27:
          int v56 = *(_DWORD *)(v47 + 80) + 1;
          break;
        default:
          goto LABEL_93;
      }
      if (!v56)
      {
        uint64_t result = 0;
LABEL_65:
        if (v48 != 30)
        {
          unsigned int v57 = 0;
          switch(*(unsigned char *)(v47 + 16))
          {
            case 0x1E:
              goto LABEL_92;
            case 0x1F:
              unsigned int v57 = (*(_DWORD *)(v47 + 20) >> 1) & 0x3FFFFFF;
              return ((v57 >> 1) | ((unint64_t)result << 31)) / v57;
            case 0x20:
            case 0x26:
              unsigned int v57 = (*(_DWORD *)(v47 + 20) & 0x7FFFFFF) - 1;
              return ((v57 >> 1) | ((unint64_t)result << 31)) / v57;
            case 0x21:
              unsigned int v57 = 2;
              return ((v57 >> 1) | ((unint64_t)result << 31)) / v57;
            case 0x24:
              unsigned int v57 = *(_WORD *)(v47 + 18) & 1;
              return ((v57 >> 1) | ((unint64_t)result << 31)) / v57;
            case 0x25:
              unsigned int v57 = 1;
              return ((v57 >> 1) | ((unint64_t)result << 31)) / v57;
            case 0x27:
              unsigned int v57 = *(_DWORD *)(v47 + 80) + 1;
              if (*(_DWORD *)(v47 + 80) != 0x7FFFFFFF) {
                return ((v57 >> 1) | ((unint64_t)result << 31)) / v57;
              }
              break;
            default:
              return ((v57 >> 1) | ((unint64_t)result << 31)) / v57;
          }
          return result;
        }
        if ((*(_DWORD *)(v47 + 20) & 0x7FFFFFF) == 3) {
          unsigned int v57 = 2;
        }
        else {
          unsigned int v57 = 1;
        }
        return ((v57 >> 1) | ((unint64_t)result << 31)) / v57;
      }
    }
LABEL_57:
    uint64_t v49 = 0;
    LODWORD(result) = 0;
    BOOL v50 = (uint64_t *)(v47 - 32);
    do
    {
      uint64_t v51 = v50;
      if (v48 != 30)
      {
        uint64_t v51 = (uint64_t *)(v47 - 32);
        switch(*(unsigned char *)(v47 + 16))
        {
          case ' ':
          case '&':
            int v61 = *(_DWORD *)(v47 + 20);
            if ((v61 & 0x40000000) != 0) {
              uint64_t v62 = *(void *)(v47 - 8);
            }
            else {
              uint64_t v62 = v47 - 32 * (v61 & 0x7FFFFFF);
            }
            uint64_t v55 = v62 + 32 * v49;
            goto LABEL_76;
          case '!':
            uint64_t v63 = -64;
            if (!v49) {
              uint64_t v63 = -96;
            }
            uint64_t v51 = (uint64_t *)(v47 + v63);
            break;
          case '""':
          case '#':
            goto LABEL_92;
          case '$':
            if ((*(_WORD *)(v47 + 18) & 1) == 0)
            {
              uint64_t v52 = 0;
              goto LABEL_61;
            }
            uint64_t v55 = v47 - 32 * (*(_DWORD *)(v47 + 20) & 0x7FFFFFF);
LABEL_76:
            uint64_t v51 = (uint64_t *)(v55 + 32);
            break;
          case '%':
            break;
          case '\'':
            if (v49) {
              uint64_t v51 = (uint64_t *)(v47 - 32 - 32 * *(unsigned int *)(v47 + 80) + 32 * (v49 - 1));
            }
            else {
              uint64_t v51 = (uint64_t *)(v47 - 32 * *(unsigned int *)(v47 + 80) - 64);
            }
            break;
          default:
            int v53 = *(_DWORD *)(v47 + 20);
            if ((v53 & 0x40000000) != 0) {
              uint64_t v54 = *(void *)(v47 - 8);
            }
            else {
              uint64_t v54 = v47 - 32 * (v53 & 0x7FFFFFF);
            }
            uint64_t v55 = v54 + (v49 << 6);
            goto LABEL_76;
        }
      }
      uint64_t v52 = *v51;
LABEL_61:
      if (v52 == a3) {
        uint64_t result = (result + 1);
      }
      else {
        uint64_t result = result;
      }
      ++v49;
      v50 -= 4;
    }
    while (v56 != v49);
    goto LABEL_65;
  }
LABEL_14:
  uint64_t v19 = *(void *)(a2 + 40);
  if (v19 == a2 + 40) {
    return 0;
  }
  if (v19) {
    uint64_t v20 = v19 - 24;
  }
  else {
    uint64_t v20 = 0;
  }
  int v21 = *(unsigned __int8 *)(v20 + 16);
  int v22 = v21 - 29;
  if ((v21 - 29) >= 0xB) {
    uint64_t v23 = 0;
  }
  else {
    uint64_t v23 = v20;
  }
  if (v21 != 30)
  {
    int v24 = 2;
    uint64_t result = 0;
    switch(v22)
    {
      case 0:
      case 5:
      case 6:
        return result;
      case 1:
        goto LABEL_92;
      case 2:
        int v24 = (*(_DWORD *)(v20 + 20) >> 1) & 0x3FFFFFF;
        goto LABEL_90;
      case 3:
      case 9:
        int v24 = (*(_DWORD *)(v20 + 20) & 0x7FFFFFF) - 1;
        goto LABEL_90;
      case 4:
        goto LABEL_25;
      case 7:
        int v24 = *(_WORD *)(v20 + 18) & 1;
        goto LABEL_90;
      case 8:
        int v24 = 1;
        goto LABEL_25;
      case 10:
        int v24 = *(_DWORD *)(v20 + 80) + 1;
LABEL_90:
        if (!v24) {
          return 0;
        }
        goto LABEL_25;
      default:
        return 0;
    }
  }
  if ((*(_DWORD *)(v20 + 20) & 0x7FFFFFF) == 3) {
    int v24 = 2;
  }
  else {
    int v24 = 1;
  }
LABEL_25:
  unsigned int v25 = 0;
  int v26 = 0;
  uint64_t result = 0;
  uint64_t v28 = v20 - 32;
  uint8x8_t v29 = (uint64_t *)(v4 + 24 * v3);
  do
  {
    if (*(unsigned char *)(v20 + 16) == 30)
    {
      int v30 = (uint64_t *)(v28 - 32 * v25);
    }
    else
    {
      int v30 = (uint64_t *)(v20 - 32);
      switch(*(unsigned char *)(v20 + 16))
      {
        case ' ':
        case '&':
          int v64 = *(_DWORD *)(v20 + 20);
          if ((v64 & 0x40000000) != 0) {
            uint64_t v59 = *(void *)(v20 - 8);
          }
          else {
            uint64_t v59 = v23 - 32 * (v64 & 0x7FFFFFF);
          }
          uint64_t v60 = v25 + 1;
          goto LABEL_87;
        case '!':
          uint64_t v65 = -64;
          if (!v25) {
            uint64_t v65 = -96;
          }
          int v30 = (uint64_t *)(v23 + v65);
          break;
        case '""':
        case '#':
          goto LABEL_92;
        case '$':
          if ((*(_WORD *)(v20 + 18) & 1) == 0)
          {
            uint64_t v31 = 0;
            goto LABEL_29;
          }
          int v30 = (uint64_t *)(v20 - 32 * (*(_DWORD *)(v20 + 20) & 0x7FFFFFF) + 32);
          break;
        case '%':
          break;
        case '\'':
          if (v25) {
            int v30 = (uint64_t *)(v28 - 32 * *(unsigned int *)(v20 + 80) + 32 * (v25 - 1));
          }
          else {
            int v30 = (uint64_t *)(v20 - 32 * *(unsigned int *)(v20 + 80) - 64);
          }
          break;
        default:
          int v58 = *(_DWORD *)(v20 + 20);
          if ((v58 & 0x40000000) != 0) {
            uint64_t v59 = *(void *)(v20 - 8);
          }
          else {
            uint64_t v59 = v23 - 32 * (v58 & 0x7FFFFFF);
          }
          uint64_t v60 = (2 * v25) | 1;
LABEL_87:
          int v30 = (uint64_t *)(v59 + 32 * v60);
          break;
      }
    }
    uint64_t v31 = *v30;
LABEL_29:
    if (v31 == a3)
    {
      unint64_t v32 = ((37 * v26) | v5) + ~((unint64_t)(37 * v26) << 32);
      unint64_t v33 = (v32 ^ (v32 >> 22)) + ~((v32 ^ (v32 >> 22)) << 13);
      unint64_t v34 = (9 * (v33 ^ (v33 >> 8))) ^ ((9 * (v33 ^ (v33 >> 8))) >> 15);
      unsigned int v35 = v9 & (((v34 + ~(v34 << 27)) >> 31) ^ (v34 + ~(v34 << 27)));
      uint64_t v36 = (uint64_t *)(v4 + 24 * v35);
      uint64_t v37 = *v36;
      int v38 = *((_DWORD *)v36 + 2);
      if (*v36 != a2 || v38 != v25)
      {
        int v40 = 1;
        while (v37 != -4096 || v38 != -1)
        {
          unsigned int v41 = v35 + v40++;
          unsigned int v35 = v41 & v9;
          uint64_t v36 = (uint64_t *)(v4 + 24 * v35);
          uint64_t v37 = *v36;
          int v38 = *((_DWORD *)v36 + 2);
          if (*v36 == a2 && v38 == v25) {
            goto LABEL_44;
          }
        }
        uint64_t v36 = v29;
      }
LABEL_44:
      uint64_t v43 = *((unsigned int *)v36 + 4);
      unint64_t v44 = v43 + result;
      unsigned int v45 = v43 + result;
      if (v44 <= 0x80000000) {
        uint64_t result = v45;
      }
      else {
        uint64_t result = 0x80000000;
      }
    }
    unsigned int v25 = ++v26;
  }
  while (v24 != v26);
  return result;
}

uint64_t llvm::BranchProbabilityInfo::getEdgeProbability(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 24);
  unsigned int v4 = *(_DWORD *)(a1 + 40);
  if (!v4)
  {
LABEL_15:
    unsigned int v9 = (uint64_t *)(v3 + 24 * v4);
    goto LABEL_16;
  }
  unint64_t v5 = ~((unint64_t)(37 * a3) << 32)
     + (37 * a3)
     + ((unint64_t)((a2 >> 4) ^ (a2 >> 9)) << 32);
  unint64_t v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
  unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
  unsigned int v8 = (v4 - 1) & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27)));
  unsigned int v9 = (uint64_t *)(v3 + 24 * v8);
  uint64_t v10 = *v9;
  int v11 = *((_DWORD *)v9 + 2);
  if (*v9 != a2 || v11 != a3)
  {
    int v13 = 1;
    while (v10 != -4096 || v11 != -1)
    {
      unsigned int v14 = v8 + v13++;
      unsigned int v8 = v14 & (v4 - 1);
      unsigned int v9 = (uint64_t *)(v3 + 24 * v8);
      uint64_t v10 = *v9;
      int v11 = *((_DWORD *)v9 + 2);
      if (*v9 == a2 && v11 == a3) {
        goto LABEL_16;
      }
    }
    goto LABEL_15;
  }
LABEL_16:
  if (v9 != (uint64_t *)(v3 + 24 * v4)) {
    return *((unsigned int *)v9 + 4);
  }
  uint64_t v16 = *(void *)(a2 + 40);
  if (v16 == a2 + 40)
  {
LABEL_28:
    unsigned int v20 = 0;
  }
  else
  {
    uint64_t v17 = v16 - 24;
    if (!v16) {
      uint64_t v17 = 0;
    }
    int v18 = *(unsigned __int8 *)(v17 + 16);
    int v19 = v18 - 29;
    if (v18 != 30)
    {
      unsigned int v20 = 0;
      switch(v19)
      {
        case 0:
        case 5:
        case 6:
          return ((v20 >> 1) | 0x80000000) / v20;
        case 1:
          __break(1u);
          goto LABEL_30;
        case 2:
          unsigned int v20 = (*(_DWORD *)(v17 + 20) >> 1) & 0x3FFFFFF;
          return ((v20 >> 1) | 0x80000000) / v20;
        case 3:
        case 9:
LABEL_30:
          unsigned int v20 = (*(_DWORD *)(v17 + 20) & 0x7FFFFFF) - 1;
          return ((v20 >> 1) | 0x80000000) / v20;
        case 4:
          unsigned int v20 = 2;
          return ((v20 >> 1) | 0x80000000) / v20;
        case 7:
          unsigned int v20 = *(_WORD *)(v17 + 18) & 1;
          return ((v20 >> 1) | 0x80000000) / v20;
        case 8:
          unsigned int v20 = 1;
          return ((v20 >> 1) | 0x80000000) / v20;
        case 10:
          unsigned int v20 = *(_DWORD *)(v17 + 80) + 1;
          if (*(_DWORD *)(v17 + 80) != 0x7FFFFFFF) {
            return ((v20 >> 1) | 0x80000000) / v20;
          }
          return 1;
        default:
          goto LABEL_28;
      }
    }
    if ((*(_DWORD *)(v17 + 20) & 0x7FFFFFF) == 3) {
      unsigned int v20 = 2;
    }
    else {
      unsigned int v20 = 1;
    }
  }
  return ((v20 >> 1) | 0x80000000) / v20;
}

uint64_t llvm::BranchProbabilityInfo::getEdgeProbability(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return llvm::BranchProbabilityInfo::getEdgeProbability(a1, a2, a4);
}

uint64_t llvm::BranchProbabilityInfo::eraseBlock(uint64_t this, const llvm::BasicBlock *a2)
{
  uint64_t v3 = (int32x2_t *)this;
  uint64_t v57 = 2;
  int v58 = 0;
  uint64_t v59 = a2;
  unsigned int v4 = a2;
  if (a2 != (const llvm::BasicBlock *)-8192)
  {
    unsigned int v4 = a2;
    if (a2 != (const llvm::BasicBlock *)-4096)
    {
      unsigned int v4 = a2;
      if (a2)
      {
        this = (uint64_t)llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v57);
        unsigned int v4 = v59;
      }
    }
  }
  uint64_t v60 = v3;
  __int32 v5 = v3[2].i32[0];
  if (!v5) {
    goto LABEL_21;
  }
  __int32 v6 = v5 - 1;
  unsigned int v7 = ((v4 >> 4) ^ (v4 >> 9)) & (v5 - 1);
  unsigned int v8 = (void *)(*(void *)v3 + 40 * v7);
  unsigned int v9 = (const llvm::BasicBlock *)v8[3];
  if (v9 == v4)
  {
LABEL_10:
    v62[0] = 2;
    v62[1] = 0;
    uint64_t v12 = -8192;
    uint64_t v63 = -8192;
    uint64_t v64 = 0;
    int v61 = &unk_1F2601308;
    if (v4 != (const llvm::BasicBlock *)-4096 && v4)
    {
      if (v4 == (const llvm::BasicBlock *)-8192)
      {
LABEL_19:
        void v8[4] = v64;
        if (v12 != -8192 && v12 != -4096 && v12 != 0) {
          this = (uint64_t)llvm::ValueHandleBase::RemoveFromUseList(v62);
        }
        v3[1] = vadd_s32(v3[1], (int32x2_t)0x1FFFFFFFFLL);
        unsigned int v4 = v59;
        goto LABEL_21;
      }
      unint64_t v44 = v8[1] & 0xFFFFFFFFFFFFFFF8;
      *(void *)unint64_t v44 = v8[2];
      unsigned int v45 = (unint64_t *)v8[2];
      if (v45)
      {
        *unsigned int v45 = *v45 & 7 | v44;
      }
      else
      {
        uint64_t v46 = v8[3];
        uint64_t v47 = ***(int32x2_t ****)v46;
        unint64_t v48 = (unint64_t)v47[303];
        if (v48 <= v44)
        {
          uint64_t v49 = v47[305].u32[0];
          if (v48 + 16 * v49 > v44)
          {
            unsigned int v50 = v49 - 1;
            LODWORD(v51) = v50 & ((v46 >> 4) ^ (v46 >> 9));
            uint64_t v52 = (uint64_t *)(v48 + 16 * v51);
            uint64_t v53 = *v52;
            if (v46 == *v52)
            {
LABEL_62:
              *uint64_t v52 = -8192;
              v47[304] = vadd_s32(v47[304], (int32x2_t)0x1FFFFFFFFLL);
              uint64_t v46 = v8[3];
            }
            else
            {
              int v54 = 1;
              while (v53 != -4096)
              {
                int v55 = v51 + v54++;
                uint64_t v51 = v55 & v50;
                uint64_t v53 = *(void *)(v48 + 16 * v51);
                if (v46 == v53)
                {
                  uint64_t v52 = (uint64_t *)(v48 + 16 * v51);
                  goto LABEL_62;
                }
              }
            }
            *(unsigned char *)(v46 + 17) &= ~1u;
          }
        }
      }
      uint64_t v12 = v63;
    }
    v8[3] = v12;
    if (v12 != -4096 && v12 != -8192 && v12 != 0)
    {
      uint64_t v14 = v62[0];
      int v15 = (void *)(v62[0] & 0xFFFFFFFFFFFFFFF8);
      v8[2] = *(void *)(v62[0] & 0xFFFFFFFFFFFFFFF8);
      *int v15 = v8 + 1;
      v8[1] = v14 & 0xFFFFFFFFFFFFFFF8 | v8[1] & 7;
      uint64_t v16 = (unint64_t *)v8[2];
      if (v16) {
        *uint64_t v16 = *v16 & 7 | (unint64_t)(v8 + 2);
      }
      uint64_t v12 = v63;
    }
    goto LABEL_19;
  }
  int v10 = 1;
  while (v9 != (const llvm::BasicBlock *)-4096)
  {
    unsigned int v11 = v7 + v10++;
    unsigned int v7 = v11 & v6;
    unsigned int v8 = (void *)(*(void *)v3 + 40 * (v11 & v6));
    unsigned int v9 = (const llvm::BasicBlock *)v8[3];
    if (v9 == v4) {
      goto LABEL_10;
    }
  }
LABEL_21:
  if (v4 != (const llvm::BasicBlock *)-8192 && v4 != (const llvm::BasicBlock *)-4096 && v4)
  {
    unint64_t v17 = v57 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v57 & 0xFFFFFFFFFFFFFFF8) = v58;
    if (v58)
    {
      *int v58 = *v58 & 7 | v17;
    }
    else
    {
      int v18 = v59;
      int v19 = ***(int32x2_t ****)v59;
      unint64_t v20 = (unint64_t)v19[303];
      if (v20 <= v17)
      {
        uint64_t v21 = v19[305].u32[0];
        if (v20 + 16 * v21 > v17)
        {
          unsigned int v22 = v21 - 1;
          LODWORD(v23) = v22 & ((v59 >> 4) ^ (v59 >> 9));
          int v24 = (const llvm::BasicBlock **)(v20 + 16 * v23);
          unsigned int v25 = *v24;
          if (v59 == *v24)
          {
LABEL_32:
            *int v24 = (const llvm::BasicBlock *)-8192;
            v19[304] = vadd_s32(v19[304], (int32x2_t)0x1FFFFFFFFLL);
            int v18 = v59;
          }
          else
          {
            int v26 = 1;
            while (v25 != (const llvm::BasicBlock *)-4096)
            {
              int v27 = v23 + v26++;
              uint64_t v23 = v27 & v22;
              unsigned int v25 = *(const llvm::BasicBlock **)(v20 + 16 * v23);
              if (v59 == v25)
              {
                int v24 = (const llvm::BasicBlock **)(v20 + 16 * v23);
                goto LABEL_32;
              }
            }
          }
          *((unsigned char *)v18 + 17) &= ~1u;
        }
      }
    }
  }
  unsigned __int32 v28 = v3[5].u32[0];
  if (v28)
  {
    int v29 = 0;
    int32x2_t v30 = v3[3];
    uint64_t v31 = *(void *)&v30 + 24 * v28;
    unsigned __int32 v32 = v28 - 1;
    this = 4294967294;
    while (1)
    {
      unint64_t v33 = (((unint64_t)((a2 >> 4) ^ (a2 >> 9)) << 32) | (37 * v29))
          + ~((unint64_t)(37 * v29) << 32);
      unint64_t v34 = (v33 ^ (v33 >> 22)) + ~((v33 ^ (v33 >> 22)) << 13);
      unint64_t v35 = (9 * (v34 ^ (v34 >> 8))) ^ ((9 * (v34 ^ (v34 >> 8))) >> 15);
      unsigned int v36 = v32 & (((v35 + ~(v35 << 27)) >> 31) ^ (v35 + ~(v35 << 27)));
      uint64_t v37 = *(void *)&v30 + 24 * v36;
      int v38 = *(const llvm::BasicBlock **)v37;
      int v39 = *(_DWORD *)(v37 + 8);
      if (*(const llvm::BasicBlock **)v37 != a2 || v29 != v39) {
        break;
      }
LABEL_49:
      if (v37 == v31) {
        return this;
      }
      *(void *)uint64_t v37 = -8192;
      *(_DWORD *)(v37 + 8) = -2;
      v3[4] = vadd_s32(v3[4], (int32x2_t)0x1FFFFFFFFLL);
      ++v29;
    }
    int v41 = 1;
    while (v38 != (const llvm::BasicBlock *)-4096 || v39 != -1)
    {
      unsigned int v42 = v36 + v41++;
      unsigned int v36 = v42 & v32;
      uint64_t v37 = *(void *)&v30 + 24 * v36;
      int v38 = *(const llvm::BasicBlock **)v37;
      int v39 = *(_DWORD *)(v37 + 8);
      if (*(const llvm::BasicBlock **)v37 == a2 && v29 == v39) {
        goto LABEL_49;
      }
    }
  }
  return this;
}

void llvm::BranchProbabilityInfo::calculate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + ++*(_DWORD *)(result + 48) = a2;
  *(void *)(a1 + 56) = a3;
  operator new();
}

void sub_1CBF8A668(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  v13[24] = *MEMORY[0x1E4F143B8];
  sub_1CBF7B63C((llvm::SmallPtrSetImplBase *)&v10, *a1);
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  v7[0] = 0;
  memset(v6, 0, sizeof(v6));
  uint64_t v3 = (char *)v6 + 8;
  unsigned int v4 = (char *)v6 + 8;
  uint64_t v5 = 8;
  v7[1] = (char *)v8 + 8;
  DWORD1(v8[0]) = 8;
  sub_1CBF90054((uint64_t)&v10, (uint64_t)&v3, a2);
  if (v7[1] != (char *)v8 + 8) {
    free(v7[1]);
  }
  if (v4 != v3) {
    free(v4);
  }
  if (v12 != v13) {
    free(v12);
  }
  if (v11 != v10) {
    free(v11);
  }
}

void llvm::BranchProbabilityInfoWrapperPass::runOnFunction(llvm::BranchProbabilityInfoWrapperPass *this, llvm::Function *a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = (uint64_t *)*((void *)this + 1);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_4:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::LoopInfoWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_4;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  (*(void (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::LoopInfoWrapperPass::ID);
  unsigned int v8 = (uint64_t *)*((void *)this + 1);
  uint64_t v9 = *v8;
  uint64_t v10 = v8[1];
  if (v9 == v10)
  {
LABEL_9:
    uint64_t v11 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v9 != &llvm::TargetLibraryInfoWrapperPass::ID)
    {
      v9 += 16;
      if (v9 == v10) {
        goto LABEL_9;
      }
    }
    uint64_t v11 = *(void *)(v9 + 8);
  }
  uint64_t v12 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v11 + 96))(v11, &llvm::TargetLibraryInfoWrapperPass::ID);
  uint64_t v13 = v12 + 32;
  if (!*(unsigned char *)(v12 + 232))
  {
    uint64_t v14 = *((void *)a2 + 5) + 216;
    __int16 v17 = 260;
    v16[0] = v14;
    llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v16);
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    int v29 = 0;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    *(void *)&long long v15 = -1;
    *((void *)&v15 + 1) = -1;
    *(_OWORD *)__src = v15;
    long long v21 = v15;
    long long v22 = v15;
    long long v23 = v15;
    long long v24 = v15;
    long long v25 = v15;
    *(_OWORD *)int v26 = v15;
    *(void *)&v26[13] = -1;
    sub_1CC153974((uint64_t)__src, (int *)__p);
    sub_1CD4D04B8(v13, (uint64_t)__src);
    sub_1CD4CFA4C((uint64_t *)__src);
    if (v19 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_1CC1569E8(__src, v13);
}

uint64_t *llvm::BranchProbabilityInfoWrapperPass::releaseMemory(llvm::BranchProbabilityInfoWrapperPass *this)
{
  char v1 = (uint64_t *)((char *)this + 32);
  sub_1CBF88DE0((_DWORD *)this + 14);

  return sub_1CBF8ECA0(v1);
}

void llvm::BranchProbabilityAnalysis::run(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + ++*(_DWORD *)(result + 48) = 0;
  *(void *)(a1 + 72) = 1;
  for (uint64_t i = 80; i != 144; i += 16)
    *(void *)(a1 + i) = -4096;
  *(void *)(a1 + 144) = 1;
  for (uint64_t j = 152; j != 248; j += 24)
    *(_OWORD *)(a1 + j) = xmmword_1CFAC30D0;
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

void *sub_1CBF8AD4C(void *result)
{
  result[1] = 0;
  v10[0] = 2;
  v10[1] = 0;
  uint64_t v11 = -4096;
  uint64_t v12 = 0;
  uint64_t v1 = *((unsigned int *)result + 4);
  if (v1)
  {
    int v2 = result;
    uint64_t result = v10;
    uint64_t v3 = *v2;
    uint64_t v4 = 40 * v1;
    uint64_t v5 = (void *)(*v2 + 16);
    do
    {
      uint64_t v6 = v10[0] & 6;
      *(v5 - 1) = v6;
      *uint64_t v5 = 0;
      uint64_t v7 = v11;
      v5[1] = v11;
      if (v7 != -4096 && v7 != -8192 && v7 != 0)
      {
        unint64_t v9 = v10[0] & 0xFFFFFFFFFFFFFFF8;
        *uint64_t v5 = *(void *)(v10[0] & 0xFFFFFFFFFFFFFFF8);
        *(void *)unint64_t v9 = v5 - 1;
        *(v5 - 1) = v9 | v6;
        if (*v5) {
          *(void *)*uint64_t v5 = *(void *)*v5 & 7 | (v3 + 16);
        }
      }
      *(v5 - 2) = &unk_1F2601308;
      void v5[2] = v12;
      v5 += 5;
      v3 += 40;
      v4 -= 40;
    }
    while (v4);
    if (v11 != -8192 && v11 != -4096)
    {
      if (v11) {
        return llvm::ValueHandleBase::RemoveFromUseList(v10);
      }
    }
  }
  return result;
}

uint64_t sub_1CBF8AE80(uint64_t a1)
{
  return llvm::BranchProbabilityInfo::eraseBlock(*(void *)(a1 + 32), *(const llvm::BasicBlock **)(a1 + 24));
}

void *sub_1CBF8AE8C(void *a1, unsigned int a2)
{
  if (a2 <= 4)
  {
    *a1 = 1;
LABEL_3:
    uint64_t result = a1 + 1;
    uint64_t v4 = a1 + 9;
    goto LABEL_4;
  }
  *(_DWORD *)a1 &= ~1u;
  uint64_t v5 = a2;
  uint64_t result = operator new(16 * a2, (std::align_val_t)8uLL);
  a1[1] = result;
  a1[2] = v5;
  int v6 = *(_DWORD *)a1;
  *a1 = *(_DWORD *)a1 & 1;
  if (v6) {
    goto LABEL_3;
  }
  uint64_t v4 = &result[2 * v5];
  do
  {
LABEL_4:
    *uint64_t result = -4096;
    result += 2;
  }
  while (result != v4);
  return result;
}

uint64_t sub_1CBF8AF10(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 144) & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 152), 8);
  }
  if ((*(unsigned char *)(a1 + 72) & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 80), 8);
  }
  int v2 = *(void **)(a1 + 64);
  *(void *)(a1 + 64) = 0;
  if (v2)
  {
    long long v21 = sub_1CBF8FEAC(v2);
    MEMORY[0x1D25D9CE0](v21, 0x1020C400B2C5FE4);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 24), 8);
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void **)a1;
  if (v3)
  {
    v27[0] = 2;
    v27[1] = 0;
    uint64_t v28 = -4096;
    uint64_t v29 = 0;
    uint64_t v25 = 0;
    int v26 = &unk_1F2601308;
    v23[0] = 2;
    v23[1] = 0;
    uint64_t v24 = -8192;
    int v6 = &v4[5 * v3];
    do
    {
      uint64_t v7 = v4[3];
      if (v7 != -4096 && v7 != -8192 && v7 != 0)
      {
        unint64_t v9 = v4[1] & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v9 = v4[2];
        uint64_t v10 = (unint64_t *)v4[2];
        if (v10)
        {
          *uint64_t v10 = *v10 & 7 | v9;
        }
        else
        {
          uint64_t v11 = v4[3];
          uint64_t v12 = ***(int32x2_t ****)v11;
          unint64_t v13 = (unint64_t)v12[303];
          if (v13 <= v9)
          {
            uint64_t v14 = v12[305].u32[0];
            if (v13 + 16 * v14 > v9)
            {
              unsigned int v15 = v14 - 1;
              LODWORD(v16) = v15 & ((v11 >> 4) ^ (v11 >> 9));
              __int16 v17 = (uint64_t *)(v13 + 16 * v16);
              uint64_t v18 = *v17;
              if (v11 == *v17)
              {
LABEL_25:
                *__int16 v17 = -8192;
                v12[304] = vadd_s32(v12[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v11 = v4[3];
              }
              else
              {
                int v19 = 1;
                while (v18 != -4096)
                {
                  int v20 = v16 + v19++;
                  uint64_t v16 = v20 & v15;
                  uint64_t v18 = *(void *)(v13 + 16 * v16);
                  if (v11 == v18)
                  {
                    __int16 v17 = (uint64_t *)(v13 + 16 * v16);
                    goto LABEL_25;
                  }
                }
              }
              *(unsigned char *)(v11 + 17) &= ~1u;
            }
          }
        }
      }
      v4 += 5;
    }
    while (v4 != v6);
    if (v24 != -8192 && v24 != -4096 && v24 != 0) {
      llvm::ValueHandleBase::RemoveFromUseList(v23);
    }
    if (v28 != -4096 && v28 != -8192 && v28) {
      llvm::ValueHandleBase::RemoveFromUseList(v27);
    }
    uint64_t v4 = *(void **)a1;
  }
  MEMORY[0x1D25D9CD0](v4, 8);
  return a1;
}

uint64_t *sub_1CBF8B16C(uint64_t *result, uint64_t *a2, unsigned int a3, _DWORD *a4)
{
  uint64_t v5 = a2;
  int v6 = result;
  uint64_t v7 = (uint64_t **)(result + 1);
  if (result + 1 != a2)
  {
    unsigned int v17 = *((_DWORD *)a2 + 8);
    if (v17 <= a3)
    {
      if (v17 >= a3) {
        return result;
      }
      uint64_t v12 = a2 + 1;
      uint64_t v18 = (uint64_t *)a2[1];
      if (v18)
      {
        do
        {
          uint64_t v12 = v18;
          uint64_t v18 = (uint64_t *)*v18;
          uint64_t v5 = v12;
          int v19 = v12;
        }
        while (v18);
      }
      else
      {
        int v19 = a2;
        do
        {
          long long v22 = v19;
          int v19 = (uint64_t *)v19[2];
        }
        while ((uint64_t *)*v19 != v22);
      }
      if (v19 != (uint64_t *)v7 && *((_DWORD *)v19 + 8) <= a3)
      {
        long long v23 = *v7;
        uint64_t v12 = result + 1;
        uint64_t v5 = result + 1;
        if (*v7)
        {
          while (1)
          {
            while (1)
            {
              uint64_t v5 = v23;
              unsigned int v24 = *((_DWORD *)v23 + 8);
              if (v24 <= a3) {
                break;
              }
              long long v23 = (uint64_t *)*v23;
              uint64_t v12 = v5;
              if (!*v5) {
                goto LABEL_15;
              }
            }
            if (v24 >= a3) {
              return result;
            }
            long long v23 = (uint64_t *)v23[1];
            if (!v23) {
              goto LABEL_46;
            }
          }
        }
      }
      goto LABEL_15;
    }
  }
  uint64_t v8 = *a2;
  unint64_t v9 = a2;
  if ((uint64_t *)*result == a2) {
    goto LABEL_7;
  }
  if (v8)
  {
    uint64_t v10 = (uint64_t *)*a2;
    do
    {
      unint64_t v9 = v10;
      uint64_t v10 = (uint64_t *)v10[1];
    }
    while (v10);
  }
  else
  {
    int v20 = a2;
    do
    {
      unint64_t v9 = (uint64_t *)v20[2];
      BOOL v21 = *v9 == (void)v20;
      int v20 = v9;
    }
    while (v21);
  }
  if (*((_DWORD *)v9 + 8) < a3)
  {
LABEL_7:
    if (v8) {
      uint64_t v11 = v9;
    }
    else {
      uint64_t v11 = a2;
    }
    if (v8) {
      uint64_t v12 = v9 + 1;
    }
    else {
      uint64_t v12 = a2;
    }
    if (*v12) {
      return result;
    }
    uint64_t v5 = v11;
    goto LABEL_15;
  }
  unsigned int v15 = *v7;
  uint64_t v12 = result + 1;
  uint64_t v5 = result + 1;
  if (!*v7)
  {
LABEL_15:
    unint64_t v13 = operator new(0x68uLL);
    v13[8] = *a4;
    *((void *)v13 + 5) = v13 + 14;
    *((void *)v13 + 6) = 0xC00000000;
    if (a4[4]) {
      sub_1CD41B6B0((uint64_t)(v13 + 10), (uint64_t)(a4 + 2));
    }
    *(void *)unint64_t v13 = 0;
    *((void *)v13 + 1) = 0;
    *((void *)v13 + 2) = v5;
    *uint64_t v12 = (uint64_t)v13;
    uint64_t v14 = *(void *)*v6;
    if (v14)
    {
      *int v6 = v14;
      unint64_t v13 = (_DWORD *)*v12;
    }
    uint64_t result = sub_1CB8358B8((uint64_t *)v6[1], (uint64_t *)v13);
    ++v6[2];
    return result;
  }
  while (1)
  {
    while (1)
    {
      uint64_t v5 = v15;
      unsigned int v16 = *((_DWORD *)v15 + 8);
      if (v16 <= a3) {
        break;
      }
      unsigned int v15 = (uint64_t *)*v15;
      uint64_t v12 = v5;
      if (!*v5) {
        goto LABEL_15;
      }
    }
    if (v16 >= a3) {
      return result;
    }
    unsigned int v15 = (uint64_t *)v15[1];
    if (!v15)
    {
LABEL_46:
      uint64_t v12 = v5 + 1;
      goto LABEL_15;
    }
  }
}

void sub_1CBF8B370(int *a1, uint64_t a2)
{
  uint64_t v46 = a2;
  int v3 = *a1 + 1;
  *a1 = v3;
  uint64_t v6 = *((void *)a1 + 1);
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  int v7 = a1[6];
  if (v7)
  {
    int v8 = v7 - 1;
    unsigned int v9 = (v7 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v10 = (uint64_t *)(v5 + 16 * v9);
    uint64_t v11 = *v10;
    if (*v10 == a2) {
      goto LABEL_16;
    }
    uint64_t v12 = 0;
    int v13 = 1;
    while (v11 != -4096)
    {
      if (v12) {
        BOOL v14 = 0;
      }
      else {
        BOOL v14 = v11 == -8192;
      }
      if (v14) {
        uint64_t v12 = v10;
      }
      unsigned int v15 = v9 + v13++;
      unsigned int v9 = v15 & v8;
      uint64_t v10 = (uint64_t *)(v5 + 16 * (v15 & v8));
      uint64_t v11 = *v10;
      if (*v10 == a2) {
        goto LABEL_16;
      }
    }
    if (v12) {
      unsigned int v16 = v12;
    }
    else {
      unsigned int v16 = v10;
    }
  }
  else
  {
    unsigned int v16 = 0;
  }
  uint64_t v10 = sub_1CBF8BBE8(v4, (uint64_t)&v46, &v46, v16);
  *uint64_t v10 = v46;
  *((_DWORD *)v10 + 2) = 0;
LABEL_16:
  *((_DWORD *)v10 + 2) = v3;
  uint64_t v18 = (void *)*((void *)a1 + 5);
  unint64_t v17 = *((void *)a1 + 6);
  if ((unint64_t)v18 < v17)
  {
    *uint64_t v18 = v46;
    int v26 = v18 + 1;
  }
  else
  {
    int v19 = (void *)*((void *)a1 + 4);
    uint64_t v20 = v18 - v19;
    unint64_t v21 = v20 + 1;
    if ((unint64_t)(v20 + 1) >> 61) {
      goto LABEL_60;
    }
    uint64_t v22 = v17 - (void)v19;
    if (v22 >> 2 > v21) {
      unint64_t v21 = v22 >> 2;
    }
    if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v23 = v21;
    }
    if (v23)
    {
      if (v23 >> 61) {
        goto LABEL_61;
      }
      unsigned int v24 = (char *)operator new(8 * v23);
    }
    else
    {
      unsigned int v24 = 0;
    }
    uint64_t v25 = &v24[8 * v20];
    *(void *)uint64_t v25 = v46;
    int v26 = v25 + 8;
    if (v18 != v19)
    {
      do
      {
        uint64_t v27 = *--v18;
        *((void *)v25 - 1) = v27;
        v25 -= 8;
      }
      while (v18 != v19);
      uint64_t v18 = (void *)*((void *)a1 + 4);
    }
    *((void *)a1 + 4) = v25;
    *((void *)a1 + 5) = v26;
    *((void *)a1 + 6) = &v24[8 * v23];
    if (v18) {
      operator delete(v18);
    }
  }
  *((void *)a1 + 5) = v26;
  uint64_t v28 = v46;
  uint64_t v29 = *(void *)(v46 + 40);
  if (v29 == v46 + 40 || v29 == 0)
  {
    if (v29 == v46 + 40)
    {
      uint64_t v33 = 0;
      goto LABEL_39;
    }
    uint64_t v31 = v29 - 24;
    if (!v29) {
      uint64_t v31 = 0;
    }
    long long v32 = (unsigned __int8 *)(v31 + 16);
  }
  else
  {
    uint64_t v31 = v29 - 24;
    long long v32 = (unsigned __int8 *)(v29 - 8);
  }
  if (*v32 - 29 >= 0xB) {
    uint64_t v33 = 0;
  }
  else {
    uint64_t v33 = v31;
  }
LABEL_39:
  int v34 = *a1;
  unsigned int v36 = (char *)*((void *)a1 + 11);
  unint64_t v35 = *((void *)a1 + 12);
  if ((unint64_t)v36 < v35)
  {
    *(void *)unsigned int v36 = v46;
    *((void *)v36 + 1) = v33;
    *((void *)v36 + 2) = 0;
    unint64_t v44 = v36 + 32;
    *((_DWORD *)v36 + 6) = v34;
    goto LABEL_55;
  }
  uint64_t v37 = (unsigned char *)*((void *)a1 + 10);
  uint64_t v38 = (v36 - v37) >> 5;
  unint64_t v39 = v38 + 1;
  if ((unint64_t)(v38 + 1) >> 59) {
LABEL_60:
  }
    abort();
  uint64_t v40 = v35 - (void)v37;
  if (v40 >> 4 > v39) {
    unint64_t v39 = v40 >> 4;
  }
  if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v41 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v41 = v39;
  }
  if (!v41)
  {
    unsigned int v42 = 0;
    goto LABEL_49;
  }
  if (v41 >> 59) {
LABEL_61:
  }
    sub_1CB833614();
  unsigned int v42 = (char *)operator new(32 * v41);
LABEL_49:
  uint64_t v43 = &v42[32 * v38];
  *(void *)uint64_t v43 = v28;
  *((void *)v43 + 1) = v33;
  *((void *)v43 + 2) = 0;
  *((_DWORD *)v43 + 6) = v34;
  unint64_t v44 = v43 + 32;
  if (v36 != v37)
  {
    do
    {
      long long v45 = *((_OWORD *)v36 - 2);
      *(_OWORD *)(v43 - 20) = *(_OWORD *)(v36 - 20);
      *((_OWORD *)v43 - 2) = v45;
      v43 -= 32;
      v36 -= 32;
    }
    while (v36 != v37);
    unsigned int v36 = (char *)*((void *)a1 + 10);
  }
  *((void *)a1 + 10) = v43;
  *((void *)a1 + 11) = v44;
  *((void *)a1 + 12) = &v42[32 * v41];
  if (v36) {
    operator delete(v36);
  }
LABEL_55:
  *((void *)a1 + 11) = v44;
}

uint64_t *sub_1CBF8B648(uint64_t *result)
{
  result[8] = result[7];
  uint64_t v1 = result[11];
  if (result[10] != v1)
  {
    int v2 = result;
    uint64_t v3 = (uint64_t)(result + 1);
    while (1)
    {
LABEL_3:
      uint64_t v4 = *(void *)(v1 - 32);
      uint64_t v7 = *(void *)(v4 + 40);
      uint64_t v5 = v4 + 40;
      uint64_t v6 = v7;
      uint64_t v8 = v7 - 24;
      if (!v7) {
        uint64_t v8 = 0;
      }
      while (1)
      {
        if (v6 == v5)
        {
LABEL_96:
          int v36 = 0;
        }
        else
        {
          int v9 = *(unsigned __int8 *)(v8 + 16);
          int v10 = v9 - 29;
          if (v9 == 30)
          {
            int v36 = (*(_DWORD *)(v8 + 20) & 0x7FFFFFF) == 3 ? 2 : 1;
          }
          else
          {
            int v36 = 0;
            switch(v10)
            {
              case 0:
              case 5:
              case 6:
                break;
              case 1:
LABEL_97:
                __break(1u);
                goto LABEL_98;
              case 2:
                int v36 = (*(_DWORD *)(v8 + 20) >> 1) & 0x3FFFFFF;
                break;
              case 3:
              case 9:
LABEL_98:
                int v36 = (*(_DWORD *)(v8 + 20) & 0x7FFFFFF) - 1;
                break;
              case 4:
                int v36 = 2;
                break;
              case 7:
                int v36 = *(_WORD *)(v8 + 18) & 1;
                break;
              case 8:
                int v36 = 1;
                break;
              case 10:
                int v36 = *(_DWORD *)(v8 + 80) + 1;
                break;
              default:
                goto LABEL_96;
            }
          }
        }
        if (*(_DWORD *)(v1 - 16) == v36) {
          break;
        }
        uint64_t v11 = *(void *)(v1 - 24);
        uint64_t v12 = *(void *)(v1 - 16);
        uint64_t v13 = (v12 + 1);
        *(_DWORD *)(v1 - 16) = v13;
        if (*(unsigned char *)(v11 + 16) == 30)
        {
          v11 -= 32 * v12;
LABEL_14:
          BOOL v14 = (uint64_t *)(v11 - 32);
        }
        else
        {
          switch(*(unsigned char *)(v11 + 16))
          {
            case ' ':
            case '&':
              int v64 = *(_DWORD *)(v11 + 20);
              if ((v64 & 0x40000000) != 0) {
                uint64_t v65 = *(void *)(v11 - 8);
              }
              else {
                uint64_t v65 = v11 - 32 * (v64 & 0x7FFFFFF);
              }
              BOOL v14 = (uint64_t *)(v65 + 32 * v13);
              break;
            case '!':
              uint64_t v66 = -64;
              if (!v12) {
                uint64_t v66 = -96;
              }
              BOOL v14 = (uint64_t *)(v11 + v66);
              break;
            case '""':
            case '#':
              goto LABEL_97;
            case '$':
              if ((*(_WORD *)(v11 + 18) & 1) == 0)
              {
                uint64_t v15 = 0;
                goto LABEL_16;
              }
              uint64_t v62 = v11 - 32 * (*(_DWORD *)(v11 + 20) & 0x7FFFFFF);
LABEL_91:
              BOOL v14 = (uint64_t *)(v62 + 32);
              break;
            case '%':
              goto LABEL_14;
            case '\'':
              if (v12)
              {
                uint64_t v11 = v11 - 32 * *(unsigned int *)(v11 + 80) + 32 * (v12 - 1);
                goto LABEL_14;
              }
              BOOL v14 = (uint64_t *)(v11 - 32 * *(unsigned int *)(v11 + 80) - 64);
              break;
            default:
              int v60 = *(_DWORD *)(v11 + 20);
              if ((v60 & 0x40000000) != 0) {
                uint64_t v61 = *(void *)(v11 - 8);
              }
              else {
                uint64_t v61 = v11 - 32 * (v60 & 0x7FFFFFF);
              }
              uint64_t v62 = v61 + 32 * (2 * v12);
              goto LABEL_91;
          }
        }
        uint64_t v15 = *v14;
LABEL_16:
        uint64_t v16 = v2[1];
        uint64_t v17 = *((unsigned int *)v2 + 6);
        if (v17)
        {
          LODWORD(v18) = ((v15 >> 4) ^ (v15 >> 9)) & (v17 - 1);
          int v19 = (uint64_t *)(v16 + 16 * v18);
          uint64_t v20 = *v19;
          if (v15 == *v19) {
            goto LABEL_23;
          }
          int v21 = 1;
          while (v20 != -4096)
          {
            int v22 = v18 + v21++;
            uint64_t v18 = v22 & (v17 - 1);
            uint64_t v20 = *(void *)(v16 + 16 * v18);
            if (v15 == v20)
            {
              int v19 = (uint64_t *)(v16 + 16 * v18);
              goto LABEL_23;
            }
          }
        }
        int v19 = (uint64_t *)(v16 + 16 * v17);
LABEL_23:
        if (v19 == (uint64_t *)(v16 + 16 * v17))
        {
          sub_1CBF8B370((int *)v2, v15);
          uint64_t v1 = v2[11];
          goto LABEL_3;
        }
        unsigned int v23 = *((_DWORD *)v19 + 2);
        if (*(_DWORD *)(v1 - 8) > v23) {
          *(_DWORD *)(v1 - 8) = v23;
        }
      }
      uint64_t v67 = 0;
      uint64_t v24 = *(void *)(v1 - 32);
      uint64_t v67 = v24;
      unsigned int v25 = *(_DWORD *)(v1 - 8);
      v2[11] = v1 - 32;
      if (v2[10] != v1 - 32 && *(_DWORD *)(v1 - 40) > v25) {
        *(_DWORD *)(v1 - 40) = v25;
      }
      int v26 = *((_DWORD *)v2 + 6);
      if (!v26)
      {
        unint64_t v35 = 0;
        goto LABEL_44;
      }
      uint64_t v27 = v2[1];
      int v28 = v26 - 1;
      unsigned int v29 = v28 & ((v24 >> 4) ^ (v24 >> 9));
      uint64_t result = (uint64_t *)(v27 + 16 * v29);
      uint64_t v30 = *result;
      if (v24 != *result)
      {
        uint64_t v31 = 0;
        int v32 = 1;
        while (v30 != -4096)
        {
          if (v31) {
            BOOL v33 = 0;
          }
          else {
            BOOL v33 = v30 == -8192;
          }
          if (v33) {
            uint64_t v31 = result;
          }
          unsigned int v34 = v29 + v32++;
          unsigned int v29 = v34 & v28;
          uint64_t result = (uint64_t *)(v27 + 16 * v29);
          uint64_t v30 = *result;
          if (v24 == *result) {
            goto LABEL_45;
          }
        }
        if (v31) {
          unint64_t v35 = v31;
        }
        else {
          unint64_t v35 = result;
        }
LABEL_44:
        uint64_t result = sub_1CBF8BBE8(v3, (uint64_t)&v67, &v67, v35);
        *uint64_t result = v67;
        *((_DWORD *)result + 2) = 0;
      }
LABEL_45:
      if (v25 == *((_DWORD *)result + 2)) {
        break;
      }
      uint64_t v1 = v2[11];
      if (v2[10] == v1) {
        return result;
      }
    }
    uint64_t v37 = (void *)v2[8];
    while (1)
    {
      uint64_t v38 = v2[5];
      unint64_t v39 = v2[9];
      if ((unint64_t)v37 >= v39)
      {
        uint64_t v53 = (void *)v2[7];
        uint64_t v54 = v37 - v53;
        unint64_t v55 = v54 + 1;
        if ((unint64_t)(v54 + 1) >> 61) {
          abort();
        }
        uint64_t v56 = v39 - (void)v53;
        if (v56 >> 2 > v55) {
          unint64_t v55 = v56 >> 2;
        }
        unint64_t v57 = (unint64_t)v56 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v55;
        if (v57)
        {
          if (v57 >> 61) {
            sub_1CB833614();
          }
          uint64_t v63 = (char *)operator new(8 * v57);
        }
        else
        {
          uint64_t v63 = 0;
        }
        int v58 = &v63[8 * v54];
        *(void *)int v58 = *(void *)(v38 - 8);
        uint64_t v40 = v58 + 8;
        if (v37 != v53)
        {
          do
          {
            uint64_t v59 = *--v37;
            *((void *)v58 - 1) = v59;
            v58 -= 8;
          }
          while (v37 != v53);
          uint64_t v37 = (void *)v2[7];
        }
        v2[7] = (uint64_t)v58;
        v2[8] = (uint64_t)v40;
        v2[9] = (uint64_t)&v63[8 * v57];
        if (v37) {
          operator delete(v37);
        }
      }
      else
      {
        *uint64_t v37 = *(void *)(v38 - 8);
        uint64_t v40 = v37 + 1;
      }
      v2[8] = (uint64_t)v40;
      v2[5] -= 8;
      unint64_t v41 = v40 - 1;
      int v42 = *((_DWORD *)v2 + 6);
      if (!v42) {
        break;
      }
      uint64_t v43 = v2[1];
      uint64_t v44 = *v41;
      int v45 = v42 - 1;
      unsigned int v46 = ((*v41 >> 4) ^ (*v41 >> 9)) & v45;
      uint64_t result = (uint64_t *)(v43 + 16 * v46);
      uint64_t v47 = *result;
      if (*v41 != *result)
      {
        unint64_t v48 = 0;
        int v49 = 1;
        while (v47 != -4096)
        {
          if (v48) {
            BOOL v50 = 0;
          }
          else {
            BOOL v50 = v47 == -8192;
          }
          if (v50) {
            unint64_t v48 = result;
          }
          unsigned int v51 = v46 + v49++;
          unsigned int v46 = v51 & v45;
          uint64_t result = (uint64_t *)(v43 + 16 * v46);
          uint64_t v47 = *result;
          if (v44 == *result) {
            goto LABEL_68;
          }
        }
        if (v48) {
          uint64_t v52 = v48;
        }
        else {
          uint64_t v52 = result;
        }
        goto LABEL_67;
      }
LABEL_68:
      *((_DWORD *)result + 2) = -1;
      uint64_t v37 = v40;
      if (v44 == v67) {
        return result;
      }
    }
    uint64_t v52 = 0;
LABEL_67:
    uint64_t result = sub_1CBF8BBE8(v3, (uint64_t)(v40 - 1), v40 - 1, v52);
    *uint64_t result = *v41;
    *((_DWORD *)result + 2) = 0;
    uint64_t v40 = (void *)v2[8];
    uint64_t v44 = *(v40 - 1);
    goto LABEL_68;
  }
  return result;
}

uint64_t *sub_1CBF8BBE8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  uint64_t v7 = *(unsigned int *)(a1 + 16);
  if (4 * v6 + 4 >= (3 * v7))
  {
    int v10 = *(uint64_t **)a1;
    unint64_t v11 = (2 * v7 - 1) | ((unint64_t)(2 * v7 - 1) >> 1);
    unint64_t v12 = v11 | (v11 >> 2) | ((v11 | (v11 >> 2)) >> 4);
    int v13 = ((v12 | (v12 >> 8)) >> 16) | v12 | (v12 >> 8);
    if ((v13 + 1) > 0x40) {
      unsigned int v14 = v13 + 1;
    }
    else {
      unsigned int v14 = 64;
    }
    *(_DWORD *)(a1 + 16) = v14;
    uint64_t v15 = (uint64_t *)operator new(16 * v14, (std::align_val_t)8uLL);
    *(void *)a1 = v15;
    if (v10)
    {
      sub_1CBAEE4F0(a1, v10, &v10[2 * v7]);
      MEMORY[0x1D25D9CD0](v10, 8);
      LODWORD(v17) = *(_DWORD *)(a1 + 16);
      uint64_t v15 = *(uint64_t **)a1;
    }
    else
    {
      uint64_t v16 = 0;
      *(void *)(a1 + 8) = 0;
      uint64_t v17 = *(unsigned int *)(a1 + 16);
      do
      {
        v15[v16] = -4096;
        v16 += 2;
      }
      while (2 * v17 != v16);
    }
    uint64_t v8 = *a3;
    int v18 = v17 - 1;
    unsigned int v19 = ((*a3 >> 4) ^ (*a3 >> 9)) & v18;
    a4 = &v15[2 * v19];
    uint64_t v20 = *a4;
    if (*a3 == *a4) {
      goto LABEL_5;
    }
    int v21 = 0;
    int v22 = 1;
    while (v20 != -4096)
    {
      if (v21) {
        BOOL v23 = 0;
      }
      else {
        BOOL v23 = v20 == -8192;
      }
      if (v23) {
        int v21 = a4;
      }
      unsigned int v24 = v19 + v22++;
      unsigned int v19 = v24 & v18;
      a4 = &v15[2 * v19];
      uint64_t v20 = *a4;
      if (v8 == *a4) {
        goto LABEL_5;
      }
    }
    if (v21) {
      a4 = v21;
    }
  }
  else if ((int)v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
  {
    sub_1CBAEE424(a1, *(_DWORD *)(a1 + 16));
    unsigned int v25 = 0;
    sub_1CBA0E618(a1, a3, &v25);
    a4 = v25;
  }
  uint64_t v8 = *a4;
LABEL_5:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

uint64_t sub_1CBF8BDAC(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    int v6 = (void *)(a1 + 16 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
LABEL_11:
      uint64_t result = 1;
    }
    else
    {
      uint64_t v8 = 0;
      int v9 = 1;
      while (v7 != -4096)
      {
        if (v8) {
          BOOL v10 = 0;
        }
        else {
          BOOL v10 = v7 == -8192;
        }
        if (v10) {
          uint64_t v8 = v6;
        }
        unsigned int v11 = v5 + v9++;
        unsigned int v5 = v11 & v4;
        int v6 = (void *)(a1 + 16 * (v11 & v4));
        uint64_t v7 = *v6;
        if (*v6 == a3) {
          goto LABEL_11;
        }
      }
      uint64_t result = 0;
      if (v8) {
        int v6 = v8;
      }
    }
  }
  else
  {
    int v6 = 0;
    uint64_t result = 0;
  }
  *a4 = v6;
  return result;
}

void *sub_1CBF8BE34(uint64_t *a1, int a2)
{
  uint64_t v3 = *((unsigned int *)a1 + 4);
  int v4 = (uint64_t *)*a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *((_DWORD *)a1 + 4) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *a1 = (uint64_t)result;
  if (v4)
  {
    a1[1] = 0;
    uint64_t v12 = *((unsigned int *)a1 + 4);
    if (v12)
    {
      uint64_t v13 = 16 * v12;
      do
      {
        *uint64_t result = -4096;
        result += 2;
        v13 -= 16;
      }
      while (v13);
    }
    if (v3)
    {
      unsigned int v14 = v4;
      do
      {
        uint64_t v15 = *v14;
        if ((*v14 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          int v16 = *((_DWORD *)a1 + 4) - 1;
          unsigned int v17 = v16 & ((v15 >> 4) ^ (v15 >> 9));
          uint64_t v18 = *a1 + 16 * v17;
          uint64_t v19 = *(void *)v18;
          if (v15 != *(void *)v18)
          {
            uint64_t v20 = 0;
            int v21 = 1;
            while (v19 != -4096)
            {
              if (v20) {
                BOOL v22 = 0;
              }
              else {
                BOOL v22 = v19 == -8192;
              }
              if (v22) {
                uint64_t v20 = v18;
              }
              unsigned int v23 = v17 + v21++;
              unsigned int v17 = v23 & v16;
              uint64_t v18 = *a1 + 16 * (v23 & v16);
              uint64_t v19 = *(void *)v18;
              if (v15 == *(void *)v18) {
                goto LABEL_27;
              }
            }
            if (v20) {
              uint64_t v18 = v20;
            }
          }
LABEL_27:
          *(void *)uint64_t v18 = v15;
          *(_DWORD *)(v18 + 8) = *((_DWORD *)v14 + 2);
          ++*((_DWORD *)a1 + 2);
        }
        v14 += 2;
      }
      while (v14 != &v4[2 * v3]);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  a1[1] = 0;
  uint64_t v10 = *((unsigned int *)a1 + 4);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *uint64_t result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CBF8BFC0(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  uint64_t v4 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v5 = 4;
  }
  else
  {
    int v5 = *(_DWORD *)(a1 + 16);
    if (!v5)
    {
      uint64_t v12 = 0;
      uint64_t result = 0;
      goto LABEL_12;
    }
    uint64_t v4 = *(void *)(a1 + 8);
  }
  unint64_t v6 = ~((unint64_t)(37 * a3) << 32)
     + (37 * a3)
     + ((unint64_t)((a2 >> 4) ^ (a2 >> 9)) << 32);
  unint64_t v7 = (v6 ^ (v6 >> 22)) + ~((v6 ^ (v6 >> 22)) << 13);
  unint64_t v8 = (9 * (v7 ^ (v7 >> 8))) ^ ((9 * (v7 ^ (v7 >> 8))) >> 15);
  int v9 = ((v8 + ~(v8 << 27)) >> 31) ^ (v8 + ~(v8 << 27));
  int v10 = v5 - 1;
  unsigned int v11 = (v5 - 1) & v9;
  uint64_t v12 = (uint64_t *)(v4 + 24 * v11);
  uint64_t v13 = *v12;
  int v14 = *((_DWORD *)v12 + 2);
  if (*v12 == a2 && v14 == a3)
  {
    uint64_t result = 1;
  }
  else
  {
    int v16 = 0;
    int v17 = 1;
    uint64_t result = 1;
    while (v13 != -4096 || v14 != 0x7FFFFFFF)
    {
      if (v16) {
        BOOL v19 = 0;
      }
      else {
        BOOL v19 = v14 == 0x80000000;
      }
      if (v19 && v13 == -8192) {
        int v16 = v12;
      }
      unsigned int v21 = v11 + v17++;
      unsigned int v11 = v21 & v10;
      uint64_t v12 = (uint64_t *)(v4 + 24 * (v21 & v10));
      uint64_t v13 = *v12;
      int v14 = *((_DWORD *)v12 + 2);
      if (*v12 == a2 && v14 == a3) {
        goto LABEL_12;
      }
    }
    uint64_t result = 0;
    if (v16) {
      uint64_t v12 = v16;
    }
  }
LABEL_12:
  *a4 = v12;
  return result;
}

int *sub_1CBF8C0D8(uint64_t a1, unsigned int a2)
{
  v14[8] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    unsigned int v11 = *(uint64_t **)(a1 + 8);
    uint64_t v12 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CBF8C264((int *)a1, v11, &v11[2 * v12]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v6 = 0;
  unint64_t v7 = v14;
  do
  {
    uint64_t v8 = *(void *)(a1 + v6 + 8);
    if ((v8 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *unint64_t v7 = v8;
      *((_DWORD *)v7 + 2) = *(_DWORD *)(a1 + v6 + 16);
      v7 += 2;
    }
    v6 += 16;
  }
  while (v6 != 64);
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v9 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v9;
  }
  return sub_1CBF8C264((int *)a1, v14, v7);
}

int *sub_1CBF8C264(int *result, uint64_t *a2, uint64_t *a3)
{
  int v3 = *result;
  *result &= 1u;
  result[1] = 0;
  if (v3)
  {
    uint64_t v6 = result + 18;
    int v5 = result + 2;
  }
  else
  {
    uint64_t v4 = result[4];
    if (!v4) {
      goto LABEL_5;
    }
    int v5 = (void *)*((void *)result + 1);
    uint64_t v6 = &v5[2 * v4];
  }
  do
  {
    *int v5 = -4096;
    v5 += 2;
  }
  while (v5 != v6);
LABEL_5:
  while (a2 != a3)
  {
    uint64_t v7 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      if (*(unsigned char *)result)
      {
        int v8 = 4;
        uint64_t v9 = result + 2;
      }
      else
      {
        uint64_t v9 = (int *)*((void *)result + 1);
        int v8 = result[4];
      }
      int v10 = v8 - 1;
      unsigned int v11 = (v8 - 1) & ((v7 >> 4) ^ (v7 >> 9));
      uint64_t v12 = (uint64_t *)&v9[4 * v11];
      uint64_t v13 = *v12;
      if (v7 != *v12)
      {
        int v14 = 0;
        int v15 = 1;
        while (v13 != -4096)
        {
          if (v14) {
            BOOL v16 = 0;
          }
          else {
            BOOL v16 = v13 == -8192;
          }
          if (v16) {
            int v14 = v12;
          }
          unsigned int v17 = v11 + v15++;
          unsigned int v11 = v17 & v10;
          uint64_t v12 = (uint64_t *)&v9[4 * (v17 & v10)];
          uint64_t v13 = *v12;
          if (v7 == *v12) {
            goto LABEL_14;
          }
        }
        if (v14) {
          uint64_t v12 = v14;
        }
      }
LABEL_14:
      *uint64_t v12 = v7;
      *((_DWORD *)v12 + 2) = *((_DWORD *)a2 + 2);
      *result += 2;
    }
    a2 += 2;
  }
  return result;
}

void sub_1CBF8C36C(char **a1, uint64_t a2)
{
  v15[24] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(*(void *)a2 + 80);
  if (v3) {
    uint64_t v4 = v3 - 24;
  }
  else {
    uint64_t v4 = 0;
  }
  sub_1CBF8EB48((llvm::SmallPtrSetImplBase *)&v12, v4);
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  v9[0] = 0;
  memset(v8, 0, sizeof(v8));
  int v5 = (char *)v8 + 8;
  uint64_t v6 = (char *)v8 + 8;
  uint64_t v7 = 8;
  v9[1] = (char *)v10 + 8;
  DWORD1(v10[0]) = 8;
  sub_1CBF8C4B4((uint64_t)&v12, (uint64_t)&v5, a1);
  if (v9[1] != (char *)v10 + 8) {
    free(v9[1]);
  }
  if (v6 != v5) {
    free(v6);
  }
  if (v14 != v15) {
    free(v14);
  }
  if (v13 != v12) {
    free(v13);
  }
}

uint64_t sub_1CBF8C4B4(uint64_t a1, uint64_t a2, char **a3)
{
  v47[25] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = v40;
  unint64_t v35 = v40;
  uint64_t v7 = *(unsigned char **)(a1 + 8);
  if (v7 == *(unsigned char **)a1)
  {
    int v36 = v40;
    int v8 = v7;
  }
  else
  {
    uint64_t v24 = *(unsigned int *)(a1 + 16);
    uint64_t v6 = malloc_type_malloc(8 * v24, 0x4065EBACuLL);
    if (!v6)
    {
      if (v24) {
        goto LABEL_47;
      }
      uint64_t v6 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v6) {
        goto LABEL_47;
      }
    }
    int v36 = v6;
    int v8 = *(unsigned char **)a1;
    uint64_t v7 = *(unsigned char **)(a1 + 8);
  }
  unsigned int v10 = *(_DWORD *)(a1 + 16);
  unsigned int v9 = *(_DWORD *)(a1 + 20);
  unsigned int v37 = v10;
  if (v7 == v8) {
    unsigned int v11 = v9;
  }
  else {
    unsigned int v11 = v10;
  }
  if (v11)
  {
    memmove(v6, v7, 8 * v11);
    unsigned int v9 = *(_DWORD *)(a1 + 20);
  }
  int v12 = *(_DWORD *)(a1 + 24);
  unsigned int v38 = v9;
  int v39 = v12;
  unint64_t v41 = v43;
  uint64_t v42 = 0x800000000;
  unsigned int v13 = *(_DWORD *)(a1 + 104);
  if (v13 && &v35 != (unsigned char **)a1)
  {
    if (v13 >= 9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy(v43, *(const void **)(a1 + 96), 24 * *(unsigned int *)(a1 + 104));
    LODWORD(v42) = v13;
  }
  int v14 = v31;
  int v26 = v31;
  int v15 = *(const void **)(a2 + 8);
  if (v15 == *(const void **)a2)
  {
    uint64_t v27 = v31;
    BOOL v16 = v15;
    goto LABEL_14;
  }
  uint64_t v25 = *(unsigned int *)(a2 + 16);
  int v14 = malloc_type_malloc(8 * v25, 0x4065EBACuLL);
  if (!v14 && (v25 || (int v14 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
LABEL_47:
  }
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  uint64_t v27 = v14;
  BOOL v16 = *(const void **)a2;
  int v15 = *(const void **)(a2 + 8);
LABEL_14:
  unsigned int v18 = *(_DWORD *)(a2 + 16);
  unsigned int v17 = *(_DWORD *)(a2 + 20);
  unsigned int v28 = v18;
  if (v15 == v16) {
    unsigned int v19 = v17;
  }
  else {
    unsigned int v19 = v18;
  }
  if (v19)
  {
    memmove(v14, v15, 8 * v19);
    unsigned int v17 = *(_DWORD *)(a2 + 20);
  }
  int v20 = *(_DWORD *)(a2 + 24);
  unsigned int v29 = v17;
  int v30 = v20;
  int v32 = v34;
  uint64_t v33 = 0x800000000;
  unsigned int v21 = *(_DWORD *)(a2 + 104);
  if (v21 && &v26 != (unsigned char **)a2)
  {
    if (v21 >= 9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy(v34, *(const void **)(a2 + 96), 24 * *(unsigned int *)(a2 + 104));
    LODWORD(v33) = v21;
  }
  sub_1CBF8C7A8((uint64_t)&v35, (uint64_t)&v26, a3, (uint64_t)&v44);
  uint64_t v22 = v47[24];
  if (v46 != v47) {
    free(v46);
  }
  if (v45 != v44) {
    free(v45);
  }
  if (v32 != v34) {
    free(v32);
  }
  if (v27 != v26) {
    free(v27);
  }
  if (v41 != v43) {
    free(v41);
  }
  if (v36 != v35) {
    free(v36);
  }
  return v22;
}

void sub_1CBF8C7A8(uint64_t a1@<X0>, uint64_t a2@<X1>, char **a3@<X2>, uint64_t a4@<X8>)
{
  v35[24] = *MEMORY[0x1E4F143B8];
  uint64_t v27 = v32;
  unsigned int v9 = *(unsigned char **)a1;
  int v8 = *(const void **)(a1 + 8);
  if (v8 == *(const void **)a1)
  {
    unsigned int v28 = v32;
    uint64_t v10 = *(unsigned int *)(a1 + 20);
    if (v10) {
      memmove(v32, v8, 8 * v10);
    }
  }
  else
  {
    unsigned int v28 = *(unsigned char **)(a1 + 8);
    *(void *)(a1 + 8) = v9;
    LODWORD(v10) = *(_DWORD *)(a1 + 20);
  }
  int v29 = *(_DWORD *)(a1 + 16);
  int v30 = v10;
  int v31 = *(_DWORD *)(a1 + 24);
  *(void *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v33 = v35;
  unint64_t v34 = 0x800000000;
  unsigned int v11 = *(_DWORD *)(a1 + 104);
  if (v11 && &v27 != (unsigned char **)a1)
  {
    int v12 = *(const void **)(a1 + 96);
    if (v12 == (const void *)(a1 + 112))
    {
      if (v11 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v35, v12, 24 * *(unsigned int *)(a1 + 104));
      LODWORD(v34) = v11;
    }
    else
    {
      uint64_t v33 = *(void **)(a1 + 96);
      unint64_t v34 = __PAIR64__(*(_DWORD *)(a1 + 108), v11);
      *(void *)(a1 + 96) = a1 + 112;
      *(_DWORD *)(a1 + 108) = 0;
    }
    *(_DWORD *)(a1 + 104) = 0;
  }
  unsigned int v18 = v23;
  int v14 = *(unsigned char **)a2;
  unsigned int v13 = *(const void **)(a2 + 8);
  if (v13 == *(const void **)a2)
  {
    unsigned int v19 = v23;
    uint64_t v15 = *(unsigned int *)(a2 + 20);
    if (v15) {
      memmove(v23, v13, 8 * v15);
    }
  }
  else
  {
    unsigned int v19 = *(unsigned char **)(a2 + 8);
    *(void *)(a2 + 8) = v14;
    LODWORD(v15) = *(_DWORD *)(a2 + 20);
  }
  int v20 = *(_DWORD *)(a2 + 16);
  int v21 = v15;
  int v22 = *(_DWORD *)(a2 + 24);
  *(void *)(a2 + 16) = 8;
  *(_DWORD *)(a2 + 24) = 0;
  uint64_t v24 = v26;
  unint64_t v25 = 0x800000000;
  unsigned int v16 = *(_DWORD *)(a2 + 104);
  if (v16 && &v18 != (unsigned char **)a2)
  {
    unsigned int v17 = *(const void **)(a2 + 96);
    if (v17 == (const void *)(a2 + 112))
    {
      if (v16 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v26, v17, 24 * *(unsigned int *)(a2 + 104));
      LODWORD(v25) = v16;
    }
    else
    {
      uint64_t v24 = *(void **)(a2 + 96);
      unint64_t v25 = __PAIR64__(*(_DWORD *)(a2 + 108), v16);
      *(void *)(a2 + 96) = a2 + 112;
      *(_DWORD *)(a2 + 108) = 0;
    }
    *(_DWORD *)(a2 + 104) = 0;
  }
  sub_1CBF8CA64((uint64_t)&v27, (uint64_t)&v18, a3, a4);
  if (v24 != v26) {
    free(v24);
  }
  if (v19 != v18) {
    free(v19);
  }
  if (v33 != v35) {
    free(v33);
  }
  if (v28 != v27) {
    free(v28);
  }
}

void sub_1CBF8CA64(uint64_t a1@<X0>, uint64_t a2@<X1>, char **a3@<X2>, uint64_t a4@<X8>)
{
  v35[24] = *MEMORY[0x1E4F143B8];
  uint64_t v27 = v32;
  unsigned int v9 = *(unsigned char **)a1;
  int v8 = *(const void **)(a1 + 8);
  if (v8 == *(const void **)a1)
  {
    unsigned int v28 = v32;
    uint64_t v10 = *(unsigned int *)(a1 + 20);
    if (v10) {
      memmove(v32, v8, 8 * v10);
    }
  }
  else
  {
    unsigned int v28 = *(unsigned char **)(a1 + 8);
    *(void *)(a1 + 8) = v9;
    LODWORD(v10) = *(_DWORD *)(a1 + 20);
  }
  int v29 = *(_DWORD *)(a1 + 16);
  int v30 = v10;
  int v31 = *(_DWORD *)(a1 + 24);
  *(void *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v33 = v35;
  unint64_t v34 = 0x800000000;
  unsigned int v11 = *(_DWORD *)(a1 + 104);
  if (v11 && &v27 != (unsigned char **)a1)
  {
    int v12 = *(const void **)(a1 + 96);
    if (v12 == (const void *)(a1 + 112))
    {
      if (v11 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v35, v12, 24 * *(unsigned int *)(a1 + 104));
      LODWORD(v34) = v11;
    }
    else
    {
      uint64_t v33 = *(void **)(a1 + 96);
      unint64_t v34 = __PAIR64__(*(_DWORD *)(a1 + 108), v11);
      *(void *)(a1 + 96) = a1 + 112;
      *(_DWORD *)(a1 + 108) = 0;
    }
    *(_DWORD *)(a1 + 104) = 0;
  }
  unsigned int v18 = v23;
  int v14 = *(unsigned char **)a2;
  unsigned int v13 = *(const void **)(a2 + 8);
  if (v13 == *(const void **)a2)
  {
    unsigned int v19 = v23;
    uint64_t v15 = *(unsigned int *)(a2 + 20);
    if (v15) {
      memmove(v23, v13, 8 * v15);
    }
  }
  else
  {
    unsigned int v19 = *(unsigned char **)(a2 + 8);
    *(void *)(a2 + 8) = v14;
    LODWORD(v15) = *(_DWORD *)(a2 + 20);
  }
  int v20 = *(_DWORD *)(a2 + 16);
  int v21 = v15;
  int v22 = *(_DWORD *)(a2 + 24);
  *(void *)(a2 + 16) = 8;
  *(_DWORD *)(a2 + 24) = 0;
  uint64_t v24 = v26;
  unint64_t v25 = 0x800000000;
  unsigned int v16 = *(_DWORD *)(a2 + 104);
  if (v16 && &v18 != (unsigned char **)a2)
  {
    unsigned int v17 = *(const void **)(a2 + 96);
    if (v17 == (const void *)(a2 + 112))
    {
      if (v16 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v26, v17, 24 * *(unsigned int *)(a2 + 104));
      LODWORD(v25) = v16;
    }
    else
    {
      uint64_t v24 = *(void **)(a2 + 96);
      unint64_t v25 = __PAIR64__(*(_DWORD *)(a2 + 108), v16);
      *(void *)(a2 + 96) = a2 + 112;
      *(_DWORD *)(a2 + 108) = 0;
    }
    *(_DWORD *)(a2 + 104) = 0;
  }
  sub_1CBF8CD20((uint64_t)&v27, (uint64_t)&v18, a3, a4);
  if (v24 != v26) {
    free(v24);
  }
  if (v19 != v18) {
    free(v19);
  }
  if (v33 != v35) {
    free(v33);
  }
  if (v28 != v27) {
    free(v28);
  }
}

void sub_1CBF8CD20(uint64_t a1@<X0>, uint64_t a2@<X1>, char **a3@<X2>, uint64_t a4@<X8>)
{
  v123[24] = *MEMORY[0x1E4F143B8];
  int v8 = v106;
  unsigned int v101 = v106;
  unsigned int v9 = *(unsigned char **)(a1 + 8);
  if (v9 == *(unsigned char **)a1)
  {
    uint64_t v102 = v106;
    uint64_t v10 = v9;
  }
  else
  {
    uint64_t v40 = *(unsigned int *)(a1 + 16);
    int v8 = malloc_type_malloc(8 * v40, 0x4065EBACuLL);
    if (!v8 && (v40 || (int v8 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    uint64_t v102 = v8;
    uint64_t v10 = *(unsigned char **)a1;
    unsigned int v9 = *(unsigned char **)(a1 + 8);
  }
  unsigned int v12 = *(_DWORD *)(a1 + 16);
  unsigned int v11 = *(_DWORD *)(a1 + 20);
  unsigned int v103 = v12;
  if (v9 == v10) {
    unsigned int v13 = v11;
  }
  else {
    unsigned int v13 = v12;
  }
  if (v13)
  {
    memmove(v8, v9, 8 * v13);
    unsigned int v11 = *(_DWORD *)(a1 + 20);
  }
  int v14 = *(_DWORD *)(a1 + 24);
  unsigned int v104 = v11;
  int v105 = v14;
  unsigned int v107 = v109;
  uint64_t v108 = 0x800000000;
  unsigned int v15 = *(_DWORD *)(a1 + 104);
  if (v15 && &v101 != (unsigned char **)a1)
  {
    if (v15 >= 9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy(v109, *(const void **)(a1 + 96), 24 * *(unsigned int *)(a1 + 104));
    LODWORD(v108) = v15;
  }
  int v92 = v97;
  unsigned int v17 = *(unsigned char **)a2;
  unsigned int v16 = *(const void **)(a2 + 8);
  if (v16 == *(const void **)a2)
  {
    int v93 = v97;
    uint64_t v18 = *(unsigned int *)(a2 + 20);
    if (v18) {
      memmove(v97, v16, 8 * v18);
    }
  }
  else
  {
    int v93 = *(void **)(a2 + 8);
    *(void *)(a2 + 8) = v17;
    LODWORD(v18) = *(_DWORD *)(a2 + 20);
  }
  int v94 = *(_DWORD *)(a2 + 16);
  int v95 = v18;
  int v96 = *(_DWORD *)(a2 + 24);
  *(void *)(a2 + 16) = 8;
  *(_DWORD *)(a2 + 24) = 0;
  uint64_t v98 = v100;
  unint64_t v99 = 0x800000000;
  unsigned int v19 = *(_DWORD *)(a2 + 104);
  if (v19 && &v92 != (unsigned char **)a2)
  {
    int v20 = *(const void **)(a2 + 96);
    if (v20 == (const void *)(a2 + 112))
    {
      if (v19 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v100, v20, 24 * *(unsigned int *)(a2 + 104));
      LODWORD(v99) = v19;
    }
    else
    {
      uint64_t v98 = *(void **)(a2 + 96);
      unint64_t v99 = __PAIR64__(*(_DWORD *)(a2 + 108), v19);
      *(void *)(a2 + 96) = a2 + 112;
      *(_DWORD *)(a2 + 108) = 0;
    }
    *(_DWORD *)(a2 + 104) = 0;
  }
  sub_1CBF8D614((uint64_t)&v101, (uint64_t)&v92, (uint64_t)&v110);
  if (v98 != v100) {
    free(v98);
  }
  if (v93 != v92) {
    free(v93);
  }
  if (v107 != v109) {
    free(v107);
  }
  if (v102 != v101) {
    free(v102);
  }
  unsigned int v76 = v81;
  if (__src == v110)
  {
    uint64_t v77 = v81;
    int v21 = HIDWORD(v112);
    if (HIDWORD(v112)) {
      memmove(v81, __src, 8 * HIDWORD(v112));
    }
  }
  else
  {
    uint64_t v77 = __src;
    __src = v110;
    int v21 = HIDWORD(v112);
  }
  int v78 = v112;
  int v79 = v21;
  int v80 = v113;
  uint64_t v112 = 8;
  int v113 = 0;
  uint64_t v82 = v84;
  uint64_t v83 = 0x800000000;
  int v22 = v115;
  if (v115)
  {
    if (v114 == v116)
    {
      if (v115 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v84, v114, 24 * v115);
      LODWORD(v83) = v22;
    }
    else
    {
      uint64_t v82 = v114;
      uint64_t v83 = v115;
      int v114 = v116;
      HIDWORD(v115) = 0;
    }
    LODWORD(v115) = 0;
  }
  uint64_t v67 = v72;
  if (v118 == v117)
  {
    unsigned int v68 = v72;
    int v23 = HIDWORD(v119);
    if (HIDWORD(v119)) {
      memmove(v72, v118, 8 * HIDWORD(v119));
    }
  }
  else
  {
    unsigned int v68 = v118;
    uint64_t v118 = v117;
    int v23 = HIDWORD(v119);
  }
  int v69 = v119;
  int v70 = v23;
  int v71 = v120;
  uint64_t v119 = 8;
  int v120 = 0;
  unsigned int v73 = v75;
  uint64_t v74 = 0x800000000;
  int v24 = v122;
  if (v122)
  {
    if (v121 == v123)
    {
      if (v122 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v75, v121, 24 * v122);
      LODWORD(v74) = v24;
    }
    else
    {
      unsigned int v73 = v121;
      uint64_t v74 = v122;
      unint64_t v121 = v123;
      HIDWORD(v122) = 0;
    }
    LODWORD(v122) = 0;
  }
  sub_1CBF8DB00((llvm::SmallPtrSetImplBase *)&v76, (uint64_t)&v67, a3, (uint64_t)&v85);
  if (v73 != v75) {
    free(v73);
  }
  if (v68 != v67) {
    free(v68);
  }
  if (v82 != v84) {
    free(v82);
  }
  if (v77 != v76) {
    free(v77);
  }
  BOOL v50 = v55;
  int v26 = *(unsigned char **)a1;
  unint64_t v25 = *(const void **)(a1 + 8);
  if (v25 == *(const void **)a1)
  {
    unsigned int v51 = v55;
    uint64_t v27 = *(unsigned int *)(a1 + 20);
    if (v27) {
      memmove(v55, v25, 8 * v27);
    }
  }
  else
  {
    unsigned int v51 = *(unsigned char **)(a1 + 8);
    *(void *)(a1 + 8) = v26;
    LODWORD(v27) = *(_DWORD *)(a1 + 20);
  }
  int v52 = *(_DWORD *)(a1 + 16);
  int v53 = v27;
  int v54 = *(_DWORD *)(a1 + 24);
  *(void *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  uint64_t v56 = v58;
  unint64_t v57 = 0x800000000;
  unsigned int v28 = *(_DWORD *)(a1 + 104);
  if (v28 && &v50 != (unsigned char **)a1)
  {
    int v29 = *(const void **)(a1 + 96);
    if (v29 == (const void *)(a1 + 112))
    {
      if (v28 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v58, v29, 24 * *(unsigned int *)(a1 + 104));
      LODWORD(v57) = v28;
    }
    else
    {
      uint64_t v56 = *(void **)(a1 + 96);
      unint64_t v57 = __PAIR64__(*(_DWORD *)(a1 + 108), v28);
      *(void *)(a1 + 96) = a1 + 112;
      *(_DWORD *)(a1 + 108) = 0;
    }
    *(_DWORD *)(a1 + 104) = 0;
  }
  unint64_t v41 = v46;
  if (v86 == v85)
  {
    uint64_t v42 = v46;
    int v30 = HIDWORD(v87);
    if (HIDWORD(v87)) {
      memmove(v46, v86, 8 * HIDWORD(v87));
    }
  }
  else
  {
    uint64_t v42 = v86;
    uint64_t v86 = v85;
    int v30 = HIDWORD(v87);
  }
  int v43 = v87;
  int v44 = v30;
  int v45 = v88;
  uint64_t v87 = 8;
  int v88 = 0;
  uint64_t v47 = v49;
  uint64_t v48 = 0x800000000;
  int v31 = v90;
  if (v90)
  {
    if (v89 == v91)
    {
      if (v90 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v49, v89, 24 * v90);
      LODWORD(v++*(_DWORD *)(result + 48) = v31;
    }
    else
    {
      uint64_t v47 = v89;
      uint64_t v48 = v90;
      int v89 = v91;
      HIDWORD(v90) = 0;
    }
    LODWORD(v90) = 0;
  }
  sub_1CBF8DD78((uint64_t)&v50, (uint64_t)&v41, (uint64_t)&v59);
  uint64_t v32 = v91[24];
  uint64_t v33 = (void *)(a4 + 32);
  *(void *)a4 = a4 + 32;
  unint64_t v34 = v60;
  unint64_t v35 = v59;
  if (v60 == v59)
  {
    *(void *)(a4 + 8) = v33;
    int v36 = HIDWORD(v61);
    if (HIDWORD(v61)) {
      memmove(v33, v34, 8 * HIDWORD(v61));
    }
  }
  else
  {
    *(void *)(a4 + 8) = v60;
    int v60 = v35;
    int v36 = HIDWORD(v61);
  }
  *(void *)(a4 + 96) = a4 + 112;
  int v37 = v62;
  *(_DWORD *)(a4 + 16) = v61;
  *(_DWORD *)(a4 + 20) = v36;
  *(_DWORD *)(a4 + 24) = v37;
  uint64_t v61 = 8;
  int v62 = 0;
  *(void *)(a4 + 104) = 0x800000000;
  unsigned int v38 = v64;
  if (v64 && &v59 != (void **)a4)
  {
    if (v63 == v66)
    {
      if (v64 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy((void *)(a4 + 112), v63, 24 * v64);
      *(_DWORD *)(a4 + 104) = v38;
    }
    else
    {
      *(void *)(a4 + 96) = v63;
      int v39 = v65;
      *(_DWORD *)(a4 + 104) = v38;
      *(_DWORD *)(a4 + 108) = v39;
      uint64_t v63 = v66;
      int v65 = 0;
    }
    unsigned int v64 = 0;
  }
  *(void *)(a4 + 304) = v32;
  if (v63 != v66) {
    free(v63);
  }
  if (v60 != v59) {
    free(v60);
  }
  if (v47 != v49) {
    free(v47);
  }
  if (v42 != v41) {
    free(v42);
  }
  if (v56 != v58) {
    free(v56);
  }
  if (v51 != v50) {
    free(v51);
  }
  if (v89 != v91) {
    free(v89);
  }
  if (v86 != v85) {
    free(v86);
  }
  if (v121 != v123) {
    free(v121);
  }
  if (v118 != v117) {
    free(v118);
  }
  if (v114 != v116) {
    free(v114);
  }
  if (__src != v110) {
    free(__src);
  }
}

void sub_1CBF8D614(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v62[24] = *MEMORY[0x1E4F143B8];
  unsigned int v46 = v51;
  uint64_t v7 = *(unsigned char **)a1;
  uint64_t v6 = *(const void **)(a1 + 8);
  if (v6 == *(const void **)a1)
  {
    uint64_t v47 = v51;
    uint64_t v8 = *(unsigned int *)(a1 + 20);
    if (v8) {
      memmove(v51, v6, 8 * v8);
    }
  }
  else
  {
    uint64_t v47 = *(void **)(a1 + 8);
    *(void *)(a1 + 8) = v7;
    LODWORD(v8) = *(_DWORD *)(a1 + 20);
  }
  int v48 = *(_DWORD *)(a1 + 16);
  int v49 = v8;
  int v50 = *(_DWORD *)(a1 + 24);
  *(void *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  int v52 = v54;
  unint64_t v53 = 0x800000000;
  unsigned int v9 = *(_DWORD *)(a1 + 104);
  if (v9 && &v46 != (unsigned char **)a1)
  {
    uint64_t v10 = *(const void **)(a1 + 96);
    if (v10 == (const void *)(a1 + 112))
    {
      if (v9 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v54, v10, 24 * *(unsigned int *)(a1 + 104));
      LODWORD(v53) = v9;
    }
    else
    {
      int v52 = *(void **)(a1 + 96);
      unint64_t v53 = __PAIR64__(*(_DWORD *)(a1 + 108), v9);
      *(void *)(a1 + 96) = a1 + 112;
      *(_DWORD *)(a1 + 108) = 0;
    }
    *(_DWORD *)(a1 + 104) = 0;
  }
  sub_1CBF8E024((uint64_t)&v46, (uint64_t)&v55);
  int v29 = v34;
  unsigned int v12 = *(unsigned char **)a2;
  unsigned int v11 = *(const void **)(a2 + 8);
  if (v11 == *(const void **)a2)
  {
    int v30 = v34;
    uint64_t v13 = *(unsigned int *)(a2 + 20);
    if (v13) {
      memmove(v34, v11, 8 * v13);
    }
  }
  else
  {
    int v30 = *(unsigned char **)(a2 + 8);
    *(void *)(a2 + 8) = v12;
    LODWORD(v13) = *(_DWORD *)(a2 + 20);
  }
  int v31 = *(_DWORD *)(a2 + 16);
  int v32 = v13;
  int v33 = *(_DWORD *)(a2 + 24);
  *(void *)(a2 + 16) = 8;
  *(_DWORD *)(a2 + 24) = 0;
  unint64_t v35 = v37;
  unint64_t v36 = 0x800000000;
  unsigned int v14 = *(_DWORD *)(a2 + 104);
  if (v14 && &v29 != (unsigned char **)a2)
  {
    unsigned int v15 = *(const void **)(a2 + 96);
    if (v15 == (const void *)(a2 + 112))
    {
      if (v14 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v37, v15, 24 * *(unsigned int *)(a2 + 104));
      LODWORD(v36) = v14;
    }
    else
    {
      unint64_t v35 = *(void **)(a2 + 96);
      unint64_t v36 = __PAIR64__(*(_DWORD *)(a2 + 108), v14);
      *(void *)(a2 + 96) = a2 + 112;
      *(_DWORD *)(a2 + 108) = 0;
    }
    *(_DWORD *)(a2 + 104) = 0;
  }
  sub_1CBF8E024((uint64_t)&v29, (uint64_t)&v38);
  unsigned int v16 = (void *)(a3 + 32);
  *(void *)a3 = a3 + 32;
  unsigned int v17 = __src;
  uint64_t v18 = v55;
  if (__src == v55)
  {
    *(void *)(a3 + 8) = v16;
    int v19 = HIDWORD(v57);
    if (HIDWORD(v57)) {
      memmove(v16, v17, 8 * HIDWORD(v57));
    }
  }
  else
  {
    *(void *)(a3 + 8) = __src;
    __src = v18;
    int v19 = HIDWORD(v57);
  }
  *(void *)(a3 + 96) = a3 + 112;
  int v20 = v58;
  *(_DWORD *)(a3 + 16) = v57;
  *(_DWORD *)(a3 + 20) = v19;
  *(_DWORD *)(a3 + 24) = v20;
  uint64_t v57 = 8;
  int v58 = 0;
  *(void *)(a3 + 104) = 0x800000000;
  unsigned int v21 = v60;
  if (v60 && &v55 != (void **)a3)
  {
    if (v59 == v62)
    {
      if (v60 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy((void *)(a3 + 112), v59, 24 * v60);
      *(_DWORD *)(a3 + 104) = v21;
    }
    else
    {
      *(void *)(a3 + 96) = v59;
      int v28 = v61;
      *(_DWORD *)(a3 + 104) = v21;
      *(_DWORD *)(a3 + 108) = v28;
      uint64_t v59 = v62;
      int v61 = 0;
    }
    unsigned int v60 = 0;
  }
  int v22 = (void *)(a3 + 336);
  *(void *)(a3 + 304) = a3 + 336;
  int v24 = v38;
  int v23 = v39;
  if (v39 == v38)
  {
    *(void *)(a3 + 312) = v22;
    int v25 = HIDWORD(v40);
    if (HIDWORD(v40)) {
      memmove(v22, v23, 8 * HIDWORD(v40));
    }
  }
  else
  {
    *(void *)(a3 + 312) = v39;
    int v39 = v24;
    int v25 = HIDWORD(v40);
  }
  int v26 = v41;
  *(_DWORD *)(a3 + 320) = v40;
  *(_DWORD *)(a3 + 324) = v25;
  *(_DWORD *)(a3 + 328) = v26;
  uint64_t v40 = 8;
  int v41 = 0;
  *(void *)(a3 + 400) = a3 + 416;
  *(void *)(a3 + 408) = 0x800000000;
  unsigned int v27 = v43;
  if (v43 && (void **)(a3 + 304) != &v38)
  {
    if (v42 == v45)
    {
      if (v43 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy((void *)(a3 + 416), v42, 24 * v43);
      *(_DWORD *)(a3 + 408) = v27;
    }
    else
    {
      *(void *)(a3 + 400) = v42;
      *(_DWORD *)(a3 + 408) = v27;
      *(_DWORD *)(a3 + 412) = v44;
      uint64_t v42 = v45;
      int v44 = 0;
    }
    unsigned int v43 = 0;
  }
  if (v42 != v45) {
    free(v42);
  }
  if (v39 != v38) {
    free(v39);
  }
  if (v35 != v37) {
    free(v35);
  }
  if (v30 != v29) {
    free(v30);
  }
  if (v59 != v62) {
    free(v59);
  }
  if (__src != v55) {
    free(__src);
  }
  if (v52 != v54) {
    free(v52);
  }
  if (v47 != v46) {
    free(v47);
  }
}

void *sub_1CBF8DB00@<X0>(llvm::SmallPtrSetImplBase *this@<X1>, uint64_t a2@<X2>, char **a3@<X3>, uint64_t a4@<X8>)
{
  while (1)
  {
    uint64_t v8 = *((unsigned int *)this + 26);
    unsigned int v9 = (char *)*((void *)this + 12);
    if (v8 != *(_DWORD *)(a2 + 104)) {
      goto LABEL_11;
    }
    if (!v8) {
      break;
    }
    uint64_t v10 = *(void *)(a2 + 96);
    unsigned int v11 = (char *)*((void *)this + 12);
    while (*(void *)v11 == *(void *)v10 && *((_DWORD *)v11 + 4) == *(_DWORD *)(v10 + 16))
    {
      v11 += 24;
      v10 += 24;
      if (v11 == &v9[24 * v8]) {
        goto LABEL_30;
      }
    }
LABEL_11:
    uint64_t v13 = &v9[24 * v8];
    unsigned int v15 = a3[1];
    unint64_t v14 = (unint64_t)a3[2];
    if ((unint64_t)v15 >= v14)
    {
      unsigned int v17 = *a3;
      uint64_t v18 = (v15 - *a3) >> 3;
      unint64_t v19 = v18 + 1;
      if ((unint64_t)(v18 + 1) >> 61) {
        abort();
      }
      uint64_t v20 = v14 - (void)v17;
      if (v20 >> 2 > v19) {
        unint64_t v19 = v20 >> 2;
      }
      if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v21 = v19;
      }
      if (v21)
      {
        if (v21 >> 61) {
          sub_1CB833614();
        }
        int v22 = (char *)operator new(8 * v21);
      }
      else
      {
        int v22 = 0;
      }
      int v23 = &v22[8 * v18];
      *(void *)int v23 = *((void *)v13 - 3);
      unsigned int v16 = v23 + 8;
      if (v15 != v17)
      {
        do
        {
          uint64_t v24 = *((void *)v15 - 1);
          v15 -= 8;
          *((void *)v23 - 1) = v24;
          v23 -= 8;
        }
        while (v15 != v17);
        unsigned int v15 = *a3;
      }
      *a3 = v23;
      a3[1] = v16;
      a3[2] = &v22[8 * v21];
      if (v15)
      {
        operator delete(v15);
        LODWORD(v8) = *((_DWORD *)this + 26);
      }
    }
    else
    {
      *(void *)unsigned int v15 = *((void *)v13 - 3);
      unsigned int v16 = v15 + 8;
    }
    a3[1] = v16;
    *((_DWORD *)this + 26) = v8 - 1;
    if (v8 != 1) {
      sub_1CBF8E2B0(this);
    }
  }
LABEL_30:
  uint64_t result = (void *)(a4 + 32);
  *(void *)a4 = a4 + 32;
  uint64_t v27 = *(void *)this;
  int v26 = (const void *)*((void *)this + 1);
  if (v26 == *(const void **)this)
  {
    *(void *)(a4 + 8) = result;
    uint64_t v28 = *((unsigned int *)this + 5);
    if (v28) {
      uint64_t result = memmove(result, v26, 8 * v28);
    }
  }
  else
  {
    *(void *)(a4 + 8) = v26;
    *((void *)this + 1) = v27;
    LODWORD(v28) = *((_DWORD *)this + 5);
  }
  *(void *)(a4 + 96) = a4 + 112;
  *(_DWORD *)(a4 + 16) = *((_DWORD *)this + 4);
  *(_DWORD *)(a4 + 20) = v28;
  *(_DWORD *)(a4 + 24) = *((_DWORD *)this + 6);
  *((void *)this + 2) = 8;
  *((_DWORD *)this + 6) = 0;
  *(void *)(a4 + 104) = 0x800000000;
  if (v8 && (llvm::SmallPtrSetImplBase *)a4 != this)
  {
    if (v9 == (char *)this + 112)
    {
      if (v8 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t result = memcpy((void *)(a4 + 112), v9, 24 * v8);
      *(_DWORD *)(a4 + 104) = v8;
    }
    else
    {
      *(void *)(a4 + 96) = v9;
      int v29 = *((_DWORD *)this + 27);
      *(_DWORD *)(a4 + 104) = v8;
      *(_DWORD *)(a4 + 108) = v29;
      *((void *)this + 12) = (char *)this + 112;
      *((_DWORD *)this + 27) = 0;
    }
    *((_DWORD *)this + 26) = 0;
  }
  *(void *)(a4 + 304) = a3;
  return result;
}

void sub_1CBF8DD78(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v33[24] = *MEMORY[0x1E4F143B8];
  int v25 = v30;
  uint64_t v7 = *(unsigned char **)a1;
  uint64_t v6 = *(const void **)(a1 + 8);
  if (v6 == *(const void **)a1)
  {
    int v26 = v30;
    uint64_t v8 = *(unsigned int *)(a1 + 20);
    if (v8) {
      memmove(v30, v6, 8 * v8);
    }
  }
  else
  {
    int v26 = *(unsigned char **)(a1 + 8);
    *(void *)(a1 + 8) = v7;
    LODWORD(v8) = *(_DWORD *)(a1 + 20);
  }
  int v27 = *(_DWORD *)(a1 + 16);
  int v28 = v8;
  int v29 = *(_DWORD *)(a1 + 24);
  *(void *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  int v31 = v33;
  unint64_t v32 = 0x800000000;
  unsigned int v9 = *(_DWORD *)(a1 + 104);
  if (v9 && &v25 != (unsigned char **)a1)
  {
    uint64_t v10 = *(const void **)(a1 + 96);
    if (v10 == (const void *)(a1 + 112))
    {
      if (v9 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v33, v10, 24 * *(unsigned int *)(a1 + 104));
      LODWORD(v32) = v9;
    }
    else
    {
      int v31 = *(void **)(a1 + 96);
      unint64_t v32 = __PAIR64__(*(_DWORD *)(a1 + 108), v9);
      *(void *)(a1 + 96) = a1 + 112;
      *(_DWORD *)(a1 + 108) = 0;
    }
    *(_DWORD *)(a1 + 104) = 0;
  }
  unsigned int v16 = v21;
  unsigned int v12 = *(unsigned char **)a2;
  unsigned int v11 = *(const void **)(a2 + 8);
  if (v11 == *(const void **)a2)
  {
    unsigned int v17 = v21;
    uint64_t v13 = *(unsigned int *)(a2 + 20);
    if (v13) {
      memmove(v21, v11, 8 * v13);
    }
  }
  else
  {
    unsigned int v17 = *(unsigned char **)(a2 + 8);
    *(void *)(a2 + 8) = v12;
    LODWORD(v13) = *(_DWORD *)(a2 + 20);
  }
  int v18 = *(_DWORD *)(a2 + 16);
  int v19 = v13;
  int v20 = *(_DWORD *)(a2 + 24);
  *(void *)(a2 + 16) = 8;
  *(_DWORD *)(a2 + 24) = 0;
  int v22 = v24;
  unint64_t v23 = 0x800000000;
  unsigned int v14 = *(_DWORD *)(a2 + 104);
  if (v14 && &v16 != (unsigned char **)a2)
  {
    unsigned int v15 = *(const void **)(a2 + 96);
    if (v15 == (const void *)(a2 + 112))
    {
      if (v14 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v24, v15, 24 * *(unsigned int *)(a2 + 104));
      LODWORD(v23) = v14;
    }
    else
    {
      int v22 = *(void **)(a2 + 96);
      unint64_t v23 = __PAIR64__(*(_DWORD *)(a2 + 108), v14);
      *(void *)(a2 + 96) = a2 + 112;
      *(_DWORD *)(a2 + 108) = 0;
    }
    *(_DWORD *)(a2 + 104) = 0;
  }
  sub_1CBF8E7A4((uint64_t)&v25, (uint64_t)&v16, a3);
  if (v22 != v24) {
    free(v22);
  }
  if (v17 != v16) {
    free(v17);
  }
  if (v31 != v33) {
    free(v31);
  }
  if (v26 != v25) {
    free(v26);
  }
}

void sub_1CBF8E024(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v27[24] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = v24;
  int v20 = v24;
  int v5 = *(unsigned char **)(a1 + 8);
  if (v5 == *(unsigned char **)a1)
  {
    unint64_t v21 = v24;
    uint64_t v6 = v5;
  }
  else
  {
    uint64_t v19 = *(unsigned int *)(a1 + 16);
    uint64_t v4 = malloc_type_malloc(8 * v19, 0x4065EBACuLL);
    if (!v4 && (v19 || (uint64_t v4 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    unint64_t v21 = v4;
    uint64_t v6 = *(unsigned char **)a1;
    int v5 = *(unsigned char **)(a1 + 8);
  }
  unsigned int v8 = *(_DWORD *)(a1 + 16);
  unsigned int v7 = *(_DWORD *)(a1 + 20);
  LODWORD(v22) = v8;
  if (v5 == v6) {
    unsigned int v9 = v7;
  }
  else {
    unsigned int v9 = v8;
  }
  if (v9)
  {
    memmove(v4, v5, 8 * v9);
    unsigned int v7 = *(_DWORD *)(a1 + 20);
  }
  int v10 = *(_DWORD *)(a1 + 24);
  HIDWORD(v22) = v7;
  int v23 = v10;
  int v25 = v27;
  uint64_t v26 = 0x800000000;
  unsigned int v11 = *(_DWORD *)(a1 + 104);
  if (v11)
  {
    if (&v20 == (unsigned char **)a1)
    {
      unsigned int v11 = 0;
    }
    else
    {
      if (v11 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v27, *(const void **)(a1 + 96), 24 * *(unsigned int *)(a1 + 104));
      LODWORD(v26) = v11;
    }
  }
  unsigned int v12 = (void *)(a2 + 32);
  *(void *)a2 = a2 + 32;
  unsigned int v14 = v20;
  uint64_t v13 = v21;
  if (v21 == v20)
  {
    *(void *)(a2 + 8) = v12;
    int v15 = HIDWORD(v22);
    if (HIDWORD(v22)) {
      memmove(v12, v13, 8 * HIDWORD(v22));
    }
  }
  else
  {
    *(void *)(a2 + 8) = v21;
    unint64_t v21 = v14;
    int v15 = HIDWORD(v22);
  }
  int v16 = v23;
  *(_DWORD *)(a2 + 16) = v22;
  *(_DWORD *)(a2 + 20) = v15;
  *(_DWORD *)(a2 + 24) = v16;
  uint64_t v22 = 8;
  *(void *)(a2 + 96) = a2 + 112;
  int v23 = 0;
  *(void *)(a2 + 104) = 0x800000000;
  unsigned int v17 = v25;
  if (v11 && &v20 != (unsigned char **)a2)
  {
    if (v25 == v27)
    {
      memcpy((void *)(a2 + 112), v27, 24 * v11);
      *(_DWORD *)(a2 + 104) = v11;
      unsigned int v17 = v25;
    }
    else
    {
      *(void *)(a2 + 96) = v25;
      int v18 = HIDWORD(v26);
      *(_DWORD *)(a2 + 104) = v11;
      *(_DWORD *)(a2 + 108) = v18;
      int v25 = v27;
      HIDWORD(v26) = 0;
      unsigned int v17 = v27;
    }
    LODWORD(v26) = 0;
  }
  if (v17 != v27) {
    free(v17);
  }
  if (v21 != v20) {
    free(v21);
  }
}

void sub_1CBF8E2B0(llvm::SmallPtrSetImplBase *this)
{
  while (1)
  {
LABEL_1:
    uint64_t v2 = *((void *)this + 12) + 24 * *((unsigned int *)this + 26);
    uint64_t v3 = *(void *)(v2 - 24);
    uint64_t v4 = *(void *)(v3 + 40);
    if (v4 == v3 + 40)
    {
LABEL_68:
      int v35 = 0;
    }
    else
    {
      uint64_t v5 = v4 - 24;
      if (!v4) {
        uint64_t v5 = 0;
      }
      int v6 = *(unsigned __int8 *)(v5 + 16);
      int v7 = v6 - 29;
      if (v6 == 30)
      {
        int v35 = (*(_DWORD *)(v5 + 20) & 0x7FFFFFF) == 3 ? 2 : 1;
      }
      else
      {
        int v35 = 0;
        switch(v7)
        {
          case 0:
          case 5:
          case 6:
            break;
          case 1:
LABEL_80:
            __break(1u);
            goto LABEL_81;
          case 2:
            int v35 = (*(_DWORD *)(v5 + 20) >> 1) & 0x3FFFFFF;
            break;
          case 3:
          case 9:
            int v35 = (*(_DWORD *)(v5 + 20) & 0x7FFFFFF) - 1;
            break;
          case 4:
            int v35 = 2;
            break;
          case 7:
            int v35 = *(_WORD *)(v5 + 18) & 1;
            break;
          case 8:
LABEL_81:
            int v35 = 1;
            break;
          case 10:
            int v35 = *(_DWORD *)(v5 + 80) + 1;
            break;
          default:
            goto LABEL_68;
        }
      }
    }
    if (*(_DWORD *)(v2 - 8) == v35) {
      break;
    }
    uint64_t v8 = *(void *)(v2 - 16);
    uint64_t v9 = *(void *)(v2 - 8);
    uint64_t v10 = (v9 + 1);
    *(_DWORD *)(v2 - 8) = v10;
    uint64_t v2 = *(unsigned __int8 *)(v8 + 16);
    if (v2 == 30)
    {
      uint64_t v11 = v8 - 32 * v9;
LABEL_12:
      unsigned int v12 = (uint64_t *)(v11 - 32);
    }
    else
    {
      switch(*(unsigned char *)(v8 + 16))
      {
        case ' ':
        case '&':
          int v42 = *(_DWORD *)(v8 + 20);
          if ((v42 & 0x40000000) != 0) {
            uint64_t v43 = *(void *)(v8 - 8);
          }
          else {
            uint64_t v43 = v8 - 32 * (v42 & 0x7FFFFFF);
          }
          unsigned int v12 = (uint64_t *)(v43 + 32 * v10);
          break;
        case '!':
          uint64_t v44 = -64;
          if (!v9) {
            uint64_t v44 = -96;
          }
          unsigned int v12 = (uint64_t *)(v8 + v44);
          break;
        case '""':
        case '#':
          goto LABEL_80;
        case '$':
          if ((*(_WORD *)(v8 + 18) & 1) == 0)
          {
            uint64_t v13 = 0;
            goto LABEL_14;
          }
          uint64_t v38 = v8 - 32 * (*(_DWORD *)(v8 + 20) & 0x7FFFFFF);
LABEL_59:
          unsigned int v12 = (uint64_t *)(v38 + 32);
          break;
        case '%':
          unsigned int v12 = (uint64_t *)(v8 - 32);
          break;
        case '\'':
          if (v9)
          {
            uint64_t v11 = v8 - 32 * *(unsigned int *)(v8 + 80) + 32 * (v9 - 1);
            goto LABEL_12;
          }
          unsigned int v12 = (uint64_t *)(v8 - 32 * *(unsigned int *)(v8 + 80) - 64);
          break;
        default:
          int v36 = *(_DWORD *)(v8 + 20);
          if ((v36 & 0x40000000) != 0) {
            uint64_t v37 = *(void *)(v8 - 8);
          }
          else {
            uint64_t v37 = v8 - 32 * (v36 & 0x7FFFFFF);
          }
          uint64_t v38 = v37 + 32 * (2 * v9);
          goto LABEL_59;
      }
    }
    uint64_t v13 = *v12;
LABEL_14:
    uint64_t v14 = *((void *)this + 1);
    uint64_t v15 = *((unsigned int *)this + 5);
    if (v14 == *(void *)this)
    {
      if (v15)
      {
        int v16 = 0;
        uint64_t v17 = 8 * v15;
        int v18 = (void *)*((void *)this + 1);
        do
        {
          if (*v18 == v13) {
            goto LABEL_1;
          }
          if (*v18 == -2) {
            int v16 = v18;
          }
          ++v18;
          v17 -= 8;
        }
        while (v17);
        if (v16)
        {
          *int v16 = v13;
          --*((_DWORD *)this + 6);
          goto LABEL_25;
        }
      }
      unsigned int v25 = *((_DWORD *)this + 4);
      if (v15 < v25)
      {
        *((_DWORD *)this + 5) = v15 + 1;
        *(void *)(v14 + 8 * v15) = v13;
        goto LABEL_25;
      }
    }
    else
    {
      unsigned int v25 = *((_DWORD *)this + 4);
    }
    if (3 * v25 <= 4 * ((int)v15 - *((_DWORD *)this + 6)))
    {
      if (v25 >= 0x40) {
        v25 *= 2;
      }
      else {
        unsigned int v25 = 128;
      }
LABEL_67:
      llvm::SmallPtrSetImplBase::Grow(this, v25);
      unsigned int v25 = *((_DWORD *)this + 4);
      uint64_t v14 = *((void *)this + 1);
      goto LABEL_34;
    }
    if (v25 - v15 < v25 >> 3) {
      goto LABEL_67;
    }
LABEL_34:
    unsigned int v26 = v25 - 1;
    unsigned int v27 = (v25 - 1) & ((v13 >> 4) ^ (v13 >> 9));
    int v28 = (void *)(v14 + 8 * v27);
    uint64_t v29 = *v28;
    if (*v28 == -1)
    {
      int v33 = 0;
LABEL_45:
      if (v33) {
        unint64_t v34 = v33;
      }
      else {
        unint64_t v34 = v28;
      }
      if (*v34 != v13)
      {
        if (*v34 == -2) {
          --*((_DWORD *)this + 6);
        }
        else {
          ++*((_DWORD *)this + 5);
        }
        *unint64_t v34 = v13;
LABEL_25:
        uint64_t v19 = *(void *)(v13 + 40);
        if (v19 == v13 + 40 || !v19)
        {
          if (v19 == v13 + 40)
          {
            uint64_t v45 = 0;
          }
          else
          {
            if (v19) {
              uint64_t v45 = v19 - 24;
            }
            else {
              uint64_t v45 = 0;
            }
            if (*(unsigned __int8 *)(v45 + 16) - 29 >= 0xB) {
              uint64_t v45 = 0;
            }
          }
          *(void *)&long long v46 = v13;
          *((void *)&v46 + 1) = v45;
          uint64_t v47 = 0;
          unsigned int v40 = *((_DWORD *)this + 26);
          unint64_t v22 = *((void *)this + 12);
          if (v40 >= *((_DWORD *)this + 27))
          {
            BOOL v41 = v22 + 24 * v40 > (unint64_t)&v46;
            if (v22 <= (unint64_t)&v46 && v41) {
LABEL_79:
            }
              llvm::SmallVectorBase<unsigned int>::grow_pod();
LABEL_63:
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
        }
        else
        {
          if (*(unsigned __int8 *)(v19 - 8) - 29 >= 0xB) {
            uint64_t v20 = 0;
          }
          else {
            uint64_t v20 = v19 - 24;
          }
          *(void *)&long long v46 = v13;
          *((void *)&v46 + 1) = v20;
          uint64_t v47 = 0;
          unsigned int v21 = *((_DWORD *)this + 26);
          unint64_t v22 = *((void *)this + 12);
          if (v21 >= *((_DWORD *)this + 27))
          {
            BOOL v39 = v22 + 24 * v21 > (unint64_t)&v46;
            if (v22 <= (unint64_t)&v46 && v39) {
              goto LABEL_79;
            }
            goto LABEL_63;
          }
        }
        uint64_t v23 = v22 + 24 * *((unsigned int *)this + 26);
        long long v24 = v46;
        *(void *)(v23 + 16) = v47;
        *(_OWORD *)uint64_t v23 = v24;
        ++*((_DWORD *)this + 26);
      }
    }
    else
    {
      int v33 = 0;
      int v30 = 1;
      while (v29 != v13)
      {
        if (v33) {
          BOOL v31 = 0;
        }
        else {
          BOOL v31 = v29 == -2;
        }
        if (v31) {
          int v33 = v28;
        }
        unsigned int v32 = v27 + v30++;
        unsigned int v27 = v32 & v26;
        int v28 = (void *)(v14 + 8 * (v32 & v26));
        uint64_t v29 = *v28;
        if (*v28 == -1) {
          goto LABEL_45;
        }
      }
    }
  }
}

void sub_1CBF8E7A4(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v38[24] = *MEMORY[0x1E4F143B8];
  int v30 = v35;
  int v7 = *(unsigned char **)a1;
  int v6 = *(const void **)(a1 + 8);
  if (v6 == *(const void **)a1)
  {
    BOOL v31 = v35;
    uint64_t v8 = *(unsigned int *)(a1 + 20);
    if (v8) {
      memmove(v35, v6, 8 * v8);
    }
  }
  else
  {
    BOOL v31 = *(unsigned char **)(a1 + 8);
    *(void *)(a1 + 8) = v7;
    LODWORD(v8) = *(_DWORD *)(a1 + 20);
  }
  int v32 = *(_DWORD *)(a1 + 16);
  int v33 = v8;
  int v34 = *(_DWORD *)(a1 + 24);
  *(void *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  int v36 = v38;
  unint64_t v37 = 0x800000000;
  unsigned int v9 = *(_DWORD *)(a1 + 104);
  if (v9 && &v30 != (unsigned char **)a1)
  {
    uint64_t v10 = *(const void **)(a1 + 96);
    if (v10 == (const void *)(a1 + 112))
    {
      if (v9 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v38, v10, 24 * *(unsigned int *)(a1 + 104));
      LODWORD(v37) = v9;
    }
    else
    {
      int v36 = *(void **)(a1 + 96);
      unint64_t v37 = __PAIR64__(*(_DWORD *)(a1 + 108), v9);
      *(void *)(a1 + 96) = a1 + 112;
      *(_DWORD *)(a1 + 108) = 0;
    }
    *(_DWORD *)(a1 + 104) = 0;
  }
  uint64_t v11 = v26;
  unint64_t v22 = v26;
  uint64_t v13 = *(unsigned char **)a2;
  unsigned int v12 = *(unsigned char **)(a2 + 8);
  if (v12 == *(unsigned char **)a2)
  {
    uint64_t v23 = v26;
    uint64_t v14 = *(unsigned int *)(a2 + 20);
    if (v14) {
      memmove(v26, v12, 8 * v14);
    }
    unsigned int v12 = v26;
  }
  else
  {
    uint64_t v23 = *(unsigned char **)(a2 + 8);
    *(void *)(a2 + 8) = v13;
    LODWORD(v14) = *(_DWORD *)(a2 + 20);
  }
  LODWORD(v24) = *(_DWORD *)(a2 + 16);
  HIDWORD(v24) = v14;
  int v25 = *(_DWORD *)(a2 + 24);
  *(void *)(a2 + 16) = 8;
  *(_DWORD *)(a2 + 24) = 0;
  unsigned int v27 = v29;
  unint64_t v28 = 0x800000000;
  unsigned int v15 = *(_DWORD *)(a2 + 104);
  if (v15)
  {
    if (&v22 == (unsigned char **)a2)
    {
      unsigned int v15 = 0;
    }
    else
    {
      int v16 = *(const void **)(a2 + 96);
      if (v16 == (const void *)(a2 + 112))
      {
        if (v15 >= 9) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        memcpy(v29, v16, 24 * *(unsigned int *)(a2 + 104));
        LODWORD(v28) = v15;
        uint64_t v11 = v22;
        unsigned int v12 = v23;
      }
      else
      {
        unsigned int v27 = *(void **)(a2 + 96);
        unint64_t v28 = __PAIR64__(*(_DWORD *)(a2 + 108), v15);
        *(void *)(a2 + 96) = a2 + 112;
        *(_DWORD *)(a2 + 108) = 0;
      }
      *(_DWORD *)(a2 + 104) = 0;
    }
  }
  uint64_t v17 = (void *)(a3 + 32);
  *(void *)a3 = a3 + 32;
  if (v12 == v11)
  {
    *(void *)(a3 + 8) = v17;
    int v18 = HIDWORD(v24);
    if (HIDWORD(v24)) {
      memmove(v17, v11, 8 * HIDWORD(v24));
    }
  }
  else
  {
    *(void *)(a3 + 8) = v12;
    uint64_t v23 = v11;
    int v18 = HIDWORD(v24);
  }
  int v19 = v25;
  *(_DWORD *)(a3 + 16) = v24;
  *(_DWORD *)(a3 + 20) = v18;
  *(_DWORD *)(a3 + 24) = v19;
  uint64_t v24 = 8;
  *(void *)(a3 + 96) = a3 + 112;
  int v25 = 0;
  *(void *)(a3 + 104) = 0x800000000;
  uint64_t v20 = v27;
  if (v15 && &v22 != (unsigned char **)a3)
  {
    if (v27 == v29)
    {
      if (v15 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy((void *)(a3 + 112), v29, 24 * v15);
      *(_DWORD *)(a3 + 104) = v15;
      uint64_t v20 = v27;
    }
    else
    {
      *(void *)(a3 + 96) = v27;
      int v21 = HIDWORD(v28);
      *(_DWORD *)(a3 + 104) = v15;
      *(_DWORD *)(a3 + 108) = v21;
      unsigned int v27 = v29;
      HIDWORD(v28) = 0;
      uint64_t v20 = v29;
    }
    LODWORD(v28) = 0;
  }
  if (v20 != v29) {
    free(v20);
  }
  if (v23 != v22) {
    free(v23);
  }
  if (v36 != v38) {
    free(v36);
  }
  if (v31 != v30) {
    free(v31);
  }
}

llvm::SmallPtrSetImplBase *sub_1CBF8EB48(llvm::SmallPtrSetImplBase *this, uint64_t a2)
{
  *((void *)this + 4) = a2;
  *(void *)this = (char *)this + 32;
  *((void *)this + 1) = (char *)this + 32;
  *((_DWORD *)this + 6) = 0;
  *((void *)this + 12) = (char *)this + 112;
  *((_DWORD *)this + 27) = 8;
  *((void *)this + 2) = 0x100000008;
  uint64_t v3 = *(void *)(a2 + 40);
  if (v3 == a2 + 40)
  {
    uint64_t v4 = 0;
  }
  else
  {
    if (v3) {
      uint64_t v4 = v3 - 24;
    }
    else {
      uint64_t v4 = 0;
    }
    if (*(unsigned __int8 *)(v4 + 16) - 29 >= 0xB) {
      uint64_t v4 = 0;
    }
  }
  *((void *)this + 14) = a2;
  *((void *)this + 15) = v4;
  *((void *)this + 16) = 0;
  *((_DWORD *)this + 26) = 1;
  sub_1CBF8E2B0(this);
  return this;
}

uint64_t sub_1CBF8EBE4(uint64_t result, unint64_t a2, int a3)
{
  if (*(unsigned int *)(result + 12) < a2)
  {
    *(_DWORD *)(result + 8) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v3 = *(_DWORD **)result;
  uint64_t v5 = (_DWORD *)(result + 8);
  unint64_t v4 = *(unsigned int *)(result + 8);
  if (v4 >= a2) {
    unint64_t v6 = a2;
  }
  else {
    unint64_t v6 = *(unsigned int *)(result + 8);
  }
  if (v6)
  {
    uint64_t v10 = *(_DWORD **)result;
    do
    {
      *v10++ = a3;
      --v6;
    }
    while (v6);
    unint64_t v4 = *v5;
  }
  unint64_t v7 = v4 - a2;
  if (v4 < a2)
  {
    uint64_t v8 = &v3[v4];
    do
      *v8++ = a3;
    while (!__CFADD__(v7++, 1));
  }
  *uint64_t v5 = a2;
  return result;
}

uint64_t *sub_1CBF8ECA0(uint64_t *result)
{
  uint64_t v1 = result;
  int v2 = *((_DWORD *)result + 2);
  if (v2 || *((_DWORD *)result + 3))
  {
    unsigned int v3 = *((_DWORD *)result + 4);
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      uint64_t v53 = 2;
      uint64_t v54 = 0;
      uint64_t v55 = -4096;
      uint64_t v56 = 0;
      uint64_t v51 = 0;
      int v52 = &unk_1F2601308;
      uint64_t v48 = 2;
      uint64_t v49 = 0;
      uint64_t v50 = -8192;
      unint64_t v4 = (void *)*result;
      uint64_t v5 = *result + 40 * v3;
      do
      {
        uint64_t v6 = v4[3];
        if (v6 != -4096 && v6 != -8192 && v6 != 0)
        {
          unint64_t v8 = v4[1] & 0xFFFFFFFFFFFFFFF8;
          *(void *)unint64_t v8 = v4[2];
          unsigned int v9 = (unint64_t *)v4[2];
          if (v9)
          {
            *unsigned int v9 = *v9 & 7 | v8;
          }
          else
          {
            uint64_t v10 = v4[3];
            uint64_t v11 = ***(int32x2_t ****)v10;
            unint64_t v12 = (unint64_t)v11[303];
            if (v12 <= v8)
            {
              uint64_t v13 = v11[305].u32[0];
              if (v12 + 16 * v13 > v8)
              {
                unsigned int v14 = v13 - 1;
                LODWORD(v15) = v14 & ((v10 >> 4) ^ (v10 >> 9));
                int v16 = (uint64_t *)(v12 + 16 * v15);
                uint64_t v17 = *v16;
                if (v10 == *v16)
                {
LABEL_22:
                  *int v16 = -8192;
                  v11[304] = vadd_s32(v11[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v10 = v4[3];
                }
                else
                {
                  int v18 = 1;
                  while (v17 != -4096)
                  {
                    int v19 = v15 + v18++;
                    uint64_t v15 = v19 & v14;
                    uint64_t v17 = *(void *)(v12 + 16 * v15);
                    if (v10 == v17)
                    {
                      int v16 = (uint64_t *)(v12 + 16 * v15);
                      goto LABEL_22;
                    }
                  }
                }
                *(unsigned char *)(v10 + 17) &= ~1u;
              }
            }
          }
        }
        v4 += 5;
      }
      while (v4 != (void *)v5);
      if (v50 != -8192 && v50 != -4096 && v50 != 0) {
        llvm::ValueHandleBase::RemoveFromUseList(&v48);
      }
      if (v55 != -4096 && v55 != -8192 && v55) {
        llvm::ValueHandleBase::RemoveFromUseList(&v53);
      }
      int v20 = 1 << (33 - __clz(v2 - 1));
      if (v20 <= 64) {
        int v20 = 64;
      }
      if (v2) {
        int v21 = v20;
      }
      else {
        int v21 = 0;
      }
      if (v21 != *((_DWORD *)v1 + 4))
      {
        uint64_t result = (uint64_t *)MEMORY[0x1D25D9CD0](*v1, 8);
        if (!v21)
        {
          *uint64_t v1 = 0;
          v1[1] = 0;
          *((_DWORD *)v1 + 4) = 0;
          return result;
        }
        unint64_t v22 = (4 * v21 / 3u + 1) | ((unint64_t)(4 * v21 / 3u + 1) >> 1);
        unint64_t v23 = v22 | (v22 >> 2) | ((v22 | (v22 >> 2)) >> 4);
        LODWORD(v23) = (((v23 | (v23 >> 8)) >> 16) | v23 | (v23 >> 8)) + 1;
        *((_DWORD *)v1 + 4) = v23;
        *uint64_t v1 = operator new(40 * v23, (std::align_val_t)8uLL);
      }
      return sub_1CBF8AD4C(v1);
    }
    uint64_t v53 = 2;
    uint64_t v54 = 0;
    uint64_t v55 = -4096;
    uint64_t v56 = 0;
    uint64_t v51 = 0;
    int v52 = &unk_1F2601308;
    uint64_t v48 = 2;
    uint64_t v49 = 0;
    uint64_t v50 = -8192;
    if (v3)
    {
      uint64_t result = &v48;
      uint64_t v24 = (void *)*v1;
      uint64_t v25 = *v1 + 40 * v3;
      do
      {
        uint64_t v26 = v24[3];
        uint64_t v27 = v55;
        if (v26 != v55)
        {
          BOOL v28 = v26 == -4096 || v26 == 0;
          if (!v28 && v26 != -8192)
          {
            unint64_t v33 = v24[1] & 0xFFFFFFFFFFFFFFF8;
            *(void *)unint64_t v33 = v24[2];
            int v34 = (unint64_t *)v24[2];
            if (v34)
            {
              *int v34 = *v34 & 7 | v33;
            }
            else
            {
              uint64_t v35 = v24[3];
              int v36 = ***(int32x2_t ****)v35;
              unint64_t v37 = (unint64_t)v36[303];
              if (v37 <= v33)
              {
                uint64_t v38 = v36[305].u32[0];
                if (v37 + 16 * v38 > v33)
                {
                  unsigned int v39 = v38 - 1;
                  LODWORD(v40) = v39 & ((v35 >> 4) ^ (v35 >> 9));
                  BOOL v41 = (uint64_t *)(v37 + 16 * v40);
                  uint64_t v42 = *v41;
                  if (v35 == *v41)
                  {
LABEL_63:
                    *BOOL v41 = -8192;
                    v36[304] = vadd_s32(v36[304], (int32x2_t)0x1FFFFFFFFLL);
                    uint64_t v35 = v24[3];
                  }
                  else
                  {
                    int v43 = 1;
                    while (v42 != -4096)
                    {
                      int v44 = v40 + v43++;
                      uint64_t v40 = v44 & v39;
                      uint64_t v42 = *(void *)(v37 + 16 * v40);
                      if (v35 == v42)
                      {
                        BOOL v41 = (uint64_t *)(v37 + 16 * v40);
                        goto LABEL_63;
                      }
                    }
                  }
                  *(unsigned char *)(v35 + 17) &= ~1u;
                }
              }
            }
            uint64_t v27 = v55;
          }
          v24[3] = v27;
          if (v27 != -4096 && v27 != -8192 && v27 != 0)
          {
            uint64_t v30 = v53;
            BOOL v31 = (void *)(v53 & 0xFFFFFFFFFFFFFFF8);
            void v24[2] = *(void *)(v53 & 0xFFFFFFFFFFFFFFF8);
            *BOOL v31 = v24 + 1;
            v24[1] = v30 & 0xFFFFFFFFFFFFFFF8 | v24[1] & 7;
            int v32 = (unint64_t *)v24[2];
            if (v32) {
              *int v32 = *v32 & 7 | (unint64_t)(v24 + 2);
            }
          }
        }
        void v24[4] = v56;
        v24 += 5;
      }
      while (v24 != (void *)v25);
      uint64_t v45 = v50;
      v1[1] = 0;
      if (v45 != -8192 && v45 != -4096 && v45 != 0) {
        uint64_t result = llvm::ValueHandleBase::RemoveFromUseList(&v48);
      }
    }
    else
    {
      result[1] = 0;
    }
    if (v55 != -4096 && v55 != -8192 && v55) {
      return llvm::ValueHandleBase::RemoveFromUseList(&v53);
    }
  }
  return result;
}

uint64_t sub_1CBF8F170(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (v3)
  {
    uint64_t v4 = *a2;
    int v5 = *((_DWORD *)a2 + 2);
    unint64_t v6 = ~((unint64_t)(37 * v5) << 32)
       + (37 * v5)
       + ((unint64_t)((*a2 >> 4) ^ (*a2 >> 9)) << 32);
    unint64_t v7 = (v6 ^ (v6 >> 22)) + ~((v6 ^ (v6 >> 22)) << 13);
    unint64_t v8 = (9 * (v7 ^ (v7 >> 8))) ^ ((9 * (v7 ^ (v7 >> 8))) >> 15);
    int v9 = ((v8 + ~(v8 << 27)) >> 31) ^ (v8 + ~(v8 << 27));
    int v10 = v3 - 1;
    unsigned int v11 = (v3 - 1) & v9;
    uint64_t v12 = *(void *)a1 + 24 * v11;
    uint64_t v13 = *(void *)v12;
    int v14 = *(_DWORD *)(v12 + 8);
    if (v4 == *(void *)v12 && v5 == v14)
    {
LABEL_22:
      uint64_t result = 1;
    }
    else
    {
      uint64_t v16 = 0;
      int v17 = 1;
      while (v13 != -4096 || v14 != -1)
      {
        if (v16) {
          BOOL v18 = 0;
        }
        else {
          BOOL v18 = v14 == -2;
        }
        if (v18 && v13 == -8192) {
          uint64_t v16 = v12;
        }
        unsigned int v20 = v11 + v17++;
        unsigned int v11 = v20 & v10;
        uint64_t v12 = *(void *)a1 + 24 * (v20 & v10);
        uint64_t v13 = *(void *)v12;
        int v14 = *(_DWORD *)(v12 + 8);
        if (v4 == *(void *)v12 && v5 == v14) {
          goto LABEL_22;
        }
      }
      uint64_t result = 0;
      if (v16) {
        uint64_t v12 = v16;
      }
    }
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t result = 0;
  }
  *a3 = v12;
  return result;
}