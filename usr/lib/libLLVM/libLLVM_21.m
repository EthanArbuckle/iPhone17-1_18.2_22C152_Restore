uint64_t sub_1CC2FEEBC(unsigned int *a1, unsigned int a2)
{
  unsigned int v2;
  uint64_t v3;
  llvm::IntervalMapImpl::Path *v4;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  int v31;
  unint64_t v32;
  unsigned int v33;
  int v34;
  unsigned int v35;
  uint64_t v36;
  char v37;
  unsigned int i;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  int *v53;
  uint64_t v54;
  int v55;
  int v56;
  int v57;
  uint64_t v58;
  unsigned int v59;
  uint64_t v60;
  unint64_t *v61;
  uint64_t v62;
  BOOL v63;
  unsigned int v65;
  int v66;
  uint64_t v67;
  char v68;
  unsigned int v69;
  uint64_t v70;
  unsigned int v71;
  unsigned int v72;
  char *v73;
  unsigned int v74;
  _DWORD v76[4];
  _OWORD v77[2];
  _DWORD v78[4];
  uint64_t v79;

  v2 = a2;
  v79 = *MEMORY[0x1E4F143B8];
  v4 = (llvm::IntervalMapImpl::Path *)(a1 + 2);
  v3 = *((void *)a1 + 1);
  memset(v77, 0, sizeof(v77));
  v6 = *(_DWORD *)(v3 + 16 * a2 + 12);
  if (a2)
  {
    v7 = -1;
    while (1)
    {
      v8 = a2 + v7;
      if (!(a2 + v7)) {
        break;
      }
      v9 = *(_DWORD *)(v3 + 16 * v8 + 12);
      --v7;
      if (v9)
      {
        LODWORD(v10) = a2 + v7 + 2;
        goto LABEL_8;
      }
    }
    v9 = *(_DWORD *)(v3 + 12);
    LODWORD(v10) = 1;
    if (!v9)
    {
      LODWORD(v11) = 0;
      goto LABEL_13;
    }
LABEL_8:
    v11 = *(void *)(*(void *)(v3 + 16 * v8) + 8 * (v9 - 1));
    if (v10 != a2)
    {
      v66 = a2 - v10;
      do
      {
        v11 = *(void *)((v11 & 0xFFFFFFFFFFFFFFC0) + 8 * (v11 & 0x3F));
        --v66;
      }
      while (v66);
    }
    if (v11)
    {
      LOBYTE(v10) = 0;
      v9 = (v11 & 0x3F) + 1;
      v78[0] = v9;
      v6 += v9;
      *(void *)&v77[0] = v11 & 0xFFFFFFFFFFFFFFC0;
      LODWORD(v11) = 1;
      goto LABEL_13;
    }
    v9 = 0;
  }
  else
  {
    v9 = 0;
    LODWORD(v11) = 0;
  }
  LOBYTE(v10) = 1;
LABEL_13:
  v12 = v3 + 16 * a2;
  v13 = *(_DWORD *)(v12 + 8);
  v78[v11] = v13;
  v14 = v13 + v9;
  v15 = v11 + 1;
  *(void *)((unint64_t)v77 | (8 * v11)) = *(void *)v12;
  if (v2)
  {
    v16 = -1;
    while (1)
    {
      v17 = a2 + v16;
      if (!(a2 + v16)) {
        break;
      }
      v18 = *(_DWORD *)(v3 + 16 * v17 + 12);
      v19 = *(_DWORD *)(v3 + 16 * v17 + 8) - 1;
      --v16;
      if (v18 != v19)
      {
        v20 = a2 + v16 + 2;
        goto LABEL_19;
      }
    }
    v18 = *(_DWORD *)(v3 + 12);
    v19 = *(_DWORD *)(v3 + 8) - 1;
    v20 = 1;
LABEL_19:
    if (v18 != v19)
    {
      v21 = *(void *)(*(void *)(v3 + 16 * v17) + 8 * (v18 + 1));
      if (v20 != a2)
      {
        v65 = v2 - v20;
        do
        {
          v21 = *(void *)(v21 & 0xFFFFFFFFFFFFFFC0);
          --v65;
        }
        while (v65);
      }
      if (v21)
      {
        v22 = (v21 & 0x3F) + 1;
        v78[v15] = v22;
        v14 += v22;
        *((void *)v77 + v15) = v21 & 0xFFFFFFFFFFFFFFC0;
        v15 = v11 | 2;
      }
    }
  }
  v23 = v14 + 1;
  if (v14 + 1 <= 8 * v15)
  {
    LODWORD(v24) = 0;
  }
  else
  {
    if (v15 == 1) {
      v24 = 1;
    }
    else {
      v24 = v15 - 1;
    }
    v78[v15] = v78[v24];
    *((void *)v77 + v15) = *((void *)v77 + v24);
    v78[v24] = 0;
    v25 = *(void *)(*(void *)a1 + 200);
    v26 = *(void *)v25;
    if (*(void *)v25)
    {
      *(void *)v25 = *(void *)v26;
    }
    else
    {
      *(void *)(v25 + 88) += 192;
      v67 = *(void *)(v25 + 8);
      if (((v67 + 63) & 0xFFFFFFFFFFFFFFC0) - v67 + 192 > *(void *)(v25 + 16) - v67)
      {
        v68 = v10;
        v69 = v6;
        v70 = v24;
        v71 = v15;
        v72 = *(_DWORD *)(v25 + 32) >> 7;
        if (v72 >= 0x1E) {
          LOBYTE(v72) = 30;
        }
        v10 = 4096 << v72;
        v73 = (char *)operator new(4096 << v72, (std::align_val_t)8uLL);
        v74 = *(_DWORD *)(v25 + 32);
        if (v74 >= *(_DWORD *)(v25 + 36)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v25 + 24) + 8 * v74) = v73;
        ++*(_DWORD *)(v25 + 32);
        v26 = (unint64_t)(v73 + 63) & 0xFFFFFFFFFFFFFFC0;
        *(void *)(v25 + 8) = v26 + 192;
        *(void *)(v25 + 16) = &v73[v10];
        v15 = v71;
        v24 = v70;
        v6 = v69;
        LOBYTE(v10) = v68;
      }
      else
      {
        v26 = (v67 + 63) & 0xFFFFFFFFFFFFFFC0;
        *(void *)(v25 + 8) = v26 + 192;
      }
    }
    *(_OWORD *)v26 = 0u;
    *(_OWORD *)(v26 + 16) = 0u;
    *(_OWORD *)(v26 + 160) = 0u;
    *(_OWORD *)(v26 + 176) = 0u;
    *(_OWORD *)(v26 + 128) = 0u;
    *(_OWORD *)(v26 + 144) = 0u;
    *(_OWORD *)(v26 + 96) = 0u;
    *(_OWORD *)(v26 + 112) = 0u;
    *(_OWORD *)(v26 + 64) = 0u;
    *(_OWORD *)(v26 + 80) = 0u;
    ++v15;
    *(_OWORD *)(v26 + 32) = 0u;
    *(_OWORD *)(v26 + 48) = 0u;
    *((void *)v77 + v24) = v26;
  }
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = v15;
  v31 = v23 / v15;
  v32 = v23 % v15;
  v33 = v15;
  do
  {
    if (v27 >= v32) {
      v34 = v31;
    }
    else {
      v34 = v31 + 1;
    }
    v76[v27] = v34;
    v35 = v6 - v28;
    v28 += v34;
    if (v33 == v15 && v28 > v6)
    {
      v33 = v27;
      v29 = v35;
    }
    ++v27;
  }
  while (v15 != v27);
  --v76[v33];
  sub_1CC2FF724((uint64_t)v77, v15, (uint64_t)v78, (uint64_t)v76);
  if ((v10 & 1) == 0) {
    llvm::IntervalMapImpl::Path::moveLeft(v4, v2);
  }
  v36 = 0;
  v37 = 0;
  for (i = v33; ; --i)
  {
    v39 = *((void *)v77 + v36);
    v40 = v76[v36];
    v41 = (v40 - 1);
    v42 = *(void *)(v39 + 16 * v41 + 8);
    if (v24 && v36 == v24)
    {
      v43 = sub_1CC2FF860(a1, v2, v39 & 0xFFFFFFFFFFFFFFC0 | v41, v42);
      v37 = v43;
      v2 += v43;
    }
    else
    {
      v44 = *(void *)v4;
      *(_DWORD *)(*(void *)v4 + 16 * v2 + 8) = v40;
      if (v2)
      {
        *(void *)(*(void *)(v44 + 16 * (v2 - 1)) + 8 * *(unsigned int *)(v44 + 16 * (v2 - 1) + 12)) = *(void *)(*(void *)(v44 + 16 * (v2 - 1)) + 8 * *(unsigned int *)(v44 + 16 * (v2 - 1) + 12)) & 0xFFFFFFFFFFFFFFC0 | v41;
        v45 = 16 * v2;
        while (1)
        {
          v46 = v45 - 16;
          if (v45 == 16) {
            break;
          }
          v47 = v44 + v45;
          v48 = *(unsigned int *)(v47 - 4);
          *(void *)(*(void *)(v47 - 16) + 8 * v48 + 96) = v42;
          v49 = *(_DWORD *)(v47 - 8) - 1;
          v45 = v46;
          if (v48 != v49) {
            goto LABEL_50;
          }
        }
        *(void *)(*(void *)v44 + 8 * *(unsigned int *)(v44 + 12) + 88) = v42;
      }
    }
LABEL_50:
    if (v36 + 1 == v30) {
      break;
    }
    v50 = 0;
    v51 = 0;
    ++v36;
    v52 = *(void *)v4;
    v53 = (int *)(*(void *)v4 + 16 * (v2 - 1) + 12);
    while (1)
    {
      v54 = v51;
      v55 = v50;
      if (v2 + v51 == 1) {
        break;
      }
      v56 = *(v53 - 1);
      v57 = *v53;
      --v51;
      v53 -= 4;
      --v50;
      if (v57 != v56 - 1)
      {
        v58 = v2 - 1 + v54;
        goto LABEL_56;
      }
    }
    v58 = 0;
    v56 = *(_DWORD *)(v52 + 8);
    v57 = *(_DWORD *)(v52 + 12);
LABEL_56:
    v59 = v57 + 1;
    *(_DWORD *)(v52 + 16 * v58 + 12) = v59;
    if (v59 != v56)
    {
      v60 = *(void *)(*(void *)(v52 + 16 * v58) + 8 * v59);
      if (v54)
      {
        do
        {
          v62 = *(void *)v4 + 16 * (v2 + v55);
          *(void *)v62 = v60 & 0xFFFFFFFFFFFFFFC0;
          *(_DWORD *)(v62 + 8) = (v60 & 0x3F) + 1;
          *(_DWORD *)(v62 + 12) = 0;
          v60 = *(void *)(v60 & 0xFFFFFFFFFFFFFFC0);
          v63 = __CFADD__(v55++, 1);
        }
        while (!v63);
        v52 = *(void *)v4;
      }
      v61 = (unint64_t *)(v52 + 16 * v2);
      *v61 = v60 & 0xFFFFFFFFFFFFFFC0;
      v61[1] = (v60 & 0x3F) + 1;
    }
  }
  if (v33 != v36)
  {
    do
    {
      llvm::IntervalMapImpl::Path::moveLeft(v4, v2);
      v63 = __CFADD__(i++, 1);
    }
    while (!v63);
  }
  *(_DWORD *)(*(void *)v4 + 16 * v2 + 12) = v29;
  return v37 & 1;
}

uint64_t *sub_1CC2FF49C(uint64_t *result, unsigned int a2)
{
  v3 = result;
  uint64_t v4 = *result;
  v6 = result + 1;
  uint64_t v5 = result[1];
  uint64_t v7 = a2 - 1;
  if (a2 != 1)
  {
    uint64_t v14 = v5 + 16 * v7;
    v15 = *(void **)(v5 + 16 * (a2 - 1));
    int v18 = *(_DWORD *)(v14 + 8);
    v17 = (_DWORD *)(v14 + 8);
    int v16 = v18;
    int v19 = v18 - 1;
    if (v18 == 1)
    {
      v31 = *(void **)(v4 + 200);
      void *v15 = *v31;
      void *v31 = v15;
      result = (uint64_t *)sub_1CC2FF49C(result, a2 - 1);
    }
    else
    {
      int v20 = *(_DWORD *)(v5 + 16 * v7 + 12);
      if (v20 + 1 != v16)
      {
        unsigned int v21 = *(_DWORD *)(v5 + 16 * v7 + 12);
        do
        {
          v15[v21] = v15[v21 + 1];
          v15[v21 + 12] = v15[v21 + 13];
          ++v21;
        }
        while (v19 != v21);
      }
      _DWORD *v17 = v19;
      uint64_t v22 = v5 + 16 * (a2 - 2);
      uint64_t v23 = *(unsigned int *)(v22 + 12);
      uint64_t v24 = *(void *)v22;
      uint64_t v25 = *(void *)(*(void *)v22 + 8 * v23);
      uint64_t v26 = (v16 - 2);
      *(void *)(v24 + 8 * v23) = v25 & 0xFFFFFFFFFFFFFFC0 | v26;
      if (v20 == v19)
      {
        sub_1CC2FEC0C((uint64_t)result, a2 - 1, v15[v26 + 12]);
        result = llvm::IntervalMapImpl::Path::moveRight(v6, v7);
      }
    }
    goto LABEL_5;
  }
  unsigned int v8 = *(_DWORD *)(v5 + 12);
  int v9 = *(_DWORD *)(v4 + 196);
  if (v8 + 1 != v9)
  {
    do
    {
      *(void *)(v4 + 8 + 8 * v8) = *(void *)(v4 + 8 + 8 * (v8 + 1));
      *(void *)(v4 + 96 + 8 * v8) = *(void *)(v4 + 96 + 8 * (v8 + 1));
      ++v8;
    }
    while (v9 - 1 != v8);
  }
  int v10 = v9 - 1;
  *(_DWORD *)(v4 + 196) = v10;
  *(_DWORD *)(v5 + 8) = v10;
  if (v10)
  {
LABEL_5:
    if (*((_DWORD *)v3 + 4))
    {
      uint64_t v11 = *v6;
      if (*(_DWORD *)(*v6 + 12) < *(_DWORD *)(*v6 + 8))
      {
        uint64_t v12 = *(void *)(*(void *)(v11 + 16 * v7)
                        + 8 * *(unsigned int *)(v11 + 16 * v7 + 12));
        uint64_t v13 = v11 + 16 * a2;
        *(void *)uint64_t v13 = v12 & 0xFFFFFFFFFFFFFFC0;
        *(_DWORD *)(v13 + 8) = (v12 & 0x3F) + 1;
        *(_DWORD *)(*v6 + 16 * a2 + 12) = 0;
      }
    }
    return result;
  }
  *(_DWORD *)(v4 + 192) = 0;
  *(_OWORD *)(v4 + 160) = 0u;
  *(_OWORD *)(v4 + 176) = 0u;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_OWORD *)(v4 + 144) = 0u;
  *(_OWORD *)(v4 + 96) = 0u;
  *(_OWORD *)(v4 + 112) = 0u;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_OWORD *)(v4 + 80) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)uint64_t v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  uint64_t v27 = *result;
  if (*(_DWORD *)(*result + 192))
  {
    unsigned int v28 = *(_DWORD *)(v27 + 196);
    *((_DWORD *)result + 4) = 0;
    v29 = result + 2;
    if (!*((_DWORD *)result + 5)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v30 = *v6;
    *(void *)uint64_t *v6 = v27 + 8;
  }
  else
  {
    unsigned int v28 = *(_DWORD *)(v27 + 196);
    *((_DWORD *)result + 4) = 0;
    v29 = result + 2;
    if (!*((_DWORD *)result + 5)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v30 = *v6;
    *(void *)uint64_t *v6 = v27;
  }
  *(void *)(v30 + 8) = v28;
  ++*v29;
  return result;
}

uint64_t sub_1CC2FF724(uint64_t result, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - 1;
  if (a2 != 1)
  {
    uint64_t v8 = result;
    uint64_t v9 = (int)v4;
    uint64_t v10 = a3 - 4;
    uint64_t v11 = result - 8;
    do
    {
      unsigned int v12 = *(_DWORD *)(a3 + 4 * v9);
      unsigned int v13 = *(_DWORD *)(a4 + 4 * v9);
      if (v12 != v13)
      {
        uint64_t v14 = v9;
        do
        {
          if (!v14) {
            break;
          }
          result = sub_1CC3001A8(*(void *)(v8 + 8 * v9), v12, *(void *)(v11 + 8 * v14), *(_DWORD *)(v10 + 4 * v14), v13 - v12);
          *(_DWORD *)(v10 + 4 * v14) -= result;
          unsigned int v12 = *(_DWORD *)(a3 + 4 * v9) + result;
          *(_DWORD *)(a3 + 4 * v9) = v12;
          unsigned int v13 = *(_DWORD *)(a4 + 4 * v9);
          --v14;
        }
        while (v12 < v13);
      }
      --v9;
    }
    while (v9);
    if (a2 >= 2)
    {
      uint64_t v15 = 0;
      int v16 = 1;
      do
      {
        unsigned int v17 = *(_DWORD *)(a3 + 4 * v15);
        unsigned int v18 = *(_DWORD *)(a4 + 4 * v15);
        if (v17 != v18)
        {
          unsigned int v19 = v16;
          do
          {
            if (a2 == v19) {
              break;
            }
            result = sub_1CC3001A8(*(void *)(v8 + 8 * v19), *(_DWORD *)(a3 + 4 * v19), *(void *)(v8 + 8 * v15), v17, v17 - v18);
            *(_DWORD *)(a3 + 4 * v19) += result;
            unsigned int v17 = *(_DWORD *)(a3 + 4 * v15) - result;
            *(_DWORD *)(a3 + 4 * v15) = v17;
            unsigned int v18 = *(_DWORD *)(a4 + 4 * v15);
            ++v19;
          }
          while (v17 < v18);
        }
        ++v15;
        ++v16;
      }
      while (v15 != v4);
    }
  }
  return result;
}

BOOL sub_1CC2FF860(unsigned int *a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v127 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (llvm::IntervalMapImpl::Path *)(a1 + 2);
  uint64_t v7 = *(void *)a1;
  BOOL v9 = a2 == 1;
  if (a2 == 1)
  {
    uint64_t v10 = *(unsigned int *)(v7 + 196);
    if (v10 <= 0xA)
    {
      uint64_t v11 = v7 + 8;
      uint64_t v12 = *(void *)v8;
      uint64_t v13 = *(unsigned int *)(*(void *)v8 + 12);
      if (v10 != v13)
      {
        unsigned int v14 = *(_DWORD *)(v7 + 196);
        do
        {
          *(void *)(v11 + 8 * v14) = *(void *)(v11 + 8 * (v14 - 1));
          *(void *)(v7 + 96 + 8 * v14) = *(void *)(v7 + 96 + 8 * (v14 - 1));
          --v14;
        }
        while (v13 != v14);
      }
      BOOL v9 = 0;
      uint64_t v15 = (void *)(v11 + 8 * v13);
      void *v15 = a3;
      v15[11] = a4;
      *(_DWORD *)(v7 + 196) = v10 + 1;
      *(_DWORD *)(v12 + 8) = v10 + 1;
      uint64_t v16 = *(void *)(*(void *)v12 + 8 * v13);
      *(void *)(v12 + 16) = v16 & 0xFFFFFFFFFFFFFFC0;
      *(_DWORD *)(v12 + 24) = (v16 & 0x3F) + 1;
      return v9;
    }
    uint64_t v18 = *(unsigned int *)(*(void *)v8 + 12);
    unint64_t v19 = sub_1CC300300(*(void *)(v7 + 200));
    int v20 = (uint64_t *)(v7 + 96);
    unsigned int v21 = (void *)v19;
    uint64_t v22 = v10;
    do
    {
      *unsigned int v21 = *(v20 - 11);
      uint64_t v23 = *v20++;
      v21[12] = v23;
      ++v21;
      --v22;
    }
    while (v22);
    uint64_t v24 = (v10 - 1);
    *(void *)(v7 + 96) = *(void *)((v19 & 0xFFFFFFFFFFFFFFC0 | v24 & 0xFFFFFFFFFFFFFFC0)
                                     + 8 * v24
                                     + 0x60);
    *(void *)(v7 + 8) = v19 & 0xFFFFFFFFFFFFFFC0 | v24;
    ++*(_DWORD *)(v7 + 192);
    *(_DWORD *)(v7 + 196) = 1;
    uint64_t v25 = (void *)*((void *)a1 + 1);
    *uint64_t v25 = v7 + 8;
    v25[1] = 1;
    uint64_t v26 = *((void *)a1 + 1);
    unint64_t v27 = *(void *)(*(void *)v26 + 8 * *(unsigned int *)(v26 + 12)) & 0xFFFFFFFFFFFFFFC0;
    uint64_t v28 = (*(void *)(*(void *)v26 + 8 * *(unsigned int *)(v26 + 12)) & 0x3FLL | (v18 << 32)) + 1;
    uint64_t v29 = a1[4];
    unsigned int v30 = a1[5];
    if (v29 == 1)
    {
      if (v30 <= 1) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(v26 + 16) = v27;
      *(void *)(v26 + 24) = v28;
      ++a1[4];
    }
    else
    {
      if (v29 >= v30) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_OWORD *)(v26 + 16 * v29) = *(_OWORD *)(v26 + 16 * v29 - 16);
      uint64_t v109 = a1[4];
      uint64_t v110 = *((void *)a1 + 1) + 16 * v109 - 16;
      if (v110 != v26 + 16)
      {
        memmove((void *)(v26 + 32), (const void *)(v26 + 16), v110 - (v26 + 16));
        LODWORD(v109) = a1[4];
      }
      a1[4] = v109 + 1;
      *(void *)(v26 + 16) = v27;
      *(void *)(v26 + 24) = v28;
    }
    a2 = 2;
  }
  uint64_t v31 = (a2 - 1);
  if (!a1[4] || (uint64_t v32 = *(void *)v8, *(_DWORD *)(*(void *)v8 + 12) >= *(_DWORD *)(*(void *)v8 + 8)))
  {
    int v115 = a2;
    llvm::IntervalMapImpl::Path::moveLeft(v8, a2 - 1);
    a2 = v115;
    uint64_t v32 = *(void *)v8;
    ++*(_DWORD *)(*(void *)v8 + 16 * v31 + 12);
  }
  uint64_t v33 = v31;
  unsigned int v34 = *(_DWORD *)(v32 + 16 * v31 + 8);
  if (v34 == 12)
  {
    long long v124 = 0u;
    long long v125 = 0u;
    unsigned int v44 = *(_DWORD *)(v32 + 16 * v31 + 12);
    unsigned int v45 = v31 - 1;
    unsigned int v46 = v31 - 1;
    int v47 = a2;
    while (1)
    {
      uint64_t v48 = v46;
      if (!v46) {
        break;
      }
      int v49 = *(_DWORD *)(v32 + 16 * v46 + 12);
      --v47;
      --v46;
      if (v49) {
        goto LABEL_89;
      }
    }
    int v49 = *(_DWORD *)(v32 + 12);
    int v47 = 1;
    if (!v49)
    {
      LODWORD(v50) = 0;
      goto LABEL_29;
    }
LABEL_89:
    uint64_t v50 = *(void *)(*(void *)(v32 + 16 * v48) + 8 * (v49 - 1));
    if (v47 != v31)
    {
      int v114 = ~v47 + a2;
      do
      {
        uint64_t v50 = *(void *)((v50 & 0xFFFFFFFFFFFFFFC0) + 8 * (v50 & 0x3F));
        --v114;
      }
      while (v114);
    }
    if (v50)
    {
      LOBYTE(v47) = 0;
      int v49 = (v50 & 0x3F) + 1;
      v126[0] = v49;
      v44 += v49;
      *(void *)&long long v124 = v50 & 0xFFFFFFFFFFFFFFC0;
      LODWORD(v50) = 1;
    }
    else
    {
      int v49 = 0;
      LOBYTE(v47) = 1;
    }
LABEL_29:
    uint64_t v51 = v32 + 16 * v31;
    int v52 = *(_DWORD *)(v51 + 8);
    v126[v50] = v52;
    int v53 = v52 + v49;
    unsigned int v54 = v50 + 1;
    *(void *)((unint64_t)&v124 | (8 * v50)) = *(void *)v51;
    int v55 = a2;
    while (1)
    {
      uint64_t v56 = v45;
      if (!v45) {
        break;
      }
      int v57 = *(_DWORD *)(v32 + 16 * v45 + 12);
      int v58 = *(_DWORD *)(v32 + 16 * v45 + 8) - 1;
      --v55;
      --v45;
      if (v57 != v58) {
        goto LABEL_34;
      }
    }
    int v57 = *(_DWORD *)(v32 + 12);
    int v58 = *(_DWORD *)(v32 + 8) - 1;
    int v55 = 1;
LABEL_34:
    if (v57 != v58)
    {
      uint64_t v59 = *(void *)(*(void *)(v32 + 16 * v56) + 8 * (v57 + 1));
      if (v55 != v31)
      {
        int v113 = ~v55 + a2;
        do
        {
          uint64_t v59 = *(void *)(v59 & 0xFFFFFFFFFFFFFFC0);
          --v113;
        }
        while (v113);
      }
      if (v59)
      {
        int v60 = (v59 & 0x3F) + 1;
        v126[v54] = v60;
        v53 += v60;
        *((void *)&v124 + v54) = v59 & 0xFFFFFFFFFFFFFFC0;
        unsigned int v54 = v50 | 2;
      }
    }
    unsigned int v61 = v53 + 1;
    uint64_t v119 = v4;
    *(void *)v121 = v31;
    v122 = (llvm::IntervalMapImpl::Path *)a1;
    char v117 = v47;
    if (v53 + 1 <= 12 * v54)
    {
      unsigned int v62 = 0;
    }
    else
    {
      if (v54 == 1) {
        unsigned int v62 = 1;
      }
      else {
        unsigned int v62 = v54 - 1;
      }
      v126[v54] = v126[v62];
      *((void *)&v124 + v54) = *((void *)&v124 + v62);
      v126[v62] = 0;
      *((void *)&v124 + v62) = sub_1CC300300(*(void *)(*(void *)a1 + 200));
      ++v54;
    }
    unint64_t v63 = 0;
    unsigned int v64 = 0;
    unsigned int v65 = 0;
    uint64_t v66 = v54;
    int v67 = v54;
    do
    {
      if (v63 >= v61 % v54) {
        int v68 = v61 / v54;
      }
      else {
        int v68 = v61 / v54 + 1;
      }
      v123[v63] = v68;
      unsigned int v69 = v44 - v64;
      v64 += v68;
      if (v67 == v54 && v64 > v44)
      {
        int v67 = v63;
        unsigned int v65 = v69;
      }
      ++v63;
    }
    while (v54 != v63);
    unsigned int v118 = v65;
    --v123[v67];
    uint64_t v70 = v54 - 1;
    if (v54 != 1)
    {
      do
      {
        unsigned int v71 = v126[v70];
        unsigned int v72 = v123[v70];
        if (v71 != v72)
        {
          uint64_t v73 = v70;
          do
          {
            if (!v73) {
              break;
            }
            unsigned int v74 = v126[v73 - 1];
            int v75 = sub_1CC2ECBB8(*((void **)&v124 + v70), v71, *(void *)&v123[2 * v73 + 2], v74, v72 - v71);
            v126[v73 - 1] = v74 - v75;
            unsigned int v71 = v126[v70] + v75;
            v126[v70] = v71;
            --v73;
          }
          while (v71 < v72);
        }
        --v70;
      }
      while (v70);
      uint64_t v76 = v54 - 1;
      uint64_t v77 = 0;
      int v78 = 1;
      do
      {
        unsigned int v79 = v126[v77];
        unsigned int v80 = v123[v77];
        if (v79 != v80)
        {
          unsigned int v111 = v78;
          do
          {
            if (v54 == v111) {
              break;
            }
            unsigned int v116 = v126[v111];
            unsigned int v120 = v111;
            int v112 = sub_1CC2ECBB8(*((void **)&v124 + v111), v116, *((void *)&v124 + v77), v79, v79 - v80);
            uint64_t v76 = v54 - 1;
            v126[v120] = v112 + v116;
            unsigned int v79 = v126[v77] - v112;
            v126[v77] = v79;
            unsigned int v111 = v120 + 1;
          }
          while (v79 < v80);
        }
        ++v77;
        ++v78;
      }
      while (v77 != v76);
    }
    if ((v117 & 1) == 0) {
      llvm::IntervalMapImpl::Path::moveLeft(v8, v121[0]);
    }
    uint64_t v81 = 0;
    BOOL v9 = 0;
    int v82 = v67;
    uint64_t v83 = *(void *)v121;
    while (1)
    {
      uint64_t v84 = *((void *)&v124 + v81);
      int v85 = v123[v81];
      uint64_t v86 = (v85 - 1);
      uint64_t v87 = *(void *)(v84 + 8 * v86 + 96);
      if (v62 && v81 == v62)
      {
        int v88 = sub_1CC2FF860(v122, v83, v84 & 0xFFFFFFFFFFFFFFC0 | v86, v87);
        BOOL v9 = v88;
        uint64_t v83 = (v83 + v88);
      }
      else
      {
        uint64_t v98 = *(void *)v8;
        *(_DWORD *)(*(void *)v8 + 16 * v83 + 8) = v85;
        if (v83)
        {
          *(void *)(*(void *)(v98 + 16 * (v83 - 1))
                    + 8 * *(unsigned int *)(v98 + 16 * (v83 - 1) + 12)) = *(void *)(*(void *)(v98 + 16 * (v83 - 1)) + 8 * *(unsigned int *)(v98 + 16 * (v83 - 1) + 12)) & 0xFFFFFFFFFFFFFFC0 | v86;
          uint64_t v99 = 16 * v83;
          while (1)
          {
            uint64_t v100 = v99 - 16;
            if (v99 == 16) {
              break;
            }
            uint64_t v101 = v98 + v99;
            uint64_t v102 = *(unsigned int *)(v101 - 4);
            *(void *)(*(void *)(v101 - 16) + 8 * v102 + 96) = v87;
            int v103 = *(_DWORD *)(v101 - 8) - 1;
            uint64_t v99 = v100;
            if (v102 != v103) {
              goto LABEL_66;
            }
          }
          *(void *)(*(void *)v98 + 8 * *(unsigned int *)(v98 + 12) + 88) = v87;
        }
      }
LABEL_66:
      if (v81 + 1 == v66) {
        break;
      }
      int v89 = 0;
      ++v81;
      uint64_t v90 = *(void *)v8;
      while (1)
      {
        int v91 = v89;
        if (v83 + v89 == 1) {
          break;
        }
        uint64_t v92 = (v83 - 1 + v89);
        int v94 = *(_DWORD *)(v90 + 16 * v92 + 8);
        int v93 = *(_DWORD *)(v90 + 16 * v92 + 12);
        --v89;
        if (v93 != v94 - 1) {
          goto LABEL_72;
        }
      }
      uint64_t v92 = 0;
      int v94 = *(_DWORD *)(v90 + 8);
      int v93 = *(_DWORD *)(v90 + 12);
LABEL_72:
      unsigned int v95 = v93 + 1;
      *(_DWORD *)(v90 + 16 * v92 + 12) = v95;
      if (v95 != v94)
      {
        uint64_t v96 = *(void *)(*(void *)(v90 + 16 * v92) + 8 * v95);
        if (v91)
        {
          do
          {
            uint64_t v104 = *(void *)v8 + 16 * (v83 + v91);
            *(void *)uint64_t v104 = v96 & 0xFFFFFFFFFFFFFFC0;
            *(_DWORD *)(v104 + 8) = (v96 & 0x3F) + 1;
            *(_DWORD *)(v104 + 12) = 0;
            uint64_t v96 = *(void *)(v96 & 0xFFFFFFFFFFFFFFC0);
            BOOL v105 = __CFADD__(v91++, 1);
          }
          while (!v105);
          uint64_t v90 = *(void *)v8;
        }
        v97 = (unint64_t *)(v90 + 16 * v83);
        unint64_t *v97 = v96 & 0xFFFFFFFFFFFFFFC0;
        v97[1] = (v96 & 0x3F) + 1;
      }
      --v82;
    }
    if (v67 != v81)
    {
      do
      {
        llvm::IntervalMapImpl::Path::moveLeft(v8, v83);
        BOOL v105 = __CFADD__(v82++, 1);
      }
      while (!v105);
    }
    uint64_t v32 = *(void *)v8;
    *(_DWORD *)(*(void *)v8 + 16 * v83 + 12) = v118;
    uint64_t v33 = v121[0] + v9;
    unsigned int v34 = *(_DWORD *)(v32 + 16 * v33 + 8);
    LODWORD(v31) = v121[0] + v9;
    uint64_t v4 = v119;
  }
  v35 = (uint64_t *)(v32 + 16 * v33);
  uint64_t v36 = *v35;
  uint64_t v37 = *((unsigned int *)v35 + 3);
  v38 = v35 + 1;
  if (v34 != v37)
  {
    unsigned int v39 = v34;
    do
    {
      *(void *)(v36 + 8 * v39) = *(void *)(v36 + 8 * (v39 - 1));
      *(void *)(v36 + 96 + 8 * v39) = *(void *)(v36 + 96 + 8 * (v39 - 1));
      --v39;
    }
    while (v37 != v39);
  }
  v40 = (void *)(v36 + 8 * v37);
  void *v40 = a3;
  v40[12] = v4;
  _DWORD *v38 = v34 + 1;
  if (v31)
  {
    uint64_t v41 = v32 + 16 * (v31 - 1);
    *(void *)(*(void *)v41 + 8 * *(unsigned int *)(v41 + 12)) = *(void *)(*(void *)v41
                                                                                + 8 * *(unsigned int *)(v41 + 12)) & 0xFFFFFFFFFFFFFFC0 | v34;
    if (v34 == v37)
    {
      v106 = (_DWORD *)(v32 + 16 * v33 - 8);
      while (--v33)
      {
        uint64_t v107 = v106[1];
        *(void *)(*((void *)v106 - 1) + 8 * v107 + 96) = v4;
        int v108 = *v106;
        v106 -= 4;
        if (v107 != v108 - 1) {
          goto LABEL_22;
        }
      }
      *(void *)(*(void *)v32 + 8 * *(unsigned int *)(v32 + 12) + 88) = v4;
    }
  }
LABEL_22:
  uint64_t v42 = *(void *)(v36 + 8 * v37);
  uint64_t v43 = v32 + 16 * (v31 + 1);
  *(void *)uint64_t v43 = v42 & 0xFFFFFFFFFFFFFFC0;
  *(_DWORD *)(v43 + 8) = (v42 & 0x3F) + 1;
  return v9;
}

uint64_t sub_1CC3001A8(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  if ((int)a5 < 1)
  {
    unint64_t v15 = -a5;
    unsigned int v16 = 8 - a4;
    if (v15 < a2) {
      LODWORD(v17) = -a5;
    }
    else {
      LODWORD(v17) = a2;
    }
    if (v16 >= v17) {
      uint64_t v17 = v17;
    }
    else {
      uint64_t v17 = v16;
    }
    if (v17)
    {
      uint64_t v18 = (uint64_t *)(a1 + 128);
      unint64_t v19 = (uint64_t *)(a1 + 8);
      uint64_t v20 = v17;
      do
      {
        unsigned int v21 = (void *)(a3 + 16 * a4);
        *unsigned int v21 = *(v19 - 1);
        uint64_t v23 = *v19;
        v19 += 2;
        uint64_t v22 = v23;
        uint64_t v24 = *v18++;
        v21[1] = v22;
        *(void *)(a3 + 8 * a4++ + 128) = v24;
        --v20;
      }
      while (v20);
    }
    if (a2 != v17)
    {
      uint64_t v25 = 0;
      if (a2 < (unint64_t)v15) {
        unint64_t v15 = a2;
      }
      if (v15 < v16) {
        unsigned int v16 = v15;
      }
      do
      {
        *(_OWORD *)(a1 + 16 * v25) = *(_OWORD *)(a1 + 16 * (v16 + v25));
        *(void *)(a1 + 8 * v25 + 128) = *(void *)(a1 + 8 * (v16 + v25) + 128);
        ++v25;
      }
      while (a2 - v17 != v25);
    }
    return -(int)v17;
  }
  else
  {
    unsigned int v5 = 8 - a2;
    if (a4 >= a5) {
      LODWORD(v6) = a5;
    }
    else {
      LODWORD(v6) = a4;
    }
    if (v5 >= v6) {
      uint64_t v6 = v6;
    }
    else {
      uint64_t v6 = v5;
    }
    if (a2)
    {
      uint64_t v7 = a2 - 1;
      int v8 = -a2;
      unint64_t v9 = a5;
      if (a5 >= (unint64_t)a4) {
        unint64_t v9 = a4;
      }
      if (v9 < v5) {
        unsigned int v5 = v9;
      }
      do
      {
        *(_OWORD *)(a1 + 16 * (v5 + v7)) = *(_OWORD *)(a1 + 16 * v7);
        *(void *)(a1 + 8 * (v5 + v7) + 128) = *(void *)(a1 + 8 * v7 + 128);
        --v7;
        BOOL v10 = __CFADD__(v8++, 1);
      }
      while (!v10);
    }
    if (v6)
    {
      uint64_t v11 = (void *)(a1 + 128);
      uint64_t v12 = (void *)(a1 + 8);
      int v13 = -(int)v6;
      do
      {
        unsigned int v14 = (void *)(a3 + 16 * (a4 + v13));
        *(v12 - 1) = *v14;
        *uint64_t v12 = v14[1];
        v12 += 2;
        *v11++ = *(void *)(a3 + 8 * (a4 + v13) + 128);
        BOOL v10 = __CFADD__(v13++, 1);
      }
      while (!v10);
    }
  }
  return v6;
}

unint64_t sub_1CC300300(uint64_t a1)
{
  unint64_t v1 = *(void *)a1;
  if (*(void *)a1)
  {
    *(void *)a1 = *(void *)v1;
  }
  else
  {
    *(void *)(a1 + 88) += 192;
    uint64_t v3 = *(void *)(a1 + 8);
    if (((v3 + 63) & 0xFFFFFFFFFFFFFFC0) - v3 + 192 > *(void *)(a1 + 16) - v3)
    {
      unsigned int v4 = *(_DWORD *)(a1 + 32) >> 7;
      if (v4 >= 0x1E) {
        LOBYTE(v4) = 30;
      }
      uint64_t v5 = 4096 << v4;
      uint64_t v6 = (char *)operator new(4096 << v4, (std::align_val_t)8uLL);
      unsigned int v7 = *(_DWORD *)(a1 + 32);
      if (v7 >= *(_DWORD *)(a1 + 36)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 24) + 8 * v7) = v6;
      ++*(_DWORD *)(a1 + 32);
      unint64_t v1 = (unint64_t)(v6 + 63) & 0xFFFFFFFFFFFFFFC0;
      *(void *)(a1 + 8) = v1 + 192;
      *(void *)(a1 + 16) = &v6[v5];
    }
    else
    {
      unint64_t v1 = (v3 + 63) & 0xFFFFFFFFFFFFFFC0;
      *(void *)(a1 + 8) = v1 + 192;
    }
  }
  *(_OWORD *)(v1 + 160) = 0u;
  *(_OWORD *)(v1 + 176) = 0u;
  *(_OWORD *)(v1 + 128) = 0u;
  *(_OWORD *)(v1 + 144) = 0u;
  *(_OWORD *)(v1 + 96) = 0u;
  *(_OWORD *)(v1 + 112) = 0u;
  *(_OWORD *)(v1 + 64) = 0u;
  *(_OWORD *)(v1 + 80) = 0u;
  *(_OWORD *)(v1 + 32) = 0u;
  *(_OWORD *)(v1 + 48) = 0u;
  *(_OWORD *)unint64_t v1 = 0u;
  *(_OWORD *)(v1 + 16) = 0u;
  return v1;
}

uint64_t sub_1CC300420@<X0>(unint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  v22[0] = &unk_1F260C9D8;
  uint64_t v23 = v22;
  unint64_t v2 = a1;
  if ((*(_WORD *)(a1 + 44) & 4) != 0)
  {
    unint64_t v2 = a1;
    do
      unint64_t v2 = *(void *)v2 & 0xFFFFFFFFFFFFFFF8;
    while ((*(_WORD *)(v2 + 44) & 4) != 0);
  }
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = v3 + 48;
  uint64_t v5 = *(void *)(v2 + 32);
  uint64_t v6 = *(unsigned int *)(v2 + 40);
  uint64_t v7 = v5 + 32 * v6;
  if (!v6)
  {
    unint64_t v10 = *(void *)(v2 + 8);
    if (v10 == v4)
    {
      unint64_t v2 = v3 + 48;
    }
    else
    {
      unint64_t v2 = v3 + 48;
      if ((*(_WORD *)(v10 + 44) & 4) != 0)
      {
        do
        {
          unint64_t v11 = v10;
          uint64_t v12 = *(unsigned int *)(v10 + 40);
          if (v12)
          {
            unint64_t v2 = v10;
            goto LABEL_23;
          }
          unint64_t v10 = *(void *)(v10 + 8);
        }
        while (v10 != v4 && (*(_WORD *)(v10 + 44) & 4) != 0);
        unint64_t v2 = v3 + 48;
LABEL_23:
        uint64_t v5 = *(void *)(v11 + 32);
        uint64_t v7 = v5 + 32 * v12;
      }
    }
  }
  uint64_t v8 = *(void *)(*(void *)(v3 + 56) + 32) + 32 * *(unsigned int *)(*(void *)(v3 + 56) + 40);
  *(void *)&long long v13 = v2;
  *((void *)&v13 + 1) = v4;
  uint64_t v14 = v5;
  uint64_t v15 = v7;
  uint64_t v16 = v4;
  uint64_t v17 = v4;
  uint64_t v18 = v8;
  uint64_t v19 = v8;
  unsigned int v21 = v20;
  v20[0] = &unk_1F260C9D8;
  sub_1CC300684(&v13, (uint64_t)v20, a2);
  if (v21 == v20)
  {
    (*(void (**)(void *))(v20[0] + 32))(v20);
  }
  else if (v21)
  {
    (*(void (**)(void))(*v21 + 40))();
  }
  uint64_t result = (uint64_t)v23;
  if (v23 == v22) {
    return (*(uint64_t (**)(void *))(v22[0] + 32))(v22);
  }
  if (v23) {
    return (*(uint64_t (**)(void *))(*v23 + 40))(v23);
  }
  return result;
}

uint64_t *llvm::LivePhysRegs::addLiveIns(llvm::LivePhysRegs *this, const llvm::MachineFunction **a2)
{
  llvm::LivePhysRegs::addPristines(this, a2[4]);

  return llvm::LivePhysRegs::addBlockLiveIns(this, (unsigned __int16 **)a2);
}

uint64_t sub_1CC300684@<X0>(long long *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  long long v6 = a1[1];
  v16[0] = *a1;
  v16[1] = v6;
  long long v7 = a1[3];
  v15[0] = a1[2];
  v15[1] = v7;
  sub_1CC300F30((uint64_t)v22, a2);
  sub_1CC300C28((uint64_t *)v24, v16, v15, (uint64_t)v22);
  long long v8 = a1[3];
  v14[0] = a1[2];
  v14[1] = v8;
  v13[0] = v14[0];
  v13[1] = v8;
  sub_1CC300F30((uint64_t)v17, a2);
  sub_1CC300C28((uint64_t *)v19, v14, v13, (uint64_t)v17);
  sub_1CC30094C(v24, v19, a3);
  if (v21 == v20)
  {
    (*(void (**)(void *))(v20[0] + 32))(v20);
  }
  else if (v21)
  {
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(*v21 + 40))(v21, v9, v10, v11);
  }
  if (v18 == v17)
  {
    (*(void (**)(void *))(v17[0] + 32))(v17);
  }
  else if (v18)
  {
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t))(*v18 + 40))(v18, v9, v10, v11);
  }
  if (v26 == v25)
  {
    (*(void (**)(void *))(v25[0] + 32))(v25);
  }
  else if (v26)
  {
    (*(void (**)(void *))(*v26 + 40))(v26);
  }
  uint64_t result = (uint64_t)v23;
  if (v23 == v22) {
    return (*(uint64_t (**)(void *))(v22[0] + 32))(v22);
  }
  if (v23) {
    return (*(uint64_t (**)(void *))(*v23 + 40))(v23);
  }
  return result;
}

void sub_1CC3008E8(uint64_t a1, void *a2)
{
  *a2 = &unk_1F260C9D8;
}

BOOL sub_1CC30090C(uint64_t a1, _DWORD *a2)
{
  if (*a2) {
    return *a2 == 12;
  }
  if ((*a2 & 0x80000000) != 0) {
    return 0;
  }
  return (a2[1] - 1) < 0x3FFFFFFF;
}

uint64_t sub_1CC30094C@<X0>(long long *a1@<X0>, long long *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  long long v5 = a1[1];
  long long v18 = *a1;
  long long v19 = v5;
  long long v6 = a1[3];
  long long v20 = a1[2];
  long long v21 = v6;
  long long v7 = (long long *)*((void *)a1 + 11);
  if (v7)
  {
    if (v7 == a1 + 4)
    {
      uint64_t v23 = v22;
      (*(void (**)(long long *, void *))(*(void *)v7 + 24))(v7, v22);
    }
    else
    {
      uint64_t v23 = (void *)*((void *)a1 + 11);
      *((void *)a1 + 11) = 0;
    }
  }
  else
  {
    uint64_t v23 = 0;
  }
  long long v12 = *a2;
  long long v13 = a2[1];
  long long v14 = a2[2];
  long long v15 = a2[3];
  long long v8 = (long long *)*((void *)a2 + 11);
  if (v8)
  {
    if (v8 == a2 + 4)
    {
      uint64_t v17 = v16;
      (*(void (**)(long long *, void *))(*(void *)v8 + 24))(v8, v16);
    }
    else
    {
      uint64_t v17 = (void *)*((void *)a2 + 11);
      *((void *)a2 + 11) = 0;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  long long v9 = v19;
  *(_OWORD *)a3 = v18;
  *(_OWORD *)(a3 + 16) = v9;
  long long v10 = v21;
  *(_OWORD *)(a3 + 32) = v20;
  *(_OWORD *)(a3 + 48) = v10;
  if (v23)
  {
    if (v23 == v22)
    {
      *(void *)(a3 + 88) = a3 + 64;
      (*(void (**)(void *))(v22[0] + 24))(v22);
    }
    else
    {
      *(void *)(a3 + 88) = v23;
      uint64_t v23 = 0;
    }
  }
  else
  {
    *(void *)(a3 + 88) = 0;
  }
  *(_OWORD *)(a3 + 96) = v12;
  *(_OWORD *)(a3 + 112) = v13;
  *(_OWORD *)(a3 + 128) = v14;
  *(_OWORD *)(a3 + 144) = v15;
  if (v17)
  {
    if (v17 == v16)
    {
      *(void *)(a3 + 184) = a3 + 160;
      (*(void (**)(void *))(v16[0] + 24))(v16);
      if (v17 == v16)
      {
        (*(void (**)(void *))(v16[0] + 32))(v16);
      }
      else if (v17)
      {
        (*(void (**)(void))(*v17 + 40))();
      }
    }
    else
    {
      *(void *)(a3 + 184) = v17;
      uint64_t v17 = 0;
    }
  }
  else
  {
    *(void *)(a3 + 184) = 0;
  }
  uint64_t result = (uint64_t)v23;
  if (v23 == v22) {
    return (*(uint64_t (**)(void *))(v22[0] + 32))(v22);
  }
  if (v23) {
    return (*(uint64_t (**)(void))(*v23 + 40))();
  }
  return result;
}

uint64_t *sub_1CC300C28(uint64_t *a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  long long v18 = *a2;
  long long v19 = a2[1];
  long long v16 = *a3;
  long long v17 = a3[1];
  sub_1CC300F30((uint64_t)v20, a4);
  *(_OWORD *)a1 = v18;
  *((_OWORD *)a1 + 1) = v19;
  *((_OWORD *)a1 + 2) = v16;
  *((_OWORD *)a1 + 3) = v17;
  if (v21)
  {
    if (v21 == v20)
    {
      a1[11] = (uint64_t)(a1 + 8);
      (*(void (**)(void *))(v20[0] + 24))(v20);
    }
    else
    {
      a1[11] = (*(uint64_t (**)(void *))(*v21 + 16))(v21);
    }
  }
  else
  {
    a1[11] = 0;
  }
LABEL_4:
  while (1)
  {
    if (*a1 == a1[4])
    {
      uint64_t v10 = a1[2];
      uint64_t v11 = a1[6];
      if (v10 == v11 || v10 == a1[3] && v11 == a1[7]) {
        break;
      }
    }
    uint64_t v5 = a1[11];
    if (!v5)
    {
      sub_1CB920400();
      goto LABEL_21;
    }
    if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 48))(v5, a1[2])) {
      break;
    }
    uint64_t v6 = a1[3];
    uint64_t v7 = a1[2] + 32;
    a1[2] = v7;
    if (v7 == v6)
    {
      uint64_t v9 = *a1;
      uint64_t v8 = a1[1];
      do
      {
        uint64_t v9 = *(void *)(v9 + 8);
        if (v9 == v8 || (*(_WORD *)(v9 + 44) & 4) == 0)
        {
          *a1 = v8;
          goto LABEL_4;
        }
        uint64_t v14 = *(void *)(v9 + 32);
        a1[2] = v14;
        uint64_t v15 = *(unsigned int *)(v9 + 40);
        a1[3] = v14 + 32 * v15;
      }
      while (!v15);
      *a1 = v9;
    }
  }
  long long v12 = v21;
  if (v21 == v20)
  {
    (*(void (**)(void *))(v20[0] + 32))(v20);
    return a1;
  }
LABEL_21:
  if (v12) {
    (*(void (**)(void *))(*v12 + 40))(v12);
  }
  return a1;
}

void sub_1CC300E50(uint64_t *a1)
{
uint64_t sub_1CC300F30(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_1CC300FC8(uint64_t *a1, unsigned __int16 *a2)
{
  uint64_t v2 = a1[5];
  unsigned int v3 = *(unsigned __int8 *)(v2 + *a2);
  uint64_t v4 = a1[1];
  if (v3 >= v4) {
    return 0;
  }
  uint64_t v5 = *a1;
  while (1)
  {
    unsigned int v6 = v3;
    if (*(unsigned __int16 *)(v5 + 2 * v3) == *a2) {
      break;
    }
    v3 += 256;
    if (v6 + 256 >= v4) {
      return 0;
    }
  }
  if (v4 == v3) {
    return 0;
  }
  uint64_t v8 = (_WORD *)(v5 + 2 * v3);
  uint64_t v9 = (_WORD *)(v5 + 2 * v4 - 2);
  if (v9 != v8)
  {
    *uint64_t v8 = *v9;
    *(unsigned char *)(v2 + (unsigned __int16)*v9) = v3;
    uint64_t v4 = a1[1];
  }
  a1[1] = v4 - 1;
  return 1;
}

void *sub_1CC30104C(void *a1)
{
  uint64_t v2 = a1 + 20;
  unsigned int v3 = (void *)a1[23];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  uint64_t v4 = (void *)a1[11];
  if (v4 == a1 + 8)
  {
    (*(void (**)(void *))(a1[8] + 32))(a1 + 8);
  }
  else if (v4)
  {
    (*(void (**)(void *))(*v4 + 40))(v4);
  }
  return a1;
}

void *sub_1CC301138(void *result, unint64_t a2)
{
  *uint64_t result = 0;
  result[1] = 0;
  unint64_t v2 = a2;
  if ((*(unsigned char *)(a2 + 44) & 4) != 0)
  {
    unint64_t v2 = a2;
    do
      unint64_t v2 = *(void *)v2 & 0xFFFFFFFFFFFFFFF8;
    while ((*(_WORD *)(v2 + 44) & 4) != 0);
  }
  *uint64_t result = v2;
  uint64_t v3 = *(void *)(a2 + 24) + 48;
  result[1] = v3;
  uint64_t v4 = *(void *)(v2 + 32);
  uint64_t v5 = *(unsigned int *)(v2 + 40);
  result[2] = v4;
  result[3] = v4 + 32 * v5;
  if (!v5)
  {
    do
    {
      unint64_t v2 = *(void *)(v2 + 8);
      if (v2 == v3 || (*(_WORD *)(v2 + 44) & 4) == 0)
      {
        *uint64_t result = v3;
        return result;
      }
      uint64_t v6 = *(void *)(v2 + 32);
      uint64_t v7 = *(unsigned int *)(v2 + 40);
      result[2] = v6;
      result[3] = v6 + 32 * v7;
    }
    while (!v7);
    *uint64_t result = v2;
  }
  return result;
}

void llvm::LiveRangeCalc::resetLiveOutMap(llvm::LiveRangeCalc *this)
{
  unint64_t v2 = *(void *)(*(void *)this + 112) - *(void *)(*(void *)this + 104);
  unint64_t v3 = v2 >> 3;
  uint64_t v4 = (void *)((char *)this + 40);
  *((_DWORD *)this + 12) = 0;
  *((_DWORD *)this + 26) = v2 >> 3;
  unsigned int v5 = (v2 >> 3) + 63;
  if (v5 < 0x40)
  {
    uint64_t v8 = 0;
    unint64_t v7 = v2 >> 3;
  }
  else
  {
    uint64_t v6 = v5 >> 6;
    if (v6 > *((_DWORD *)this + 13)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    unint64_t v7 = v2 >> 3;
    bzero(*((void **)this + 5), 8 * v6);
    uint64_t v8 = v6;
    *((_DWORD *)this + 12) = v6;
  }
  if ((v7 & 0x3F) != 0) {
    *(void *)(*v4 + 8 * v8 - 8) &= ~(-1 << (v7 & 0x3F));
  }
  int v9 = *((_DWORD *)this + 30);
  if (v9 || *((_DWORD *)this + 31))
  {
    long long v17 = (_DWORD *)((char *)this + 112);
    unsigned int v18 = *((_DWORD *)this + 32);
    if (v18 > 4 * v9 && v18 >= 0x41)
    {
      sub_1CD51D4C4(v17);
    }
    else
    {
      if (v18)
      {
        uint64_t v19 = 152 * v18;
        uint64_t v20 = *(void *)v17 + 96;
        do
        {
          uint64_t v21 = *(void *)(v20 - 96);
          if (v21 != -4096)
          {
            if (v21 != -8192)
            {
              uint64_t v22 = *(void **)(v20 - 16);
              if ((void *)v20 != v22) {
                free(v22);
              }
              uint64_t v23 = *(void **)(v20 - 88);
              if ((void *)(v20 - 72) != v23) {
                free(v23);
              }
            }
            *(void *)(v20 - 96) = -4096;
          }
          v20 += 152;
          v19 -= 152;
        }
        while (v19);
      }
      *((void *)this + 15) = 0;
    }
  }
  long long v10 = *(_OWORD *)((char *)this + 152);
  unint64_t v11 = (v2 >> 3);
  unint64_t v12 = *((unsigned int *)this + 36);
  uint64_t v13 = v11 - v12;
  if (v11 != v12)
  {
    if (v11 >= v12)
    {
      if (v11 > *((unsigned int *)this + 37)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      int v24 = *((_DWORD *)this + 36);
      if (v13)
      {
        uint64_t v14 = (_OWORD *)(*((void *)this + 17) + 16 * *((unsigned int *)this + 36));
        uint64_t v15 = v12 - v11;
        do
          *v14++ = v10;
        while (!__CFADD__(v15++, 1));
      }
      LODWORD(v3) = v24 + v13;
    }
    *((_DWORD *)this + 36) = v3;
  }
}

void llvm::LiveRangeCalc::reset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *(void *)(a2 + 40);
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v6;
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = a4;
  *(void *)(a1 + 32) = a5;
  llvm::LiveRangeCalc::resetLiveOutMap((llvm::LiveRangeCalc *)a1);
  *(_DWORD *)(a1 + 184) = 0;
}

void llvm::LiveRangeCalc::updateFromLiveIns(llvm::LiveRangeCalc *this)
{
  v22[48] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = 0;
  unint64_t v19 = 0;
  uint64_t v20 = v22;
  uint64_t v21 = 0x1000000000;
  uint64_t v2 = *((unsigned int *)this + 46);
  if (v2)
  {
    uint64_t v3 = 32 * v2;
    uint64_t v4 = (uint64_t *)(*((void *)this + 22) + 24);
    do
    {
      uint64_t v5 = *(v4 - 2);
      if (v5)
      {
        uint64_t v6 = *(unsigned int *)(*(void *)v5 + 24);
        uint64_t v7 = *(void *)(*((void *)this + 2) + 392);
        uint64_t v8 = *(void *)(v7 + 16 * v6);
        unint64_t v9 = *(v4 - 1);
        if (v9 <= 7)
        {
          unint64_t v9 = *(void *)(v7 + 16 * v6 + 8);
          long long v10 = (uint64_t *)(*((void *)this + 17) + 16 * v6);
          *long long v10 = *v4;
          v10[1] = 0;
        }
        uint64_t v11 = *(v4 - 3);
        if (v18 != v11 && v19 >= 8)
        {
          uint64_t v15 = *(v4 - 3);
          uint64_t v16 = v8;
          unint64_t v14 = v9;
          llvm::LiveRangeUpdater::flush((char *)&v18);
          unint64_t v9 = v14;
          uint64_t v11 = v15;
          uint64_t v8 = v16;
        }
        uint64_t v18 = v11;
        uint64_t v13 = *v4;
        v17[0] = v8;
        v17[1] = v9;
        v17[2] = v13;
        llvm::LiveRangeUpdater::add((llvm::LiveRangeUpdater *)&v18, v17);
      }
      v4 += 4;
      v3 -= 32;
    }
    while (v3);
  }
  *((_DWORD *)this + 46) = 0;
  llvm::LiveRangeUpdater::flush((char *)&v18);
  if (v20 != v22) {
    free(v20);
  }
}

void llvm::LiveRangeCalc::extend(llvm::LiveRangeCalc *a1, uint64_t a2, unint64_t a3, uint64_t a4, void *a5, uint64_t a6)
{
  uint64_t v11 = *((void *)a1 + 2);
  unsigned int v12 = (a3 >> 1) & 3;
  unint64_t v13 = a3 & 0xFFFFFFFFFFFFFFF8;
  if (v12) {
    unint64_t v14 = v13 | (2 * (v12 - 1));
  }
  else {
    unint64_t v14 = *(void *)v13 | 6;
  }
  if (v14 >= 8 && (uint64_t v15 = *(void *)((v14 & 0xFFFFFFFFFFFFFFF8) + 16)) != 0)
  {
    uint64_t v16 = (uint64_t *)(v15 + 24);
  }
  else
  {
    uint64_t v21 = *(unsigned int *)(v11 + 544);
    if (v21)
    {
      unsigned int v22 = *(_DWORD *)((v14 & 0xFFFFFFFFFFFFFFF8) + 24) | (v14 >> 1) & 3;
      uint64_t v23 = *(void **)(v11 + 536);
      unint64_t v24 = *(unsigned int *)(v11 + 544);
      do
      {
        unint64_t v25 = v24 >> 1;
        uint64_t v26 = &v23[2 * (v24 >> 1)];
        uint64_t v28 = *v26;
        uint64_t v27 = v26 + 2;
        v24 += ~(v24 >> 1);
        if (((v28 >> 1) & 3 | *(_DWORD *)((v28 & 0xFFFFFFFFFFFFFFF8) + 24)) < v22) {
          uint64_t v23 = v27;
        }
        else {
          unint64_t v24 = v25;
        }
      }
      while (v24);
      if (v23 == (void *)(*(void *)(v11 + 536) + 16 * v21)
        || ((*v23 >> 1) & 3 | *(_DWORD *)((*v23 & 0xFFFFFFFFFFFFFFF8) + 24)) > v22)
      {
        v23 -= 2;
      }
    }
    else
    {
      uint64_t v23 = *(void **)(v11 + 536);
    }
    uint64_t v16 = v23 + 1;
  }
  uint64_t v17 = *v16;
  uint64_t v18 = llvm::LiveRange::extendInBlock(a2, a5, a6, *(void *)(*(void *)(v11 + 392) + 16 * *(unsigned int *)(*v16 + 24)), a3);
  if (!(v18 | v20 & 1) && (llvm::LiveRangeCalc::findReachingDefs((uint64_t)a1, a2, v17, a3, v19, a5, a6) & 1) == 0)
  {
    llvm::LiveRangeCalc::updateSSA((uint64_t)a1);
    llvm::LiveRangeCalc::updateFromLiveIns(a1);
  }
}

uint64_t llvm::LiveRangeCalc::findReachingDefs(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, void *a6, uint64_t a7)
{
  char v8 = 0;
  int v9 = 0;
  long long v10 = 0;
  uint64_t v124 = *MEMORY[0x1E4F143B8];
  int v11 = *(_DWORD *)(a3 + 24);
  v121 = v123;
  int v93 = v11;
  v123[0] = v11;
  uint64_t v122 = 0x1000000001;
  unsigned int v12 = 1;
  int v13 = 1;
  do
  {
    uint64_t v14 = *(void *)(*(void *)(*(void *)a1 + 104) + 8 * v121[v9]);
    uint64_t v15 = *(uint64_t **)(v14 + 64);
    uint64_t v16 = *(uint64_t **)(v14 + 72);
    char v17 = v8 & 1 | (v15 == v16);
    if (v15 != v16)
    {
      do
      {
        uint64_t v18 = *v15;
        unint64_t v19 = *(unsigned int *)(*v15 + 24);
        if ((*(void *)(*(void *)(a1 + 40) + ((v19 >> 3) & 0x1FFFFFF8)) >> v19))
        {
          char v20 = *(void **)(*(void *)(a1 + 136) + 16 * v19);
          if (v20)
          {
            if (v10) {
              BOOL v21 = v10 == v20;
            }
            else {
              BOOL v21 = 1;
            }
            int v22 = v21;
            v13 &= v22;
            long long v10 = v20;
          }
        }
        else
        {
          uint64_t v23 = (uint64_t *)(*(void *)(*(void *)(a1 + 16) + 392) + 16 * v19);
          uint64_t v24 = llvm::LiveRange::extendInBlock(a2, a6, a7, *v23, v23[1]);
          char v17 = v17 & 1 | v25 & 1;
          uint64_t v26 = &unk_1EA615298;
          if ((v25 & 1) == 0) {
            uint64_t v26 = (void *)v24;
          }
          unint64_t v27 = *(unsigned int *)(v18 + 24);
          *(void *)(*(void *)(a1 + 40) + ((v27 >> 3) & 0x1FFFFFF8)) |= 1 << v27;
          uint64_t v28 = (void *)(*(void *)(a1 + 136) + 16 * v27);
          *uint64_t v28 = v26;
          v28[1] = 0;
          BOOL v29 = v24 == 0;
          if (v24) {
            unsigned int v30 = (void *)v24;
          }
          else {
            unsigned int v30 = v10;
          }
          if (!v10) {
            BOOL v29 = 1;
          }
          BOOL v21 = v10 == (void *)v24;
          long long v10 = v30;
          if (v21) {
            BOOL v29 = 1;
          }
          v13 &= v29;
          if (!(v25 & 1 | (unint64_t)v24))
          {
            if (v18 == a3)
            {
              a4 = 0;
            }
            else
            {
              if (v122 >= (unint64_t)HIDWORD(v122)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              v121[v122] = v27;
              LODWORD(v122) = v122 + 1;
            }
          }
        }
        ++v15;
      }
      while (v15 != v16);
      unsigned int v12 = v122;
    }
    ++v9;
    char v8 = v17 & 1;
  }
  while (v12 != v9);
  *(_DWORD *)(a1 + 184) = 0;
  if (a7)
  {
    if (v10) {
      BOOL v31 = v10 == &unk_1EA615298;
    }
    else {
      BOOL v31 = 1;
    }
    char v32 = !v31;
    if (v17) {
      char v32 = 0;
    }
    LOBYTE(v13) = v32 & v13;
  }
  if (v12 >= 5) {
    qsort(v121, v12, 4uLL, (int (__cdecl *)(const void *, const void *))sub_1CBC0DC50);
  }
  if (v13)
  {
    long long v114 = (unint64_t)a2;
    unsigned int v116 = v118;
    uint64_t v117 = 0x1000000000;
    if (v122)
    {
      uint64_t v33 = v121;
      uint64_t v34 = 4 * v122;
      do
      {
        uint64_t v35 = *v33;
        uint64_t v36 = *(void *)(*(void *)(a1 + 16) + 392);
        uint64_t v37 = *(void **)(v36 + 16 * v35);
        BOOL v38 = v35 == v93 && a4 > 7;
        unint64_t v39 = a4;
        if (!v38)
        {
          unint64_t v39 = *(void *)(v36 + 16 * v35 + 8);
          v40 = (void *)(*(void *)(a1 + 136)
                         + 16 * *(unsigned int *)(*(void *)(*(void *)(*(void *)a1 + 104) + 8 * v35) + 24));
          void *v40 = v10;
          v40[1] = 0;
        }
        uint64_t v107 = v37;
        uint64_t v108 = v39;
        v109[0] = v10;
        llvm::LiveRangeUpdater::add((llvm::LiveRangeUpdater *)&v114, (uint64_t *)&v107);
        ++v33;
        v34 -= 4;
      }
      while (v34);
    }
    llvm::LiveRangeUpdater::flush((char *)&v114);
    if (v116 != v118) {
      free(v116);
    }
    goto LABEL_132;
  }
  uint64_t v104 = v106;
  uint64_t v105 = 0x600000000;
  v106[12] = 0;
  uint64_t v101 = v103;
  uint64_t v102 = 0x600000000;
  v103[12] = 0;
  uint64_t v107 = v109;
  uint64_t v108 = 0x600000000;
  int v110 = 0;
  unsigned int v111 = v113;
  uint64_t v112 = 0x600000000;
  v113[12] = 0;
  *(void *)&long long v114 = a2;
  sub_1CC302E54((uint64_t)&v114 + 8, (uint64_t)&v107);
  uint64_t v41 = a1 + 112;
  uint64_t v42 = *(void *)(a1 + 112);
  unsigned int v43 = *(_DWORD *)(a1 + 128);
  if (v43)
  {
    unsigned int v44 = ((v114 >> 4) ^ (v114 >> 9)) & (v43 - 1);
    unsigned int v45 = (uint64_t *)(v42 + 152 * v44);
    uint64_t v46 = *v45;
    if ((void)v114 == *v45)
    {
      char v49 = 1;
      goto LABEL_74;
    }
    int v47 = 0;
    int v48 = 1;
    char v49 = 1;
    while (v46 != -4096)
    {
      if (v47) {
        BOOL v50 = 0;
      }
      else {
        BOOL v50 = v46 == -8192;
      }
      if (v50) {
        int v47 = v45;
      }
      unsigned int v51 = v44 + v48++;
      unsigned int v44 = v51 & (v43 - 1);
      unsigned int v45 = (uint64_t *)(v42 + 152 * v44);
      uint64_t v46 = *v45;
      if ((void)v114 == *v45) {
        goto LABEL_74;
      }
    }
    if (v47) {
      unsigned int v45 = v47;
    }
  }
  else
  {
    unsigned int v45 = 0;
  }
  int v52 = *(_DWORD *)(a1 + 120);
  if (4 * v52 + 4 >= 3 * v43)
  {
    sub_1CC3030D8(v41, 2 * v43);
    uint64_t v83 = *(void *)(a1 + 112);
    uint64_t v53 = v114;
    int v84 = *(_DWORD *)(a1 + 128) - 1;
    unsigned int v85 = ((v114 >> 4) ^ (v114 >> 9)) & v84;
    unsigned int v45 = (uint64_t *)(v83 + 152 * v85);
    uint64_t v86 = *v45;
    if ((void)v114 == *v45) {
      goto LABEL_71;
    }
    uint64_t v87 = 0;
    int v88 = 1;
    while (v86 != -4096)
    {
      if (v87) {
        BOOL v89 = 0;
      }
      else {
        BOOL v89 = v86 == -8192;
      }
      if (v89) {
        uint64_t v87 = v45;
      }
      unsigned int v90 = v85 + v88++;
      unsigned int v85 = v90 & v84;
      unsigned int v45 = (uint64_t *)(v83 + 152 * v85);
      uint64_t v86 = *v45;
      if ((void)v114 == *v45) {
        goto LABEL_71;
      }
    }
    if (v87) {
      unsigned int v45 = v87;
    }
  }
  else if (v43 + ~v52 - *(_DWORD *)(a1 + 124) <= v43 >> 3)
  {
    sub_1CC3030D8(v41, v43);
    uint64_t v100 = 0;
    sub_1CC303054(*(void *)(a1 + 112), *(_DWORD *)(a1 + 128), v114, &v100);
    unsigned int v45 = v100;
  }
  uint64_t v53 = *v45;
LABEL_71:
  ++*(_DWORD *)(a1 + 120);
  if (v53 != -4096) {
    --*(_DWORD *)(a1 + 124);
  }
  *unsigned int v45 = v114;
  sub_1CC302E54((uint64_t)(v45 + 1), (uint64_t)&v114 + 8);
  char v49 = 0;
LABEL_74:
  if (v119 != &v120) {
    free(v119);
  }
  if (*((long long **)&v114 + 1) != (long long *)((char *)&v115 + 8)) {
    free(*((void **)&v114 + 1));
  }
  if (v111 != v113) {
    free(v111);
  }
  if (v107 != v109) {
    free(v107);
  }
  if (v101 != v103) {
    free(v101);
  }
  if (v104 != v106) {
    free(v104);
  }
  if ((v49 & 1) == 0)
  {
    uint64_t v54 = (*(void *)(*(void *)a1 + 112) - *(void *)(*(void *)a1 + 104)) >> 3;
    uint64_t v55 = *((unsigned int *)v45 + 4);
    if ((v45[9] & 0x3F) != 0)
    {
      uint64_t v91 = v45[1] + 8 * v55;
      *(void *)(v91 - 8) &= ~(-1 << (v45[9] & 0x3F));
    }
    unsigned int v56 = v55;
    int v57 = v45 + 1;
    *((_DWORD *)v45 + 18) = v54;
    uint64_t v58 = (v54 + 63) >> 6;
    if (v55 != (v54 + 63) >> 6)
    {
      if (v55 <= v58)
      {
        if (v58 > *((_DWORD *)v45 + 5)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v58 != v55) {
          bzero((void *)(*v57 + 8 * v55), 8 * (v58 - v55));
        }
        unsigned int v56 = (v54 + 63) >> 6;
        *((_DWORD *)v45 + 4) = v58;
        int v59 = *((_DWORD *)v45 + 18);
        goto LABEL_95;
      }
      *((_DWORD *)v45 + 4) = v58;
      unsigned int v56 = (v54 + 63) >> 6;
    }
    LOBYTE(v59) = v54;
LABEL_95:
    int v60 = v59 & 0x3F;
    if (v60) {
      *(void *)(*v57 + 8 * v56 - 8) &= ~(-1 << v60);
    }
    uint64_t v61 = *((unsigned int *)v45 + 22);
    if ((v45[18] & 0x3F) != 0)
    {
      uint64_t v92 = v45[10] + 8 * v61;
      *(void *)(v92 - 8) &= ~(-1 << (v45[18] & 0x3F));
    }
    unsigned int v62 = v45 + 10;
    *((_DWORD *)v45 + 36) = v54;
    if (v61 != v58)
    {
      if (v61 > v58)
      {
        *((_DWORD *)v45 + 22) = v58;
      }
      else
      {
        if (v58 > *((_DWORD *)v45 + 23)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v58 != v61) {
          bzero((void *)(*v62 + 8 * v61), 8 * (v58 - v61));
        }
        *((_DWORD *)v45 + 22) = v58;
        LODWORD(v54) = *((_DWORD *)v45 + 36);
      }
    }
    if ((v54 & 0x3F) != 0) {
      *(void *)(*v62 + 8 * v58 - 8) &= ~(-1 << (v54 & 0x3F));
    }
  }
  if (*(_DWORD *)(a1 + 188) < v122) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v122)
  {
    unint64_t v63 = v121;
    int v94 = &v121[v122];
    while (1)
    {
      uint64_t v64 = *(void *)(*(void *)a1 + 104);
      uint64_t v65 = *(void *)(v64 + 8 * *v63);
      if (!a7
        || llvm::LiveRangeCalc::isDefOnEntry((void *)a1, a2, a6, a7, *(void *)(v64 + 8 * *v63), v45 + 1, v45 + 10))
      {
        break;
      }
LABEL_125:
      if (++v63 == v94) {
        goto LABEL_132;
      }
    }
    uint64_t v66 = *(void *)(a1 + 24);
    llvm::MachineDominatorTree::applySplitCriticalEdges((void ***)v66);
    uint64_t v67 = *(void *)(v66 + 1320);
    uint64_t v68 = *(void *)(v67 + 24);
    uint64_t v69 = *(unsigned int *)(v67 + 40);
    if (v69)
    {
      LODWORD(v70) = (v69 - 1) & ((v65 >> 4) ^ (v65 >> 9));
      unsigned int v71 = (uint64_t *)(v68 + 16 * v70);
      uint64_t v72 = *v71;
      if (*v71 == v65)
      {
LABEL_120:
        if (v71 == (uint64_t *)(v68 + 16 * v69)) {
          uint64_t v75 = 0;
        }
        else {
          uint64_t v75 = v71[1];
        }
        *(void *)&long long v114 = a2;
        *((void *)&v114 + 1) = v75;
        long long v115 = 0uLL;
        uint64_t v76 = *(unsigned int *)(a1 + 184);
        unint64_t v77 = *(void *)(a1 + 176);
        if (v76 >= *(_DWORD *)(a1 + 188))
        {
          BOOL v81 = v77 + 32 * v76 > (unint64_t)&v114;
          if (v77 > (unint64_t)&v114 || !v81) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        int v78 = (_OWORD *)(v77 + 32 * *(unsigned int *)(a1 + 184));
        long long v79 = v115;
        *int v78 = v114;
        v78[1] = v79;
        uint64_t v80 = (*(_DWORD *)(a1 + 184) + 1);
        *(_DWORD *)(a1 + 184) = v80;
        if (v65 == a3) {
          *(void *)(*(void *)(a1 + 176) + 32 * v80 - 16) = a4;
        }
        goto LABEL_125;
      }
      int v73 = 1;
      while (v72 != -4096)
      {
        int v74 = v70 + v73++;
        uint64_t v70 = v74 & (v69 - 1);
        uint64_t v72 = *(void *)(v68 + 16 * v70);
        if (v72 == v65)
        {
          unsigned int v71 = (uint64_t *)(v68 + 16 * v70);
          goto LABEL_120;
        }
      }
    }
    unsigned int v71 = (uint64_t *)(v68 + 16 * v69);
    goto LABEL_120;
  }
LABEL_132:
  if (v121 != v123) {
    free(v121);
  }
  return v13 & 1;
}

void llvm::LiveRangeCalc::calculateValues(llvm::LiveRangeCalc *this)
{
  llvm::LiveRangeCalc::updateSSA((uint64_t)this);

  llvm::LiveRangeCalc::updateFromLiveIns(this);
}

uint64_t llvm::LiveRangeCalc::updateSSA(uint64_t this)
{
  uint64_t v1 = this;
  do
  {
    uint64_t v2 = *(unsigned int *)(v1 + 184);
    if (!v2) {
      return this;
    }
    int v3 = 0;
    uint64_t v4 = *(uint64_t **)(v1 + 176);
    uint64_t v92 = &v4[4 * v2];
    do
    {
      uint64_t v5 = (uint64_t *)v4[1];
      if (!v5) {
        goto LABEL_87;
      }
      uint64_t v6 = *v5;
      uint64_t v7 = v5[1];
      if (!v7)
      {
        uint64_t v9 = *(void *)(v1 + 136);
LABEL_25:
        uint64_t v30 = *(unsigned int *)(v6 + 24);
LABEL_80:
        long long v67 = *(_OWORD *)(*(void *)(*(void *)(v1 + 16) + 392) + 16 * v30);
        uint64_t v68 = *v4;
        uint64_t v69 = *(void *)(v1 + 32);
        *(void *)(v69 + 80) += 16;
        if (((*(void *)v69 + 7) & 0xFFFFFFFFFFFFFFF8) - *(void *)v69 + 16 > *(void *)(v69 + 8)
                                                                                   - *(void *)v69)
        {
          long long v91 = v67;
          unsigned int v76 = *(_DWORD *)(v69 + 24) >> 7;
          if (v76 >= 0x1E) {
            LOBYTE(v76) = 30;
          }
          uint64_t v77 = 4096 << v76;
          unint64_t v70 = (unint64_t)operator new(4096 << v76, (std::align_val_t)8uLL);
          unint64_t v78 = *(unsigned int *)(v69 + 24);
          if (v78 >= *(unsigned int *)(v69 + 28)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(v69 + 16) + 8 * v78) = v70;
          ++*(_DWORD *)(v69 + 24);
          *(void *)(v69 + 8) = v70 + v77;
          long long v67 = v91;
        }
        else
        {
          unint64_t v70 = (*(void *)v69 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)uint64_t v69 = v70 + 16;
        unint64_t v71 = *(unsigned int *)(v68 + 72);
        unint64_t v72 = *(unsigned int *)(v68 + 76);
        *(_DWORD *)unint64_t v70 = v71;
        *(void *)(v70 + 8) = v67;
        if (v71 >= v72) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v68 + 64) + 8 * v71) = v70;
        ++*(_DWORD *)(v68 + 72);
        v4[3] = v70;
        v4[1] = 0;
        unint64_t v73 = v4[2];
        if (v73 < 8)
        {
          long long v93 = v67;
          unint64_t v94 = v70;
          this = llvm::LiveRange::addSegment(v68, (uint64_t)&v93);
          *(void *)(v9 + 16 * v30) = v70;
          *(void *)(v9 + 16 * v30 + 8) = v5;
        }
        else
        {
          v95[0] = v67;
          v95[1] = v73;
          v95[2] = v70;
          this = llvm::LiveRange::addSegment(v68, (uint64_t)v95);
        }
LABEL_86:
        int v3 = 1;
        goto LABEL_87;
      }
      unint64_t v8 = *(unsigned int *)(*(void *)v7 + 24);
      uint64_t v9 = *(void *)(v1 + 136);
      if (((*(void *)(*(void *)(v1 + 40) + ((v8 >> 3) & 0x1FFFFFF8)) >> v8) & 1) == 0) {
        goto LABEL_25;
      }
      uint64_t v10 = v9 + 16 * v8;
      unsigned int v12 = *(void **)v10;
      uint64_t v11 = *(void *)(v10 + 8);
      if (*(void *)v10) {
        BOOL v13 = v12 == (void *)&unk_1EA615298;
      }
      else {
        BOOL v13 = 1;
      }
      if (!v13 && v11 == 0)
      {
        uint64_t v15 = *(void *)(v1 + 16);
        unint64_t v16 = v12[1];
        if (v16 >= 8 && (uint64_t v17 = *(void *)((v16 & 0xFFFFFFFFFFFFFFF8) + 16)) != 0)
        {
          uint64_t v18 = *v5;
          unint64_t v19 = (uint64_t *)(v17 + 24);
        }
        else
        {
          long long v79 = *(void **)(v15 + 536);
          unint64_t v80 = *(unsigned int *)(v15 + 544);
          if (v80)
          {
            unsigned int v81 = *(_DWORD *)((v16 & 0xFFFFFFFFFFFFFFF8) + 24) | (v16 >> 1) & 3;
            int v82 = v79;
            unint64_t v83 = v80;
            do
            {
              unint64_t v84 = v83 >> 1;
              unsigned int v85 = &v82[2 * (v83 >> 1)];
              uint64_t v87 = *v85;
              uint64_t v86 = v85 + 2;
              v83 += ~(v83 >> 1);
              if (((v87 >> 1) & 3 | *(_DWORD *)((v87 & 0xFFFFFFFFFFFFFFF8) + 24)) < v81) {
                int v82 = v86;
              }
              else {
                unint64_t v83 = v84;
              }
            }
            while (v83);
            if (v82 == &v79[2 * v80]
              || ((*v82 >> 1) & 3 | *(_DWORD *)((*v82 & 0xFFFFFFFFFFFFFFF8) + 24)) > v81)
            {
              v82 -= 2;
            }
          }
          else
          {
            int v82 = *(void **)(v15 + 536);
          }
          uint64_t v18 = *v5;
          unint64_t v19 = v82 + 1;
        }
        uint64_t v20 = *(void *)(v1 + 24);
        uint64_t v21 = *v19;
        this = (uint64_t)llvm::MachineDominatorTree::applySplitCriticalEdges((void ***)v20);
        uint64_t v22 = *(void *)(v20 + 1320);
        uint64_t v23 = *(void *)(v22 + 24);
        uint64_t v24 = *(unsigned int *)(v22 + 40);
        uint64_t v6 = v18;
        if (!v24) {
          goto LABEL_26;
        }
        LODWORD(v25) = (v24 - 1) & ((v21 >> 4) ^ (v21 >> 9));
        uint64_t v26 = (uint64_t *)(v23 + 16 * v25);
        uint64_t v27 = *v26;
        if (*v26 != v21)
        {
          int v28 = 1;
          while (v27 != -4096)
          {
            int v29 = v25 + v28++;
            uint64_t v25 = v29 & (v24 - 1);
            uint64_t v27 = *(void *)(v23 + 16 * v25);
            if (v27 == v21)
            {
              uint64_t v26 = (uint64_t *)(v23 + 16 * v25);
              goto LABEL_27;
            }
          }
LABEL_26:
          uint64_t v26 = (uint64_t *)(v23 + 16 * v24);
        }
LABEL_27:
        if (v26 == (uint64_t *)(v23 + 16 * v24)) {
          uint64_t v11 = 0;
        }
        else {
          uint64_t v11 = v26[1];
        }
        uint64_t v9 = *(void *)(v1 + 136);
        *(void *)(v9 + 16 * *(unsigned int *)(*(void *)v7 + 24) + 8) = v11;
      }
      uint64_t v31 = *(void *)(v6 + 64);
      uint64_t v32 = *(void *)(v6 + 72);
      if (v31 != v32)
      {
        uint64_t v88 = v11;
        uint64_t v90 = v6;
        int v89 = v3;
        while (1)
        {
          uint64_t v33 = *(unsigned int *)(*(void *)v31 + 24);
          uint64_t v9 = *(void *)(v1 + 136);
          uint64_t v34 = *(void **)(v9 + 16 * v33);
          if (v34) {
            BOOL v35 = v34 == v12;
          }
          else {
            BOOL v35 = 1;
          }
          if (v35) {
            goto LABEL_59;
          }
          if (v34 == (void *)&unk_1EA615298)
          {
            uint64_t v6 = v90;
            goto LABEL_25;
          }
          uint64_t v36 = v9 + 16 * v33;
          uint64_t v39 = *(void *)(v36 + 8);
          BOOL v38 = (void *)(v36 + 8);
          uint64_t v37 = v39;
          if (!v39) {
            break;
          }
LABEL_51:
          uint64_t v54 = *(void *)(v1 + 24);
          this = (uint64_t)llvm::MachineDominatorTree::applySplitCriticalEdges((void ***)v54);
          if (v37 == v7 || !v37 || *(void *)(v37 + 8) == v7) {
            goto LABEL_79;
          }
          if (*(void *)(v7 + 8) != v37)
          {
            unsigned int v55 = *(_DWORD *)(v7 + 16);
            if (v55 < *(_DWORD *)(v37 + 16))
            {
              this = *(void *)(v54 + 1320);
              if (*(unsigned char *)(this + 64))
              {
                if (*(_DWORD *)(v37 + 72) >= *(_DWORD *)(v7 + 72) && *(_DWORD *)(v37 + 76) <= *(_DWORD *)(v7 + 76)) {
                  goto LABEL_79;
                }
              }
              else
              {
                unsigned int v56 = *(_DWORD *)(this + 68) + 1;
                *(_DWORD *)(this + 68) = v56;
                if (v56 > 0x20) {
                  llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::updateDFSNumbers();
                }
                do
                {
                  uint64_t v57 = v37;
                  uint64_t v37 = *(void *)(v37 + 8);
                }
                while (v37 && *(_DWORD *)(v37 + 16) >= v55);
                if (v57 == v7)
                {
LABEL_79:
                  uint64_t v30 = *(unsigned int *)(v90 + 24);
                  uint64_t v9 = *(void *)(v1 + 136);
                  goto LABEL_80;
                }
              }
            }
          }
LABEL_59:
          v31 += 8;
          if (v31 == v32)
          {
            uint64_t v9 = *(void *)(v1 + 136);
            uint64_t v74 = *(unsigned int *)(v90 + 24);
            uint64_t v75 = (void **)(v9 + 16 * v74);
            int v3 = v89;
            uint64_t v11 = v88;
            goto LABEL_90;
          }
        }
        uint64_t v40 = *(void *)(v1 + 16);
        unint64_t v41 = v34[1];
        if (v41 >= 8 && (uint64_t v42 = *(void *)((v41 & 0xFFFFFFFFFFFFFFF8) + 16)) != 0)
        {
          unsigned int v43 = (uint64_t *)(v42 + 24);
        }
        else
        {
          uint64_t v58 = *(void **)(v40 + 536);
          unint64_t v59 = *(unsigned int *)(v40 + 544);
          if (v59)
          {
            unsigned int v60 = *(_DWORD *)((v41 & 0xFFFFFFFFFFFFFFF8) + 24) | (v41 >> 1) & 3;
            uint64_t v61 = v58;
            unint64_t v62 = v59;
            do
            {
              unint64_t v63 = v62 >> 1;
              uint64_t v64 = &v61[2 * (v62 >> 1)];
              uint64_t v66 = *v64;
              uint64_t v65 = v64 + 2;
              v62 += ~(v62 >> 1);
              if (((v66 >> 1) & 3 | *(_DWORD *)((v66 & 0xFFFFFFFFFFFFFFF8) + 24)) < v60) {
                uint64_t v61 = v65;
              }
              else {
                unint64_t v62 = v63;
              }
            }
            while (v62);
            if (v61 == &v58[2 * v59]
              || ((*v61 >> 1) & 3 | *(_DWORD *)((*v61 & 0xFFFFFFFFFFFFFFF8) + 24)) > v60)
            {
              v61 -= 2;
            }
          }
          else
          {
            uint64_t v61 = *(void **)(v40 + 536);
          }
          unsigned int v43 = v61 + 1;
        }
        uint64_t v44 = *(void *)(v1 + 24);
        uint64_t v45 = *v43;
        llvm::MachineDominatorTree::applySplitCriticalEdges((void ***)v44);
        uint64_t v46 = *(void *)(v44 + 1320);
        uint64_t v47 = *(void *)(v46 + 24);
        uint64_t v48 = *(unsigned int *)(v46 + 40);
        if (v48)
        {
          LODWORD(v49) = (v48 - 1) & ((v45 >> 4) ^ (v45 >> 9));
          BOOL v50 = (uint64_t *)(v47 + 16 * v49);
          uint64_t v51 = *v50;
          if (*v50 == v45)
          {
LABEL_48:
            if (v50 == (uint64_t *)(v47 + 16 * v48)) {
              uint64_t v37 = 0;
            }
            else {
              uint64_t v37 = v50[1];
            }
            void *v38 = v37;
            goto LABEL_51;
          }
          int v52 = 1;
          while (v51 != -4096)
          {
            int v53 = v49 + v52++;
            uint64_t v49 = v53 & (v48 - 1);
            uint64_t v51 = *(void *)(v47 + 16 * v49);
            if (v51 == v45)
            {
              BOOL v50 = (uint64_t *)(v47 + 16 * v49);
              goto LABEL_48;
            }
          }
        }
        BOOL v50 = (uint64_t *)(v47 + 16 * v48);
        goto LABEL_48;
      }
      uint64_t v74 = *(unsigned int *)(v6 + 24);
      uint64_t v75 = (void **)(v9 + 16 * v74);
LABEL_90:
      if (v12)
      {
        if (v12 != (void *)&unk_1EA615298)
        {
          v4[3] = (uint64_t)v12;
          if ((unint64_t)v4[2] <= 7 && *v75 != v12)
          {
            *uint64_t v75 = v12;
            *(void *)(v9 + 16 * v74 + 8) = v11;
            goto LABEL_86;
          }
        }
      }
LABEL_87:
      v4 += 4;
    }
    while (v4 != v92);
  }
  while ((v3 & 1) != 0);
  return this;
}

uint64_t llvm::LiveRangeCalc::isDefOnEntry(void *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t *a7)
{
  unint64_t v7 = *(unsigned int *)(a5 + 24);
  unint64_t v8 = v7 >> 6;
  uint64_t v9 = 1;
  uint64_t v10 = 1 << v7;
  if (((1 << v7) & *(void *)(*a6 + 8 * (v7 >> 6))) != 0) {
    return v9;
  }
  if ((*(void *)(*a7 + 8 * v8) & v10) != 0) {
    return 0;
  }
  v72[0] = 0;
  v72[1] = 0;
  int v73 = 0;
  uint64_t v75 = 0;
  uint64_t v76 = 0;
  uint64_t v74 = 0;
  unsigned int v12 = *(uint64_t **)(a5 + 64);
  BOOL v13 = *(uint64_t **)(a5 + 72);
  if (v12 == v13)
  {
    uint64_t v18 = 0;
LABEL_50:
    uint64_t v9 = 0;
    uint64_t v54 = *a7;
    goto LABEL_51;
  }
  do
  {
    uint64_t v17 = *v12++;
    int v71 = *(_DWORD *)(v17 + 24);
    sub_1CBB29A9C((uint64_t)v72, &v71);
  }
  while (v12 != v13);
  uint64_t v18 = v74;
  unint64_t v19 = v75;
  if (v75 == v74)
  {
    uint64_t v18 = v75;
    goto LABEL_50;
  }
  uint64_t v20 = 0;
  int v21 = 0;
  uint64_t v23 = a3;
  uint64_t v22 = a4;
  while (1)
  {
    unint64_t v24 = v18[v20];
    uint64_t v25 = *(void *)(*(void *)(*a1 + 104) + 8 * v24);
    unint64_t v26 = v24 >> 6;
    uint64_t v27 = *(void *)(a1[5] + 8 * (v24 >> 6));
    uint64_t v28 = 1 << v24;
    uint64_t v29 = *(unsigned int *)(v25 + 24);
    if ((v27 & v28) != 0)
    {
      uint64_t v30 = *(void **)(a1[17] + 16 * v29);
      if (v30 && v30 != &unk_1EA615298)
      {
        unint64_t v62 = *(uint64_t **)(v25 + 88);
        unint64_t v63 = *(uint64_t **)(v25 + 96);
        uint64_t v54 = *a6;
        if (v62 != v63)
        {
          do
          {
            uint64_t v64 = *v62++;
            uint64_t v9 = 1;
            *(void *)(v54 + (((unint64_t)*(unsigned int *)(v64 + 24) >> 3) & 0x1FFFFFF8)) |= 1 << *(_DWORD *)(v64 + 24);
          }
          while (v62 != v63);
          goto LABEL_51;
        }
        *(void *)(v54 + 8 * v8) |= v10;
        uint64_t v9 = 1;
        goto LABEL_52;
      }
    }
    uint64_t v32 = (uint64_t *)(*(void *)(a1[2] + 392) + 16 * v29);
    uint64_t v33 = v32[1];
    unsigned int v34 = (v33 >> 1) & 3;
    unint64_t v35 = v33 & 0xFFFFFFFFFFFFFFF8;
    if (v34) {
      uint64_t v36 = v35 | (2 * (v34 - 1));
    }
    else {
      uint64_t v36 = *(void *)v35 | 6;
    }
    uint64_t v37 = *v32;
    unint64_t v38 = *(unsigned int *)(a2 + 8);
    if (v38)
    {
      unsigned int v39 = *(_DWORD *)((v36 & 0xFFFFFFFFFFFFFFF8) + 24) | (v36 >> 1) & 3;
      uint64_t v40 = *(void **)a2;
      do
      {
        unint64_t v41 = v38 >> 1;
        uint64_t v42 = &v40[3 * (v38 >> 1)];
        uint64_t v44 = *v42;
        unsigned int v43 = v42 + 3;
        v38 += ~(v38 >> 1);
        if (v39 < ((v44 >> 1) & 3 | *(_DWORD *)((v44 & 0xFFFFFFFFFFFFFFF8) + 24))) {
          unint64_t v38 = v41;
        }
        else {
          uint64_t v40 = v43;
        }
      }
      while (v38);
      if (v40 != *(void **)a2)
      {
        unsigned int v45 = (*(v40 - 2) >> 1) & 3 | *(_DWORD *)((*(v40 - 2) & 0xFFFFFFFFFFFFFFF8) + 24);
        if (v45 > (*(_DWORD *)((v37 & 0xFFFFFFFFFFFFFFF8) + 24) | (v37 >> 1) & 3))
        {
          if (v22)
          {
            uint64_t v46 = 8 * a4;
            uint64_t v47 = v23;
            do
            {
              unsigned int v48 = (*v47 >> 1) & 3 | *(_DWORD *)((*v47 & 0xFFFFFFFFFFFFFFF8) + 24);
              if (v45 <= v48 && v48 < (*(_DWORD *)(v35 + 24) | v34)) {
                goto LABEL_43;
              }
              ++v47;
              v46 -= 8;
            }
            while (v46);
          }
          uint64_t v58 = *(uint64_t **)(v25 + 88);
          unint64_t v59 = *(uint64_t **)(v25 + 96);
          uint64_t v54 = *a6;
          if (v58 != v59)
          {
            do
            {
              uint64_t v60 = *v58++;
              uint64_t v9 = 1;
              *(void *)(v54 + (((unint64_t)*(unsigned int *)(v60 + 24) >> 3) & 0x1FFFFFF8)) |= 1 << *(_DWORD *)(v60 + 24);
            }
            while (v58 != v59);
            goto LABEL_51;
          }
LABEL_61:
          uint64_t v9 = 1;
          goto LABEL_51;
        }
      }
    }
    uint64_t v49 = *(void *)(*a7 + 8 * v26);
    if ((v49 & v28) != 0) {
      goto LABEL_32;
    }
    if (!v22) {
      break;
    }
    unsigned int v50 = *(_DWORD *)((v37 & 0xFFFFFFFFFFFFFFF8) + 24) | (v37 >> 1) & 3;
    uint64_t v51 = 8 * a4;
    int v52 = v23;
    while (1)
    {
      unsigned int v53 = (*v52 >> 1) & 3 | *(_DWORD *)((*v52 & 0xFFFFFFFFFFFFFFF8) + 24);
      if (v50 <= v53 && v53 < (*(_DWORD *)(v35 + 24) | v34)) {
        break;
      }
      ++v52;
      v51 -= 8;
      if (!v51) {
        goto LABEL_38;
      }
    }
LABEL_32:
    *(void *)(*a7 + 8 * v26) = v49 | v28;
LABEL_43:
    uint64_t v20 = ++v21;
    if (v21 == v19 - v18) {
      goto LABEL_50;
    }
  }
LABEL_38:
  uint64_t v54 = *a6;
  if ((*(void *)(*a6 + 8 * v26) & v28) == 0)
  {
    unsigned int v55 = *(uint64_t **)(v25 + 64);
    unsigned int v56 = *(uint64_t **)(v25 + 72);
    if (v55 != v56)
    {
      int v68 = v21;
      do
      {
        uint64_t v57 = *v55++;
        int v71 = *(_DWORD *)(v57 + 24);
        sub_1CBB29A9C((uint64_t)v72, &v71);
      }
      while (v55 != v56);
      uint64_t v18 = v74;
      unint64_t v19 = v75;
      uint64_t v23 = a3;
      uint64_t v22 = a4;
      int v21 = v68;
    }
    goto LABEL_43;
  }
  uint64_t v65 = *(uint64_t **)(v25 + 88);
  uint64_t v66 = *(uint64_t **)(v25 + 96);
  if (v65 == v66) {
    goto LABEL_61;
  }
  do
  {
    uint64_t v67 = *v65++;
    uint64_t v9 = 1;
    *(void *)(v54 + (((unint64_t)*(unsigned int *)(v67 + 24) >> 3) & 0x1FFFFFF8)) |= 1 << *(_DWORD *)(v67 + 24);
  }
  while (v65 != v66);
LABEL_51:
  *(void *)(v54 + 8 * v8) |= v10;
  if (v18)
  {
LABEL_52:
    uint64_t v75 = v18;
    operator delete(v18);
  }
  MEMORY[0x1D25D9CD0](v72[0], 4);
  return v9;
}

uint64_t llvm::LiveRangeCalc::isJointlyDominated(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v9 = (*(void *)(v8 + 112) - *(void *)(v8 + 104)) >> 3;
  uint64_t v10 = (v9 + 63) >> 6;
  uint64_t v42 = v45;
  int v44 = 6;
  if (v10 >= 7)
  {
    unsigned int v43 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if ((v9 + 63) >> 6) {
    bzero(v45, 8 * v10);
  }
  unsigned int v43 = (v9 + 63) >> 6;
  int v46 = v9;
  if (a3)
  {
    uint64_t v11 = &a2[a3];
    unsigned int v12 = *(void **)(a4 + 536);
    unint64_t v13 = *(unsigned int *)(a4 + 544);
    do
    {
      uint64_t v14 = *a2;
      if ((unint64_t)*a2 >= 8 && (uint64_t v15 = *(void *)((v14 & 0xFFFFFFFFFFFFFFF8) + 16)) != 0)
      {
        unint64_t v16 = (void *)(v15 + 24);
      }
      else
      {
        uint64_t v17 = v12;
        if (v13)
        {
          unsigned int v18 = *(_DWORD *)((v14 & 0xFFFFFFFFFFFFFFF8) + 24) | (v14 >> 1) & 3;
          uint64_t v17 = v12;
          unint64_t v19 = v13;
          do
          {
            unint64_t v20 = v19 >> 1;
            int v21 = &v17[2 * (v19 >> 1)];
            uint64_t v23 = *v21;
            uint64_t v22 = v21 + 2;
            v19 += ~(v19 >> 1);
            if (((v23 >> 1) & 3 | *(_DWORD *)((v23 & 0xFFFFFFFFFFFFFFF8) + 24)) < v18) {
              uint64_t v17 = v22;
            }
            else {
              unint64_t v19 = v20;
            }
          }
          while (v19);
          if (v17 == &v12[2 * v13]
            || ((*v17 >> 1) & 3 | *(_DWORD *)((*v17 & 0xFFFFFFFFFFFFFFF8) + 24)) > v18)
          {
            v17 -= 2;
          }
        }
        unint64_t v16 = v17 + 1;
      }
      *(void *)&v45[((unint64_t)*(unsigned int *)(*v16 + 24) >> 3) & 0x1FFFFFF8] |= 1 << *(_DWORD *)(*v16 + 24);
      ++a2;
    }
    while (a2 != v11);
  }
  v37[0] = 0;
  v37[1] = 0;
  int v38 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  unsigned int v39 = 0;
  int v36 = *(_DWORD *)(a1 + 24);
  sub_1CBB29A9C((uint64_t)v37, &v36);
  unint64_t v24 = v39;
  uint64_t v25 = v40;
  if (v40 != v39)
  {
    uint64_t v26 = 0;
    int v27 = 0;
    while (1)
    {
      unint64_t v28 = v24[v26];
      if ((*(void *)((char *)v42 + ((v28 >> 3) & 0x1FFFFFF8)) >> v28)) {
        break;
      }
      uint64_t v29 = *(void *)(*(void *)(v8 + 104) + 8 * v28);
      uint64_t v30 = *(uint64_t **)(v29 + 64);
      uint64_t v31 = *(uint64_t **)(v29 + 72);
      if (v30 != v31)
      {
        do
        {
          uint64_t v32 = *v30++;
          int v36 = *(_DWORD *)(v32 + 24);
          sub_1CBB29A9C((uint64_t)v37, &v36);
        }
        while (v30 != v31);
        unint64_t v24 = v39;
        uint64_t v25 = v40;
      }
      uint64_t v26 = ++v27;
      if (v27 == v25 - v24) {
        goto LABEL_32;
      }
    }
    uint64_t v33 = 1;
LABEL_35:
    uint64_t v40 = v24;
    operator delete(v24);
    uint64_t v34 = v33;
    goto LABEL_36;
  }
  unint64_t v24 = v40;
LABEL_32:
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  if (v24) {
    goto LABEL_35;
  }
LABEL_36:
  MEMORY[0x1D25D9CD0](v37[0], 4);
  if (v42 != v45) {
    free(v42);
  }
  return v34;
}

uint64_t sub_1CC302E54(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x600000000;
  if (a1 != a2)
  {
    unsigned int v4 = *(_DWORD *)(a2 + 8);
    if (v4)
    {
      uint64_t v5 = *(const void **)a2;
      if (*(void *)a2 == a2 + 16)
      {
        if (v4 >= 7) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        memcpy((void *)(a1 + 16), v5, 8 * *(unsigned int *)(a2 + 8));
        *(_DWORD *)(a1 + 8) = v4;
      }
      else
      {
        *(void *)a1 = v5;
        int v11 = *(_DWORD *)(a2 + 12);
        *(_DWORD *)(a1 + 8) = v4;
        *(_DWORD *)(a1 + 12) = v11;
        *(void *)a2 = a2 + 16;
        *(_DWORD *)(a2 + 12) = 0;
      }
      *(_DWORD *)(a2 + 8) = 0;
    }
  }
  int v6 = *(_DWORD *)(a2 + 64);
  *(void *)(a1 + 72) = a1 + 88;
  *(_DWORD *)(a1 + 64) = v6;
  *(void *)(a1 + 80) = 0x600000000;
  unsigned int v7 = *(_DWORD *)(a2 + 80);
  if (v7 && a1 != a2)
  {
    uint64_t v8 = *(const void **)(a2 + 72);
    if (v8 == (const void *)(a2 + 88))
    {
      if (v7 >= 7) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy((void *)(a1 + 88), v8, 8 * *(unsigned int *)(a2 + 80));
      *(_DWORD *)(a1 + 80) = v7;
    }
    else
    {
      *(void *)(a1 + 72) = v8;
      int v10 = *(_DWORD *)(a2 + 84);
      *(_DWORD *)(a1 + 80) = v7;
      *(_DWORD *)(a1 + 84) = v10;
      *(void *)(a2 + 72) = a2 + 88;
      *(_DWORD *)(a2 + 84) = 0;
    }
    *(_DWORD *)(a2 + 80) = 0;
  }
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 136);
  return a1;
}

void sub_1CC302FD0(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = 152 * v1;
    uint64_t v3 = *(void *)a1 + 96;
    do
    {
      uint64_t v4 = *(void *)(v3 - 96);
      if (v4 != -4096 && v4 != -8192)
      {
        uint64_t v5 = *(void **)(v3 - 16);
        if ((void *)v3 != v5) {
          free(v5);
        }
        int v6 = *(void **)(v3 - 88);
        if ((void *)(v3 - 72) != v6) {
          free(v6);
        }
      }
      v3 += 152;
      v2 -= 152;
    }
    while (v2);
  }
}

uint64_t sub_1CC303054(uint64_t result, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    int v6 = (void *)(result + 152 * v5);
    uint64_t v7 = *v6;
    if (*v6 != a3)
    {
      uint64_t v8 = 0;
      int v9 = 1;
      while (v7 != -4096)
      {
        if (v8) {
          BOOL v10 = 0;
        }
        else {
          BOOL v10 = v7 == -8192;
        }
        if (v10) {
          uint64_t v8 = v6;
        }
        unsigned int v11 = v5 + v9++;
        unsigned int v5 = v11 & v4;
        int v6 = (void *)(result + 152 * (v11 & v4));
        uint64_t v7 = *v6;
        if (*v6 == a3) {
          goto LABEL_7;
        }
      }
      if (v8) {
        int v6 = v8;
      }
    }
  }
  else
  {
    int v6 = 0;
  }
LABEL_7:
  *a4 = v6;
  return result;
}

void *sub_1CC3030D8(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(152 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD51D578(a1, v4, &v4[19 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  unsigned int v10 = *(_DWORD *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 152 * v10;
    do
    {
      *uint64_t result = -4096;
      result += 19;
      v11 -= 152;
    }
    while (v11);
  }
  return result;
}

void llvm::LiveIntervalCalc::calculate(llvm::LiveIntervalCalc *this, llvm::LiveInterval *a2, char a3)
{
  uint64_t v86 = *MEMORY[0x1E4F143B8];
  int v7 = (void *)*((void *)this + 1);
  uint64_t v6 = *((void *)this + 2);
  uint64_t v8 = *((void *)this + 4);
  int v9 = (void *)(*(uint64_t (**)(void))(**(void **)(*v7 + 16) + 176))(*(void *)(*v7 + 16));
  uint64_t v10 = *((unsigned int *)a2 + 28);
  if ((v10 & 0x80000000) != 0) {
    uint64_t v11 = (int **)(v7[3] + 16 * (v10 & 0x7FFFFFFF) + 8);
  }
  else {
    uint64_t v11 = (int **)(v7[34] + 8 * v10);
  }
  unsigned int v12 = *v11;
  if (!*v11) {
    goto LABEL_51;
  }
  while (1)
  {
    unsigned int v13 = *v12;
    if ((*v12 & 0x80000000) == 0) {
      break;
    }
    unsigned int v12 = (int *)*((void *)v12 + 3);
    if (!v12) {
      goto LABEL_51;
    }
  }
LABEL_5:
  if ((v13 & 0x1000000) == 0 && ((v13 & 0x30000000) != 0 || (v13 & 0x10FFF00) == 0x1000000)) {
    goto LABEL_26;
  }
  unsigned int v14 = (v13 >> 8) & 0xFFF;
  if (*((void *)a2 + 13))
  {
    if (v14) {
      uint64_t v34 = *(void *)(v9[29] + 8 * v14);
    }
    else {
      uint64_t v34 = *(void *)((*(void *)(v7[3] + 16 * (v10 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8) + 24);
    }
  }
  else
  {
    if (!v14 || (a3 & 1) == 0) {
      goto LABEL_11;
    }
    uint64_t v34 = *(void *)(v9[29] + 8 * v14);
    if (*((_DWORD *)a2 + 2))
    {
      uint64_t v68 = *(void *)((*(void *)(v7[3] + 16 * (v10 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8) + 24);
      unint64_t v70 = v9;
      *(void *)(v8 + 80) += 120;
      if (((*(void *)v8 + 7) & 0xFFFFFFFFFFFFFFF8) - *(void *)v8 + 120 > *(void *)(v8 + 8) - *(void *)v8)
      {
        unsigned int v35 = *(_DWORD *)(v8 + 24) >> 7;
        if (v35 >= 0x1E) {
          LOBYTE(v35) = 30;
        }
        uint64_t v66 = 4096 << v35;
        uint64_t v33 = operator new(4096 << v35, (std::align_val_t)8uLL);
        unint64_t v36 = *(unsigned int *)(v8 + 24);
        if (v36 >= *(unsigned int *)(v8 + 28)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v8 + 16) + 8 * v36) = v33;
        ++*(_DWORD *)(v8 + 24);
        *(void *)(v8 + 8) = (char *)v33 + v66;
      }
      else
      {
        uint64_t v33 = (void *)((*(void *)v8 + 7) & 0xFFFFFFFFFFFFFFF8);
      }
      *(void *)uint64_t v8 = v33 + 15;
      *uint64_t v33 = v33 + 2;
      v33[1] = 0x200000000;
      v33[8] = v33 + 10;
      v33[9] = 0x200000000;
      v33[12] = 0;
      sub_1CC2CD2F8((uint64_t)v33, (uint64_t)a2, v8);
      v33[14] = v68;
      v33[13] = *((void *)a2 + 13);
      *((void *)a2 + 13) = v33;
      int v9 = v70;
    }
  }
  uint64_t v32 = operator new(0x20uLL);
  *uint64_t v32 = &unk_1F260CA20;
  v32[1] = v12;
  v32[2] = v6;
  v32[3] = v8;
  unsigned int v85 = v32;
  llvm::LiveInterval::refineSubRanges((uint64_t)a2, v8, v34, (uint64_t)v84, v6, v9, 0);
  if (v85 == v84)
  {
    (*(void (**)(void *))(v84[0] + 32))(v84);
  }
  else if (v85)
  {
    (*(void (**)(void))(*v85 + 40))();
  }
LABEL_11:
  if ((*v12 & 0x1000000) == 0 || *((void *)a2 + 13)) {
    goto LABEL_26;
  }
  unint64_t v15 = *((void *)v12 + 1);
  __int16 v16 = *(_WORD *)(v15 + 44);
  unint64_t v17 = v15;
  if ((v16 & 0xC) != 0)
  {
    if ((v16 & 4) != 0)
    {
      unint64_t v17 = *((void *)v12 + 1);
      do
        unint64_t v17 = *(void *)v17 & 0xFFFFFFFFFFFFFFF8;
      while ((*(_WORD *)(v17 + 44) & 4) != 0);
    }
    if ((v16 & 8) != 0)
    {
      do
        unint64_t v15 = *(void *)(v15 + 8);
      while ((*(_WORD *)(v15 + 44) & 8) != 0);
    }
  }
  unint64_t v18 = *(void *)(v15 + 8);
  if (v17 != v18)
  {
    while (1)
    {
      unsigned int v19 = **(unsigned __int16 **)(v17 + 16);
      BOOL v20 = v19 > 0x17;
      int v21 = (1 << v19) & 0x83E000;
      if (v20 || v21 == 0) {
        break;
      }
      unint64_t v17 = *(void *)(v17 + 8);
      if (v17 == v18)
      {
        unint64_t v17 = v18;
        break;
      }
    }
  }
  uint64_t v23 = *(void *)(v6 + 368);
  uint64_t v24 = *(unsigned int *)(v6 + 384);
  if (v24)
  {
    LODWORD(v25) = ((v17 >> 4) ^ (v17 >> 9)) & (v24 - 1);
    uint64_t v26 = (uint64_t *)(v23 + 16 * v25);
    uint64_t v27 = *v26;
    if (v17 == *v26) {
      goto LABEL_22;
    }
    int v30 = 1;
    while (v27 != -4096)
    {
      int v31 = v25 + v30++;
      uint64_t v25 = v31 & (v24 - 1);
      uint64_t v27 = *(void *)(v23 + 16 * v25);
      if (v17 == v27)
      {
        uint64_t v26 = (uint64_t *)(v23 + 16 * v25);
        goto LABEL_22;
      }
    }
  }
  uint64_t v26 = (uint64_t *)(v23 + 16 * v24);
LABEL_22:
  uint64_t v28 = 2;
  if ((*v12 & 0x40000000) == 0) {
    uint64_t v28 = 4;
  }
  unint64_t v29 = v26[1] & 0xFFFFFFFFFFFFFFF8 | v28;
  if (*((void *)a2 + 12))
  {
    v71[0] = (unint64_t *)a2;
    sub_1CC2F6AE4((uint64_t *)v71, v29, v8, 0);
  }
  else
  {
    v71[0] = (unint64_t *)a2;
    sub_1CC2F6F18(v71, v29, v8, 0);
  }
LABEL_26:
  while (1)
  {
    unsigned int v12 = (int *)*((void *)v12 + 3);
    if (!v12) {
      break;
    }
    unsigned int v13 = *v12;
    if ((*v12 & 0x80000000) == 0) {
      goto LABEL_5;
    }
  }
LABEL_51:
  uint64_t v37 = (uint64_t *)((char *)a2 + 104);
  uint64_t v38 = *((void *)a2 + 13);
  if (!v38) {
    goto LABEL_52;
  }
  unsigned int v43 = (void *)((char *)a2 + 104);
  while (1)
  {
    uint64_t v44 = v38;
    if (!*(_DWORD *)(v38 + 8)) {
      break;
    }
LABEL_56:
    unsigned int v43 = (void *)(v38 + 104);
    uint64_t v38 = *(void *)(v38 + 104);
    if (!v38) {
      goto LABEL_57;
    }
  }
  while (1)
  {
    uint64_t v63 = *(void *)(v44 + 96);
    uint64_t v38 = *(void *)(v44 + 104);
    *(void *)(v44 + 96) = 0;
    if (v63)
    {
      sub_1CB833A08(v63, *(void **)(v63 + 8));
      MEMORY[0x1D25D9CE0](v63, 0x1020C4062D53EE8);
    }
    uint64_t v64 = *(void **)(v44 + 64);
    if (v64 != (void *)(v44 + 80)) {
      free(v64);
    }
    if (*(void *)v44 != v44 + 16) {
      free(*(void **)v44);
    }
    if (!v38) {
      break;
    }
    uint64_t v44 = v38;
    if (*(_DWORD *)(v38 + 8))
    {
      *unsigned int v43 = v38;
      goto LABEL_56;
    }
  }
  *unsigned int v43 = 0;
LABEL_57:
  uint64_t v45 = *v37;
  if (*v37)
  {
    int v46 = *(unint64_t **)this;
    uint64_t v67 = (unint64_t *)v8;
    uint64_t v69 = (unint64_t *)*((void *)this + 3);
    uint64_t v47 = v80;
    do
    {
      unint64_t v72 = v74;
      uint64_t v73 = 0x600000000;
      v74[12] = 0;
      uint64_t v75 = 0;
      uint64_t v76 = 0;
      unsigned int v77 = 0;
      v80[0] = 0;
      v80[1] = 0;
      uint64_t v79 = 0;
      unint64_t v78 = v47;
      unsigned int v81 = v83;
      uint64_t v82 = 0x1000000000;
      unsigned int v48 = (unint64_t *)v46[5];
      v71[0] = v46;
      v71[1] = v48;
      v71[2] = (unint64_t *)v6;
      v71[3] = v69;
      v71[4] = v67;
      llvm::LiveRangeCalc::resetLiveOutMap((llvm::LiveRangeCalc *)v71);
      LODWORD(v82) = 0;
      llvm::LiveIntervalCalc::extendToUses((llvm::LiveRangeCalc *)v71, v45, v10, *(void *)(v45 + 112), (uint64_t)a2);
      if (v81 != v83) {
        free(v81);
      }
      uint64_t v49 = v47;
      if (v78 != v47) {
        free(v78);
      }
      uint64_t v50 = v75;
      if (v77)
      {
        uint64_t v65 = v46;
        uint64_t v53 = 152 * v77;
        int v52 = (void *)(v75 + 96);
        do
        {
          uint64_t v51 = *(v52 - 12);
          if (v51 != -4096 && v51 != -8192)
          {
            uint64_t v54 = (void *)*(v52 - 2);
            if (v52 != v54) {
              free(v54);
            }
            unsigned int v55 = (char *)*(v52 - 11);
            if (v52 - 9 != (void *)v55) {
              free(v55);
            }
          }
          v52 += 19;
          v53 -= 152;
        }
        while (v53);
        uint64_t v50 = v75;
        int v46 = v65;
      }
      MEMORY[0x1D25D9CD0](v50, 8);
      if (v72 != v74) {
        free(v72);
      }
      uint64_t v45 = *(void *)(v45 + 104);
      uint64_t v47 = v49;
    }
    while (v45);
    *((_DWORD *)a2 + 18) = 0;
    *((_DWORD *)a2 + 2) = 0;
    uint64_t v56 = *((void *)a2 + 13);
    if (v56)
    {
      uint64_t v57 = *((void *)this + 4);
      do
      {
        uint64_t v58 = *(unsigned int *)(v56 + 72);
        if (v58)
        {
          uint64_t v59 = *(void *)(v56 + 64);
          uint64_t v60 = 8 * v58;
          do
          {
            unint64_t v61 = *(void *)(*(void *)v59 + 8);
            if (v61 >= 8 && (*(void *)(*(void *)v59 + 8) & 6) != 0)
            {
              if (*((void *)a2 + 12))
              {
                v71[0] = (unint64_t *)a2;
                sub_1CC2F6AE4((uint64_t *)v71, v61, v57, 0);
              }
              else
              {
                v71[0] = (unint64_t *)a2;
                sub_1CC2F6F18(v71, v61, v57, 0);
              }
            }
            v59 += 8;
            v60 -= 8;
          }
          while (v60);
        }
        uint64_t v56 = *(void *)(v56 + 104);
      }
      while (v56);
    }
    llvm::LiveRangeCalc::resetLiveOutMap(this);
    uint64_t v41 = *((unsigned int *)a2 + 28);
    unsigned int v39 = this;
    uint64_t v40 = a2;
    uint64_t v42 = a2;
  }
  else
  {
LABEL_52:
    llvm::LiveRangeCalc::resetLiveOutMap(this);
    unsigned int v39 = this;
    uint64_t v40 = a2;
    uint64_t v41 = v10;
    uint64_t v42 = 0;
  }
  llvm::LiveIntervalCalc::extendToUses(v39, (uint64_t)v40, v41, -1, (uint64_t)v42);
}

void llvm::LiveIntervalCalc::extendToUses(llvm::LiveRangeCalc *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v48[4] = *MEMORY[0x1E4F143B8];
  int v9 = (void *)*((void *)a1 + 1);
  uint64_t v8 = *((void *)a1 + 2);
  int v46 = v48;
  uint64_t v47 = 0x400000000;
  if (a5) {
    llvm::LiveInterval::computeSubRangeUndefs(a5, (uint64_t)&v46, a4, v9, v8);
  }
  uint64_t v44 = (*(uint64_t (**)(void))(**(void **)(*v9 + 16) + 176))(*(void *)(*v9 + 16));
  if ((a3 & 0x80000000) != 0) {
    uint64_t v10 = (unsigned int **)(v9[3] + 16 * (a3 & 0x7FFFFFFF) + 8);
  }
  else {
    uint64_t v10 = (unsigned int **)(v9[34] + 8 * a3);
  }
  uint64_t v11 = *v10;
  if (*v10)
  {
    while (1)
    {
      unsigned int v12 = *v11;
      if ((*v11 & 0x80000000) == 0) {
        break;
      }
      uint64_t v11 = (unsigned int *)*((void *)v11 + 3);
      if (!v11) {
        goto LABEL_53;
      }
    }
LABEL_7:
    if ((v12 & 0x1000000) == 0)
    {
      v12 &= ~0x4000000u;
      *uint64_t v11 = v12;
    }
    if ((v12 & 0x30000000) == 0 && (v12 & 0x10FFF00) != 0x1000000 && (a4 == -1 || (v12 & 0x1000000) == 0))
    {
      unsigned int v13 = (v12 >> 8) & 0xFFF;
      if (!v13 || ((*(void *)(*(void *)(v44 + 232) + 8 * v13) ^ ((uint64_t)(int)(v12 << 7) >> 31)) & a4) != 0)
      {
        unint64_t v14 = *((void *)v11 + 1);
        uint64_t v15 = *(void *)(v14 + 32);
        uint64_t v16 = ((unint64_t)v11 - v15) >> 5;
        int v17 = **(unsigned __int16 **)(v14 + 16);
        if (v17 == 69 || v17 == 0)
        {
          unint64_t v36 = *(void *)(*(void *)(v8 + 392)
                          + 16 * *(unsigned int *)(*(void *)(v15 + 32 * (v16 + 1) + 16) + 24)
                          + 8);
        }
        else
        {
          if ((v12 & 0x1000000) != 0)
          {
            int v41 = (v12 >> 30) & 1;
          }
          else
          {
            int v19 = *(_DWORD *)(v15 + (((unint64_t)v11 - v15) & 0x1FFFFFFFE0));
            int v20 = v19 & 0x10000FF;
            int v21 = v19 & 0xF00000;
            if (v20) {
              BOOL v22 = 1;
            }
            else {
              BOOL v22 = v21 == 0;
            }
            if (v22)
            {
              int v41 = 0;
            }
            else
            {
              unsigned int v43 = v11;
              unint64_t v39 = *((void *)v11 + 1);
              unsigned int TiedOperandIdx = llvm::MachineInstr::findTiedOperandIdx((llvm::MachineInstr *)v14, v16);
              unint64_t v14 = v39;
              uint64_t v11 = v43;
              int v41 = (*(unsigned __int8 *)(*(void *)(v14 + 32) + 32 * TiedOperandIdx + 3) >> 6) & 1;
            }
          }
          __int16 v23 = *(_WORD *)(v14 + 44);
          if ((v23 & 0xC) != 0)
          {
            unint64_t v42 = v14;
            unint64_t v24 = v14;
            if ((v23 & 4) != 0)
            {
              unint64_t v24 = v14;
              do
                unint64_t v24 = *(void *)v24 & 0xFFFFFFFFFFFFFFF8;
              while ((*(_WORD *)(v24 + 44) & 4) != 0);
            }
            if ((v23 & 8) != 0)
            {
              do
                unint64_t v42 = *(void *)(v42 + 8);
              while ((*(_WORD *)(v42 + 44) & 8) != 0);
            }
            unint64_t v14 = v42;
          }
          else
          {
            unint64_t v24 = v14;
          }
          unint64_t v25 = *(void *)(v14 + 8);
          if (v24 != v25)
          {
            do
            {
              unsigned int v26 = **(unsigned __int16 **)(v24 + 16);
              BOOL v27 = v26 > 0x17;
              int v28 = (1 << v26) & 0x83E000;
              if (v27 || v28 == 0) {
                goto LABEL_33;
              }
              unint64_t v24 = *(void *)(v24 + 8);
            }
            while (v24 != v25);
            unint64_t v24 = v25;
          }
LABEL_33:
          uint64_t v30 = *(void *)(v8 + 368);
          uint64_t v31 = *(unsigned int *)(v8 + 384);
          if (v31)
          {
            LODWORD(v32) = ((v24 >> 4) ^ (v24 >> 9)) & (v31 - 1);
            uint64_t v33 = (uint64_t *)(v30 + 16 * v32);
            uint64_t v34 = *v33;
            if (v24 != *v33)
            {
              int v37 = 1;
              do
              {
                if (v34 == -4096) {
                  goto LABEL_49;
                }
                int v38 = v32 + v37++;
                uint64_t v32 = v38 & (v31 - 1);
                uint64_t v34 = *(void *)(v30 + 16 * v32);
              }
              while (v24 != v34);
              uint64_t v33 = (uint64_t *)(v30 + 16 * v32);
            }
          }
          else
          {
LABEL_49:
            uint64_t v33 = (uint64_t *)(v30 + 16 * v31);
          }
          if (v41) {
            uint64_t v35 = 2;
          }
          else {
            uint64_t v35 = 4;
          }
          unint64_t v36 = v33[1] & 0xFFFFFFFFFFFFFFF8 | v35;
        }
        llvm::LiveRangeCalc::extend(a1, a2, v36, a3, v46, v47);
      }
    }
    while (1)
    {
      uint64_t v11 = (unsigned int *)*((void *)v11 + 3);
      if (!v11) {
        break;
      }
      unsigned int v12 = *v11;
      if ((*v11 & 0x80000000) == 0) {
        goto LABEL_7;
      }
    }
  }
LABEL_53:
  if (v46 != v48) {
    free(v46);
  }
}

void llvm::LiveIntervalCalc::constructMainRangeFromSubranges(llvm::LiveIntervalCalc *this, llvm::LiveInterval *a2)
{
  uint64_t v4 = *((void *)a2 + 13);
  if (v4)
  {
    uint64_t v5 = *((void *)this + 4);
    do
    {
      uint64_t v6 = *(unsigned int *)(v4 + 72);
      if (v6)
      {
        uint64_t v7 = *(void *)(v4 + 64);
        uint64_t v8 = 8 * v6;
        do
        {
          unint64_t v9 = *(void *)(*(void *)v7 + 8);
          if (v9 >= 8 && (*(void *)(*(void *)v7 + 8) & 6) != 0)
          {
            if (*((void *)a2 + 12))
            {
              unsigned int v12 = (unint64_t *)a2;
              sub_1CC2F6AE4((uint64_t *)&v12, v9, v5, 0);
            }
            else
            {
              unsigned int v12 = (unint64_t *)a2;
              sub_1CC2F6F18(&v12, v9, v5, 0);
            }
          }
          v7 += 8;
          v8 -= 8;
        }
        while (v8);
      }
      uint64_t v4 = *(void *)(v4 + 104);
    }
    while (v4);
  }
  llvm::LiveRangeCalc::resetLiveOutMap(this);
  uint64_t v11 = *((unsigned int *)a2 + 28);

  llvm::LiveIntervalCalc::extendToUses(this, (uint64_t)a2, v11, -1, (uint64_t)a2);
}

void *llvm::LiveIntervalCalc::createDeadDefs(void *result, unint64_t *a2, unsigned int a3)
{
  uint64_t v4 = result[1];
  if ((a3 & 0x80000000) != 0) {
    uint64_t v5 = (int **)(*(void *)(v4 + 24) + 16 * (a3 & 0x7FFFFFFF) + 8);
  }
  else {
    uint64_t v5 = (int **)(*(void *)(v4 + 272) + 8 * a3);
  }
  uint64_t v6 = *v5;
  if (*v5)
  {
    uint64_t v7 = result[2];
    uint64_t v8 = result[4];
    int v9 = *v6;
    if ((*v6 & 0x1000000) != 0 || (v6 = (int *)*((void *)v6 + 3)) != 0 && (int v9 = *v6, (*v6 & 0x1000000) != 0))
    {
      while (1)
      {
        unint64_t v10 = *((void *)v6 + 1);
        __int16 v11 = *(_WORD *)(v10 + 44);
        unint64_t v12 = v10;
        if ((v11 & 4) != 0)
        {
          do
            unint64_t v12 = *(void *)v12 & 0xFFFFFFFFFFFFFFF8;
          while ((*(_WORD *)(v12 + 44) & 4) != 0);
        }
        if ((v11 & 8) != 0)
        {
          do
            unint64_t v10 = *(void *)(v10 + 8);
          while ((*(_WORD *)(v10 + 44) & 8) != 0);
        }
        unint64_t v13 = *(void *)(v10 + 8);
        if (v12 != v13)
        {
          while (1)
          {
            unsigned int v14 = **(unsigned __int16 **)(v12 + 16);
            BOOL v15 = v14 > 0x17;
            int v16 = (1 << v14) & 0x83E000;
            if (v15 || v16 == 0) {
              break;
            }
            unint64_t v12 = *(void *)(v12 + 8);
            if (v12 == v13)
            {
              unint64_t v12 = v13;
              break;
            }
          }
        }
        uint64_t v18 = *(void *)(v7 + 368);
        uint64_t v19 = *(unsigned int *)(v7 + 384);
        if (!v19) {
          goto LABEL_28;
        }
        LODWORD(v20) = ((v12 >> 4) ^ (v12 >> 9)) & (v19 - 1);
        int v21 = (uint64_t *)(v18 + 16 * v20);
        uint64_t v22 = *v21;
        if (v12 != *v21) {
          break;
        }
LABEL_16:
        if ((v9 & 0x40000000) != 0) {
          uint64_t v23 = 2;
        }
        else {
          uint64_t v23 = 4;
        }
        unint64_t v24 = v23 | v21[1] & 0xFFFFFFFFFFFFFFF8;
        if (a2[12])
        {
          BOOL v27 = a2;
          uint64_t result = (void *)sub_1CC2F6AE4((uint64_t *)&v27, v24, v8, 0);
        }
        else
        {
          BOOL v27 = a2;
          uint64_t result = (void *)sub_1CC2F6F18(&v27, v24, v8, 0);
        }
        uint64_t v6 = (int *)*((void *)v6 + 3);
        if (v6)
        {
          int v9 = *v6;
          if ((*v6 & 0x1000000) != 0) {
            continue;
          }
        }
        return result;
      }
      int v25 = 1;
      while (v22 != -4096)
      {
        int v26 = v20 + v25++;
        uint64_t v20 = v26 & (v19 - 1);
        uint64_t v22 = *(void *)(v18 + 16 * v20);
        if (v12 == v22)
        {
          int v21 = (uint64_t *)(v18 + 16 * v20);
          goto LABEL_16;
        }
      }
LABEL_28:
      int v21 = (uint64_t *)(v18 + 16 * v19);
      goto LABEL_16;
    }
  }
  return result;
}

void sub_1CC303FF0()
{
}

__n128 sub_1CC304004(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F260CA20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1CC304058(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F260CA20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void *sub_1CC304090(void *result, unint64_t *a2)
{
  uint64_t v2 = (int *)result[1];
  int v3 = *v2;
  if ((*v2 & 0x1000000) == 0) {
    return result;
  }
  unint64_t v4 = *((void *)v2 + 1);
  __int16 v5 = *(_WORD *)(v4 + 44);
  unint64_t v6 = v4;
  if ((v5 & 4) != 0)
  {
    unint64_t v6 = v4;
    do
      unint64_t v6 = *(void *)v6 & 0xFFFFFFFFFFFFFFF8;
    while ((*(_WORD *)(v6 + 44) & 4) != 0);
  }
  uint64_t v7 = result[2];
  if ((v5 & 8) != 0)
  {
    do
      unint64_t v4 = *(void *)(v4 + 8);
    while ((*(_WORD *)(v4 + 44) & 8) != 0);
  }
  unint64_t v8 = *(void *)(v4 + 8);
  if (v6 != v8)
  {
    while (1)
    {
      unsigned int v9 = **(unsigned __int16 **)(v6 + 16);
      BOOL v10 = v9 > 0x17;
      int v11 = (1 << v9) & 0x83E000;
      BOOL v12 = v10 || v11 == 0;
      if (v12) {
        break;
      }
      unint64_t v6 = *(void *)(v6 + 8);
      if (v6 == v8)
      {
        unint64_t v6 = v8;
        break;
      }
    }
  }
  uint64_t v13 = result[3];
  uint64_t v14 = *(void *)(v7 + 368);
  uint64_t v15 = *(unsigned int *)(v7 + 384);
  if (!v15) {
    goto LABEL_17;
  }
  LODWORD(v16) = ((v6 >> 4) ^ (v6 >> 9)) & (v15 - 1);
  int v17 = (uint64_t *)(v14 + 16 * v16);
  uint64_t v18 = *v17;
  if (v6 != *v17)
  {
    int v19 = 1;
    while (v18 != -4096)
    {
      int v20 = v16 + v19++;
      uint64_t v16 = v20 & (v15 - 1);
      uint64_t v18 = *(void *)(v14 + 16 * v16);
      if (v6 == v18)
      {
        int v17 = (uint64_t *)(v14 + 16 * v16);
        goto LABEL_18;
      }
    }
LABEL_17:
    int v17 = (uint64_t *)(v14 + 16 * v15);
  }
LABEL_18:
  BOOL v12 = (v3 & 0x40000000) == 0;
  uint64_t v21 = 2;
  if (v12) {
    uint64_t v21 = 4;
  }
  unint64_t v22 = v17[1] & 0xFFFFFFFFFFFFFFF8 | v21;
  if (a2[12])
  {
    uint64_t v23 = a2;
    return (void *)sub_1CC2F6AE4((uint64_t *)&v23, v22, v13, 0);
  }
  else
  {
    uint64_t v23 = a2;
    return (void *)sub_1CC2F6F18(&v23, v22, v13, 0);
  }
}

void llvm::LiveRangeEdit::createEmptyIntervalFrom(void *a1, int a2)
{
  uint64_t v4 = a1[3];
  uint64_t v5 = a2 & 0x7FFFFFFF;
  unint64_t v6 = *(void *)(*(void *)(v4 + 24) + 16 * v5) & 0xFFFFFFFFFFFFFFF8;
  uint64_t IncompleteVirtualRegister = llvm::MachineRegisterInfo::createIncompleteVirtualRegister(v4, (unsigned __int8 *)&unk_1CFB67CFF, 0);
  unint64_t v8 = IncompleteVirtualRegister & 0x7FFFFFFF;
  *(void *)(*(void *)(v4 + 24) + 16 * v8) = v6;
  uint64_t v9 = *(void *)(v4 + 8);
  if (v9) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 24))(v9, IncompleteVirtualRegister);
  }
  uint64_t v10 = a1[5];
  if (v10)
  {
    if (*(_DWORD *)(*(void *)(v10 + 328) + 4 * v5)) {
      int v11 = *(_DWORD *)(*(void *)(v10 + 328) + 4 * v5);
    }
    else {
      int v11 = a2;
    }
    sub_1CC3044E0(v10, IncompleteVirtualRegister, v11);
  }
  uint64_t v12 = a1[4];
  unint64_t v13 = *(unsigned int *)(v12 + 416);
  BOOL v14 = v8 >= v13;
  unint64_t v15 = v8 - v13;
  if (v14) {
    sub_1CB9153B8(v12 + 408, v15 + 1, *(void *)(v12 + 424));
  }
  operator new();
}

double sub_1CC3044E0(uint64_t a1, int a2, int a3)
{
  *(_DWORD *)(*(void *)(a1 + 328) + 4 * (a2 & 0x7FFFFFFF)) = a3;
  *(void *)&double result = sub_1CC2CACD0(a1, a3, v11).n128_u64[0];
  if (*(void *)&v11[0]) {
    BOOL v7 = *((void *)&v11[0] + 1) == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    sub_1CC2CACD0(a1, a3, v11);
    int v10 = a2;
    unint64_t v8 = sub_1CD516808((uint64_t *)(a1 + 352), &v10);
    double result = *(double *)v11;
    long long v9 = v11[1];
    *(_OWORD *)(v8 + 2) = v11[0];
    *(_OWORD *)(v8 + 6) = v9;
  }
  return result;
}

uint64_t llvm::LiveRangeEdit::createFrom(void *a1, int a2)
{
  uint64_t v4 = a1[3];
  uint64_t v5 = a2 & 0x7FFFFFFF;
  unint64_t v6 = *(void *)(*(void *)(v4 + 24) + 16 * v5) & 0xFFFFFFFFFFFFFFF8;
  uint64_t IncompleteVirtualRegister = llvm::MachineRegisterInfo::createIncompleteVirtualRegister(v4, (unsigned __int8 *)&unk_1CFB67CFF, 0);
  *(void *)(*(void *)(v4 + 24) + 16 * (IncompleteVirtualRegister & 0x7FFFFFFF)) = v6;
  uint64_t v8 = *(void *)(v4 + 8);
  if (v8) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 24))(v8, IncompleteVirtualRegister);
  }
  uint64_t v9 = a1[5];
  if (v9)
  {
    if (*(_DWORD *)(*(void *)(v9 + 328) + 4 * v5)) {
      int v10 = *(_DWORD *)(*(void *)(v9 + 328) + 4 * v5);
    }
    else {
      int v10 = a2;
    }
    sub_1CC3044E0(v9, IncompleteVirtualRegister, v10);
  }
  uint64_t v11 = a1[1];
  if (v11 && *(float *)(v11 + 116) == INFINITY) {
    *(_DWORD *)(sub_1CC2F12AC(a1[4], IncompleteVirtualRegister) + 116) = 2139095040;
  }
  return IncompleteVirtualRegister;
}

uint64_t llvm::LiveRangeEdit::checkRematerializable(uint64_t a1, uint64_t a2, const llvm::MachineInstr *a3, llvm::AAResults *a4)
{
  *(unsigned char *)(a1 + 68) = 1;
  uint64_t v6 = *((void *)a3 + 2);
  if (*(_WORD *)v6 == 10) {
    goto LABEL_7;
  }
  if ((*(unsigned char *)(v6 + 11) & 0x20) == 0) {
    return 0;
  }
  uint64_t v9 = *(llvm::TargetInstrInfo **)(a1 + 48);
  if (((*(uint64_t (**)(llvm::TargetInstrInfo *, const llvm::MachineInstr *, llvm::AAResults *))(*(void *)v9 + 32))(v9, a3, a4) & 1) != 0|| (uint64_t result = llvm::TargetInstrInfo::isReallyTriviallyReMaterializableGeneric(v9, a3, a4), result))
  {
LABEL_7:
    uint64_t v11 = *(void *)(a1 + 88);
    uint64_t v12 = *(unsigned int *)(a1 + 100);
    if (v11 == *(void *)(a1 + 80))
    {
      if (v12)
      {
        unint64_t v13 = 0;
        uint64_t v14 = 8 * v12;
        unint64_t v15 = *(void **)(a1 + 88);
        while (*v15 != a2)
        {
          if (*v15 == -2) {
            unint64_t v13 = v15;
          }
          ++v15;
          v14 -= 8;
          if (!v14)
          {
            if (!v13) {
              goto LABEL_15;
            }
            *unint64_t v13 = a2;
            --*(_DWORD *)(a1 + 104);
            return 1;
          }
        }
        return 1;
      }
LABEL_15:
      unsigned int v16 = *(_DWORD *)(a1 + 96);
      if (v12 < v16)
      {
        *(_DWORD *)(a1 + 100) = v12 + 1;
        *(void *)(v11 + 8 * v12) = a2;
        return 1;
      }
    }
    else
    {
      unsigned int v16 = *(_DWORD *)(a1 + 96);
    }
    if (3 * v16 <= 4 * ((int)v12 - *(_DWORD *)(a1 + 104)))
    {
      if (v16 >= 0x40) {
        v16 *= 2;
      }
      else {
        unsigned int v16 = 128;
      }
    }
    else if (v16 - v12 >= v16 >> 3)
    {
      goto LABEL_21;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(a1 + 80), v16);
    unsigned int v16 = *(_DWORD *)(a1 + 96);
    uint64_t v11 = *(void *)(a1 + 88);
LABEL_21:
    unsigned int v17 = v16 - 1;
    unsigned int v18 = (v16 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    int v19 = (void *)(v11 + 8 * v18);
    uint64_t v20 = *v19;
    if (*v19 == -1)
    {
      uint64_t v21 = 0;
LABEL_33:
      if (v21) {
        int v25 = v21;
      }
      else {
        int v25 = v19;
      }
      if (*v25 != a2)
      {
        if (*v25 == -2) {
          --*(_DWORD *)(a1 + 104);
        }
        else {
          ++*(_DWORD *)(a1 + 100);
        }
        *int v25 = a2;
      }
    }
    else
    {
      uint64_t v21 = 0;
      int v22 = 1;
      while (v20 != a2)
      {
        if (v21) {
          BOOL v23 = 0;
        }
        else {
          BOOL v23 = v20 == -2;
        }
        if (v23) {
          uint64_t v21 = v19;
        }
        unsigned int v24 = v18 + v22++;
        unsigned int v18 = v24 & v17;
        int v19 = (void *)(v11 + 8 * (v24 & v17));
        uint64_t v20 = *v19;
        if (*v19 == -1) {
          goto LABEL_33;
        }
      }
    }
    return 1;
  }
  return result;
}

void *llvm::LiveRangeEdit::scanRemattable(void *this, llvm::AAResults *a2)
{
  uint64_t v2 = this;
  uint64_t v3 = this[1];
  uint64_t v4 = *(unsigned int *)(v3 + 72);
  if (v4)
  {
    uint64_t v6 = *(void *)(v3 + 64);
    uint64_t v7 = v6 + 8 * v4;
    while (1)
    {
      unint64_t v8 = *(void *)(*(void *)v6 + 8);
      if (v8 >= 8) {
        break;
      }
LABEL_23:
      v6 += 8;
      if (v6 == v7) {
        goto LABEL_27;
      }
    }
    int v9 = *(_DWORD *)(v2[1] + 112);
    uint64_t v10 = v2[4];
    if (*(_DWORD *)(*(void *)(v2[5] + 328) + 4 * (v9 & 0x7FFFFFFF))) {
      int v11 = *(_DWORD *)(*(void *)(v2[5] + 328) + 4 * (v9 & 0x7FFFFFFF));
    }
    else {
      int v11 = *(_DWORD *)(v2[1] + 112);
    }
    this = (void *)(v10 + 408);
    unint64_t v12 = *(unsigned int *)(v10 + 416);
    BOOL v24 = (v11 & 0x7FFFFFFFu) >= v12;
    unint64_t v13 = (v11 & 0x7FFFFFFF) - v12;
    if (v24)
    {
      sub_1CB9153B8((uint64_t)this, v13 + 1, *(void *)(v10 + 424));
LABEL_29:
      llvm::LiveIntervals::createInterval();
    }
    uint64_t v14 = *(void *)(*this + 8 * (v11 & 0x7FFFFFFF));
    if (!v14) {
      goto LABEL_29;
    }
    unsigned int v15 = *(_DWORD *)(v14 + 8);
    unsigned int v16 = *(void **)v14;
    if (v15)
    {
      uint64_t v17 = v16[3 * v15 - 2];
      unsigned int v18 = *(_DWORD *)((v8 & 0xFFFFFFFFFFFFFFF8) + 24) | (v8 >> 1) & 3;
      unsigned int v19 = (v17 >> 1) & 3 | *(_DWORD *)((v17 & 0xFFFFFFFFFFFFFFF8) + 24);
      uint64_t v20 = *(void **)v14;
      unint64_t v21 = *(unsigned int *)(v14 + 8);
      if (v18 < v19)
      {
        do
        {
          unint64_t v22 = v21 >> 1;
          uint64_t v23 = v20[3 * (v21 >> 1) + 1];
          LODWORD(v23) = (v23 >> 1) & 3 | *(_DWORD *)((v23 & 0xFFFFFFFFFFFFFFF8) + 24);
          v21 -= (v21 >> 1) + 1;
          BOOL v24 = v18 >= v23;
          if (v18 >= v23) {
            unint64_t v25 = v22 + 1;
          }
          else {
            unint64_t v25 = 0;
          }
          v20 += 3 * v25;
          if (!v24) {
            unint64_t v21 = v22;
          }
        }
        while (v21);
        goto LABEL_17;
      }
    }
    else
    {
      unsigned int v15 = 0;
    }
    uint64_t v20 = &v16[3 * v15];
LABEL_17:
    if (v20 != &v16[3 * v15]
      && ((*v20 >> 1) & 3 | *(_DWORD *)((*v20 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)((v8 & 0xFFFFFFFFFFFFFFF8) + 24) | (v8 >> 1) & 3))
    {
      uint64_t v26 = v20[2];
      if (v26)
      {
        unint64_t v27 = *(void *)(v26 + 8);
        if (v27 >= 8)
        {
          int v28 = *(const llvm::MachineInstr **)((v27 & 0xFFFFFFFFFFFFFFF8) + 16);
          if (v28) {
            this = (void *)llvm::LiveRangeEdit::checkRematerializable((uint64_t)v2, v26, v28, a2);
          }
        }
      }
    }
    goto LABEL_23;
  }
LABEL_27:
  *((unsigned char *)v2 + 68) = 1;
  return this;
}

BOOL llvm::LiveRangeEdit::anyRematerializable(llvm::LiveRangeEdit *this, llvm::AAResults *a2)
{
  if (!*((unsigned char *)this + 68)) {
    llvm::LiveRangeEdit::scanRemattable(this, a2);
  }
  return *((_DWORD *)this + 25) != *((_DWORD *)this + 26);
}

uint64_t llvm::LiveRangeEdit::allUsesAvailableAt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(unsigned int *)(a2 + 40);
  if (v4)
  {
    uint64_t v6 = *(unsigned int **)(a2 + 32);
    uint64_t v7 = &v6[8 * v4];
    unint64_t v8 = a3 & 0xFFFFFFFFFFFFFFF8;
    unint64_t v59 = a4 & 0xFFFFFFFFFFFFFFF8;
    if ((*(_DWORD *)((a4 & 0xFFFFFFFFFFFFFFF8) + 24) | (a4 >> 1) & 3) < (*(_DWORD *)((a4 & 0xFFFFFFFFFFFFFFF8) + 24) | 1u)) {
      unsigned int v9 = 1;
    }
    else {
      unsigned int v9 = (a4 >> 1) & 3;
    }
    unsigned int v58 = v9;
    do
    {
      unsigned int v10 = *v6;
      if (*v6) {
        goto LABEL_65;
      }
      unsigned int v11 = v6[1];
      BOOL v12 = (v10 & 0x10FFF00) != 0x1000000 && (v10 & 0x30000000) == 0;
      if (!v12 || v11 == 0) {
        goto LABEL_65;
      }
      if (v11 - 1 <= 0x3FFFFFFE)
      {
        if ((llvm::MachineRegisterInfo::isConstantPhysReg(*(void **)(a1 + 24), v6[1]) & 1) == 0
          && ((*(uint64_t (**)(void, unsigned int *))(**(void **)(a1 + 48) + 24))(*(void *)(a1 + 48), v6) & 1) == 0)
        {
          return 0;
        }
        goto LABEL_65;
      }
      unint64_t v14 = v8;
      uint64_t v15 = *(void *)(a1 + 32);
      unsigned int v16 = (void *)(v15 + 408);
      unint64_t v17 = *(unsigned int *)(v15 + 416);
      BOOL v30 = (v11 & 0x7FFFFFFF) >= v17;
      unint64_t v18 = (v11 & 0x7FFFFFFF) - v17;
      if (v30)
      {
        sub_1CB9153B8((uint64_t)v16, v18 + 1, *(void *)(v15 + 424));
LABEL_68:
        operator new();
      }
      uint64_t v19 = *(void *)(*v16 + 8 * (v11 & 0x7FFFFFFF));
      if (!v19) {
        goto LABEL_68;
      }
      unsigned int v20 = *(_DWORD *)(v19 + 8);
      unint64_t v21 = *(void **)v19;
      if (v20)
      {
        uint64_t v22 = v21[3 * v20 - 2];
        unint64_t v8 = v14;
        unsigned int v23 = *(_DWORD *)(v14 + 24) | 1;
        unsigned int v24 = (v22 >> 1) & 3 | *(_DWORD *)((v22 & 0xFFFFFFFFFFFFFFF8) + 24);
        unint64_t v25 = *(unsigned int *)(v19 + 8);
        uint64_t v26 = *(void **)v19;
        unint64_t v27 = v25;
        if (v23 < v24)
        {
          do
          {
            unint64_t v28 = v27 >> 1;
            uint64_t v29 = v26[3 * (v27 >> 1) + 1];
            LODWORD(v29) = (v29 >> 1) & 3 | *(_DWORD *)((v29 & 0xFFFFFFFFFFFFFFF8) + 24);
            v27 -= (v27 >> 1) + 1;
            BOOL v30 = v23 >= v29;
            if (v23 >= v29) {
              unint64_t v31 = v28 + 1;
            }
            else {
              unint64_t v31 = 0;
            }
            v26 += 3 * v31;
            if (!v30) {
              unint64_t v27 = v28;
            }
          }
          while (v27);
          unint64_t v25 = *(unsigned int *)(v19 + 8);
          goto LABEL_31;
        }
      }
      else
      {
        unint64_t v25 = 0;
        unint64_t v8 = v14;
      }
      uint64_t v26 = &v21[3 * v25];
LABEL_31:
      uint64_t v32 = &v21[3 * v25];
      if (v26 != v32
        && ((*v26 >> 1) & 3 | *(_DWORD *)((*v26 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)(v8 + 24) | 1u))
      {
        uint64_t v33 = v26[2];
        if (v33)
        {
          uint64_t result = 0;
          if (v8 == v59 || !v20) {
            return result;
          }
          unsigned int v35 = *(_DWORD *)(v59 + 24) | v58;
          if (v35 >= ((*(v32 - 2) >> 1) & 3 | *(_DWORD *)((*(v32 - 2) & 0xFFFFFFFFFFFFFFF8) + 24))) {
            return 0;
          }
          do
          {
            unint64_t v36 = v25 >> 1;
            uint64_t v37 = v21[3 * (v25 >> 1) + 1];
            LODWORD(v37) = (v37 >> 1) & 3 | *(_DWORD *)((v37 & 0xFFFFFFFFFFFFFFF8) + 24);
            v25 -= (v25 >> 1) + 1;
            BOOL v38 = v35 >= v37;
            if (v35 >= v37) {
              unint64_t v39 = v36 + 1;
            }
            else {
              unint64_t v39 = 0;
            }
            v21 += 3 * v39;
            if (!v38) {
              unint64_t v25 = v36;
            }
          }
          while (v25);
          if (v21 == v32
            || ((*v21 >> 1) & 3 | *(_DWORD *)((*v21 & 0xFFFFFFFFFFFFFFF8) + 24)) > (*(_DWORD *)(v59 + 24) | v58)
            || v33 != v21[2])
          {
            return 0;
          }
          if ((*v6 & 0xFFF00) != 0)
          {
            uint64_t v40 = *(void *)(**(void **)(a1 + 24) + 16);
            uint64_t v41 = (*(uint64_t (**)(uint64_t))(*(void *)v40 + 176))(v40);
            uint64_t v42 = *(void *)(v19 + 104);
            if (v42)
            {
              uint64_t v43 = *(void *)(*(void *)(v41 + 232) + 8 * (((unint64_t)*v6 >> 8) & 0xFFF));
              while (2)
              {
                uint64_t v44 = *(void *)(v42 + 112);
                if ((v44 & v43) == 0) {
                  goto LABEL_64;
                }
                unsigned int v45 = *(_DWORD *)(v42 + 8);
                int v46 = *(void **)v42;
                if (v45)
                {
                  uint64_t v47 = v46[3 * v45 - 2];
                  unint64_t v48 = v59;
                  unsigned int v49 = v58;
                  unsigned int v50 = *(_DWORD *)(v59 + 24) | v58;
                  unsigned int v51 = (v47 >> 1) & 3 | *(_DWORD *)((v47 & 0xFFFFFFFFFFFFFFF8) + 24);
                  int v52 = *(void **)v42;
                  unint64_t v53 = *(unsigned int *)(v42 + 8);
                  if (v50 < v51)
                  {
                    do
                    {
                      unint64_t v54 = v53 >> 1;
                      uint64_t v55 = v52[3 * (v53 >> 1) + 1];
                      LODWORD(v55) = (v55 >> 1) & 3 | *(_DWORD *)((v55 & 0xFFFFFFFFFFFFFFF8) + 24);
                      v53 -= (v53 >> 1) + 1;
                      BOOL v56 = v50 >= v55;
                      if (v50 >= v55) {
                        unint64_t v57 = v54 + 1;
                      }
                      else {
                        unint64_t v57 = 0;
                      }
                      v52 += 3 * v57;
                      if (!v56) {
                        unint64_t v53 = v54;
                      }
                    }
                    while (v53);
LABEL_61:
                    if (v52 == &v46[3 * v45]
                      || ((*v52 >> 1) & 3 | *(_DWORD *)((*v52 & 0xFFFFFFFFFFFFFFF8) + 24)) > (*(_DWORD *)(v48 + 24) | v49))
                    {
                      return 0;
                    }
                    v43 &= ~v44;
                    if (!v43) {
                      goto LABEL_65;
                    }
LABEL_64:
                    uint64_t v42 = *(void *)(v42 + 104);
                    if (!v42) {
                      goto LABEL_65;
                    }
                    continue;
                  }
                }
                else
                {
                  unsigned int v45 = 0;
                  unint64_t v48 = v59;
                  unsigned int v49 = v58;
                }
                break;
              }
              int v52 = &v46[3 * v45];
              goto LABEL_61;
            }
          }
        }
      }
LABEL_65:
      v6 += 8;
    }
    while (v6 != v7);
  }
  return 1;
}

uint64_t llvm::LiveRangeEdit::canRematerializeAt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v9 = *(void *)(a1 + 80);
  uint64_t v8 = *(void *)(a1 + 88);
  if (v8 == v9)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 100);
    unsigned int v11 = (void *)(v8 + 8 * v10);
    if (v10)
    {
      uint64_t v12 = 0;
      uint64_t v13 = 8 * v10;
      while (*(void *)(v8 + v12) != a3)
      {
        v12 += 8;
        if (v13 == v12) {
          goto LABEL_6;
        }
      }
      unsigned int v11 = (void *)(v8 + v12);
    }
LABEL_6:
    uint64_t v9 = *(void *)(a1 + 88);
  }
  else
  {
    uint64_t v16 = *(unsigned int *)(a1 + 96);
    int v17 = v16 - 1;
    unsigned int v18 = (v16 - 1) & ((a3 >> 4) ^ (a3 >> 9));
    unsigned int v11 = (void *)(v8 + 8 * v18);
    uint64_t v19 = *v11;
    if (*v11 == -1)
    {
      unsigned int v20 = 0;
LABEL_40:
      if (v20) {
        unsigned int v11 = v20;
      }
      if (*v11 != a3) {
        unsigned int v11 = (void *)(v8 + 8 * v16);
      }
    }
    else
    {
      unsigned int v20 = 0;
      int v21 = 1;
      while (v19 != a3)
      {
        if (v20) {
          BOOL v22 = 0;
        }
        else {
          BOOL v22 = v19 == -2;
        }
        if (v22) {
          unsigned int v20 = v11;
        }
        unsigned int v23 = v18 + v21++;
        unsigned int v18 = v23 & v17;
        unsigned int v11 = (void *)(v8 + 8 * (v23 & v17));
        uint64_t v19 = *v11;
        if (*v11 == -1) {
          goto LABEL_40;
        }
      }
    }
  }
  BOOL v22 = v8 == v9;
  uint64_t v14 = 96;
  if (v22) {
    uint64_t v14 = 100;
  }
  if (v11 == (void *)(v8 + 8 * *(unsigned int *)(a1 + v14))) {
    return 0;
  }
  uint64_t v24 = *(void *)(a2 + 8);
  __int16 v25 = *(_WORD *)(v24 + 44);
  unint64_t v26 = *(void *)(a2 + 8);
  if ((v25 & 4) != 0)
  {
    unint64_t v26 = *(void *)(a2 + 8);
    do
      unint64_t v26 = *(void *)v26 & 0xFFFFFFFFFFFFFFF8;
    while ((*(_WORD *)(v26 + 44) & 4) != 0);
  }
  uint64_t v27 = *(void *)(*(void *)(a1 + 32) + 288);
  uint64_t v28 = *(void *)(a2 + 8);
  if ((v25 & 8) != 0)
  {
    uint64_t v28 = *(void *)(a2 + 8);
    do
      uint64_t v28 = *(void *)(v28 + 8);
    while ((*(_WORD *)(v28 + 44) & 8) != 0);
  }
  unint64_t v29 = *(void *)(v28 + 8);
  if (v26 != v29)
  {
    while (1)
    {
      unsigned int v30 = **(unsigned __int16 **)(v26 + 16);
      BOOL v31 = v30 > 0x17;
      int v32 = (1 << v30) & 0x83E000;
      if (v31 || v32 == 0) {
        break;
      }
      unint64_t v26 = *(void *)(v26 + 8);
      if (v26 == v29)
      {
        unint64_t v26 = v29;
        break;
      }
    }
  }
  uint64_t v34 = *(void *)(v27 + 368);
  uint64_t v35 = *(unsigned int *)(v27 + 384);
  if (v35)
  {
    LODWORD(v36) = ((v26 >> 4) ^ (v26 >> 9)) & (v35 - 1);
    uint64_t v37 = (uint64_t *)(v34 + 16 * v36);
    uint64_t v38 = *v37;
    if (v26 == *v37) {
      goto LABEL_33;
    }
    int v40 = 1;
    while (v38 != -4096)
    {
      int v41 = v36 + v40++;
      uint64_t v36 = v41 & (v35 - 1);
      uint64_t v38 = *(void *)(v34 + 16 * v36);
      if (v26 == v38)
      {
        uint64_t v37 = (uint64_t *)(v34 + 16 * v36);
        goto LABEL_33;
      }
    }
  }
  uint64_t v37 = (uint64_t *)(v34 + 16 * v35);
LABEL_33:
  uint64_t v39 = v37[1];
  if (a5)
  {
    if (!(*(unsigned int (**)(void))(**(void **)(a1 + 48) + 152))(*(void *)(a1 + 48))) {
      return 0;
    }
    uint64_t v24 = *(void *)(a2 + 8);
  }

  return llvm::LiveRangeEdit::allUsesAvailableAt(a1, v24, v39, a4);
}

unint64_t llvm::LiveRangeEdit::rematerializeAt(uint64_t a1, uint64_t a2, void *a3, unsigned int a4, uint64_t *a5, uint64_t a6, int a7)
{
  (*(void (**)(void, uint64_t, void *, void, void, uint64_t, uint64_t))(**(void **)(a1 + 48) + 176))(*(void *)(a1 + 48), a2, a3, a4, 0, a5[1], a6);
  unint64_t v11 = *a3 & 0xFFFFFFFFFFFFFFF8;
  if (!v11 || (*(unsigned char *)v11 & 4) == 0)
  {
    while ((*(_WORD *)(v11 + 44) & 4) != 0)
      unint64_t v11 = *(void *)v11 & 0xFFFFFFFFFFFFFFF8;
  }
  **(_DWORD **)(v11 + 32) &= ~0x4000000u;
  uint64_t v12 = *(void *)(a1 + 152);
  uint64_t v13 = *a5;
  uint64_t v14 = *(unsigned int *)(a1 + 164);
  if (v12 != *(void *)(a1 + 144))
  {
    unsigned int v18 = *(_DWORD *)(a1 + 160);
    goto LABEL_16;
  }
  if (!v14)
  {
LABEL_12:
    unsigned int v18 = *(_DWORD *)(a1 + 160);
    if (v14 < v18)
    {
      *(_DWORD *)(a1 + 164) = v14 + 1;
      *(void *)(v12 + 8 * v14) = v13;
      return sub_1CB914C88(*(void *)(*(void *)(a1 + 32) + 288), v11, a7) & 0xFFFFFFFFFFFFFFF8 | 4;
    }
LABEL_16:
    if (3 * v18 <= 4 * ((int)v14 - *(_DWORD *)(a1 + 168)))
    {
      if (v18 >= 0x40) {
        v18 *= 2;
      }
      else {
        unsigned int v18 = 128;
      }
    }
    else if (v18 - v14 >= v18 >> 3)
    {
      goto LABEL_18;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(a1 + 144), v18);
    unsigned int v18 = *(_DWORD *)(a1 + 160);
    uint64_t v12 = *(void *)(a1 + 152);
LABEL_18:
    unsigned int v20 = v18 - 1;
    unsigned int v21 = (v18 - 1) & ((v13 >> 4) ^ (v13 >> 9));
    BOOL v22 = (void *)(v12 + 8 * v21);
    uint64_t v23 = *v22;
    if (*v22 == -1)
    {
      uint64_t v24 = 0;
LABEL_30:
      if (v24) {
        uint64_t v28 = v24;
      }
      else {
        uint64_t v28 = v22;
      }
      if (*v28 != v13)
      {
        if (*v28 == -2) {
          --*(_DWORD *)(a1 + 168);
        }
        else {
          ++*(_DWORD *)(a1 + 164);
        }
        *uint64_t v28 = v13;
      }
    }
    else
    {
      uint64_t v24 = 0;
      int v25 = 1;
      while (v23 != v13)
      {
        if (v24) {
          BOOL v26 = 0;
        }
        else {
          BOOL v26 = v23 == -2;
        }
        if (v26) {
          uint64_t v24 = v22;
        }
        unsigned int v27 = v21 + v25++;
        unsigned int v21 = v27 & v20;
        BOOL v22 = (void *)(v12 + 8 * (v27 & v20));
        uint64_t v23 = *v22;
        if (*v22 == -1) {
          goto LABEL_30;
        }
      }
    }
    return sub_1CB914C88(*(void *)(*(void *)(a1 + 32) + 288), v11, a7) & 0xFFFFFFFFFFFFFFF8 | 4;
  }
  uint64_t v15 = 0;
  uint64_t v16 = 8 * v14;
  int v17 = *(void **)(a1 + 152);
  while (*v17 != v13)
  {
    if (*v17 == -2) {
      uint64_t v15 = v17;
    }
    ++v17;
    v16 -= 8;
    if (!v16)
    {
      if (!v15) {
        goto LABEL_12;
      }
      void *v15 = v13;
      --*(_DWORD *)(a1 + 168);
      return sub_1CB914C88(*(void *)(*(void *)(a1 + 32) + 288), v11, a7) & 0xFFFFFFFFFFFFFFF8 | 4;
    }
  }
  return sub_1CB914C88(*(void *)(*(void *)(a1 + 32) + 288), v11, a7) & 0xFFFFFFFFFFFFFFF8 | 4;
}

uint64_t llvm::LiveRangeEdit::eraseVirtReg(uint64_t a1, unsigned int a2)
{
  uint64_t result = *(void *)(a1 + 56);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)result + 32))(result, a2);
    if (result)
    {
      uint64_t v5 = *(void *)(a1 + 32);
      uint64_t v6 = a2 & 0x7FFFFFFF;
      uint64_t v7 = *(void *)(v5 + 408);
      uint64_t v8 = *(void *)(v7 + 8 * v6);
      if (v8)
      {
        uint64_t v9 = *(void *)(v8 + 104);
        if (v9)
        {
          do
          {
            uint64_t v13 = *(void *)(v9 + 96);
            uint64_t v12 = *(void *)(v9 + 104);
            *(void *)(v9 + 96) = 0;
            if (v13)
            {
              uint64_t v17 = v9;
              uint64_t v19 = v12;
              sub_1CB833A08(v13, *(void **)(v13 + 8));
              MEMORY[0x1D25D9CE0](v13, 0x1020C4062D53EE8);
              uint64_t v9 = v17;
              uint64_t v12 = v19;
            }
            uint64_t v14 = *(void **)(v9 + 64);
            if (v14 != (void *)(v9 + 80))
            {
              uint64_t v18 = v12;
              uint64_t v16 = v9;
              free(v14);
              uint64_t v9 = v16;
              uint64_t v12 = v18;
            }
            if (*(void *)v9 != v9 + 16)
            {
              uint64_t v15 = v12;
              free(*(void **)v9);
              uint64_t v12 = v15;
            }
            uint64_t v9 = v12;
          }
          while (v12);
        }
        uint64_t v10 = *(void *)(v8 + 96);
        *(void *)(v8 + 96) = 0;
        *(void *)(v8 + 104) = 0;
        if (v10)
        {
          sub_1CB833A08(v10, *(void **)(v10 + 8));
          MEMORY[0x1D25D9CE0](v10, 0x1020C4062D53EE8);
        }
        unint64_t v11 = *(void **)(v8 + 64);
        if (v11 != (void *)(v8 + 80)) {
          free(v11);
        }
        if (*(void *)v8 != v8 + 16) {
          free(*(void **)v8);
        }
        uint64_t result = MEMORY[0x1D25D9CE0](v8, 0x10A0C408DA535C6);
        uint64_t v7 = *(void *)(v5 + 408);
      }
      *(void *)(v7 + 8 * v6) = 0;
    }
  }
  return result;
}

uint64_t llvm::LiveRangeEdit::foldAsLoad(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v63[4] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 24);
  uint64_t v7 = *(unsigned int *)(a2 + 112);
  if ((v7 & 0x80000000) != 0) {
    uint64_t v8 = (int **)(*(void *)(v6 + 24) + 16 * (v7 & 0x7FFFFFFF) + 8);
  }
  else {
    uint64_t v8 = (int **)(*(void *)(v6 + 272) + 8 * v7);
  }
  uint64_t v9 = *v8;
  if (!v9) {
    return 0;
  }
  while (1)
  {
    int v10 = *v9;
    if ((*v9 & 0x80000000) == 0) {
      break;
    }
    uint64_t v9 = (int *)*((void *)v9 + 3);
    if (!v9) {
      return 0;
    }
  }
  uint64_t v11 = 0;
  uint64_t v12 = 0;
LABEL_9:
  uint64_t v13 = *((void *)v9 + 1);
  if ((v10 & 0x1000000) != 0)
  {
    if ((!v11 || v11 == v13) && (*(unsigned char *)(*(void *)(v13 + 16) + 10) & 4) != 0) {
      goto LABEL_24;
    }
    return 0;
  }
  if ((v10 & 0x10000000) != 0)
  {
    uint64_t v13 = v11;
    goto LABEL_24;
  }
  BOOL v14 = v12 == v13 || v12 == 0;
  int v15 = v10 & 0xFFF00;
  BOOL v16 = v14 && v15 == 0;
  uint64_t v12 = *((void *)v9 + 1);
  uint64_t v13 = v11;
  if (!v16) {
    return 0;
  }
LABEL_24:
  while (1)
  {
    uint64_t v9 = (int *)*((void *)v9 + 3);
    if (!v9) {
      break;
    }
    int v10 = *v9;
    if ((*v9 & 0x80000000) == 0)
    {
      uint64_t v11 = v13;
      goto LABEL_9;
    }
  }
  uint64_t v17 = 0;
  if (v13 && v12)
  {
    __int16 v18 = *(_WORD *)(v13 + 44);
    unint64_t v19 = v13;
    if ((v18 & 4) != 0)
    {
      unint64_t v19 = v13;
      do
        unint64_t v19 = *(void *)v19 & 0xFFFFFFFFFFFFFFF8;
      while ((*(_WORD *)(v19 + 44) & 4) != 0);
    }
    uint64_t v20 = *(void *)(*(void *)(a1 + 32) + 288);
    uint64_t v21 = v13;
    if ((v18 & 8) != 0)
    {
      uint64_t v21 = v13;
      do
        uint64_t v21 = *(void *)(v21 + 8);
      while ((*(_WORD *)(v21 + 44) & 8) != 0);
    }
    uint64_t v22 = *(void *)(v21 + 8);
    if (v19 != v22)
    {
      while (1)
      {
        unsigned int v23 = **(unsigned __int16 **)(v19 + 16);
        BOOL v24 = v23 > 0x17;
        int v25 = (1 << v23) & 0x83E000;
        if (v24 || v25 == 0) {
          break;
        }
        unint64_t v19 = *(void *)(v19 + 8);
        if (v19 == v22)
        {
          unint64_t v19 = *(void *)(v21 + 8);
          break;
        }
      }
    }
    uint64_t v27 = *(void *)(v20 + 368);
    uint64_t v28 = *(unsigned int *)(v20 + 384);
    if (v28)
    {
      LODWORD(v29) = ((v19 >> 4) ^ (v19 >> 9)) & (v28 - 1);
      unsigned int v30 = (uint64_t *)(v27 + 16 * v29);
      uint64_t v31 = *v30;
      if (v19 == *v30) {
        goto LABEL_45;
      }
      int v32 = 1;
      while (v31 != -4096)
      {
        int v33 = v29 + v32++;
        uint64_t v29 = v33 & (v28 - 1);
        uint64_t v31 = *(void *)(v27 + 16 * v29);
        if (v19 == v31)
        {
          unsigned int v30 = (uint64_t *)(v27 + 16 * v29);
          goto LABEL_45;
        }
      }
    }
    unsigned int v30 = (uint64_t *)(v27 + 16 * v28);
LABEL_45:
    __int16 v34 = *(_WORD *)(v12 + 44);
    unint64_t v35 = v12;
    if ((v34 & 4) != 0)
    {
      unint64_t v35 = v12;
      do
        unint64_t v35 = *(void *)v35 & 0xFFFFFFFFFFFFFFF8;
      while ((*(_WORD *)(v35 + 44) & 4) != 0);
    }
    uint64_t v36 = v12;
    if ((v34 & 8) != 0)
    {
      uint64_t v36 = v12;
      do
        uint64_t v36 = *(void *)(v36 + 8);
      while ((*(_WORD *)(v36 + 44) & 8) != 0);
    }
    uint64_t v37 = v30[1];
    uint64_t v38 = *(void *)(v36 + 8);
    if (v35 != v38)
    {
      while (1)
      {
        unsigned int v39 = **(unsigned __int16 **)(v35 + 16);
        BOOL v24 = v39 > 0x17;
        int v40 = (1 << v39) & 0x83E000;
        if (v24 || v40 == 0) {
          break;
        }
        unint64_t v35 = *(void *)(v35 + 8);
        if (v35 == v38)
        {
          unint64_t v35 = *(void *)(v36 + 8);
          break;
        }
      }
    }
    if (v28)
    {
      LODWORD(v42) = ((v35 >> 4) ^ (v35 >> 9)) & (v28 - 1);
      uint64_t v43 = (uint64_t *)(v27 + 16 * v42);
      uint64_t v44 = *v43;
      if (v35 == *v43) {
        goto LABEL_61;
      }
      int v45 = 1;
      while (v44 != -4096)
      {
        int v46 = v42 + v45++;
        uint64_t v42 = v46 & (v28 - 1);
        uint64_t v44 = *(void *)(v27 + 16 * v42);
        if (v35 == v44)
        {
          uint64_t v43 = (uint64_t *)(v27 + 16 * v42);
          goto LABEL_61;
        }
      }
    }
    uint64_t v43 = (uint64_t *)(v27 + 16 * v28);
LABEL_61:
    if (!llvm::LiveRangeEdit::allUsesAvailableAt(a1, v13, v37, v43[1])) {
      return 0;
    }
    BOOL v60 = 1;
    if (!llvm::MachineInstr::isSafeToMove((llvm::MachineInstr *)v13, 0, &v60)) {
      return 0;
    }
    unint64_t v61 = v63;
    uint64_t v62 = 0x800000000;
    uint64_t v47 = *(unsigned int *)(v12 + 40);
    if (v47)
    {
      uint64_t v48 = 0;
      int v49 = 0;
      unsigned int v50 = 0;
      int v51 = 0;
      char v52 = 0;
      int v53 = *(_DWORD *)(a2 + 112);
      uint64_t v54 = 32 * v47;
      do
      {
        uint64_t v55 = *(void *)(v12 + 32);
        if (!*(unsigned char *)(v55 + v48) && *(_DWORD *)(v55 + v48 + 4) == v53)
        {
          if (v50 >= HIDWORD(v62)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((_DWORD *)v61 + v50) = v49;
          unsigned int v50 = v62 + 1;
          LODWORD(v62) = v62 + 1;
          unsigned int v56 = *(_DWORD *)(v55 + v48);
          if ((v56 & 0x1000000) != 0)
          {
            BOOL v14 = (v56 & 0xFFF00) == 0;
            int v57 = (v56 >> 28) & 1;
            if (v14) {
              int v57 = 1;
            }
            v52 |= v57;
            v51 |= v57 ^ 1;
          }
        }
        ++v49;
        v48 += 32;
      }
      while (v54 != v48);
    }
    else
    {
      unsigned int v50 = 0;
      LOBYTE(v51) = 0;
      char v52 = 0;
    }
    uint64_t v17 = 0;
    if ((v51 & 1) == 0 && (v52 & 1) == 0)
    {
      uint64_t v17 = llvm::TargetInstrInfo::foldMemoryOperand(*(void **)(a1 + 48), (uint64_t *)v12, (__int32 *)v61, v50, v13, *(void *)(a1 + 32));
      if (v17)
      {
        sub_1CBB16C94(*(int32x2_t **)(*(void *)(a1 + 32) + 288), v12, v17);
        if (llvm::MachineInstr::shouldUpdateCallSiteInfo((llvm::MachineInstr *)v12)) {
          llvm::MachineFunction::moveCallSiteInfo(*(llvm::MachineFunction **)(*(void *)(v12 + 24) + 32), (const llvm::MachineInstr *)v12, (const llvm::MachineInstr *)v17);
        }
        llvm::MachineInstr::eraseFromParent((llvm::MachineInstr *)v12);
        llvm::MachineInstr::addRegisterDead((llvm::MachineInstr *)v13, *(_DWORD *)(a2 + 112), 0, 0);
        unsigned int v59 = *(_DWORD *)(a3 + 8);
        if (v59 >= *(_DWORD *)(a3 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a3 + 8 * v59) = v13;
        ++*(_DWORD *)(a3 + 8);
        uint64_t v17 = 1;
      }
    }
    if (v61 != v63) {
      free(v61);
    }
  }
  return v17;
}

uint64_t llvm::LiveRangeEdit::useIsKill(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  unint64_t v5 = *((void *)a3 + 1);
  __int16 v6 = *(_WORD *)(v5 + 44);
  unint64_t v7 = v5;
  if ((v6 & 4) != 0)
  {
    unint64_t v7 = *((void *)a3 + 1);
    do
      unint64_t v7 = *(void *)v7 & 0xFFFFFFFFFFFFFFF8;
    while ((*(_WORD *)(v7 + 44) & 4) != 0);
  }
  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 288);
  if ((v6 & 8) != 0)
  {
    do
      unint64_t v5 = *(void *)(v5 + 8);
    while ((*(_WORD *)(v5 + 44) & 8) != 0);
  }
  unint64_t v9 = *(void *)(v5 + 8);
  if (v7 != v9)
  {
    while (1)
    {
      unsigned int v10 = **(unsigned __int16 **)(v7 + 16);
      BOOL v11 = v10 > 0x17;
      int v12 = (1 << v10) & 0x83E000;
      if (v11 || v12 == 0) {
        break;
      }
      unint64_t v7 = *(void *)(v7 + 8);
      if (v7 == v9)
      {
        unint64_t v7 = v9;
        break;
      }
    }
  }
  uint64_t v14 = *(void *)(v8 + 368);
  uint64_t v15 = *(unsigned int *)(v8 + 384);
  if (v15)
  {
    LODWORD(v16) = ((v7 >> 4) ^ (v7 >> 9)) & (v15 - 1);
    uint64_t v17 = (uint64_t *)(v14 + 16 * v16);
    uint64_t v18 = *v17;
    if (v7 == *v17) {
      goto LABEL_11;
    }
    int v34 = 1;
    while (v18 != -4096)
    {
      int v35 = v16 + v34++;
      uint64_t v16 = v35 & (v15 - 1);
      uint64_t v18 = *(void *)(v14 + 16 * v16);
      if (v7 == v18)
      {
        uint64_t v17 = (uint64_t *)(v14 + 16 * v16);
        goto LABEL_11;
      }
    }
  }
  uint64_t v17 = (uint64_t *)(v14 + 16 * v15);
LABEL_11:
  unint64_t v19 = v17[1] & 0xFFFFFFFFFFFFFFF8;
  unsigned int v20 = *(_DWORD *)(a2 + 8);
  uint64_t v21 = *(void **)a2;
  if (!v20)
  {
    unsigned int v20 = 0;
    goto LABEL_49;
  }
  uint64_t v22 = v21[3 * v20 - 2];
  unsigned int v23 = *(_DWORD *)(v19 + 24);
  if (v23 >= ((v22 >> 1) & 3 | *(_DWORD *)((v22 & 0xFFFFFFFFFFFFFFF8) + 24)))
  {
LABEL_49:
    BOOL v24 = &v21[3 * v20];
    goto LABEL_20;
  }
  BOOL v24 = *(void **)a2;
  unint64_t v25 = *(unsigned int *)(a2 + 8);
  do
  {
    unint64_t v26 = v25 >> 1;
    uint64_t v27 = v24[3 * (v25 >> 1) + 1];
    LODWORD(v27) = (v27 >> 1) & 3 | *(_DWORD *)((v27 & 0xFFFFFFFFFFFFFFF8) + 24);
    v25 -= (v25 >> 1) + 1;
    BOOL v28 = v23 >= v27;
    if (v23 >= v27) {
      unint64_t v29 = v26 + 1;
    }
    else {
      unint64_t v29 = 0;
    }
    v24 += 3 * v29;
    if (!v28) {
      unint64_t v25 = v26;
    }
  }
  while (v25);
LABEL_20:
  if (v24 == &v21[3 * v20]
    || ((*v24 >> 1) & 3 | *(_DWORD *)((*v24 & 0xFFFFFFFFFFFFFFF8) + 24)) > *(_DWORD *)(v19 + 24)
    || v19 != (v24[1] & 0xFFFFFFFFFFFFFFF8))
  {
    uint64_t v30 = *(void *)(**(void **)(a1 + 24) + 16);
    uint64_t v31 = (*(uint64_t (**)(uint64_t))(*(void *)v30 + 176))(v30);
    uint64_t v32 = *(void *)(a2 + 104);
    if (!v32) {
      return 0;
    }
    uint64_t v36 = *(void *)(*(void *)(v31 + 232) + 8 * (((unint64_t)*a3 >> 8) & 0xFFF));
    while (1)
    {
      if ((*(void *)(v32 + 112) & v36) == 0) {
        goto LABEL_42;
      }
      unsigned int v37 = *(_DWORD *)(v32 + 8);
      uint64_t v38 = *(void **)v32;
      if (!v37) {
        break;
      }
      uint64_t v39 = v38[3 * v37 - 2];
      unsigned int v40 = *(_DWORD *)(v19 + 24);
      unsigned int v41 = (v39 >> 1) & 3 | *(_DWORD *)((v39 & 0xFFFFFFFFFFFFFFF8) + 24);
      uint64_t v42 = *(void **)v32;
      unint64_t v43 = *(unsigned int *)(v32 + 8);
      if (v40 >= v41) {
        goto LABEL_44;
      }
      do
      {
        unint64_t v44 = v43 >> 1;
        uint64_t v45 = v42[3 * (v43 >> 1) + 1];
        LODWORD(v45) = (v45 >> 1) & 3 | *(_DWORD *)((v45 & 0xFFFFFFFFFFFFFFF8) + 24);
        v43 -= (v43 >> 1) + 1;
        BOOL v46 = v40 >= v45;
        if (v40 >= v45) {
          unint64_t v47 = v44 + 1;
        }
        else {
          unint64_t v47 = 0;
        }
        v42 += 3 * v47;
        if (!v46) {
          unint64_t v43 = v44;
        }
      }
      while (v43);
LABEL_39:
      if (v42 != &v38[3 * v37]
        && ((*v42 >> 1) & 3 | *(_DWORD *)((*v42 & 0xFFFFFFFFFFFFFFF8) + 24)) <= *(_DWORD *)(v19 + 24)
        && v19 == (v42[1] & 0xFFFFFFFFFFFFFFF8))
      {
        return 1;
      }
LABEL_42:
      uint64_t result = 0;
      uint64_t v32 = *(void *)(v32 + 104);
      if (!v32) {
        return result;
      }
    }
    unsigned int v37 = 0;
LABEL_44:
    uint64_t v42 = &v38[3 * v37];
    goto LABEL_39;
  }
  return 1;
}

void llvm::LiveRangeEdit::eliminateDeadDef(void *a1, llvm::MachineInstr *this, uint64_t *a3, llvm::AAResults *a4)
{
  v164[4] = *MEMORY[0x1E4F143B8];
  __int16 v8 = *((_WORD *)this + 22);
  unint64_t v9 = this;
  if ((v8 & 4) != 0)
  {
    unint64_t v9 = this;
    do
      unint64_t v9 = (llvm::MachineInstr *)(*(void *)v9 & 0xFFFFFFFFFFFFFFF8);
    while ((*((_WORD *)v9 + 22) & 4) != 0);
  }
  uint64_t v10 = *(void *)(a1[4] + 288);
  BOOL v11 = this;
  if ((v8 & 8) != 0)
  {
    BOOL v11 = this;
    do
      BOOL v11 = (llvm::MachineInstr *)*((void *)v11 + 1);
    while ((*((_WORD *)v11 + 22) & 8) != 0);
  }
  int v12 = (llvm::MachineInstr *)*((void *)v11 + 1);
  if (v9 != v12)
  {
    while (1)
    {
      unsigned int v13 = **((unsigned __int16 **)v9 + 2);
      BOOL v14 = v13 > 0x17;
      int v15 = (1 << v13) & 0x83E000;
      if (v14 || v15 == 0) {
        break;
      }
      unint64_t v9 = (llvm::MachineInstr *)*((void *)v9 + 1);
      if (v9 == v12)
      {
        unint64_t v9 = v12;
        break;
      }
    }
  }
  uint64_t v17 = *(void *)(v10 + 368);
  uint64_t v18 = *(unsigned int *)(v10 + 384);
  if (!v18) {
    goto LABEL_16;
  }
  LODWORD(v19) = ((v9 >> 4) ^ (v9 >> 9)) & (v18 - 1);
  unsigned int v20 = (llvm::MachineInstr **)(v17 + 16 * v19);
  uint64_t v21 = *v20;
  if (v9 != *v20)
  {
    int v22 = 1;
    while (v21 != (llvm::MachineInstr *)-4096)
    {
      int v23 = v19 + v22++;
      uint64_t v19 = v23 & (v18 - 1);
      uint64_t v21 = *(llvm::MachineInstr **)(v17 + 16 * v19);
      if (v9 == v21)
      {
        unsigned int v20 = (llvm::MachineInstr **)(v17 + 16 * v19);
        goto LABEL_17;
      }
    }
LABEL_16:
    unsigned int v20 = (llvm::MachineInstr **)(v17 + 16 * v18);
  }
LABEL_17:
  if ((v8 & 0xC) != 0) {
    return;
  }
  if (**((unsigned __int16 **)this + 2) - 1 < 2) {
    return;
  }
  BOOL v24 = v20[1];
  BOOL v161 = 0;
  if (!llvm::MachineInstr::isSafeToMove(this, 0, &v161)) {
    return;
  }
  unint64_t v158 = (unint64_t)v24 & 0xFFFFFFFFFFFFFFF8;
  unint64_t v26 = (unint64_t)v24 & 0xFFFFFFFFFFFFFFF8 | 4;
  v162 = v164;
  uint64_t v163 = 0x800000000;
  uint64_t v27 = a1[5];
  if (!v27
    || (BOOL v28 = (_DWORD *)*((void *)this + 4), (*v28 & 0x10000FF) != 0x1000000)
    || *(unsigned char *)(*((void *)this + 2) + 4) != 1)
  {
    int v155 = 0;
LABEL_39:
    BOOL v157 = 0;
    goto LABEL_40;
  }
  unint64_t v29 = (unint64_t)v24 & 0xFFFFFFFFFFFFFFF8 | 4;
  int v30 = *(_DWORD *)(*(void *)(v27 + 328) + 4 * (v28[1] & 0x7FFFFFFF));
  int v155 = v28[1];
  if (v30) {
    int v31 = v30;
  }
  else {
    int v31 = v28[1];
  }
  uint64_t v32 = a1[4];
  uint64_t v33 = v31 & 0x7FFFFFFF;
  int v34 = (void *)(v32 + 408);
  uint64_t v35 = *(unsigned int *)(v32 + 416);
  if (v33 >= v35)
  {
    sub_1CB9153B8((uint64_t)v34, v33 - v35 + 1, *(void *)(v32 + 424));
LABEL_271:
    operator new();
  }
  uint64_t v36 = *(void *)(*v34 + 8 * v33);
  if (!v36) {
    goto LABEL_271;
  }
  unsigned int v37 = *(_DWORD *)(v36 + 8);
  uint64_t v38 = *(void **)v36;
  if (!v37)
  {
    unsigned int v37 = 0;
    unint64_t v26 = v29;
    goto LABEL_259;
  }
  uint64_t v39 = v38[3 * v37 - 2];
  unsigned int v40 = *(_DWORD *)(v158 + 24) | 2;
  unint64_t v26 = v29;
  if (v40 >= ((v39 >> 1) & 3 | *(_DWORD *)((v39 & 0xFFFFFFFFFFFFFFF8) + 24)))
  {
LABEL_259:
    unsigned int v41 = &v38[3 * v37];
    goto LABEL_260;
  }
  unsigned int v41 = *(void **)v36;
  unint64_t v42 = *(unsigned int *)(v36 + 8);
  do
  {
    unint64_t v43 = v42 >> 1;
    uint64_t v44 = v41[3 * (v42 >> 1) + 1];
    LODWORD(v44) = (v44 >> 1) & 3 | *(_DWORD *)((v44 & 0xFFFFFFFFFFFFFFF8) + 24);
    v42 -= (v42 >> 1) + 1;
    BOOL v45 = v40 >= v44;
    if (v40 >= v44) {
      unint64_t v46 = v43 + 1;
    }
    else {
      unint64_t v46 = 0;
    }
    v41 += 3 * v46;
    if (!v45) {
      unint64_t v42 = v43;
    }
  }
  while (v42);
LABEL_260:
  if (v41 == &v38[3 * v37]) {
    goto LABEL_39;
  }
  if (((*v41 >> 1) & 3 | *(_DWORD *)((*v41 & 0xFFFFFFFFFFFFFFF8) + 24)) > (*(_DWORD *)(v158 + 24) | 2u)) {
    goto LABEL_39;
  }
  uint64_t v154 = v41[2];
  if (!v154) {
    goto LABEL_39;
  }
  BOOL v157 = (*(void *)(v154 + 8) & 0xFFFFFFFFFFFFFFF8) == v158;
LABEL_40:
  unint64_t v159 = v26;
  uint64_t v47 = *((unsigned int *)this + 10);
  if (!v47)
  {
    char v160 = 0;
LABEL_168:
    if (v157 && !((a1[9] == 0) | v160 & 1))
    {
      uint64_t v104 = *((void *)this + 2);
      if (*(_WORD *)v104 == 10
        || (*(unsigned char *)(v104 + 11) & 0x20) != 0
        && ((uint64_t v105 = (llvm::TargetInstrInfo *)a1[6],
             ((*(uint64_t (**)(llvm::TargetInstrInfo *, llvm::MachineInstr *, llvm::AAResults *))(*(void *)v105 + 32))(v105, this, a4) & 1) != 0)|| llvm::TargetInstrInfo::isReallyTriviallyReMaterializableGeneric(v105, this, a4)))
      {
        llvm::LiveRangeEdit::createEmptyIntervalFrom(a1, v155);
      }
    }
    uint64_t v106 = a1[7];
    if (v106) {
      (*(void (**)(uint64_t, llvm::MachineInstr *, size_t))(*(void *)v106 + 24))(v106, this, v25);
    }
    uint64_t v107 = *(int32x2_t **)(a1[4] + 288);
    int32x2_t v108 = v107[46];
    uint64_t v109 = v107[48].u32[0];
    if (v109)
    {
      LODWORD(v110) = (v109 - 1) & ((this >> 4) ^ (this >> 9));
      uint64_t v111 = *(void *)&v108 + 16 * v110;
      uint64_t v112 = *(llvm::MachineInstr **)v111;
      if (*(llvm::MachineInstr **)v111 == this)
      {
LABEL_184:
        if (v111 != *(void *)&v108 + 16 * v109)
        {
          unint64_t v115 = *(void *)(v111 + 8) & 0xFFFFFFFFFFFFFFF8;
          *(void *)uint64_t v111 = -8192;
          v107[47] = vadd_s32(v107[47], (int32x2_t)0x1FFFFFFFFLL);
          *(void *)(v115 + 16) = 0;
        }
        llvm::MachineInstr::eraseFromParent(this);
        goto LABEL_187;
      }
      int v113 = 1;
      while (v112 != (llvm::MachineInstr *)-4096)
      {
        int v114 = v110 + v113++;
        uint64_t v110 = v114 & (v109 - 1);
        uint64_t v112 = *(llvm::MachineInstr **)(*(void *)&v108 + 16 * v110);
        if (v112 == this)
        {
          uint64_t v111 = *(void *)&v108 + 16 * v110;
          goto LABEL_184;
        }
      }
    }
    uint64_t v111 = *(void *)&v108 + 16 * v109;
    goto LABEL_184;
  }
  char v156 = 0;
  char v160 = 0;
  uint64_t v48 = (unsigned int *)*((void *)this + 4);
  int v49 = &v48[8 * v47];
  size_t v25 = 0x1000000;
  do
  {
    while (1)
    {
      unsigned int v50 = *v48;
      if (*v48) {
        goto LABEL_145;
      }
      unint64_t v51 = v48[1];
      if ((v51 & 0x80000000) != 0) {
        break;
      }
      BOOL v53 = (v50 & 0x10FFF00) == 0x1000000 || (v50 & 0x30000000) != 0 || v51 == 0;
      if (v53 || ((*(void *)(*(void *)(a1[3] + 352) + ((v51 >> 3) & 0x1FFFFFF8)) >> v51) & 1) != 0)
      {
        if ((v50 & 0x1000000) != 0)
        {
          llvm::LiveIntervals::removePhysRegDefAt((void *)a1[4], v48[1], v159);
          size_t v25 = 0x1000000;
        }
        goto LABEL_145;
      }
      v48 += 8;
      char v156 = 1;
      if (v48 == v49) {
        goto LABEL_160;
      }
    }
    uint64_t v54 = a1[4];
    uint64_t v55 = v51 & 0x7FFFFFFF;
    unsigned int v56 = (void *)(v54 + 408);
    uint64_t v57 = *(unsigned int *)(v54 + 416);
    if ((v51 & 0x7FFFFFFF) >= v57)
    {
      sub_1CB9153B8((uint64_t)v56, v55 - v57 + 1, *(void *)(v54 + 424));
LABEL_157:
      operator new();
    }
    uint64_t v58 = *(void *)(*v56 + 8 * v55);
    if (!v58) {
      goto LABEL_157;
    }
    uint64_t v59 = *((unsigned int *)this + 10);
    if (!v59) {
      goto LABEL_73;
    }
    int v60 = 0;
    char v61 = 0;
    int v62 = 0;
    uint64_t v63 = (_DWORD *)(*((void *)this + 4) + 4);
    do
    {
      unsigned int v64 = *(v63 - 1);
      if (!(_BYTE)v64 && *v63 == v51)
      {
        int v65 = (v64 >> 28) & 1;
        if ((v64 & 0xFFF00) == 0) {
          int v65 = 1;
        }
        int v66 = v65 | v62;
        int v67 = v65 ^ 1 | v60;
        if ((v64 & 0x1000000) != 0) {
          int v62 = v66;
        }
        else {
          v61 |= (v64 & 0x10000000) == 0;
        }
        if ((v64 & 0x1000000) != 0) {
          int v60 = v67;
        }
      }
      v63 += 8;
      --v59;
    }
    while (v59);
    if ((v61 & 1) != 0 || ((v60 ^ 1 | v62) & 1) == 0)
    {
      if (**((_WORD **)this + 2) == 19) {
        goto LABEL_83;
      }
      unsigned int v68 = *v48;
      if ((*v48 & 0x1000000) != 0) {
        goto LABEL_83;
      }
    }
    else
    {
LABEL_73:
      unsigned int v68 = *v48;
    }
    if ((v68 & 0x30000000) == 0 && (v68 & 0x10FFF00) != 0x1000000)
    {
      uint64_t v69 = *(void *)(*(void *)(a1[3] + 24) + 16 * v55 + 8);
      if (v69)
      {
        if ((*(unsigned char *)(v69 + 3) & 0x81) == 0) {
          goto LABEL_80;
        }
        while (1)
        {
          uint64_t v69 = *(void *)(v69 + 24);
          if (!v69) {
            break;
          }
          if ((*(_DWORD *)v69 & 0x81000000) == 0)
          {
LABEL_80:
            while (1)
            {
              uint64_t v69 = *(void *)(v69 + 24);
              if (!v69) {
                goto LABEL_83;
              }
              if ((*(_DWORD *)v69 & 0x81000000) == 0) {
                goto LABEL_82;
              }
            }
          }
        }
      }
LABEL_82:
      char IsKill = llvm::LiveRangeEdit::useIsKill((uint64_t)a1, v58, v48);
      size_t v25 = 0x1000000;
      if (IsKill)
      {
LABEL_83:
        uint64_t v71 = a3[1];
        uint64_t v72 = *((unsigned int *)a3 + 5);
        if (v71 == *a3)
        {
          if (v72)
          {
            uint64_t v73 = 0;
            uint64_t v74 = 8 * v72;
            uint64_t v75 = (uint64_t *)a3[1];
            while (*v75 != v58)
            {
              if (*v75 == -2) {
                uint64_t v73 = v75;
              }
              ++v75;
              v74 -= 8;
              if (!v74)
              {
                if (!v73) {
                  goto LABEL_91;
                }
                *uint64_t v73 = v58;
                --*((_DWORD *)a3 + 6);
                goto LABEL_115;
              }
            }
            goto LABEL_117;
          }
LABEL_91:
          unsigned int v76 = *((_DWORD *)a3 + 4);
          if (v72 < v76)
          {
            *((_DWORD *)a3 + 5) = v72 + 1;
            *(void *)(v71 + 8 * v72) = v58;
            goto LABEL_115;
          }
        }
        else
        {
          unsigned int v76 = *((_DWORD *)a3 + 4);
        }
        if (3 * v76 <= 4 * ((int)v72 - *((_DWORD *)a3 + 6)))
        {
          if (v76 >= 0x40) {
            v76 *= 2;
          }
          else {
            unsigned int v76 = 128;
          }
        }
        else if (v76 - v72 >= v76 >> 3)
        {
LABEL_96:
          unsigned int v77 = v76 - 1;
          unsigned int v78 = (v76 - 1) & ((v58 >> 4) ^ (v58 >> 9));
          uint64_t v79 = (uint64_t *)(v71 + 8 * v78);
          uint64_t v80 = *v79;
          if (*v79 != -1)
          {
            unsigned int v81 = 0;
            int v82 = 1;
            while (v80 != v58)
            {
              if (v81) {
                BOOL v83 = 0;
              }
              else {
                BOOL v83 = v80 == -2;
              }
              if (v83) {
                unsigned int v81 = v79;
              }
              unsigned int v84 = v78 + v82++;
              unsigned int v78 = v84 & v77;
              uint64_t v79 = (uint64_t *)(v71 + 8 * (v84 & v77));
              uint64_t v80 = *v79;
              if (*v79 == -1) {
                goto LABEL_108;
              }
            }
            goto LABEL_117;
          }
          unsigned int v81 = 0;
LABEL_108:
          if (v81) {
            unsigned int v85 = v81;
          }
          else {
            unsigned int v85 = v79;
          }
          if (*v85 == v58)
          {
LABEL_117:
            if ((*v48 & 0x1000000) == 0) {
              goto LABEL_145;
            }
LABEL_125:
            uint64_t v88 = a1[7];
            if (!v88)
            {
LABEL_141:
              llvm::LiveIntervals::removeVRegDefAt(a1[4], v58, v159);
              if (*(_DWORD *)(v58 + 8))
              {
                size_t v25 = 0x1000000;
              }
              else
              {
                size_t v25 = 0x1000000;
                if (v163 >= (unint64_t)HIDWORD(v163)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *((_DWORD *)v162 + v163) = v51;
                LODWORD(v163) = v163 + 1;
              }
              goto LABEL_145;
            }
            unsigned int v89 = *(_DWORD *)(v58 + 8);
            uint64_t v90 = *(void **)v58;
            if (v89)
            {
              uint64_t v91 = v90[3 * v89 - 2];
              unsigned int v92 = *(_DWORD *)(v158 + 24) | 2;
              unsigned int v93 = (v91 >> 1) & 3 | *(_DWORD *)((v91 & 0xFFFFFFFFFFFFFFF8) + 24);
              unint64_t v94 = *(void **)v58;
              unint64_t v95 = *(unsigned int *)(v58 + 8);
              if (v92 < v93)
              {
                do
                {
                  unint64_t v96 = v95 >> 1;
                  uint64_t v97 = v94[3 * (v95 >> 1) + 1];
                  LODWORD(v97) = (v97 >> 1) & 3 | *(_DWORD *)((v97 & 0xFFFFFFFFFFFFFFF8) + 24);
                  v95 -= (v95 >> 1) + 1;
                  BOOL v98 = v92 >= v97;
                  if (v92 >= v97) {
                    unint64_t v99 = v96 + 1;
                  }
                  else {
                    unint64_t v99 = 0;
                  }
                  v94 += 3 * v99;
                  if (!v98) {
                    unint64_t v95 = v96;
                  }
                }
                while (v95);
                goto LABEL_137;
              }
            }
            else
            {
              unsigned int v89 = 0;
            }
            unint64_t v94 = &v90[3 * v89];
LABEL_137:
            if (v94 != &v90[3 * v89]
              && ((*v94 >> 1) & 3 | *(_DWORD *)((*v94 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)(v158 + 24) | 2u)
              && v94[2])
            {
              (*(void (**)(uint64_t, void))(*(void *)v88 + 40))(v88, *(unsigned int *)(v58 + 112));
            }
            goto LABEL_141;
          }
          if (*v85 == -2) {
            --*((_DWORD *)a3 + 6);
          }
          else {
            ++*((_DWORD *)a3 + 5);
          }
          *unsigned int v85 = v58;
LABEL_115:
          unint64_t v86 = *((unsigned int *)a3 + 26);
          if (v86 >= *((unsigned int *)a3 + 27)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(a3[12] + 8 * v86) = v58;
          ++*((_DWORD *)a3 + 26);
          goto LABEL_117;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a3, v76);
        size_t v25 = 0x1000000;
        unsigned int v76 = *((_DWORD *)a3 + 4);
        uint64_t v71 = a3[1];
        goto LABEL_96;
      }
      unsigned int v68 = *v48;
    }
    BOOL v87 = (v68 & 0xFFF00) != 0;
    if ((v68 & 0x1000000) == 0) {
      BOOL v87 = 1;
    }
    if ((v68 & 0x30000000) != 0) {
      BOOL v87 = 0;
    }
    v160 |= v87;
    if ((v68 & 0x1000000) != 0) {
      goto LABEL_125;
    }
LABEL_145:
    v48 += 8;
  }
  while (v48 != v49);
  if ((v156 & 1) == 0) {
    goto LABEL_168;
  }
LABEL_160:
  *((void *)this + 2) = *(void *)(a1[6] + 8) + 336;
  int v100 = *((_DWORD *)this + 10);
  if (v100)
  {
    unsigned int v101 = v100 - 1;
    uint64_t v102 = 32 * (v100 - 1);
    do
    {
      uint64_t v103 = *((void *)this + 4);
      if (*(unsigned char *)(v103 + v102) || (*(_DWORD *)(v103 + v102 + 4) - 1) >= 0x3FFFFFFF) {
        llvm::MachineInstr::removeOperand((char *)this, v101);
      }
      v102 -= 32;
      --v101;
    }
    while (v101 != -1);
  }
LABEL_187:
  uint64_t v116 = v163;
  if (v163)
  {
    uint64_t v117 = 0;
    do
    {
      uint64_t v118 = *((unsigned int *)v162 + v117);
      uint64_t v119 = a1[4];
      unint64_t v120 = v118 & 0x7FFFFFFF;
      if (v120 < *(unsigned int *)(v119 + 416))
      {
        uint64_t v121 = *(void *)(*(void *)(v119 + 408) + 8 * v120);
        if (v121)
        {
          uint64_t v122 = a1[3];
          if ((v118 & 0x80000000) != 0) {
            v123 = (uint64_t *)(*(void *)(v122 + 24) + 16 * v120 + 8);
          }
          else {
            v123 = (uint64_t *)(*(void *)(v122 + 272) + 8 * v118);
          }
          uint64_t v124 = *v123;
          if (v124)
          {
            while ((*(_DWORD *)v124 & 0x80000000) != 0)
            {
              uint64_t v124 = *(void *)(v124 + 24);
              if (!v124) {
                goto LABEL_197;
              }
            }
          }
          else
          {
LABEL_197:
            uint64_t v126 = *a3;
            uint64_t v125 = a3[1];
            if (v125 == *a3)
            {
              uint64_t v127 = *((unsigned int *)a3 + 5);
              v128 = (void *)(v125 + 8 * v127);
              if (v127)
              {
                uint64_t v129 = 0;
                uint64_t v130 = 8 * v127;
                while (*(void *)(v125 + v129) != v121)
                {
                  v129 += 8;
                  if (v130 == v129) {
                    goto LABEL_215;
                  }
                }
                v128 = (void *)(v125 + v129);
              }
LABEL_215:
              uint64_t v126 = a3[1];
            }
            else
            {
              uint64_t v131 = *((unsigned int *)a3 + 4);
              int v132 = v131 - 1;
              unsigned int v133 = (v131 - 1) & ((v121 >> 4) ^ (v121 >> 9));
              v128 = (void *)(v125 + 8 * v133);
              uint64_t v134 = *v128;
              if (*v128 == -1)
              {
                v135 = 0;
LABEL_243:
                if (v135) {
                  v128 = v135;
                }
                if (*v128 != v121) {
                  v128 = (void *)(v125 + 8 * v131);
                }
              }
              else
              {
                v135 = 0;
                int v136 = 1;
                while (v134 != v121)
                {
                  if (v135) {
                    BOOL v137 = 0;
                  }
                  else {
                    BOOL v137 = v134 == -2;
                  }
                  if (v137) {
                    v135 = v128;
                  }
                  unsigned int v138 = v133 + v136++;
                  unsigned int v133 = v138 & v132;
                  v128 = (void *)(v125 + 8 * (v138 & v132));
                  uint64_t v134 = *v128;
                  if (*v128 == -1) {
                    goto LABEL_243;
                  }
                }
              }
            }
            if (v125 == v126) {
              v139 = (unsigned int *)a3 + 5;
            }
            else {
              v139 = (unsigned int *)(a3 + 2);
            }
            if (v128 != (void *)(v125 + 8 * *v139))
            {
              void *v128 = -2;
              ++*((_DWORD *)a3 + 6);
              v140 = (char *)a3[12];
              uint64_t v141 = *((unsigned int *)a3 + 26);
              v142 = &v140[8 * v141];
              if (v141)
              {
                uint64_t v143 = 8 * v141;
                while (*(void *)v140 != v121)
                {
                  v140 += 8;
                  v143 -= 8;
                  if (!v143)
                  {
                    v140 = v142;
                    break;
                  }
                }
              }
              size_t v25 = v142 - (v140 + 8);
              if (v142 != v140 + 8)
              {
                memmove(v140, v140 + 8, v25);
                LODWORD(v141) = *((_DWORD *)a3 + 26);
              }
              *((_DWORD *)a3 + 26) = v141 - 1;
            }
            uint64_t v144 = a1[7];
            if (v144
              && (*(unsigned int (**)(uint64_t, uint64_t, size_t))(*(void *)v144 + 32))(v144, v118, v25))
            {
              uint64_t v145 = a1[4];
              uint64_t v146 = *(void *)(v145 + 408);
              uint64_t v147 = *(void *)(v146 + 8 * v120);
              if (v147)
              {
                uint64_t v148 = *(void *)(v147 + 104);
                if (v148)
                {
                  do
                  {
                    uint64_t v151 = *(void *)(v148 + 96);
                    uint64_t v152 = *(void *)(v148 + 104);
                    *(void *)(v148 + 96) = 0;
                    if (v151)
                    {
                      sub_1CB833A08(v151, *(void **)(v151 + 8));
                      MEMORY[0x1D25D9CE0](v151, 0x1020C4062D53EE8);
                    }
                    v153 = *(void **)(v148 + 64);
                    if (v153 != (void *)(v148 + 80)) {
                      free(v153);
                    }
                    if (*(void *)v148 != v148 + 16) {
                      free(*(void **)v148);
                    }
                    uint64_t v148 = v152;
                  }
                  while (v152);
                }
                uint64_t v149 = *(void *)(v147 + 96);
                *(void *)(v147 + 96) = 0;
                *(void *)(v147 + 104) = 0;
                if (v149)
                {
                  sub_1CB833A08(v149, *(void **)(v149 + 8));
                  MEMORY[0x1D25D9CE0](v149, 0x1020C4062D53EE8);
                }
                v150 = *(void **)(v147 + 64);
                if (v150 != (void *)(v147 + 80)) {
                  free(v150);
                }
                if (*(void *)v147 != v147 + 16) {
                  free(*(void **)v147);
                }
                MEMORY[0x1D25D9CE0](v147, 0x10A0C408DA535C6);
                uint64_t v146 = *(void *)(v145 + 408);
              }
              *(void *)(v146 + 8 * v120) = 0;
            }
          }
        }
      }
      ++v117;
    }
    while (v117 != v116);
  }
  if (v162 != v164) {
    free(v162);
  }
}

void llvm::LiveRangeEdit::eliminateDeadDefs(void *a1, uint64_t a2, _DWORD *a3, uint64_t a4, llvm::AAResults *a5)
{
  v36[8] = *MEMORY[0x1E4F143B8];
  unint64_t v29 = v33;
  int v30 = v33;
  uint64_t v31 = 8;
  int v32 = 0;
  int v34 = v36;
  uint64_t v35 = 0x800000000;
  while (1)
  {
    while (1)
    {
      unsigned int v10 = *(_DWORD *)(a2 + 8);
      if (!v10) {
        break;
      }
      BOOL v14 = *(llvm::MachineInstr **)(*(void *)a2 + 8 * v10 - 8);
      *(_DWORD *)(a2 + 8) = v10 - 1;
      llvm::LiveRangeEdit::eliminateDeadDef(a1, v14, (uint64_t *)&v29, a5);
    }
    int v11 = v35;
    if (!v35) {
      break;
    }
    int v12 = (unsigned int *)*((void *)v34 + v35 - 1);
    unsigned int v13 = v29;
    if (v30 == v29)
    {
      unsigned int v20 = &v30[8 * HIDWORD(v31)];
      if (HIDWORD(v31))
      {
        uint64_t v15 = 0;
        while (*(unsigned int **)&v30[v15] != v12)
        {
          v15 += 8;
          if (8 * HIDWORD(v31) == v15) {
            goto LABEL_41;
          }
        }
        unsigned int v20 = &v30[v15];
      }
LABEL_41:
      unsigned int v13 = v30;
    }
    else
    {
      int v21 = v31 - 1;
      unsigned int v22 = (v31 - 1) & ((v12 >> 4) ^ (v12 >> 9));
      unsigned int v20 = &v30[8 * v22];
      int v23 = *(unsigned int **)v20;
      if (*(void *)v20 == -1)
      {
        BOOL v24 = 0;
LABEL_43:
        if (v24) {
          unsigned int v20 = v24;
        }
        if (*(unsigned int **)v20 != v12) {
          unsigned int v20 = &v30[8 * v31];
        }
      }
      else
      {
        BOOL v24 = 0;
        int v25 = 1;
        while (v23 != v12)
        {
          if (v24) {
            BOOL v26 = 0;
          }
          else {
            BOOL v26 = v23 == (unsigned int *)-2;
          }
          if (v26) {
            BOOL v24 = v20;
          }
          unsigned int v27 = v22 + v25++;
          unsigned int v22 = v27 & v21;
          unsigned int v20 = &v30[8 * (v27 & v21)];
          int v23 = *(unsigned int **)v20;
          if (*(void *)v20 == -1) {
            goto LABEL_43;
          }
        }
      }
    }
    if (v30 == v13) {
      uint64_t v16 = (uint64_t *)((char *)&v31 + 4);
    }
    else {
      uint64_t v16 = &v31;
    }
    if (v20 != &v30[8 * *(unsigned int *)v16])
    {
      *(void *)unsigned int v20 = -2;
      ++v32;
    }
    LODWORD(v35) = v11 - 1;
    if ((llvm::LiveRangeEdit::foldAsLoad((uint64_t)a1, (uint64_t)v12, a2) & 1) == 0)
    {
      uint64_t v17 = v12[28];
      uint64_t v18 = a1[7];
      if (v18) {
        (*(void (**)(uint64_t, void))(*(void *)v18 + 40))(v18, v12[28]);
      }
      if (llvm::LiveIntervals::shrinkToUses((void *)a1[4], (uint64_t)v12, a2))
      {
        uint64_t v19 = a3;
        if (a4)
        {
          uint64_t v28 = 4 * a4;
          uint64_t v19 = a3;
          while (*v19 != v17)
          {
            ++v19;
            v28 -= 4;
            if (!v28)
            {
              uint64_t v19 = &a3[a4];
              break;
            }
          }
        }
        if (a4 == v19 - a3)
        {
          llvm::LiveRange::RenumberValues((llvm::LiveRange *)v12);
          llvm::LiveIntervals::splitSeparateComponents(a1[4], (const llvm::LiveRange *)v12);
        }
      }
    }
  }
  if (v34 != v36) {
    free(v34);
  }
  if (v30 != v29) {
    free(v30);
  }
}

uint64_t llvm::LiveRangeEdit::MRI_NoteNewVirtualRegister(uint64_t a1, int a2)
{
  uint64_t result = *(void *)(a1 + 40);
  if (result) {
    uint64_t result = llvm::VirtRegMap::grow(result);
  }
  uint64_t v5 = *(void *)(a1 + 16);
  unsigned int v6 = *(_DWORD *)(v5 + 8);
  if (v6 >= *(_DWORD *)(v5 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)v5 + 4 * v6) = a2;
  ++*(_DWORD *)(v5 + 8);
  return result;
}

void llvm::LiveRangeEdit::calculateRegClassAndHint(llvm::LiveRangeEdit *this, llvm::MachineFunction *a2, llvm::VirtRegAuxInfo *a3)
{
  int v3 = *(_DWORD *)(*((void *)this + 2) + 8);
  int v4 = *((_DWORD *)this + 16);
  int v5 = v3 - v4;
  if (v3 != v4)
  {
    int v8 = 0;
    do
    {
      uint64_t v9 = *((void *)this + 4);
      unint64_t v10 = *(_DWORD *)(**((void **)this + 2) + 4 * (v8 + *((_DWORD *)this + 16))) & 0x7FFFFFFF;
      int v11 = (void *)(v9 + 408);
      unint64_t v12 = *(unsigned int *)(v9 + 416);
      BOOL v13 = v10 >= v12;
      unint64_t v14 = v10 - v12;
      if (v13)
      {
        sub_1CB9153B8((uint64_t)v11, v14 + 1, *(void *)(v9 + 424));
LABEL_10:
        llvm::LiveIntervals::createInterval();
      }
      uint64_t v15 = *(void *)(*v11 + 8 * v10);
      if (!v15) {
        goto LABEL_10;
      }
      llvm::MachineRegisterInfo::recomputeRegClass(*((void **)this + 3), *(_DWORD *)(v15 + 112));
      float v16 = llvm::VirtRegAuxInfo::weightCalcHelper(a3, (llvm::LiveInterval *)v15, 0, 0);
      if (v16 >= 0.0) {
        *(float *)(v15 + 116) = v16;
      }
      ++v8;
    }
    while (v5 != v8);
  }
}

void sub_1CC3075A0()
{
}

void sub_1CC3075B4()
{
}

void sub_1CC307650()
{
}

void sub_1CC307760(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F260E110;
  unsigned int v1 = (void *)*((void *)a1 + 22);
  if (v1 != (void *)((char *)a1 + 192))
  {
    int v4 = a1;
    free(v1);
    a1 = v4;
  }
  uint64_t v2 = (void *)*((void *)a1 + 13);
  if (v2 != (void *)((char *)a1 + 120))
  {
    int v5 = a1;
    free(v2);
    a1 = v5;
  }
  int v3 = (void *)*((void *)a1 + 4);
  if (v3 != (void *)((char *)a1 + 48))
  {
    unsigned int v6 = a1;
    free(v3);
    a1 = v6;
  }

  llvm::Pass::~Pass(a1);
}

void sub_1CC307814(llvm::Pass *this)
{
  *(void *)this = &unk_1F260E110;
  uint64_t v2 = (char *)*((void *)this + 22);
  if (v2 != (char *)this + 192) {
    free(v2);
  }
  int v3 = (char *)*((void *)this + 13);
  if (v3 != (char *)this + 120) {
    free(v3);
  }
  int v4 = (char *)*((void *)this + 4);
  if (v4 != (char *)this + 48) {
    free(v4);
  }
  llvm::Pass::~Pass(this);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CC3078C0()
{
  return "Live Range Shrink";
}

void sub_1CC3078D0(llvm::PassRegistry *a1, uint64_t a2)
{
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)a1, a2);
}

uint64_t sub_1CC307944(llvm::FunctionPass *a1, uint64_t a2)
{
  if ((llvm::FunctionPass::skipFunction(a1, *(llvm::LLVMContextImpl *****)a2) & 1) == 0)
  {
    int v3 = *(void **)(a2 + 40);
    v99[0] = 0;
    v99[1] = 0;
    unsigned int v100 = 0;
    int v4 = (void *)(a2 + 320);
    v97[0] = 0;
    v97[1] = 0;
    int v98 = 0;
    int v5 = *(void **)(a2 + 328);
    if (v5 == (void *)(a2 + 320))
    {
      uint64_t v88 = 0;
    }
    else
    {
      do
      {
        unsigned int v6 = v5 + 6;
        if (v5 + 6 != (void *)(v5[6] & 0xFFFFFFFFFFFFFFF8))
        {
          BOOL v96 = 0;
          sub_1CC308224((_DWORD *)v5[7], (uint64_t)v99);
          sub_1CD51D714(v97);
          uint64_t v7 = v5[7];
          if ((void *)v7 != v6)
          {
            while (1)
            {
              if (!v7 || (uint64_t v8 = v7, (*(unsigned char *)v7 & 4) == 0))
              {
                uint64_t v8 = v7;
                if ((*(_WORD *)(v7 + 44) & 8) != 0)
                {
                  uint64_t v8 = v7;
                  do
                    uint64_t v8 = *(void *)(v8 + 8);
                  while ((*(_WORD *)(v8 + 44) & 8) != 0);
                }
              }
              uint64_t v9 = *(void *)(v8 + 8);
              unint64_t v10 = *(unsigned __int16 **)(v7 + 16);
              int v11 = *v10;
              if ((v11 - 13) <= 0x38 && ((1 << (v11 - 13)) & 0x10000000000041FLL) != 0
                || v11 == 0)
              {
                goto LABEL_20;
              }
              if ((v11 - 1) <= 1 && (*(unsigned char *)(*(void *)(v7 + 32) + 48) & 0x10) != 0) {
                goto LABEL_26;
              }
              __int16 v14 = *(_WORD *)(v7 + 44);
              uint64_t v15 = *((void *)v10 + 1);
              if ((v14 & 0xC) == 0 || (v14 & 4) != 0) {
                break;
              }
              uint64_t v85 = v7;
              if ((v15 & 0x100000) != 0) {
                goto LABEL_26;
              }
              while ((*(_WORD *)(v85 + 44) & 8) != 0)
              {
                uint64_t v85 = *(void *)(v85 + 8);
                if ((*(unsigned char *)(*(void *)(v85 + 16) + 10) & 0x10) != 0) {
                  goto LABEL_26;
                }
              }
LABEL_27:
              unsigned int v92 = v3;
              uint64_t v95 = v7;
              float v16 = sub_1CD51D768((uint64_t)v99, &v95);
              uint64_t v17 = *(unsigned int *)(v7 + 40);
              if (v17)
              {
                unsigned int v93 = 0;
                uint64_t v91 = 0;
                int v18 = *((_DWORD *)v16 + 2);
                uint64_t v19 = *(int **)(v7 + 32);
                unsigned int v20 = &v19[8 * v17];
                do
                {
                  int v21 = *v19;
                  if ((*v19 & 0x800000FF) == 0)
                  {
                    if ((v21 & 0x1000000) != 0)
                    {
                      if ((~v21 & 0x5000000) == 0 && v98)
                      {
                        int v22 = v19[1];
                        unsigned int v23 = (v98 - 1) & (37 * v22);
                        int v24 = *(_DWORD *)(v97[0] + 24 * v23);
                        if (v22 == v24)
                        {
LABEL_34:
                          LODWORD(v95) = v19[1];
                          if (v93 < sub_1CD51D7CC((uint64_t)v97, (int *)&v95)[2])
                          {
                            LODWORD(v95) = v19[1];
                            unsigned int v93 = sub_1CD51D7CC((uint64_t)v97, (int *)&v95)[2];
                            LODWORD(v95) = v19[1];
                            uint64_t v91 = *((void *)sub_1CD51D7CC((uint64_t)v97, (int *)&v95) + 2);
                          }
                        }
                        else
                        {
                          int v26 = 1;
                          while (v24 != -1)
                          {
                            unsigned int v27 = v23 + v26++;
                            unsigned int v23 = v27 & (v98 - 1);
                            int v24 = *(_DWORD *)(v97[0] + 24 * v23);
                            if (v22 == v24) {
                              goto LABEL_34;
                            }
                          }
                        }
                      }
                    }
                    else
                    {
                      LODWORD(v95) = v19[1];
                      int v25 = sub_1CD51D7CC((uint64_t)v97, (int *)&v95);
                      v25[2] = v18;
                      *((void *)v25 + 2) = v7;
                    }
                  }
                  v19 += 8;
                }
                while (v19 != v20);
              }
              else
              {
                uint64_t v91 = 0;
                unsigned int v93 = 0;
              }
              if (llvm::MachineInstr::isSafeToMove((llvm::MachineInstr *)v7, 0, &v96))
              {
                uint64_t v95 = 0;
                uint64_t v28 = *(unsigned int *)(v7 + 40);
                if (v28)
                {
                  unint64_t v29 = 0;
                  unsigned int v90 = 0;
                  int v30 = *(_DWORD **)(v7 + 32);
                  uint64_t v31 = &v30[8 * v28];
                  do
                  {
                    int v32 = v29;
                    int v33 = *v30;
                    if (!*v30 && (v33 & 0x80000000) == 0 && (v33 & 0x5000000) != 0x5000000)
                    {
                      unsigned int v34 = v30[1];
                      if ((v34 & 0x80000000) != 0)
                      {
                        if ((v33 & 0x1000000) == 0)
                        {
                          uint64_t v37 = v34 & 0x7FFFFFFF;
                          uint64_t v38 = v92[3];
                          uint64_t v39 = *(int **)(v38 + 16 * v37 + 8);
                          if (v39)
                          {
                            int v40 = *v39;
                            uint64_t v41 = *(void *)(v38 + 16 * v37 + 8);
                            if ((*v39 & 0x81000000) == 0) {
                              goto LABEL_62;
                            }
                            uint64_t v41 = *(void *)(v38 + 16 * v37 + 8);
                            do
                            {
                              uint64_t v41 = *(void *)(v41 + 24);
                              if (!v41) {
                                goto LABEL_123;
                              }
                            }
                            while ((*(_DWORD *)v41 & 0x81000000) != 0);
LABEL_62:
                            while (1)
                            {
                              uint64_t v41 = *(void *)(v41 + 24);
                              if (!v41) {
                                break;
                              }
                              if ((*(_DWORD *)v41 & 0x81000000) == 0) {
                                goto LABEL_123;
                              }
                            }
                            uint64_t v42 = *(void *)(v38 + 16 * v37 + 8);
                            if ((v40 & 0x1000000) != 0
                              || (uint64_t v42 = *((void *)v39 + 3)) != 0 && (*(unsigned char *)(v42 + 3) & 1) != 0)
                            {
                              uint64_t v43 = *(void *)(v42 + 24);
                              BOOL v44 = !v43 || (*(unsigned char *)(v43 + 3) & 1) == 0;
                              if (v44
                                && v29
                                && (*(void *)(v38 + 16 * (v29[1] & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8) == (*(void *)(v38 + 16 * v37) & 0xFFFFFFFFFFFFFFF8))
                              {
                                if ((v40 & 0x1000000) == 0)
                                {
                                  uint64_t v39 = (int *)*((void *)v39 + 3);
                                  if ((*((unsigned char *)v39 + 3) & 1) == 0) {
                                    uint64_t v39 = 0;
                                  }
                                }
                                uint64_t v45 = *((void *)v39 + 1);
                                unsigned int v46 = v90;
                                if (**(_WORD **)(v45 + 16) != 19) {
                                  unsigned int v46 = v90 + 1;
                                }
                                unsigned int v90 = v46;
                                uint64_t v47 = v95;
                                if (v100)
                                {
                                  unsigned int v48 = v100 - 1;
                                  uint64_t v49 = (v100 - 1) & ((v45 >> 4) ^ (v45 >> 9));
                                  uint64_t v50 = *(void *)(v99[0] + 16 * v49);
                                  if (v45 == v50)
                                  {
LABEL_81:
                                    if (v49 == v100) {
                                      goto LABEL_82;
                                    }
                                    if (v95)
                                    {
                                      uint64_t v51 = ((v95 >> 4) ^ (v95 >> 9)) & v48;
                                      uint64_t v52 = *(void *)(v99[0] + 16 * v51);
                                      if (v95 != v52)
                                      {
                                        int v64 = 1;
                                        while (v52 != -4096)
                                        {
                                          int v65 = v51 + v64++;
                                          uint64_t v51 = v65 & v48;
                                          uint64_t v52 = *(void *)(v99[0] + 16 * v51);
                                          if (v95 == v52) {
                                            goto LABEL_86;
                                          }
                                        }
                                        uint64_t v51 = v100;
                                      }
LABEL_86:
                                      unsigned int v53 = *(_DWORD *)(v99[0] + 16 * v51 + 8);
                                      unsigned int v54 = *(_DWORD *)(v99[0] + 16 * v49 + 8);
                                      if (v53 == v54)
                                      {
                                        do
                                        {
                                          uint64_t v55 = *(void *)(v47 + 24);
                                          uint64_t v47 = *(void *)(v47 + 8);
                                          if (v47 == v55 + 48) {
                                            uint64_t v47 = 0;
                                          }
                                          uint64_t v56 = ((v47 >> 4) ^ (v47 >> 9)) & v48;
                                          uint64_t v57 = *(void *)(v99[0] + 16 * v56);
                                          if (v47 != v57)
                                          {
                                            int v60 = 1;
                                            while (v57 != -4096)
                                            {
                                              int v61 = v56 + v60++;
                                              uint64_t v56 = v61 & v48;
                                              uint64_t v57 = *(void *)(v99[0] + 16 * v56);
                                              if (v47 == v57) {
                                                goto LABEL_90;
                                              }
                                            }
                                            uint64_t v56 = v100;
                                          }
LABEL_90:
                                          int v58 = *(_DWORD *)(v99[0] + 16 * v56 + 8);
                                        }
                                        while (v47 != v45 && v58 == v53);
                                        if (v58 != v53) {
                                          uint64_t v45 = v95;
                                        }
                                      }
                                      else if (v53 >= v54)
                                      {
                                        uint64_t v45 = v95;
                                      }
                                    }
LABEL_83:
                                    uint64_t v95 = v45;
                                    goto LABEL_48;
                                  }
                                  int v62 = 1;
                                  while (v50 != -4096)
                                  {
                                    int v63 = v49 + v62++;
                                    uint64_t v49 = v63 & v48;
                                    uint64_t v50 = *(void *)(v99[0] + 16 * v49);
                                    if (v45 == v50) {
                                      goto LABEL_81;
                                    }
                                  }
                                }
LABEL_82:
                                uint64_t v45 = v95;
                                goto LABEL_83;
                              }
                            }
                          }
LABEL_123:
                          uint64_t v95 = 0;
                          goto LABEL_124;
                        }
                        unint64_t v29 = v30;
                        if (v32) {
                          goto LABEL_123;
                        }
                      }
                      else if (v34)
                      {
                        uint64_t v35 = v31;
                        char isConstantPhysReg = llvm::MachineRegisterInfo::isConstantPhysReg(v92, v34);
                        uint64_t v31 = v35;
                        unint64_t v29 = v32;
                        if ((isConstantPhysReg & 1) == 0) {
                          goto LABEL_123;
                        }
                      }
                    }
LABEL_48:
                    v30 += 8;
                  }
                  while (v30 != v31);
                  uint64_t v94 = v95;
                  int v3 = v92;
                  if (v95)
                  {
                    do
                    {
                      if (*((_DWORD *)sub_1CC308370((uint64_t)v99, &v94) + 2) != v93) {
                        break;
                      }
                      if (v94 == v91) {
                        goto LABEL_20;
                      }
                      uint64_t v69 = *(void *)(v94 + 8);
                      if (v69 == *(void *)(v94 + 24) + 48) {
                        uint64_t v69 = 0;
                      }
                      uint64_t v94 = v69;
                    }
                    while (v69);
                    if (v29 && v95 && v90 >= 2 && v93 <= *((_DWORD *)sub_1CC308370((uint64_t)v99, &v95) + 2))
                    {
                      uint64_t v70 = (uint64_t)(v5 + 6);
                      if (*(void **)(v95 + 8) != v6)
                      {
                        uint64_t v70 = *(void *)(v95 + 8);
                        while (1)
                        {
                          int v71 = **(unsigned __int16 **)(v70 + 16);
                          BOOL v72 = (v71 - 13) > 0x38
                             || ((1 << (v71 - 13)) & 0x10000000000041FLL) == 0;
                          if (v72 && v71 != 0) {
                            break;
                          }
                          if ((*(unsigned char *)v70 & 4) == 0)
                          {
                            while ((*(_WORD *)(v70 + 44) & 8) != 0)
                              uint64_t v70 = *(void *)(v70 + 8);
                          }
                          uint64_t v70 = *(void *)(v70 + 8);
                          if ((void *)v70 == v6)
                          {
                            uint64_t v70 = (uint64_t)(v5 + 6);
                            break;
                          }
                        }
                      }
                      if (v70 != v7)
                      {
                        uint64_t v94 = v70;
                        int v74 = *((_DWORD *)sub_1CD51D768((uint64_t)v99, &v94) + 2);
                        uint64_t v94 = v7;
                        *((_DWORD *)sub_1CD51D768((uint64_t)v99, &v94) + 2) = v74;
                        uint64_t v75 = *(void *)(v7 + 8);
                        if (**(unsigned char **)(v7 + 32)) {
                          BOOL v76 = 1;
                        }
                        else {
                          BOOL v76 = v75 == (void)v6;
                        }
                        if (!v76)
                        {
                          while (1)
                          {
                            int v81 = **(unsigned __int16 **)(v75 + 16);
                            if ((v81 - 13) > 1) {
                              break;
                            }
                            uint64_t v82 = *(void *)(v75 + 32);
                            if (v81 != 14)
                            {
                              uint64_t v84 = v82 + 32;
                              goto LABEL_164;
                            }
                            uint64_t v83 = *(unsigned int *)(v75 + 40);
                            if (v83 == 2) {
                              break;
                            }
                            uint64_t v84 = v82 + 32 * v83;
                            v82 += 64;
LABEL_164:
                            while (*(unsigned char *)v82 || *(_DWORD *)(v82 + 4) != *(_DWORD *)(*(void *)(v7 + 32) + 4))
                            {
                              v82 += 32;
                              if (v82 == v84) {
                                goto LABEL_156;
                              }
                            }
                            uint64_t v94 = v75;
                            *((_DWORD *)sub_1CD51D768((uint64_t)v99, &v94) + 2) = v74;
                            if (!v75 || (*(unsigned char *)v75 & 4) == 0)
                            {
                              while ((*(_WORD *)(v75 + 44) & 8) != 0)
                                uint64_t v75 = *(void *)(v75 + 8);
                            }
                            uint64_t v75 = *(void *)(v75 + 8);
                            if (!v9 || (*(unsigned char *)v9 & 4) == 0)
                            {
                              while ((*(_WORD *)(v9 + 44) & 8) != 0)
                                uint64_t v9 = *(void *)(v9 + 8);
                            }
                            uint64_t v9 = *(void *)(v9 + 8);
                            if ((void *)v75 == v6)
                            {
                              uint64_t v75 = (uint64_t)(v5 + 6);
                              break;
                            }
                          }
                        }
LABEL_156:
                        if (v7 != v75 && v70 != v75)
                        {
                          uint64_t v77 = *(void *)v75;
                          unint64_t v78 = *(void *)v75 & 0xFFFFFFFFFFFFFFF8;
                          unint64_t v79 = *(void *)v7 & 0xFFFFFFFFFFFFFFF8;
                          *(void *)(v79 + 8) = v75;
                          *(void *)uint64_t v75 = v79 | v77 & 7;
                          unint64_t v80 = *(void *)v70 & 0xFFFFFFFFFFFFFFF8;
                          *(void *)(v78 + 8) = v70;
                          *(void *)uint64_t v7 = v80 | *(void *)v7 & 7;
                          *(void *)(v80 + 8) = v7;
                          *(void *)uint64_t v70 = v77 & 0xFFFFFFFFFFFFFFF8 | *(void *)v70 & 7;
                        }
                        goto LABEL_124;
                      }
                    }
                  }
                }
                else
                {
LABEL_124:
                  int v3 = v92;
                }
                goto LABEL_20;
              }
              __int16 v66 = *(_WORD *)(v7 + 44);
              int v67 = *(unsigned __int16 **)(v7 + 16);
              uint64_t v68 = *((void *)v67 + 1);
              int v3 = v92;
              if ((v66 & 0xC) != 0 && (v66 & 4) == 0)
              {
                uint64_t v86 = v7;
                if ((v68 & 0x1000000) != 0) {
                  goto LABEL_189;
                }
                while ((*(_WORD *)(v86 + 44) & 8) != 0)
                {
                  uint64_t v86 = *(void *)(v86 + 8);
                  if (*(unsigned char *)(*(void *)(v86 + 16) + 11)) {
                    goto LABEL_189;
                  }
                }
              }
              else if ((v68 & 0x1000000) != 0)
              {
                goto LABEL_189;
              }
              if *v67 - 1 <= 1 && (*(unsigned char *)(*(void *)(v7 + 32) + 48))
              {
LABEL_189:
                if (*v67 != 23 && v9 != (void)v6)
                {
                  sub_1CC308224((_DWORD *)v9, (uint64_t)v99);
                  BOOL v96 = 0;
                }
              }
LABEL_20:
              uint64_t v7 = v9;
              if ((void *)v9 == v6) {
                goto LABEL_4;
              }
            }
            if ((v15 & 0x100000) == 0) {
              goto LABEL_27;
            }
LABEL_26:
            BOOL v96 = 1;
            goto LABEL_27;
          }
        }
LABEL_4:
        int v5 = (void *)v5[1];
      }
      while (v5 != v4);
      uint64_t v88 = v97[0];
    }
    MEMORY[0x1D25D9CD0](v88, 8);
    MEMORY[0x1D25D9CD0](v99[0], 8);
  }
  return 0;
}

_DWORD *sub_1CC308224(_DWORD *result, uint64_t a2)
{
  uint64_t v3 = (uint64_t)result;
  int v4 = *(_DWORD *)(a2 + 8);
  if (v4)
  {
    unsigned int v5 = *(_DWORD *)(a2 + 16);
    if (v5 > 4 * v4 && v5 >= 0x41)
    {
      int v6 = 1 << (33 - __clz(v4 - 1));
      if (v6 <= 64) {
        int v7 = 64;
      }
      else {
        int v7 = v6;
      }
      goto LABEL_7;
    }
  }
  else
  {
    if (!*(_DWORD *)(a2 + 12)) {
      goto LABEL_16;
    }
    unsigned int v5 = *(_DWORD *)(a2 + 16);
    if (v5 > 0x40)
    {
      int v7 = 0;
LABEL_7:
      if (v7 == v5)
      {
        *(void *)(a2 + 8) = 0;
        uint64_t v12 = 16 * v5;
        BOOL v13 = *(void **)a2;
        do
        {
          *BOOL v13 = -4096;
          v13 += 2;
          v12 -= 16;
        }
        while (v12);
      }
      else
      {
        MEMORY[0x1D25D9CD0](*(void *)a2, 8);
        uint64_t result = sub_1CB837D60((_DWORD *)a2, v7);
      }
      goto LABEL_16;
    }
  }
  if (v5)
  {
    uint64_t v8 = *(void **)a2;
    uint64_t v9 = 16 * v5;
    do
    {
      *uint64_t v8 = -4096;
      v8 += 2;
      v9 -= 16;
    }
    while (v9);
  }
  *(void *)(a2 + 8) = 0;
LABEL_16:
  uint64_t v10 = *(void *)(v3 + 24) + 48;
  if (v10 != v3)
  {
    int v11 = 0;
    do
    {
      uint64_t v14 = v3;
      uint64_t result = sub_1CD51D768(a2, &v14);
      result[2] = v11;
      if (!v3 || (*(unsigned char *)v3 & 4) == 0)
      {
        while ((*(_WORD *)(v3 + 44) & 8) != 0)
          uint64_t v3 = *(void *)(v3 + 8);
      }
      ++v11;
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != v10);
  }
  return result;
}

void *sub_1CC308370(uint64_t a1, uint64_t *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    uint64_t v12 = 0;
LABEL_15:
    int v6 = sub_1CB9A052C(a1, (uint64_t)a2, a2, v12);
    void *v6 = *a2;
    *((_DWORD *)v6 + 2) = 0;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
  int v6 = (void *)(*(void *)a1 + 16 * v5);
  uint64_t v7 = *v6;
  if (*a2 != *v6)
  {
    uint64_t v8 = 0;
    int v9 = 1;
    while (v7 != -4096)
    {
      if (v8) {
        BOOL v10 = 0;
      }
      else {
        BOOL v10 = v7 == -8192;
      }
      if (v10) {
        uint64_t v8 = v6;
      }
      unsigned int v11 = v5 + v9++;
      unsigned int v5 = v11 & v4;
      int v6 = (void *)(*(void *)a1 + 16 * (v11 & v4));
      uint64_t v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v8) {
      uint64_t v12 = v8;
    }
    else {
      uint64_t v12 = v6;
    }
    goto LABEL_15;
  }
  return v6;
}

void sub_1CC308430(llvm *a1)
{
  llvm::initializeLiveIntervalsPass((uint64_t)a1);
  llvm::initializeVirtRegMapPass(a1, v2);
  operator new();
}

uint64_t llvm::LiveRegMatrix::runOnMachineFunction(llvm::LiveRegMatrix *this, llvm::MachineFunction *a2)
{
  *((void *)this + 31) = (*(uint64_t (**)(void))(**((void **)a2 + 2) + 176))(*((void *)a2 + 2));
  int v3 = (uint64_t *)*((void *)this + 1);
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 == v5)
  {
LABEL_13:
    uint64_t v6 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v4 != &llvm::LiveIntervals::ID)
    {
      v4 += 16;
      if (v4 == v5) {
        goto LABEL_13;
      }
    }
    uint64_t v6 = *(void *)(v4 + 8);
  }
  *((void *)this + 32) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, &llvm::LiveIntervals::ID);
  uint64_t v7 = (uint64_t *)*((void *)this + 1);
  uint64_t v8 = *v7;
  uint64_t v9 = v7[1];
  if (v8 == v9)
  {
LABEL_7:
    uint64_t v10 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v8 != &llvm::VirtRegMap::ID)
    {
      v8 += 16;
      if (v8 == v9) {
        goto LABEL_7;
      }
    }
    uint64_t v10 = *(void *)(v8 + 8);
  }
  *((void *)this + 33) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v10 + 96))(v10, &llvm::VirtRegMap::ID);
  unsigned int v11 = *(_DWORD *)(*((void *)this + 31) + 44);
  if (v11 != *((_DWORD *)this + 96)) {
    operator new[]();
  }
  llvm::LiveIntervalUnion::Array::init((llvm::LiveRegMatrix *)((char *)this + 384), (uint64_t)this + 280, v11);
  ++*((_DWORD *)this + 68);
  return 0;
}

void llvm::LiveRegMatrix::releaseMemory(llvm::LiveRegMatrix *this)
{
  unsigned int v1 = *((_DWORD *)this + 96);
  if (v1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = 216 * v1;
    do
    {
      uint64_t v5 = *((void *)this + 49) + v3;
      if (*(_DWORD *)(v5 + 200))
      {
        sub_1CC2FE1FC(v5 + 8, (void (*)(void *, void, uint64_t))llvm::IntervalMap<llvm::SlotIndex,llvm::LiveInterval const*,8u,llvm::IntervalMapInfo<llvm::SlotIndex>>::deleteNode, 0);
        *(_DWORD *)(v5 + 200) = 0;
        *(_OWORD *)(v5 + 184) = 0u;
        *(_OWORD *)(v5 + 168) = 0u;
        *(_OWORD *)(v5 + 152) = 0u;
        *(_OWORD *)(v5 + 136) = 0u;
        *(_OWORD *)(v5 + 120) = 0u;
        *(_OWORD *)(v5 + 104) = 0u;
        *(_OWORD *)(v5 + 88) = 0u;
        *(_OWORD *)(v5 + 72) = 0u;
        *(_OWORD *)(v5 + 56) = 0u;
        *(_OWORD *)(v5 + 40) = 0u;
        *(_OWORD *)(v5 + 24) = 0u;
        *(_OWORD *)(v5 + 8) = 0u;
      }
      *(_DWORD *)(v5 + 204) = 0;
      ++*(_DWORD *)v5;
      v3 += 216;
    }
    while (v4 != v3);
  }
}

uint64_t llvm::LiveRegMatrix::assign(void *a1, llvm::LiveInterval *a2, unsigned int a3)
{
  *(_DWORD *)(*(void *)(a1[33] + 280) + 4 * (*((_DWORD *)a2 + 28) & 0x7FFFFFFF)) = (unsigned __int16)a3;
  uint64_t v5 = a1[31];
  if (v5) {
    uint64_t v6 = (void *)(v5 + 8);
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = (unsigned __int16 *)(v6[6] + (((unint64_t)*(unsigned int *)(*v6 + 24 * a3 + 16) >> 3) & 0x1FFFFFFE));
  int v9 = *v7;
  uint64_t v8 = v7 + 1;
  int v10 = v9 + (*(_DWORD *)(*v6 + 24 * a3 + 16) & 0xF) * a3;
  if (*((void *)a2 + 13))
  {
    uint64_t v14 = (void *)(v6[7] + 8 * *(unsigned __int16 *)(*v6 + 24 * a3 + 20));
    do
    {
      uint64_t v15 = *((void *)a2 + 13);
      if (v15)
      {
        while ((*(void *)(v15 + 112) & *v14) == 0)
        {
          uint64_t v15 = *(void *)(v15 + 104);
          if (!v15) {
            goto LABEL_15;
          }
        }
        llvm::LiveIntervalUnion::unify((llvm::LiveIntervalUnion *)(a1[49] + 216 * (unsigned __int16)v10), a2, (uint64_t **)v15);
      }
LABEL_15:
      ++v14;
      int v16 = *v8++;
      LOWORD(v10) = v16 + v10;
    }
    while (v16);
  }
  else
  {
    do
    {
      llvm::LiveIntervalUnion::unify((llvm::LiveIntervalUnion *)(a1[49] + 216 * (unsigned __int16)v10), a2, (uint64_t **)a2);
      int v11 = *v8++;
      v10 += v11;
    }
    while (v11);
  }
  uint64_t v12 = *(uint64_t (**)(void))(*(void *)a1[31] + 576);

  return v12();
}

uint64_t llvm::LiveRegMatrix::unassign(llvm::LiveRegMatrix *this, const llvm::LiveInterval *a2)
{
  uint64_t v4 = *((_DWORD *)a2 + 28) & 0x7FFFFFFF;
  uint64_t v5 = *(void *)(*((void *)this + 33) + 280);
  unsigned int v6 = *(_DWORD *)(v5 + 4 * v4);
  *(_DWORD *)(v5 + 4 * v4) = 0;
  uint64_t v7 = *((void *)this + 31);
  if (v7) {
    uint64_t v8 = (void *)(v7 + 8);
  }
  else {
    uint64_t v8 = 0;
  }
  int v9 = (unsigned __int16 *)(v8[6] + (((unint64_t)*(unsigned int *)(*v8 + 24 * v6 + 16) >> 3) & 0x1FFFFFFE));
  int v11 = *v9;
  int v10 = v9 + 1;
  int v12 = v11 + (*(_DWORD *)(*v8 + 24 * v6 + 16) & 0xF) * v6;
  if (*((void *)a2 + 13))
  {
    int v16 = (void *)(v8[7] + 8 * *(unsigned __int16 *)(*v8 + 24 * v6 + 20));
    do
    {
      uint64_t v17 = *((void *)a2 + 13);
      if (v17)
      {
        while ((*(void *)(v17 + 112) & *v16) == 0)
        {
          uint64_t v17 = *(void *)(v17 + 104);
          if (!v17) {
            goto LABEL_15;
          }
        }
        llvm::LiveIntervalUnion::extract((llvm::LiveIntervalUnion *)(*((void *)this + 49) + 216 * (unsigned __int16)v12), a2, (uint64_t **)v17);
      }
LABEL_15:
      ++v16;
      int v18 = *v10++;
      LOWORD(v12) = v18 + v12;
    }
    while (v18);
  }
  else
  {
    do
    {
      llvm::LiveIntervalUnion::extract((llvm::LiveIntervalUnion *)(*((void *)this + 49) + 216 * (unsigned __int16)v12), a2, (uint64_t **)a2);
      int v13 = *v10++;
      v12 += v13;
    }
    while (v13);
  }
  uint64_t v14 = *(uint64_t (**)(void))(**((void **)this + 31) + 584);

  return v14();
}

BOOL llvm::LiveRegMatrix::isPhysRegUsed(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 248);
  if (v2) {
    uint64_t v3 = (void *)(v2 + 8);
  }
  else {
    uint64_t v3 = 0;
  }
  unint64_t v4 = *(unsigned int *)(*v3 + 24 * a2 + 16);
  uint64_t v5 = (_WORD *)(v3[6] + ((v4 >> 3) & 0x1FFFFFFE));
  __int16 v7 = *v5;
  unsigned int v6 = v5 + 1;
  unsigned __int16 v8 = v7 + (v4 & 0xF) * a2;
  do
  {
    int v9 = *(_DWORD *)(*(void *)(a1 + 392) + 216 * v8 + 204);
    if (v9) {
      break;
    }
    int v10 = *v6++;
    v8 += v10;
  }
  while (v10);
  return v9 != 0;
}

BOOL llvm::LiveRegMatrix::checkRegMaskInterference(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v5 = *(_DWORD *)(a2 + 112);
  if (*(_DWORD *)(a1 + 412) == v5)
  {
    int v6 = *(_DWORD *)(a1 + 272);
    if (*(_DWORD *)(a1 + 408) == v6) {
      goto LABEL_3;
    }
  }
  else
  {
    int v6 = *(_DWORD *)(a1 + 272);
  }
  *(_DWORD *)(a1 + 412) = v5;
  *(_DWORD *)(a1 + 408) = v6;
  *(_DWORD *)(a1 + 480) = 0;
  *(_DWORD *)(a1 + 424) = 0;
  llvm::LiveIntervals::checkRegMaskInterference(*(void *)(a1 + 256), a2, a1 + 416);
LABEL_3:
  if (!*(_DWORD *)(a1 + 480)) {
    return 0;
  }
  if (a3) {
    return ((*(void *)(*(void *)(a1 + 416) + 8 * (a3 >> 6)) >> a3) & 1) == 0;
  }
  return 1;
}

uint64_t llvm::LiveRegMatrix::checkRegUnitInterference(uint64_t a1, llvm::LiveRange *this, unsigned int a3)
{
  if (!*((_DWORD *)this + 2)) {
    return 0;
  }
  int v5 = *((_DWORD *)this + 28);
  uint64_t v23 = *(void *)(a1 + 248);
  unsigned int v24 = a3;
  int v25 = v5;
  v26[2] = 0;
  v26[0] = 0;
  *(_DWORD *)((char *)v26 + 7) = 0;
  if (v23) {
    int v6 = (void *)(v23 + 8);
  }
  else {
    int v6 = 0;
  }
  unint64_t v7 = *(unsigned int *)(*v6 + 24 * a3 + 16);
  unsigned __int16 v8 = (_WORD *)(v6[6] + ((v7 >> 3) & 0x1FFFFFFE));
  __int16 v10 = *v8;
  int v9 = v8 + 1;
  unsigned __int16 v11 = v10 + (v7 & 0xF) * a3;
  if (*((void *)this + 13))
  {
    uint64_t v17 = (void *)(v6[7] + 8 * *(unsigned __int16 *)(*v6 + 24 * a3 + 20));
    while (1)
    {
      unsigned __int16 v18 = v11;
      uint64_t v19 = (llvm::LiveRange *)*((void *)this + 13);
      if (v19)
      {
        while ((*((void *)v19 + 14) & *v17) == 0)
        {
          uint64_t v19 = (llvm::LiveRange *)*((void *)v19 + 13);
          if (!v19) {
            goto LABEL_17;
          }
        }
        uint64_t v20 = *(void *)(a1 + 256);
        int v21 = *(const llvm::LiveRange **)(*(void *)(v20 + 680) + 8 * v11);
        if (!v21) {
          operator new();
        }
        if (llvm::LiveRange::overlaps(v19, v21, (const llvm::CoalescerPair *)&v23, *(const llvm::SlotIndexes **)(v20 + 288)))return 1; {
      }
        }
LABEL_17:
      uint64_t result = 0;
      ++v17;
      int v22 = *v9++;
      unsigned __int16 v11 = v22 + v18;
      if (!v22) {
        return result;
      }
    }
  }
  else
  {
    do
    {
      unsigned __int16 v12 = v11;
      uint64_t v13 = *(void *)(a1 + 256);
      uint64_t v14 = *(const llvm::LiveRange **)(*(void *)(v13 + 680) + 8 * v11);
      if (!v14) {
        operator new();
      }
      uint64_t result = llvm::LiveRange::overlaps(this, v14, (const llvm::CoalescerPair *)&v23, *(const llvm::SlotIndexes **)(v13 + 288));
      if (result) {
        break;
      }
      int v16 = *v9++;
      unsigned __int16 v11 = v16 + v12;
    }
    while (v16);
  }
  return result;
}

uint64_t llvm::LiveRegMatrix::query(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5 = *(void *)(a1 + 392);
  uint64_t v4 = *(void *)(a1 + 400);
  uint64_t result = v4 + 176 * a3;
  int v7 = *(_DWORD *)(a1 + 272);
  unsigned __int16 v8 = (_DWORD *)(v5 + 216 * a3);
  if (*(_DWORD *)(result + 168) != v7
    || *(void *)(v4 + 176 * a3 + 8) != a2
    || *(_DWORD **)result != v8
    || *v8 != *(_DWORD *)(v4 + 176 * a3 + 164))
  {
    *(void *)uint64_t result = v8;
    uint64_t v9 = v4 + 176 * a3;
    *(void *)(v9 + 8) = a2;
    *(_DWORD *)(v9 + 120) = 0;
    *(_WORD *)(v9 + 160) = 0;
    *(_DWORD *)(v9 + 164) = *v8;
    *(_DWORD *)(result + 168) = v7;
  }
  return result;
}

uint64_t llvm::LiveRegMatrix::checkInterference(uint64_t a1, llvm::LiveRange *this, unsigned int a3)
{
  if (!*((_DWORD *)this + 2)) {
    return 0;
  }
  __int16 v3 = a3;
  unint64_t v6 = a3;
  int v7 = *((_DWORD *)this + 28);
  if (*(_DWORD *)(a1 + 412) != v7)
  {
    int v8 = *(_DWORD *)(a1 + 272);
    goto LABEL_35;
  }
  int v8 = *(_DWORD *)(a1 + 272);
  if (*(_DWORD *)(a1 + 408) != v8)
  {
LABEL_35:
    *(_DWORD *)(a1 + 412) = v7;
    *(_DWORD *)(a1 + 408) = v8;
    *(_DWORD *)(a1 + 480) = 0;
    *(_DWORD *)(a1 + 424) = 0;
    llvm::LiveIntervals::checkRegMaskInterference(*(void *)(a1 + 256), (uint64_t)this, a1 + 416);
  }
  if (*(_DWORD *)(a1 + 480)
    && (!v6 || ((*(void *)(*(void *)(a1 + 416) + ((v6 >> 3) & 0x1FFFFFF8)) >> v3) & 1) == 0))
  {
    return 3;
  }
  if (llvm::LiveRegMatrix::checkRegUnitInterference(a1, this, v6)) {
    return 2;
  }
  uint64_t v9 = *(void *)(a1 + 248);
  if (v9) {
    __int16 v10 = (void *)(v9 + 8);
  }
  else {
    __int16 v10 = 0;
  }
  unint64_t v11 = *(unsigned int *)(*v10 + 24 * v6 + 16);
  unsigned __int16 v12 = (_WORD *)(v10[6] + ((v11 >> 3) & 0x1FFFFFFE));
  __int16 v14 = *v12;
  uint64_t v13 = v12 + 1;
  unsigned __int16 v15 = v14 + (v11 & 0xF) * v3;
  if (*((void *)this + 13))
  {
    uint64_t v23 = (void *)(v10[7] + 8 * *(unsigned __int16 *)(*v10 + 24 * v6 + 20));
    do
    {
      uint64_t v24 = *((void *)this + 13);
      if (v24)
      {
        while ((*(void *)(v24 + 112) & *v23) == 0)
        {
          uint64_t v24 = *(void *)(v24 + 104);
          if (!v24) {
            goto LABEL_22;
          }
        }
        uint64_t v25 = *(void *)(a1 + 400);
        int v26 = (llvm::LiveIntervalUnion::Query *)(v25 + 176 * v15);
        int v27 = *(_DWORD *)(a1 + 272);
        uint64_t v28 = (_DWORD *)(*(void *)(a1 + 392) + 216 * v15);
        if (*((_DWORD *)v26 + 42) != v27
          || *(void *)(v25 + 176 * v15 + 8) != v24
          || *(_DWORD **)v26 != v28
          || *v28 != *(_DWORD *)(v25 + 176 * v15 + 164))
        {
          *(void *)int v26 = v28;
          uint64_t v29 = v25 + 176 * v15;
          *(void *)(v29 + 8) = v24;
          *(_DWORD *)(v29 + 120) = 0;
          *(_WORD *)(v29 + 160) = 0;
          *(_DWORD *)(v29 + 164) = *v28;
          *((_DWORD *)v26 + 42) = v27;
        }
        uint64_t v21 = 1;
        if (llvm::LiveIntervalUnion::Query::collectInterferingVRegs(v26, 1u)) {
          break;
        }
      }
LABEL_22:
      uint64_t v21 = 0;
      ++v23;
      int v30 = *v13++;
      v15 += v30;
    }
    while (v30);
  }
  else
  {
    do
    {
      uint64_t v16 = *(void *)(a1 + 400);
      uint64_t v17 = (llvm::LiveIntervalUnion::Query *)(v16 + 176 * v15);
      int v18 = *(_DWORD *)(a1 + 272);
      uint64_t v19 = (_DWORD *)(*(void *)(a1 + 392) + 216 * v15);
      if (*((_DWORD *)v17 + 42) != v18
        || *(llvm::LiveRange **)(v16 + 176 * v15 + 8) != this
        || *(_DWORD **)v17 != v19
        || *v19 != *(_DWORD *)(v16 + 176 * v15 + 164))
      {
        *(void *)uint64_t v17 = v19;
        uint64_t v20 = v16 + 176 * v15;
        *(void *)(v20 + 8) = this;
        *(_DWORD *)(v20 + 120) = 0;
        *(_WORD *)(v20 + 160) = 0;
        *(_DWORD *)(v20 + 164) = *v19;
        *((_DWORD *)v17 + 42) = v18;
      }
      uint64_t v21 = 1;
      if (llvm::LiveIntervalUnion::Query::collectInterferingVRegs(v17, 1u)) {
        break;
      }
      uint64_t v21 = 0;
      int v31 = *v13++;
      v15 += v31;
    }
    while (v31);
  }
  return v21;
}

BOOL llvm::LiveRegMatrix::checkInterference(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  int v19 = 0;
  uint64_t v20 = a2;
  v30[0] = v31;
  v30[1] = (void *)0x200000000;
  int v32 = v34;
  uint64_t v33 = 0x200000000;
  uint64_t v35 = 0;
  v18[0] = a2;
  v18[1] = a3;
  v18[2] = &v19;
  llvm::LiveRange::addSegment((uint64_t)v30, (uint64_t)v18);
  uint64_t v6 = *(void *)(a1 + 248);
  if (v6) {
    int v7 = (void *)(v6 + 8);
  }
  else {
    int v7 = 0;
  }
  unint64_t v8 = *(unsigned int *)(*v7 + 24 * a4 + 16);
  uint64_t v9 = (_WORD *)(v7[6] + ((v8 >> 3) & 0x1FFFFFFE));
  __int16 v11 = *v9;
  __int16 v10 = v9 + 1;
  unsigned __int16 v12 = v11 + (v8 & 0xF) * a4;
  do
  {
    v21[3] = 0;
    int v22 = v24;
    uint64_t v23 = 0x400000000;
    uint64_t v25 = v27;
    int v13 = *(_DWORD *)(a1 + 272);
    v21[0] = *(void *)(a1 + 392) + 216 * v12;
    v21[1] = v30;
    uint64_t v26 = 0x400000000;
    v27[16] = 0;
    int v28 = *(_DWORD *)v21[0];
    int v29 = v13;
    int v14 = llvm::LiveIntervalUnion::Query::collectInterferingVRegs((llvm::LiveIntervalUnion::Query *)v21, 1u);
    if (v25 != v27) {
      free(v25);
    }
    if (v22 != v24) {
      free(v22);
    }
    if (v14) {
      break;
    }
    int v15 = *v10++;
    v12 += v15;
  }
  while (v15);
  uint64_t v16 = v35;
  uint64_t v35 = 0;
  if (v16)
  {
    sub_1CB833A08(v16, *(void **)(v16 + 8));
    MEMORY[0x1D25D9CE0](v16, 0x1020C4062D53EE8);
  }
  if (v32 != v34) {
    free(v32);
  }
  if (v30[0] != v31) {
    free(v30[0]);
  }
  return v14 != 0;
}

uint64_t llvm::LiveRegMatrix::getOneVReg(llvm::LiveRegMatrix *this, unsigned int a2)
{
  uint64_t v3 = *((void *)this + 31);
  if (v3) {
    uint64_t v4 = (void *)(v3 + 8);
  }
  else {
    uint64_t v4 = 0;
  }
  unint64_t v5 = *(unsigned int *)(*v4 + 24 * a2 + 16);
  uint64_t v6 = (_WORD *)(v4[6] + ((v5 >> 3) & 0x1FFFFFFE));
  __int16 v8 = *v6;
  int v7 = v6 + 1;
  unsigned __int16 v9 = v8 + (v5 & 0xF) * a2;
  while (1)
  {
    uint64_t OneVReg = llvm::LiveIntervalUnion::getOneVReg((llvm::LiveIntervalUnion *)(*((void *)this + 49) + 216 * v9));
    if (OneVReg) {
      break;
    }
    int v11 = *v7++;
    v9 += v11;
    if (!v11) {
      return 0;
    }
  }
  return *(unsigned int *)(OneVReg + 112);
}

void *llvm::LiveRegUnits::removeRegsNotPreserved(void *this, const unsigned int *a2)
{
  uint64_t v2 = *(unsigned int *)(*this + 44);
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *(void *)(*this + 48);
    do
    {
      unsigned int v5 = *(unsigned __int16 *)(v4 + 4 * v3);
      if (*(_WORD *)(v4 + 4 * v3))
      {
        unsigned int v6 = *(unsigned __int16 *)(v4 + 4 * v3 + 2);
        do
        {
          unsigned int v7 = a2[v5 >> 5] >> v5;
          unsigned int v5 = v6;
          if ((v7 & 1) == 0) {
            *(void *)(this[1] + 8 * (v3 >> 6)) &= ~(1 << v3);
          }
          unsigned int v6 = 0;
        }
        while (v5);
      }
      ++v3;
    }
    while (v3 != v2);
  }
  return this;
}

void *llvm::LiveRegUnits::addRegsInMask(void *this, const unsigned int *a2)
{
  uint64_t v2 = *(unsigned int *)(*this + 44);
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *(void *)(*this + 48);
    do
    {
      unsigned int v5 = *(unsigned __int16 *)(v4 + 4 * v3);
      if (*(_WORD *)(v4 + 4 * v3))
      {
        unsigned int v6 = *(unsigned __int16 *)(v4 + 4 * v3 + 2);
        do
        {
          unsigned int v7 = a2[v5 >> 5] >> v5;
          unsigned int v5 = v6;
          if ((v7 & 1) == 0) {
            *(void *)(this[1] + 8 * (v3 >> 6)) |= 1 << v3;
          }
          unsigned int v6 = 0;
        }
        while (v5);
      }
      ++v3;
    }
    while (v3 != v2);
  }
  return this;
}

void *llvm::LiveRegUnits::stepBackward(llvm::LiveRegUnits *this, const llvm::MachineInstr *a2)
{
  uint64_t v2 = a2;
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  sub_1CC300420((unint64_t)a2, (uint64_t)&v52);
  long long v46 = v52;
  long long v47 = v53;
  long long v48 = v54;
  long long v49 = v55;
  uint64_t v4 = v50;
  if (v57)
  {
    if (v57 == v56)
    {
      uint64_t v51 = v50;
      (*(void (**)(void))(*v57 + 24))();
    }
    else
    {
      uint64_t v51 = (void *)(*(uint64_t (**)(void))(*v57 + 16))();
    }
    goto LABEL_4;
  }
  while (1)
  {
    uint64_t v51 = 0;
LABEL_4:
    uint64_t v40 = v58;
    long long v42 = v59;
    if (v61)
    {
      if (v61 == v60)
      {
        uint64_t v45 = v44;
        (*(void (**)(void))(*v61 + 24))();
      }
      else
      {
        uint64_t v45 = (void *)(*(uint64_t (**)(void))(*v61 + 16))();
      }
    }
    else
    {
      uint64_t v45 = 0;
    }
LABEL_7:
    uint64_t v5 = v47;
    if ((void)v46 != v40
      || (void)v47 != (void)v42
      && ((void)v47 == *((void *)&v47 + 1) ? (BOOL v6 = (void)v42 == *((void *)&v42 + 1)) : (BOOL v6 = 0), !v6))
    {
      if (*(_DWORD *)v47 == 12)
      {
        llvm::LiveRegUnits::removeRegsNotPreserved(this, *(const unsigned int **)(v47 + 16));
        uint64_t v5 = v47;
      }
      else if ((*(_DWORD *)v47 & 0x1000000) != 0)
      {
        uint64_t v12 = *((void *)this + 1);
        if (*(void *)this) {
          int v13 = (void *)(*(void *)this + 8);
        }
        else {
          int v13 = 0;
        }
        int v14 = (unsigned __int16 *)(v13[6]
                                 + (((unint64_t)*(unsigned int *)(*v13
                                                                       + 24 * (unsigned __int16)*(_DWORD *)(v47 + 4)
                                                                       + 16) >> 3) & 0x1FFFFFFE));
        int v16 = *v14;
        int v15 = v14 + 1;
        int v17 = v16
            + (*(_DWORD *)(*v13 + 24 * (unsigned __int16)*(_DWORD *)(v47 + 4) + 16) & 0xF) * *(_DWORD *)(v47 + 4);
        do
        {
          *(void *)(v12 + 8 * ((unsigned __int16)v17 >> 6)) &= ~(1 << v17);
          int v18 = *v15++;
          v17 += v18;
        }
        while (v18);
      }
      uint64_t v7 = v5 + 32;
      *(void *)&long long v47 = v7;
      uint64_t v8 = *((void *)&v47 + 1);
      if (v7 == *((void *)&v47 + 1))
      {
        uint64_t v35 = *(void *)(v46 + 8);
        if (v35 == *((void *)&v46 + 1))
        {
          uint64_t v9 = v7;
        }
        else
        {
          uint64_t v9 = v7;
          if ((*(_WORD *)(v35 + 44) & 4) != 0)
          {
            do
            {
              uint64_t v9 = *(void *)(v35 + 32);
              uint64_t v38 = *(unsigned int *)(v35 + 40);
              uint64_t v8 = v9 + 32 * v38;
              if (v38)
              {
                *(void *)&long long v47 = *(void *)(v35 + 32);
                *((void *)&v47 + 1) = v9 + 32 * v38;
                *(void *)&long long v46 = v35;
                goto LABEL_17;
              }
              uint64_t v35 = *(void *)(v35 + 8);
            }
            while (v35 != *((void *)&v46 + 1) && (*(_WORD *)(v35 + 44) & 4) != 0);
            *(void *)&long long v47 = v9;
            *((void *)&v47 + 1) = v9 + 32 * v38;
            uint64_t v7 = *((void *)&v47 + 1);
          }
        }
        *(void *)&long long v46 = *((void *)&v46 + 1);
        uint64_t v8 = v7;
      }
      else
      {
        uint64_t v9 = v7;
      }
      while (1)
      {
        do
        {
LABEL_17:
          if ((void)v46 == (void)v48 && (v9 == (void)v49 || v9 == v8 && (void)v49 == *((void *)&v49 + 1))) {
            goto LABEL_7;
          }
          if (!v51) {
            goto LABEL_96;
          }
          if ((*(uint64_t (**)(void *))(*v51 + 48))(v51)) {
            goto LABEL_7;
          }
          uint64_t v8 = *((void *)&v47 + 1);
          uint64_t v9 = v47 + 32;
          *(void *)&long long v47 = v9;
        }
        while (v9 != *((void *)&v47 + 1));
        uint64_t v10 = *(void *)(v46 + 8);
        if (v10 == *((void *)&v46 + 1))
        {
          uint64_t v11 = v9;
LABEL_23:
          *(void *)&long long v46 = *((void *)&v46 + 1);
          uint64_t v8 = v9;
          uint64_t v9 = v11;
        }
        else
        {
          uint64_t v11 = v9;
          if ((*(_WORD *)(v10 + 44) & 4) == 0) {
            goto LABEL_23;
          }
          while (1)
          {
            uint64_t v11 = *(void *)(v10 + 32);
            uint64_t v37 = *(unsigned int *)(v10 + 40);
            uint64_t v8 = v11 + 32 * v37;
            if (v37) {
              break;
            }
            uint64_t v10 = *(void *)(v10 + 8);
            if (v10 == *((void *)&v46 + 1) || (*(_WORD *)(v10 + 44) & 4) == 0)
            {
              *(void *)&long long v47 = v11;
              *((void *)&v47 + 1) = v11 + 32 * v37;
              uint64_t v9 = *((void *)&v47 + 1);
              goto LABEL_23;
            }
          }
          *(void *)&long long v47 = *(void *)(v10 + 32);
          *((void *)&v47 + 1) = v11 + 32 * v37;
          uint64_t v9 = v11;
          *(void *)&long long v46 = v10;
        }
      }
    }
    if (v45 == v44)
    {
      (*(void (**)(void *))(v44[0] + 32))(v44);
    }
    else if (v45)
    {
      (*(void (**)(void))(*v45 + 40))();
    }
    if (v51 == v4)
    {
      (*(void (**)(void *))(v50[0] + 32))(v4);
    }
    else if (v51)
    {
      (*(void (**)(void))(*v51 + 40))();
    }
    if (v61 == v60)
    {
      (*(void (**)(void *))(v60[0] + 32))(v60);
    }
    else if (v61)
    {
      (*(void (**)(void))(*v61 + 40))();
    }
    if (v57 == v56)
    {
      (*(void (**)(void *))(v56[0] + 32))(v56);
    }
    else if (v57)
    {
      (*(void (**)(void))(*v57 + 40))();
    }
    sub_1CC300420((unint64_t)v2, (uint64_t)&v52);
    long long v46 = v52;
    long long v47 = v53;
    long long v48 = v54;
    long long v49 = v55;
    uint64_t v2 = (const llvm::MachineInstr *)v50;
    if (v57)
    {
      if (v57 == v56)
      {
        uint64_t v51 = v50;
        (*(void (**)(void))(*v57 + 24))();
      }
      else
      {
        uint64_t v51 = (void *)(*(uint64_t (**)(void))(*v57 + 16))();
      }
    }
    else
    {
      uint64_t v51 = 0;
    }
    uint64_t v41 = v58;
    long long v43 = v59;
    uint64_t v4 = v44;
    if (v61)
    {
      if (v61 == v60)
      {
        uint64_t v45 = v44;
        (*(void (**)(void))(*v61 + 24))();
      }
      else
      {
        uint64_t v45 = (void *)(*(uint64_t (**)(void))(*v61 + 16))();
      }
    }
    else
    {
      uint64_t v45 = 0;
    }
LABEL_48:
    uint64_t v19 = v46;
    uint64_t v20 = v47;
    if ((void)v46 == v41)
    {
      if ((void)v47 == (void)v43) {
        break;
      }
      if ((void)v47 == *((void *)&v47 + 1) && (void)v43 == *((void *)&v43 + 1)) {
        break;
      }
    }
    if ((*(_DWORD *)v47 & 0x300000FF) == 0 && (*(_DWORD *)v47 & 0x10FFF00) != 0x1000000)
    {
      uint64_t v23 = *((void *)this + 1);
      if (*(void *)this) {
        uint64_t v24 = (void *)(*(void *)this + 8);
      }
      else {
        uint64_t v24 = 0;
      }
      uint64_t v25 = (unsigned __int16 *)(v24[6]
                               + (((unint64_t)*(unsigned int *)(*v24
                                                                     + 24 * (unsigned __int16)*(_DWORD *)(v47 + 4)
                                                                     + 16) >> 3) & 0x1FFFFFFE));
      int v27 = *v25;
      uint64_t v26 = v25 + 1;
      int v28 = v27 + (*(_DWORD *)(*v24 + 24 * (unsigned __int16)*(_DWORD *)(v47 + 4) + 16) & 0xF) * *(_DWORD *)(v47 + 4);
      do
      {
        *(void *)(v23 + 8 * ((unsigned __int16)v28 >> 6)) |= 1 << v28;
        int v29 = *v26++;
        v28 += v29;
      }
      while (v29);
    }
    uint64_t v30 = v20 + 32;
    *(void *)&long long v47 = v30;
    uint64_t v31 = *((void *)&v47 + 1);
    if (v30 != *((void *)&v47 + 1))
    {
      uint64_t v32 = v30;
      goto LABEL_65;
    }
    uint64_t v19 = *(void *)(v19 + 8);
    if (v19 == *((void *)&v46 + 1))
    {
      uint64_t v32 = v30;
LABEL_91:
      *(void *)&long long v46 = *((void *)&v46 + 1);
      uint64_t v31 = v30;
      uint64_t v19 = *((void *)&v46 + 1);
      goto LABEL_65;
    }
    uint64_t v32 = v30;
    if ((*(_WORD *)(v19 + 44) & 4) == 0) {
      goto LABEL_91;
    }
    while (1)
    {
      uint64_t v32 = *(void *)(v19 + 32);
      uint64_t v39 = *(unsigned int *)(v19 + 40);
      uint64_t v31 = v32 + 32 * v39;
      if (v39) {
        break;
      }
      uint64_t v19 = *(void *)(v19 + 8);
      if (v19 == *((void *)&v46 + 1) || (*(_WORD *)(v19 + 44) & 4) == 0)
      {
        *(void *)&long long v47 = v32;
        *((void *)&v47 + 1) = v32 + 32 * v39;
        uint64_t v30 = *((void *)&v47 + 1);
        goto LABEL_91;
      }
    }
    *(void *)&long long v47 = *(void *)(v19 + 32);
    *((void *)&v47 + 1) = v32 + 32 * v39;
LABEL_126:
    *(void *)&long long v46 = v19;
    while (1)
    {
LABEL_65:
      if (v19 == (void)v48 && (v32 == (void)v49 || v32 == v31 && (void)v49 == *((void *)&v49 + 1))) {
        goto LABEL_48;
      }
      if (!v51) {
        break;
      }
      if ((*(uint64_t (**)(void *))(*v51 + 48))(v51)) {
        goto LABEL_48;
      }
      uint64_t v19 = v46;
      uint64_t v32 = v47 + 32;
      *(void *)&long long v47 = v32;
      uint64_t v31 = *((void *)&v47 + 1);
      if (v32 == *((void *)&v47 + 1))
      {
        uint64_t v19 = *(void *)(v46 + 8);
        if (v19 == *((void *)&v46 + 1))
        {
          uint64_t v33 = v32;
        }
        else
        {
          uint64_t v33 = v32;
          if ((*(_WORD *)(v19 + 44) & 4) != 0)
          {
            while (1)
            {
              uint64_t v33 = *(void *)(v19 + 32);
              uint64_t v36 = *(unsigned int *)(v19 + 40);
              uint64_t v31 = v33 + 32 * v36;
              if (v36) {
                break;
              }
              uint64_t v19 = *(void *)(v19 + 8);
              if (v19 == *((void *)&v46 + 1) || (*(_WORD *)(v19 + 44) & 4) == 0)
              {
                *(void *)&long long v47 = v33;
                *((void *)&v47 + 1) = v33 + 32 * v36;
                uint64_t v32 = *((void *)&v47 + 1);
                goto LABEL_71;
              }
            }
            *(void *)&long long v47 = *(void *)(v19 + 32);
            *((void *)&v47 + 1) = v33 + 32 * v36;
            uint64_t v32 = v33;
            goto LABEL_126;
          }
        }
LABEL_71:
        *(void *)&long long v46 = *((void *)&v46 + 1);
        uint64_t v31 = v32;
        uint64_t v32 = v33;
        uint64_t v19 = *((void *)&v46 + 1);
      }
    }
LABEL_96:
    sub_1CB920400();
  }
  if (v45 == v44)
  {
    (*(void (**)(void *))(v44[0] + 32))(v44);
  }
  else if (v45)
  {
    (*(void (**)(void))(*v45 + 40))();
  }
  if (v51 == v50)
  {
    (*(void (**)(void *))(v50[0] + 32))(v50);
  }
  else if (v51)
  {
    (*(void (**)(void))(*v51 + 40))();
  }
  if (v61 == v60)
  {
    (*(void (**)(void *))(v60[0] + 32))(v60);
  }
  else if (v61)
  {
    (*(void (**)(void))(*v61 + 40))();
  }
  uint64_t result = v57;
  if (v57 == v56) {
    return (void *)(*(uint64_t (**)(void *))(v56[0] + 32))(v56);
  }
  if (v57) {
    return (void *)(*(uint64_t (**)(void))(*v57 + 40))();
  }
  return result;
}

void *sub_1CC309F80(void *result, unsigned int a2)
{
  uint64_t v2 = result[1];
  if (*result) {
    uint64_t v3 = (void *)(*result + 8);
  }
  else {
    uint64_t v3 = 0;
  }
  unint64_t v4 = *(unsigned int *)(*v3 + 24 * a2 + 16);
  uint64_t v5 = (unsigned __int16 *)(v3[6] + ((v4 >> 3) & 0x1FFFFFFE));
  int v7 = *v5;
  BOOL v6 = v5 + 1;
  int v8 = v7 + (v4 & 0xF) * a2;
  do
  {
    *(void *)(v2 + 8 * ((unsigned __int16)v8 >> 6)) &= ~(1 << v8);
    int v9 = *v6++;
    v8 += v9;
  }
  while (v9);
  return result;
}

void *llvm::LiveRegUnits::accumulate(llvm::LiveRegUnits *this, const llvm::MachineInstr *a2)
{
  uint64_t v3 = v36;
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  sub_1CC300420((unint64_t)a2, (uint64_t)v36);
  long long v30 = v36[0];
  long long v31 = v36[1];
  long long v32 = v36[2];
  long long v33 = v36[3];
  if (v38)
  {
    if (v38 == v37)
    {
      uint64_t v35 = v34;
      (*(void (**)(void))(*v38 + 24))();
    }
    else
    {
      uint64_t v35 = (void *)(*(uint64_t (**)(void))(*v38 + 16))();
    }
  }
  else
  {
LABEL_54:
    uint64_t v35 = 0;
  }
  long long v26 = *((_OWORD *)v3 + 6);
  long long v27 = *((_OWORD *)v3 + 7);
  uint64_t v3 = v28;
  if (v40)
  {
    if (v40 == v39)
    {
      int v29 = v28;
      (*(void (**)(void))(*v40 + 24))();
    }
    else
    {
      int v29 = (void *)(*(uint64_t (**)(void))(*v40 + 16))();
    }
  }
  else
  {
    int v29 = 0;
  }
LABEL_7:
  uint64_t v4 = v31;
  if ((void)v30 != (void)v26
    || (void)v31 != (void)v27
    && ((void)v31 == *((void *)&v31 + 1) ? (BOOL v21 = (void)v27 == *((void *)&v27 + 1)) : (BOOL v21 = 0), !v21))
  {
    int v5 = *(_DWORD *)v31;
    if (*(_DWORD *)v31 == 12)
    {
      llvm::LiveRegUnits::addRegsInMask(this, *(const unsigned int **)(v31 + 16));
      uint64_t v4 = v31;
    }
    else if ((v5 & 0x1000000) != 0 {
           || ((v6 = v5 & 0x30000000, int v7 = v5 & 0x10FFF00, !v6) ? (v8 = v7 == 0x1000000) : (v8 = 1), !v8))
    }
    {
      uint64_t v9 = *((void *)this + 1);
      if (*(void *)this) {
        uint64_t v10 = (void *)(*(void *)this + 8);
      }
      else {
        uint64_t v10 = 0;
      }
      uint64_t v11 = (unsigned __int16 *)(v10[6]
                               + (((unint64_t)*(unsigned int *)(*v10
                                                                     + 24 * (unsigned __int16)*(_DWORD *)(v31 + 4)
                                                                     + 16) >> 3) & 0x1FFFFFFE));
      int v13 = *v11;
      uint64_t v12 = v11 + 1;
      int v14 = v13 + (*(_DWORD *)(*v10 + 24 * (unsigned __int16)*(_DWORD *)(v31 + 4) + 16) & 0xF) * *(_DWORD *)(v31 + 4);
      do
      {
        *(void *)(v9 + 8 * ((unsigned __int16)v14 >> 6)) |= 1 << v14;
        int v15 = *v12++;
        v14 += v15;
      }
      while (v15);
    }
    uint64_t v16 = v4 + 32;
    *(void *)&long long v31 = v16;
    uint64_t v17 = *((void *)&v31 + 1);
    if (v16 == *((void *)&v31 + 1))
    {
      uint64_t v23 = *(void *)(v30 + 8);
      if (v23 == *((void *)&v30 + 1))
      {
        uint64_t v18 = v16;
      }
      else
      {
        uint64_t v18 = v16;
        if ((*(_WORD *)(v23 + 44) & 4) != 0)
        {
          do
          {
            uint64_t v18 = *(void *)(v23 + 32);
            uint64_t v25 = *(unsigned int *)(v23 + 40);
            uint64_t v17 = v18 + 32 * v25;
            if (v25)
            {
              *(void *)&long long v31 = *(void *)(v23 + 32);
              *((void *)&v31 + 1) = v18 + 32 * v25;
              *(void *)&long long v30 = v23;
              goto LABEL_21;
            }
            uint64_t v23 = *(void *)(v23 + 8);
          }
          while (v23 != *((void *)&v30 + 1) && (*(_WORD *)(v23 + 44) & 4) != 0);
          *(void *)&long long v31 = v18;
          *((void *)&v31 + 1) = v18 + 32 * v25;
          uint64_t v16 = *((void *)&v31 + 1);
        }
      }
      *(void *)&long long v30 = *((void *)&v30 + 1);
      uint64_t v17 = v16;
    }
    else
    {
      uint64_t v18 = v16;
    }
    while (1)
    {
      do
      {
LABEL_21:
        if ((void)v30 == (void)v32 && (v18 == (void)v33 || v18 == v17 && (void)v33 == *((void *)&v33 + 1))) {
          goto LABEL_7;
        }
        if (!v35)
        {
          sub_1CB920400();
          goto LABEL_54;
        }
        if ((*(uint64_t (**)(void *))(*v35 + 48))(v35)) {
          goto LABEL_7;
        }
        uint64_t v17 = *((void *)&v31 + 1);
        uint64_t v18 = v31 + 32;
        *(void *)&long long v31 = v18;
      }
      while (v18 != *((void *)&v31 + 1));
      uint64_t v19 = *(void *)(v30 + 8);
      if (v19 == *((void *)&v30 + 1))
      {
        uint64_t v20 = v18;
LABEL_27:
        *(void *)&long long v30 = *((void *)&v30 + 1);
        uint64_t v17 = v18;
        uint64_t v18 = v20;
      }
      else
      {
        uint64_t v20 = v18;
        if ((*(_WORD *)(v19 + 44) & 4) == 0) {
          goto LABEL_27;
        }
        while (1)
        {
          uint64_t v20 = *(void *)(v19 + 32);
          uint64_t v24 = *(unsigned int *)(v19 + 40);
          uint64_t v17 = v20 + 32 * v24;
          if (v24) {
            break;
          }
          uint64_t v19 = *(void *)(v19 + 8);
          if (v19 == *((void *)&v30 + 1) || (*(_WORD *)(v19 + 44) & 4) == 0)
          {
            *(void *)&long long v31 = v20;
            *((void *)&v31 + 1) = v20 + 32 * v24;
            uint64_t v18 = *((void *)&v31 + 1);
            goto LABEL_27;
          }
        }
        *(void *)&long long v31 = *(void *)(v19 + 32);
        *((void *)&v31 + 1) = v20 + 32 * v24;
        uint64_t v18 = v20;
        *(void *)&long long v30 = v19;
      }
    }
  }
  if (v29 == v28)
  {
    (*(void (**)(void *))(v28[0] + 32))(v28);
  }
  else if (v29)
  {
    (*(void (**)(void))(*v29 + 40))();
  }
  if (v35 == v34)
  {
    (*(void (**)(void *))(v34[0] + 32))(v34);
  }
  else if (v35)
  {
    (*(void (**)(void))(*v35 + 40))();
  }
  if (v40 == v39)
  {
    (*(void (**)(void *))(v39[0] + 32))(v39);
  }
  else if (v40)
  {
    (*(void (**)(void))(*v40 + 40))();
  }
  uint64_t result = v38;
  if (v38 == v37) {
    return (void *)(*(uint64_t (**)(void *))(v37[0] + 32))(v37);
  }
  if (v38) {
    return (void *)(*(uint64_t (**)(void))(*v38 + 40))();
  }
  return result;
}

void llvm::LiveRegUnits::addPristines(llvm::LiveRegUnits *this, const llvm::MachineFunction *a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)a2 + 7);
  if (*(unsigned char *)(v2 + 104))
  {
    uint64_t v4 = (void *)*((void *)this + 1);
    uint64_t v5 = *((unsigned int *)this + 4);
    if (v5)
    {
      uint64_t v6 = 8 * v5;
      while (!*v4)
      {
        ++v4;
        v6 -= 8;
        if (!v6) {
          goto LABEL_6;
        }
      }
      long long v27 = (void *)((char *)this + 8);
      uint64_t v17 = *(void *)this;
      uint64_t v30 = 0x600000000;
      unsigned int v32 = 0;
      uint64_t v28 = v17;
      int v29 = v31;
      sub_1CB8F8DF4((uint64_t)&v29, *(_DWORD *)(v17 + 44), 0);
      sub_1CC30A754(&v28, *((void **)a2 + 5), *((void *)a2 + 7));
      uint64_t v20 = *(unsigned __int16 **)(v2 + 80);
      uint64_t v19 = *(unsigned __int16 **)(v2 + 88);
      while (v20 != v19)
      {
        unsigned int v21 = *v20;
        v20 += 6;
        sub_1CC309F80(&v28, v21);
      }
      if (*((_DWORD *)this + 18) < v32) {
        sub_1CB8F8DF4((uint64_t)v27, v32, 0);
      }
      uint64_t v22 = v30;
      uint64_t v23 = v29;
      if (v30)
      {
        uint64_t v24 = (void *)*v27;
        uint64_t v25 = (uint64_t *)v29;
        do
        {
          uint64_t v26 = *v25++;
          *v24++ |= v26;
          --v22;
        }
        while (v22);
      }
      if (v23 != v31) {
        free(v23);
      }
    }
    else
    {
LABEL_6:
      sub_1CC30A754(this, *((void **)a2 + 5), v2);
      int v7 = *(_DWORD **)(v2 + 80);
      BOOL v8 = *(_DWORD **)(v2 + 88);
      if (v7 != v8)
      {
        uint64_t v9 = *((void *)this + 1);
        uint64_t v10 = (uint64_t *)(*(void *)this + 8);
        if (!*(void *)this) {
          uint64_t v10 = 0;
        }
        uint64_t v11 = *v10;
        uint64_t v12 = v10[6];
        do
        {
          unint64_t v13 = ((unint64_t)*(unsigned int *)(v11 + 24 * (unsigned __int16)*v7 + 16) >> 3) & 0x1FFFFFFE;
          int v14 = *(unsigned __int16 *)(v12 + v13) + (*(_DWORD *)(v11 + 24 * (unsigned __int16)*v7 + 16) & 0xF) * *v7;
          int v15 = (unsigned __int16 *)(v12 + 2 + v13);
          do
          {
            *(void *)(v9 + 8 * ((unsigned __int16)v14 >> 6)) &= ~(1 << v14);
            int v16 = *v15++;
            v14 += v16;
          }
          while (v16);
          v7 += 3;
        }
        while (v7 != v8);
      }
    }
  }
}

unsigned __int16 *sub_1CC30A754(void *a1, void *a2, uint64_t a3)
{
  if (*((unsigned char *)a2 + 144))
  {
    uint64_t result = (unsigned __int16 *)a2[19];
    if (!result) {
      return result;
    }
  }
  else
  {
    uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(*a2 + 16) + 176))(*(void *)(*a2 + 16));
    uint64_t result = (unsigned __int16 *)(*(uint64_t (**)(uint64_t, void))(*(void *)v6 + 32))(v6, *a2);
    if (!result) {
      return result;
    }
  }
  if (*a1) {
    BOOL v8 = (void *)(*a1 + 8);
  }
  else {
    BOOL v8 = 0;
  }
  unsigned __int16 v9 = *result;
  if (*result)
  {
    uint64_t v10 = a1[1];
    uint64_t v11 = *(void *)(a3 + 80);
    uint64_t v12 = *(void *)(a3 + 88);
    do
    {
      if (v11 == v12) {
        goto LABEL_14;
      }
      uint64_t v13 = v11;
      while (v9 != *(_DWORD *)v13)
      {
        v13 += 12;
        if (v13 == v12) {
          goto LABEL_14;
        }
      }
      if (*(unsigned char *)(v13 + 8))
      {
LABEL_14:
        int v14 = (unsigned __int16 *)(v8[6]
                                 + (((unint64_t)*(unsigned int *)(*v8 + 24 * v9 + 16) >> 3) & 0x1FFFFFFE));
        int v16 = *v14;
        int v15 = v14 + 1;
        int v17 = v16 + (*(_DWORD *)(*v8 + 24 * v9 + 16) & 0xF) * v9;
        do
        {
          *(void *)(v10 + 8 * ((unsigned __int16)v17 >> 6)) |= 1 << v17;
          int v18 = *v15++;
          v17 += v18;
        }
        while (v18);
      }
      int v19 = result[1];
      ++result;
      unsigned __int16 v9 = v19;
    }
    while (v19);
  }
  return result;
}

uint64_t llvm::LiveRegUnits::addLiveOuts(llvm::LiveRegUnits *this, const llvm::MachineBasicBlock *a2)
{
  uint64_t v4 = (const llvm::MachineFunction *)*((void *)a2 + 4);
  llvm::LiveRegUnits::addPristines(this, v4);
  uint64_t v5 = *((void *)a2 + 11);
  for (uint64_t i = *((void *)a2 + 12); v5 != i; v5 += 8)
  {
    int v7 = *(unsigned __int16 **)(*(void *)v5 + 152);
    BOOL v8 = *(unsigned __int16 **)(*(void *)v5 + 160);
    if (v8 != v7)
    {
      if (*(void *)this) {
        unsigned __int16 v9 = (uint64_t *)(*(void *)this + 8);
      }
      else {
        unsigned __int16 v9 = 0;
      }
      uint64_t v10 = *v9;
      uint64_t v11 = v9[6];
      uint64_t v12 = v9[7];
      do
      {
        uint64_t v13 = *((void *)v7 + 1);
        uint64_t v14 = v10 + 24 * *v7;
        unint64_t v15 = *(unsigned int *)(v14 + 16);
        __int16 v16 = v15 & 0xF;
        uint64_t v17 = (v15 >> 3) & 0x1FFFFFFE;
        unsigned __int16 v18 = *(_WORD *)(v11 + v17) + v16 * *v7;
        int v19 = (void *)(v12 + 8 * *(unsigned __int16 *)(v14 + 20));
        uint64_t v20 = (unsigned __int16 *)(v11 + 2 + v17);
        do
        {
          if (*v19) {
            BOOL v21 = (*v19 & v13) == 0;
          }
          else {
            BOOL v21 = 0;
          }
          if (!v21) {
            *(void *)(*((void *)this + 1) + 8 * (v18 >> 6)) |= 1 << v18;
          }
          ++v19;
          int v22 = *v20++;
          v18 += v22;
        }
        while (v22);
        v7 += 8;
      }
      while (v7 != v8);
    }
  }
  uint64_t result = *((void *)a2 + 6) & 0xFFFFFFFFFFFFFFF8;
  if ((const llvm::MachineBasicBlock *)((char *)a2 + 48) != (const llvm::MachineBasicBlock *)result)
  {
    if (result && (*(unsigned char *)result & 4) != 0)
    {
      __int16 v24 = *(_WORD *)(result + 44);
    }
    else
    {
      while (1)
      {
        __int16 v24 = *(_WORD *)(result + 44);
        if ((v24 & 4) == 0) {
          break;
        }
        uint64_t result = *(void *)result & 0xFFFFFFFFFFFFFFF8;
      }
    }
    int v25 = v24 & 0xC;
    int v26 = v24 & 4;
    if (v25) {
      BOOL v27 = v26 == 0;
    }
    else {
      BOOL v27 = 0;
    }
    if (v27)
    {
      uint64_t result = llvm::MachineInstr::hasPropertyInBundle(result, 32, 1);
      if ((result & 1) == 0) {
        return result;
      }
    }
    else if ((*(unsigned char *)(*(void *)(result + 16) + 8) & 0x20) == 0)
    {
      return result;
    }
    uint64_t v28 = *((void *)v4 + 7);
    if (*(unsigned char *)(v28 + 104))
    {
      int v29 = (void *)*((void *)v4 + 5);
      return (uint64_t)sub_1CC30A754(this, v29, v28);
    }
  }
  return result;
}

void llvm::LiveRegUnits::addLiveIns(llvm::LiveRegUnits *this, const llvm::MachineFunction **a2)
{
  llvm::LiveRegUnits::addPristines(this, a2[4]);
  uint64_t v4 = (unsigned __int16 *)a2[19];
  uint64_t v5 = (unsigned __int16 *)a2[20];
  if (v5 != v4)
  {
    if (*(void *)this) {
      uint64_t v6 = (uint64_t *)(*(void *)this + 8);
    }
    else {
      uint64_t v6 = 0;
    }
    uint64_t v7 = *v6;
    uint64_t v8 = v6[6];
    uint64_t v9 = v6[7];
    do
    {
      uint64_t v10 = *((void *)v4 + 1);
      uint64_t v11 = v7 + 24 * *v4;
      unint64_t v12 = *(unsigned int *)(v11 + 16);
      __int16 v13 = v12 & 0xF;
      uint64_t v14 = (v12 >> 3) & 0x1FFFFFFE;
      unsigned __int16 v15 = *(_WORD *)(v8 + v14) + v13 * *v4;
      __int16 v16 = (void *)(v9 + 8 * *(unsigned __int16 *)(v11 + 20));
      uint64_t v17 = (unsigned __int16 *)(v8 + 2 + v14);
      do
      {
        if (*v16) {
          BOOL v18 = (*v16 & v10) == 0;
        }
        else {
          BOOL v18 = 0;
        }
        if (!v18) {
          *(void *)(*((void *)this + 1) + 8 * (v15 >> 6)) |= 1 << v15;
        }
        ++v16;
        int v19 = *v17++;
        v15 += v19;
      }
      while (v19);
      v4 += 8;
    }
    while (v4 != v5);
  }
}

void sub_1CC30AB08(uint64_t a1)
{
}

void llvm::LiveStacks::releaseMemory(llvm::LiveStacks *this)
{
  uint64_t v2 = *((unsigned int *)this + 82);
  if (v2)
  {
    uint64_t v11 = (uint64_t *)*((void *)this + 40);
    uint64_t v12 = 16 * v2;
    do
    {
      uint64_t v13 = *v11;
      v11 += 2;
      MEMORY[0x1D25D9CD0](v13, 8);
      v12 -= 16;
    }
    while (v12);
  }
  *((_DWORD *)this + 82) = 0;
  uint64_t v3 = *((unsigned int *)this + 70);
  if (v3)
  {
    *((void *)this + 42) = 0;
    uint64_t v4 = (void *)*((void *)this + 34);
    uint64_t v5 = *v4 + 4096;
    *((void *)this + 32) = *v4;
    *((void *)this + 33) = v5;
    if (v3 != 1)
    {
      uint64_t v6 = v4 + 1;
      uint64_t v7 = 8 * v3 - 8;
      do
      {
        uint64_t v8 = *v6++;
        MEMORY[0x1D25D9CD0](v8, 8);
        v7 -= 8;
      }
      while (v7);
    }
    *((_DWORD *)this + 70) = 1;
  }
  if (*((void *)this + 47))
  {
    sub_1CC30B700(*((void **)this + 46));
    *((void *)this + 46) = 0;
    uint64_t v9 = *((void *)this + 45);
    if (v9)
    {
      for (uint64_t i = 0; i != v9; ++i)
        *(void *)(*((void *)this + 44) + 8 * i) = 0;
    }
    *((void *)this + 47) = 0;
  }
  sub_1CD40B1BC(*((void **)this + 50));
  *((void *)this + 50) = 0;
  *((void *)this + 51) = 0;
  *((void *)this + 49) = (char *)this + 400;
}

uint64_t llvm::LiveStacks::runOnMachineFunction(llvm::LiveStacks *this, llvm::MachineFunction *a2)
{
  *((void *)this + 31) = (*(uint64_t (**)(void))(**((void **)a2 + 2) + 176))(*((void *)a2 + 2));
  unsigned int v138 = this;
  uint64_t v4 = (uint64_t *)*((void *)this + 1);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_149:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::SlotIndexes::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_149;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::SlotIndexes::ID);
  uint64_t v11 = v8;
  int v142 = 0;
  v140 = 0;
  uint64_t v141 = 0;
  uint64_t v12 = *((void *)a2 + 7);
  uint64_t v13 = -858993459 * ((*(void *)(v12 + 16) - *(void *)(v12 + 8)) >> 3);
  if (v13)
  {
    uint64_t v76 = v8;
    unsigned __int16 v15 = (char *)operator new(8 * v13);
    bzero(v15, 8 * v13);
    uint64_t v77 = &v15[8 * v13];
    uint64_t v78 = -858993459 * ((*(void *)(v12 + 16) - *(void *)(v12 + 8)) >> 3);
    if (v78)
    {
      uint64_t v79 = 3 * v78;
      uint64_t v80 = 48 * v78;
      int v81 = (char *)operator new(48 * v78);
      __int16 v16 = v81;
      uint64_t v82 = 0;
      uint64_t v17 = &v81[16 * v79];
      do
      {
        uint64_t v83 = &v81[v82];
        *(void *)uint64_t v83 = &v81[v82 + 16];
        *((void *)v83 + 1) = 0x400000000;
        v82 += 48;
      }
      while (v80 != v82);
    }
    else
    {
      __int16 v16 = 0;
      uint64_t v17 = 0;
    }
    uint64_t v11 = v76;
    uint64_t v14 = v77;
  }
  else
  {
    uint64_t v14 = 0;
    unsigned __int16 v15 = 0;
    __int16 v16 = 0;
    uint64_t v17 = 0;
  }
  BOOL v18 = (char *)a2 + 320;
  int v19 = (char *)*((void *)a2 + 41);
  if (v19 == (char *)a2 + 320)
  {
    long long v53 = 0;
    uint64_t v51 = 0;
    int v52 = 0;
    long long v54 = 0;
    goto LABEL_50;
  }
  uint64_t v10 = 48;
  uint64_t v9 = 8642560;
  do
  {
    for (unint64_t i = *((void *)v19 + 7); (char *)i != v19 + 48; unint64_t i = *(void *)(i + 8))
    {
      uint64_t v21 = *(unsigned int *)(i + 40);
      if (!v21) {
        goto LABEL_15;
      }
      uint64_t v22 = *(void *)(i + 32);
      uint64_t v23 = v22 + 32 * v21;
      do
      {
        if (*(unsigned char *)v22 != 5) {
          goto LABEL_13;
        }
        int v24 = *(_DWORD *)(v22 + 16);
        if (!*(unsigned char *)(*(void *)(v12 + 8) + 40 * (*(_DWORD *)(v12 + 32) + v24) + 18)) {
          goto LABEL_13;
        }
        int v25 = (int *)(i + 48);
        unint64_t v26 = *(void *)(i + 48);
        if (v26 < 8) {
          goto LABEL_103;
        }
        BOOL v27 = (int *)(v26 & 0xFFFFFFFFFFFFFFF8);
        uint64_t v28 = *(void *)(i + 48) & 7;
        if (v28)
        {
          if (v28 != 3) {
            goto LABEL_103;
          }
          if (!v27) {
            goto LABEL_103;
          }
          uint64_t v102 = *v27;
          unsigned int v100 = v27 + 2;
          uint64_t v101 = v102;
          if (!v102) {
            goto LABEL_103;
          }
          int v29 = &v100[2 * v101];
          int v25 = v100;
        }
        else
        {
          int v29 = (int *)(i + 56);
          *(void *)(i + 48) = v27;
        }
        uint64_t v30 = 0;
        do
        {
          uint64_t v31 = **(void **)v25;
          if ((v31 & 4) != 0)
          {
            unint64_t v32 = v31 & 0xFFFFFFFFFFFFFFF8;
            if (v32)
            {
              if (*(_DWORD *)(v32 + 8) == 4 && *(_DWORD *)(v32 + 16) == v24) {
                uint64_t v30 = *(uint64_t **)v25;
              }
            }
          }
          v25 += 2;
        }
        while (v25 != v29);
        if (!v30)
        {
          int v24 = *(_DWORD *)(v22 + 16);
LABEL_103:
          int v139 = v24;
LABEL_104:
          v135 = v14;
          uint64_t v137 = v11;
          sub_1CD51DE74((uint64_t)v143, (uint64_t)&v140, &v139);
          uint64_t v9 = 8642560;
          uint64_t v10 = 48;
          uint64_t v14 = v135;
          uint64_t v11 = v137;
          goto LABEL_13;
        }
        __int16 v33 = *(_WORD *)(i + 44);
        unint64_t v34 = i;
        if ((v33 & 4) != 0)
        {
          do
            unint64_t v34 = *(void *)v34 & 0xFFFFFFFFFFFFFFF8;
          while ((*(_WORD *)(v34 + 44) & 4) != 0);
        }
        unint64_t v35 = i;
        if ((v33 & 8) != 0)
        {
          do
            unint64_t v35 = *(void *)(v35 + 8);
          while ((*(_WORD *)(v35 + 44) & 8) != 0);
        }
        unint64_t v36 = *(void *)(v35 + 8);
        if (v34 != v36)
        {
          while (1)
          {
            unsigned int v37 = **(unsigned __int16 **)(v34 + 16);
            BOOL v38 = v37 > 0x17;
            int v39 = (1 << v37) & 0x83E000;
            if (v38 || v39 == 0) {
              break;
            }
            unint64_t v34 = *(void *)(v34 + 8);
            if (v34 == v36)
            {
              unint64_t v34 = v36;
              break;
            }
          }
        }
        uint64_t v41 = *(void *)(v11 + 368);
        uint64_t v42 = *(unsigned int *)(v11 + 384);
        if (!v42) {
          goto LABEL_115;
        }
        LODWORD(v43) = ((v34 >> 4) ^ (v34 >> 9)) & (v42 - 1);
        BOOL v44 = (uint64_t *)(v41 + 16 * v43);
        uint64_t v45 = *v44;
        if (v34 != *v44)
        {
          int v111 = 1;
          while (v45 != -4096)
          {
            int v112 = v43 + v111++;
            uint64_t v43 = v112 & (v42 - 1);
            uint64_t v45 = *(void *)(v41 + 16 * v43);
            if (v34 == v45)
            {
              BOOL v44 = (uint64_t *)(v41 + 16 * v43);
              goto LABEL_42;
            }
          }
LABEL_115:
          BOOL v44 = (uint64_t *)(v41 + 16 * v42);
        }
LABEL_42:
        unint64_t v46 = v44[1] & 0xFFFFFFFFFFFFFFF8 | 4;
        __int16 v47 = *((_WORD *)v30 + 16);
        if ((v47 & 2) != 0)
        {
          int v48 = *(_DWORD *)(v22 + 16);
          if (*(void *)&v15[8 * v48] >= 8uLL)
          {
            int v139 = *(_DWORD *)(v22 + 16);
            goto LABEL_104;
          }
          *(void *)&v15[8 * v48] = v46;
        }
        if (v47)
        {
          long long v49 = &v16[48 * *(int *)(v22 + 16)];
          unint64_t v50 = *((unsigned int *)v49 + 2);
          if (v50 >= *((unsigned int *)v49 + 3)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)v49 + 8 * v50) = v46;
          ++*((_DWORD *)v49 + 2);
        }
LABEL_13:
        v22 += 32;
      }
      while (v22 != v23);
      if (i)
      {
LABEL_15:
        if ((*(unsigned char *)i & 4) == 0) {
          goto LABEL_16;
        }
      }
      else
      {
LABEL_16:
        while ((*(_WORD *)(i + 44) & 8) != 0)
          unint64_t i = *(void *)(i + 8);
      }
    }
    int v19 = (char *)*((void *)v19 + 1);
  }
  while (v19 != v18);
  uint64_t v51 = v140;
  int v52 = v142;
  long long v53 = &v140[v142];
  if (v141)
  {
    if (v142)
    {
      uint64_t v134 = 0;
      while ((v140[v134] - 0x7FFFFFFF) <= 1)
      {
        if (v142 == ++v134) {
          goto LABEL_49;
        }
      }
      long long v54 = &v140[v134];
    }
    else
    {
      long long v54 = v140;
    }
  }
  else
  {
LABEL_49:
    long long v54 = &v140[v142];
  }
LABEL_50:
  long long v55 = &v51[v52];
  while (v54 != v55)
  {
    uint64_t v132 = *v54;
    uint64_t v131 = v54 + 1;
    *(void *)&v15[8 * v132] = 0;
    *(_DWORD *)&v16[48 * (int)v132 + 8] = 0;
    while (v131 != v53)
    {
      int v133 = *v131++;
      if ((v133 - 0x7FFFFFFF) >= 2)
      {
        long long v54 = v131 - 1;
        goto LABEL_155;
      }
    }
    long long v54 = v53;
LABEL_155:
    ;
  }
  if (((v14 - v15) & 0x7FFFFFFF8) != 0)
  {
    uint64_t v59 = 0;
    uint64_t v60 = ((unint64_t)(v14 - v15) >> 3);
    do
    {
      int v61 = &v16[48 * v59];
      unsigned int v64 = *((_DWORD *)v61 + 2);
      uint64_t v62 = v61 + 8;
      uint64_t v63 = v64;
      if (v64)
      {
        uint64_t v103 = *(void *)&v15[8 * v59];
        unsigned int v104 = (v103 >> 1) & 3;
        unint64_t v105 = v103 & 0xFFFFFFFFFFFFFFF8;
        if (v104) {
          unint64_t v106 = v105 | (2 * (v104 - 1));
        }
        else {
          unint64_t v106 = *(void *)v105 | 6;
        }
        if (v106 >= 8 && (uint64_t v107 = *(void *)((v106 & 0xFFFFFFFFFFFFFFF8) + 16)) != 0)
        {
          int32x2_t v108 = (uint64_t *)(v107 + 24);
        }
        else
        {
          uint64_t v123 = *(unsigned int *)(v11 + 544);
          if (v123)
          {
            unsigned int v124 = *(_DWORD *)((v106 & 0xFFFFFFFFFFFFFFF8) + 24) | (v106 >> 1) & 3;
            uint64_t v125 = *(void **)(v11 + 536);
            unint64_t v126 = *(unsigned int *)(v11 + 544);
            do
            {
              unint64_t v127 = v126 >> 1;
              v128 = &v125[2 * (v126 >> 1)];
              uint64_t v130 = *v128;
              uint64_t v129 = v128 + 2;
              uint64_t v9 = (v130 >> 1) & 3 | *(_DWORD *)((v130 & 0xFFFFFFFFFFFFFFF8) + 24);
              uint64_t v10 = ~(v126 >> 1);
              v126 += v10;
              if (v9 < v124) {
                uint64_t v125 = v129;
              }
              else {
                unint64_t v126 = v127;
              }
            }
            while (v126);
            if (v125 == (void *)(*(void *)(v11 + 536) + 16 * v123)
              || ((*v125 >> 1) & 3 | *(_DWORD *)((*v125 & 0xFFFFFFFFFFFFFFF8) + 24)) > v124)
            {
              v125 -= 2;
            }
          }
          else
          {
            uint64_t v125 = *(void **)(v11 + 536);
          }
          int32x2_t v108 = v125 + 1;
        }
        uint64_t v109 = *v108;
        uint64_t v70 = *(void **)&v16[48 * v59];
        uint64_t v110 = &v70[v63];
        while (1)
        {
          unsigned int v65 = (*v70 >> 1) & 3;
          unint64_t v66 = *v70 & 0xFFFFFFFFFFFFFFF8;
          unint64_t v67 = v65 ? v66 | (2 * (v65 - 1)) : *(void *)v66 | 6;
          if (v67 >= 8 && (uint64_t v68 = *(void *)((v67 & 0xFFFFFFFFFFFFFFF8) + 16)) != 0)
          {
            uint64_t v69 = (void *)(v68 + 24);
          }
          else
          {
            uint64_t v113 = *(unsigned int *)(v11 + 544);
            if (v113)
            {
              unsigned int v114 = *(_DWORD *)((v67 & 0xFFFFFFFFFFFFFFF8) + 24) | (v67 >> 1) & 3;
              int v74 = *(void **)(v11 + 536);
              unint64_t v73 = *(unsigned int *)(v11 + 544);
              do
              {
                uint64_t v9 = v73 >> 1;
                int v71 = &v74[2 * (v73 >> 1)];
                uint64_t v72 = *v71;
                uint64_t v10 = (uint64_t)(v71 + 2);
                v73 += ~(v73 >> 1);
                if (((v72 >> 1) & 3 | *(_DWORD *)((v72 & 0xFFFFFFFFFFFFFFF8) + 24)) < v114) {
                  int v74 = (void *)v10;
                }
                else {
                  unint64_t v73 = v9;
                }
              }
              while (v73);
              if (v74 == (void *)(*(void *)(v11 + 536) + 16 * v113)
                || ((*v74 >> 1) & 3 | *(_DWORD *)((*v74 & 0xFFFFFFFFFFFFFFF8) + 24)) > v114)
              {
                v74 -= 2;
              }
            }
            else
            {
              int v74 = *(void **)(v11 + 536);
            }
            uint64_t v69 = v74 + 1;
          }
          if (*v69 != v109) {
            break;
          }
          if (++v70 == v110) {
            goto LABEL_62;
          }
        }
        *(void *)&v15[8 * v59] = 0;
        *uint64_t v62 = 0;
      }
LABEL_62:
      ++v59;
    }
    while (v59 != v60);
    uint64_t v75 = 0;
    do
    {
      if (*(void *)&v15[8 * v75] >= 8uLL)
      {
        uint64_t v136 = v11;
        uint64_t v84 = (uint64_t)v138 + 256;
        Interval = (unint64_t *)llvm::LiveStacks::getOrCreateInterval((uint64_t)v138, v75, 0);
        uint64_t v86 = (uint64_t)Interval;
        uint64_t v87 = *(void *)&v15[8 * v75];
        if (Interval[12])
        {
          v143[0] = Interval;
          sub_1CC2F6AE4((uint64_t *)v143, v87, v84, 0);
        }
        else
        {
          v143[0] = Interval;
          sub_1CC2F6F18(v143, v87, v84, 0);
        }
        uint64_t v88 = *(void *)&v15[8 * v75];
        unsigned int v89 = (v88 >> 1) & 3;
        unint64_t v90 = v88 & 0xFFFFFFFFFFFFFFF8;
        uint64_t v11 = v136;
        if (v89) {
          unint64_t v91 = v90 | (2 * (v89 - 1));
        }
        else {
          unint64_t v91 = *(void *)v90 | 6;
        }
        if (v91 >= 8 && (uint64_t v92 = *(void *)((v91 & 0xFFFFFFFFFFFFFFF8) + 16)) != 0)
        {
          unsigned int v93 = (void *)(v92 + 24);
        }
        else
        {
          uint64_t v115 = *(unsigned int *)(v136 + 544);
          if (v115)
          {
            unsigned int v116 = *(_DWORD *)((v91 & 0xFFFFFFFFFFFFFFF8) + 24) | (v91 >> 1) & 3;
            uint64_t v117 = *(void **)(v136 + 536);
            unint64_t v118 = *(unsigned int *)(v136 + 544);
            do
            {
              unint64_t v119 = v118 >> 1;
              unint64_t v120 = &v117[2 * (v118 >> 1)];
              uint64_t v122 = *v120;
              uint64_t v121 = v120 + 2;
              v118 += ~(v118 >> 1);
              if (((v122 >> 1) & 3 | *(_DWORD *)((v122 & 0xFFFFFFFFFFFFFFF8) + 24)) < v116) {
                uint64_t v117 = v121;
              }
              else {
                unint64_t v118 = v119;
              }
            }
            while (v118);
            if (v117 == (void *)(*(void *)(v136 + 536) + 16 * v115)
              || ((*v117 >> 1) & 3 | *(_DWORD *)((*v117 & 0xFFFFFFFFFFFFFFF8) + 24)) > v116)
            {
              v117 -= 2;
            }
          }
          else
          {
            uint64_t v117 = *(void **)(v136 + 536);
          }
          unsigned int v93 = v117 + 1;
        }
        uint64_t v94 = &v16[48 * v75];
        uint64_t v95 = *((unsigned int *)v94 + 2);
        if (v95)
        {
          uint64_t v96 = *(void *)(*(void *)(v136 + 392) + 16 * *(unsigned int *)(*v93 + 24));
          uint64_t v97 = *(uint64_t **)v94;
          uint64_t v98 = 8 * v95;
          do
          {
            uint64_t v99 = *v97++;
            llvm::LiveRange::extendInBlock(v86, v96, v99);
            uint64_t v11 = v136;
            v98 -= 8;
          }
          while (v98);
        }
      }
      ++v75;
    }
    while (v75 != v60);
  }
  if (v16)
  {
    while (v17 != v16)
    {
      uint64_t v57 = (char *)*((void *)v17 - 6);
      v17 -= 48;
      uint64_t v56 = v57;
      if (v17 + 16 != v57) {
        free(v56);
      }
    }
    operator delete(v16);
  }
  if (v15) {
    operator delete(v15);
  }
  MEMORY[0x1D25D9CD0](v140, 4, v9, v10);
  return 1;
}

uint64_t *llvm::LiveStacks::getOrCreateInterval(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unsigned int v16 = a2;
  uint64_t v5 = (void *)(a1 + 352);
  uint64_t v6 = sub_1CC2CD930((void *)(a1 + 352), (int *)&v16);
  if (v6)
  {
    uint64_t v7 = v6;
    unint64_t v13 = (unint64_t)&v16;
    uint64_t v9 = sub_1CD51DF60((uint64_t **)(a1 + 392), (int *)&v16, (uint64_t)&std::piecewise_construct, (_DWORD **)&v13);
    CommonSubClass = (uint64_t *)llvm::TargetRegisterInfo::getCommonSubClass(*(void *)(a1 + 248), (uint64_t)v9[5], a3);
    unint64_t v13 = (unint64_t)&v16;
    sub_1CD51DF60((uint64_t **)(a1 + 392), (int *)&v16, (uint64_t)&std::piecewise_construct, (_DWORD **)&v13)[5] = CommonSubClass;
  }
  else
  {
    int v11 = 0;
    unsigned int v12 = v16 + 0x40000000;
    unint64_t v13 = (unint64_t)&v12;
    uint64_t v14 = &v11;
    unsigned __int16 v15 = &v16;
    uint64_t v7 = sub_1CC30B840(v5, (uint64_t)&std::piecewise_construct, (int **)&v15, (_DWORD **)&v13);
    unint64_t v13 = v16;
    uint64_t v14 = (int *)a3;
    sub_1CC30BDF0((uint64_t **)(a1 + 392), (int *)&v13, (uint64_t)&v13);
  }
  return v7 + 3;
}

void sub_1CC30B700(void *__p)
{
  if (__p)
  {
    unsigned int v1 = __p;
    do
    {
      uint64_t v2 = (void *)*v1;
      uint64_t v3 = v1[16];
      if (v3)
      {
        do
        {
          uint64_t v7 = *(void *)(v3 + 96);
          uint64_t v8 = *(void *)(v3 + 104);
          *(void *)(v3 + 96) = 0;
          if (v7)
          {
            unsigned __int16 v15 = v2;
            uint64_t v13 = v7;
            sub_1CB833A08(v7, *(void **)(v7 + 8));
            uint64_t v14 = v13;
            uint64_t v2 = v15;
            MEMORY[0x1D25D9CE0](v14, 0x1020C4062D53EE8);
          }
          uint64_t v9 = *(void **)(v3 + 64);
          if (v9 != (void *)(v3 + 80)) {
            free(v9);
          }
          if (*(void *)v3 != v3 + 16) {
            free(*(void **)v3);
          }
          uint64_t v3 = v8;
        }
        while (v8);
      }
      uint64_t v4 = v1[15];
      v1[15] = 0;
      v1[16] = 0;
      if (v4)
      {
        uint64_t v10 = v2;
        uint64_t v11 = v4;
        sub_1CB833A08(v4, *(void **)(v4 + 8));
        uint64_t v12 = v11;
        uint64_t v2 = v10;
        MEMORY[0x1D25D9CE0](v12, 0x1020C4062D53EE8);
      }
      uint64_t v5 = (void *)v1[11];
      if (v5 != v1 + 13) {
        free(v5);
      }
      uint64_t v6 = (void *)v1[3];
      if (v6 != v1 + 5) {
        free(v6);
      }
      operator delete(v1);
      unsigned int v1 = v2;
    }
    while (v2);
  }
}

uint64_t *sub_1CC30B840(void *a1, uint64_t a2, int **a3, _DWORD **a4)
{
  uint64_t v7 = a1 + 2;
  uint64_t v8 = operator new(0x90uLL);
  unsigned int v16 = v7;
  *(void *)uint64_t v8 = 0;
  uint64_t v9 = *a4;
  uint64_t v10 = a4[1];
  uint64_t v11 = **a3;
  v8[4] = v11;
  LODWORD(v9) = *v9;
  int v12 = *v10;
  *((void *)v8 + 3) = v8 + 10;
  *((void *)v8 + 4) = 0x200000000;
  *((void *)v8 + 11) = v8 + 26;
  *((void *)v8 + 12) = 0x200000000;
  *((void *)v8 + 15) = 0;
  *((void *)v8 + 16) = 0;
  v8[34] = v9;
  v8[35] = v12;
  char v17 = 1;
  *((void *)v8 + 1) = v11;
  uint64_t result = sub_1CC30B924(a1, (uint64_t)v8);
  if ((v14 & 1) == 0)
  {
    unsigned __int16 v15 = result;
    sub_1CC30BCA8((uint64_t)&v16, v8);
    return v15;
  }
  return result;
}

uint64_t *sub_1CC30B924(void *a1, uint64_t a2)
{
  uint64_t v2 = (void *)a2;
  uint64_t v5 = (_DWORD *)(a2 + 16);
  unint64_t v4 = *(int *)(a2 + 16);
  *((void *)v5 - 1) = v4;
  uint64_t v6 = sub_1CC30B97C((uint64_t)a1, v4, v5);
  if (v6) {
    return v6;
  }
  sub_1CBF4DD88(a1, v2);
  return v2;
}

uint64_t *sub_1CC30B97C(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  unint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    uint8x8_t v5 = (uint8x8_t)vcnt_s8((int8x8_t)v4);
    v5.i16[0] = vaddlv_u8(v5);
    if (v5.u32[0] > 1uLL)
    {
      unint64_t v6 = a2 % v4;
      if (v4 > a2) {
        unint64_t v6 = a2;
      }
    }
    else
    {
      unint64_t v6 = (v4 - 1) & a2;
    }
    uint64_t v7 = *(uint64_t ***)(*(void *)a1 + 8 * v6);
    if (v7)
    {
      for (uint64_t result = *v7; result; uint64_t result = (uint64_t *)*result)
      {
        unint64_t v9 = result[1];
        if (v9 == a2)
        {
          if (*((_DWORD *)result + 4) == *a3) {
            return result;
          }
        }
        else
        {
          if (v5.u32[0] > 1uLL)
          {
            if (v9 >= v4) {
              v9 %= v4;
            }
          }
          else
          {
            v9 &= v4 - 1;
          }
          if (v9 != v6) {
            break;
          }
        }
      }
    }
  }
  float v10 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v11 = *(float *)(a1 + 32);
  if (!v4 || (float)(v11 * (float)v4) < v10)
  {
    BOOL v12 = 1;
    if (v4 >= 3) {
      BOOL v12 = (v4 & (v4 - 1)) != 0;
    }
    unint64_t v13 = v12 | (2 * v4);
    unint64_t v14 = vcvtps_u32_f32(v10 / v11);
    if (v13 <= v14) {
      size_t prime = v14;
    }
    else {
      size_t prime = v13;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v4 = *(void *)(a1 + 8);
    }
    if (prime > v4) {
      goto LABEL_39;
    }
    if (prime < v4)
    {
      unint64_t v16 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v4 < 3 || (uint8x8_t v17 = (uint8x8_t)vcnt_s8((int8x8_t)v4), v17.i16[0] = vaddlv_u8(v17), v17.u32[0] > 1uLL))
      {
        unint64_t v16 = std::__next_prime(v16);
      }
      else
      {
        uint64_t v18 = 1 << -(char)__clz(v16 - 1);
        if (v16 >= 2) {
          unint64_t v16 = v18;
        }
      }
      if (prime <= v16) {
        size_t prime = v16;
      }
      if (prime < v4) {
LABEL_39:
      }
        sub_1CC30BB48(a1, prime);
    }
  }
  return 0;
}

void sub_1CC30BB48(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      sub_1CB833614();
    }
    unint64_t v4 = operator new(8 * a2);
    uint8x8_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] <= 1uLL)
      {
        v8 &= a2 - 1;
      }
      else if (v8 >= a2)
      {
        v8 %= a2;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      float v10 = (void *)*v7;
      if (*v7)
      {
        while (1)
        {
          unint64_t v11 = v10[1];
          if (v9.u32[0] <= 1uLL)
          {
            v11 &= a2 - 1;
          }
          else if (v11 >= a2)
          {
            v11 %= a2;
          }
          if (v11 == v8) {
            goto LABEL_22;
          }
          if (*(void *)(*(void *)a1 + 8 * v11)) {
            break;
          }
          *(void *)(*(void *)a1 + 8 * v11) = v7;
LABEL_18:
          uint64_t v7 = v10;
          float v10 = (void *)*v10;
          unint64_t v8 = v11;
          if (!v10) {
            return;
          }
        }
        *uint64_t v7 = *v10;
        *float v10 = **(void **)(*(void *)a1 + 8 * v11);
        **(void **)(*(void *)a1 + 8 * v11) = v10;
        float v10 = v7;
LABEL_22:
        unint64_t v11 = v8;
        goto LABEL_18;
      }
    }
  }
  else
  {
    BOOL v12 = *(void **)a1;
    *(void *)a1 = 0;
    if (v12) {
      operator delete(v12);
    }
    *(void *)(a1 + 8) = 0;
  }
}

void sub_1CC30BCA8(uint64_t a1, void *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v3 = __p[16];
    if (v3)
    {
      do
      {
        uint64_t v9 = *(void *)(v3 + 96);
        uint64_t v10 = *(void *)(v3 + 104);
        *(void *)(v3 + 96) = 0;
        if (v9)
        {
          uint64_t v12 = v3;
          uint64_t v7 = v9;
          sub_1CB833A08(v9, *(void **)(v9 + 8));
          uint64_t v8 = v7;
          uint64_t v3 = v12;
          MEMORY[0x1D25D9CE0](v8, 0x1020C4062D53EE8);
        }
        unint64_t v11 = *(void **)(v3 + 64);
        if (v11 != (void *)(v3 + 80)) {
          free(v11);
        }
        if (*(void *)v3 != v3 + 16) {
          free(*(void **)v3);
        }
        uint64_t v3 = v10;
      }
      while (v10);
    }
    uint64_t v4 = __p[15];
    __p[15] = 0;
    __p[16] = 0;
    if (v4)
    {
      sub_1CB833A08(v4, *(void **)(v4 + 8));
      MEMORY[0x1D25D9CE0](v4, 0x1020C4062D53EE8);
    }
    uint8x8_t v5 = (void *)__p[11];
    if (v5 != __p + 13) {
      free(v5);
    }
    uint64_t v6 = (void *)__p[3];
    if (v6 != __p + 5) {
      free(v6);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t **sub_1CC30BDF0(uint64_t **a1, int *a2, uint64_t a3)
{
  uint64_t v6 = a1 + 1;
  uint8x8_t v5 = a1[1];
  if (v5)
  {
    int v7 = *a2;
    do
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 8);
        if (v7 >= v9) {
          break;
        }
        uint8x8_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_7;
        }
      }
      if (v9 >= v7) {
        return v8;
      }
      uint8x8_t v5 = v8[1];
    }
    while (v5);
    uint64_t v6 = v8 + 1;
  }
  else
  {
    uint64_t v8 = a1 + 1;
  }
LABEL_7:
  uint64_t v10 = (uint64_t *)v8;
  uint64_t v8 = (uint64_t **)operator new(0x30uLL);
  *((_DWORD *)v8 + 8) = *(_DWORD *)a3;
  v8[5] = *(uint64_t **)(a3 + 8);
  *uint64_t v8 = 0;
  v8[1] = 0;
  v8[2] = v10;
  void *v6 = (uint64_t *)v8;
  unint64_t v11 = (uint64_t *)**a1;
  uint64_t v12 = (uint64_t *)v8;
  if (v11)
  {
    *a1 = v11;
    uint64_t v12 = *v6;
  }
  sub_1CB8358B8(a1[1], v12);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return v8;
}

void sub_1CC30BEDC(llvm *a1, llvm::PassRegistry *a2)
{
}

uint64_t llvm::LiveVariables::FindLastPartialDef(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unsigned int v38 = 0;
  uint64_t v3 = *(void *)(a1 + 376);
  if (v3) {
    uint64_t v4 = (void *)(v3 + 8);
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t v5 = v4[6];
  uint64_t v6 = *(unsigned int *)(*v4 + 24 * a2 + 4);
  if (!*(_WORD *)(v5 + 2 * v6)) {
    return 0;
  }
  unsigned int v10 = 0;
  uint64_t v11 = 0;
  unsigned __int16 v12 = *(_WORD *)(v5 + 2 * v6) + a2;
  uint64_t v13 = a1 + 456;
  unint64_t v14 = (unsigned __int16 *)(v5 + 2 * v6 + 2);
  do
  {
    unsigned int v15 = v12;
    uint64_t v37 = 0;
    uint64_t v37 = *(void *)(*(void *)(a1 + 384) + 8 * v12);
    if (v37)
    {
      unsigned int v16 = *((_DWORD *)sub_1CC308370(v13, &v37) + 2);
      if (v16 > v10)
      {
        unsigned int v38 = v15;
        uint64_t v11 = v37;
        unsigned int v10 = v16;
      }
    }
    int v17 = *v14++;
    unsigned __int16 v12 = v17 + v15;
  }
  while (v17);
  if (v11)
  {
    sub_1CB918828(a3, &v38);
    uint64_t v18 = *(unsigned int *)(v11 + 40);
    if (v18)
    {
      for (uint64_t i = 0; i != v18; ++i)
      {
        uint64_t v20 = *(void *)(v11 + 32);
        if ((*(_DWORD *)(v20 + 32 * i) & 0x10000FF) == 0x1000000)
        {
          unsigned int v21 = *(_DWORD *)(v20 + 32 * i + 4);
          if (v21)
          {
            uint64_t v22 = *(void *)(a1 + 376);
            uint64_t v23 = (_WORD *)(*(void *)(v22 + 56) + 2 * *(unsigned int *)(*(void *)(v22 + 8) + 24 * v21 + 8));
            int v24 = (unsigned __int16)*v23;
            unsigned __int16 v25 = v24 + v21;
            BOOL v27 = v24 == 0;
            BOOL v26 = *v23 != 0;
            BOOL v27 = v27 || v25 == a2;
            if (!v27)
            {
              uint64_t v28 = v23 + 1;
              do
              {
                int v30 = *v28++;
                int v29 = v30;
                v25 += v30;
                BOOL v26 = v30 != 0;
                if (!v30) {
                  uint64_t v28 = 0;
                }
                if (v29) {
                  BOOL v31 = v25 == a2;
                }
                else {
                  BOOL v31 = 1;
                }
              }
              while (!v31);
            }
            if (v26)
            {
              if (v22) {
                unint64_t v32 = (void *)(v22 + 8);
              }
              else {
                unint64_t v32 = 0;
              }
              uint64_t v33 = v32[6];
              if (v33)
              {
                unint64_t v34 = (unsigned __int16 *)(v33 + 2 * *(unsigned int *)(*v32 + 24 * v21 + 4));
                do
                {
                  LODWORD(v37) = (unsigned __int16)v21;
                  sub_1CB918828(a3, (unsigned int *)&v37);
                  int v35 = *v34++;
                  v21 += v35;
                }
                while (v35);
              }
            }
          }
        }
      }
    }
  }
  return v11;
}

uint64_t llvm::LiveVariables::FindLastRefOrPartRef(void *a1, unsigned int a2)
{
  __int16 v2 = a2;
  uint64_t v3 = *(void *)(a1[48] + 8 * a2);
  uint64_t v4 = *(void *)(a1[51] + 8 * a2);
  if (!(v3 | v4)) {
    return 0;
  }
  if (!v4) {
    uint64_t v4 = *(void *)(a1[48] + 8 * a2);
  }
  uint64_t v24 = v4;
  uint64_t v7 = (uint64_t)(a1 + 57);
  uint64_t v8 = sub_1CC308370((uint64_t)(a1 + 57), &v24);
  uint64_t v9 = a1[47];
  if (v9) {
    unsigned int v10 = (void *)(v9 + 8);
  }
  else {
    unsigned int v10 = 0;
  }
  uint64_t v11 = v10[6];
  uint64_t v12 = *(unsigned int *)(*v10 + 24 * a2 + 4);
  if (*(_WORD *)(v11 + 2 * v12))
  {
    unsigned __int16 v13 = *(_WORD *)(v11 + 2 * v12) + v2;
    unsigned int v14 = *((_DWORD *)v8 + 2);
    unsigned int v15 = (unsigned __int16 *)(v11 + 2 * v12 + 2);
    do
    {
      uint64_t v23 = 0;
      uint64_t v16 = v13;
      uint64_t v17 = *(void *)(a1[48] + 8 * v13);
      uint64_t v23 = v17;
      if (v17) {
        BOOL v18 = v17 == v3;
      }
      else {
        BOOL v18 = 1;
      }
      if (v18)
      {
        uint64_t v22 = 0;
        uint64_t v22 = *(void *)(a1[51] + 8 * v16);
        if (v22)
        {
          unsigned int v19 = *((_DWORD *)sub_1CC308370(v7, &v22) + 2);
          if (v19 > v14)
          {
            uint64_t v24 = v22;
            unsigned int v14 = v19;
          }
        }
      }
      else
      {
        sub_1CC308370(v7, &v23);
      }
      int v20 = *v15++;
      unsigned __int16 v13 = v20 + v16;
    }
    while (v20);
  }
  return v24;
}

BOOL llvm::LiveVariables::HandlePhysRegKill(void *a1, unsigned int a2, llvm::MachineInstr *a3)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(llvm::MachineInstr **)(a1[48] + 8 * a2);
  uint64_t v6 = *(llvm::MachineInstr **)(a1[51] + 8 * a2);
  BOOL result = ((unint64_t)v5 | (unint64_t)v6) != 0;
  if ((unint64_t)v5 | (unint64_t)v6)
  {
    BOOL v67 = ((unint64_t)v5 | (unint64_t)v6) != 0;
    if (!v6) {
      uint64_t v6 = v5;
    }
    unint64_t v73 = v6;
    unsigned int v9 = *((_DWORD *)sub_1CC308370((uint64_t)(a1 + 57), (uint64_t *)&v73) + 2);
    __dst = v76;
    uint64_t v75 = 0x800000000;
    uint64_t v66 = a2;
    uint64_t v78 = 0;
    uint64_t v79 = 0;
    uint64_t v77 = &v78;
    uint64_t v10 = a1[47];
    if (v10) {
      uint64_t v11 = (void *)(v10 + 8);
    }
    else {
      uint64_t v11 = 0;
    }
    uint64_t v12 = (unsigned __int16 *)(v11[6] + 2 * *(unsigned int *)(*v11 + 24 * a2 + 4));
    unsigned int v65 = a2;
    unsigned __int16 v13 = 0;
    if (*v12)
    {
      unsigned int v14 = 0;
      unsigned int v15 = *v12 + a2;
      do
      {
        *(void *)&long long v68 = 0;
        uint64_t v16 = *(llvm::MachineInstr **)(a1[48] + 8 * (unsigned __int16)v15);
        *(void *)&long long v68 = v16;
        if (v16) {
          BOOL v17 = v16 == v5;
        }
        else {
          BOOL v17 = 1;
        }
        if (v17)
        {
          uint64_t v72 = 0;
          uint64_t v72 = *(llvm::MachineInstr **)(a1[51] + 8 * (unsigned __int16)v15);
          if (v72)
          {
            uint64_t v18 = a1[47];
            unsigned int v19 = (void *)(v18 + 8);
            if (!v18) {
              unsigned int v19 = 0;
            }
            uint64_t v20 = v19[6];
            if (v20)
            {
              unsigned int v21 = (unsigned __int16 *)(v20 + 2 * *(unsigned int *)(*v19 + 24 * (unsigned __int16)v15 + 4));
              unsigned int v22 = v15;
              do
              {
                unsigned int v71 = (unsigned __int16)v22;
                sub_1CB913D18((uint64_t)&__dst, &v71);
                int v23 = *v21++;
                v22 += v23;
              }
              while (v23);
            }
            unsigned int v24 = *((_DWORD *)sub_1CC308370((uint64_t)(a1 + 57), (uint64_t *)&v72) + 2);
            if (v24 > v9)
            {
              unint64_t v73 = v72;
              unsigned int v9 = v24;
            }
          }
        }
        else
        {
          unsigned __int16 v25 = sub_1CC308370((uint64_t)(a1 + 57), (uint64_t *)&v68);
          if (*((_DWORD *)v25 + 2) > v14)
          {
            unsigned int v14 = *((_DWORD *)v25 + 2);
            unsigned __int16 v13 = (llvm::MachineInstr *)v68;
          }
        }
        int v26 = v12[1];
        ++v12;
        v15 += v26;
      }
      while (v26);
    }
    if (*(void *)(a1[51] + 8 * v66))
    {
      BOOL v27 = v73;
      if (v73 == a3 || v73 != *(llvm::MachineInstr **)(a1[48] + 8 * v66))
      {
        llvm::MachineInstr::addRegisterKilled(v73, v66, a1[47], 1);
      }
      else if (v13)
      {
        *((void *)&v68 + 1) = 0;
        uint64_t v69 = 0;
        uint64_t v70 = 0;
        LODWORD(v68) = 100663296;
        DWORD1(v68) = v65;
        llvm::MachineInstr::addOperand(v13, *(llvm::MachineFunction **)(*((void *)v13 + 3) + 32), (const llvm::MachineOperand *)&v68);
      }
      else
      {
        unsigned int RegisterDefOperandIdx = llvm::MachineInstr::findRegisterDefOperandIdx((uint64_t)v73, v66, 0, 0, a1[47]);
        if (RegisterDefOperandIdx == -1) {
          uint64_t v59 = 0;
        }
        else {
          uint64_t v59 = *((void *)v27 + 4) + 32 * RegisterDefOperandIdx;
        }
        if ((*(unsigned char *)(v59 + 3) & 0x40) != 0)
        {
          int v60 = *(_DWORD *)(v59 + 4);
          llvm::MachineInstr::addRegisterDead(v73, v66, a1[47], 1);
          if (v60 != v65)
          {
            int v61 = v73;
            unsigned int v62 = llvm::MachineInstr::findRegisterDefOperandIdx((uint64_t)v73, v66, 0, 0, 0);
            if (v62 != -1)
            {
              uint64_t v63 = *((void *)v61 + 4);
              if (v63) {
                *(_DWORD *)(v63 + 32 * v62) |= 0x40000000u;
              }
            }
          }
        }
        else
        {
          llvm::MachineInstr::addRegisterDead(v73, v66, a1[47], 1);
        }
      }
    }
    else
    {
      llvm::MachineInstr::addRegisterDead(*(llvm::MachineInstr **)(a1[48] + 8 * v66), v66, a1[47], 1);
      uint64_t v28 = a1[47];
      if (v28) {
        int v29 = (void *)(v28 + 8);
      }
      else {
        int v29 = 0;
      }
      int v30 = (unsigned __int16 *)(v29[6] + 2 * *(unsigned int *)(*v29 + 24 * v66 + 4));
      if (*v30)
      {
        unsigned int v31 = *v30 + v65;
        do
        {
          if (v79)
          {
            for (uint64_t i = v78; i; uint64_t i = (void *)*i)
            {
              unsigned int v33 = *((_DWORD *)i + 7);
              if (v33 <= (unsigned __int16)v31)
              {
                if (v33 >= (unsigned __int16)v31) {
                  goto LABEL_48;
                }
                ++i;
              }
            }
          }
          else if (v75)
          {
            unint64_t v34 = __dst;
            uint64_t v35 = 4 * v75;
            while (*v34 != (unsigned __int16)v31)
            {
              ++v34;
              v35 -= 4;
              if (!v35) {
                goto LABEL_77;
              }
            }
            if (v35)
            {
LABEL_48:
              uint64_t v36 = a1[48];
              uint64_t v37 = *(void *)(v36 + 8 * v66);
              if (v37 != *(void *)(v36 + 8 * (unsigned __int16)v31)
                || llvm::MachineInstr::findRegisterDefOperandIdx(v37, (unsigned __int16)v31, 0, 0, 0) == -1
                || !*(void *)(v37 + 32))
              {
                unsigned int v38 = *(llvm::MachineInstr **)(a1[48] + 8 * v66);
                HIDWORD(v68) = 0;
                uint64_t v69 = 0;
                uint64_t v70 = 0;
                LODWORD(v68) = 50331648;
                *(void *)((char *)&v68 + 4) = (unsigned __int16)v31;
                llvm::MachineInstr::addOperand(v38, *(llvm::MachineFunction **)(*((void *)v38 + 3) + 32), (const llvm::MachineOperand *)&v68);
              }
              LastRefOrPartRef = (llvm::MachineInstr *)llvm::LiveVariables::FindLastRefOrPartRef(a1, (unsigned __int16)v31);
              if (LastRefOrPartRef)
              {
                llvm::MachineInstr::addRegisterKilled(LastRefOrPartRef, (unsigned __int16)v31, a1[47], 1);
              }
              else
              {
                llvm::MachineInstr::addRegisterKilled(v73, (unsigned __int16)v31, a1[47], 1);
                uint64_t v40 = a1[47];
                uint64_t v41 = (void *)(v40 + 8);
                if (!v40) {
                  uint64_t v41 = 0;
                }
                uint64_t v42 = v41[6];
                if (v42)
                {
                  uint64_t v43 = (unsigned __int16 *)(v42 + 2 * *(unsigned int *)(*v41 + 24 * (unsigned __int16)v31 + 4));
                  unsigned int v44 = v31;
                  do
                  {
                    *(void *)(a1[51] + 8 * (unsigned __int16)v44) = v73;
                    int v45 = *v43++;
                    v44 += v45;
                  }
                  while (v45);
                }
              }
              uint64_t v46 = a1[47];
              if (v46) {
                __int16 v47 = (void *)(v46 + 8);
              }
              else {
                __int16 v47 = 0;
              }
              int v48 = (_WORD *)(v47[6] + 2 * *(unsigned int *)(*v47 + 24 * (unsigned __int16)v31 + 4));
              if (*v48)
              {
                unsigned __int16 v49 = *v48 + v31;
                do
                {
                  int v50 = v49;
                  LODWORD(v68) = v49;
                  if (v79)
                  {
                    sub_1CD50BF28((uint64_t)&v77, (unsigned int *)&v68);
                  }
                  else
                  {
                    int v51 = v75;
                    if (v75)
                    {
                      int v52 = (char *)__dst;
                      size_t v53 = 4 * v75 - 4;
                      long long v54 = (char *)__dst;
                      while (1)
                      {
                        int v55 = *(_DWORD *)v54;
                        v54 += 4;
                        if (v55 == v50) {
                          break;
                        }
                        v53 -= 4;
                        int v52 = v54;
                        if (v53 == -4) {
                          goto LABEL_74;
                        }
                      }
                      if (v53)
                      {
                        memmove(v52, v52 + 4, v53);
                        int v51 = v75;
                      }
                      LODWORD(v75) = v51 - 1;
                    }
                  }
LABEL_74:
                  int v56 = (unsigned __int16)v48[1];
                  ++v48;
                  unsigned __int16 v49 = v56 + v50;
                }
                while (v56);
              }
            }
          }
LABEL_77:
          int v57 = v30[1];
          ++v30;
          v31 += v57;
        }
        while (v57);
      }
    }
    sub_1CB833A08((uint64_t)&v77, v78);
    if (__dst != v76) {
      free(__dst);
    }
    return v67;
  }
  return result;
}

_DWORD *sub_1CC30C86C(_DWORD *result)
{
  unsigned int v1 = result;
  int v2 = result[2];
  if (v2)
  {
    unsigned int v3 = result[4];
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      int v4 = 1 << (33 - __clz(v2 - 1));
      if (v4 <= 64) {
        int v5 = 64;
      }
      else {
        int v5 = v4;
      }
LABEL_7:
      if (v5 == v3)
      {
        *((void *)result + 1) = 0;
        uint64_t v8 = 16 * v3;
        unsigned int v9 = *(void **)result;
        do
        {
          *unsigned int v9 = -4096;
          v9 += 2;
          v8 -= 16;
        }
        while (v8);
      }
      else
      {
        MEMORY[0x1D25D9CD0](*(void *)result, 8);
        return sub_1CB837D60(v1, v5);
      }
      return result;
    }
  }
  else
  {
    if (!result[3]) {
      return result;
    }
    unsigned int v3 = result[4];
    if (v3 > 0x40)
    {
      int v5 = 0;
      goto LABEL_7;
    }
  }
  if (v3)
  {
    uint64_t v6 = *(void **)result;
    uint64_t v7 = 16 * v3;
    do
    {
      void *v6 = -4096;
      v6 += 2;
      v7 -= 16;
    }
    while (v7);
  }
  *((void *)result + 1) = 0;
  return result;
}

void llvm::LiveVariables::recomputeForSingleDefVirtReg(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = a1;
  v110[6] = *MEMORY[0x1E4F143B8];
  int v4 = (uint64_t *)(a1 + 248);
  unint64_t v5 = a2 & 0x7FFFFFFF;
  if (v5 >= *(unsigned int *)(a1 + 256)) {
    sub_1CD520A8C((uint64_t *)(a1 + 248), v5 + 1, a1 + 264);
  }
  uint64_t v6 = *v4;
  uint64_t v7 = (uint64_t *)(v6 + 56 * v5);
  if (v7[2])
  {
    uint64_t v9 = *v7;
    uint64_t v8 = (uint64_t *)v7[1];
    uint64_t v10 = *v8;
    *(void *)(v10 + 8) = *(void *)(*v7 + 8);
    **(void **)(v9 + 8) = v10;
    v7[2] = 0;
    if (v8 != v7)
    {
      do
      {
        uint64_t v11 = (uint64_t *)v8[1];
        operator delete(v8);
        uint64_t v8 = v11;
      }
      while (v11 != v7);
    }
  }
  uint64_t v12 = a2;
  uint64_t v13 = v6 + 56 * v5;
  unsigned int v14 = *(unint64_t **)(v13 + 32);
  *(void *)(v13 + 40) = v14;
  uint64_t v92 = (unint64_t **)(v13 + 32);
  unsigned int v93 = (void *)(v13 + 40);
  uint64_t v15 = *(void *)(v3 + 368);
  if ((a2 & 0x80000000) != 0) {
    uint64_t v16 = (uint64_t *)(*(void *)(v15 + 24) + 16 * v5 + 8);
  }
  else {
    uint64_t v16 = (uint64_t *)(*(void *)(v15 + 272) + 8 * a2);
  }
  uint64_t v17 = *v16;
  if (v17 && ((*(unsigned char *)(v17 + 3) & 1) != 0 || (uint64_t v89 = *(void *)(v17 + 24)) != 0 && (*(unsigned char *)(v89 + 3) & 1) != 0))
  {
    if ((a2 & 0x80000000) != 0) {
      uint64_t v75 = (uint64_t *)(*(void *)(v15 + 24) + 16 * v5 + 8);
    }
    else {
      uint64_t v75 = (uint64_t *)(*(void *)(v15 + 272) + 8 * a2);
    }
    uint64_t v76 = *v75;
    if (v76)
    {
      if ((*(unsigned char *)(v76 + 3) & 1) == 0)
      {
        uint64_t v76 = *(void *)(v76 + 24);
        if (v76)
        {
          if ((*(unsigned char *)(v76 + 3) & 1) == 0) {
            uint64_t v76 = 0;
          }
        }
      }
    }
    unint64_t v77 = *(void *)(v76 + 8);
    while (1)
    {
      uint64_t v76 = *(void *)(v76 + 24);
      if (!v76 || (*(unsigned char *)(v76 + 3) & 1) == 0) {
        break;
      }
      unint64_t v18 = 0;
      if (*(void *)(v76 + 8) != v77) {
        goto LABEL_11;
      }
    }
    unint64_t v18 = v77;
  }
  else
  {
    unint64_t v18 = 0;
  }
LABEL_11:
  if ((a2 & 0x80000000) != 0) {
    unsigned int v19 = (uint64_t *)(*(void *)(v15 + 24) + 16 * v5 + 8);
  }
  else {
    unsigned int v19 = (uint64_t *)(*(void *)(v15 + 272) + 8 * a2);
  }
  uint64_t v20 = *v19;
  if (!v20) {
    goto LABEL_130;
  }
  uint64_t v21 = *(void *)(v18 + 24);
  if ((*(unsigned char *)(v20 + 3) & 0x81) != 0)
  {
    while (1)
    {
      uint64_t v20 = *(void *)(v20 + 24);
      if (!v20) {
        break;
      }
      if ((*(_DWORD *)v20 & 0x81000000) == 0) {
        goto LABEL_17;
      }
    }
LABEL_130:
    uint64_t v78 = v6 + 56 * v5;
    unint64_t v81 = *(void *)(v78 + 48);
    uint64_t v80 = (unint64_t **)(v78 + 48);
    unint64_t v79 = v81;
    if ((unint64_t)v14 >= v81)
    {
      uint64_t v84 = v79 - (void)v14;
      uint64_t v85 = v84 >> 2;
      if ((unint64_t)(v84 >> 2) <= 1) {
        uint64_t v85 = 1;
      }
      if ((unint64_t)v84 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v86 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v86 = v85;
      }
      uint64_t v83 = v93;
      if (v86 >> 61) {
LABEL_147:
      }
        sub_1CB833614();
      uint64_t v87 = (unint64_t *)operator new(8 * v86);
      uint64_t v88 = &v87[v86];
      *uint64_t v87 = v18;
      *uint64_t v92 = v87;
      uint64_t v82 = v87 + 1;
      *unsigned int v93 = v87 + 1;
      *uint64_t v80 = v88;
      if (v14) {
        operator delete(v14);
      }
    }
    else
    {
      *unsigned int v14 = v18;
      uint64_t v82 = v14 + 1;
      uint64_t v83 = v93;
    }
    *uint64_t v83 = v82;
    llvm::MachineInstr::addRegisterDead((llvm::MachineInstr *)v18, a2, 0, 0);
    return;
  }
LABEL_17:
  uint64_t v22 = *(unsigned int *)(v18 + 40);
  if (v22)
  {
    int v23 = *(_DWORD **)(v18 + 32);
    uint64_t v24 = 32 * v22;
    do
    {
      if ((*v23 & 0x10000FF) == 0x1000000 && v23[1] == a2) {
        *v23 &= ~0x4000000u;
      }
      v23 += 8;
      v24 -= 32;
    }
    while (v24);
    uint64_t v15 = *(void *)(v3 + 368);
  }
  uint64_t v109 = 0x600000000;
  uint64_t v104 = (uint64_t)&v104;
  unint64_t v105 = &v104;
  uint64_t v106 = 0;
  uint64_t v107 = &v104;
  int32x2_t v108 = v110;
  if ((a2 & 0x80000000) != 0) {
    unsigned __int16 v25 = (unsigned int **)(*(void *)(v15 + 24) + 16 * v5 + 8);
  }
  else {
    unsigned __int16 v25 = (unsigned int **)(*(void *)(v15 + 272) + 8 * a2);
  }
  int v26 = *v25;
  if (!*v25) {
    goto LABEL_63;
  }
  while (1)
  {
    unsigned int v27 = *v26;
    if ((*v26 & 0x81000000) == 0) {
      break;
    }
    int v26 = (unsigned int *)*((void *)v26 + 3);
    if (!v26) {
      goto LABEL_63;
    }
  }
LABEL_30:
  *int v26 = v27 & 0xFBFFFFFF;
  uint64_t v28 = *((void *)v26 + 1);
  uint64_t v29 = *(void *)(v28 + 24);
  sub_1CBF7C6A8(&v104, *(_DWORD *)(v29 + 24));
  int v30 = **(unsigned __int16 **)(v28 + 16);
  if (v30 == 69 || v30 == 0)
  {
    if (v109 >= (unint64_t)HIDWORD(v109)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v108 + v109) = *(void *)(*(void *)(v28 + 32)
                                                       + 32
                                                       * ((((unint64_t)v26 - *(void *)(v28 + 32)) >> 5)
                                                        + 1)
                                                       + 16);
    int v32 = v109 + 1;
  }
  else
  {
    if (v29 == v21) {
      goto LABEL_44;
    }
    uint64_t v90 = v3;
    uint64_t v33 = v6;
    uint64_t v34 = v12;
    uint64_t v35 = *(char **)(v29 + 64);
    uint64_t v36 = *(char **)(v29 + 72);
    unint64_t v37 = v36 - v35;
    int v38 = v109;
    if ((unint64_t)v109 + ((v36 - v35) >> 3) > HIDWORD(v109)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    if (v35 != v36)
    {
      int v39 = (char *)v108 + 8 * v109;
      do
      {
        uint64_t v40 = *(void *)v35;
        v35 += 8;
        *v39++ = v40;
      }
      while (v35 != v36);
    }
    int v32 = v38 + (v37 >> 3);
    uint64_t v12 = v34;
    uint64_t v6 = v33;
    uint64_t v3 = v90;
  }
  LODWORD(v109) = v32;
LABEL_44:
  while (1)
  {
    int v26 = (unsigned int *)*((void *)v26 + 3);
    if (!v26) {
      break;
    }
    unsigned int v27 = *v26;
    if ((*v26 & 0x81000000) == 0) {
      goto LABEL_30;
    }
  }
  unsigned int v41 = v109;
  if (v109)
  {
    char v42 = 0;
    do
    {
      uint64_t v43 = *((void *)v108 + --v41);
      LODWORD(v109) = v41;
      if (v43 == v21)
      {
        char v42 = 1;
      }
      else if (sub_1CD460634(v7, *(_DWORD *)(v43 + 24)))
      {
        unsigned int v41 = v109;
      }
      else
      {
        sub_1CBF7C6A8(v7, *(_DWORD *)(v43 + 24));
        unsigned int v44 = *(char **)(v43 + 64);
        int v45 = *(char **)(v43 + 72);
        unint64_t v46 = v45 - v44;
        int v47 = v109;
        if ((unint64_t)v109 + ((v45 - v44) >> 3) > HIDWORD(v109)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v44 != v45)
        {
          int v48 = (char *)v108 + 8 * v109;
          do
          {
            uint64_t v49 = *(void *)v44;
            v44 += 8;
            *v48++ = v49;
          }
          while (v44 != v45);
        }
        unsigned int v41 = v47 + (v46 >> 3);
        LODWORD(v109) = v41;
      }
    }
    while (v41);
  }
  else
  {
LABEL_63:
    char v42 = 0;
  }
  unsigned int v100 = &v104;
  uint64_t v101 = v105;
  unint64_t v103 = 0;
  unint64_t v102 = 0xFFFFFFFF00000000;
  v99[0] = 0;
  sub_1CC30D2C4((uint64_t)v99);
  uint64_t v95 = &v104;
  uint64_t v96 = v105;
  uint64_t v98 = 0;
  unint64_t v97 = 0xFFFFFFFF00000000;
  v94[0] = 1;
  sub_1CC30D2C4((uint64_t)v94);
  int v50 = v99[0];
  int v51 = v94[0];
  if (!v99[0] || !v94[0])
  {
    int v56 = (void *)(v6 + 56 * v5 + 48);
    while (1)
    {
      uint64_t v57 = v102;
      if (v50 == v51 && v97 == v102) {
        break;
      }
      if ((sub_1CD460634(v7, v102) & 1) == 0)
      {
        uint64_t v58 = *(void *)(*(void *)(*(void *)(v3 + 360) + 104) + 8 * v57);
        if (((v58 == v21) & v42) == 0)
        {
          uint64_t v60 = *(void *)(v58 + 48);
          uint64_t v59 = v58 + 48;
          unint64_t v61 = v60 & 0xFFFFFFFFFFFFFFF8;
          if ((v60 & 0xFFFFFFFFFFFFFFF8) == 0 || (*(unsigned char *)v61 & 4) == 0)
          {
            while ((*(_WORD *)(v61 + 44) & 4) != 0)
              unint64_t v61 = *(void *)v61 & 0xFFFFFFFFFFFFFFF8;
          }
          while (1)
          {
            if (v61 == v59) {
              goto LABEL_77;
            }
            int v62 = **(unsigned __int16 **)(v61 + 16);
            if ((v62 - 13) >= 5 && v62 != 23)
            {
              if (!**(_WORD **)(v61 + 16) || v62 == 69) {
                goto LABEL_77;
              }
              if (llvm::MachineInstr::findRegisterUseOperandIdx(v61, v12, 0, 0) != -1) {
                break;
              }
            }
            unint64_t v61 = *(void *)v61 & 0xFFFFFFFFFFFFFFF8;
            if (!v61 || (*(unsigned char *)v61 & 4) == 0)
            {
              while ((*(_WORD *)(v61 + 44) & 4) != 0)
                unint64_t v61 = *(void *)v61 & 0xFFFFFFFFFFFFFFF8;
            }
          }
          llvm::MachineInstr::addRegisterKilled((llvm::MachineInstr *)v61, v12, 0, 0);
          unsigned int v64 = (unint64_t *)*v93;
          if (*v93 >= *v56)
          {
            BOOL v67 = *v92;
            uint64_t v68 = v64 - *v92;
            unint64_t v69 = v68 + 1;
            if ((unint64_t)(v68 + 1) >> 61) {
              abort();
            }
            uint64_t v70 = *v56 - (void)v67;
            if (v70 >> 2 > v69) {
              unint64_t v69 = v70 >> 2;
            }
            if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v69 = 0x1FFFFFFFFFFFFFFFLL;
            }
            unint64_t v91 = v69;
            if (v69)
            {
              if (v69 >> 61) {
                goto LABEL_147;
              }
              unsigned int v71 = (char *)operator new(8 * v69);
            }
            else
            {
              unsigned int v71 = 0;
            }
            uint64_t v72 = (unint64_t *)&v71[8 * v68];
            *uint64_t v72 = v61;
            unsigned int v65 = v72 + 1;
            if (v64 == v67)
            {
              int v74 = v92;
              uint64_t v66 = v93;
            }
            else
            {
              uint64_t v66 = v93;
              do
              {
                unint64_t v73 = *--v64;
                *--uint64_t v72 = v73;
              }
              while (v64 != v67);
              int v74 = v92;
              unsigned int v64 = *v92;
            }
            *int v74 = v72;
            *uint64_t v66 = v65;
            *int v56 = &v71[8 * v91];
            if (v64) {
              operator delete(v64);
            }
          }
          else
          {
            *unsigned int v64 = v61;
            unsigned int v65 = v64 + 1;
            uint64_t v66 = v93;
          }
          *uint64_t v66 = v65;
        }
      }
LABEL_77:
      LODWORD(v102) = v102 + 1;
      v103 >>= 1;
      sub_1CC30D348((uint64_t)v99);
      int v50 = v99[0];
      int v51 = v94[0];
      if (v99[0])
      {
        if (v94[0]) {
          break;
        }
      }
    }
  }
  if (v106)
  {
    uint64_t v53 = v104;
    int v52 = v105;
    uint64_t v54 = *v105;
    *(void *)(v54 + 8) = *(void *)(v104 + 8);
    **(void **)(v53 + 8) = v54;
    uint64_t v106 = 0;
    if (v52 != &v104)
    {
      do
      {
        int v55 = (uint64_t *)v52[1];
        operator delete(v52);
        int v52 = v55;
      }
      while (v55 != &v104);
    }
  }
  if (v108 != v110) {
    free(v108);
  }
}

BOOL sub_1CC30D1B0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(char **)(a1 + 32);
  int v4 = *(char **)(a1 + 40);
  if (v3 != v4)
  {
    while (*(void *)v3 != a2)
    {
      v3 += 8;
      if (v3 == v4)
      {
        uint64_t v3 = *(char **)(a1 + 40);
        break;
      }
    }
  }
  if (v3 != v4)
  {
    if (v4 != v3 + 8) {
      memmove(v3, v3 + 8, v4 - (v3 + 8));
    }
    *(void *)(a1 + 40) = v4 - 8;
  }
  return v3 != v4;
}

void sub_1CC30D230(void ***a1)
{
  unsigned int v1 = *a1;
  int v2 = (char *)**a1;
  if (v2)
  {
    int v4 = (char *)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 16;
      do
      {
        uint64_t v7 = (char *)*((void *)v6 - 2);
        if (v6 != v7) {
          free(v7);
        }
        uint64_t v8 = v6 - 16;
        v6 -= 32;
      }
      while (v8 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1CC30D2C4(uint64_t result)
{
  if (!*(unsigned char *)result)
  {
    uint64_t v1 = *(void *)(result + 8);
    if (*(void *)(v1 + 16))
    {
      uint64_t v2 = 0;
      uint64_t v3 = *(void *)(v1 + 8);
      *(void *)(result + 16) = v3;
      int v5 = *(_DWORD *)(v3 + 16);
      uint64_t v4 = v3 + 16;
      int v6 = v5 << 7;
      char v7 = 1;
      while (1)
      {
        unint64_t v8 = *(void *)(v4 + 8 * v2 + 8);
        if (v8) {
          break;
        }
        char v9 = v7;
        char v7 = 0;
        uint64_t v2 = 1;
        if ((v9 & 1) == 0) {
          goto LABEL_8;
        }
      }
      LODWORD(v8) = __clz(__rbit64(v8)) | (v2 << 6);
LABEL_8:
      unsigned int v10 = (v8 >> 6) & 1;
      *(_DWORD *)(result + 24) = v8 + v6;
      *(_DWORD *)(result + 28) = v10;
      *(void *)(result + 32) = *(void *)(v4 + 8 * v10 + 8) >> v8;
    }
    else
    {
      *(unsigned char *)BOOL result = 1;
    }
  }
  return result;
}

uint64_t sub_1CC30D348(uint64_t result)
{
  if (*(unsigned char *)result) {
    return result;
  }
  unint64_t v1 = *(void *)(result + 32);
  if (v1) {
    BOOL v2 = (*(void *)(result + 32) & 1) == 0;
  }
  else {
    BOOL v2 = 0;
  }
  if (v2)
  {
    int v3 = *(_DWORD *)(result + 24);
    do
    {
      unint64_t v4 = v1;
      v1 >>= 1;
      ++v3;
    }
    while (v4 >= 2 && (v4 & 2) == 0);
    *(void *)(result + 32) = v1;
    *(_DWORD *)(result + 24) = v3;
  }
  if (v1) {
    return result;
  }
  uint64_t v5 = *(void *)(result + 16);
  int v6 = (_DWORD *)(v5 + 16);
  unsigned int v7 = *(_DWORD *)(result + 24) & 0x7F;
  unint64_t v8 = (-1 << *(_DWORD *)(result + 24)) & *(void *)(v5
                                                      + 16
                                                      + (((unint64_t)*(unsigned int *)(result + 24) >> 3) & 8)
                                                      + 8);
  if (v8)
  {
    int v21 = *(_DWORD *)(result + 24) & 0x40;
    int v22 = __clz(__rbit64(v8));
LABEL_27:
    if (v7)
    {
      unsigned int v23 = v21 | v22;
      unsigned int v24 = (v21 | v22) >> 6;
      char v25 = (v21 | v22) - 64;
      if (v23 < 0x40) {
        char v25 = v23;
      }
      *(void *)(result + 32) = *(void *)&v6[2 * v24 + 2] >> v25;
      *(_DWORD *)(result + 24) = v23 + (*v6 << 7);
      *(_DWORD *)(result + 28) = v24;
      return result;
    }
    goto LABEL_16;
  }
  if (v7 <= 0x3F)
  {
    unint64_t v9 = *(void *)(v5 + 32);
    if (v9)
    {
      int v21 = __clz(__rbit64(v9));
      int v22 = 64;
      goto LABEL_27;
    }
  }
LABEL_16:
  uint64_t v10 = *(void *)(v5 + 8);
  *(void *)(result + 16) = v10;
  *(_DWORD *)(result + 28) = 0;
  if (v10 == *(void *)(result + 8))
  {
    *(unsigned char *)BOOL result = 1;
  }
  else
  {
    uint64_t v11 = 0;
    int v13 = *(_DWORD *)(v10 + 16);
    uint64_t v12 = v10 + 16;
    int v14 = v13 << 7;
    char v15 = 1;
    while (1)
    {
      unint64_t v16 = *(void *)(v12 + 8 * v11 + 8);
      if (v16) {
        break;
      }
      char v17 = v15;
      char v15 = 0;
      uint64_t v11 = 1;
      if ((v17 & 1) == 0) {
        goto LABEL_23;
      }
    }
    LODWORD(v16) = __clz(__rbit64(v16)) | (v11 << 6);
LABEL_23:
    unsigned int v18 = (v16 >> 6) & 1;
    *(_DWORD *)(result + 24) = v16 + v14;
    *(_DWORD *)(result + 28) = v18;
    unint64_t v19 = *(void *)(v12 + 8 * v18 + 8);
    char v20 = v16 - 64;
    if (v16 < 0x40) {
      char v20 = v16;
    }
    *(void *)(result + 32) = v19 >> v20;
  }
  return result;
}

__n128 sub_1CC30D4A8(__n128 *a1, __n128 *a2, uint64_t *a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      sub_1CD46E850(a3, v5);
      a3[3] = a3[1];
      a3[4] = 0;
      a3[5] = 0;
      a3[6] = 0;
      __n128 result = v5[2];
      *((__n128 *)a3 + 2) = result;
      a3[6] = v5[3].n128_i64[0];
      v5[2].n128_u64[0] = 0;
      v5[2].n128_u64[1] = 0;
      v5[3].n128_u64[0] = 0;
      a3 += 7;
      uint64_t v5 = (__n128 *)((char *)v5 + 56);
    }
    while (v5 != a2);
  }
  return result;
}

void *sub_1CC30D528(void *result, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v4 = a2;
    uint64_t v5 = result;
    do
    {
      *uint64_t v5 = v5;
      v5[1] = v5;
      void v5[2] = 0;
      uint64_t v6 = *(void *)(a3 + 8);
      unsigned int v7 = v5;
      if (v6 != a3)
      {
        uint64_t v8 = 1;
        unint64_t v9 = v5;
        do
        {
          uint64_t v10 = operator new(0x28uLL);
          *uint64_t v10 = 0;
          v10[1] = 0;
          uint64_t v11 = *(void *)(v6 + 32);
          *((_OWORD *)v10 + 1) = *(_OWORD *)(v6 + 16);
          v10[4] = v11;
          *uint64_t v10 = v9;
          v10[1] = v5;
          v9[1] = v10;
          *uint64_t v5 = v10;
          void v5[2] = v8;
          uint64_t v6 = *(void *)(v6 + 8);
          ++v8;
          unint64_t v9 = v10;
        }
        while (v6 != a3);
        unsigned int v7 = (void *)v5[1];
      }
      v5[4] = 0;
      uint64_t v12 = v5 + 4;
      *(v12 - 1) = v7;
      v12[1] = 0;
      v12[2] = 0;
      __n128 result = sub_1CBFCBA2C(v12, *(const void **)(a3 + 32), *(void *)(a3 + 40), (uint64_t)(*(void *)(a3 + 40) - *(void *)(a3 + 32)) >> 3);
      uint64_t v5 = v12 + 3;
      --v4;
    }
    while (v4);
  }
  return result;
}

void *sub_1CC30D5F8(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  unsigned int v8 = *(_DWORD *)(a2 + 16);
  if (!v8)
  {
    unsigned int v18 = 0;
LABEL_15:
    __n128 result = sub_1CB9A052C(a2, (uint64_t)a3, a3, v18);
    *__n128 result = *a3;
    *((_DWORD *)result + 2) = *a4;
    uint64_t v9 = *(void *)a2;
    unsigned int v8 = *(_DWORD *)(a2 + 16);
    char v17 = 1;
    goto LABEL_16;
  }
  uint64_t v9 = *(void *)a2;
  unsigned int v10 = ((*a3 >> 4) ^ (*a3 >> 9)) & (v8 - 1);
  __n128 result = (void *)(*(void *)a2 + 16 * v10);
  uint64_t v12 = *result;
  if (*a3 != *result)
  {
    int v13 = 0;
    int v14 = 1;
    while (v12 != -4096)
    {
      if (v13) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v12 == -8192;
      }
      if (v15) {
        int v13 = result;
      }
      unsigned int v16 = v10 + v14++;
      unsigned int v10 = v16 & (v8 - 1);
      __n128 result = (void *)(v9 + 16 * v10);
      uint64_t v12 = *result;
      if (*a3 == *result) {
        goto LABEL_11;
      }
    }
    if (v13) {
      unsigned int v18 = v13;
    }
    else {
      unsigned int v18 = result;
    }
    goto LABEL_15;
  }
LABEL_11:
  char v17 = 0;
LABEL_16:
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v9 + 16 * v8;
  *(unsigned char *)(a1 + 16) = v17;
  return result;
}

uint64_t llvm::LLVMTargetMachine::LLVMTargetMachine(uint64_t a1, uint64_t a2, const void *a3, unint64_t a4, long long *a5, const std::string::value_type *a6, std::string::size_type a7, uint64_t a8, const std::string::value_type *a9, std::string::size_type a10, long long *a11, uint64_t a12, int a13)
{
  uint64_t result = llvm::TargetMachine::TargetMachine(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
  *(void *)uint64_t result = &unk_1F260CDE0;
  *(void *)(result + 544) = a12;
  *(_DWORD *)(result + 552) = a13;
  if (byte_1EBD050A0) {
    *(_DWORD *)(result + 1040) |= 0x80u;
  }
  return result;
}

{
  uint64_t result;

  uint64_t result = llvm::TargetMachine::TargetMachine(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
  *(void *)uint64_t result = &unk_1F260CDE0;
  *(void *)(result + 544) = a12;
  *(_DWORD *)(result + 552) = a13;
  if (byte_1EBD050A0) {
    *(_DWORD *)(result + 1040) |= 0x80u;
  }
  return result;
}

void llvm::LLVMTargetMachine::createMCStreamer(llvm *this@<X4>, uint64_t a2@<X0>, llvm::raw_pwrite_stream *a3@<X1>, llvm::raw_pwrite_stream *a4@<X2>, int a5@<W3>, uint64_t a6@<X8>)
{
  uint64_t v9 = a2;
  if ((*(_WORD *)(a2 + 1128) & 0x40) != 0) {
    *((unsigned char *)this + 1627) = 0;
  }
  uint64_t v11 = (_WORD *)(a2 + 1128);
  uint64_t v12 = *(void *)(a2 + 584);
  uint64_t v13 = *(void *)(a2 + 568);
  uint64_t v14 = *(void *)(a2 + 576);
  switch(a5)
  {
    case 1:
      unsigned int v16 = *(uint64_t (**)(void, llvm *))(*(void *)(a2 + 8) + 144);
      if (!v16 || (a2 = v16(*(void *)(a2 + 576), this)) == 0)
      {
        llvm::inconvertibleErrorCode((llvm *)a2);
        operator new();
      }
      uint64_t v17 = a2;
      unsigned int v18 = *(llvm **)(v9 + 8);
      unint64_t v19 = (uint64_t (*)(void))*((void *)v18 + 13);
      if (!v19 || (unsigned int v18 = (llvm *)v19()) == 0)
      {
        llvm::inconvertibleErrorCode(v18);
        operator new();
      }
      uint64_t v29 = v18;
      __int16 v38 = 260;
      v37[0] = v9 + 448;
      llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v37);
      uint64_t v30 = *(void *)(v9 + 8);
      v37[0] = v29;
      if (a4) {
        llvm::MCAsmBackend::createDwoObjectWriter(v29, a3, a4);
      }
      llvm::MCAsmBackend::createObjectWriter(&v36, v29, a3);
      uint64_t v35 = v17;
      uint64_t v15 = sub_1CD455004(v30, (uint64_t)__p, (uint64_t)this, (uint64_t)v37, (uint64_t)&v36, (uint64_t)&v35, v12, *v11 & 1, HIBYTE(*v11) & 1, 1u);
      uint64_t v31 = v35;
      uint64_t v35 = 0;
      if (v31) {
        (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
      }
      uint64_t v32 = v36;
      uint64_t v36 = 0;
      if (v32) {
        (*(void (**)(uint64_t))(*(void *)v32 + 8))(v32);
      }
      uint64_t v33 = v37[0];
      v37[0] = 0;
      if (v33) {
        (*(void (**)(uint64_t))(*(void *)v33 + 8))(v33);
      }
      if (v40 < 0) {
        operator delete(__p[0]);
      }
      break;
    case 2:
      llvm::createNullStreamer(this, a3);
    case 0:
      uint64_t v20 = *(void *)(a2 + 560);
      uint64_t v21 = *(void *)(a2 + 8);
      uint64_t v22 = *(unsigned int *)(v20 + 176);
      unsigned int v23 = *(void (**)(void))(v21 + 288);
      if (v23)
      {
        unsigned int v34 = *(_DWORD *)(v20 + 176);
        v23();
        uint64_t v22 = v34;
      }
      unsigned int v24 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v21 + 136);
      if (v24) {
        v24(v9 + 448, v22, v20, v14, v13);
      }
      __p[0] = 0;
      uint64_t v25 = *(void *)(v9 + 8);
      if ((*(_WORD *)(v9 + 1128) & 0x200) != 0)
      {
        int v26 = *(uint64_t (**)(uint64_t, llvm *))(v25 + 144);
        if (v26)
        {
          int v26 = (uint64_t (*)(uint64_t, llvm *))v26(v14, this);
          uint64_t v25 = *(void *)(v9 + 8);
        }
        __p[0] = v26;
      }
      unsigned int v27 = *(uint64_t (**)(void))(v25 + 104);
      if (v27) {
        uint64_t v28 = v27();
      }
      else {
        uint64_t v28 = 0;
      }
      v37[0] = v28;
      operator new();
    default:
      uint64_t v15 = 0;
      break;
  }
  *(unsigned char *)(a6 + 8) &= ~1u;
  *(void *)a6 = v15;
}

void sub_1CC30DC14(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  unsigned int v7 = (llvm::TargetMachine **)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 152))(a1);
  *((unsigned char *)v7 + 129) = a3;
  (*(void (**)(uint64_t, llvm::TargetMachine **))(*(void *)a2 + 16))(a2, v7);
  (*((void (**)(llvm::TargetMachine **))*v7 + 19))(v7);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a4);
  llvm::TargetPassConfig::addISelPasses(v7);
}

uint64_t sub_1CC30DD38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a4 + 8) > 0x40u) {
    operator new[]();
  }
  sub_1CB90D414((uint64_t)v9, a8);
  sub_1CB90D414((uint64_t)v11, (uint64_t)v9);
  if (v12 == v11)
  {
    (*(void (**)(void *))(v11[0] + 32))(v11);
  }
  else if (v12)
  {
    (*(void (**)(void))(*v12 + 40))();
  }
  if (v10 == v9)
  {
    (*(void (**)(void *))(v9[0] + 32))(v9);
  }
  else if (v10)
  {
    (*(void (**)(void))(*v10 + 40))();
  }
  return 0;
}

uint64_t sub_1CC30DF50(llvm::DataLayout **a1, uint64_t a2, llvm::Value *this, llvm::Constant **a4, uint64_t a5)
{
  unsigned int v10 = llvm::Value::stripPointerCasts(this);
  if (*((unsigned __int8 *)v10 + 16) >= 4u) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = v10;
  }
  uint64_t v12 = *a1;
  unsigned int v13 = *(_DWORD *)(*(void *)this + 8);
  if ((v13 & 0xFE) == 0x12) {
    unsigned int v13 = *(_DWORD *)(**(void **)(*(void *)this + 16) + 8);
  }
  uint64_t v14 = *((void *)v12 + 29);
  if (v13 < 0x100) {
    goto LABEL_15;
  }
  unsigned int v15 = v13 >> 8;
  unint64_t v16 = *((unsigned int *)v12 + 60);
  uint64_t v17 = *((void *)v12 + 29);
  if (v16)
  {
    uint64_t v17 = v14;
    unint64_t v18 = v16;
    do
    {
      unint64_t v19 = v18 >> 1;
      uint64_t v20 = v17 + 16 * (v18 >> 1);
      unsigned int v21 = *(_DWORD *)(v20 + 8);
      uint64_t v22 = v20 + 16;
      v18 += ~(v18 >> 1);
      if (v21 < v15) {
        uint64_t v17 = v22;
      }
      else {
        unint64_t v18 = v19;
      }
    }
    while (v18);
  }
  if (v17 == v14 + 16 * v16 || *(_DWORD *)(v17 + 8) != v15) {
LABEL_15:
  }
    uint64_t v17 = v14;
  unsigned int v23 = *(_DWORD *)(v17 + 4);
  unsigned int v80 = v23;
  if (v23 > 0x40) {
    llvm::APInt::initSlowCase((llvm::APInt *)&v79);
  }
  unint64_t v79 = 0;
  unint64_t v77 = a4;
  uint64_t v78 = a2 | 4;
  if (!a5)
  {
    unsigned int v66 = v11 != 0;
    goto LABEL_99;
  }
  unint64_t v73 = v11;
  int v74 = this;
  uint64_t v24 = 0;
  uint64_t v25 = &a4[a5];
  do
  {
    uint64_t v26 = v24;
    unint64_t v27 = v78 & 0xFFFFFFFFFFFFFFF8;
    if ((v78 & 4) == 0 || !v27)
    {
      AggregateElement = *v77;
      if (*v77) {
        BOOL v29 = *((unsigned char *)*v77 + 16) == 16;
      }
      else {
        BOOL v29 = 0;
      }
      if (!v29) {
        AggregateElement = (llvm::Constant *)llvm::Constant::getAggregateElement(AggregateElement, 0);
      }
      uint64_t v32 = (unsigned int *)*((void *)AggregateElement + 3);
      uint64_t v30 = (unsigned int *)((char *)AggregateElement + 24);
      uint64_t v31 = v32;
      if (v30[2] < 0x41) {
        uint64_t v31 = v30;
      }
      unint64_t v27 = *(void *)(*(void *)(v27 + 16) + 8 * *v31);
    }
    uint64_t v33 = (unsigned int *)*a4;
    unsigned int v34 = *((unsigned __int8 *)*a4 + 16);
    if (*a4) {
      BOOL v35 = v34 == 16;
    }
    else {
      BOOL v35 = 0;
    }
    if (!v35)
    {
      if (v34 <= 0x14 && (*(_DWORD *)(*(void *)v33 + 8) & 0xFE) == 18)
      {
        SplatValue = (unsigned int *)llvm::Constant::getSplatValue(*a4, 0);
        if (!SplatValue)
        {
LABEL_79:
          uint64_t v33 = 0;
          goto LABEL_38;
        }
      }
      else
      {
        uint64_t v85 = 0;
        uint64_t v82 = (void **)&v85;
        int v37 = sub_1CC189A5C((uint64_t)&v81, (uint64_t)v33);
        uint64_t v33 = 0;
        if (!v37) {
          goto LABEL_38;
        }
        SplatValue = v85;
        if (!v85) {
          goto LABEL_79;
        }
      }
      if (*((unsigned char *)SplatValue + 16) == 16) {
        uint64_t v33 = SplatValue;
      }
      else {
        uint64_t v33 = 0;
      }
    }
LABEL_38:
    __int16 v38 = (llvm::Type *)(v78 & 0xFFFFFFFFFFFFFFF8);
    if ((v78 & 4) == 0 && v38)
    {
      int v39 = v33 + 6;
      if (v33[8] >= 0x41) {
        int v39 = *(unsigned int **)v39;
      }
      uint64_t v40 = *v39;
      StructLayout = llvm::DataLayout::getStructLayout(*a1, (llvm::StructType *)(v78 & 0xFFFFFFFFFFFFFFF8));
      llvm::APInt::operator+=((uint64_t)&v79, *((void *)StructLayout + v40 + 2));
LABEL_69:
      uint64_t v24 = v26;
      goto LABEL_70;
    }
    if (*(unsigned char *)(v27 + 8) == 19) {
      goto LABEL_98;
    }
    char v42 = *a1;
    if (!v38 || (v78 & 4) == 0)
    {
      uint64_t v43 = *v77;
      if (*v77) {
        BOOL v44 = *((unsigned char *)*v77 + 16) == 16;
      }
      else {
        BOOL v44 = 0;
      }
      if (!v44) {
        uint64_t v43 = (llvm::Constant *)llvm::Constant::getAggregateElement(v43, 0);
      }
      int v47 = (unsigned int *)*((void *)v43 + 3);
      int v45 = (unsigned int *)((char *)v43 + 24);
      unint64_t v46 = v47;
      if (v45[2] < 0x41) {
        unint64_t v46 = v45;
      }
      __int16 v38 = *(llvm::Type **)(*((void *)v38 + 2) + 8 * *v46);
    }
    unint64_t v48 = (unint64_t)(sub_1CB83544C((uint64_t)v42, (uint64_t)v38) + 7) >> 3;
    char Alignment = llvm::DataLayout::getAlignment(v42, v38, 1);
    uint64_t v24 = ((1 << Alignment) + v48 - 1) & -(1 << Alignment);
    if (v33)
    {
      llvm::APInt::sextOrTrunc((uint64_t)(v33 + 6), v23, (uint64_t)&v75);
      unsigned int v50 = v76;
      if (v76 <= 0x40)
      {
        uint64_t v75 = (llvm::APInt *)((void)v75 * v24);
        if (v76) {
          goto LABEL_57;
        }
LABEL_87:
        unint64_t v51 = 0;
        goto LABEL_58;
      }
      llvm::APInt::tcMultiplyPart(v75, (unint64_t *)v75, (const unint64_t *)v24, 0, ((unint64_t)v76 + 63) >> 6, ((unint64_t)v76 + 63) >> 6, 0);
      unsigned int v50 = v76;
      if (!v76) {
        goto LABEL_87;
      }
LABEL_57:
      unint64_t v51 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v50;
      if (v50 >= 0x41) {
        int v52 = (llvm::APInt **)((char *)v75 + 8 * (((unint64_t)v50 + 63) >> 6) - 8);
      }
      else {
LABEL_58:
      }
        int v52 = &v75;
      *int v52 = (llvm::APInt *)((unint64_t)*v52 & v51);
      unsigned int v53 = v76;
      uint64_t v54 = v75;
      unsigned int v76 = 0;
      char v55 = v80;
      if (v80 >= 0x41)
      {
        uint64_t v58 = 0;
        uint64_t v59 = (unint64_t *)v79;
        unint64_t v60 = ((unint64_t)v80 + 63) >> 6;
        unint64_t v61 = v75;
        unint64_t v62 = v60;
        do
        {
          uint64_t v63 = *(void *)v61;
          unint64_t v61 = (llvm::APInt *)((char *)v61 + 8);
          unint64_t v64 = v63 + *v59;
          BOOL v65 = v64 + 1 <= *v59;
          if (v58)
          {
            ++v64;
            uint64_t v58 = v65;
          }
          else
          {
            uint64_t v58 = v64 < *v59;
          }
          *v59++ = v64;
          --v62;
        }
        while (v62);
        *(void *)(v79 + 8 * (v60 - 1)) &= 0xFFFFFFFFFFFFFFFFLL >> -v55;
      }
      else
      {
        if (v80) {
          unint64_t v56 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v80;
        }
        else {
          unint64_t v56 = 0;
        }
        unint64_t v79 = v56 & ((unint64_t)v75 + v79);
      }
      if (v53 >= 0x41 && v54) {
        MEMORY[0x1D25D9CB0](v54, 0x1000C8000313F17);
      }
      if (v76 >= 0x41 && v75) {
        MEMORY[0x1D25D9CB0](v75, 0x1000C8000313F17);
      }
      goto LABEL_69;
    }
    if (v26)
    {
LABEL_98:
      unsigned int v66 = 1;
      goto LABEL_99;
    }
LABEL_70:
    ++a4;
    sub_1CB90797C((uint64_t)&v77);
  }
  while (a4 != v25);
  if (v80 <= 0x3F)
  {
    uint64_t v68 = (uint64_t)(v79 << -(char)v80) >> -(char)v80;
    unint64_t v69 = v73;
    BOOL v67 = v74;
  }
  else
  {
    BOOL v67 = v74;
    if (v80 == 64) {
      uint64_t v68 = v79;
    }
    else {
      uint64_t v68 = *(void *)v79;
    }
    unint64_t v69 = v73;
  }
  uint64_t v70 = *(void *)v67;
  unsigned int v71 = *(_DWORD *)(*(void *)v67 + 8);
  if ((v71 & 0xFE) == 0x12) {
    unsigned int v71 = *(_DWORD *)(**(void **)(v70 + 16) + 8);
  }
  unint64_t v81 = v69;
  uint64_t v82 = (void **)v68;
  BOOL v83 = v69 == 0;
  uint64_t v84 = v24;
  unsigned int v66 = (*(uint64_t (**)(llvm::DataLayout *, llvm::DataLayout *, llvm::Value **, unint64_t, void, void))(*(void *)a1[2] + 1064))(a1[2], *a1, &v81, v27, v71 >> 8, 0) ^ 1;
LABEL_99:
  if (v80 >= 0x41 && v79) {
    MEMORY[0x1D25D9CB0](v79, 0x1000C8000313F17);
  }
  return v66;
}

uint64_t sub_1CC30E504(uint64_t a1, int **this, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = (llvm::ShuffleVectorInst *)this;
  v118[7] = *MEMORY[0x1E4F143B8];
  unsigned int v7 = *((unsigned __int8 *)this + 16);
  uint64_t v8 = v7 - 28;
  if (v7 < 0x1C) {
    goto LABEL_16;
  }
  if (v7 == 33 || v7 == 39) {
    goto LABEL_9;
  }
  if (v7 == 84)
  {
    uint64_t v9 = (uint64_t)*(this - 4);
    if (!v9
      || *(unsigned char *)(v9 + 16)
      || *(int **)(v9 + 24) != this[9]
      || (unsigned int v10 = (llvm::ShuffleVectorInst *)this, (*(unsigned char *)(v9 + 33) & 0x20) == 0))
    {
LABEL_9:
      uint64_t v11 = (uint64_t)*(this - 4);
      if (!v11 || *(unsigned char *)(v11 + 16) || *(int **)(v11 + 24) != this[9])
      {
        if (v7 == 84)
        {
          uint64_t v12 = 0;
        }
        else if (v7 == 39)
        {
          uint64_t v12 = (*((_DWORD *)this + 20) + 1);
        }
        else
        {
          uint64_t v12 = 2;
        }
        int v13 = 0;
        int v14 = *((_DWORD *)this + 5);
        uint64_t v15 = -(uint64_t)(v14 & 0x7FFFFFF);
        if (v14 < 0)
        {
          unint64_t v103 = &this[-4 * (v14 & 0x7FFFFFF)];
          uint64_t v104 = (uint64_t)*(v103 - 1);
          if ((v104 & 0xFFFFFFFF0) != 0) {
            int v13 = *((_DWORD *)v103 - 3) - *(_DWORD *)((char *)v103 - v104);
          }
          else {
            int v13 = 0;
          }
        }
        return ((-32 * v12 + 32 * (unint64_t)-v13 - 32 * v15 - 32) >> 5) + 1;
      }
      if (sub_1CB9091FC(a1, (uint64_t ***)*(this - 4))) {
        return *(unsigned int *)(*(void *)(v11 + 24) + 12);
      }
      return 1;
    }
  }
  else
  {
LABEL_16:
    unsigned int v10 = 0;
  }
  int v17 = *((_DWORD *)this + 5);
  uint64_t v18 = v17 & 0x7FFFFFF;
  if ((v17 & 0x7FFFFFF) == 1)
  {
    if ((v17 & 0x40000000) != 0) {
      unint64_t v19 = (llvm::Type *****)*(this - 1);
    }
    else {
      unint64_t v19 = (llvm::Type *****)(this - 4);
    }
    uint64_t v20 = **v19;
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v21 = (uint64_t)*this;
  if (v7 <= 0x1B)
  {
    if (v7 != 5) {
      return 1;
    }
    uint64_t v8 = *((unsigned __int16 *)this + 9);
  }
  unint64_t v16 = 0;
  uint64_t v22 = a1 - 8;
  switch((int)v8)
  {
    case 1:
    case 2:
    case 3:
    case 55:
      if (a5) {
        BOOL v25 = v8 == 55;
      }
      else {
        BOOL v25 = 0;
      }
      return !v25;
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
      LODWORD(v110) = 0;
      LODWORD(v108) = 0;
      if ((v17 & 0x40000000) != 0) {
        uint64_t v26 = (uint64_t *)*(this - 1);
      }
      else {
        uint64_t v26 = (uint64_t *)&this[-4 * v18];
      }
      llvm::TargetTransformInfo::getOperandInfo(*v26, &v110);
      if (v8 != 12)
      {
        int v44 = *((_DWORD *)v6 + 5);
        if ((v44 & 0x40000000) != 0) {
          int v45 = (char *)*((void *)v6 - 1);
        }
        else {
          int v45 = (char *)v6 - 32 * (v44 & 0x7FFFFFF);
        }
        llvm::TargetTransformInfo::getOperandInfo(*((void *)v45 + 4), &v108);
      }
      int v46 = *((_DWORD *)v6 + 5);
      if ((v46 & 0x40000000) != 0)
      {
        unint64_t v48 = (uint64_t *)*((void *)v6 - 1);
        unint64_t v47 = v46 & 0x7FFFFFF;
      }
      else
      {
        unint64_t v47 = v46 & 0x7FFFFFF;
        unint64_t v48 = (uint64_t *)((char *)v6 - 32 * v47);
      }
      int v112 = &v114;
      uint64_t v113 = 0x200000000;
      if (v47 >= 3) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v47)
      {
        uint64_t v49 = 32 * v47;
        unsigned int v50 = &v114;
        do
        {
          uint64_t v51 = *v48;
          v48 += 4;
          *v50++ = v51;
          v49 -= 32;
        }
        while (v49);
        int v52 = (uint64_t *)v112;
      }
      else
      {
        int v52 = &v114;
      }
      LODWORD(v113) = v47;
      unint64_t v16 = sub_1CD522C04(v22, v8, v21, a5, (uint64_t)v52, v47);
      __int16 v38 = v112;
      if (v112 != &v114) {
        goto LABEL_95;
      }
      return v16;
    case 31:
      if (*((unsigned char *)*(this - 4) + 16) != 16) {
        return 1;
      }
      uint64_t v40 = this[5];
      uint64_t v41 = *(void *)(*((void *)v40 + 7) + 80);
      uint64_t v42 = v41 ? v41 - 24 : 0;
      return v40 != (int *)v42 || (*((_WORD *)this + 9) & 0x40) != 0;
    case 32:
      if (a5 == 2)
      {
        unint64_t v73 = this[1];
        if (v73)
        {
          if (!*((void *)v73 + 1) && (*(_DWORD *)(v21 + 8) & 0xFE) != 0x12)
          {
            uint64_t v74 = *((void *)v73 + 3);
            if (v74)
            {
              if (*(unsigned char *)(v74 + 16) == 66) {
                uint64_t v21 = *(void *)v74;
              }
            }
          }
        }
      }
      uint64_t v75 = a1 - 8;
      int v76 = 32;
      unint64_t v77 = (llvm::EVT *)v21;
      return sub_1CD522FB8(v75, v76, v77, a5);
    case 33:
      if ((v17 & 0x40000000) != 0) {
        uint64_t v72 = (llvm::EVT ***)*(this - 1);
      }
      else {
        uint64_t v72 = (llvm::EVT ***)&this[-4 * v18];
      }
      unint64_t v77 = **v72;
      uint64_t v75 = a1 - 8;
      int v76 = 33;
      return sub_1CD522FB8(v75, v76, v77, a5);
    case 34:
      BOOL v25 = v7 == 62;
      uint64_t v34 = 3;
      if (v25) {
        uint64_t v34 = 8;
      }
      uint64_t v35 = (uint64_t)this[v34];
      if ((v17 & 0x40000000) != 0) {
        uint64_t v36 = (llvm::Value **)*((void *)v6 - 1);
      }
      else {
        uint64_t v36 = (llvm::Value **)((char *)v6 - 32 * v18);
      }
      return sub_1CC30DF50((llvm::DataLayout **)a1, v35, *v36, (llvm::Constant **)(a3 + 8), a4 - 1);
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
      if (v7 <= 0x1B) {
        uint64_t v6 = 0;
      }
      unsigned int CastContextHint = llvm::TargetTransformInfo::getCastContextHint((uint64_t)v6);
      return sub_1CC30FB74(v22, v8, (llvm::Type ***)v21, v20, CastContextHint, a5, (uint64_t)v6);
    case 53:
    case 54:
      if ((v17 & 0x40000000) != 0) {
        uint64_t v70 = (uint64_t **)*(this - 1);
      }
      else {
        uint64_t v70 = (uint64_t **)&this[-4 * v18];
      }
      return sub_1CD523148(a1 - 8, v8, **v70, (uint64_t)*this, a5);
    case 56:
      llvm::IntrinsicCostAttributes::IntrinsicCostAttributes((uint64_t)&v112, (*(this - 4))[9], (uint64_t)v10, 0, 1);
      unint64_t v16 = sub_1CC30F1CC(v22, (uint64_t)&v112, a5);
      if (v117 != v118) {
        free(v117);
      }
      __int16 v38 = v115;
      if (v115 != &v116) {
LABEL_95:
      }
        free(v38);
      return v16;
    case 57:
      *(void *)uint64_t v107 = 0;
      uint64_t v108 = 0;
      int v112 = &v108;
      uint64_t v113 = (uint64_t)v107;
      if ((sub_1CB90D004((void **)&v112, (uint64_t)this) & 1) != 0
        || (uint64_t v110 = (llvm::Type *)&v108, v111 = v107, (sub_1CB90D1A4((void **)&v110, (uint64_t)v6) & 1) != 0))
      {
        LODWORD(v110) = 0;
        int v106 = 0;
        llvm::TargetTransformInfo::getOperandInfo(v108, &v110);
        llvm::TargetTransformInfo::getOperandInfo(*(uint64_t *)v107, &v106);
        int v112 = &v114;
        uint64_t v114 = v108;
        uint64_t v115 = *(uint64_t **)v107;
        uint64_t v113 = 0x200000002;
        if (sub_1CB90D2C0((uint64_t)v105, (unsigned __int8 *)v6)) {
          uint64_t v71 = 29;
        }
        else {
          uint64_t v71 = 28;
        }
        unint64_t v16 = sub_1CD522C04(v22, v71, v21, a5, (uint64_t)v112, v113);
        if (v112 != &v114) {
          free(v112);
        }
      }
      else
      {
        int v78 = *((_DWORD *)v6 + 5);
        if ((v78 & 0x40000000) != 0) {
          unint64_t v79 = (uint64_t **)*((void *)v6 - 1);
        }
        else {
          unint64_t v79 = (uint64_t **)((char *)v6 - 32 * (v78 & 0x7FFFFFF));
        }
        return sub_1CD523148(v22, 57, *(void *)v6, **v79, a5);
      }
      return v16;
    case 61:
      if (v7 != 89) {
        return 1;
      }
      if ((v17 & 0x40000000) != 0) {
        int v37 = (int **)*(this - 1);
      }
      else {
        int v37 = &this[-4 * v18];
      }
      uint64_t v53 = *(void *)*v37;
      unint64_t v54 = *(void *)(a1 + 16);
      if ((*(_DWORD *)(v53 + 8) & 0xFE) == 0x12) {
        uint64_t v53 = **(void **)(v53 + 16);
      }
      char v55 = *(llvm::LLVMContext **)v53;
      unint64_t v56 = sub_1CB87DC14(*(void *)(a1 + 16), *(void *)a1, (llvm::EVT *)v53, 0);
      uint64_t v58 = v57;
      uint64_t v108 = 1;
      LODWORD(v109) = 0;
      while (2)
      {
        llvm::TargetLoweringBase::getTypeConversion(v54, v55, v56, v58, (uint64_t)&v112);
        if (!(_BYTE)v112) {
          return v108;
        }
        if (v112 == 10) {
          return 0;
        }
        if ((v112 & 0xFB) == 2)
        {
          uint64_t v110 = (llvm::Type *)2;
          LODWORD(v111) = 0;
          sub_1CB90C9D4((uint64_t)&v108, (uint64_t)&v110);
        }
        int v59 = v56;
        unint64_t v56 = v113;
        if (v59 != v113)
        {
          uint64_t v60 = v114;
LABEL_106:
          uint64_t v58 = v60;
          continue;
        }
        break;
      }
      if (!v59)
      {
        uint64_t v60 = v114;
        if (v58 != v114) {
          goto LABEL_106;
        }
      }
      return v108;
    case 62:
      if (v7 != 90) {
        return 1;
      }
      unint64_t v27 = *(void *)(a1 + 16);
      if ((*(_DWORD *)(v21 + 8) & 0xFE) == 0x12) {
        uint64_t v21 = **(void **)(v21 + 16);
      }
      uint64_t v28 = *(llvm::Type ***)v21;
      unint64_t v29 = sub_1CB87DC14(*(void *)(a1 + 16), *(void *)a1, (llvm::EVT *)v21, 0);
      uint64_t v31 = v30;
      uint64_t v108 = 1;
      LODWORD(v109) = 0;
      while (2)
      {
        llvm::TargetLoweringBase::getTypeConversion(v27, (llvm::LLVMContext *)v28, v29, v31, (uint64_t)&v112);
        if (!(_BYTE)v112) {
          return v108;
        }
        if (v112 == 10) {
          return 0;
        }
        if ((v112 & 0xFB) == 2)
        {
          uint64_t v110 = (llvm::Type *)2;
          LODWORD(v111) = 0;
          sub_1CB90C9D4((uint64_t)&v108, (uint64_t)&v110);
        }
        int v32 = v29;
        unint64_t v29 = v113;
        if (v32 == v113)
        {
          if (v32) {
            return v108;
          }
          uint64_t v33 = v114;
          if (v31 == v114) {
            return v108;
          }
        }
        else
        {
          uint64_t v33 = v114;
        }
        uint64_t v31 = v33;
        continue;
      }
    case 63:
      if (v7 != 91) {
        return 1;
      }
      if ((v17 & 0x40000000) != 0) {
        int v39 = (uint64_t **)*(this - 1);
      }
      else {
        int v39 = (uint64_t **)&this[-4 * v18];
      }
      uint64_t v61 = **v39;
      LODWORD(v110) = 0;
      LODWORD(v108) = 0;
      unint64_t v62 = (uint64_t *)*(this - 8);
      uint64_t v63 = *v62;
      uint64_t v64 = *(unsigned int *)(*v62 + 32);
      uint64_t v65 = *((unsigned int *)this + 18);
      if (v64 != v65)
      {
        if (v64 >= v65
          || (llvm::ShuffleVectorInst::isIdentityWithPadding((llvm::ShuffleVectorInst *)this) & 1) == 0)
        {
          if (*(unsigned char *)(v21 + 8) == 19) {
            goto LABEL_123;
          }
          unint64_t v69 = (int *)*((void *)v6 + 8);
          if (llvm::ShuffleVectorInst::isExtractSubvectorMask(v69, v65, v64, (int *)&v108))
          {
            uint64_t v67 = v22;
            uint64_t v68 = 5;
            uint64_t v87 = v61;
            uint64_t v88 = v69;
            uint64_t v89 = v65;
            uint64_t v90 = v21;
            return sub_1CD52331C(v67, v68, v87, v88, v89, v90);
          }
          if (*(unsigned char *)(v21 + 8) == 19
            || !llvm::ShuffleVectorInst::isInsertSubvectorMask(v69, v65, *(_DWORD *)(v63 + 32), &v110, (signed int *)&v108))
          {
LABEL_123:
            int v106 = 0;
            v107[0] = 0;
            if (llvm::ShuffleVectorInst::isReplicationMask(v6, v107, &v106))
            {
              unsigned int v80 = *((_DWORD *)v6 + 18);
              LODWORD(v113) = v80;
              if (v80 > 0x40) {
                llvm::APInt::initSlowCase((llvm::APInt *)&v112);
              }
              int v112 = 0;
              if (v80)
              {
                uint64_t v81 = 0;
                uint64_t v82 = *((void *)v6 + 8);
                uint64_t v83 = v80;
                unsigned int v84 = v113;
                uint64_t v85 = 4 * v83;
                do
                {
                  if (*(_DWORD *)(v82 + 4 * v81) != -1)
                  {
                    uint64_t v86 = 1 << v81;
                    if (v84 > 0x40) {
                      *((void *)v112 + (v81 >> 6)) |= v86;
                    }
                    else {
                      int v112 = (void *)((unint64_t)v112 | v86);
                    }
                  }
                  ++v81;
                  v85 -= 4;
                }
                while (v85);
              }
              unint64_t v16 = sub_1CD5233F8(v22, *(llvm::FixedVectorType **)(v61 + 24), v107[0], (llvm::Type *)v106, (llvm::APIntOps *)&v112);
              if (v113 >= 0x41 && v112) {
                MEMORY[0x1D25D9CB0](v112, 0x1000C8000313F17);
              }
            }
            else if (a5)
            {
              return 1;
            }
            else
            {
              return -1;
            }
            return v16;
          }
          unint64_t v91 = (int *)*((void *)v6 + 8);
          uint64_t v92 = *((unsigned int *)v6 + 18);
          unsigned int v93 = (llvm::FixedVectorType *)v21;
          if ((*(_DWORD *)(v21 + 8) & 0xFE) == 0x12) {
            unsigned int v93 = **(llvm::FixedVectorType ***)(v21 + 16);
          }
          llvm::FixedVectorType::get(v93, (llvm::Type *)v110);
          uint64_t v90 = v94;
          uint64_t v67 = v22;
          uint64_t v68 = 4;
          uint64_t v87 = v21;
          uint64_t v88 = v91;
          uint64_t v89 = v92;
          return sub_1CD52331C(v67, v68, v87, v88, v89, v90);
        }
        return 0;
      }
      unsigned int v66 = this[8];
      if (sub_1CC5D47FC(v66, *(unsigned int *)(*v62 + 32), *(_DWORD *)(*v62 + 32))) {
        return 0;
      }
      if (llvm::ShuffleVectorInst::isReverseMask(v66, v64))
      {
        uint64_t v67 = v22;
        uint64_t v68 = 1;
LABEL_193:
        uint64_t v87 = v21;
        uint64_t v88 = v66;
        uint64_t v89 = v64;
        uint64_t v90 = 0;
        return sub_1CD52331C(v67, v68, v87, v88, v89, v90);
      }
      if (llvm::ShuffleVectorInst::isSelectMask(v66, v64))
      {
        uint64_t v67 = v22;
        uint64_t v68 = 2;
        goto LABEL_193;
      }
      if (llvm::ShuffleVectorInst::isTransposeMask(v66, v64))
      {
        uint64_t v67 = v22;
        uint64_t v68 = 3;
        goto LABEL_193;
      }
      if (llvm::ShuffleVectorInst::isZeroEltSplatMask(v66, v64))
      {
        uint64_t v67 = v22;
        uint64_t v68 = 0;
        goto LABEL_193;
      }
      if (v64)
      {
        char v95 = 0;
        char v96 = 0;
        uint64_t v97 = 4 * v64;
        uint64_t v98 = v66;
        while (1)
        {
          int v99 = *v98;
          if (*v98 != -1)
          {
            v95 |= v99 < (int)v64;
            v96 |= v99 >= (int)v64;
            if (v95 & 1) != 0 && (v96) {
              break;
            }
          }
          ++v98;
          v97 -= 4;
          if (!v97)
          {
            if (v95) {
              goto LABEL_192;
            }
            goto LABEL_184;
          }
        }
      }
      else
      {
        char v96 = 0;
LABEL_184:
        if (v96)
        {
LABEL_192:
          uint64_t v67 = v22;
          uint64_t v68 = 7;
          goto LABEL_193;
        }
      }
      if (*(unsigned char *)(v21 + 8) == 19
        || (isInsertSubvectorMask = llvm::ShuffleVectorInst::isInsertSubvectorMask(v66, v64, v64, &v110, (signed int *)&v108), uint64_t v64 = *((unsigned int *)v6 + 18), v66 = (int *)*((void *)v6 + 8), !isInsertSubvectorMask))
      {
        uint64_t v67 = v22;
        uint64_t v68 = 6;
        goto LABEL_193;
      }
      uint64_t v101 = (llvm::FixedVectorType *)v21;
      if ((*(_DWORD *)(v21 + 8) & 0xFE) == 0x12) {
        uint64_t v101 = **(llvm::FixedVectorType ***)(v21 + 16);
      }
      llvm::FixedVectorType::get(v101, (llvm::Type *)v110);
      uint64_t v90 = v102;
      uint64_t v67 = v22;
      uint64_t v68 = 4;
      uint64_t v87 = v21;
      uint64_t v88 = v66;
      uint64_t v89 = v64;
      return sub_1CD52331C(v67, v68, v87, v88, v89, v90);
    case 64:
    case 67:
      return v16;
    default:
      return 1;
  }
}

uint64_t sub_1CC30F1CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a1 + 8;
  uint64_t v7 = sub_1CB90A9F8(a1 + 8, a2);
  BOOL v9 = v7 < 0;
  if (v8) {
    BOOL v9 = v8 < 0;
  }
  if (!v9)
  {
    BOOL v10 = v8 < 1;
    if (!v8) {
      BOOL v10 = v7 < 1;
    }
    if (v10) {
      return 0;
    }
  }
  int v12 = *(_DWORD *)(a2 + 16);
  if (v12 > 0x181) {
    return 1;
  }
  unsigned int v13 = *(_DWORD *)(a2 + 80);
  if (!v13) {
    return sub_1CC310550(a1, a2, a3);
  }
  int v14 = *(_DWORD **)(a2 + 8);
  int v15 = v14[2];
  if ((v14[2] & 0xFE) == 0x12) {
    unint64_t v16 = v14[8] | ((unint64_t)(v15 == 19) << 32);
  }
  else {
    unint64_t v16 = 1;
  }
  uint64_t v18 = *(void *)a2;
  int v19 = *(_DWORD *)(a2 + 120);
  if (v12 <= 185)
  {
    if (v12 <= 147)
    {
      switch(v12)
      {
        case 130:
          if (v15 == 19) {
            return sub_1CB90A9F8(v6, a2);
          }
          return 1;
        case 131:
          if (v15 == 19) {
            return sub_1CB90A9F8(v6, a2);
          }
          uint64_t v57 = ***(void ***)(a2 + 72);
          uint64_t v58 = a1;
          uint64_t v59 = 5;
          goto LABEL_115;
        case 132:
          char v55 = *(uint64_t ***)(a2 + 72);
          uint64_t v56 = *v55[1];
          if (*(unsigned char *)(v56 + 8) == 19) {
            return sub_1CB90A9F8(v6, a2);
          }
          uint64_t v57 = **v55;
          uint64_t v58 = a1;
          uint64_t v59 = 4;
          return sub_1CD52331C(v58, v59, v57, 0, 0, v56);
        case 133:
          uint64_t v57 = ***(void ***)(a2 + 72);
          uint64_t v58 = a1;
          uint64_t v59 = 1;
          goto LABEL_115;
        case 134:
          uint64_t v57 = ***(void ***)(a2 + 72);
          uint64_t v58 = a1;
          uint64_t v59 = 8;
LABEL_115:
          uint64_t v56 = *(void *)(a2 + 8);
          return sub_1CD52331C(v58, v59, v57, 0, 0, v56);
        default:
          if (v12 == 52)
          {
            if (v16 != 1) {
              goto LABEL_86;
            }
            char v38 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 224))(*(void *)(a1 + 24));
          }
          else
          {
            if (v12 != 54 || v16 != 1) {
              goto LABEL_86;
            }
            char v38 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 216))(*(void *)(a1 + 24));
          }
          unint64_t v61 = 0;
          unint64_t v11 = 1;
          if (v38) {
            return v11;
          }
          break;
      }
      goto LABEL_95;
    }
    if ((v12 - 148) >= 2)
    {
      if (v12 == 153)
      {
        unint64_t v42 = sub_1CB87DC14(*(void *)(a1 + 24), *(void *)(a1 + 8), *(llvm::EVT **)(a2 + 8), (llvm::Type *)1);
        uint64_t v44 = v43;
        unint64_t v45 = sub_1CB87DC14(*(void *)(a1 + 24), *(void *)(a1 + 8), **(llvm::EVT ***)(a2 + 24), (llvm::Type *)1);
        if ((*(uint64_t (**)(void, unint64_t, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 24) + 104))(*(void *)(a1 + 24), v42, v44, v45, v46))
        {
          uint64_t v83 = **(uint64_t ****)(a2 + 24);
          unsigned int v84 = (llvm::Type *)v14[8];
          if (*((unsigned char *)v14 + 8) == 19) {
            llvm::ScalableVectorType::get(v83, v84);
          }
          else {
            llvm::FixedVectorType::get((llvm::FixedVectorType *)v83, v84);
          }
          uint64_t v86 = v85;
          uint64_t v96 = 0;
          uint64_t v97 = (_DWORD *)v85;
          LODWORD(v98) = 300;
          int v99 = v101;
          uint64_t v102 = v104;
          uint64_t v103 = 0x400000000;
          int v105 = v19;
          long long v106 = xmmword_1CD96D880;
          uint64_t v100 = 0x400000000;
          unint64_t v87 = sub_1CC310550(a1, (uint64_t)&v96, a3);
          unint64_t v88 = sub_1CD523148(a1, 53, v86, (uint64_t)v14, a3);
          if (__OFADD__(v87, v88)) {
            unint64_t v11 = ((uint64_t)(v87 + v88) >> 63) ^ 0x8000000000000000;
          }
          else {
            unint64_t v11 = v87 + v88;
          }
          if (v102 != v104) {
            free(v102);
          }
          uint64_t v22 = v99;
          if (v99 != v101) {
            goto LABEL_23;
          }
        }
        else
        {
          unint64_t v47 = *(void *)(a1 + 24);
          uint64_t v48 = *(void *)(a1 + 8);
          uint64_t v49 = *(llvm::LLVMContext **)v14;
          unint64_t v50 = sub_1CB87DC14(v47, v48, (llvm::EVT *)v14, 0);
          uint64_t v52 = v51;
          uint64_t v94 = 1;
          LODWORD(v95) = 0;
          while (1)
          {
            llvm::TargetLoweringBase::getTypeConversion(v47, v49, v50, v52, (uint64_t)&v96);
            if (!(_BYTE)v96) {
              return v94;
            }
            if (v96 == 10) {
              break;
            }
            if ((v96 & 0xFB) == 2)
            {
              uint64_t __src = 2;
              LODWORD(v108) = 0;
              sub_1CB90C9D4((uint64_t)&v94, (uint64_t)&__src);
            }
            int v53 = v50;
            unint64_t v50 = (unint64_t)v97;
            if (v53 == v97)
            {
              if (v53) {
                return v94;
              }
              uint64_t v54 = v98;
              if (v52 == v98) {
                return v94;
              }
            }
            else
            {
              uint64_t v54 = v98;
            }
            uint64_t v52 = v54;
          }
          return 0;
        }
        return v11;
      }
      if (v12 == 184)
      {
        uint64_t v77 = *(void *)(a2 + 72);
        uint64_t v78 = *(void *)(v77 + 8);
        unsigned int v79 = *(unsigned __int8 *)(*(void *)(v77 + 16) + 16);
        unsigned int v80 = (unint64_t *)(v78 + 24);
        if (*(_DWORD *)(v78 + 32) >= 0x41u) {
          unsigned int v80 = (unint64_t *)*v80;
        }
        BOOL v66 = v79 > 0x14;
        unint64_t v81 = *v80;
        unint64_t v82 = __clz(v81) ^ 0x3F;
        if (v81) {
          uint64_t v70 = v82;
        }
        else {
          uint64_t v70 = 0;
        }
        uint64_t v71 = a1;
        int v72 = 32;
        uint64_t v69 = *(void *)(a2 + 8);
        return sub_1CD523948(v71, v72, v69, v70, v66, 1, a3);
      }
      goto LABEL_86;
    }
    if (v15 != 19)
    {
      unsigned int v23 = *(uint64_t **)(a2 + 72);
      uint64_t v24 = *v23;
      uint64_t v25 = v23[1];
      uint64_t v26 = v23[2];
      LODWORD(v96) = 0;
      LODWORD(__src) = 0;
      LODWORD(v94) = 0;
      llvm::TargetTransformInfo::getOperandInfo(v24, &v96);
      llvm::TargetTransformInfo::getOperandInfo(v25, &__src);
      int OperandInfo = llvm::TargetTransformInfo::getOperandInfo(v26, &v94);
      unint64_t v28 = sub_1CD522C04(a1, 29, (uint64_t)v14, a3, 0, 0);
      unint64_t v29 = sub_1CD522C04(a1, 15, (uint64_t)v14, a3, 0, 0);
      if (__OFADD__(v28, v29)) {
        unint64_t v30 = ((uint64_t)(v28 + v29) >> 63) ^ 0x8000000000000000;
      }
      else {
        unint64_t v30 = v28 + v29;
      }
      unint64_t v31 = sub_1CD522C04(a1, 25, (uint64_t)v14, a3, 0, 0);
      if (__OFADD__(v30, v31)) {
        unint64_t v32 = ((uint64_t)(v30 + v31) >> 63) ^ 0x8000000000000000;
      }
      else {
        unint64_t v32 = v30 + v31;
      }
      unint64_t v33 = sub_1CD522C04(a1, 26, (uint64_t)v14, a3, 0, 0);
      if (__OFADD__(v32, v33)) {
        unint64_t v11 = ((uint64_t)(v32 + v33) >> 63) ^ 0x8000000000000000;
      }
      else {
        unint64_t v11 = v32 + v33;
      }
      if ((OperandInfo - 4) <= 0xFFFFFFFD)
      {
        unint64_t v90 = sub_1CD522C04(a1, 22, (uint64_t)v14, a3, 0, 0);
        if (__OFADD__(v11, v90)) {
          unint64_t v11 = ((uint64_t)(v11 + v90) >> 63) ^ 0x8000000000000000;
        }
        else {
          v11 += v90;
        }
      }
      if (v24 != v25)
      {
        uint64_t v34 = **(void **)v14 + 1888;
        if ((v14[2] & 0xFE) == 0x12)
        {
          unint64_t v91 = (llvm::Type *)v14[8];
          uint64_t v92 = (uint64_t **)(**(void **)v14 + 1888);
          if (v14[2] == 19) {
            llvm::ScalableVectorType::get(v92, v91);
          }
          else {
            llvm::FixedVectorType::get((llvm::FixedVectorType *)v92, v91);
          }
          uint64_t v34 = v93;
        }
        unint64_t v35 = sub_1CD523148(a1, 53, (uint64_t)v14, v34, a3);
        if (__OFADD__(v11, v35)) {
          unint64_t v36 = ((uint64_t)(v11 + v35) >> 63) ^ 0x8000000000000000;
        }
        else {
          unint64_t v36 = v11 + v35;
        }
        unint64_t v37 = sub_1CD523148(a1, 57, (uint64_t)v14, v34, a3);
        if (__OFADD__(v36, v37)) {
          return ((uint64_t)(v36 + v37) >> 63) ^ 0x8000000000000000;
        }
        else {
          return v36 + v37;
        }
      }
      return v11;
    }
    return sub_1CB90A9F8(v6, a2);
  }
  if ((v12 - 317) <= 0xC)
  {
    if (((1 << (v12 - 61)) & 0x1FDB) != 0)
    {
      uint64_t __src = ***(void ***)(a2 + 72);
      uint64_t v96 = v18;
      uint64_t v97 = v14;
      LODWORD(v98) = v12;
      int v99 = v101;
      uint64_t v100 = 0x400000000;
      uint64_t v102 = v104;
      uint64_t v103 = 0x400000000;
      int v105 = v19;
      long long v106 = xmmword_1CD91D2E0;
      uint64_t v20 = (char *)&v108;
    }
    else
    {
      int v39 = *(uint64_t ***)(a2 + 72);
      uint64_t v41 = *v39;
      uint64_t v40 = v39[1];
      uint64_t __src = *v41;
      uint64_t v108 = *v40;
      uint64_t v96 = v18;
      uint64_t v97 = v14;
      LODWORD(v98) = v12;
      int v99 = v101;
      uint64_t v100 = 0x400000000;
      uint64_t v102 = v104;
      uint64_t v103 = 0x400000000;
      int v105 = v19;
      long long v106 = xmmword_1CD91D2E0;
      uint64_t v20 = (char *)&v109;
    }
    p_src = (char *)&__src;
    goto LABEL_20;
  }
  if (v12 == 194) {
    return 4;
  }
  if (v12 == 186)
  {
    uint64_t v62 = *(void *)(a2 + 72);
    uint64_t v63 = *(void *)(v62 + 16);
    unsigned int v64 = *(unsigned __int8 *)(*(void *)(v62 + 24) + 16);
    uint64_t v65 = (unint64_t *)(v63 + 24);
    if (*(_DWORD *)(v63 + 32) >= 0x41u) {
      uint64_t v65 = (unint64_t *)*v65;
    }
    BOOL v66 = v64 > 0x14;
    unint64_t v67 = *v65;
    unint64_t v68 = __clz(v67) ^ 0x3F;
    uint64_t v69 = **(void **)(a2 + 24);
    if (v67) {
      uint64_t v70 = v68;
    }
    else {
      uint64_t v70 = 0;
    }
    uint64_t v71 = a1;
    int v72 = 33;
    return sub_1CD523948(v71, v72, v69, v70, v66, 1, a3);
  }
LABEL_86:
  unint64_t v61 = 0;
  unint64_t v11 = 1;
  if (!HIDWORD(v16) && v16 >= 2)
  {
    if (v15 == 7)
    {
      unint64_t v11 = 0;
      unint64_t v73 = 0;
    }
    else
    {
      unint64_t v73 = sub_1CD5234F4(a1, *(void *)(a2 + 8), 1, 0);
      unint64_t v11 = v89 == 1;
      unsigned int v13 = *(_DWORD *)(a2 + 80);
    }
    unint64_t v74 = sub_1CC3121A4(a1, *(void *)(a2 + 72), v13, *(void *)(a2 + 24));
    if (v75 == 1) {
      unint64_t v11 = 1;
    }
    if (__OFADD__(v73, v74)) {
      unint64_t v61 = ((uint64_t)(v73 + v74) >> 63) ^ 0x8000000000000000;
    }
    else {
      unint64_t v61 = v73 + v74;
    }
  }
LABEL_95:
  p_src = *(char **)(a2 + 24);
  uint64_t v76 = *(unsigned int *)(a2 + 32);
  uint64_t v96 = v18;
  uint64_t v97 = v14;
  LODWORD(v98) = v12;
  int v99 = v101;
  uint64_t v100 = 0x400000000;
  uint64_t v102 = v104;
  uint64_t v103 = 0x400000000;
  int v105 = v19;
  uint64_t v20 = &p_src[8 * v76];
  *(void *)&long long v106 = v61;
  *((void *)&v106 + 1) = v11;
LABEL_20:
  sub_1CC1587C8((uint64_t)&v99, (uint64_t)v101, p_src, v20);
  unint64_t v11 = sub_1CC310550(a1, (uint64_t)&v96, a3);
  if (v102 != v104) {
    free(v102);
  }
  uint64_t v22 = v99;
  if (v99 != v101) {
LABEL_23:
  }
    free(v22);
  return v11;
}

uint64_t sub_1CC30FB74(uint64_t a1, uint64_t a2, llvm::Type ***a3, llvm::Type ***a4, unsigned int a5, unsigned int a6, uint64_t a7)
{
  uint64_t v10 = (uint64_t)a4;
  unint64_t v11 = a3;
  int v14 = (uint64_t *)(a1 + 8);
  uint64_t v15 = sub_1CB90CBC0((uint64_t *)(a1 + 8), a2, a3, a4);
  BOOL v17 = v15 < 0;
  if (v16) {
    BOOL v17 = v16 < 0;
  }
  if (!v17)
  {
    BOOL v18 = v16 < 1;
    if (!v16) {
      BOOL v18 = v15 < 1;
    }
    if (v18) {
      return 0;
    }
  }
  unsigned int v100 = a5;
  unsigned int v96 = a6;
  unint64_t v20 = *(void *)(a1 + 24);
  uint64_t v101 = qword_1CFAC6EE8[(int)a2 - 1];
  uint64_t v102 = a7;
  uint64_t v21 = *(llvm::LLVMContext **)v10;
  unint64_t v22 = sub_1CB87DC14(v20, *(void *)(a1 + 8), (llvm::EVT *)v10, 0);
  uint64_t v24 = v23;
  *(void *)&long long v103 = 1;
  DWORD2(v103) = 0;
  while (1)
  {
    int v25 = v22;
    llvm::TargetLoweringBase::getTypeConversion(v20, v21, v22, v24, (uint64_t)&v107);
    if (!(_BYTE)v107)
    {
LABEL_18:
      long long v27 = v103;
      goto LABEL_19;
    }
    if (v107 == 10) {
      break;
    }
    if ((v107 & 0xFB) == 2)
    {
      *(void *)&long long v105 = 2;
      DWORD2(v105) = 0;
      sub_1CB90C9D4((uint64_t)&v103, (uint64_t)&v105);
    }
    unint64_t v22 = *((void *)&v107 + 1);
    if (v25 == BYTE8(v107))
    {
      if (v25) {
        goto LABEL_18;
      }
      uint64_t v26 = v108;
      if (v24 == v108) {
        goto LABEL_18;
      }
    }
    else
    {
      uint64_t v26 = v108;
    }
    uint64_t v24 = v26;
  }
  if (!v25) {
    LOBYTE(v25) = 6;
  }
  long long v27 = xmmword_1CD96D880;
LABEL_19:
  long long v105 = v27;
  v106[0] = v25;
  unint64_t v28 = (llvm::LLVMContext *)*v11;
  unint64_t v29 = sub_1CB87DC14(v20, *v14, (llvm::EVT *)v11, 0);
  uint64_t v31 = v30;
  *(void *)&long long v109 = 1;
  DWORD2(v109) = 0;
  while (1)
  {
    int v32 = v29;
    llvm::TargetLoweringBase::getTypeConversion(v20, v28, v29, v31, (uint64_t)&v107);
    if (!(_BYTE)v107)
    {
LABEL_29:
      long long v34 = v109;
      goto LABEL_30;
    }
    if (v107 == 10) {
      break;
    }
    if ((v107 & 0xFB) == 2)
    {
      *(void *)&long long v103 = 2;
      DWORD2(v103) = 0;
      sub_1CB90C9D4((uint64_t)&v109, (uint64_t)&v103);
    }
    unint64_t v29 = *((void *)&v107 + 1);
    if (v32 == BYTE8(v107))
    {
      if (v32) {
        goto LABEL_29;
      }
      uint64_t v33 = v108;
      if (v31 == v108) {
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t v33 = v108;
    }
    uint64_t v31 = v33;
  }
  if (!v32) {
    LOBYTE(v32) = 6;
  }
  long long v34 = xmmword_1CD96D880;
LABEL_30:
  long long v103 = v34;
  v104[0] = v32;
  uint64_t v99 = sub_1CB87E200(v106);
  int v36 = v35;
  uint64_t v37 = sub_1CB87E200(v104);
  int v97 = v39;
  uint64_t v98 = v37;
  unsigned int v40 = *(_DWORD *)(v10 + 8);
  unsigned int v41 = *((_DWORD *)v11 + 2);
  switch((int)a2)
  {
    case '&':
      char v42 = (*(uint64_t (**)(unint64_t, void, void, void, void))(*(void *)v20 + 1160))(v20, v106[0], 0, v104[0], 0);
      uint64_t result = 0;
      if ((v42 & 1) == 0) {
        goto LABEL_32;
      }
      return result;
    case '\'':
      char v45 = (*(uint64_t (**)(unint64_t, void, void, void, void))(*(void *)v20 + 1192))(v20, v106[0], 0, v104[0], 0);
      uint64_t result = 0;
      if ((v45 & 1) == 0) {
        goto LABEL_50;
      }
      return result;
    case '(':
LABEL_50:
      if (v102 && (sub_1CB90CE98(*(void *)(a1 + 24), v102, v38) & 1) != 0) {
        return 0;
      }
      if (v100 == 1)
      {
        unsigned __int8 EVT = llvm::EVT::getEVT((llvm::EVT *)v11, 0, v38);
        unsigned __int8 v48 = llvm::EVT::getEVT((llvm::EVT *)v10, 0, v47);
        BOOL v49 = (uint64_t)v103 < (uint64_t)v105;
        if (DWORD2(v103) != DWORD2(v105)) {
          BOOL v49 = SDWORD2(v103) < SDWORD2(v105);
        }
        if (!v49)
        {
          BOOL v50 = DWORD2(v103) == DWORD2(v105) ? (uint64_t)v105 >= (uint64_t)v103 : SDWORD2(v105) >= SDWORD2(v103);
          if (v50 && EVT && v48)
          {
            __int16 v51 = a2 == 39 ? -4096 : 3840;
            if (((unsigned __int16)v51 & *(_WORD *)(v20 + 358 * EVT + 2 * v48 + 73672)) == 0) {
              return 0;
            }
          }
        }
      }
      goto LABEL_69;
    case '.':
      if (v102 && (sub_1CB90CE98(*(void *)(a1 + 24), v102, v38) & 1) != 0) {
        return 0;
      }
      goto LABEL_69;
    case '1':
LABEL_32:
      BOOL v43 = (uint64_t)v105 < (uint64_t)v103;
      if (DWORD2(v105) != DWORD2(v103)) {
        BOOL v43 = SDWORD2(v105) < SDWORD2(v103);
      }
      if (!v43)
      {
        BOOL v44 = DWORD2(v105) == DWORD2(v103) ? (uint64_t)v103 < (uint64_t)v105 : SDWORD2(v103) < SDWORD2(v105);
        if (!v44 && ((v40 & 0xFD) == 13) == ((v41 & 0xFD) == 13) && v99 == v98 && v36 == v97) {
          return 0;
        }
      }
      goto LABEL_69;
    case '2':
      if ((*(_DWORD *)(v10 + 8) & 0xFE) == 0x12) {
        unsigned int v40 = *(_DWORD *)(**(void **)(v10 + 16) + 8);
      }
      if ((v11[1] & 0xFE) == 0x12) {
        unsigned int v41 = *((_DWORD *)*v11[2] + 2);
      }
      if ((*(uint64_t (**)(unint64_t, void, void))(*(void *)v20 + 840))(v20, v40 >> 8, v41 >> 8))return 0; {
      goto LABEL_69;
      }
    default:
LABEL_69:
      int v52 = v36;
      int v53 = *(_DWORD *)(v10 + 8) & 0xFE;
      if (v53 == 18) {
        uint64_t v54 = v10;
      }
      else {
        uint64_t v54 = 0;
      }
      int v55 = v11[1] & 0xFE;
      if (v55 == 18) {
        uint64_t v56 = (uint64_t)v11;
      }
      else {
        uint64_t v56 = 0;
      }
      uint64_t result = v105;
      BOOL v57 = (uint64_t)v105 < (uint64_t)v103;
      if (DWORD2(v105) != DWORD2(v103)) {
        BOOL v57 = SDWORD2(v105) < SDWORD2(v103);
      }
      if (!v57)
      {
        BOOL v58 = SDWORD2(v103) >= SDWORD2(v105);
        if (DWORD2(v105) == DWORD2(v103)) {
          BOOL v58 = (uint64_t)v103 >= (uint64_t)v105;
        }
        if (v58
          && v104[0]
          && (v104[0] == 1 || *(void *)(v20 + 8 * v104[0] + 96))
          && *(unsigned __int8 *)(v20 + 390 * v104[0] + v101 + 3862) <= 1u)
        {
          return result;
        }
      }
      if (v53 == 18 || v55 == 18)
      {
        if (v53 == 18 && v55 == 18)
        {
          if (!v57)
          {
            BOOL v59 = SDWORD2(v103) >= SDWORD2(v105);
            if (DWORD2(v105) == DWORD2(v103)) {
              BOOL v59 = (uint64_t)v103 >= (uint64_t)v105;
            }
            if (v59 && v99 == v98 && v52 == v97)
            {
              if (a2 == 40)
              {
                uint64_t v95 = 2;
              }
              else
              {
                if (a2 == 39) {
                  return result;
                }
                if (!v104[0]
                  || !*(void *)(v20 + 8 * v104[0] + 96)
                  || *(unsigned char *)(v20 + 390 * v104[0] + v101 + 3862) == 2)
                {
                  goto LABEL_106;
                }
                uint64_t v95 = 1;
              }
              *(void *)&long long v109 = v95;
              DWORD2(v109) = 0;
              long long v107 = v105;
              sub_1CB90C9D4((uint64_t)&v107, (uint64_t)&v109);
              return v107;
            }
          }
LABEL_106:
          uint64_t v60 = *(llvm::LLVMContext **)v10;
          unint64_t v61 = sub_1CB87DC14(v20, *v14, (llvm::EVT *)v10, 0);
          llvm::TargetLoweringBase::getTypeConversion(v20, v60, v61, v62, (uint64_t)&v107);
          int v63 = v107;
          unsigned int v64 = (llvm::LLVMContext *)*v11;
          unint64_t v65 = sub_1CB87DC14(v20, *v14, (llvm::EVT *)v11, 0);
          llvm::TargetLoweringBase::getTypeConversion(v20, v64, v65, v66, (uint64_t)&v107);
          int v68 = v107;
          if (v63 == 6 || v107 == 6)
          {
            unsigned int v69 = *(_DWORD *)(v54 + 32);
            BOOL v70 = v69 && *(unsigned char *)(v54 + 8) == 19;
            BOOL v71 = v70;
            if (v69 > 1 || v71)
            {
              unsigned int v72 = *(_DWORD *)(v56 + 32);
              int v73 = *(unsigned __int8 *)(v56 + 8);
              BOOL v74 = v72 && v73 == 19;
              BOOL v75 = v74;
              if (v72 > 1 || v75)
              {
                unint64_t v81 = *(uint64_t ***)(v56 + 24);
                unint64_t v82 = (llvm::Type *)(v72 >> 1);
                if (v73 == 19) {
                  llvm::ScalableVectorType::get(v81, v82);
                }
                else {
                  llvm::FixedVectorType::get((llvm::FixedVectorType *)v81, v82);
                }
                uint64_t v84 = v83;
                uint64_t v85 = *(uint64_t ***)(v54 + 24);
                uint64_t v86 = (llvm::Type *)(*(_DWORD *)(v54 + 32) >> 1);
                if (*(unsigned char *)(v54 + 8) == 19) {
                  v88.n128_f64[0] = llvm::ScalableVectorType::get(v85, v86);
                }
                else {
                  v88.n128_f64[0] = llvm::FixedVectorType::get((llvm::FixedVectorType *)v85, v86);
                }
                BOOL v90 = v63 != 6 || v68 != 6;
                *(void *)&long long v109 = sub_1CC30FB74(a1, a2, v84, v87, v100, v96, v102, v88);
                *((void *)&v109 + 1) = v91;
                *(void *)&long long v107 = 2;
                DWORD2(v107) = 0;
                sub_1CB90C9D4((uint64_t)&v107, (uint64_t)&v109);
                BOOL v78 = __OFADD__(v90, (void)v107);
                uint64_t v79 = v90 + v107;
                unint64_t v80 = 0x7FFFFFFFFFFFFFFFLL;
                goto LABEL_132;
              }
            }
          }
          if (*(unsigned char *)(v56 + 8) == 19) {
            return 0;
          }
          uint64_t v92 = *(unsigned int *)(v56 + 32);
          if ((v11[1] & 0xFE) == 0x12) {
            unint64_t v11 = (llvm::Type ***)*v11[2];
          }
          if ((*(_DWORD *)(v10 + 8) & 0xFE) == 0x12) {
            uint64_t v10 = **(void **)(v10 + 16);
          }
          *(void *)&long long v109 = sub_1CC30FB74(a1, a2, v11, v10, v100, v96, v102, v67);
          *((void *)&v109 + 1) = v93;
          unint64_t v94 = sub_1CD5234F4(a1, v56, 1, 1);
          *(void *)&long long v107 = v92;
          DWORD2(v107) = 0;
          sub_1CB90C9D4((uint64_t)&v107, (uint64_t)&v109);
          BOOL v78 = __OFADD__(v94, (void)v107);
          uint64_t v79 = v94 + v107;
LABEL_131:
          unint64_t v80 = (v79 >> 63) ^ 0x8000000000000000;
LABEL_132:
          if (v78) {
            return v80;
          }
          else {
            return v79;
          }
        }
        if (v53 == 18)
        {
          unint64_t v76 = sub_1CD5234F4(a1, v10, 0, 1);
          if (!v56) {
            goto LABEL_129;
          }
        }
        else
        {
          unint64_t v76 = 0;
          if (!v56)
          {
LABEL_129:
            unint64_t v77 = 0;
LABEL_130:
            BOOL v78 = __OFADD__(v76, v77);
            uint64_t v79 = v76 + v77;
            goto LABEL_131;
          }
        }
        unint64_t v77 = sub_1CD5234F4(a1, v56, 1, 0);
        goto LABEL_130;
      }
      if (!v104[0] || !*(void *)(v20 + 8 * v104[0] + 96)) {
        return 4;
      }
      if (*(unsigned char *)(v20 + 390 * v104[0] + v101 + 3862) == 2) {
        return 4;
      }
      return 1;
  }
}

unint64_t sub_1CC310550(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1;
  uint64_t v269 = *MEMORY[0x1E4F143B8];
  int v4 = *(_DWORD *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v6 = *(unsigned int *)(a2 + 120);
  unint64_t v8 = *(void *)(a2 + 128);
  uint64_t v7 = *(void *)(a2 + 136);
  uint64_t v9 = *(unsigned int *)(a2 + 32);
  if (v9)
  {
    BOOL v10 = v4 == 319 || v4 == 322;
    unsigned int v11 = v10;
    uint64_t v12 = *(void *)(*(void *)(a2 + 24) + 8 * v11);
    if ((*(_DWORD *)(v12 + 8) & 0xFE) == 0x12) {
      unsigned int v13 = (llvm::FixedVectorType **)v12;
    }
    else {
      unsigned int v13 = 0;
    }
  }
  else
  {
    unsigned int v13 = 0;
  }
  unint64_t v14 = 0;
  if (a3 == 2) {
    int v15 = 1;
  }
  else {
    int v15 = 10;
  }
  v266 = &v268;
  uint64_t v267 = 0x200000000;
  if (v4 > 166)
  {
    if (v4 <= 191)
    {
      switch(v4)
      {
        case 167:
        case 168:
          goto LABEL_149;
        case 169:
        case 170:
        case 171:
        case 172:
        case 173:
        case 174:
          goto LABEL_201;
        case 175:
          int v16 = 230;
          goto LABEL_57;
        case 176:
          int v16 = 232;
          goto LABEL_57;
        case 177:
          int v16 = 231;
          goto LABEL_57;
        default:
          if (v4 == 185)
          {
            int v69 = a3;
            uint64_t Alignment = llvm::DataLayout::getAlignment(*(llvm::DataLayout **)(a1 + 8), (llvm::Type *)v5, 1);
            uint64_t v71 = v3;
            int v72 = 32;
            uint64_t v73 = v5;
          }
          else
          {
            if (v4 != 187) {
              goto LABEL_201;
            }
            int v68 = **(llvm::Type ***)(a2 + 24);
            int v69 = a3;
            uint64_t Alignment = llvm::DataLayout::getAlignment(*(llvm::DataLayout **)(a1 + 8), v68, 1);
            uint64_t v71 = v3;
            int v72 = 33;
            uint64_t v73 = (uint64_t)v68;
          }
          unint64_t v95 = sub_1CD523948(v71, v72, v73, Alignment, 1, 0, v69);
          break;
      }
    }
    else
    {
      int v16 = 224;
      switch(v4)
      {
        case 238:
          int v16 = 229;
          goto LABEL_57;
        case 239:
        case 240:
        case 241:
        case 242:
        case 243:
        case 245:
        case 246:
        case 247:
        case 248:
        case 249:
        case 250:
        case 251:
        case 252:
        case 253:
        case 254:
        case 255:
        case 256:
        case 257:
        case 261:
        case 264:
        case 265:
        case 266:
        case 267:
        case 268:
        case 269:
        case 270:
        case 271:
        case 277:
        case 279:
        case 281:
        case 282:
        case 285:
        case 286:
        case 287:
        case 288:
        case 289:
        case 290:
        case 291:
        case 292:
        case 293:
        case 294:
        case 295:
        case 297:
        case 298:
        case 299:
        case 302:
        case 303:
        case 304:
        case 308:
        case 310:
        case 313:
        case 314:
        case 315:
        case 316:
          goto LABEL_201;
        case 244:
        case 272:
          goto LABEL_149;
        case 258:
          int v16 = 237;
          goto LABEL_57;
        case 259:
          int v16 = 239;
          goto LABEL_57;
        case 260:
          int v16 = 240;
          goto LABEL_57;
        case 262:
        case 283:
          int v165 = v6;
          v166 = (uint64_t **)(**(void **)v5 + 1888);
          unsigned int v234 = a3;
          uint64_t v167 = v7;
          if ((*(_DWORD *)(v5 + 8) & 0xFE) == 0x12)
          {
            v213 = (llvm::Type *)*(unsigned int *)(v5 + 32);
            if (*(_DWORD *)(v5 + 8) == 19) {
              llvm::ScalableVectorType::get(v166, v213);
            }
            else {
              llvm::FixedVectorType::get((llvm::FixedVectorType *)v166, v213);
            }
            v166 = v214;
          }
          *(void *)&long long v256 = v5;
          *((void *)&v256 + 1) = v166;
          uint64_t v169 = llvm::StructType::create(*(uint64_t **)v5, 0, 0);
          llvm::StructType::setBody(v169, (uint64_t)&v256, 2, 0);
          if (v4 == 262) {
            int v170 = 263;
          }
          else {
            int v170 = 284;
          }
          uint64_t __src = (void *)v5;
          uint64_t v242 = v5;
          *(void *)&long long v256 = 0;
          *((void *)&v256 + 1) = v169;
          LODWORD(v257) = v170;
          v258 = v260;
          uint64_t v259 = 0x400000000;
          v261 = v263;
          uint64_t v262 = 0x400000000;
          int v264 = v165;
          *(void *)&long long v265 = v8;
          *((void *)&v265 + 1) = v167;
          sub_1CC1587C8((uint64_t)&v258, (uint64_t)v260, (char *)&__src, (char *)&v243);
          uint64_t v171 = sub_1CC30F1CC(a1, &v256, v234);
          unint64_t v172 = sub_1CD523148(a1, 53, v5, (uint64_t)v166, v234);
          if (__OFADD__(v171, v172)) {
            unint64_t v173 = ((uint64_t)(v171 + v172) >> 63) ^ 0x8000000000000000;
          }
          else {
            unint64_t v173 = v171 + v172;
          }
          v253 = (void *)sub_1CD523148(a1, 57, v5, (uint64_t)v166, v234);
          uint64_t v254 = v174;
          uint64_t __src = (void *)2;
          LODWORD(v242) = 0;
          sub_1CB90C9D4((uint64_t)&__src, (uint64_t)&v253);
          if (__OFADD__(v173, __src)) {
            unint64_t v14 = ((uint64_t)((uint64_t)__src + v173) >> 63) ^ 0x8000000000000000;
          }
          else {
            unint64_t v14 = (unint64_t)__src + v173;
          }
          if (v261 != v263) {
            free(v261);
          }
          BOOL v58 = v258;
          if (v258 == v260) {
            goto LABEL_149;
          }
          goto LABEL_148;
        case 263:
        case 284:
          uint64_t v144 = *(uint64_t **)(v5 + 16);
          int v145 = v4;
          uint64_t v146 = *v144;
          uint64_t v147 = v144[1];
          if (v145 == 263) {
            uint64_t v148 = 13;
          }
          else {
            uint64_t v148 = 15;
          }
          int v149 = a3;
          unint64_t v150 = sub_1CD522C04(a1, v148, v146, a3, 0, 0);
          uint64_t __src = (void *)sub_1CD523148(v3, 53, v146, v147, v149);
          uint64_t v242 = v151;
          *(void *)&long long v256 = 2;
          DWORD2(v256) = 0;
          sub_1CB90C9D4((uint64_t)&v256, (uint64_t)&__src);
          if (__OFADD__(v150, (void)v256)) {
            unint64_t v152 = ((uint64_t)(v150 + v256) >> 63) ^ 0x8000000000000000;
          }
          else {
            unint64_t v152 = v150 + v256;
          }
          unint64_t v153 = sub_1CD522C04(v3, 30, v147, v149, 0, 0);
          goto LABEL_339;
        case 273:
          int v16 = 226;
          goto LABEL_57;
        case 274:
        case 275:
        case 305:
        case 306:
          uint64_t v96 = **(void **)v5 + 1888;
          int v97 = a3;
          if ((*(_DWORD *)(v5 + 8) & 0xFE) == 0x12)
          {
            v206 = (llvm::Type *)*(unsigned int *)(v5 + 32);
            v207 = (uint64_t **)(**(void **)v5 + 1888);
            if (*(_DWORD *)(v5 + 8) == 19) {
              llvm::ScalableVectorType::get(v207, v206);
            }
            else {
              llvm::FixedVectorType::get((llvm::FixedVectorType *)v207, v206);
            }
            uint64_t v96 = v208;
          }
          unint64_t v98 = sub_1CD523148(v3, 53, v5, v96, v97);
          uint64_t v99 = v3;
          uint64_t v100 = 57;
          uint64_t v101 = v5;
          goto LABEL_267;
        case 276:
        case 307:
          unsigned int v127 = a3;
          v128 = (llvm::Type *)v5;
          if ((*(_DWORD *)(v5 + 8) & 0xFE) == 0x12) {
            v128 = **(llvm::Type ***)(v5 + 16);
          }
          int PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits(v128);
          uint64_t v130 = (uint64_t **)llvm::IntegerType::get(*(llvm::IntegerType **)v5, (llvm::LLVMContext *)(2 * PrimitiveSizeInBits));
          uint64_t v131 = (llvm::Type ***)v130;
          if ((*(_DWORD *)(v5 + 8) & 0xFE) == 0x12)
          {
            v209 = (llvm::Type *)*(unsigned int *)(v5 + 32);
            if (*(_DWORD *)(v5 + 8) == 19) {
              llvm::ScalableVectorType::get(v130, v209);
            }
            else {
              llvm::FixedVectorType::get((llvm::FixedVectorType *)v130, v209);
            }
            uint64_t v131 = v210;
          }
          if (v4 == 276) {
            uint64_t v132 = 40;
          }
          else {
            uint64_t v132 = 39;
          }
          uint64_t __src = (void *)sub_1CC30FB74(v3, v132, v131, (llvm::Type ***)v5, 0, v127, 0);
          uint64_t v242 = v133;
          *(void *)&long long v256 = 2;
          DWORD2(v256) = 0;
          sub_1CB90C9D4((uint64_t)&v256, (uint64_t)&__src);
          uint64_t v134 = v256;
          unint64_t v135 = sub_1CD522C04(v3, 17, (uint64_t)v131, v127, 0, 0);
          if (__OFADD__(v134, v135)) {
            unint64_t v136 = ((uint64_t)(v134 + v135) >> 63) ^ 0x8000000000000000;
          }
          else {
            unint64_t v136 = v134 + v135;
          }
          uint64_t __src = (void *)sub_1CC30FB74(v3, 38, (llvm::Type ***)v5, v131, 0, v127, 0);
          uint64_t v242 = v137;
          *(void *)&long long v256 = 2;
          DWORD2(v256) = 0;
          sub_1CB90C9D4((uint64_t)&v256, (uint64_t)&__src);
          if (__OFADD__(v136, (void)v256)) {
            unint64_t v138 = ((uint64_t)(v136 + v256) >> 63) ^ 0x8000000000000000;
          }
          else {
            unint64_t v138 = v136 + v256;
          }
          unint64_t v139 = sub_1CD522C04(v3, 26, v5, v127, 0, 0);
          if (__OFADD__(v138, v139)) {
            unint64_t v140 = ((uint64_t)(v138 + v139) >> 63) ^ 0x8000000000000000;
          }
          else {
            unint64_t v140 = v138 + v139;
          }
          unint64_t v141 = sub_1CD522C04(v3, 25, v5, v127, 0, 0);
          if (__OFADD__(v140, v141)) {
            unint64_t v142 = ((uint64_t)(v140 + v141) >> 63) ^ 0x8000000000000000;
          }
          else {
            unint64_t v142 = v140 + v141;
          }
          unint64_t v143 = sub_1CD522C04(v3, 29, v5, v127, 0, 0);
          BOOL v125 = __OFADD__(v142, v143);
          uint64_t v126 = v142 + v143;
          goto LABEL_347;
        case 278:
        case 309:
          int v175 = v4;
          unsigned int v176 = a3;
          v177 = *(uint64_t **)(v5 + 16);
          uint64_t v178 = *v177;
          v179 = (llvm::Type *)*v177;
          if ((*(_DWORD *)(*v177 + 8) & 0xFE) == 0x12) {
            v179 = **(llvm::Type ***)(v178 + 16);
          }
          uint64_t v237 = v177[1];
          int v180 = llvm::Type::getPrimitiveSizeInBits(v179);
          v181 = (uint64_t **)llvm::IntegerType::get(*(llvm::IntegerType **)v178, (llvm::LLVMContext *)(2 * v180));
          v182 = (llvm::Type ***)v181;
          if ((*(_DWORD *)(v178 + 8) & 0xFE) == 0x12)
          {
            v215 = (llvm::Type *)*(unsigned int *)(v178 + 32);
            if (*(_DWORD *)(v178 + 8) == 19) {
              llvm::ScalableVectorType::get(v181, v215);
            }
            else {
              llvm::FixedVectorType::get((llvm::FixedVectorType *)v181, v215);
            }
            v182 = v216;
          }
          if (v175 == 278) {
            uint64_t v183 = 40;
          }
          else {
            uint64_t v183 = 39;
          }
          uint64_t __src = (void *)sub_1CC30FB74(v3, v183, v182, (llvm::Type ***)v178, 0, v176, 0);
          uint64_t v242 = v184;
          *(void *)&long long v256 = 2;
          DWORD2(v256) = 0;
          sub_1CB90C9D4((uint64_t)&v256, (uint64_t)&__src);
          uint64_t v185 = v256;
          unint64_t v186 = sub_1CD522C04(v3, 17, (uint64_t)v182, v176, 0, 0);
          if (__OFADD__(v185, v186)) {
            unint64_t v187 = ((uint64_t)(v185 + v186) >> 63) ^ 0x8000000000000000;
          }
          else {
            unint64_t v187 = v185 + v186;
          }
          uint64_t __src = (void *)sub_1CC30FB74(v3, 38, (llvm::Type ***)v178, v182, 0, v176, 0);
          uint64_t v242 = v188;
          *(void *)&long long v256 = 2;
          DWORD2(v256) = 0;
          sub_1CB90C9D4((uint64_t)&v256, (uint64_t)&__src);
          if (__OFADD__(v187, (void)v256)) {
            unint64_t v189 = ((uint64_t)(v187 + v256) >> 63) ^ 0x8000000000000000;
          }
          else {
            unint64_t v189 = v187 + v256;
          }
          unint64_t v190 = sub_1CD522C04(v3, 26, (uint64_t)v182, v176, 0, 0);
          if (__OFADD__(v189, v190)) {
            unint64_t v152 = ((uint64_t)(v189 + v190) >> 63) ^ 0x8000000000000000;
          }
          else {
            unint64_t v152 = v189 + v190;
          }
          if (v175 == 278)
          {
            unint64_t v191 = sub_1CD522C04(v3, 27, v178, v176, 0, 0);
            if (__OFADD__(v152, v191)) {
              unint64_t v152 = ((uint64_t)(v152 + v191) >> 63) ^ 0x8000000000000000;
            }
            else {
              v152 += v191;
            }
          }
          unint64_t v153 = sub_1CD523148(v3, 53, v178, v237, v176);
LABEL_339:
          BOOL v125 = __OFADD__(v152, v153);
          uint64_t v126 = v152 + v153;
          goto LABEL_347;
        case 280:
          goto LABEL_57;
        case 296:
          int v16 = 236;
          goto LABEL_57;
        case 300:
        case 311:
          int v221 = v6;
          int v154 = v4;
          int v155 = (uint64_t **)(**(void **)v5 + 1888);
          uint64_t v156 = v5;
          int v157 = *(_DWORD *)(v5 + 8);
          uint64_t v158 = v7;
          uint64_t v159 = a3;
          if ((v157 & 0xFE) == 0x12)
          {
            v211 = (llvm::Type *)*(unsigned int *)(v156 + 32);
            if (v157 == 19) {
              llvm::ScalableVectorType::get(v155, v211);
            }
            else {
              llvm::FixedVectorType::get((llvm::FixedVectorType *)v155, v211);
            }
            int v155 = v212;
          }
          *(void *)&long long v256 = v156;
          *((void *)&v256 + 1) = v155;
          uint64_t v161 = llvm::StructType::create(*(uint64_t **)v156, 0, 0);
          llvm::StructType::setBody(v161, (uint64_t)&v256, 2, 0);
          if (v154 == 300) {
            int v162 = 301;
          }
          else {
            int v162 = 312;
          }
          uint64_t __src = (void *)v156;
          uint64_t v242 = v156;
          *(void *)&long long v256 = 0;
          *((void *)&v256 + 1) = v161;
          LODWORD(v257) = v162;
          v258 = v260;
          uint64_t v259 = 0x400000000;
          v261 = v263;
          uint64_t v262 = 0x400000000;
          int v264 = v221;
          *(void *)&long long v265 = v8;
          *((void *)&v265 + 1) = v158;
          sub_1CC1587C8((uint64_t)&v258, (uint64_t)v260, (char *)&__src, (char *)&v243);
          uint64_t v163 = sub_1CC30F1CC(a1, &v256, v159);
          unint64_t v164 = sub_1CD523148(a1, 57, v156, (uint64_t)v155, v159);
          if (__OFADD__(v163, v164)) {
            unint64_t v14 = ((uint64_t)(v163 + v164) >> 63) ^ 0x8000000000000000;
          }
          else {
            unint64_t v14 = v163 + v164;
          }
          if (v261 != v263) {
            free(v261);
          }
          BOOL v58 = v258;
          if (v258 == v260) {
            goto LABEL_149;
          }
          goto LABEL_148;
        case 301:
        case 312:
          unint64_t v120 = *(uint64_t **)(v5 + 16);
          int v121 = v4;
          uint64_t v122 = *v120;
          uint64_t v96 = v120[1];
          if (v121 == 301) {
            uint64_t v123 = 13;
          }
          else {
            uint64_t v123 = 15;
          }
          int v97 = a3;
          unint64_t v98 = sub_1CD522C04(a1, v123, v122, a3, 0, 0);
          uint64_t v99 = v3;
          uint64_t v100 = 53;
          uint64_t v101 = v122;
LABEL_267:
          unint64_t v124 = sub_1CD523148(v99, v100, v101, v96, v97);
          BOOL v125 = __OFADD__(v98, v124);
          uint64_t v126 = v98 + v124;
          goto LABEL_347;
        case 317:
          uint64_t v198 = 13;
          goto LABEL_358;
        case 318:
          uint64_t v198 = 28;
          goto LABEL_358;
        case 319:
          uint64_t v199 = v6 | 0x100000000;
          uint64_t v200 = 14;
          goto LABEL_356;
        case 320:
        case 321:
        case 325:
        case 326:
        case 327:
        case 328:
          int v93 = a3;
          unint64_t v94 = (uint64_t **)(*(void *)*v13 + 1888);
          if (v13 && (v13[1] & 0xFE) == 0x12)
          {
            v204 = (llvm::Type *)*((unsigned int *)v13 + 8);
            if (*((_DWORD *)v13 + 2) == 19) {
              llvm::ScalableVectorType::get(v94, v204);
            }
            else {
              llvm::FixedVectorType::get((llvm::FixedVectorType *)v94, v204);
            }
            unint64_t v94 = v205;
          }
          unint64_t v95 = sub_1CD5235B0(v3, v13, (uint64_t)v94, v93);
          break;
        case 322:
          uint64_t v199 = v6 | 0x100000000;
          uint64_t v200 = 18;
LABEL_356:
          unint64_t v95 = sub_1CD523594(a1, v200, v13, v199, a3);
          break;
        case 323:
          uint64_t v198 = 17;
          goto LABEL_358;
        case 324:
          uint64_t v198 = 29;
          goto LABEL_358;
        case 329:
          uint64_t v198 = 30;
LABEL_358:
          unint64_t v95 = sub_1CD523C08(a1, v198, v13, a3);
          break;
        default:
          switch(v4)
          {
            case 192:
              int v16 = 251;
              goto LABEL_57;
            case 193:
              int v16 = 247;
              goto LABEL_57;
            case 201:
              int v16 = 250;
              goto LABEL_57;
            case 202:
              int v16 = 246;
              goto LABEL_57;
            case 203:
              int v16 = 238;
              goto LABEL_57;
            default:
              goto LABEL_201;
          }
      }
    }
    unint64_t v14 = v95;
    goto LABEL_149;
  }
  if (v4 <= 74)
  {
    switch(v4)
    {
      case 5:
        goto LABEL_149;
      case 6:
      case 7:
      case 10:
      case 11:
      case 12:
      case 15:
      case 16:
      case 17:
      case 18:
        goto LABEL_201;
      case 8:
        int v16 = 186;
        goto LABEL_57;
      case 9:
        int v16 = 182;
        goto LABEL_57;
      case 13:
        int v16 = 145;
        goto LABEL_57;
      case 14:
        int v16 = 235;
        goto LABEL_57;
      case 19:
        int v16 = 143;
        goto LABEL_57;
      default:
        switch(v4)
        {
          case '3':
            int v16 = 227;
            goto LABEL_57;
          case '4':
            int v16 = 184;
            goto LABEL_57;
          case '5':
            int v15 = 4;
            int v16 = 185;
            goto LABEL_57;
          case '6':
            int v16 = 183;
            goto LABEL_57;
          default:
            if (v4 != 1) {
              goto LABEL_201;
            }
            uint64_t v192 = **(void **)v5 + 1888;
            int v193 = a3;
            if ((*(_DWORD *)(v5 + 8) & 0xFE) == 0x12)
            {
              v217 = (llvm::Type *)*(unsigned int *)(v5 + 32);
              v218 = (uint64_t **)(**(void **)v5 + 1888);
              if (*(_DWORD *)(v5 + 8) == 19) {
                llvm::ScalableVectorType::get(v218, v217);
              }
              else {
                llvm::FixedVectorType::get((llvm::FixedVectorType *)v218, v217);
              }
              uint64_t v192 = v219;
            }
            unint64_t v194 = sub_1CD523148(v3, 53, v5, v192, v193);
            unint64_t v195 = sub_1CD523148(v3, 57, v5, v192, v193);
            if (__OFADD__(v194, v195)) {
              unint64_t v196 = ((uint64_t)(v194 + v195) >> 63) ^ 0x8000000000000000;
            }
            else {
              unint64_t v196 = v194 + v195;
            }
            unint64_t v197 = sub_1CD522C04(v3, 15, v5, v193, 0, 0);
            BOOL v125 = __OFADD__(v196, v197);
            uint64_t v126 = v196 + v197;
LABEL_347:
            if (v125) {
              unint64_t v14 = (v126 >> 63) ^ 0x8000000000000000;
            }
            else {
              unint64_t v14 = v126;
            }
            break;
        }
        break;
    }
    goto LABEL_149;
  }
  if (v4 > 138)
  {
    switch(v4)
    {
      case 139:
        int v16 = 223;
        goto LABEL_57;
      case 140:
        int v16 = 241;
        goto LABEL_57;
      case 142:
      case 143:
        int v16 = 141;
        goto LABEL_57;
      default:
        goto LABEL_201;
    }
  }
  switch(v4)
  {
    case 'K':
      int v16 = 233;
LABEL_57:
      unsigned int v225 = v15;
      uint64_t v222 = v7;
      unint64_t v226 = v8;
      unsigned int v233 = a3;
      int v268 = v16;
      LODWORD(v267) = 1;
      unint64_t v17 = *(void *)(a1 + 24);
      BOOL v18 = *(llvm::LLVMContext **)v5;
      unint64_t v19 = sub_1CB87DC14(v17, *(void *)(a1 + 8), (llvm::EVT *)v5, 0);
      uint64_t v21 = v20;
      v253 = (void *)1;
      LODWORD(v254) = 0;
      int v220 = v6;
      while (1)
      {
        llvm::TargetLoweringBase::getTypeConversion(v17, v18, v19, v21, (uint64_t)&v256);
        if (!(_BYTE)v256)
        {
LABEL_67:
          uint64_t v24 = (uint64_t)v253;
          uint64_t v23 = v254;
          goto LABEL_68;
        }
        if (v256 == 10) {
          break;
        }
        if ((v256 & 0xFB) == 2)
        {
          uint64_t __src = (void *)2;
          LODWORD(v242) = 0;
          sub_1CB90C9D4((uint64_t)&v253, (uint64_t)&__src);
        }
        if (v19 == BYTE8(v256))
        {
          if ((_BYTE)v19) {
            goto LABEL_67;
          }
          uint64_t v22 = v257;
          if (v21 == v257) {
            goto LABEL_67;
          }
        }
        else
        {
          uint64_t v22 = v257;
        }
        uint64_t v21 = v22;
        unint64_t v19 = *((void *)&v256 + 1);
      }
      uint64_t v24 = 0;
      if (!(_BYTE)v19) {
        LOBYTE(v19) = 6;
      }
      uint64_t v23 = 1;
LABEL_68:
      v253 = v255;
      uint64_t v254 = 0x200000000;
      v250 = v252;
      uint64_t v251 = 0x200000000;
      if (!v267) {
        goto LABEL_127;
      }
      uint64_t v231 = v5;
      uint64_t v228 = v3;
      int v25 = v4;
      uint64_t v26 = (unsigned int *)v266;
      long long v27 = (uint64_t *)(v17 + 8 * v19 + 96);
      BOOL v28 = v24 > 1;
      if (v23) {
        BOOL v28 = (int)v23 > 0;
      }
      BOOL v236 = v28;
      BOOL v30 = (v19 - 8) >= 7u
         && (v19 - 75) >= 0x2Du
         && (v19 + 104) >= 0x13u;
      int v229 = v25;
      int v32 = !v30 && v25 == 139;
      uint64_t v33 = 4 * v267;
      while (!(_BYTE)v19)
      {
LABEL_106:
        ++v26;
        v33 -= 4;
        if (!v33)
        {
          BOOL v38 = v253;
          if (v254 >= 2)
          {
            int v39 = (char *)v253 + 16;
            uint64_t v40 = *(void *)v253;
            uint64_t v41 = 16 * v254 - 16;
            uint64_t v3 = v228;
            uint64_t v5 = v231;
            int v4 = v229;
            do
            {
              int v42 = *((_DWORD *)v39 + 2);
              int v43 = v38[2];
              BOOL v10 = v42 == v43;
              BOOL v44 = v42 < v43;
              if (v10) {
                BOOL v44 = *(void *)v39 < v40;
              }
              if (v44)
              {
                uint64_t v40 = *(void *)v39;
                BOOL v38 = v39;
              }
              v39 += 16;
              v41 -= 16;
            }
            while (v41);
          }
          else
          {
            uint64_t v3 = v228;
            uint64_t v5 = v231;
            int v4 = v229;
          }
          if (v38 != (_DWORD *)((char *)v253 + 16 * v254)) {
            goto LABEL_126;
          }
          BOOL v38 = v250;
          if (v251 >= 2)
          {
            char v45 = (char *)v250 + 16;
            uint64_t v46 = *(void *)v250;
            uint64_t v47 = 16 * v251 - 16;
            do
            {
              int v48 = *((_DWORD *)v45 + 2);
              int v49 = v38[2];
              BOOL v10 = v48 == v49;
              BOOL v50 = v48 < v49;
              if (v10) {
                BOOL v50 = *(void *)v45 < v46;
              }
              if (v50)
              {
                uint64_t v46 = *(void *)v45;
                BOOL v38 = v45;
              }
              v45 += 16;
              v47 -= 16;
            }
            while (v47);
          }
          if (v38 != (_DWORD *)((char *)v250 + 16 * v251))
          {
LABEL_126:
            unint64_t v14 = *(void *)v38;
            goto LABEL_145;
          }
LABEL_127:
          if (v4 == 90)
          {
            __int16 v51 = *(char **)(a2 + 24);
            uint64_t v52 = *(unsigned int *)(a2 + 32);
            *(void *)&long long v256 = 0;
            *((void *)&v256 + 1) = v5;
            LODWORD(v257) = 89;
            v258 = v260;
            uint64_t v259 = 0x400000000;
            v261 = v263;
            uint64_t v262 = 0x400000000;
            int v264 = 0;
            long long v265 = xmmword_1CD96D880;
            sub_1CC1587C8((uint64_t)&v258, (uint64_t)v260, v51, &v51[8 * v52]);
            int v53 = *(char **)(a2 + 24);
            uint64_t v54 = *(unsigned int *)(a2 + 32);
            uint64_t __src = 0;
            uint64_t v242 = v5;
            int v243 = 83;
            v244[0] = v245;
            v244[1] = (void *)0x400000000;
            v246 = v248;
            uint64_t v247 = 0x400000000;
            v248[8] = 0;
            long long v249 = xmmword_1CD96D880;
            sub_1CC1587C8((uint64_t)v244, (uint64_t)v245, v53, &v53[8 * v54]);
            uint64_t v55 = sub_1CC30F1CC(v3, &v256, v233);
            uint64_t v56 = sub_1CC30F1CC(v3, &__src, v233);
            if (__OFADD__(v55, v56)) {
              unint64_t v14 = ((v55 + v56) >> 63) ^ 0x8000000000000000;
            }
            else {
              unint64_t v14 = v55 + v56;
            }
            if (v246 != v248) {
              free(v246);
            }
            if (v244[0] != v245) {
              free(v244[0]);
            }
            if (v261 != v263) {
              free(v261);
            }
            BOOL v57 = v258;
            if (v258 == v260) {
              goto LABEL_145;
            }
          }
          else
          {
            if (v4 == 143)
            {
              unint64_t v83 = sub_1CD522C04(v3, 18, v5, v233, 0, 0);
              unint64_t v84 = sub_1CD522C04(v3, 14, v5, v233, 0, 0);
              if (__OFADD__(v83, v84)) {
                unint64_t v14 = ((uint64_t)(v83 + v84) >> 63) ^ 0x8000000000000000;
              }
              else {
                unint64_t v14 = v83 + v84;
              }
              goto LABEL_145;
            }
            if ((*(_DWORD *)(v5 + 8) & 0xFE) != 0x12)
            {
              unint64_t v14 = v225;
              goto LABEL_145;
            }
            if (*(_DWORD *)(v5 + 8) == 19)
            {
              unint64_t v14 = 0;
              goto LABEL_145;
            }
            uint64_t v60 = *(unsigned int *)(a2 + 32);
            if (v60)
            {
              uint64_t v61 = *(void *)(a2 + 24);
              uint64_t v62 = 8 * v60;
              while (*(unsigned char *)(*(void *)v61 + 8) != 19)
              {
                v61 += 8;
                v62 -= 8;
                if (!v62) {
                  goto LABEL_156;
                }
              }
              unint64_t v14 = 0;
LABEL_145:
              if (v250 != v252) {
                free(v250);
              }
              BOOL v58 = v253;
              if (v253 != v255) {
LABEL_148:
              }
                free(v58);
              goto LABEL_149;
            }
LABEL_156:
            if (v222)
            {
              unint64_t v226 = sub_1CD5234F4(v3, v5, 1, 0);
              LODWORD(v60) = *(_DWORD *)(a2 + 32);
            }
            unsigned int v63 = *(_DWORD *)(v5 + 32);
            uint64_t __src = &v243;
            uint64_t v242 = 0x400000000;
            if (v60)
            {
              uint64_t v64 = v5;
              uint64_t v65 = 0;
              LODWORD(v66) = 0;
              do
              {
                uint64_t v67 = *(void *)(*(void *)(a2 + 24) + v65);
                if ((*(_DWORD *)(v67 + 8) & 0xFE) == 0x12) {
                  uint64_t v67 = **(void **)(v67 + 16);
                }
                if (v66 >= HIDWORD(v242)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *((void *)__src + v66) = v67;
                uint64_t v66 = (v242 + 1);
                LODWORD(v242) = v242 + 1;
                v65 += 8;
              }
              while (8 * v60 != v65);
              uint64_t v5 = v64;
            }
            else
            {
              uint64_t v66 = 0;
            }
            if ((*(_DWORD *)(v5 + 8) & 0xFE) == 0x12) {
              uint64_t v5 = **(void **)(v5 + 16);
            }
            *(void *)&long long v256 = 0;
            *((void *)&v256 + 1) = v5;
            LODWORD(v257) = v4;
            v258 = v260;
            uint64_t v259 = 0x400000000;
            v261 = v263;
            uint64_t v262 = 0x400000000;
            int v264 = v220;
            long long v265 = xmmword_1CD96D880;
            sub_1CC1587C8((uint64_t)&v258, (uint64_t)v260, (char *)__src, (char *)__src + 8 * v66);
            v238[0] = sub_1CC30F1CC(v3, &v256, v233);
            v238[1] = v74;
            uint64_t v75 = *(unsigned int *)(a2 + 32);
            if (v75)
            {
              uint64_t v76 = v3;
              uint64_t v77 = 0;
              uint64_t v78 = 8 * v75;
              do
              {
                uint64_t v79 = *(void *)(*(void *)(a2 + 24) + v77);
                if (v79) {
                  BOOL v80 = (*(_DWORD *)(v79 + 8) & 0xFE) == 18;
                }
                else {
                  BOOL v80 = 0;
                }
                if (v80)
                {
                  if (*(_DWORD *)(a2 + 136))
                  {
                    unint64_t v81 = sub_1CD5234F4(v76, *(void *)(*(void *)(a2 + 24) + v77), 0, 1);
                    unint64_t v82 = v226 + v81;
                    if (__OFADD__(v226, v81)) {
                      unint64_t v82 = ((uint64_t)(v226 + v81) >> 63) ^ 0x8000000000000000;
                    }
                    unint64_t v226 = v82;
                  }
                  if (v63 <= *(_DWORD *)(v79 + 32)) {
                    unsigned int v63 = *(_DWORD *)(v79 + 32);
                  }
                }
                v77 += 8;
              }
              while (v78 != v77);
            }
            uint64_t v239 = v63;
            LODWORD(v240) = 0;
            sub_1CB90C9D4((uint64_t)&v239, (uint64_t)v238);
            if (__OFADD__(v239, v226)) {
              unint64_t v14 = ((uint64_t)(v239 + v226) >> 63) ^ 0x8000000000000000;
            }
            else {
              unint64_t v14 = v239 + v226;
            }
            if (v261 != v263) {
              free(v261);
            }
            if (v258 != v260) {
              free(v258);
            }
            BOOL v57 = __src;
            if (__src == &v243) {
              goto LABEL_145;
            }
          }
          free(v57);
          goto LABEL_145;
        }
      }
      uint64_t v34 = *v26;
      if (v19 == 1)
      {
        if (v34 > 0x185)
        {
LABEL_100:
          uint64_t v35 = *v27;
          goto LABEL_101;
        }
      }
      else
      {
        uint64_t v35 = *v27;
        if (v34 > 0x185 || v35 == 0)
        {
LABEL_101:
          if (v35 && (v34 > 0x185 || *(unsigned char *)(v17 + 390 * v19 + v34 + 3862) != 2))
          {
            uint64_t __src = (void *)2;
            LODWORD(v242) = 0;
            *(void *)&long long v256 = v24;
            *((void *)&v256 + 1) = v23;
            sub_1CB90C9D4((uint64_t)&v256, (uint64_t)&__src);
            if (v251 >= (unint64_t)HIDWORD(v251)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((_OWORD *)v250 + v251) = v256;
            LODWORD(v251) = v251 + 1;
          }
          goto LABEL_106;
        }
      }
      if (*(unsigned __int8 *)(v17 + 390 * v19 + v34 + 3862) <= 1u)
      {
        if (v32
          && ((*(uint64_t (**)(unint64_t, void, void))(*(void *)v17 + 1328))(v17, v19, 0) & 1) != 0)
        {
          unint64_t v14 = 0;
          goto LABEL_145;
        }
        if (v236) {
          uint64_t v37 = 2;
        }
        else {
          uint64_t v37 = 1;
        }
        uint64_t __src = (void *)v37;
        LODWORD(v242) = 0;
        *(void *)&long long v256 = v24;
        *((void *)&v256 + 1) = v23;
        sub_1CB90C9D4((uint64_t)&v256, (uint64_t)&__src);
        if (v254 >= (unint64_t)HIDWORD(v254)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_OWORD *)v253 + v254) = v256;
        LODWORD(v254) = v254 + 1;
        goto LABEL_106;
      }
      goto LABEL_100;
    case 'L':
      int v16 = 234;
      goto LABEL_57;
    case 'Z':
      int v16 = 106;
      goto LABEL_57;
  }
LABEL_201:
  int v85 = *(unsigned __int8 *)(v5 + 8);
  if (v85 == 19)
  {
    unint64_t v14 = 0;
    goto LABEL_149;
  }
  uint64_t v223 = v7;
  uint64_t v86 = a2;
  if (v9)
  {
    uint64_t v87 = *(void *)(a2 + 24);
    uint64_t v88 = 8 * v9;
    do
    {
      if (*(unsigned char *)(*(void *)v87 + 8) == 19)
      {
        unint64_t v14 = 0;
        goto LABEL_149;
      }
      v87 += 8;
      v88 -= 8;
    }
    while (v88);
  }
  if (v7) {
    unint64_t v89 = 0;
  }
  else {
    unint64_t v89 = v8;
  }
  uint64_t v224 = v7;
  if (v7) {
    uint64_t v90 = 0;
  }
  else {
    uint64_t v90 = v7;
  }
  unsigned int v91 = 1;
  if ((v85 & 0xFE) == 0x12 && v5)
  {
    uint64_t v92 = v7;
    if (v7)
    {
      uint64_t v201 = a3;
      unint64_t v202 = sub_1CD5234F4(a1, v5, 1, 0);
      uint64_t v92 = v223;
      a3 = v201;
      unint64_t v8 = v202;
      uint64_t v224 = v203;
      int v85 = *(_DWORD *)(v5 + 8);
    }
    if (*(_DWORD *)(v5 + 32) <= 1u) {
      unsigned int v91 = 1;
    }
    else {
      unsigned int v91 = *(_DWORD *)(v5 + 32);
    }
    unint64_t v227 = v8;
    if ((v85 & 0xFE) == 0x12) {
      uint64_t v5 = **(void **)(v5 + 16);
    }
  }
  else
  {
    unint64_t v227 = v89;
    uint64_t v224 = v90;
    uint64_t v92 = v7;
  }
  uint64_t __src = &v243;
  uint64_t v242 = 0x400000000;
  uint64_t v102 = *(unsigned int *)(a2 + 32);
  if (v102)
  {
    int v230 = v4;
    uint64_t v232 = v5;
    uint64_t v103 = 0;
    uint64_t v104 = 8 * v102;
    do
    {
      uint64_t v105 = *(void *)(*(void *)(v86 + 24) + v103);
      int v106 = *(_DWORD *)(v105 + 8);
      if (v105) {
        BOOL v107 = (*(_DWORD *)(v105 + 8) & 0xFE) == 18;
      }
      else {
        BOOL v107 = 0;
      }
      if (v107)
      {
        if (v92)
        {
          uint64_t v109 = *(void *)(*(void *)(v86 + 24) + v103);
          uint64_t v110 = v86;
          uint64_t v111 = v6;
          uint64_t v112 = a3;
          unint64_t v113 = sub_1CD5234F4(v3, v109, 0, 1);
          uint64_t v92 = v223;
          uint64_t v114 = v224;
          a3 = v112;
          uint64_t v6 = v111;
          uint64_t v86 = v110;
          if (v115 == 1) {
            uint64_t v114 = 1;
          }
          uint64_t v224 = v114;
          unint64_t v116 = v227 + v113;
          if (__OFADD__(v227, v113)) {
            unint64_t v116 = ((uint64_t)(v227 + v113) >> 63) ^ 0x8000000000000000;
          }
          unint64_t v227 = v116;
          int v106 = *(_DWORD *)(v105 + 8);
        }
        if (v91 <= *(_DWORD *)(v105 + 32)) {
          unsigned int v91 = *(_DWORD *)(v105 + 32);
        }
        if ((v106 & 0xFE) == 0x12) {
          uint64_t v105 = **(void **)(v105 + 16);
        }
      }
      if (v242 >= (unint64_t)HIDWORD(v242)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)__src + v242) = v105;
      uint64_t v108 = (v242 + 1);
      LODWORD(v242) = v242 + 1;
      v103 += 8;
    }
    while (v104 != v103);
    uint64_t v117 = a3;
    unint64_t v118 = (char *)__src;
    uint64_t v5 = v232;
    int v4 = v230;
  }
  else
  {
    uint64_t v117 = a3;
    uint64_t v108 = 0;
    unint64_t v118 = (char *)&v243;
  }
  if (v91 == 1)
  {
    unint64_t v14 = 1;
  }
  else
  {
    *(void *)&long long v256 = 0;
    *((void *)&v256 + 1) = v5;
    LODWORD(v257) = v4;
    v258 = v260;
    uint64_t v259 = 0x400000000;
    v261 = v263;
    uint64_t v262 = 0x400000000;
    int v264 = v6;
    long long v265 = xmmword_1CD96D880;
    sub_1CC1587C8((uint64_t)&v258, (uint64_t)v260, v118, &v118[8 * v108]);
    v250 = (void *)sub_1CC30F1CC(v3, &v256, v117);
    uint64_t v251 = v119;
    v253 = (void *)v91;
    LODWORD(v254) = 0;
    sub_1CB90C9D4((uint64_t)&v253, (uint64_t)&v250);
    if (__OFADD__(v253, v227)) {
      unint64_t v14 = ((uint64_t)((uint64_t)v253 + v227) >> 63) ^ 0x8000000000000000;
    }
    else {
      unint64_t v14 = (unint64_t)v253 + v227;
    }
    if (v261 != v263) {
      free(v261);
    }
    if (v258 != v260) {
      free(v258);
    }
    unint64_t v118 = (char *)__src;
  }
  if (v118 != (char *)&v243)
  {
    BOOL v58 = v118;
    goto LABEL_148;
  }
LABEL_149:
  if (v266 != &v268) {
    free(v266);
  }
  return v14;
}

unint64_t sub_1CC3121A4(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v31 = v35;
  int v32 = v35;
  uint64_t v33 = 4;
  int v34 = 0;
  uint64_t v4 = a3;
  if (!a3) {
    return 0;
  }
  uint64_t v8 = 0;
  unint64_t v9 = 0;
  do
  {
    uint64_t v10 = *(void *)(a2 + 8 * v8);
    uint64_t v11 = *(void *)(a4 + 8 * v8);
    if ((*(_DWORD *)(v11 + 8) & 0xFE) == 0x12) {
      unsigned int v12 = *(unsigned __int8 *)(**(void **)(v11 + 16) + 8);
    }
    else {
      unsigned int v12 = *(_DWORD *)(v11 + 8);
    }
    BOOL v13 = v12 < 7 || v12 == 13;
    if (!v13 && v12 != 15 || *(unsigned __int8 *)(v10 + 16) < 0x15u) {
      goto LABEL_48;
    }
    unint64_t v14 = v32;
    uint64_t v15 = HIDWORD(v33);
    if (v32 == v31)
    {
      if (HIDWORD(v33))
      {
        int v16 = 0;
        uint64_t v17 = 8 * HIDWORD(v33);
        BOOL v18 = v32;
        while (*(void *)v18 != v10)
        {
          if (*(void *)v18 == -2) {
            int v16 = v18;
          }
          v18 += 8;
          v17 -= 8;
          if (!v17)
          {
            if (!v16) {
              goto LABEL_20;
            }
            *(void *)int v16 = v10;
            --v34;
            if (v11) {
              goto LABEL_47;
            }
            goto LABEL_48;
          }
        }
        goto LABEL_48;
      }
LABEL_20:
      unsigned int v19 = v33;
      if (HIDWORD(v33) < v33)
      {
        ++HIDWORD(v33);
        *(void *)&v32[8 * v15] = v10;
        if (!v11) {
          goto LABEL_48;
        }
LABEL_47:
        if ((*(_DWORD *)(v11 + 8) & 0xFE) == 0x12)
        {
          unint64_t v29 = sub_1CD5234F4(a1, v11, 0, 1);
          if (__OFADD__(v9, v29)) {
            unint64_t v9 = ((uint64_t)(v9 + v29) >> 63) ^ 0x8000000000000000;
          }
          else {
            v9 += v29;
          }
        }
        goto LABEL_48;
      }
    }
    else
    {
      unsigned int v19 = v33;
    }
    if (3 * v19 <= 4 * (HIDWORD(v33) - v34))
    {
      if (v19 >= 0x40) {
        v19 *= 2;
      }
      else {
        unsigned int v19 = 128;
      }
    }
    else if (v19 - HIDWORD(v33) >= v19 >> 3)
    {
      goto LABEL_26;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v31, v19);
    unsigned int v19 = v33;
    unint64_t v14 = v32;
LABEL_26:
    unsigned int v20 = v19 - 1;
    unsigned int v21 = (v19 - 1) & ((v10 >> 4) ^ (v10 >> 9));
    uint64_t v22 = &v14[8 * v21];
    uint64_t v23 = *(void *)v22;
    if (*(void *)v22 == -1)
    {
      uint64_t v24 = 0;
LABEL_40:
      if (v24) {
        BOOL v28 = v24;
      }
      else {
        BOOL v28 = v22;
      }
      if (*(void *)v28 != v10)
      {
        if (*(void *)v28 == -2) {
          --v34;
        }
        else {
          ++HIDWORD(v33);
        }
        *(void *)BOOL v28 = v10;
        if (v11) {
          goto LABEL_47;
        }
      }
    }
    else
    {
      uint64_t v24 = 0;
      int v25 = 1;
      while (v23 != v10)
      {
        if (v24) {
          BOOL v26 = 0;
        }
        else {
          BOOL v26 = v23 == -2;
        }
        if (v26) {
          uint64_t v24 = v22;
        }
        unsigned int v27 = v21 + v25++;
        unsigned int v21 = v27 & v20;
        uint64_t v22 = &v14[8 * (v27 & v20)];
        uint64_t v23 = *(void *)v22;
        if (*(void *)v22 == -1) {
          goto LABEL_40;
        }
      }
    }
LABEL_48:
    ++v8;
  }
  while (v8 != v4);
  if (v32 != v31) {
    free(v32);
  }
  return v9;
}

uint64_t sub_1CC312450(uint64_t ****a1, llvm::Loop **a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = ****a1;
  if (*(void *)(v3 + 128)
    || (uint64_t result = (*(uint64_t (**)(void))(**(void **)(v3 + 72) + 48))(*(void *)(v3 + 72)),
        result))
  {
    llvm::Loop::getStartLoc(*a2);
  }
  return result;
}

uint64_t sub_1CC3127C8()
{
  int v4 = 1;
  int v5 = 1;
  char v2 = 0;
  uint64_t v3 = &v2;
  v1.n128_u64[0] = (unint64_t)"Enable generating trap for unreachable";
  v1.n128_u64[1] = 38;
  sub_1CD521CAC(&v5, &v4, &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBD05020, &dword_1CB82C000);
}

void sub_1CC312840()
{
}

void sub_1CC3128DC()
{
}

void sub_1CC312A04(llvm::Pass *this)
{
  *(void *)this = &unk_1F260D3A8;
  char v2 = (char *)*((void *)this + 31);
  if (v2 != (char *)this + 264) {
    free(v2);
  }
  *(void *)this = &unk_1F260E110;
  uint64_t v3 = (char *)*((void *)this + 22);
  if (v3 != (char *)this + 192) {
    free(v3);
  }
  int v4 = (char *)*((void *)this + 13);
  if (v4 != (char *)this + 120) {
    free(v4);
  }
  int v5 = (char *)*((void *)this + 4);
  if (v5 != (char *)this + 48) {
    free(v5);
  }

  llvm::Pass::~Pass(this);
}

void sub_1CC312ACC(llvm::Pass *this)
{
  *(void *)this = &unk_1F260D3A8;
  char v2 = (char *)*((void *)this + 31);
  if (v2 != (char *)this + 264) {
    free(v2);
  }
  *(void *)this = &unk_1F260E110;
  uint64_t v3 = (char *)*((void *)this + 22);
  if (v3 != (char *)this + 192) {
    free(v3);
  }
  int v4 = (char *)*((void *)this + 13);
  if (v4 != (char *)this + 120) {
    free(v4);
  }
  int v5 = (char *)*((void *)this + 4);
  if (v5 != (char *)this + 48) {
    free(v5);
  }
  llvm::Pass::~Pass(this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC312BA8(llvm::PassRegistry *a1, uint64_t a2)
{
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)a1, a2);
}

uint64_t sub_1CC312C1C(uint64_t a1, uint64_t a2)
{
  uint64_t v105 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a2 + 56);
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 176))(*(void *)(a2 + 16));
  if (*(_DWORD *)(v4 + 32) == -858993459 * ((*(void *)(v4 + 16) - *(void *)(v4 + 8)) >> 3)) {
    return 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 408))(v5, a2);
  if (result)
  {
    uint64_t v72 = v4;
    uint64_t v78 = (void *)(a1 + 248);
    sub_1CD42769C(a1 + 248, (int)(-858993459 * ((*(void *)(v4 + 16) - *(void *)(v4 + 8)) >> 3) - *(_DWORD *)(v4 + 32)));
    uint64_t v7 = *(void *)(a2 + 56);
    uint64_t v8 = (_DWORD *)(*(uint64_t (**)(void))(**(void **)(a2 + 16) + 112))(*(void *)(a2 + 16));
    int v9 = v8[2];
    uint64_t v82 = 0;
    char v81 = 0;
    uint64_t v99 = v101;
    uint64_t v100 = 0x1000000000;
    uint64_t v103 = 0;
    uint64_t v104 = 0;
    uint64_t v102 = &v103;
    signed int v10 = *(_DWORD *)(v7 + 64);
    if (v10 != -1)
    {
      *(void *)&long long v94 = 1;
      memset_pattern16((char *)&v94 + 8, &unk_1CDB165A0, 0x20uLL);
      uint64_t v96 = (signed int *)v98;
      uint64_t v97 = 0x800000000;
      uint64_t v89 = 1;
      memset_pattern16(v90, &unk_1CDB165A0, 0x20uLL);
      unsigned int v91 = (signed int *)v93;
      uint64_t v92 = 0x800000000;
      uint64_t v84 = 1;
      memset_pattern16(v85, &unk_1CDB165A0, 0x20uLL);
      uint64_t v86 = v88;
      uint64_t v87 = 0x800000000;
      if ((*(unsigned int (**)(_DWORD *, void))(*(void *)v8 + 24))(v8, *(unsigned __int8 *)(*(void *)(v7 + 8) + 40 * (*(_DWORD *)(v7 + 32) + v10) + 20)))
      {
        sub_1CC3137A0(a1, v7, v10, &v82, v9 == 1, &v81);
      }
      int v11 = -858993459 * ((*(void *)(v7 + 16) - *(void *)(v7 + 8)) >> 3);
      int v12 = *(_DWORD *)(v7 + 32);
      int v13 = v11 - v12;
      if (v11 != v12)
      {
        int v65 = 0;
        do
        {
          if (v10 != v65)
          {
            unsigned int v66 = v65 + *(_DWORD *)(v7 + 32);
            uint64_t v67 = *(void *)(v7 + 8);
            if (*(void *)(v67 + 40 * v66 + 8) != -1)
            {
              if ((*(unsigned int (**)(_DWORD *, void))(*(void *)v8 + 24))(v8, *(unsigned __int8 *)(v67 + 40 * v66 + 20)))
              {
                uint64_t v68 = *(void *)(v7 + 8);
                int v69 = *(unsigned __int8 *)(v68 + 40 * (v65 + *(_DWORD *)(v7 + 32)) + 36);
                if (*(unsigned char *)(v68 + 40 * (v65 + *(_DWORD *)(v7 + 32)) + 36))
                {
                  if (v69 == 1)
                  {
                    int v83 = v65;
                    BOOL v70 = (uint64_t *)&v94;
                  }
                  else
                  {
                    int v83 = v65;
                    if (v69 == 3) {
                      BOOL v70 = &v84;
                    }
                    else {
                      BOOL v70 = &v89;
                    }
                  }
                  sub_1CD52500C((uint64_t)v70, &v83);
                }
              }
            }
          }
          ++v65;
        }
        while (v13 != v65);
      }
      if (v97)
      {
        unint64_t v14 = v96;
        uint64_t v15 = 4 * v97;
        do
        {
          int v83 = 0;
          signed int v16 = *v14++;
          int v83 = v16;
          sub_1CC3137A0(a1, v7, v16, &v82, v9 == 1, &v81);
          sub_1CD41AE70((uint64_t)&v99, &v83);
          v15 -= 4;
        }
        while (v15);
      }
      if (v92)
      {
        uint64_t v17 = v91;
        uint64_t v18 = 4 * v92;
        do
        {
          int v83 = 0;
          signed int v19 = *v17++;
          int v83 = v19;
          sub_1CC3137A0(a1, v7, v19, &v82, v9 == 1, &v81);
          sub_1CD41AE70((uint64_t)&v99, &v83);
          v18 -= 4;
        }
        while (v18);
      }
      unsigned int v20 = (signed int *)v86;
      if (v87)
      {
        uint64_t v21 = 4 * v87;
        do
        {
          int v83 = 0;
          signed int v22 = *v20++;
          int v83 = v22;
          sub_1CC3137A0(a1, v7, v22, &v82, v9 == 1, &v81);
          sub_1CD41AE70((uint64_t)&v99, &v83);
          v21 -= 4;
        }
        while (v21);
        unsigned int v20 = (signed int *)v86;
      }
      if (v20 != (signed int *)v88) {
        free(v20);
      }
      if ((v84 & 1) == 0) {
        MEMORY[0x1D25D9CD0](v85[0], 4);
      }
      if (v91 != (signed int *)v93) {
        free(v91);
      }
      if ((v89 & 1) == 0) {
        MEMORY[0x1D25D9CD0](v90[0], 4);
      }
      if (v96 != (signed int *)v98) {
        free(v96);
      }
      if ((v94 & 1) == 0) {
        MEMORY[0x1D25D9CD0](*((void *)&v94 + 1), 4);
      }
    }
    int v23 = -858993459 * ((*(void *)(v7 + 16) - *(void *)(v7 + 8)) >> 3);
    int v24 = *(_DWORD *)(v7 + 32);
    int v25 = v23 - v24;
    if (v23 != v24)
    {
      for (signed int i = 0; i != v25; ++i)
      {
        unsigned int v27 = *(_DWORD *)(v7 + 32) + i;
        uint64_t v28 = *(void *)(v7 + 8);
        if (*(void *)(v28 + 40 * v27 + 8) != -1 && *(_DWORD *)(v7 + 64) != i)
        {
          if (v104)
          {
            for (j = v103; j; j = (void *)*j)
            {
              signed int v30 = *((_DWORD *)j + 7);
              if (i >= v30)
              {
                if (v30 >= i) {
                  goto LABEL_49;
                }
                ++j;
              }
            }
          }
          else if (v100)
          {
            uint64_t v31 = v99;
            uint64_t v32 = 4 * v100;
            while (*(_DWORD *)v31 != i)
            {
              v31 += 4;
              v32 -= 4;
              if (!v32) {
                goto LABEL_47;
              }
            }
            if (v32) {
              continue;
            }
          }
LABEL_47:
          if ((*(unsigned int (**)(_DWORD *, void))(*(void *)v8 + 24))(v8, *(unsigned __int8 *)(v28 + 40 * v27 + 20)))
          {
            sub_1CC3137A0(a1, v7, i, &v82, v9 == 1, &v81);
          }
        }
LABEL_49:
        ;
      }
    }
    *(void *)(v7 + 640) = v82;
    *(unsigned char *)(v7 + 648) = v81;
    sub_1CD3C5048((uint64_t)&v102, v103);
    if (v99 != v101) {
      free(v99);
    }
    uint64_t v80 = *(void *)(a2 + 56);
    uint64_t v33 = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 176))(*(void *)(a2 + 16));
    int v75 = *(_DWORD *)((*(uint64_t (**)(void))(**(void **)(a2 + 16) + 112))(*(void *)(a2 + 16)) + 8);
    uint64_t v99 = v101;
    uint64_t v100 = 0x4000000000;
    uint64_t v34 = *(void *)(a2 + 328);
    if (v34 != a2 + 320)
    {
      unsigned int v76 = 0;
      do
      {
        for (uint64_t k = *(void *)(v34 + 56); k != v34 + 48; uint64_t k = *(void *)(k + 8))
        {
          unsigned int v36 = **(unsigned __int16 **)(k + 16);
          if (v36 - 13 >= 5)
          {
            BOOL v37 = v36 > 0x1F;
            unsigned int v38 = (1 << v36) & 0x8A000000;
            if (v37 || v38 == 0)
            {
              uint64_t v40 = *(unsigned int *)(k + 40);
              if (v40)
              {
                uint64_t v41 = (_DWORD *)(*(void *)(k + 32) + 16);
                uint64_t v42 = 32 * v40;
                while (*((unsigned char *)v41 - 16) != 5)
                {
                  v41 += 8;
                  v42 -= 32;
                  if (!v42) {
                    goto LABEL_72;
                  }
                }
                unsigned int v43 = *v41;
                if (*(unsigned char *)(*(void *)(v80 + 8) + 40 * (*(_DWORD *)(v80 + 32) + *v41) + 32))
                {
                  uint64_t v44 = *(void *)(*v78 + 8 * (int)v43);
                  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)v33 + 456))(v33, k, v44))
                  {
                    *(void *)&long long v94 = k;
                    *((void *)&v94 + 1) = v44;
                    unint64_t v95 = __PAIR64__(v76, v43);
                    if (v100 >= HIDWORD(v100))
                    {
                      if (v99 > (char *)&v94 || &v99[24 * v100] <= (char *)&v94) {
                        llvm::SmallVectorBase<unsigned int>::grow_pod();
                      }
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    ++v76;
                    char v45 = &v99[24 * v100];
                    long long v46 = v94;
                    *((void *)v45 + 2) = v95;
                    *(_OWORD *)char v45 = v46;
                    LODWORD(v100) = v100 + 1;
                  }
                }
LABEL_72:
                if (!k) {
                  goto LABEL_75;
                }
              }
            }
          }
          if ((*(unsigned char *)k & 4) == 0)
          {
LABEL_75:
            while ((*(_WORD *)(k + 44) & 8) != 0)
              uint64_t k = *(void *)(k + 8);
          }
        }
        uint64_t v34 = *(void *)(v34 + 8);
      }
      while (v34 != a2 + 320);
      int v47 = v100;
      if (v100 >= 2)
      {
        qsort(v99, v100, 0x18uLL, (int (__cdecl *)(const void *, const void *))sub_1CC313890);
        int v47 = v100;
      }
      if (v47 >= 1)
      {
        uint64_t v48 = 0;
        char v79 = 0;
        uint64_t v73 = 0;
        unsigned int v74 = 0;
        uint64_t v71 = *(void *)(a2 + 328);
        unint64_t v49 = v47;
        unint64_t v77 = v47;
        while (1)
        {
          BOOL v50 = &v99[24 * v48];
          uint64_t v51 = *((unsigned int *)v50 + 4);
          int v52 = *(_DWORD *)(v80 + 64);
          if (v52 != -1 && v51 == v52) {
            goto LABEL_106;
          }
          uint64_t v54 = *(void *)v50;
          uint64_t v55 = *(unsigned int *)(*(void *)v50 + 40);
          if (v55)
          {
            uint64_t v56 = 0;
            BOOL v57 = (_DWORD *)(*(void *)(v54 + 32) + 16);
            while (*((unsigned char *)v57 - 16) != 5 || v51 != *v57)
            {
              ++v56;
              v57 += 8;
              if (v55 == v56)
              {
                uint64_t v56 = *(unsigned int *)(*(void *)v50 + 40);
                break;
              }
            }
          }
          else
          {
            uint64_t v56 = 0;
          }
          if (v75 == 1) {
            uint64_t v58 = *(void *)(v80 + 640);
          }
          else {
            uint64_t v58 = 0;
          }
          uint64_t v59 = *((void *)v50 + 1);
          if ((v79 & 1) == 0
            || (uint64_t v60 = v58 + v59 - v73,
                uint64_t v61 = v74,
                ((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(*(void *)v33 + 480))(v33, v54, v74, v60) & 1) == 0))
          {
            uint64_t v62 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v33 + 448))(v33, v54, v56);
            unint64_t v49 = v77;
            if (v48 + 1 >= v77) {
              goto LABEL_106;
            }
            uint64_t v63 = v62;
            uint64_t v64 = v58 + v59 + v62;
            if (!(*(unsigned int (**)(uint64_t, void, void, uint64_t))(*(void *)v33 + 480))(v33, *(void *)&v99[24 * v48 + 24], v74, *(void *)&v99[24 * v48 + 32] - (v59 + v62)))goto LABEL_106; {
            uint64_t v60 = -v63;
            }
            unsigned int v74 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v33 + 464))(v33, v71, v51, v63);
            uint64_t v61 = v74;
            uint64_t v73 = v64;
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v33 + 472))(v33, v54, v61, v60);
          char v79 = 1;
          unint64_t v49 = v77;
LABEL_106:
          if (++v48 == v49) {
            goto LABEL_109;
          }
        }
      }
    }
    char v79 = 0;
LABEL_109:
    if (v99 != v101) {
      free(v99);
    }
    *(unsigned char *)(v72 + 649) = v79 & 1;
    return 1;
  }
  return result;
}

uint64_t sub_1CC3137A0(uint64_t a1, uint64_t a2, signed int a3, uint64_t *a4, int a5, unsigned char *a6)
{
  char v6 = a5;
  if (a5)
  {
    unsigned int v10 = *(_DWORD *)(a2 + 32) + a3;
    uint64_t v11 = *(void *)(a2 + 8);
    *a4 += *(void *)(v11 + 40 * v10 + 8);
  }
  else
  {
    uint64_t v11 = *(void *)(a2 + 8);
    unsigned int v10 = *(_DWORD *)(a2 + 32) + a3;
  }
  unsigned int v12 = *(unsigned __int8 *)(v11 + 40 * v10 + 16);
  unsigned int v13 = *a6;
  if (v13 <= v12) {
    LOBYTE(v13) = v12;
  }
  *a6 = v13;
  uint64_t v14 = ((1 << v12) + *a4 - 1) & -(1 << v12);
  *a4 = v14;
  if (a5) {
    uint64_t v15 = -v14;
  }
  else {
    uint64_t v15 = v14;
  }
  *(void *)(*(void *)(a1 + 248) + 8 * a3) = v15;
  uint64_t result = sub_1CD52509C(a2, a3, v15);
  if ((v6 & 1) == 0) {
    *a4 += *(void *)(*(void *)(a2 + 8) + 40 * (*(_DWORD *)(a2 + 32) + a3) + 8);
  }
  return result;
}

uint64_t sub_1CC313890(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  if (v3 < v2) {
    return 1;
  }
  int v4 = *(_DWORD *)(a1 + 16);
  int v5 = *(_DWORD *)(a2 + 16);
  if (v4 < v5) {
    return 0xFFFFFFFFLL;
  }
  if (v5 < v4) {
    return 1;
  }
  unsigned int v7 = *(_DWORD *)(a1 + 20);
  unsigned int v8 = *(_DWORD *)(a2 + 20);
  if (v7 >= v8) {
    return v8 < v7;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

BOOL llvm::LoopTraversal::isBlockDone(void *a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 24);
  if (*(unsigned char *)(*a1 + 16 * v2) && (uint64_t v3 = (_DWORD *)(*a1 + 16 * v2), v3[3] == v3[2])) {
    return v3[1] == ((*(void *)(a2 + 72) - *(void *)(a2 + 64)) >> 3);
  }
  else {
    return 0;
  }
}

unint64_t llvm::getLLTForType(llvm *this, llvm::Type *a2, const llvm::DataLayout *a3)
{
  unint64_t v5 = *((unsigned int *)this + 2);
  if ((*((_DWORD *)this + 2) & 0xFE) != 0x12)
  {
    if (*((_DWORD *)this + 2) == 15)
    {
      unint64_t v11 = v5 >> 8;
      if (v5 < 0x100) {
        goto LABEL_19;
      }
      uint64_t v12 = *((unsigned int *)a2 + 60);
      uint64_t v13 = *((void *)a2 + 29);
      if (v12)
      {
        uint64_t v13 = *((void *)a2 + 29);
        unint64_t v14 = *((unsigned int *)a2 + 60);
        do
        {
          unint64_t v15 = v14 >> 1;
          uint64_t v16 = v13 + 16 * (v14 >> 1);
          unsigned int v17 = *(_DWORD *)(v16 + 8);
          uint64_t v18 = v16 + 16;
          v14 += ~(v14 >> 1);
          if (v17 < v11) {
            uint64_t v13 = v18;
          }
          else {
            unint64_t v14 = v15;
          }
        }
        while (v14);
      }
      if (v13 == *((void *)a2 + 29) + 16 * v12 || *(_DWORD *)(v13 + 8) != v11) {
LABEL_19:
      }
        uint64_t v13 = *((void *)a2 + 29);
      return (v11 << 19) | (8 * (unsigned __int16)*(_DWORD *)(v13 + 4)) | 2;
    }
    if (*((_DWORD *)this + 2) <= 0x11u)
    {
      if (((1 << v5) & 0xAC7F) != 0)
      {
LABEL_23:
        unsigned int v20 = sub_1CB83544C((uint64_t)a2, (uint64_t)this);
        if (v19 == 1) {
        return ((unint64_t)(*((unsigned char *)this + 8) == 1) << 63) | (8 * v20) | 1;
        }
      }
      if (((1 << v5) & 0x30000) != 0) {
        goto LABEL_28;
      }
    }
    if (*((_DWORD *)this + 2) != 21) {
      return 0;
    }
LABEL_28:
    int isSizedDerivedType = llvm::Type::isSizedDerivedType((uint64_t)this, 0);
    unint64_t LLTForType = 0;
    if (isSizedDerivedType) {
      goto LABEL_23;
    }
    return LLTForType;
  }
  uint64_t v6 = *((unsigned int *)this + 8);
  int v7 = *((_DWORD *)this + 2);
  unint64_t LLTForType = llvm::getLLTForType(*((llvm **)this + 3), a2, a3);
  if (v7 != 19 && v6 == 1) {
    return LLTForType;
  }

  return sub_1CBA5A95C(v6 | ((unint64_t)(v7 == 19) << 32), LLTForType);
}

unint64_t llvm::getLLTForMVT(unsigned __int8 a1)
{
  unsigned __int8 v11 = a1;
  if (a1 - 15 >= 0x9C)
  {
    unsigned int v7 = sub_1CB87E200(&v11);
    if (v6 == 1) {
    return (8 * v7) | 1;
    }
  }
  else
  {
    unsigned int v1 = sub_1CB8C32B0(&v11);
    unsigned __int8 v2 = v11;
    unsigned __int8 v10 = sub_1CB8C2FBC(&v11);
    unsigned int v3 = sub_1CB87E200(&v10);
    if (v4 == 1)
    {
      unsigned int v9 = v3;
      unsigned int v3 = v9;
    }
    unint64_t v5 = (8 * v3) | 1;
    if (v1 != 1 || (v2 + 85) >= 0xCDu) {
      return sub_1CBA5A95C(v1 | ((unint64_t)((v2 + 85) > 0xCCu) << 32), v5);
    }
  }
  return v5;
}

void llvm::initializeLowerEmuTLSPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD490, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CC313C40;
    v3[1] = &v1;
    unsigned __int8 v2 = v3;
    std::__call_once(&qword_1EBCCD490, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC313C40()
{
}

uint64_t sub_1CC313CDC(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCCD488;
  *(_DWORD *)(a1 + 24) = 4;
  *(void *)a1 = &unk_1F260D468;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD490, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC313C40;
    v5[1] = &PassRegistry;
    int v4 = v5;
    std::__call_once(&qword_1EBCCD490, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CC313D8C()
{
}

void sub_1CC313DCC(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC313E04(llvm::ModulePass *a1, uint64_t a2)
{
  uint64_t v123 = *MEMORY[0x1E4F143B8];
  if (llvm::ModulePass::skipModule(a1, (llvm::LLVMContextImpl ***)a2)) {
    goto LABEL_8;
  }
  uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*((void *)a1 + 1) + 24), &llvm::TargetPassConfig::ID, 1);
  if (!AnalysisPass) {
    goto LABEL_8;
  }
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void *))(*(void *)AnalysisPass + 96))(AnalysisPass, &llvm::TargetPassConfig::ID);
  if (!v5) {
    goto LABEL_8;
  }
  uint64_t v6 = *(_DWORD **)(v5 + 112);
  int v7 = v6[260];
  if ((v7 & 0x40000) != 0)
  {
    if ((v7 & 0x20000) == 0)
    {
LABEL_8:
      char v10 = 0;
      return v10 & 1;
    }
  }
  else
  {
    int v8 = v6[122];
    if (v8 != 11)
    {
      int v9 = v6[121];
      if (v9 != 13 && (v9 != 15 || v8 != 18)) {
        goto LABEL_8;
      }
    }
  }
  unint64_t v116 = (uint64_t *)v118;
  uint64_t v117 = 0x800000000;
  uint64_t v12 = *(void *)(a2 + 16);
  if (v12 == a2 + 8) {
    goto LABEL_8;
  }
  unsigned int v13 = 0;
  do
  {
    if (v12) {
      uint64_t v14 = v12 - 56;
    }
    else {
      uint64_t v14 = 0;
    }
    if ((*(unsigned char *)(v14 + 33) & 0x1C) != 0)
    {
      if (v13 >= HIDWORD(v117)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v116[v13] = v14;
      unsigned int v13 = v117 + 1;
      LODWORD(v117) = v117 + 1;
    }
    uint64_t v12 = *(void *)(v12 + 8);
  }
  while (v12 != a2 + 8);
  uint64_t v105 = v116;
  char v10 = 0;
  if (v13)
  {
    uint64_t v97 = &v116[v13];
    unint64_t v98 = (llvm::DataLayout *)(a2 + 272);
    while (1)
    {
      uint64_t v15 = *v105;
      uint64_t v99 = *(llvm::LLVMContextImpl ***)a2;
      int v106 = (llvm::ConstantPointerNull *)llvm::PointerType::get((llvm::PointerType *)(**(void **)a2 + 1912), 0);
      uint64_t v109 = v15;
      unsigned int v102 = v15 >> 4;
      if ((*(unsigned char *)(v15 + 23) & 0x10) == 0)
      {
        uint64_t v25 = 0;
        BOOL v26 = &byte_1CFBCE98E;
        goto LABEL_34;
      }
      uint64_t v16 = ***(void ***)v15;
      uint64_t v17 = *(void *)(v16 + 152);
      uint64_t v18 = *(unsigned int *)(v16 + 168);
      if (!v18) {
        goto LABEL_32;
      }
      LODWORD(v19) = (v18 - 1) & (v102 ^ (v15 >> 9));
      unsigned int v20 = (uint64_t *)(v17 + 16 * v19);
      uint64_t v21 = *v20;
      if (*v20 != v15) {
        break;
      }
LABEL_33:
      int v24 = (void *)v20[1];
      uint64_t v27 = *v24;
      BOOL v26 = (char *)(v24 + 2);
      uint64_t v25 = v27;
LABEL_34:
      __int16 v122 = 1283;
      *(void *)&long long v120 = "__emutls_v.";
      *(void *)&long long v121 = v26;
      *((void *)&v121 + 1) = v25;
      llvm::Twine::str((llvm::Twine *)&v120, &v113);
      char v103 = v115;
      unint64_t v29 = (unsigned __int8 *)v113;
      if (v115 >= 0) {
        unint64_t v29 = (unsigned __int8 *)&v113;
      }
      __s1 = v29;
      if (v115 >= 0) {
        size_t v30 = v115 & 0x7F;
      }
      else {
        size_t v30 = v114;
      }
      uint64_t v31 = *(uint64_t **)(a2 + 112);
      size_t v32 = *((unsigned int *)v31 + 8);
      if ((v32 & 0x80000000) == 0)
      {
        if (v32 <= 1) {
          unint64_t v33 = 1;
        }
        else {
          unint64_t v33 = v32;
        }
        if (v30 < v33) {
          unint64_t v33 = v30;
        }
        if (v30 > v32) {
          size_t v30 = v33;
        }
      }
      uint64_t v100 = (llvm::PoisonValue *)*((unsigned int *)v31 + 2);
      if (v100)
      {
        int v34 = 0;
        if (v30)
        {
          size_t v35 = v30;
          unsigned int v36 = __s1;
          do
          {
            int v37 = *v36++;
            int v34 = 33 * v34 + v37;
            --v35;
          }
          while (v35);
        }
        uint64_t v38 = *v31;
        uint64_t v39 = *v31 + 8 * (void)v100 + 8;
        int v40 = 1;
        int v41 = v34;
        while (1)
        {
          uint64_t v42 = v41 & (v100 - 1);
          unsigned int v43 = *(void **)(v38 + 8 * v42);
          if (v43 != (void *)-8)
          {
            if (!v43) {
              goto LABEL_62;
            }
            if (*(_DWORD *)(v39 + 4 * v42) == v34
              && v30 == *v43
              && (!v30 || !memcmp(__s1, (char *)v43 + *((unsigned int *)v31 + 5), v30)))
            {
              break;
            }
          }
          int v41 = v40 + v42;
          ++v40;
        }
        if (v42 != -1 && (llvm::PoisonValue *)(int)v42 != v100)
        {
          uint64_t v44 = *(void *)(*(void *)(v38 + 8 * (int)v42) + 8);
          if (v44)
          {
            if (*(unsigned char *)(v44 + 16) == 3)
            {
              char v96 = 0;
              goto LABEL_141;
            }
          }
        }
      }
LABEL_62:
      uint64_t v104 = (llvm::detail::IEEEFloat *)llvm::ConstantPointerNull::get(v106, v28);
      if (v109 && *(unsigned char *)(v109 + 16) == 3)
      {
        if ((*(_DWORD *)(v109 + 20) & 0x7FFFFFF) == 0) {
          goto LABEL_73;
        }
      }
      else if (!*(unsigned char *)(v109 + 16) && *(void *)(v109 + 72) == v109 + 72 && (*(unsigned char *)(v109 + 34) & 0x80) == 0)
      {
        goto LABEL_73;
      }
      uint64_t v45 = *(void *)(v109 - 32);
      int v46 = *(unsigned __int8 *)(v45 + 16);
      if (v46 == 16) {
        uint64_t v47 = *(void *)(v109 - 32);
      }
      else {
        uint64_t v47 = 0;
      }
      if (v46 == 13)
      {
LABEL_73:
        uint64_t v48 = llvm::IntegerType::get((llvm::IntegerType *)v99, (llvm::LLVMContext *)*(unsigned int *)(*(void *)(a2 + 504) + 4));
        uint64_t v45 = 0;
        char v49 = 1;
        unint64_t v50 = (unint64_t)v106;
        goto LABEL_85;
      }
      if (v47)
      {
        uint64_t v51 = *(unsigned int *)(v47 + 32);
        if (v51 > 0x40)
        {
          int v52 = 0;
          int64_t v53 = (unint64_t)(v51 + 63) >> 6;
          do
          {
            if (v53-- < 1) {
              break;
            }
            unint64_t v55 = *(void *)(*(void *)(v47 + 24) + 8 * v53);
            v52 += __clz(v55);
          }
          while (!v55);
          int v56 = v51 | 0xFFFFFFC0;
          if ((v51 & 0x3F) == 0) {
            int v56 = 0;
          }
          if (v52 + v56 == v51) {
            goto LABEL_73;
          }
        }
        else if (!*(void *)(v47 + 24))
        {
          goto LABEL_73;
        }
      }
      uint64_t v48 = llvm::IntegerType::get((llvm::IntegerType *)v99, (llvm::LLVMContext *)*(unsigned int *)(*(void *)(a2 + 504) + 4));
      unint64_t v50 = llvm::PointerType::get(*(llvm::PointerType **)v45, 0);
      char v49 = 0;
LABEL_85:
      v119[0] = v48;
      v119[1] = v48;
      v119[2] = v106;
      v119[3] = v50;
      BOOL v57 = (llvm::PointerType *)llvm::StructType::create(*(uint64_t **)v48, 0, 0);
      llvm::StructType::setBody((uint64_t)v57, (uint64_t)v119, 4, 0);
      if (v115 >= 0) {
        uint64_t v58 = (unsigned __int8 *)&v113;
      }
      else {
        uint64_t v58 = (unsigned __int8 *)v113;
      }
      if (v115 >= 0) {
        unint64_t v59 = v115 & 0x7F;
      }
      else {
        unint64_t v59 = v114;
      }
      uint64_t v101 = v57;
      inserted = llvm::Module::getOrInsertGlobal(a2, v58, v59, v57);
      sub_1CC31480C(a2, v109, (uint64_t ***)inserted);
      if (v109 && *(unsigned char *)(v109 + 16) == 3)
      {
        if ((*(_DWORD *)(v109 + 20) & 0x7FFFFFF) != 0) {
          goto LABEL_98;
        }
      }
      else if (*(unsigned char *)(v109 + 16) || *(void *)(v109 + 72) != v109 + 72 || (*(unsigned char *)(v109 + 34) & 0x80) != 0)
      {
LABEL_98:
        uint64_t v61 = *(llvm::PointerType **)(v109 + 24);
        if ((*(_WORD *)(v109 + 34) & 0x3F) != 0) {
          unsigned __int8 __s1a = (*(_WORD *)(v109 + 34) & 0x3F) - 1;
        }
        else {
          unsigned __int8 __s1a = llvm::DataLayout::getAlignment(v98, *(llvm::Type **)(v109 + 24), 1);
        }
        if (v49)
        {
          uint64_t v62 = 0;
LABEL_123:
          long long v120 = 0u;
          long long v121 = 0u;
          uint64_t v81 = sub_1CB83544C((uint64_t)v98, (uint64_t)v61);
          if (v79 == 1) {
          unint64_t v82 = (unint64_t)(v81 + 7) >> 3;
          }
          int v83 = *(uint64_t **)v48;
          unsigned int v84 = *(_DWORD *)(v48 + 8);
          LODWORD(v111) = v84 >> 8;
          if (v84 >> 8 > 0x40) {
            operator new[]();
          }
          if (v84 <= 0xFF) {
            unint64_t v85 = 0;
          }
          else {
            unint64_t v85 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v84) + 63);
          }
          __p = (void *)(v85 & v82);
          uint64_t v87 = llvm::ConstantInt::get((llvm::ConstantInt *)v83, (llvm::LLVMContext *)&__p, v80);
          if (v111 >= 0x41 && __p) {
            MEMORY[0x1D25D9CB0](__p, 0x1000C8000313F17);
          }
          *(void *)&long long v120 = v87;
          uint64_t v88 = *(uint64_t **)v48;
          unsigned int v89 = *(_DWORD *)(v48 + 8);
          LODWORD(v111) = v89 >> 8;
          if (v89 >> 8 > 0x40) {
            operator new[]();
          }
          if (v89 <= 0xFF) {
            unint64_t v90 = 0;
          }
          else {
            unint64_t v90 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v89) + 63);
          }
          __p = (void *)(v90 & (1 << __s1a));
          unsigned int v91 = llvm::ConstantInt::get((llvm::ConstantInt *)v88, (llvm::LLVMContext *)&__p, v86);
          if (v111 >= 0x41 && __p) {
            MEMORY[0x1D25D9CB0](__p, 0x1000C8000313F17);
          }
          uint64_t v92 = v104;
          *((void *)&v120 + 1) = v91;
          *(void *)&long long v121 = v104;
          if (v62) {
            uint64_t v92 = v62;
          }
          *((void *)&v121 + 1) = v92;
          int v93 = (llvm::Constant *)llvm::ConstantStruct::get(v101, (llvm::Type *)&v120, 4);
          llvm::GlobalVariable::setInitializer((uint64_t)inserted, v93);
          unsigned int Alignment = llvm::DataLayout::getAlignment(v98, (llvm::Type *)v48, 1);
          unsigned int v95 = llvm::DataLayout::getAlignment(v98, v106, 1);
          if (Alignment > v95) {
            unsigned int v95 = Alignment;
          }
          *((_DWORD *)inserted + 8) = ((v95 << 16) + 0x10000) | *((_DWORD *)inserted + 8) & 0xFFC0FFFF;
          goto LABEL_140;
        }
        if ((*(unsigned char *)(v109 + 23) & 0x10) != 0)
        {
          uint64_t v63 = ***(void ***)v109;
          uint64_t v64 = *(void *)(v63 + 152);
          uint64_t v65 = *(unsigned int *)(v63 + 168);
          if (!v65) {
            goto LABEL_110;
          }
          LODWORD(v66) = (v65 - 1) & (v102 ^ (v109 >> 9));
          uint64_t v67 = (uint64_t *)(v64 + 16 * v66);
          uint64_t v68 = *v67;
          if (*v67 != v109)
          {
            int v69 = 1;
            while (v68 != -4096)
            {
              int v70 = v66 + v69++;
              uint64_t v66 = v70 & (v65 - 1);
              uint64_t v68 = *(void *)(v64 + 16 * v66);
              if (v68 == v109)
              {
                uint64_t v67 = (uint64_t *)(v64 + 16 * v66);
                goto LABEL_111;
              }
            }
LABEL_110:
            uint64_t v67 = (uint64_t *)(v64 + 16 * v65);
          }
LABEL_111:
          uint64_t v71 = (void *)v67[1];
          uint64_t v74 = *v71;
          uint64_t v73 = (char *)(v71 + 2);
          uint64_t v72 = v74;
        }
        else
        {
          uint64_t v72 = 0;
          uint64_t v73 = &byte_1CFBCE98E;
        }
        __int16 v122 = 1283;
        *(void *)&long long v120 = "__emutls_t.";
        *(void *)&long long v121 = v73;
        *((void *)&v121 + 1) = v72;
        llvm::Twine::str((llvm::Twine *)&v120, &__p);
        if (v112 >= 0) {
          p_p = (unsigned __int8 *)&__p;
        }
        else {
          p_p = (unsigned __int8 *)__p;
        }
        if (v112 >= 0) {
          unint64_t v76 = v112 & 0x7F;
        }
        else {
          unint64_t v76 = v111;
        }
        unint64_t v77 = llvm::Module::getOrInsertGlobal(a2, p_p, v76, v61);
        uint64_t v62 = v77;
        if (*((unsigned char *)v77 + 16) == 3) {
          uint64_t v78 = (uint64_t)v77;
        }
        else {
          uint64_t v78 = 0;
        }
        *(unsigned char *)(v78 + 80) |= 1u;
        llvm::GlobalVariable::setInitializer(v78, (llvm::Constant *)v45);
        *(_DWORD *)(v78 + 32) = *(_DWORD *)(v78 + 32) & 0xFFC0FFFF | ((__s1a << 16) + 0x10000);
        sub_1CC31480C(a2, v109, (uint64_t ***)v78);
        if (v112 < 0) {
          operator delete(__p);
        }
        goto LABEL_123;
      }
LABEL_140:
      char v96 = 1;
      char v103 = v115;
LABEL_141:
      if (v103 < 0) {
        operator delete(v113);
      }
      v10 |= v96;
      if (++v105 == v97)
      {
        uint64_t v105 = v116;
        goto LABEL_155;
      }
    }
    int v22 = 1;
    while (v21 != -4096)
    {
      int v23 = v19 + v22++;
      uint64_t v19 = v23 & (v18 - 1);
      uint64_t v21 = *(void *)(v17 + 16 * v19);
      if (v21 == v15)
      {
        unsigned int v20 = (uint64_t *)(v17 + 16 * v19);
        goto LABEL_33;
      }
    }
LABEL_32:
    unsigned int v20 = (uint64_t *)(v17 + 16 * v18);
    goto LABEL_33;
  }
LABEL_155:
  if (v105 != (uint64_t *)v118) {
    free(v105);
  }
  return v10 & 1;
}

uint64_t sub_1CC31480C(uint64_t result, uint64_t a2, uint64_t ***a3)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(a2 + 32);
  unsigned int v7 = (v6 & 0xF) - 7;
  int v8 = *((_DWORD *)a3 + 8);
  BOOL v9 = v7 >= 2;
  if (v7 >= 2) {
    unsigned int v10 = *((_DWORD *)a3 + 8);
  }
  else {
    unsigned int v10 = v8 & 0xFFFFFFC0;
  }
  unsigned int v11 = v10 & 0xFFFFFFF0 | v6 & 0xF;
  *((_DWORD *)a3 + 8) = v11;
  if (!v9
    || (v8 & 0x30) != 0
    && (uint64_t result = llvm::GlobalValue::hasExternalWeakLinkage((llvm::GlobalValue *)a3),
        unsigned int v11 = *((_DWORD *)a3 + 8),
        (result & 1) == 0))
  {
    v11 |= 0x4000u;
    *((_DWORD *)a3 + 8) = v11;
  }
  int v12 = *(_DWORD *)(a2 + 32) & 0x30;
  unsigned int v13 = v12 | v11 & 0xFFFFFFCF;
  *((_DWORD *)a3 + 8) = v13;
  if ((v11 & 0xF) - 7 < 2
    || v12
    && (uint64_t result = llvm::GlobalValue::hasExternalWeakLinkage((llvm::GlobalValue *)a3),
        unsigned int v13 = *((_DWORD *)a3 + 8),
        (result & 1) == 0))
  {
    v13 |= 0x4000u;
    *((_DWORD *)a3 + 8) = v13;
  }
  *((_DWORD *)a3 + 8) = v13 & 0xFFFFBFFF | (((*(_DWORD *)(a2 + 32) >> 14) & 1) << 14);
  if (*(void *)(a2 + 48))
  {
    if ((*((unsigned char *)a3 + 23) & 0x10) == 0)
    {
      size_t v24 = 0;
      int v23 = (unsigned __int8 *)&byte_1CFBCE98E;
      goto LABEL_21;
    }
    uint64_t v14 = ***a3;
    uint64_t v15 = *(void *)(v14 + 152);
    uint64_t v16 = *(unsigned int *)(v14 + 168);
    if (v16)
    {
      LODWORD(v17) = (v16 - 1) & ((a3 >> 4) ^ (a3 >> 9));
      uint64_t v18 = (uint64_t ****)(v15 + 16 * v17);
      uint64_t v19 = *v18;
      if (*v18 == a3)
      {
LABEL_20:
        int v22 = v18[1];
        size_t v25 = (size_t)*v22;
        int v23 = (unsigned __int8 *)(v22 + 2);
        size_t v24 = v25;
LABEL_21:
        inserted = llvm::Module::getOrInsertComdat(v5, v23, v24);
        uint64_t result = (uint64_t)llvm::GlobalObject::setComdat((llvm::GlobalObject *)a3, (llvm::Comdat *)inserted);
        *((_DWORD *)a3[6] + 2) = *(_DWORD *)(*(void *)(a2 + 48) + 8);
        return result;
      }
      int v20 = 1;
      while (v19 != (uint64_t ***)-4096)
      {
        int v21 = v17 + v20++;
        uint64_t v17 = v21 & (v16 - 1);
        uint64_t v19 = *(uint64_t ****)(v15 + 16 * v17);
        if (v19 == a3)
        {
          uint64_t v18 = (uint64_t ****)(v15 + 16 * v17);
          goto LABEL_20;
        }
      }
    }
    uint64_t v18 = (uint64_t ****)(v15 + 16 * v16);
    goto LABEL_20;
  }
  return result;
}

llvm::MachineBasicBlock *llvm::MachineBasicBlock::MachineBasicBlock(llvm::MachineBasicBlock *this, llvm::MachineFunction *a2, const llvm::BasicBlock *a3)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = a3;
  *((_DWORD *)this + 6) = -1;
  *((void *)this + 6) = ((unint64_t)this + 48) | 4;
  *((void *)this + 7) = (char *)this + 48;
  *((unsigned char *)this + 144) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *(_OWORD *)((char *)this + 121) = 0u;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 19) = 0;
  *((unsigned char *)this + 176) = 0;
  *(_DWORD *)((char *)this + 187) = 0;
  *(void *)((char *)this + 180) = 0;
  *((void *)this + 24) = 0;
  *(_DWORD *)((char *)this + 199) = 0;
  *((void *)this + 27) = 0;
  *((void *)this + 28) = 0;
  *((void *)this + 26) = 0;
  *((void *)this + 4) = a2;
  *((void *)this + 5) = this;
  if (a3)
  {
    *((void *)this + 17) = llvm::BasicBlock::getIrrLoopHeaderWeight(a3);
    *((void *)this + 18) = v4;
  }
  return this;
}

{
  uint64_t v4;

  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = a3;
  *((_DWORD *)this + 6) = -1;
  *((void *)this + 6) = ((unint64_t)this + 48) | 4;
  *((void *)this + 7) = (char *)this + 48;
  *((unsigned char *)this + 144) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *(_OWORD *)((char *)this + 121) = 0u;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 19) = 0;
  *((unsigned char *)this + 176) = 0;
  *(_DWORD *)((char *)this + 187) = 0;
  *(void *)((char *)this + 180) = 0;
  *((void *)this + 24) = 0;
  *(_DWORD *)((char *)this + 199) = 0;
  *((void *)this + 27) = 0;
  *((void *)this + 28) = 0;
  *((void *)this + 26) = 0;
  *((void *)this + 4) = a2;
  *((void *)this + 5) = this;
  if (a3)
  {
    *((void *)this + 17) = llvm::BasicBlock::getIrrLoopHeaderWeight(a3);
    *((void *)this + 18) = v4;
  }
  return this;
}

void llvm::MachineBasicBlock::~MachineBasicBlock(llvm::MachineBasicBlock *this)
{
  unsigned __int8 v2 = (void *)*((void *)this + 19);
  if (v2)
  {
    *((void *)this + 20) = v2;
    operator delete(v2);
  }
  unsigned int v3 = (void *)*((void *)this + 14);
  if (v3)
  {
    *((void *)this + 15) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 11);
  if (v4)
  {
    *((void *)this + 12) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 8);
  if (v5)
  {
    *((void *)this + 9) = v5;
    operator delete(v5);
  }
  for (signed int i = (llvm::MachineBasicBlock *)*((void *)this + 7);
        (llvm::MachineBasicBlock *)((char *)this + 48) != i;
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  llvm::MachineBasicBlock *i;

  unsigned __int8 v2 = (void *)*((void *)this + 19);
  if (v2)
  {
    *((void *)this + 20) = v2;
    operator delete(v2);
  }
  unsigned int v3 = (void *)*((void *)this + 14);
  if (v3)
  {
    *((void *)this + 15) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 11);
  if (v4)
  {
    *((void *)this + 12) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 8);
  if (v5)
  {
    *((void *)this + 9) = v5;
    operator delete(v5);
  }
  for (signed int i = (llvm::MachineBasicBlock *)*((void *)this + 7);
        (llvm::MachineBasicBlock *)((char *)this + 48) != i;
}

uint64_t llvm::MachineBasicBlock::getSymbol(llvm::MachineBasicBlock *this)
{
  uint64_t result = *((void *)this + 26);
  if (!result)
  {
    uint64_t v3 = *((void *)this + 4);
    uint64_t v4 = *(llvm::MCContext **)(v3 + 24);
    unsigned int v5 = *(_DWORD *)(v3 + 640);
    BOOL v6 = v5 > 3 || v5 == 2;
    if (v6 || !*((unsigned char *)this + 200))
    {
      long long v20 = *(_OWORD *)(*((void *)v4 + 19) + 104);
      int v21 = "BB";
      __int16 v22 = 773;
      uint64_t v7 = *(unsigned int *)(v3 + 336);
      int v23 = (uint64_t *)&v20;
      uint64_t v25 = v7;
      __int16 v26 = 2050;
      v27[0] = (uint64_t)&v23;
      v27[2] = (uint64_t)"_";
      __int16 v28 = 770;
      int v8 = (unsigned __int8 **)*((unsigned int *)this + 6);
      v29[0] = (unsigned __int8 **)v27;
      v29[2] = v8;
      __int16 v30 = 2306;
      uint64_t result = llvm::MCContext::getOrCreateSymbol(v4, v29);
      *((void *)this + 26) = result;
      return result;
    }
    uint64_t v16 = (llvm::Value **)*((void *)this + 4);
    uint64_t v17 = *(llvm::MCContext **)(v3 + 24);
    unint64_t v33 = &v35;
    long long v34 = xmmword_1CFAC7100;
    if (*((void *)this + 24) == llvm::MBBSectionID::ColdSectionID)
    {
      BOOL v9 = ".cold";
      unsigned int v10 = "";
    }
    else
    {
      if (*((void *)this + 24) != llvm::MBBSectionID::ExceptionSectionID)
      {
        __int16 v26 = 261;
        int v23 = &v35;
        uint64_t v24 = 0;
        *(void *)&long long v20 = ".__part.";
        __int16 v22 = 259;
        sub_1CB8F1E58((uint64_t *)&v23, (uint64_t *)&v20, (uint64_t)v27);
        int v13 = *((_DWORD *)this + 49);
        __int16 v19 = 264;
        LODWORD(v18[0]) = v13;
        sub_1CB8F1E58(v27, v18, (uint64_t)v29);
        llvm::Twine::str((llvm::Twine *)v29, v31);
        if (v32 >= 0) {
          uint64_t v14 = v31;
        }
        else {
          uint64_t v14 = (void **)v31[0];
        }
        uint64_t v15 = (unsigned char *)(v32 & 0x7F);
        if (v32 < 0) {
          uint64_t v15 = v31[1];
        }
        *(void *)&long long v34 = 0;
        sub_1CC22C75C(&v33, v14, &v15[(void)v14]);
        if (v32 < 0) {
          operator delete(v31[0]);
        }
        goto LABEL_15;
      }
      BOOL v9 = ".eh";
      unsigned int v10 = "";
    }
    sub_1CC22C75C(&v33, v9, v10);
LABEL_15:
    Name = llvm::MachineFunction::getName(v16);
    __int16 v28 = 261;
    v27[0] = (uint64_t)Name;
    v27[1] = v12;
    __int16 v26 = 261;
    int v23 = v33;
    uint64_t v24 = v34;
    sub_1CB8F1E58(v27, (uint64_t *)&v23, (uint64_t)v29);
    uint64_t result = llvm::MCContext::getOrCreateSymbol(v17, v29);
    *((void *)this + 26) = result;
    if (v33 != &v35)
    {
      free(v33);
      return *((void *)this + 26);
    }
  }
  return result;
}

llvm::raw_ostream *llvm::operator<<(llvm::raw_ostream *a1, llvm::MachineBasicBlock *a2)
{
  return a1;
}

uint64_t llvm::printMBBReference@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  a2[3] = a2;
  *a2 = &unk_1F260D508;
  a2[1] = result;
  return result;
}

void llvm::ilist_callback_traits<llvm::MachineBasicBlock>::addNodeToList(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a2 + 32);
  unsigned int v5 = (void *)v3[14];
  unint64_t v4 = v3[15];
  if ((unint64_t)v5 >= v4)
  {
    BOOL v9 = (void *)v3[13];
    uint64_t v10 = v5 - v9;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 61) {
      abort();
    }
    uint64_t v12 = v4 - (void)v9;
    if (v12 >> 2 > v11) {
      unint64_t v11 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13)
    {
      if (v13 >> 61) {
        sub_1CB833614();
      }
      uint64_t v14 = (char *)operator new(8 * v13);
    }
    else
    {
      uint64_t v14 = 0;
    }
    uint64_t v15 = &v14[8 * v10];
    *(void *)uint64_t v15 = a2;
    BOOL v6 = v15 + 8;
    if (v5 != v9)
    {
      do
      {
        uint64_t v16 = *--v5;
        *((void *)v15 - 1) = v16;
        v15 -= 8;
      }
      while (v5 != v9);
      unsigned int v5 = (void *)v3[13];
    }
    v3[13] = v15;
    v3[14] = v6;
    v3[15] = &v14[8 * v13];
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    *unsigned int v5 = a2;
    BOOL v6 = v5 + 1;
  }
  v3[14] = v6;
  *(_DWORD *)(a2 + 24) = (((unint64_t)v6 - v3[13]) >> 3) - 1;
  uint64_t v7 = a2 + 48;
  uint64_t v8 = *(void *)(a2 + 56);
  if (v8 != v7)
  {
    uint64_t v17 = v3[5];
    do
    {
      llvm::MachineInstr::addRegOperandsToUseLists(v8, v17);
      uint64_t v8 = *(void *)(v8 + 8);
    }
    while (v8 != v7);
  }
}

void llvm::ilist_callback_traits<llvm::MachineBasicBlock>::removeNodeFromList(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a2 + 32) + 104) + 8 * *(unsigned int *)(a2 + 24)) = 0;
  *(_DWORD *)(a2 + 24) = -1;
}

uint64_t llvm::ilist_traits<llvm::MachineInstr>::addNodeToList(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  *(void *)(a2 + 24) = *a1;
  uint64_t v3 = *(void *)(v2 + 32);
  uint64_t v4 = *(unsigned int *)(a2 + 40);
  if (v4)
  {
    uint64_t v6 = *(void *)(a2 + 32);
    uint64_t v7 = *(void *)(v3 + 40);
    uint64_t v8 = 32 * v4;
    do
    {
      if (!*(unsigned char *)v6)
      {
        uint64_t v9 = *(unsigned int *)(v6 + 4);
        if ((int)v9 >= 0) {
          uint64_t v10 = (uint64_t *)(*(void *)(v7 + 272) + 8 * v9);
        }
        else {
          uint64_t v10 = (uint64_t *)(*(void *)(v7 + 24) + 16 * (v9 & 0x7FFFFFFF) + 8);
        }
        uint64_t v11 = *v10;
        if (*v10)
        {
          uint64_t v12 = *(void *)(v11 + 16);
          *(void *)(v11 + 16) = v6;
          *(void *)(v6 + 16) = v12;
          if (*(unsigned char *)(v6 + 3))
          {
            *(void *)(v6 + 24) = v11;
          }
          else
          {
            *(void *)(v6 + 24) = 0;
            uint64_t v10 = (uint64_t *)(v12 + 24);
          }
        }
        else
        {
          *(void *)(v6 + 16) = v6;
          *(void *)(v6 + 24) = 0;
        }
        *uint64_t v10 = v6;
      }
      v6 += 32;
      v8 -= 32;
    }
    while (v8);
  }
  uint64_t result = *(void *)(v3 + 728);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

void llvm::ilist_traits<llvm::MachineInstr>::removeNodeFromList(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)(a2 + 24) + 32);
  if (v3)
  {
    uint64_t v4 = *(void *)(v3 + 728);
    if (v4) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 32))(v4, a2);
    }
    uint64_t v5 = *(unsigned int *)(a2 + 40);
    if (v5)
    {
      uint64_t v6 = *(void *)(a2 + 32);
      uint64_t v7 = *(void *)(v3 + 40);
      uint64_t v8 = 32 * v5;
      do
      {
        if (!*(unsigned char *)v6)
        {
          uint64_t v9 = *(unsigned int *)(v6 + 4);
          if ((v9 & 0x80000000) != 0) {
            uint64_t v10 = (uint64_t *)(*(void *)(v7 + 24) + 16 * (v9 & 0x7FFFFFFF) + 8);
          }
          else {
            uint64_t v10 = (uint64_t *)(*(void *)(v7 + 272) + 8 * v9);
          }
          uint64_t v11 = *v10;
          uint64_t v13 = *(void *)(v6 + 16);
          uint64_t v12 = *(void *)(v6 + 24);
          if (v6 != *v10) {
            uint64_t v10 = (uint64_t *)(v13 + 24);
          }
          *uint64_t v10 = v12;
          if (v12) {
            uint64_t v14 = v12;
          }
          else {
            uint64_t v14 = v11;
          }
          *(void *)(v14 + 16) = v13;
          *(void *)(v6 + 16) = 0;
          *(void *)(v6 + 24) = 0;
        }
        v6 += 32;
        v8 -= 32;
      }
      while (v8);
    }
  }
  *(void *)(a2 + 24) = 0;
}

uint64_t *llvm::ilist_traits<llvm::MachineInstr>::transferNodesFromList(uint64_t *result, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (result != a2 && a3 != a4)
  {
    uint64_t v4 = *result;
    do
    {
      *(void *)(a3 + 24) = v4;
      a3 = *(void *)(a3 + 8);
    }
    while (a3 != a4);
  }
  return result;
}

void llvm::ilist_traits<llvm::MachineInstr>::deleteNode(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)a1 + 32);
  uint64_t v4 = *(void **)(a2 + 32);
  if (v4)
  {
    uint64_t v5 = *(unsigned __int8 *)(a2 + 47);
    uint64_t v6 = (uint64_t *)(v3 + 232);
    if (*(_DWORD *)(v3 + 240) <= v5) {
      sub_1CC34BDE0(v3 + 232, v5 + 1);
    }
    uint64_t v7 = *v6;
    *uint64_t v4 = *(void *)(*v6 + 8 * v5);
    *(void *)(v7 + 8 * v5) = v4;
  }
  *(void *)a2 = *(void *)(v3 + 224);
  *(void *)(v3 + 224) = a2;
}

uint64_t llvm::MachineBasicBlock::getFirstNonPHI(llvm::MachineBasicBlock *this)
{
  uint64_t result = (uint64_t)this + 48;
  for (uint64_t i = *((void *)this + 7); i != result; uint64_t i = *(void *)(i + 8))
  {
    if (**(_WORD **)(i + 16) && **(_WORD **)(i + 16) != 69) {
      return i;
    }
  }
  return result;
}

uint64_t llvm::MachineBasicBlock::SkipPHIsAndLabels(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 32) + 16) + 104))(*(void *)(*(void *)(a1 + 32) + 16));
  uint64_t v5 = a1 + 48;
  if (v5 != a2)
  {
    uint64_t v6 = v4;
    while (1)
    {
      int v7 = **(unsigned __int16 **)(a2 + 16);
      if (**(_WORD **)(a2 + 16))
      {
        if (v7 != 69
          && (v7 - 3) >= 4
          && !(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v6 + 1144))(v6, a2))
        {
          break;
        }
      }
      if ((*(unsigned char *)a2 & 4) == 0)
      {
        while ((*(_WORD *)(a2 + 44) & 8) != 0)
          a2 = *(void *)(a2 + 8);
      }
      a2 = *(void *)(a2 + 8);
      if (a2 == v5) {
        return v5;
      }
    }
  }
  return a2;
}

uint64_t llvm::MachineBasicBlock::SkipPHIsLabelsAndDebug(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 32) + 16) + 104))(*(void *)(*(void *)(a1 + 32) + 16));
  uint64_t v7 = a1 + 48;
  if (v7 != a2)
  {
    uint64_t v8 = v6;
    while (1)
    {
      unsigned int v9 = **(unsigned __int16 **)(a2 + 16);
      BOOL v10 = v9 > 0x11 || ((1 << v9) & 0x3E079) == 0;
      if (v10
        && v9 != 69
        && (v9 != 23 || (a3 & 1) == 0)
        && !(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v8 + 1144))(v8, a2))
      {
        break;
      }
      if ((*(unsigned char *)a2 & 4) == 0)
      {
        while ((*(_WORD *)(a2 + 44) & 8) != 0)
          a2 = *(void *)(a2 + 8);
      }
      a2 = *(void *)(a2 + 8);
      if (a2 == v7) {
        return v7;
      }
    }
  }
  return a2;
}

unint64_t llvm::MachineBasicBlock::getFirstTerminator(llvm::MachineBasicBlock *this)
{
  unint64_t result = (unint64_t)this + 48;
  unint64_t v3 = *((void *)this + 7);
  if (result != v3)
  {
    unint64_t v4 = result;
    do
    {
      unint64_t v4 = *(void *)v4 & 0xFFFFFFFFFFFFFFF8;
      if (v4 && (*(unsigned char *)v4 & 4) != 0)
      {
        __int16 v5 = *(_WORD *)(v4 + 44);
      }
      else
      {
        while (1)
        {
          __int16 v5 = *(_WORD *)(v4 + 44);
          if ((v5 & 4) == 0) {
            break;
          }
          unint64_t v4 = *(void *)v4 & 0xFFFFFFFFFFFFFFF8;
        }
      }
      int v6 = v5 & 0xC;
      int v7 = v5 & 4;
      uint64_t v8 = *(unsigned __int16 **)(v4 + 16);
      uint64_t v9 = *((void *)v8 + 1);
      if (v6) {
        BOOL v10 = v7 == 0;
      }
      else {
        BOOL v10 = 0;
      }
      if (v10)
      {
        unint64_t v14 = v4;
        if ((v9 & 0x200) == 0)
        {
          while ((*(_WORD *)(v14 + 44) & 8) != 0)
          {
            unint64_t v14 = *(void *)(v14 + 8);
            if ((*(unsigned char *)(*(void *)(v14 + 16) + 9) & 2) != 0) {
              goto LABEL_12;
            }
          }
LABEL_11:
          if (*v8 - 13 > 4)
          {
            unint64_t v3 = v4;
            break;
          }
        }
      }
      else if ((v9 & 0x200) == 0)
      {
        goto LABEL_11;
      }
LABEL_12:
      ;
    }
    while (v4 != v3);
  }
  while (v3 != result)
  {
    __int16 v11 = *(_WORD *)(v3 + 44);
    uint64_t v12 = *(void *)(*(void *)(v3 + 16) + 8);
    if ((v11 & 0xC) != 0 && (v11 & 4) == 0)
    {
      unint64_t v15 = v3;
      if ((v12 & 0x200) != 0) {
        return v3;
      }
      while ((*(_WORD *)(v15 + 44) & 8) != 0)
      {
        unint64_t v15 = *(void *)(v15 + 8);
        if ((*(unsigned char *)(*(void *)(v15 + 16) + 9) & 2) != 0) {
          return v3;
        }
      }
    }
    else if ((v12 & 0x200) != 0)
    {
      return v3;
    }
    if ((v11 & 8) != 0 && (*(void *)v3 & 4) == 0)
    {
      do
        unint64_t v3 = *(void *)(v3 + 8);
      while ((*(_WORD *)(v3 + 44) & 8) != 0);
    }
    unint64_t v3 = *(void *)(v3 + 8);
  }
  return result;
}

uint64_t llvm::MachineBasicBlock::getFirstInstrTerminator(llvm::MachineBasicBlock *this)
{
  uint64_t result = (uint64_t)this + 48;
  unint64_t v3 = *((void *)this + 7);
  if (result != v3)
  {
    unint64_t v4 = result;
    do
    {
      unint64_t v4 = *(void *)v4 & 0xFFFFFFFFFFFFFFF8;
      __int16 v5 = *(unsigned __int16 **)(v4 + 16);
      uint64_t v6 = *((void *)v5 + 1);
      if ((*(_WORD *)(v4 + 44) & 0xC) != 0 && (*(_WORD *)(v4 + 44) & 4) == 0)
      {
        if ((v6 & 0x200) == 0)
        {
          unint64_t v10 = v4;
          while ((*(_WORD *)(v10 + 44) & 8) != 0)
          {
            unint64_t v10 = *(void *)(v10 + 8);
            if ((*(unsigned char *)(*(void *)(v10 + 16) + 9) & 2) != 0) {
              goto LABEL_8;
            }
          }
LABEL_10:
          if (*v5 - 13 > 4) {
            goto LABEL_11;
          }
        }
      }
      else if ((v6 & 0x200) == 0)
      {
        goto LABEL_10;
      }
LABEL_8:
      ;
    }
    while (v3 != v4);
  }
  unint64_t v4 = v3;
LABEL_11:
  while (v4 != result)
  {
    uint64_t v8 = *(void *)(*(void *)(v4 + 16) + 8);
    if ((*(_WORD *)(v4 + 44) & 0xC) != 0 && (*(_WORD *)(v4 + 44) & 4) == 0)
    {
      unint64_t v11 = v4;
      if ((v8 & 0x200) != 0) {
        return v4;
      }
      while ((*(_WORD *)(v11 + 44) & 8) != 0)
      {
        unint64_t v11 = *(void *)(v11 + 8);
        if ((*(unsigned char *)(*(void *)(v11 + 16) + 9) & 2) != 0) {
          return v4;
        }
      }
    }
    else if ((v8 & 0x200) != 0)
    {
      return v4;
    }
    unint64_t v4 = *(void *)(v4 + 8);
  }
  return result;
}

char *llvm::MachineBasicBlock::getFirstNonDebugInstr(llvm::MachineBasicBlock *this, int a2)
{
  uint64_t v2 = (char *)this + 48;
  uint64_t result = (char *)*((void *)this + 7);
  if (result != v2)
  {
    while (1)
    {
      int v4 = **((unsigned __int16 **)result + 2);
      unsigned int v5 = v4 - 13;
      int v6 = v4 == 23 ? a2 : 0;
      if (v5 >= 5 && v6 == 0) {
        break;
      }
      if ((*result & 4) == 0)
      {
        while ((*((_WORD *)result + 22) & 8) != 0)
          uint64_t result = (char *)*((void *)result + 1);
      }
      uint64_t result = (char *)*((void *)result + 1);
      if (result == v2) {
        return v2;
      }
    }
  }
  return result;
}

uint64_t llvm::MachineBasicBlock::getLastNonDebugInstr(llvm::MachineBasicBlock *this, char a2)
{
  uint64_t result = (uint64_t)this + 48;
  uint64_t v4 = *((void *)this + 7);
  if (result == v4) {
    return v4;
  }
  unint64_t v5 = result;
  while (1)
  {
    unint64_t v5 = *(void *)v5 & 0xFFFFFFFFFFFFFFF8;
    int v6 = **(unsigned __int16 **)(v5 + 16);
    if ((v6 - 13) >= 5)
    {
      char v7 = v6 == 23 ? a2 : 0;
      if ((v7 & 1) == 0 && (*(_WORD *)(v5 + 44) & 4) == 0) {
        break;
      }
    }
    if (v4 == v5) {
      return result;
    }
  }
  return v5;
}

BOOL llvm::MachineBasicBlock::hasEHPadSuccessor(llvm::MachineBasicBlock *this)
{
  uint64_t v2 = *((void *)this + 11);
  uint64_t v1 = *((void *)this + 12);
  if (v2 == v1) {
    return 0;
  }
  uint64_t v3 = v2 + 8;
  do
  {
    BOOL result = *(unsigned char *)(*(void *)(v3 - 8) + 184) != 0;
    if (*(unsigned char *)(*(void *)(v3 - 8) + 184)) {
      BOOL v5 = 1;
    }
    else {
      BOOL v5 = v3 == v1;
    }
    v3 += 8;
  }
  while (!v5);
  return result;
}

BOOL llvm::MachineBasicBlock::mayHaveInlineAsmBr(llvm::MachineBasicBlock *this)
{
  uint64_t v2 = *((void *)this + 11);
  uint64_t v1 = *((void *)this + 12);
  if (v2 == v1) {
    return 0;
  }
  uint64_t v3 = v2 + 8;
  do
  {
    BOOL result = *(unsigned char *)(*(void *)(v3 - 8) + 202) != 0;
    if (*(unsigned char *)(*(void *)(v3 - 8) + 202)) {
      BOOL v5 = 1;
    }
    else {
      BOOL v5 = v3 == v1;
    }
    v3 += 8;
  }
  while (!v5);
  return result;
}

BOOL llvm::MachineBasicBlock::isLegalToHoistInto(llvm::MachineBasicBlock *this)
{
  unint64_t v1 = *((void *)this + 6) & 0xFFFFFFFFFFFFFFF8;
  if ((llvm::MachineBasicBlock *)((char *)this + 48) != (llvm::MachineBasicBlock *)v1)
  {
    if (v1 && (*(unsigned char *)v1 & 4) != 0)
    {
      __int16 v2 = *(_WORD *)(v1 + 44);
    }
    else
    {
      while (1)
      {
        __int16 v2 = *(_WORD *)(v1 + 44);
        if ((v2 & 4) == 0) {
          break;
        }
        unint64_t v1 = *(void *)v1 & 0xFFFFFFFFFFFFFFF8;
      }
    }
    int v3 = v2 & 0xC;
    int v4 = v2 & 4;
    uint64_t v5 = *(void *)(*(void *)(v1 + 16) + 8);
    if (v3) {
      BOOL v6 = v4 == 0;
    }
    else {
      BOOL v6 = 0;
    }
    if (!v6)
    {
      if ((v5 & 0x20) == 0) {
        goto LABEL_12;
      }
      return 0;
    }
    if ((v5 & 0x20) != 0) {
      return 0;
    }
    while ((*(_WORD *)(v1 + 44) & 8) != 0)
    {
      BOOL v11 = 0;
      unint64_t v1 = *(void *)(v1 + 8);
      if ((*(unsigned char *)(*(void *)(v1 + 16) + 8) & 0x20) != 0) {
        return v11;
      }
    }
  }
LABEL_12:
  uint64_t v7 = *((void *)this + 11);
  uint64_t v8 = *((void *)this + 12);
  if (v7 != v8)
  {
    uint64_t v9 = *((void *)this + 11);
    while (!*(unsigned char *)(*(void *)v9 + 184))
    {
      v9 += 8;
      if (v9 == v8)
      {
        uint64_t v10 = v7 + 8;
        do
        {
          BOOL v11 = *(unsigned char *)(*(void *)(v10 - 8) + 202) == 0;
          if (*(unsigned char *)(*(void *)(v10 - 8) + 202)) {
            BOOL v12 = 1;
          }
          else {
            BOOL v12 = v10 == v8;
          }
          v10 += 8;
        }
        while (!v12);
        return v11;
      }
    }
    return 0;
  }
  return 1;
}

void llvm::MachineBasicBlock::print(llvm::MachineBasicBlock *this, llvm::raw_ostream *a2, llvm::SlotTracker **a3, const llvm::SlotIndexes *a4, const llvm::TargetRegisterInfo *a5)
{
  uint64_t v131 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *((void *)this + 4);
  if (!v6)
  {
    uint64_t v7 = (void *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v7 > 0x3FuLL)
    {
      qmemcpy(v7, "Can't print out MachineBasicBlock because parent MachineFunction", 64);
      uint64_t v8 = *((void *)a2 + 4) + 64;
      *((void *)a2 + 4) = v8;
    }
    else
    {
      llvm::raw_ostream::write(a2, "Can't print out MachineBasicBlock because parent MachineFunction", 0x40uLL);
      uint64_t v8 = *((void *)a2 + 4);
    }
    if ((unint64_t)(*((void *)a2 + 3) - v8) > 8)
    {
      *(unsigned char *)(v8 + 8) = 10;
      *(void *)uint64_t v8 = *(void *)" is null\n";
      *((void *)a2 + 4) += 9;
    }
    else
    {
      llvm::raw_ostream::write(a2, " is null\n", 9uLL);
    }
    return;
  }
  if (a4 && byte_1EBCCD518)
  {
    unsigned int v127 = *(void (***)(void **))(*((void *)a4 + 49) + 16 * *((unsigned int *)this + 6));
    llvm::SlotIndex::print((llvm::SlotIndex *)&v127, a2);
    uint64_t v13 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v13 >= *((void *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, 9);
    }
    else
    {
      *((void *)a2 + 4) = v13 + 1;
      *uint64_t v13 = 9;
    }
  }
  llvm::MachineBasicBlock::printName(this, a2, 3, a3);
  unint64_t v14 = (_WORD *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v14 > 1uLL)
  {
    *unint64_t v14 = 2618;
    *((void *)a2 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(a2, ":\n", 2uLL);
  }
  uint64_t v122 = (*(uint64_t (**)(void))(**(void **)(v6 + 16) + 176))(*(void *)(v6 + 16));
  uint64_t v15 = *(void *)(v6 + 40);
  uint64_t v16 = (*(uint64_t (**)(void))(**(void **)(*((void *)this + 4) + 16) + 104))(*(void *)(*((void *)this + 4) + 16));
  uint64_t v17 = (const llvm::TargetInstrInfo *)v16;
  if (*((void *)this + 8) == *((void *)this + 9)) {
    int v18 = 0;
  }
  else {
    int v18 = (int)a5;
  }
  uint64_t v123 = (const llvm::TargetInstrInfo *)v16;
  uint64_t v121 = v15;
  if (v18 == 1)
  {
    if (a4)
    {
      __int16 v19 = (unsigned char *)*((void *)a2 + 4);
      if ((unint64_t)v19 >= *((void *)a2 + 3))
      {
        llvm::raw_ostream::write(a2, 9);
      }
      else
      {
        *((void *)a2 + 4) = v19 + 1;
        *__int16 v19 = 9;
      }
    }
    long long v20 = (_OWORD *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v20 > 0xFuLL)
    {
      *long long v20 = *(_OWORD *)"; predecessors: ";
      *((void *)a2 + 4) += 16;
    }
    else
    {
      llvm::raw_ostream::write(a2, "; predecessors: ", 0x10uLL);
    }
    int v21 = (llvm::MachineBasicBlock **)*((void *)this + 8);
    __int16 v22 = (llvm::MachineBasicBlock **)*((void *)this + 9);
    if (v21 != v22)
    {
      char v23 = 0;
      do
      {
        uint64_t v24 = *v21;
        if (v23) {
          size_t v25 = 2;
        }
        else {
          size_t v25 = 0;
        }
        __int16 v26 = (_WORD *)*((void *)a2 + 4);
        if (v25 <= *((void *)a2 + 3) - (void)v26)
        {
          if (v23)
          {
            *__int16 v26 = 8236;
            *((void *)a2 + 4) += 2;
          }
        }
        else
        {
          if (v23) {
            uint64_t v27 = ", ";
          }
          else {
            uint64_t v27 = 0;
          }
          llvm::raw_ostream::write(a2, v27, v25);
        }
        uint64_t v130 = (void **)&v127;
        unsigned int v127 = (void (**)(void **))&unk_1F260D508;
        v128 = (const char *)v24;
        llvm::MachineBasicBlock::printAsOperand(v24, a2);
        if (v130 == (void **)&v127)
        {
          v127[4]((void **)&v127);
        }
        else if (v130)
        {
          (*((void (**)(void))*v130 + 5))();
        }
        ++v21;
        char v23 = 1;
      }
      while (v21 != v22);
    }
    __int16 v28 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v28 >= *((void *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, 10);
    }
    else
    {
      *((void *)a2 + 4) = v28 + 1;
      *__int16 v28 = 10;
    }
    uint64_t v17 = v123;
    uint64_t v15 = v121;
  }
  if (*((void *)this + 11) != *((void *)this + 12))
  {
    if (a4)
    {
      unint64_t v29 = (unsigned char *)*((void *)a2 + 4);
      if ((unint64_t)v29 >= *((void *)a2 + 3))
      {
        llvm::raw_ostream::write(a2, 9);
      }
      else
      {
        *((void *)a2 + 4) = v29 + 1;
        unsigned char *v29 = 9;
      }
    }
    llvm::raw_ostream::write(a2, "                                                                                ", 2uLL);
    uint64_t v30 = *((void *)a2 + 4);
    if ((unint64_t)(*((void *)a2 + 3) - v30) > 0xB)
    {
      *(_DWORD *)(v30 + 8) = 540701554;
      *(void *)uint64_t v30 = *(void *)"successors: ";
      *((void *)a2 + 4) += 12;
    }
    else
    {
      llvm::raw_ostream::write(a2, "successors: ", 0xCuLL);
    }
    uint64_t v31 = (llvm::MachineBasicBlock **)*((void *)this + 11);
    char v32 = (llvm::MachineBasicBlock **)*((void *)this + 12);
    if (v31 != v32)
    {
      char v33 = 0;
      do
      {
        if (v33) {
          size_t v34 = 2;
        }
        else {
          size_t v34 = 0;
        }
        uint64_t v35 = (_WORD *)*((void *)a2 + 4);
        if (v34 <= *((void *)a2 + 3) - (void)v35)
        {
          if (v33)
          {
            _WORD *v35 = 8236;
            *((void *)a2 + 4) += 2;
          }
        }
        else
        {
          if (v33) {
            unsigned int v36 = ", ";
          }
          else {
            unsigned int v36 = 0;
          }
          llvm::raw_ostream::write(a2, v36, v34);
        }
        int v37 = *v31;
        uint64_t v130 = (void **)&v127;
        unsigned int v127 = (void (**)(void **))&unk_1F260D508;
        v128 = (const char *)v37;
        llvm::MachineBasicBlock::printAsOperand(v37, a2);
        if (v130 == (void **)&v127)
        {
          v127[4]((void **)&v127);
        }
        else if (v130)
        {
          (*((void (**)(void))*v130 + 5))();
        }
        if (*((void *)this + 14) != *((void *)this + 15))
        {
          uint64_t v38 = (unsigned char *)*((void *)a2 + 4);
          if ((unint64_t)v38 >= *((void *)a2 + 3))
          {
            llvm::raw_ostream::write(a2, 40);
          }
          else
          {
            *((void *)a2 + 4) = v38 + 1;
            unsigned char *v38 = 40;
          }
          uint64_t v39 = (char *)*((void *)this + 14);
          int v40 = (char *)*((void *)this + 15);
          uint64_t v41 = *((void *)this + 11);
          if (v39 == v40)
          {
            unint64_t v51 = *((void *)this + 12) - v41;
            BOOL v107 = (v51 >> 3) == 0x80000000;
            unsigned int v52 = ((v51 >> 4) | 0x80000000) / (v51 >> 3);
            if (v107) {
              unsigned int v42 = 1;
            }
            else {
              unsigned int v42 = v52;
            }
          }
          else
          {
            unsigned int v42 = *(_DWORD *)&v39[((uint64_t)v31 - v41) >> 1];
            if (v42 == -1)
            {
              int v43 = 0;
              unsigned int v44 = 0;
              uint64_t v45 = (unsigned int *)*((void *)this + 14);
              do
              {
                unsigned int v47 = *v45++;
                unsigned int v46 = v47;
                unsigned int v48 = v47 + v44;
                if (v47 + (unint64_t)v44 <= 0x80000000) {
                  unsigned int v49 = v48;
                }
                else {
                  unsigned int v49 = 0x80000000;
                }
                if (v46 != -1)
                {
                  unsigned int v44 = v49;
                  ++v43;
                }
              }
              while (v45 != (unsigned int *)v40);
              unsigned int v42 = (0x80000000 - v44) / (((unint64_t)(v40 - v39) >> 2) - v43);
            }
          }
          unsigned int v127 = (void (**)(void **))&unk_1F25FED10;
          v128 = "0x%08x";
          uint64_t v129 = v42;
          llvm::raw_ostream::operator<<(a2, (uint64_t)&v127);
          unint64_t v50 = (unsigned char *)*((void *)a2 + 4);
          if ((unint64_t)v50 >= *((void *)a2 + 3))
          {
            llvm::raw_ostream::write(a2, 41);
          }
          else
          {
            *((void *)a2 + 4) = v50 + 1;
            *unint64_t v50 = 41;
          }
        }
        ++v31;
        char v33 = 1;
      }
      while (v31 != v32);
    }
    if (*((void *)this + 14) != *((void *)this + 15) && (a5 & 1) != 0)
    {
      int64_t v53 = (_WORD *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v53 > 1uLL)
      {
        *int64_t v53 = 8251;
        *((void *)a2 + 4) += 2;
      }
      else
      {
        llvm::raw_ostream::write(a2, "; ", 2uLL);
      }
      uint64_t v54 = (llvm::MachineBasicBlock **)*((void *)this + 11);
      unint64_t v55 = (llvm::MachineBasicBlock **)*((void *)this + 12);
      if (v54 != v55)
      {
        char v56 = 0;
        do
        {
          BOOL v57 = (char *)*((void *)this + 14);
          uint64_t v58 = (char *)*((void *)this + 15);
          uint64_t v59 = *((void *)this + 11);
          if (v57 == v58)
          {
            unint64_t v74 = *((void *)this + 12) - v59;
            BOOL v107 = (v74 >> 3) == 0x80000000;
            unsigned int v75 = ((v74 >> 4) | 0x80000000) / (v74 >> 3);
            if (v107) {
              unsigned int v60 = 1;
            }
            else {
              unsigned int v60 = v75;
            }
          }
          else
          {
            unsigned int v60 = *(_DWORD *)&v57[((uint64_t)v54 - v59) >> 1];
            if (v60 == -1)
            {
              int v61 = 0;
              unsigned int v62 = 0;
              uint64_t v63 = (unsigned int *)*((void *)this + 14);
              do
              {
                unsigned int v65 = *v63++;
                unsigned int v64 = v65;
                unsigned int v66 = v65 + v62;
                if (v65 + (unint64_t)v62 <= 0x80000000) {
                  unsigned int v67 = v66;
                }
                else {
                  unsigned int v67 = 0x80000000;
                }
                if (v64 != -1)
                {
                  unsigned int v62 = v67;
                  ++v61;
                }
              }
              while (v63 != (unsigned int *)v58);
              unsigned int v60 = (0x80000000 - v62) / (((unint64_t)(v58 - v57) >> 2) - v61);
            }
          }
          if (v56) {
            size_t v68 = 2;
          }
          else {
            size_t v68 = 0;
          }
          int v69 = (_WORD *)*((void *)a2 + 4);
          if (v68 <= *((void *)a2 + 3) - (void)v69)
          {
            if (v56)
            {
              *int v69 = 8236;
              *((void *)a2 + 4) += 2;
            }
          }
          else
          {
            if (v56) {
              int v70 = ", ";
            }
            else {
              int v70 = 0;
            }
            llvm::raw_ostream::write(a2, v70, v68);
          }
          uint64_t v71 = *v54;
          uint64_t v130 = (void **)&v127;
          unsigned int v127 = (void (**)(void **))&unk_1F260D508;
          v128 = (const char *)v71;
          llvm::MachineBasicBlock::printAsOperand(v71, a2);
          uint64_t v72 = (unsigned char *)*((void *)a2 + 4);
          if ((unint64_t)v72 >= *((void *)a2 + 3))
          {
            llvm::raw_ostream::write(a2, 40);
          }
          else
          {
            *((void *)a2 + 4) = v72 + 1;
            *uint64_t v72 = 40;
          }
          unint64_t v124 = &unk_1F25F6490;
          BOOL v125 = "%.2f%%";
          double v126 = rint((double)v60 * 4.65661287e-10 * 100.0 * 100.0) / 100.0;
          llvm::raw_ostream::operator<<(a2, (uint64_t)&v124);
          uint64_t v73 = (unsigned char *)*((void *)a2 + 4);
          if ((unint64_t)v73 >= *((void *)a2 + 3))
          {
            llvm::raw_ostream::write(a2, 41);
          }
          else
          {
            *((void *)a2 + 4) = v73 + 1;
            *uint64_t v73 = 41;
          }
          uint64_t v17 = v123;
          if (v130 == (void **)&v127)
          {
            v127[4]((void **)&v127);
          }
          else if (v130)
          {
            (*((void (**)(void))*v130 + 5))();
          }
          ++v54;
          char v56 = 1;
        }
        while (v54 != v55);
      }
    }
    unint64_t v76 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v76 >= *((void *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, 10);
    }
    else
    {
      *((void *)a2 + 4) = v76 + 1;
      *unint64_t v76 = 10;
    }
    int v18 = 1;
    uint64_t v15 = v121;
  }
  if (*((void *)this + 19) != *((void *)this + 20) && (**(unsigned char **)(*(void *)v15 + 360) & 4) != 0)
  {
    if (a4)
    {
      unint64_t v77 = (unsigned char *)*((void *)a2 + 4);
      if ((unint64_t)v77 >= *((void *)a2 + 3))
      {
        llvm::raw_ostream::write(a2, 9);
      }
      else
      {
        *((void *)a2 + 4) = v77 + 1;
        *unint64_t v77 = 9;
      }
    }
    llvm::raw_ostream::write(a2, "                                                                                ", 2uLL);
    uint64_t v78 = *((void *)a2 + 4);
    if ((unint64_t)(*((void *)a2 + 3) - v78) > 8)
    {
      *(unsigned char *)(v78 + 8) = 32;
      *(void *)uint64_t v78 = *(void *)"liveins: ";
      *((void *)a2 + 4) += 9;
    }
    else
    {
      llvm::raw_ostream::write(a2, "liveins: ", 9uLL);
    }
    char v79 = (unsigned __int16 *)*((void *)this + 19);
    uint64_t v80 = (unsigned __int16 *)*((void *)this + 20);
    if (v79 != v80)
    {
      char v81 = 0;
      unint64_t v82 = (void (*)(llvm::raw_ostream *, llvm::raw_ostream *))off_1F2615510;
      do
      {
        if (v81) {
          size_t v83 = 2;
        }
        else {
          size_t v83 = 0;
        }
        unsigned int v84 = (_WORD *)*((void *)a2 + 4);
        if (v83 <= *((void *)a2 + 3) - (void)v84)
        {
          if (v81)
          {
            *unsigned int v84 = 8236;
            *((void *)a2 + 4) += 2;
          }
        }
        else
        {
          if (v81) {
            unint64_t v85 = ", ";
          }
          else {
            unint64_t v85 = 0;
          }
          llvm::raw_ostream::write(a2, v85, v83);
        }
        int v86 = *v79;
        uint64_t v87 = operator new(0x28uLL);
        *(void *)uint64_t v87 = &unk_1F26154E0;
        v87[2] = v86;
        *((void *)v87 + 2) = v122;
        v87[6] = 0;
        *((void *)v87 + 4) = 0;
        uint64_t v130 = (void **)v87;
        v82((llvm::raw_ostream *)v87, a2);
        if (v130 == (void **)&v127)
        {
          v127[4]((void **)&v127);
          uint64_t v17 = v123;
        }
        else
        {
          uint64_t v17 = v123;
          if (v130) {
            (*((void (**)(void))*v130 + 5))();
          }
        }
        if (*((void *)v79 + 1) != -1)
        {
          uint64_t v88 = *((void *)a2 + 4);
          if ((unint64_t)(*((void *)a2 + 3) - v88) > 2)
          {
            *(unsigned char *)(v88 + 2) = 120;
            *(_WORD *)uint64_t v88 = 12346;
            *((void *)a2 + 4) += 3;
          }
          else
          {
            llvm::raw_ostream::write(a2, ":0x", 3uLL);
          }
          unsigned int v89 = (const char *)*((void *)v79 + 1);
          uint64_t v130 = (void **)&v127;
          unsigned int v127 = (void (**)(void **))&unk_1F260C990;
          v128 = v89;
          unint64_t v124 = &unk_1F25FF808;
          BOOL v125 = "%016llX";
          double v126 = *(double *)&v89;
          llvm::raw_ostream::operator<<(a2, (uint64_t)&v124);
          if (v130 == (void **)&v127)
          {
            v127[4]((void **)&v127);
          }
          else if (v130)
          {
            (*((void (**)(void))*v130 + 5))();
          }
        }
        v79 += 8;
        char v81 = 1;
      }
      while (v79 != v80);
    }
    goto LABEL_174;
  }
  if (v18)
  {
LABEL_174:
    unint64_t v90 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v90 >= *((void *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, 10);
    }
    else
    {
      *((void *)a2 + 4) = v90 + 1;
      *unint64_t v90 = 10;
    }
  }
  unint64_t v91 = *((void *)this + 7);
  if ((llvm::MachineBasicBlock *)v91 == (llvm::MachineBasicBlock *)((char *)this + 48)) {
    goto LABEL_228;
  }
  char v92 = 0;
  do
  {
    if (!a4 || !byte_1EBCCD518) {
      goto LABEL_204;
    }
    uint64_t v93 = *((unsigned int *)a4 + 96);
    if (v93)
    {
      uint64_t v94 = *((void *)a4 + 46);
      unsigned int v95 = v93 - 1;
      unsigned int v96 = (v93 - 1) & ((v91 >> 4) ^ (v91 >> 9));
      uint64_t v97 = *(void *)(v94 + 16 * v96);
      if (v91 == v97)
      {
LABEL_186:
        __int16 v100 = *(_WORD *)(v91 + 44);
        unint64_t v101 = v91;
        if ((v100 & 4) != 0)
        {
          do
            unint64_t v101 = *(void *)v101 & 0xFFFFFFFFFFFFFFF8;
          while ((*(_WORD *)(v101 + 44) & 4) != 0);
        }
        unint64_t v102 = v91;
        if ((v100 & 8) != 0)
        {
          do
            unint64_t v102 = *(void *)(v102 + 8);
          while ((*(_WORD *)(v102 + 44) & 8) != 0);
        }
        unint64_t v103 = *(void *)(v102 + 8);
        if (v101 != v103)
        {
          while (1)
          {
            unsigned int v104 = **(unsigned __int16 **)(v101 + 16);
            BOOL v105 = v104 > 0x17;
            int v106 = (1 << v104) & 0x83E000;
            BOOL v107 = v105 || v106 == 0;
            if (v107) {
              break;
            }
            unint64_t v101 = *(void *)(v101 + 8);
            if (v101 == v103)
            {
              unint64_t v101 = v103;
              break;
            }
          }
        }
        LODWORD(v108) = ((v101 >> 4) ^ (v101 >> 9)) & v95;
        uint64_t v109 = (uint64_t *)(v94 + 16 * v108);
        uint64_t v110 = *v109;
        if (v101 != *v109)
        {
          int v111 = 1;
          while (v110 != -4096)
          {
            int v112 = v108 + v111++;
            uint64_t v108 = v112 & v95;
            uint64_t v110 = *(void *)(v94 + 16 * v108);
            if (v101 == v110)
            {
              uint64_t v109 = (uint64_t *)(v94 + 16 * v108);
              goto LABEL_201;
            }
          }
          uint64_t v109 = (uint64_t *)(v94 + 16 * v93);
        }
LABEL_201:
        unsigned int v127 = (void (**)(void **))v109[1];
        llvm::SlotIndex::print((llvm::SlotIndex *)&v127, a2);
      }
      else
      {
        int v98 = 1;
        while (v97 != -4096)
        {
          unsigned int v99 = v96 + v98++;
          unsigned int v96 = v99 & v95;
          uint64_t v97 = *(void *)(v94 + 16 * v96);
          if (v91 == v97) {
            goto LABEL_186;
          }
        }
      }
    }
    unint64_t v113 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v113 < *((void *)a2 + 3))
    {
      *((void *)a2 + 4) = v113 + 1;
      *unint64_t v113 = 9;
LABEL_204:
      if ((v92 & 1) == 0) {
        goto LABEL_210;
      }
      goto LABEL_205;
    }
    llvm::raw_ostream::write(a2, 9);
    if ((v92 & 1) == 0) {
      goto LABEL_210;
    }
LABEL_205:
    if ((*(_WORD *)(v91 + 44) & 4) != 0)
    {
      llvm::raw_ostream::write(a2, "                                                                                ", 4uLL);
      llvm::MachineInstr::print((llvm::MachineInstr *)v91, a2, (llvm::ModuleSlotTracker *)a3, a5, 0, 0, 0, v17);
      goto LABEL_213;
    }
    llvm::raw_ostream::write(a2, "                                                                                ", 2uLL);
    size_t v114 = (_WORD *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v114 > 1uLL)
    {
      *size_t v114 = 2685;
      *((void *)a2 + 4) += 2;
    }
    else
    {
      llvm::raw_ostream::write(a2, "}\n", 2uLL);
    }
LABEL_210:
    llvm::raw_ostream::write(a2, "                                                                                ", 2uLL);
    llvm::MachineInstr::print((llvm::MachineInstr *)v91, a2, (llvm::ModuleSlotTracker *)a3, a5, 0, 0, 0, v17);
    char v92 = 0;
    if ((*(_WORD *)(v91 + 44) & 8) == 0) {
      goto LABEL_214;
    }
    char v115 = (_WORD *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v115 > 1uLL)
    {
      *char v115 = 31520;
      *((void *)a2 + 4) += 2;
    }
    else
    {
      llvm::raw_ostream::write(a2, " {", 2uLL);
    }
LABEL_213:
    char v92 = 1;
LABEL_214:
    unint64_t v116 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v116 >= *((void *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, 10);
    }
    else
    {
      *((void *)a2 + 4) = v116 + 1;
      *unint64_t v116 = 10;
    }
    unint64_t v91 = *(void *)(v91 + 8);
  }
  while ((llvm::MachineBasicBlock *)v91 != (llvm::MachineBasicBlock *)((char *)this + 48));
  if (v92)
  {
    llvm::raw_ostream::write(a2, "                                                                                ", 2uLL);
    uint64_t v117 = (_WORD *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v117 > 1uLL)
    {
      *uint64_t v117 = 2685;
      *((void *)a2 + 4) += 2;
    }
    else
    {
      llvm::raw_ostream::write(a2, "}\n", 2uLL);
    }
  }
LABEL_228:
  if (*((unsigned char *)this + 144) && a5)
  {
    if (a4)
    {
      unint64_t v118 = (unsigned char *)*((void *)a2 + 4);
      if ((unint64_t)v118 >= *((void *)a2 + 3))
      {
        llvm::raw_ostream::write(a2, 9);
      }
      else
      {
        *((void *)a2 + 4) = v118 + 1;
        *unint64_t v118 = 9;
      }
    }
    llvm::raw_ostream::write(a2, "                                                                                ", 2uLL);
    uint64_t v119 = (void *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v119 > 0x21uLL)
    {
      qmemcpy(v119, "; Irreducible loop header weight: ", 34);
      *((void *)a2 + 4) += 34;
    }
    else
    {
      llvm::raw_ostream::write(a2, "; Irreducible loop header weight: ", 0x22uLL);
    }
    sub_1CD098D14(a2, *((void *)this + 17), 0, 0, 0);
    long long v120 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v120 >= *((void *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, 10);
    }
    else
    {
      *((void *)a2 + 4) = v120 + 1;
      *long long v120 = 10;
    }
  }
}

uint64_t llvm::MachineBasicBlock::getSuccProbability(void *a1, uint64_t a2)
{
  __int16 v2 = (char *)a1[14];
  int v3 = (char *)a1[15];
  if (v2 == v3)
  {
    unint64_t v12 = a1[12] - a1[11];
    BOOL v13 = (v12 >> 3) == 0x80000000;
    unsigned int v14 = ((v12 >> 4) | 0x80000000) / (v12 >> 3);
    if (v13) {
      return 1;
    }
    else {
      return v14;
    }
  }
  else
  {
    uint64_t result = *(unsigned int *)&v2[(a2 - a1[11]) >> 1];
    if (result == -1)
    {
      int v5 = 0;
      unsigned int v6 = 0;
      uint64_t v7 = v2;
      do
      {
        unsigned int v9 = *(_DWORD *)v7;
        v7 += 4;
        unsigned int v8 = v9;
        unsigned int v10 = v9 + v6;
        if (v9 + (unint64_t)v6 <= 0x80000000) {
          unsigned int v11 = v10;
        }
        else {
          unsigned int v11 = 0x80000000;
        }
        if (v8 != -1)
        {
          unsigned int v6 = v11;
          ++v5;
        }
      }
      while (v7 != v3);
      return (0x80000000 - v6) / (((unint64_t)(v3 - v2) >> 2) - v5);
    }
  }
  return result;
}

void *llvm::MachineBasicBlock::removeLiveIn(void *result, int a2, uint64_t a3)
{
  int v4 = (char *)result[19];
  int v3 = (char *)result[20];
  if (v4 != v3)
  {
    int v5 = result;
    uint64_t v6 = 0;
    while (*(unsigned __int16 *)&v4[v6] != a2)
    {
      v6 += 16;
      if (&v4[v6] == v3) {
        return result;
      }
    }
    uint64_t v7 = &v4[v6];
    uint64_t v8 = *(void *)&v4[v6 + 8] & ~a3;
    *((void *)v7 + 1) = v8;
    if (!v8)
    {
      int64_t v9 = v3 - (v7 + 16);
      if (v3 != v7 + 16) {
        uint64_t result = memmove(v7, v7 + 16, v3 - (v7 + 16));
      }
      v5[20] = &v7[v9];
    }
  }
  return result;
}

char *llvm::MachineBasicBlock::removeLiveIn(uint64_t a1, char *__dst)
{
  int v4 = __dst + 16;
  int v5 = *(char **)(a1 + 160);
  int64_t v6 = v5 - v4;
  if (v5 != v4) {
    memmove(__dst, v4, v5 - v4);
  }
  *(void *)(a1 + 160) = &__dst[v6];
  return __dst;
}

BOOL llvm::MachineBasicBlock::isLiveIn(uint64_t a1, int a2, uint64_t a3)
{
  for (uint64_t i = *(unsigned __int16 **)(a1 + 152); ; i += 8)
  {
    if (i == *(unsigned __int16 **)(a1 + 160)) {
      return 0;
    }
    if (*i == a2) {
      break;
    }
  }
  return (*((void *)i + 1) & a3) != 0;
}

void llvm::MachineBasicBlock::sortUniqueLiveIns(llvm::MachineBasicBlock *this)
{
  __int16 v2 = (unsigned __int16 *)*((void *)this + 19);
  int v3 = (unsigned __int16 *)*((void *)this + 20);
  unint64_t v4 = 126 - 2 * __clz(((char *)v3 - (char *)v2) >> 4);
  if (v3 == v2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = v4;
  }
  sub_1CC31AF28(v2, v3, v5, 1);
  uint64_t v7 = (unsigned __int16 *)*((void *)this + 19);
  int64_t v6 = (unsigned __int16 *)*((void *)this + 20);
  if (v7 == v6)
  {
    uint64_t v8 = *((void *)this + 19);
  }
  else
  {
    uint64_t v8 = *((void *)this + 19);
    while (2)
    {
      int v9 = *v7;
      for (uint64_t i = *((void *)v7 + 1); ; i |= *((void *)v7 + 1))
      {
        v7 += 8;
        if (v7 == v6)
        {
          *(_WORD *)uint64_t v8 = v9;
          *(void *)(v8 + 8) = i;
          v8 += 16;
          goto LABEL_12;
        }
        if (v9 != *v7) {
          break;
        }
      }
      *(_WORD *)uint64_t v8 = v9;
      *(void *)(v8 + 8) = i;
      v8 += 16;
      if (v7 != v6) {
        continue;
      }
      break;
    }
  }
LABEL_12:
  if ((unsigned __int16 *)v8 != v6) {
    *((void *)this + 20) = v8;
  }
}

BOOL llvm::MachineBasicBlock::isLayoutSuccessor(llvm::MachineBasicBlock *this, const llvm::MachineBasicBlock *a2)
{
  return *((void *)this + 1) == (void)a2;
}

BOOL llvm::MachineBasicBlock::isSuccessor(llvm::MachineBasicBlock *this, const llvm::MachineBasicBlock *a2)
{
  __int16 v2 = (const llvm::MachineBasicBlock **)*((void *)this + 11);
  int v3 = (const llvm::MachineBasicBlock **)*((void *)this + 12);
  if (v2 != v3)
  {
    while (*v2 != a2)
    {
      if (++v2 == v3)
      {
        __int16 v2 = (const llvm::MachineBasicBlock **)*((void *)this + 12);
        return v2 != v3;
      }
    }
  }
  return v2 != v3;
}

void llvm::MachineBasicBlock::addSuccessor(void *a1, void *a2, int a3)
{
  int64_t v6 = (char *)a1[14];
  uint64_t v7 = (char *)a1[15];
  if (v6 != v7 || (uint64_t v15 = (void *)a1[12], (void *)a1[11] == v15))
  {
    unint64_t v8 = a1[16];
    if ((unint64_t)v7 >= v8)
    {
      uint64_t v10 = (v7 - v6) >> 2;
      unint64_t v11 = v10 + 1;
      if ((unint64_t)(v10 + 1) >> 62) {
        goto LABEL_56;
      }
      uint64_t v12 = v8 - (void)v6;
      if (v12 >> 1 > v11) {
        unint64_t v11 = v12 >> 1;
      }
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v11;
      }
      if (v13)
      {
        if (v13 >> 62) {
          goto LABEL_57;
        }
        unsigned int v14 = (char *)operator new(4 * v13);
      }
      else
      {
        unsigned int v14 = 0;
      }
      uint64_t v16 = &v14[4 * v10];
      *(_DWORD *)uint64_t v16 = a3;
      for (uint64_t i = v16 + 4; v7 != v6; v16 -= 4)
      {
        int v17 = *((_DWORD *)v7 - 1);
        v7 -= 4;
        *((_DWORD *)v16 - 1) = v17;
      }
      a1[14] = v16;
      a1[15] = i;
      a1[16] = &v14[4 * v13];
      if (v6) {
        operator delete(v6);
      }
    }
    else
    {
      *(_DWORD *)uint64_t v7 = a3;
      uint64_t i = v7 + 4;
    }
    a1[15] = i;
    uint64_t v15 = (void *)a1[12];
  }
  unint64_t v18 = a1[13];
  if ((unint64_t)v15 >= v18)
  {
    long long v20 = (void *)a1[11];
    uint64_t v21 = v15 - v20;
    unint64_t v22 = v21 + 1;
    if ((unint64_t)(v21 + 1) >> 61) {
      goto LABEL_56;
    }
    uint64_t v23 = v18 - (void)v20;
    if (v23 >> 2 > v22) {
      unint64_t v22 = v23 >> 2;
    }
    if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v24 = v22;
    }
    if (v24)
    {
      if (v24 >> 61) {
        goto LABEL_57;
      }
      size_t v25 = (char *)operator new(8 * v24);
    }
    else
    {
      size_t v25 = 0;
    }
    __int16 v26 = &v25[8 * v21];
    *(void *)__int16 v26 = a2;
    __int16 v19 = v26 + 8;
    if (v15 != v20)
    {
      do
      {
        uint64_t v27 = *--v15;
        *((void *)v26 - 1) = v27;
        v26 -= 8;
      }
      while (v15 != v20);
      uint64_t v15 = (void *)a1[11];
    }
    a1[11] = v26;
    a1[12] = v19;
    a1[13] = &v25[8 * v24];
    if (v15) {
      operator delete(v15);
    }
  }
  else
  {
    void *v15 = a2;
    __int16 v19 = v15 + 1;
  }
  a1[12] = v19;
  unint64_t v29 = (void *)a2[9];
  unint64_t v28 = a2[10];
  if ((unint64_t)v29 < v28)
  {
    void *v29 = a1;
    uint64_t v30 = v29 + 1;
    goto LABEL_55;
  }
  uint64_t v31 = (void *)a2[8];
  uint64_t v32 = v29 - v31;
  unint64_t v33 = v32 + 1;
  if ((unint64_t)(v32 + 1) >> 61) {
LABEL_56:
  }
    abort();
  uint64_t v34 = v28 - (void)v31;
  if (v34 >> 2 > v33) {
    unint64_t v33 = v34 >> 2;
  }
  if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v35 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v35 = v33;
  }
  if (!v35)
  {
    unsigned int v36 = 0;
    goto LABEL_50;
  }
  if (v35 >> 61) {
LABEL_57:
  }
    sub_1CB833614();
  unsigned int v36 = (char *)operator new(8 * v35);
LABEL_50:
  int v37 = &v36[8 * v32];
  *(void *)int v37 = a1;
  uint64_t v30 = v37 + 8;
  if (v29 != v31)
  {
    do
    {
      uint64_t v38 = *--v29;
      *((void *)v37 - 1) = v38;
      v37 -= 8;
    }
    while (v29 != v31);
    unint64_t v29 = (void *)a2[8];
  }
  a2[8] = v37;
  a2[9] = v30;
  a2[10] = &v36[8 * v35];
  if (v29) {
    operator delete(v29);
  }
LABEL_55:
  a2[9] = v30;
}

void llvm::MachineBasicBlock::addPredecessor(llvm::MachineBasicBlock *this, llvm::MachineBasicBlock *a2)
{
  uint64_t v5 = (void *)*((void *)this + 9);
  unint64_t v4 = *((void *)this + 10);
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (void *)*((void *)this + 8);
    uint64_t v8 = v5 - v7;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61) {
      abort();
    }
    uint64_t v10 = v4 - (void)v7;
    if (v10 >> 2 > v9) {
      unint64_t v9 = v10 >> 2;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 >> 61) {
        sub_1CB833614();
      }
      uint64_t v12 = (char *)operator new(8 * v11);
    }
    else
    {
      uint64_t v12 = 0;
    }
    unint64_t v13 = &v12[8 * v8];
    *(void *)unint64_t v13 = a2;
    int64_t v6 = v13 + 8;
    if (v5 != v7)
    {
      do
      {
        uint64_t v14 = *--v5;
        *((void *)v13 - 1) = v14;
        v13 -= 8;
      }
      while (v5 != v7);
      uint64_t v5 = (void *)*((void *)this + 8);
    }
    *((void *)this + 8) = v13;
    *((void *)this + 9) = v6;
    *((void *)this + 10) = &v12[8 * v11];
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    *uint64_t v5 = a2;
    int64_t v6 = v5 + 1;
  }
  *((void *)this + 9) = v6;
}

void *llvm::MachineBasicBlock::addSuccessorWithoutProb(void *this, llvm::MachineBasicBlock *a2)
{
  unint64_t v9 = a2;
  unint64_t v2 = this[13];
  this[15] = this[14];
  int v3 = (void *)this[12];
  if ((unint64_t)v3 >= v2)
  {
    uint64_t v8 = this;
    uint64_t v5 = sub_1CBC13470((void **)this + 11, &v9);
    this = v8;
    unint64_t v4 = v9;
  }
  else
  {
    unint64_t v4 = a2;
    void *v3 = a2;
    uint64_t v5 = v3 + 1;
  }
  this[12] = v5;
  uint64_t v10 = this;
  int64_t v6 = (void *)*((void *)v4 + 9);
  if ((unint64_t)v6 >= *((void *)v4 + 10))
  {
    this = sub_1CBC13470((void **)v4 + 8, &v10);
    uint64_t v7 = this;
  }
  else
  {
    void *v6 = this;
    uint64_t v7 = v6 + 1;
  }
  *((void *)v4 + 9) = v7;
  return this;
}

void llvm::MachineBasicBlock::splitSuccessor(llvm::MachineBasicBlock *this, llvm::MachineBasicBlock *a2, llvm::MachineBasicBlock *a3, int a4)
{
  uint64_t v7 = (llvm::MachineBasicBlock **)*((void *)this + 11);
  uint64_t v8 = (llvm::MachineBasicBlock **)*((void *)this + 12);
  unint64_t v9 = v7;
  if (v7 != v8)
  {
    while (*v9 != a2)
    {
      if (++v9 == v8)
      {
        unint64_t v9 = (llvm::MachineBasicBlock **)*((void *)this + 12);
        break;
      }
    }
  }
  uint64_t v10 = *((void *)this + 14);
  if (v10 == *((void *)this + 15)) {
    int v11 = -1;
  }
  else {
    int v11 = *(_DWORD *)(v10 + (((char *)v9 - (char *)v7) >> 1));
  }
  llvm::MachineBasicBlock::addSuccessor(this, a3, v11);
  if (a4)
  {
    uint64_t v12 = (unsigned int *)*((void *)this + 14);
    unint64_t v13 = (unsigned int *)*((void *)this + 15);
    sub_1CC2BE0A8(v12, v13);
  }
}

uint64_t llvm::MachineBasicBlock::getProbabilityIterator(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 112) + ((a2 - *(void *)(a1 + 88)) >> 1);
}

{
  return *(void *)(a1 + 112) + ((a2 - *(void *)(a1 + 88)) >> 1);
}

char *llvm::MachineBasicBlock::removeSuccessor(llvm::MachineBasicBlock *this, llvm::MachineBasicBlock *a2, int a3)
{
  unint64_t v4 = (char *)*((void *)this + 11);
  uint64_t v5 = (char *)*((void *)this + 12);
  if (v4 != v5)
  {
    while (*(llvm::MachineBasicBlock **)v4 != a2)
    {
      v4 += 8;
      if (v4 == v5)
      {
        unint64_t v4 = (char *)*((void *)this + 12);
        return llvm::MachineBasicBlock::removeSuccessor((uint64_t)this, v4, a3);
      }
    }
  }
  return llvm::MachineBasicBlock::removeSuccessor((uint64_t)this, v4, a3);
}

char *llvm::MachineBasicBlock::removeSuccessor(uint64_t a1, char *__dst, int a3)
{
  uint64_t v6 = *(void *)(a1 + 112);
  uint64_t v5 = *(void *)(a1 + 120);
  if (v6 != v5)
  {
    uint64_t v8 = v6 + ((uint64_t)&__dst[-*(void *)(a1 + 88)] >> 1);
    uint64_t v9 = v5 - (v8 + 4);
    if (v5 != v8 + 4) {
      memmove((void *)(v6 + ((uint64_t)&__dst[-*(void *)(a1 + 88)] >> 1)), (const void *)(v8 + 4), v5 - (v8 + 4));
    }
    *(void *)(a1 + 120) = v8 + v9;
    if (a3) {
      sub_1CC2BE0A8(*(unsigned int **)(a1 + 112), (unsigned int *)(v8 + v9));
    }
  }
  uint64_t v10 = *(void *)__dst;
  uint64_t v12 = *(char **)(*(void *)__dst + 64);
  int v11 = *(char **)(*(void *)__dst + 72);
  if (v12 != v11)
  {
    while (*(void *)v12 != a1)
    {
      v12 += 8;
      if (v12 == v11)
      {
        uint64_t v12 = *(char **)(*(void *)__dst + 72);
        break;
      }
    }
  }
  int64_t v13 = v11 - (v12 + 8);
  if (v11 != v12 + 8) {
    memmove(v12, v12 + 8, v11 - (v12 + 8));
  }
  *(void *)(v10 + 72) = &v12[v13];
  uint64_t v14 = *(char **)(a1 + 96);
  int64_t v15 = v14 - (__dst + 8);
  if (v14 != __dst + 8) {
    memmove(__dst, __dst + 8, v14 - (__dst + 8));
  }
  *(void *)(a1 + 96) = &__dst[v15];
  return __dst;
}

llvm::MachineBasicBlock ***llvm::MachineBasicBlock::removePredecessor(llvm::MachineBasicBlock ***this, llvm::MachineBasicBlock *a2)
{
  unint64_t v2 = this;
  unint64_t v4 = this[8];
  int v3 = this[9];
  if (v4 != v3)
  {
    while (*v4 != a2)
    {
      if (++v4 == v3)
      {
        unint64_t v4 = this[9];
        break;
      }
    }
  }
  int64_t v5 = (char *)v3 - (char *)(v4 + 1);
  if (v3 != v4 + 1) {
    this = (llvm::MachineBasicBlock ***)memmove(v4, v4 + 1, (char *)v3 - (char *)(v4 + 1));
  }
  v2[9] = (llvm::MachineBasicBlock **)((char *)v4 + v5);
  return this;
}

void llvm::MachineBasicBlock::replaceSuccessor(llvm::MachineBasicBlock *this, llvm::MachineBasicBlock *a2, llvm::MachineBasicBlock *a3)
{
  if (a2 == a3) {
    return;
  }
  uint64_t v6 = (char *)*((void *)this + 11);
  uint64_t v7 = (char *)*((void *)this + 12);
  if (v6 != v7)
  {
    uint64_t v8 = (char *)*((void *)this + 12);
    uint64_t v9 = v8;
    uint64_t v10 = (llvm::MachineBasicBlock **)*((void *)this + 11);
    while (1)
    {
      if (*v10 == a2)
      {
        uint64_t v9 = (char *)v10;
        if (v8 != v7) {
          break;
        }
      }
      if (*v10 == a3)
      {
        uint64_t v8 = (char *)v10;
        if (v9 != v7)
        {
          uint64_t v8 = (char *)v10;
          goto LABEL_8;
        }
      }
      if (++v10 == (llvm::MachineBasicBlock **)v7) {
        goto LABEL_8;
      }
    }
    uint64_t v9 = (char *)v10;
LABEL_8:
    if (v8 != v7)
    {
      uint64_t v25 = *((void *)this + 14);
      if (v25 != *((void *)this + 15))
      {
        uint64_t v26 = v8 - v6;
        uint64_t v27 = *(unsigned int *)(v25 + ((v8 - v6) >> 1));
        if (v27 != -1)
        {
          uint64_t v28 = v26 >> 3;
          uint64_t v29 = *(unsigned int *)(v25 + ((v9 - v6) >> 1));
          unint64_t v30 = v29 + v27;
          unsigned int v31 = v29 + v27;
          if (v30 > 0x80000000) {
            unsigned int v31 = 0x80000000;
          }
          *(_DWORD *)(v25 + 4 * v28) = v31;
        }
      }
      llvm::MachineBasicBlock::removeSuccessor((uint64_t)this, v9, 0);
      return;
    }
    uint64_t v7 = v9;
  }
  uint64_t v12 = (llvm::MachineBasicBlock **)*((void *)a2 + 8);
  int v11 = (llvm::MachineBasicBlock **)*((void *)a2 + 9);
  if (v12 != v11)
  {
    while (*v12 != this)
    {
      if (++v12 == v11)
      {
        uint64_t v12 = (llvm::MachineBasicBlock **)*((void *)a2 + 9);
        break;
      }
    }
  }
  int64_t v13 = (char *)v11 - (char *)(v12 + 1);
  if (v11 != v12 + 1) {
    memmove(v12, v12 + 1, (char *)v11 - (char *)(v12 + 1));
  }
  *((void *)a2 + 9) = (char *)v12 + v13;
  int64_t v15 = (void *)*((void *)a3 + 9);
  unint64_t v14 = *((void *)a3 + 10);
  if ((unint64_t)v15 < v14)
  {
    void *v15 = this;
    uint64_t v23 = v15 + 1;
  }
  else
  {
    uint64_t v16 = (void *)*((void *)a3 + 8);
    uint64_t v17 = v15 - v16;
    unint64_t v18 = v17 + 1;
    if ((unint64_t)(v17 + 1) >> 61) {
      abort();
    }
    uint64_t v19 = v14 - (void)v16;
    if (v19 >> 2 > v18) {
      unint64_t v18 = v19 >> 2;
    }
    if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v20 = v18;
    }
    if (v20)
    {
      if (v20 >> 61) {
        sub_1CB833614();
      }
      uint64_t v21 = (char *)operator new(8 * v20);
    }
    else
    {
      uint64_t v21 = 0;
    }
    unint64_t v22 = &v21[8 * v17];
    *(void *)unint64_t v22 = this;
    uint64_t v23 = v22 + 8;
    if (v15 != v16)
    {
      do
      {
        uint64_t v24 = *--v15;
        *((void *)v22 - 1) = v24;
        v22 -= 8;
      }
      while (v15 != v16);
      int64_t v15 = (void *)*((void *)a3 + 8);
    }
    *((void *)a3 + 8) = v22;
    *((void *)a3 + 9) = v23;
    *((void *)a3 + 10) = &v21[8 * v20];
    if (v15) {
      operator delete(v15);
    }
  }
  *((void *)a3 + 9) = v23;
  *(void *)uint64_t v7 = a3;
}

void llvm::MachineBasicBlock::copySuccessor(void *a1, void *a2, llvm::MachineBasicBlock **a3)
{
  unint64_t v4 = (char *)a2[14];
  int64_t v5 = (char *)a2[15];
  uint64_t v6 = *a3;
  if (v4 == v5)
  {
    llvm::MachineBasicBlock::addSuccessorWithoutProb(a1, v6);
  }
  else
  {
    unsigned int v7 = *(_DWORD *)&v4[((uint64_t)a3 - a2[11]) >> 1];
    if (v7 == -1)
    {
      int v8 = 0;
      unsigned int v9 = 0;
      uint64_t v10 = v4;
      do
      {
        unsigned int v12 = *(_DWORD *)v10;
        v10 += 4;
        unsigned int v11 = v12;
        unsigned int v13 = v12 + v9;
        if (v12 + (unint64_t)v9 <= 0x80000000) {
          unsigned int v14 = v13;
        }
        else {
          unsigned int v14 = 0x80000000;
        }
        if (v11 != -1)
        {
          unsigned int v9 = v14;
          ++v8;
        }
      }
      while (v10 != v5);
      unsigned int v7 = (0x80000000 - v9) / (((unint64_t)(v5 - v4) >> 2) - v8);
    }
    llvm::MachineBasicBlock::addSuccessor(a1, v6, v7);
  }
}

unsigned int *llvm::MachineBasicBlock::transferSuccessorsAndUpdatePHIs(unsigned int *this, llvm::MachineBasicBlock *a2)
{
  if (this != (unsigned int *)a2)
  {
    for (uint64_t i = this; ; llvm::MachineBasicBlock::replacePhiUsesWith((uint64_t)v6, a2, (llvm::MachineBasicBlock *)i))
    {
      int64_t v5 = (llvm::MachineBasicBlock **)*((void *)a2 + 11);
      if (v5 == *((llvm::MachineBasicBlock ***)a2 + 12)) {
        break;
      }
      uint64_t v6 = *v5;
      unsigned int v7 = (int *)*((void *)a2 + 14);
      if (v7 == *((int **)a2 + 15)) {
        llvm::MachineBasicBlock::addSuccessorWithoutProb(i, v6);
      }
      else {
        llvm::MachineBasicBlock::addSuccessor(i, v6, *v7);
      }
      int v8 = (char *)*((void *)a2 + 11);
      unsigned int v9 = (char *)*((void *)a2 + 12);
      if (v8 != v9)
      {
        while (*(llvm::MachineBasicBlock **)v8 != v6)
        {
          v8 += 8;
          if (v8 == v9)
          {
            int v8 = (char *)*((void *)a2 + 12);
            break;
          }
        }
      }
      llvm::MachineBasicBlock::removeSuccessor((uint64_t)a2, v8, 0);
    }
    uint64_t v10 = (unsigned int *)*((void *)i + 14);
    unsigned int v11 = (unsigned int *)*((void *)i + 15);
    return sub_1CC2BE0A8(v10, v11);
  }
  return this;
}

uint64_t llvm::MachineBasicBlock::replacePhiUsesWith(uint64_t this, llvm::MachineBasicBlock *a2, llvm::MachineBasicBlock *a3)
{
  uint64_t v3 = *(void *)(this + 56);
  if (v3 != this + 48)
  {
    uint64_t v4 = *(void *)(this + 56);
    while (1)
    {
      int v5 = **(unsigned __int16 **)(v4 + 16);
      if (v5 != 69 && v5 != 0) {
        break;
      }
      uint64_t v4 = *(void *)(v4 + 8);
      if (v4 == this + 48)
      {
        uint64_t v4 = this + 48;
        break;
      }
    }
    while (v3 != v4)
    {
      int v7 = *(_DWORD *)(v3 + 40);
      if (v7 != 1)
      {
        for (int i = 1; i != v7; i += 2)
        {
          uint64_t v9 = *(void *)(v3 + 32) + 32 * (i + 1);
          unsigned int v11 = *(llvm::MachineBasicBlock **)(v9 + 16);
          uint64_t v10 = (void *)(v9 + 16);
          if (v11 == a2) {
            *uint64_t v10 = a3;
          }
        }
      }
      if ((*(unsigned char *)v3 & 4) == 0)
      {
        while ((*(_WORD *)(v3 + 44) & 8) != 0)
          uint64_t v3 = *(void *)(v3 + 8);
      }
      uint64_t v3 = *(void *)(v3 + 8);
    }
  }
  return this;
}

BOOL llvm::MachineBasicBlock::isPredecessor(llvm::MachineBasicBlock *this, const llvm::MachineBasicBlock *a2)
{
  uint64_t v2 = (const llvm::MachineBasicBlock **)*((void *)this + 8);
  uint64_t v3 = (const llvm::MachineBasicBlock **)*((void *)this + 9);
  if (v2 != v3)
  {
    while (*v2 != a2)
    {
      if (++v2 == v3)
      {
        uint64_t v2 = (const llvm::MachineBasicBlock **)*((void *)this + 9);
        return v2 != v3;
      }
    }
  }
  return v2 != v3;
}

uint64_t llvm::MachineBasicBlock::getFallThrough(llvm::MachineBasicBlock *this)
{
  v20[16] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *((void *)this + 1);
  uint64_t v2 = *((void *)this + 4);
  if (v1 == v2 + 320) {
    return 0;
  }
  uint64_t v4 = (void *)*((void *)this + 11);
  int v5 = (void *)*((void *)this + 12);
  if (v4 != v5)
  {
    while (*v4 != v1)
    {
      if (++v4 == v5)
      {
        uint64_t v4 = (void *)*((void *)this + 12);
        break;
      }
    }
  }
  if (v4 == v5) {
    return 0;
  }
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  unint64_t v18 = v20;
  uint64_t v19 = 0x400000000;
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(v2 + 16) + 104))(*(void *)(v2 + 16));
  if (!(*(unsigned int (**)(uint64_t, llvm::MachineBasicBlock *, uint64_t *, uint64_t *, void **, void))(*(void *)v6 + 248))(v6, this, &v17, &v16, &v18, 0))
  {
    if (v17 && v17 != v1 && v16 != v1 && (!v19 || v16 != 0)) {
      uint64_t v1 = 0;
    }
    goto LABEL_37;
  }
  int v7 = (_WORD *)(*((void *)this + 6) & 0xFFFFFFFFFFFFFFF8);
  if ((_WORD *)((char *)this + 48) == v7) {
    goto LABEL_37;
  }
  if (v7)
  {
    unint64_t v8 = *((void *)this + 6) & 0xFFFFFFFFFFFFFFF8;
    if ((*(unsigned char *)v7 & 4) != 0)
    {
      __int16 v9 = v7[22];
      unint64_t v8 = *((void *)this + 6) & 0xFFFFFFFFFFFFFFF8;
      goto LABEL_25;
    }
  }
  else
  {
    unint64_t v8 = 0;
  }
  while (1)
  {
    __int16 v9 = *(_WORD *)(v8 + 44);
    if ((v9 & 4) == 0) {
      break;
    }
    unint64_t v8 = *(void *)v8 & 0xFFFFFFFFFFFFFFF8;
  }
LABEL_25:
  int v11 = v9 & 0xC;
  int v12 = v9 & 4;
  uint64_t v13 = *(void *)(*(void *)(v8 + 16) + 8);
  if (v11) {
    BOOL v14 = v12 == 0;
  }
  else {
    BOOL v14 = 0;
  }
  if (v14)
  {
    if ((v13 & 0x100) == 0)
    {
      while ((*(_WORD *)(v8 + 44) & 8) != 0)
      {
        unint64_t v8 = *(void *)(v8 + 8);
        if (*(unsigned char *)(*(void *)(v8 + 16) + 9)) {
          goto LABEL_30;
        }
      }
      goto LABEL_37;
    }
    goto LABEL_30;
  }
  if ((v13 & 0x100) != 0)
  {
LABEL_30:
    if (!v7 || (*(unsigned char *)v7 & 4) == 0)
    {
      while ((v7[22] & 4) != 0)
        int v7 = (_WORD *)(*(void *)v7 & 0xFFFFFFFFFFFFFFF8);
    }
    if (!(*(unsigned int (**)(uint64_t))(*(void *)v6 + 768))(v6)) {
      uint64_t v1 = 0;
    }
  }
LABEL_37:
  if (v18 != v20) {
    free(v18);
  }
  return v1;
}

llvm::MachineBasicBlock *llvm::MachineBasicBlock::splitAt(llvm::MachineBasicBlock *this, llvm::MachineInstr *a2, int a3, llvm::LiveIntervals *a4)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = a2;
  if ((*(unsigned char *)a2 & 4) == 0)
  {
    unint64_t v8 = a2;
    if ((*((_WORD *)a2 + 22) & 8) != 0)
    {
      unint64_t v8 = a2;
      do
        unint64_t v8 = (llvm::MachineInstr *)*((void *)v8 + 1);
      while ((*((_WORD *)v8 + 22) & 8) != 0);
    }
  }
  __int16 v9 = (llvm::MachineBasicBlock *)*((void *)v8 + 1);
  uint64_t v10 = (unint64_t *)((char *)this + 48);
  if (v9 == (llvm::MachineBasicBlock *)((char *)this + 48)) {
    return this;
  }
  int v11 = (llvm::MachineFunction *)*((void *)this + 4);
  uint64_t v28 = 0;
  uint64_t v29 = v31;
  long long v30 = xmmword_1CD96EEC0;
  uint64_t v32 = 0;
  unsigned int v33 = 0;
  if (a3)
  {
    uint64_t v28 = (*(uint64_t (**)(void *))(**((void **)v11 + 2) + 176))(*((void **)v11 + 2));
    *(void *)&long long v30 = 0;
    size_t v24 = *(unsigned int *)(v28 + 16);
    if (v33 < v24 || v33 >> 2 > v24)
    {
      free(v32);
      uint64_t v26 = malloc_type_calloc(v24, 1uLL, 0x6D9A4F0CuLL);
      if (!v26 && (v24 || (uint64_t v26 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
        llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
      }
      uint64_t v32 = v26;
      unsigned int v33 = v24;
    }
    llvm::LivePhysRegs::addLiveOuts((llvm::LivePhysRegs *)&v28, (const llvm::MachineFunction **)this);
    uint64_t v27 = (llvm::MachineInstr *)(*((void *)this + 6) & 0xFFFFFFFFFFFFFFF8);
    if (!v27 || (*(unsigned char *)v27 & 4) == 0)
    {
      while ((*((_WORD *)v27 + 22) & 4) != 0)
        uint64_t v27 = (llvm::MachineInstr *)(*(void *)v27 & 0xFFFFFFFFFFFFFFF8);
    }
    while (v27 != a2)
    {
      llvm::LivePhysRegs::removeDefs((llvm::LivePhysRegs *)&v28, v27);
      llvm::LivePhysRegs::addUses((llvm::LivePhysRegs *)&v28, v27);
      uint64_t v27 = (llvm::MachineInstr *)(*(void *)v27 & 0xFFFFFFFFFFFFFFF8);
      if (!v27 || (*(unsigned char *)v27 & 4) == 0)
      {
        while ((*((_WORD *)v27 + 22) & 4) != 0)
          uint64_t v27 = (llvm::MachineInstr *)(*(void *)v27 & 0xFFFFFFFFFFFFFFF8);
      }
    }
  }
  MachineBasicBlocuint64_t k = (unsigned int *)llvm::MachineFunction::CreateMachineBasicBlock(v11, *((const llvm::BasicBlock **)this + 2));
  uint64_t v13 = (unsigned int **)*((void *)this + 1);
  llvm::ilist_callback_traits<llvm::MachineBasicBlock>::addNodeToList((uint64_t)MachineBasicBlock, (uint64_t)MachineBasicBlock);
  BOOL v14 = *v13;
  *(void *)MachineBasicBlocuint64_t k = *v13;
  *((void *)MachineBasicBlock + 1) = v13;
  *((void *)v14 + 1) = MachineBasicBlock;
  *uint64_t v13 = MachineBasicBlock;
  int64_t v15 = (unint64_t *)*((void *)MachineBasicBlock + 7);
  if (v15 != v10)
  {
    if (MachineBasicBlock != (unsigned int *)this)
    {
      uint64_t v16 = *((void *)MachineBasicBlock + 5);
      uint64_t v17 = v9;
      do
      {
        *((void *)v17 + 3) = v16;
        uint64_t v17 = (llvm::MachineBasicBlock *)*((void *)v17 + 1);
      }
      while (v17 != (llvm::MachineBasicBlock *)v10);
    }
    unint64_t v18 = *v10;
    unint64_t v19 = *v10 & 0xFFFFFFFFFFFFFFF8;
    unint64_t v20 = *(void *)v9 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v20 + 8) = v10;
    *uint64_t v10 = v20 | v18 & 7;
    unint64_t v21 = *v15 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v19 + 8) = v15;
    *(void *)__int16 v9 = v21 | *(void *)v9 & 7;
    *(void *)(v21 + 8) = v9;
    unint64_t *v15 = v18 & 0xFFFFFFFFFFFFFFF8 | *v15 & 7;
  }
  llvm::MachineBasicBlock::transferSuccessorsAndUpdatePHIs(MachineBasicBlock, this);
  llvm::MachineBasicBlock::addSuccessor(this, MachineBasicBlock, -1);
  if (a3) {
    llvm::addLiveIns((llvm *)MachineBasicBlock, (llvm::MachineBasicBlock *)&v28, v22);
  }
  if (a4) {
    sub_1CD526C2C((uint64_t)a4, (uint64_t *)MachineBasicBlock);
  }
  free(v32);
  if (v29 != v31) {
    free(v29);
  }
  return (llvm::MachineBasicBlock *)MachineBasicBlock;
}

unint64_t llvm::MachineBasicBlock::SplitCriticalEdge(void *a1, const llvm::MachineBasicBlock *a2, uint64_t a3, void *a4)
{
  v272[2] = *MEMORY[0x1E4F143B8];
  canSplitCriticalEdge = (char *)llvm::MachineBasicBlock::canSplitCriticalEdge((llvm::MachineBasicBlock *)a1, a2);
  if (!canSplitCriticalEdge) {
    return 0;
  }
  uint64_t v11 = a1[4];
  int v12 = (llvm::MachineBasicBlock *)a1[1];
  uint64_t v13 = (llvm::MachineBasicBlock *)(v11 + 320);
  long long v256 = 0;
  unint64_t v9 = *(void *)(v11 + 312);
  uint64_t v237 = a4;
  if (v9)
  {
    *(void *)(v11 + 312) = *(void *)v9;
  }
  else
  {
    *(void *)(v11 + 208) += 232;
    uint64_t v14 = *(void *)(v11 + 128);
    if (((v14 + 7) & 0xFFFFFFFFFFFFFFF8) - v14 + 232 > *(void *)(v11 + 136) - v14)
    {
      unsigned int v225 = *(_DWORD *)(v11 + 152) >> 7;
      if (v225 >= 0x1E) {
        LOBYTE(v225) = 30;
      }
      uint64_t v226 = v11;
      uint64_t v227 = 4096 << v225;
      canSplitCriticalEdge = (char *)operator new(4096 << v225, (std::align_val_t)8uLL);
      unint64_t v9 = (unint64_t)canSplitCriticalEdge;
      unsigned int v228 = *(_DWORD *)(v226 + 152);
      if (v228 >= *(_DWORD *)(v226 + 156)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v226 + 144) + 8 * v228) = canSplitCriticalEdge;
      ++*(_DWORD *)(v226 + 152);
      *(void *)(v226 + 128) = canSplitCriticalEdge + 232;
      *(void *)(v226 + 136) = &canSplitCriticalEdge[v227];
      uint64_t v11 = v226;
    }
    else
    {
      unint64_t v9 = (v14 + 7) & 0xFFFFFFFFFFFFFFF8;
      *(void *)(v11 + 128) = v9 + 232;
    }
  }
  *(void *)unint64_t v9 = 0;
  *(void *)(v9 + 8) = 0;
  *(void *)(v9 + 16) = 0;
  *(_DWORD *)(v9 + 24) = -1;
  *(void *)(v9 + 48) = (v9 + 48) | 4;
  *(void *)(v9 + 56) = v9 + 48;
  unint64_t v238 = v9 + 48;
  uint64_t v239 = v11;
  *(unsigned char *)(v9 + 144) = 0;
  *(void *)(v9 + 152) = 0;
  uint64_t v251 = (void *)(v9 + 152);
  *(_OWORD *)(v9 + 64) = 0u;
  *(_OWORD *)(v9 + 80) = 0u;
  *(_OWORD *)(v9 + 96) = 0u;
  *(_OWORD *)(v9 + 112) = 0u;
  *(_OWORD *)(v9 + 121) = 0u;
  *(void *)(v9 + 160) = 0;
  *(void *)(v9 + 168) = 0;
  *(unsigned char *)(v9 + 176) = 0;
  *(_DWORD *)(v9 + 187) = 0;
  *(void *)(v9 + 180) = 0;
  *(void *)(v9 + 192) = 0;
  *(_DWORD *)(v9 + 199) = 0;
  *(void *)(v9 + 216) = 0;
  *(void *)(v9 + 224) = 0;
  *(void *)(v9 + 208) = 0;
  *(void *)(v9 + 32) = v11;
  *(void *)(v9 + 40) = v9;
  if (v12 == v13) {
    int64_t v15 = 0;
  }
  else {
    int64_t v15 = v12;
  }
  uint64_t v16 = (unint64_t *)a1[1];
  llvm::ilist_callback_traits<llvm::MachineBasicBlock>::addNodeToList((uint64_t)canSplitCriticalEdge, v9);
  unint64_t v17 = *v16;
  *(void *)unint64_t v9 = *v16;
  *(void *)(v9 + 8) = v16;
  *(void *)(v17 + 8) = v9;
  *uint64_t v16 = v9;
  unint64_t v18 = *(llvm::PMDataManager **)(*(void *)(a3 + 8) + 24);
  uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass(v18, &llvm::LiveIntervals::ID, 1);
  if (AnalysisPass)
  {
    uint64_t v22 = (*(uint64_t (**)(uint64_t, void *))(*(void *)AnalysisPass + 96))(AnalysisPass, &llvm::LiveIntervals::ID);
    uint64_t v21 = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*(void *)(a3 + 8) + 24), &llvm::SlotIndexes::ID, 1);
    if (!v21)
    {
      if (!v22)
      {
        char v20 = 1;
        uint64_t v247 = 0;
        uint64_t v249 = 0;
        goto LABEL_24;
      }
      uint64_t v247 = 0;
      goto LABEL_21;
    }
  }
  else
  {
    char v20 = 1;
    uint64_t v21 = llvm::PMDataManager::findAnalysisPass(v18, &llvm::SlotIndexes::ID, 1);
    uint64_t v22 = 0;
    uint64_t v247 = 0;
    uint64_t v249 = 0;
    if (!v21) {
      goto LABEL_24;
    }
  }
  uint64_t v23 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v21 + 96))(v21, &llvm::SlotIndexes::ID);
  if (v22)
  {
    uint64_t v247 = (int32x2_t *)v23;
LABEL_21:
    sub_1CD526C2C(v22, (uint64_t *)v9);
    char v20 = 0;
    uint64_t v249 = v22;
    goto LABEL_24;
  }
  if (v23)
  {
    uint64_t v247 = (int32x2_t *)v23;
    sub_1CD526C98(v23, (uint64_t *)v9);
    uint64_t v249 = 0;
  }
  else
  {
    uint64_t v247 = 0;
    uint64_t v249 = 0;
  }
  char v20 = 1;
LABEL_24:
  uint64_t v24 = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*(void *)(a3 + 8) + 24), &llvm::LiveVariables::ID, 1);
  uint64_t v25 = &dword_1CD912700[7744];
  v244 = a2;
  v250 = (llvm::MachineBasicBlock *)a1;
  uint64_t v241 = a3;
  char v242 = v20;
  if (!v24)
  {
    uint64_t v26 = 0;
    v270 = v272;
    uint64_t v271 = 0x400000000;
LABEL_27:
    char v245 = 1;
    goto LABEL_28;
  }
  uint64_t v26 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v24 + 96))(v24, &llvm::LiveVariables::ID);
  v270 = v272;
  uint64_t v271 = 0x400000000;
  if (!v26) {
    goto LABEL_27;
  }
  uint64_t FirstInstrTerminator = llvm::MachineBasicBlock::getFirstInstrTerminator((llvm::MachineBasicBlock *)a1);
  if (a1 + 6 == (void *)FirstInstrTerminator)
  {
    char v245 = 0;
  }
  else
  {
    uint64_t v212 = FirstInstrTerminator;
    do
    {
      uint64_t v213 = *(unsigned int *)(v212 + 40);
      if (v213)
      {
        v214 = *(unsigned int **)(v212 + 32);
        uint64_t v215 = 32 * v213;
        do
        {
          unsigned int v216 = *v214;
          if (!*v214 && (v216 & 0x1000000) == 0)
          {
            unsigned int v217 = v214[1];
            if (v217)
            {
              if (v216 & 0x10000000) == 0 && ((v216 >> 26) & ~HIBYTE(v216))
              {
                if (!(v217 >> 30)) {
                  goto LABEL_309;
                }
                uint64_t v218 = v217 & 0x7FFFFFFF;
                if ((v217 & 0x7FFFFFFF) >= *(_DWORD *)(v26 + 256)) {
                  sub_1CD520A8C((uint64_t *)(v26 + 248), v218 + 1, v26 + 264);
                }
                if (sub_1CC30D1B0(*(void *)(v26 + 248) + 56 * v218, v212))
                {
LABEL_309:
                  if (v271 >= (unint64_t)HIDWORD(v271)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  v270[v271] = v217;
                  LODWORD(v271) = v271 + 1;
                  *v214 &= ~0x4000000u;
                }
              }
            }
          }
          v214 += 8;
          v215 -= 32;
        }
        while (v215);
      }
      uint64_t v212 = *(void *)(v212 + 8);
    }
    while ((void *)v212 != a1 + 6);
    char v245 = 0;
    char v20 = v242;
    uint64_t v25 = dword_1CD912700 + 30976;
  }
LABEL_28:
  uint64_t v267 = v269;
  uint64_t v27 = *((void *)v25 + 126);
  uint64_t v268 = v27;
  if ((v20 & 1) == 0)
  {
    uint64_t v28 = llvm::MachineBasicBlock::getFirstInstrTerminator((llvm::MachineBasicBlock *)a1);
    if (a1 + 6 != (void *)v28)
    {
      uint64_t v29 = v28;
      unsigned int v30 = 0;
      do
      {
        uint64_t v31 = *(unsigned int *)(v29 + 40);
        if (v31)
        {
          uint64_t v32 = *(void *)(v29 + 32);
          uint64_t v33 = v32 + 32 * v31;
          do
          {
            if (!*(unsigned char *)v32)
            {
              int v34 = *(_DWORD *)(v32 + 4);
              if (v34)
              {
                unint64_t v35 = v267;
                if (v30)
                {
                  uint64_t v36 = 4 * v30;
                  unint64_t v35 = v267;
                  while (*(_DWORD *)v35 != v34)
                  {
                    v35 += 4;
                    v36 -= 4;
                    if (!v36)
                    {
                      unint64_t v35 = &v267[4 * v30];
                      break;
                    }
                  }
                }
                if (v30 == (v35 - v267) >> 2)
                {
                  if (v30 >= HIDWORD(v268)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *(_DWORD *)&v267[4 * v30] = v34;
                  unsigned int v30 = v268 + 1;
                  LODWORD(v268) = v268 + 1;
                }
              }
            }
            v32 += 32;
          }
          while (v32 != v33);
        }
        uint64_t v29 = *(void *)(v29 + 8);
      }
      while ((void *)v29 != a1 + 6);
    }
  }
  llvm::MachineBasicBlock::ReplaceUsesOfBlockWith((llvm::MachineBasicBlock *)a1, v244, (llvm::MachineBasicBlock *)v9);
  int v264 = v266;
  uint64_t v265 = v27;
  if (!v247)
  {
    if (v15 == v244) {
      int v37 = (llvm::MachineBasicBlock *)v9;
    }
    else {
      int v37 = v15;
    }
    llvm::MachineBasicBlock::updateTerminator((llvm::MachineBasicBlock *)a1, v37);
    goto LABEL_91;
  }
  uint64_t v38 = v15;
  uint64_t v39 = llvm::MachineBasicBlock::getFirstInstrTerminator((llvm::MachineBasicBlock *)a1);
  int v40 = a1 + 6;
  if (a1 + 6 != (void *)v39)
  {
    uint64_t v47 = v39;
    unsigned int v48 = 0;
    do
    {
      if (v48 >= HIDWORD(v265)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)&v264[8 * v48] = v47;
      unsigned int v48 = v265 + 1;
      LODWORD(v265) = v265 + 1;
      uint64_t v47 = *(void *)(v47 + 8);
    }
    while ((void *)v47 != v40);
  }
  if (v38 == v244) {
    uint64_t v41 = (llvm::MachineBasicBlock *)v9;
  }
  else {
    uint64_t v41 = v38;
  }
  llvm::MachineBasicBlock::updateTerminator((llvm::MachineBasicBlock *)a1, v41);
  v258 = v260;
  uint64_t v259 = v27;
  uint64_t v42 = llvm::MachineBasicBlock::getFirstInstrTerminator((llvm::MachineBasicBlock *)a1);
  if (v40 == (void *)v42)
  {
    unsigned int v44 = 0;
    uint64_t v45 = v247;
  }
  else
  {
    uint64_t v43 = v42;
    unsigned int v44 = 0;
    uint64_t v45 = v247;
    do
    {
      if (v44 >= HIDWORD(v259)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v258 + v44) = v43;
      unsigned int v44 = v259 + 1;
      LODWORD(v259) = v259 + 1;
      uint64_t v43 = *(void *)(v43 + 8);
    }
    while ((void *)v43 != v40);
  }
  if (v265)
  {
    unsigned int v49 = v264;
    unint64_t v50 = &v264[8 * v265];
    do
    {
      uint64_t v51 = *(void *)v49;
      if (v44)
      {
        uint64_t v52 = 8 * v44;
        int64_t v53 = (char *)v258;
        while (*(void *)v53 != v51)
        {
          v53 += 8;
          v52 -= 8;
          if (!v52)
          {
            int64_t v53 = (char *)v258 + 8 * v44;
            break;
          }
        }
      }
      else
      {
        int64_t v53 = (char *)v258;
      }
      if (v44 != (v53 - (unsigned char *)v258) >> 3) {
        goto LABEL_88;
      }
      int32x2_t v54 = v45[46];
      uint64_t v55 = v45[48].u32[0];
      if (v55)
      {
        LODWORD(v56) = (v55 - 1) & ((v51 >> 4) ^ (v51 >> 9));
        BOOL v57 = (uint64_t *)(*(void *)&v54 + 16 * v56);
        uint64_t v58 = *v57;
        if (*v57 == v51) {
          goto LABEL_86;
        }
        int v59 = 1;
        while (v58 != -4096)
        {
          int v60 = v56 + v59++;
          uint64_t v56 = v60 & (v55 - 1);
          uint64_t v58 = *(void *)(*(void *)&v54 + 16 * v56);
          if (v58 == v51)
          {
            BOOL v57 = (uint64_t *)(*(void *)&v54 + 16 * v56);
            goto LABEL_86;
          }
        }
      }
      BOOL v57 = (uint64_t *)(*(void *)&v54 + 16 * v55);
LABEL_86:
      if (v57 != (uint64_t *)(*(void *)&v54 + 16 * v55))
      {
        unint64_t v61 = v57[1] & 0xFFFFFFFFFFFFFFF8;
        *BOOL v57 = -8192;
        v45[47] = vadd_s32(v45[47], (int32x2_t)0x1FFFFFFFFLL);
        *(void *)(v61 + 16) = 0;
      }
LABEL_88:
      v49 += 8;
    }
    while (v49 != v50);
  }
  if (v258 != v260) {
    free(v258);
  }
LABEL_91:
  llvm::MachineBasicBlock::addSuccessor((void *)v9, v244, -1);
  if (*(llvm::MachineBasicBlock **)(v9 + 8) != v244)
  {
    v258 = v260;
    uint64_t v259 = v27;
    uint64_t v62 = *(void *)(*(uint64_t (**)(void))(**(void **)(a1[4] + 16) + 104))(*(void *)(a1[4] + 16));
    (*(void (**)(void))(v62 + 272))();
    if (v247)
    {
      for (uint64_t i = *(void *)(v9 + 56); i != v238; uint64_t i = *(void *)(i + 8))
      {
        uint64_t v64 = v247[48].u32[0];
        if (v64)
        {
          int32x2_t v65 = v247[46];
          unsigned int v66 = v64 - 1;
          LODWORD(v67) = ((i >> 4) ^ (i >> 9)) & (v64 - 1);
          size_t v68 = (uint64_t *)(*(void *)&v65 + 16 * v67);
          uint64_t v69 = *v68;
          if (i == *v68)
          {
LABEL_105:
            if (v68 != (uint64_t *)(*(void *)&v65 + 16 * v64))
            {
              unint64_t v76 = v68[1] & 0xFFFFFFFFFFFFFFF8;
              *size_t v68 = -8192;
              v247[47] = vadd_s32(v247[47], (int32x2_t)0x1FFFFFFFFLL);
              *(void *)(v76 + 16) = 0;
            }
          }
          else
          {
            int v70 = 1;
            uint64_t v71 = *v68;
            unsigned int v72 = ((i >> 4) ^ (i >> 9)) & v66;
            while (v71 != -4096)
            {
              unsigned int v73 = v72 + v70++;
              unsigned int v72 = v73 & v66;
              uint64_t v71 = *(void *)(*(void *)&v65 + 16 * v72);
              if (i == v71)
              {
                if (i != v69)
                {
                  int v74 = 1;
                  while (v69 != -4096)
                  {
                    int v75 = v67 + v74++;
                    uint64_t v67 = v75 & v66;
                    uint64_t v69 = *(void *)(*(void *)&v65 + 16 * v67);
                    if (v69 == i)
                    {
                      size_t v68 = (uint64_t *)(*(void *)&v65 + 16 * v67);
                      goto LABEL_105;
                    }
                  }
                  size_t v68 = (uint64_t *)(*(void *)&v65 + 16 * v64);
                }
                goto LABEL_105;
              }
            }
          }
        }
        sub_1CB914C88((uint64_t)v247, i, 0);
      }
    }
    if (v258 != v260) {
      free(v258);
    }
  }
  llvm::MachineBasicBlock::replacePhiUsesWith((uint64_t)v244, (llvm::MachineBasicBlock *)a1, (llvm::MachineBasicBlock *)v9);
  unint64_t v77 = (_OWORD *)*((void *)v244 + 19);
  uint64_t v78 = (_OWORD *)*((void *)v244 + 20);
  if (v77 != v78)
  {
    char v79 = *(_OWORD **)(v9 + 160);
    do
    {
      unint64_t v80 = *(void *)(v9 + 168);
      if ((unint64_t)v79 >= v80)
      {
        unint64_t v82 = (_OWORD *)*v251;
        uint64_t v83 = ((uint64_t)v79 - *v251) >> 4;
        unint64_t v84 = v83 + 1;
        if ((unint64_t)(v83 + 1) >> 60) {
LABEL_357:
        }
          abort();
        uint64_t v85 = v80 - (void)v82;
        if (v85 >> 3 > v84) {
          unint64_t v84 = v85 >> 3;
        }
        if ((unint64_t)v85 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v86 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v86 = v84;
        }
        if (v86)
        {
          if (v86 >> 60) {
LABEL_358:
          }
            sub_1CB833614();
          uint64_t v87 = (char *)operator new(16 * v86);
        }
        else
        {
          uint64_t v87 = 0;
        }
        uint64_t v88 = &v87[16 * v83];
        *(_OWORD *)uint64_t v88 = *v77;
        unsigned int v89 = v88;
        if (v79 != v82)
        {
          do
          {
            *((_OWORD *)v89 - 1) = *(v79 - 1);
            v89 -= 16;
            --v79;
          }
          while (v79 != v82);
          char v79 = (_OWORD *)*v251;
        }
        char v81 = v88 + 16;
        *(void *)(v9 + 152) = v89;
        *(void *)(v9 + 160) = v88 + 16;
        *(void *)(v9 + 168) = &v87[16 * v86];
        if (v79) {
          operator delete(v79);
        }
      }
      else
      {
        *char v79 = *v77;
        char v81 = v79 + 1;
      }
      *(void *)(v9 + 160) = v81;
      ++v77;
      char v79 = v81;
    }
    while (v77 != v78);
  }
  uint64_t v90 = (*(uint64_t (**)(void))(**(void **)(v239 + 16) + 176))(*(void *)(v239 + 16));
  uint64_t v91 = (uint64_t)a1;
  if ((v245 & 1) == 0)
  {
    int v92 = v271;
    if (v271)
    {
      uint64_t v93 = v90;
      uint64_t v94 = (uint64_t *)(v26 + 248);
      do
      {
        unsigned int v95 = v270[v92 - 1];
        LODWORD(v271) = v92 - 1;
        unsigned int v96 = *(llvm::MachineInstr **)(v91 + 56);
        uint64_t v97 = (llvm::MachineInstr *)(a1 + 6);
        do
        {
          if (v97 == v96) {
            goto LABEL_158;
          }
          uint64_t v97 = (llvm::MachineInstr *)(*(void *)v97 & 0xFFFFFFFFFFFFFFF8);
        }
        while (!llvm::MachineInstr::addRegisterKilled(v97, v95, v93, 0));
        if ((v95 & 0x80000000) != 0)
        {
          unint64_t v98 = v95 & 0x7FFFFFFF;
          if (v98 >= *(unsigned int *)(v26 + 256)) {
            sub_1CD520A8C(v94, v98 + 1, v26 + 264);
          }
          unsigned int v99 = (void *)(*v94 + 56 * v98);
          unint64_t v101 = (llvm::MachineInstr **)v99[5];
          unint64_t v100 = v99[6];
          if ((unint64_t)v101 >= v100)
          {
            unint64_t v103 = (void *)v99[4];
            uint64_t v104 = v101 - (llvm::MachineInstr **)v103;
            unint64_t v105 = v104 + 1;
            if ((unint64_t)(v104 + 1) >> 61) {
              goto LABEL_357;
            }
            uint64_t v106 = v100 - (void)v103;
            if (v106 >> 2 > v105) {
              unint64_t v105 = v106 >> 2;
            }
            if ((unint64_t)v106 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v107 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v107 = v105;
            }
            if (v107)
            {
              if (v107 >> 61) {
                goto LABEL_358;
              }
              uint64_t v108 = (char *)operator new(8 * v107);
            }
            else
            {
              uint64_t v108 = 0;
            }
            uint64_t v109 = (llvm::MachineInstr **)&v108[8 * v104];
            *uint64_t v109 = v97;
            unint64_t v102 = v109 + 1;
            if (v101 != v103)
            {
              do
              {
                uint64_t v110 = *--v101;
                *--uint64_t v109 = v110;
              }
              while (v101 != v103);
              unint64_t v101 = (llvm::MachineInstr **)v99[4];
            }
            v99[4] = v109;
            v99[5] = v102;
            v99[6] = &v108[8 * v107];
            if (v101) {
              operator delete(v101);
            }
            uint64_t v91 = (uint64_t)a1;
            uint64_t v94 = (uint64_t *)(v26 + 248);
          }
          else
          {
            *unint64_t v101 = v97;
            unint64_t v102 = v101 + 1;
          }
          v99[5] = v102;
        }
LABEL_158:
        int v92 = v271;
      }
      while (v271);
    }
    if (v237) {
      llvm::LiveVariables::addNewBlock(v26, v9, v91, (uint64_t)v244, v237);
    }
    else {
      llvm::LiveVariables::addNewBlock((llvm::LiveVariables *)v26, (llvm::MachineBasicBlock *)v9, (llvm::MachineBasicBlock *)v91, v244);
    }
  }
  uint64_t v111 = (uint64_t)v244;
  uint64_t v112 = v241;
  if ((v242 & 1) == 0)
  {
    int32x2_t v113 = v247[49];
    uint64_t v114 = *(void *)(*(void *)&v113 + 16 * *(unsigned int *)(v91 + 24) + 8);
    unsigned int v115 = (v114 >> 1) & 3;
    uint64_t v246 = v114;
    unint64_t v116 = v114 & 0xFFFFFFFFFFFFFFF8;
    unsigned int v236 = v115;
    unint64_t v235 = v114 & 0xFFFFFFFFFFFFFFF8;
    if (v115) {
      uint64_t v117 = v116 | (2 * (v115 - 1));
    }
    else {
      uint64_t v117 = *(void *)v116 | 6;
    }
    uint64_t v118 = *(void *)(v91 + 32);
    uint64_t v240 = *(void *)(v9 + 8);
    uint64_t v248 = *(void *)(*(void *)&v113 + 16 * *(unsigned int *)(v9 + 24) + 8);
    v258 = v260;
    uint64_t v259 = 0x800000000;
    uint64_t v262 = 0;
    uint64_t v263 = 0;
    v261 = &v262;
    uint64_t v119 = *((void *)v244 + 7);
    if ((llvm::MachineBasicBlock *)v119 == (llvm::MachineBasicBlock *)((char *)v244 + 48))
    {
      uint64_t v141 = v118;
      uint64_t v120 = v249;
    }
    else
    {
      uint64_t v233 = v118;
      uint64_t v234 = v117;
      uint64_t v120 = v249;
      int v243 = (void *)(v249 + 408);
      unint64_t v252 = v117 & 0xFFFFFFFFFFFFFFF8;
      unsigned int v121 = (v117 >> 1) & 3;
      while (!**(_WORD **)(v119 + 16) || **(_WORD **)(v119 + 16) == 69)
      {
        int v122 = *(_DWORD *)(v119 + 40);
        if (v122 != 1)
        {
          unsigned int v123 = 1;
          while (1)
          {
            uint64_t v124 = *(void *)(v119 + 32);
            if (*(void *)(v124 + 32 * (v123 + 1) + 16) == v9)
            {
              uint64_t v125 = v124 + 32 * v123;
              LODWORD(v257[0]) = *(_DWORD *)(v125 + 4);
              sub_1CD513F60((uint64_t)&v258, (unsigned int *)v257);
              if ((*(unsigned char *)(v125 + 3) & 0x10) == 0) {
                break;
              }
            }
LABEL_175:
            v123 += 2;
            if (v123 == v122) {
              goto LABEL_171;
            }
          }
          uint64_t v126 = v257[0] & 0x7FFFFFFF;
          uint64_t v127 = *(unsigned int *)(v120 + 416);
          if (v126 >= v127)
          {
            sub_1CB9153B8((uint64_t)v243, v126 - v127 + 1, *(void *)(v249 + 424));
LABEL_197:
            operator new();
          }
          uint64_t v128 = *(void *)(*v243 + 8 * v126);
          if (!v128) {
            goto LABEL_197;
          }
          unsigned int v129 = *(_DWORD *)(v128 + 8);
          uint64_t v130 = *(void **)v128;
          if (v129)
          {
            uint64_t v131 = v130[3 * v129 - 2];
            unsigned int v132 = *(_DWORD *)(v252 + 24) | v121;
            unsigned int v133 = (v131 >> 1) & 3 | *(_DWORD *)((v131 & 0xFFFFFFFFFFFFFFF8) + 24);
            uint64_t v134 = *(void **)v128;
            unint64_t v135 = *(unsigned int *)(v128 + 8);
            uint64_t v120 = v249;
            if (v132 < v133)
            {
              do
              {
                unint64_t v136 = v135 >> 1;
                uint64_t v137 = v134[3 * (v135 >> 1) + 1];
                LODWORD(v137) = (v137 >> 1) & 3 | *(_DWORD *)((v137 & 0xFFFFFFFFFFFFFFF8) + 24);
                v135 -= (v135 >> 1) + 1;
                BOOL v138 = v132 >= v137;
                if (v132 >= v137) {
                  unint64_t v139 = v136 + 1;
                }
                else {
                  unint64_t v139 = 0;
                }
                v134 += 3 * v139;
                if (!v138) {
                  unint64_t v135 = v136;
                }
              }
              while (v135);
              goto LABEL_191;
            }
          }
          else
          {
            unsigned int v129 = 0;
            uint64_t v120 = v249;
          }
          uint64_t v134 = &v130[3 * v129];
LABEL_191:
          if (v134 == &v130[3 * v129]
            || ((*v134 >> 1) & 3 | *(_DWORD *)((*v134 & 0xFFFFFFFFFFFFFFF8) + 24)) > (*(_DWORD *)(v252 + 24) | v121))
          {
            uint64_t v140 = 0;
          }
          else
          {
            uint64_t v140 = v134[2];
          }
          v255[0] = v246;
          v255[1] = v248;
          v255[2] = v140;
          llvm::LiveRange::addSegment(v128, (uint64_t)v255);
          goto LABEL_175;
        }
LABEL_171:
        uint64_t v119 = *(void *)(v119 + 8);
        if ((llvm::MachineBasicBlock *)v119 == (llvm::MachineBasicBlock *)((char *)v244 + 48)) {
          break;
        }
      }
      uint64_t v141 = *((void *)v250 + 4);
      uint64_t v111 = (uint64_t)v244;
      uint64_t v112 = v241;
      uint64_t v118 = v233;
      uint64_t v117 = v234;
    }
    int v142 = *(_DWORD *)(*(void *)(v141 + 40) + 32);
    if (v142)
    {
      int v143 = 0;
      uint64_t v144 = v118 + 320;
      unint64_t v145 = v117 & 0xFFFFFFFFFFFFFFF8;
      unsigned int v146 = (v117 >> 1) & 3;
      uint64_t v253 = v118 + 320;
      while (1)
      {
        unsigned int v147 = v143 | 0x80000000;
        if (v263)
        {
          for (j = v262; j; j = (void *)*j)
          {
            unsigned int v149 = *((_DWORD *)j + 7);
            if (v147 >= v149)
            {
              if (v149 >= v147) {
                goto LABEL_273;
              }
              ++j;
            }
          }
        }
        else if (v259)
        {
          unint64_t v150 = v258;
          uint64_t v151 = 4 * v259;
          while (*v150 != v147)
          {
            ++v150;
            v151 -= 4;
            if (!v151) {
              goto LABEL_215;
            }
          }
          if (v151) {
            goto LABEL_273;
          }
        }
LABEL_215:
        if ((v143 & 0x7FFFFFFFu) >= *(_DWORD *)(v120 + 416)) {
          goto LABEL_273;
        }
        uint64_t v152 = *(void *)(*(void *)(v120 + 408) + 8 * (v143 & 0x7FFFFFFF));
        if (!v152) {
          goto LABEL_273;
        }
        unsigned int v153 = *(_DWORD *)(v152 + 8);
        int v154 = *(char **)v152;
        if (!v153) {
          break;
        }
        uint64_t v155 = *(void *)&v154[24 * v153 - 16];
        unsigned int v156 = *(_DWORD *)(v145 + 24) | v146;
        unsigned int v157 = (v155 >> 1) & 3 | *(_DWORD *)((v155 & 0xFFFFFFFFFFFFFFF8) + 24);
        uint64_t v158 = *(char **)v152;
        unint64_t v159 = *(unsigned int *)(v152 + 8);
        if (v156 >= v157)
        {
          unint64_t v164 = *(unsigned int *)(v152 + 8);
LABEL_228:
          uint64_t v158 = &v154[24 * v164];
          goto LABEL_229;
        }
        do
        {
          unint64_t v160 = v159 >> 1;
          uint64_t v161 = *(void *)&v158[24 * (v159 >> 1) + 8];
          LODWORD(v161) = (v161 >> 1) & 3 | *(_DWORD *)((v161 & 0xFFFFFFFFFFFFFFF8) + 24);
          v159 -= (v159 >> 1) + 1;
          BOOL v162 = v156 >= v161;
          if (v156 >= v161) {
            unint64_t v163 = v160 + 1;
          }
          else {
            unint64_t v163 = 0;
          }
          v158 += 24 * v163;
          if (!v162) {
            unint64_t v159 = v160;
          }
        }
        while (v159);
        unint64_t v164 = *(unsigned int *)(v152 + 8);
LABEL_229:
        int v165 = &v154[24 * v164];
        if (v158 == v165) {
          goto LABEL_273;
        }
        unsigned int v166 = (*(void *)v158 >> 1) & 3 | *(_DWORD *)((*(void *)v158 & 0xFFFFFFFFFFFFFFF8) + 24);
        unsigned int v167 = *(_DWORD *)(v145 + 24) | v146;
        if (v166 > v167) {
          goto LABEL_273;
        }
        v168 = &v154[24 * v164];
        if (!v153)
        {
          if (v240 == v144) {
            goto LABEL_273;
          }
LABEL_255:
          uint64_t v190 = *((void *)v168 + 1);
          if (*(void *)v168 == v246)
          {
            if (v190 == v248)
            {
              if (v165 != v168 + 24)
              {
                memmove(v168, v168 + 24, v165 - (v168 + 24));
                uint64_t v144 = v253;
                unsigned int v153 = *(_DWORD *)(v152 + 8);
              }
              *(_DWORD *)(v152 + 8) = v153 - 1;
            }
            else
            {
              *(void *)v168 = v248;
            }
            goto LABEL_273;
          }
          uint64_t v196 = *((void *)v168 + 2);
          *((void *)v168 + 1) = v246;
          if (v190 != v248)
          {
            v257[0] = v248;
            v257[1] = v190;
            v257[2] = v196;
            sub_1CC2FC960((uint64_t *)v152, (unint64_t)(v168 + 24), (unint64_t)v257);
LABEL_272:
            uint64_t v144 = v253;
            goto LABEL_273;
          }
          goto LABEL_273;
        }
        uint64_t v169 = *(void *)(*(void *)(*(void *)(v120 + 288) + 392) + 16 * *(unsigned int *)(v111 + 24));
        unint64_t v170 = v169 & 0xFFFFFFFFFFFFFFF8;
        int v171 = *(_DWORD *)((v169 & 0xFFFFFFFFFFFFFFF8) + 24);
        unsigned int v172 = (v169 >> 1) & 3;
        unsigned int v173 = v171 | v172;
        if (v173 >= ((*((void *)v165 - 2) >> 1) & 3 | *(_DWORD *)((*((void *)v165 - 2) & 0xFFFFFFFFFFFFFFF8)
                                                                                 + 24)))
          goto LABEL_246;
        uint64_t v174 = *(char **)v152;
        unint64_t v175 = v164;
        do
        {
          unint64_t v176 = v175 >> 1;
          uint64_t v177 = *(void *)&v174[24 * (v175 >> 1) + 8];
          LODWORD(v177) = (v177 >> 1) & 3 | *(_DWORD *)((v177 & 0xFFFFFFFFFFFFFFF8) + 24);
          v175 -= (v175 >> 1) + 1;
          BOOL v178 = v173 >= v177;
          if (v173 >= v177) {
            unint64_t v179 = v176 + 1;
          }
          else {
            unint64_t v179 = 0;
          }
          v174 += 24 * v179;
          if (!v178) {
            unint64_t v175 = v176;
          }
        }
        while (v175);
        if (v174 == v165) {
          goto LABEL_246;
        }
        unsigned int v180 = (*(void *)v174 >> 1) & 3 | *(_DWORD *)((*(void *)v174 & 0xFFFFFFFFFFFFFFF8) + 24);
        unsigned int v181 = *(_DWORD *)(v170 + 24) | v172;
        BOOL v182 = v180 > v181;
        BOOL v183 = v180 <= v181;
        if (!v182 && v240 == v144)
        {
          if (v167 >= ((*((void *)v165 - 2) >> 1) & 3 | *(_DWORD *)((*((void *)v165 - 2) & 0xFFFFFFFFFFFFFFF8)
                                                                                   + 24)))
            goto LABEL_267;
          do
          {
            unint64_t v191 = v164 >> 1;
            uint64_t v192 = *(void *)&v154[24 * (v164 >> 1) + 8];
            LODWORD(v192) = (v192 >> 1) & 3 | *(_DWORD *)((v192 & 0xFFFFFFFFFFFFFFF8) + 24);
            v164 -= (v164 >> 1) + 1;
            BOOL v193 = v167 >= v192;
            if (v167 >= v192) {
              unint64_t v194 = v191 + 1;
            }
            else {
              unint64_t v194 = 0;
            }
            v154 += 24 * v194;
            if (!v193) {
              unint64_t v164 = v191;
            }
          }
          while (v164);
          if (v154 == v165
            || ((*(void *)v154 >> 1) & 3 | *(_DWORD *)((*(void *)v154 & 0xFFFFFFFFFFFFFFF8) + 24)) > v167)
          {
LABEL_267:
            uint64_t v195 = 0;
          }
          else
          {
            uint64_t v195 = *((void *)v154 + 2);
          }
          v254[0] = v246;
          v254[1] = v248;
          v254[2] = v195;
          llvm::LiveRange::addSegment(v152, (uint64_t)v254);
          goto LABEL_272;
        }
        if (!v183)
        {
LABEL_246:
          if (v240 != v144)
          {
            unsigned int v185 = *(_DWORD *)(v235 + 24) | v236;
            if (v185 < ((*((void *)v165 - 2) >> 1) & 3 | *(_DWORD *)((*((void *)v165 - 2) & 0xFFFFFFFFFFFFFFF8)
                                                                                    + 24)))
            {
              v168 = *(char **)v152;
              do
              {
                unint64_t v186 = v164 >> 1;
                uint64_t v187 = *(void *)&v168[24 * (v164 >> 1) + 8];
                LODWORD(v187) = (v187 >> 1) & 3 | *(_DWORD *)((v187 & 0xFFFFFFFFFFFFFFF8) + 24);
                v164 -= (v164 >> 1) + 1;
                BOOL v188 = v185 >= v187;
                if (v185 >= v187) {
                  unint64_t v189 = v186 + 1;
                }
                else {
                  unint64_t v189 = 0;
                }
                v168 += 24 * v189;
                if (!v188) {
                  unint64_t v164 = v186;
                }
              }
              while (v164);
            }
            goto LABEL_255;
          }
        }
LABEL_273:
        if (++v143 == v142) {
          goto LABEL_281;
        }
      }
      unint64_t v164 = 0;
      goto LABEL_228;
    }
LABEL_281:
    uint64_t v197 = v120;
    uint64_t v91 = (uint64_t)v250;
    FirstTerminator = (_WORD *)llvm::MachineBasicBlock::getFirstTerminator(v250);
    llvm::LiveIntervals::repairIntervalsInRange(v197, v91, FirstTerminator, (unsigned char *)(v91 + 48), v267, v268);
    sub_1CB833A08((uint64_t)&v261, v262);
    if (v258 != v260) {
      free(v258);
    }
  }
  uint64_t v199 = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*(void *)(v112 + 8) + 24), &llvm::MachineDominatorTree::ID, 1);
  if (v199)
  {
    uint64_t v200 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v199 + 96))(v199, &llvm::MachineDominatorTree::ID);
    if (v200) {
      sub_1CD526EF4(v200, v91, v111, v9);
    }
  }
  uint64_t v201 = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*(void *)(v112 + 8) + 24), &llvm::MachineLoopInfo::ID, 1);
  if (v201)
  {
    uint64_t v202 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v201 + 96))(v201, &llvm::MachineLoopInfo::ID);
    if (v202)
    {
      uint64_t v203 = *(void *)(v202 + 248);
      int v204 = *(_DWORD *)(v202 + 264);
      if (v204)
      {
        unsigned int v205 = v204 - 1;
        LODWORD(v206) = v205 & ((v91 >> 4) ^ (v91 >> 9));
        v207 = (uint64_t *)(v203 + 16 * v206);
        uint64_t v208 = *v207;
        if (*v207 == v91)
        {
          v211 = (void *)v207[1];
          if (v211)
          {
LABEL_315:
            uint64_t v219 = v205 & ((v111 >> 4) ^ (v111 >> 9));
            uint64_t v220 = *(void *)(v203 + 16 * v219);
            if (v220 == v111)
            {
LABEL_319:
              uint64_t v223 = *(void **)(v203 + 16 * v219 + 8);
              if (v223)
              {
                if (v211 == v223) {
                  goto LABEL_334;
                }
                uint64_t v224 = v223;
                while (v224)
                {
                  uint64_t v224 = (void *)*v224;
                  if (v224 == v211) {
                    goto LABEL_334;
                  }
                }
                while (v211)
                {
                  v211 = (void *)*v211;
                  if (v211 == v223) {
                    goto LABEL_334;
                  }
                }
                if (*v223) {
LABEL_334:
                }
                  llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::addBasicBlockToLoop();
              }
            }
            else
            {
              int v221 = 1;
              while (v220 != -4096)
              {
                int v222 = v219 + v221++;
                uint64_t v219 = v222 & v205;
                uint64_t v220 = *(void *)(v203 + 16 * v219);
                if (v220 == v111) {
                  goto LABEL_319;
                }
              }
            }
          }
        }
        else
        {
          int v209 = 1;
          while (v208 != -4096)
          {
            int v210 = v206 + v209++;
            uint64_t v206 = v210 & v205;
            uint64_t v208 = *(void *)(v203 + 16 * v206);
            if (v208 == v91)
            {
              v211 = *(void **)(v203 + 16 * v206 + 8);
              if (!v211) {
                break;
              }
              goto LABEL_315;
            }
          }
        }
      }
    }
  }
  if (v264 != v266) {
    free(v264);
  }
  if (v267 != v269) {
    free(v267);
  }
  if (v270 != (_DWORD *)v272) {
    free(v270);
  }
  if (v256)
  {
    int v229 = *v256;
    if ((v229 - 4) > 0x1E)
    {
      if ((v229 - 3) >= 0xFFFFFFFE) {
        uint64_t v232 = v256;
      }
      else {
        uint64_t v232 = 0;
      }
      if ((v229 - 3) >= 0xFFFFFFFE)
      {
        unint64_t v231 = (unint64_t)(v232 + 8);
LABEL_353:
        v258 = &v256;
        sub_1CC5FA668(v231 + 16, &v258);
        return v9;
      }
      if (v229 == 3) {
        *((void *)v256 + 1) = 0;
      }
    }
    else if ((v256[1] & 0x7F) == 2 || *((_DWORD *)v256 + 3))
    {
      uint64_t v230 = *((void *)v256 + 2);
      if ((v230 & 4) != 0)
      {
        unint64_t v231 = v230 & 0xFFFFFFFFFFFFFFF8;
        if (v231) {
          goto LABEL_353;
        }
      }
    }
  }
  return v9;
}

uint64_t llvm::MachineBasicBlock::canSplitCriticalEdge(llvm::MachineBasicBlock *this, const llvm::MachineBasicBlock *a2)
{
  v12[16] = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)a2 + 184)) {
    return 0;
  }
  if (*((unsigned char *)a2 + 202)) {
    return 0;
  }
  uint64_t v2 = *((void *)this + 4);
  if (*(unsigned char *)(*(void *)(v2 + 8) + 592)) {
    return 0;
  }
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(v2 + 16) + 104))(*(void *)(v2 + 16));
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  v11[0] = v12;
  v11[1] = (void *)0x400000000;
  char v6 = (*(uint64_t (**)(uint64_t, llvm::MachineBasicBlock *, uint64_t *, uint64_t *, void **, void))(*(void *)v5 + 248))(v5, this, &v10, &v9, v11, 0);
  uint64_t v7 = 0;
  if ((v6 & 1) == 0)
  {
    if (v10) {
      BOOL v8 = v10 == v9;
    }
    else {
      BOOL v8 = 0;
    }
    uint64_t v7 = !v8;
  }
  if (v11[0] != v12) {
    free(v11[0]);
  }
  return v7;
}

uint64_t llvm::MachineBasicBlock::erase(uint64_t a1, uint64_t a2)
{
  sub_1CC319554(a2);

  return sub_1CC3195AC(a1 + 40, a2);
}

uint64_t sub_1CC319554(uint64_t result)
{
  __int16 v1 = *(_WORD *)(result + 44);
  if ((v1 & 0xC) == 8)
  {
    *(_WORD *)(result + 44) = v1 & 0xFFF7;
    *(_WORD *)(*(void *)(result + 8) + 44) &= ~4u;
    __int16 v1 = *(_WORD *)(result + 44);
  }
  if ((v1 & 0xC) == 4)
  {
    *(_WORD *)(result + 44) = v1 & 0xFFFB;
    *(_WORD *)((*(void *)result & 0xFFFFFFFFFFFFFFF8) + 44) &= ~8u;
  }
  return result;
}

uint64_t sub_1CC3195AC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(*(void *)(a2 + 24) + 32);
  if (v5)
  {
    uint64_t v6 = *(void *)(v5 + 728);
    if (v6) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 32))(v6, a2);
    }
    uint64_t v7 = *(unsigned int *)(a2 + 40);
    if (v7)
    {
      uint64_t v8 = *(void *)(a2 + 32);
      uint64_t v9 = *(void *)(v5 + 40);
      uint64_t v10 = 32 * v7;
      do
      {
        if (!*(unsigned char *)v8)
        {
          uint64_t v11 = *(unsigned int *)(v8 + 4);
          if ((v11 & 0x80000000) != 0) {
            int v12 = (uint64_t *)(*(void *)(v9 + 24) + 16 * (v11 & 0x7FFFFFFF) + 8);
          }
          else {
            int v12 = (uint64_t *)(*(void *)(v9 + 272) + 8 * v11);
          }
          uint64_t v13 = *v12;
          uint64_t v15 = *(void *)(v8 + 16);
          uint64_t v14 = *(void *)(v8 + 24);
          if (v8 != *v12) {
            int v12 = (uint64_t *)(v15 + 24);
          }
          *int v12 = v14;
          if (v14) {
            uint64_t v16 = v14;
          }
          else {
            uint64_t v16 = v13;
          }
          *(void *)(v16 + 16) = v15;
          *(void *)(v8 + 16) = 0;
          *(void *)(v8 + 24) = 0;
        }
        v8 += 32;
        v10 -= 32;
      }
      while (v10);
    }
  }
  *(void *)(a2 + 24) = 0;
  unint64_t v17 = *(unint64_t **)(a2 + 8);
  unint64_t v18 = *(void *)a2 & 0xFFFFFFFFFFFFFFF8;
  unint64_t *v17 = v18 | *v17 & 7;
  *(void *)(v18 + 8) = v17;
  *(void *)a2 &= 7uLL;
  *(void *)(a2 + 8) = 0;
  uint64_t v19 = *(void *)(*(void *)a1 + 32);
  char v20 = *(void **)(a2 + 32);
  if (v20)
  {
    uint64_t v21 = *(unsigned __int8 *)(a2 + 47);
    uint64_t v22 = (uint64_t *)(v19 + 232);
    if (*(_DWORD *)(v19 + 240) <= v21) {
      sub_1CC34BDE0(v19 + 232, v21 + 1);
    }
    uint64_t v23 = *v22;
    *char v20 = *(void *)(*v22 + 8 * v21);
    *(void *)(v23 + 8 * v21) = v20;
  }
  *(void *)a2 = *(void *)(v19 + 224);
  *(void *)(v19 + 224) = a2;
  return v4;
}

uint64_t llvm::MachineBasicBlock::insert(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 + 48 != a2 && (*(_WORD *)(a2 + 44) & 4) != 0) {
    *(_WORD *)(a3 + 44) |= 0xCu;
  }
  return sub_1CC31973C((uint64_t *)(a1 + 40), (uint64_t *)a2, a3);
}

uint64_t sub_1CC31973C(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = *a1;
  *(void *)(a3 + 24) = *a1;
  uint64_t v6 = *(void *)(v5 + 32);
  llvm::MachineInstr::addRegOperandsToUseLists(a3, *(void *)(v6 + 40));
  uint64_t v7 = *(void *)(v6 + 728);
  if (v7) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 24))(v7, a3);
  }
  unint64_t v8 = *a2 & 0xFFFFFFFFFFFFFFF8;
  *(void *)a3 = v8 | *(void *)a3 & 7;
  *(void *)(a3 + 8) = a2;
  *(void *)(v8 + 8) = a3;
  *a2 = *a2 & 7 | a3;
  return a3;
}

uint64_t *llvm::MachineBasicBlock::removeFromParent(uint64_t *this)
{
  *(void *)(*(void *)(this[4] + 104) + 8 * *((unsigned int *)this + 6)) = 0;
  *((_DWORD *)this + 6) = -1;
  uint64_t v1 = *this;
  uint64_t v2 = (void *)this[1];
  *uint64_t v2 = *this;
  *(void *)(v1 + 8) = v2;
  *this = 0;
  this[1] = 0;
  return this;
}

void llvm::MachineBasicBlock::eraseFromParent(llvm::MachineBasicBlock *this)
{
  uint64_t v2 = *((void *)this + 4);
  int v3 = v2 + 320;
  *(void *)(*(void *)(v2 + 104) + 8 * *((unsigned int *)this + 6)) = 0;
  *((_DWORD *)this + 6) = -1;
  uint64_t v4 = *(void *)this;
  uint64_t v5 = (void *)*((void *)this + 1);
  *uint64_t v5 = *(void *)this;
  *(void *)(v4 + 8) = v5;
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  llvm::ilist_alloc_traits<llvm::MachineBasicBlock>::deleteNode(v3, this);
}

uint64_t llvm::MachineBasicBlock::findDebugLoc@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, unsigned __int8 **a3@<X8>)
{
  if (result + 48 == a2)
  {
LABEL_10:
    *a3 = 0;
  }
  else
  {
    while (1)
    {
      unsigned int v3 = **(unsigned __int16 **)(a2 + 16);
      BOOL v4 = v3 > 0x17;
      int v5 = (1 << v3) & 0x83E000;
      if (v4 || v5 == 0) {
        break;
      }
      a2 = *(void *)(a2 + 8);
      if (a2 == result + 48) {
        goto LABEL_10;
      }
    }
    uint64_t v7 = *(unsigned __int8 **)(a2 + 56);
    *a3 = v7;
    if (v7) {
      return llvm::MetadataTracking::track((uint64_t)a3, v7, 2);
    }
  }
  return result;
}

uint64_t llvm::MachineBasicBlock::rfindDebugLoc@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, unsigned __int8 **a3@<X8>)
{
  unint64_t v3 = *(void *)(result + 48) & 0xFFFFFFFFFFFFFFF8;
  if (a2 != v3)
  {
    while (1)
    {
      int v4 = **(unsigned __int16 **)(a2 + 16);
      if ((v4 - 13) >= 5 && v4 != 23) {
        break;
      }
      a2 = *(void *)(a2 + 8);
      if (a2 == v3)
      {
        a2 = *(void *)(result + 48) & 0xFFFFFFFFFFFFFFF8;
        break;
      }
    }
  }
  if (**(unsigned __int16 **)(a2 + 16) - 13 >= 5)
  {
    uint64_t v6 = *(unsigned __int8 **)(a2 + 56);
    *a3 = v6;
    if (v6) {
      return llvm::MetadataTracking::track((uint64_t)a3, v6, 2);
    }
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

uint64_t llvm::MachineBasicBlock::findPrevDebugLoc@<X0>(uint64_t result@<X0>, uint64_t *a2@<X1>, unsigned __int8 **a3@<X8>)
{
  unint64_t v3 = *(void *)(result + 56);
  if ((uint64_t *)v3 == a2) {
    goto LABEL_11;
  }
  for (uint64_t i = *a2; ; uint64_t i = *(void *)v5)
  {
    unint64_t v5 = i & 0xFFFFFFFFFFFFFFF8;
    if (v3 == v5) {
      break;
    }
    int v6 = **(unsigned __int16 **)(v5 + 16);
    if ((v6 - 13) >= 5 && v6 != 23)
    {
      unint64_t v3 = v5;
      break;
    }
  }
  if (**(unsigned __int16 **)(v3 + 16) - 13 < 5)
  {
LABEL_11:
    *a3 = 0;
  }
  else
  {
    unint64_t v8 = *(unsigned __int8 **)(v3 + 56);
    *a3 = v8;
    if (v8) {
      return llvm::MetadataTracking::track((uint64_t)a3, v8, 2);
    }
  }
  return result;
}

uint64_t llvm::MachineBasicBlock::rfindPrevDebugLoc@<X0>(uint64_t result@<X0>, uint64_t *a2@<X1>, unsigned __int8 **a3@<X8>)
{
  if ((uint64_t *)(result + 48) != a2)
  {
    for (uint64_t i = *a2; ; uint64_t i = *(void *)v4)
    {
      unint64_t v4 = i & 0xFFFFFFFFFFFFFFF8;
      if (result + 48 == v4) {
        break;
      }
      int v5 = **(unsigned __int16 **)(v4 + 16);
      if ((v5 - 13) >= 5 && v5 != 23)
      {
        uint64_t v7 = *(unsigned __int8 **)(v4 + 56);
        *a3 = v7;
        if (v7) {
          return llvm::MetadataTracking::track((uint64_t)a3, v7, 2);
        }
        return result;
      }
    }
  }
  *a3 = 0;
  return result;
}

uint64_t llvm::MachineBasicBlock::computeRegisterLiveness(void *a1, uint64_t a2, unsigned int a3, void *a4, int a5)
{
  int v5 = a5;
  unint64_t v6 = (unint64_t)a4;
  uint64_t v10 = a1 + 6;
  BOOL v11 = a1 + 6 == a4 || a5 == 0;
  unint64_t v12 = (unint64_t)a4;
  if (!v11)
  {
    int v18 = a5;
    unint64_t v12 = (unint64_t)a4;
    do
    {
      int v19 = **(unsigned __int16 **)(v12 + 16);
      if ((v19 - 13) >= 5 && v19 != 23)
      {
        int v22 = llvm::AnalyzePhysRegInBundle(v12, a3, a2);
        if ((v22 & 0x1000000) != 0) {
          return 0;
        }
        if ((*(void *)&v22 & 0x10001) != 0) {
          return 1;
        }
        --v18;
      }
      if ((*(unsigned char *)v12 & 4) == 0)
      {
        while ((*(_WORD *)(v12 + 44) & 8) != 0)
          unint64_t v12 = *(void *)(v12 + 8);
      }
      unint64_t v12 = *(void *)(v12 + 8);
    }
    while ((void *)v12 != v10 && v18 != 0);
  }
  if ((void *)v12 == v10)
  {
    uint64_t v23 = a1[11];
    uint64_t v24 = a1[12];
    if (v23 != v24)
    {
      uint64_t v25 = (void *)(a2 + 8);
      do
      {
        uint64_t v26 = *(unsigned __int16 **)(*(void *)v23 + 152);
        uint64_t v27 = *(unsigned __int16 **)(*(void *)v23 + 160);
        while (v26 != v27)
        {
          unsigned int v28 = *v26;
          if (v28 == a3
            || a3 - 1 <= 0x3FFFFFFE && v28 - 1 <= 0x3FFFFFFE && llvm::MCRegisterInfo::regsOverlap(v25, v28, a3))
          {
            return 0;
          }
          v26 += 8;
        }
        v23 += 8;
        uint64_t result = 1;
      }
      while (v23 != v24);
      return result;
    }
    return 1;
  }
  uint64_t v13 = a1[7];
  if (v13 == v6)
  {
LABEL_77:
    uint64_t v33 = (unsigned __int16 *)a1[19];
    int v34 = (unsigned __int16 *)a1[20];
    if (v33 != v34)
    {
      unint64_t v35 = (void *)(a2 + 8);
      while (1)
      {
        unsigned int v36 = *v33;
        if (v36 == a3
          || a3 - 1 <= 0x3FFFFFFE && v36 - 1 <= 0x3FFFFFFE && llvm::MCRegisterInfo::regsOverlap(v35, v36, a3))
        {
          break;
        }
        v33 += 8;
        if (v33 == v34) {
          return 1;
        }
      }
      return 0;
    }
    return 1;
  }
  while (1)
  {
    unint64_t v6 = *(void *)v6 & 0xFFFFFFFFFFFFFFF8;
    if (!v6 || (*(unsigned char *)v6 & 4) == 0)
    {
      while ((*(_WORD *)(v6 + 44) & 4) != 0)
        unint64_t v6 = *(void *)v6 & 0xFFFFFFFFFFFFFFF8;
    }
    int v14 = **(unsigned __int16 **)(v6 + 16);
    if ((v14 - 13) < 5 || v14 == 23) {
      goto LABEL_18;
    }
    unint64_t v17 = llvm::AnalyzePhysRegInBundle(v6, a3, a2);
    if ((v17 & 0x10000000000) != 0) {
      return 1;
    }
    if ((v17 & 0x100) != 0) {
      break;
    }
    if ((v17 & 0x100000000000001) != 0) {
      return 1;
    }
    if ((v17 & 0x1000000) != 0) {
      return 0;
    }
    --v5;
    uint64_t v13 = a1[7];
LABEL_18:
    if (v6 == v13 || v5 == 0)
    {
      while (1)
      {
LABEL_76:
        if (v6 == v13) {
          goto LABEL_77;
        }
        unint64_t v6 = *(void *)v6 & 0xFFFFFFFFFFFFFFF8;
        if (!v6) {
          break;
        }
        unint64_t v30 = v6;
        if ((*(unsigned char *)v6 & 4) == 0) {
          goto LABEL_65;
        }
LABEL_66:
        int v31 = **(unsigned __int16 **)(v30 + 16);
        if ((v31 - 13) >= 5 && v31 != 23) {
          return 2;
        }
        if (!v6 || (*(unsigned char *)v6 & 4) == 0)
        {
          while ((*(_WORD *)(v6 + 44) & 4) != 0)
            unint64_t v6 = *(void *)v6 & 0xFFFFFFFFFFFFFFF8;
        }
      }
      unint64_t v30 = 0;
LABEL_65:
      while ((*(_WORD *)(v30 + 44) & 4) != 0)
        unint64_t v30 = *(void *)v30 & 0xFFFFFFFFFFFFFFF8;
      goto LABEL_66;
    }
  }
  if ((v17 & 0x1000000000000) != 0)
  {
    uint64_t v13 = a1[7];
    goto LABEL_76;
  }
  return 0;
}

uint64_t llvm::MachineBasicBlock::getBeginClobberMask(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 189)) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 56))(a2);
  }
  else {
    return 0;
  }
}

uint64_t llvm::MachineBasicBlock::getEndClobberMask(void *a1, uint64_t a2)
{
  unint64_t v2 = a1[6] & 0xFFFFFFFFFFFFFFF8;
  if (a1 + 6 == (void *)v2) {
    return 0;
  }
  if (v2 && (*(unsigned char *)v2 & 4) != 0)
  {
    __int16 v3 = *(_WORD *)(v2 + 44);
  }
  else
  {
    while (1)
    {
      __int16 v3 = *(_WORD *)(v2 + 44);
      if ((v3 & 4) == 0) {
        break;
      }
      unint64_t v2 = *(void *)v2 & 0xFFFFFFFFFFFFFFF8;
    }
  }
  int v4 = v3 & 0xC;
  int v5 = v3 & 4;
  uint64_t v6 = *(void *)(*(void *)(v2 + 16) + 8);
  if (v4) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7)
  {
    if ((v6 & 0x20) == 0)
    {
      while ((*(_WORD *)(v2 + 44) & 8) != 0)
      {
        unint64_t v2 = *(void *)(v2 + 8);
        if ((*(unsigned char *)(*(void *)(v2 + 16) + 8) & 0x20) != 0) {
          goto LABEL_16;
        }
      }
      return 0;
    }
  }
  else if ((v6 & 0x20) == 0)
  {
    return 0;
  }
LABEL_16:
  if (a1[11] == a1[12]) {
    return 0;
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 56))(a2);
}

uint64_t llvm::MachineBasicBlock::livein_begin(llvm::MachineBasicBlock *this)
{
  return *((void *)this + 19);
}

uint64_t sub_1CC319DC8(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  unint64_t v8 = (uint64_t *)result;
LABEL_2:
  uint64_t v9 = a2 - 2;
LABEL_3:
  for (uint64_t i = 1 - a4; ; ++i)
  {
    uint64_t v11 = (char *)a2 - (char *)v8;
    unint64_t v12 = ((char *)a2 - (char *)v8) >> 4;
    if (v12 < 2) {
      break;
    }
    if (v12 <= 2)
    {
      switch(v12)
      {
        case 2uLL:
          uint64_t v22 = *v8;
          if (((*v9 >> 1) & 3 | *(_DWORD *)((*v9 & 0xFFFFFFFFFFFFFFF8) + 24)) < (*(_DWORD *)((*v8 & 0xFFFFFFFFFFFFFFF8) + 24) | (*v8 >> 1) & 3))
          {
            uint64_t v23 = v8[1];
            uint64_t v24 = *(a2 - 1);
            *unint64_t v8 = *v9;
            v8[1] = v24;
            *(a2 - 2) = v22;
            *(a2 - 1) = v23;
          }
          break;
        case 3uLL:
          uint64_t result = sub_1CC31A314(v8, v8 + 2, a2 - 2);
          break;
        case 4uLL:
          uint64_t result = sub_1CC31A864(v8, v8 + 2, v8 + 4, a2 - 2);
          break;
        case 5uLL:
          uint64_t result = sub_1CC31A968(v8, v8 + 2, v8 + 4, v8 + 6, a2 - 2);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v11 <= 383)
    {
      if (a5)
      {
        return (uint64_t)sub_1CC31A1C4(v8, a2);
      }
      else
      {
        return (uint64_t)sub_1CC31A278(v8, a2);
      }
    }
    if (i == 1)
    {
      if (v8 != a2)
      {
        return (uint64_t)sub_1CC31AABC((char *)v8, (char *)a2, (char *)a2, a3);
      }
      return result;
    }
    unint64_t v13 = v12 >> 1;
    int v14 = &v8[2 * (v12 >> 1)];
    if ((unint64_t)v11 >= 0x801)
    {
      sub_1CC31A314(v8, &v8[2 * (v12 >> 1)], a2 - 2);
      sub_1CC31A314(v8 + 2, v14 - 2, a2 - 4);
      sub_1CC31A314(v8 + 4, &v8[2 * v13 + 2], a2 - 6);
      sub_1CC31A314(v14 - 2, v14, &v8[2 * v13 + 2]);
      uint64_t v19 = *v8;
      uint64_t v20 = v8[1];
      uint64_t v21 = v14[1];
      *unint64_t v8 = *v14;
      v8[1] = v21;
      *int v14 = v19;
      v14[1] = v20;
    }
    else
    {
      sub_1CC31A314(&v8[2 * (v12 >> 1)], v8, a2 - 2);
    }
    if ((a5 & 1) != 0
      || ((*(v8 - 2) >> 1) & 3 | *(_DWORD *)((*(v8 - 2) & 0xFFFFFFFFFFFFFFF8) + 24)) < (*(_DWORD *)((*v8 & 0xFFFFFFFFFFFFFFF8) + 24) | (*v8 >> 1) & 3))
    {
      uint64_t v15 = sub_1CC31A550(v8, a2);
      if ((v16 & 1) == 0) {
        goto LABEL_43;
      }
      BOOL v17 = sub_1CC31A670(v8, v15);
      int v18 = v15 + 2;
      uint64_t result = sub_1CC31A670(v15 + 2, a2);
      if (result)
      {
        a4 = -i;
        a2 = v15;
        if (!v17) {
          goto LABEL_2;
        }
        return result;
      }
      if (!v17)
      {
LABEL_43:
        uint64_t result = sub_1CC319DC8(v8, v15, a3, -i, a5 & 1);
        a4 = -i;
        a5 = 0;
        unint64_t v8 = v15 + 2;
        goto LABEL_3;
      }
    }
    else
    {
      uint64_t result = (uint64_t)sub_1CC31A424(v8, a2);
      int v18 = (uint64_t *)result;
    }
    unint64_t v8 = v18;
  }
  return result;
}

uint64_t *sub_1CC31A1C4(uint64_t *result, uint64_t *a2)
{
  if (result != a2)
  {
    unint64_t v2 = result + 2;
    if (result + 2 != a2)
    {
      uint64_t v3 = 0;
      int v4 = result;
      do
      {
        int v5 = v2;
        uint64_t v6 = *v4;
        uint64_t v7 = v4[2];
        unsigned int v8 = (v7 >> 1) & 3 | *(_DWORD *)((v7 & 0xFFFFFFFFFFFFFFF8) + 24);
        if (v8 < (*(_DWORD *)((*v4 & 0xFFFFFFFFFFFFFFF8) + 24) | (*v4 >> 1) & 3))
        {
          uint64_t v9 = v4[3];
          uint64_t v10 = v3;
          while (1)
          {
            uint64_t v11 = (char *)result + v10;
            uint64_t v12 = *(uint64_t *)((char *)result + v10 + 8);
            *((void *)v11 + 2) = v6;
            *((void *)v11 + 3) = v12;
            if (!v10) {
              break;
            }
            uint64_t v6 = *((void *)v11 - 2);
            v10 -= 16;
            if (v8 >= ((v6 >> 1) & 3 | *(_DWORD *)((v6 & 0xFFFFFFFFFFFFFFF8) + 24)))
            {
              unint64_t v13 = (uint64_t *)((char *)result + v10 + 16);
              goto LABEL_10;
            }
          }
          unint64_t v13 = result;
LABEL_10:
          *unint64_t v13 = v7;
          v13[1] = v9;
        }
        unint64_t v2 = v5 + 2;
        v3 += 16;
        int v4 = v5;
      }
      while (v5 + 2 != a2);
    }
  }
  return result;
}

uint64_t *sub_1CC31A278(uint64_t *result, uint64_t *a2)
{
  if (result != a2)
  {
    unint64_t v2 = result + 2;
    if (result + 2 != a2)
    {
      uint64_t v3 = result + 3;
      do
      {
        int v4 = v2;
        uint64_t v5 = *result;
        uint64_t v6 = result[2];
        unsigned int v7 = (v6 >> 1) & 3 | *(_DWORD *)((v6 & 0xFFFFFFFFFFFFFFF8) + 24);
        if (v7 < (*(_DWORD *)((*result & 0xFFFFFFFFFFFFFFF8) + 24) | (*result >> 1) & 3))
        {
          uint64_t v8 = result[3];
          uint64_t v9 = v3;
          do
          {
            uint64_t v10 = v9;
            *(v9 - 1) = v5;
            uint64_t v11 = *(v9 - 2);
            v9 -= 2;
            *uint64_t v10 = v11;
            uint64_t v5 = *(v10 - 5);
          }
          while (v7 < ((v5 >> 1) & 3 | *(_DWORD *)((v5 & 0xFFFFFFFFFFFFFFF8) + 24)));
          *(v9 - 1) = v6;
          *uint64_t v9 = v8;
        }
        unint64_t v2 = v4 + 2;
        v3 += 2;
        uint64_t result = v4;
      }
      while (v4 + 2 != a2);
    }
  }
  return result;
}

uint64_t sub_1CC31A314(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *a2;
  unsigned int v5 = (*a2 >> 1) & 3 | *(_DWORD *)((*a2 & 0xFFFFFFFFFFFFFFF8) + 24);
  unsigned int v6 = *(_DWORD *)((*a1 & 0xFFFFFFFFFFFFFFF8) + 24) | (*a1 >> 1) & 3;
  uint64_t v7 = *a3;
  unsigned int v8 = (*a3 >> 1) & 3 | *(_DWORD *)((*a3 & 0xFFFFFFFFFFFFFFF8) + 24);
  if (v5 < v6)
  {
    if (v8 < v5)
    {
      uint64_t v9 = a1[1];
      uint64_t v10 = a3[1];
      *a1 = v7;
      a1[1] = v10;
      *a3 = v3;
      a3[1] = v9;
      return 1;
    }
    uint64_t v16 = a1[1];
    uint64_t v17 = a2[1];
    *a1 = v4;
    a1[1] = v17;
    *a2 = v3;
    a2[1] = v16;
    if (((*a3 >> 1) & 3 | *(_DWORD *)((*a3 & 0xFFFFFFFFFFFFFFF8) + 24)) >= v6) {
      return 1;
    }
    uint64_t v18 = a3[1];
    *a2 = *a3;
    a2[1] = v18;
    *a3 = v3;
    a3[1] = v16;
    return 2;
  }
  if (v8 < v5)
  {
    *a2 = v7;
    *a3 = v4;
    uint64_t v11 = *a2;
    uint64_t v12 = a2[1];
    a2[1] = a3[1];
    a3[1] = v12;
    uint64_t v13 = *a1;
    if (((v11 >> 1) & 3 | *(_DWORD *)((v11 & 0xFFFFFFFFFFFFFFF8) + 24)) >= (*(_DWORD *)((*a1 & 0xFFFFFFFFFFFFFFF8) + 24) | (*a1 >> 1) & 3)) {
      return 1;
    }
    uint64_t v14 = a1[1];
    uint64_t v15 = a2[1];
    *a1 = v11;
    a1[1] = v15;
    *a2 = v13;
    a2[1] = v14;
    return 2;
  }
  return 0;
}

uint64_t *sub_1CC31A424(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  unsigned int v3 = *(_DWORD *)((*a1 & 0xFFFFFFFFFFFFFFF8) + 24) | (*a1 >> 1) & 3;
  if (v3 >= ((*(a2 - 2) >> 1) & 3 | *(_DWORD *)((*(a2 - 2) & 0xFFFFFFFFFFFFFFF8) + 24)))
  {
    unsigned int v6 = a1 + 2;
    do
    {
      uint64_t v4 = v6;
      if (v6 >= a2) {
        break;
      }
      v6 += 2;
    }
    while (v3 >= ((*v4 >> 1) & 3 | *(_DWORD *)((*v4 & 0xFFFFFFFFFFFFFFF8) + 24)));
  }
  else
  {
    uint64_t v4 = a1;
    do
    {
      uint64_t v5 = v4[2];
      v4 += 2;
    }
    while (v3 >= ((v5 >> 1) & 3 | *(_DWORD *)((v5 & 0xFFFFFFFFFFFFFFF8) + 24)));
  }
  if (v4 < a2)
  {
    do
    {
      uint64_t v7 = *(a2 - 2);
      a2 -= 2;
    }
    while (v3 < ((v7 >> 1) & 3 | *(_DWORD *)((v7 & 0xFFFFFFFFFFFFFFF8) + 24)));
  }
  uint64_t v8 = a1[1];
  if (v4 < a2)
  {
    uint64_t v9 = *v4;
    uint64_t v10 = *a2;
    do
    {
      uint64_t v11 = v4[1];
      uint64_t v12 = a2[1];
      *uint64_t v4 = v10;
      v4[1] = v12;
      *a2 = v9;
      a2[1] = v11;
      do
      {
        uint64_t v13 = v4[2];
        v4 += 2;
        uint64_t v9 = v13;
      }
      while (v3 >= ((v13 >> 1) & 3 | *(_DWORD *)((v13 & 0xFFFFFFFFFFFFFFF8) + 24)));
      do
      {
        uint64_t v14 = *(a2 - 2);
        a2 -= 2;
        uint64_t v10 = v14;
      }
      while (v3 < ((v14 >> 1) & 3 | *(_DWORD *)((v14 & 0xFFFFFFFFFFFFFFF8) + 24)));
    }
    while (v4 < a2);
  }
  if (v4 - 2 != a1)
  {
    uint64_t v15 = *(v4 - 1);
    *a1 = *(v4 - 2);
    a1[1] = v15;
  }
  *(v4 - 2) = v2;
  *(v4 - 1) = v8;
  return v4;
}

uint64_t *sub_1CC31A550(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  unsigned int v5 = (*a1 >> 1) & 3 | *(_DWORD *)((*a1 & 0xFFFFFFFFFFFFFFF8) + 24);
  do
  {
    uint64_t v6 = a1[v2 + 2];
    v2 += 2;
  }
  while (((v6 >> 1) & 3 | *(_DWORD *)((v6 & 0xFFFFFFFFFFFFFFF8) + 24)) < v5);
  uint64_t v7 = &a1[v2];
  if (v2 == 2)
  {
    do
    {
      if (v7 >= a2) {
        break;
      }
      uint64_t v9 = *(a2 - 2);
      a2 -= 2;
    }
    while (((v9 >> 1) & 3 | *(_DWORD *)((v9 & 0xFFFFFFFFFFFFFFF8) + 24)) >= v5);
  }
  else
  {
    do
    {
      uint64_t v8 = *(a2 - 2);
      a2 -= 2;
    }
    while (((v8 >> 1) & 3 | *(_DWORD *)((v8 & 0xFFFFFFFFFFFFFFF8) + 24)) >= v5);
  }
  if (v7 >= a2)
  {
    uint64_t v11 = &a1[v2];
  }
  else
  {
    uint64_t v10 = *a2;
    uint64_t v11 = &a1[v2];
    uint64_t v12 = a2;
    do
    {
      uint64_t v13 = v11[1];
      uint64_t v14 = v12[1];
      *uint64_t v11 = v10;
      v11[1] = v14;
      *uint64_t v12 = v6;
      v12[1] = v13;
      do
      {
        uint64_t v15 = v11[2];
        v11 += 2;
        uint64_t v6 = v15;
      }
      while (((v15 >> 1) & 3 | *(_DWORD *)((v15 & 0xFFFFFFFFFFFFFFF8) + 24)) < v5);
      do
      {
        uint64_t v16 = *(v12 - 2);
        v12 -= 2;
        uint64_t v10 = v16;
      }
      while (((v16 >> 1) & 3 | *(_DWORD *)((v16 & 0xFFFFFFFFFFFFFFF8) + 24)) >= v5);
    }
    while (v11 < v12);
  }
  if (v11 - 2 != a1)
  {
    uint64_t v17 = *(v11 - 1);
    *a1 = *(v11 - 2);
    a1[1] = v17;
  }
  *(v11 - 2) = v3;
  *(v11 - 1) = v4;
  return v11 - 2;
}

BOOL sub_1CC31A670(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *a1;
      uint64_t v7 = *(a2 - 2);
      if (((v7 >> 1) & 3 | *(_DWORD *)((v7 & 0xFFFFFFFFFFFFFFF8) + 24)) < (*(_DWORD *)((*a1 & 0xFFFFFFFFFFFFFFF8) + 24) | (*a1 >> 1) & 3))
      {
        uint64_t v8 = a1[1];
        uint64_t v9 = *(a2 - 1);
        *a1 = v7;
        a1[1] = v9;
        *(a2 - 2) = v6;
        *(a2 - 1) = v8;
      }
      return result;
    case 3:
      sub_1CC31A314(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      sub_1CC31A864(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      sub_1CC31A968(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      uint64_t v10 = a1 + 4;
      sub_1CC31A314(a1, a1 + 2, a1 + 4);
      uint64_t v11 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (1)
  {
    uint64_t v14 = *v10;
    uint64_t v15 = *v11;
    unsigned int v16 = (*v11 >> 1) & 3 | *(_DWORD *)((*v11 & 0xFFFFFFFFFFFFFFF8) + 24);
    if (v16 < (*(_DWORD *)((*v10 & 0xFFFFFFFFFFFFFFF8) + 24) | (*v10 >> 1) & 3))
    {
      uint64_t v17 = v11[1];
      uint64_t v18 = v12;
      while (1)
      {
        uint64_t v19 = (uint64_t *)((char *)a1 + v18);
        uint64_t v20 = *(uint64_t *)((char *)a1 + v18 + 40);
        v19[6] = v14;
        v19[7] = v20;
        if (v18 == -32) {
          break;
        }
        uint64_t v14 = v19[2];
        v18 -= 16;
        if (v16 >= ((v14 >> 1) & 3 | *(_DWORD *)((v14 & 0xFFFFFFFFFFFFFFF8) + 24)))
        {
          uint64_t v21 = (uint64_t *)((char *)a1 + v18 + 48);
          goto LABEL_12;
        }
      }
      uint64_t v21 = a1;
LABEL_12:
      *uint64_t v21 = v15;
      v21[1] = v17;
      if (++v13 == 8) {
        return v11 + 2 == a2;
      }
    }
    uint64_t v10 = v11;
    v12 += 16;
    v11 += 2;
    if (v11 == a2) {
      return 1;
    }
  }
}

uint64_t sub_1CC31A864(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t result = sub_1CC31A314(a1, a2, a3);
  uint64_t v9 = *a3;
  if (((*a4 >> 1) & 3 | *(_DWORD *)((*a4 & 0xFFFFFFFFFFFFFFF8) + 24)) < (*(_DWORD *)((*a3 & 0xFFFFFFFFFFFFFFF8) + 24) | (*a3 >> 1) & 3))
  {
    *a3 = *a4;
    *a4 = v9;
    uint64_t v10 = *a3;
    uint64_t v11 = a3[1];
    a3[1] = a4[1];
    a4[1] = v11;
    uint64_t v12 = *a2;
    if (((v10 >> 1) & 3 | *(_DWORD *)((v10 & 0xFFFFFFFFFFFFFFF8) + 24)) < (*(_DWORD *)((*a2 & 0xFFFFFFFFFFFFFFF8) + 24) | (*a2 >> 1) & 3))
    {
      *a2 = v10;
      *a3 = v12;
      uint64_t v13 = *a2;
      uint64_t v14 = a2[1];
      a2[1] = a3[1];
      a3[1] = v14;
      uint64_t v15 = *a1;
      if (((v13 >> 1) & 3 | *(_DWORD *)((v13 & 0xFFFFFFFFFFFFFFF8) + 24)) < (*(_DWORD *)((*a1 & 0xFFFFFFFFFFFFFFF8) + 24) | (*a1 >> 1) & 3))
      {
        uint64_t v16 = a1[1];
        uint64_t v17 = a2[1];
        *a1 = v13;
        a1[1] = v17;
        *a2 = v15;
        a2[1] = v16;
      }
    }
  }
  return result;
}

uint64_t sub_1CC31A968(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t result = sub_1CC31A864(a1, a2, a3, a4);
  uint64_t v11 = *a4;
  if (((*a5 >> 1) & 3 | *(_DWORD *)((*a5 & 0xFFFFFFFFFFFFFFF8) + 24)) < (*(_DWORD *)((*a4 & 0xFFFFFFFFFFFFFFF8) + 24) | (*a4 >> 1) & 3))
  {
    *a4 = *a5;
    *a5 = v11;
    uint64_t v12 = *a4;
    uint64_t v13 = a4[1];
    a4[1] = a5[1];
    a5[1] = v13;
    uint64_t v14 = *a3;
    if (((v12 >> 1) & 3 | *(_DWORD *)((v12 & 0xFFFFFFFFFFFFFFF8) + 24)) < (*(_DWORD *)((*a3 & 0xFFFFFFFFFFFFFFF8) + 24) | (*a3 >> 1) & 3))
    {
      *a3 = v12;
      *a4 = v14;
      uint64_t v15 = *a3;
      uint64_t v16 = a3[1];
      a3[1] = a4[1];
      a4[1] = v16;
      uint64_t v17 = *a2;
      if (((v15 >> 1) & 3 | *(_DWORD *)((v15 & 0xFFFFFFFFFFFFFFF8) + 24)) < (*(_DWORD *)((*a2 & 0xFFFFFFFFFFFFFFF8) + 24) | (*a2 >> 1) & 3))
      {
        *a2 = v15;
        *a3 = v17;
        uint64_t v18 = *a2;
        uint64_t v19 = a2[1];
        a2[1] = a3[1];
        a3[1] = v19;
        uint64_t v20 = *a1;
        if (((v18 >> 1) & 3 | *(_DWORD *)((v18 & 0xFFFFFFFFFFFFFFF8) + 24)) < (*(_DWORD *)((*a1 & 0xFFFFFFFFFFFFFFF8) + 24) | (*a1 >> 1) & 3))
        {
          uint64_t v21 = a1[1];
          uint64_t v22 = a2[1];
          *a1 = v18;
          a1[1] = v22;
          *a2 = v20;
          a2[1] = v21;
        }
      }
    }
  }
  return result;
}

char *sub_1CC31AABC(char *a1, char *a2, char *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    uint64_t v8 = a2 - a1;
    uint64_t v9 = (a2 - a1) >> 4;
    if (a2 - a1 >= 17)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      uint64_t v12 = &a1[16 * v10];
      do
      {
        sub_1CC31AC2C((uint64_t)a1, a4, v9, v12);
        v12 -= 16;
        --v11;
      }
      while (v11);
    }
    uint64_t v13 = a2;
    if (a2 != a3)
    {
      uint64_t v14 = a2;
      do
      {
        uint64_t v15 = *(void *)v14;
        if (((*(void *)v14 >> 1) & 3 | *(_DWORD *)((*(void *)v14 & 0xFFFFFFFFFFFFFFF8) + 24)) < (*(_DWORD *)((*(void *)a1 & 0xFFFFFFFFFFFFFFF8) + 24) | (*(void *)a1 >> 1) & 3))
        {
          uint64_t v16 = *((void *)v14 + 1);
          uint64_t v17 = *((void *)a1 + 1);
          *(void *)uint64_t v14 = *(void *)a1;
          *((void *)v14 + 1) = v17;
          *(void *)a1 = v15;
          *((void *)a1 + 1) = v16;
          sub_1CC31AC2C((uint64_t)a1, a4, v9, a1);
        }
        v14 += 16;
      }
      while (v14 != a3);
      uint64_t v13 = a3;
    }
    if (v8 >= 17)
    {
      uint64_t v18 = a2 - 16;
      do
      {
        uint64_t v20 = *(void *)a1;
        uint64_t v19 = *((void *)a1 + 1);
        uint64_t v21 = (char *)sub_1CC31AD6C(a1, a4, v9);
        if (v18 == v21)
        {
          *(void *)uint64_t v21 = v20;
          *((void *)v21 + 1) = v19;
        }
        else
        {
          uint64_t v22 = *((void *)v18 + 1);
          *(void *)uint64_t v21 = *(void *)v18;
          *((void *)v21 + 1) = v22;
          *(void *)uint64_t v18 = v20;
          *((void *)v18 + 1) = v19;
          sub_1CC31AE04((uint64_t)a1, (uint64_t)(v21 + 16), a4, (v21 + 16 - a1) >> 4);
        }
        v18 -= 16;
      }
      while (v9-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t sub_1CC31AC2C(uint64_t result, uint64_t a2, uint64_t a3, void *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 4)
    {
      uint64_t v6 = v4 >> 3;
      uint64_t v7 = (v4 >> 3) + 1;
      uint64_t v8 = (void *)(result + 16 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 >= a3)
      {
        uint64_t v10 = *v8;
      }
      else
      {
        uint64_t v10 = *v8;
        if (((*v8 >> 1) & 3 | *(_DWORD *)((*v8 & 0xFFFFFFFFFFFFFFF8) + 24)) < (*(_DWORD *)((v8[2] & 0xFFFFFFFFFFFFFFF8) + 24) | (v8[2] >> 1) & 3))
        {
          uint64_t v10 = v8[2];
          v8 += 2;
          uint64_t v7 = v9;
        }
      }
      uint64_t v11 = *a4;
      unsigned int v12 = (*a4 >> 1) & 3 | *(_DWORD *)((*a4 & 0xFFFFFFFFFFFFFFF8) + 24);
      if ((*(_DWORD *)((v10 & 0xFFFFFFFFFFFFFFF8) + 24) | (v10 >> 1) & 3) >= v12)
      {
        uint64_t v13 = a4[1];
        do
        {
          uint64_t v14 = a4;
          a4 = v8;
          uint64_t v15 = v8[1];
          *uint64_t v14 = v10;
          v14[1] = v15;
          if (v5 < v7) {
            break;
          }
          uint64_t v16 = (2 * v7) | 1;
          uint64_t v8 = (void *)(result + 16 * v16);
          uint64_t v7 = 2 * v7 + 2;
          if (v7 >= a3)
          {
            uint64_t v10 = *v8;
            uint64_t v7 = v16;
          }
          else
          {
            uint64_t v10 = v8[2];
            unsigned int v17 = (*v8 >> 1) & 3 | *(_DWORD *)((*v8 & 0xFFFFFFFFFFFFFFF8) + 24);
            unsigned int v18 = *(_DWORD *)((v10 & 0xFFFFFFFFFFFFFFF8) + 24) | (v10 >> 1) & 3;
            if (v17 < v18) {
              v8 += 2;
            }
            else {
              uint64_t v10 = *v8;
            }
            if (v17 >= v18) {
              uint64_t v7 = v16;
            }
          }
        }
        while (((v10 >> 1) & 3 | *(_DWORD *)((v10 & 0xFFFFFFFFFFFFFFF8) + 24)) >= v12);
        *a4 = v11;
        a4[1] = v13;
      }
    }
  }
  return result;
}

void *sub_1CC31AD6C(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = a3 - 2;
  if (a3 < 2) {
    uint64_t v4 = a3 - 1;
  }
  uint64_t v5 = v4 >> 1;
  do
  {
    uint64_t v6 = &a1[2 * v3 + 2];
    uint64_t v7 = (2 * v3) | 1;
    uint64_t v3 = 2 * v3 + 2;
    if (v3 >= a3)
    {
      uint64_t v8 = *v6;
      uint64_t v3 = v7;
    }
    else
    {
      uint64_t v8 = v6[2];
      unsigned int v9 = (*v6 >> 1) & 3 | *(_DWORD *)((*v6 & 0xFFFFFFFFFFFFFFF8) + 24);
      unsigned int v10 = *(_DWORD *)((v8 & 0xFFFFFFFFFFFFFFF8) + 24) | (v8 >> 1) & 3;
      if (v9 < v10) {
        v6 += 2;
      }
      else {
        uint64_t v8 = *v6;
      }
      if (v9 >= v10) {
        uint64_t v3 = v7;
      }
    }
    uint64_t v11 = v6[1];
    *a1 = v8;
    a1[1] = v11;
    a1 = v6;
  }
  while (v3 <= v5);
  return v6;
}

uint64_t sub_1CC31AE04(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    unint64_t v5 = v4 >> 1;
    uint64_t v6 = (void *)(result + 16 * (v4 >> 1));
    uint64_t v7 = (void *)(a2 - 16);
    uint64_t v8 = *(void *)(a2 - 16);
    uint64_t v9 = *v6;
    unsigned int v10 = *(_DWORD *)((v8 & 0xFFFFFFFFFFFFFFF8) + 24) | (v8 >> 1) & 3;
    if (((*v6 >> 1) & 3 | *(_DWORD *)((*v6 & 0xFFFFFFFFFFFFFFF8) + 24)) < v10)
    {
      uint64_t v11 = *(void *)(a2 - 8);
      do
      {
        unsigned int v12 = v7;
        uint64_t v7 = v6;
        uint64_t v13 = v6[1];
        *unsigned int v12 = v9;
        v12[1] = v13;
        if (!v5) {
          break;
        }
        unint64_t v5 = (v5 - 1) >> 1;
        uint64_t v6 = (void *)(result + 16 * v5);
        uint64_t v9 = *v6;
      }
      while (((*v6 >> 1) & 3 | *(_DWORD *)((*v6 & 0xFFFFFFFFFFFFFFF8) + 24)) < v10);
      *uint64_t v7 = v8;
      v7[1] = v11;
    }
  }
  return result;
}

void sub_1CC31AE94()
{
}

void *sub_1CC31AEA8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F260D508;
  result[1] = v3;
  return result;
}

uint64_t sub_1CC31AEF0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F260D508;
  a2[1] = v2;
  return result;
}

llvm::raw_ostream *sub_1CC31AF1C(uint64_t a1, llvm::raw_ostream *a2)
{
  return llvm::MachineBasicBlock::printAsOperand(*(llvm::MachineBasicBlock **)(a1 + 8), a2);
}

void sub_1CC31AF28(unsigned __int16 *a1, unsigned __int16 *a2, uint64_t a3, char a4)
{
  while (2)
  {
    unsigned int v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          uint64_t v12 = ((char *)a2 - (char *)v10) >> 4;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0:
              case 1:
                return;
              case 2:
                unsigned int v33 = *(a2 - 8);
                uint64_t v32 = a2 - 8;
                if (v33 < *a1)
                {
                  long long v75 = *(_OWORD *)a1;
                  *(_OWORD *)a1 = *(_OWORD *)v32;
                  *(_OWORD *)uint64_t v32 = v75;
                }
                break;
              case 3:
                sub_1CC31B6A0(a1, a1 + 8, a2 - 8);
                break;
              case 4:
                sub_1CC31B9B8(a1, a1 + 8, a1 + 16, a2 - 8);
                break;
              case 5:
                int v34 = a1 + 8;
                unint64_t v35 = a1 + 16;
                unsigned int v36 = a1 + 24;
                sub_1CC31B9B8(a1, a1 + 8, a1 + 16, a1 + 24);
                unsigned int v38 = *(a2 - 8);
                int v37 = a2 - 8;
                if (v38 < a1[24])
                {
                  long long v39 = *(_OWORD *)v36;
                  *(_OWORD *)unsigned int v36 = *(_OWORD *)v37;
                  *(_OWORD *)int v37 = v39;
                  if (*v36 < *v35)
                  {
                    long long v40 = *(_OWORD *)v35;
                    *(_OWORD *)unint64_t v35 = *(_OWORD *)v36;
                    *(_OWORD *)unsigned int v36 = v40;
                    if (*v35 < *v34)
                    {
                      long long v41 = *(_OWORD *)v34;
                      *(_OWORD *)int v34 = *(_OWORD *)v35;
                      *(_OWORD *)unint64_t v35 = v41;
                      if (a1[8] < *a1)
                      {
                        long long v76 = *(_OWORD *)a1;
                        *(_OWORD *)a1 = *(_OWORD *)v34;
                        *(_OWORD *)int v34 = v76;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 383)
          {
            uint64_t v42 = a1 + 8;
            BOOL v44 = a1 == a2 || v42 == a2;
            if (a4)
            {
              if (!v44)
              {
                uint64_t v45 = 0;
                unsigned int v46 = a1;
                do
                {
                  uint64_t v47 = v42;
                  unsigned int v48 = v46[8];
                  if (v48 < *v46)
                  {
                    *(void *)unint64_t v77 = *(void *)(v46 + 9);
                    *(void *)&v77[6] = *((void *)v46 + 3);
                    uint64_t v49 = v45;
                    while (1)
                    {
                      *(_OWORD *)((char *)a1 + v49 + 16) = *(_OWORD *)((char *)a1 + v49);
                      if (!v49) {
                        break;
                      }
                      unsigned int v50 = *(unsigned __int16 *)((char *)a1 + v49 - 16);
                      v49 -= 16;
                      if (v48 >= v50)
                      {
                        uint64_t v51 = (uint64_t)a1 + v49 + 16;
                        goto LABEL_80;
                      }
                    }
                    uint64_t v51 = (uint64_t)a1;
LABEL_80:
                    *(_WORD *)uint64_t v51 = v48;
                    *(void *)(v51 + 8) = *(void *)&v77[6];
                    *(void *)(v51 + 2) = *(void *)v77;
                  }
                  uint64_t v42 = v47 + 8;
                  v45 += 16;
                  unsigned int v46 = v47;
                }
                while (v47 + 8 != a2);
              }
            }
            else if (!v44)
            {
              do
              {
                unsigned int v66 = v42;
                unsigned int v67 = a1[8];
                if (v67 < *a1)
                {
                  *(void *)char v79 = *(void *)(a1 + 9);
                  *(void *)&v79[6] = *((void *)a1 + 3);
                  do
                  {
                    *(_OWORD *)uint64_t v42 = *((_OWORD *)v42 - 1);
                    unsigned int v68 = *(v42 - 16);
                    v42 -= 8;
                  }
                  while (v67 < v68);
                  *uint64_t v42 = v67;
                  *((void *)v42 + 1) = *(void *)&v79[6];
                  *(void *)(v42 + 1) = *(void *)v79;
                }
                uint64_t v42 = v66 + 8;
                a1 = v66;
              }
              while (v66 + 8 != a2);
            }
            return;
          }
          if (!a3)
          {
            if (a1 != a2)
            {
              unint64_t v52 = (unint64_t)(v12 - 2) >> 1;
              unint64_t v53 = v52 + 1;
              int32x2_t v54 = &a1[8 * v52];
              do
              {
                sub_1CC31BA58((uint64_t)a1, v12, v54);
                v54 -= 8;
                --v53;
              }
              while (v53);
              do
              {
                uint64_t v55 = 0;
                long long v78 = *(_OWORD *)a1;
                uint64_t v56 = a1;
                do
                {
                  BOOL v57 = &v56[8 * v55 + 8];
                  uint64_t v58 = (2 * v55) | 1;
                  uint64_t v59 = 2 * v55 + 2;
                  if (v59 < v12 && *v57 < v57[8])
                  {
                    v57 += 8;
                    uint64_t v58 = v59;
                  }
                  *(_OWORD *)uint64_t v56 = *(_OWORD *)v57;
                  uint64_t v56 = v57;
                  uint64_t v55 = v58;
                }
                while (v58 <= (uint64_t)((unint64_t)(v12 - 2) >> 1));
                a2 -= 8;
                if (v57 == a2)
                {
                  *(_OWORD *)BOOL v57 = v78;
                }
                else
                {
                  *(_OWORD *)BOOL v57 = *(_OWORD *)a2;
                  *(_OWORD *)a2 = v78;
                  uint64_t v60 = (char *)v57 - (char *)a1 + 16;
                  if (v60 >= 17)
                  {
                    unint64_t v61 = (((unint64_t)v60 >> 4) - 2) >> 1;
                    uint64_t v62 = &a1[8 * v61];
                    unsigned int v63 = *v57;
                    if (*v62 < v63)
                    {
                      *(void *)&v71[6] = *((void *)v57 + 1);
                      *(void *)uint64_t v71 = *(void *)(v57 + 1);
                      do
                      {
                        uint64_t v64 = v57;
                        BOOL v57 = v62;
                        *(_OWORD *)uint64_t v64 = *(_OWORD *)v62;
                        if (!v61) {
                          break;
                        }
                        unint64_t v61 = (v61 - 1) >> 1;
                        uint64_t v62 = &a1[8 * v61];
                      }
                      while (*v62 < v63);
                      *BOOL v57 = v63;
                      *((void *)v57 + 1) = *(void *)&v71[6];
                      *(void *)(v57 + 1) = *(void *)v71;
                    }
                  }
                }
              }
              while (v12-- > 2);
            }
            return;
          }
          unint64_t v13 = (unint64_t)v12 >> 1;
          uint64_t v14 = &a1[8 * ((unint64_t)v12 >> 1)];
          if ((unint64_t)v11 < 0x801)
          {
            sub_1CC31B6A0(v14, a1, a2 - 8);
          }
          else
          {
            sub_1CC31B6A0(a1, v14, a2 - 8);
            sub_1CC31B6A0(a1 + 8, v14 - 8, a2 - 16);
            sub_1CC31B6A0(a1 + 16, &a1[8 * v13 + 8], a2 - 24);
            sub_1CC31B6A0(v14 - 8, v14, &a1[8 * v13 + 8]);
            long long v72 = *(_OWORD *)a1;
            *(_OWORD *)a1 = *(_OWORD *)v14;
            *(_OWORD *)uint64_t v14 = v72;
          }
          --a3;
          unsigned int v15 = *a1;
          if ((a4 & 1) != 0 || *(a1 - 8) < v15) {
            break;
          }
          *(void *)&v70[6] = *((void *)a1 + 1);
          *(void *)int v70 = *(void *)(a1 + 1);
          if (v15 >= *(a2 - 8))
          {
            uint64_t v27 = a1 + 8;
            do
            {
              unsigned int v10 = v27;
              if (v27 >= a2) {
                break;
              }
              v27 += 8;
            }
            while (v15 >= *v10);
          }
          else
          {
            unsigned int v10 = a1;
            do
            {
              unsigned int v26 = v10[8];
              v10 += 8;
            }
            while (v15 >= v26);
          }
          unsigned int v28 = a2;
          if (v10 < a2)
          {
            unsigned int v28 = a2;
            do
            {
              unsigned int v29 = *(v28 - 8);
              v28 -= 8;
            }
            while (v15 < v29);
          }
          while (v10 < v28)
          {
            long long v74 = *(_OWORD *)v10;
            *(_OWORD *)unsigned int v10 = *(_OWORD *)v28;
            *(_OWORD *)unsigned int v28 = v74;
            do
            {
              unsigned int v30 = v10[8];
              v10 += 8;
            }
            while (v15 >= v30);
            do
            {
              unsigned int v31 = *(v28 - 8);
              v28 -= 8;
            }
            while (v15 < v31);
          }
          BOOL v4 = v10 - 8 >= a1;
          BOOL v5 = v10 - 8 == a1;
          if (v10 - 8 != a1) {
            *(_OWORD *)a1 = *((_OWORD *)v10 - 1);
          }
          a4 = 0;
          *(v10 - 8) = v15;
          *((void *)v10 - 1) = *(void *)&v70[6];
          *(void *)(v10 - 7) = *(void *)v70;
        }
        uint64_t v16 = 0;
        *(void *)&v69[6] = *((void *)a1 + 1);
        *(void *)uint64_t v69 = *(void *)(a1 + 1);
        do
        {
          unsigned int v17 = a1[v16 + 8];
          v16 += 8;
        }
        while (v17 < v15);
        unsigned int v18 = &a1[v16];
        uint64_t v19 = a2;
        if (v16 == 8)
        {
          uint64_t v19 = a2;
          do
          {
            if (v18 >= v19) {
              break;
            }
            unsigned int v21 = *(v19 - 8);
            v19 -= 8;
          }
          while (v21 >= v15);
        }
        else
        {
          do
          {
            unsigned int v20 = *(v19 - 8);
            v19 -= 8;
          }
          while (v20 >= v15);
        }
        unsigned int v10 = &a1[v16];
        if (v18 < v19)
        {
          uint64_t v22 = v19;
          do
          {
            long long v73 = *(_OWORD *)v10;
            *(_OWORD *)unsigned int v10 = *(_OWORD *)v22;
            *(_OWORD *)uint64_t v22 = v73;
            do
            {
              unsigned int v23 = v10[8];
              v10 += 8;
            }
            while (v23 < v15);
            do
            {
              unsigned int v24 = *(v22 - 8);
              v22 -= 8;
            }
            while (v24 >= v15);
          }
          while (v10 < v22);
        }
        if (v10 - 8 != a1) {
          *(_OWORD *)a1 = *((_OWORD *)v10 - 1);
        }
        *(v10 - 8) = v15;
        *((void *)v10 - 1) = *(void *)&v69[6];
        *(void *)(v10 - 7) = *(void *)v69;
        if (v18 >= v19) {
          break;
        }
LABEL_30:
        sub_1CC31AF28(a1, v10 - 8, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v25 = sub_1CC31B744(a1, v10 - 8);
      if (sub_1CC31B744(v10, a2)) {
        break;
      }
      if (!v25) {
        goto LABEL_30;
      }
    }
    a2 = v10 - 8;
    if (!v25) {
      continue;
    }
    break;
  }
}

unsigned __int16 *sub_1CC31B6A0(unsigned __int16 *result, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *a3;
  if (v3 >= *result)
  {
    if (v4 < v3)
    {
      long long v6 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v6;
      if (*a2 < *result)
      {
        long long v7 = *(_OWORD *)result;
        *(_OWORD *)uint64_t result = *(_OWORD *)a2;
        *(_OWORD *)a2 = v7;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      long long v8 = *(_OWORD *)result;
      *(_OWORD *)uint64_t result = *(_OWORD *)a2;
      *(_OWORD *)a2 = v8;
      if (*a3 >= *a2) {
        return result;
      }
      long long v5 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
    }
    else
    {
      long long v5 = *(_OWORD *)result;
      *(_OWORD *)uint64_t result = *(_OWORD *)a3;
    }
    *(_OWORD *)a3 = v5;
  }
  return result;
}

BOOL sub_1CC31B744(unsigned __int16 *a1, unsigned __int16 *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      long long v6 = a2 - 8;
      if (*(a2 - 8) < *a1)
      {
        long long v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)long long v6 = v7;
      }
      return result;
    case 3:
      sub_1CC31B6A0(a1, a1 + 8, a2 - 8);
      return 1;
    case 4:
      sub_1CC31B9B8(a1, a1 + 8, a1 + 16, a2 - 8);
      return 1;
    case 5:
      uint64_t v16 = a1 + 8;
      unsigned int v17 = a1 + 16;
      unsigned int v18 = a1 + 24;
      sub_1CC31B9B8(a1, a1 + 8, a1 + 16, a1 + 24);
      unsigned int v20 = *(a2 - 8);
      uint64_t v19 = a2 - 8;
      if (v20 < a1[24])
      {
        long long v21 = *(_OWORD *)v18;
        *(_OWORD *)unsigned int v18 = *(_OWORD *)v19;
        *(_OWORD *)uint64_t v19 = v21;
        if (*v18 < *v17)
        {
          long long v22 = *(_OWORD *)v17;
          *(_OWORD *)unsigned int v17 = *(_OWORD *)v18;
          *(_OWORD *)unsigned int v18 = v22;
          if (*v17 < *v16)
          {
            long long v23 = *(_OWORD *)v16;
            *(_OWORD *)uint64_t v16 = *(_OWORD *)v17;
            *(_OWORD *)unsigned int v17 = v23;
            if (a1[8] < *a1)
            {
              long long v24 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *(_OWORD *)v16;
              *(_OWORD *)uint64_t v16 = v24;
            }
          }
        }
      }
      return 1;
    default:
      long long v8 = a1 + 16;
      sub_1CC31B6A0(a1, a1 + 8, a1 + 16);
      uint64_t v9 = a1 + 24;
      if (a1 + 24 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    unsigned int v12 = *v9;
    if (v12 < *v8)
    {
      *(void *)BOOL v25 = *(void *)(v9 + 1);
      *(void *)&v25[6] = *((void *)v9 + 1);
      uint64_t v13 = v10;
      while (1)
      {
        *(_OWORD *)((char *)a1 + v13 + 48) = *(_OWORD *)((char *)a1 + v13 + 32);
        if (v13 == -32) {
          break;
        }
        unsigned int v14 = *(unsigned __int16 *)((char *)a1 + v13 + 16);
        v13 -= 16;
        if (v12 >= v14)
        {
          uint64_t v15 = (uint64_t)a1 + v13 + 48;
          goto LABEL_12;
        }
      }
      uint64_t v15 = (uint64_t)a1;
LABEL_12:
      *(_WORD *)uint64_t v15 = v12;
      *(void *)(v15 + 2) = *(void *)v25;
      *(void *)(v15 + 8) = *(void *)&v25[6];
      if (++v11 == 8) {
        return v9 + 8 == a2;
      }
    }
    long long v8 = v9;
    v10 += 16;
    v9 += 8;
    if (v9 == a2) {
      return 1;
    }
  }
}

__n128 sub_1CC31B9B8(unsigned __int16 *a1, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  sub_1CC31B6A0(a1, a2, a3);
  if (*a4 < *a3)
  {
    __n128 result = *(__n128 *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(__n128 *)a4 = result;
    if (*a3 < *a2)
    {
      __n128 result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      if (*a2 < *a1)
      {
        __n128 result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

uint64_t sub_1CC31BA58(uint64_t result, uint64_t a2, unsigned __int16 *a3)
{
  if (a2 >= 2)
  {
    uint64_t v3 = (uint64_t)a3 - result;
    int64_t v4 = (unint64_t)(a2 - 2) >> 1;
    if (v4 >= ((uint64_t)a3 - result) >> 4)
    {
      uint64_t v5 = v3 >> 3;
      uint64_t v6 = (v3 >> 3) + 1;
      long long v7 = (unsigned __int16 *)(result + 16 * v6);
      uint64_t v8 = v5 + 2;
      if (v8 >= a2)
      {
        unsigned int v9 = *v7;
      }
      else
      {
        unsigned int v9 = *v7;
        unsigned int v10 = v7[8];
        BOOL v11 = v9 >= v10;
        if (v9 <= v10) {
          unsigned int v9 = v7[8];
        }
        if (!v11)
        {
          v7 += 8;
          uint64_t v6 = v8;
        }
      }
      unsigned int v12 = *a3;
      if (v9 >= v12)
      {
        *(void *)unsigned int v18 = *(void *)(a3 + 1);
        *(void *)&v18[6] = *((void *)a3 + 1);
        do
        {
          uint64_t v13 = a3;
          a3 = v7;
          *uint64_t v13 = *(_OWORD *)v7;
          if (v4 < v6) {
            break;
          }
          uint64_t v14 = (2 * v6) | 1;
          long long v7 = (unsigned __int16 *)(result + 16 * v14);
          uint64_t v6 = 2 * v6 + 2;
          if (v6 >= a2)
          {
            unsigned int v15 = *v7;
            uint64_t v6 = v14;
          }
          else
          {
            unsigned int v15 = *v7;
            unsigned int v16 = v7[8];
            BOOL v17 = v15 >= v16;
            if (v15 <= v16) {
              unsigned int v15 = v7[8];
            }
            if (v17) {
              uint64_t v6 = v14;
            }
            else {
              v7 += 8;
            }
          }
        }
        while (v15 >= v12);
        *a3 = v12;
        *((void *)a3 + 1) = *(void *)&v18[6];
        *(void *)(a3 + 1) = *(void *)v18;
      }
    }
  }
  return result;
}

double sub_1CC31BB88()
{
  v4.n128_u64[0] = (unint64_t)"When printing machine IR, annotate instructions and blocks with SlotIndexes when available";
  v4.n128_u64[1] = 90;
  char v2 = 1;
  uint64_t v3 = &v2;
  int v1 = 1;
  sub_1CD4130FC((llvm::cl::Option *)&unk_1EBCCD498, "print-slotindexes", &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCCD498, &dword_1CB82C000);
  llvm::MBBSectionID::ColdSectionID = 2;
  *(void *)&double result = 1;
  llvm::MBBSectionID::ExceptionSectionID = 1;
  return result;
}

void sub_1CC31BC34(llvm *a1, llvm::PassRegistry *a2)
{
}

llvm::MachineBlockFrequencyInfo *llvm::MachineBlockFrequencyInfo::MachineBlockFrequencyInfo(llvm::MachineBlockFrequencyInfo *this, llvm::MachineFunction *a2, llvm::MachineBranchProbabilityInfo *a3, llvm::MachineLoopInfo *a4)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::MachineBlockFrequencyInfo::ID;
  *((_DWORD *)this + 6) = 2;
  *((void *)this + 6) = 0;
  *((void *)this + 4) = (char *)this + 48;
  *((void *)this + 5) = 0x600000001;
  *((_DWORD *)this + 24) = 11;
  *((void *)this + 15) = 0;
  *((void *)this + 13) = (char *)this + 120;
  *((void *)this + 14) = 0x600000001;
  *((_DWORD *)this + 42) = 11;
  *((void *)this + 24) = 0;
  *((void *)this + 22) = (char *)this + 192;
  *((void *)this + 23) = 0x600000001;
  *((_DWORD *)this + 60) = 11;
  *(void *)this = &unk_1F260D550;
  *((void *)this + 31) = 0;
  llvm::MachineBlockFrequencyInfo::calculate(this, a2, a3, a4);
  return this;
}

{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::MachineBlockFrequencyInfo::ID;
  *((_DWORD *)this + 6) = 2;
  *((void *)this + 6) = 0;
  *((void *)this + 4) = (char *)this + 48;
  *((void *)this + 5) = 0x600000001;
  *((_DWORD *)this + 24) = 11;
  *((void *)this + 15) = 0;
  *((void *)this + 13) = (char *)this + 120;
  *((void *)this + 14) = 0x600000001;
  *((_DWORD *)this + 42) = 11;
  *((void *)this + 24) = 0;
  *((void *)this + 22) = (char *)this + 192;
  *((void *)this + 23) = 0x600000001;
  *((_DWORD *)this + 60) = 11;
  *(void *)this = &unk_1F260D550;
  *((void *)this + 31) = 0;
  llvm::MachineBlockFrequencyInfo::calculate(this, a2, a3, a4);
  return this;
}

void llvm::MachineBlockFrequencyInfo::calculate(llvm::MachineBlockFrequencyInfo *this, const llvm::MachineFunction *a2, const llvm::MachineBranchProbabilityInfo *a3, const llvm::MachineLoopInfo *a4)
{
  uint64_t v4 = MEMORY[0x1F4188790](this, a2, a3, a4);
  uint64_t v8 = v5;
  uint64_t v9 = v4;
  v426[16] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)(v4 + 248);
  if (!v10) {
    operator new();
  }
  *(void *)(v10 + 112) = v6;
  *(void *)(v10 + 120) = v7;
  *(void *)(v10 + 128) = v5;
  llvm::BlockFrequencyInfoImplBase::clear((llvm::BlockFrequencyInfoImplBase *)v10);
  BOOL v11 = (void *)(v10 + 136);
  *(void *)(v10 + 144) = *(void *)(v10 + 136);
  uint64_t v249 = v9;
  v250 = (_DWORD *)(v10 + 160);
  int v12 = *(_DWORD *)(v10 + 168);
  uint64_t v248 = v8;
  if (v12 || *(_DWORD *)(v10 + 172))
  {
    uint64_t v223 = *(unsigned int *)(v10 + 176);
    if (v223 > 4 * v12 && v223 >= 0x41)
    {
      sub_1CD3C8060(v250);
    }
    else
    {
      if (v223)
      {
        uint64_t v224 = *(void **)v250;
        uint64_t v225 = 16 * v223;
        do
        {
          *uint64_t v224 = -4096;
          v224 += 2;
          v225 -= 16;
        }
        while (v225);
      }
      *(void *)(v10 + 168) = 0;
    }
  }
  uint64_t v13 = *(void *)(v10 + 128);
  uint64_t v14 = v13 + 320;
  uint64_t v15 = *(void *)(v13 + 328);
  unsigned int v16 = -1;
  uint64_t v17 = v14;
  do
  {
    uint64_t v17 = *(void *)(v17 + 8);
    ++v16;
  }
  while (v17 != v14);
  sub_1CBF7ACFC(v10 + 136, v16);
  v258 = v262;
  uint64_t v259 = v262;
  int v261 = 0;
  uint64_t v260 = 0x100000008;
  uint64_t __src = v265;
  v262[0] = v15;
  uint64_t v18 = *(void *)(v15 + 88);
  v265[0] = v15;
  v265[1] = v18;
  uint64_t v264 = 0x800000001;
  sub_1CB93B280((llvm::SmallPtrSetImplBase *)&v258);
  v255[0] = 0;
  memset(v256, 0, sizeof(v256));
  uint64_t v257 = 0;
  long long v254 = 0u;
  long long v253 = 0u;
  long long v252 = 0u;
  long long v251 = 0u;
  v255[1] = (char *)v256 + 8;
  DWORD1(v256[0]) = 8;
  uint64_t v19 = v278;
  v274 = v278;
  unsigned int v20 = v259;
  if (v259 == v258)
  {
    v275 = v278;
    long long v21 = v259;
  }
  else
  {
    int v204 = v260;
    uint64_t v19 = malloc_type_malloc(8 * v260, 0x4065EBACuLL);
    if (!v19)
    {
      if (v204) {
        goto LABEL_597;
      }
      uint64_t v19 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v19) {
        goto LABEL_597;
      }
    }
    v275 = v19;
    long long v21 = v258;
    unsigned int v20 = v259;
  }
  int v22 = HIDWORD(v260);
  LODWORD(v276) = v260;
  if (v20 == v21) {
    unsigned int v23 = HIDWORD(v260);
  }
  else {
    unsigned int v23 = v260;
  }
  if (v23)
  {
    memmove(v19, v20, 8 * v23);
    int v22 = HIDWORD(v260);
  }
  int v24 = v264;
  HIDWORD(v276) = v22;
  int v277 = v261;
  v279 = v281;
  uint64_t v280 = 0x800000000;
  if (v264)
  {
    if (v264 >= 9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy(v281, __src, 16 * v264);
    LODWORD(v280) = v24;
  }
  v266 = v270;
  uint64_t v267 = v270;
  uint64_t v268 = 8;
  int v25 = v256[0];
  int v269 = v251;
  uint64_t v271 = v273;
  uint64_t v272 = 0x800000000;
  if (LODWORD(v256[0]))
  {
    if (LODWORD(v256[0]) >= 9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy(v273, v255[1], 16 * LODWORD(v256[0]));
    LODWORD(v272) = v25;
  }
  v299 = v303;
  if (v275 == v274)
  {
    v300 = v303;
    unsigned int v26 = HIDWORD(v276);
    if (HIDWORD(v276)) {
      memmove(v303, v275, 8 * HIDWORD(v276));
    }
  }
  else
  {
    v300 = v275;
    v275 = v274;
    unsigned int v26 = HIDWORD(v276);
  }
  unint64_t v301 = __PAIR64__(v26, v276);
  int v302 = v277;
  uint64_t v276 = 8;
  int v277 = 0;
  v304 = v306;
  uint64_t v305 = 0x800000000;
  int v27 = v280;
  if (v280)
  {
    if (v279 == v281)
    {
      if (v280 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v306, v281, 16 * v280);
      LODWORD(v305) = v27;
    }
    else
    {
      v304 = v279;
      uint64_t v305 = v280;
      v279 = v281;
      HIDWORD(v280) = 0;
    }
    LODWORD(v280) = 0;
  }
  v291 = v295;
  if (v267 == v266)
  {
    v292 = v295;
    unsigned int v28 = HIDWORD(v268);
    if (HIDWORD(v268)) {
      memmove(v295, v267, 8 * HIDWORD(v268));
    }
  }
  else
  {
    v292 = v267;
    uint64_t v267 = v266;
    unsigned int v28 = HIDWORD(v268);
  }
  unint64_t v293 = __PAIR64__(v28, v268);
  int v294 = v269;
  uint64_t v268 = 8;
  int v269 = 0;
  v296 = v298;
  uint64_t v297 = 0x800000000;
  int v29 = v272;
  if (v272)
  {
    if (v271 == v273)
    {
      if (v272 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v298, v273, 16 * v272);
      LODWORD(v297) = v29;
    }
    else
    {
      v296 = v271;
      uint64_t v297 = v272;
      uint64_t v271 = v273;
      HIDWORD(v272) = 0;
    }
    LODWORD(v272) = 0;
  }
  v315 = v319;
  if (v300 == v299)
  {
    v316 = v319;
    unsigned int v30 = HIDWORD(v301);
    if (HIDWORD(v301)) {
      memmove(v319, v300, 8 * HIDWORD(v301));
    }
  }
  else
  {
    v316 = v300;
    v300 = v299;
    unsigned int v30 = HIDWORD(v301);
  }
  unint64_t v317 = __PAIR64__(v30, v301);
  int v318 = v302;
  unint64_t v301 = 8;
  int v302 = 0;
  v320 = v322;
  uint64_t v321 = 0x800000000;
  int v31 = v305;
  if (v305)
  {
    if (v304 == v306)
    {
      if (v305 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v322, v306, 16 * v305);
      LODWORD(v321) = v31;
    }
    else
    {
      v320 = v304;
      uint64_t v321 = v305;
      v304 = v306;
      HIDWORD(v305) = 0;
    }
    LODWORD(v305) = 0;
  }
  v307 = v311;
  if (v292 == v291)
  {
    v308 = v311;
    unsigned int v32 = HIDWORD(v293);
    if (HIDWORD(v293)) {
      memmove(v311, v292, 8 * HIDWORD(v293));
    }
  }
  else
  {
    v308 = v292;
    v292 = v291;
    unsigned int v32 = HIDWORD(v293);
  }
  unint64_t v309 = __PAIR64__(v32, v293);
  int v310 = v294;
  unint64_t v293 = 8;
  int v294 = 0;
  v312 = v314;
  uint64_t v313 = 0x800000000;
  int v33 = v297;
  if (v297)
  {
    if (v296 == v298)
    {
      if (v297 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v314, v298, 16 * v297);
      LODWORD(v313) = v33;
    }
    else
    {
      v312 = v296;
      uint64_t v313 = v297;
      v296 = v298;
      HIDWORD(v297) = 0;
    }
    LODWORD(v297) = 0;
  }
  int v34 = v385;
  v381 = v385;
  unint64_t v35 = v316;
  if (v316 != v315)
  {
    int v205 = v317;
    int v34 = malloc_type_malloc(8 * v317, 0x4065EBACuLL);
    if (v34 || !v205 && (int v34 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) != 0)
    {
      v382 = v34;
      unsigned int v36 = v315;
      unint64_t v35 = v316;
      goto LABEL_38;
    }
LABEL_597:
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  v382 = v385;
  unsigned int v36 = v316;
LABEL_38:
  int v37 = HIDWORD(v317);
  LODWORD(v383) = v317;
  if (v35 == v36) {
    unsigned int v38 = HIDWORD(v317);
  }
  else {
    unsigned int v38 = v317;
  }
  if (v38)
  {
    memmove(v34, v35, 8 * v38);
    int v37 = HIDWORD(v317);
  }
  int v39 = v321;
  HIDWORD(v383) = v37;
  int v384 = v318;
  v386 = v388;
  uint64_t v387 = 0x800000000;
  if (v321)
  {
    if (v321 >= 9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy(v388, v320, 16 * v321);
    LODWORD(v387) = v39;
  }
  v373 = v377;
  if (v308 == v307)
  {
    v374 = v377;
    unsigned int v40 = HIDWORD(v309);
    if (HIDWORD(v309)) {
      memmove(v377, v308, 8 * HIDWORD(v309));
    }
  }
  else
  {
    v374 = v308;
    v308 = v307;
    unsigned int v40 = HIDWORD(v309);
  }
  unint64_t v375 = __PAIR64__(v40, v309);
  int v376 = v310;
  unint64_t v309 = 8;
  int v310 = 0;
  v378 = v380;
  uint64_t v379 = 0x800000000;
  int v41 = v313;
  if (v313)
  {
    if (v312 == v314)
    {
      if (v313 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v380, v314, 16 * v313);
      LODWORD(v379) = v41;
    }
    else
    {
      v378 = v312;
      uint64_t v379 = v313;
      v312 = v314;
      HIDWORD(v313) = 0;
    }
    LODWORD(v313) = 0;
  }
  v282 = v287;
  if (v382 == v381)
  {
    v283 = v287;
    int v42 = HIDWORD(v383);
    if (HIDWORD(v383)) {
      memmove(v287, v382, 8 * HIDWORD(v383));
    }
  }
  else
  {
    v283 = v382;
    v382 = v381;
    int v42 = HIDWORD(v383);
  }
  int v284 = v383;
  int v285 = v42;
  int v286 = v384;
  uint64_t v383 = 8;
  int v384 = 0;
  v288 = v290;
  uint64_t v289 = 0x800000000;
  int v43 = v387;
  if (v387)
  {
    if (v386 == v388)
    {
      if (v387 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v290, v388, 16 * v387);
      LODWORD(v289) = v43;
    }
    else
    {
      v288 = v386;
      uint64_t v289 = v387;
      v386 = v388;
      HIDWORD(v387) = 0;
    }
    LODWORD(v387) = 0;
  }
  sub_1CC31EBCC((uint64_t)&v364, (uint64_t)&v282);
  v411 = v415;
  if (v374 == v373)
  {
    v412 = v415;
    unsigned int v44 = HIDWORD(v375);
    if (HIDWORD(v375)) {
      memmove(v415, v374, 8 * HIDWORD(v375));
    }
  }
  else
  {
    v412 = v374;
    v374 = v373;
    unsigned int v44 = HIDWORD(v375);
  }
  unint64_t v413 = __PAIR64__(v44, v375);
  int v414 = v376;
  unint64_t v375 = 8;
  int v376 = 0;
  v416 = v418;
  uint64_t v417 = 0x800000000;
  int v45 = v379;
  if (v379)
  {
    if (v378 == v380)
    {
      if (v379 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v418, v380, 16 * v379);
      LODWORD(v417) = v45;
    }
    else
    {
      v416 = v378;
      uint64_t v417 = v379;
      v378 = v380;
      HIDWORD(v379) = 0;
    }
    LODWORD(v379) = 0;
  }
  sub_1CC31EBCC((uint64_t)&v419, (uint64_t)&v411);
  __p[0] = v391;
  if (v365 == v364)
  {
    __p[1] = v391;
    unsigned int v46 = HIDWORD(v366);
    if (HIDWORD(v366)) {
      memmove(v391, v365, 8 * HIDWORD(v366));
    }
  }
  else
  {
    __p[1] = v365;
    v365 = v364;
    unsigned int v46 = HIDWORD(v366);
  }
  *(void *)&long long v390 = __PAIR64__(v46, v366);
  DWORD2(v390) = v367;
  unint64_t v366 = 8;
  LODWORD(v367) = 0;
  v392 = v394;
  uint64_t v393 = 0x800000000;
  int v47 = v370;
  if (v370)
  {
    if (v369 == v371)
    {
      if (v370 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v394, v369, 16 * v370);
      LODWORD(v393) = v47;
    }
    else
    {
      v392 = v369;
      uint64_t v393 = v370;
      v369 = v371;
      HIDWORD(v370) = 0;
    }
    LODWORD(v370) = 0;
  }
  v395 = v399;
  if (v420 == v419)
  {
    v396 = v399;
    unsigned int v48 = HIDWORD(v421);
    if (HIDWORD(v421)) {
      memmove(v399, v420, 8 * HIDWORD(v421));
    }
  }
  else
  {
    v396 = v420;
    v420 = v419;
    unsigned int v48 = HIDWORD(v421);
  }
  unint64_t v397 = __PAIR64__(v48, v421);
  int v398 = v422;
  unint64_t v421 = 8;
  int v422 = 0;
  v400 = v402;
  uint64_t v401 = 0x800000000;
  int v49 = v425;
  if (v425)
  {
    if (v424 == v426)
    {
      if (v425 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v402, v424, 16 * v425);
      LODWORD(v401) = v49;
    }
    else
    {
      v400 = v424;
      uint64_t v401 = v425;
      v424 = v426;
      HIDWORD(v425) = 0;
    }
    LODWORD(v425) = 0;
  }
  if (v424 != v426) {
    free(v424);
  }
  if (v420 != v419) {
    free(v420);
  }
  if (v416 != v418) {
    free(v416);
  }
  if (v412 != v411) {
    free(v412);
  }
  if (v369 != v371) {
    free(v369);
  }
  if (v365 != v364) {
    free(v365);
  }
  if (v288 != v290) {
    free(v288);
  }
  if (v283 != v282) {
    free(v283);
  }
  if (v378 != v380) {
    free(v378);
  }
  if (v374 != v373) {
    free(v374);
  }
  if (v386 != v388) {
    free(v386);
  }
  if (v382 != v381) {
    free(v382);
  }
  v356 = v360;
  if (__p[1] == __p[0])
  {
    v357 = v360;
    unsigned int v50 = DWORD1(v390);
    if (DWORD1(v390)) {
      memmove(v360, __p[1], 8 * DWORD1(v390));
    }
  }
  else
  {
    v357 = __p[1];
    __p[1] = __p[0];
    unsigned int v50 = DWORD1(v390);
  }
  unint64_t v358 = __PAIR64__(v50, v390);
  int v359 = DWORD2(v390);
  *(void *)&long long v390 = 8;
  DWORD2(v390) = 0;
  v361 = v363;
  uint64_t v362 = 0x800000000;
  int v51 = v393;
  if (v393)
  {
    if (v392 == v394)
    {
      if (v393 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v363, v394, 16 * v393);
      LODWORD(v362) = v51;
    }
    else
    {
      v361 = v392;
      uint64_t v362 = v393;
      v392 = v394;
      HIDWORD(v393) = 0;
    }
    LODWORD(v393) = 0;
  }
  v347 = v352;
  if (v396 == v395)
  {
    v348 = v352;
    int v52 = HIDWORD(v397);
    if (HIDWORD(v397)) {
      memmove(v352, v396, 8 * HIDWORD(v397));
    }
  }
  else
  {
    v348 = v396;
    v396 = v395;
    int v52 = HIDWORD(v397);
  }
  int v349 = v397;
  int v350 = v52;
  int v351 = v398;
  unint64_t v397 = 8;
  int v398 = 0;
  v353 = v355;
  uint64_t v354 = 0x800000000;
  unsigned int v53 = v401;
  if (v401)
  {
    if (v400 == v402)
    {
      if (v401 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v355, v402, 16 * v401);
      LODWORD(v354) = v53;
    }
    else
    {
      v353 = v400;
      uint64_t v354 = v401;
      v400 = v402;
      HIDWORD(v401) = 0;
    }
    LODWORD(v401) = 0;
  }
  while (1)
  {
    uint64_t v54 = v362;
    uint64_t v55 = v361;
    if (v362 != v53) {
      goto LABEL_108;
    }
    if (!v53) {
      break;
    }
    uint64_t v56 = v353;
    BOOL v57 = v361;
    while (*v57 == *v56 && v57[1] == v56[1])
    {
      v57 += 2;
      v56 += 2;
      if (v57 == (void *)((char *)v361 + 16 * v362)) {
        goto LABEL_129;
      }
    }
LABEL_108:
    uint64_t v59 = (char *)v361 + 16 * v362;
    unint64_t v61 = *(void **)(v10 + 144);
    unint64_t v60 = *(void *)(v10 + 152);
    if ((unint64_t)v61 >= v60)
    {
      unsigned int v63 = (void *)*v11;
      uint64_t v64 = ((uint64_t)v61 - *v11) >> 3;
      unint64_t v65 = v64 + 1;
      if ((unint64_t)(v64 + 1) >> 61) {
        abort();
      }
      unsigned int v66 = (void **)v11;
      uint64_t v67 = v60 - (void)v63;
      if (v67 >> 2 > v65) {
        unint64_t v65 = v67 >> 2;
      }
      if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v68 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v68 = v65;
      }
      if (v68)
      {
        if (v68 >> 61) {
          sub_1CB833614();
        }
        uint64_t v69 = (char *)operator new(8 * v68);
      }
      else
      {
        uint64_t v69 = 0;
      }
      int v70 = &v69[8 * v64];
      *(void *)int v70 = *((void *)v59 - 2);
      uint64_t v62 = v70 + 8;
      if (v61 != v63)
      {
        do
        {
          uint64_t v71 = *--v61;
          *((void *)v70 - 1) = v71;
          v70 -= 8;
        }
        while (v61 != v63);
        unint64_t v61 = *v66;
      }
      *(void *)(v10 + 136) = v70;
      *(void *)(v10 + 144) = v62;
      *(void *)(v10 + 152) = &v69[8 * v68];
      if (v61)
      {
        operator delete(v61);
        LODWORD(v54) = v362;
      }
      BOOL v11 = v66;
    }
    else
    {
      *unint64_t v61 = *((void *)v59 - 2);
      uint64_t v62 = v61 + 1;
    }
    *(void *)(v10 + 144) = v62;
    LODWORD(v362) = v54 - 1;
    if (v54 != 1) {
      sub_1CB93B280((llvm::SmallPtrSetImplBase *)&v356);
    }
    unsigned int v53 = v354;
  }
LABEL_129:
  v364 = (char *)v368;
  if (v357 == v356)
  {
    v365 = v368;
    unsigned int v72 = HIDWORD(v358);
    if (HIDWORD(v358)) {
      memmove(v368, v357, 8 * HIDWORD(v358));
    }
  }
  else
  {
    v365 = v357;
    v357 = v356;
    unsigned int v72 = HIDWORD(v358);
  }
  unint64_t v366 = __PAIR64__(v72, v358);
  LODWORD(v367) = v359;
  unint64_t v358 = 8;
  int v359 = 0;
  v369 = v371;
  unint64_t v370 = 0x800000000;
  if (v53)
  {
    if (v55 == v363)
    {
      if (v53 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v371, v363, 16 * v54);
      LODWORD(v370) = v53;
    }
    else
    {
      v369 = v55;
      unint64_t v370 = __PAIR64__(HIDWORD(v362), v53);
      v361 = v363;
      HIDWORD(v362) = 0;
    }
    LODWORD(v362) = 0;
  }
  v372 = v11;
  if (v353 != v355) {
    free(v353);
  }
  if (v348 != v347) {
    free(v348);
  }
  if (v361 != v363) {
    free(v361);
  }
  if (v357 != v356) {
    free(v357);
  }
  v331 = v335;
  if (v316 == v315)
  {
    v332 = v335;
    unsigned int v73 = HIDWORD(v317);
    if (HIDWORD(v317)) {
      memmove(v335, v316, 8 * HIDWORD(v317));
    }
  }
  else
  {
    v332 = v316;
    v316 = v315;
    unsigned int v73 = HIDWORD(v317);
  }
  unint64_t v333 = __PAIR64__(v73, v317);
  int v334 = v318;
  unint64_t v317 = 8;
  int v318 = 0;
  v336 = v338;
  uint64_t v337 = 0x800000000;
  int v74 = v321;
  if (v321)
  {
    if (v320 == v322)
    {
      if (v321 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v338, v322, 16 * v321);
      LODWORD(v337) = v74;
    }
    else
    {
      v336 = v320;
      uint64_t v337 = v321;
      v320 = v322;
      HIDWORD(v321) = 0;
    }
    LODWORD(v321) = 0;
  }
  v323 = v327;
  if (v365 == v364)
  {
    v324 = v327;
    unsigned int v75 = HIDWORD(v366);
    if (HIDWORD(v366)) {
      memmove(v327, v365, 8 * HIDWORD(v366));
    }
  }
  else
  {
    v324 = v365;
    v365 = v364;
    unsigned int v75 = HIDWORD(v366);
  }
  unint64_t v325 = __PAIR64__(v75, v366);
  int v326 = v367;
  unint64_t v366 = 8;
  LODWORD(v367) = 0;
  v328 = v330;
  uint64_t v329 = 0x800000000;
  int v76 = v370;
  if (v370)
  {
    if (v369 == v371)
    {
      if (v370 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v330, v371, 16 * v370);
      LODWORD(v329) = v76;
    }
    else
    {
      v328 = v369;
      uint64_t v329 = v370;
      v369 = v371;
      HIDWORD(v370) = 0;
    }
    LODWORD(v370) = 0;
  }
  v411 = v415;
  if (v332 == v331)
  {
    v412 = v415;
    unsigned int v77 = HIDWORD(v333);
    if (HIDWORD(v333)) {
      memmove(v415, v332, 8 * HIDWORD(v333));
    }
  }
  else
  {
    v412 = v332;
    v332 = v331;
    unsigned int v77 = HIDWORD(v333);
  }
  unint64_t v413 = __PAIR64__(v77, v333);
  int v414 = v334;
  unint64_t v333 = 8;
  int v334 = 0;
  v416 = v418;
  uint64_t v417 = 0x800000000;
  int v78 = v337;
  if (v337)
  {
    if (v336 == v338)
    {
      if (v337 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v418, v338, 16 * v337);
      LODWORD(v417) = v78;
    }
    else
    {
      v416 = v336;
      uint64_t v417 = v337;
      v336 = v338;
      HIDWORD(v337) = 0;
    }
    LODWORD(v337) = 0;
  }
  v403 = v407;
  if (v324 == v323)
  {
    v404 = v407;
    unsigned int v79 = HIDWORD(v325);
    if (HIDWORD(v325)) {
      memmove(v407, v324, 8 * HIDWORD(v325));
    }
  }
  else
  {
    v404 = v324;
    v324 = v323;
    unsigned int v79 = HIDWORD(v325);
  }
  unint64_t v405 = __PAIR64__(v79, v325);
  int v406 = v326;
  unint64_t v325 = 8;
  int v326 = 0;
  v408 = v410;
  uint64_t v409 = 0x800000000;
  int v80 = v329;
  if (v329)
  {
    if (v328 == v330)
    {
      if (v329 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v410, v330, 16 * v329);
      LODWORD(v409) = v80;
    }
    else
    {
      v408 = v328;
      uint64_t v409 = v329;
      v328 = v330;
      HIDWORD(v329) = 0;
    }
    LODWORD(v329) = 0;
  }
  v282 = v287;
  if (v412 == v411)
  {
    v283 = v287;
    int v81 = HIDWORD(v413);
    if (HIDWORD(v413)) {
      memmove(v287, v412, 8 * HIDWORD(v413));
    }
  }
  else
  {
    v283 = v412;
    v412 = v411;
    int v81 = HIDWORD(v413);
  }
  int v284 = v413;
  int v285 = v81;
  int v286 = v414;
  unint64_t v413 = 8;
  int v414 = 0;
  v288 = v290;
  uint64_t v289 = 0x800000000;
  int v82 = v417;
  if (v417)
  {
    if (v416 == v418)
    {
      if (v417 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v290, v418, 16 * v417);
      LODWORD(v289) = v82;
    }
    else
    {
      v288 = v416;
      uint64_t v289 = v417;
      v416 = v418;
      HIDWORD(v417) = 0;
    }
    LODWORD(v417) = 0;
  }
  uint64_t v83 = v423;
  v419 = v423;
  unint64_t v84 = v404;
  if (v404 == v403)
  {
    v420 = v423;
    unsigned int v85 = HIDWORD(v405);
    if (HIDWORD(v405)) {
      memmove(v423, v404, 8 * HIDWORD(v405));
    }
    unint64_t v84 = v423;
  }
  else
  {
    v420 = v404;
    v404 = v403;
    unsigned int v85 = HIDWORD(v405);
  }
  unint64_t v421 = __PAIR64__(v85, v405);
  int v422 = v406;
  unint64_t v405 = 8;
  int v406 = 0;
  v424 = v426;
  uint64_t v425 = 0x800000000;
  uint64_t v86 = v409;
  if (v409)
  {
    if (v408 == v410)
    {
      if (v409 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v426, v410, 16 * v409);
      LODWORD(v425) = v86;
      unint64_t v84 = v420;
      uint64_t v83 = v419;
    }
    else
    {
      v424 = v408;
      uint64_t v425 = v409;
      v408 = v410;
      HIDWORD(v409) = 0;
    }
    LODWORD(v409) = 0;
  }
  v339 = v343;
  if (v84 == v83)
  {
    v340 = v343;
    unsigned int v87 = HIDWORD(v421);
    if (HIDWORD(v421)) {
      memmove(v343, v83, 8 * HIDWORD(v421));
    }
  }
  else
  {
    v340 = v84;
    v420 = v83;
    unsigned int v87 = HIDWORD(v421);
  }
  unint64_t v341 = __PAIR64__(v87, v421);
  int v342 = v422;
  unint64_t v421 = 8;
  int v422 = 0;
  v344 = v346;
  unint64_t v345 = 0x800000000;
  uint64_t v88 = v424;
  if (v86)
  {
    if (v424 == v426)
    {
      if (v86 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v346, v426, 16 * v86);
      LODWORD(v345) = v86;
      uint64_t v88 = v424;
    }
    else
    {
      v344 = v424;
      unint64_t v345 = __PAIR64__(HIDWORD(v425), v86);
      v424 = v426;
      HIDWORD(v425) = 0;
      uint64_t v88 = v426;
    }
    LODWORD(v425) = 0;
  }
  if (v88 != v426) {
    free(v88);
  }
  if (v420 != v419) {
    free(v420);
  }
  if (v288 != v290) {
    free(v288);
  }
  if (v283 != v282) {
    free(v283);
  }
  if (v408 != v410) {
    free(v408);
  }
  if (v404 != v403) {
    free(v404);
  }
  if (v416 != v418) {
    free(v416);
  }
  if (v412 != v411) {
    free(v412);
  }
  unsigned int v89 = v372;
  v282 = v287;
  if (v340 == v339)
  {
    v283 = v287;
    int v90 = HIDWORD(v341);
    if (HIDWORD(v341)) {
      memmove(v287, v340, 8 * HIDWORD(v341));
    }
  }
  else
  {
    v283 = v340;
    v340 = v339;
    int v90 = HIDWORD(v341);
  }
  int v284 = v341;
  int v285 = v90;
  int v286 = v342;
  unint64_t v341 = 8;
  int v342 = 0;
  v288 = v290;
  uint64_t v289 = 0x800000000;
  int v91 = v345;
  int v92 = v344;
  if (v345)
  {
    if (v344 == v346)
    {
      if (v345 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v290, v346, 16 * v345);
      LODWORD(v289) = v91;
      int v92 = v344;
    }
    else
    {
      v288 = v344;
      uint64_t v289 = v345;
      v344 = v346;
      HIDWORD(v345) = 0;
      int v92 = v346;
    }
    LODWORD(v345) = 0;
  }
  v290[16] = v89;
  if (v92 != v346) {
    free(v92);
  }
  if (v340 != v339) {
    free(v340);
  }
  if (v328 != v330) {
    free(v328);
  }
  if (v324 != v323) {
    free(v324);
  }
  if (v336 != v338) {
    free(v336);
  }
  if (v332 != v331) {
    free(v332);
  }
  if (v369 != v371) {
    free(v369);
  }
  if (v365 != v364) {
    free(v365);
  }
  if (v400 != v402) {
    free(v400);
  }
  if (v396 != v395) {
    free(v396);
  }
  if (v392 != v394) {
    free(v392);
  }
  if (__p[1] != __p[0]) {
    free(__p[1]);
  }
  if (v312 != v314) {
    free(v312);
  }
  if (v308 != v307) {
    free(v308);
  }
  if (v320 != v322) {
    free(v320);
  }
  if (v316 != v315) {
    free(v316);
  }
  if (v296 != v298) {
    free(v296);
  }
  if (v292 != v291) {
    free(v292);
  }
  if (v304 != v306) {
    free(v304);
  }
  if (v300 != v299) {
    free(v300);
  }
  if (v288 != v290) {
    free(v288);
  }
  if (v283 != v282) {
    free(v283);
  }
  if (v271 != v273) {
    free(v271);
  }
  if (v267 != v266) {
    free(v267);
  }
  if (v279 != v281) {
    free(v279);
  }
  if (v275 != v274) {
    free(v275);
  }
  if (v255[1] != (char *)v256 + 8) {
    free(v255[1]);
  }
  if (__src != v265) {
    free(__src);
  }
  if (v259 != v258) {
    free(v259);
  }
  uint64_t v93 = *(uint64_t **)(v10 + 136);
  uint64_t v94 = *(uint64_t **)(v10 + 144);
  if (v93 != v94)
  {
    unsigned int v95 = v94 - 1;
    if (v93 < v94 - 1)
    {
      unsigned int v96 = v93 + 1;
      do
      {
        uint64_t v97 = *(v96 - 1);
        *(v96 - 1) = *v95;
        *v95-- = v97;
      }
      while (v96++ < v95);
      uint64_t v93 = *(uint64_t **)(v10 + 136);
      uint64_t v94 = *(uint64_t **)(v10 + 144);
    }
  }
  if (v93 != v94)
  {
    while (1)
    {
      uint64_t v99 = *(void *)(v10 + 136);
      int v100 = *(_DWORD *)(v10 + 176);
      if (!v100) {
        break;
      }
      uint64_t v101 = *(void *)(v10 + 160);
      int v102 = v100 - 1;
      unsigned int v103 = ((*v93 >> 4) ^ (*v93 >> 9)) & v102;
      uint64_t v104 = (uint64_t *)(v101 + 16 * v103);
      uint64_t v105 = *v104;
      if (*v93 != *v104)
      {
        uint64_t v106 = 0;
        int v107 = 1;
        while (v105 != -4096)
        {
          if (v106) {
            BOOL v108 = 0;
          }
          else {
            BOOL v108 = v105 == -8192;
          }
          if (v108) {
            uint64_t v106 = v104;
          }
          unsigned int v109 = v103 + v107++;
          unsigned int v103 = v109 & v102;
          uint64_t v104 = (uint64_t *)(v101 + 16 * v103);
          uint64_t v105 = *v104;
          if (*v93 == *v104) {
            goto LABEL_257;
          }
        }
        if (v106) {
          uint64_t v110 = v106;
        }
        else {
          uint64_t v110 = v104;
        }
        goto LABEL_271;
      }
LABEL_257:
      *((_DWORD *)v104 + 2) = ((unint64_t)v93++ - v99) >> 3;
      if (v93 == v94)
      {
        uint64_t v94 = *(uint64_t **)(v10 + 136);
        uint64_t v111 = *(uint64_t **)(v10 + 144);
        goto LABEL_272;
      }
    }
    uint64_t v110 = 0;
LABEL_271:
    uint64_t v104 = sub_1CC31EF18((uint64_t)v250, v93, v110);
    *uint64_t v104 = *v93;
    *((_DWORD *)v104 + 2) = -1;
    goto LABEL_257;
  }
  uint64_t v111 = v94;
LABEL_272:
  uint64_t v112 = (void *)(v10 + 64);
  sub_1CBF7ADB4(v10 + 64, v111 - v94);
  __p[0] = 0;
  uint64_t v114 = *(void *)(v10 + 136);
  uint64_t v113 = *(void *)(v10 + 144);
  if (v113 == v114)
  {
    unint64_t v117 = (v113 - v114) >> 3;
  }
  else
  {
    unint64_t v115 = 0;
    unint64_t v116 = *(char **)(v10 + 72);
    do
    {
      if ((unint64_t)v116 >= *(void *)(v10 + 80))
      {
        unint64_t v116 = sub_1CBF7BB20((char **)(v10 + 64), __p);
        unint64_t v115 = (unint64_t)__p[0];
        uint64_t v114 = *(void *)(v10 + 136);
        uint64_t v113 = *(void *)(v10 + 144);
      }
      else
      {
        *(_DWORD *)unint64_t v116 = v115;
        *((void *)v116 + 1) = 0;
        *((void *)v116 + 2) = 0;
        v116 += 24;
      }
      *(void *)(v10 + 72) = v116;
      __p[0] = (void *)++v115;
    }
    while (v115 < (v113 - v114) >> 3);
    unint64_t v117 = (v113 - v114) >> 3;
  }
  uint64_t v118 = *(void *)(v10 + 8);
  unint64_t v119 = 0xAAAAAAAAAAAAAAABLL * ((*(void *)(v10 + 16) - v118) >> 3);
  if (v117 <= v119)
  {
    if (v117 < v119) {
      *(void *)(v10 + 16) = v118 + 24 * v117;
    }
  }
  else
  {
    sub_1CBF7BC34((char **)(v10 + 8), v117 - v119);
  }
  uint64_t v120 = *(void *)(v10 + 120);
  unsigned int v121 = *(uint64_t **)(v120 + 272);
  int v122 = *(uint64_t **)(v120 + 280);
  if (v121 != v122)
  {
    uint64_t v123 = 0;
    uint64_t v124 = 0;
    uint64_t v125 = 0;
    uint64_t v126 = 0;
    v391[0] = 0u;
    long long v390 = 0u;
    *(_OWORD *)__p = 0u;
    do
    {
      uint64_t v127 = *v121;
      if (v126 == v125) {
        uint64_t v128 = 0;
      }
      else {
        uint64_t v128 = 32 * (v126 - v125) - 1;
      }
      unint64_t v129 = v124 + v123;
      if (v128 == v124 + v123)
      {
        sub_1CBF7BE74((uint64_t)__p);
        uint64_t v125 = (char *)__p[1];
        uint64_t v126 = (unsigned char *)v390;
        uint64_t v123 = *((void *)&v391[0] + 1);
        uint64_t v124 = *(void *)&v391[0];
        unint64_t v129 = *(void *)&v391[0] + *((void *)&v391[0] + 1);
      }
      uint64_t v130 = (void *)(*(void *)&v125[(v129 >> 5) & 0x7FFFFFFFFFFFFF8] + 16 * v129);
      *uint64_t v130 = v127;
      v130[1] = 0;
      *((void *)&v391[0] + 1) = ++v123;
      ++v121;
    }
    while (v121 != v122);
    if (v123)
    {
      uint64_t v131 = (uint64_t *)(v10 + 88);
      while (1)
      {
        unsigned int v132 = (uint64_t *)(*(void *)((char *)__p[1] + ((*(void *)&v391[0] >> 5) & 0x7FFFFFFFFFFFFF8))
                         + 16 * LOBYTE(v391[0]));
        uint64_t v134 = (uint64_t **)*v132;
        uint64_t v133 = v132[1];
        *((void *)&v391[0] + 1) = v123 - 1;
        if (++*(void *)&v391[0] >= 0x200uLL)
        {
          operator delete(*(void **)__p[1]);
          __p[1] = (char *)__p[1] + 8;
          *(void *)&v391[0] -= 256;
        }
        int v135 = *(_DWORD *)(v10 + 176);
        if (!v135) {
          goto LABEL_309;
        }
        uint64_t v136 = *v134[4];
        uint64_t v137 = *(void *)(v10 + 160);
        unsigned int v138 = v135 - 1;
        uint64_t v139 = ((v136 >> 4) ^ (v136 >> 9)) & (v135 - 1);
        uint64_t v140 = *(void *)(v137 + 16 * v139);
        if (v136 != v140) {
          break;
        }
LABEL_294:
        int v141 = *(_DWORD *)(v137 + 16 * v139 + 8);
LABEL_295:
        LODWORD(v364) = v141;
        int v142 = operator new(0xC0uLL);
        void *v142 = 0;
        v142[1] = 0;
        uint64_t v143 = sub_1CBF7C050((uint64_t)(v142 + 2), v133, (int *)&v364);
        v142[1] = v131;
        uint64_t v144 = *(void *)(v10 + 88);
        void *v142 = v144;
        *(void *)(v144 + 8) = v142;
        *(void *)(v10 + 88) = v142;
        ++*(void *)(v10 + 104);
        *(void *)(*(void *)(v10 + 64) + 24 * v364 + 8) = v143;
        unint64_t v145 = v134[1];
        unsigned int v146 = v134[2];
        uint64_t v123 = *((void *)&v391[0] + 1);
        if (v145 != v146)
        {
          unsigned int v147 = (unsigned char *)v390;
          uint64_t v148 = (char *)__p[1];
          uint64_t v149 = *(void *)&v391[0];
          do
          {
            uint64_t v150 = *v145;
            uint64_t v151 = *v131;
            if (v147 == v148) {
              uint64_t v152 = 0;
            }
            else {
              uint64_t v152 = 32 * (v147 - v148) - 1;
            }
            unint64_t v153 = v149 + v123;
            if (v152 == v149 + v123)
            {
              sub_1CBF7BE74((uint64_t)__p);
              uint64_t v148 = (char *)__p[1];
              unsigned int v147 = (unsigned char *)v390;
              uint64_t v123 = *((void *)&v391[0] + 1);
              uint64_t v149 = *(void *)&v391[0];
              unint64_t v153 = *(void *)&v391[0] + *((void *)&v391[0] + 1);
            }
            int v154 = (void *)(*(void *)&v148[(v153 >> 5) & 0x7FFFFFFFFFFFFF8] + 16 * v153);
            *int v154 = v150;
            v154[1] = v151 + 16;
            *((void *)&v391[0] + 1) = ++v123;
            ++v145;
          }
          while (v145 != v146);
        }
        if (!v123) {
          goto LABEL_310;
        }
      }
      int v155 = 1;
      while (v140 != -4096)
      {
        int v156 = v139 + v155++;
        uint64_t v139 = v156 & v138;
        uint64_t v140 = *(void *)(v137 + 16 * v139);
        if (v136 == v140) {
          goto LABEL_294;
        }
      }
LABEL_309:
      int v141 = -1;
      goto LABEL_295;
    }
LABEL_310:
    uint64_t v158 = *(void *)(v10 + 136);
    uint64_t v157 = *(void *)(v10 + 144);
    if (v157 != v158)
    {
      for (unint64_t i = 0; i < (v157 - v158) >> 3; ++i)
      {
        uint64_t v160 = *v112 + 24 * i;
        uint64_t v161 = (uint64_t *)(v160 + 8);
        BOOL v162 = *(uint64_t **)(v160 + 8);
        if (!v162)
        {
LABEL_313:
          uint64_t v163 = *(void *)(v10 + 120);
          int v164 = *(_DWORD *)(v163 + 264);
          if (v164)
          {
            uint64_t v165 = *(void *)(v158 + 8 * i);
            uint64_t v166 = *(void *)(v163 + 248);
            unsigned int v167 = v164 - 1;
            uint64_t v168 = ((v165 >> 4) ^ (v165 >> 9)) & (v164 - 1);
            uint64_t v169 = *(void *)(v166 + 16 * v168);
            if (v165 != v169)
            {
              int v170 = 1;
              while (v169 != -4096)
              {
                int v171 = v168 + v170++;
                uint64_t v168 = v171 & v167;
                uint64_t v169 = *(void *)(v166 + 16 * v168);
                if (v165 == v169) {
                  goto LABEL_318;
                }
              }
              continue;
            }
LABEL_318:
            uint64_t v172 = *(void *)(v166 + 16 * v168 + 8);
            if (v172)
            {
              int v173 = *(_DWORD *)(v10 + 176);
              if (v173)
              {
                uint64_t v174 = **(void **)(v172 + 32);
                uint64_t v175 = *(void *)(v10 + 160);
                unsigned int v176 = v173 - 1;
                uint64_t v177 = ((v174 >> 4) ^ (v174 >> 9)) & (v173 - 1);
                uint64_t v178 = *(void *)(v175 + 16 * v177);
                if (v174 == v178)
                {
LABEL_321:
                  unsigned int v179 = *(_DWORD *)(v175 + 16 * v177 + 8);
                  goto LABEL_322;
                }
                int v192 = 1;
                while (v178 != -4096)
                {
                  int v193 = v177 + v192++;
                  uint64_t v177 = v193 & v176;
                  uint64_t v178 = *(void *)(v175 + 16 * v177);
                  if (v174 == v178) {
                    goto LABEL_321;
                  }
                }
              }
              unsigned int v179 = -1;
LABEL_322:
              uint64_t v180 = *v112 + 24 * v179;
              *uint64_t v161 = *(void *)(v180 + 8);
              uint64_t v181 = *(void *)(v180 + 8);
              BOOL v182 = (void *)(v181 + 96);
              uint64_t v184 = (_DWORD *)(v181 + 104);
              unint64_t v183 = *(unsigned int *)(v181 + 104);
              unint64_t v185 = *(unsigned int *)(v181 + 108);
LABEL_323:
              if (v183 >= v185) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(_DWORD *)(*v182 + 4 * v183) = i;
              ++*v184;
              uint64_t v158 = *(void *)(v10 + 136);
              uint64_t v157 = *(void *)(v10 + 144);
              continue;
            }
          }
          continue;
        }
        unint64_t v186 = *((unsigned int *)v162 + 3);
        uint64_t v187 = (unsigned int *)v162[12];
        if (v186 >= 2)
        {
          unsigned int v188 = *(_DWORD *)v160;
          uint64_t v206 = (unsigned int *)v162[12];
          unint64_t v207 = *((unsigned int *)v162 + 3);
          do
          {
            unint64_t v208 = v207 >> 1;
            int v209 = &v206[v207 >> 1];
            unsigned int v211 = *v209;
            int v210 = v209 + 1;
            v207 += ~(v207 >> 1);
            if (v211 < v188) {
              uint64_t v206 = v210;
            }
            else {
              unint64_t v207 = v208;
            }
          }
          while (v207);
          uint64_t v212 = &v187[v186];
          if (v206 == v212 || v188 < *v206) {
            goto LABEL_313;
          }
          uint64_t v213 = (unsigned int *)v162[12];
          unint64_t v214 = *((unsigned int *)v162 + 3);
          do
          {
            unint64_t v215 = v214 >> 1;
            unsigned int v216 = &v213[v214 >> 1];
            unsigned int v218 = *v216;
            unsigned int v217 = v216 + 1;
            v214 += ~(v214 >> 1);
            if (v218 < v188) {
              uint64_t v213 = v217;
            }
            else {
              unint64_t v214 = v215;
            }
          }
          while (v214);
          if (v213 == v212 || v188 < *v213) {
            goto LABEL_332;
          }
          do
          {
            unint64_t v219 = v186 >> 1;
            uint64_t v220 = &v187[v186 >> 1];
            unsigned int v222 = *v220;
            int v221 = v220 + 1;
            v186 += ~(v186 >> 1);
            if (v222 < v188) {
              uint64_t v187 = v221;
            }
            else {
              unint64_t v186 = v219;
            }
          }
          while (v186);
          if (v187 == v212 || v188 < *v187) {
            goto LABEL_331;
          }
        }
        else
        {
          unsigned int v188 = *(_DWORD *)v160;
          if (v188 != *v187) {
            goto LABEL_313;
          }
        }
        uint64_t v189 = *v162;
        if (!*v162) {
          continue;
        }
        uint64_t v190 = *(unsigned int *)(v189 + 12);
        if (v190 < 2)
        {
LABEL_331:
          uint64_t v161 = v162;
          goto LABEL_332;
        }
        uint64_t v226 = *(unsigned int **)(v189 + 96);
        unint64_t v227 = *(unsigned int *)(v189 + 12);
        do
        {
          unint64_t v228 = v227 >> 1;
          int v229 = &v226[v227 >> 1];
          unsigned int v231 = *v229;
          uint64_t v230 = v229 + 1;
          v227 += ~(v227 >> 1);
          if (v231 < v188) {
            uint64_t v226 = v230;
          }
          else {
            unint64_t v227 = v228;
          }
        }
        while (v227);
        uint64_t v232 = *(void *)(v189 + 96) + 4 * v190;
        uint64_t v161 = v162;
        if (v226 != (unsigned int *)v232)
        {
          if (v188 >= *v226) {
            uint64_t v161 = (uint64_t *)*v162;
          }
          else {
            uint64_t v161 = v162;
          }
        }
LABEL_332:
        uint64_t v191 = *v161;
        if (*v161)
        {
          uint64_t v184 = (_DWORD *)(v191 + 104);
          unint64_t v183 = *(unsigned int *)(v191 + 104);
          BOOL v182 = (void *)(v191 + 96);
          unint64_t v185 = *(unsigned int *)(v191 + 108);
          goto LABEL_323;
        }
      }
    }
    unint64_t v194 = (void **)__p[1];
    uint64_t v195 = (void **)v390;
    *((void *)&v391[0] + 1) = 0;
    unint64_t v196 = v390 - (unint64_t)__p[1];
    if ((unint64_t)v390 - (unint64_t)__p[1] >= 0x11)
    {
      do
      {
        operator delete(*v194);
        uint64_t v195 = (void **)v390;
        unint64_t v194 = (void **)((char *)__p[1] + 8);
        __p[1] = v194;
        unint64_t v196 = v390 - (void)v194;
      }
      while ((void)v390 - (void)v194 > 0x10uLL);
    }
    unint64_t v197 = v196 >> 3;
    if (v197 == 1)
    {
      uint64_t v198 = 128;
    }
    else
    {
      if (v197 != 2)
      {
LABEL_343:
        if (v194 != v195)
        {
          do
          {
            uint64_t v199 = *v194++;
            operator delete(v199);
          }
          while (v194 != v195);
          if ((void *)v390 != __p[1]) {
            *(void *)&long long v390 = v390 + (((unint64_t)__p[1] - v390 + 7) & 0xFFFFFFFFFFFFFFF8);
          }
        }
        if (__p[0]) {
          operator delete(__p[0]);
        }
        goto LABEL_349;
      }
      uint64_t v198 = 256;
    }
    *(void *)&v391[0] = v198;
    goto LABEL_343;
  }
LABEL_349:
  uint64_t v200 = v10 + 88;
  uint64_t v201 = *(uint64_t **)(v10 + 96);
  if ((uint64_t *)(v10 + 88) != v201)
  {
    uint64_t v203 = (uint64_t *)(v10 + 88);
    do
    {
      if ((sub_1CC31F1E4((uint64_t *)v10, *v203 + 16) & 1) == 0) {
        sub_1CD5282A4(v10, *v203 + 16, v203);
      }
      uint64_t v203 = (uint64_t *)*v203;
    }
    while (v203 != v201);
  }
  if ((sub_1CC31F8A0((void *)v10) & 1) == 0) {
    sub_1CD5282A4(v10, 0, *(uint64_t **)(v10 + 96));
  }
  llvm::BlockFrequencyInfoImplBase::unwrapLoops((void *)v10);
  if (byte_1EBD02E18)
  {
    llvm::Function::getEntryCount(**(uint64_t *****)(v10 + 128), 0, (uint64_t)__p);
    if ((_BYTE)v390)
    {
      while (v200 != *(void *)(v10 + 96))
      {
        uint64_t v200 = *(void *)v200;
        if (*(_DWORD *)(v200 + 28) >= 2u)
        {
          sub_1CD527FF0(v10);
          break;
        }
      }
    }
  }
  uint64_t Name = (uint64_t)llvm::BlockFrequencyInfoImplBase::finalizeMetrics((llvm::BlockFrequencyInfoImplBase *)v10);
  if (byte_1EBD02D58)
  {
    for (uint64_t j = *((void *)v248 + 41);
          (llvm::MachineFunction *)j != (llvm::MachineFunction *)((char *)v248 + 320);
          uint64_t j = *(void *)(j + 8))
    {
      uint64_t Name = sub_1CC152E2C(*(void *)(v10 + 160), *(_DWORD *)(v10 + 176), j, __p);
      if ((Name & 1) == 0) {
        uint64_t Name = sub_1CD527760(v10, j, 0);
      }
    }
  }
  if (dword_1EBCCD6A0)
  {
    uint64_t v234 = byte_1EBD02887 & 0x7F;
    if (byte_1EBD02887 < 0) {
      uint64_t v234 = qword_1EBD02878;
    }
    if (!v234) {
      goto LABEL_553;
    }
    uint64_t Name = (uint64_t)llvm::MachineFunction::getName((llvm::Value **)v248);
    size_t v236 = v235;
    if (byte_1EBD02887 >= 0) {
      uint64_t v237 = &qword_1EBD02870;
    }
    else {
      uint64_t v237 = (uint64_t *)qword_1EBD02870;
    }
    uint64_t v238 = qword_1EBD02878;
    if (byte_1EBD02887 >= 0) {
      uint64_t v238 = byte_1EBD02887 & 0x7F;
    }
    if (v236 == v238)
    {
      if (!v236 || (uint64_t Name = memcmp((const void *)Name, v237, v236), !Name))
      {
LABEL_553:
        uint64_t v239 = llvm::MachineFunction::getName((llvm::Value **)v248);
        v368[0] = 1283;
        v364 = "MachineBlockFrequencyDAGS.";
        unint64_t v366 = (unint64_t)v239;
        uint64_t v367 = v240;
        v282 = (unsigned char *)v249;
        LOWORD(v391[0]) = 257;
        sub_1CD52756C((uint64_t)&v282, (llvm::Twine *)&v364, 1, (llvm::Twine *)__p);
      }
    }
  }
  if (byte_1EBCCD5E0)
  {
    uint64_t v241 = byte_1EBD02C87 & 0x7F;
    if (byte_1EBD02C87 < 0) {
      uint64_t v241 = qword_1EBD02C78;
    }
    if (!v241) {
      goto LABEL_565;
    }
    uint64_t Name = (uint64_t)llvm::MachineFunction::getName((llvm::Value **)v248);
    size_t v243 = v242;
    if (byte_1EBD02C87 >= 0) {
      v244 = &qword_1EBD02C70;
    }
    else {
      v244 = (uint64_t *)qword_1EBD02C70;
    }
    uint64_t v245 = qword_1EBD02C78;
    if (byte_1EBD02C87 >= 0) {
      uint64_t v245 = byte_1EBD02C87 & 0x7F;
    }
    if (v243 == v245)
    {
      if (!v243 || (uint64_t Name = memcmp((const void *)Name, v244, v243), !Name))
      {
LABEL_565:
        uint64_t v246 = *(void *)(v249 + 248);
        uint64_t v247 = llvm::dbgs((llvm *)Name);
        (*(void (**)(uint64_t, llvm *))(*(void *)v246 + 24))(v246, v247);
      }
    }
  }
}

void llvm::MachineBlockFrequencyInfo::~MachineBlockFrequencyInfo(llvm::MachineBlockFrequencyInfo *this)
{
  *(void *)this = &unk_1F260D550;
  uint64_t v2 = *((void *)this + 31);
  *((void *)this + 31) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *(void *)this = &unk_1F260E110;
  uint64_t v3 = (char *)*((void *)this + 22);
  if (v3 != (char *)this + 192) {
    free(v3);
  }
  uint64_t v4 = (char *)*((void *)this + 13);
  if (v4 != (char *)this + 120) {
    free(v4);
  }
  uint64_t v5 = (char *)*((void *)this + 4);
  if (v5 != (char *)this + 48) {
    free(v5);
  }

  llvm::Pass::~Pass(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F260D550;
  uint64_t v2 = *((void *)this + 31);
  *((void *)this + 31) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  sub_1CBA0E6AC(this);
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F260D550;
  uint64_t v2 = *((void *)this + 31);
  *((void *)this + 31) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  sub_1CBA0E6AC(this);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t llvm::MachineBlockFrequencyInfo::runOnMachineFunction(llvm::MachineBlockFrequencyInfo *this, llvm::MachineFunction *a2)
{
  uint64_t v4 = (uint64_t *)*((void *)this + 1);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_11:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::MachineBranchProbabilityInfo::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_11;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = (const llvm::MachineBranchProbabilityInfo *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::MachineBranchProbabilityInfo::ID);
  uint64_t v9 = (uint64_t *)*((void *)this + 1);
  uint64_t v10 = *v9;
  uint64_t v11 = v9[1];
  if (v10 == v11)
  {
LABEL_7:
    uint64_t v12 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v10 != &llvm::MachineLoopInfo::ID)
    {
      v10 += 16;
      if (v10 == v11) {
        goto LABEL_7;
      }
    }
    uint64_t v12 = *(void *)(v10 + 8);
  }
  uint64_t v13 = (const llvm::MachineLoopInfo *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v12 + 96))(v12, &llvm::MachineLoopInfo::ID);
  llvm::MachineBlockFrequencyInfo::calculate(this, a2, v8, v13);
  return 0;
}

uint64_t llvm::MachineBlockFrequencyInfo::releaseMemory(llvm::MachineBlockFrequencyInfo *this)
{
  uint64_t result = *((void *)this + 31);
  *((void *)this + 31) = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t llvm::MachineBlockFrequencyInfo::getBlockFreq(llvm::MachineBlockFrequencyInfo *this, const llvm::MachineBasicBlock *a2)
{
  uint64_t v2 = *((void *)this + 31);
  if (v2)
  {
    int v3 = *(_DWORD *)(v2 + 176);
    if (v3)
    {
      uint64_t v4 = *(void *)(v2 + 160);
      unsigned int v5 = v3 - 1;
      uint64_t v6 = (v3 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      uint64_t v7 = *(const llvm::MachineBasicBlock **)(v4 + 16 * v6);
      if (v7 == a2)
      {
LABEL_4:
        uint64_t v8 = *(unsigned int *)(v4 + 16 * v6 + 8);
        if (v8 != 0xFFFFFFFFLL) {
          return *(void *)(*(void *)(v2 + 8) + 24 * v8 + 16);
        }
      }
      else
      {
        int v10 = 1;
        while (v7 != (const llvm::MachineBasicBlock *)-4096)
        {
          int v11 = v6 + v10++;
          uint64_t v6 = v11 & v5;
          uint64_t v7 = *(const llvm::MachineBasicBlock **)(v4 + 16 * v6);
          if (v7 == a2) {
            goto LABEL_4;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t sub_1CC31E95C(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 176);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 160);
    unsigned int v4 = v2 - 1;
    uint64_t v5 = (v2 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v6 = *(void *)(v3 + 16 * v5);
    if (v6 == a2)
    {
LABEL_3:
      uint64_t v7 = *(unsigned int *)(v3 + 16 * v5 + 8);
      if (v7 != 0xFFFFFFFFLL) {
        return *(void *)(*(void *)(a1 + 8) + 24 * v7 + 16);
      }
    }
    else
    {
      int v9 = 1;
      while (v6 != -4096)
      {
        int v10 = v5 + v9++;
        uint64_t v5 = v10 & v4;
        uint64_t v6 = *(void *)(v3 + 16 * v5);
        if (v6 == a2) {
          goto LABEL_3;
        }
      }
    }
  }
  return 0;
}

uint64_t llvm::MachineBlockFrequencyInfo::isIrrLoopHeader(llvm::MachineBlockFrequencyInfo *this, const llvm::MachineBasicBlock *a2)
{
  uint64_t v2 = *((void *)this + 31);
  int v3 = *(_DWORD *)(v2 + 176);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(v2 + 160);
  unsigned int v5 = v3 - 1;
  uint64_t v6 = (v3 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v7 = *(const llvm::MachineBasicBlock **)(v4 + 16 * v6);
  if (v7 != a2)
  {
    int v10 = 1;
    while (v7 != (const llvm::MachineBasicBlock *)-4096)
    {
      int v11 = v6 + v10++;
      uint64_t v6 = v11 & v5;
      uint64_t v7 = *(const llvm::MachineBasicBlock **)(v4 + 16 * v6);
      if (v7 == a2) {
        goto LABEL_3;
      }
    }
    return 0;
  }
LABEL_3:
  unsigned int v8 = *(_DWORD *)(v4 + 16 * v6 + 8);
  if (v8 == -1) {
    return 0;
  }
  return sub_1CD460634((uint64_t *)(v2 + 32), v8);
}

uint64_t llvm::MachineBlockFrequencyInfo::getFunction(llvm::MachineBlockFrequencyInfo *this)
{
  uint64_t v1 = *((void *)this + 31);
  if (v1) {
    return *(void *)(v1 + 128);
  }
  else {
    return 0;
  }
}

llvm::ScaledNumberBase *llvm::MachineBlockFrequencyInfo::printBlockFreq(uint64_t a1, llvm::ScaledNumberBase *a2, uint64_t a3)
{
  uint64_t v5 = a3;
  uint64_t v3 = *(void *)(a1 + 248);
  if (v3) {
    return llvm::BlockFrequencyInfoImplBase::printBlockFreq(v3, a2, &v5);
  }
  return a2;
}

llvm::ScaledNumberBase *llvm::MachineBlockFrequencyInfo::printBlockFreq(llvm::MachineBlockFrequencyInfo *this, llvm::raw_ostream *a2, const llvm::MachineBasicBlock *a3)
{
  uint64_t v3 = *((void *)this + 31);
  if (v3) {
    return sub_1CD527874(v3, a2, (uint64_t)a3);
  }
  else {
    return a2;
  }
}

uint64_t llvm::MachineBlockFrequencyInfo::getEntryFreq(llvm::MachineBlockFrequencyInfo *this)
{
  uint64_t v1 = *((void *)this + 31);
  if (v1) {
    return *(void *)(*(void *)(v1 + 8) + 16);
  }
  else {
    return 0;
  }
}

void sub_1CC31EAE0(void *a1)
{
  *a1 = &unk_1F260D610;
  MEMORY[0x1D25D9CD0](a1[20], 8);
  uint64_t v2 = (void *)a1[17];
  if (v2)
  {
    a1[18] = v2;
    operator delete(v2);
  }
  sub_1CBF7A1F4(a1);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC31EB60(void *a1)
{
  *a1 = &unk_1F260D610;
  MEMORY[0x1D25D9CD0](a1[20], 8);
  uint64_t v2 = (void *)a1[17];
  if (v2)
  {
    a1[18] = v2;
    operator delete(v2);
  }

  return sub_1CBF7A1F4(a1);
}

void sub_1CC31EBCC(uint64_t a1, uint64_t a2)
{
  v27[16] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = v24;
  unsigned int v20 = v24;
  uint64_t v5 = *(unsigned char **)(a2 + 8);
  if (v5 == *(unsigned char **)a2)
  {
    long long v21 = v24;
    uint64_t v6 = v5;
  }
  else
  {
    uint64_t v19 = *(unsigned int *)(a2 + 16);
    uint64_t v4 = malloc_type_malloc(8 * v19, 0x4065EBACuLL);
    if (!v4 && (v19 || (uint64_t v4 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    long long v21 = v4;
    uint64_t v6 = *(unsigned char **)a2;
    uint64_t v5 = *(unsigned char **)(a2 + 8);
  }
  unsigned int v8 = *(_DWORD *)(a2 + 16);
  unsigned int v7 = *(_DWORD *)(a2 + 20);
  LODWORD(v22) = v8;
  if (v5 == v6) {
    unsigned int v9 = v7;
  }
  else {
    unsigned int v9 = v8;
  }
  if (v9)
  {
    memmove(v4, v5, 8 * v9);
    unsigned int v7 = *(_DWORD *)(a2 + 20);
  }
  int v10 = *(_DWORD *)(a2 + 24);
  HIDWORD(v22) = v7;
  int v23 = v10;
  int v25 = v27;
  uint64_t v26 = 0x800000000;
  unsigned int v11 = *(_DWORD *)(a2 + 104);
  if (v11)
  {
    if (&v20 == (unsigned char **)a2)
    {
      unsigned int v11 = 0;
    }
    else
    {
      if (v11 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v27, *(const void **)(a2 + 96), 16 * *(unsigned int *)(a2 + 104));
      LODWORD(v26) = v11;
    }
  }
  uint64_t v12 = (void *)(a1 + 32);
  *(void *)a1 = a1 + 32;
  uint64_t v14 = v20;
  uint64_t v13 = v21;
  if (v21 == v20)
  {
    *(void *)(a1 + 8) = v12;
    int v15 = HIDWORD(v22);
    if (HIDWORD(v22)) {
      memmove(v12, v13, 8 * HIDWORD(v22));
    }
  }
  else
  {
    *(void *)(a1 + 8) = v21;
    long long v21 = v14;
    int v15 = HIDWORD(v22);
  }
  int v16 = v23;
  *(_DWORD *)(a1 + 16) = v22;
  *(_DWORD *)(a1 + 20) = v15;
  *(_DWORD *)(a1 + 24) = v16;
  uint64_t v22 = 8;
  *(void *)(a1 + 96) = a1 + 112;
  int v23 = 0;
  *(void *)(a1 + 104) = 0x800000000;
  uint64_t v17 = v25;
  if (v11 && &v20 != (unsigned char **)a1)
  {
    if (v25 == v27)
    {
      memcpy((void *)(a1 + 112), v27, 16 * v11);
      *(_DWORD *)(a1 + 104) = v11;
      uint64_t v17 = v25;
    }
    else
    {
      *(void *)(a1 + 96) = v25;
      int v18 = HIDWORD(v26);
      *(_DWORD *)(a1 + 104) = v11;
      *(_DWORD *)(a1 + 108) = v18;
      int v25 = v27;
      HIDWORD(v26) = 0;
      uint64_t v17 = v27;
    }
    LODWORD(v26) = 0;
  }
  if (v17 != v27) {
    free(v17);
  }
  if (v21 != v20) {
    free(v21);
  }
}

uint64_t *sub_1CC31EE54(uint64_t a1, uint64_t *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    uint64_t v13 = 0;
LABEL_16:
    uint64_t v6 = sub_1CC31EF18(a1, a2, v13);
    uint64_t *v6 = *a2;
    *((_DWORD *)v6 + 2) = -1;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
  uint64_t v6 = (uint64_t *)(*(void *)a1 + 16 * v5);
  uint64_t v7 = *v6;
  if (*a2 != *v6)
  {
    unsigned int v9 = 0;
    int v10 = 1;
    while (v7 != -4096)
    {
      if (v9) {
        BOOL v11 = 0;
      }
      else {
        BOOL v11 = v7 == -8192;
      }
      if (v11) {
        unsigned int v9 = v6;
      }
      unsigned int v12 = v5 + v10++;
      unsigned int v5 = v12 & v4;
      uint64_t v6 = (uint64_t *)(*(void *)a1 + 16 * (v12 & v4));
      uint64_t v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v9) {
      uint64_t v13 = v9;
    }
    else {
      uint64_t v13 = v6;
    }
    goto LABEL_16;
  }
  return v6;
}

uint64_t *sub_1CC31EF18(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) <= v6 >> 3)
    {
      sub_1CC31F050(a1, v6);
      int v16 = 0;
      sub_1CC152E2C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v16);
      a3 = v16;
    }
LABEL_4:
    uint64_t v7 = *a3;
    goto LABEL_5;
  }
  sub_1CC31F050(a1, 2 * v6);
  uint64_t v7 = *a2;
  int v9 = *(_DWORD *)(a1 + 16) - 1;
  unsigned int v10 = ((*a2 >> 4) ^ (*a2 >> 9)) & v9;
  a3 = (uint64_t *)(*(void *)a1 + 16 * v10);
  uint64_t v11 = *a3;
  if (*a2 != *a3)
  {
    unsigned int v12 = 0;
    int v13 = 1;
    while (v11 != -4096)
    {
      if (v12) {
        BOOL v14 = 0;
      }
      else {
        BOOL v14 = v11 == -8192;
      }
      if (v14) {
        unsigned int v12 = a3;
      }
      unsigned int v15 = v10 + v13++;
      unsigned int v10 = v15 & v9;
      a3 = (uint64_t *)(*(void *)a1 + 16 * v10);
      uint64_t v11 = *a3;
      if (v7 == *a3) {
        goto LABEL_5;
      }
    }
    if (v12) {
      a3 = v12;
    }
    goto LABEL_4;
  }
LABEL_5:
  ++*(_DWORD *)(a1 + 8);
  if (v7 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CC31F050(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v12 = *(unsigned int *)(a1 + 16);
    if (v12)
    {
      uint64_t v13 = 16 * v12;
      do
      {
        *uint64_t result = -4096;
        result += 2;
        v13 -= 16;
      }
      while (v13);
    }
    if (v3)
    {
      BOOL v14 = v4;
      do
      {
        uint64_t v15 = *v14;
        if ((*v14 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          int v16 = *(_DWORD *)(a1 + 16) - 1;
          unsigned int v17 = v16 & ((v15 >> 4) ^ (v15 >> 9));
          int v18 = (void *)(*(void *)a1 + 16 * v17);
          uint64_t v19 = *v18;
          if (v15 != *v18)
          {
            unsigned int v20 = 0;
            int v21 = 1;
            while (v19 != -4096)
            {
              if (v20) {
                BOOL v22 = 0;
              }
              else {
                BOOL v22 = v19 == -8192;
              }
              if (v22) {
                unsigned int v20 = v18;
              }
              unsigned int v23 = v17 + v21++;
              unsigned int v17 = v23 & v16;
              int v18 = (void *)(*(void *)a1 + 16 * (v23 & v16));
              uint64_t v19 = *v18;
              if (v15 == *v18) {
                goto LABEL_16;
              }
            }
            if (v20) {
              int v18 = v20;
            }
          }
LABEL_16:
          *int v18 = v15;
          v18[1] = v14[1];
          ++*(_DWORD *)(a1 + 8);
        }
        v14 += 2;
      }
      while (v14 != &v4[2 * v3]);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *uint64_t result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CC31F1E4(uint64_t *a1, uint64_t a2)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = *(_DWORD *)(a2 + 12);
  if (v4 >= 2)
  {
    v61[0] = v62;
    v61[1] = (void *)0x400000000;
    v62[8] = 0;
    char v63 = 0;
    BOOL v57 = 0;
    uint64_t v58 = 0;
    unsigned int v59 = 0;
    sub_1CD45E50C(&v57, v4);
    unsigned int v56 = 0;
    if (*(_DWORD *)(a2 + 12))
    {
      int v20 = 0;
      unsigned int v21 = 0;
      char v22 = 0;
      unint64_t v23 = 0;
      do
      {
        int v24 = (unsigned int *)(*(void *)(a2 + 96) + 4 * v21);
        uint64_t v25 = *v24;
        uint64_t v26 = *(void *)(a1[17] + 8 * v25);
        sub_1CBF7C6A8(a1 + 4, v25);
        if (*(unsigned char *)(v26 + 144))
        {
          unint64_t v27 = *(void *)(v26 + 136);
          ++v20;
          if (v22) {
            BOOL v28 = v27 >= v23;
          }
          else {
            BOOL v28 = 0;
          }
          if (!v28)
          {
            unint64_t v23 = *(void *)(v26 + 136);
            char v22 = 1;
          }
          if (v27) {
            llvm::BlockFrequencyInfoImplBase::Distribution::add((uint64_t)v61, v24, v27, 0);
          }
        }
        else
        {
          sub_1CBF7CCE0((uint64_t)&v57, (int *)&v56, (uint64_t)v60);
        }
        unsigned int v21 = v56 + 1;
        unsigned int v56 = v21;
      }
      while (v21 < *(_DWORD *)(a2 + 12));
      if (v22) {
        goto LABEL_51;
      }
    }
    else
    {
      int v20 = 0;
    }
    unint64_t v23 = 1;
LABEL_51:
    int v41 = &v57[v59];
    if (v58)
    {
      if (v59)
      {
        uint64_t v42 = 4 * v59;
        int v43 = v57;
        while (*v43 >= 0xFFFFFFFE)
        {
          ++v43;
          v42 -= 4;
          if (!v42) {
            goto LABEL_56;
          }
        }
      }
      else
      {
        int v43 = v57;
      }
    }
    else
    {
LABEL_56:
      int v43 = &v57[v59];
    }
    unsigned int v44 = &v57[v59];
LABEL_58:
    while (v43 != v44)
    {
      if (v23) {
        llvm::BlockFrequencyInfoImplBase::Distribution::add((uint64_t)v61, (unsigned int *)(*(void *)(a2 + 96) + 4 * *v43), v23, 0);
      }
      int v45 = v43 + 1;
      while (v45 != v41)
      {
        unsigned int v46 = *v45++;
        if (v46 <= 0xFFFFFFFD)
        {
          int v43 = v45 - 1;
          goto LABEL_58;
        }
      }
      int v43 = v41;
    }
    llvm::BlockFrequencyInfoImplBase::distributeIrrLoopHeaderMass((llvm::BlockFrequencyInfoImplBase *)a1, (llvm::BlockFrequencyInfoImplBase::Distribution *)v61);
    uint64_t v47 = *(unsigned int *)(a2 + 104);
    if (v47)
    {
      unsigned int v48 = *(unsigned int **)(a2 + 96);
      uint64_t v49 = 4 * v47;
      do
      {
        sub_1CC31F634((uint64_t)a1, a2, v48++);
        v49 -= 4;
      }
      while (v49);
    }
    if (!v20) {
      llvm::BlockFrequencyInfoImplBase::adjustLoopHeaderMass((uint64_t)a1, a2);
    }
    MEMORY[0x1D25D9CD0](v57, 4);
    if (v61[0] != v62) {
      free(v61[0]);
    }
    goto LABEL_8;
  }
  unsigned int v5 = **(_DWORD **)(a2 + 96);
  uint64_t v6 = a1[8];
  uint64_t v7 = v6 + 24 * v5;
  unsigned int v8 = *(uint64_t **)(v7 + 8);
  if (!v8)
  {
LABEL_3:
    int v9 = (void *)(v6 + 24 * v5 + 16);
    goto LABEL_4;
  }
  unint64_t v15 = *((unsigned int *)v8 + 3);
  int v16 = (unsigned int *)v8[12];
  if (v15 >= 2)
  {
    unsigned int v17 = *(_DWORD *)v7;
    unsigned int v30 = (unsigned int *)v8[12];
    unint64_t v31 = *((unsigned int *)v8 + 3);
    do
    {
      unint64_t v32 = v31 >> 1;
      int v33 = &v30[v31 >> 1];
      unsigned int v35 = *v33;
      int v34 = v33 + 1;
      v31 += ~(v31 >> 1);
      if (v35 < v17) {
        unsigned int v30 = v34;
      }
      else {
        unint64_t v31 = v32;
      }
    }
    while (v31);
    unsigned int v36 = &v16[v15];
    if (v30 == v36 || v17 < *v30 || !*((unsigned char *)v8 + 8)) {
      goto LABEL_3;
    }
    do
    {
      unint64_t v37 = v15 >> 1;
      unsigned int v38 = &v16[v15 >> 1];
      unsigned int v40 = *v38;
      int v39 = v38 + 1;
      v15 += ~(v15 >> 1);
      if (v40 < v17) {
        int v16 = v39;
      }
      else {
        unint64_t v15 = v37;
      }
    }
    while (v15);
    if (v16 == v36 || v17 < *v16) {
      goto LABEL_14;
    }
  }
  else
  {
    unsigned int v17 = *(_DWORD *)v7;
    if (v17 != *v16 || !*((unsigned char *)v8 + 8)) {
      goto LABEL_3;
    }
  }
  uint64_t v18 = *v8;
  if (!*v8) {
    goto LABEL_14;
  }
  uint64_t v19 = *(unsigned int *)(v18 + 12);
  if (v19 < 2) {
    goto LABEL_14;
  }
  unsigned int v50 = *(unsigned int **)(v18 + 96);
  unint64_t v51 = *(unsigned int *)(v18 + 12);
  do
  {
    unint64_t v52 = v51 >> 1;
    unsigned int v53 = &v50[v51 >> 1];
    unsigned int v55 = *v53;
    uint64_t v54 = v53 + 1;
    v51 += ~(v51 >> 1);
    if (v55 < v17) {
      unsigned int v50 = v54;
    }
    else {
      unint64_t v51 = v52;
    }
  }
  while (v51);
  if (v50 == (unsigned int *)(*(void *)(v18 + 96) + 4 * v19) || v17 < *v50 || !*(unsigned char *)(v18 + 8))
  {
LABEL_14:
    int v9 = v8 + 19;
    goto LABEL_4;
  }
  int v9 = (void *)(v18 + 152);
LABEL_4:
  *int v9 = -1;
  LODWORD(v61[0]) = v5;
  sub_1CC31F634((uint64_t)a1, a2, (unsigned int *)v61);
  uint64_t v10 = *(unsigned int *)(a2 + 12);
  uint64_t v11 = *(unsigned int *)(a2 + 104);
  if (v10 == v11)
  {
LABEL_8:
    llvm::BlockFrequencyInfoImplBase::computeLoopScale((uint64_t)a1, a2);
    llvm::BlockFrequencyInfoImplBase::packageLoop((uint64_t)a1, a2);
    return 1;
  }
  uint64_t v12 = (unsigned int *)(*(void *)(a2 + 96) + 4 * v10);
  uint64_t v13 = 4 * v11 - 4 * v10;
  while ((sub_1CC31F634((uint64_t)a1, a2, v12) & 1) != 0)
  {
    ++v12;
    v13 -= 4;
    if (!v13) {
      goto LABEL_8;
    }
  }
  return 0;
}

uint64_t sub_1CC31F634(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  v37[0] = v38;
  v37[1] = (void *)0x400000000;
  v38[8] = 0;
  char v39 = 0;
  uint64_t v6 = *a3;
  uint64_t v7 = *(void *)(*(void *)(a1 + 64) + 24 * v6 + 8);
  if (!v7 || !*(unsigned char *)(v7 + 8))
  {
    unsigned int v8 = *(void **)(*(void *)(a1 + 136) + 8 * v6);
    int v9 = (void *)v8[11];
    uint64_t v10 = (void *)v8[12];
    if (v9 != v10)
    {
      while (1)
      {
        int v11 = *(_DWORD *)(a1 + 176);
        if (v11)
        {
          uint64_t v12 = *(void *)(a1 + 160);
          unsigned int v13 = v11 - 1;
          uint64_t v14 = ((*v9 >> 4) ^ (*v9 >> 9)) & (v11 - 1);
          uint64_t v15 = *(void *)(v12 + 16 * (((*v9 >> 4) ^ (*v9 >> 9)) & v13));
          if (*v9 == v15)
          {
LABEL_6:
            unsigned int v16 = *(_DWORD *)(v12 + 16 * v14 + 8);
            goto LABEL_7;
          }
          int v28 = 1;
          while (v15 != -4096)
          {
            int v29 = v14 + v28++;
            uint64_t v14 = v29 & v13;
            uint64_t v15 = *(void *)(v12 + 16 * v14);
            if (*v9 == v15) {
              goto LABEL_6;
            }
          }
        }
        unsigned int v16 = -1;
LABEL_7:
        unsigned int v36 = v16;
        unsigned int v17 = (char *)v8[14];
        uint64_t v18 = (char *)v8[15];
        uint64_t v19 = v8[11];
        if (v17 == v18)
        {
          unint64_t v33 = v8[12] - v19;
          BOOL v34 = (v33 >> 3) == 0x80000000;
          unsigned int v35 = ((v33 >> 4) | 0x80000000) / (v33 >> 3);
          if (v34) {
            unsigned int v20 = 1;
          }
          else {
            unsigned int v20 = v35;
          }
        }
        else
        {
          unsigned int v20 = *(_DWORD *)&v17[((uint64_t)v9 - v19) >> 1];
          if (v20 == -1)
          {
            int v21 = 0;
            unsigned int v22 = 0;
            unint64_t v23 = (unsigned int *)v8[14];
            do
            {
              unsigned int v25 = *v23++;
              unsigned int v24 = v25;
              unsigned int v26 = v25 + v22;
              if (v25 + (unint64_t)v22 <= 0x80000000) {
                unsigned int v27 = v26;
              }
              else {
                unsigned int v27 = 0x80000000;
              }
              if (v24 != -1)
              {
                unsigned int v22 = v27;
                ++v21;
              }
            }
            while (v23 != (unsigned int *)v18);
            unsigned int v20 = (0x80000000 - v22) / (((unint64_t)(v18 - v17) >> 2) - v21);
          }
        }
        if ((llvm::BlockFrequencyInfoImplBase::addToDist(a1, (uint64_t)v37, a2, a3, &v36, v20) & 1) == 0) {
          goto LABEL_35;
        }
        if (++v9 == v10) {
          goto LABEL_28;
        }
      }
    }
    goto LABEL_28;
  }
  do
  {
    uint64_t v30 = v7;
    uint64_t v7 = *(void *)v7;
  }
  while (v7 && *(unsigned char *)(v7 + 8));
  if (llvm::BlockFrequencyInfoImplBase::addLoopSuccessorsToDist(a1, a2, v30, (uint64_t)v37))
  {
LABEL_28:
    llvm::BlockFrequencyInfoImplBase::distributeMass(a1, a3, a2, (llvm::BlockFrequencyInfoImplBase::Distribution *)v37);
    uint64_t v31 = 1;
    goto LABEL_29;
  }
LABEL_35:
  uint64_t v31 = 0;
LABEL_29:
  if (v37[0] != v38) {
    free(v37[0]);
  }
  return v31;
}

uint64_t sub_1CC31F8A0(void *a1)
{
  uint64_t v2 = (int *)a1[8];
  uint64_t v3 = (uint64_t *)*((void *)v2 + 1);
  if (!v3) {
    goto LABEL_2;
  }
  unint64_t v12 = *((unsigned int *)v3 + 3);
  unsigned int v13 = (unsigned int *)v3[12];
  if (v12 >= 2)
  {
    unsigned int v14 = *v2;
    unsigned int v17 = (unsigned int *)v3[12];
    unint64_t v18 = *((unsigned int *)v3 + 3);
    do
    {
      unint64_t v19 = v18 >> 1;
      unsigned int v20 = &v17[v18 >> 1];
      unsigned int v22 = *v20;
      int v21 = v20 + 1;
      v18 += ~(v18 >> 1);
      if (v22 < v14) {
        unsigned int v17 = v21;
      }
      else {
        unint64_t v18 = v19;
      }
    }
    while (v18);
    unint64_t v23 = &v13[v12];
    if (v17 == v23 || v14 < *v17 || !*((unsigned char *)v3 + 8)) {
      goto LABEL_2;
    }
    do
    {
      unint64_t v24 = v12 >> 1;
      unsigned int v25 = &v13[v12 >> 1];
      unsigned int v27 = *v25;
      unsigned int v26 = v25 + 1;
      v12 += ~(v12 >> 1);
      if (v27 < v14) {
        unsigned int v13 = v26;
      }
      else {
        unint64_t v12 = v24;
      }
    }
    while (v12);
    if (v13 == v23 || v14 < *v13) {
      goto LABEL_19;
    }
  }
  else
  {
    unsigned int v14 = *v2;
    if (*v2 != *v13 || !*((unsigned char *)v3 + 8))
    {
LABEL_2:
      unsigned int v4 = v2 + 4;
      goto LABEL_3;
    }
  }
  uint64_t v15 = *v3;
  if (!*v3) {
    goto LABEL_19;
  }
  uint64_t v16 = *(unsigned int *)(v15 + 12);
  if (v16 < 2) {
    goto LABEL_19;
  }
  int v28 = *(unsigned int **)(v15 + 96);
  unint64_t v29 = *(unsigned int *)(v15 + 12);
  do
  {
    unint64_t v30 = v29 >> 1;
    uint64_t v31 = &v28[v29 >> 1];
    unsigned int v33 = *v31;
    unint64_t v32 = v31 + 1;
    v29 += ~(v29 >> 1);
    if (v33 < v14) {
      int v28 = v32;
    }
    else {
      unint64_t v29 = v30;
    }
  }
  while (v29);
  if (v28 == (unsigned int *)(*(void *)(v15 + 96) + 4 * v16) || v14 < *v28 || !*(unsigned char *)(v15 + 8))
  {
LABEL_19:
    unsigned int v4 = v3 + 19;
    goto LABEL_3;
  }
  unsigned int v4 = (void *)(v15 + 152);
LABEL_3:
  *unsigned int v4 = -1;
  uint64_t v5 = a1[17];
  uint64_t v6 = a1[18];
  if (v5 == v6) {
    return 1;
  }
  while (1)
  {
    unsigned int v34 = (unint64_t)(v5 - a1[17]) >> 3;
    uint64_t v7 = a1[8] + 24 * v34;
    unsigned int v8 = *(uint64_t **)(v7 + 8);
    int v9 = (_DWORD *)v7;
    if (v8)
    {
      int v9 = (_DWORD *)(a1[8] + 24 * v34);
      if (*((unsigned char *)v8 + 8))
      {
        do
        {
          uint64_t v10 = v8;
          unsigned int v8 = (uint64_t *)*v8;
        }
        while (v8 && *((unsigned char *)v8 + 8));
        int v9 = (_DWORD *)v10[12];
      }
    }
    if (*v9 == *(_DWORD *)v7)
    {
      uint64_t result = sub_1CC31F634((uint64_t)a1, 0, &v34);
      if (!result) {
        break;
      }
    }
    v5 += 8;
    if (v5 == v6) {
      return 1;
    }
  }
  return result;
}

void sub_1CC31FAAC(uint64_t a1, char **a2)
{
  long long v146 = 0u;
  long long v147 = 0u;
  long long v145 = 0u;
  uint64_t v140 = v144;
  int v141 = v144;
  uint64_t v142 = 8;
  int v143 = 0;
  uint64_t v4 = *(void *)(*(void *)(a1 + 128) + 328);
  uint64_t v139 = v4;
  sub_1CD45F140(&v145, &v139);
  uint64_t v5 = v141;
  uint64_t v6 = HIDWORD(v142);
  if (v141 != v140)
  {
    unsigned int v10 = v142;
    goto LABEL_12;
  }
  if (HIDWORD(v142))
  {
    uint64_t v7 = 0;
    uint64_t v8 = 8 * HIDWORD(v142);
    int v9 = v141;
    while (*v9 != v4)
    {
      if (*v9 == -2) {
        uint64_t v7 = v9;
      }
      ++v9;
      v8 -= 8;
      if (!v8)
      {
        if (!v7) {
          goto LABEL_9;
        }
        *uint64_t v7 = v4;
        --v143;
        goto LABEL_33;
      }
    }
    goto LABEL_33;
  }
LABEL_9:
  unsigned int v10 = v142;
  if (HIDWORD(v142) >= v142)
  {
LABEL_12:
    if (3 * v10 <= 4 * (HIDWORD(v142) - v143))
    {
      if (v10 >= 0x40) {
        v10 *= 2;
      }
      else {
        unsigned int v10 = 128;
      }
    }
    else if (v10 - HIDWORD(v142) >= v10 >> 3)
    {
      goto LABEL_14;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v140, v10);
    unsigned int v10 = v142;
    uint64_t v5 = v141;
LABEL_14:
    unsigned int v11 = v10 - 1;
    unsigned int v12 = (v10 - 1) & ((v4 >> 4) ^ (v4 >> 9));
    unsigned int v13 = &v5[8 * v12];
    uint64_t v14 = *(void *)v13;
    if (*(void *)v13 == -1)
    {
      uint64_t v15 = 0;
LABEL_26:
      if (v15) {
        unint64_t v19 = v15;
      }
      else {
        unint64_t v19 = v13;
      }
      if (*(void *)v19 != v4)
      {
        if (*(void *)v19 == -2) {
          --v143;
        }
        else {
          ++HIDWORD(v142);
        }
        *(void *)unint64_t v19 = v4;
      }
    }
    else
    {
      uint64_t v15 = 0;
      int v16 = 1;
      while (v14 != v4)
      {
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v14 == -2;
        }
        if (v17) {
          uint64_t v15 = v13;
        }
        unsigned int v18 = v12 + v16++;
        unsigned int v12 = v18 & v11;
        unsigned int v13 = &v5[8 * (v18 & v11)];
        uint64_t v14 = *(void *)v13;
        if (*(void *)v13 == -1) {
          goto LABEL_26;
        }
      }
    }
    goto LABEL_33;
  }
  ++HIDWORD(v142);
  *(void *)&v141[8 * v6] = v4;
LABEL_33:
  uint64_t v20 = *((void *)&v147 + 1);
  if (!*((void *)&v147 + 1)) {
    goto LABEL_80;
  }
  do
  {
    int v21 = *(const llvm::MachineBasicBlock **)(*(void *)(*((void *)&v145 + 1)
                                                        + (((unint64_t)v147 >> 6) & 0x3FFFFFFFFFFFFF8))
                                            + 8 * (v147 & 0x1FF));
    *(void *)&long long v147 = v147 + 1;
    *((void *)&v147 + 1) = v20 - 1;
    if ((unint64_t)v147 >= 0x400)
    {
      operator delete(**((void ***)&v145 + 1));
      *((void *)&v145 + 1) += 8;
      *(void *)&long long v147 = v147 - 512;
    }
    unsigned int v22 = (const llvm::MachineBasicBlock **)*((void *)v21 + 11);
    unint64_t v23 = (const llvm::MachineBasicBlock **)*((void *)v21 + 12);
    while (v22 != v23)
    {
      unint64_t v24 = *v22;
      uint64_t v134 = v24;
      if (!llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(a1 + 112), v21, v24))goto LABEL_72; {
      unsigned int v25 = v141;
      }
      uint64_t v26 = HIDWORD(v142);
      if (v141 == v140)
      {
        if (HIDWORD(v142))
        {
          unsigned int v27 = 0;
          uint64_t v28 = 8 * HIDWORD(v142);
          unint64_t v29 = (const llvm::MachineBasicBlock **)v141;
          while (*v29 != v24)
          {
            if (*v29 == (const llvm::MachineBasicBlock *)-2) {
              unsigned int v27 = v29;
            }
            ++v29;
            v28 -= 8;
            if (!v28)
            {
              if (!v27) {
                goto LABEL_47;
              }
              *unsigned int v27 = v24;
              --v143;
              goto LABEL_71;
            }
          }
          goto LABEL_72;
        }
LABEL_47:
        unsigned int v30 = v142;
        if (HIDWORD(v142) < v142)
        {
          ++HIDWORD(v142);
          *(void *)&v141[8 * v26] = v24;
LABEL_71:
          sub_1CD45F140(&v145, &v134);
          goto LABEL_72;
        }
      }
      else
      {
        unsigned int v30 = v142;
      }
      if (3 * v30 <= 4 * (HIDWORD(v142) - v143))
      {
        if (v30 >= 0x40) {
          v30 *= 2;
        }
        else {
          unsigned int v30 = 128;
        }
      }
      else if (v30 - HIDWORD(v142) >= v30 >> 3)
      {
        goto LABEL_52;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v140, v30);
      unsigned int v30 = v142;
      unsigned int v25 = v141;
LABEL_52:
      unsigned int v31 = v30 - 1;
      unsigned int v32 = (v30 - 1) & ((v24 >> 4) ^ (v24 >> 9));
      unsigned int v33 = &v25[8 * v32];
      unsigned int v34 = *(const llvm::MachineBasicBlock **)v33;
      if (*(void *)v33 == -1)
      {
        unsigned int v35 = 0;
LABEL_64:
        if (v35) {
          char v39 = v35;
        }
        else {
          char v39 = (const llvm::MachineBasicBlock **)v33;
        }
        if (*v39 != v24)
        {
          if (*v39 == (const llvm::MachineBasicBlock *)-2) {
            --v143;
          }
          else {
            ++HIDWORD(v142);
          }
          *char v39 = v24;
          goto LABEL_71;
        }
      }
      else
      {
        unsigned int v35 = 0;
        int v36 = 1;
        while (v34 != v24)
        {
          if (v35) {
            BOOL v37 = 0;
          }
          else {
            BOOL v37 = v34 == (const llvm::MachineBasicBlock *)-2;
          }
          if (v37) {
            unsigned int v35 = (const llvm::MachineBasicBlock **)v33;
          }
          unsigned int v38 = v32 + v36++;
          unsigned int v32 = v38 & v31;
          unsigned int v33 = &v25[8 * (v38 & v31)];
          unsigned int v34 = *(const llvm::MachineBasicBlock **)v33;
          if (*(void *)v33 == -1) {
            goto LABEL_64;
          }
        }
      }
LABEL_72:
      ++v22;
    }
    uint64_t v20 = *((void *)&v147 + 1);
  }
  while (*((void *)&v147 + 1));
LABEL_80:
  uint64_t v134 = (const llvm::MachineBasicBlock *)v138;
  int v135 = (const llvm::MachineBasicBlock *)v138;
  uint64_t v136 = 8;
  int v137 = 0;
  uint64_t v40 = *(void *)(a1 + 128);
  int v41 = (const llvm::MachineBasicBlock *)(v40 + 320);
  uint64_t v42 = *(const llvm::MachineBasicBlock **)(v40 + 328);
  if (v42 == (const llvm::MachineBasicBlock *)(v40 + 320)) {
    goto LABEL_199;
  }
  while (2)
  {
    if (*((void *)v42 + 11) == *((void *)v42 + 12))
    {
      int v43 = v140;
      if (v141 == v140)
      {
        int v44 = HIDWORD(v142);
        int v45 = &v141[8 * HIDWORD(v142)];
        if (HIDWORD(v142))
        {
          uint64_t v46 = 0;
          while (*(const llvm::MachineBasicBlock **)&v141[v46] != v42)
          {
            v46 += 8;
            if (8 * HIDWORD(v142) == v46) {
              goto LABEL_101;
            }
          }
          int v45 = &v141[v46];
        }
LABEL_101:
        int v43 = v141;
      }
      else
      {
        int v47 = v142 - 1;
        unsigned int v48 = (v142 - 1) & ((v42 >> 4) ^ (v42 >> 9));
        int v45 = &v141[8 * v48];
        uint64_t v49 = *(const llvm::MachineBasicBlock **)v45;
        if (*(void *)v45 == -1)
        {
          unsigned int v50 = 0;
LABEL_109:
          if (v50) {
            int v45 = v50;
          }
          int v44 = HIDWORD(v142);
          if (*(const llvm::MachineBasicBlock **)v45 != v42) {
            int v45 = &v141[8 * v142];
          }
        }
        else
        {
          unsigned int v50 = 0;
          int v51 = 1;
          while (v49 != v42)
          {
            if (v50) {
              BOOL v52 = 0;
            }
            else {
              BOOL v52 = v49 == (const llvm::MachineBasicBlock *)-2;
            }
            if (v52) {
              unsigned int v50 = v45;
            }
            unsigned int v53 = v48 + v51++;
            unsigned int v48 = v53 & v47;
            int v45 = &v141[8 * (v53 & v47)];
            uint64_t v49 = *(const llvm::MachineBasicBlock **)v45;
            if (*(void *)v45 == -1) {
              goto LABEL_109;
            }
          }
          int v44 = HIDWORD(v142);
        }
      }
      int v54 = v141 == v43 ? v44 : v142;
      if (v45 != &v141[8 * v54])
      {
        uint64_t v133 = v42;
        sub_1CD45F140(&v145, &v133);
        unsigned int v55 = v135;
        uint64_t v56 = HIDWORD(v136);
        if (v135 == v134)
        {
          if (HIDWORD(v136))
          {
            BOOL v57 = 0;
            uint64_t v58 = 8 * HIDWORD(v136);
            unsigned int v59 = v135;
            while (*(const llvm::MachineBasicBlock **)v59 != v42)
            {
              if (*(void *)v59 == -2) {
                BOOL v57 = v59;
              }
              unsigned int v59 = (const llvm::MachineBasicBlock *)((char *)v59 + 8);
              v58 -= 8;
              if (!v58)
              {
                if (!v57) {
                  goto LABEL_122;
                }
                *BOOL v57 = v42;
                --v137;
                goto LABEL_106;
              }
            }
            goto LABEL_106;
          }
LABEL_122:
          unsigned int v60 = v136;
          if (HIDWORD(v136) < v136)
          {
            ++HIDWORD(v136);
            *((void *)v135 + v56) = v42;
            goto LABEL_106;
          }
        }
        else
        {
          unsigned int v60 = v136;
        }
        if (3 * v60 <= 4 * (HIDWORD(v136) - v137))
        {
          if (v60 >= 0x40) {
            v60 *= 2;
          }
          else {
            unsigned int v60 = 128;
          }
        }
        else if (v60 - HIDWORD(v136) >= v60 >> 3)
        {
          goto LABEL_127;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v134, v60);
        unsigned int v60 = v136;
        unsigned int v55 = v135;
LABEL_127:
        unsigned int v61 = v60 - 1;
        unsigned int v62 = (v60 - 1) & ((v42 >> 4) ^ (v42 >> 9));
        char v63 = (char *)v55 + 8 * v62;
        uint64_t v64 = *(const llvm::MachineBasicBlock **)v63;
        if (*(void *)v63 == -1)
        {
          unint64_t v65 = 0;
LABEL_139:
          if (v65) {
            uint64_t v69 = (const llvm::MachineBasicBlock **)v65;
          }
          else {
            uint64_t v69 = (const llvm::MachineBasicBlock **)v63;
          }
          if (*v69 != v42)
          {
            if (*v69 == (const llvm::MachineBasicBlock *)-2) {
              --v137;
            }
            else {
              ++HIDWORD(v136);
            }
            *uint64_t v69 = v42;
          }
        }
        else
        {
          unint64_t v65 = 0;
          int v66 = 1;
          while (v64 != v42)
          {
            if (v65) {
              BOOL v67 = 0;
            }
            else {
              BOOL v67 = v64 == (const llvm::MachineBasicBlock *)-2;
            }
            if (v67) {
              unint64_t v65 = v63;
            }
            unsigned int v68 = v62 + v66++;
            unsigned int v62 = v68 & v61;
            char v63 = (char *)v55 + 8 * (v68 & v61);
            uint64_t v64 = *(const llvm::MachineBasicBlock **)v63;
            if (*(void *)v63 == -1) {
              goto LABEL_139;
            }
          }
        }
      }
    }
LABEL_106:
    uint64_t v42 = (const llvm::MachineBasicBlock *)*((void *)v42 + 1);
    if (v42 != v41) {
      continue;
    }
    break;
  }
  uint64_t v70 = *((void *)&v147 + 1);
  if (*((void *)&v147 + 1))
  {
    while (2)
    {
      uint64_t v71 = *(const llvm::MachineBasicBlock **)(*(void *)(*((void *)&v145 + 1)
                                                          + (((unint64_t)v147 >> 6) & 0x3FFFFFFFFFFFFF8))
                                              + 8 * (v147 & 0x1FF));
      *(void *)&long long v147 = v147 + 1;
      *((void *)&v147 + 1) = v70 - 1;
      if ((unint64_t)v147 >= 0x400)
      {
        operator delete(**((void ***)&v145 + 1));
        *((void *)&v145 + 1) += 8;
        *(void *)&long long v147 = v147 - 512;
      }
      unsigned int v72 = (const llvm::MachineBasicBlock **)*((void *)v71 + 8);
      unsigned int v73 = (const llvm::MachineBasicBlock **)*((void *)v71 + 9);
LABEL_156:
      if (v72 == v73)
      {
        uint64_t v70 = *((void *)&v147 + 1);
        if (!*((void *)&v147 + 1)) {
          goto LABEL_199;
        }
        continue;
      }
      break;
    }
    int v74 = *v72;
    uint64_t v133 = v74;
    if (!llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(a1 + 112), v74, v71))goto LABEL_191; {
    unsigned int v75 = v135;
    }
    uint64_t v76 = HIDWORD(v136);
    if (v135 == v134)
    {
      if (HIDWORD(v136))
      {
        unsigned int v77 = 0;
        uint64_t v78 = 8 * HIDWORD(v136);
        unsigned int v79 = (const llvm::MachineBasicBlock **)v135;
        while (*v79 != v74)
        {
          if (*v79 == (const llvm::MachineBasicBlock *)-2) {
            unsigned int v77 = v79;
          }
          ++v79;
          v78 -= 8;
          if (!v78)
          {
            if (!v77) {
              goto LABEL_166;
            }
            *unsigned int v77 = v74;
            --v137;
            goto LABEL_190;
          }
        }
        goto LABEL_191;
      }
LABEL_166:
      unsigned int v80 = v136;
      if (HIDWORD(v136) < v136)
      {
        ++HIDWORD(v136);
        *((void *)v135 + v76) = v74;
        goto LABEL_190;
      }
    }
    else
    {
      unsigned int v80 = v136;
    }
    if (3 * v80 <= 4 * (HIDWORD(v136) - v137))
    {
      if (v80 >= 0x40) {
        v80 *= 2;
      }
      else {
        unsigned int v80 = 128;
      }
    }
    else if (v80 - HIDWORD(v136) >= v80 >> 3)
    {
LABEL_171:
      unsigned int v81 = v80 - 1;
      unsigned int v82 = (v80 - 1) & ((v74 >> 4) ^ (v74 >> 9));
      uint64_t v83 = (char *)v75 + 8 * v82;
      unint64_t v84 = *(const llvm::MachineBasicBlock **)v83;
      if (*(void *)v83 == -1)
      {
        unsigned int v85 = 0;
LABEL_183:
        if (v85) {
          unsigned int v89 = v85;
        }
        else {
          unsigned int v89 = (const llvm::MachineBasicBlock **)v83;
        }
        if (*v89 != v74)
        {
          if (*v89 == (const llvm::MachineBasicBlock *)-2) {
            --v137;
          }
          else {
            ++HIDWORD(v136);
          }
          *unsigned int v89 = v74;
LABEL_190:
          sub_1CD45F140(&v145, &v133);
        }
      }
      else
      {
        unsigned int v85 = 0;
        int v86 = 1;
        while (v84 != v74)
        {
          if (v85) {
            BOOL v87 = 0;
          }
          else {
            BOOL v87 = v84 == (const llvm::MachineBasicBlock *)-2;
          }
          if (v87) {
            unsigned int v85 = (const llvm::MachineBasicBlock **)v83;
          }
          unsigned int v88 = v82 + v86++;
          unsigned int v82 = v88 & v81;
          uint64_t v83 = (char *)v75 + 8 * (v88 & v81);
          unint64_t v84 = *(const llvm::MachineBasicBlock **)v83;
          if (*(void *)v83 == -1) {
            goto LABEL_183;
          }
        }
      }
LABEL_191:
      ++v72;
      goto LABEL_156;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v134, v80);
    unsigned int v80 = v136;
    unsigned int v75 = v135;
    goto LABEL_171;
  }
LABEL_199:
  unsigned int v90 = -1;
  uint64_t v91 = *(void *)(a1 + 128) + 320;
  do
  {
    uint64_t v91 = *(void *)(v91 + 8);
    ++v90;
  }
  while (v91 != *(void *)(a1 + 128) + 320);
  sub_1CBF7ACFC((uint64_t)a2, v90);
  uint64_t v92 = *(void *)(a1 + 128);
  uint64_t v93 = v92 + 320;
  uint64_t v94 = *(void *)(v92 + 328);
  if (v94 != v92 + 320)
  {
    do
    {
      unint64_t v98 = v140;
      if (v141 == v140)
      {
        int v99 = HIDWORD(v142);
        int v100 = &v141[8 * HIDWORD(v142)];
        if (HIDWORD(v142))
        {
          uint64_t v101 = 0;
          while (*(void *)&v141[v101] != v94)
          {
            v101 += 8;
            if (8 * HIDWORD(v142) == v101) {
              goto LABEL_232;
            }
          }
          int v100 = &v141[v101];
        }
LABEL_232:
        unint64_t v98 = v141;
      }
      else
      {
        int v102 = v142 - 1;
        unsigned int v103 = (v142 - 1) & ((v94 >> 4) ^ (v94 >> 9));
        int v100 = &v141[8 * v103];
        uint64_t v104 = *(void *)v100;
        if (*(void *)v100 == -1)
        {
          uint64_t v105 = 0;
LABEL_273:
          if (v105) {
            int v100 = v105;
          }
          int v99 = HIDWORD(v142);
          if (*(void *)v100 != v94) {
            int v100 = &v141[8 * v142];
          }
        }
        else
        {
          uint64_t v105 = 0;
          int v106 = 1;
          while (v104 != v94)
          {
            if (v105) {
              BOOL v107 = 0;
            }
            else {
              BOOL v107 = v104 == -2;
            }
            if (v107) {
              uint64_t v105 = v100;
            }
            unsigned int v108 = v103 + v106++;
            unsigned int v103 = v108 & v102;
            int v100 = &v141[8 * (v108 & v102)];
            uint64_t v104 = *(void *)v100;
            if (*(void *)v100 == -1) {
              goto LABEL_273;
            }
          }
          int v99 = HIDWORD(v142);
        }
      }
      if (v141 == v98) {
        int v109 = v99;
      }
      else {
        int v109 = v142;
      }
      if (v100 != &v141[8 * v109])
      {
        uint64_t v110 = v134;
        if (v135 == v134)
        {
          unsigned int v111 = HIDWORD(v136);
          uint64_t v112 = (char *)v135 + 8 * HIDWORD(v136);
          if (HIDWORD(v136))
          {
            uint64_t v113 = 0;
            while (*(void *)((char *)v135 + v113) != v94)
            {
              v113 += 8;
              if (8 * HIDWORD(v136) == v113) {
                goto LABEL_256;
              }
            }
            uint64_t v112 = (char *)v135 + v113;
          }
LABEL_256:
          uint64_t v110 = v135;
        }
        else
        {
          int v114 = v136 - 1;
          unsigned int v115 = (v136 - 1) & ((v94 >> 4) ^ (v94 >> 9));
          uint64_t v112 = (char *)v135 + 8 * v115;
          uint64_t v116 = *(void *)v112;
          if (*(void *)v112 == -1)
          {
            unint64_t v117 = 0;
LABEL_288:
            if (v117) {
              uint64_t v112 = v117;
            }
            unsigned int v111 = HIDWORD(v136);
            if (*(void *)v112 != v94) {
              uint64_t v112 = (char *)v135 + 8 * v136;
            }
          }
          else
          {
            unint64_t v117 = 0;
            int v118 = 1;
            while (v116 != v94)
            {
              if (v117) {
                BOOL v119 = 0;
              }
              else {
                BOOL v119 = v116 == -2;
              }
              if (v119) {
                unint64_t v117 = v112;
              }
              unsigned int v120 = v115 + v118++;
              unsigned int v115 = v120 & v114;
              uint64_t v112 = (char *)v135 + 8 * (v120 & v114);
              uint64_t v116 = *(void *)v112;
              if (*(void *)v112 == -1) {
                goto LABEL_288;
              }
            }
            unsigned int v111 = HIDWORD(v136);
          }
        }
        if (v135 == v110) {
          unsigned int v121 = v111;
        }
        else {
          unsigned int v121 = v136;
        }
        if (v112 != (char *)v135 + 8 * v121)
        {
          uint64_t v123 = a2[1];
          unint64_t v122 = (unint64_t)a2[2];
          if ((unint64_t)v123 >= v122)
          {
            uint64_t v125 = *a2;
            uint64_t v126 = (v123 - *a2) >> 3;
            unint64_t v127 = v126 + 1;
            if ((unint64_t)(v126 + 1) >> 61) {
              abort();
            }
            uint64_t v128 = v122 - (void)v125;
            if (v128 >> 2 > v127) {
              unint64_t v127 = v128 >> 2;
            }
            if ((unint64_t)v128 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v129 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v129 = v127;
            }
            if (v129)
            {
              if (v129 >> 61) {
                sub_1CB833614();
              }
              uint64_t v130 = (char *)operator new(8 * v129);
            }
            else
            {
              uint64_t v130 = 0;
            }
            uint64_t v131 = &v130[8 * v126];
            *(void *)uint64_t v131 = v94;
            uint64_t v124 = v131 + 8;
            if (v123 != v125)
            {
              do
              {
                uint64_t v132 = *((void *)v123 - 1);
                v123 -= 8;
                *((void *)v131 - 1) = v132;
                v131 -= 8;
              }
              while (v123 != v125);
              uint64_t v123 = *a2;
            }
            *a2 = v131;
            a2[1] = v124;
            a2[2] = &v130[8 * v129];
            if (v123) {
              operator delete(v123);
            }
          }
          else
          {
            *(void *)uint64_t v123 = v94;
            uint64_t v124 = v123 + 8;
          }
          a2[1] = v124;
        }
      }
      uint64_t v94 = *(void *)(v94 + 8);
    }
    while (v94 != v93);
  }
  if (v135 != v134) {
    free(v135);
  }
  if (v141 != v140) {
    free(v141);
  }
  sub_1CD3F260C(&v145);
  unsigned int v95 = (void **)*((void *)&v145 + 1);
  unsigned int v96 = (void **)v146;
  if (*((void *)&v145 + 1) != (void)v146)
  {
    do
    {
      uint64_t v97 = *v95++;
      operator delete(v97);
    }
    while (v95 != v96);
    if ((void)v146 != *((void *)&v145 + 1)) {
      *(void *)&long long v146 = v146 + ((*((void *)&v145 + 1) - v146 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if ((void)v145) {
    operator delete((void *)v145);
  }
}

void sub_1CC320674(uint64_t a1, uint64_t a2, llvm::Twine *this, char a4, llvm::Twine *a5, uint64_t a6)
{
  if (*(char *)(a6 + 23) < 0) {
    uint64_t v11 = *(void *)(a6 + 8);
  }
  else {
    uint64_t v11 = *(unsigned __int8 *)(a6 + 23);
  }
  int v49 = 0;
  if (v11)
  {
    __int16 v44 = 260;
    uint64_t v42 = a6;
    *(void *)&long long v47 = llvm::sys::fs::openFile((unsigned __int8 *)&v42, &v49, 0, 2, 1, 438);
    *((void *)&v47 + 1) = v12;
    unsigned int v13 = std::generic_category();
    uint64_t v42 = 17;
    int v43 = v13;
    uint64_t v14 = (llvm *)(*(uint64_t (**)(void, void, uint64_t *))(**((void **)&v47 + 1) + 32))(*((void *)&v47 + 1), v47, &v42);
    if (v14
      || (uint64_t v14 = (llvm *)((uint64_t (*)(const std::error_category *, long long *, void))v43->equivalent_0)(v43, &v47, v42), v14))
    {
      uint64_t v20 = (llvm::raw_ostream *)llvm::errs(v14);
      int v21 = (void *)*((void *)v20 + 4);
      if (*((void *)v20 + 3) - (void)v21 > 0x17uLL)
      {
        qmemcpy(v21, "file exists, overwriting", 24);
        unsigned int v22 = (unsigned char *)(*((void *)v20 + 4) + 24);
        *((void *)v20 + 4) = v22;
      }
      else
      {
        uint64_t v20 = llvm::raw_ostream::write(v20, "file exists, overwriting", 0x18uLL);
        unsigned int v22 = (unsigned char *)*((void *)v20 + 4);
      }
      unint64_t v23 = (unsigned char *)*((void *)v20 + 3);
    }
    else
    {
      int v15 = v47;
      int v16 = (llvm::raw_ostream *)llvm::errs(v14);
      BOOL v17 = (char *)*((void *)v16 + 4);
      unint64_t v18 = *((void *)v16 + 3) - (void)v17;
      if (v15)
      {
        if (v18 > 0x16)
        {
          qmemcpy(v17, "error writing into file", 23);
          unint64_t v19 = (unsigned char *)(*((void *)v16 + 4) + 23);
          *((void *)v16 + 4) = v19;
        }
        else
        {
          int v16 = llvm::raw_ostream::write(v16, "error writing into file", 0x17uLL);
          unint64_t v19 = (unsigned char *)*((void *)v16 + 4);
        }
        if (*((unsigned char **)v16 + 3) == v19)
        {
          llvm::raw_ostream::write(v16, "\n", 1uLL);
        }
        else
        {
          *unint64_t v19 = 10;
          ++*((void *)v16 + 4);
        }
        *(unsigned char *)(a1 + 23) = 0;
        *(unsigned char *)a1 = 0;
        return;
      }
      if (v18 > 0x21)
      {
        qmemcpy(v17, "writing to the newly created file ", 34);
        *((void *)v16 + 4) += 34;
      }
      else
      {
        int v16 = llvm::raw_ostream::write(v16, "writing to the newly created file ", 0x22uLL);
      }
      char v24 = *(unsigned char *)(a6 + 23);
      BOOL v25 = v24 < 0;
      if (v24 >= 0) {
        uint64_t v26 = (const char *)a6;
      }
      else {
        uint64_t v26 = *(const char **)a6;
      }
      size_t v27 = v24 & 0x7F;
      if (v25) {
        size_t v28 = *(void *)(a6 + 8);
      }
      else {
        size_t v28 = v27;
      }
      uint64_t v20 = llvm::raw_ostream::write(v16, v26, v28);
      unint64_t v23 = (unsigned char *)*((void *)v20 + 3);
      unsigned int v22 = (unsigned char *)*((void *)v20 + 4);
    }
    if (v23 == v22)
    {
      llvm::raw_ostream::write(v20, "\n", 1uLL);
    }
    else
    {
      *unsigned int v22 = 10;
      ++*((void *)v20 + 4);
    }
  }
  else
  {
    llvm::Twine::str(this, __p);
    __int16 v44 = 260;
    uint64_t v42 = (uint64_t)__p;
    llvm::createGraphFilename((llvm *)&v42, (const llvm::Twine *)&v49, (uint64_t)&v47);
    if (*(char *)(a6 + 23) < 0) {
      operator delete(*(void **)a6);
    }
    *(_OWORD *)a6 = v47;
    *(void *)(a6 + 16) = v48;
    HIBYTE(v48) = 0;
    LOBYTE(v47) = 0;
    if (v46 < 0) {
      operator delete(__p[0]);
    }
  }
  unint64_t v29 = (llvm *)llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v42, v49, 1, 0, 0);
  if (v49 == -1)
  {
    unsigned int v30 = (llvm::raw_ostream *)llvm::errs(v29);
    uint64_t v31 = *((void *)v30 + 4);
    if ((unint64_t)(*((void *)v30 + 3) - v31) > 0x13)
    {
      *(_DWORD *)(v31 + 16) = 656434540;
      *(_OWORD *)uint64_t v31 = *(_OWORD *)"error opening file '";
      *((void *)v30 + 4) += 20;
    }
    else
    {
      unsigned int v30 = llvm::raw_ostream::write(v30, "error opening file '", 0x14uLL);
    }
    char v32 = *(unsigned char *)(a6 + 23);
    BOOL v33 = v32 < 0;
    if (v32 >= 0) {
      unsigned int v34 = (const char *)a6;
    }
    else {
      unsigned int v34 = *(const char **)a6;
    }
    size_t v35 = v32 & 0x7F;
    if (v33) {
      size_t v36 = *(void *)(a6 + 8);
    }
    else {
      size_t v36 = v35;
    }
    BOOL v37 = llvm::raw_ostream::write(v30, v34, v36);
    unsigned int v38 = (void *)*((void *)v37 + 4);
    if (*((void *)v37 + 3) - (void)v38 > 0xEuLL)
    {
      qmemcpy(v38, "' for writing!\n", 15);
      *((void *)v37 + 4) += 15;
    }
    else
    {
      llvm::raw_ostream::write(v37, "' for writing!\n", 0xFuLL);
    }
    *(unsigned char *)(a1 + 23) = 0;
    *(unsigned char *)a1 = 0;
  }
  else
  {
    char v39 = (llvm *)sub_1CD528A9C((uint64_t)&v42, a2, a4, a5);
    uint64_t v40 = (llvm::raw_ostream *)llvm::errs(v39);
    int v41 = (void *)*((void *)v40 + 4);
    if (*((void *)v40 + 3) - (void)v41 > 7uLL)
    {
      *int v41 = 0xA202E656E6F6420;
      *((void *)v40 + 4) += 8;
    }
    else
    {
      llvm::raw_ostream::write(v40, " done. \n", 8uLL);
    }
    *(_OWORD *)a1 = *(_OWORD *)a6;
    *(void *)(a1 + 16) = *(void *)(a6 + 16);
    *(void *)(a6 + 8) = 0;
    *(void *)(a6 + 16) = 0;
    *(void *)a6 = 0;
  }
  llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v42);
}

void sub_1CC320AC8(uint64_t **a1, llvm::MachineBasicBlock *a2)
{
  uint64_t v4 = (uint64_t)(a1 + 3);
  sub_1CD529030(v68, (uint64_t)(a1 + 3), (uint64_t)a2, *a1[1], dword_1EBD02958);
  uint64_t v5 = *a1;
  uint64_t v6 = (*a1)[4];
  if ((unint64_t)((*a1)[3] - v6) > 4)
  {
    *(unsigned char *)(v6 + 4) = 101;
    *(_DWORD *)uint64_t v6 = 1685016073;
    v5[4] += 5;
  }
  else
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)*a1, "\tNode", 5uLL);
  }
  llvm::write_hex((llvm::raw_ostream *)v5, (unint64_t)a2, 3, 0, 0);
  uint64_t v7 = (void *)v5[4];
  if ((unint64_t)(v5[3] - (void)v7) > 7)
  {
    *uint64_t v7 = 0x3D65706168735B20;
    v5[4] += 8;
  }
  else
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)v5, " [shape=", 8uLL);
  }
  uint64_t v8 = (llvm::raw_ostream *)*a1;
  uint64_t v9 = (*a1)[4];
  unint64_t v10 = (*a1)[3] - v9;
  if (*((unsigned char *)a1 + 16))
  {
    if (v10 <= 4)
    {
      uint64_t v11 = "none,";
      size_t v12 = 5;
      goto LABEL_10;
    }
    *(unsigned char *)(v9 + 4) = 44;
    *(_DWORD *)uint64_t v9 = 1701736302;
    uint64_t v56 = *((void *)v8 + 4) + 5;
  }
  else
  {
    if (v10 <= 6)
    {
      uint64_t v11 = "record,";
      size_t v12 = 7;
LABEL_10:
      llvm::raw_ostream::write(v8, v11, v12);
      goto LABEL_11;
    }
    *(_DWORD *)(v9 + 3) = 744780399;
    *(_DWORD *)uint64_t v9 = 1868785010;
    uint64_t v56 = *((void *)v8 + 4) + 7;
  }
  *((void *)v8 + 4) = v56;
LABEL_11:
  if (v69 >= 0) {
    size_t v13 = v69 & 0x7F;
  }
  else {
    size_t v13 = (size_t)v68[1];
  }
  if (v13)
  {
    if (v69 >= 0) {
      uint64_t v14 = (const char *)v68;
    }
    else {
      uint64_t v14 = (const char *)v68[0];
    }
    int v15 = llvm::raw_ostream::write((llvm::raw_ostream *)*a1, v14, v13);
    int v16 = (unsigned char *)*((void *)v15 + 4);
    if (*((unsigned char **)v15 + 3) == v16)
    {
      llvm::raw_ostream::write(v15, ",", 1uLL);
    }
    else
    {
      *int v16 = 44;
      ++*((void *)v15 + 4);
    }
  }
  BOOL v17 = (llvm::raw_ostream *)*a1;
  uint64_t v18 = (*a1)[4];
  if ((unint64_t)((*a1)[3] - v18) > 5)
  {
    *(_WORD *)(v18 + 4) = 15724;
    *(_DWORD *)uint64_t v18 = 1700946284;
    *((void *)v17 + 4) += 6;
  }
  else
  {
    llvm::raw_ostream::write(v17, "label=", 6uLL);
  }
  if (*((unsigned char *)a1 + 16))
  {
    uint64_t v23 = *((void *)a2 + 11);
    uint64_t v22 = *((void *)a2 + 12);
    if (v23 == v22)
    {
      unsigned int v24 = 0;
      BOOL v25 = 0;
    }
    else
    {
      int v26 = 0;
      uint64_t v27 = v23 + 8;
      do
      {
        unsigned int v24 = v26 + 1;
        BOOL v25 = v27 != v22;
        if (v27 == v22) {
          break;
        }
        v27 += 8;
      }
      while (v26++ != 63);
    }
    if (v24 <= 1) {
      int v29 = 1;
    }
    else {
      int v29 = v24;
    }
    unsigned int v30 = (llvm::raw_ostream *)*a1;
    uint64_t v31 = (void *)(*a1)[4];
    if ((unint64_t)((*a1)[3] - (void)v31) > 0x30)
    {
      qmemcpy(v31, "<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"", 49);
      char v32 = (void *)(*((void *)v30 + 4) + 49);
      *((void *)v30 + 4) = v32;
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)*a1, "<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"", 0x31uLL);
      char v32 = (void *)*((void *)v30 + 4);
    }
    unint64_t v33 = (v29 + v25);
    if (*((void *)v30 + 3) - (void)v32 > 0x2EuLL)
    {
      qmemcpy(v32, " cellpadding=\"0\"><tr><td align=\"text\" colspan=\"", 47);
      *((void *)v30 + 4) += 47;
    }
    else
    {
      llvm::raw_ostream::write(v30, " cellpadding=\"0\"><tr><td align=\"text\" colspan=\"", 0x2FuLL);
    }
    sub_1CD098D14(v30, v33, 0, 0, 0);
    unsigned int v34 = (_WORD *)*((void *)v30 + 4);
    if (*((void *)v30 + 3) - (void)v34 <= 1uLL)
    {
      int v21 = "\">";
      unint64_t v19 = v30;
      goto LABEL_40;
    }
    *unsigned int v34 = 15906;
    *((void *)v30 + 4) += 2;
  }
  else
  {
    unint64_t v19 = (llvm::raw_ostream *)*a1;
    uint64_t v20 = (_WORD *)(*a1)[4];
    if ((unint64_t)((*a1)[3] - (void)v20) <= 1)
    {
      int v21 = "\"{";
LABEL_40:
      llvm::raw_ostream::write(v19, v21, 2uLL);
      goto LABEL_41;
    }
    *uint64_t v20 = 31522;
    *((void *)v19 + 4) += 2;
  }
LABEL_41:
  size_t v35 = (llvm::raw_ostream *)*a1;
  if (*((unsigned char *)a1 + 16))
  {
    sub_1CD528E98(&__p, v4, a2, *a1[1]);
    if (v59 >= 0) {
      p_p = (const char *)&__p;
    }
    else {
      p_p = (const char *)__p;
    }
    if (v59 >= 0) {
      size_t v40 = HIBYTE(v59) & 0x7F;
    }
    else {
      size_t v40 = v58;
    }
    llvm::raw_ostream::write(v35, p_p, v40);
    uint64_t v41 = *((void *)v35 + 4);
    if ((unint64_t)(*((void *)v35 + 3) - v41) > 4)
    {
      *(unsigned char *)(v41 + 4) = 62;
      *(_DWORD *)uint64_t v41 = 1685335868;
      *((void *)v35 + 4) += 5;
    }
    else
    {
      llvm::raw_ostream::write(v35, "</td>", 5uLL);
    }
    if (SHIBYTE(v59) < 0)
    {
      unsigned int v38 = __p;
      goto LABEL_62;
    }
  }
  else
  {
    sub_1CD528E98(v66, v4, a2, *a1[1]);
    llvm::DOT::EscapeString((char *)v66, (uint64_t)&__p);
    if (v59 >= 0) {
      size_t v36 = (const char *)&__p;
    }
    else {
      size_t v36 = (const char *)__p;
    }
    if (v59 >= 0) {
      size_t v37 = HIBYTE(v59) & 0x7F;
    }
    else {
      size_t v37 = v58;
    }
    llvm::raw_ostream::write(v35, v36, v37);
    if (SHIBYTE(v59) < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v67) < 0)
    {
      unsigned int v38 = v66[0];
LABEL_62:
      operator delete(v38);
    }
  }
  v66[0] = 0;
  v66[1] = 0;
  uint64_t v67 = 0;
  LODWORD(v58) = 0;
  char v62 = 0;
  uint64_t v63 = 0;
  unint64_t v65 = v66;
  int v64 = 0;
  __p = &unk_1F2646F30;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  if (*((unsigned char *)a1 + 16)
    && (llvm::raw_ostream::write((llvm::raw_ostream *)&__p, "</tr><tr>", 9uLL), *((unsigned char *)a1 + 16)))
  {
    uint64_t v42 = (llvm::raw_ostream *)*a1;
    int v43 = (void *)(*a1)[4];
    if ((unint64_t)((*a1)[3] - (void)v43) <= 0xD)
    {
      __int16 v44 = "</tr></table>>";
      size_t v45 = 14;
LABEL_69:
      llvm::raw_ostream::write(v42, v44, v45);
      goto LABEL_70;
    }
    qmemcpy(v43, "</tr></table>>", 14);
    uint64_t v55 = *((void *)v42 + 4) + 14;
  }
  else
  {
    uint64_t v42 = (llvm::raw_ostream *)*a1;
    char v46 = (_WORD *)(*a1)[4];
    if ((unint64_t)((*a1)[3] - (void)v46) <= 1)
    {
      __int16 v44 = "}\"";
      size_t v45 = 2;
      goto LABEL_69;
    }
    *char v46 = 8829;
    uint64_t v55 = *((void *)v42 + 4) + 2;
  }
  *((void *)v42 + 4) = v55;
LABEL_70:
  long long v47 = (llvm::raw_ostream *)*a1;
  uint64_t v48 = (*a1)[4];
  if ((unint64_t)((*a1)[3] - v48) > 2)
  {
    *(unsigned char *)(v48 + 2) = 10;
    *(_WORD *)uint64_t v48 = 15197;
    *((void *)v47 + 4) += 3;
  }
  else
  {
    llvm::raw_ostream::write(v47, "];\n", 3uLL);
  }
  int v49 = (unint64_t *)*((void *)a2 + 11);
  unsigned int v50 = (unint64_t *)*((void *)a2 + 12);
  if (v49 != v50)
  {
    uint64_t v51 = 0;
    do
    {
      BOOL v52 = &v49[v51];
      sub_1CD528F90((uint64_t)a1, a2, &v49[v51]);
      uint64_t v53 = v51 * 8 + 8;
      if ((v51 * 8) == 504) {
        break;
      }
      ++v51;
    }
    while (v52 + 1 != v50);
    int v49 = (unint64_t *)((char *)v49 + v53);
  }
  if (v49 != v50)
  {
    int v54 = v49;
    do
    {
      sub_1CD528F90((uint64_t)a1, a2, v54);
      ++v49;
      ++v54;
    }
    while (v49 != v50);
  }
  __p = &unk_1F2646B98;
  if (v64 == 1 && v59) {
    MEMORY[0x1D25D9CB0](v59, 0x1000C8077774924);
  }
  if (SHIBYTE(v67) < 0) {
    operator delete(v66[0]);
  }
  if (v69 < 0) {
    operator delete(v68[0]);
  }
}

void *sub_1CC3211BC(void **a1)
{
  uint64_t v2 = (char *)*a1;
  uint64_t v1 = (char *)a1[1];
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((v1 - (unsigned char *)*a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((unsigned char *)a1[2] - v2) >> 3) > v4) {
    unint64_t v4 = 0x5555555555555556 * (((unsigned char *)a1[2] - v2) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - v2) >> 3) >= 0x555555555555555) {
    unint64_t v6 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v4;
  }
  if (v6)
  {
    if (v6 > 0xAAAAAAAAAAAAAAALL) {
      sub_1CB833614();
    }
    uint64_t v7 = (char *)operator new(24 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = &v7[24 * v3];
  uint64_t v9 = v8 + 24;
  *(void *)uint64_t v8 = 0;
  *((void *)v8 + 1) = 0;
  *((void *)v8 + 2) = 0;
  if (v1 != v2)
  {
    do
    {
      long long v10 = *(_OWORD *)(v1 - 24);
      *((void *)v8 - 1) = *((void *)v1 - 1);
      *(_OWORD *)(v8 - 24) = v10;
      v8 -= 24;
      v1 -= 24;
    }
    while (v1 != v2);
    uint64_t v1 = (char *)*a1;
  }
  *a1 = v8;
  a1[1] = v9;
  a1[2] = &v7[24 * v6];
  if (v1) {
    operator delete(v1);
  }
  return v9;
}

uint64_t sub_1CC3212CC()
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  int v2 = 1;
  *(void *)&long long v1 = "Pop up a window to show a dag displaying how machine block frequencies propagate through the CFG.";
  *((void *)&v1 + 1) = 97;
  v4.n128_u64[0] = (unint64_t)&v5;
  uint64_t v5 = "none";
  uint64_t v6 = 4;
  int v7 = 0;
  uint64_t v8 = "do not display graphs.";
  uint64_t v9 = 22;
  long long v10 = "fraction";
  uint64_t v11 = 8;
  int v12 = 1;
  size_t v13 = "display a graph using the fractional block frequency representation.";
  uint64_t v14 = 68;
  int v15 = "integer";
  uint64_t v16 = 7;
  int v17 = 2;
  uint64_t v18 = "display a graph using the raw integer fractional block frequency representation.";
  uint64_t v19 = 80;
  uint64_t v20 = "count";
  uint64_t v21 = 5;
  int v22 = 3;
  uint64_t v23 = "display a graph using the real profile count if available.";
  uint64_t v24 = 58;
  v4.n128_u64[1] = 0x400000004;
  sub_1CD527CE0(&v2, &v1, (uint64_t *)&v4);
  if ((const char **)v4.n128_u64[0] != &v5) {
    free((void *)v4.n128_u64[0]);
  }
  __cxa_atexit((void (*)(void *))sub_1CD45C7DC, &qword_1EBCCD620, &dword_1CB82C000);
  int v2 = 1;
  *(void *)&long long v1 = "Pop up a window to show a dag displaying MBP layout and associated block frequencies of the CFG.";
  *((void *)&v1 + 1) = 96;
  v4.n128_u64[0] = (unint64_t)&v5;
  uint64_t v5 = "none";
  uint64_t v6 = 4;
  int v7 = 0;
  uint64_t v8 = "do not display graphs.";
  uint64_t v9 = 22;
  long long v10 = "fraction";
  uint64_t v11 = 8;
  int v12 = 1;
  size_t v13 = "display a graph using the fractional block frequency representation.";
  uint64_t v14 = 68;
  int v15 = "integer";
  uint64_t v16 = 7;
  int v17 = 2;
  uint64_t v18 = "display a graph using the raw integer fractional block frequency representation.";
  uint64_t v19 = 80;
  uint64_t v20 = "count";
  uint64_t v21 = 5;
  int v22 = 3;
  uint64_t v23 = "display a graph using the real profile count if available.";
  uint64_t v24 = 58;
  v4.n128_u64[1] = 0x400000004;
  sub_1CD527E68(&v2, &v1, (uint64_t *)&v4);
  if ((const char **)v4.n128_u64[0] != &v5) {
    free((void *)v4.n128_u64[0]);
  }
  __cxa_atexit((void (*)(void *))sub_1CD45C7DC, &llvm::ViewBlockLayoutWithBFI, &dword_1CB82C000);
  char v3 = 0;
  *(void *)&long long v1 = &v3;
  int v2 = 1;
  v4.n128_u64[0] = (unint64_t)"Print the machine block frequency info.";
  v4.n128_u64[1] = 39;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCCD560, "print-machine-bfi", (unsigned char **)&v1, &v2, &v4);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCCD560, &dword_1CB82C000);
}

void sub_1CC321574(llvm *a1, llvm::PassRegistry *a2)
{
  llvm::initializeMachineBranchProbabilityInfoPass(a1, a2);
  llvm::initializeMachineBlockFrequencyInfoPass(a1, v3);
  llvm::initializeMachinePostDominatorTreePass(a1, v4);
  llvm::initializeMachineLoopInfoPass((uint64_t)a1);
  llvm::initializeProfileSummaryInfoWrapperPassPass(a1, v5);
  operator new();
}

void sub_1CC321634(llvm *a1, llvm::PassRegistry *a2)
{
  llvm::initializeMachineBranchProbabilityInfoPass(a1, a2);
  llvm::initializeMachineBlockFrequencyInfoPass(a1, v3);
  operator new();
}

void sub_1CC3216DC()
{
}

void sub_1CC321868(uint64_t a1)
{
  *(void *)a1 = &unk_1F260D640;
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 920), 8);
  sub_1CC32392C(a1 + 824);
  uint64_t v2 = *(unsigned int *)(a1 + 848);
  if (v2)
  {
    char v3 = *(uint64_t **)(a1 + 840);
    uint64_t v4 = 8 * v2;
    do
    {
      uint64_t v5 = *v3++;
      MEMORY[0x1D25D9CD0](v5, 8);
      v4 -= 8;
    }
    while (v4);
  }
  uint64_t v6 = *(uint64_t **)(a1 + 888);
  uint64_t v7 = *(unsigned int *)(a1 + 896);
  if (v7)
  {
    uint64_t v15 = 16 * v7;
    do
    {
      uint64_t v16 = *v6;
      v6 += 2;
      MEMORY[0x1D25D9CD0](v16, 8);
      v15 -= 16;
    }
    while (v15);
    uint64_t v6 = *(uint64_t **)(a1 + 888);
  }
  if (v6 != (uint64_t *)(a1 + 904)) {
    free(v6);
  }
  uint64_t v8 = *(void **)(a1 + 840);
  if (v8 != (void *)(a1 + 856)) {
    free(v8);
  }
  sub_1CD5295FC(a1 + 632);
  uint64_t v9 = *(void *)(a1 + 576);
  *(void *)(a1 + 576) = 0;
  if (v9)
  {
    MEMORY[0x1D25D9CD0](*(void *)(v9 + 8), 8);
    MEMORY[0x1D25D9CE0](v9, 0x1060C4012208D3FLL);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 536), 8);
  long long v10 = *(void **)(a1 + 392);
  if (v10 != (void *)(a1 + 408)) {
    free(v10);
  }
  uint64_t v11 = *(void **)(a1 + 248);
  if (v11 != (void *)(a1 + 264)) {
    free(v11);
  }
  *(void *)a1 = &unk_1F260E110;
  int v12 = *(void **)(a1 + 176);
  if (v12 != (void *)(a1 + 192)) {
    free(v12);
  }
  size_t v13 = *(void **)(a1 + 104);
  if (v13 != (void *)(a1 + 120)) {
    free(v13);
  }
  uint64_t v14 = *(void **)(a1 + 32);
  if (v14 != (void *)(a1 + 48)) {
    free(v14);
  }

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1CC321A24(uint64_t a1)
{
  sub_1CC321868(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC321A5C(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineBranchProbabilityInfo::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineBlockFrequencyInfo::ID);
  if (byte_1EBCCE088) {
    sub_1CB843600(a2, a2, (uint64_t)&llvm::MachinePostDominatorTree::ID);
  }
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineLoopInfo::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::ProfileSummaryInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::TargetPassConfig::ID);

  llvm::MachineFunctionPass::getAnalysisUsage(a1, a2);
}

uint64_t sub_1CC321B18(llvm::FunctionPass *a1, uint64_t a2)
{
  if ((llvm::FunctionPass::skipFunction(a1, *(llvm::LLVMContextImpl *****)a2) & 1) == 0
    && *(void *)(*(void *)(a2 + 328) + 8) != a2 + 320)
  {
    *((void *)a1 + 70) = a2;
    uint64_t v4 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1];
    if (v5 == v6)
    {
LABEL_6:
      uint64_t v7 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v5 != &llvm::MachineBranchProbabilityInfo::ID)
      {
        v5 += 16;
        if (v5 == v6) {
          goto LABEL_6;
        }
      }
      uint64_t v7 = *(void *)(v5 + 8);
    }
    *((void *)a1 + 71) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::MachineBranchProbabilityInfo::ID);
    uint64_t v9 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v10 = *v9;
    uint64_t v11 = v9[1];
    if (v10 == v11)
    {
LABEL_12:
      uint64_t v12 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v10 != &llvm::MachineBlockFrequencyInfo::ID)
      {
        v10 += 16;
        if (v10 == v11) {
          goto LABEL_12;
        }
      }
      uint64_t v12 = *(void *)(v10 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v12 + 96))(v12, &llvm::MachineBlockFrequencyInfo::ID);
    operator new();
  }
  return 0;
}

void sub_1CC32392C(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 24);
  if (v2)
  {
    char v3 = *(uint64_t **)(a1 + 16);
    uint64_t v4 = &v3[v2];
    do
    {
      uint64_t v5 = *(void *)(a1 + 16);
      uint64_t v6 = *v3;
      if (*v3 == *(void *)(v5 + 8 * *(unsigned int *)(a1 + 24) - 8))
      {
        unint64_t v8 = *(void *)a1;
      }
      else
      {
        uint64_t v7 = (((unint64_t)v3 - v5) >> 10) & 0x1FFFFFF;
        if (v7 >= 0x1E) {
          LOBYTE(v7) = 30;
        }
        unint64_t v8 = v6 + (4096 << v7);
      }
      for (unint64_t i = ((v6 + 7) & 0xFFFFFFFFFFFFFFF8) + 64; i <= v8; i += 64)
      {
        uint64_t v10 = *(void **)(i - 64);
        if ((void *)(i - 48) != v10) {
          free(v10);
        }
      }
      ++v3;
    }
    while (v3 != v4);
  }
  uint64_t v11 = *(unsigned int *)(a1 + 72);
  if (v11)
  {
    uint64_t v12 = *(void **)(a1 + 64);
    size_t v13 = &v12[2 * v11];
    do
    {
      unint64_t v14 = *v12 + v12[1];
      for (unint64_t j = ((*v12 + 7) & 0xFFFFFFFFFFFFFFF8) + 64; j <= v14; j += 64)
      {
        uint64_t v16 = *(void **)(j - 64);
        if ((void *)(j - 48) != v16) {
          free(v16);
        }
      }
      v12 += 2;
    }
    while (v12 != v13);
    uint64_t v17 = *(unsigned int *)(a1 + 72);
    if (v17)
    {
      uint64_t v24 = *(uint64_t **)(a1 + 64);
      uint64_t v25 = 16 * v17;
      do
      {
        uint64_t v26 = *v24;
        v24 += 2;
        MEMORY[0x1D25D9CD0](v26, 8);
        v25 -= 16;
      }
      while (v25);
    }
  }
  *(_DWORD *)(a1 + 72) = 0;
  uint64_t v18 = *(unsigned int *)(a1 + 24);
  if (v18)
  {
    *(void *)(a1 + 80) = 0;
    uint64_t v19 = *(void **)(a1 + 16);
    uint64_t v20 = *v19 + 4096;
    *(void *)a1 = *v19;
    *(void *)(a1 + 8) = v20;
    if (v18 != 1)
    {
      uint64_t v21 = v19 + 1;
      uint64_t v22 = 8 * v18 - 8;
      do
      {
        uint64_t v23 = *v21++;
        MEMORY[0x1D25D9CD0](v23, 8);
        v22 -= 8;
      }
      while (v22);
    }
    *(_DWORD *)(a1 + 24) = 1;
  }
}

void sub_1CC323AC4(uint64_t a1)
{
  v50[16] = *MEMORY[0x1E4F143B8];
  uint64_t v48 = v50;
  uint64_t v49 = 0x400000000;
  uint64_t v2 = *(void *)(a1 + 560);
  char v3 = (void *)(v2 + 320);
  uint64_t v4 = *(void **)(v2 + 328);
  if (v4 != (void *)(v2 + 320))
  {
    do
    {
      *(void *)(a1 + 904) += 64;
      uint64_t v5 = *(void *)(a1 + 824);
      if (((v5 + 7) & 0xFFFFFFFFFFFFFFF8) - v5 + 64 > *(void *)(a1 + 832) - v5)
      {
        unsigned int v7 = *(_DWORD *)(a1 + 848) >> 7;
        if (v7 >= 0x1E) {
          LOBYTE(v7) = 30;
        }
        uint64_t v8 = 4096 << v7;
        unint64_t v6 = (unint64_t)operator new(4096 << v7, (std::align_val_t)8uLL);
        unint64_t v9 = *(unsigned int *)(a1 + 848);
        if (v9 >= *(unsigned int *)(a1 + 852)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 840) + 8 * v9) = v6;
        ++*(_DWORD *)(a1 + 848);
        *(void *)(a1 + 832) = v6 + v8;
      }
      else
      {
        unint64_t v6 = (v5 + 7) & 0xFFFFFFFFFFFFFFF8;
      }
      *(void *)(a1 + 824) = v6 + 64;
      char v39 = v4;
      *(void *)(v6 + 16) = v4;
      *(void *)unint64_t v6 = v6 + 16;
      *(void *)(v6 + 8) = 0x400000001;
      *(void *)(v6 + 48) = a1 + 920;
      *(_DWORD *)(v6 + 56) = 0;
      *sub_1CC3261A0(a1 + 920, (uint64_t *)&v39) = v6;
      while (1)
      {
        LODWORD(v49) = 0;
        char v39 = 0;
        __int16 v44 = 0;
        if (!(*(unsigned int (**)(void, void *, unsigned char **, void **, void **, void))(**(void **)(a1 + 600) + 248))(*(void *)(a1 + 600), v4, &v39, &v44, &v48, 0)|| !llvm::MachineBasicBlock::getFallThrough((llvm::MachineBasicBlock *)v4))
        {
          break;
        }
        uint64_t v4 = (void *)v4[1];
        sub_1CC32466C((void *)v6, (uint64_t)v4, 0);
      }
      uint64_t v4 = (void *)v4[1];
    }
    while (v4 != v3);
  }
  *(void *)(a1 + 592) = 0;
  uint64_t v10 = *(void *)(a1 + 584);
  uint64_t v11 = *(uint64_t **)(v10 + 272);
  uint64_t v12 = *(uint64_t **)(v10 + 280);
  while (v11 != v12)
  {
    uint64_t v13 = *v11++;
    sub_1CC324774(a1, v13);
  }
  char v39 = v43;
  size_t v40 = v43;
  uint64_t v41 = 4;
  int v42 = 0;
  uint64_t v14 = *(void *)(a1 + 560);
  uint64_t v15 = (void *)(v14 + 320);
  uint64_t v16 = *(void *)(v14 + 328);
  if (v16 != v14 + 320)
  {
    do
    {
      sub_1CC325EE8((_DWORD *)a1, v16, (uint64_t)&v39, 0);
      uint64_t v16 = *(void *)(v16 + 8);
    }
    while ((void *)v16 != v15);
    uint64_t v15 = *(void **)(*(void *)(a1 + 560) + 328);
  }
  __int16 v44 = v15;
  uint64_t v17 = sub_1CC3261A0(a1 + 920, (uint64_t *)&v44);
  uint64_t v18 = *v17;
  sub_1CC326208(a1, *(void *)(*(void *)(a1 + 560) + 328), *v17, 0);
  uint64_t v19 = *(void **)(a1 + 560);
  unint64_t v20 = v19[14] - v19[13];
  unint64_t v21 = (v20 >> 3);
  __int16 v44 = v47;
  int v46 = 4;
  if (v21 >= 5)
  {
    int v45 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if ((v20 >> 3)) {
    bzero(v47, 8 * v21);
  }
  int v45 = v20 >> 3;
  uint64_t v22 = (void *)v19[41];
  if (v22 != v19 + 40)
  {
    uint64_t v23 = 0;
    do
    {
      uint64_t v24 = v22;
      if (v23) {
        *((void *)v44 + *((int *)v23 + 6)) = v22;
      }
      uint64_t v22 = (void *)v22[1];
      uint64_t v23 = v24;
    }
    while (v22 != v19 + 40);
    uint64_t v19 = *(void **)(a1 + 560);
  }
  *((void *)v44 + *(int *)(v19[40] + 24)) = 0;
  uint64_t v25 = *(unsigned int *)(v18 + 8);
  uint64_t v26 = *(void *)(a1 + 560);
  if (v25)
  {
    uint64_t v27 = *(int ****)v18;
    size_t v28 = *(int ***)(v26 + 328);
    uint64_t v29 = 8 * v25;
    do
    {
      unsigned int v30 = *v27;
      if (v28 == *v27)
      {
        size_t v28 = (int **)v28[1];
      }
      else
      {
        uint64_t v31 = (int **)v30[1];
        if (v31 != v28 && v31 != v30)
        {
          unint64_t v33 = *v31;
          unsigned int v34 = *v30;
          *((void *)v34 + 1) = v31;
          void *v31 = v34;
          size_t v35 = *v28;
          *((void *)v33 + 1) = v28;
          *unsigned int v30 = v35;
          *((void *)v35 + 1) = v30;
          *size_t v28 = v33;
        }
      }
      if (v30 != **(int ****)v18)
      {
        size_t v36 = *v30;
        LODWORD(v49) = 0;
        uint64_t v37 = 0;
        uint64_t v38 = 0;
        if (((*(uint64_t (**)(void, int *, uint64_t *, uint64_t *, void **, void))(**(void **)(a1 + 600)
                                                                                              + 248))(*(void *)(a1 + 600), v36, &v38, &v37, &v48, 0) & 1) == 0)llvm::MachineBasicBlock::updateTerminator((llvm::MachineBasicBlock *)v36, *((llvm::MachineBasicBlock **)v44 + v36[6]));
      }
      ++v27;
      v29 -= 8;
    }
    while (v29);
    uint64_t v26 = *(void *)(a1 + 560);
  }
  LODWORD(v49) = 0;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  if (((*(uint64_t (**)(void, void, uint64_t *, uint64_t *, void **, void))(**(void **)(a1 + 600)
                                                                                         + 248))(*(void *)(a1 + 600), *(void *)(v26 + 320), &v38, &v37, &v48, 0) & 1) == 0)llvm::MachineBasicBlock::updateTerminator(*(llvm::MachineBasicBlock **)(*(void *)(a1 + 560) + 320), *((llvm::MachineBasicBlock **)v44 + *(int *)(*(void *)(*(void *)(a1 + 560) + 320) + 24)));
  *(_DWORD *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 400) = 0;
  if (v44 != v47) {
    free(v44);
  }
  if (v40 != v39) {
    free(v40);
  }
  if (v48 != v50) {
    free(v48);
  }
}

unsigned int *sub_1CC323FC0(unsigned int *result)
{
  long long v1 = result;
  unsigned int v2 = result[2];
  if (v2)
  {
    uint64_t v3 = result[4];
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      uint64_t result = *(unsigned int **)result;
      int v4 = 1 << (33 - __clz(v2 - 1));
      if (v4 <= 64) {
        int v5 = 64;
      }
      else {
        int v5 = v4;
      }
      if (v5 == v3)
      {
        *((void *)v1 + 1) = 0;
        uint64_t v6 = 16 * v3;
        do
        {
          *(void *)uint64_t result = -4096;
          result += 4;
          v6 -= 16;
        }
        while (v6);
      }
      else
      {
        MEMORY[0x1D25D9CD0](result, 8);
        unint64_t v9 = (4 * v5 / 3u + 1) | ((unint64_t)(4 * v5 / 3u + 1) >> 1);
        unint64_t v10 = v9 | (v9 >> 2) | ((v9 | (v9 >> 2)) >> 4);
        LODWORD(v10) = (((v10 | (v10 >> 8)) >> 16) | v10 | (v10 >> 8)) + 1;
        v1[4] = v10;
        uint64_t result = (unsigned int *)operator new(16 * v10, (std::align_val_t)8uLL);
        *(void *)long long v1 = result;
        *((void *)v1 + 1) = 0;
        uint64_t v11 = v1[4];
        if (v11)
        {
          uint64_t v12 = 16 * v11;
          do
          {
            *(void *)uint64_t result = -4096;
            result += 4;
            v12 -= 16;
          }
          while (v12);
        }
      }
      return result;
    }
  }
  else
  {
    if (!result[3]) {
      return result;
    }
    LODWORD(v3) = result[4];
    if (v3 > 0x40)
    {
      uint64_t result = (unsigned int *)MEMORY[0x1D25D9CD0](*(void *)result, 8);
      *(void *)long long v1 = 0;
      *((void *)v1 + 1) = 0;
      v1[4] = 0;
      return result;
    }
  }
  if (v3)
  {
    unsigned int v7 = *(void **)result;
    uint64_t v8 = 16 * v3;
    do
    {
      *unsigned int v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  *((void *)result + 1) = 0;
  return result;
}

unsigned int *sub_1CC324108(unsigned int *result)
{
  long long v1 = result;
  unsigned int v2 = result[2];
  if (v2 || result[3])
  {
    uint64_t v3 = result[4];
    uint64_t result = *(unsigned int **)result;
    if (v3 <= 4 * v2 || v3 < 0x41)
    {
      if (v3)
      {
        uint64_t v7 = 24 * v3;
        do
        {
          *(void *)uint64_t result = -4096;
          result += 6;
          v7 -= 24;
        }
        while (v7);
      }
      *((void *)v1 + 1) = 0;
    }
    else if (v2)
    {
      int v4 = 1 << (33 - __clz(v2 - 1));
      if (v4 <= 64) {
        int v5 = 64;
      }
      else {
        int v5 = v4;
      }
      if (v5 == v3)
      {
        *((void *)v1 + 1) = 0;
        uint64_t v6 = 24 * v3;
        do
        {
          *(void *)uint64_t result = -4096;
          result += 6;
          v6 -= 24;
        }
        while (v6);
      }
      else
      {
        MEMORY[0x1D25D9CD0](result, 8);
        unint64_t v8 = (4 * v5 / 3u + 1) | ((unint64_t)(4 * v5 / 3u + 1) >> 1);
        unint64_t v9 = v8 | (v8 >> 2) | ((v8 | (v8 >> 2)) >> 4);
        LODWORD(v9) = (((v9 | (v9 >> 8)) >> 16) | v9 | (v9 >> 8)) + 1;
        v1[4] = v9;
        uint64_t result = (unsigned int *)operator new(24 * v9, (std::align_val_t)8uLL);
        *(void *)long long v1 = result;
        *((void *)v1 + 1) = 0;
        uint64_t v10 = v1[4];
        if (v10)
        {
          uint64_t v11 = 24 * v10;
          do
          {
            *(void *)uint64_t result = -4096;
            result += 6;
            v11 -= 24;
          }
          while (v11);
        }
      }
    }
    else
    {
      uint64_t result = (unsigned int *)MEMORY[0x1D25D9CD0](result, 8);
      *(void *)long long v1 = 0;
      *((void *)v1 + 1) = 0;
      v1[4] = 0;
    }
  }
  return result;
}

uint64_t sub_1CC32424C(uint64_t result, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    uint64_t v4 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    int v5 = (void *)(result + 32 * v4);
    uint64_t v6 = *v5;
    if (*v5 != a3)
    {
      uint64_t v7 = 0;
      int v8 = 1;
      while (v6 != -4096)
      {
        if (v7) {
          BOOL v9 = 0;
        }
        else {
          BOOL v9 = v6 == -8192;
        }
        if (v9) {
          uint64_t v7 = v5;
        }
        int v10 = v4 + v8++;
        uint64_t v4 = v10 & (a2 - 1);
        int v5 = (void *)(result + 32 * v4);
        uint64_t v6 = *v5;
        if (*v5 == a3) {
          goto LABEL_13;
        }
      }
      if (v7) {
        int v5 = v7;
      }
    }
  }
  else
  {
    int v5 = 0;
  }
LABEL_13:
  *a4 = v5;
  return result;
}

void *sub_1CC3242C8(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v24 = a3;
  int v5 = *(_DWORD *)(a1 + 8);
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (4 * v5 + 4 >= (3 * v6))
  {
    int v7 = 2 * v6;
  }
  else
  {
    int v7 = *(_DWORD *)(a1 + 16);
    if ((int)v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_3;
    }
  }
  uint64_t v9 = *(void *)a1;
  unint64_t v10 = (v7 - 1) | ((unint64_t)(v7 - 1) >> 1);
  unint64_t v11 = v10 | (v10 >> 2) | ((v10 | (v10 >> 2)) >> 4);
  int v12 = ((v11 | (v11 >> 8)) >> 16) | v11 | (v11 >> 8);
  if ((v12 + 1) > 0x40) {
    unsigned int v13 = v12 + 1;
  }
  else {
    unsigned int v13 = 64;
  }
  *(_DWORD *)(a1 + 16) = v13;
  uint64_t v14 = operator new(32 * v13, (std::align_val_t)8uLL);
  *(void *)a1 = v14;
  if (v9)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v15 = *(unsigned int *)(a1 + 16);
    if (v15)
    {
      uint64_t v16 = 32 * v15;
      do
      {
        *uint64_t v14 = -4096;
        v14 += 4;
        v16 -= 32;
      }
      while (v16);
    }
    if (v6)
    {
      int v17 = 0;
      uint64_t v18 = 32 * v6;
      uint64_t v19 = v9;
      do
      {
        uint64_t v20 = *(void *)v19;
        if ((*(void *)v19 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          uint64_t v25 = 0;
          sub_1CC32424C(*(void *)a1, *(_DWORD *)(a1 + 16), v20, &v25);
          unint64_t v21 = v25;
          *uint64_t v25 = v20;
          v21[1] = 0;
          v21[2] = 0;
          v21[3] = 0;
          *(_OWORD *)(v21 + 1) = *(_OWORD *)(v19 + 8);
          v21[3] = *(void *)(v19 + 24);
          ++v17;
          *(void *)(v19 + 8) = 0;
          *(void *)(v19 + 16) = 0;
          *(void *)(v19 + 24) = 0;
          *(_DWORD *)(a1 + 8) = v17;
        }
        v19 += 32;
        v18 -= 32;
      }
      while (v18);
    }
    MEMORY[0x1D25D9CD0](v9, 8);
    uint64_t v14 = *(void **)a1;
    LODWORD(v22) = *(_DWORD *)(a1 + 16);
  }
  else
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v22 = *(unsigned int *)(a1 + 16);
    if (v22)
    {
      uint64_t v23 = 0;
      do
      {
        v14[v23] = -4096;
        v23 += 4;
      }
      while (4 * v22 != v23);
    }
  }
  sub_1CC32424C((uint64_t)v14, v22, *a2, &v24);
  int v5 = *(_DWORD *)(a1 + 8);
  a3 = v24;
LABEL_3:
  *(_DWORD *)(a1 + 8) = v5 + 1;
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CC3244A0(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v23 = a3;
  int v5 = *(_DWORD *)(a1 + 8);
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (4 * v5 + 4 >= (3 * v6))
  {
    int v7 = 2 * v6;
  }
  else
  {
    int v7 = *(_DWORD *)(a1 + 16);
    if ((int)v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_3;
    }
  }
  uint64_t v9 = *(void *)a1;
  unint64_t v10 = (v7 - 1) | ((unint64_t)(v7 - 1) >> 1);
  unint64_t v11 = v10 | (v10 >> 2) | ((v10 | (v10 >> 2)) >> 4);
  int v12 = ((v11 | (v11 >> 8)) >> 16) | v11 | (v11 >> 8);
  if ((v12 + 1) > 0x40) {
    unsigned int v13 = v12 + 1;
  }
  else {
    unsigned int v13 = 64;
  }
  *(_DWORD *)(a1 + 16) = v13;
  uint64_t v14 = operator new(24 * v13, (std::align_val_t)8uLL);
  *(void *)a1 = v14;
  if (v9)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v15 = *(unsigned int *)(a1 + 16);
    if (v15)
    {
      uint64_t v16 = 24 * v15;
      do
      {
        *uint64_t v14 = -4096;
        v14 += 3;
        v16 -= 24;
      }
      while (v16);
    }
    if (v6)
    {
      int v17 = (_OWORD *)(v9 + 8);
      uint64_t v18 = 24 * v6;
      do
      {
        uint64_t v19 = *((void *)v17 - 1);
        if ((v19 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          uint64_t v24 = 0;
          sub_1CC01F510(*(void *)a1, *(_DWORD *)(a1 + 16), v19, &v24);
          uint64_t v20 = v24;
          *uint64_t v24 = v19;
          *(_OWORD *)(v20 + 1) = *v17;
          ++*(_DWORD *)(a1 + 8);
        }
        int v17 = (_OWORD *)((char *)v17 + 24);
        v18 -= 24;
      }
      while (v18);
    }
    MEMORY[0x1D25D9CD0](v9, 8);
    uint64_t v14 = *(void **)a1;
    LODWORD(v21) = *(_DWORD *)(a1 + 16);
  }
  else
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v21 = *(unsigned int *)(a1 + 16);
    if (v21)
    {
      uint64_t v22 = 0;
      do
      {
        v14[v22] = -4096;
        v22 += 3;
      }
      while (3 * v21 != v22);
    }
  }
  sub_1CC01F510((uint64_t)v14, v21, *a2, &v23);
  int v5 = *(_DWORD *)(a1 + 8);
  a3 = v23;
LABEL_3:
  *(_DWORD *)(a1 + 8) = v5 + 1;
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CC32466C(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  uint64_t v11 = a2;
  if (a3)
  {
    uint64_t v4 = *(unsigned int *)(a3 + 8);
    if (v4)
    {
      int v5 = *(uint64_t **)a3;
      uint64_t v6 = 8 * v4;
      do
      {
        uint64_t v7 = *v5;
        uint64_t v10 = *v5;
        unint64_t v8 = *((unsigned int *)v3 + 2);
        if (v8 >= *((unsigned int *)v3 + 3)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*v3 + 8 * v8) = v7;
        ++*((_DWORD *)v3 + 2);
        uint64_t result = sub_1CC3261A0(v3[6], &v10);
        *uint64_t result = v3;
        ++v5;
        v6 -= 8;
      }
      while (v6);
    }
  }
  else
  {
    unsigned int v9 = *((_DWORD *)result + 2);
    if (v9 >= *((_DWORD *)result + 3)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*result + 8 * v9) = a2;
    ++*((_DWORD *)result + 2);
    uint64_t result = sub_1CC3261A0(result[6], &v11);
    *uint64_t result = v3;
  }
  return result;
}

void sub_1CC324774(uint64_t a1, uint64_t a2)
{
  v290[6] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(uint64_t **)(a2 + 8);
  int v5 = *(uint64_t **)(a2 + 16);
  while (v4 != v5)
  {
    uint64_t v6 = *v4++;
    sub_1CC324774(a1, v6);
  }
  v282[0] = 1;
  uint64_t v7 = 1;
  int64x2_t v8 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  do
  {
    *(int64x2_t *)&v282[v7] = v8;
    v7 += 2;
  }
  while (v7 != 17);
  v283 = v285;
  uint64_t v284 = 0x1000000000;
  llvm::Function::getEntryCount(**(uint64_t *****)(a1 + 560), 0, (uint64_t)&BlockFreq);
  unsigned int v9 = *(const llvm::MachineBasicBlock ***)(a2 + 32);
  if (v288 | byte_1EBCCDCC8)
  {
    uint64_t v10 = (const llvm::MachineBasicBlock **)*((void *)*v9 + 8);
    uint64_t v11 = (const llvm::MachineBasicBlock **)*((void *)*v9 + 9);
    if (v10 == v11)
    {
      unint64_t v12 = 0;
    }
    else
    {
      unint64_t v12 = 0;
      do
      {
        unsigned int v13 = *v10;
        uint64_t v15 = *(void *)(a2 + 56);
        uint64_t v14 = *(void *)(a2 + 64);
        if (v14 == v15)
        {
          uint64_t v16 = *(unsigned int *)(a2 + 76);
          int v17 = (const llvm::MachineBasicBlock **)(v14 + 8 * v16);
          if (v16)
          {
            uint64_t v18 = 0;
            while (*(const llvm::MachineBasicBlock **)(v14 + v18) != v13)
            {
              v18 += 8;
              if (8 * v16 == v18) {
                goto LABEL_28;
              }
            }
            int v17 = (const llvm::MachineBasicBlock **)(v14 + v18);
          }
LABEL_28:
          uint64_t v15 = *(void *)(a2 + 64);
        }
        else
        {
          uint64_t v19 = *(unsigned int *)(a2 + 72);
          int v20 = v19 - 1;
          unsigned int v21 = (v19 - 1) & ((v13 >> 4) ^ (v13 >> 9));
          int v17 = (const llvm::MachineBasicBlock **)(v14 + 8 * v21);
          uint64_t v22 = *v17;
          if (*v17 == (const llvm::MachineBasicBlock *)-1)
          {
            uint64_t v23 = 0;
LABEL_36:
            if (v23) {
              int v17 = v23;
            }
            LODWORD(v16) = *(_DWORD *)(a2 + 76);
            size_t v28 = (const llvm::MachineBasicBlock **)(v14 + 8 * v19);
            if (*v17 != v13) {
              int v17 = v28;
            }
          }
          else
          {
            uint64_t v23 = 0;
            int v24 = 1;
            while (v22 != v13)
            {
              if (v23) {
                BOOL v25 = 0;
              }
              else {
                BOOL v25 = v22 == (const llvm::MachineBasicBlock *)-2;
              }
              if (v25) {
                uint64_t v23 = v17;
              }
              unsigned int v26 = v21 + v24++;
              unsigned int v21 = v26 & v20;
              int v17 = (const llvm::MachineBasicBlock **)(v14 + 8 * (v26 & v20));
              uint64_t v22 = *v17;
              if (*v17 == (const llvm::MachineBasicBlock *)-1) {
                goto LABEL_36;
              }
            }
            LODWORD(v16) = *(_DWORD *)(a2 + 76);
          }
        }
        if (v14 == v15) {
          unsigned int v27 = v16;
        }
        else {
          unsigned int v27 = *(_DWORD *)(a2 + 72);
        }
        if (v17 == (const llvm::MachineBasicBlock **)(v14 + 8 * v27))
        {
          BlockFreq = (uint64_t *)llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(a1 + 576), *v10);
          unsigned int EdgeProbability = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(a1 + 568), v13, **(const llvm::MachineBasicBlock ***)(a2 + 32));
          unint64_t v30 = llvm::BlockFrequency::operator*((unint64_t *)&BlockFreq, EdgeProbability);
          if (__CFADD__(v30, v12)) {
            unint64_t v12 = -1;
          }
          else {
            v12 += v30;
          }
        }
        ++v10;
      }
      while (v10 != v11);
      unsigned int v9 = *(const llvm::MachineBasicBlock ***)(a2 + 32);
    }
    for (unint64_t i = *(const llvm::MachineBasicBlock ***)(a2 + 40); v9 != i; ++v9)
    {
      char v32 = *v9;
      v273 = v32;
      if ((sub_1CD5297D8((uint64_t)v282, (uint64_t)v32, &BlockFreq) & 1) == 0)
      {
        unint64_t v33 = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(a1 + 576), v32);
        if (v33)
        {
          if (v12 / v33 <= dword_1EBCCDC08)
          {
            unsigned int v34 = (void ****)sub_1CC3261A0(a1 + 920, (uint64_t *)&v273);
            uint64_t v35 = *((unsigned int *)*v34 + 2);
            if (v35)
            {
              size_t v36 = **v34;
              uint64_t v37 = 8 * v35;
              do
              {
                uint64_t v38 = (uint64_t *)*v36++;
                BlockFreq = v38;
                sub_1CD5296A0((uint64_t)v282, (uint64_t *)&BlockFreq);
                v37 -= 8;
              }
              while (v37);
            }
          }
        }
      }
    }
  }
  else
  {
    sub_1CD529724(v282, *(uint64_t **)(a2 + 32), *(uint64_t **)(a2 + 40));
  }
  if (byte_1EBCCDE48)
  {
    BOOL v39 = 1;
  }
  else if (byte_1EBCCDD88)
  {
    llvm::Function::getEntryCount(**(uint64_t *****)(a1 + 560), 0, (uint64_t)&BlockFreq);
    BOOL v39 = (_BYTE)v288 != 0;
  }
  else
  {
    BOOL v39 = 0;
  }
  uint64_t v278 = 0;
  uint64_t v40 = *(void *)(**(void **)(a1 + 560) + 112);
  uint64_t v272 = a1;
  if (v40 && ((*(unsigned char *)(v40 + 17) & 4) != 0 || *(char *)(v40 + 13) < 0)
    || llvm::shouldOptimizeForSize(**(llvm::MachineBasicBlock ***)(a2 + 32), *(void *)(a1 + 624), *(llvm::MBFIWrapper **)(a1 + 576)))
  {
    uint64_t v41 = **(void **)(a2 + 32);
  }
  else
  {
    uint64_t v41 = **(void **)(a2 + 32);
    v279 = (uint64_t **)v41;
    if (v41)
    {
      uint64_t v184 = a1 + 920;
      uint64_t v280 = (uint64_t **)v41;
      unint64_t v185 = (uint64_t ***)sub_1CC3261A0(a1 + 920, (uint64_t *)&v280);
      unint64_t v186 = *v185;
      if (sub_1CD5297D8((uint64_t)v282, ***v185, &BlockFreq))
      {
        uint64_t v187 = a1 + 536;
        uint64_t v271 = a1 + 536;
        while (v41 == **v186)
        {
          uint64_t v189 = *(uint64_t **)(v41 + 64);
          unsigned int v188 = *(uint64_t **)(v41 + 72);
          if (v189 == v188) {
            goto LABEL_67;
          }
          uint64_t v190 = 0;
          unint64_t v191 = 0;
          do
          {
            uint64_t v192 = *v189;
            if (sub_1CD5297D8((uint64_t)v282, *v189, &BlockFreq))
            {
              if (v192 != **(void **)(a2 + 32))
              {
                unint64_t v194 = *(const llvm::MachineBasicBlock ***)(v192 + 88);
                uint64_t v193 = *(void *)(v192 + 96);
                unint64_t v195 = (unint64_t)(v193 - (void)v194) >> 3;
                if (v195 <= 2)
                {
                  uint64_t v252 = v41;
                  unint64_t v196 = (const llvm::MachineBasicBlock *)v280;
                  if (v195 == 2)
                  {
                    unint64_t v197 = *v194;
                    if (*v194 == (const llvm::MachineBasicBlock *)v280) {
                      unint64_t v197 = *(const llvm::MachineBasicBlock **)(v193 - 8);
                    }
                  }
                  else
                  {
                    unint64_t v197 = 0;
                  }
                  uint64_t v198 = *(void *)(v192 + 64);
                  if (((*(void *)(v192 + 72) - v198) & 0x7FFFFFFF8) != 8) {
                    goto LABEL_342;
                  }
                  uint64_t v200 = *(uint64_t ****)(*(void *)v198 + 88);
                  uint64_t v199 = *(void *)(*(void *)v198 + 96);
                  if (((v199 - (void)v200) & 0x7FFFFFFF8) != 0x10) {
                    goto LABEL_342;
                  }
                  uint64_t v201 = *v200;
                  if (v201 == (uint64_t **)v192) {
                    uint64_t v201 = *(uint64_t ***)(v199 - 8);
                  }
                  if (v201 == v280)
                  {
                    uint64_t v41 = v252;
                    uint64_t v187 = v271;
                  }
                  else
                  {
LABEL_342:
                    uint64_t v263 = v184;
                    unint64_t v257 = v191;
                    unint64_t v260 = sub_1CC327498(v272, v280, (uint64_t)v282);
                    BOOL v250 = v39;
                    if (v197)
                    {
                      BlockFreq = (uint64_t *)llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v272 + 576), (const llvm::MachineBasicBlock *)v192);
                      unsigned int v202 = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(v272 + 568), (const llvm::MachineBasicBlock *)v192, v197);
                      unint64_t v197 = (const llvm::MachineBasicBlock *)llvm::BlockFrequency::operator*((unint64_t *)&BlockFreq, v202);
                    }
                    BlockFreq = (uint64_t *)llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v272 + 576), (const llvm::MachineBasicBlock *)v192);
                    unsigned int v203 = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(v272 + 568), (const llvm::MachineBasicBlock *)v192, v196);
                    unint64_t v204 = llvm::BlockFrequency::operator*((unint64_t *)&BlockFreq, v203);
                    int v205 = *(const llvm::MachineBasicBlock ***)(v192 + 64);
                    uint64_t v267 = *(const llvm::MachineBasicBlock ***)(v192 + 72);
                    if (v205 == v267)
                    {
                      unint64_t v213 = 0;
                      unint64_t v206 = 0;
                      unint64_t v191 = v257;
                    }
                    else
                    {
                      unint64_t v253 = v204;
                      v255 = v197;
                      unint64_t v206 = 0;
                      unint64_t v207 = 0;
                      do
                      {
                        unint64_t v208 = v206;
                        int v209 = *v205;
                        v281 = v209;
                        if (sub_1CD5297D8((uint64_t)v282, (uint64_t)v209, &BlockFreq)
                          && ((uint64_t v210 = *sub_1CC3261A0(v184, (uint64_t *)&v281)) == 0
                           || v209 == *(const llvm::MachineBasicBlock **)(*(void *)v210
                                                                        + 8 * *(unsigned int *)(v210 + 8)
                                                                        - 8)))
                        {
                          BlockFreq = (uint64_t *)llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v272 + 576), v209);
                          uint64_t v184 = v263;
                          unsigned int v211 = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(v272 + 568), v209, (const llvm::MachineBasicBlock *)v192);
                          unint64_t v212 = llvm::BlockFrequency::operator*((unint64_t *)&BlockFreq, v211);
                          if (v212 <= v208)
                          {
                            unint64_t v206 = v208;
                          }
                          else
                          {
                            unint64_t v207 = v209;
                            unint64_t v206 = v212;
                          }
                        }
                        else
                        {
                          unint64_t v206 = v208;
                        }
                        ++v205;
                      }
                      while (v205 != v267);
                      v273 = v207;
                      if (v207)
                      {
                        unint64_t v248 = v206;
                        uint64_t v220 = (const llvm::MachineBasicBlock **)*((void *)v207 + 11);
                        unint64_t v219 = (const llvm::MachineBasicBlock **)*((void *)v207 + 12);
                        if (v220 == v219)
                        {
                          unint64_t v268 = 0;
                        }
                        else
                        {
                          unint64_t v268 = 0;
                          do
                          {
                            uint64_t v223 = *v220;
                            v281 = v223;
                            if (v223 != (const llvm::MachineBasicBlock *)v192 && v223 != v207)
                            {
                              if (sub_1CD5297D8((uint64_t)v282, (uint64_t)v223, &BlockFreq))
                              {
                                if (*(void *)(v272 + 536) + 24 * *(unsigned int *)(v272 + 552) == sub_1CC327644(v271, (uint64_t)v223))
                                {
                                  uint64_t v226 = (const llvm::MachineBasicBlock ***)*sub_1CC3261A0(v263, (uint64_t *)&v281);
                                  if ((!v226 || v223 == **v226)
                                    && v226 != (const llvm::MachineBasicBlock ***)*sub_1CC3261A0(v263, (uint64_t *)&v273))
                                  {
                                    BlockFreq = (uint64_t *)llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v272 + 576), v207);
                                    unsigned int v227 = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(v272 + 568), v207, v223);
                                    unint64_t v228 = llvm::BlockFrequency::operator*((unint64_t *)&BlockFreq, v227);
                                    unint64_t v229 = v268;
                                    if (v228 > v268) {
                                      unint64_t v229 = v228;
                                    }
                                    unint64_t v268 = v229;
                                  }
                                }
                              }
                            }
                            ++v220;
                          }
                          while (v220 != v219);
                        }
                        BlockFreq = (uint64_t *)llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v272 + 576), v207);
                        unsigned int v221 = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(v272 + 568), v207, (const llvm::MachineBasicBlock *)v192);
                        unint64_t v222 = llvm::BlockFrequency::operator*((unint64_t *)&BlockFreq, v221);
                        uint64_t v184 = v263;
                        unint64_t v213 = v268;
                        if (v268 > v222) {
                          unint64_t v213 = 0;
                        }
                        unint64_t v206 = v248;
                        if (v268 > v222) {
                          unint64_t v206 = 0;
                        }
                      }
                      else
                      {
                        unint64_t v213 = 0;
                      }
                      BOOL v39 = v250;
                      unint64_t v197 = v255;
                      unint64_t v191 = v257;
                      unint64_t v204 = v253;
                    }
                    BOOL v217 = __CFADD__(v213, v204);
                    unint64_t v214 = v213 + v204;
                    if (v217) {
                      unint64_t v214 = -1;
                    }
                    uint64_t v215 = (uint64_t)v197 + v260;
                    if (__CFADD__(v197, v260)) {
                      uint64_t v215 = -1;
                    }
                    BOOL v217 = __CFADD__(v206, v215);
                    unint64_t v216 = v206 + v215;
                    if (v217) {
                      unint64_t v216 = -1;
                    }
                    BOOL v217 = v214 >= v216;
                    BOOL v78 = v214 > v216;
                    unint64_t v218 = v214 - v216;
                    uint64_t v41 = v252;
                    uint64_t v187 = v271;
                    if (v78)
                    {
                      if (!v217) {
                        unint64_t v218 = 0;
                      }
                      if (v218 > v191 || v218 == v191 && *(uint64_t ***)(v192 + 8) == v280)
                      {
                        unint64_t v191 = v218;
                        uint64_t v190 = v192;
                      }
                    }
                  }
                }
              }
            }
            ++v189;
          }
          while (v189 != v188);
          if (v190)
          {
            a1 = v272;
            do
            {
              uint64_t v230 = (uint64_t **)v190;
              unsigned int v231 = *(uint64_t **)(v190 + 64);
              if (((*(void *)(v190 + 72) - (void)v231) & 0x7FFFFFFF8) != 8) {
                break;
              }
              uint64_t v190 = *v231;
              if (((*(void *)(*v231 + 96) - *(void *)(*v231 + 88)) & 0x7FFFFFFF8) != 8) {
                break;
              }
            }
            while (v190 != **(void **)(a2 + 32));
          }
          else
          {
            uint64_t v230 = v280;
            a1 = v272;
          }
          v279 = v230;
          if (v230 == (uint64_t **)v41) {
            goto LABEL_67;
          }
          uint64_t v232 = sub_1CC32742C(v187, (uint64_t *)&v279);
          *uint64_t v232 = v41;
          *((unsigned char *)v232 + 8) = 0;
          uint64_t v280 = v230;
          uint64_t v233 = (uint64_t ***)sub_1CC3261A0(v184, (uint64_t *)&v280);
          unint64_t v186 = *v233;
          uint64_t v41 = (uint64_t)v230;
          if ((sub_1CD5297D8((uint64_t)v282, ***v233, &BlockFreq) & 1) == 0) {
            goto LABEL_412;
          }
        }
      }
      uint64_t v230 = (uint64_t **)v41;
LABEL_412:
      uint64_t v41 = (uint64_t)v230;
    }
  }
LABEL_67:
  unint64_t v42 = 0;
  uint64_t v278 = v41;
  *(void *)(a1 + 592) = 0;
  if (v39) {
    goto LABEL_70;
  }
  if (v41 != **(void **)(a2 + 32))
  {
    unint64_t v42 = 0;
    goto LABEL_70;
  }
  BlockFreq = (uint64_t *)v41;
  uint64_t v136 = a1 + 920;
  int v137 = (uint64_t ***)sub_1CC3261A0(a1 + 920, (uint64_t *)&BlockFreq);
  if (!sub_1CD5297D8((uint64_t)v282, ***v137, &BlockFreq))
  {
    unint64_t v42 = 0;
    uint64_t v140 = 0;
    goto LABEL_442;
  }
  v281 = 0;
  BlockFreq = v290;
  uint64_t v287 = (uint64_t)v290;
  uint64_t v288 = 4;
  int v289 = 0;
  unsigned int v138 = *(uint64_t ****)(a2 + 32);
  v270 = *(uint64_t ****)(a2 + 40);
  if (v270 == v138)
  {
LABEL_313:
    unint64_t v42 = 0;
    uint64_t v140 = 0;
    goto LABEL_440;
  }
  uint64_t v251 = v41;
  BOOL v249 = v39;
  unint64_t v254 = 0;
  uint64_t v139 = 0;
  uint64_t v140 = 0;
  do
  {
    uint64_t v280 = *v138;
    int v141 = v280;
    uint64_t v142 = sub_1CC3261A0(v136, (uint64_t *)&v280);
    int v143 = (void *)*v142;
    if (v141 != *(uint64_t ***)(*(void *)*v142 + 8 * *(unsigned int *)(*v142 + 8) - 8))
    {
      uint64_t v144 = v139;
      goto LABEL_310;
    }
    v266 = v140;
    long long v146 = (uint64_t ***)v141[11];
    long long v145 = v141[12];
    if (v146 == (uint64_t ***)v145) {
      goto LABEL_309;
    }
    uint64_t v256 = v139;
    uint64_t v259 = v138;
    char v147 = 0;
    uint64_t v144 = v139;
    uint64_t v262 = v266;
    do
    {
      while (1)
      {
        uint64_t v148 = *v146;
        v279 = v148;
        if (*((unsigned char *)v148 + 184)) {
          BOOL v149 = 1;
        }
        else {
          BOOL v149 = v148 == v141;
        }
        if (v149 || v143 == (void *)*sub_1CC3261A0(v136, (uint64_t *)&v279)) {
          goto LABEL_278;
        }
        unsigned int v150 = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(v272 + 568), (const llvm::MachineBasicBlock *)v141, (const llvm::MachineBasicBlock *)v148);
        if ((sub_1CD5297D8((uint64_t)v282, (uint64_t)v148, &v273) & 1) == 0) {
          break;
        }
        ++v146;
        char v147 = 1;
        if (v146 == (uint64_t ***)v145)
        {
          unsigned int v138 = v259;
          uint64_t v140 = v262;
          goto LABEL_310;
        }
      }
      uint64_t v151 = *(void *)(v272 + 584);
      int v152 = *(_DWORD *)(v151 + 264);
      if (!v152) {
        goto LABEL_254;
      }
      uint64_t v153 = *(void *)(v151 + 248);
      unsigned int v154 = v152 - 1;
      uint64_t v155 = (v152 - 1) & ((v148 >> 4) ^ (v148 >> 9));
      int v156 = *(uint64_t ***)(v153 + 16 * v155);
      if (v148 != v156)
      {
        int v157 = 1;
        while (v156 != (uint64_t **)-4096)
        {
          int v158 = v155 + v157++;
          uint64_t v155 = v158 & v154;
          int v156 = *(uint64_t ***)(v153 + 16 * v155);
          if (v148 == v156) {
            goto LABEL_253;
          }
        }
LABEL_254:
        int v160 = 0;
        goto LABEL_255;
      }
LABEL_253:
      unint64_t v159 = *(void **)(v153 + 16 * v155 + 8);
      if (!v159) {
        goto LABEL_254;
      }
      int v160 = 0;
      uint64_t v163 = v159;
      do
      {
        uint64_t v163 = (void *)*v163;
        ++v160;
      }
      while (v163);
      if (v159 != (void *)a2)
      {
        int v164 = (void *)a2;
        while (v164)
        {
          int v164 = (void *)*v164;
          if (v164 == v159) {
            goto LABEL_266;
          }
        }
        goto LABEL_255;
      }
LABEL_266:
      uint64_t v165 = v287;
      uint64_t v166 = HIDWORD(v288);
      if ((uint64_t *)v287 != BlockFreq)
      {
        unsigned int v170 = v288;
LABEL_281:
        if (3 * v170 <= 4 * (HIDWORD(v288) - v289))
        {
          if (v170 >= 0x40) {
            v170 *= 2;
          }
          else {
            unsigned int v170 = 128;
          }
        }
        else if (v170 - HIDWORD(v288) >= v170 >> 3)
        {
          goto LABEL_283;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&BlockFreq, v170);
        unsigned int v170 = v288;
        uint64_t v165 = v287;
LABEL_283:
        unsigned int v171 = v170 - 1;
        unsigned int v172 = (v170 - 1) & ((v141 >> 4) ^ (v141 >> 9));
        int v173 = (uint64_t ***)(v165 + 8 * v172);
        uint64_t v174 = *v173;
        if (*v173 == (uint64_t **)-1)
        {
          uint64_t v175 = 0;
LABEL_295:
          if (v175) {
            unsigned int v179 = v175;
          }
          else {
            unsigned int v179 = v173;
          }
          if (*v179 != v141)
          {
            if (*v179 == (uint64_t **)-2) {
              --v289;
            }
            else {
              ++HIDWORD(v288);
            }
            llvm::Type *v179 = v141;
          }
        }
        else
        {
          uint64_t v175 = 0;
          int v176 = 1;
          while (v174 != v141)
          {
            if (v175) {
              BOOL v177 = 0;
            }
            else {
              BOOL v177 = v174 == (uint64_t **)-2;
            }
            if (v177) {
              uint64_t v175 = v173;
            }
            unsigned int v178 = v172 + v176++;
            unsigned int v172 = v178 & v171;
            int v173 = (uint64_t ***)(v165 + 8 * (v178 & v171));
            uint64_t v174 = *v173;
            if (*v173 == (uint64_t **)-1) {
              goto LABEL_295;
            }
          }
        }
        goto LABEL_255;
      }
      if (HIDWORD(v288))
      {
        unsigned int v167 = 0;
        uint64_t v168 = 8 * HIDWORD(v288);
        uint64_t v169 = (uint64_t ***)v287;
        while (*v169 != v141)
        {
          if (*v169 == (uint64_t **)-2) {
            unsigned int v167 = v169;
          }
          ++v169;
          v168 -= 8;
          if (!v168)
          {
            if (!v167) {
              goto LABEL_274;
            }
            *unsigned int v167 = v141;
            --v289;
            goto LABEL_255;
          }
        }
        goto LABEL_255;
      }
LABEL_274:
      unsigned int v170 = v288;
      if (HIDWORD(v288) >= v288) {
        goto LABEL_281;
      }
      ++HIDWORD(v288);
      *(void *)(v287 + 8 * v166) = v141;
LABEL_255:
      v273 = (const llvm::MachineBasicBlock *)llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v272 + 576), (const llvm::MachineBasicBlock *)v141);
      unint64_t v161 = llvm::BlockFrequency::operator*((unint64_t *)&v273, v150);
      uint64_t v162 = v161;
      if (!v262 || v160 || v161 > v254) {
        goto LABEL_277;
      }
      if (v141[1] != (uint64_t *)v148)
      {
        uint64_t v144 = v254;
        goto LABEL_278;
      }
      uint64_t v144 = v254;
      if (v161 >= llvm::BlockFrequency::operator*((unint64_t *)&v281, (unint64_t)(((((unint64_t)(100 - dword_1EBCCDB48) << 31) | 0x30)* (unsigned __int128)0xA3D70A3D70A3D70BLL) >> 64) >> 6))
      {
LABEL_277:
        v281 = (const llvm::MachineBasicBlock *)v162;
        unint64_t v254 = v162;
        uint64_t v144 = v162;
        uint64_t v262 = v141;
      }
LABEL_278:
      ++v146;
    }
    while (v146 != (uint64_t ***)v145);
    unsigned int v138 = v259;
    uint64_t v140 = v262;
    uint64_t v139 = v256;
    if ((v147 & 1) == 0)
    {
LABEL_309:
      v281 = (const llvm::MachineBasicBlock *)v139;
      unint64_t v254 = v139;
      uint64_t v144 = v139;
      uint64_t v140 = v266;
    }
LABEL_310:
    ++v138;
    uint64_t v139 = v144;
  }
  while (v138 != v270);
  if (!v140)
  {
    unint64_t v42 = 0;
    a1 = v272;
    LOBYTE(v39) = v249;
    uint64_t v41 = v251;
    goto LABEL_440;
  }
  a1 = v272;
  LOBYTE(v39) = v249;
  uint64_t v41 = v251;
  if (((*(void *)(a2 + 40) - *(void *)(a2 + 32)) & 0x7FFFFFFF8) == 8) {
    goto LABEL_313;
  }
  unsigned int v237 = HIDWORD(v288);
  unint64_t v42 = v254;
  if (HIDWORD(v288) != v289)
  {
    uint64_t v238 = BlockFreq;
    if ((uint64_t *)v287 == BlockFreq)
    {
      uint64_t v239 = (char *)(v287 + 8 * HIDWORD(v288));
      if (HIDWORD(v288))
      {
        uint64_t v240 = 0;
        while (*(uint64_t ***)(v287 + v240) != v140)
        {
          v240 += 8;
          if (8 * HIDWORD(v288) == v240) {
            goto LABEL_436;
          }
        }
        uint64_t v239 = (char *)(v287 + v240);
      }
LABEL_436:
      uint64_t v238 = (void *)v287;
    }
    else
    {
      int v241 = v288 - 1;
      unsigned int v242 = (v288 - 1) & ((v140 >> 4) ^ (v140 >> 9));
      uint64_t v239 = (char *)(v287 + 8 * v242);
      size_t v243 = *(uint64_t ***)v239;
      if (*(void *)v239 == -1)
      {
        v244 = 0;
LABEL_444:
        if (v244) {
          uint64_t v239 = v244;
        }
        if (*(uint64_t ***)v239 != v140) {
          uint64_t v239 = (char *)(v287 + 8 * v288);
        }
      }
      else
      {
        v244 = 0;
        int v245 = 1;
        while (v243 != v140)
        {
          if (v244) {
            BOOL v246 = 0;
          }
          else {
            BOOL v246 = v243 == (uint64_t **)-2;
          }
          if (v246) {
            v244 = v239;
          }
          unsigned int v247 = v242 + v245++;
          unsigned int v242 = v247 & v241;
          uint64_t v239 = (char *)(v287 + 8 * (v247 & v241));
          size_t v243 = *(uint64_t ***)v239;
          if (*(void *)v239 == -1) {
            goto LABEL_444;
          }
        }
      }
    }
    if ((void *)v287 != v238) {
      unsigned int v237 = v288;
    }
    if (v239 == (char *)(v287 + 8 * v237)) {
      goto LABEL_313;
    }
  }
LABEL_440:
  if ((uint64_t *)v287 != BlockFreq) {
    free((void *)v287);
  }
LABEL_442:
  *(void *)(a1 + 592) = v140;
LABEL_70:
  uint64_t v43 = a1 + 920;
  uint64_t v44 = *sub_1CC3261A0(a1 + 920, &v278);
  v273 = (const llvm::MachineBasicBlock *)v277;
  v274 = (const llvm::MachineBasicBlock *)v277;
  int v276 = 0;
  uint64_t v275 = 0x100000004;
  uint64_t v269 = v44;
  v277[0] = v44;
  if (v284)
  {
    int v45 = (uint64_t *)v283;
    uint64_t v46 = 8 * v284;
    do
    {
      uint64_t v47 = *v45++;
      sub_1CC325EE8((_DWORD *)a1, v47, (uint64_t)&v273, (uint64_t)v282);
      v46 -= 8;
    }
    while (v46);
  }
  uint64_t v48 = v41;
  uint64_t v49 = (const llvm::MachineBasicBlock ***)v269;
  sub_1CC326208(a1, v48, v269, (uint64_t)v282);
  if (v39)
  {
    unsigned int v50 = **(const llvm::MachineBasicBlock ***)v269;
    if (*(const llvm::MachineBasicBlock **)(*((void *)v50 + 4) + 328) != v50)
    {
      uint64_t v51 = (const llvm::MachineBasicBlock **)(*(void *)v269 + 8 * *(unsigned int *)(v269 + 8));
      BOOL v52 = (uint64_t *)*((void *)v50 + 8);
      uint64_t v53 = (uint64_t *)*((void *)v50 + 9);
      if (v52 == v53)
      {
        unint64_t v264 = 0;
      }
      else
      {
        unint64_t v264 = 0;
        do
        {
          v281 = (const llvm::MachineBasicBlock *)*v52;
          int v54 = v281;
          uint64_t v55 = *sub_1CC3261A0(v43, (uint64_t *)&v281);
          if ((sub_1CD5297D8((uint64_t)v282, (uint64_t)v54, &BlockFreq) & 1) == 0
            && (!v55 || v54 == *(const llvm::MachineBasicBlock **)(*(void *)v55 + 8 * *(unsigned int *)(v55 + 8) - 8)))
          {
            BlockFreq = (uint64_t *)llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v272 + 576), v54);
            unsigned int v56 = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(v272 + 568), v54, v50);
            unint64_t v57 = llvm::BlockFrequency::operator*((unint64_t *)&BlockFreq, v56);
            unint64_t v58 = dword_1EBCCDF08;
            if (dword_1EBCCDF08)
            {
              if (dword_1EBCCDF08 == 0x80000000) {
                unsigned int v59 = 1;
              }
              else {
                unsigned int v59 = ((dword_1EBCCDF08 >> 1) | 0x80000000) / dword_1EBCCDF08;
              }
              LODWORD(BlockFreq) = v59;
              unint64_t v58 = llvm::BranchProbability::scaleByInverse((llvm::BranchProbability *)&BlockFreq, v57);
            }
            if (((*((void *)v54 + 12) - *((void *)v54 + 11)) & 0x7FFFFFFF8) == 8)
            {
              unint64_t v60 = dword_1EBCCDFC8;
              if (dword_1EBCCDFC8)
              {
                unsigned int v61 = ((dword_1EBCCDFC8 >> 1) | 0x80000000) / dword_1EBCCDFC8;
                if (dword_1EBCCDFC8 == 0x80000000) {
                  unsigned int v61 = 1;
                }
                LODWORD(BlockFreq) = v61;
                unint64_t v60 = llvm::BranchProbability::scaleByInverse((llvm::BranchProbability *)&BlockFreq, v57);
              }
              if (__CFADD__(v60, v58)) {
                unint64_t v58 = -1;
              }
              else {
                v58 += v60;
              }
            }
            unint64_t v62 = v264;
            if (v264 <= v58) {
              unint64_t v62 = v58;
            }
            unint64_t v264 = v62;
            uint64_t v49 = (const llvm::MachineBasicBlock ***)v269;
          }
          ++v52;
        }
        while (v52 != v53);
      }
      BlockFreq = &v288;
      uint64_t v287 = 0x400000000;
      unsigned int v79 = *v49;
      uint64_t v80 = *((unsigned int *)v49 + 2);
      if (v80)
      {
        unsigned int v81 = &v79[v80];
        do
        {
          unsigned int v82 = *v79;
          unint64_t v84 = (uint64_t ***)*((void *)*v79 + 11);
          uint64_t v83 = (uint64_t ***)*((void *)*v79 + 12);
          if (v84 != v83)
          {
            unsigned int v85 = 0;
            do
            {
              uint64_t v280 = *v84;
              int v86 = (const llvm::MachineBasicBlock *)v280;
              BOOL v87 = (const llvm::MachineBasicBlock ***)*sub_1CC3261A0(v43, (uint64_t *)&v280);
              if ((sub_1CD5297D8((uint64_t)v282, (uint64_t)v86, &v281) & 1) == 0 && (!v87 || v86 == **v87))
              {
                unsigned int v88 = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(v272 + 568), v82, v86);
                if (v85 <= v88) {
                  unsigned int v85 = v88;
                }
              }
              ++v84;
            }
            while (v84 != v83);
            if (v85)
            {
              v281 = (const llvm::MachineBasicBlock *)llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v272 + 576), v82);
              unint64_t v89 = llvm::BlockFrequency::operator*((unint64_t *)&v281, v85);
              int v90 = v287;
              if (v287 >= HIDWORD(v287)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              uint64_t v91 = (const llvm::MachineBasicBlock **)&BlockFreq[2 * v287];
              *uint64_t v91 = v82;
              v91[1] = (const llvm::MachineBasicBlock *)v89;
              LODWORD(v287) = v90 + 1;
            }
          }
          ++v79;
        }
        while (v79 != v81);
        uint64_t v92 = v269;
        unsigned int v79 = *(const llvm::MachineBasicBlock ***)v269;
        uint64_t v93 = *(unsigned int *)(v269 + 8);
        if (v93)
        {
          uint64_t v94 = &v79[v93];
          unsigned int v95 = v94 - 1;
          unint64_t v96 = -1;
          unint64_t v97 = v264;
          do
          {
            if (v95 == (const llvm::MachineBasicBlock **)(*(void *)v92 + 8 * *(unsigned int *)(v92 + 8))) {
              unint64_t v98 = *(const llvm::MachineBasicBlock ***)v92;
            }
            else {
              unint64_t v98 = v95;
            }
            int v99 = *v98;
            if (v79 == *(const llvm::MachineBasicBlock ***)v92) {
              unint64_t v100 = 0;
            }
            else {
              unint64_t v100 = v97;
            }
            if (v287)
            {
              uint64_t v101 = 16 * v287;
              int v102 = BlockFreq + 1;
              do
              {
                if (v99 != (const llvm::MachineBasicBlock *)*(v102 - 1))
                {
                  if (__CFADD__(*v102, v100)) {
                    unint64_t v100 = -1;
                  }
                  else {
                    v100 += *v102;
                  }
                }
                v102 += 2;
                v101 -= 16;
              }
              while (v101);
            }
            unsigned int v103 = (const llvm::MachineBasicBlock **)*((void *)v99 + 11);
            uint64_t v104 = (const llvm::MachineBasicBlock **)*((void *)v99 + 12);
            if (v103 != v104)
            {
              while (*v103 != *v79)
              {
                if (++v103 == v104)
                {
                  unsigned int v103 = (const llvm::MachineBasicBlock **)*((void *)v99 + 12);
                  break;
                }
              }
            }
            if (v103 != v104)
            {
              uint64_t v105 = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v272 + 576), *v98);
              v281 = (const llvm::MachineBasicBlock *)v105;
              uint64_t v106 = (*((void *)v99 + 12) - *((void *)v99 + 11)) >> 3;
              if (v106 == 2)
              {
                unsigned int v110 = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(v272 + 568), v99, *v79);
                unint64_t v111 = llvm::BlockFrequency::operator*((unint64_t *)&v281, v110);
                unint64_t v112 = v111;
                if (v110 >= 0x40000001) {
                  unint64_t v112 = llvm::BlockFrequency::operator*((unint64_t *)&v281, 0x80000000 - v110);
                }
                unint64_t v113 = dword_1EBCCDF08;
                if (dword_1EBCCDF08)
                {
                  unsigned int v114 = ((dword_1EBCCDF08 >> 1) | 0x80000000) / dword_1EBCCDF08;
                  if (dword_1EBCCDF08 == 0x80000000) {
                    unsigned int v114 = 1;
                  }
                  LODWORD(v280) = v114;
                  unint64_t v113 = llvm::BranchProbability::scaleByInverse((llvm::BranchProbability *)&v280, v111);
                }
                unint64_t v115 = dword_1EBCCDFC8;
                if (dword_1EBCCDFC8)
                {
                  unsigned int v116 = ((dword_1EBCCDFC8 >> 1) | 0x80000000) / dword_1EBCCDFC8;
                  if (dword_1EBCCDFC8 == 0x80000000) {
                    unsigned int v116 = 1;
                  }
                  LODWORD(v280) = v116;
                  unint64_t v115 = llvm::BranchProbability::scaleByInverse((llvm::BranchProbability *)&v280, v112);
                }
                uint64_t v117 = v115 + v113;
                if (__CFADD__(v115, v113)) {
                  uint64_t v117 = -1;
                }
                BOOL v217 = __CFADD__(v117, v100);
                unint64_t v118 = v117 + v100;
                if (v217) {
                  unint64_t v100 = -1;
                }
                else {
                  unint64_t v100 = v118;
                }
                uint64_t v92 = v269;
                unint64_t v97 = v264;
              }
              else if (v106 == 1)
              {
                unint64_t v107 = v105;
                unint64_t v108 = (dword_1EBCCDFC8 + dword_1EBCCDF08);
                if (dword_1EBCCDFC8 + dword_1EBCCDF08)
                {
                  if (v108 == 0x80000000) {
                    unsigned int v109 = 1;
                  }
                  else {
                    unsigned int v109 = ((v108 >> 1) | 0x80000000) / v108;
                  }
                  LODWORD(v280) = v109;
                  unint64_t v108 = llvm::BranchProbability::scaleByInverse((llvm::BranchProbability *)&v280, v107);
                }
                if (__CFADD__(v108, v100)) {
                  unint64_t v100 = -1;
                }
                else {
                  v100 += v108;
                }
              }
            }
            if (v100 < v96)
            {
              unint64_t v96 = v100;
              uint64_t v51 = v79;
            }
            ++v79;
            unsigned int v95 = v98 + 1;
          }
          while (v79 != v94);
          unsigned int v79 = *(const llvm::MachineBasicBlock ***)v92;
          uint64_t v119 = *(unsigned int *)(v92 + 8);
        }
        else
        {
          uint64_t v119 = 0;
        }
      }
      else
      {
        uint64_t v119 = 0;
      }
      uint64_t v131 = &v79[v119];
      if (v79 != v51 && v51 != v131)
      {
        if (v79 + 1 == v51)
        {
          uint64_t v133 = *v79;
          int64_t v134 = (char *)v131 - (char *)v51;
          memmove(v79, v51, (char *)v131 - (char *)v51);
          *(const llvm::MachineBasicBlock **)((char *)v79 + v134) = v133;
        }
        else if (v51 + 1 == v131)
        {
          int v135 = *(v131 - 1);
          if (v131 - 1 != v79) {
            memmove(v79 + 1, v79, 8 * v119 - 8);
          }
          *unsigned int v79 = v135;
        }
        else
        {
          sub_1CC057214(v79, v51, v131);
        }
      }
      if (BlockFreq != &v288) {
        free(BlockFreq);
      }
    }
    goto LABEL_226;
  }
  uint64_t v63 = *(const llvm::MachineBasicBlock **)(a1 + 592);
  if (!v63) {
    goto LABEL_226;
  }
  int v64 = *(const llvm::MachineBasicBlock ***)v269;
  unint64_t v65 = *(uint64_t *****)(*(void *)v269 + 8 * *(unsigned int *)(v269 + 8) - 8);
  if (v65 == (uint64_t ****)v63) {
    goto LABEL_226;
  }
  int v66 = (uint64_t **)*v64;
  if (*(const llvm::MachineBasicBlock **)(*((void *)*v64 + 4) + 328) == *v64) {
    goto LABEL_226;
  }
  unsigned int v68 = v66[8];
  uint64_t v67 = v66[9];
  while (2)
  {
    if (v68 == v67)
    {
      char v120 = 1;
LABEL_190:
      unsigned int v121 = *v49;
      uint64_t v122 = *((unsigned int *)v49 + 2);
      uint64_t v123 = (char *)&(*v49)[v122];
      uint64_t v124 = *v49;
      if (v122)
      {
        uint64_t v125 = 8 * v122;
        uint64_t v124 = *v49;
        while (*v124 != v63)
        {
          ++v124;
          v125 -= 8;
          if (!v125)
          {
            uint64_t v124 = &(*v49)[v122];
            break;
          }
        }
      }
      if (v122 != v124 - v121)
      {
        if (v120) {
          goto LABEL_207;
        }
        uint64_t v126 = (const llvm::MachineBasicBlock **)*((void *)v63 + 11);
        unint64_t v127 = (const llvm::MachineBasicBlock **)*((void *)v63 + 12);
        if (v126 != v127)
        {
          while (*v126 != v124[1])
          {
            if (++v126 == v127)
            {
              uint64_t v126 = (const llvm::MachineBasicBlock **)*((void *)v63 + 12);
              break;
            }
          }
        }
        if (v126 == v127) {
          goto LABEL_207;
        }
        uint64_t v128 = v65[11];
        unint64_t v129 = v65[12];
        if (v128 != v129)
        {
          while (*v128 != v66)
          {
            if (++v128 == v129)
            {
              uint64_t v128 = v65[12];
              break;
            }
          }
        }
        if (v128 != v129)
        {
LABEL_207:
          uint64_t v130 = (char *)(v124 + 1);
          if (v121 != v124 + 1 && v130 != v123)
          {
            if (v124 == v121)
            {
              uint64_t v234 = *v124;
              int64_t v235 = v123 - v130;
              memmove(v124, v130, v123 - v130);
              *(const llvm::MachineBasicBlock **)((char *)v124 + v235) = v234;
            }
            else if (v124 + 2 == (const llvm::MachineBasicBlock **)v123)
            {
              size_t v236 = (const llvm::MachineBasicBlock *)*((void *)v123 - 1);
              if (v123 - 8 != (char *)v121) {
                memmove(v121 + 1, *v49, v123 - 8 - (char *)v121);
              }
              uint64_t *v121 = v236;
            }
            else
            {
              sub_1CC057214(*v49, v130, v123);
            }
          }
        }
      }
      goto LABEL_226;
    }
    v281 = (const llvm::MachineBasicBlock *)*v68;
    char v69 = v281;
    uint64_t v70 = *sub_1CC3261A0(v43, (uint64_t *)&v281);
    if ((sub_1CD5297D8((uint64_t)v282, (uint64_t)v69, &BlockFreq) & 1) != 0
      || v70 && v69 != *(const llvm::MachineBasicBlock **)(*(void *)v70 + 8 * *(unsigned int *)(v70 + 8) - 8))
    {
LABEL_119:
      ++v68;
      continue;
    }
    break;
  }
  v258 = v67;
  int v261 = v66;
  uint64_t v265 = v65;
  unsigned int v71 = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(v272 + 568), v69, (const llvm::MachineBasicBlock *)v66);
  unsigned int v72 = (void **)*((void *)v69 + 11);
  unsigned int v73 = (void **)*((void *)v69 + 12);
  if (v72 != v73)
  {
    unsigned int v74 = v71;
    do
    {
      BlockFreq = (uint64_t *)*v72;
      unsigned int v75 = BlockFreq;
      unsigned int v76 = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(v272 + 568), v69, (const llvm::MachineBasicBlock *)BlockFreq);
      unsigned int v77 = (void ***)*sub_1CC3261A0(v43, (uint64_t *)&BlockFreq);
      if (v77)
      {
        BOOL v78 = v75 == **v77 && v76 > v74;
        if (v78)
        {
LABEL_118:
          uint64_t v49 = (const llvm::MachineBasicBlock ***)v269;
          int v66 = v261;
          unint64_t v65 = v265;
          uint64_t v67 = v258;
          goto LABEL_119;
        }
      }
      else if (v76 > v74)
      {
        goto LABEL_118;
      }
      ++v72;
    }
    while (v72 != v73);
  }
  unint64_t v65 = v265;
  uint64_t v180 = (uint64_t *)v265[11];
  uint64_t v181 = (uint64_t *)v265[12];
  uint64_t v49 = (const llvm::MachineBasicBlock ***)v269;
  if (v180 == v181)
  {
LABEL_319:
    int v66 = v261;
    if (sub_1CC327498(v272, v261, (uint64_t)v282) >= v42) {
      goto LABEL_226;
    }
    char v120 = 0;
    goto LABEL_190;
  }
  while (1)
  {
    v281 = (const llvm::MachineBasicBlock *)*v180;
    uint64_t v182 = (uint64_t)v281;
    unint64_t v183 = (void **)*sub_1CC3261A0(v43, (uint64_t *)&v281);
    if ((sub_1CD5297D8((uint64_t)v282, v182, &BlockFreq) & 1) == 0 && (!v183 || v182 == **v183)) {
      break;
    }
    if (++v180 == v181) {
      goto LABEL_319;
    }
  }
LABEL_226:
  *(_DWORD *)(v272 + 256) = 0;
  *(_DWORD *)(v272 + 400) = 0;
  if (v274 != v273) {
    free(v274);
  }
  if (v283 != v285) {
    free(v283);
  }
  if ((v282[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v282[1], 8);
  }
}

void sub_1CC325EE8(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v35 = a2;
  uint64_t v7 = (uint64_t)(a1 + 230);
  int64x2_t v8 = (uint64_t **)*sub_1CC3261A0((uint64_t)(a1 + 230), &v35);
  uint64_t v9 = *(void *)(a3 + 8);
  uint64_t v10 = *(unsigned int *)(a3 + 20);
  if (v9 == *(void *)a3)
  {
    if (v10)
    {
      uint64_t v11 = 0;
      uint64_t v12 = 8 * v10;
      unsigned int v13 = *(uint64_t ****)(a3 + 8);
      do
      {
        if (*v13 == v8) {
          return;
        }
        if (*v13 == (uint64_t **)-2) {
          uint64_t v11 = v13;
        }
        ++v13;
        v12 -= 8;
      }
      while (v12);
      if (v11)
      {
        *uint64_t v11 = v8;
        --*(_DWORD *)(a3 + 24);
        goto LABEL_33;
      }
    }
    unsigned int v14 = *(_DWORD *)(a3 + 16);
    if (v10 < v14)
    {
      *(_DWORD *)(a3 + 20) = v10 + 1;
      *(void *)(v9 + 8 * v10) = v8;
      goto LABEL_33;
    }
  }
  else
  {
    unsigned int v14 = *(_DWORD *)(a3 + 16);
  }
  if (3 * v14 <= 4 * ((int)v10 - *(_DWORD *)(a3 + 24)))
  {
    if (v14 >= 0x40) {
      v14 *= 2;
    }
    else {
      unsigned int v14 = 128;
    }
  }
  else if (v14 - v10 >= v14 >> 3)
  {
    goto LABEL_14;
  }
  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a3, v14);
  unsigned int v14 = *(_DWORD *)(a3 + 16);
  uint64_t v9 = *(void *)(a3 + 8);
LABEL_14:
  unsigned int v15 = v14 - 1;
  unsigned int v16 = (v14 - 1) & ((v8 >> 4) ^ (v8 >> 9));
  int v17 = (uint64_t ***)(v9 + 8 * v16);
  uint64_t v18 = *v17;
  if (*v17 != (uint64_t **)-1)
  {
    uint64_t v19 = 0;
    int v20 = 1;
    while (v18 != v8)
    {
      if (v19) {
        BOOL v21 = 0;
      }
      else {
        BOOL v21 = v18 == (uint64_t **)-2;
      }
      if (v21) {
        uint64_t v19 = v17;
      }
      unsigned int v22 = v16 + v20++;
      unsigned int v16 = v22 & v15;
      int v17 = (uint64_t ***)(v9 + 8 * (v22 & v15));
      uint64_t v18 = *v17;
      if (*v17 == (uint64_t **)-1) {
        goto LABEL_26;
      }
    }
    return;
  }
  uint64_t v19 = 0;
LABEL_26:
  if (v19) {
    uint64_t v23 = v19;
  }
  else {
    uint64_t v23 = v17;
  }
  if (*v23 != v8)
  {
    if (*v23 == (uint64_t **)-2) {
      --*(_DWORD *)(a3 + 24);
    }
    else {
      ++*(_DWORD *)(a3 + 20);
    }
    *uint64_t v23 = v8;
LABEL_33:
    uint64_t v24 = *((unsigned int *)v8 + 2);
    if (v24)
    {
      BOOL v25 = *v8;
      uint64_t v26 = (uint64_t)&(*v8)[v24];
      do
      {
        unsigned int v27 = *(uint64_t **)(*v25 + 64);
        size_t v28 = *(uint64_t **)(*v25 + 72);
        while (v27 != v28)
        {
          uint64_t v29 = *v27;
          uint64_t v34 = *v27;
          if ((!a4 || sub_1CD5297D8(a4, v29, &v36)) && (uint64_t **)*sub_1CC3261A0(v7, &v34) != v8) {
            ++*((_DWORD *)v8 + 14);
          }
          ++v27;
        }
        ++v25;
      }
      while (v25 != (uint64_t *)v26);
    }
    if (!*((_DWORD *)v8 + 14))
    {
      uint64_t v30 = **v8;
      if (*(unsigned char *)(v30 + 184))
      {
        uint64_t v31 = a1 + 98;
        char v32 = a1 + 100;
        unsigned int v33 = a1[100];
        if (v33 >= a1[101]) {
LABEL_57:
        }
          llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      else
      {
        uint64_t v31 = a1 + 62;
        char v32 = a1 + 64;
        unsigned int v33 = a1[64];
        if (v33 >= a1[65]) {
          goto LABEL_57;
        }
      }
      *(void *)(*v31 + 8 * v33) = v30;
      ++*v32;
    }
  }
}

void *sub_1CC3261A0(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CBB0BF40(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  int v5 = v7;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CC327228(a1, a2, v7);
    *int v5 = *a2;
    v5[1] = 0;
  }
  return v5 + 1;
}

llvm::TailDuplicator *sub_1CC326208(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v5 = (const llvm::MachineBasicBlock ***)a3;
  uint64_t v7 = a1;
  v192[24] = *MEMORY[0x1E4F143B8];
  unsigned int v172 = *(void **)(*(void *)(a1 + 560) + 328);
  int64x2_t v8 = *(const llvm::MachineBasicBlock ***)a3;
  uint64_t v9 = *(unsigned int *)(a3 + 8);
  if (v9)
  {
    uint64_t v10 = 8 * v9;
    do
    {
      uint64_t v11 = (uint64_t)*v8++;
      sub_1CC327A20((unsigned int *)v7, (uint64_t)v5, *(uint64_t **)(v11 + 88), *(uint64_t **)(v11 + 96), a2, a4);
      v10 -= 8;
    }
    while (v10);
    int64x2_t v8 = *v5;
    uint64_t v12 = *((unsigned int *)v5 + 2);
  }
  else
  {
    uint64_t v12 = 0;
  }
  unsigned int v13 = (uint64_t **)v8[v12 - 1];
  uint64_t v167 = v7 + 536;
  uint64_t v170 = v7 + 920;
  int v164 = (llvm::TailDuplicator *)(v7 + 632);
  uint64_t v165 = v7 + 248;
  uint64_t v163 = v7 + 392;
  uint64_t v168 = a4;
  uint64_t v169 = v5;
  uint64_t v166 = a2;
  uint64_t v171 = v7;
  while (1)
  {
    uint64_t v182 = v184;
    uint64_t v183 = 0x400000000;
    unsigned int v14 = sub_1CC327BA8(v7, (llvm::MachineBasicBlock *)v13, v5, a4, (uint64_t)&v182);
    unsigned int v15 = (void *)sub_1CC327644(v167, (uint64_t)v13);
    if ((void *)(*(void *)(v7 + 536) + 24 * *(unsigned int *)(v7 + 552)) != v15)
    {
      int v17 = v15;
      uint64_t v18 = (llvm::TailDuplicator *)v15[1];
      BOOL v177 = v18;
      void *v15 = -8192;
      *(int32x2_t *)(v7 + 544) = vadd_s32(*(int32x2_t *)(v7 + 544), (int32x2_t)0x1FFFFFFFFLL);
      uint64_t v19 = (const llvm::MachineBasicBlock ****)sub_1CC3261A0(v170, (uint64_t *)&v177);
      int v20 = v13[11];
      BOOL v21 = v13[12];
      if (v20 != v21)
      {
        while ((llvm::TailDuplicator *)*v20 != v18)
        {
          if (++v20 == v21)
          {
            int v20 = v13[12];
            break;
          }
        }
      }
      if (v20 != v21)
      {
        unsigned int v22 = *v19;
        if ((!a4 || sub_1CD5297D8(a4, (uint64_t)v18, &v185)) && v22 != v5 && v18 == **v22)
        {
          size_t v28 = (llvm::TailDuplicator *)v17[1];
          uint64_t v52 = v17[2];
          goto LABEL_63;
        }
      }
    }
    uint64_t v23 = v13[11];
    uint64_t v24 = v13[12];
    uint64_t v25 = v183;
    BOOL v26 = (((char *)v24 - (char *)v23) & 0x7FFFFFFF8) == 0x10 && v183 == 2;
    if (v26)
    {
      sub_1CD529C44((llvm::SmallPtrSetImplBase *)&v177, v23, v24);
      unint64_t v185 = v189;
      uint64_t v186 = (uint64_t)v189;
      uint64_t v187 = 8;
      int v188 = 0;
      if (!v183)
      {
        BOOL v114 = 1;
        goto LABEL_236;
      }
      unint64_t v60 = (uint64_t *)v182;
      unsigned int v61 = (uint64_t *)((char *)v182 + 8 * v183);
LABEL_87:
      int v176 = (const llvm::MachineBasicBlock *)*v60;
      unint64_t v62 = (uint64_t *)*((void *)v176 + 8);
      uint64_t v63 = (uint64_t *)*((void *)v176 + 9);
      if (v62 != v63)
      {
        int v64 = 0;
        while (1)
        {
          uint64_t v65 = *v62;
          uint64_t v175 = *v62;
          if (v178 == v177)
          {
            unsigned int v66 = v180;
            uint64_t v67 = (char *)v178 + 8 * v180;
            if (v180)
            {
              uint64_t v68 = 0;
              while (*(void *)((char *)v178 + v68) != v65)
              {
                v68 += 8;
                if (8 * v180 == v68) {
                  goto LABEL_108;
                }
              }
              uint64_t v67 = (char *)v178 + v68;
            }
LABEL_108:
            unsigned int v76 = v178;
          }
          else
          {
            unsigned int v69 = v179 - 1;
            unsigned int v70 = (v179 - 1) & ((v65 >> 4) ^ (v65 >> 9));
            uint64_t v67 = (char *)v178 + 8 * v70;
            uint64_t v71 = *(void *)v67;
            if (*(void *)v67 == -1)
            {
              unsigned int v72 = 0;
LABEL_110:
              if (v72) {
                uint64_t v67 = v72;
              }
              unsigned int v66 = v180;
              if (*(void *)v67 != v65) {
                uint64_t v67 = (char *)v178 + 8 * v179;
              }
            }
            else
            {
              unsigned int v72 = 0;
              int v73 = 1;
              while (v71 != v65)
              {
                if (v72) {
                  BOOL v74 = 0;
                }
                else {
                  BOOL v74 = v71 == -2;
                }
                if (v74) {
                  unsigned int v72 = v67;
                }
                unsigned int v75 = v70 + v73++;
                unsigned int v70 = v75 & v69;
                uint64_t v67 = (char *)v178 + 8 * (v75 & v69);
                uint64_t v71 = *(void *)v67;
                if (*(void *)v67 == -1) {
                  goto LABEL_110;
                }
              }
              unsigned int v66 = v180;
            }
            unsigned int v76 = v177;
          }
          if (v178 == v76) {
            unsigned int v77 = v66;
          }
          else {
            unsigned int v77 = v179;
          }
          if (v67 != (char *)v178 + 8 * v77)
          {
            BOOL v78 = *(uint64_t **)(v65 + 88);
            unsigned int v79 = *(uint64_t **)(v65 + 96);
            if (v78 != v79)
            {
              unsigned int v80 = v179 - 1;
              if (v178 == v177) {
                unsigned int v81 = v66;
              }
              else {
                unsigned int v81 = v179;
              }
              unsigned int v82 = (char *)v178 + 8 * v81;
              unsigned int v83 = v66;
              unint64_t v84 = v178;
              while (1)
              {
                uint64_t v85 = *v78;
                if (v84 == v76)
                {
                  int v86 = (llvm::TailDuplicator *)((char *)v76 + 8 * v83);
                  if (v83)
                  {
                    uint64_t v87 = 0;
                    while (*(void *)((char *)v76 + v87) != v85)
                    {
                      v87 += 8;
                      if (8 * v83 == v87) {
                        goto LABEL_143;
                      }
                    }
                    int v86 = (llvm::TailDuplicator *)((char *)v76 + v87);
                  }
LABEL_143:
                  unint64_t v84 = v76;
                }
                else
                {
                  unsigned int v88 = ((v85 >> 4) ^ (v85 >> 9)) & v80;
                  unint64_t v89 = (char *)v178 + 8 * v88;
                  uint64_t v90 = *(void *)v89;
                  if (*(void *)v89 == -1)
                  {
                    uint64_t v91 = 0;
LABEL_145:
                    if (v91) {
                      unint64_t v89 = v91;
                    }
                    uint64_t v95 = *(void *)v89;
                  }
                  else
                  {
                    uint64_t v91 = 0;
                    int v92 = 1;
                    while (v90 != v85)
                    {
                      if (v91) {
                        BOOL v93 = 0;
                      }
                      else {
                        BOOL v93 = v90 == -2;
                      }
                      if (v93) {
                        uint64_t v91 = v89;
                      }
                      unsigned int v94 = v88 + v92++;
                      unsigned int v88 = v94 & v80;
                      unint64_t v89 = (char *)v178 + 8 * (v94 & v80);
                      uint64_t v90 = *(void *)v89;
                      if (*(void *)v89 == -1) {
                        goto LABEL_145;
                      }
                    }
                    uint64_t v95 = *v78;
                  }
                  int v86 = (llvm::TailDuplicator *)(v95 == v85 ? v89 : v82);
                  unsigned int v83 = v66;
                  unsigned int v76 = v177;
                  unint64_t v84 = v178;
                }
                unsigned int v96 = v84 == v76 ? v83 : v179;
                if (v86 == (llvm::TailDuplicator *)((char *)v84 + 8 * v96)) {
                  break;
                }
                if (++v78 == v79) {
                  goto LABEL_197;
                }
              }
LABEL_208:
              BOOL v114 = 0;
              a4 = v168;
              goto LABEL_209;
            }
            goto LABEL_197;
          }
          unint64_t v97 = (const llvm::MachineBasicBlock ****)sub_1CC3261A0(v170, &v175);
          if ((uint64_t **)v65 == v13) {
            goto LABEL_197;
          }
          unint64_t v98 = *v97;
          if (v168)
          {
            if (!sub_1CD5297D8(v168, v65, &v173)) {
              goto LABEL_197;
            }
          }
          if (v98 == v169 || v98 == (const llvm::MachineBasicBlock ***)*sub_1CC3261A0(v170, (uint64_t *)&v176)) {
            goto LABEL_197;
          }
          ++v64;
          uint64_t v99 = v186;
          uint64_t v100 = HIDWORD(v187);
          if ((void *)v186 == v185)
          {
            if (HIDWORD(v187))
            {
              uint64_t v101 = 0;
              uint64_t v102 = 8 * HIDWORD(v187);
              unsigned int v103 = (uint64_t *)v186;
              while (*v103 != v65)
              {
                if (*v103 == -2) {
                  uint64_t v101 = v103;
                }
                ++v103;
                v102 -= 8;
                if (!v102)
                {
                  if (!v101) {
                    goto LABEL_170;
                  }
                  *uint64_t v101 = v65;
                  --v188;
                  goto LABEL_196;
                }
              }
              goto LABEL_197;
            }
LABEL_170:
            unsigned int v104 = v187;
            if (HIDWORD(v187) < v187)
            {
              ++HIDWORD(v187);
              *(void *)(v186 + 8 * v100) = v65;
              goto LABEL_196;
            }
          }
          else
          {
            unsigned int v104 = v187;
          }
          if (3 * v104 <= 4 * (HIDWORD(v187) - v188))
          {
            if (v104 >= 0x40) {
              v104 *= 2;
            }
            else {
              unsigned int v104 = 128;
            }
          }
          else if (v104 - HIDWORD(v187) >= v104 >> 3)
          {
            goto LABEL_175;
          }
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v185, v104);
          unsigned int v104 = v187;
          uint64_t v99 = v186;
LABEL_175:
          unsigned int v105 = v104 - 1;
          unsigned int v106 = (v104 - 1) & ((v65 >> 4) ^ (v65 >> 9));
          unint64_t v107 = (uint64_t *)(v99 + 8 * v106);
          uint64_t v108 = *v107;
          if (*v107 == -1)
          {
            unsigned int v109 = 0;
LABEL_189:
            if (v109) {
              unint64_t v113 = v109;
            }
            else {
              unint64_t v113 = v107;
            }
            if (*v113 != v65)
            {
              if (*v113 == -2) {
                --v188;
              }
              else {
                ++HIDWORD(v187);
              }
              *unint64_t v113 = v65;
LABEL_196:
              if (!sub_1CC32844C(v65, (uint64_t *)&v177)) {
                goto LABEL_208;
              }
            }
          }
          else
          {
            unsigned int v109 = 0;
            int v110 = 1;
            while (v108 != v65)
            {
              if (v109) {
                BOOL v111 = 0;
              }
              else {
                BOOL v111 = v108 == -2;
              }
              if (v111) {
                unsigned int v109 = v107;
              }
              unsigned int v112 = v106 + v110++;
              unsigned int v106 = v112 & v105;
              unint64_t v107 = (uint64_t *)(v99 + 8 * (v112 & v105));
              uint64_t v108 = *v107;
              if (*v107 == -1) {
                goto LABEL_189;
              }
            }
          }
LABEL_197:
          if (++v62 == v63)
          {
            BOOL v114 = v64 > 0;
            a2 = v166;
            if (v64 < 1)
            {
              a4 = v168;
            }
            else
            {
              ++v60;
              a4 = v168;
              if (v60 != v61) {
                goto LABEL_87;
              }
            }
            goto LABEL_236;
          }
        }
      }
      BOOL v114 = 0;
LABEL_209:
      a2 = v166;
LABEL_236:
      if ((void *)v186 != v185) {
        free((void *)v186);
      }
      int v5 = v169;
      if (v178 != v177) {
        free(v178);
      }
      if (!v114)
      {
        uint64_t v25 = v183;
        goto LABEL_20;
      }
      sub_1CD482B64((llvm::SmallPtrSetImplBase *)&v177, v13[11], v13[12]);
      LOBYTE(v52) = 0;
      if (v180 - v181 != 2)
      {
        size_t v28 = 0;
        goto LABEL_293;
      }
      size_t v28 = 0;
      if (v183 != 2) {
        goto LABEL_293;
      }
      uint64_t v128 = 0;
      uint64_t v129 = 0;
      unint64_t v185 = &v187;
      uint64_t v186 = 0x800000000;
      uint64_t v190 = (__n128 *)v192;
      uint64_t v191 = 0x800000000;
      uint64_t v162 = v182;
      do
      {
        uint64_t v130 = (const llvm::MachineBasicBlock *)v162[v129];
        int v176 = v130;
        uint64_t v132 = (const llvm::MachineBasicBlock **)*((void *)v130 + 8);
        uint64_t v131 = (const llvm::MachineBasicBlock **)*((void *)v130 + 9);
        if (v132 != v131)
        {
          uint64_t v133 = &v185 + 26 * v128;
          do
          {
            int64_t v134 = *v132;
            uint64_t v175 = (uint64_t)v134;
            if (v134 == (const llvm::MachineBasicBlock *)v13
              || (!v168 || sub_1CD5297D8(v168, (uint64_t)v134, &v173))
              && (const llvm::MachineBasicBlock ***)*sub_1CC3261A0(v170, &v175) != v169
              && (int v135 = v13,
                  uint64_t v136 = *sub_1CC3261A0(v170, &v175),
                  BOOL v26 = v136 == *sub_1CC3261A0(v170, (uint64_t *)&v176),
                  unsigned int v13 = v135,
                  uint64_t v7 = v171,
                  !v26))
            {
              v173.n128_u64[0] = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v7 + 576), v134);
              unsigned int EdgeProbability = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(v7 + 568), v134, v130);
              v173.n128_u64[0] = llvm::BlockFrequency::operator*(v173.n128_u64, EdgeProbability);
              v173.n128_u64[1] = (unint64_t)v134;
              uint64_t v174 = v130;
              unsigned int v138 = *((_DWORD *)v133 + 2);
              uint64_t v139 = (__n128 *)*v133;
              if (v138 >= *((_DWORD *)v133 + 3))
              {
                BOOL v141 = (__n128 *)((char *)v139 + 24 * v138) > &v173;
                if (v139 > &v173 || !v141) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              uint64_t v140 = (__n128 *)((char *)v139 + 24 * *((unsigned int *)v133 + 2));
              __n128 v127 = v173;
              v140[1].n128_u64[0] = (unint64_t)v174;
              __n128 *v140 = v127;
              ++*((_DWORD *)v133 + 2);
            }
            ++v132;
          }
          while (v132 != v131);
        }
        ++v128;
        uint64_t v129 = 1;
      }
      while (v128 != 2);
      sub_1CC32866C((__n128 *)v185, v186, v127);
      sub_1CC32866C(v190, v191, v142);
      uint64_t v144 = (char *)v185;
      long long v145 = v190;
      unint64_t v146 = v190->n128_u64[1];
      if (*((void *)v185 + 1) == v146)
      {
        unint64_t v147 = v190[1].n128_u64[1];
        BOOL v148 = __CFADD__(v147, *(void *)v185);
        unint64_t v149 = v147 + *(void *)v185;
        if (v148) {
          unint64_t v149 = -1;
        }
        uint64_t v150 = *((void *)v185 + 3);
        BOOL v148 = __CFADD__(v150, v190->n128_u64[0]);
        unint64_t v151 = v150 + v190->n128_u64[0];
        if (v148) {
          unint64_t v151 = -1;
        }
        if (v149 < v151) {
          uint64_t v144 = (char *)v185 + 24;
        }
        else {
          long long v145 = (__n128 *)((char *)v190 + 24);
        }
        unint64_t v146 = v145->n128_u64[1];
      }
      a4 = v168;
      int v5 = v169;
      BOOL v152 = v146 == (void)v13;
      if ((uint64_t **)v146 == v13) {
        uint64_t v153 = (__n128 *)v144;
      }
      else {
        uint64_t v153 = v145;
      }
      if (v152) {
        uint64_t v144 = (char *)v145;
      }
      unsigned int v154 = (uint64_t **)*((void *)v144 + 1);
      size_t v28 = (llvm::TailDuplicator *)*((void *)v144 + 2);
      __n128 v173 = *v153;
      uint64_t v174 = (llvm::TailDuplicator *)v153[1].n128_u64[0];
      if (v154 != v13)
      {
        LOBYTE(v52) = 0;
        size_t v28 = 0;
        goto LABEL_289;
      }
      uint64_t v155 = v174;
      if (v28 == (llvm::TailDuplicator *)v173.n128_u64[1]
        && byte_1EBCCE088 != 0
        && (*(unsigned char *)(*(void *)(*(void *)(v7 + 560) + 8) + 592) & 1) == 0)
      {
        int isSimpleBB = llvm::TailDuplicator::isSimpleBB(v174, v143);
        if (((*((void *)v155 + 12) - *((void *)v155 + 11)) & 0x7FFFFFFF8) != 8
          && llvm::TailDuplicator::shouldTailDuplicate(v164, isSimpleBB, v155)
          && sub_1CC3276A0(v7, v13, (llvm::MachineBasicBlock ***)v155, (uint64_t)v169, v168))
        {
          unsigned int v161 = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(v7 + 568), (const llvm::MachineBasicBlock *)v13, v28);
          if (sub_1CC327F64(v7, (const llvm::MachineBasicBlock *)v13, v155, v161, v169, v168))
          {
            LOBYTE(v52) = 1;
            size_t v28 = v155;
LABEL_289:
            uint64_t v158 = 52;
            do
            {
              unint64_t v159 = *(const llvm::MachineBasicBlock *****)((char *)&v185 + v158 * 8 - 208);
              if (&(&v169)[v158] != v159) {
                free(v159);
              }
              v158 -= 26;
            }
            while (v158 * 8);
LABEL_293:
            uint64_t v53 = v178;
            if (v178 != v177) {
              goto LABEL_62;
            }
            goto LABEL_63;
          }
          uint64_t v155 = v174;
        }
      }
      int v157 = sub_1CC32742C(v167, &v173.n128_i64[1]);
      LOBYTE(v52) = 0;
      *int v157 = v155;
      *((unsigned char *)v157 + 8) = 0;
      goto LABEL_289;
    }
LABEL_20:
    unsigned int v27 = (__n128 *)&v187;
    unint64_t v185 = &v187;
    uint64_t v186 = 0x400000000;
    if (!v25)
    {
      unint64_t v43 = 0;
      size_t v28 = 0;
      unsigned int v29 = 0;
      uint64_t v44 = (__n128 *)&v187;
LABEL_50:
      sub_1CC32927C(v27, v44, v43, 0, 0, v16);
      goto LABEL_51;
    }
    size_t v28 = 0;
    unsigned int v29 = 0;
    uint64_t v30 = (llvm::TailDuplicator **)v182;
    uint64_t v31 = 8 * v25;
    do
    {
      BOOL v177 = *v30;
      char v32 = *(llvm::MachineBranchProbabilityInfo **)(v7 + 568);
      uint64_t v33 = (uint64_t)v13;
      unsigned int v34 = llvm::MachineBranchProbabilityInfo::getEdgeProbability(v32, (const llvm::MachineBasicBlock *)v13, v177);
      unsigned int v35 = v34;
      if (v34 < v14) {
        LODWORD(v36) = v34;
      }
      else {
        LODWORD(v36) = 0x80000000;
      }
      if (v34 < v14 && v14 != 0x80000000) {
        unint64_t v36 = ((v14 >> 1) | ((unint64_t)v34 << 31)) / v14;
      }
      uint64_t v38 = sub_1CC3261A0(v170, (uint64_t *)&v177);
      if (sub_1CC327CE0(v171, v33, v177, *v38, v35, (uint64_t)v169, v168))
      {
        if (byte_1EBCCE088)
        {
          if ((*(unsigned char *)(*(void *)(*(void *)(v171 + 560) + 8) + 592) & 1) == 0)
          {
            uint64_t v40 = v177;
            int v41 = llvm::TailDuplicator::isSimpleBB(v177, v39);
            if (((*((void *)v40 + 12) - *((void *)v40 + 11)) & 0x7FFFFFFF8) != 8)
            {
              if (llvm::TailDuplicator::shouldTailDuplicate(v164, v41, v40))
              {
                if (v186 >= HIDWORD(v186)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                unint64_t v42 = (char *)v185 + 16 * v186;
                *(_DWORD *)unint64_t v42 = v36;
                *((void *)v42 + 1) = v40;
                LODWORD(v186) = v186 + 1;
              }
            }
          }
        }
      }
      else if (v28 == 0 || v29 < v36)
      {
        unsigned int v29 = v36;
        size_t v28 = v177;
      }
      unsigned int v13 = (uint64_t **)v33;
      ++v30;
      v31 -= 8;
      uint64_t v7 = v171;
    }
    while (v31);
    unsigned int v27 = (__n128 *)v185;
    unint64_t v43 = v186;
    uint64_t v44 = (__n128 *)((char *)v185 + 16 * v186);
    if (!v186)
    {
      unint64_t v43 = 0;
LABEL_49:
      a4 = v168;
      goto LABEL_50;
    }
    unint64_t v45 = v186;
    uint64_t v46 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
    while (1)
    {
      uint64_t v47 = (__n128 *)operator new(16 * v45, v46);
      if (v47) {
        break;
      }
      BOOL v48 = v45 > 1;
      v45 >>= 1;
      if (!v48) {
        goto LABEL_49;
      }
    }
    unsigned int v56 = v47;
    sub_1CC32927C(v27, v44, v43, v47, v45, v16);
    operator delete(v56);
    a4 = v168;
LABEL_51:
    uint64_t v49 = (uint64_t *)v185;
    int v5 = v169;
    if (v186)
    {
      unsigned int v50 = (uint64_t *)((char *)v185 + 16 * v186);
      while (1)
      {
        if (*(_DWORD *)v49 < v29)
        {
LABEL_57:
          LOBYTE(v52) = 0;
          goto LABEL_58;
        }
        uint64_t v51 = (llvm::MachineBasicBlock *)v49[1];
        if (sub_1CC3276A0(v7, v13, (llvm::MachineBasicBlock ***)v51, (uint64_t)v169, a4))
        {
          if (sub_1CC327F64(v7, (const llvm::MachineBasicBlock *)v13, v51, v29, v169, a4)) {
            break;
          }
        }
        v49 += 2;
        if (v49 == v50) {
          goto LABEL_57;
        }
      }
      LOBYTE(v52) = 1;
      size_t v28 = v51;
LABEL_58:
      uint64_t v49 = (uint64_t *)v185;
    }
    else
    {
      LOBYTE(v52) = 0;
    }
    a2 = v166;
    if (v49 != &v187)
    {
      uint64_t v53 = (llvm::TailDuplicator *)v49;
LABEL_62:
      free(v53);
    }
LABEL_63:
    if (v182 != v184) {
      free(v182);
    }
    BOOL v177 = v28;
    if (!byte_1EBCCE088 || (*(unsigned char *)(*(void *)(*(void *)(v7 + 560) + 8) + 592) & 1) != 0)
    {
      BOOL v55 = v52 & 1;
      if (v28) {
        goto LABEL_211;
      }
    }
    else
    {
      if (v28)
      {
        unsigned int v54 = sub_1CC3276A0(v7, v13, (llvm::MachineBasicBlock ***)v28, (uint64_t)v5, a4);
        size_t v28 = v177;
      }
      else
      {
        unsigned int v54 = 0;
      }
      BOOL v55 = (v52 & 1 | v54) != 0;
      if (v28) {
        goto LABEL_211;
      }
    }
    size_t v28 = sub_1CC32786C(v7, (uint64_t)v5, v165);
    BOOL v177 = v28;
    if (!v28)
    {
      uint64_t result = sub_1CC32786C(v7, (uint64_t)v5, v163);
      size_t v28 = result;
      BOOL v177 = result;
      if (!result)
      {
        unint64_t v58 = v172;
        uint64_t v59 = *(void *)(v7 + 560) + 320;
        if ((void *)v59 == v172) {
          return result;
        }
        while (1)
        {
          if (!a4 || (uint64_t result = (llvm::TailDuplicator *)sub_1CD5297D8(a4, (uint64_t)v58, &v185), result))
          {
            unint64_t v185 = v58;
            uint64_t result = (llvm::TailDuplicator *)sub_1CC3261A0(v170, (uint64_t *)&v185);
            if (*(const llvm::MachineBasicBlock ****)result != v5) {
              break;
            }
          }
          unint64_t v58 = (void *)v58[1];
          if (v58 == (void *)v59) {
            return result;
          }
        }
        unsigned int v172 = v58;
        unint64_t v185 = v58;
        uint64_t result = (llvm::TailDuplicator *)sub_1CC3261A0(v170, (uint64_t *)&v185);
        size_t v28 = ***(llvm::TailDuplicator ****)result;
        BOOL v177 = v28;
        if (!v28) {
          return result;
        }
      }
    }
LABEL_211:
    if (byte_1EBCCE088)
    {
      if ((*(unsigned char *)(*(void *)(*(void *)(v7 + 560) + 8) + 592) & 1) == 0 && v55)
      {
        LOBYTE(v185) = 0;
        if (sub_1CC329B44(v7, (char **)v28, (uint64_t)v13, (uint64_t)v5, a4, (uint64_t)&v172, &v185))
        {
          if ((_BYTE)v185)
          {
            while (1)
            {
              unsigned int v116 = *v5;
              uint64_t v117 = *((unsigned int *)v5 + 2);
              uint64_t v118 = (uint64_t)&(*v5)[v117];
              if ((const llvm::MachineBasicBlock **)(v118 - 8) == *v5) {
                break;
              }
              BOOL v119 = sub_1CC329B44(v7, *(char ***)(v118 - 8), *(void *)(v118 - 16), (uint64_t)v5, a4, (uint64_t)&v172, &v185);
              if (!(_BYTE)v185 || !v119)
              {
                unsigned int v116 = *v5;
                uint64_t v117 = *((unsigned int *)v5 + 2);
                break;
              }
            }
            unsigned int v13 = (uint64_t **)v116[v117 - 1];
            sub_1CC327A20((unsigned int *)v7, (uint64_t)v5, v13[11], v13[12], a2, a4);
          }
          else
          {
            unsigned int v13 = (uint64_t **)(*v5)[*((unsigned int *)v5 + 2) - 1];
          }
        }
        size_t v28 = v177;
        char v120 = (llvm::TailDuplicator **)v13[11];
        unsigned int v121 = (llvm::TailDuplicator **)v13[12];
        if (v120 != v121)
        {
          while (*v120 != v177)
          {
            if (++v120 == v121)
            {
              char v120 = (llvm::TailDuplicator **)v13[12];
              break;
            }
          }
        }
        if (v120 == v121) {
          continue;
        }
      }
    }
    uint64_t v122 = *sub_1CC3261A0(v170, (uint64_t *)&v177);
    *(_DWORD *)(v122 + 56) = 0;
    uint64_t v123 = *(unsigned int *)(v122 + 8);
    if (v123)
    {
      uint64_t v124 = *(uint64_t **)v122;
      uint64_t v125 = 8 * v123;
      do
      {
        uint64_t v126 = *v124++;
        sub_1CC327A20((unsigned int *)v7, v122, *(uint64_t **)(v126 + 88), *(uint64_t **)(v126 + 96), a2, a4);
        v125 -= 8;
      }
      while (v125);
    }
    sub_1CC32466C(v5, (uint64_t)v28, v122);
    unsigned int v13 = (uint64_t **)(*v5)[*((unsigned int *)v5 + 2) - 1];
  }
}

void *sub_1CC327228(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CC3272DC(a1, v6);
  int64x2_t v8 = 0;
  sub_1CBB0BF40(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CC3272DC(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      uint64_t v11 = 16 * v10;
      do
      {
        *uint64_t result = -4096;
        result += 2;
        v11 -= 16;
      }
      while (v11);
    }
    if (v3)
    {
      int v12 = 0;
      uint64_t v13 = 16 * v3;
      unsigned int v14 = (uint64_t *)(v4 + 8);
      do
      {
        uint64_t v15 = *(v14 - 1);
        if ((v15 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          uint64_t v19 = 0;
          sub_1CBB0BF40(*(void *)a1, *(_DWORD *)(a1 + 16), v15, &v19);
          __n128 v16 = v19;
          *uint64_t v19 = v15;
          v16[1] = *v14;
          *(_DWORD *)(a1 + 8) = ++v12;
        }
        v14 += 2;
        v13 -= 16;
      }
      while (v13);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v17 = *(unsigned int *)(a1 + 16);
  if (v17)
  {
    uint64_t v18 = 16 * v17;
    do
    {
      *uint64_t result = -4096;
      result += 2;
      v18 -= 16;
    }
    while (v18);
  }
  return result;
}

void *sub_1CC32742C(uint64_t a1, uint64_t *a2)
{
  int v7 = 0;
  char v4 = sub_1CC01F510(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  unint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CC3244A0(a1, a2, v7);
    *unint64_t v5 = *a2;
    v5[1] = 0;
    void v5[2] = 0;
  }
  return v5 + 1;
}

unint64_t sub_1CC327498(uint64_t a1, uint64_t **a2, uint64_t a3)
{
  char v4 = a2[8];
  uint64_t v3 = a2[9];
  if (v4 == v3) {
    return 0;
  }
  unint64_t v6 = (const llvm::MachineBasicBlock *)a2;
  uint64_t v7 = a1;
  unint64_t v8 = 0;
  uint64_t v25 = a1 + 920;
  do
  {
    unsigned int v27 = (const llvm::MachineBasicBlock *)*v4;
    uint64_t v9 = v27;
    uint64_t v10 = *sub_1CC3261A0(v25, (uint64_t *)&v27);
    if ((sub_1CD5297D8(a3, (uint64_t)v9, &BlockFreq) & 1) == 0
      && (!v10 || v9 == *(const llvm::MachineBasicBlock **)(*(void *)v10 + 8 * *(unsigned int *)(v10 + 8) - 8)))
    {
      unsigned int v22 = v3;
      unint64_t v23 = v8;
      uint64_t v24 = v6;
      unsigned int EdgeProbability = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(v7 + 568), v9, v6);
      int v12 = (const llvm::MachineBasicBlock **)*((void *)v9 + 11);
      uint64_t v13 = (const llvm::MachineBasicBlock **)*((void *)v9 + 12);
      if (v12 == v13)
      {
LABEL_13:
        uint64_t BlockFreq = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v7 + 576), v9);
        unint64_t v6 = v24;
        unsigned int v19 = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(v7 + 568), v9, v24);
        unint64_t v20 = llvm::BlockFrequency::operator*((unint64_t *)&BlockFreq, v19);
        unint64_t v8 = v23;
        if (v20 > v23) {
          unint64_t v8 = v20;
        }
      }
      else
      {
        unsigned int v14 = EdgeProbability;
        while (1)
        {
          uint64_t v15 = *v12;
          BOOL v26 = v15;
          uint64_t v16 = v7;
          unsigned int v17 = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(v7 + 568), v9, v15);
          uint64_t v18 = (const llvm::MachineBasicBlock ***)*sub_1CC3261A0(v25, (uint64_t *)&v26);
          if ((sub_1CD5297D8(a3, (uint64_t)v15, &BlockFreq) & 1) == 0 && v17 > v14 && (!v18 || v15 == **v18)) {
            break;
          }
          ++v12;
          uint64_t v7 = v16;
          if (v12 == v13) {
            goto LABEL_13;
          }
        }
        uint64_t v7 = v16;
        unint64_t v8 = v23;
        unint64_t v6 = v24;
      }
      uint64_t v3 = v22;
    }
    ++v4;
  }
  while (v4 != v3);
  return v8;
}

uint64_t sub_1CC327644(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0;
  if (sub_1CC01F510(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v4)) {
    return v4;
  }
  else {
    return *(void *)a1 + 24 * *(unsigned int *)(a1 + 16);
  }
}

uint64_t sub_1CC3276A0(uint64_t a1, uint64_t **a2, llvm::MachineBasicBlock ***this, uint64_t a4, uint64_t a5)
{
  int isSimpleBB = llvm::TailDuplicator::isSimpleBB((llvm::TailDuplicator *)this, (llvm::MachineBasicBlock *)a2);
  if ((((char *)this[12] - (char *)this[11]) & 0x7FFFFFFF8) == 8
    || !llvm::TailDuplicator::shouldTailDuplicate((llvm::TailDuplicator *)(a1 + 632), isSimpleBB, (llvm::MachineBasicBlock *)this))
  {
    return 0;
  }
  sub_1CD482B64((llvm::SmallPtrSetImplBase *)&v21, a2[11], a2[12]);
  unsigned int v14 = this[8];
  uint64_t v13 = this[9];
  if (v14 == v13) {
    goto LABEL_22;
  }
  char v18 = 1;
  int v19 = 0;
  do
  {
    uint64_t v15 = *v14;
    unint64_t v20 = v15;
    if (v15 != (llvm::MachineBasicBlock *)a2
      && (!a5 || sub_1CD5297D8(a5, (uint64_t)v15, v25))
      && *sub_1CC3261A0(a1 + 920, (uint64_t *)&v20) != a4)
    {
      if (llvm::TailDuplicator::canTailDuplicate((llvm::TailDuplicator *)(a1 + 632), (llvm::MachineBasicBlock *)this, v15))
      {
        ++v19;
      }
      else if ((v23 - v24) < 2 || !sub_1CC32844C((uint64_t)v15, (uint64_t *)&v21))
      {
        char v18 = 0;
      }
    }
    ++v14;
  }
  while (v14 != v13);
  if (!v19)
  {
LABEL_22:
    uint64_t v11 = 0;
  }
  else
  {
    llvm::Function::getEntryCount(**(uint64_t *****)(a1 + 560), 0, (uint64_t)v25);
    if (v26)
    {
      uint64_t v11 = 1;
    }
    else
    {
      uint64_t v16 = this[11];
      unsigned int v17 = this[12];
      if (v16 == v17) {
        uint64_t v11 = 1;
      }
      else {
        uint64_t v11 = (v19 + 1 <= ((unint64_t)((char *)v17 - (char *)v16) >> 3)) & v18;
      }
    }
  }
  if (v22 != v21) {
    free(v22);
  }
  return v11;
}

const llvm::MachineBasicBlock *sub_1CC32786C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = *(uint64_t **)a3;
  uint64_t v7 = *(unsigned int *)(a3 + 8);
  if (v7)
  {
    unint64_t v8 = &v6[v7];
    uint64_t v9 = 8 * v7 - 8;
    uint64_t v10 = *(uint64_t **)a3;
    while (1)
    {
      uint64_t v11 = *v10;
      unsigned int v22 = 0;
      if ((sub_1CBB0BF40(*(void *)(a1 + 920), *(_DWORD *)(a1 + 936), v11, &v22) & 1) != 0
        && *((void *)v22 + 1) == a2)
      {
        break;
      }
      ++v10;
      v9 -= 8;
      if (v10 == v8) {
        goto LABEL_16;
      }
    }
    if (v10 + 1 == v8)
    {
      unint64_t v8 = v10;
    }
    else
    {
      uint64_t v12 = 1;
      unint64_t v8 = v10;
      do
      {
        uint64_t v13 = v10[v12];
        unsigned int v22 = 0;
        if ((sub_1CBB0BF40(*(void *)(a1 + 920), *(_DWORD *)(a1 + 936), v13, &v22) & 1) == 0
          || *((void *)v22 + 1) != a2)
        {
          *v8++ = v10[v12];
        }
        ++v12;
        v9 -= 8;
      }
      while (v9);
      unint64_t v6 = *(uint64_t **)a3;
    }
  }
  else
  {
    unint64_t v8 = *(uint64_t **)a3;
  }
LABEL_16:
  unint64_t v14 = (unint64_t)((char *)v8 - (char *)v6) >> 3;
  *(_DWORD *)(a3 + 8) = v14;
  if (!v14) {
    return 0;
  }
  uint64_t v15 = 0;
  unint64_t v16 = 0;
  int v17 = *(unsigned __int8 *)(*v6 + 184);
  uint64_t v18 = 8 * ((unint64_t)((char *)v8 - (char *)v6) >> 3);
  do
  {
    int v19 = (const llvm::MachineBasicBlock *)*v6;
    unsigned int v22 = (const llvm::MachineBasicBlock *)*v6;
    if (*sub_1CC3261A0(a1 + 920, (uint64_t *)&v22) != a2)
    {
      unint64_t BlockFreq = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(a1 + 576), v19);
      if (((v15 != 0) & ((v17 != 0) ^ (v16 >= BlockFreq))) == 0)
      {
        unint64_t v16 = BlockFreq;
        uint64_t v15 = v19;
      }
    }
    ++v6;
    v18 -= 8;
  }
  while (v18);
  return v15;
}

unsigned int *sub_1CC327A20(unsigned int *result, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  if (a3 != a4)
  {
    v29[11] = v6;
    v29[12] = v7;
    uint64_t v11 = a3;
    uint64_t v13 = result;
    uint64_t v14 = (uint64_t)(result + 230);
    uint64_t v15 = result + 98;
    unint64_t v16 = result + 100;
    unsigned int v27 = result + 62;
    char v26 = result + 64;
    do
    {
      uint64_t v17 = *v11;
      uint64_t v28 = *v11;
      if (!a6 || (uint64_t result = (unsigned int *)sub_1CD5297D8(a6, v17, v29), result))
      {
        uint64_t result = (unsigned int *)sub_1CC3261A0(v14, &v28);
        uint64_t v18 = *(uint64_t ***)result;
        if (*(void *)result != a2 && v17 != a5)
        {
          int v20 = *((_DWORD *)v18 + 14);
          if (v20)
          {
            int v21 = v20 - 1;
            *((_DWORD *)v18 + 14) = v21;
            if (!v21)
            {
              uint64_t v22 = **v18;
              if (*(unsigned char *)(v22 + 184))
              {
                unint64_t v23 = v13[100];
                if (v23 >= v13[101]) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                int v24 = v15;
                uint64_t v25 = v16;
              }
              else
              {
                unint64_t v23 = v13[64];
                if (v23 >= v13[65]) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                uint64_t v25 = v26;
                int v24 = v27;
              }
              *(void *)(*v24 + 8 * v23) = v22;
              ++*v25;
            }
          }
        }
      }
      ++v11;
    }
    while (v11 != a4);
  }
  return result;
}

uint64_t sub_1CC327BA8(uint64_t a1, llvm::MachineBasicBlock *a2, const llvm::MachineBasicBlock ***a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = (const llvm::MachineBasicBlock **)*((void *)a2 + 11);
  unint64_t v5 = (const llvm::MachineBasicBlock **)*((void *)a2 + 12);
  if (v6 == v5) {
    return 0x80000000;
  }
  uint64_t v12 = a1 + 920;
  uint64_t v13 = 0x80000000;
  do
  {
    uint64_t v14 = *v6;
    int v19 = v14;
    if (*((unsigned char *)v14 + 184)
      || a4 && !sub_1CD5297D8(a4, (uint64_t)v14, &v20)
      || (unint64_t v16 = (const llvm::MachineBasicBlock ***)*sub_1CC3261A0(v12, (uint64_t *)&v19), v16 == a3))
    {
      unsigned int EdgeProbability = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(a1 + 568), a2, v14);
      if (v13 >= EdgeProbability) {
        uint64_t v13 = v13 - EdgeProbability;
      }
      else {
        uint64_t v13 = 0;
      }
    }
    else if (v14 == **v16)
    {
      unint64_t v17 = *(unsigned int *)(a5 + 8);
      if (v17 >= *(unsigned int *)(a5 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a5 + 8 * v17) = v14;
      ++*(_DWORD *)(a5 + 8);
    }
    ++v6;
  }
  while (v6 != v5);
  return v13;
}

uint64_t sub_1CC327CE0(uint64_t a1, uint64_t a2, const llvm::MachineBasicBlock *a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7)
{
  if (!*(_DWORD *)(a4 + 56)) {
    return 0;
  }
  llvm::Function::getEntryCount(**(uint64_t *****)(a2 + 32), 0, (uint64_t)v42);
  if (!v43)
  {
    uint64_t v15 = &llvm::StaticLikelyProb;
LABEL_18:
    unsigned int v37 = *((_DWORD *)v15 + 32);
    unint64_t v35 = 100;
    uint64_t v23 = 48;
    goto LABEL_19;
  }
  unint64_t v16 = *(uint64_t **)(a2 + 88);
  if (((*(void *)(a2 + 96) - (void)v16) & 0x7FFFFFFF8) != 0x10) {
    goto LABEL_17;
  }
  uint64_t v17 = *v16;
  uint64_t v18 = v16[1];
  int v19 = *(void **)(v17 + 88);
  uint64_t v20 = *(void **)(v17 + 96);
  if (v19 != v20)
  {
    while (*v19 != v18)
    {
      if (++v19 == v20)
      {
        int v19 = *(void **)(v17 + 96);
        break;
      }
    }
  }
  if (v19 == v20)
  {
    uint64_t v22 = *(void **)(v18 + 88);
    int v21 = *(void **)(v18 + 96);
    if (v22 != v21)
    {
      while (*v22 != v17)
      {
        if (++v22 == v21)
        {
          uint64_t v22 = v21;
          break;
        }
      }
    }
    if (v22 == v21)
    {
LABEL_17:
      uint64_t v15 = (uint64_t *)&llvm::ProfileLikelyProb;
      goto LABEL_18;
    }
  }
  unsigned int v37 = 2 * dword_1EBD05488;
  unint64_t v35 = 150;
  uint64_t v23 = 74;
LABEL_19:
  v42[0] = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(a1 + 576), (const llvm::MachineBasicBlock *)a2);
  unint64_t v41 = llvm::BlockFrequency::operator*(v42, a5);
  int v24 = (uint64_t *)*((void *)a3 + 8);
  uint64_t v25 = (uint64_t *)*((void *)a3 + 9);
  if (v24 != v25)
  {
    unint64_t v26 = (v23 | ((unint64_t)v37 << 31)) / v35;
    uint64_t v27 = a1 + 920;
    unsigned int v36 = v26;
    uint64_t v38 = a1;
    unsigned int v34 = 0x80000000 - v26;
    do
    {
      uint64_t v40 = (const llvm::MachineBasicBlock *)*v24;
      uint64_t v28 = v40;
      uint64_t v29 = *sub_1CC3261A0(v27, (uint64_t *)&v40);
      if (v28 == a3 || v29 == a4) {
        goto LABEL_29;
      }
      if (a7)
      {
        if (sub_1CD5297D8(a7, (uint64_t)v28, v42)) {
          BOOL v31 = v29 == a6;
        }
        else {
          BOOL v31 = 1;
        }
        if (v31) {
          goto LABEL_29;
        }
      }
      else if (v29 == a6)
      {
        goto LABEL_29;
      }
      if (v28 != (const llvm::MachineBasicBlock *)a2
        && v28 == *(const llvm::MachineBasicBlock **)(*(void *)v29 + 8 * *(unsigned int *)(v29 + 8) - 8))
      {
        uint64_t BlockFreq = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v38 + 576), v28);
        unsigned int EdgeProbability = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(v38 + 568), v28, a3);
        v42[0] = llvm::BlockFrequency::operator*((unint64_t *)&BlockFreq, EdgeProbability);
        unint64_t v33 = llvm::BlockFrequency::operator*(v42, v36);
        if (v33 >= llvm::BlockFrequency::operator*(&v41, v34)) {
          return 1;
        }
      }
LABEL_29:
      ++v24;
    }
    while (v24 != v25);
  }
  return 0;
}

BOOL sub_1CC327F64(uint64_t a1, const llvm::MachineBasicBlock *a2, llvm::MachineBasicBlock *a3, unsigned int a4, const llvm::MachineBasicBlock ***a5, uint64_t a6)
{
  void v21[4] = *MEMORY[0x1E4F143B8];
  v17[1] = 0;
  int v19 = v21;
  uint64_t v20 = 0x400000000;
  sub_1CC327BA8(a1, a3, a5, a6, (uint64_t)&v19);
  unsigned int EdgeProbability = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(a1 + 568), a2, a3);
  v17[0] = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(a1 + 576), a2);
  llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(a1 + 576), a3);
  unint64_t v11 = llvm::BlockFrequency::operator*(v17, EdgeProbability);
  unint64_t v12 = llvm::BlockFrequency::operator*(v17, a4);
  unint64_t EntryFreq = llvm::MachineBlockFrequencyInfo::getEntryFreq(**(llvm::MachineBlockFrequencyInfo ***)(a1 + 576));
  if (v20)
  {
    llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(a1 + 568), a3, *(const llvm::MachineBasicBlock **)v19);
    llvm::DominatorTreeBase<llvm::MachineBasicBlock,true>::dominates();
  }
  if (v11 >= v12) {
    unint64_t v14 = v11 - v12;
  }
  else {
    unint64_t v14 = 0;
  }
  LODWORD(v18) = (unint64_t)(((((unint64_t)dword_1EBCCE388 << 31) | 0x30)
                                   * (unsigned __int128)0xA3D70A3D70A3D70BLL) >> 64) >> 6;
  unint64_t v15 = llvm::BranchProbability::scaleByInverse((llvm::BranchProbability *)&v18, v14);
  if (v19 != v21) {
    free(v19);
  }
  return v15 >= EntryFreq;
}

BOOL sub_1CC32844C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(char **)(a1 + 88);
  unsigned int v2 = *(char **)(a1 + 96);
  uint64_t v4 = *((unsigned int *)a2 + 5);
  if (v4 - *((_DWORD *)a2 + 6) != ((unint64_t)(v2 - v3) >> 3)) {
    return 0;
  }
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  if (v5 == *a2)
  {
    uint64_t v7 = (void *)(v5 + 8 * v4);
    if (v4)
    {
      uint64_t v8 = 0;
      while (*(void *)(v5 + v8) != a1)
      {
        v8 += 8;
        if (8 * v4 == v8) {
          goto LABEL_20;
        }
      }
      uint64_t v7 = (void *)(v5 + v8);
    }
LABEL_20:
    uint64_t v17 = a2[1];
  }
  else
  {
    uint64_t v9 = *((unsigned int *)a2 + 4);
    int v10 = v9 - 1;
    unsigned int v11 = (v9 - 1) & ((a1 >> 4) ^ (a1 >> 9));
    uint64_t v7 = (void *)(v5 + 8 * v11);
    uint64_t v12 = *v7;
    if (*v7 == -1)
    {
      uint64_t v13 = 0;
LABEL_22:
      if (v13) {
        uint64_t v7 = v13;
      }
      uint64_t v18 = (void *)(v5 + 8 * v9);
      if (*v7 != a1) {
        uint64_t v7 = v18;
      }
    }
    else
    {
      uint64_t v13 = 0;
      int v14 = 1;
      while (v12 != a1)
      {
        if (v13) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v12 == -2;
        }
        if (v15) {
          uint64_t v13 = v7;
        }
        unsigned int v16 = v11 + v14++;
        unsigned int v11 = v16 & v10;
        uint64_t v7 = (void *)(v5 + 8 * (v16 & v10));
        uint64_t v12 = *v7;
        if (*v7 == -1) {
          goto LABEL_22;
        }
      }
    }
    uint64_t v17 = *a2;
  }
  unsigned int v19 = *((_DWORD *)a2 + 4);
  unsigned int v20 = v5 == v17 ? *((_DWORD *)a2 + 5) : *((_DWORD *)a2 + 4);
  if (v7 != (void *)(v5 + 8 * v20)) {
    return 0;
  }
  if (v3 == v2) {
    return 1;
  }
  unsigned int v22 = v19 - 1;
  if (v5 == v6) {
    unsigned int v23 = *((_DWORD *)a2 + 5);
  }
  else {
    unsigned int v23 = *((_DWORD *)a2 + 4);
  }
  int v24 = (void *)(v5 + 8 * v23);
  unsigned int v25 = *((_DWORD *)a2 + 5);
  uint64_t v26 = v5;
  do
  {
    uint64_t v27 = *(void *)v3;
    if (v26 == v17)
    {
      uint64_t v28 = (void *)(v17 + 8 * v25);
      if (v25)
      {
        uint64_t v29 = 0;
        while (*(void *)(v17 + v29) != v27)
        {
          v29 += 8;
          if (8 * v25 == v29) {
            goto LABEL_56;
          }
        }
        uint64_t v28 = (void *)(v17 + v29);
      }
LABEL_56:
      uint64_t v26 = v17;
    }
    else
    {
      unsigned int v30 = ((v27 >> 4) ^ (v27 >> 9)) & v22;
      BOOL v31 = (void *)(v5 + 8 * v30);
      uint64_t v32 = *v31;
      if (*v31 == -1)
      {
        unint64_t v33 = 0;
LABEL_58:
        if (v33) {
          BOOL v31 = v33;
        }
        uint64_t v37 = *v31;
      }
      else
      {
        unint64_t v33 = 0;
        int v34 = 1;
        while (v32 != v27)
        {
          if (v33) {
            BOOL v35 = 0;
          }
          else {
            BOOL v35 = v32 == -2;
          }
          if (v35) {
            unint64_t v33 = v31;
          }
          unsigned int v36 = v30 + v34++;
          unsigned int v30 = v36 & v22;
          BOOL v31 = (void *)(v5 + 8 * (v36 & v22));
          uint64_t v32 = *v31;
          if (*v31 == -1) {
            goto LABEL_58;
          }
        }
        uint64_t v37 = *(void *)v3;
      }
      if (v37 == v27) {
        uint64_t v28 = v31;
      }
      else {
        uint64_t v28 = v24;
      }
      unsigned int v25 = v4;
      uint64_t v17 = v6;
      uint64_t v26 = v5;
    }
    if (v26 == v17) {
      unsigned int v38 = v25;
    }
    else {
      unsigned int v38 = v19;
    }
    BOOL v39 = (void *)(v26 + 8 * v38);
    BOOL v15 = v28 == v39;
    BOOL result = v28 != v39;
    v3 += 8;
  }
  while (!v15 && v3 != v2);
  return result;
}

void sub_1CC32866C(__n128 *a1, unsigned int a2, __n128 a3)
{
  unint64_t v4 = a2;
  uint64_t v5 = (__n128 *)((char *)a1 + 24 * a2);
  if (a2 < 0x81)
  {
LABEL_5:
    sub_1CC328748(a1, v5, v4, 0, 0, a3);
  }
  else
  {
    uint64_t v6 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
    unint64_t v7 = a2;
    while (1)
    {
      uint64_t v8 = operator new(24 * v7, v6);
      if (v8) {
        break;
      }
      BOOL v9 = v7 > 1;
      v7 >>= 1;
      if (!v9) {
        goto LABEL_5;
      }
    }
    int v10 = v8;
    sub_1CC328748(a1, v5, v4, (uint64_t)v8, v7, a3);
    operator delete(v10);
  }
}

__n128 sub_1CC328748(__n128 *a1, __n128 *a2, unint64_t a3, uint64_t a4, uint64_t a5, __n128 result)
{
  if (a3 >= 2)
  {
    unint64_t v7 = a1;
    if (a3 == 2)
    {
      uint64_t v8 = (__n128 *)((char *)a2 - 24);
      if (a2[-2].n128_u64[1] > a1->n128_u64[0])
      {
        unint64_t v9 = a1[1].n128_u64[0];
        BOOL result = *a1;
        unint64_t v10 = a2[-1].n128_u64[1];
        *a1 = *v8;
        a1[1].n128_u64[0] = v10;
        *uint64_t v8 = result;
        a2[-1].n128_u64[1] = v9;
      }
    }
    else if ((uint64_t)a3 > 128)
    {
      uint64_t v21 = a4;
      unint64_t v22 = a3 >> 1;
      unsigned int v23 = (__n128 *)((char *)a1 + 24 * (a3 >> 1));
      unint64_t v24 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        __n128 v25 = sub_1CC3289F4(a1, v23, v24, a4, result);
        uint64_t v26 = v21 + 24 * v22;
        result.n128_u64[0] = sub_1CC3289F4((__n128 *)((char *)v7 + 24 * (a3 >> 1)), a2, a3 - (a3 >> 1), v26, v25).n128_u64[0];
        uint64_t v27 = (__n128 *)(v21 + 24 * a3);
        uint64_t v28 = (__n128 *)v26;
        while (v28 != v27)
        {
          if (v28->n128_u64[0] <= *(void *)v21)
          {
            BOOL result = *(__n128 *)v21;
            v7[1].n128_u64[0] = *(void *)(v21 + 16);
            *unint64_t v7 = result;
            v21 += 24;
          }
          else
          {
            BOOL result = *v28;
            v7[1].n128_u64[0] = v28[1].n128_u64[0];
            *unint64_t v7 = result;
            uint64_t v28 = (__n128 *)((char *)v28 + 24);
          }
          unint64_t v7 = (__n128 *)((char *)v7 + 24);
          if (v21 == v26)
          {
            if (v28 != v27)
            {
              unint64_t v29 = 0;
              do
              {
                unsigned int v30 = (__n128 *)((char *)v7 + v29);
                BOOL result = *(__n128 *)((char *)v28 + v29);
                v30[1].n128_u64[0] = v28[1].n128_u64[v29 / 8];
                *unsigned int v30 = result;
                v29 += 24;
              }
              while ((__n128 *)((char *)v28 + v29) != v27);
            }
            return result;
          }
        }
        if (v21 != v26)
        {
          uint64_t v31 = 0;
          do
          {
            uint64_t v32 = (__n128 *)((char *)v7 + v31);
            BOOL result = *(__n128 *)(v21 + v31);
            v32[1].n128_u64[0] = *(void *)(v21 + v31 + 16);
            *uint64_t v32 = result;
            v31 += 24;
          }
          while (v21 + v31 != v26);
        }
      }
      else
      {
        sub_1CC328748(a1, v23, v24, a4, a5);
        sub_1CC328748((char *)v7 + 24 * (a3 >> 1), a2, a3 - (a3 >> 1), v21, a5);
        sub_1CC328C6C((char *)v7, (char *)v7 + 24 * (a3 >> 1), (char *)a2, a3 >> 1, a3 - (a3 >> 1), (char *)v21, a5);
      }
    }
    else if (a1 != a2)
    {
      uint64_t v12 = &a1[1].n128_i8[8];
      if (&a1[1].n128_i8[8] != (__int8 *)a2)
      {
        uint64_t v13 = 0;
        int v14 = a1;
        do
        {
          BOOL v15 = (__n128 *)v12;
          unint64_t v16 = v14[1].n128_u64[1];
          if (v16 > v14->n128_u64[0])
          {
            __n128 v33 = v14[2];
            uint64_t v17 = v13;
            while (1)
            {
              uint64_t v18 = (char *)a1 + v17;
              *(__n128 *)(v18 + 24) = *(__n128 *)((char *)a1 + v17);
              *((void *)v18 + 5) = *(unint64_t *)((char *)a1[1].n128_u64 + v17);
              if (!v17) {
                break;
              }
              v17 -= 24;
              if (v16 <= *((void *)v18 - 3))
              {
                uint64_t v19 = (uint64_t)&a1[1].n128_i64[1] + v17;
                goto LABEL_15;
              }
            }
            uint64_t v19 = (uint64_t)a1;
LABEL_15:
            *(void *)uint64_t v19 = v16;
            BOOL result = v33;
            *(__n128 *)(v19 + 8) = v33;
          }
          uint64_t v12 = &v15[1].n128_i8[8];
          v13 += 24;
          int v14 = v15;
        }
        while (&v15[1].n128_i8[8] != (__int8 *)a2);
      }
    }
  }
  return result;
}

__n128 sub_1CC3289F4(__n128 *a1, __n128 *a2, unint64_t a3, uint64_t a4, __n128 result)
{
  if (a3)
  {
    uint64_t v5 = (__n128 *)a4;
    uint64_t v8 = a1;
    if (a3 == 2)
    {
      unint64_t v9 = (__n128 *)((char *)a2 - 24);
      if (a2[-2].n128_u64[1] <= a1->n128_u64[0])
      {
        __n128 v19 = *a1;
        *(void *)(a4 + 16) = a1[1].n128_u64[0];
        *(__n128 *)a4 = v19;
        BOOL result = *v9;
        unint64_t v11 = a2[-1].n128_u64[1];
      }
      else
      {
        __n128 v10 = *v9;
        *(void *)(a4 + 16) = a2[-1].n128_u64[1];
        *(__n128 *)a4 = v10;
        BOOL result = *a1;
        unint64_t v11 = a1[1].n128_u64[0];
      }
      *(void *)(a4 + 40) = v11;
      *(__n128 *)(a4 + 24) = result;
    }
    else if (a3 == 1)
    {
      BOOL result = *a1;
      *(void *)(a4 + 16) = a1[1].n128_u64[0];
      *(__n128 *)a4 = result;
    }
    else if ((uint64_t)a3 > 8)
    {
      unsigned int v20 = (__n128 *)((char *)a1 + 24 * (a3 >> 1));
      sub_1CC328748(a1, v20, a3 >> 1, a4, a3 >> 1);
      sub_1CC328748((char *)v8 + 24 * (a3 >> 1), a2, a3 - (a3 >> 1), (char *)v5 + 24 * (a3 >> 1), a3 - (a3 >> 1));
      uint64_t v21 = (__n128 *)((char *)v8 + 24 * (a3 >> 1));
      while (v21 != a2)
      {
        if (v21->n128_u64[0] <= v8->n128_u64[0])
        {
          BOOL result = *v8;
          v5[1].n128_u64[0] = v8[1].n128_u64[0];
          *uint64_t v5 = result;
          uint64_t v8 = (__n128 *)((char *)v8 + 24);
        }
        else
        {
          BOOL result = *v21;
          v5[1].n128_u64[0] = v21[1].n128_u64[0];
          *uint64_t v5 = result;
          uint64_t v21 = (__n128 *)((char *)v21 + 24);
        }
        uint64_t v5 = (__n128 *)((char *)v5 + 24);
        if (v8 == v20)
        {
          if (v21 != a2)
          {
            unint64_t v22 = 0;
            do
            {
              unsigned int v23 = (__n128 *)((char *)v5 + v22);
              BOOL result = *(__n128 *)((char *)v21 + v22);
              v23[1].n128_u64[0] = v21[1].n128_u64[v22 / 8];
              *unsigned int v23 = result;
              v22 += 24;
            }
            while ((__n128 *)((char *)v21 + v22) != a2);
          }
          return result;
        }
      }
      if (v8 != v20)
      {
        unint64_t v24 = 0;
        do
        {
          __n128 v25 = (__n128 *)((char *)v5 + v24);
          BOOL result = *(__n128 *)((char *)v8 + v24);
          v25[1].n128_u64[0] = v8[1].n128_u64[v24 / 8];
          *__n128 v25 = result;
          v24 += 24;
        }
        while ((__n128 *)((char *)v8 + v24) != v20);
      }
    }
    else if (a1 != a2)
    {
      BOOL result = *a1;
      *(void *)(a4 + 16) = a1[1].n128_u64[0];
      *(__n128 *)a4 = result;
      uint64_t v12 = (__n128 *)((char *)a1 + 24);
      if (&a1[1].n128_i8[8] != (__int8 *)a2)
      {
        uint64_t v13 = 0;
        int v14 = (void *)a4;
        do
        {
          BOOL v15 = v14;
          unint64_t v16 = *v14;
          v14 += 3;
          uint64_t v17 = v14;
          if (v12->n128_u64[0] > v16)
          {
            *(_OWORD *)int v14 = *(_OWORD *)v15;
            long long v14[2] = v15[2];
            uint64_t v17 = (void *)a4;
            if (v15 != (void *)a4)
            {
              uint64_t v18 = v13;
              while (1)
              {
                uint64_t v17 = (void *)(a4 + v18);
                if (v12->n128_u64[0] <= *(void *)(a4 + v18 - 24)) {
                  break;
                }
                *(_OWORD *)uint64_t v17 = *(_OWORD *)(a4 + v18 - 24);
                unint64_t v17[2] = *(void *)(a4 + v18 - 8);
                v18 -= 24;
                if (!v18)
                {
                  uint64_t v17 = (void *)a4;
                  break;
                }
              }
            }
          }
          BOOL result = *v12;
          unint64_t v17[2] = v12[1].n128_u64[0];
          *(__n128 *)uint64_t v17 = result;
          uint64_t v12 = (__n128 *)((char *)v12 + 24);
          v13 += 24;
        }
        while (v12 != a2);
      }
    }
  }
  return result;
}

char *sub_1CC328C6C(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7)
{
  if (a5)
  {
    uint64_t v7 = a5;
    while (a4 > a7 && v7 > a7)
    {
      if (!a4) {
        return result;
      }
      uint64_t v10 = 0;
      uint64_t v11 = -a4;
      while (*(void *)a2 <= *(void *)&result[v10])
      {
        v10 += 24;
        if (__CFADD__(v11++, 1)) {
          return result;
        }
      }
      uint64_t v13 = -v11;
      int v14 = &result[v10];
      if (-v11 >= v7)
      {
        if (v11 == -1)
        {
          uint64_t v85 = &result[v10];
          uint64_t v105 = *((void *)v85 + 2);
          long long v100 = *(_OWORD *)v85;
          long long v86 = *(_OWORD *)a2;
          *((void *)v85 + 2) = *((void *)a2 + 2);
          *(_OWORD *)uint64_t v85 = v86;
          *((void *)a2 + 2) = v105;
          *(_OWORD *)a2 = v100;
          return result;
        }
        if (v11 > 0) {
          uint64_t v13 = 1 - v11;
        }
        uint64_t v24 = v13 >> 1;
        uint64_t v18 = &result[24 * (v13 >> 1) + v10];
        uint64_t v17 = a3;
        if (a3 != a2)
        {
          unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((a3 - a2) >> 3);
          uint64_t v17 = a2;
          do
          {
            unint64_t v26 = v25 >> 1;
            uint64_t v27 = &v17[24 * (v25 >> 1)];
            unint64_t v29 = *(void *)v27;
            uint64_t v28 = v27 + 24;
            v25 += ~(v25 >> 1);
            if (v29 > *(void *)v18) {
              uint64_t v17 = v28;
            }
            else {
              unint64_t v25 = v26;
            }
          }
          while (v25);
        }
        uint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v17 - a2) >> 3);
      }
      else
      {
        if (v7 >= 0) {
          uint64_t v15 = v7;
        }
        else {
          uint64_t v15 = v7 + 1;
        }
        uint64_t v16 = v15 >> 1;
        uint64_t v17 = &a2[24 * (v15 >> 1)];
        uint64_t v18 = a2;
        if (v14 != a2)
        {
          unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((a2 - result - v10) >> 3);
          uint64_t v18 = &result[v10];
          do
          {
            unint64_t v20 = v19 >> 1;
            uint64_t v21 = &v18[24 * (v19 >> 1)];
            unint64_t v23 = *(void *)v21;
            unint64_t v22 = v21 + 24;
            v19 += ~(v19 >> 1);
            if (*(void *)v17 > v23) {
              unint64_t v19 = v20;
            }
            else {
              uint64_t v18 = v22;
            }
          }
          while (v19);
        }
        uint64_t v24 = 0xAAAAAAAAAAAAAAABLL * ((v18 - result - v10) >> 3);
      }
      unsigned int v30 = v17;
      if (v18 != a2)
      {
        unsigned int v30 = v18;
        if (a2 != v17)
        {
          if (v18 + 24 == a2)
          {
            uint64_t v102 = *((void *)v18 + 2);
            long long v97 = *(_OWORD *)v18;
            int64_t v36 = v17 - a2;
            int v92 = a6;
            uint64_t v94 = a7;
            uint64_t v37 = a3;
            unsigned int v38 = &result[v10];
            uint64_t v90 = v16;
            uint64_t v39 = v24;
            memmove(v18, a2, v17 - a2);
            uint64_t v24 = v39;
            uint64_t v16 = v90;
            a6 = v92;
            int v14 = v38;
            a7 = v94;
            a3 = v37;
            unsigned int v30 = &v18[v36];
            *(_OWORD *)unsigned int v30 = v97;
            *((void *)v30 + 2) = v102;
          }
          else if (a2 + 24 == v17)
          {
            unsigned int v30 = v18 + 24;
            uint64_t v103 = *((void *)v17 - 1);
            long long v98 = *(_OWORD *)(v17 - 24);
            if (v17 - 24 != v18)
            {
              BOOL v93 = a6;
              uint64_t v95 = a7;
              uint64_t v40 = a3;
              unint64_t v41 = &result[v10];
              uint64_t v91 = v16;
              uint64_t v42 = v24;
              memmove(v18 + 24, v18, v17 - 24 - v18);
              uint64_t v24 = v42;
              uint64_t v16 = v91;
              a6 = v93;
              int v14 = v41;
              a7 = v95;
              a3 = v40;
            }
            *((void *)v18 + 2) = v103;
            *(_OWORD *)uint64_t v18 = v98;
          }
          else
          {
            unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((a2 - v18) >> 3);
            if (v31 == 0xAAAAAAAAAAAAAAABLL * ((v17 - a2) >> 3))
            {
              uint64_t v32 = 0;
              do
              {
                __n128 v33 = &a2[v32];
                int v34 = &v18[v32];
                uint64_t v101 = *(void *)&v18[v32 + 16];
                long long v96 = *(_OWORD *)&v18[v32];
                long long v35 = *(_OWORD *)&a2[v32];
                *((void *)v34 + 2) = *(void *)&a2[v32 + 16];
                *(_OWORD *)int v34 = v35;
                *((void *)v33 + 2) = v101;
                *(_OWORD *)__n128 v33 = v96;
                if (&v18[v32 + 24] == a2) {
                  break;
                }
                v32 += 24;
              }
              while (v33 + 24 != v17);
              unsigned int v30 = a2;
            }
            else
            {
              uint64_t v43 = 0xAAAAAAAAAAAAAAABLL * ((v17 - a2) >> 3);
              unint64_t v44 = 0xAAAAAAAAAAAAAAABLL * ((a2 - v18) >> 3);
              do
              {
                uint64_t v45 = v44;
                unint64_t v44 = v43;
                uint64_t v43 = v45 % v43;
              }
              while (v43);
              if (v44)
              {
                uint64_t v46 = &v18[24 * v44];
                do
                {
                  long long v47 = *(_OWORD *)(v46 - 24);
                  uint64_t v48 = *((void *)v46 - 1);
                  v46 -= 24;
                  uint64_t v104 = v48;
                  long long v99 = v47;
                  uint64_t v49 = &v46[8 * ((a2 - v18) >> 3)];
                  unsigned int v50 = v46;
                  do
                  {
                    uint64_t v51 = v50;
                    unsigned int v50 = v49;
                    long long v52 = *(_OWORD *)v49;
                    *((void *)v51 + 2) = *((void *)v49 + 2);
                    *(_OWORD *)uint64_t v51 = v52;
                    unint64_t v53 = 0xAAAAAAAAAAAAAAABLL * ((v17 - v49) >> 3);
                    BOOL v54 = __OFSUB__(v31, v53);
                    uint64_t v55 = v31 - v53;
                    char v75 = (v55 < 0) ^ v54;
                    uint64_t v49 = &v18[24 * v55];
                    if (v75) {
                      uint64_t v49 = &v50[8 * ((a2 - v18) >> 3)];
                    }
                  }
                  while (v49 != v46);
                  *((void *)v50 + 2) = v104;
                  *(_OWORD *)unsigned int v50 = v99;
                }
                while (v46 != v18);
              }
              unsigned int v30 = &v18[8 * ((v17 - a2) >> 3)];
            }
          }
        }
      }
      a4 = -(v24 + v11);
      uint64_t v56 = v7 - v16;
      if (v24 + v16 >= v7 - (v24 + v16) - v11)
      {
        uint64_t v61 = v24;
        uint64_t v62 = -(v24 + v11);
        uint64_t v63 = v16;
        uint64_t v64 = v7 - v16;
        uint64_t v65 = a6;
        uint64_t v66 = a7;
        uint64_t v67 = v14;
        sub_1CC328C6C(v30, v17, a3, v62, v64);
        BOOL result = v67;
        a7 = v66;
        a6 = v65;
        uint64_t v17 = v18;
        uint64_t v56 = v63;
        a4 = v61;
        a3 = v30;
      }
      else
      {
        unint64_t v57 = v18;
        unint64_t v58 = a6;
        uint64_t v59 = a7;
        unint64_t v60 = a3;
        sub_1CC328C6C(v14, v57, v30, v24, v16);
        a7 = v59;
        a3 = v60;
        a6 = v58;
        BOOL result = v30;
      }
      uint64_t v7 = v56;
      a2 = v17;
      if (!v56) {
        return result;
      }
    }
    if (a4 <= v7)
    {
      if (result != a2)
      {
        unint64_t v79 = 0;
        do
        {
          unsigned int v80 = &a6[v79];
          long long v81 = *(_OWORD *)&result[v79];
          *((void *)v80 + 2) = *(void *)&result[v79 + 16];
          *(_OWORD *)unsigned int v80 = v81;
          v79 += 24;
        }
        while (&result[v79] != a2);
        if (v79)
        {
          unsigned int v82 = a6;
          while (a2 != a3)
          {
            if (*(void *)a2 <= *(void *)v82)
            {
              long long v84 = *(_OWORD *)v82;
              *((void *)result + 2) = *((void *)v82 + 2);
              *(_OWORD *)BOOL result = v84;
              v82 += 24;
            }
            else
            {
              long long v83 = *(_OWORD *)a2;
              *((void *)result + 2) = *((void *)a2 + 2);
              *(_OWORD *)BOOL result = v83;
              a2 += 24;
            }
            result += 24;
            if (&a6[v79] == v82) {
              return result;
            }
          }
          return (char *)memmove(result, v82, a6 - v82 + v79);
        }
      }
    }
    else if (a2 != a3)
    {
      unint64_t v68 = 0;
      do
      {
        unsigned int v69 = &a6[v68];
        long long v70 = *(_OWORD *)&a2[v68];
        *((void *)v69 + 2) = *(void *)&a2[v68 + 16];
        *(_OWORD *)unsigned int v69 = v70;
        v68 += 24;
      }
      while (&a2[v68] != a3);
      if (v68)
      {
        uint64_t v71 = &a6[v68];
        unsigned int v72 = a3 - 24;
        while (a2 != result)
        {
          unint64_t v73 = *((void *)v71 - 3);
          unint64_t v74 = *((void *)a2 - 3);
          char v75 = v73 > v74;
          if (v73 <= v74) {
            unsigned int v76 = v71 - 24;
          }
          else {
            unsigned int v76 = a2 - 24;
          }
          if (v75) {
            a2 -= 24;
          }
          long long v77 = *(_OWORD *)v76;
          uint64_t v78 = *((void *)v76 + 2);
          if (!v75) {
            v71 -= 24;
          }
          *((void *)v72 + 2) = v78;
          *(_OWORD *)unsigned int v72 = v77;
          v72 -= 24;
          if (v71 == a6) {
            return result;
          }
        }
        if (v71 != a6)
        {
          unint64_t v87 = 0;
          do
          {
            unsigned int v88 = &v72[v87];
            long long v89 = *(_OWORD *)&v71[v87 - 24];
            *((void *)v88 + 2) = *(void *)&v71[v87 - 8];
            *(_OWORD *)unsigned int v88 = v89;
            v87 -= 24;
          }
          while (&v71[v87] != a6);
        }
      }
    }
  }
  return result;
}

void sub_1CC32927C(__n128 *a1, __n128 *a2, unint64_t a3, __n128 *a4, uint64_t a5, __n128 a6)
{
  if (a3 >= 2)
  {
    uint64_t v7 = a1;
    if (a3 == 2)
    {
      unsigned __int32 v8 = a2[-1].n128_u32[0];
      unsigned __int32 v9 = a1->n128_u32[0];
      if (v8 > a1->n128_u32[0])
      {
        a1->n128_u32[0] = v8;
        a2[-1].n128_u32[0] = v9;
        unint64_t v10 = a1->n128_u64[1];
        a1->n128_u64[1] = a2[-1].n128_u64[1];
        a2[-1].n128_u64[1] = v10;
      }
    }
    else if ((uint64_t)a3 <= 0)
    {
      if (a1 != a2)
      {
        uint64_t v17 = a1 + 1;
        if (&a1[1] != a2)
        {
          uint64_t v18 = 0;
          unint64_t v19 = a1;
          do
          {
            unint64_t v20 = v17;
            unsigned __int32 v21 = v19[1].n128_u32[0];
            unsigned __int32 v22 = v19->n128_u32[0];
            if (v21 > v19->n128_u32[0])
            {
              unint64_t v23 = v19[1].n128_u64[1];
              uint64_t v24 = v18;
              while (1)
              {
                unint64_t v25 = (char *)a1 + v24;
                *((_DWORD *)v25 + 4) = v22;
                *((void *)v25 + 3) = *(unint64_t *)((char *)&a1->n128_u64[1] + v24);
                if (!v24) {
                  break;
                }
                unsigned __int32 v22 = *((_DWORD *)v25 - 4);
                v24 -= 16;
                if (v21 <= v22)
                {
                  uint64_t v26 = (uint64_t)&a1[1] + v24;
                  goto LABEL_20;
                }
              }
              uint64_t v26 = (uint64_t)a1;
LABEL_20:
              *(_DWORD *)uint64_t v26 = v21;
              *(void *)(v26 + 8) = v23;
            }
            uint64_t v17 = v20 + 1;
            v18 += 16;
            unint64_t v19 = v20;
          }
          while (&v20[1] != a2);
        }
      }
    }
    else
    {
      uint64_t v13 = (char *)a4;
      unint64_t v14 = a3 >> 1;
      uint64_t v15 = &a1[a3 >> 1];
      unint64_t v16 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        __n128 v27 = sub_1CC3294EC(a1, v15, v16, a4, a6);
        uint64_t v28 = (__n128 *)&v13[16 * v14];
        sub_1CC3294EC(&v7[a3 >> 1], a2, a3 - (a3 >> 1), v28, v27);
        unint64_t v29 = &v13[16 * a3];
        unsigned int v30 = v28;
        while (v30 != (__n128 *)v29)
        {
          unsigned __int32 v31 = v30->n128_u32[0];
          BOOL v32 = v30->n128_u32[0] > *(_DWORD *)v13;
          if (v30->n128_u32[0] > *(_DWORD *)v13)
          {
            __n128 v33 = v30;
          }
          else
          {
            unsigned __int32 v31 = *(_DWORD *)v13;
            __n128 v33 = (__n128 *)v13;
          }
          if (v30->n128_u32[0] > *(_DWORD *)v13) {
            ++v30;
          }
          unint64_t v34 = v33->n128_u64[1];
          if (!v32) {
            v13 += 16;
          }
          v7->n128_u32[0] = v31;
          v7->n128_u64[1] = v34;
          ++v7;
          if (v13 == (char *)v28)
          {
            if (v30 != (__n128 *)v29)
            {
              uint64_t v35 = 0;
              do
              {
                int64_t v36 = &v30[v35];
                uint64_t v37 = &v7[v35];
                v37->n128_u32[0] = v30[v35].n128_u32[0];
                v37->n128_u64[1] = v30[v35++].n128_u64[1];
              }
              while (&v36[1] != (__n128 *)v29);
            }
            return;
          }
        }
        if (v13 != (char *)v28)
        {
          unint64_t v38 = 0;
          do
          {
            uint64_t v39 = &v7[v38 / 0x10];
            uint64_t v40 = (__n128 *)&v13[v38];
            v39->n128_u32[0] = *(_DWORD *)&v13[v38];
            v39->n128_u64[1] = *(void *)&v13[v38 + 8];
            v38 += 16;
          }
          while (&v40[1] != v28);
        }
      }
      else
      {
        sub_1CC32927C(a1, v15, v16, a4, a5);
        sub_1CC32927C(&v7[a3 >> 1], a2, a3 - (a3 >> 1), v13, a5);
        sub_1CC3296F8((char *)v7, (char *)&v7[a3 >> 1], (char *)a2, a3 >> 1, a3 - (a3 >> 1), v13, a5);
      }
    }
  }
}

__n128 sub_1CC3294EC(__n128 *a1, __n128 *a2, unint64_t a3, __n128 *a4, __n128 result)
{
  if (a3)
  {
    uint64_t v5 = a4;
    unsigned __int32 v8 = a1;
    if (a3 == 2)
    {
      unsigned __int32 v9 = a2 - 1;
      if (a2[-1].n128_u32[0] <= a1->n128_u32[0])
      {
        *a4 = *a1;
        BOOL result = *v9;
      }
      else
      {
        *a4 = *v9;
        BOOL result = *a1;
      }
      a4[1] = result;
    }
    else if (a3 == 1)
    {
      BOOL result = *a1;
      *a4 = *a1;
    }
    else if ((uint64_t)a3 > 8)
    {
      unint64_t v19 = &a1[a3 >> 1];
      sub_1CC32927C(a1, v19, a3 >> 1, a4, a3 >> 1);
      sub_1CC32927C(&v8[a3 >> 1], a2, a3 - (a3 >> 1), &v5[a3 >> 1], a3 - (a3 >> 1));
      unint64_t v20 = &v8[a3 >> 1];
      while (v20 != a2)
      {
        if (v20->n128_u32[0] <= v8->n128_u32[0])
        {
          __n128 v22 = *v8++;
          BOOL result = v22;
        }
        else
        {
          __n128 v21 = *v20++;
          BOOL result = v21;
        }
        *v5++ = result;
        if (v8 == v19)
        {
          if (v20 != a2)
          {
            uint64_t v23 = 0;
            do
            {
              BOOL result = v20[v23];
              v5[v23++] = result;
            }
            while (&v20[v23] != a2);
          }
          return result;
        }
      }
      if (v8 != v19)
      {
        uint64_t v24 = 0;
        do
        {
          BOOL result = v8[v24];
          v5[v24++] = result;
        }
        while (&v8[v24] != v19);
      }
    }
    else if (a1 != a2)
    {
      BOOL result = *a1;
      *a4 = *a1;
      unint64_t v10 = a1 + 1;
      if (&a1[1] != a2)
      {
        uint64_t v11 = 0;
        uint64_t v12 = a4;
        uint64_t v13 = a4;
        do
        {
          unint64_t v14 = v10;
          unsigned __int32 v15 = v13->n128_u32[0];
          ++v13;
          if (v8[1].n128_u32[0] <= v15)
          {
            BOOL result = *v10;
            *uint64_t v13 = *v10;
          }
          else
          {
            BOOL result = *v12;
            *uint64_t v13 = *v12;
            unint64_t v16 = a4;
            if (v12 != a4)
            {
              uint64_t v17 = v11;
              while (1)
              {
                unint64_t v16 = (__n128 *)((char *)a4 + v17);
                unsigned __int32 v18 = *(unsigned __int32 *)((char *)a4[-1].n128_u32 + v17);
                if (v14->n128_u32[0] <= v18) {
                  break;
                }
                v16->n128_u32[0] = v18;
                v16->n128_u64[1] = v16[-1].n128_u64[1];
                v17 -= 16;
                if (!v17)
                {
                  unint64_t v16 = a4;
                  break;
                }
              }
            }
            v16->n128_u32[0] = v14->n128_u32[0];
            v16->n128_u64[1] = v8[1].n128_u64[1];
          }
          unint64_t v10 = v14 + 1;
          v11 += 16;
          uint64_t v12 = v13;
          unsigned __int32 v8 = v14;
        }
        while (&v14[1] != a2);
      }
    }
  }
  return result;
}

char *sub_1CC3296F8(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7)
{
  if (a5)
  {
    while (a4 > a7 && a5 > a7)
    {
      if (!a4) {
        return result;
      }
      uint64_t v9 = 0;
      unsigned int v10 = *(_DWORD *)a2;
      uint64_t v11 = -a4;
      while (1)
      {
        unsigned int v12 = *(_DWORD *)&result[v9];
        if (v10 > v12) {
          break;
        }
        v9 += 16;
        if (__CFADD__(v11++, 1)) {
          return result;
        }
      }
      unint64_t v14 = &result[v9];
      if (-v11 >= a5)
      {
        if (v11 == -1)
        {
          uint64_t v63 = &result[v9];
          *(_DWORD *)uint64_t v63 = v10;
          *(_DWORD *)a2 = v12;
          uint64_t v64 = *(void *)&result[v9 + 8];
          *((void *)v63 + 1) = *((void *)a2 + 1);
          *((void *)a2 + 1) = v64;
          return result;
        }
        if (v11 <= 0) {
          uint64_t v25 = -v11;
        }
        else {
          uint64_t v25 = 1 - v11;
        }
        uint64_t v24 = v25 >> 1;
        unsigned __int32 v18 = &result[16 * (v25 >> 1) + v9];
        uint64_t v17 = a3;
        if (a3 != a2)
        {
          unint64_t v26 = (a3 - a2) >> 4;
          uint64_t v17 = a2;
          do
          {
            unint64_t v27 = v26 >> 1;
            uint64_t v28 = &v17[16 * (v26 >> 1)];
            unsigned int v30 = *(_DWORD *)v28;
            unint64_t v29 = v28 + 16;
            v26 += ~(v26 >> 1);
            if (v30 > *(_DWORD *)v18) {
              uint64_t v17 = v29;
            }
            else {
              unint64_t v26 = v27;
            }
          }
          while (v26);
        }
        uint64_t v16 = (v17 - a2) >> 4;
      }
      else
      {
        if (a5 >= 0) {
          uint64_t v15 = a5;
        }
        else {
          uint64_t v15 = a5 + 1;
        }
        uint64_t v16 = v15 >> 1;
        uint64_t v17 = &a2[16 * (v15 >> 1)];
        unsigned __int32 v18 = a2;
        if (v14 != a2)
        {
          unint64_t v19 = (a2 - result - v9) >> 4;
          unsigned __int32 v18 = &result[v9];
          do
          {
            unint64_t v20 = v19 >> 1;
            __n128 v21 = (unsigned int *)&v18[16 * (v19 >> 1)];
            unsigned int v23 = *v21;
            __n128 v22 = (char *)(v21 + 4);
            v19 += ~(v19 >> 1);
            if (*(_DWORD *)v17 > v23) {
              unint64_t v19 = v20;
            }
            else {
              unsigned __int32 v18 = v22;
            }
          }
          while (v19);
        }
        uint64_t v24 = (v18 - result - v9) >> 4;
      }
      unsigned __int32 v31 = v17;
      if (v18 != a2)
      {
        unsigned __int32 v31 = v18;
        if (a2 != v17)
        {
          int v32 = *(_DWORD *)v18;
          *(_DWORD *)unsigned __int32 v18 = v10;
          *(_DWORD *)a2 = v32;
          uint64_t v33 = *((void *)v18 + 1);
          *((void *)v18 + 1) = *((void *)a2 + 1);
          *((void *)a2 + 1) = v33;
          unsigned __int32 v31 = v18 + 16;
          for (unint64_t i = a2 + 16; i != v17; i += 16)
          {
            if (v31 == a2) {
              a2 = i;
            }
            int v35 = *(_DWORD *)v31;
            *(_DWORD *)unsigned __int32 v31 = *(_DWORD *)i;
            *(_DWORD *)unint64_t i = v35;
            uint64_t v36 = *((void *)v31 + 1);
            *((void *)v31 + 1) = *((void *)i + 1);
            *((void *)i + 1) = v36;
            v31 += 16;
          }
          if (v31 == a2)
          {
            unsigned __int32 v31 = a2;
          }
          else
          {
            uint64_t v37 = v31;
            unint64_t v38 = a2;
            do
            {
              while (1)
              {
                int v39 = *(_DWORD *)v37;
                *(_DWORD *)uint64_t v37 = *(_DWORD *)a2;
                *(_DWORD *)a2 = v39;
                uint64_t v40 = *((void *)v37 + 1);
                *((void *)v37 + 1) = *((void *)a2 + 1);
                *((void *)a2 + 1) = v40;
                v37 += 16;
                a2 += 16;
                if (a2 == v17) {
                  break;
                }
                if (v37 == v38) {
                  unint64_t v38 = a2;
                }
              }
              a2 = v38;
            }
            while (v37 != v38);
          }
        }
      }
      a4 = -(v24 + v11);
      uint64_t v41 = a5 - v16;
      if (v24 + v16 >= a5 - (v24 + v16) - v11)
      {
        uint64_t v46 = v17;
        long long v47 = a6;
        sub_1CC3296F8(v31, v46, a3, a4, a5 - v16, a6, a7);
        a6 = v47;
        uint64_t v17 = v18;
        uint64_t v41 = v16;
        a4 = v24;
        a3 = v31;
      }
      else
      {
        uint64_t v42 = v14;
        uint64_t v43 = a3;
        uint64_t v44 = v16;
        uint64_t v45 = a6;
        sub_1CC3296F8(v42, v18, v31, v24, v44, a6, a7);
        a3 = v43;
        a6 = v45;
        unint64_t v14 = v31;
      }
      a5 = v41;
      BOOL result = v14;
      a2 = v17;
      if (!v41) {
        return result;
      }
    }
    if (a4 <= a5)
    {
      if (result != a2)
      {
        uint64_t v56 = 0;
        do
        {
          *(_OWORD *)&a6[v56] = *(_OWORD *)&result[v56];
          v56 += 16;
        }
        while (&result[v56] != a2);
        if (v56)
        {
          unint64_t v57 = &a6[v56];
          uint64_t v58 = (uint64_t)&a6[v56 - 16];
          while (a2 != a3)
          {
            unsigned int v59 = *(_DWORD *)a2;
            BOOL v60 = *(_DWORD *)a2 > *(_DWORD *)a6;
            if (*(_DWORD *)a2 > *(_DWORD *)a6)
            {
              uint64_t v61 = a2;
            }
            else
            {
              unsigned int v59 = *(_DWORD *)a6;
              uint64_t v61 = a6;
            }
            if (*(_DWORD *)a2 > *(_DWORD *)a6) {
              a2 += 16;
            }
            uint64_t v62 = *((void *)v61 + 1);
            if (!v60) {
              a6 += 16;
            }
            *(_DWORD *)BOOL result = v59;
            *((void *)result + 1) = v62;
            result += 16;
            if (v57 == a6) {
              return result;
            }
          }
          if (v57 != a6)
          {
            uint64_t v67 = 0;
            do
            {
              unint64_t v68 = &result[v67];
              unsigned int v69 = &a6[v67];
              *(_DWORD *)unint64_t v68 = *(_DWORD *)&a6[v67];
              *((void *)v68 + 1) = *(void *)&a6[v67 + 8];
              v67 += 16;
            }
            while ((char *)v58 != v69);
          }
        }
      }
    }
    else if (a2 != a3)
    {
      uint64_t v48 = 0;
      do
      {
        *(_OWORD *)&a6[v48] = *(_OWORD *)&a2[v48];
        v48 += 16;
      }
      while (&a2[v48] != a3);
      if (v48)
      {
        uint64_t v49 = &a6[v48];
        unsigned int v50 = a3 - 8;
        while (a2 != result)
        {
          unsigned int v51 = *((_DWORD *)a2 - 4);
          unsigned int v52 = *((_DWORD *)v49 - 4);
          BOOL v53 = v52 > v51;
          if (v52 > v51)
          {
            BOOL v54 = a2;
          }
          else
          {
            unsigned int v51 = *((_DWORD *)v49 - 4);
            BOOL v54 = v49;
          }
          if (v53) {
            a2 -= 16;
          }
          uint64_t v55 = *((void *)v54 - 1);
          if (!v53) {
            v49 -= 16;
          }
          *((_DWORD *)v50 - 2) = v51;
          *(void *)unsigned int v50 = v55;
          v50 -= 16;
          if (v49 == a6) {
            return result;
          }
        }
        if (v49 != a6)
        {
          unint64_t v65 = 0;
          do
          {
            uint64_t v66 = &v50[v65];
            *((_DWORD *)v66 - 2) = *(_DWORD *)&v49[v65 - 16];
            *(void *)uint64_t v66 = *(void *)&v49[v65 - 8];
            v65 -= 16;
          }
          while (&v49[v65] != a6);
        }
      }
    }
  }
  return result;
}

BOOL sub_1CC329B44(uint64_t a1, char **this, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned char *a7)
{
  uint64_t v113 = *MEMORY[0x1E4F143B8];
  uint64_t v95 = a5;
  *a7 = 0;
  int isSimpleBB = llvm::TailDuplicator::isSimpleBB((llvm::TailDuplicator *)this, (llvm::MachineBasicBlock *)this);
  BOOL v14 = 0;
  if (((this[12] - this[11]) & 0x7FFFFFFF8) == 8) {
    return v14;
  }
  if (!llvm::TailDuplicator::shouldTailDuplicate((llvm::TailDuplicator *)(a1 + 632), isSimpleBB, (llvm::MachineBasicBlock *)this))return 0; {
  char v94 = 0;
  }
  v93[0] = &v94;
  v93[1] = a1;
  v93[2] = a6;
  v93[3] = &v95;
  v92[0] = sub_1CC32A3A8;
  v92[1] = v93;
  uint64_t v104 = v106;
  uint64_t v105 = 0x800000000;
  int v17 = llvm::TailDuplicator::isSimpleBB((llvm::TailDuplicator *)this, v15);
  uint64_t v101 = v103;
  uint64_t v102 = 0x800000000;
  llvm::Function::getEntryCount(**(uint64_t *****)(a1 + 560), 0, (uint64_t)&v110);
  if (!v112[0])
  {
    int v35 = 0;
LABEL_92:
    llvm::TailDuplicator::tailDuplicateAndUpdate(a1 + 632, v17, (uint64_t)this, a3, (uint64_t)&v104, (uint64_t)v92, (uint64_t)v35);
    *a7 = 0;
    if (v105)
    {
      unint64_t v65 = (void **)v104;
      uint64_t v66 = (void **)((char *)v104 + 8 * v105);
      uint64_t v67 = a1 + 920;
      do
      {
        unint64_t v107 = *v65;
        unint64_t v68 = v107;
        unsigned int v69 = sub_1CC3261A0(v67, (uint64_t *)&v107);
        if (v68 == (void *)a3)
        {
          *a7 = 1;
        }
        else
        {
          uint64_t v70 = *v69;
          if (v95)
          {
            if (sub_1CD5297D8(v95, (uint64_t)v68, &v110)) {
              BOOL v76 = v70 == a4;
            }
            else {
              BOOL v76 = 1;
            }
            if (!v76)
            {
LABEL_97:
              unsigned int v72 = (const llvm::MachineBasicBlock ***)*((void *)v68 + 11);
              uint64_t v71 = (const llvm::MachineBasicBlock ***)*((void *)v68 + 12);
              while (v72 != v71)
              {
                unint64_t v73 = *v72;
                v98[0] = *v72;
                if (!v95 || sub_1CD5297D8(v95, (uint64_t)v73, &v110))
                {
                  uint64_t v74 = *sub_1CC3261A0(v67, (uint64_t *)v98);
                  if (v74 != a4 && v74 != v70) {
                    ++*(_DWORD *)(v74 + 56);
                  }
                }
                ++v72;
              }
            }
          }
          else if (v70 != a4)
          {
            goto LABEL_97;
          }
        }
        ++v65;
      }
      while (v65 != v66);
    }
    BOOL v14 = v94 != 0;
    goto LABEL_119;
  }
  int v80 = v17;
  uint64_t v84 = v95;
  long long v97 = (llvm::MachineBasicBlock *)this;
  uint64_t v18 = sub_1CC32A6B8(*(void *)(a1 + 808), (uint64_t)this);
  unint64_t v19 = this[8];
  unint64_t v20 = this[9];
  int v110 = v112;
  uint64_t v111 = 0x800000000;
  unint64_t v21 = v20 - v19;
  unint64_t v79 = v18;
  if ((unint64_t)(v20 - v19) >= 0x41) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v19 != v20)
  {
    __n128 v22 = v110;
    do
    {
      uint64_t v23 = *(void *)v19;
      v19 += 8;
      *v22++ = v23;
    }
    while (v19 != v20);
  }
  LODWORD(v111) = v21 >> 3;
  uint64_t v24 = (char *)*((void *)v97 + 11);
  uint64_t v25 = (char *)*((void *)v97 + 12);
  unint64_t v26 = (const llvm::MachineBasicBlock **)v109;
  unint64_t v107 = v109;
  uint64_t v108 = 0x800000000;
  unint64_t v27 = v25 - v24;
  if ((unint64_t)(v25 - v24) >= 0x41) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v24 != v25)
  {
    uint64_t v28 = v109;
    do
    {
      uint64_t v29 = *(void *)v24;
      v24 += 8;
      *v28++ = v29;
    }
    while (v24 != v25);
    unint64_t v26 = (const llvm::MachineBasicBlock **)v107;
  }
  unint64_t v30 = (v27 >> 3);
  LODWORD(v108) = v30;
  long long v89 = v26;
  uint64_t v85 = &v26[v30];
  v98[0] = (const llvm::MachineBasicBlock **)a1;
  v98[1] = &v97;
  if (v30 < 0x81)
  {
LABEL_19:
    sub_1CC32A768(v89, v85, v98, v30, 0, 0);
  }
  else
  {
    unsigned __int32 v31 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
    unint64_t v32 = (v27 >> 3);
    while (1)
    {
      uint64_t v33 = (const llvm::MachineBasicBlock **)operator new(8 * v32, v31);
      if (v33) {
        break;
      }
      BOOL v34 = v32 > 1;
      v32 >>= 1;
      if (!v34) {
        goto LABEL_19;
      }
    }
    uint64_t v36 = v33;
    sub_1CC32A768(v89, v85, v98, v30, v33, v32);
    operator delete(v36);
  }
  unint64_t v37 = v111;
  uint64_t v90 = (const llvm::MachineBasicBlock **)v110;
  long long v86 = (const llvm::MachineBasicBlock **)&v110[8 * v111];
  v98[0] = (const llvm::MachineBasicBlock **)a1;
  if (v111 < 0x81)
  {
LABEL_26:
    sub_1CC32B298(v90, v86, (uint64_t *)v98, v37, 0, 0);
  }
  else
  {
    unint64_t v38 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
    unint64_t v39 = v111;
    while (1)
    {
      uint64_t v40 = (const llvm::MachineBasicBlock **)operator new(8 * v39, v38);
      if (v40) {
        break;
      }
      BOOL v34 = v39 > 1;
      v39 >>= 1;
      if (!v34) {
        goto LABEL_26;
      }
    }
    uint64_t v41 = v40;
    sub_1CC32B298(v90, v86, (uint64_t *)v98, v37, v40, v39);
    operator delete(v41);
  }
  long long v83 = (const llvm::MachineBasicBlock **)v107;
  if (v108) {
    unsigned int v78 = 0x80000000
  }
        - llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(a1 + 568), v97, *(const llvm::MachineBasicBlock **)v107);
  else {
    unsigned int v78 = 0;
  }
  if (v111)
  {
    unint64_t v87 = 0;
    uint64_t v42 = (llvm::MachineBasicBlock **)v110;
    uint64_t v43 = (llvm::MachineBasicBlock **)&v110[8 * v111];
    uint64_t v82 = a1 + 920;
    long long v77 = v43;
    do
    {
      uint64_t v44 = *v42;
      uint64_t v45 = sub_1CC32A728(*(llvm::MBFIWrapper **)(a1 + 576), *(unsigned char *)(a1 + 816), *v42);
      long long v96 = v45;
      uint64_t v91 = v44;
      if (llvm::TailDuplicator::canTailDuplicate((llvm::TailDuplicator *)(a1 + 632), v97, v44))
      {
        unint64_t v46 = llvm::BlockFrequency::operator*((unint64_t *)&v96, v78);
        if (__CFADD__(v46, v45)) {
          unint64_t v47 = -1;
        }
        else {
          unint64_t v47 = (unint64_t)v45 + v46;
        }
        if (v83 == (const llvm::MachineBasicBlock **)((char *)v107 + 8 * v108))
        {
          if (v108) {
            unsigned int v50 = v45;
          }
          else {
            unsigned int v50 = 0;
          }
        }
        else
        {
          unsigned int EdgeProbability = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(a1 + 568), v97, *v83);
          unint64_t v49 = llvm::BlockFrequency::operator*((unint64_t *)&v96, EdgeProbability);
          unsigned int v50 = (uint64_t *****)((char *)v45 - v49);
          if ((unint64_t)v45 < v49) {
            unsigned int v50 = 0;
          }
        }
        BOOL v58 = v47 >= (unint64_t)v50;
        unint64_t v59 = v47 - (void)v50;
        if (!v58) {
          unint64_t v59 = 0;
        }
        if (v59 <= v79)
        {
          uint64_t v43 = v77;
        }
        else
        {
          uint64_t v43 = v77;
          if (v102 >= (unint64_t)HIDWORD(v102)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v101 + v102) = v44;
          LODWORD(v102) = v102 + 1;
          v83 += v83 != (const llvm::MachineBasicBlock **)((char *)v107 + 8 * v108);
        }
      }
      else if (!v87)
      {
        long long v100 = v44;
        unsigned int v88 = v97;
        if (v97 == v44 || v84 && !sub_1CD5297D8(v84, (uint64_t)v44, v98)) {
          goto LABEL_76;
        }
        uint64_t v51 = *sub_1CC3261A0(v82, (uint64_t *)&v100);
        if (v51)
        {
          if (v44 != *(llvm::MachineBasicBlock **)(*(void *)v51 + 8 * *(unsigned int *)(v51 + 8) - 8)) {
            goto LABEL_76;
          }
        }
        unsigned int v52 = (const llvm::MachineBasicBlock **)*((void *)v44 + 11);
        BOOL v53 = (const llvm::MachineBasicBlock **)*((void *)v44 + 12);
        if (v52 == v53)
        {
          unsigned int v81 = 0;
        }
        else
        {
          unsigned int v81 = 0;
          do
          {
            BOOL v54 = *v52;
            long long v99 = v54;
            if (v54 != v88 && (!v84 || sub_1CD5297D8(v84, (uint64_t)v54, v98)))
            {
              uint64_t v55 = (const llvm::MachineBasicBlock ***)*sub_1CC3261A0(v82, (uint64_t *)&v99);
              if (!v55 || v54 == **v55)
              {
                unsigned int v56 = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(a1 + 568), v91, v54);
                unsigned int v57 = v81;
                if (v56 > v81) {
                  unsigned int v57 = v56;
                }
                unsigned int v81 = v57;
              }
            }
            ++v52;
          }
          while (v52 != v53);
        }
        unsigned int v60 = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(a1 + 568), v91, v88);
        uint64_t v43 = v77;
        if (v60 <= v81
          || ((unsigned int v61 = v60,
               v98[0] = (const llvm::MachineBasicBlock **)sub_1CC32A728(*(llvm::MBFIWrapper **)(a1 + 576), *(unsigned char *)(a1 + 816), v91), v61 >= v81)? (unsigned int v62 = v61 - v81): (unsigned int v62 = 0), v63 = llvm::BlockFrequency::operator*((unint64_t *)v98, v62), v63 <= sub_1CC32A6B8(*(void *)(a1 + 808), (uint64_t)v88)))
        {
LABEL_76:
          unint64_t v87 = 0;
        }
        else
        {
          v83 += v83 != (const llvm::MachineBasicBlock **)((char *)v107 + 8 * v108);
          unint64_t v87 = v91;
        }
      }
      ++v42;
    }
    while (v42 != v43);
    if (!v87)
    {
      int v64 = v102;
      if (v102)
      {
        if (v102 < v111)
        {
          *(void *)uint64_t v101 = *((void *)v101 + v102 - 1);
          LODWORD(v102) = v64 - 1;
        }
      }
    }
  }
  if (v107 != v109) {
    free(v107);
  }
  int v17 = v80;
  if (v110 != v112) {
    free(v110);
  }
  if (v102)
  {
    if (v102 >= (unint64_t)((unint64_t)(this[9] - this[8]) >> 3)) {
      int v35 = 0;
    }
    else {
      int v35 = &v101;
    }
    goto LABEL_92;
  }
  BOOL v14 = 0;
LABEL_119:
  if (v101 != v103) {
    free(v101);
  }
  if (v104 != v106) {
    free(v104);
  }
  return v14;
}

void sub_1CC32A3A8(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = a2;
  uint64_t v4 = *(void *)(a1 + 8);
  BOOL v5 = 1;
  **(unsigned char **)a1 = 1;
  if (sub_1CBB0BF40(*(void *)(v4 + 920), *(_DWORD *)(v4 + 936), a2, &v27))
  {
    uint64_t v6 = sub_1CC3261A0(v4 + 920, &v26);
    uint64_t v7 = *v6;
    BOOL v5 = *(_DWORD *)(*v6 + 56) == 0;
    uint64_t v8 = *(unsigned int *)(*v6 + 8);
    if (v8)
    {
      uint64_t v9 = *(uint64_t **)v7;
      size_t v10 = 8 * v8 - 8;
      uint64_t v11 = *(uint64_t **)v7;
      while (1)
      {
        uint64_t v12 = *v11++;
        if (v12 == a2) {
          break;
        }
        v10 -= 8;
        uint64_t v9 = v11;
        if (v10 == -8) {
          goto LABEL_10;
        }
      }
      if (v10)
      {
        memmove(v9, v9 + 1, v10);
        LODWORD(v8) = *(_DWORD *)(v7 + 8);
      }
      *(_DWORD *)(v7 + 8) = v8 - 1;
    }
LABEL_10:
    unint64_t v27 = 0;
    if (sub_1CBB0BF40(*(void *)(v4 + 920), *(_DWORD *)(v4 + 936), a2, &v27))
    {
      *unint64_t v27 = -8192;
      *(int32x2_t *)(v4 + 928) = vadd_s32(*(int32x2_t *)(v4 + 928), (int32x2_t)0x1FFFFFFFFLL);
    }
  }
  uint64_t v13 = *(void **)(a1 + 16);
  if (*v13 == a2)
  {
    *uint64_t v13 = *(void *)(a2 + 8);
    if (!v5) {
      goto LABEL_37;
    }
  }
  else if (!v5)
  {
    goto LABEL_37;
  }
  BOOL v14 = (void *)(v4 + 248);
  if (*(unsigned char *)(a2 + 184))
  {
    uint64_t v15 = *(unsigned int *)(v4 + 400);
    uint64_t v16 = (_DWORD *)(v4 + 256);
    uint64_t v17 = *(unsigned int *)(v4 + 256);
    if (v17 < v15)
    {
      if (*(_DWORD *)(v4 + 260) < v15)
      {
        *(_DWORD *)(v4 + 256) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v17)
      {
        uint64_t v25 = *(unsigned int *)(v4 + 256);
        memmove(*(void **)(v4 + 248), *(const void **)(v4 + 392), 8 * v17);
        uint64_t v18 = v25;
      }
      else
      {
        uint64_t v18 = 0;
      }
      uint64_t v19 = *(unsigned int *)(v4 + 400);
      if (v18 != v19) {
        memcpy((void *)(*(void *)(v4 + 248) + 8 * v18), (const void *)(*(void *)(v4 + 392) + 8 * v18), 8 * v19 - 8 * v18);
      }
      goto LABEL_23;
    }
    if (v15)
    {
      memmove(*(void **)(v4 + 248), *(const void **)(v4 + 392), 8 * v15);
LABEL_23:
      unint64_t v20 = (void *)*v14;
      uint64_t v21 = *v14 + 8 * v15;
      goto LABEL_25;
    }
    unint64_t v20 = (void *)*v14;
    uint64_t v21 = *v14 + 8 * v15;
    __n128 v22 = (void *)*v14;
    uint64_t v15 = 0;
  }
  else
  {
    uint64_t v16 = (_DWORD *)(v4 + 256);
    uint64_t v15 = *(unsigned int *)(v4 + 256);
    unint64_t v20 = *(void **)(v4 + 248);
    uint64_t v21 = (uint64_t)&v20[v15];
    if (v15)
    {
LABEL_25:
      __n128 v22 = v20;
      do
      {
        if (*v22 == a2) {
          goto LABEL_30;
        }
        ++v22;
      }
      while (v22 != (void *)v21);
      __n128 v22 = (void *)v21;
      goto LABEL_30;
    }
    uint64_t v15 = 0;
    __n128 v22 = *(void **)(v4 + 248);
  }
LABEL_30:
  if (v15 != v22 - v20)
  {
    uint64_t v23 = v22 + 1;
    if (v22 + 1 != (void *)v21)
    {
      do
      {
        if (*v23 != a2) {
          *v22++ = *v23;
        }
        ++v23;
      }
      while (v23 != (void *)v21);
      unint64_t v20 = (void *)*v14;
    }
  }
  *uint64_t v16 = (unint64_t)((char *)v22 - (char *)v20) >> 3;
LABEL_37:
  uint64_t v24 = **(void **)(a1 + 24);
  if (v24) {
    sub_1CD529CAC(v24, &v26);
  }
  llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::removeBlock();
}

uint64_t sub_1CC32A664(_DWORD *a1, uint64_t a2)
{
  BOOL v5 = 0;
  uint64_t result = sub_1CD5297D8((uint64_t)a1, a2, &v5);
  if (result)
  {
    *BOOL v5 = -8192;
    int v4 = a1[1] + 1;
    *a1 -= 2;
    a1[1] = v4;
  }
  return result;
}

uint64_t sub_1CC32A6B8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  if (v2 == a2 + 48)
  {
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = *(void *)(v2 + 16);
      if (*(_WORD *)v4 && *(_WORD *)v4 != 69) {
        v3 += (*(_DWORD *)(v4 + 8) & 0x10) == 0;
      }
      if ((*(unsigned char *)v2 & 4) == 0)
      {
        while ((*(_WORD *)(v2 + 44) & 8) != 0)
          uint64_t v2 = *(void *)(v2 + 8);
      }
      uint64_t v2 = *(void *)(v2 + 8);
    }
    while (v2 != a2 + 48);
  }
  return v3 * a1;
}

uint64_t *****sub_1CC32A728(llvm::MBFIWrapper *a1, char a2, llvm::MachineBasicBlock *a3)
{
  if (a2)
  {
    uint64_t result = llvm::MBFIWrapper::getBlockProfileCount(a1, a3);
    if (!v5) {
      return 0;
    }
  }
  else
  {
    return (uint64_t *****)llvm::MBFIWrapper::getBlockFreq(a1, a3);
  }
  return result;
}

const llvm::MachineBasicBlock **sub_1CC32A768(const llvm::MachineBasicBlock **result, const llvm::MachineBasicBlock **a2, const llvm::MachineBasicBlock ***a3, unint64_t a4, const llvm::MachineBasicBlock **a5, uint64_t a6)
{
  if (a4 >= 2)
  {
    uint64_t v8 = result;
    if (a4 == 2)
    {
      uint64_t v9 = *result;
      size_t v10 = *a3;
      unsigned int EdgeProbability = llvm::MachineBranchProbabilityInfo::getEdgeProbability((*a3)[71], *a3[1], *(a2 - 1));
      uint64_t result = (const llvm::MachineBasicBlock **)llvm::MachineBranchProbabilityInfo::getEdgeProbability(v10[71], *a3[1], v9);
      if (EdgeProbability > result)
      {
        uint64_t v12 = *v8;
        *uint64_t v8 = *(a2 - 1);
        *(a2 - 1) = v12;
      }
    }
    else if ((uint64_t)a4 > 128)
    {
      uint64_t v28 = a5;
      unint64_t v29 = a4 >> 1;
      unint64_t v30 = &result[a4 >> 1];
      unint64_t v31 = a4 >> 1;
      if ((uint64_t)a4 <= a6)
      {
        sub_1CC32AA6C(result, v30, a3, v31, a5);
        unint64_t v32 = &v28[v29];
        uint64_t result = sub_1CC32AA6C(&v8[a4 >> 1], a2, a3, a4 - (a4 >> 1), v32);
        uint64_t v33 = &v28[a4];
        BOOL v34 = v32;
        while (v34 != v33)
        {
          int v35 = v34;
          uint64_t v36 = *v28;
          unint64_t v37 = *a3;
          unsigned int v38 = llvm::MachineBranchProbabilityInfo::getEdgeProbability((*a3)[71], *a3[1], *v34);
          uint64_t result = (const llvm::MachineBasicBlock **)llvm::MachineBranchProbabilityInfo::getEdgeProbability(v37[71], *a3[1], v36);
          if (v38 > result) {
            unint64_t v39 = v35;
          }
          else {
            unint64_t v39 = v28;
          }
          v28 += v38 <= result;
          BOOL v34 = &v35[v38 > result];
          *v8++ = *v39;
          if (v28 == v32)
          {
            if (v34 != v33)
            {
              uint64_t v40 = 0;
              if (v38 > result) {
                char v41 = 1;
              }
              else {
                char v41 = 2;
              }
              uint64_t v42 = &v35[v41 & 1];
              do
              {
                v8[v40] = v42[v40];
                ++v40;
              }
              while (&v42[v40] != v33);
            }
            return result;
          }
        }
        if (v28 != v32)
        {
          uint64_t v43 = 0;
          do
          {
            v8[v43] = v28[v43];
            ++v43;
          }
          while (&v28[v43] != v32);
        }
      }
      else
      {
        sub_1CC32A768(result, v30, a3, v31, a5, a6);
        sub_1CC32A768(&v8[a4 >> 1], a2, a3, a4 - (a4 >> 1), v28, a6);
        return sub_1CC32AD1C(v8, &v8[a4 >> 1], a2, a3, a4 >> 1, a4 - (a4 >> 1), v28, a6);
      }
    }
    else if (result != a2)
    {
      BOOL v14 = result + 1;
      if (result + 1 != a2)
      {
        uint64_t v15 = 0;
        uint64_t v16 = result;
        do
        {
          uint64_t v18 = *v16;
          uint64_t v17 = v16[1];
          uint64_t v16 = v14;
          uint64_t v19 = *a3;
          unsigned int v20 = llvm::MachineBranchProbabilityInfo::getEdgeProbability((*a3)[71], *a3[1], v17);
          uint64_t result = (const llvm::MachineBasicBlock **)llvm::MachineBranchProbabilityInfo::getEdgeProbability(v19[71], *a3[1], v18);
          if (v20 > result)
          {
            uint64_t v21 = *v16;
            uint64_t v22 = v15;
            while (1)
            {
              *(const llvm::MachineBasicBlock **)((char *)v8 + v22 + 8) = *(const llvm::MachineBasicBlock **)((char *)v8 + v22);
              if (!v22) {
                break;
              }
              uint64_t v23 = *(const llvm::MachineBasicBlock **)((char *)v8 + v22 - 8);
              uint64_t v24 = *a3;
              unsigned int v25 = llvm::MachineBranchProbabilityInfo::getEdgeProbability((*a3)[71], *a3[1], v21);
              uint64_t result = (const llvm::MachineBasicBlock **)llvm::MachineBranchProbabilityInfo::getEdgeProbability(v24[71], *a3[1], v23);
              v22 -= 8;
              if (v25 <= result)
              {
                uint64_t v26 = (const llvm::MachineBasicBlock **)((char *)v8 + v22 + 8);
                goto LABEL_15;
              }
            }
            uint64_t v26 = v8;
LABEL_15:
            *uint64_t v26 = v21;
          }
          BOOL v14 = v16 + 1;
          v15 += 8;
        }
        while (v16 + 1 != a2);
      }
    }
  }
  return result;
}

const llvm::MachineBasicBlock **sub_1CC32AA6C(const llvm::MachineBasicBlock **result, const llvm::MachineBasicBlock **a2, const llvm::MachineBasicBlock ***a3, unint64_t a4, const llvm::MachineBasicBlock **a5)
{
  if (a4)
  {
    char v5 = a5;
    uint64_t v7 = result;
    if (a4 == 1)
    {
LABEL_9:
      *char v5 = *v7;
      return result;
    }
    if (a4 == 2)
    {
      size_t v10 = a2 - 1;
      uint64_t v11 = *result;
      uint64_t v12 = *a3;
      unsigned int EdgeProbability = llvm::MachineBranchProbabilityInfo::getEdgeProbability((*a3)[71], *a3[1], *(a2 - 1));
      uint64_t result = (const llvm::MachineBasicBlock **)llvm::MachineBranchProbabilityInfo::getEdgeProbability(v12[71], *a3[1], v11);
      if (EdgeProbability <= result) {
        BOOL v14 = v7;
      }
      else {
        BOOL v14 = v10;
      }
      *v5++ = *v14;
      if (EdgeProbability <= result) {
        uint64_t v7 = v10;
      }
      goto LABEL_9;
    }
    if ((uint64_t)a4 > 8)
    {
      uint64_t v28 = &result[a4 >> 1];
      sub_1CC32A768(result, v28, a3, a4 >> 1, a5, a4 >> 1);
      uint64_t result = (const llvm::MachineBasicBlock **)sub_1CC32A768(&v7[a4 >> 1], a2, a3, a4 - (a4 >> 1), &v5[a4 >> 1], a4 - (a4 >> 1));
      unint64_t v29 = &v7[a4 >> 1];
      while (v29 != a2)
      {
        unint64_t v30 = v29;
        unint64_t v31 = *v7;
        unint64_t v32 = *a3;
        unsigned int v33 = llvm::MachineBranchProbabilityInfo::getEdgeProbability((*a3)[71], *a3[1], *v29);
        uint64_t result = (const llvm::MachineBasicBlock **)llvm::MachineBranchProbabilityInfo::getEdgeProbability(v32[71], *a3[1], v31);
        if (v33 <= result) {
          BOOL v34 = v7;
        }
        else {
          BOOL v34 = v30;
        }
        unint64_t v29 = &v30[v33 > result];
        v7 += v33 <= result;
        *v5++ = *v34;
        if (v7 == v28)
        {
          if (v29 != a2)
          {
            uint64_t v35 = 0;
            uint64_t v36 = &v30[v33 > result];
            do
            {
              v5[v35] = v36[v35];
              ++v35;
            }
            while (&v36[v35] != a2);
          }
          return result;
        }
      }
      if (v7 != v28)
      {
        uint64_t v37 = 0;
        do
        {
          v5[v37] = v7[v37];
          ++v37;
        }
        while (&v7[v37] != v28);
      }
    }
    else if (result != a2)
    {
      uint64_t v15 = result + 1;
      *a5 = *result;
      if (result + 1 != a2)
      {
        uint64_t v16 = 0;
        uint64_t v17 = a5;
        do
        {
          uint64_t v18 = v17;
          uint64_t v19 = *v17++;
          unsigned int v20 = *a3;
          unsigned int v21 = llvm::MachineBranchProbabilityInfo::getEdgeProbability((*a3)[71], *a3[1], *v15);
          uint64_t result = (const llvm::MachineBasicBlock **)llvm::MachineBranchProbabilityInfo::getEdgeProbability(v20[71], *a3[1], v19);
          uint64_t v22 = v17;
          if (v21 > result)
          {
            v18[1] = *v18;
            uint64_t v22 = v5;
            if (v18 != v5)
            {
              uint64_t v23 = v16;
              while (1)
              {
                uint64_t v22 = (const llvm::MachineBasicBlock **)((char *)v5 + v23);
                uint64_t v24 = *(const llvm::MachineBasicBlock **)((char *)v5 + v23 - 8);
                unsigned int v25 = *a3;
                unsigned int v26 = llvm::MachineBranchProbabilityInfo::getEdgeProbability((*a3)[71], *a3[1], *v15);
                uint64_t result = (const llvm::MachineBasicBlock **)llvm::MachineBranchProbabilityInfo::getEdgeProbability(v25[71], *a3[1], v24);
                if (v26 <= result) {
                  break;
                }
                *uint64_t v22 = *(v22 - 1);
                v23 -= 8;
                if (!v23)
                {
                  uint64_t v22 = v5;
                  break;
                }
              }
            }
          }
          unint64_t v27 = *v15++;
          *uint64_t v22 = v27;
          v16 += 8;
        }
        while (v15 != a2);
      }
    }
  }
  return result;
}

const llvm::MachineBasicBlock **sub_1CC32AD1C(const llvm::MachineBasicBlock **result, const llvm::MachineBasicBlock **a2, const llvm::MachineBasicBlock **a3, const llvm::MachineBasicBlock ***a4, uint64_t a5, uint64_t a6, const llvm::MachineBasicBlock **a7, uint64_t a8)
{
  uint64_t v90 = a6;
  if (!a6) {
    return result;
  }
  uint64_t v11 = a4;
  BOOL v14 = result;
  while (a5 > a8 && v90 > a8)
  {
    if (!a5) {
      return result;
    }
    while (1)
    {
      uint64_t v15 = *v14;
      uint64_t v16 = *v11;
      unsigned int EdgeProbability = llvm::MachineBranchProbabilityInfo::getEdgeProbability((*v11)[71], *v11[1], *a2);
      uint64_t result = (const llvm::MachineBasicBlock **)llvm::MachineBranchProbabilityInfo::getEdgeProbability(v16[71], *v11[1], v15);
      if (EdgeProbability > result) {
        break;
      }
      ++v14;
      if (!--a5) {
        return result;
      }
    }
    uint64_t v18 = v90;
    if (a5 >= v90)
    {
      if (a5 == 1)
      {
        unint64_t v79 = *v14;
        *BOOL v14 = *a2;
        *a2 = v79;
        return result;
      }
      uint64_t v85 = a8;
      if (a5 >= 0) {
        uint64_t v37 = a5;
      }
      else {
        uint64_t v37 = a5 + 1;
      }
      uint64_t v38 = v37 >> 1;
      unint64_t v39 = a2;
      unint64_t v81 = v38;
      long long v83 = a3;
      a2 = &v14[v38];
      unsigned int v21 = a3;
      unsigned int v88 = v39;
      uint64_t v40 = (char *)a3 - (char *)v39;
      if (v40)
      {
        unint64_t v41 = v40 >> 3;
        unsigned int v21 = v88;
        uint64_t v91 = *a4;
        BOOL v93 = a4[1];
        do
        {
          uint64_t v42 = &v21[v41 >> 1];
          uint64_t v44 = *v42;
          uint64_t v43 = v42 + 1;
          uint64_t v45 = *a2;
          unsigned int v46 = llvm::MachineBranchProbabilityInfo::getEdgeProbability(v91[71], *v93, v44);
          unsigned int v47 = llvm::MachineBranchProbabilityInfo::getEdgeProbability(v91[71], *v93, v45);
          if (v46 <= v47) {
            v41 >>= 1;
          }
          else {
            v41 += ~(v41 >> 1);
          }
          if (v46 > v47) {
            unsigned int v21 = v43;
          }
        }
        while (v41);
      }
      uint64_t v36 = v88;
      uint64_t v20 = v21 - v88;
      unint64_t v22 = v81;
    }
    else
    {
      if (v90 >= 0) {
        uint64_t v19 = v90;
      }
      else {
        uint64_t v19 = v90 + 1;
      }
      uint64_t v20 = v19 >> 1;
      unsigned int v21 = &a2[v19 >> 1];
      unint64_t v22 = a2 - v14;
      if (a2 == v14)
      {
        BOOL v14 = a2;
        uint64_t v48 = &a2[v19 >> 1];
        goto LABEL_50;
      }
      uint64_t v92 = v19 >> 1;
      uint64_t v85 = a8;
      long long v86 = a7;
      unint64_t v87 = a2;
      long long v83 = a3;
      uint64_t v84 = v14;
      a2 = v14;
      uint64_t v23 = v11;
      do
      {
        unint64_t v24 = v22 >> 1;
        unsigned int v25 = &a2[v22 >> 1];
        unsigned int v26 = *v21;
        uint64_t v28 = *v25;
        unint64_t v27 = v25 + 1;
        unint64_t v29 = *v23;
        unint64_t v30 = a2;
        unint64_t v31 = v21;
        unint64_t v32 = v22;
        unsigned int v33 = llvm::MachineBranchProbabilityInfo::getEdgeProbability((*v23)[71], *v23[1], v26);
        unsigned int v34 = llvm::MachineBranchProbabilityInfo::getEdgeProbability(v29[71], *v23[1], v28);
        unint64_t v35 = v32 + ~(v32 >> 1);
        unsigned int v21 = v31;
        if (v33 <= v34) {
          a2 = v27;
        }
        else {
          a2 = v30;
        }
        if (v33 <= v34) {
          unint64_t v22 = v35;
        }
        else {
          unint64_t v22 = v24;
        }
      }
      while (v22);
      BOOL v14 = v84;
      unint64_t v22 = a2 - v84;
      a7 = v86;
      uint64_t v36 = v87;
      uint64_t v20 = v92;
    }
    uint64_t v11 = a4;
    uint64_t v18 = v90;
    a8 = v85;
    if (a2 == v36)
    {
      a2 = v36;
      uint64_t v48 = v21;
    }
    else if (v36 == v21)
    {
      unsigned int v21 = v36;
      uint64_t v48 = a2;
    }
    else
    {
      if (a2 + 1 != v36)
      {
        uint64_t v94 = v20;
        unint64_t v82 = v22;
        if (v36 + 1 == v21)
        {
          BOOL v53 = *(v21 - 1);
          uint64_t v48 = a2 + 1;
          a3 = v83;
          if (v21 - 1 != a2) {
            memmove(a2 + 1, a2, (char *)(v21 - 1) - (char *)a2);
          }
          *a2 = v53;
          uint64_t v11 = a4;
        }
        else
        {
          uint64_t v48 = (const llvm::MachineBasicBlock **)sub_1CC057214(a2, v36, v21);
          a3 = v83;
        }
        unint64_t v22 = v82;
        uint64_t v20 = v94;
        goto LABEL_50;
      }
      unint64_t v49 = *a2;
      int64_t v50 = (char *)v21 - (char *)v36;
      unint64_t v51 = v22;
      uint64_t v52 = v20;
      memmove(a2, v36, (char *)v21 - (char *)v36);
      uint64_t v20 = v52;
      unint64_t v22 = v51;
      uint64_t v48 = (const llvm::MachineBasicBlock **)((char *)a2 + v50);
      *(const llvm::MachineBasicBlock **)((char *)a2 + v50) = v49;
      uint64_t v11 = a4;
      uint64_t v18 = v90;
    }
    a3 = v83;
LABEL_50:
    a5 -= v22;
    uint64_t v54 = v18 - v20;
    if ((uint64_t)(v20 + v22) >= v54 + a5)
    {
      uint64_t v55 = a3;
      unint64_t v56 = v22;
      uint64_t v57 = a5;
      uint64_t v58 = v20;
      uint64_t result = (const llvm::MachineBasicBlock **)sub_1CC32AD1C(v48, v21, v55, v11, v57, v54, a7, a8);
      unsigned int v21 = a2;
      uint64_t v54 = v58;
      a5 = v56;
      a3 = v48;
    }
    else
    {
      uint64_t result = (const llvm::MachineBasicBlock **)sub_1CC32AD1C(v14, a2, v48, v11, v22, v20, a7, a8);
      BOOL v14 = v48;
    }
    a2 = v21;
    uint64_t v90 = v54;
    if (!v54) {
      return result;
    }
  }
  if (a5 <= v90)
  {
    if (v14 != a2)
    {
      uint64_t v67 = 0;
      do
      {
        a7[v67] = v14[v67];
        ++v67;
      }
      while (&v14[v67] != a2);
      if (v67 * 8)
      {
        unint64_t v68 = a7;
        while (a2 != a3)
        {
          unsigned int v69 = *v68;
          uint64_t v70 = *v11;
          unsigned int v71 = llvm::MachineBranchProbabilityInfo::getEdgeProbability((*v11)[71], *v11[1], *a2);
          unsigned int v72 = a2;
          unint64_t v73 = a3;
          unsigned int v74 = v71;
          uint64_t result = (const llvm::MachineBasicBlock **)llvm::MachineBranchProbabilityInfo::getEdgeProbability(v70[71], *v11[1], v69);
          BOOL v75 = v74 > result;
          a3 = v73;
          unsigned int v76 = v75;
          unsigned int v77 = !v75;
          if (v75) {
            unsigned int v78 = v72;
          }
          else {
            unsigned int v78 = v68;
          }
          v68 += v77;
          a2 = &v72[v76];
          *v14++ = *v78;
          if (&a7[v67] == v68) {
            return result;
          }
        }
        return (const llvm::MachineBasicBlock **)memmove(v14, v68, (char *)a7 - (char *)v68 + v67 * 8);
      }
    }
  }
  else if (a2 != a3)
  {
    uint64_t v59 = 0;
    do
    {
      a7[v59] = a2[v59];
      ++v59;
    }
    while (&a2[v59] != a3);
    if (v59 * 8)
    {
      unsigned int v60 = a3;
      unsigned int v61 = &a7[v59];
      unsigned int v62 = v60 - 1;
      while (a2 != v14)
      {
        unint64_t v63 = *(a2 - 1);
        int v64 = *a4;
        unsigned int v65 = llvm::MachineBranchProbabilityInfo::getEdgeProbability((*a4)[71], *a4[1], *(v61 - 1));
        uint64_t result = (const llvm::MachineBasicBlock **)llvm::MachineBranchProbabilityInfo::getEdgeProbability(v64[71], *a4[1], v63);
        if (v65 <= result) {
          uint64_t v66 = v61;
        }
        else {
          uint64_t v66 = a2;
        }
        if (v65 <= result) {
          --v61;
        }
        else {
          --a2;
        }
        *v62-- = *(v66 - 1);
        if (v61 == a7) {
          return result;
        }
      }
      if (v61 != a7)
      {
        uint64_t v80 = 0;
        do
        {
          v62[v80] = v61[v80 - 1];
          --v80;
        }
        while (&v61[v80] != a7);
      }
    }
  }
  return result;
}

const llvm::MachineBasicBlock **sub_1CC32B298(const llvm::MachineBasicBlock **result, const llvm::MachineBasicBlock **a2, uint64_t *a3, unint64_t a4, const llvm::MachineBasicBlock **a5, uint64_t a6)
{
  if (a4 >= 2)
  {
    uint64_t v8 = result;
    if (a4 == 2)
    {
      uint64_t v40 = *result;
      uint64_t v41 = *a3;
      unint64_t BlockFreq = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(*a3 + 576), *(a2 - 1));
      uint64_t result = (const llvm::MachineBasicBlock **)llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v41 + 576), v40);
      if (BlockFreq > (unint64_t)result)
      {
        uint64_t v43 = *v8;
        *uint64_t v8 = *(a2 - 1);
        *(a2 - 1) = v43;
      }
    }
    else if ((uint64_t)a4 > 128)
    {
      unint64_t v24 = a5;
      unint64_t v25 = a4 >> 1;
      unsigned int v26 = &result[a4 >> 1];
      unint64_t v27 = a4 >> 1;
      if ((uint64_t)a4 <= a6)
      {
        sub_1CC32B570(result, v26, a3, v27, a5);
        uint64_t v28 = &v24[v25];
        uint64_t result = sub_1CC32B570(&v8[a4 >> 1], a2, a3, a4 - (a4 >> 1), v28);
        unint64_t v29 = &v24[a4];
        unint64_t v30 = v28;
        while (v30 != v29)
        {
          unint64_t v31 = v30;
          unint64_t v32 = *v24;
          uint64_t v33 = *a3;
          unint64_t v34 = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(*a3 + 576), *v30);
          uint64_t result = (const llvm::MachineBasicBlock **)llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v33 + 576), v32);
          if (v34 > (unint64_t)result) {
            unint64_t v35 = v31;
          }
          else {
            unint64_t v35 = v24;
          }
          v24 += v34 <= (unint64_t)result;
          unint64_t v30 = &v31[v34 > (unint64_t)result];
          *v8++ = *v35;
          if (v24 == v28)
          {
            if (v30 != v29)
            {
              uint64_t v36 = 0;
              if (v34 > (unint64_t)result) {
                char v37 = 1;
              }
              else {
                char v37 = 2;
              }
              uint64_t v38 = &v31[v37 & 1];
              do
              {
                v8[v36] = v38[v36];
                ++v36;
              }
              while (&v38[v36] != v29);
            }
            return result;
          }
        }
        if (v24 != v28)
        {
          uint64_t v39 = 0;
          do
          {
            v8[v39] = v24[v39];
            ++v39;
          }
          while (&v24[v39] != v28);
        }
      }
      else
      {
        sub_1CC32B298(result, v26, a3, v27, a5, a6);
        sub_1CC32B298(&v8[a4 >> 1], a2, a3, a4 - (a4 >> 1), v24, a6);
        return sub_1CC32B7F0(v8, &v8[a4 >> 1], a2, a3, a4 >> 1, a4 - (a4 >> 1), v24, a6);
      }
    }
    else if (result != a2)
    {
      size_t v10 = result + 1;
      if (result + 1 != a2)
      {
        uint64_t v11 = 0;
        uint64_t v12 = result;
        do
        {
          BOOL v14 = *v12;
          uint64_t v13 = v12[1];
          uint64_t v12 = v10;
          uint64_t v15 = *a3;
          unint64_t v16 = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(*a3 + 576), v13);
          uint64_t result = (const llvm::MachineBasicBlock **)llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v15 + 576), v14);
          if (v16 > (unint64_t)result)
          {
            uint64_t v17 = *v12;
            uint64_t v18 = v11;
            while (1)
            {
              *(const llvm::MachineBasicBlock **)((char *)v8 + v18 + 8) = *(const llvm::MachineBasicBlock **)((char *)v8 + v18);
              if (!v18) {
                break;
              }
              uint64_t v19 = *(const llvm::MachineBasicBlock **)((char *)v8 + v18 - 8);
              uint64_t v20 = *a3;
              unint64_t v21 = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(*a3 + 576), v17);
              uint64_t result = (const llvm::MachineBasicBlock **)llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v20 + 576), v19);
              v18 -= 8;
              if (v21 <= (unint64_t)result)
              {
                unint64_t v22 = (const llvm::MachineBasicBlock **)((char *)v8 + v18 + 8);
                goto LABEL_14;
              }
            }
            unint64_t v22 = v8;
LABEL_14:
            *unint64_t v22 = v17;
          }
          size_t v10 = v12 + 1;
          v11 += 8;
        }
        while (v12 + 1 != a2);
      }
    }
  }
  return result;
}

const llvm::MachineBasicBlock **sub_1CC32B570(const llvm::MachineBasicBlock **result, const llvm::MachineBasicBlock **a2, uint64_t *a3, unint64_t a4, const llvm::MachineBasicBlock **a5)
{
  if (!a4) {
    return result;
  }
  char v5 = a5;
  uint64_t v7 = result;
  if (a4 == 1)
  {
LABEL_36:
    *char v5 = *v7;
    return result;
  }
  if (a4 == 2)
  {
    uint64_t v33 = a2 - 1;
    unint64_t v34 = *result;
    uint64_t v35 = *a3;
    unint64_t BlockFreq = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(*a3 + 576), *(a2 - 1));
    uint64_t result = (const llvm::MachineBasicBlock **)llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v35 + 576), v34);
    if (BlockFreq <= (unint64_t)result) {
      char v37 = v7;
    }
    else {
      char v37 = v33;
    }
    *v5++ = *v37;
    if (BlockFreq <= (unint64_t)result) {
      uint64_t v7 = v33;
    }
    goto LABEL_36;
  }
  if ((uint64_t)a4 > 8)
  {
    uint64_t v23 = &result[a4 >> 1];
    sub_1CC32B298(result, v23, a3, a4 >> 1, a5, a4 >> 1);
    uint64_t result = (const llvm::MachineBasicBlock **)sub_1CC32B298(&v7[a4 >> 1], a2, a3, a4 - (a4 >> 1), &v5[a4 >> 1], a4 - (a4 >> 1));
    unint64_t v24 = &v7[a4 >> 1];
    while (v24 != a2)
    {
      unint64_t v25 = v24;
      unsigned int v26 = *v7;
      uint64_t v27 = *a3;
      unint64_t v28 = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(*a3 + 576), *v24);
      uint64_t result = (const llvm::MachineBasicBlock **)llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v27 + 576), v26);
      if (v28 <= (unint64_t)result) {
        unint64_t v29 = v7;
      }
      else {
        unint64_t v29 = v25;
      }
      unint64_t v24 = &v25[v28 > (unint64_t)result];
      v7 += v28 <= (unint64_t)result;
      *v5++ = *v29;
      if (v7 == v23)
      {
        if (v24 != a2)
        {
          uint64_t v30 = 0;
          unint64_t v31 = &v25[v28 > (unint64_t)result];
          do
          {
            v5[v30] = v31[v30];
            ++v30;
          }
          while (&v31[v30] != a2);
        }
        return result;
      }
    }
    if (v7 != v23)
    {
      uint64_t v32 = 0;
      do
      {
        v5[v32] = v7[v32];
        ++v32;
      }
      while (&v7[v32] != v23);
    }
  }
  else if (result != a2)
  {
    size_t v10 = result + 1;
    *a5 = *result;
    if (result + 1 != a2)
    {
      uint64_t v11 = 0;
      uint64_t v12 = a5;
      do
      {
        uint64_t v13 = v12;
        BOOL v14 = *v12++;
        uint64_t v15 = *a3;
        unint64_t v16 = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(*a3 + 576), *v10);
        uint64_t result = (const llvm::MachineBasicBlock **)llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v15 + 576), v14);
        uint64_t v17 = v12;
        if (v16 > (unint64_t)result)
        {
          v13[1] = *v13;
          uint64_t v17 = v5;
          if (v13 != v5)
          {
            uint64_t v38 = v12;
            uint64_t v18 = v11;
            while (1)
            {
              uint64_t v17 = (const llvm::MachineBasicBlock **)((char *)v5 + v18);
              uint64_t v19 = *(const llvm::MachineBasicBlock **)((char *)v5 + v18 - 8);
              uint64_t v20 = *a3;
              unint64_t v21 = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(*a3 + 576), *v10);
              uint64_t result = (const llvm::MachineBasicBlock **)llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v20 + 576), v19);
              if (v21 <= (unint64_t)result) {
                break;
              }
              const llvm::MachineBasicBlock *v17 = *(v17 - 1);
              v18 -= 8;
              if (!v18)
              {
                uint64_t v17 = v5;
                break;
              }
            }
            uint64_t v12 = v38;
          }
        }
        unint64_t v22 = *v10++;
        const llvm::MachineBasicBlock *v17 = v22;
        v11 += 8;
      }
      while (v10 != a2);
    }
  }
  return result;
}

const llvm::MachineBasicBlock **sub_1CC32B7F0(const llvm::MachineBasicBlock **result, const llvm::MachineBasicBlock **a2, const llvm::MachineBasicBlock **a3, uint64_t *a4, uint64_t a5, uint64_t a6, const llvm::MachineBasicBlock **a7, uint64_t a8)
{
  if (!a6) {
    return result;
  }
  uint64_t v10 = a6;
  BOOL v14 = result;
  while (a5 > a8 && v10 > a8)
  {
    if (!a5) {
      return result;
    }
    while (1)
    {
      uint64_t v15 = *v14;
      uint64_t v16 = *a4;
      unint64_t BlockFreq = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(*a4 + 576), *a2);
      uint64_t result = (const llvm::MachineBasicBlock **)llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v16 + 576), v15);
      if (BlockFreq > (unint64_t)result) {
        break;
      }
      ++v14;
      if (!--a5) {
        return result;
      }
    }
    if (a5 >= v10)
    {
      if (a5 == 1)
      {
        unsigned int v61 = *v14;
        *BOOL v14 = *a2;
        *a2 = v61;
        return result;
      }
      if (a5 >= 0) {
        uint64_t v29 = a5;
      }
      else {
        uint64_t v29 = a5 + 1;
      }
      uint64_t v64 = v29 >> 1;
      uint64_t v67 = a7;
      unint64_t v22 = &v14[v29 >> 1];
      uint64_t v20 = a3;
      if (a3 != a2)
      {
        unint64_t v30 = a3 - a2;
        uint64_t v62 = *a4;
        uint64_t v20 = a2;
        unsigned int v69 = &v14[v29 >> 1];
        do
        {
          unint64_t v31 = &v20[v30 >> 1];
          uint64_t v33 = *v31;
          uint64_t v32 = v31 + 1;
          unsigned int v72 = *v22;
          unsigned int v71 = (llvm::MachineBasicBlock *)llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v62 + 576), v33);
          unint64_t v34 = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v62 + 576), v72);
          unint64_t v22 = v69;
          if ((unint64_t)v71 <= v34) {
            v30 >>= 1;
          }
          else {
            v30 += ~(v30 >> 1);
          }
          if ((unint64_t)v71 > v34) {
            uint64_t v20 = v32;
          }
        }
        while (v30);
      }
      uint64_t v19 = v20 - a2;
      unint64_t v21 = v64;
    }
    else
    {
      if (v10 >= 0) {
        uint64_t v18 = v10;
      }
      else {
        uint64_t v18 = v10 + 1;
      }
      uint64_t v19 = v18 >> 1;
      uint64_t v20 = &a2[v18 >> 1];
      unint64_t v21 = a2 - v14;
      if (a2 == v14)
      {
        BOOL v14 = a2;
        goto LABEL_42;
      }
      uint64_t v63 = v18 >> 1;
      uint64_t v67 = a7;
      unint64_t v22 = v14;
      unint64_t v73 = &a2[v18 >> 1];
      do
      {
        uint64_t v23 = &v22[v21 >> 1];
        unint64_t v25 = *v23;
        unint64_t v24 = v23 + 1;
        uint64_t v26 = *a4;
        uint64_t v27 = v22;
        unint64_t v68 = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(*a4 + 576), *v73);
        unint64_t v28 = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v26 + 576), v25);
        if (v68 <= v28) {
          unint64_t v22 = v24;
        }
        else {
          unint64_t v22 = v27;
        }
        if (v68 <= v28) {
          v21 += ~(v21 >> 1);
        }
        else {
          v21 >>= 1;
        }
      }
      while (v21);
      unint64_t v21 = v22 - v14;
      uint64_t v20 = v73;
      uint64_t v19 = v63;
    }
    a7 = v67;
    if (v22 != a2)
    {
      if (a2 == v20)
      {
        uint64_t v20 = a2;
        uint64_t v38 = v22;
      }
      else if (v22 + 1 == a2)
      {
        unint64_t v65 = v21;
        unsigned int v74 = *v22;
        uint64_t v39 = v19;
        int64_t v40 = (char *)v20 - (char *)a2;
        uint64_t v41 = a2;
        size_t v42 = (char *)v20 - (char *)a2;
        uint64_t v43 = v22;
        memmove(v22, v41, v42);
        unint64_t v22 = v43;
        uint64_t v38 = (const llvm::MachineBasicBlock **)((char *)v43 + v40);
        uint64_t v19 = v39;
        const std::nothrow_t *v38 = v74;
        unint64_t v21 = v65;
      }
      else if (a2 + 1 == v20)
      {
        uint64_t v66 = v19;
        uint64_t v44 = *(v20 - 1);
        uint64_t v38 = v22 + 1;
        if (v20 - 1 != v22)
        {
          uint64_t v70 = v22;
          memmove(v22 + 1, v22, (char *)(v20 - 1) - (char *)v22);
          unint64_t v22 = v70;
        }
        *unint64_t v22 = v44;
        uint64_t v19 = v66;
      }
      else
      {
        uint64_t v35 = a2;
        uint64_t v36 = v22;
        char v37 = (const llvm::MachineBasicBlock **)sub_1CC057214(v22, v35, v20);
        unint64_t v22 = v36;
        uint64_t v38 = v37;
      }
      goto LABEL_48;
    }
LABEL_42:
    unint64_t v22 = a2;
    uint64_t v38 = v20;
LABEL_48:
    a5 -= v21;
    v10 -= v19;
    if ((uint64_t)(v19 + v21) >= v10 + a5)
    {
      uint64_t v45 = v20;
      uint64_t v20 = v22;
      uint64_t result = (const llvm::MachineBasicBlock **)sub_1CC32B7F0(v38, v45, a3, a4, a5, v10, a7, a8);
      uint64_t v10 = v19;
      a5 = v21;
      a3 = v38;
    }
    else
    {
      uint64_t result = (const llvm::MachineBasicBlock **)sub_1CC32B7F0(v14, v22, v38, a4, v21, v19, a7, a8);
      BOOL v14 = v38;
    }
    a2 = v20;
    if (!v10) {
      return result;
    }
  }
  if (a5 <= v10)
  {
    if (v14 != a2)
    {
      uint64_t v54 = 0;
      do
      {
        a7[v54] = v14[v54];
        ++v54;
      }
      while (&v14[v54] != a2);
      if (v54 * 8)
      {
        uint64_t v55 = a7;
        while (a2 != a3)
        {
          unint64_t v56 = *v55;
          uint64_t v57 = *a4;
          unint64_t v58 = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(*a4 + 576), *a2);
          uint64_t result = (const llvm::MachineBasicBlock **)llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(v57 + 576), v56);
          if (v58 > (unint64_t)result) {
            uint64_t v59 = a2;
          }
          else {
            uint64_t v59 = v55;
          }
          v55 += v58 <= (unint64_t)result;
          a2 += v58 > (unint64_t)result;
          *v14++ = *v59;
          if (&a7[v54] == v55) {
            return result;
          }
        }
        return (const llvm::MachineBasicBlock **)memmove(v14, v55, (char *)a7 - (char *)v55 + v54 * 8);
      }
    }
  }
  else if (a2 != a3)
  {
    uint64_t v46 = 0;
    do
    {
      a7[v46] = a2[v46];
      ++v46;
    }
    while (&a2[v46] != a3);
    if (v46 * 8)
    {
      unsigned int v47 = &a7[v46];
      uint64_t v48 = a3 - 1;
      while (a2 != v14)
      {
        unsigned int v76 = *(a2 - 1);
        unint64_t v49 = a7;
        uint64_t v50 = *a4;
        unint64_t v51 = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(*a4 + 576), *(v47 - 1));
        uint64_t v52 = *(llvm::MBFIWrapper **)(v50 + 576);
        a7 = v49;
        uint64_t result = (const llvm::MachineBasicBlock **)llvm::MBFIWrapper::getBlockFreq(v52, v76);
        if (v51 <= (unint64_t)result) {
          BOOL v53 = v47;
        }
        else {
          BOOL v53 = a2;
        }
        if (v51 <= (unint64_t)result) {
          --v47;
        }
        else {
          --a2;
        }
        *v48-- = *(v53 - 1);
        if (v47 == v49) {
          return result;
        }
      }
      if (v47 != a7)
      {
        uint64_t v60 = 0;
        do
        {
          v48[v60] = v47[v60 - 1];
          --v60;
        }
        while (&v47[v60] != a7);
      }
    }
  }
  return result;
}

uint64_t *sub_1CC32BD08(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = (void *)*result;
  if ((uint64_t *)*result != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (uint64_t *)result[1];
    if ((uint64_t *)v4[1] != result)
    {
      if (v4 == result)
      {
        unint64_t v21 = &v21;
        unint64_t v22 = (uint64_t *)&v21;
        BOOL v8 = &v21 == (void **)result;
      }
      else
      {
        uint64_t v6 = (uint64_t *)result[1];
        do
        {
          uint64_t v7 = (uint64_t *)v6[1];
          if (v7 == result) {
            break;
          }
          uint64_t v4 = (uint64_t *)v4[1];
          uint64_t v6 = (uint64_t *)v7[1];
        }
        while (v6 != result);
        unint64_t v21 = &v21;
        unint64_t v22 = (uint64_t *)&v21;
        BOOL v8 = &v21 == (void **)result;
        if (&v21 != (void **)result && v4 != result)
        {
          BOOL v8 = 0;
          uint64_t v9 = (void *)*v4;
          v9[1] = result;
          *uint64_t result = (uint64_t)v9;
          v2[1] = &v21;
          *uint64_t v4 = (uint64_t)&v21;
          unint64_t v21 = v2;
          unint64_t v22 = v4;
        }
      }
      sub_1CC32BD08(result, a2);
      uint64_t result = (uint64_t *)sub_1CC32BD08(&v21, a2);
      if (!v8 && v21 != &v21)
      {
        uint64_t v10 = v22;
        uint64_t v11 = (uint64_t *)v3[1];
        if (v11 != v3)
        {
          while (1)
          {
            unint64_t v24 = v10;
            unint64_t v12 = sub_1CD4D7004(a2, &v24)[1];
            uint64_t v23 = v11;
            uint64_t result = sub_1CD4D7004(a2, &v23);
            if (v12 >= result[1])
            {
              BOOL v14 = v10;
            }
            else
            {
              uint64_t v13 = v10;
              do
              {
                uint64_t v13 = (uint64_t *)v13[1];
                BOOL v14 = (uint64_t *)&v21;
                if (v13 == (uint64_t *)&v21) {
                  break;
                }
                unint64_t v24 = v13;
                unint64_t v15 = sub_1CD4D7004(a2, &v24)[1];
                uint64_t v23 = v11;
                uint64_t result = sub_1CD4D7004(a2, &v23);
                BOOL v14 = v13;
              }
              while (v15 < result[1]);
              if (v11 != v14 && v10 != v14)
              {
                uint64_t v16 = *v14;
                uint64_t v17 = *v10;
                *(void *)(v17 + 8) = v14;
                *BOOL v14 = v17;
                uint64_t v18 = *v11;
                *(void *)(v16 + 8) = v11;
                *uint64_t v10 = v18;
                *(void *)(v18 + 8) = v10;
                *uint64_t v11 = v16;
              }
              if (v13 == (uint64_t *)&v21) {
                return result;
              }
            }
            uint64_t v11 = (uint64_t *)v11[1];
            uint64_t v10 = v14;
            if (v11 == v3) {
              goto LABEL_27;
            }
          }
        }
        BOOL v14 = v22;
LABEL_27:
        if (v14 != (uint64_t *)&v21)
        {
          uint64_t v19 = v21;
          *(void *)(*v14 + 8) = &v21;
          uint64_t v20 = *v3;
          v19[1] = v3;
          *BOOL v14 = v20;
          *(void *)(v20 + 8) = v14;
          uint64_t *v3 = (uint64_t)v19;
        }
      }
    }
  }
  return result;
}

void sub_1CC32BF24()
{
}

void sub_1CC32C038(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F260E110;
  long long v1 = (void *)*((void *)a1 + 22);
  if (v1 != (void *)((char *)a1 + 192))
  {
    uint64_t v4 = a1;
    free(v1);
    a1 = v4;
  }
  uint64_t v2 = (void *)*((void *)a1 + 13);
  if (v2 != (void *)((char *)a1 + 120))
  {
    char v5 = a1;
    free(v2);
    a1 = v5;
  }
  uint64_t v3 = (void *)*((void *)a1 + 4);
  if (v3 != (void *)((char *)a1 + 48))
  {
    uint64_t v6 = a1;
    free(v3);
    a1 = v6;
  }

  llvm::Pass::~Pass(a1);
}

void sub_1CC32C0EC(llvm::Pass *this)
{
  *(void *)this = &unk_1F260E110;
  uint64_t v2 = (char *)*((void *)this + 22);
  if (v2 != (char *)this + 192) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 13);
  if (v3 != (char *)this + 120) {
    free(v3);
  }
  uint64_t v4 = (char *)*((void *)this + 4);
  if (v4 != (char *)this + 48) {
    free(v4);
  }
  llvm::Pass::~Pass(this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC32C198(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineBranchProbabilityInfo::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineBlockFrequencyInfo::ID);
  *(unsigned char *)(a2 + 160) = 1;

  llvm::MachineFunctionPass::getAnalysisUsage(a1, a2);
}

uint64_t sub_1CC32C200(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (const llvm::MachineBasicBlock *)(a2 + 320);
  if (*(void *)(*(void *)(a2 + 328) + 8) != a2 + 320)
  {
    char v5 = *(uint64_t **)(a1 + 8);
    uint64_t v6 = *v5;
    uint64_t v7 = v5[1];
    if (v6 == v7)
    {
LABEL_5:
      uint64_t v8 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v6 != &llvm::MachineBranchProbabilityInfo::ID)
      {
        v6 += 16;
        if (v6 == v7) {
          goto LABEL_5;
        }
      }
      uint64_t v8 = *(void *)(v6 + 8);
    }
    *(void *)(a1 + 248) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v8 + 96))(v8, &llvm::MachineBranchProbabilityInfo::ID);
    uint64_t v9 = *(uint64_t **)(a1 + 8);
    uint64_t v10 = *v9;
    uint64_t v11 = v9[1];
    if (v10 == v11)
    {
LABEL_10:
      uint64_t v12 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v10 != &llvm::MachineBlockFrequencyInfo::ID)
      {
        v10 += 16;
        if (v10 == v11) {
          goto LABEL_10;
        }
      }
      uint64_t v12 = *(void *)(v10 + 8);
    }
    *(void *)(a1 + 256) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v12 + 96))(v12, &llvm::MachineBlockFrequencyInfo::ID);
    for (unint64_t i = *(const llvm::MachineBasicBlock **)(a2 + 328);
          i != v2;
          unint64_t i = (const llvm::MachineBasicBlock *)*((void *)i + 1))
    {
      unint64_t v14 = *(void *)(*(void *)(a1 + 256) + 248);
      if (!v14) {
        goto LABEL_18;
      }
      int v15 = *(_DWORD *)(v14 + 176);
      if (v15)
      {
        uint64_t v16 = *(void *)(v14 + 160);
        unsigned int v17 = v15 - 1;
        uint64_t v18 = (v15 - 1) & ((i >> 4) ^ (i >> 9));
        uint64_t v19 = *(const llvm::MachineBasicBlock **)(v16 + 16 * v18);
        if (v19 == i)
        {
LABEL_16:
          uint64_t v20 = *(unsigned int *)(v16 + 16 * v18 + 8);
          if (v20 != 0xFFFFFFFFLL)
          {
            unint64_t v14 = *(void *)(*(void *)(v14 + 8) + 24 * v20 + 16);
            goto LABEL_18;
          }
        }
        else
        {
          int v24 = 1;
          while (v19 != (const llvm::MachineBasicBlock *)-4096)
          {
            int v25 = v18 + v24++;
            uint64_t v18 = v25 & v17;
            uint64_t v19 = *(const llvm::MachineBasicBlock **)(v16 + 16 * v18);
            if (v19 == i) {
              goto LABEL_16;
            }
          }
        }
      }
      unint64_t v14 = 0;
LABEL_18:
      unint64_t v27 = v14;
      unint64_t v22 = (const llvm::MachineBasicBlock **)*((void *)i + 11);
      unint64_t v21 = (const llvm::MachineBasicBlock **)*((void *)i + 12);
      while (v22 != v21)
      {
        if (*((const llvm::MachineBasicBlock **)i + 1) != *v22)
        {
          unsigned int EdgeProbability = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(a1 + 248), i, *v22);
          llvm::BlockFrequency::operator*(&v27, EdgeProbability);
        }
        ++v22;
      }
    }
  }
  return 0;
}

uint64_t sub_1CC32C420()
{
  v4.n128_u64[0] = (unint64_t)"Force the alignment of all blocks in the function in log2 format (e.g 4 means align"
                                     " on 16B boundaries).";
  v4.n128_u64[1] = 103;
  uint64_t v3 = &v2;
  int v1 = 1;
  int v2 = 0;
  sub_1CD50BCD4((uint64_t)&unk_1EBCCD888, "align-all-blocks", &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCCD888, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Force the alignment of all blocks that have no fall-through predecessors (i.e. don'"
                                     "t add nops that are executed). In log2 format (e.g 4 means align on 16B boundaries).";
  v4.n128_u64[1] = 167;
  int v1 = 1;
  int v2 = 0;
  uint64_t v3 = &v2;
  sub_1CD52A138((long long *)&v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCCD948, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Forces the maximum bytes allowed to be emitted when padding for alignment";
  v4.n128_u64[1] = 73;
  int v1 = 1;
  int v2 = 0;
  uint64_t v3 = &v2;
  sub_1CD50BCD4((uint64_t)algn_1EBCCDA08, "max-bytes-for-alignment", &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, algn_1EBCCDA08, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Block frequency percentage a loop exit block needs over the original exit to be con"
                                     "sidered the new exit.";
  v4.n128_u64[1] = 104;
  int v1 = 1;
  int v2 = 0;
  uint64_t v3 = &v2;
  sub_1CD52A260((long long *)&v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCCDAC8, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Outline loop blocks from loop chain if (frequency of loop) / (frequency of block) i"
                                     "s greater than this ratio";
  v4.n128_u64[1] = 108;
  int v1 = 1;
  int v2 = 5;
  uint64_t v3 = &v2;
  sub_1CD50BCD4((uint64_t)&unk_1EBCCDB88, "loop-to-cold-block-ratio", &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCCDB88, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Force outlining cold blocks from loops.";
  v4.n128_u64[1] = 39;
  LOBYTE(v1) = 0;
  uint64_t v3 = &v1;
  int v2 = 1;
  sub_1CD4130FC((llvm::cl::Option *)&unk_1EBCCDC48, "force-loop-cold-block", &v4, (unsigned char **)&v3, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCCDC48, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Model the cost of loop rotation more precisely by using profile data.";
  v4.n128_u64[1] = 69;
  LOBYTE(v1) = 0;
  uint64_t v3 = &v1;
  int v2 = 1;
  sub_1CD4130FC((llvm::cl::Option *)&unk_1EBCCDD08, "precise-rotation-cost", &v4, (unsigned char **)&v3, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCCDD08, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Force the use of precise cost loop rotation strategy.";
  v4.n128_u64[1] = 53;
  LOBYTE(v1) = 0;
  uint64_t v3 = &v1;
  int v2 = 1;
  sub_1CD4130FC((llvm::cl::Option *)&unk_1EBCCDDC8, "force-precise-rotation-cost", &v4, (unsigned char **)&v3, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCCDDC8, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Cost that models the probabilistic risk of an instruction misfetch due to a jump co"
                                     "mparing to falling through, whose cost is zero.";
  v4.n128_u64[1] = 130;
  int v1 = 1;
  int v2 = 1;
  uint64_t v3 = &v2;
  sub_1CD50BCD4((uint64_t)&unk_1EBCCDE88, "misfetch-cost", &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCCDE88, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Cost of jump instructions.";
  v4.n128_u64[1] = 26;
  int v1 = 1;
  int v2 = 1;
  uint64_t v3 = &v2;
  sub_1CD50BCD4((uint64_t)&unk_1EBCCDF48, "jump-inst-cost", &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCCDF48, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Perform tail duplication during placement. Creates more fallthrough opportunites in"
                                     " outline branches.";
  v4.n128_u64[1] = 101;
  LOBYTE(v1) = 1;
  uint64_t v3 = &v1;
  int v2 = 1;
  sub_1CD4130FC((llvm::cl::Option *)&unk_1EBCCE008, "tail-dup-placement", &v4, (unsigned char **)&v3, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCCE008, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Perform branch folding during placement. Reduces code size.";
  v4.n128_u64[1] = 59;
  LOBYTE(v1) = 1;
  uint64_t v3 = &v1;
  int v2 = 1;
  sub_1CD4130FC((llvm::cl::Option *)&unk_1EBCCE0C8, "branch-fold-placement", &v4, (unsigned char **)&v3, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCCE0C8, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Instruction cutoff for tail duplication during layout. Tail merging during layout i"
                                     "s forced to have a threshold that won't conflict.";
  v4.n128_u64[1] = 132;
  int v1 = 1;
  int v2 = 2;
  uint64_t v3 = &v2;
  sub_1CD50BCD4((uint64_t)&unk_1EBCCE188, "tail-dup-placement-threshold", &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCCE188, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Instruction cutoff for aggressive tail duplication during layout. Used at -O3. Tail"
                                     " merging during layout is forced to have a threshold that won't conflict.";
  v4.n128_u64[1] = 156;
  int v1 = 1;
  int v2 = 4;
  uint64_t v3 = &v2;
  sub_1CD52A388((long long *)&v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCCE248, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Cost penalty for blocks that can avoid breaking CFG by copying. Copying can increas"
                                     "e fallthrough, but it also increases icache pressure. This parameter controls the p"
                                     "enalty to account for that. Percent as integer.";
  v4.n128_u64[1] = 213;
  int v1 = 1;
  int v2 = 2;
  uint64_t v3 = &v2;
  sub_1CD50BCD4((uint64_t)&unk_1EBCCE308, "tail-dup-placement-penalty", &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCCE308, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"If profile count information is used in tail duplication cost model, the gained fal"
                                     "l through number from tail duplication should be at least this percent of hot count.";
  v4.n128_u64[1] = 167;
  int v1 = 1;
  int v2 = 50;
  uint64_t v3 = &v2;
  sub_1CD50BCD4((uint64_t)&unk_1EBCCE3C8, "tail-dup-profile-percent-threshold", &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCCE3C8, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Number of triangle-shaped-CFG's that need to be in a row for the triangle tail dupl"
                                     "ication heuristic to kick in. 0 to disable.";
  v4.n128_u64[1] = 126;
  int v1 = 1;
  int v2 = 2;
  uint64_t v3 = &v2;
  sub_1CD50BCD4((uint64_t)&unk_1EBCCE488, "triangle-chain-count", &v4, &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCCE488, &dword_1CB82C000);
}

void sub_1CC32C958()
{
}

uint64_t llvm::MachineBranchProbabilityInfo::getEdgeProbability(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v3 = (char *)a2[14];
  __n128 v4 = (char *)a2[15];
  if (v3 == v4)
  {
    unint64_t v13 = a2[12] - a2[11];
    BOOL v14 = (v13 >> 3) == 0x80000000;
    unsigned int v15 = ((v13 >> 4) | 0x80000000) / (v13 >> 3);
    if (v14) {
      return 1;
    }
    else {
      return v15;
    }
  }
  else
  {
    uint64_t result = *(unsigned int *)&v3[(a3 - a2[11]) >> 1];
    if (result == -1)
    {
      int v6 = 0;
      unsigned int v7 = 0;
      uint64_t v8 = (unsigned int *)a2[14];
      do
      {
        unsigned int v10 = *v8++;
        unsigned int v9 = v10;
        unsigned int v11 = v10 + v7;
        if (v10 + (unint64_t)v7 <= 0x80000000) {
          unsigned int v12 = v11;
        }
        else {
          unsigned int v12 = 0x80000000;
        }
        if (v9 != -1)
        {
          unsigned int v7 = v12;
          ++v6;
        }
      }
      while (v8 != (unsigned int *)v4);
      return (0x80000000 - v7) / (((unint64_t)(v4 - v3) >> 2) - v6);
    }
  }
  return result;
}

uint64_t llvm::MachineBranchProbabilityInfo::getEdgeProbability(llvm::MachineBranchProbabilityInfo *this, const llvm::MachineBasicBlock *a2, const llvm::MachineBasicBlock *a3)
{
  uint64_t v3 = (const llvm::MachineBasicBlock **)*((void *)a2 + 11);
  __n128 v4 = (const llvm::MachineBasicBlock **)*((void *)a2 + 12);
  char v5 = v3;
  if (v3 != v4)
  {
    while (*v5 != a3)
    {
      if (++v5 == v4)
      {
        char v5 = (const llvm::MachineBasicBlock **)*((void *)a2 + 12);
        break;
      }
    }
  }
  int v6 = (char *)*((void *)a2 + 14);
  unsigned int v7 = (char *)*((void *)a2 + 15);
  if (v6 == v7)
  {
    unint64_t v16 = (unint64_t)((char *)v4 - (char *)v3) >> 3;
    if (v16 == 0x80000000) {
      return 1;
    }
    else {
      return (((unint64_t)((char *)v4 - (char *)v3) >> 4) | 0x80000000) / v16;
    }
  }
  else
  {
    uint64_t result = *(unsigned int *)&v6[((char *)v5 - (char *)v3) >> 1];
    if (result == -1)
    {
      int v9 = 0;
      unsigned int v10 = 0;
      unsigned int v11 = (unsigned int *)*((void *)a2 + 14);
      do
      {
        unsigned int v13 = *v11++;
        unsigned int v12 = v13;
        unsigned int v14 = v13 + v10;
        if (v13 + (unint64_t)v10 <= 0x80000000) {
          unsigned int v15 = v14;
        }
        else {
          unsigned int v15 = 0x80000000;
        }
        if (v12 != -1)
        {
          unsigned int v10 = v15;
          ++v9;
        }
      }
      while (v11 != (unsigned int *)v7);
      return (0x80000000 - v10) / (((unint64_t)(v7 - v6) >> 2) - v9);
    }
  }
  return result;
}

BOOL llvm::MachineBranchProbabilityInfo::isEdgeHot(llvm::MachineBranchProbabilityInfo *this, const llvm::MachineBasicBlock *a2, const llvm::MachineBasicBlock *a3)
{
  uint64_t v3 = (const llvm::MachineBasicBlock **)*((void *)a2 + 11);
  __n128 v4 = (const llvm::MachineBasicBlock **)*((void *)a2 + 12);
  char v5 = v3;
  if (v3 != v4)
  {
    while (*v5 != a3)
    {
      if (++v5 == v4)
      {
        char v5 = (const llvm::MachineBasicBlock **)*((void *)a2 + 12);
        break;
      }
    }
  }
  int v6 = (char *)*((void *)a2 + 14);
  unsigned int v7 = (char *)*((void *)a2 + 15);
  if (v6 == v7)
  {
    unint64_t v17 = (unint64_t)((char *)v4 - (char *)v3) >> 3;
    if (v17 == 0x80000000) {
      unsigned int v8 = 1;
    }
    else {
      unsigned int v8 = (((unint64_t)((char *)v4 - (char *)v3) >> 4) | 0x80000000) / v17;
    }
  }
  else
  {
    unsigned int v8 = *(_DWORD *)&v6[((char *)v5 - (char *)v3) >> 1];
    if (v8 == -1)
    {
      int v9 = 0;
      unsigned int v10 = 0;
      unsigned int v11 = (unsigned int *)*((void *)a2 + 14);
      do
      {
        unsigned int v13 = *v11++;
        unsigned int v12 = v13;
        unsigned int v14 = v13 + v10;
        if (v13 + (unint64_t)v10 <= 0x80000000) {
          unsigned int v15 = v14;
        }
        else {
          unsigned int v15 = 0x80000000;
        }
        if (v12 != -1)
        {
          unsigned int v10 = v15;
          ++v9;
        }
      }
      while (v11 != (unsigned int *)v7);
      unsigned int v8 = (0x80000000 - v10) / (((unint64_t)(v7 - v6) >> 2) - v9);
    }
  }
  return v8 > ((unint64_t)(((((unint64_t)dword_1EBD053C8 << 31) | 0x30)
                                               * (unsigned __int128)0xA3D70A3D70A3D70BLL) >> 64) >> 6);
}

llvm::raw_ostream *llvm::MachineBranchProbabilityInfo::printEdgeProbability(llvm::MachineBranchProbabilityInfo *this, llvm::raw_ostream *a2, const llvm::MachineBasicBlock *a3, const llvm::MachineBasicBlock *a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unsigned int v7 = (const llvm::MachineBasicBlock **)*((void *)a3 + 11);
  unsigned int v8 = (const llvm::MachineBasicBlock **)*((void *)a3 + 12);
  int v9 = v7;
  if (v7 != v8)
  {
    while (*v9 != a4)
    {
      if (++v9 == v8)
      {
        int v9 = (const llvm::MachineBasicBlock **)*((void *)a3 + 12);
        break;
      }
    }
  }
  unsigned int v10 = (char *)*((void *)a3 + 14);
  unsigned int v11 = (char *)*((void *)a3 + 15);
  if (v10 == v11)
  {
    unint64_t v31 = (unint64_t)((char *)v8 - (char *)v7) >> 3;
    if (v31 == 0x80000000) {
      unsigned int v12 = 1;
    }
    else {
      unsigned int v12 = (((unint64_t)((char *)v8 - (char *)v7) >> 4) | 0x80000000) / v31;
    }
  }
  else
  {
    unsigned int v12 = *(_DWORD *)&v10[((char *)v9 - (char *)v7) >> 1];
    if (v12 == -1)
    {
      int v13 = 0;
      unsigned int v14 = 0;
      unsigned int v15 = (unsigned int *)*((void *)a3 + 14);
      do
      {
        unsigned int v17 = *v15++;
        unsigned int v16 = v17;
        unsigned int v18 = v17 + v14;
        if (v17 + (unint64_t)v14 <= 0x80000000) {
          unsigned int v19 = v18;
        }
        else {
          unsigned int v19 = 0x80000000;
        }
        if (v16 != -1)
        {
          unsigned int v14 = v19;
          ++v13;
        }
      }
      while (v15 != (unsigned int *)v11);
      unsigned int v12 = (0x80000000 - v14) / (((unint64_t)(v11 - v10) >> 2) - v13);
    }
  }
  uint64_t v20 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v20) > 4)
  {
    *(unsigned char *)(v20 + 4) = 32;
    *(_DWORD *)uint64_t v20 = 1701274725;
    *((void *)a2 + 4) += 5;
    unint64_t v21 = a2;
  }
  else
  {
    unint64_t v21 = llvm::raw_ostream::write(a2, "edge ", 5uLL);
  }
  uint64_t v36 = v35;
  v35[0] = &unk_1F260D508;
  v35[1] = a3;
  unint64_t v22 = (void (*)(uint64_t, llvm::raw_ostream *))off_1F260D538;
  off_1F260D538((uint64_t)v35, v21);
  uint64_t v23 = (_DWORD *)*((void *)v21 + 4);
  if (*((void *)v21 + 3) - (void)v23 > 3uLL)
  {
    *uint64_t v23 = 540945696;
    *((void *)v21 + 4) += 4;
  }
  else
  {
    unint64_t v21 = llvm::raw_ostream::write(v21, " -> ", 4uLL);
  }
  unint64_t v34 = v33;
  v33[0] = &unk_1F260D508;
  v33[1] = a4;
  v22((uint64_t)v33, v21);
  int v24 = (_OWORD *)*((void *)v21 + 4);
  if (*((void *)v21 + 3) - (void)v24 > 0xFuLL)
  {
    *int v24 = *(_OWORD *)" probability is ";
    *((void *)v21 + 4) += 16;
  }
  else
  {
    unint64_t v21 = llvm::raw_ostream::write(v21, " probability is ", 0x10uLL);
  }
  unsigned int v32 = v12;
  int v25 = llvm::BranchProbability::print((llvm::BranchProbability *)&v32, v21);
  BOOL isEdgeHot = llvm::MachineBranchProbabilityInfo::isEdgeHot(v25, a3, a4);
  if (isEdgeHot) {
    unint64_t v27 = " [HOT edge]\n";
  }
  else {
    unint64_t v27 = "\n";
  }
  if (isEdgeHot) {
    size_t v28 = 12;
  }
  else {
    size_t v28 = 1;
  }
  uint64_t v29 = (void *)*((void *)v25 + 4);
  if (v28 <= *((void *)v25 + 3) - (void)v29)
  {
    memcpy(v29, v27, v28);
    *((void *)v25 + 4) += v28;
  }
  else
  {
    llvm::raw_ostream::write(v25, v27, v28);
  }
  if (v34 == v33)
  {
    (*(void (**)(void *))(v33[0] + 32))(v33);
  }
  else if (v34)
  {
    (*(void (**)(void))(*v34 + 40))();
  }
  if (v36 == v35)
  {
    (*(void (**)(void *))(v35[0] + 32))(v35);
  }
  else if (v36)
  {
    (*(void (**)(void))(*v36 + 40))();
  }
  return a2;
}

uint64_t sub_1CC32D038()
{
  *(void *)&long long v4 = "branch probability threshold in percentageto be considered very likely";
  *((void *)&v4 + 1) = 70;
  uint64_t v3 = &v2;
  int v1 = 1;
  int v2 = 80;
  sub_1CD52A660(&v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &llvm::StaticLikelyProb, &dword_1CB82C000);
  *(void *)&long long v4 = "branch probability threshold in percentage to be considered very likely when profile is available";
  *((void *)&v4 + 1) = 97;
  int v1 = 1;
  int v2 = 51;
  uint64_t v3 = &v2;
  sub_1CD50BCD4((uint64_t)&llvm::ProfileLikelyProb, "profile-likely-prob", &v4, &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &llvm::ProfileLikelyProb, &dword_1CB82C000);
}

void sub_1CC32D114(llvm *a1)
{
  llvm::initializeMachineLoopInfoPass((uint64_t)a1);
  llvm::initializeMachineTraceMetricsPass(a1, v2);
  operator new();
}

void sub_1CC32D1BC()
{
}

void sub_1CC32D370(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_1F260D870;
  int v2 = (uint64_t *)a1[103];
  if (v2 != a1 + 105) {
    free(v2);
  }
  sub_1CD50C1C0(a1 + 49);
  *a1 = (uint64_t)&unk_1F260E110;
  uint64_t v3 = (uint64_t *)a1[22];
  if (v3 != a1 + 24) {
    free(v3);
  }
  long long v4 = (uint64_t *)a1[13];
  if (v4 != a1 + 15) {
    free(v4);
  }
  char v5 = (uint64_t *)a1[4];
  if (v5 != a1 + 6) {
    free(v5);
  }

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1CC32D440(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_1F260D870;
  int v2 = (uint64_t *)a1[103];
  if (v2 != a1 + 105) {
    free(v2);
  }
  sub_1CD50C1C0(a1 + 49);
  *a1 = (uint64_t)&unk_1F260E110;
  uint64_t v3 = (uint64_t *)a1[22];
  if (v3 != a1 + 24) {
    free(v3);
  }
  long long v4 = (uint64_t *)a1[13];
  if (v4 != a1 + 15) {
    free(v4);
  }
  char v5 = (uint64_t *)a1[4];
  if (v5 != a1 + 6) {
    free(v5);
  }
  llvm::Pass::~Pass((llvm::Pass *)a1);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CC32D524()
{
  return "Machine InstCombiner";
}

void sub_1CC32D534(llvm::PassRegistry *a1, uint64_t a2)
{
  uint64_t v4 = a2 + 112;
  v6[0] = &unk_1F2617E40;
  v6[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v6);
  sub_1CB843600(a2, v4, (uint64_t)&llvm::MachineDominatorTree::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineLoopInfo::ID);
  sub_1CB843600(a2, v4, (uint64_t)&llvm::MachineLoopInfo::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineTraceMetrics::ID);
  sub_1CB843600(a2, v4, (uint64_t)&llvm::MachineTraceMetrics::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LazyMachineBlockFrequencyInfoPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::ProfileSummaryInfoWrapperPass::ID);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)a1, a2);
}

uint64_t sub_1CC32D63C(uint64_t a1, const llvm::MachineFunction *a2)
{
  v190[1] = *(const llvm::MachineBasicBlock **)MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)a2 + 2);
  *(void *)(a1 + 248) = v4;
  *(void *)(a1 + 256) = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 104))(v4);
  *(void *)(a1 + 264) = (*(uint64_t (**)(void))(**(void **)(a1 + 248) + 176))(*(void *)(a1 + 248));
  char v5 = *(const llvm::TargetSubtargetInfo **)(a1 + 248);
  uint64_t v6 = *((void *)v5 + 20);
  *(_OWORD *)(a1 + 272) = *(_OWORD *)v6;
  long long v8 = *(_OWORD *)(v6 + 32);
  long long v7 = *(_OWORD *)(v6 + 48);
  long long v9 = *(_OWORD *)(v6 + 16);
  *(void *)(a1 + 336) = *(void *)(v6 + 64);
  *(_OWORD *)(a1 + 304) = v8;
  *(_OWORD *)(a1 + 320) = v7;
  *(_OWORD *)(a1 + 288) = v9;
  unint64_t v146 = (llvm::TargetSchedModel *)(a1 + 632);
  llvm::TargetSchedModel::init((llvm::TargetSchedModel *)(a1 + 632), v5);
  *(void *)(a1 + 344) = *((void *)a2 + 5);
  unsigned int v10 = *(uint64_t **)(a1 + 8);
  uint64_t v11 = *v10;
  uint64_t v12 = v10[1];
  if (v11 == v12)
  {
LABEL_4:
    uint64_t v13 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v11 != &llvm::MachineLoopInfo::ID)
    {
      v11 += 16;
      if (v11 == v12) {
        goto LABEL_4;
      }
    }
    uint64_t v13 = *(void *)(v11 + 8);
  }
  *(void *)(a1 + 352) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v13 + 96))(v13, &llvm::MachineLoopInfo::ID);
  unsigned int v14 = *(uint64_t **)(a1 + 8);
  uint64_t v15 = *v14;
  uint64_t v16 = v14[1];
  if (v15 == v16)
  {
LABEL_9:
    uint64_t v17 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v15 != &llvm::MachineTraceMetrics::ID)
    {
      v15 += 16;
      if (v15 == v16) {
        goto LABEL_9;
      }
    }
    uint64_t v17 = *(void *)(v15 + 8);
  }
  *(void *)(a1 + 360) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v17 + 96))(v17, &llvm::MachineTraceMetrics::ID);
  unsigned int v18 = *(uint64_t **)(a1 + 8);
  uint64_t v19 = *v18;
  uint64_t v20 = v18[1];
  if (v19 == v20)
  {
LABEL_14:
    uint64_t v21 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v19 != &llvm::ProfileSummaryInfoWrapperPass::ID)
    {
      v19 += 16;
      if (v19 == v20) {
        goto LABEL_14;
      }
    }
    uint64_t v21 = *(void *)(v19 + 8);
  }
  uint64_t v22 = *(void *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v21 + 96))(v21, &llvm::ProfileSummaryInfoWrapperPass::ID)+ 32);
  *(void *)(a1 + 384) = v22;
  if (*(void *)(v22 + 8))
  {
    uint64_t v23 = *(uint64_t **)(a1 + 8);
    uint64_t v24 = *v23;
    uint64_t v25 = v23[1];
    if (v24 == v25)
    {
LABEL_20:
      uint64_t v26 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v24 != &llvm::LazyMachineBlockFrequencyInfoPass::ID)
      {
        v24 += 16;
        if (v24 == v25) {
          goto LABEL_20;
        }
      }
      uint64_t v26 = *(void *)(v24 + 8);
    }
    size_t v28 = (llvm::PMDataManager ***)(*(uint64_t (**)(uint64_t, void *))(*(void *)v26 + 96))(v26, &llvm::LazyMachineBlockFrequencyInfoPass::ID);
    uint64_t v27 = llvm::LazyMachineBlockFrequencyInfoPass::calculateIfNotAvailable(v28);
  }
  else
  {
    uint64_t v27 = 0;
  }
  *(void *)(a1 + 368) = 0;
  *(void *)(a1 + 376) = v27;
  uint64_t v29 = *(void *)(*(void *)a2 + 112);
  if (v29) {
    LOBYTE(v29) = (*(unsigned char *)(v29 + 17) & 4) != 0 || *(char *)(v29 + 13) < 0;
  }
  *(unsigned char *)(a1 + 912) = v29;
  uint64_t v128 = a1 + 392;
  llvm::RegisterClassInfo::runOnMachineFunction((llvm::RegisterClassInfo *)(a1 + 392), a2);
  if (!(*(unsigned int (**)(void))(**(void **)(a1 + 256) + 576))()
    || (uint64_t v30 = *((void *)a2 + 41),
        __n128 v127 = (void *)((char *)a2 + 320),
        (const llvm::MachineFunction *)v30 == (const llvm::MachineFunction *)((char *)a2 + 320)))
  {
    LOBYTE(v31) = 0;
    return v31 & 1;
  }
  int v31 = 0;
  uint64_t v145 = a1;
  do
  {
    uint64_t v32 = *(void *)(a1 + 352);
    int v33 = *(_DWORD *)(v32 + 264);
    int v129 = v31;
    if (!v33) {
      goto LABEL_37;
    }
    uint64_t v34 = *(void *)(v32 + 248);
    unsigned int v35 = v33 - 1;
    uint64_t v36 = (v33 - 1) & ((v30 >> 4) ^ (v30 >> 9));
    uint64_t v37 = *(void *)(v34 + 16 * v36);
    if (v30 != v37)
    {
      int v38 = 1;
      while (v37 != -4096)
      {
        int v39 = v36 + v38++;
        uint64_t v36 = v39 & v35;
        uint64_t v37 = *(void *)(v34 + 16 * v36);
        if (v30 == v37) {
          goto LABEL_36;
        }
      }
LABEL_37:
      uint64_t v137 = 0;
      goto LABEL_38;
    }
LABEL_36:
    uint64_t v137 = *(void *)(v34 + 16 * v36 + 8);
LABEL_38:
    int64_t v40 = *(llvm::MachineInstr **)(v30 + 56);
    if (!*(void *)(a1 + 368)) {
      *(void *)(a1 + 368) = llvm::MachineTraceMetrics::getEnsemble(*(void *)(a1 + 360), 0);
    }
    v178[0] = v179;
    v178[1] = (void *)0x800000000;
    unsigned int v180 = 0;
    int v181 = 0;
    uint64_t v41 = *(void *)(a1 + 264);
    int v42 = *(_DWORD *)(v41 + 44);
    if (v42)
    {
      uint64_t v43 = malloc_type_calloc(*(unsigned int *)(v41 + 44), 1uLL, 0x6D9A4F0CuLL);
      if (!v43) {
        llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
      }
      unsigned int v180 = v43;
      int v181 = v42;
    }
    if (*(unsigned char *)(a1 + 912)) {
      int shouldOptimizeForSize = 1;
    }
    else {
      int shouldOptimizeForSize = llvm::shouldOptimizeForSize((const llvm::MachineBasicBlock *)v30, *(void *)(a1 + 384), *(llvm::MachineBlockFrequencyInfo **)(a1 + 376));
    }
    int v138 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 256) + 512))(*(void *)(a1 + 256), v30, v128);
    uint64_t v135 = v30 + 48;
    if (v40 == (llvm::MachineInstr *)(v30 + 48))
    {
      int v123 = 0;
      goto LABEL_240;
    }
    uint64_t v44 = v40;
    int v136 = 0;
    int v141 = 0;
    uint64_t v140 = 0;
    uint64_t v133 = v30;
    do
    {
      if (!v44 || (uint64_t v45 = v44, (*(unsigned char *)v44 & 4) == 0))
      {
        uint64_t v45 = v44;
        if ((*((_WORD *)v44 + 22) & 8) != 0)
        {
          uint64_t v45 = v44;
          do
            uint64_t v45 = (llvm::MachineInstr *)*((void *)v45 + 1);
          while ((*((_WORD *)v45 + 22) & 8) != 0);
        }
      }
      unint64_t v46 = *((void *)v45 + 1);
      uint64_t v175 = v177;
      uint64_t v176 = 0x1000000000;
      uint64_t v144 = v44;
      int v47 = (*(uint64_t (**)(void))(**(void **)(a1 + 256) + 504))(*(void *)(a1 + 256));
      uint64_t v48 = (unsigned int *)v175;
      if (!v47)
      {
LABEL_68:
        uint64_t v44 = (llvm::MachineInstr *)v46;
        goto LABEL_232;
      }
      uint64_t v49 = v176;
      if (byte_1EBCCE760)
      {
        if (!v176) {
          goto LABEL_68;
        }
        uint64_t v50 = 4 * v176;
        do
        {
          unint64_t v51 = v48;
          unint64_t v185 = v187;
          uint64_t v186 = 0x1000000000;
          uint64_t v182 = v184;
          uint64_t v183 = 0x1000000000;
          uint64_t v173 = 0;
          uint64_t __src = 0;
          v174[0] = 0;
          (*(void (**)(void))(**(void **)(a1 + 256) + 552))();
          if (v186 && (byte_1EBD06248 && *(void *)(a1 + 672) || byte_1EBD06308 && *(void *)(a1 + 800)))
          {
            Trace = llvm::MachineTraceMetrics::Ensemble::getTrace(*(llvm::MachineTraceMetrics::Ensemble **)(a1 + 368), (const llvm::MachineBasicBlock *)v30);
            sub_1CC32EC3C(a1, v144, (uint64_t)&v185, (uint64_t)&v182, (uint64_t)Trace, v53);
          }
          MEMORY[0x1D25D9CD0](__src, 4);
          if (v182 != v184) {
            free(v182);
          }
          if (v185 != v187) {
            free(v185);
          }
          uint64_t v48 = v51 + 1;
          v50 -= 4;
        }
        while (v50);
        uint64_t v48 = (unsigned int *)v175;
        uint64_t v49 = v176;
      }
      if (!v49) {
        goto LABEL_231;
      }
      uint64_t v139 = &v48[v49];
      do
      {
        __n128 v142 = v48;
        unsigned int v54 = *v48;
        uint64_t __src = v174;
        uint64_t v173 = 0x1000000000;
        uint64_t v169 = v171;
        uint64_t v170 = 0x1000000000;
        unint64_t v147 = 0;
        uint64_t v148 = 0;
        unsigned int v149 = 0;
        unsigned int v143 = v54;
        (*(void (**)(void))(**(void **)(a1 + 256) + 552))();
        unsigned int v55 = v173;
        if (!v173)
        {
          int v58 = 7;
          goto LABEL_120;
        }
        unsigned int v56 = v170;
        if (v137) {
          int v57 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 256) + 528))(*(void *)(a1 + 256), v143);
        }
        else {
          int v57 = 0;
        }
        uint64_t v59 = v140;
        if ((v141 & (v140 != v46)) == 1)
        {
          llvm::MachineTraceMetrics::Ensemble::updateDepths(*(void **)(a1 + 368), v140, v46, (uint64_t)v178);
          uint64_t v59 = v46;
        }
        int v60 = v138;
        if ((v143 & 0xFFFFFFFE) != 6) {
          int v60 = 0;
        }
        if (v60 == 1)
        {
          unsigned int v61 = -1;
          uint64_t v62 = v135;
          do
          {
            uint64_t v62 = *(void *)(v62 + 8);
            ++v61;
          }
          while (v62 != v135);
          BOOL v63 = dword_1EBCCE5E0 < v61;
          if (dword_1EBCCE5E0 < v61) {
            uint64_t v59 = v46;
          }
          uint64_t v140 = v59;
          uint64_t v166 = v168;
          uint64_t v167 = 0x1000000000;
          int v64 = v173;
          if (v173)
          {
            if (v173 >= 0x11uLL) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            memcpy(v168, __src, 8 * v173);
            LODWORD(v167) = v64;
          }
          uint64_t v163 = v165;
          uint64_t v164 = 0x1000000000;
          int v65 = v170;
          if (v170)
          {
            if (v170 >= 0x11uLL) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            memcpy(v165, v169, 8 * v170);
            LODWORD(v164) = v65;
          }
          v141 |= v63;
          sub_1CC32E98C(v30, (uint64_t *)v144, (uint64_t)&v166, (uint64_t)&v163, *(llvm::MachineTraceMetrics::Ensemble **)(a1 + 368), (uint64_t)v178, *(void *)(a1 + 256), v143, v141 & 1);
          if (v163 != v165) {
            free(v163);
          }
          if (v166 != v168) {
            free(v166);
          }
          unint64_t v46 = *(void *)v46 & 0xFFFFFFFFFFFFFFF8;
          if (!v46 || (*(unsigned char *)v46 & 4) == 0)
          {
            while ((*(_WORD *)(v46 + 44) & 4) != 0)
              unint64_t v46 = *(void *)v46 & 0xFFFFFFFFFFFFFFF8;
          }
LABEL_119:
          int v136 = 1;
          int v58 = 6;
          goto LABEL_120;
        }
        uint64_t v140 = v59;
        int v66 = shouldOptimizeForSize;
        if (v55 >= v56) {
          int v66 = 0;
        }
        if (((v57 | v66) & 1) != 0
          || (!byte_1EBD06248 || !*(void *)(a1 + 672)) && (!byte_1EBD06308 || !*(void *)(a1 + 800)))
        {
          int v160 = v162;
          uint64_t v161 = 0x1000000000;
          int v67 = v173;
          if (v173)
          {
            if (v173 >= 0x11uLL) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            memcpy(v162, __src, 8 * v173);
            LODWORD(v161) = v67;
          }
          int v157 = v159;
          uint64_t v158 = 0x1000000000;
          int v68 = v170;
          if (v170)
          {
            if (v170 >= 0x11uLL) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            memcpy(v159, v169, 8 * v170);
            LODWORD(v158) = v68;
          }
          sub_1CC32E98C(v30, (uint64_t *)v144, (uint64_t)&v160, (uint64_t)&v157, *(llvm::MachineTraceMetrics::Ensemble **)(a1 + 368), (uint64_t)v178, *(void *)(a1 + 256), v143, v141 & 1);
          if (v157 != v159) {
            free(v157);
          }
          unsigned int v69 = v160;
          BOOL v70 = v160 == v162;
LABEL_117:
          if (!v70) {
            free(v69);
          }
          goto LABEL_119;
        }
        unsigned int v71 = (uint64_t *)llvm::MachineTraceMetrics::Ensemble::getTrace(*(llvm::MachineTraceMetrics::Ensemble **)(a1 + 368), (const llvm::MachineBasicBlock *)v30);
        uint64_t v73 = v72;
        (*(void (**)(void))(**(void **)(a1 + 360) + 120))(*(void *)(a1 + 360));
        uint64_t v182 = v71;
        uint64_t v131 = v73;
        uint64_t v132 = (uint64_t)v71;
        uint64_t v183 = v73;
        unint64_t v185 = v187;
        uint64_t v186 = 0x1000000000;
        if (!v173)
        {
          unsigned int v74 = STACK[0x400000794];
          BOOL v75 = v144;
          goto LABEL_178;
        }
        unsigned int v76 = 0;
        unsigned int v77 = (char *)__src;
        unsigned int v78 = (char *)__src + 8 * v173;
        uint64_t v130 = v71 + 47;
        do
        {
          unint64_t v79 = *(const llvm::MachineInstr **)v77;
          uint64_t v80 = *(unsigned int *)(*(void *)v77 + 40);
          if (v80)
          {
            unsigned int v81 = 0;
            unint64_t v82 = (_DWORD *)*((void *)v79 + 4);
            long long v83 = &v82[8 * v80];
            while (1)
            {
              if (!*v82 && (*v82 & 0x1000000) == 0)
              {
                unsigned int v84 = v82[1];
                if ((v84 & 0x80000000) != 0) {
                  break;
                }
              }
LABEL_147:
              v82 += 8;
              if (v82 == v83)
              {
                unsigned int v76 = v186;
                goto LABEL_171;
              }
            }
            if (v149)
            {
              LODWORD(v85) = (v149 - 1) & (37 * v84);
              long long v86 = &v147[2 * v85];
              int v87 = *v86;
              if (v84 == *v86) {
                goto LABEL_140;
              }
              int v95 = 1;
              while (v87 != -1)
              {
                int v96 = v85 + v95++;
                uint64_t v85 = v96 & (v149 - 1);
                int v87 = v147[2 * v85];
                if (v84 == v87)
                {
                  long long v86 = &v147[2 * v85];
                  goto LABEL_140;
                }
              }
            }
            long long v86 = &v147[2 * v149];
LABEL_140:
            if (&v147[2 * v149] != v86)
            {
              uint64_t v88 = v86[1];
              long long v89 = (const llvm::MachineInstr *)*((void *)__src + v88);
              LODWORD(v90) = *((_DWORD *)v185 + v88);
LABEL_142:
              uint64_t RegisterDefOperandIdx = llvm::MachineInstr::findRegisterDefOperandIdx((uint64_t)v89, v84, 0, 0, 0);
              uint64_t RegisterUseOperandIdx = llvm::MachineInstr::findRegisterUseOperandIdx((uint64_t)v79, v82[1], 0, 0);
              int v93 = llvm::TargetSchedModel::computeOperandLatency(v146, v89, RegisterDefOperandIdx, v79, RegisterUseOperandIdx);
              goto LABEL_145;
            }
            uint64_t v94 = *(void *)(*(void *)(*(void *)(v145 + 344) + 24) + 16 * (v84 & 0x7FFFFFFF) + 8);
            if (!v94) {
              goto LABEL_144;
            }
            if ((*(unsigned char *)(v94 + 3) & 1) == 0)
            {
              uint64_t v94 = *(void *)(v94 + 24);
              if (!v94 || (*(unsigned char *)(v94 + 3) & 1) == 0) {
                goto LABEL_144;
              }
            }
            long long v89 = *(const llvm::MachineInstr **)(v94 + 8);
            do
            {
              uint64_t v94 = *(void *)(v94 + 24);
              if (!v94 || (*(unsigned char *)(v94 + 3) & 1) == 0) {
                break;
              }
              int v93 = 0;
              LODWORD(v90) = 0;
            }
            while (*(const llvm::MachineInstr **)(v94 + 8) == v89);
            if (v89)
            {
              int v93 = 0;
              if (**((_WORD **)v89 + 2))
              {
                LODWORD(v90) = 0;
                if (**((_WORD **)v89 + 2) != 69)
                {
                  int v188 = (const llvm::MachineBasicBlock **)v89;
                  v150[0] = 0;
                  LODWORD(v90) = 0;
                  if (sub_1CD3C8538(v130, &v188, v150)) {
                    uint64_t v90 = *(void *)(v150[0] + 8);
                  }
                  unsigned int v84 = v82[1];
                  goto LABEL_142;
                }
              }
              else
              {
                LODWORD(v90) = 0;
              }
            }
            else
            {
LABEL_144:
              int v93 = 0;
              LODWORD(v90) = 0;
            }
LABEL_145:
            if (v81 <= (int)v90 + v93) {
              unsigned int v81 = v90 + v93;
            }
            goto LABEL_147;
          }
          unsigned int v81 = 0;
LABEL_171:
          if (v76 >= HIDWORD(v186)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((_DWORD *)v185 + v76) = v81;
          unsigned int v76 = v186 + 1;
          LODWORD(v186) = v186 + 1;
          v77 += 8;
        }
        while (v77 != v78);
        unsigned int v74 = *((_DWORD *)v185 + (v173 - 1));
        if (v185 != v187) {
          free(v185);
        }
        BOOL v75 = v144;
        a1 = v145;
        uint64_t v30 = v133;
        unsigned int v71 = (uint64_t *)v132;
LABEL_178:
        unint64_t v185 = v75;
        int v188 = 0;
        if (sub_1CD3C8538(v71 + 47, &v185, &v188)) {
          unsigned int v97 = *((_DWORD *)v188 + 2);
        }
        else {
          unsigned int v97 = 0;
        }
        uint64_t v98 = v140;
        if (v143 > 5)
        {
          unint64_t v117 = sub_1CC32EC3C(a1, v144, (uint64_t)&__src, (uint64_t)&v169, v132, v131);
          int v118 = v117;
          unint64_t v119 = HIDWORD(v117);
          InstrSlacuint64_t k = llvm::MachineTraceMetrics::Trace::getInstrSlack((llvm::MachineTraceMetrics::Trace *)&v182, v144);
          uint64_t v98 = v140;
          if (v141) {
            int v121 = 0;
          }
          else {
            int v121 = InstrSlack;
          }
          if (v74 + v118 <= v97 + v119 + v121) {
            goto LABEL_183;
          }
          goto LABEL_192;
        }
        if (v74 >= v97) {
          goto LABEL_192;
        }
LABEL_183:
        v150[0] = v132;
        v150[1] = v131;
        if (!byte_1EBD06248 || !*(void *)(a1 + 672)) {
          goto LABEL_205;
        }
        int v188 = v190;
        v190[0] = (const llvm::MachineBasicBlock *)v30;
        uint64_t v189 = 0x100000001;
        int ResourceLength = llvm::MachineTraceMetrics::Trace::getResourceLength(v150, v190, 1, 0, 0, 0, 0);
        unint64_t v185 = v187;
        uint64_t v186 = 0x1000000000;
        uint64_t v182 = v184;
        uint64_t v183 = 0x1000000000;
        sub_1CC32EE30(a1, (uint64_t)__src, v173, (uint64_t)&v185);
        sub_1CC32EE30(a1, (uint64_t)v169, v170, (uint64_t)&v182);
        unsigned int v100 = llvm::MachineTraceMetrics::Trace::getResourceLength(v150, v188, v189, (uint64_t *)v185, v186, (uint64_t *)v182, v183);
        int v101 = (*(uint64_t (**)(void))(**(void **)(a1 + 256) + 560))();
        if (v182 != v184) {
          free(v182);
        }
        if (v185 != v187) {
          free(v185);
        }
        if (v188 != v190) {
          free(v188);
        }
        uint64_t v98 = v140;
        if (v100 <= v101 + ResourceLength)
        {
LABEL_205:
          unsigned int v110 = -1;
          uint64_t v111 = v135;
          do
          {
            uint64_t v111 = *(void *)(v111 + 8);
            ++v110;
          }
          while (v111 != v135);
          BOOL v112 = dword_1EBCCE5E0 < v110;
          if (dword_1EBCCE5E0 < v110) {
            uint64_t v98 = v46;
          }
          uint64_t v140 = v98;
          unsigned int v154 = v156;
          uint64_t v155 = 0x1000000000;
          int v113 = v173;
          if (v173)
          {
            if (v173 >= 0x11uLL) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            memcpy(v156, __src, 8 * v173);
            LODWORD(v155) = v113;
          }
          unint64_t v151 = v153;
          uint64_t v152 = 0x1000000000;
          int v114 = v170;
          if (v170)
          {
            if (v170 >= 0x11uLL) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            memcpy(v153, v169, 8 * v170);
            LODWORD(v152) = v114;
          }
          v141 |= v112;
          sub_1CC32E98C(v30, (uint64_t *)v144, (uint64_t)&v154, (uint64_t)&v151, *(llvm::MachineTraceMetrics::Ensemble **)(a1 + 368), (uint64_t)v178, *(void *)(a1 + 256), v143, v141 & 1);
          if (v151 != v153) {
            free(v151);
          }
          unsigned int v69 = v154;
          BOOL v70 = v154 == v156;
          goto LABEL_117;
        }
LABEL_192:
        if (v173)
        {
          uint64_t v102 = (char *)__src;
          uint64_t v103 = *(void *)(v30 + 32);
          uint64_t v104 = (uint64_t *)(v103 + 232);
          uint64_t v105 = 8 * v173;
          do
          {
            uint64_t v106 = *(void *)v102;
            unint64_t v107 = *(void **)(*(void *)v102 + 32);
            if (v107)
            {
              uint64_t v108 = *(unsigned __int8 *)(v106 + 47);
              if (*(_DWORD *)(v103 + 240) <= v108) {
                sub_1CC34BDE0(v103 + 232, v108 + 1);
              }
              uint64_t v109 = *v104;
              *unint64_t v107 = *(void *)(*v104 + 8 * v108);
              *(void *)(v109 + 8 * v108) = v107;
            }
            *(void *)uint64_t v106 = *(void *)(v103 + 224);
            *(void *)(v103 + 224) = v106;
            v102 += 8;
            v105 -= 8;
            uint64_t v30 = v133;
          }
          while (v105);
        }
        if (v148)
        {
          a1 = v145;
          if (v149 <= 4 * (int)v148 || v149 < 0x41)
          {
            if (v149)
            {
              unint64_t v115 = v147;
              uint64_t v116 = 8 * v149;
              do
              {
                *unint64_t v115 = -1;
                v115 += 2;
                v116 -= 8;
              }
              while (v116);
            }
            int v58 = 0;
            uint64_t v148 = 0;
          }
          else
          {
            sub_1CB83872C(&v147);
            int v58 = 0;
          }
        }
        else
        {
          int v58 = 0;
          a1 = v145;
        }
LABEL_120:
        MEMORY[0x1D25D9CD0](v147, 4);
        if (v169 != v171) {
          free(v169);
        }
        if (__src != v174) {
          free(__src);
        }
        if (v58 != 7 && v58) {
          break;
        }
        uint64_t v48 = v142 + 1;
      }
      while (v142 + 1 != v139);
      uint64_t v48 = (unsigned int *)v175;
LABEL_231:
      uint64_t v44 = (llvm::MachineInstr *)v46;
LABEL_232:
      if (v48 != (unsigned int *)v177)
      {
        uint64_t v122 = v44;
        free(v48);
        uint64_t v44 = v122;
      }
    }
    while (v44 != (llvm::MachineInstr *)v135);
    int v123 = v136;
    if (v136 & v141)
    {
      uint64_t v124 = *(void *)(a1 + 360);
      *(_DWORD *)(*(void *)(v124 + 568) + 8 * *(int *)(v30 + 24)) = -1;
      uint64_t v125 = *(llvm::MachineTraceMetrics::Ensemble **)(v124 + 632);
      if (v125) {
        llvm::MachineTraceMetrics::Ensemble::invalidate(v125, (const llvm::MachineBasicBlock *)v30);
      }
      int v123 = 1;
    }
LABEL_240:
    free(v180);
    if (v178[0] != v179) {
      free(v178[0]);
    }
    int v31 = v129 | v123;
    uint64_t v30 = *(void *)(v30 + 8);
  }
  while ((void *)v30 != v127);
  return v31 & 1;
}

void sub_1CC32E98C(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, llvm::MachineTraceMetrics::Ensemble *a5, uint64_t a6, uint64_t a7, int a8, char a9)
{
  int v45 = a8;
  (*(void (**)(uint64_t, uint64_t *, int *, uint64_t))(*(void *)a7 + 520))(a7, a2, &v45, a3);
  uint64_t v15 = *(unsigned int *)(a3 + 8);
  if (v15)
  {
    uint64_t v16 = *(uint64_t **)a3;
    uint64_t v17 = *(void *)a3 + 8 * v15;
    do
    {
      uint64_t v18 = *v16;
      uint64_t v19 = *(void *)(a1 + 40);
      *(void *)(v18 + 24) = v19;
      uint64_t v20 = *(void *)(v19 + 32);
      uint64_t v21 = *(unsigned int *)(v18 + 40);
      if (v21)
      {
        uint64_t v24 = *(void *)(v18 + 32);
        uint64_t v25 = *(void *)(v20 + 40);
        uint64_t v26 = 32 * v21;
        do
        {
          if (!*(unsigned char *)v24)
          {
            uint64_t v27 = *(unsigned int *)(v24 + 4);
            if ((int)v27 >= 0) {
              size_t v28 = (uint64_t *)(*(void *)(v25 + 272) + 8 * v27);
            }
            else {
              size_t v28 = (uint64_t *)(*(void *)(v25 + 24) + 16 * (v27 & 0x7FFFFFFF) + 8);
            }
            uint64_t v29 = *v28;
            if (*v28)
            {
              uint64_t v30 = *(void *)(v29 + 16);
              *(void *)(v29 + 16) = v24;
              *(void *)(v24 + 16) = v30;
              if (*(unsigned char *)(v24 + 3))
              {
                *(void *)(v24 + 24) = v29;
              }
              else
              {
                *(void *)(v24 + 24) = 0;
                size_t v28 = (uint64_t *)(v30 + 24);
              }
            }
            else
            {
              *(void *)(v24 + 16) = v24;
              *(void *)(v24 + 24) = 0;
            }
            *size_t v28 = v24;
          }
          v24 += 32;
          v26 -= 32;
        }
        while (v26);
      }
      uint64_t v22 = *(void *)(v20 + 728);
      if (v22) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v22 + 24))(v22, v18);
      }
      unint64_t v23 = *a2 & 0xFFFFFFFFFFFFFFF8;
      *(void *)uint64_t v18 = v23 | *(void *)v18 & 7;
      *(void *)(v18 + 8) = a2;
      *(void *)(v23 + 8) = v18;
      *a2 = *a2 & 7 | v18;
      ++v16;
    }
    while (v16 != (uint64_t *)v17);
  }
  uint64_t v31 = *(unsigned int *)(a4 + 8);
  if (v31)
  {
    uint64_t v32 = *(llvm::MachineInstr ***)a4;
    uint64_t v33 = *(void *)a4 + 8 * v31;
    do
    {
      uint64_t v34 = *v32;
      llvm::MachineInstr::eraseFromParent(*v32);
      unsigned int v35 = *(_DWORD *)(a6 + 8);
      if (v35)
      {
        uint64_t v36 = *(void *)a6;
        uint64_t v37 = *(void *)a6 + 24 * v35;
        uint64_t v38 = *(void *)a6;
        do
        {
          if (*(llvm::MachineInstr **)(v38 + 8) == v34)
          {
            uint64_t v39 = v37 - 24;
            if (v39 != v38)
            {
              long long v40 = *(_OWORD *)v39;
              *(_DWORD *)(v38 + 16) = *(_DWORD *)(v39 + 16);
              *(_OWORD *)uint64_t v38 = v40;
              *(unsigned char *)(*(void *)(a6 + 208) + *(unsigned int *)(*(void *)a6 + 24 * *(unsigned int *)(a6 + 8) - 24)) = -85 * ((v38 - *(void *)a6) >> 3);
              unsigned int v35 = *(_DWORD *)(a6 + 8);
              uint64_t v36 = *(void *)a6;
            }
            *(_DWORD *)(a6 + 8) = --v35;
          }
          else
          {
            v38 += 24;
          }
          uint64_t v37 = v36 + 24 * v35;
        }
        while (v38 != v37);
      }
      ++v32;
    }
    while (v32 != (llvm::MachineInstr **)v33);
  }
  if (a9)
  {
    uint64_t v41 = *(unsigned int *)(a3 + 8);
    if (v41)
    {
      int v42 = *(uint64_t **)a3;
      uint64_t v43 = 8 * v41;
      do
      {
        uint64_t v44 = *v42++;
        llvm::MachineTraceMetrics::Ensemble::updateDepth(a5, *((void *)a5 + 1) + 88 * *(int *)(a1 + 24), v44, a6);
        v43 -= 8;
      }
      while (v43);
    }
  }
  else
  {
    llvm::MachineTraceMetrics::Ensemble::invalidate(a5, (const llvm::MachineBasicBlock *)a1);
  }
}

uint64_t sub_1CC32EC3C(uint64_t a1, llvm::MachineInstr *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = *(unsigned int *)(a3 + 8);
  uint64_t v11 = *(void *)(*(void *)a3 + 8 * v10 - 8);
  if (v10 == 1)
  {
    int v12 = 0;
  }
  else
  {
    uint64_t v14 = 0;
    int v12 = 0;
    unsigned int v15 = 1;
    do
    {
      v12 += llvm::TargetSchedModel::computeInstrLatency((llvm::TargetSchedModel *)(a1 + 632), *(const llvm::MachineInstr **)(*(void *)a3 + 8 * v14), 1);
      uint64_t v14 = v15;
    }
    while ((unint64_t)*(unsigned int *)(a3 + 8) - 1 > v15++);
  }
  v36[0] = a5;
  v36[1] = a6;
  uint64_t v17 = *(unsigned int *)(v11 + 40);
  if (v17)
  {
    unsigned int v18 = 0;
    uint64_t v19 = 32 * v17;
    uint64_t v20 = (unsigned int *)(*(void *)(v11 + 32) + 4);
    do
    {
      if (!*(v20 - 1) && (*(v20 - 1) & 0x1000000) != 0)
      {
        unsigned int v21 = *v20;
        if ((*v20 & 0x80000000) != 0)
        {
          uint64_t v22 = *(void *)(*(void *)(*(void *)(*(void *)(a1 + 344) + 24) + 16 * (v21 & 0x7FFFFFFF) + 8) + 24);
          if (v22)
          {
            unint64_t v23 = *(const llvm::MachineInstr **)(v22 + 8);
            if (v23
              && llvm::MachineTraceMetrics::Trace::isDepInTrace((llvm::MachineTraceMetrics::Trace *)v36, a2, *(const llvm::MachineInstr **)(v22 + 8)))
            {
              uint64_t RegisterDefOperandIdx = llvm::MachineInstr::findRegisterDefOperandIdx(v11, v21, 0, 0, 0);
              uint64_t RegisterUseOperandIdx = llvm::MachineInstr::findRegisterUseOperandIdx((uint64_t)v23, *v20, 0, 0);
              unsigned int v26 = llvm::TargetSchedModel::computeOperandLatency((llvm::TargetSchedModel *)(a1 + 632), (const llvm::MachineInstr *)v11, RegisterDefOperandIdx, v23, RegisterUseOperandIdx);
            }
            else
            {
              unsigned int v26 = llvm::TargetSchedModel::computeInstrLatency((llvm::TargetSchedModel *)(a1 + 632), (const llvm::MachineInstr *)v11, 1);
            }
            if (v18 <= v26) {
              unsigned int v18 = v26;
            }
          }
        }
      }
      v20 += 8;
      v19 -= 32;
    }
    while (v19);
  }
  else
  {
    unsigned int v18 = 0;
  }
  uint64_t v27 = *(unsigned int *)(a4 + 8);
  if (v27)
  {
    LODWORD(v28) = 0;
    uint64_t v29 = *(const llvm::MachineInstr ***)a4;
    uint64_t v30 = (llvm::TargetSchedModel *)(a1 + 632);
    uint64_t v31 = 8 * v27;
    do
    {
      uint64_t v32 = *v29++;
      uint64_t v28 = llvm::TargetSchedModel::computeInstrLatency(v30, v32, 1) + v28;
      v31 -= 8;
    }
    while (v31);
    uint64_t v33 = v28 << 32;
  }
  else
  {
    uint64_t v33 = 0;
  }
  return v33 | (v18 + v12);
}

uint64_t sub_1CC32EE30(uint64_t result, uint64_t a2, unsigned int a3, uint64_t a4)
{
  if (a3)
  {
    unsigned int v5 = *(_DWORD *)(a4 + 8);
    uint64_t v6 = 8 * a3;
    do
    {
      if (v5 >= *(_DWORD *)(a4 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a4 + 8 * v5) = *(void *)(result + 312)
                                            + 24
                                            * *(unsigned __int16 *)(*(void *)(*(void *)(result + 256) + 8)
                                                                  + 48 * **(unsigned __int16 **)(*(void *)a2 + 16)
                                                                  + 6);
      unsigned int v5 = *(_DWORD *)(a4 + 8) + 1;
      *(_DWORD *)(a4 + 8) = v5;
      a2 += 8;
      v6 -= 8;
    }
    while (v6);
  }
  return result;
}

uint64_t sub_1CC32EF0C()
{
  int v4 = 1;
  v3.n128_u64[0] = (unint64_t)"Incremental depth computation will be used for basic blocks with more instructions.";
  v3.n128_u64[1] = 83;
  int v1 = 500;
  int v2 = &v1;
  sub_1CD413D64((uint64_t)&unk_1EBCCE560, "machine-combiner-inc-threshold", &v4, &v3, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCCE560, &dword_1CB82C000);
  int v4 = 1;
  v3.n128_u64[0] = (unint64_t)"Dump all substituted intrs";
  v3.n128_u64[1] = 26;
  LOBYTE(v1) = 0;
  int v2 = &v1;
  sub_1CD413E90((llvm::cl::Option *)&unk_1EBCCE620, "machine-combiner-dump-subst-intrs", &v4, &v3, (unsigned char **)&v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCCE620, &dword_1CB82C000);
  int v4 = 1;
  v3.n128_u64[0] = (unint64_t)"Verify that the generated patterns are ordered by increasing latency";
  v3.n128_u64[1] = 68;
  LOBYTE(v1) = 0;
  int v2 = &v1;
  sub_1CD52A7FC(&v4, &v3, (char **)&v2);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCCE6E0, &dword_1CB82C000);
}

void sub_1CC32F048()
{
}

void sub_1CC32F0E4()
{
}

void sub_1CC32F23C(uint64_t a1)
{
  *(void *)a1 = &unk_1F260D930;
  uint64_t v2 = *(unsigned int *)(a1 + 464);
  uint64_t v3 = *(void *)(a1 + 448);
  if (v2)
  {
    uint64_t v4 = 56 * v2;
    unsigned int v5 = (void *)(v3 + 32);
    do
    {
      if (*((_DWORD *)v5 - 8) <= 0xFFFFFFFD)
      {
        uint64_t v6 = (void *)*(v5 - 2);
        if (v5 != v6) {
          free(v6);
        }
      }
      v5 += 7;
      v4 -= 56;
    }
    while (v4);
    uint64_t v3 = *(void *)(a1 + 448);
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  sub_1CC330830((unsigned int *)(a1 + 424));
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 424), 8);
  long long v7 = *(void **)(a1 + 344);
  if (v7 != (void *)(a1 + 360)) {
    free(v7);
  }
  if ((*(unsigned char *)(a1 + 272) & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 280), 8);
  }
  *(void *)a1 = &unk_1F260E110;
  long long v8 = *(void **)(a1 + 176);
  if (v8 != (void *)(a1 + 192)) {
    free(v8);
  }
  long long v9 = *(void **)(a1 + 104);
  if (v9 != (void *)(a1 + 120)) {
    free(v9);
  }
  uint64_t v10 = *(void **)(a1 + 32);
  if (v10 != (void *)(a1 + 48)) {
    free(v10);
  }

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1CC32F384(uint64_t a1)
{
  sub_1CC32F23C(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC32F3BC(llvm::PassRegistry *a1, uint64_t a2)
{
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)a1, a2);
}

BOOL sub_1CC32F430(uint64_t a1, uint64_t a2)
{
  v237[6] = *MEMORY[0x1E4F143B8];
  if (llvm::FunctionPass::skipFunction((llvm::FunctionPass *)a1, *(llvm::LLVMContextImpl *****)a2)) {
    return 0;
  }
  *(unsigned char *)(a1 + 472) = 0;
  *(void *)(a1 + 248) = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 176))(*(void *)(a2 + 16));
  *(void *)(a1 + 256) = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 104))(*(void *)(a2 + 16));
  *(void *)(a1 + 264) = *(void *)(a2 + 40);
  unsigned int v5 = *(void **)(a2 + 328);
  uint64_t v225 = (void *)(a2 + 320);
  if (v5 != (void *)(a2 + 320))
  {
    uint64_t v230 = (char *)(a1 + 272);
    unsigned int v227 = (uint64_t **)(a1 + 344);
    uint64_t v224 = (void **)(a1 + 280);
    uint64_t v233 = (unsigned int *)(a1 + 424);
    uint64_t v232 = (int32x2_t *)(a1 + 448);
    while (1)
    {
      uint64_t v226 = v5;
      unint64_t v229 = v5 + 6;
      unint64_t v6 = v5[6] & 0xFFFFFFFFFFFFFFF8;
      if (!v6 || (*(unsigned char *)v6 & 4) == 0)
      {
        while ((*(_WORD *)(v6 + 44) & 4) != 0)
          unint64_t v6 = *(void *)v6 & 0xFFFFFFFFFFFFFFF8;
      }
      while (2)
      {
        if ((void *)v6 != v229)
        {
          uint64_t v7 = v6;
          unint64_t v6 = *(void *)v6 & 0xFFFFFFFFFFFFFFF8;
          if (!v6 || (*(unsigned char *)v6 & 4) == 0)
          {
            while ((*(_WORD *)(v6 + 44) & 4) != 0)
              unint64_t v6 = *(void *)v6 & 0xFFFFFFFFFFFFFFF8;
          }
          uint64_t v8 = *(unsigned int *)(v7 + 40);
          if (**(_WORD **)(v7 + 16) != 19 || v8 != 2)
          {
            if (!v8) {
              continue;
            }
            uint64_t v10 = *(_DWORD **)(v7 + 32);
            unsigned int v231 = (int **)(v7 + 32);
            uint64_t v11 = (uint64_t)&v10[8 * v8];
            do
            {
LABEL_35:
              if ((*v10 & 0x400000FF) == 0x40000000)
              {
                unsigned int v20 = v10[1];
                if (v20) {
                  sub_1CC3308A4(v232, v20, *(void *)(a1 + 248));
                }
              }
              v10 += 8;
            }
            while (v10 != (_DWORD *)v11);
            uint64_t v21 = *(unsigned int *)(v7 + 40);
            if (!*(_DWORD *)(a1 + 456))
            {
              uint64_t v22 = v231;
              if (!*(_DWORD *)(v7 + 40)) {
                continue;
              }
              goto LABEL_132;
            }
            uint64_t v22 = v231;
            if (!*(_DWORD *)(v7 + 40)) {
              continue;
            }
            uint64_t v23 = 0;
LABEL_42:
            uint64_t v24 = (unsigned int *)&(*v22)[8 * v23];
            unsigned int v25 = *v24;
            if ((*v24 & 0x13F000FF) != 0x1000000 || (v25 & 0x8000000) == 0 || (unsigned int v26 = v24 + 1, !v24[1]))
            {
LABEL_117:
              if (++v23 == v21)
              {
                uint64_t v21 = *(unsigned int *)(v7 + 40);
                if (!*(_DWORD *)(v7 + 40)) {
                  continue;
                }
LABEL_132:
                unsigned int v81 = *v22;
                uint64_t v82 = (uint64_t)&(*v22)[8 * v21];
LABEL_133:
                int v83 = *v81;
                if (*v81) {
                  goto LABEL_134;
                }
                unsigned int v84 = v81[1];
                if (!v84) {
                  goto LABEL_134;
                }
                if ((v83 & 0x1000000) != 0)
                {
                  sub_1CC3308A4(v232, v84, *(void *)(a1 + 248));
                  int v83 = *v81;
                }
                if ((v83 & 0x30000000) != 0 || (v83 & 0x10FFF00) == 0x1000000)
                {
LABEL_134:
                  v81 += 8;
                  if (v81 == (int *)v82) {
                    continue;
                  }
                  goto LABEL_133;
                }
                unsigned int v86 = v81[1];
                uint64_t v87 = *(void *)(a1 + 248);
                if ((v83 & 0x80000000) == 0)
                {
                  sub_1CC3308A4(v232, v86, v87);
                  goto LABEL_134;
                }
                uint64_t v88 = (void *)(v87 + 8);
                if (!v87) {
                  uint64_t v88 = 0;
                }
                unint64_t v89 = *(unsigned int *)(*v88 + 24 * v86 + 16);
                uint64_t v90 = (_WORD *)(v88[6] + ((v89 >> 3) & 0x1FFFFFFE));
                unsigned __int16 v91 = *v90 + (v89 & 0xF) * v86;
                while (2)
                {
                  int64_t v235 = (void *)sub_1CC331120(*(void *)(a1 + 448), *(_DWORD *)(a1 + 464), v91, *(void *)(*(void *)(a1 + 248) + 8), *(void *)(*(void *)(a1 + 248) + 56));
                  if (!v235)
                  {
LABEL_181:
                    int v111 = (unsigned __int16)v90[1];
                    ++v90;
                    v91 += v111;
                    if (!v111) {
                      goto LABEL_134;
                    }
                    continue;
                  }
                  break;
                }
                sub_1CC331A70((uint64_t)v233, (uint64_t *)&v235);
                uint64_t v93 = v92;
                uint64_t v95 = *(void *)(v92 + 8);
                uint64_t v94 = (llvm::SmallPtrSetImplBase *)(v92 + 8);
                uint64_t v96 = *(void *)(v93 + 16);
                uint64_t v97 = *(unsigned int *)(v93 + 28);
                if (v96 == v95)
                {
                  if (v97)
                  {
                    uint64_t v98 = 0;
                    uint64_t v99 = 8 * v97;
                    unsigned int v100 = *(uint64_t **)(v93 + 16);
                    while (*v100 != v7)
                    {
                      if (*v100 == -2) {
                        uint64_t v98 = v100;
                      }
                      ++v100;
                      v99 -= 8;
                      if (!v99)
                      {
                        if (!v98) {
                          goto LABEL_157;
                        }
                        *uint64_t v98 = v7;
                        --*(_DWORD *)(v93 + 32);
                        goto LABEL_181;
                      }
                    }
                    goto LABEL_181;
                  }
LABEL_157:
                  unsigned int v101 = *(_DWORD *)(v93 + 24);
                  if (v97 < v101)
                  {
                    *(_DWORD *)(v93 + 28) = v97 + 1;
                    *(void *)(v96 + 8 * v97) = v7;
                    goto LABEL_181;
                  }
                }
                else
                {
                  unsigned int v101 = *(_DWORD *)(v93 + 24);
                }
                if (3 * v101 <= 4 * ((int)v97 - *(_DWORD *)(v93 + 32)))
                {
                  if (v101 >= 0x40) {
                    v101 *= 2;
                  }
                  else {
                    unsigned int v101 = 128;
                  }
                }
                else if (v101 - v97 >= v101 >> 3)
                {
                  goto LABEL_162;
                }
                llvm::SmallPtrSetImplBase::Grow(v94, v101);
                unsigned int v101 = *(_DWORD *)(v93 + 24);
                uint64_t v96 = *(void *)(v93 + 16);
LABEL_162:
                unsigned int v102 = v101 - 1;
                unsigned int v103 = (v101 - 1) & ((v7 >> 4) ^ (v7 >> 9));
                uint64_t v104 = (uint64_t *)(v96 + 8 * v103);
                uint64_t v105 = *v104;
                if (*v104 == -1)
                {
                  uint64_t v106 = 0;
LABEL_174:
                  if (v106) {
                    unsigned int v110 = v106;
                  }
                  else {
                    unsigned int v110 = v104;
                  }
                  if (*v110 != v7)
                  {
                    if (*v110 == -2) {
                      --*(_DWORD *)(v93 + 32);
                    }
                    else {
                      ++*(_DWORD *)(v93 + 28);
                    }
                    *unsigned int v110 = v7;
                  }
                }
                else
                {
                  uint64_t v106 = 0;
                  int v107 = 1;
                  while (v105 != v7)
                  {
                    if (v106) {
                      BOOL v108 = 0;
                    }
                    else {
                      BOOL v108 = v105 == -2;
                    }
                    if (v108) {
                      uint64_t v106 = v104;
                    }
                    unsigned int v109 = v103 + v107++;
                    unsigned int v103 = v109 & v102;
                    uint64_t v104 = (uint64_t *)(v96 + 8 * (v109 & v102));
                    uint64_t v105 = *v104;
                    if (*v104 == -1) {
                      goto LABEL_174;
                    }
                  }
                }
                goto LABEL_181;
              }
              goto LABEL_42;
            }
            uint64_t v27 = *(void *)&(*v22)[8 * v23 + 2];
            if (v27)
            {
              uint64_t v28 = *(void *)(*(void *)(v27 + 16) + 8);
              if ((v25 & 0x1000000) != 0)
              {
                if ((v28 & 0x100000000) != 0) {
                  goto LABEL_117;
                }
              }
              else if ((v28 & 0x80000000) != 0)
              {
                goto LABEL_117;
              }
            }
            int64_t v235 = 0;
            unsigned int v29 = *v26;
            uint64_t v30 = *(uint64_t **)(a1 + 248);
            uint64_t v31 = v30[1];
            unint64_t v32 = *(unsigned int *)(v31 + 24 * *v26 + 16);
            unint64_t v228 = (llvm::TargetRegisterInfo *)v30;
            uint64_t v33 = v30[7];
            uint64_t v34 = (void *)sub_1CC331120(*(void *)(a1 + 448), *(_DWORD *)(a1 + 464), (unsigned __int16)(*(_WORD *)(v33 + ((v32 >> 3) & 0x1FFFFFFE)) + (v32 & 0xF) * *v26), v31, v33);
            if (v34)
            {
              uint64_t v35 = v34[4];
              unint64_t v36 = *(unsigned int *)(v35 + 36);
              if (v36 == v29) {
                goto LABEL_63;
              }
              uint64_t v37 = (_WORD *)(v33 + 2 * *(unsigned int *)(v31 + 24 * v29 + 8));
              BOOL v38 = *v37 != 0;
              if (*v37)
              {
                unsigned __int16 v39 = *v37 + v29;
                if (v36 != v39)
                {
                  long long v40 = v37 + 1;
                  do
                  {
                    int v42 = *v40++;
                    int v41 = v42;
                    v39 += v42;
                    BOOL v38 = v42 != 0;
                    if (!v42) {
                      long long v40 = 0;
                    }
                    if (v41) {
                      BOOL v43 = v36 == v39;
                    }
                    else {
                      BOOL v43 = 1;
                    }
                  }
                  while (!v43);
                }
              }
              if (v38)
              {
LABEL_63:
                if (v34 != (void *)v7)
                {
                  unint64_t v44 = *(unsigned int *)(v35 + 4);
                  unint64_t v45 = v44 >> 5;
                  int v46 = 1 << v44;
                  unint64_t v47 = (unint64_t)v34;
                  while (1)
                  {
                    uint64_t v48 = *(unsigned int *)(v47 + 40);
                    if (v48) {
                      break;
                    }
LABEL_71:
                    unint64_t v47 = *(void *)v47 & 0xFFFFFFFFFFFFFFF8;
                    if (v7 == v47) {
                      goto LABEL_72;
                    }
                  }
                  uint64_t v49 = 32 * v48;
                  uint64_t v50 = (void *)(*(void *)(v47 + 32) + 16);
                  while (*((unsigned char *)v50 - 16) != 12
                       || (*(_DWORD *)(*v50 + 4 * (v36 >> 5)) & (1 << v36)) != 0
                       && (*(_DWORD *)(*v50 + 4 * v45) & v46) != 0)
                  {
                    v50 += 4;
                    v49 -= 32;
                    if (!v49) {
                      goto LABEL_71;
                    }
                  }
                  goto LABEL_116;
                }
LABEL_72:
                int64_t v235 = v34;
                if (*v26 == v36)
                {
                  unint64_t v51 = *(unsigned int *)(v35 + 4);
                  uint64_t RegClassConstraint = llvm::MachineInstr::getRegClassConstraint((llvm::MachineInstr *)v7, v23, *(const llvm::TargetInstrInfo **)(a1 + 256), v228);
                  if (RegClassConstraint)
                  {
                    if ((v51 - 1) <= 0x3FFFFFFE
                      && (v51 >> 3) < *(unsigned __int16 *)(*(void *)RegClassConstraint + 22)
                      && ((*(unsigned __int8 *)(*(void *)(*(void *)RegClassConstraint + 8) + (v51 >> 3)) >> (v51 & 7)) & 1) != 0
                      && (sub_1CC3318A4(a1, v7, v24) & 1) == 0)
                    {
                      uint64_t v53 = *(unsigned int **)(v7 + 32);
                      uint64_t v54 = *(void *)(v7 + 16);
                      unsigned int v55 = *(unsigned __int8 *)(v54 + 4);
                      if ((*(unsigned char *)(v54 + 8) & 2) == 0 || (int v78 = *(_DWORD *)(v7 + 40), v78 == v55))
                      {
                        unsigned int v56 = v55;
                      }
                      else
                      {
                        int v79 = v78 - 1;
                        unsigned int v56 = v55;
                        do
                        {
                          unsigned int v80 = v53[8 * v55];
                          if ((v80 & 0x10000FF) != 0x1000000) {
                            break;
                          }
                          v56 += (v80 & 0x2000000) == 0;
                          if (v79 == v55) {
                            break;
                          }
                          ++v55;
                        }
                        while ((v80 & 0x2000000) == 0);
                      }
                      if (v56)
                      {
                        uint64_t v57 = 32 * v56;
                        do
                        {
                          if (v53 != v24 && !*(unsigned char *)v53)
                          {
                            unsigned int v58 = v53[1];
                            if (v58 == v51
                              || v58 - 1 <= 0x3FFFFFFE
                              && llvm::MCRegisterInfo::regsOverlap((void *)(*(void *)(a1 + 248) + 8), v51, v58))
                            {
                              goto LABEL_116;
                            }
                          }
                          v53 += 8;
                          v57 -= 32;
                        }
                        while (v57);
                      }
                      llvm::MachineOperand::setReg((uint64_t)v24, v51);
                      uint64_t v59 = (int *)*((void *)v235 + 4);
                      int v60 = *v59;
                      if ((*v59 & 0x8000000) != 0)
                      {
                        uint64_t v61 = *((void *)v59 + 1);
                        if (v61)
                        {
                          uint64_t v62 = *(void *)(*(void *)(v61 + 16) + 8);
                          unsigned int v63 = *v24;
                          if ((v60 & 0x1000000) != 0)
                          {
                            if ((v62 & 0x100000000) != 0) {
                              goto LABEL_95;
                            }
                          }
                          else if ((v62 & 0x80000000) != 0)
                          {
LABEL_95:
                            int v64 = 0;
                            goto LABEL_96;
                          }
                        }
                        else
                        {
                          unsigned int v63 = *v24;
                        }
                        int v64 = 0x8000000;
                        goto LABEL_96;
                      }
                      int v64 = 0;
                      unsigned int v63 = *v24;
LABEL_96:
                      *uint64_t v24 = v63 & 0xF7FFFFFF | v64;
                      if (*v230)
                      {
                        int v65 = 8;
                        uint64_t v66 = a1 + 280;
LABEL_100:
                        int v67 = v65 - 1;
                        unsigned int v68 = ((v235 >> 4) ^ (v235 >> 9)) & v67;
                        unsigned int v69 = (void *)(v66 + 8 * v68);
                        BOOL v70 = (void *)*v69;
                        if (v235 != (void *)*v69)
                        {
                          unsigned int v71 = 0;
                          int v72 = 1;
                          while (v70 != (void *)-4096)
                          {
                            if (v71) {
                              BOOL v73 = 0;
                            }
                            else {
                              BOOL v73 = v70 == (void *)-8192;
                            }
                            if (v73) {
                              unsigned int v71 = v69;
                            }
                            unsigned int v74 = v68 + v72++;
                            unsigned int v68 = v74 & v67;
                            unsigned int v69 = (void *)(v66 + 8 * v68);
                            BOOL v70 = (void *)*v69;
                            if (v235 == (void *)*v69) {
                              goto LABEL_115;
                            }
                          }
                          if (v71) {
                            BOOL v75 = v71;
                          }
                          else {
                            BOOL v75 = v69;
                          }
                          goto LABEL_113;
                        }
                      }
                      else
                      {
                        int v65 = *(_DWORD *)(a1 + 288);
                        if (v65)
                        {
                          uint64_t v66 = *(void *)(a1 + 280);
                          goto LABEL_100;
                        }
                        BOOL v75 = 0;
LABEL_113:
                        unsigned int v76 = sub_1CB938A98((uint64_t)v230, (uint64_t)&v235, &v235, v75);
                        *unsigned int v76 = v235;
                        unint64_t v77 = *(unsigned int *)(a1 + 352);
                        if (v77 >= *(unsigned int *)(a1 + 356)) {
                          llvm::SmallVectorBase<unsigned int>::grow_pod();
                        }
                        *(void *)(*(void *)(a1 + 344) + 8 * v77) = v235;
                        ++*(_DWORD *)(a1 + 352);
                      }
LABEL_115:
                      *(unsigned char *)(a1 + 472) = 1;
                    }
                  }
                }
              }
            }
LABEL_116:
            uint64_t v22 = v231;
            goto LABEL_117;
          }
          uint64_t v13 = (_DWORD **)(v7 + 32);
          uint64_t v12 = *(void *)(v7 + 32);
          unint64_t v14 = *(unsigned int *)(v12 + 4);
          unint64_t v15 = *(unsigned int *)(v12 + 36);
          if (v14 == v15) {
            goto LABEL_34;
          }
          uint64_t v16 = *(void *)(a1 + 248);
          BOOL v17 = (v14 - 1) > 0x3FFFFFFE || (v15 - 1) > 0x3FFFFFFE;
          if (!v17
            && llvm::MCRegisterInfo::regsOverlap((void *)(v16 + 8), *(_DWORD *)(v12 + 4), *(_DWORD *)(v12 + 36)))
          {
            goto LABEL_34;
          }
          if (!v14 || v15 == 0) {
            goto LABEL_34;
          }
          uint64_t v19 = *(void *)(*(void *)(a1 + 264) + 352);
          if ((*(void *)(v19 + ((v14 >> 3) & 0x1FFFFFF8)) >> v14)) {
            goto LABEL_34;
          }
          if ((*(void *)(v19 + ((v15 >> 3) & 0x1FFFFFF8)) >> v15)) {
            goto LABEL_34;
          }
          unsigned int v112 = *(_DWORD *)(v12 + 32);
          if ((v112 & 0x8000000) == 0) {
            goto LABEL_34;
          }
          uint64_t v113 = *(void *)(v12 + 40);
          if (v113)
          {
            uint64_t v114 = *(void *)(*(void *)(v113 + 16) + 8);
            if ((v112 & 0x1000000) == 0)
            {
              if ((v114 & 0x80000000) == 0) {
                goto LABEL_195;
              }
LABEL_34:
              unsigned int v231 = (int **)(v7 + 32);
              uint64_t v10 = *v13;
              uint64_t v11 = (uint64_t)(*v13 + 16);
              goto LABEL_35;
            }
            if ((v114 & 0x100000000) != 0) {
              goto LABEL_34;
            }
          }
LABEL_195:
          if ((v112 >> 26) & ~HIBYTE(v112))
          {
            sub_1CC3308A4(v232, v15, v16);
            sub_1CC3308A4(v232, v14, *(void *)(a1 + 248));
            sub_1CC330BEC((uint64_t)v232, v7, *(void *)(a1 + 248));
            continue;
          }
          goto LABEL_34;
        }
        break;
      }
      uint64_t v115 = *(unsigned int *)(a1 + 352);
      if (v115)
      {
        uint64_t v116 = *(llvm::MachineInstr ***)(a1 + 344);
        unint64_t v117 = &v116[v115];
        do
        {
          int v118 = *v116;
          uint64_t v234 = v118;
          uint64_t v119 = *((void *)v118 + 4);
          int v120 = *(_DWORD *)(v119 + 36);
          int v121 = *(_DWORD *)(v119 + 4);
          sub_1CC331A70((uint64_t)v233, (uint64_t *)&v234);
          int v123 = *(unint64_t **)(v122 + 16);
          if (v123 == *(unint64_t **)(v122 + 8)) {
            uint64_t v124 = (unsigned int *)(v122 + 28);
          }
          else {
            uint64_t v124 = (unsigned int *)(v122 + 24);
          }
          uint64_t v125 = *v124;
          uint64_t v126 = &v123[v125];
          if (v125)
          {
            uint64_t v127 = 8 * v125;
            while (*v123 >= 0xFFFFFFFFFFFFFFFELL)
            {
              ++v123;
              v127 -= 8;
              if (!v127)
              {
                int v123 = v126;
                break;
              }
            }
          }
          sub_1CC331A70((uint64_t)v233, (uint64_t *)&v234);
          uint64_t v129 = *(void *)(v128 + 16);
          if (v129 == *(void *)(v128 + 8)) {
            uint64_t v130 = (unsigned int *)(v128 + 28);
          }
          else {
            uint64_t v130 = (unsigned int *)(v128 + 24);
          }
          uint64_t v131 = (unint64_t *)(v129 + 8 * *v130);
          int64_t v235 = v237;
          uint64_t v236 = 0x600000000;
          sub_1CC331CE4((uint64_t)&v235, v123, v126, v131);
          sub_1CC3311D4(*(void *)(a1 + 264), v120, v121, (uint64_t *)v235, v236);
          llvm::MachineInstr::eraseFromParent(v118);
          if (v235 != v237) {
            free(v235);
          }
          ++v116;
        }
        while (v116 != v117);
      }
      int v132 = *(_DWORD *)v230;
      if (*(_DWORD *)v230 > 1u || *(_DWORD *)(a1 + 276)) {
        break;
      }
LABEL_216:
      *(_DWORD *)(a1 + 352) = 0;
      int v133 = *(_DWORD *)(a1 + 432);
      if (v133 || *(_DWORD *)(a1 + 436))
      {
        uint64_t v216 = *(unsigned int *)(a1 + 440);
        if (v216 > 4 * v133 && v216 >= 0x41)
        {
          sub_1CD52ABA0(v233);
        }
        else
        {
          if (v216)
          {
            BOOL v217 = *(void **)v233;
            uint64_t v218 = 56 * v216;
            do
            {
              if (*v217 != -4096)
              {
                if (*v217 != -8192)
                {
                  unint64_t v219 = (void *)v217[2];
                  if (v219 != (void *)v217[1]) {
                    free(v219);
                  }
                }
                void *v217 = -4096;
              }
              v217 += 7;
              v218 -= 56;
            }
            while (v218);
          }
          *(void *)(a1 + 432) = 0;
        }
      }
      sub_1CC3312A0((uint64_t)v232);
      uint64_t v134 = v226[7];
      if ((void *)v134 != v229)
      {
        while (1)
        {
          if (!v134 || (uint64_t v135 = v134, (*(unsigned char *)v134 & 4) == 0))
          {
            uint64_t v135 = v134;
            if ((*(_WORD *)(v134 + 44) & 8) != 0)
            {
              uint64_t v135 = v134;
              do
                uint64_t v135 = *(void *)(v135 + 8);
              while ((*(_WORD *)(v135 + 44) & 8) != 0);
            }
          }
          uint64_t v136 = *(void *)(v135 + 8);
          if (**(_WORD **)(v134 + 16) != 19)
          {
            uint64_t v137 = *(void *)(v134 + 32);
LABEL_247:
            uint64_t v152 = *(unsigned int *)(v134 + 40);
            if (v152)
            {
              uint64_t v153 = 32 * v152;
              unsigned int v154 = (unsigned int *)(v137 + 4);
              do
              {
                int v155 = *(v154 - 1);
                if ((v155 & 0x400000FF) == 0x40000000)
                {
                  unsigned int v156 = *v154;
                  if ((v155 & 0xF00000) != 0) {
                    sub_1CC3325C4(a1, *v154, v134, 1);
                  }
                  sub_1CC332860(v232, v156, *(void *)(a1 + 248));
                }
                v154 += 8;
                v153 -= 32;
              }
              while (v153);
            }
            sub_1CC332144(a1, v134);
            int64_t v235 = v237;
            uint64_t v236 = 0x200000000;
            uint64_t v157 = *(unsigned int *)(v134 + 40);
            if (v157)
            {
              uint64_t v158 = 0;
              unint64_t v159 = *(_DWORD **)(v134 + 32);
              uint64_t v160 = 32 * v157;
              do
              {
                int v161 = *v159;
                if (*v159 == 12) {
                  uint64_t v158 = v159;
                }
                if (!*v159)
                {
                  int v162 = v159[1];
                  if (v162)
                  {
                    if ((v161 & 0x41000000) == 0x1000000)
                    {
                      if (v236 >= (unint64_t)HIDWORD(v236)) {
                        llvm::SmallVectorBase<unsigned int>::grow_pod();
                      }
                      *((_DWORD *)v235 + v236) = v162;
                      LODWORD(v236) = v236 + 1;
                    }
                    else if ((v161 & 0x30000000) == 0 && (v161 & 0x10FFF00) != 0x1000000)
                    {
                      sub_1CC3325C4(a1, v159[1], v134, v161 >= 0);
                    }
                  }
                }
                v159 += 8;
                v160 -= 32;
              }
              while (v160);
              if (v158)
              {
                uint64_t v163 = *(unsigned int *)(a1 + 352);
                if (v163)
                {
                  uint64_t v164 = *v227;
                  uint64_t v165 = *v227;
                  do
                  {
                    uint64_t v166 = (llvm::MachineInstr *)*v165;
                    unint64_t v167 = *(unsigned int *)(*(void *)(*v165 + 32) + 4);
                    if ((*(_DWORD *)(*((void *)v158 + 2) + ((v167 >> 3) & 0x1FFFFFFC)) >> v167))
                    {
                      ++v165;
                    }
                    else
                    {
                      sub_1CC332860(v232, v167, *(void *)(a1 + 248));
                      sub_1CC332B30((uint64_t)v230, *v165);
                      uint64_t v168 = *(unsigned int *)(a1 + 352);
                      uint64_t v169 = *(void *)(a1 + 344) + 8 * v168;
                      if ((uint64_t *)v169 != v165 + 1)
                      {
                        memmove(v165, v165 + 1, v169 - (void)(v165 + 1));
                        LODWORD(v168) = *(_DWORD *)(a1 + 352);
                      }
                      *(_DWORD *)(a1 + 352) = v168 - 1;
                      llvm::MachineInstr::eraseFromParent(v166);
                      *(unsigned char *)(a1 + 472) = 1;
                      uint64_t v164 = *(uint64_t **)(a1 + 344);
                      uint64_t v163 = *(unsigned int *)(a1 + 352);
                    }
                  }
                  while (v165 != &v164[v163]);
                }
              }
            }
            uint64_t v170 = (unsigned int *)v235;
            if (v236)
            {
              uint64_t v171 = 4 * v236;
              do
              {
                unsigned int v172 = *v170++;
                sub_1CC332860(v232, v172, *(void *)(a1 + 248));
                v171 -= 4;
              }
              while (v171);
              uint64_t v170 = (unsigned int *)v235;
            }
            if (v170 != (unsigned int *)v237) {
              free(v170);
            }
            goto LABEL_284;
          }
          uint64_t v137 = *(void *)(v134 + 32);
          unint64_t v138 = *(unsigned int *)(v137 + 4);
          unsigned int v139 = *(_DWORD *)(v137 + 36);
          if (v138 == v139) {
            goto LABEL_247;
          }
          BOOL v140 = (v138 - 1) > 0x3FFFFFFE || v139 - 1 > 0x3FFFFFFE;
          if (!v140
            && llvm::MCRegisterInfo::regsOverlap((void *)(*(void *)(a1 + 248) + 8), *(_DWORD *)(v137 + 4), *(_DWORD *)(v137 + 36)))
          {
            goto LABEL_247;
          }
          if ((sub_1CC331FB0(a1, (llvm::MachineInstr *)v134, v138, v139) & 1) == 0
            && (sub_1CC331FB0(a1, (llvm::MachineInstr *)v134, v139, v138) & 1) == 0)
          {
            break;
          }
LABEL_284:
          uint64_t v134 = v136;
          if ((void *)v136 == v229) {
            goto LABEL_311;
          }
        }
        sub_1CC332144(a1, v134);
        sub_1CC3325C4(a1, *(_DWORD *)(*(void *)(v134 + 32) + 36), v134, 1);
        uint64_t v141 = *(void *)(v134 + 32);
        unsigned int NumExplicitOperands = llvm::MachineInstr::getNumExplicitOperands(v134);
        uint64_t v143 = *(unsigned int *)(v134 + 40);
        if (NumExplicitOperands != v143)
        {
          uint64_t v144 = 32 * v143 - 32 * NumExplicitOperands;
          uint64_t v145 = (unsigned int *)(v141 + 32 * NumExplicitOperands + 4);
          do
          {
            int v146 = *(v145 - 1);
            int v147 = v146 & 0x300000FF;
            int v148 = v146 & 0x10FFF00;
            if (v147) {
              BOOL v149 = 1;
            }
            else {
              BOOL v149 = v148 == 0x1000000;
            }
            if (!v149 && *v145) {
              sub_1CC3325C4(a1, *v145, v134, 1);
            }
            v145 += 8;
            v144 -= 32;
          }
          while (v144);
        }
        if (((*(void *)(*(void *)(*(void *)(a1 + 264) + 352) + ((v138 >> 3) & 0x1FFFFFF8)) >> v138) & 1) == 0)
        {
          int64_t v235 = (void *)v134;
          if (*v230)
          {
            int v150 = 8;
            uint64_t v151 = a1 + 280;
LABEL_287:
            int v173 = v150 - 1;
            unsigned int v174 = v173 & ((v134 >> 4) ^ (v134 >> 9));
            uint64_t v175 = (void *)(v151 + 8 * v174);
            uint64_t v176 = *v175;
            if (v134 != *v175)
            {
              BOOL v177 = 0;
              int v178 = 1;
              while (v176 != -4096)
              {
                if (v177) {
                  BOOL v179 = 0;
                }
                else {
                  BOOL v179 = v176 == -8192;
                }
                if (v179) {
                  BOOL v177 = v175;
                }
                unsigned int v180 = v174 + v178++;
                unsigned int v174 = v180 & v173;
                uint64_t v175 = (void *)(v151 + 8 * v174);
                uint64_t v176 = *v175;
                if (v134 == *v175) {
                  goto LABEL_302;
                }
              }
              if (v177) {
                int v181 = v177;
              }
              else {
                int v181 = v175;
              }
              goto LABEL_300;
            }
          }
          else
          {
            int v150 = *(_DWORD *)(a1 + 288);
            if (v150)
            {
              uint64_t v151 = *(void *)(a1 + 280);
              goto LABEL_287;
            }
            int v181 = 0;
LABEL_300:
            uint64_t v182 = sub_1CB938A98((uint64_t)v230, (uint64_t)&v235, &v235, v181);
            *uint64_t v182 = v235;
            unint64_t v183 = *(unsigned int *)(a1 + 352);
            if (v183 >= *(unsigned int *)(a1 + 356)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(a1 + 344) + 8 * v183) = v235;
            ++*(_DWORD *)(a1 + 352);
          }
        }
LABEL_302:
        sub_1CC332860(v232, v138, *(void *)(a1 + 248));
        uint64_t v184 = *(void *)(v134 + 32);
        unsigned int v185 = llvm::MachineInstr::getNumExplicitOperands(v134);
        uint64_t v186 = *(unsigned int *)(v134 + 40);
        if (v185 != v186)
        {
          uint64_t v187 = 32 * v186 - 32 * v185;
          int v188 = (unsigned int *)(v184 + 32 * v185 + 4);
          do
          {
            if ((*(v188 - 1) & 0x10000FF) == 0x1000000 && *v188) {
              sub_1CC332860(v232, *v188, *(void *)(a1 + 248));
            }
            v188 += 8;
            v187 -= 32;
          }
          while (v187);
        }
        sub_1CC330BEC((uint64_t)v232, v134, *(void *)(a1 + 248));
        goto LABEL_284;
      }
LABEL_311:
      if (v226[11] == v226[12])
      {
        uint64_t v189 = *(unsigned int *)(a1 + 352);
        if (v189)
        {
          uint64_t v190 = *(llvm::MachineInstr ***)(a1 + 344);
          uint64_t v191 = &v190[v189];
          do
          {
            uint64_t v192 = *v190;
            uint64_t v234 = v192;
            uint64_t v193 = *((void *)v192 + 4);
            int v194 = *(_DWORD *)(v193 + 36);
            int v195 = *(_DWORD *)(v193 + 4);
            sub_1CC331A70((uint64_t)v233, (uint64_t *)&v234);
            unint64_t v197 = *(unint64_t **)(v196 + 16);
            if (v197 == *(unint64_t **)(v196 + 8)) {
              uint64_t v198 = (unsigned int *)(v196 + 28);
            }
            else {
              uint64_t v198 = (unsigned int *)(v196 + 24);
            }
            uint64_t v199 = *v198;
            uint64_t v200 = &v197[v199];
            if (v199)
            {
              uint64_t v201 = 8 * v199;
              while (*v197 >= 0xFFFFFFFFFFFFFFFELL)
              {
                ++v197;
                v201 -= 8;
                if (!v201)
                {
                  unint64_t v197 = v200;
                  break;
                }
              }
            }
            sub_1CC331A70((uint64_t)v233, (uint64_t *)&v234);
            uint64_t v203 = *(void *)(v202 + 16);
            if (v203 == *(void *)(v202 + 8)) {
              unint64_t v204 = (unsigned int *)(v202 + 28);
            }
            else {
              unint64_t v204 = (unsigned int *)(v202 + 24);
            }
            int v205 = (unint64_t *)(v203 + 8 * *v204);
            int64_t v235 = v237;
            uint64_t v236 = 0x600000000;
            sub_1CC331CE4((uint64_t)&v235, v197, v200, v205);
            sub_1CC3311D4(*(void *)(a1 + 264), v195, v194, (uint64_t *)v235, v236);
            llvm::MachineInstr::eraseFromParent(v192);
            *(unsigned char *)(a1 + 472) = 1;
            if (v235 != v237) {
              free(v235);
            }
            ++v190;
          }
          while (v190 != v191);
        }
      }
      int v206 = *(_DWORD *)v230;
      if (*(_DWORD *)v230 > 1u || *(_DWORD *)(a1 + 276))
      {
        uint64_t v212 = a1 + 344;
        unint64_t v213 = (void *)(a1 + 280);
        if (v206) {
          goto LABEL_347;
        }
        uint64_t v214 = *(unsigned int *)(a1 + 288);
        if (((2 * v206) & 0xFFFFFFFC) >= v214 || v214 < 0x41)
        {
          if (v214)
          {
            unint64_t v213 = *v224;
            uint64_t v212 = (uint64_t)&(*v224)[v214];
            do
LABEL_347:
              *v213++ = -4096;
            while (v213 != (void *)v212);
            int v215 = *(_DWORD *)v230 & 1;
          }
          else
          {
            int v215 = 0;
          }
          *(_DWORD *)(a1 + 272) = v215;
          *(_DWORD *)(a1 + 276) = 0;
          goto LABEL_330;
        }
        sub_1CC331E98(v230);
      }
LABEL_330:
      *(_DWORD *)(a1 + 352) = 0;
      int v207 = *(_DWORD *)(a1 + 432);
      if (v207 || *(_DWORD *)(a1 + 436))
      {
        uint64_t v220 = *(unsigned int *)(a1 + 440);
        if (v220 > 4 * v207 && v220 >= 0x41)
        {
          sub_1CD52ABA0(v233);
        }
        else
        {
          if (v220)
          {
            unsigned int v221 = *(void **)v233;
            uint64_t v222 = 56 * v220;
            do
            {
              if (*v221 != -4096)
              {
                if (*v221 != -8192)
                {
                  uint64_t v223 = (void *)v221[2];
                  if (v223 != (void *)v221[1]) {
                    free(v223);
                  }
                }
                *unsigned int v221 = -4096;
              }
              v221 += 7;
              v222 -= 56;
            }
            while (v222);
          }
          *(void *)(a1 + 432) = 0;
        }
      }
      sub_1CC3312A0((uint64_t)v232);
      unsigned int v5 = (void *)v226[1];
      if (v5 == v225) {
        return *(unsigned char *)(a1 + 472) != 0;
      }
    }
    uint64_t v208 = a1 + 344;
    int v209 = (void *)(a1 + 280);
    if ((v132 & 1) == 0)
    {
      uint64_t v210 = *(unsigned int *)(a1 + 288);
      if (((2 * v132) & 0xFFFFFFFC) < v210 && v210 >= 0x41)
      {
        sub_1CC331E98(v230);
        goto LABEL_216;
      }
      if (!v210)
      {
        int v211 = 0;
LABEL_341:
        *(_DWORD *)(a1 + 272) = v211;
        *(_DWORD *)(a1 + 276) = 0;
        goto LABEL_216;
      }
      int v209 = *v224;
      uint64_t v208 = (uint64_t)&(*v224)[v210];
    }
    do
      *v209++ = -4096;
    while (v209 != (void *)v208);
    int v211 = *(_DWORD *)v230 & 1;
    goto LABEL_341;
  }
  return *(unsigned char *)(a1 + 472) != 0;
}

double sub_1CC330808@<D0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + 16) = 8;
  *(void *)a1 = a1 + 16;
  *(void *)&double result = 0x600000001;
  *(void *)(a1 + 8) = 0x600000001;
  *(_DWORD *)(a1 + 64) = 11;
  return result;
}

void sub_1CC330830(unsigned int *a1)
{
  uint64_t v1 = a1[4];
  if (v1)
  {
    uint64_t v2 = 56 * v1;
    uint64_t v3 = (void **)(*(void *)a1 + 16);
    do
    {
      uint64_t v4 = (uint64_t)*(v3 - 2);
      if (v4 != -4096 && v4 != -8192 && *v3 != *(v3 - 1))
      {
        unsigned int v5 = v3;
        uint64_t v6 = v2;
        free(*v3);
        uint64_t v3 = v5;
        uint64_t v2 = v6;
      }
      v3 += 7;
      v2 -= 56;
    }
    while (v2);
  }
}

void sub_1CC3308A4(int32x2_t *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  unsigned int v44 = a2;
  unint64_t v45 = v47;
  uint64_t v46 = 0x800000000;
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  uint64_t v48 = &v49;
  sub_1CC33145C((uint64_t)&v45, &v44);
  unint64_t v5 = *(unsigned int *)(*(void *)(a3 + 8) + 24 * v44 + 16);
  uint64_t v6 = (_WORD *)(*(void *)(a3 + 56) + ((v5 >> 3) & 0x1FFFFFFE));
  unsigned __int16 v7 = *v6 + (v5 & 0xF) * v44;
  do
  {
    int v8 = v7;
    int32x2_t v9 = *a1;
    unsigned __int32 v10 = a1[2].u32[0];
    if (v10)
    {
      unsigned int v11 = (v10 - 1) & (37 * v8);
      uint64_t v12 = *(void *)&v9 + 56 * v11;
      int v13 = *(_DWORD *)v12;
      if (*(_DWORD *)v12 == v8) {
        goto LABEL_9;
      }
      int v14 = 1;
      while (v13 != -1)
      {
        unsigned int v15 = v11 + v14++;
        unsigned int v11 = v15 & (v10 - 1);
        uint64_t v12 = *(void *)&v9 + 56 * v11;
        int v13 = *(_DWORD *)v12;
        if (*(_DWORD *)v12 == v8) {
          goto LABEL_9;
        }
      }
    }
    uint64_t v12 = *(void *)&v9 + 56 * v10;
LABEL_9:
    if (v12 != *(void *)&v9 + 56 * v10)
    {
      uint64_t v16 = *(void *)(v12 + 8);
      if (v16)
      {
        unsigned int v43 = *(_DWORD *)(*(void *)(v16 + 32) + 4);
        sub_1CC33145C((uint64_t)&v45, &v43);
        unsigned int v43 = *(_DWORD *)(*(void *)(v16 + 32) + 36);
        sub_1CC33145C((uint64_t)&v45, &v43);
      }
      uint64_t v17 = *(unsigned int *)(v12 + 24);
      if (v17)
      {
        unsigned int v18 = *(unsigned int **)(v12 + 16);
        uint64_t v19 = 4 * v17;
        do
        {
          sub_1CC33145C((uint64_t)&v45, v18++);
          v19 -= 4;
        }
        while (v19);
      }
    }
    int v20 = (unsigned __int16)v6[1];
    ++v6;
    unsigned __int16 v7 = v20 + v8;
  }
  while (v20);
  uint64_t v21 = v50;
  if (v50) {
    uint64_t v22 = v48;
  }
  else {
    uint64_t v22 = v45;
  }
  int v42 = (char *)v45 + 4 * v46;
  while (1)
  {
    uint64_t v23 = v21 ? &v49 : (void **)v42;
    if (v22 == v23) {
      break;
    }
    uint64_t v24 = (unsigned int *)v22 + 7;
    if (!v21) {
      uint64_t v24 = (unsigned int *)v22;
    }
    unsigned int v25 = *v24;
    unint64_t v26 = *(unsigned int *)(*(void *)(a3 + 8) + 24 * v25 + 16);
    uint64_t v27 = (_WORD *)(*(void *)(a3 + 56) + ((v26 >> 3) & 0x1FFFFFFE));
    unsigned __int16 v28 = *v27 + (v26 & 0xF) * v25;
    do
    {
      unsigned __int16 v29 = v28;
      __int32 v30 = a1[2].i32[0];
      if (v30)
      {
        __int32 v31 = v30 - 1;
        unsigned int v32 = v31 & (37 * v28);
        uint64_t v33 = *(void *)a1 + 56 * v32;
        int v34 = *(_DWORD *)v33;
        if (*(_DWORD *)v33 == v28)
        {
LABEL_29:
          uint64_t v35 = *(void **)(v33 + 16);
          if (v35 != (void *)(v33 + 32)) {
            free(v35);
          }
          *(_DWORD *)uint64_t v33 = -2;
          a1[1] = vadd_s32(a1[1], (int32x2_t)0x1FFFFFFFFLL);
        }
        else
        {
          int v37 = 1;
          while (v34 != -1)
          {
            unsigned int v38 = v32 + v37++;
            unsigned int v32 = v38 & v31;
            uint64_t v33 = *(void *)a1 + 56 * v32;
            int v34 = *(_DWORD *)v33;
            if (*(_DWORD *)v33 == v28) {
              goto LABEL_29;
            }
          }
        }
      }
      int v36 = (unsigned __int16)v27[1];
      ++v27;
      unsigned __int16 v28 = v36 + v29;
    }
    while (v36);
    if (v21)
    {
      unsigned __int16 v39 = (void *)v22[1];
      long long v40 = v22;
      if (v39)
      {
        do
        {
          uint64_t v22 = v39;
          unsigned __int16 v39 = (void *)*v39;
        }
        while (v39);
      }
      else
      {
        do
        {
          uint64_t v22 = (void *)v40[2];
          BOOL v41 = *v22 == (void)v40;
          long long v40 = v22;
        }
        while (!v41);
      }
    }
    else
    {
      uint64_t v22 = (void *)((char *)v22 + 4);
    }
  }
  sub_1CD3C5048((uint64_t)&v48, v49);
  if (v45 != v47) {
    free(v45);
  }
}

uint64_t sub_1CC330BEC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a2 + 32);
  unsigned int v6 = *(_DWORD *)(v5 + 4);
  unsigned int v50 = *(_DWORD *)(v5 + 36);
  unint64_t v7 = *(unsigned int *)(*(void *)(a3 + 8) + 24 * v6 + 16);
  int v8 = (_WORD *)(*(void *)(a3 + 56) + ((v7 >> 3) & 0x1FFFFFFE));
  unsigned __int16 v9 = *v8 + (v7 & 0xF) * v6;
  do
  {
    uint64_t v56 = a2;
    uint64_t v57 = &v59;
    unsigned int v58 = (void *)0x400000000;
    char v61 = 1;
    int v10 = v9;
    LODWORD(v52) = v9;
    int v11 = *(_DWORD *)(a1 + 16);
    if (v11)
    {
      int v12 = v11 - 1;
      unsigned int v13 = v12 & (37 * v9);
      int v14 = (_DWORD *)(*(void *)a1 + 56 * v13);
      int v15 = *v14;
      if (*v14 == v9)
      {
LABEL_4:
        uint64_t v16 = &v59;
        uint64_t v17 = a2;
        goto LABEL_7;
      }
      uint64_t v23 = 0;
      int v24 = 1;
      while (v15 != -1)
      {
        if (v23) {
          BOOL v25 = 0;
        }
        else {
          BOOL v25 = v15 == -2;
        }
        if (v25) {
          uint64_t v23 = v14;
        }
        unsigned int v26 = v13 + v24++;
        unsigned int v13 = v26 & v12;
        int v14 = (_DWORD *)(*(void *)a1 + 56 * v13);
        int v15 = *v14;
        if (*v14 == v9) {
          goto LABEL_4;
        }
      }
      if (v23) {
        unsigned int v18 = v23;
      }
      else {
        unsigned int v18 = v14;
      }
    }
    else
    {
      unsigned int v18 = 0;
    }
    int v14 = sub_1CC3315F8(a1, (int *)&v52, v18);
    *int v14 = v10;
    *(_OWORD *)(v14 + 2) = 0u;
    *(_OWORD *)(v14 + 6) = 0u;
    *(_OWORD *)(v14 + 10) = 0u;
    *((void *)v14 + 2) = v14 + 8;
    v14[7] = 4;
    uint64_t v17 = v56;
    uint64_t v16 = (uint64_t *)v57;
LABEL_7:
    *((void *)v14 + 1) = v17;
    uint64_t v19 = (void **)(v14 + 4);
    if (v14 + 4 != (_DWORD *)&v57)
    {
      if (v16 == &v59)
      {
        int v20 = (int)v58;
        uint64_t v21 = v14[6];
        if (v21 < v58)
        {
          if (v14[7] < v58)
          {
            v14[6] = 0;
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          if (v21)
          {
            memmove(*v19, &v59, 4 * v21);
            uint64_t v19 = (void **)(v14 + 4);
          }
          else
          {
            uint64_t v21 = 0;
          }
          if (v21 != v58) {
            memcpy((char *)*v19 + 4 * v21, (char *)v57 + 4 * v21, 4 * v58 - 4 * v21);
          }
        }
        else if (v58)
        {
          memmove(*v19, &v59, 4 * v58);
        }
        v14[6] = v20;
      }
      else
      {
        if (*((_DWORD **)v14 + 2) != v14 + 8)
        {
          free(*((void **)v14 + 2));
          uint64_t v16 = (uint64_t *)v57;
        }
        *((void *)v14 + 2) = v16;
        *((void *)v14 + 3) = v58;
        uint64_t v57 = &v59;
        HIDWORD(v58) = 0;
      }
      LODWORD(v58) = 0;
      uint64_t v16 = (uint64_t *)v57;
    }
    *((unsigned char *)v14 + 48) = v61;
    if (v16 != &v59) {
      free(v16);
    }
    int v22 = (unsigned __int16)v8[1];
    ++v8;
    unsigned __int16 v9 = v22 + v10;
  }
  while (v22);
  unint64_t v27 = *(unsigned int *)(*(void *)(a3 + 8) + 24 * v50 + 16);
  unsigned __int16 v28 = (_WORD *)(*(void *)(a3 + 56) + ((v27 >> 3) & 0x1FFFFFFE));
  unsigned __int16 v29 = *v28 + (v27 & 0xF) * v50;
  do
  {
    unsigned __int16 v30 = v29;
    uint64_t v52 = 0;
    uint64_t v53 = v55;
    uint64_t v54 = 0x400000000;
    v55[16] = 0;
    LODWORD(v56) = v29;
    uint64_t v57 = 0;
    unsigned int v58 = &v60;
    uint64_t v59 = 0x400000000;
    char v62 = 0;
    int v31 = *(_DWORD *)(a1 + 16);
    if (v31)
    {
      int v32 = v31 - 1;
      unsigned int v33 = v32 & (37 * v29);
      uint64_t v34 = *(void *)a1 + 56 * v33;
      int v35 = *(_DWORD *)v34;
      if (*(_DWORD *)v34 == v29) {
        goto LABEL_60;
      }
      int v36 = 0;
      int v37 = 1;
      while (v35 != -1)
      {
        if (v36) {
          BOOL v38 = 0;
        }
        else {
          BOOL v38 = v35 == -2;
        }
        if (v38) {
          int v36 = (_DWORD *)v34;
        }
        unsigned int v39 = v33 + v37++;
        unsigned int v33 = v39 & v32;
        uint64_t v34 = *(void *)a1 + 56 * v33;
        int v35 = *(_DWORD *)v34;
        if (*(_DWORD *)v34 == v29) {
          goto LABEL_60;
        }
      }
      if (v36) {
        long long v40 = v36;
      }
      else {
        long long v40 = (_DWORD *)v34;
      }
    }
    else
    {
      long long v40 = 0;
    }
    BOOL v41 = (uint64_t *)sub_1CC3315F8(a1, (int *)&v56, v40);
    uint64_t v34 = (uint64_t)v41;
    *(_DWORD *)BOOL v41 = v56;
    v41[1] = (uint64_t)v57;
    v41[2] = (uint64_t)(v41 + 4);
    v41[3] = 0x400000000;
    int v42 = (uint64_t *)v58;
    if (v41 != &v56)
    {
      int v43 = v59;
      if (v59)
      {
        if (v58 == &v60)
        {
          if (v59 >= 5) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy(v41 + 4, &v60, 4 * v59);
          int v42 = (uint64_t *)v58;
          *(_DWORD *)(v34 + 24) = v43;
        }
        else
        {
          v41[2] = (uint64_t)v58;
          *((_DWORD *)v41 + 6) = v43;
          *((_DWORD *)v41 + 7) = HIDWORD(v59);
          unsigned int v58 = &v60;
          HIDWORD(v59) = 0;
          int v42 = &v60;
        }
        LODWORD(v59) = 0;
      }
    }
    *(unsigned char *)(v34 + 48) = v62;
    if (v42 != &v60) {
      free(v42);
    }
LABEL_60:
    if (v53 != v55) {
      free(v53);
    }
    uint64_t result = v34 + 16;
    unint64_t v45 = *(_DWORD **)(v34 + 16);
    uint64_t v46 = *(unsigned int *)(v34 + 24);
    unint64_t v47 = v45;
    if (v46)
    {
      uint64_t v48 = 4 * v46;
      unint64_t v47 = *(_DWORD **)(v34 + 16);
      while (*v47 != v6)
      {
        ++v47;
        v48 -= 4;
        if (!v48)
        {
          unint64_t v47 = &v45[v46];
          break;
        }
      }
    }
    if (v46 == v47 - v45)
    {
      if (v46 >= *(_DWORD *)(v34 + 28)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v45[v46] = v6;
      ++*(_DWORD *)(v34 + 24);
    }
    int v49 = (unsigned __int16)v28[1];
    ++v28;
    unsigned __int16 v29 = v49 + v30;
  }
  while (v49);
  return result;
}

uint64_t sub_1CC331120(uint64_t a1, unsigned int a2, int a3, uint64_t a4, uint64_t a5)
{
  if (!a2)
  {
LABEL_7:
    uint64_t v6 = a1 + 56 * a2;
    goto LABEL_8;
  }
  unsigned int v5 = (37 * a3) & (a2 - 1);
  uint64_t v6 = a1 + 56 * v5;
  int v7 = *(_DWORD *)v6;
  if (*(_DWORD *)v6 != a3)
  {
    int v8 = 1;
    while (v7 != -1)
    {
      unsigned int v9 = v5 + v8++;
      unsigned int v5 = v9 & (a2 - 1);
      uint64_t v6 = a1 + 56 * v5;
      int v7 = *(_DWORD *)v6;
      if (*(_DWORD *)v6 == a3) {
        goto LABEL_8;
      }
    }
    goto LABEL_7;
  }
LABEL_8:
  if (v6 == a1 + 56 * a2 || *(_DWORD *)(v6 + 24) != 1) {
    return 0;
  }
  unsigned int v10 = **(_DWORD **)(v6 + 16);
  unint64_t v11 = *(unsigned int *)(a4 + 24 * v10 + 16);
  return sub_1CC3319E8(a1, a2, (unsigned __int16)(*(_WORD *)(a5 + ((v11 >> 3) & 0x1FFFFFFE)) + (v11 & 0xF) * v10), 1);
}

uint64_t sub_1CC3311D4(uint64_t result, int a2, int a3, uint64_t *a4, uint64_t a5)
{
  int v13 = a3;
  int v14 = a2;
  v12[0] = result;
  v12[1] = &v13;
  v12[2] = &v14;
  if (a5)
  {
    unsigned int v5 = &a4[a5];
    do
    {
      uint64_t v6 = a4;
      uint64_t v7 = *a4;
      int v8 = **(unsigned __int16 **)(*a4 + 16);
      if ((v8 - 13) > 1)
      {
        uint64_t result = sub_1CC331DDC((uint64_t)v12, *(void *)(v7 + 32));
      }
      else
      {
        uint64_t v9 = *(void *)(v7 + 32);
        if (v8 != 14)
        {
          uint64_t v11 = v9 + 32;
          goto LABEL_12;
        }
        uint64_t v10 = *(unsigned int *)(v7 + 40);
        if (v10 != 2)
        {
          uint64_t v11 = v9 + 32 * v10;
          v9 += 64;
          do
          {
LABEL_12:
            uint64_t result = sub_1CC331DDC((uint64_t)v12, v9);
            v9 += 32;
          }
          while (v9 != v11);
        }
      }
      a4 = v6 + 1;
    }
    while (v6 + 1 != v5);
  }
  return result;
}

void sub_1CC3312A0(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 8);
  if (!v2 && !*(_DWORD *)(a1 + 12)) {
    return;
  }
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(_DWORD **)a1;
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_28:
      *(void *)(a1 + 8) = 0;
      return;
    }
    uint64_t v12 = 56 * v3;
    int v13 = v4 + 8;
    while (1)
    {
      int v14 = *(v13 - 8);
      if (v14 == -2) {
        goto LABEL_26;
      }
      if (v14 != -1) {
        break;
      }
LABEL_27:
      v13 += 14;
      v12 -= 56;
      if (!v12) {
        goto LABEL_28;
      }
    }
    int v15 = (_DWORD *)*((void *)v13 - 2);
    if (v13 != v15) {
      free(v15);
    }
LABEL_26:
    *(v13 - 8) = -1;
    goto LABEL_27;
  }
  uint64_t v5 = 56 * v3;
  uint64_t v6 = v4 + 8;
  do
  {
    if (*((_DWORD *)v6 - 8) <= 0xFFFFFFFD)
    {
      uint64_t v7 = (void *)*(v6 - 2);
      if (v6 != v7) {
        free(v7);
      }
    }
    v6 += 7;
    v5 -= 56;
  }
  while (v5);
  int v8 = 1 << (33 - __clz(v2 - 1));
  if (v8 <= 64) {
    int v8 = 64;
  }
  if (v2) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  if (v9 == *(_DWORD *)(a1 + 16))
  {
    *(void *)(a1 + 8) = 0;
    if (v9)
    {
      uint64_t v10 = *(_DWORD **)a1;
      uint64_t v11 = 56 * v9;
      do
      {
        *uint64_t v10 = -1;
        v10 += 14;
        v11 -= 56;
      }
      while (v11);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    if (v9)
    {
      unint64_t v16 = (4 * (int)v9 / 3u + 1) | ((unint64_t)(4 * (int)v9 / 3u + 1) >> 1);
      unint64_t v17 = v16 | (v16 >> 2) | ((v16 | (v16 >> 2)) >> 4);
      LODWORD(v17) = (((v17 | (v17 >> 8)) >> 16) | v17 | (v17 >> 8)) + 1;
      *(_DWORD *)(a1 + 16) = v17;
      unsigned int v18 = operator new(56 * v17, (std::align_val_t)8uLL);
      *(void *)a1 = v18;
      *(void *)(a1 + 8) = 0;
      uint64_t v19 = *(unsigned int *)(a1 + 16);
      if (v19)
      {
        uint64_t v20 = 56 * v19;
        do
        {
          *unsigned int v18 = -1;
          v18 += 14;
          v20 -= 56;
        }
        while (v20);
      }
    }
    else
    {
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 16) = 0;
    }
  }
}

unint64_t sub_1CC33145C(uint64_t a1, unsigned int *a2)
{
  if (*(void *)(a1 + 64))
  {
    sub_1CD52A9E8((uint64_t **)(a1 + 48), a2, a2);
    return ((unint64_t)v10 << 32) | 1;
  }
  else
  {
    uint64_t v2 = *(unsigned int *)(a1 + 8);
    unsigned int v3 = *a2;
    if (v2)
    {
      uint64_t v5 = 4 * v2;
      uint64_t v6 = *(_DWORD **)a1;
      while (*v6 != v3)
      {
        ++v6;
        v5 -= 4;
        if (!v5) {
          goto LABEL_9;
        }
      }
      if (v5) {
        return 1;
      }
LABEL_9:
      if (v2 <= 7) {
        goto LABEL_3;
      }
      uint64_t v7 = (uint64_t **)(a1 + 48);
      do
      {
        uint64_t v9 = (unsigned int *)(*(void *)a1 + 4 * v2 - 4);
        sub_1CD52A9E8(v7, v9, v9);
        LODWORD(v2) = *(_DWORD *)(a1 + 8) - 1;
        *(_DWORD *)(a1 + 8) = v2;
      }
      while (v2);
      sub_1CD52A9E8(v7, a2, a2);
    }
    else
    {
LABEL_3:
      if (v2 >= *(_DWORD *)(a1 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a1 + 4 * v2) = v3;
      ++*(_DWORD *)(a1 + 8);
    }
    return 0x100000001;
  }
}

uint64_t sub_1CC331578(uint64_t result, int a2, int a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = (37 * a3) & (a2 - 1);
    uint64_t v6 = (_DWORD *)(result + 56 * v5);
    int v7 = *v6;
    if (*v6 != a3)
    {
      int v8 = 0;
      int v9 = 1;
      while (v7 != -1)
      {
        if (v8) {
          BOOL v10 = 0;
        }
        else {
          BOOL v10 = v7 == -2;
        }
        if (v10) {
          int v8 = v6;
        }
        unsigned int v11 = v5 + v9++;
        unsigned int v5 = v11 & v4;
        uint64_t v6 = (_DWORD *)(result + 56 * (v11 & v4));
        int v7 = *v6;
        if (*v6 == a3) {
          goto LABEL_13;
        }
      }
      if (v8) {
        uint64_t v6 = v8;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
LABEL_13:
  *a4 = v6;
  return result;
}

_DWORD *sub_1CC3315F8(uint64_t a1, int *a2, _DWORD *a3)
{
  unsigned __int16 v28 = a3;
  int v5 = *(_DWORD *)(a1 + 8);
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (4 * v5 + 4 >= (3 * v6))
  {
    int v7 = 2 * v6;
  }
  else
  {
    int v7 = *(_DWORD *)(a1 + 16);
    if ((int)v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_3;
    }
  }
  uint64_t v9 = *(void *)a1;
  unint64_t v10 = (v7 - 1) | ((unint64_t)(v7 - 1) >> 1);
  unint64_t v11 = v10 | (v10 >> 2) | ((v10 | (v10 >> 2)) >> 4);
  int v12 = ((v11 | (v11 >> 8)) >> 16) | v11 | (v11 >> 8);
  if ((v12 + 1) > 0x40) {
    unsigned int v13 = v12 + 1;
  }
  else {
    unsigned int v13 = 64;
  }
  *(_DWORD *)(a1 + 16) = v13;
  int v14 = operator new(56 * v13, (std::align_val_t)8uLL);
  *(void *)a1 = v14;
  if (v9)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v15 = *(unsigned int *)(a1 + 16);
    if (v15)
    {
      uint64_t v16 = 56 * v15;
      do
      {
        *int v14 = -1;
        v14 += 14;
        v16 -= 56;
      }
      while (v16);
    }
    if (v6)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 56 * v6;
      do
      {
        uint64_t v19 = v9 + v17;
        unsigned int v20 = *(_DWORD *)(v9 + v17);
        if (v20 <= 0xFFFFFFFD)
        {
          unsigned __int16 v29 = 0;
          sub_1CC331578(*(void *)a1, *(_DWORD *)(a1 + 16), v20, &v29);
          uint64_t v21 = v29;
          unsigned int *v29 = v20;
          *((void *)v21 + 1) = *(void *)(v19 + 8);
          *((void *)v21 + 2) = v21 + 8;
          *((void *)v21 + 3) = 0x400000000;
          unsigned int v22 = *(_DWORD *)(v19 + 24);
          if (v22 && (unsigned int *)v19 != v21)
          {
            uint64_t v23 = *(const void **)(v9 + v17 + 16);
            uint64_t v24 = v9 + v17 + 32;
            if ((const void *)v24 == v23)
            {
              if (v22 >= 5) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              memcpy(v21 + 8, v23, 4 * *(unsigned int *)(v19 + 24));
              void v21[6] = v22;
            }
            else
            {
              *((void *)v21 + 2) = v23;
              void v21[6] = v22;
              v21[7] = *(_DWORD *)(v9 + v17 + 28);
              *(void *)(v9 + v17 + 16) = v24;
              *(_DWORD *)(v9 + v17 + 28) = 0;
            }
            *(_DWORD *)(v19 + 24) = 0;
          }
          *((unsigned char *)v21 + 48) = *(unsigned char *)(v9 + v17 + 48);
          ++*(_DWORD *)(a1 + 8);
          BOOL v25 = *(void **)(v9 + v17 + 16);
          if ((void *)(v9 + v17 + 32) != v25) {
            free(v25);
          }
        }
        v17 += 56;
      }
      while (v18 != v17);
    }
    MEMORY[0x1D25D9CD0](v9, 8);
    int v14 = *(_DWORD **)a1;
    LODWORD(v26) = *(_DWORD *)(a1 + 16);
  }
  else
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v26 = *(unsigned int *)(a1 + 16);
    if (v26)
    {
      uint64_t v27 = 0;
      do
      {
        v14[v27] = -1;
        v27 += 14;
      }
      while (14 * v26 != v27);
    }
  }
  sub_1CC331578((uint64_t)v14, v26, *a2, &v28);
  int v5 = *(_DWORD *)(a1 + 8);
  a3 = v28;
LABEL_3:
  *(_DWORD *)(a1 + 8) = v5 + 1;
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

uint64_t sub_1CC3318A4(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v5 = *(void *)(a2 + 32);
  uint64_t v6 = *(void *)(a2 + 16);
  unsigned int v7 = *(unsigned __int8 *)(v6 + 4);
  uint64_t v8 = *(unsigned int *)(a2 + 40);
  if ((*(unsigned char *)(v6 + 8) & 2) != 0)
  {
    if (v8 == v7) {
      return 0;
    }
    unsigned int v9 = *(unsigned __int8 *)(v6 + 4);
    do
    {
      int v15 = *(_DWORD *)(v5 + 32 * v7);
      if ((v15 & 0x10000FF) != 0x1000000) {
        break;
      }
      v9 += (v15 & 0x2000000) == 0;
      if (v8 - 1 == v7) {
        break;
      }
      ++v7;
    }
    while ((v15 & 0x2000000) == 0);
  }
  else
  {
    unsigned int v9 = *(unsigned __int8 *)(v6 + 4);
  }
  if (v9 == v8) {
    return 0;
  }
  unint64_t v10 = (_DWORD *)(v5 + 32 * v9);
  unsigned int v11 = a3[1];
  uint64_t v12 = 32 * v8 - 32 * v9;
  while (1)
  {
    if (v10 != a3 && (*v10 & 0x30000FF) == 0x2000000)
    {
      unsigned int v13 = v10[1];
      if (v11 == v13
        || v11 - 1 <= 0x3FFFFFFE
        && v13 - 1 <= 0x3FFFFFFE
        && llvm::MCRegisterInfo::regsOverlap((void *)(*(void *)(a1 + 248) + 8), v11, v13))
      {
        break;
      }
    }
    v10 += 8;
    v12 -= 32;
    if (!v12) {
      return 0;
    }
  }
  return 1;
}

uint64_t sub_1CC3319E8(uint64_t a1, unsigned int a2, int a3, int a4)
{
  if (!a2)
  {
LABEL_7:
    uint64_t v5 = (int *)(a1 + 56 * a2);
    goto LABEL_8;
  }
  unsigned int v4 = (37 * a3) & (a2 - 1);
  uint64_t v5 = (int *)(a1 + 56 * v4);
  int v6 = *v5;
  if (*v5 != a3)
  {
    int v7 = 1;
    while (v6 != -1)
    {
      unsigned int v8 = v4 + v7++;
      unsigned int v4 = v8 & (a2 - 1);
      uint64_t v5 = (int *)(a1 + 56 * v4);
      int v6 = *v5;
      if (*v5 == a3) {
        goto LABEL_8;
      }
    }
    goto LABEL_7;
  }
LABEL_8:
  if (v5 == (int *)(a1 + 56 * a2) || a4 && !*((unsigned char *)v5 + 48)) {
    return 0;
  }
  else {
    return *((void *)v5 + 1);
  }
}

double sub_1CC331A70(uint64_t a1, uint64_t *a2)
{
  unint64_t v10 = 0;
  char v4 = sub_1CC331B70(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v10);
  int v6 = v10;
  if (v4) {
    return result;
  }
  int v7 = *(_DWORD *)(a1 + 8);
  unsigned int v8 = *(_DWORD *)(a1 + 16);
  if (4 * v7 + 4 >= 3 * v8)
  {
    v8 *= 2;
    goto LABEL_9;
  }
  if (v8 + ~v7 - *(_DWORD *)(a1 + 12) <= v8 >> 3)
  {
LABEL_9:
    sub_1CC331C0C(a1, v8);
    unint64_t v10 = 0;
    sub_1CC331B70(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v10);
    int v6 = v10;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*v6 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  uint64_t v9 = *a2;
  v6[4] = 0;
  v6[6] = 0;
  v6[5] = 0;
  uint64_t *v6 = v9;
  v6[1] = (uint64_t)(v6 + 5);
  void v6[2] = (uint64_t)(v6 + 5);
  *(void *)&double result = 2;
  v6[3] = 2;
  return result;
}

uint64_t sub_1CC331B70(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    int v6 = (void *)(a1 + 56 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v9 = 0;
      int v10 = 1;
      while (v7 != -4096)
      {
        if (v9) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          uint64_t v9 = v6;
        }
        unsigned int v13 = v5 + v10++;
        unsigned int v5 = v13 & v4;
        int v6 = (void *)(a1 + 56 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_8;
        }
      }
      uint64_t v8 = 0;
      if (v9) {
        int v6 = v9;
      }
    }
  }
  else
  {
    int v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_8:
  *a4 = v6;
  return v8;
}

void *sub_1CC331C0C(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  double result = operator new(56 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD52AACC(a1, v4, &v4[7 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 56 * v10;
    do
    {
      *double result = -4096;
      result += 7;
      v11 -= 56;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CC331CE4(uint64_t result, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  if (a2 == a4)
  {
    uint64_t v4 = 0;
  }
  else
  {
    uint64_t v4 = 0;
    unint64_t v6 = a2;
    do
    {
      ++v4;
      int v7 = v6 + 1;
      while (v7 != a3)
      {
        unint64_t v8 = *v7++;
        if (v8 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          unint64_t v6 = v7 - 1;
          goto LABEL_12;
        }
      }
      unint64_t v6 = a3;
LABEL_12:
      ;
    }
    while (v6 != a4);
  }
  uint64_t v5 = *(unsigned int *)(result + 8);
  if (v4 + v5 > (unint64_t)*(unsigned int *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (a2 != a4)
  {
    uint64_t v9 = (unint64_t *)(*(void *)result + 8 * v5);
    do
    {
      unint64_t v11 = *a2;
      uint64_t v10 = a2 + 1;
      *uint64_t v9 = v11;
      while (v10 != a3)
      {
        unint64_t v12 = *v10++;
        if (v12 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          a2 = v10 - 1;
          goto LABEL_21;
        }
      }
      a2 = a3;
LABEL_21:
      ++v9;
    }
    while (a2 != a4);
  }
  *(_DWORD *)(result + 8) = v5 + v4;
  return result;
}

uint64_t sub_1CC331DDC(uint64_t result, uint64_t a2)
{
  if (!*(unsigned char *)a2)
  {
    uint64_t v3 = result;
    double result = (*(uint64_t (**)(void))(**(void **)(**(void **)result + 16) + 176))(*(void *)(**(void **)result + 16));
    unsigned int v4 = *(_DWORD *)(a2 + 4);
    unsigned int v5 = **(_DWORD **)(v3 + 16);
    if (v4 == v5
      || (v4 - 1 <= 0x3FFFFFFE ? (BOOL v6 = v5 - 1 > 0x3FFFFFFE) : (BOOL v6 = 1),
          !v6 && (double result = llvm::MCRegisterInfo::regsOverlap((void *)(result + 8), v4, v5), result)))
    {
      unsigned int v7 = **(_DWORD **)(v3 + 8);
      return llvm::MachineOperand::setReg(a2, v7);
    }
  }
  return result;
}

char *sub_1CC331E98(char *result)
{
  uint64_t v1 = result;
  unsigned int v2 = *(_DWORD *)result;
  char v3 = __clz((*(_DWORD *)result >> 1) - 1);
  if ((v3 & 0x3E) == 0x1C) {
    unsigned int v4 = 64;
  }
  else {
    unsigned int v4 = 1 << (33 - v3);
  }
  if (v2 >= 2) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if ((v2 & 1) != 0 && v5 < 9)
  {
    unint64_t v8 = result + 8;
    *(void *)double result = 1;
    uint64_t v9 = result + 72;
  }
  else
  {
    if (v2) {
      goto LABEL_12;
    }
    if (v5 != *((_DWORD *)result + 4))
    {
      MEMORY[0x1D25D9CD0](*((void *)result + 1), 8);
LABEL_12:
      if (v5 > 8)
      {
        *(_DWORD *)v1 &= ~1u;
        double result = (char *)operator new(8 * v5, (std::align_val_t)8uLL);
        *((void *)v1 + 1) = result;
        *((void *)v1 + 2) = v5;
        int v7 = *(_DWORD *)v1;
        *(void *)uint64_t v1 = *(_DWORD *)v1 & 1;
        if ((v7 & 1) == 0)
        {
          BOOL v6 = &result[8 * v5];
          do
          {
LABEL_15:
            *(void *)double result = -4096;
            result += 8;
          }
          while (result != v6);
          return result;
        }
      }
      else
      {
        *(void *)uint64_t v1 = 1;
      }
      double result = v1 + 8;
      BOOL v6 = v1 + 72;
      goto LABEL_15;
    }
    *(void *)double result = 0;
    if (!v5) {
      return result;
    }
    unint64_t v8 = (void *)*((void *)result + 1);
    uint64_t v9 = &v8[v5];
  }
  do
    *v8++ = -4096;
  while (v8 != v9);
  return result;
}

uint64_t sub_1CC331FB0(uint64_t a1, llvm::MachineInstr *a2, unsigned int a3, unsigned int a4)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 264) + 352);
  if ((*(void *)(v4 + 8 * (a3 >> 6)) >> a3) & 1) != 0 || ((*(void *)(v4 + 8 * (a4 >> 6)) >> a4)) {
    return 0;
  }
  uint64_t v10 = *(void *)(a1 + 248);
  uint64_t v13 = *(void *)(v10 + 8);
  unint64_t v11 = (void *)(v10 + 8);
  uint64_t v12 = v13;
  uint64_t v14 = v11[6];
  uint64_t result = sub_1CC3329CC(*(void *)(a1 + 448), *(_DWORD *)(a1 + 464), (uint64_t)a2, a4, v13, v14);
  if (result)
  {
    uint64_t v15 = result;
    uint64_t v16 = *(_DWORD **)(result + 32);
    if ((~*v16 & 0x5000000) == 0) {
      return 0;
    }
    unsigned int v17 = v16[9];
    unsigned int v18 = v16[1];
    BOOL v19 = v17 == a3 && v18 == a4;
    if (!v19)
    {
      unsigned int v20 = (_WORD *)(v14 + 2 * *(unsigned int *)(v12 + 24 * a3 + 8));
      int v21 = (unsigned __int16)*v20;
      unsigned __int16 v22 = v21 + a3;
      BOOL v19 = v21 == 0;
      BOOL v23 = *v20 != 0;
      if (!v19 && v17 != v22)
      {
        BOOL v25 = v20 + 1;
        do
        {
          int v27 = *v25++;
          int v26 = v27;
          v22 += v27;
          BOOL v23 = v27 != 0;
          if (!v27) {
            BOOL v25 = 0;
          }
          if (v26) {
            BOOL v28 = v17 == v22;
          }
          else {
            BOOL v28 = 1;
          }
        }
        while (!v28);
      }
      if (!v23) {
        return 0;
      }
      int SubRegIndex = llvm::MCRegisterInfo::getSubRegIndex(v11, v17, a3);
      if (SubRegIndex != llvm::MCRegisterInfo::getSubRegIndex(v11, v18, a4)) {
        return 0;
      }
    }
    if ((llvm::MachineInstr *)v15 != a2)
    {
      unsigned int v30 = *(_DWORD *)(*((void *)a2 + 4) + 4);
      do
      {
        llvm::MachineInstr::clearRegisterKills(v15, v30, *(void *)(a1 + 248));
        uint64_t v15 = *(void *)(v15 + 8);
      }
      while ((llvm::MachineInstr *)v15 != a2);
    }
    llvm::MachineInstr::eraseFromParent(a2);
    uint64_t result = 1;
    *(unsigned char *)(a1 + 472) = 1;
  }
  return result;
}

uint64_t sub_1CC332144(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 456))
  {
    uint64_t v3 = *(unsigned int *)(a2 + 40);
    if (v3)
    {
      uint64_t v4 = result;
      for (uint64_t i = 0; i != v3; ++i)
      {
        uint64_t v6 = *(void *)(a2 + 32);
        int v7 = (unsigned int *)(v6 + 32 * i);
        unsigned int v8 = *v7;
        if ((*v7 & 0x13F000FF) != 0) {
          continue;
        }
        if ((v8 & 0x8000000) == 0) {
          continue;
        }
        unsigned int v9 = v7[1];
        if (!v9) {
          continue;
        }
        uint64_t v10 = *(void *)(v6 + 32 * i + 8);
        if (v10)
        {
          uint64_t v11 = *(void *)(*(void *)(v10 + 16) + 8);
          if ((v8 & 0x1000000) != 0)
          {
            if ((v11 & 0x100000000) != 0) {
              continue;
            }
          }
          else if ((v11 & 0x80000000) != 0)
          {
            continue;
          }
        }
        uint64_t v12 = *(uint64_t **)(v4 + 248);
        uint64_t result = sub_1CC3329CC(*(void *)(v4 + 448), *(_DWORD *)(v4 + 464), a2, v7[1], v12[1], v12[7]);
        if (!result) {
          continue;
        }
        uint64_t v13 = result;
        uint64_t v14 = *(void *)(result + 32);
        if (v9 != *(_DWORD *)(v14 + 4)) {
          continue;
        }
        unint64_t v15 = *(unsigned int *)(v14 + 36);
        uint64_t v16 = *(void **)(v4 + 264);
        uint64_t v66 = v14;
        if ((*(void *)(v16[44] + ((v15 >> 3) & 0x1FFFFFF8)) >> v15))
        {
          int v17 = *(_DWORD *)(v14 + 36);
          uint64_t result = llvm::MachineRegisterInfo::isConstantPhysReg(v16, v15);
          if (!result) {
            continue;
          }
          unsigned int v18 = *(_DWORD *)(*(void *)(v13 + 32) + 36);
          uint64_t v12 = *(uint64_t **)(v4 + 248);
          LODWORD(v15) = v17;
        }
        else
        {
          unsigned int v18 = *(_DWORD *)(v14 + 36);
        }
        unsigned int v65 = v15;
        uint64_t result = llvm::MachineInstr::getRegClassConstraint((llvm::MachineInstr *)a2, i, *(const llvm::TargetInstrInfo **)(v4 + 256), (const llvm::TargetRegisterInfo *)v12);
        if (result)
        {
          if (v18 - 1 > 0x3FFFFFFE) {
            continue;
          }
          unint64_t v19 = (unint64_t)v18 >> 3;
          if (v19 >= *(unsigned __int16 *)(*(void *)result + 22)) {
            continue;
          }
          int v20 = *(unsigned __int8 *)(*(void *)(*(void *)result + 8) + v19) >> (v18 & 7);
LABEL_24:
          if ((v20 & 1) == 0) {
            continue;
          }
        }
        else
        {
          if (**(_WORD **)(a2 + 16) != 19) {
            continue;
          }
          uint64_t v25 = *(void *)(v4 + 248);
          int v27 = *(uint64_t ***)(v25 + 240);
          int v26 = *(uint64_t ***)(v25 + 248);
          if (v27 == v26) {
            continue;
          }
          LOBYTE(v20) = 0;
          unint64_t v28 = *(unsigned int *)(*(void *)(a2 + 32) + 4);
          unint64_t v29 = v18;
          char v30 = v18;
          unsigned int v31 = v18 - 1;
          unint64_t v32 = v29 >> 3;
          int v33 = 1 << (v30 & 7);
          unsigned int v34 = v28 - 1;
          unint64_t v35 = v28 >> 3;
          uint64_t result = (1 << (v28 & 7));
          while (1)
          {
            while (1)
            {
              if (v31 <= 0x3FFFFFFE)
              {
                int v36 = *v27;
                uint64_t v37 = **v27;
                unsigned int v38 = *(unsigned __int16 *)(v37 + 22);
                if (v32 < v38)
                {
                  uint64_t v39 = *(void *)(v37 + 8);
                  BOOL v40 = (v33 & *(unsigned char *)(v39 + v32)) == 0 || v34 > 0x3FFFFFFE;
                  BOOL v41 = v40 || v35 >= v38;
                  if (!v41 && (result & *(unsigned char *)(v39 + v35)) != 0) {
                    break;
                  }
                }
              }
              if (++v27 == v26) {
                goto LABEL_24;
              }
            }
            unsigned int v56 = result;
            unint64_t v57 = v35;
            unsigned int v59 = v34;
            char v61 = v26;
            int v63 = v33;
            uint64_t v64 = v32;
            uint64_t result = (*(uint64_t (**)(void, uint64_t *))(**(void **)(v4 + 248) + 248))(*(void *)(v4 + 248), v36);
            if ((uint64_t *)result != v36) {
              break;
            }
            ++v27;
            LOBYTE(v20) = 1;
            int v26 = v61;
            unint64_t v32 = v64;
            int v33 = v63;
            unsigned int v34 = v59;
            unint64_t v35 = v57;
            uint64_t result = v56;
            if (v27 == v61) {
              goto LABEL_25;
            }
          }
          uint64_t v42 = *(void *)(v4 + 248);
          int v43 = *(uint64_t ***)(v42 + 240);
          unsigned int v44 = *(uint64_t ***)(v42 + 248);
          uint64_t v45 = v64;
          unsigned __int8 v46 = v63;
          if (v43 == v44) {
            continue;
          }
          unint64_t v47 = *(unsigned int *)(*(void *)(v13 + 32) + 4);
          unsigned int v48 = v47 - 1;
          unint64_t v49 = v47 >> 3;
          unsigned int v60 = v47 - 1;
          int v62 = 1 << (v47 & 7);
          unint64_t v58 = v47 >> 3;
          while (1)
          {
            unsigned int v50 = *v43;
            uint64_t v51 = **v43;
            unsigned int v52 = *(unsigned __int16 *)(v51 + 22);
            if (v45 < v52)
            {
              uint64_t v53 = *(void *)(v51 + 8);
              BOOL v54 = (v46 & *(unsigned char *)(v53 + v45)) == 0 || v48 > 0x3FFFFFFE;
              if (!v54 && v49 < v52 && (v62 & *(unsigned char *)(v53 + v49)) != 0)
              {
                uint64_t result = (*(uint64_t (**)(void, uint64_t *))(**(void **)(v4 + 248) + 248))(*(void *)(v4 + 248), *v43);
                unint64_t v49 = v58;
                unsigned int v48 = v60;
                unsigned __int8 v46 = v63;
                uint64_t v45 = v64;
                if ((uint64_t *)result != v50) {
                  break;
                }
              }
            }
            if (++v43 == v44) {
              goto LABEL_5;
            }
          }
        }
LABEL_25:
        uint64_t result = sub_1CC3318A4(v4, a2, v7);
        if ((result & 1) == 0)
        {
          if (**(_WORD **)(a2 + 16) != 19
            || llvm::MachineInstr::findRegisterDefOperandIdx(a2, v65, 0, 1, *(void *)(v4 + 248)) == -1
            || (uint64_t result = llvm::MachineInstr::findRegisterDefOperandIdx(a2, v65, 0, 0, 0), result != -1))
          {
            uint64_t result = llvm::MachineOperand::setReg((uint64_t)v7, v65);
            unsigned int v21 = *(_DWORD *)(v66 + 32);
            if ((v21 & 0x8000000) == 0) {
              goto LABEL_33;
            }
            uint64_t v22 = *(void *)(v66 + 40);
            if (v22)
            {
              uint64_t v23 = *(void *)(*(void *)(v22 + 16) + 8);
              if ((v21 & 0x1000000) != 0)
              {
                if ((v23 & 0x100000000) != 0)
                {
LABEL_33:
                  *v7 &= ~0x8000000u;
                  unsigned int v21 = *(_DWORD *)(v66 + 32);
                }
              }
              else if ((v23 & 0x80000000) != 0)
              {
                goto LABEL_33;
              }
            }
            *int v7 = *v7 & 0xEFFFFFFF | (((v21 >> 28) & 1) << 28);
            uint64_t v24 = *(void *)(a2 + 8);
            while (v13 != v24)
            {
              uint64_t result = llvm::MachineInstr::clearRegisterKills(v13, v65, *(void *)(v4 + 248));
              uint64_t v13 = *(void *)(v13 + 8);
            }
            *(unsigned char *)(v4 + 472) = 1;
          }
        }
LABEL_5:
        ;
      }
    }
  }
  return result;
}

void sub_1CC3325C4(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  uint64_t v7 = *(void *)(a1 + 248);
  if (v7) {
    unsigned int v8 = (void *)(v7 + 8);
  }
  else {
    unsigned int v8 = 0;
  }
  unint64_t v9 = *(unsigned int *)(*v8 + 24 * a2 + 16);
  uint64_t v10 = (_WORD *)(v8[6] + ((v9 >> 3) & 0x1FFFFFFE));
  unsigned __int16 v11 = *v10 + (v9 & 0xF) * a2;
  uint64_t v12 = a1 + 424;
  uint64_t v13 = a1 + 272;
  unsigned int v14 = (a3 >> 4) ^ (a3 >> 9);
  do
  {
    uint64_t v15 = sub_1CC3319E8(*(void *)(a1 + 448), *(_DWORD *)(a1 + 464), v11, 0);
    uint64_t v41 = v15;
    if (!v15) {
      goto LABEL_48;
    }
    if (a4 == 1)
    {
      uint64_t v16 = v15;
      if (sub_1CC332B30(v13, v15))
      {
        int v17 = *(void **)(a1 + 344);
        uint64_t v18 = *(unsigned int *)(a1 + 352);
        unint64_t v19 = &v17[v18];
        if (v18)
        {
          uint64_t v20 = 8 * v18;
          while (*v17 != v16)
          {
            ++v17;
            v20 -= 8;
            if (!v20)
            {
              int v17 = v19;
              break;
            }
          }
        }
        if (v19 != v17 + 1)
        {
          memmove(v17, v17 + 1, (char *)v19 - (char *)(v17 + 1));
          LODWORD(v18) = *(_DWORD *)(a1 + 352);
        }
        *(_DWORD *)(a1 + 352) = v18 - 1;
      }
      goto LABEL_48;
    }
    sub_1CC331A70(v12, &v41);
    uint64_t v22 = v21;
    uint64_t v24 = *(void *)(v21 + 8);
    uint64_t v23 = (llvm::SmallPtrSetImplBase *)(v21 + 8);
    uint64_t v25 = *(void *)(v22 + 16);
    uint64_t v26 = *(unsigned int *)(v22 + 28);
    if (v25 != v24)
    {
      unsigned int v30 = *(_DWORD *)(v22 + 24);
      goto LABEL_27;
    }
    if (!v26)
    {
LABEL_24:
      unsigned int v30 = *(_DWORD *)(v22 + 24);
      if (v26 < v30)
      {
        *(_DWORD *)(v22 + 28) = v26 + 1;
        *(void *)(v25 + 8 * v26) = a3;
        goto LABEL_48;
      }
LABEL_27:
      if (3 * v30 <= 4 * ((int)v26 - *(_DWORD *)(v22 + 32)))
      {
        if (v30 >= 0x40) {
          v30 *= 2;
        }
        else {
          unsigned int v30 = 128;
        }
      }
      else if (v30 - v26 >= v30 >> 3)
      {
        goto LABEL_29;
      }
      llvm::SmallPtrSetImplBase::Grow(v23, v30);
      unsigned int v30 = *(_DWORD *)(v22 + 24);
      uint64_t v25 = *(void *)(v22 + 16);
LABEL_29:
      unsigned int v31 = v30 - 1;
      unsigned int v32 = (v30 - 1) & v14;
      int v33 = (void *)(v25 + 8 * v32);
      uint64_t v34 = *v33;
      if (*v33 == -1)
      {
        unint64_t v35 = 0;
LABEL_41:
        if (v35) {
          uint64_t v39 = v35;
        }
        else {
          uint64_t v39 = v33;
        }
        if (*v39 != a3)
        {
          if (*v39 == -2) {
            --*(_DWORD *)(v22 + 32);
          }
          else {
            ++*(_DWORD *)(v22 + 28);
          }
          *uint64_t v39 = a3;
        }
      }
      else
      {
        unint64_t v35 = 0;
        int v36 = 1;
        while (v34 != a3)
        {
          if (v35) {
            BOOL v37 = 0;
          }
          else {
            BOOL v37 = v34 == -2;
          }
          if (v37) {
            unint64_t v35 = v33;
          }
          unsigned int v38 = v32 + v36++;
          unsigned int v32 = v38 & v31;
          int v33 = (void *)(v25 + 8 * (v38 & v31));
          uint64_t v34 = *v33;
          if (*v33 == -1) {
            goto LABEL_41;
          }
        }
      }
      goto LABEL_48;
    }
    int v27 = 0;
    uint64_t v28 = 8 * v26;
    unint64_t v29 = *(void **)(v22 + 16);
    while (*v29 != a3)
    {
      if (*v29 == -2) {
        int v27 = v29;
      }
      ++v29;
      v28 -= 8;
      if (!v28)
      {
        if (!v27) {
          goto LABEL_24;
        }
        *int v27 = a3;
        --*(_DWORD *)(v22 + 32);
        break;
      }
    }
LABEL_48:
    int v40 = (unsigned __int16)v10[1];
    ++v10;
    v11 += v40;
  }
  while (v40);
}

void sub_1CC332860(int32x2_t *a1, unsigned int a2, uint64_t a3)
{
  unint64_t v5 = *(unsigned int *)(*(void *)(a3 + 8) + 24 * a2 + 16);
  uint64_t v6 = (_WORD *)(*(void *)(a3 + 56) + ((v5 >> 3) & 0x1FFFFFFE));
  unsigned __int16 v7 = *v6 + (v5 & 0xF) * a2;
  do
  {
    int v8 = v7;
    int32x2_t v9 = *a1;
    unsigned __int32 v10 = a1[2].u32[0];
    if (v10)
    {
      unsigned int v11 = (v10 - 1) & (37 * v8);
      uint64_t v12 = *(void *)&v9 + 56 * v11;
      int v13 = *(_DWORD *)v12;
      if (*(_DWORD *)v12 == v8) {
        goto LABEL_9;
      }
      int v14 = 1;
      while (v13 != -1)
      {
        unsigned int v15 = v11 + v14++;
        unsigned int v11 = v15 & (v10 - 1);
        uint64_t v12 = *(void *)&v9 + 56 * v11;
        int v13 = *(_DWORD *)v12;
        if (*(_DWORD *)v12 == v8) {
          goto LABEL_9;
        }
      }
    }
    uint64_t v12 = *(void *)&v9 + 56 * v10;
LABEL_9:
    if (v12 != *(void *)&v9 + 56 * v10)
    {
      sub_1CC332BC0((uint64_t)a1, *(_DWORD **)(v12 + 16), *(unsigned int *)(v12 + 24), *(void *)(a3 + 8), *(void *)(a3 + 56));
      uint64_t v16 = *(void *)(v12 + 8);
      if (v16)
      {
        int v19 = *(_DWORD *)(*(void *)(v16 + 32) + 4);
        sub_1CC332BC0((uint64_t)a1, &v19, 1, *(void *)(a3 + 8), *(void *)(a3 + 56));
      }
      int v17 = *(void **)(v12 + 16);
      if (v17 != (void *)(v12 + 32)) {
        free(v17);
      }
      *(_DWORD *)uint64_t v12 = -2;
      a1[1] = vadd_s32(a1[1], (int32x2_t)0x1FFFFFFFFLL);
    }
    int v18 = (unsigned __int16)v6[1];
    ++v6;
    unsigned __int16 v7 = v18 + v8;
  }
  while (v18);
}

uint64_t sub_1CC3329CC(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6)
{
  unint64_t v11 = *(unsigned int *)(a5 + 24 * a4 + 16);
  uint64_t v12 = sub_1CC3319E8(a1, a2, (unsigned __int16)(*(_WORD *)(a6 + ((v11 >> 3) & 0x1FFFFFFE)) + (v11 & 0xF) * a4), 1);
  if (!v12) {
    return 0;
  }
  uint64_t v13 = *(void *)(v12 + 32);
  unint64_t v14 = *(unsigned int *)(v13 + 4);
  if (v14 != a4)
  {
    unsigned int v15 = (_WORD *)(a6 + 2 * *(unsigned int *)(a5 + 24 * a4 + 8));
    BOOL v16 = *v15 != 0;
    if (*v15)
    {
      unsigned __int16 v17 = *v15 + a4;
      if (v14 != v17)
      {
        int v18 = v15 + 1;
        do
        {
          int v20 = *v18++;
          int v19 = v20;
          v17 += v20;
          BOOL v16 = v20 != 0;
          if (!v20) {
            int v18 = 0;
          }
          if (v19) {
            BOOL v21 = v14 == v17;
          }
          else {
            BOOL v21 = 1;
          }
        }
        while (!v21);
      }
    }
    if (!v16) {
      return 0;
    }
  }
  if (v12 != a3)
  {
    unint64_t v22 = *(unsigned int *)(v13 + 36);
    unint64_t v23 = v22 >> 5;
    int v24 = 1 << v22;
    unint64_t v25 = v14 >> 5;
    int v26 = 1 << v14;
    uint64_t v27 = v12;
    while (1)
    {
      uint64_t v28 = *(unsigned int *)(v27 + 40);
      if (v28) {
        break;
      }
LABEL_22:
      uint64_t v27 = *(void *)(v27 + 8);
      if (v27 == a3) {
        return v12;
      }
    }
    uint64_t v29 = 32 * v28;
    unsigned int v30 = (void *)(*(void *)(v27 + 32) + 16);
    while (*((unsigned char *)v30 - 16) != 12
         || (*(_DWORD *)(*v30 + 4 * v23) & v24) != 0 && (*(_DWORD *)(*v30 + 4 * v25) & v26) != 0)
    {
      v30 += 4;
      v29 -= 32;
      if (!v29) {
        goto LABEL_22;
      }
    }
    return 0;
  }
  return a3;
}

uint64_t sub_1CC332B30(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v3 = 8;
  }
  else
  {
    int v3 = *(_DWORD *)(a1 + 16);
    if (!v3) {
      return 0;
    }
    uint64_t v2 = *(void *)(a1 + 8);
  }
  int v4 = v3 - 1;
  LODWORD(v5) = (v3 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v6 = (uint64_t *)(v2 + 8 * v5);
  uint64_t v7 = *v6;
  if (*v6 == a2)
  {
LABEL_10:
    uint64_t *v6 = -8192;
    int v10 = *(_DWORD *)(a1 + 4) + 1;
    *(_DWORD *)a1 -= 2;
    *(_DWORD *)(a1 + 4) = v10;
    return 1;
  }
  int v8 = 1;
  while (v7 != -4096)
  {
    int v9 = v5 + v8++;
    uint64_t v5 = v9 & v4;
    uint64_t v7 = *(void *)(v2 + 8 * v5);
    if (v7 == a2)
    {
      uint64_t v6 = (uint64_t *)(v2 + 8 * v5);
      goto LABEL_10;
    }
  }
  return 0;
}

uint64_t sub_1CC332BC0(uint64_t result, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3)
  {
    uint64_t v5 = &a2[a3];
    uint64_t v6 = *(void *)result;
    unsigned int v7 = *(_DWORD *)(result + 16);
    uint64_t v8 = *(void *)result + 56 * v7;
    unsigned int v9 = v7 - 1;
    do
    {
      int v10 = (unsigned __int16 *)(a5
                               + (((unint64_t)*(unsigned int *)(a4 + 24 * *a2 + 16) >> 3) & 0x1FFFFFFE));
      int v11 = *v10 + (*(_DWORD *)(a4 + 24 * *a2 + 16) & 0xF) * *a2;
      do
      {
        if (v7)
        {
          unsigned int v12 = (37 * (unsigned __int16)v11) & v9;
          uint64_t v13 = (int *)(v6 + 56 * v12);
          int v14 = *v13;
          if (*v13 == (unsigned __int16)v11)
          {
LABEL_6:
            if (v13 != (int *)v8) {
              *((unsigned char *)v13 + 48) = 0;
            }
          }
          else
          {
            int v16 = 1;
            while (v14 != -1)
            {
              unsigned int v17 = v12 + v16++;
              unsigned int v12 = v17 & v9;
              uint64_t v13 = (int *)(v6 + 56 * v12);
              int v14 = *v13;
              if (*v13 == (unsigned __int16)v11) {
                goto LABEL_6;
              }
            }
          }
        }
        unsigned int v15 = v10[1];
        ++v10;
        uint64_t result = v15;
        LOWORD(v11) = v15 + v11;
      }
      while (v15);
      ++a2;
    }
    while (a2 != v5);
  }
  return result;
}

uint64_t sub_1CC332C80()
{
  uint64_t result = sub_1CBF64200((llvm::DebugCounter *)"machine-cp-fwd", 0xEuLL, "Controls which register COPYs are forwarded", 0x2BuLL);
  dword_1EBCCE7A0 = result;
  return result;
}

void sub_1CC332CB8(llvm *a1)
{
  llvm::initializeMachineDominatorTreePass((uint64_t)a1);
  llvm::initializeAAResultsWrapperPassPass(a1, v2);
  operator new();
}

void sub_1CC332D60()
{
}

void sub_1CC332EDC(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F260D9F0;
  uint64_t v2 = (void *)*((void *)a1 + 61);
  if (v2 != (void *)((char *)a1 + 504)) {
    free(v2);
  }
  sub_1CC335A64((void *)a1 + 44);
  MEMORY[0x1D25D9CD0](*((void *)a1 + 41), 8);
  MEMORY[0x1D25D9CD0](*((void *)a1 + 38), 8);
  *(void *)a1 = &unk_1F260E110;
  int v3 = (void *)*((void *)a1 + 22);
  if (v3 != (void *)((char *)a1 + 192)) {
    free(v3);
  }
  int v4 = (void *)*((void *)a1 + 13);
  if (v4 != (void *)((char *)a1 + 120)) {
    free(v4);
  }
  uint64_t v5 = (void *)*((void *)a1 + 4);
  if (v5 != (void *)((char *)a1 + 48)) {
    free(v5);
  }

  llvm::Pass::~Pass(a1);
}

void sub_1CC332FC4(llvm::Pass *a1)
{
  sub_1CC332EDC(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC332FFC(llvm::PassRegistry *a1, uint64_t a2)
{
  uint64_t v4 = a2 + 112;
  v6[0] = &unk_1F2617E40;
  v6[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v6);
  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)a1, a2);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::AAResultsWrapperPass::ID);
  sub_1CB843600(a2, v4, (uint64_t)&llvm::MachineLoopInfo::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineDominatorTree::ID);
  sub_1CB843600(a2, v4, (uint64_t)&llvm::MachineDominatorTree::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineBlockFrequencyInfo::ID);

  sub_1CB843600(a2, v4, (uint64_t)&llvm::MachineBlockFrequencyInfo::ID);
}

_DWORD *sub_1CC3330F0(uint64_t a1)
{
  uint64_t v2 = a1 + 304;
  int v3 = *(_DWORD *)(a1 + 312);
  if (v3)
  {
    unsigned int v4 = *(_DWORD *)(a1 + 320);
    if (v4 <= 4 * v3 || v4 < 0x41)
    {
LABEL_4:
      if (v4)
      {
        uint64_t v5 = *(void **)v2;
        uint64_t v6 = 16 * v4;
        do
        {
          *uint64_t v5 = -4096;
          v5 += 2;
          v6 -= 16;
        }
        while (v6);
      }
      *(void *)(a1 + 312) = 0;
      goto LABEL_8;
    }
    int v14 = 1 << (33 - __clz(v3 - 1));
    if (v14 <= 64) {
      int v8 = 64;
    }
    else {
      int v8 = v14;
    }
  }
  else
  {
    if (!*(_DWORD *)(a1 + 316)) {
      goto LABEL_8;
    }
    unsigned int v4 = *(_DWORD *)(a1 + 320);
    if (v4 <= 0x40) {
      goto LABEL_4;
    }
    int v8 = 0;
  }
  if (v8 == v4)
  {
    *(void *)(a1 + 312) = 0;
    uint64_t v15 = 16 * v4;
    int v16 = *(void **)(a1 + 304);
    do
    {
      *int v16 = -4096;
      v16 += 2;
      v15 -= 16;
    }
    while (v15);
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)v2, 8);
    if (v8)
    {
      unint64_t v9 = (4 * v8 / 3u + 1) | ((unint64_t)(4 * v8 / 3u + 1) >> 1);
      unint64_t v10 = v9 | (v9 >> 2) | ((v9 | (v9 >> 2)) >> 4);
      LODWORD(v10) = (((v10 | (v10 >> 8)) >> 16) | v10 | (v10 >> 8)) + 1;
      *(_DWORD *)(a1 + 320) = v10;
      int v11 = operator new(16 * v10, (std::align_val_t)8uLL);
      *(void *)(a1 + 304) = v11;
      *(void *)(a1 + 312) = 0;
      uint64_t v12 = *(unsigned int *)(a1 + 320);
      if (v12)
      {
        uint64_t v13 = 16 * v12;
        do
        {
          *int v11 = -4096;
          v11 += 2;
          v13 -= 16;
        }
        while (v13);
      }
    }
    else
    {
      *(void *)uint64_t v2 = 0;
      *(void *)(v2 + 8) = 0;
      *(_DWORD *)(v2 + 16) = 0;
    }
  }
LABEL_8:
  uint64_t result = sub_1CC335AC8((_DWORD *)(a1 + 328));
  *(_DWORD *)(a1 + 496) = 0;
  return result;
}

uint64_t sub_1CC333254(llvm::FunctionPass *a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t)a1;
  v86[3] = *(void **)MEMORY[0x1E4F143B8];
  if (llvm::FunctionPass::skipFunction(a1, *(llvm::LLVMContextImpl *****)a2))
  {
    char v4 = 0;
    return v4 & 1;
  }
  *(void *)(v3 + 248) = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 104))(*(void *)(a2 + 16));
  *(void *)(v3 + 256) = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 176))(*(void *)(a2 + 16));
  *(void *)(v3 + 280) = *(void *)(a2 + 40);
  uint64_t v5 = *(uint64_t **)(v3 + 8);
  uint64_t v6 = *v5;
  uint64_t v7 = v5[1];
  if (v6 == v7)
  {
LABEL_6:
    uint64_t v8 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v6 != &llvm::AAResultsWrapperPass::ID)
    {
      v6 += 16;
      if (v6 == v7) {
        goto LABEL_6;
      }
    }
    uint64_t v8 = *(void *)(v6 + 8);
  }
  *(void *)(v3 + 264) = *(void *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v8 + 96))(v8, &llvm::AAResultsWrapperPass::ID)+ 32);
  unint64_t v9 = *(uint64_t **)(v3 + 8);
  uint64_t v10 = *v9;
  uint64_t v11 = v9[1];
  if (v10 == v11)
  {
LABEL_11:
    uint64_t v12 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v10 != &llvm::MachineDominatorTree::ID)
    {
      v10 += 16;
      if (v10 == v11) {
        goto LABEL_11;
      }
    }
    uint64_t v12 = *(void *)(v10 + 8);
  }
  *(void *)(v3 + 272) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v12 + 96))(v12, &llvm::MachineDominatorTree::ID);
  uint64_t v13 = *(uint64_t **)(v3 + 8);
  uint64_t v14 = *v13;
  uint64_t v15 = v13[1];
  if (v14 == v15)
  {
LABEL_16:
    uint64_t v16 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v14 != &llvm::MachineBlockFrequencyInfo::ID)
    {
      v14 += 16;
      if (v14 == v15) {
        goto LABEL_16;
      }
    }
    uint64_t v16 = *(void *)(v14 + 8);
  }
  *(void *)(v3 + 288) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v16 + 96))(v16, &llvm::MachineBlockFrequencyInfo::ID);
  *(_DWORD *)(v3 + 296) = (*(uint64_t (**)(void))(**(void **)(v3 + 248) + 1072))();
  unsigned int v17 = lstat;
  uint64_t v71 = v3;
  if ((*(_DWORD *)(*(void *)(a2 + 8) + 472) - 30) > 0xFFFFFFFD)
  {
    char v69 = 0;
    goto LABEL_95;
  }
  uint64_t v18 = *(void *)(v3 + 272);
  int v79 = v81;
  uint64_t v80 = 0x2000000000;
  uint64_t v70 = v3 + 328;
  sub_1CC335AC8((_DWORD *)(v3 + 328));
  llvm::MachineDominatorTree::applySplitCriticalEdges((void ***)v18);
  char v69 = 0;
  v81[0] = *(void *)(*(void *)(v18 + 1320) + 48);
  unsigned int v19 = 1;
  do
  {
    uint64_t v20 = *((void *)v79 + v19 - 1);
    LODWORD(v80) = v19 - 1;
    sub_1CC335B14((unsigned int *)&v79, (uint64_t)v79 + 8 * v19 - 8, *(char **)(v20 + 24), (char *)(*(void *)(v20 + 24) + 8 * *(unsigned int *)(v20 + 32)));
    uint64_t v21 = *(void *)v20;
    uint64_t v22 = *(void *)v20 + 48;
    uint64_t v23 = *(void *)(*(void *)v20 + 56);
    if (v23 != v22)
    {
      uint64_t v24 = 0;
      while (1)
      {
        if (!v23 || (uint64_t v25 = v23, (*(unsigned char *)v23 & 4) == 0))
        {
          uint64_t v25 = v23;
          if ((*(_WORD *)(v23 + 44) & 8) != 0)
          {
            uint64_t v25 = v23;
            do
              uint64_t v25 = *(void *)(v25 + 8);
            while ((*(_WORD *)(v25 + 44) & 8) != 0);
          }
        }
        uint64_t v26 = *(void *)(v25 + 8);
        v83[0] = v84;
        v83[1] = (void *)0x800000000;
        v86[0] = 0;
        v86[1] = 0;
        uint64_t v85 = v86;
        if (!sub_1CC336520(v3, (llvm::MachineInstr *)v23)) {
          goto LABEL_61;
        }
        unsigned int v27 = *(unsigned __int16 *)(v23 + 44);
        BOOL v65 = (v27 & 0xC) == 0;
        int v28 = (v27 >> 2) & 1;
        if (v65) {
          char v29 = 1;
        }
        else {
          char v29 = v28;
        }
        unsigned int v30 = *(unsigned __int16 **)(v23 + 16);
        uint64_t v31 = *((void *)v30 + 1);
        if (v29)
        {
          if ((v31 & 0x800000) != 0) {
            goto LABEL_61;
          }
        }
        else
        {
          uint64_t v36 = v23;
          if ((v31 & 0x800000) != 0) {
            goto LABEL_61;
          }
          while ((*(_WORD *)(v36 + 44) & 8) != 0)
          {
            uint64_t v36 = *(void *)(v36 + 8);
            if ((*(unsigned char *)(*(void *)(v36 + 16) + 10) & 0x80) != 0) {
              goto LABEL_61;
            }
          }
        }
        if (*v30 - 1 > 1 || (*(unsigned char *)(*(void *)(v23 + 32) + 48) & 8) == 0)
        {
          if (v29)
          {
            if ((v31 & 0x40080000) == 0) {
              goto LABEL_36;
            }
          }
          else
          {
            uint64_t v49 = v21;
            uint64_t v50 = v24;
            uint64_t v51 = v23;
            if ((v31 & 0x80000) == 0)
            {
              while ((*(_WORD *)(v51 + 44) & 8) != 0)
              {
                uint64_t v51 = *(void *)(v51 + 8);
                if ((*(unsigned char *)(*(void *)(v51 + 16) + 10) & 8) != 0) {
                  goto LABEL_83;
                }
              }
              uint64_t v52 = *(void *)(v23 + 16);
              for (i = v23; ; uint64_t v52 = *(void *)(i + 16))
              {
                uint64_t v3 = v71;
                if ((*(unsigned char *)(v52 + 11) & 0x40) == 0)
                {
                  uint64_t v24 = v50;
                  uint64_t v21 = v49;
                  if (*(_WORD *)v52 != 20) {
                    break;
                  }
                }
                if ((*(_WORD *)(i + 44) & 8) == 0) {
                  goto LABEL_83;
                }
                uint64_t i = *(void *)(i + 8);
              }
LABEL_36:
              unsigned int v32 = *((unsigned __int8 *)v30 + 4);
              unsigned int v33 = v32;
              if ((v31 & 2) != 0)
              {
                int v42 = *(_DWORD *)(v23 + 40);
                unsigned int v33 = *((unsigned __int8 *)v30 + 4);
                if (v42 != v32)
                {
                  int v43 = v42 - 1;
                  unsigned int v44 = *((unsigned __int8 *)v30 + 4);
                  unsigned int v33 = v44;
                  do
                  {
                    int v45 = *(_DWORD *)(*(void *)(v23 + 32) + 32 * v44);
                    if ((v45 & 0x10000FF) != 0x1000000) {
                      break;
                    }
                    v33 += (v45 & 0x2000000) == 0;
                    if (v43 == v44) {
                      break;
                    }
                    ++v44;
                  }
                  while ((v45 & 0x2000000) == 0);
                }
              }
              uint64_t v34 = *((void *)v30 + 4);
              if (v34)
              {
                unsigned int v35 = -1;
                do
                  ++v35;
                while (*(_WORD *)(v34 + 2 * v35));
              }
              else
              {
                unsigned int v35 = 0;
              }
              if (v35 + v33 == 1)
              {
                if ((v31 & 2) == 0 || (int v46 = *(_DWORD *)(v23 + 40), v46 == v32))
                {
                  unsigned int v37 = v32;
                }
                else
                {
                  int v47 = v46 - 1;
                  unsigned int v37 = v32;
                  do
                  {
                    int v48 = *(_DWORD *)(*(void *)(v23 + 32) + 32 * v32);
                    if ((v48 & 0x10000FF) != 0x1000000) {
                      break;
                    }
                    v37 += (v48 & 0x2000000) == 0;
                    if (v47 == v32) {
                      break;
                    }
                    ++v32;
                  }
                  while ((v48 & 0x2000000) == 0);
                }
                if (v37 == 1)
                {
                  uint64_t v38 = v24;
                  uint64_t v39 = *(unsigned int *)(v23 + 40);
                  if (v39)
                  {
                    uint64_t v40 = 32 * v39;
                    uint64_t v41 = (_DWORD *)(*(void *)(v23 + 32) + 4);
                    do
                    {
                      if (!*(v41 - 1) && (*v41 & 0x80000000) == 0)
                      {
                        if ((*(v41 - 1) & 0x1000000) != 0)
                        {
                          uint64_t v3 = v71;
                          goto LABEL_60;
                        }
                        LODWORD(v75) = *v41;
                        sub_1CC33145C((uint64_t)v83, (unsigned int *)&v75);
                      }
                      v41 += 8;
                      v40 -= 32;
                    }
                    while (v40);
                  }
                  BOOL v75 = (void *)v23;
                  uint64_t v3 = v71;
                  if (sub_1CD52AD70(*(void *)(v71 + 328), (const llvm::MachineInstr *const *)*(unsigned int *)(v71 + 344), (llvm::MachineInstrExpressionTrait *)&v75, (uint64_t **)&v82))
                  {
                    BOOL v75 = (void *)v23;
                    sub_1CD52AE60(v70, (llvm::MachineInstrExpressionTrait *)&v75);
                    llvm::MachineDominatorTree::applySplitCriticalEdges((void ***)v18);
                    llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::findNearestCommonDominator();
                  }
                  BOOL v75 = (void *)v23;
                  sub_1CD52AE60(v70, (llvm::MachineInstrExpressionTrait *)&v75)[1] = v21;
LABEL_60:
                  uint64_t v24 = v38;
                }
              }
              goto LABEL_61;
            }
LABEL_83:
            uint64_t v3 = v71;
            uint64_t v24 = v50;
            uint64_t v21 = v49;
          }
        }
LABEL_61:
        sub_1CD3C5048((uint64_t)&v85, v86[0]);
        if (v83[0] != v84) {
          free(v83[0]);
        }
        uint64_t v23 = v26;
        if (v26 == v22) {
          goto LABEL_90;
        }
      }
    }
    LOBYTE(v24) = 0;
LABEL_90:
    v69 |= v24;
    unsigned int v19 = v80;
  }
  while (v80);
  unsigned int v17 = lstat;
  if (v79 != v81) {
    free(v79);
  }
LABEL_95:
  uint64_t v54 = *(void *)(v3 + 272);
  llvm::MachineDominatorTree::applySplitCriticalEdges((void ***)v54);
  uint64_t v74 = *(void *)(*(void *)(v54 + 1320) + 48);
  uint64_t v55 = v74;
  int v79 = v81;
  uint64_t v80 = *((void *)v17 + 420);
  BOOL v75 = v78;
  int v77 = 8;
  v72[0] = 0;
  v72[1] = 0;
  int v73 = 0;
  *(_DWORD *)(v3 + 1016) = 0;
  v78[0] = v55;
  unsigned int v56 = 1;
  while (2)
  {
    uint64_t v57 = *((void *)v75 + v56 - 1);
    unsigned int v76 = v56 - 1;
    uint64_t v74 = v57;
    if (v80 >= (unint64_t)HIDWORD(v80)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v79 + v80) = v57;
    LODWORD(v80) = v80 + 1;
    uint64_t v58 = v74;
    int v59 = *(_DWORD *)(v74 + 32);
    if (!v73)
    {
      int v67 = 0;
      goto LABEL_111;
    }
    unsigned int v60 = ((v74 >> 4) ^ (v74 >> 9)) & (v73 - 1);
    char v61 = (void *)(v72[0] + 16 * v60);
    uint64_t v62 = *v61;
    if (v74 != *v61)
    {
      int v63 = 0;
      int v64 = 1;
      while (v62 != -4096)
      {
        if (v63) {
          BOOL v65 = 0;
        }
        else {
          BOOL v65 = v62 == -8192;
        }
        if (v65) {
          int v63 = v61;
        }
        unsigned int v66 = v60 + v64++;
        unsigned int v60 = v66 & (v73 - 1);
        char v61 = (void *)(v72[0] + 16 * v60);
        uint64_t v62 = *v61;
        if (v74 == *v61) {
          goto LABEL_112;
        }
      }
      if (v63) {
        int v67 = v63;
      }
      else {
        int v67 = v61;
      }
LABEL_111:
      char v61 = sub_1CC2CE980((uint64_t)v72, (uint64_t)&v74, &v74, v67);
      *char v61 = v74;
      *((_DWORD *)v61 + 2) = 0;
      uint64_t v58 = v74;
    }
LABEL_112:
    *((_DWORD *)v61 + 2) = v59;
    sub_1CC335B14((unsigned int *)&v75, (uint64_t)v75 + 8 * v76, *(char **)(v58 + 24), (char *)(*(void *)(v58 + 24) + 8 * *(unsigned int *)(v58 + 32)));
    unsigned int v56 = v76;
    if (v76) {
      continue;
    }
    break;
  }
  if (v80) {
    operator new();
  }
  MEMORY[0x1D25D9CD0](v72[0], 8);
  if (v75 != v78) {
    free(v75);
  }
  if (v79 != v81) {
    free(v79);
  }
  char v4 = v69;
  return v4 & 1;
}

double sub_1CC3359AC@<D0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + 16) = 1;
  *(void *)a1 = a1 + 16;
  *(void *)&double result = 0x600000001;
  *(void *)(a1 + 8) = 0x600000001;
  *(_DWORD *)(a1 + 64) = 11;
  return result;
}

_DWORD *sub_1CC3359D4(_DWORD *result, int a2)
{
  uint64_t v2 = result;
  if (a2)
  {
    unint64_t v3 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    LODWORD(v4) = (((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8)) + 1;
    result[4] = v4;
    double result = operator new(16 * v4, (std::align_val_t)8uLL);
    *(void *)uint64_t v2 = result;
    *((void *)v2 + 1) = 0;
    uint64_t v5 = v2[4];
    if (v5)
    {
      uint64_t v6 = 16 * v5;
      do
      {
        *(void *)double result = 0;
        result += 4;
        v6 -= 16;
      }
      while (v6);
    }
  }
  else
  {
    *(void *)double result = 0;
    *((void *)result + 1) = 0;
    result[4] = 0;
  }
  return result;
}

void *sub_1CC335A64(void *a1)
{
  a1[4] = 0;
  sub_1CBFFBA64((uint64_t)(a1 + 5));
  MEMORY[0x1D25D9CD0](*a1, 8);
  return a1;
}

BOOL sub_1CC335AA0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 + 1;
  if ((unint64_t)(a2 + 1) >= 2)
  {
    BOOL v3 = v2 != 0;
    BOOL v4 = v2 == 1;
  }
  else
  {
    BOOL v3 = 0;
    BOOL v4 = 0;
  }
  if (!v4 && v3) {
    return llvm::MachineInstr::isIdenticalTo(a1, a2, 3);
  }
  else {
    return a1 == a2;
  }
}

_DWORD *sub_1CC335AC8(_DWORD *result)
{
  if (*((void *)result + 1))
  {
    uint64_t v1 = result[4];
    if (v1 > 4 * result[2] && v1 >= 0x41)
    {
      return sub_1CD52ACC8(result);
    }
    else
    {
      if (v1)
      {
        uint64_t v2 = *(void **)result;
        uint64_t v3 = 16 * v1;
        do
        {
          *uint64_t v2 = 0;
          v2 += 2;
          v3 -= 16;
        }
        while (v3);
      }
      *((void *)result + 1) = 0;
    }
  }
  return result;
}

unsigned int *sub_1CC335B14(unsigned int *result, uint64_t a2, char *__src, char *a4)
{
  uint64_t v5 = __src;
  uint64_t v6 = result;
  uint64_t v7 = *(void *)result;
  uint64_t v8 = result[2];
  unint64_t v9 = result[3];
  size_t v10 = a4 - __src;
  unint64_t v11 = v8 + ((a4 - __src) >> 3);
  if (*(void *)result + 8 * v8 == a2)
  {
    if (v11 > v9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    if (v5 != a4)
    {
      double result = (unsigned int *)memcpy((void *)(v7 + 8 * v8), v5, v10);
      LODWORD(v8) = v6[2];
    }
    void v6[2] = v8 + (v10 >> 3);
  }
  else
  {
    uint64_t v12 = (a2 - v7) >> 3;
    unint64_t v13 = (uint64_t)v10 >> 3;
    if (v11 > v9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v14 = (void *)(v7 + 8 * v12);
    uint64_t v15 = (unsigned char *)(v7 + 8 * v8);
    unint64_t v16 = (v15 - (unsigned char *)v14) >> 3;
    if (v16 >= v13)
    {
      double result = (unsigned int *)sub_1CD4570C8((uint64_t)result, &v15[-8 * v13], (char *)(v7 + 8 * v8));
      if (&v15[-8 * v13] != (unsigned char *)v14) {
        double result = (unsigned int *)memmove(&v14[v13], v14, &v15[-8 * v13] - (unsigned char *)v14);
      }
      if (v5 != a4)
      {
        return (unsigned int *)memmove(v14, v5, v10);
      }
    }
    else
    {
      unsigned int v17 = v8 + (v10 >> 3);
      result[2] = v17;
      if (v12 != v8)
      {
        double result = (unsigned int *)memcpy((void *)(v7 + 8 * v17 - 8 * v16), (const void *)(v7 + 8 * v12), v15 - (unsigned char *)v14);
        do
        {
          uint64_t v18 = *(void *)v5;
          v5 += 8;
          *v14++ = v18;
          --v16;
        }
        while (v16);
      }
      if (v5 != a4)
      {
        return (unsigned int *)memcpy(v15, v5, a4 - v5);
      }
    }
  }
  return result;
}

BOOL sub_1CC335CE4(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t *a5, unsigned char *a6)
{
  uint64_t v9 = a2;
  unint64_t v11 = (void *)a3[3];
  uint64_t v12 = *(void **)(a2 + 24);
  if (v12 != v11)
  {
    unint64_t v13 = (void *)v11[8];
    if (((v11[9] - (void)v13) & 0x7FFFFFFF8) != 8 || (void *)*v13 != v12) {
      return 0;
    }
    uint64_t v15 = *((unsigned int *)a5 + 2);
    if (v15)
    {
      uint64_t v16 = 0;
      unsigned int v17 = *(void **)(a1 + 280);
      uint64_t v18 = *a5;
      uint64_t v19 = 8 * v15;
      do
      {
        if (sub_1CB946A80(v17, *(_DWORD *)(v18 + v16 + 4))) {
          return 0;
        }
        unsigned int v17 = *(void **)(a1 + 280);
        uint64_t v18 = *a5;
        unint64_t v20 = *(unsigned int *)(*a5 + v16 + 4);
        if ((*(void *)(v17[44] + ((v20 >> 3) & 0x1FFFFFF8)) >> v20)) {
          return 0;
        }
        v16 += 8;
      }
      while (v19 != v16);
      if (!v9) {
        goto LABEL_13;
      }
    }
  }
  if ((*(unsigned char *)v9 & 4) == 0)
  {
LABEL_13:
    while ((*(_WORD *)(v9 + 44) & 8) != 0)
      uint64_t v9 = *(void *)(v9 + 8);
  }
  int v21 = *(_DWORD *)(a1 + 296);
  if (v21)
  {
    uint64_t v22 = (void *)(v9 + 8);
    while (1)
    {
      uint64_t v23 = v12 + 6;
      uint64_t v24 = *(unsigned int *)(a4 + 8);
      while (1)
      {
        for (uint64_t i = (void *)*v22; ; uint64_t i = (void *)i[1])
        {
          BOOL v26 = i == a3 || i == v23;
          if (v26 || *(unsigned __int16 *)i[2] - 13 > 4) {
            break;
          }
          if ((*(unsigned char *)i & 4) == 0)
          {
            while ((*((_WORD *)i + 22) & 8) != 0)
              uint64_t i = (void *)i[1];
          }
        }
        if (i == v23) {
          break;
        }
        BOOL result = i == a3;
        if (i == a3) {
          return result;
        }
        uint64_t v28 = *((unsigned int *)i + 10);
        if (v28)
        {
          char v29 = (_DWORD *)i[4];
          unsigned int v30 = &v29[8 * v28];
          do
          {
            if (*v29)
            {
              if (*v29 == 12) {
                return 0;
              }
            }
            else if ((*v29 & 0x1000000) != 0)
            {
              unsigned int v31 = v29[1];
              if ((v31 & 0x80000000) == 0)
              {
                if (*(void *)(a4 + 64))
                {
                  if (*(void *)(a4 + 56))
                  {
                    unsigned int v32 = *(uint64_t **)(a4 + 56);
                    do
                    {
                      unsigned int v33 = *((_DWORD *)v32 + 7);
                      if (v31 >= v33)
                      {
                        if (v33 >= v31) {
                          return 0;
                        }
                        ++v32;
                      }
                      unsigned int v32 = (uint64_t *)*v32;
                    }
                    while (v32);
                  }
                }
                else if (v24)
                {
                  uint64_t v34 = 4 * v24;
                  unsigned int v35 = *(_DWORD **)a4;
                  while (*v35 != v31)
                  {
                    ++v35;
                    v34 -= 4;
                    if (!v34) {
                      goto LABEL_50;
                    }
                  }
                  if (v34) {
                    return 0;
                  }
                }
              }
            }
LABEL_50:
            v29 += 8;
          }
          while (v29 != v30);
          --v21;
          if (!i)
          {
LABEL_57:
            while ((*((_WORD *)i + 22) & 8) != 0)
              uint64_t i = (void *)i[1];
            goto LABEL_58;
          }
        }
        else
        {
          --v21;
        }
        if ((*(unsigned char *)i & 4) == 0) {
          goto LABEL_57;
        }
LABEL_58:
        uint64_t v22 = i + 1;
        if (!v21) {
          return result;
        }
      }
      *a6 = 1;
      uint64_t v22 = v11 + 7;
      uint64_t v12 = v11;
    }
  }
  return 0;
}

uint64_t sub_1CC335F44(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  if ((a2 & 0x80000000) == 0 || (a3 & 0x80000000) == 0) {
    goto LABEL_99;
  }
  size_t v10 = v77;
  int v73 = v77;
  uint64_t v74 = v77;
  uint64_t v75 = 8;
  int v76 = 0;
  uint64_t v11 = *(void *)(*(void *)(a1 + 280) + 24);
  uint64_t v12 = *(void *)(v11 + 16 * (a2 & 0x7FFFFFFF) + 8);
  if (!v12)
  {
LABEL_6:
    unsigned int v13 = 0;
    unsigned int v14 = 8;
    uint64_t v15 = v77;
    goto LABEL_50;
  }
  while ((*(_DWORD *)v12 & 0x81000000) != 0)
  {
    uint64_t v12 = *(void *)(v12 + 24);
    if (!v12) {
      goto LABEL_6;
    }
  }
  unsigned int v13 = 0;
  uint64_t v16 = *(void *)(v12 + 8);
  unsigned int v14 = 8;
  uint64_t v15 = v77;
LABEL_8:
  if (v15 != v10) {
    goto LABEL_18;
  }
  if (v13)
  {
    unsigned int v17 = 0;
    uint64_t v18 = 8 * v13;
    uint64_t v19 = v10;
    while (*v19 != v16)
    {
      if (*v19 == -2) {
        unsigned int v17 = v19;
      }
      ++v19;
      v18 -= 8;
      if (!v18)
      {
        if (!v17) {
          goto LABEL_16;
        }
        void *v17 = v16;
        --v76;
        goto LABEL_38;
      }
    }
    goto LABEL_38;
  }
LABEL_16:
  if (v14 <= v13)
  {
LABEL_18:
    if (3 * v14 <= 4 * (v13 - v76))
    {
      if (v14 >= 0x40) {
        v14 *= 2;
      }
      else {
        unsigned int v14 = 128;
      }
    }
    else if (v14 - v13 >= v14 >> 3)
    {
      goto LABEL_20;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v73, v14);
    unsigned int v14 = v75;
    uint64_t v15 = v74;
LABEL_20:
    unsigned int v20 = v14 - 1;
    unsigned int v21 = (v14 - 1) & ((v16 >> 4) ^ (v16 >> 9));
    uint64_t v22 = &v15[8 * v21];
    uint64_t v23 = *v22;
    if (*v22 == -1)
    {
      uint64_t v24 = 0;
LABEL_32:
      if (v24) {
        uint64_t v22 = v24;
      }
      if (*v22 != v16)
      {
        if (*v22 == -2) {
          --v76;
        }
        else {
          ++HIDWORD(v75);
        }
        *uint64_t v22 = v16;
      }
    }
    else
    {
      uint64_t v24 = 0;
      int v25 = 1;
      while (v23 != v16)
      {
        if (v24) {
          BOOL v26 = 0;
        }
        else {
          BOOL v26 = v23 == -2;
        }
        if (v26) {
          uint64_t v24 = v22;
        }
        unsigned int v27 = v21 + v25++;
        unsigned int v21 = v27 & v20;
        uint64_t v22 = &v15[8 * (v27 & v20)];
        uint64_t v23 = *v22;
        if (*v22 == -1) {
          goto LABEL_32;
        }
      }
    }
    goto LABEL_38;
  }
  HIDWORD(v75) = v13 + 1;
  *(void *)&v10[8 * v13] = v16;
LABEL_38:
  size_t v10 = v73;
  uint64_t v15 = v74;
  unsigned int v14 = v75;
  unsigned int v13 = HIDWORD(v75);
  uint64_t v28 = *(void *)(v12 + 8);
  while (1)
  {
    uint64_t v12 = *(void *)(v12 + 24);
    if (!v12) {
      break;
    }
    if ((*(_DWORD *)v12 & 0x81000000) == 0)
    {
      uint64_t v16 = *(void *)(v12 + 8);
      if (v16 != v28) {
        goto LABEL_8;
      }
    }
  }
  uint64_t v11 = *(void *)(*(void *)(a1 + 280) + 24);
LABEL_50:
  uint64_t v29 = *(void *)(v11 + 16 * (a3 & 0x7FFFFFFF) + 8);
  if (v29)
  {
    while ((*(_DWORD *)v29 & 0x81000000) != 0)
    {
      uint64_t v29 = *(void *)(v29 + 24);
      if (!v29) {
        goto LABEL_53;
      }
    }
    char v30 = 0;
    unsigned int v31 = v14 - 1;
    if (v15 == v10) {
      unsigned int v32 = v13;
    }
    else {
      unsigned int v32 = v14;
    }
    unsigned int v33 = &v15[8 * v32];
    uint64_t v34 = *(void *)(v29 + 8);
    unsigned int v35 = v13;
    uint64_t v36 = v15;
LABEL_58:
    if (v36 == v10)
    {
      unsigned int v37 = &v10[8 * v35];
      if (v35)
      {
        uint64_t v38 = 0;
        while (*(void *)&v10[v38] != v34)
        {
          v38 += 8;
          if (8 * v35 == v38) {
            goto LABEL_77;
          }
        }
        unsigned int v37 = &v10[v38];
      }
LABEL_77:
      uint64_t v36 = v10;
    }
    else
    {
      unsigned int v39 = v31 & ((v34 >> 4) ^ (v34 >> 9));
      uint64_t v40 = &v15[8 * v39];
      uint64_t v41 = *v40;
      if (*v40 == -1)
      {
        int v42 = 0;
LABEL_79:
        if (v42) {
          uint64_t v40 = v42;
        }
        uint64_t v46 = *v40;
      }
      else
      {
        int v42 = 0;
        int v43 = 1;
        while (v41 != v34)
        {
          if (v42) {
            BOOL v44 = 0;
          }
          else {
            BOOL v44 = v41 == -2;
          }
          if (v44) {
            int v42 = v40;
          }
          unsigned int v45 = v39 + v43++;
          unsigned int v39 = v45 & v31;
          uint64_t v40 = &v15[8 * (v45 & v31)];
          uint64_t v41 = *v40;
          if (*v40 == -1) {
            goto LABEL_79;
          }
        }
        uint64_t v46 = v34;
      }
      if (v46 == v34) {
        unsigned int v37 = v40;
      }
      else {
        unsigned int v37 = v33;
      }
      unsigned int v35 = v13;
      uint64_t v36 = v15;
    }
    if (v36 == v10) {
      unsigned int v47 = v35;
    }
    else {
      unsigned int v47 = v14;
    }
    if (v37 == &v36[8 * v47])
    {
      char v30 = 1;
    }
    else
    {
      while (1)
      {
        uint64_t v29 = *(void *)(v29 + 24);
        if (!v29) {
          break;
        }
        if ((*(_DWORD *)v29 & 0x81000000) == 0 && *(void *)(v29 + 8) != v34)
        {
          uint64_t v34 = *(void *)(v29 + 8);
          goto LABEL_58;
        }
      }
    }
    uint64_t v15 = v36;
  }
  else
  {
LABEL_53:
    char v30 = 0;
  }
  if (v15 != v10) {
    free(v15);
  }
  if ((v30 & 1) == 0) {
    goto LABEL_156;
  }
LABEL_99:
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 248) + 152))(*(void *)(a1 + 248), a5))
  {
    uint64_t v48 = *(void *)(a5 + 24);
    if (v48 != a4)
    {
      uint64_t v49 = *(void **)(a4 + 88);
      uint64_t v50 = *(void **)(a4 + 96);
      if (v49 != v50)
      {
        while (*v49 != v48)
        {
          if (++v49 == v50)
          {
            uint64_t v49 = *(void **)(a4 + 96);
            break;
          }
        }
      }
      if (v49 == v50) {
        goto LABEL_130;
      }
    }
  }
  uint64_t v51 = *(unsigned int *)(a5 + 40);
  if (!v51)
  {
LABEL_111:
    uint64_t v54 = *(void *)(a1 + 280);
    if ((a3 & 0x80000000) != 0) {
      uint64_t v55 = (uint64_t *)(*(void *)(v54 + 24) + 16 * (a3 & 0x7FFFFFFF) + 8);
    }
    else {
      uint64_t v55 = (uint64_t *)(*(void *)(v54 + 272) + 8 * a3);
    }
    uint64_t v56 = *v55;
    if (v56)
    {
      while ((*(_DWORD *)v56 & 0x81000000) != 0)
      {
        uint64_t v56 = *(void *)(v56 + 24);
        if (!v56) {
          goto LABEL_130;
        }
      }
      char v57 = 0;
      uint64_t v58 = *(void *)(v56 + 8);
LABEL_118:
      int v59 = **(unsigned __int16 **)(v58 + 16);
      BOOL v60 = v59 != 19;
      if (v59 == 11) {
        BOOL v60 = 0;
      }
      v57 |= v60;
      if (v59 == 19 || v59 == 11)
      {
        while (1)
        {
          uint64_t v56 = *(void *)(v56 + 24);
          if (!v56) {
            break;
          }
          if ((*(_DWORD *)v56 & 0x81000000) == 0 && *(void *)(v56 + 8) != v58)
          {
            uint64_t v58 = *(void *)(v56 + 8);
            goto LABEL_118;
          }
        }
      }
      if (v57) {
        goto LABEL_132;
      }
    }
LABEL_130:
    char v62 = 0;
    return v62 & 1;
  }
  uint64_t v52 = 32 * v51;
  uint64_t v53 = (_DWORD *)(*(void *)(a5 + 32) + 4);
  while ((*(v53 - 1) & 0x10000FF) != 0 || (*v53 & 0x80000000) == 0)
  {
    v53 += 8;
    v52 -= 32;
    if (!v52) {
      goto LABEL_111;
    }
  }
  uint64_t v54 = *(void *)(a1 + 280);
LABEL_132:
  if ((a2 & 0x80000000) != 0) {
    int v63 = (uint64_t *)(*(void *)(v54 + 24) + 16 * (a2 & 0x7FFFFFFF) + 8);
  }
  else {
    int v63 = (uint64_t *)(*(void *)(v54 + 272) + 8 * a2);
  }
  uint64_t v64 = *v63;
  if (!v64) {
    goto LABEL_156;
  }
  while ((*(_DWORD *)v64 & 0x81000000) != 0)
  {
    uint64_t v64 = *(void *)(v64 + 24);
    if (!v64) {
      goto LABEL_156;
    }
  }
  uint64_t v65 = *(void *)(a5 + 24);
  uint64_t v66 = *(void *)(v64 + 8);
  if (*(void *)(v66 + 24) == v65)
  {
LABEL_156:
    char v62 = 1;
    return v62 & 1;
  }
  if (**(_WORD **)(v66 + 16)) {
    BOOL v67 = **(unsigned __int16 **)(v66 + 16) == 69;
  }
  else {
    BOOL v67 = 1;
  }
  char v68 = v67;
  while (1)
  {
    uint64_t v64 = *(void *)(v64 + 24);
    if (!v64) {
      break;
    }
    if ((*(_DWORD *)v64 & 0x81000000) == 0)
    {
      uint64_t v69 = *(void *)(v64 + 8);
      if (v69 != v66)
      {
        BOOL v70 = !**(_WORD **)(v69 + 16) || **(_WORD **)(v69 + 16) == 69;
        BOOL v71 = v70;
        v68 |= v71;
        char v62 = 1;
        uint64_t v66 = *(void *)(v64 + 8);
        if (*(void *)(v69 + 24) == v65) {
          return v62 & 1;
        }
      }
    }
  }
  char v62 = v68 ^ 1;
  return v62 & 1;
}

BOOL sub_1CC336520(uint64_t a1, llvm::MachineInstr *this)
{
  uint64_t v2 = (unsigned __int16 *)*((void *)this + 2);
  unsigned int v3 = *v2;
  if (v3 - 3 < 4) {
    return 0;
  }
  BOOL v4 = v3 - 7 > 0x3E || ((1 << (v3 - 7)) & 0x40000000000017D9) == 0;
  BOOL v5 = v4 && v3 >= 3;
  if (!v5 || v3 - 1 <= 1 && (*(unsigned char *)(*((void *)this + 4) + 48) & 0x10) != 0) {
    return 0;
  }
  __int16 v9 = *((_WORD *)this + 22);
  BOOL v10 = (v9 & 0xC) == 0 || (v9 & 4) != 0;
  uint64_t v11 = *((void *)v2 + 1);
  if (v10)
  {
    if ((v11 & 0x100280) != 0) {
      return 0;
    }
    if ((v11 & 0x200000) == 0) {
      goto LABEL_18;
    }
  }
  else
  {
    if ((v11 & 0x100000) != 0) {
      return 0;
    }
    uint64_t v12 = this;
    while ((*((_WORD *)v12 + 22) & 8) != 0)
    {
      uint64_t v6 = 0;
      uint64_t v12 = (llvm::MachineInstr *)*((void *)v12 + 1);
      if ((*(unsigned char *)(*((void *)v12 + 2) + 10) & 0x10) != 0) {
        return v6;
      }
    }
    if ((v11 & 0x80) != 0) {
      return 0;
    }
    unsigned int v13 = this;
    while ((*((_WORD *)v13 + 22) & 8) != 0)
    {
      uint64_t v6 = 0;
      unsigned int v13 = (llvm::MachineInstr *)*((void *)v13 + 1);
      if ((*(unsigned char *)(*((void *)v13 + 2) + 8) & 0x80) != 0) {
        return v6;
      }
    }
    if ((v11 & 0x200) != 0) {
      return 0;
    }
    unsigned int v14 = this;
    while ((*((_WORD *)v14 + 22) & 8) != 0)
    {
      uint64_t v6 = 0;
      unsigned int v14 = (llvm::MachineInstr *)*((void *)v14 + 1);
      if ((*(unsigned char *)(*((void *)v14 + 2) + 9) & 2) != 0) {
        return v6;
      }
    }
    if ((v11 & 0x200000) == 0)
    {
      uint64_t v15 = this;
      while ((*((_WORD *)v15 + 22) & 8) != 0)
      {
        uint64_t v15 = (llvm::MachineInstr *)*((void *)v15 + 1);
        if ((*(unsigned char *)(*((void *)v15 + 2) + 10) & 0x20) != 0) {
          goto LABEL_46;
        }
      }
      goto LABEL_47;
    }
  }
LABEL_46:
  if ((*((_WORD *)this + 22) & 0x4000) == 0) {
    return 0;
  }
LABEL_47:
  if (v10)
  {
LABEL_18:
    if ((v11 & 0x1000000) != 0) {
      return 0;
    }
    goto LABEL_19;
  }
  if ((v11 & 0x1000000) != 0) {
    return 0;
  }
  uint64_t v16 = this;
  while ((*((_WORD *)v16 + 22) & 8) != 0)
  {
    uint64_t v6 = 0;
    uint64_t v16 = (llvm::MachineInstr *)*((void *)v16 + 1);
    if (*(unsigned char *)(*((void *)v16 + 2) + 11)) {
      return v6;
    }
  }
LABEL_19:
  if (v3 - 1 > 1) {
    goto LABEL_20;
  }
  uint64_t v17 = *(void *)(*((void *)this + 4) + 48);
  if (v17) {
    return 0;
  }
  if ((v17 & 8) == 0)
  {
LABEL_20:
    if (v10)
    {
      if ((v11 & 0x80000) == 0) {
        return v3 != 28;
      }
    }
    else if ((v11 & 0x80000) == 0)
    {
      uint64_t v18 = this;
      while ((*((_WORD *)v18 + 22) & 8) != 0)
      {
        uint64_t v18 = (llvm::MachineInstr *)*((void *)v18 + 1);
        if ((*(unsigned char *)(*((void *)v18 + 2) + 10) & 8) != 0) {
          goto LABEL_22;
        }
      }
      return v3 != 28;
    }
  }
LABEL_22:
  if (llvm::MachineInstr::isDereferenceableInvariantLoad(this, *(llvm::AAResults **)(a1 + 264)))
  {
    unsigned int v3 = **((unsigned __int16 **)this + 2);
    return v3 != 28;
  }
  return 0;
}

void *sub_1CC336704(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  BOOL v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  BOOL result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      uint64_t v11 = 16 * v10;
      do
      {
        *BOOL result = -4096;
        result += 2;
        v11 -= 16;
      }
      while (v11);
    }
    if (v3)
    {
      int v12 = 0;
      int v13 = v10 - 1;
      unsigned int v14 = v4;
      do
      {
        uint64_t v15 = *v14;
        if ((*v14 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          unsigned int v16 = ((v15 >> 4) ^ (v15 >> 9)) & v13;
          uint64_t v17 = (void *)(*(void *)a1 + 16 * v16);
          uint64_t v18 = *v17;
          if (v15 != *v17)
          {
            uint64_t v19 = 0;
            int v20 = 1;
            while (v18 != -4096)
            {
              if (v19) {
                BOOL v21 = 0;
              }
              else {
                BOOL v21 = v18 == -8192;
              }
              if (v21) {
                uint64_t v19 = v17;
              }
              unsigned int v22 = v16 + v20++;
              unsigned int v16 = v22 & v13;
              uint64_t v17 = (void *)(*(void *)a1 + 16 * (v22 & v13));
              uint64_t v18 = *v17;
              if (v15 == *v17) {
                goto LABEL_25;
              }
            }
            if (v19) {
              uint64_t v17 = v19;
            }
          }
LABEL_25:
          void *v17 = v15;
          v17[1] = v14[1];
          *(_DWORD *)(a1 + 8) = ++v12;
        }
        v14 += 2;
      }
      while (v14 != &v4[2 * v3]);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v23 = *(unsigned int *)(a1 + 16);
  if (v23)
  {
    uint64_t v24 = 16 * v23;
    do
    {
      *BOOL result = -4096;
      result += 2;
      v24 -= 16;
    }
    while (v24);
  }
  return result;
}

uint64_t sub_1CC336894(uint64_t *a1, const llvm::MachineInstr *const *a2)
{
  uint64_t v15 = a2;
  uint64_t v2 = *a1;
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    int HashValue = llvm::MachineInstrExpressionTrait::getHashValue((llvm::MachineInstrExpressionTrait *)&v15, a2);
    unsigned int v7 = v3 - 1;
    for (int i = 1; ; ++i)
    {
      int v9 = HashValue & v7;
      uint64_t v10 = (uint64_t *)(v2 + 16 * (HashValue & v7));
      uint64_t v11 = *v10;
      if ((unint64_t)(*v10 + 1) >= 2 && (unint64_t)a2 + 1 > 1)
      {
        if (llvm::MachineInstr::isIdenticalTo((uint64_t)a2, v11, 3))
        {
LABEL_18:
          uint64_t v2 = *a1;
          uint64_t v13 = *((unsigned int *)a1 + 4);
          goto LABEL_14;
        }
        if (!*v10) {
          goto LABEL_12;
        }
      }
      else
      {
        if ((const llvm::MachineInstr *const *)v11 == a2) {
          goto LABEL_18;
        }
        if (!v11)
        {
LABEL_12:
          uint64_t v2 = *a1;
          uint64_t v13 = *((unsigned int *)a1 + 4);
          goto LABEL_13;
        }
      }
      int HashValue = v9 + i;
    }
  }
  uint64_t v13 = 0;
LABEL_13:
  uint64_t v10 = (uint64_t *)(v2 + 16 * v13);
LABEL_14:
  if (v10 == (uint64_t *)(v2 + 16 * v13)) {
    return 0;
  }
  else {
    return *(unsigned int *)(v10[1] + 24);
  }
}

uint64_t sub_1CC336984(uint64_t a1, uint64_t a2, llvm::MachineInstrExpressionTrait *this, _DWORD *a4)
{
  int v7 = *(_DWORD *)(a1 + 16);
  if (v7)
  {
    uint64_t v8 = *(void *)a1;
    uint64_t result = llvm::MachineInstrExpressionTrait::getHashValue(this, (const llvm::MachineInstr *const *)a2);
    uint64_t v10 = 0;
    int v11 = v7 - 1;
    for (int i = 1; ; ++i)
    {
      unsigned int v13 = result & v11;
      unsigned int v14 = (uint64_t *)(v8 + 16 * (result & v11));
      uint64_t v15 = *v14;
      if ((unint64_t)(*v14 + 1) < 2
        || (uint64_t result = *(void *)this, (unint64_t)(*(void *)this + 1) <= 1))
      {
        if (*(void *)this == v15) {
          goto LABEL_15;
        }
      }
      else
      {
        uint64_t result = llvm::MachineInstr::isIdenticalTo(result, v15, 3);
        if (result)
        {
LABEL_15:
          uint64_t v17 = v14[1];
          goto LABEL_20;
        }
        uint64_t v15 = *v14;
      }
      if (!v15) {
        break;
      }
      if (v10) {
        BOOL v16 = 0;
      }
      else {
        BOOL v16 = v15 == -1;
      }
      if (v16) {
        uint64_t v10 = (uint64_t *)(v8 + 16 * v13);
      }
      uint64_t result = v13 + i;
    }
    if (v10) {
      uint64_t v18 = v10;
    }
    else {
      uint64_t v18 = (uint64_t *)(v8 + 16 * v13);
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  uint64_t result = (uint64_t)sub_1CC336C60(a1, this, v18);
  unsigned int v14 = (uint64_t *)result;
  uint64_t v17 = 0;
  *(void *)uint64_t result = *(void *)this;
  *(void *)(result + 8) = 0;
LABEL_20:
  uint64_t v19 = *(void *)(a2 + 16);
  unint64_t v20 = *(void *)(a1 + 32);
  if (v20)
  {
    *(void *)(a1 + 32) = *(void *)v20;
  }
  else
  {
    *(void *)(a1 + 120) += 32;
    uint64_t v21 = *(void *)(a1 + 40);
    if (((v21 + 7) & 0xFFFFFFFFFFFFFFF8) - v21 + 32 > *(void *)(a1 + 48) - v21)
    {
      uint64_t v22 = v17;
      unsigned int v23 = *(_DWORD *)(a1 + 64) >> 7;
      if (v23 >= 0x1E) {
        LOBYTE(v23) = 30;
      }
      uint64_t v24 = 4096 << v23;
      uint64_t result = (uint64_t)operator new(4096 << v23, (std::align_val_t)8uLL);
      unsigned int v25 = *(_DWORD *)(a1 + 64);
      if (v25 >= *(_DWORD *)(a1 + 68)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      unint64_t v20 = result;
      *(void *)(*(void *)(a1 + 56) + 8 * v25) = result;
      ++*(_DWORD *)(a1 + 64);
      *(void *)(a1 + 40) = result + 32;
      *(void *)(a1 + 48) = result + v24;
      uint64_t v17 = v22;
    }
    else
    {
      unint64_t v20 = (v21 + 7) & 0xFFFFFFFFFFFFFFF8;
      *(void *)(a1 + 40) = v20 + 32;
    }
  }
  *(void *)(v20 + 16) = *(void *)this;
  *(_DWORD *)(v20 + 24) = *a4;
  *(void *)unint64_t v20 = v19;
  *(void *)(v20 + 8) = v17;
  v14[1] = v20;
  *(void *)(a2 + 16) = v20;
  return result;
}

uint64_t sub_1CC336B84(uint64_t result, const llvm::MachineInstr *const *a2, llvm::MachineInstrExpressionTrait *this, uint64_t **a4)
{
  if (a2)
  {
    int v6 = (int)a2;
    uint64_t v7 = result;
    uint64_t result = llvm::MachineInstrExpressionTrait::getHashValue(this, a2);
    uint64_t v8 = 0;
    int v9 = v6 - 1;
    for (int i = 1; ; ++i)
    {
      unsigned int v11 = result & v9;
      int v12 = (uint64_t *)(v7 + 16 * (result & v9));
      uint64_t v13 = *v12;
      if ((unint64_t)(*v12 + 1) < 2
        || (uint64_t result = *(void *)this, (unint64_t)(*(void *)this + 1) <= 1))
      {
        if (*(void *)this == v13) {
          goto LABEL_17;
        }
      }
      else
      {
        uint64_t result = llvm::MachineInstr::isIdenticalTo(result, v13, 3);
        if (result) {
          goto LABEL_17;
        }
        uint64_t v13 = *v12;
      }
      if (!v13) {
        break;
      }
      if (v8) {
        BOOL v14 = 0;
      }
      else {
        BOOL v14 = v13 == -1;
      }
      if (v14) {
        uint64_t v8 = (uint64_t *)(v7 + 16 * v11);
      }
      uint64_t result = v11 + i;
    }
    if (v8) {
      int v12 = v8;
    }
  }
  else
  {
    int v12 = 0;
  }
LABEL_17:
  *a4 = v12;
  return result;
}

uint64_t *sub_1CC336C60(uint64_t a1, llvm::MachineInstrExpressionTrait *a2, uint64_t *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    sub_1CC336DE8(a1, 2 * v6);
    unsigned int v25 = 0;
    sub_1CC336B84(*(void *)a1, (const llvm::MachineInstr *const *)*(unsigned int *)(a1 + 16), a2, &v25);
    a3 = v25;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) <= v6 >> 3)
  {
    sub_1CC336DE8(a1, v6);
    int v9 = *(_DWORD *)(a1 + 16);
    if (v9)
    {
      uint64_t v10 = *(void *)a1;
      unsigned int HashValue = llvm::MachineInstrExpressionTrait::getHashValue(a2, v8);
      uint64_t v12 = v10;
      uint64_t v13 = 0;
      int v14 = v9 - 1;
      for (int i = 1; ; ++i)
      {
        unsigned int v16 = HashValue & v14;
        a3 = (uint64_t *)(v12 + 16 * (HashValue & v14));
        uint64_t v17 = *a3;
        if ((unint64_t)(*a3 + 1) < 2 || (unint64_t)(*(void *)a2 + 1) <= 1)
        {
          if (*(void *)a2 == v17) {
            goto LABEL_3;
          }
        }
        else
        {
          int v22 = v14;
          int v23 = HashValue & v14;
          int v21 = i;
          uint64_t v19 = v13;
          uint64_t v20 = v12;
          uint64_t v24 = (uint64_t *)(v12 + 16 * v16);
          if (llvm::MachineInstr::isIdenticalTo(*(void *)a2, v17, 3))
          {
            a3 = v24;
            goto LABEL_3;
          }
          a3 = v24;
          uint64_t v17 = *v24;
          uint64_t v13 = v19;
          uint64_t v12 = v20;
          int i = v21;
          int v14 = v22;
          unsigned int v16 = v23;
        }
        if (!v17) {
          break;
        }
        if (v13) {
          BOOL v18 = 0;
        }
        else {
          BOOL v18 = v17 == -1;
        }
        if (v18) {
          uint64_t v13 = a3;
        }
        unsigned int HashValue = v16 + i;
      }
      if (v13) {
        a3 = v13;
      }
    }
    else
    {
      a3 = 0;
    }
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CC336DE8(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  BOOL v4 = *(llvm::MachineInstrExpressionTrait **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v11 = *(unsigned int *)(a1 + 16);
    if (v11)
    {
      uint64_t v12 = 16 * v11;
      do
      {
        *uint64_t result = 0;
        result += 2;
        v12 -= 16;
      }
      while (v12);
    }
    if (v3)
    {
      uint64_t v13 = (llvm::MachineInstrExpressionTrait *)((char *)v4 + 16 * v3);
      int v14 = v4;
      do
      {
        if ((unint64_t)(*(void *)v14 + 1) >= 2)
        {
          uint64_t v15 = *(llvm::MachineInstrExpressionTrait **)a1;
          int v16 = *(_DWORD *)(a1 + 16);
          unsigned int HashValue = llvm::MachineInstrExpressionTrait::getHashValue(v14, v10);
          uint64_t v18 = 0;
          int v19 = v16 - 1;
          for (int i = 1; ; ++i)
          {
            unsigned int v21 = HashValue & v19;
            uint64_t v22 = (uint64_t)v15 + 16 * (HashValue & v19);
            uint64_t v10 = *(const llvm::MachineInstr *const **)v22;
            if ((unint64_t)(*(void *)v22 + 1) < 2 || (unint64_t)(*(void *)v14 + 1) <= 1)
            {
              if (*(const llvm::MachineInstr *const **)v14 == v10) {
                goto LABEL_28;
              }
            }
            else
            {
              if (llvm::MachineInstr::isIdenticalTo(*(void *)v14, (uint64_t)v10, 3)) {
                goto LABEL_28;
              }
              uint64_t v10 = *(const llvm::MachineInstr *const **)v22;
            }
            if (!v10) {
              break;
            }
            if (v18) {
              BOOL v23 = 0;
            }
            else {
              BOOL v23 = v10 == (const llvm::MachineInstr *const *)-1;
            }
            if (v23) {
              uint64_t v18 = (uint64_t)v15 + 16 * v21;
            }
            unsigned int HashValue = v21 + i;
          }
          if (v18) {
            uint64_t v22 = v18;
          }
LABEL_28:
          *(void *)uint64_t v22 = *(void *)v14;
          *(void *)(v22 + 8) = *((void *)v14 + 1);
          ++*(_DWORD *)(a1 + 8);
        }
        int v14 = (llvm::MachineInstrExpressionTrait *)((char *)v14 + 16);
      }
      while (v14 != v13);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v24 = *(unsigned int *)(a1 + 16);
  if (v24)
  {
    uint64_t v25 = 16 * v24;
    do
    {
      *uint64_t result = 0;
      result += 2;
      v25 -= 16;
    }
    while (v25);
  }
  return result;
}

int32x2_t sub_1CC336FC8(int32x2_t *a1, const llvm::MachineInstr *const *a2)
{
  int32x2_t v3 = a1[38];
  uint64_t v4 = a1[40].u32[0];
  if (v4)
  {
    LODWORD(v5) = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    unint64_t v6 = (const llvm::MachineInstr *const **)(*(void *)&v3 + 16 * v5);
    int v7 = *v6;
    if (*v6 == a2) {
      goto LABEL_3;
    }
    int v30 = 1;
    while (v7 != (const llvm::MachineInstr *const *)-4096)
    {
      int v31 = v5 + v30++;
      uint64_t v5 = v31 & (v4 - 1);
      int v7 = *(const llvm::MachineInstr *const **)(*(void *)&v3 + 16 * v5);
      if (v7 == a2)
      {
        unint64_t v6 = (const llvm::MachineInstr *const **)(*(void *)&v3 + 16 * v5);
        goto LABEL_3;
      }
    }
  }
  unint64_t v6 = (const llvm::MachineInstr *const **)(*(void *)&v3 + 16 * v4);
LABEL_3:
  unsigned int v8 = (int32x2_t **)v6[1];
  int v9 = (int32x2_t *)&unk_1CD91C000;
  if (v8)
  {
    unsigned int v33 = v6;
    uint64_t v10 = *v8;
    (*v8)[3] = (int32x2_t)v8[1];
    uint64_t v11 = v8[2];
    if (v11)
    {
      do
      {
        uint64_t v12 = (uint64_t *)&v11[2];
        int32x2_t v13 = *v10;
        __int32 v14 = v10[2].i32[0];
        if (!*(void *)&v11[1])
        {
          if (!v14) {
            goto LABEL_17;
          }
          int HashValue = llvm::MachineInstrExpressionTrait::getHashValue((llvm::MachineInstrExpressionTrait *)&v11[2], a2);
          __int32 v16 = v14 - 1;
          for (int i = 1; ; ++i)
          {
            int v18 = HashValue & v16;
            int v19 = (const llvm::MachineInstr *const **)(*(void *)&v13 + 16 * (HashValue & v16));
            a2 = *v19;
            if ((unint64_t)*v19 + 1 < 2 || (unint64_t)(*v12 + 1) <= 1)
            {
              if ((const llvm::MachineInstr *const *)*v12 == a2) {
                goto LABEL_16;
              }
              if (!a2) {
                goto LABEL_17;
              }
            }
            else
            {
              if (llvm::MachineInstr::isIdenticalTo(*v12, (uint64_t)a2, 3))
              {
LABEL_16:
                *int v19 = (const llvm::MachineInstr *const *)-1;
                v10[1] = vadd_s32(v10[1], (int32x2_t)0x1FFFFFFFFLL);
                goto LABEL_17;
              }
              a2 = *v19;
              if (!*v19) {
                goto LABEL_17;
              }
            }
            int HashValue = v18 + i;
          }
        }
        if (v14)
        {
          unsigned int v21 = llvm::MachineInstrExpressionTrait::getHashValue((llvm::MachineInstrExpressionTrait *)&v11[2], a2);
          uint64_t v22 = 0;
          __int32 v23 = v14 - 1;
          for (int j = 1; ; ++j)
          {
            unsigned int v25 = v21 & v23;
            BOOL v26 = (uint64_t *)(*(void *)&v13 + 16 * (v21 & v23));
            a2 = (const llvm::MachineInstr *const *)*v26;
            if ((unint64_t)(*v26 + 1) < 2 || (unint64_t)(*v12 + 1) <= 1)
            {
              if ((const llvm::MachineInstr *const *)*v12 == a2) {
                goto LABEL_37;
              }
            }
            else
            {
              __int32 v32 = v23;
              if (llvm::MachineInstr::isIdenticalTo(*v12, (uint64_t)a2, 3)) {
                goto LABEL_37;
              }
              a2 = (const llvm::MachineInstr *const *)*v26;
              __int32 v23 = v32;
            }
            if (!a2) {
              break;
            }
            if (v22) {
              BOOL v27 = 0;
            }
            else {
              BOOL v27 = a2 == (const llvm::MachineInstr *const *)-1;
            }
            if (v27) {
              uint64_t v22 = (uint64_t *)(*(void *)&v13 + 16 * v25);
            }
            unsigned int v21 = v25 + j;
          }
          if (v22) {
            uint64_t v28 = v22;
          }
          else {
            uint64_t v28 = (uint64_t *)(*(void *)&v13 + 16 * v25);
          }
        }
        else
        {
          uint64_t v28 = 0;
        }
        BOOL v26 = sub_1CC336C60((uint64_t)v10, (llvm::MachineInstrExpressionTrait *)&v11[2], v28);
        *BOOL v26 = *v12;
        v26[1] = 0;
LABEL_37:
        v26[1] = (uint64_t)v11[1];
LABEL_17:
        uint64_t v20 = (int32x2_t *)*v11;
        v8[2] = (int32x2_t *)*v11;
        uint64_t v10 = *v8;
        *uint64_t v11 = (*v8)[4];
        v10[4] = (int32x2_t)v11;
        uint64_t v11 = v20;
      }
      while (v20);
    }
    MEMORY[0x1D25D9CE0](v8, 0x20C40960023A9);
    unint64_t v6 = v33;
    int v9 = (int32x2_t *)&unk_1CD91C000;
  }
  _DWORD *v6 = (const llvm::MachineInstr *const *)-8192;
  int32x2_t result = vadd_s32(a1[39], v9[12]);
  a1[39] = result;
  return result;
}

void sub_1CC337250()
{
}

void sub_1CC3372EC()
{
}

void sub_1CC33734C(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC337384(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

uint64_t sub_1CC3373BC(uint64_t a1, llvm::Module **this)
{
  uint64_t v141 = *MEMORY[0x1E4F143B8];
  v138[0] = "llvm.mir.debugify";
  v139[8] = 259;
  uint64_t NamedMetadata = llvm::Module::getNamedMetadata((llvm::Module *)this, (const char **)v138);
  if (NamedMetadata)
  {
    uint64_t v5 = NamedMetadata;
    unint64_t v6 = *(uint64_t **)(a1 + 8);
    uint64_t v7 = *v6;
    uint64_t v8 = v6[1];
    if (v7 == v8)
    {
LABEL_5:
      uint64_t v9 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v7 != &llvm::MachineModuleInfoWrapperPass::ID)
      {
        v7 += 16;
        if (v7 == v8) {
          goto LABEL_5;
        }
      }
      uint64_t v9 = *(void *)(v7 + 8);
    }
    uint64_t v12 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v9 + 96))(v9, &llvm::MachineModuleInfoWrapperPass::ID);
    int32x2_t v13 = **(void ***)(v5 + 48);
    uint64_t v14 = *(void *)(*(void *)(*v13 - 8 * *(unsigned int *)(*v13 + 8)) + 128);
    uint64_t v15 = (void *)(v14 + 24);
    if (*(_DWORD *)(v14 + 32) >= 0x41u) {
      uint64_t v15 = (void *)*v15;
    }
    int v16 = *(_DWORD *)v15;
    uint64_t v17 = *(void *)(*(void *)(v13[1] - 8 * *(unsigned int *)(v13[1] + 8)) + 128);
    int v18 = (void *)(v17 + 24);
    if (*(_DWORD *)(v17 + 32) >= 0x41u) {
      int v18 = (void *)*v18;
    }
    int v19 = *(_DWORD *)v18;
    sub_1CB9F9A80((uint64_t)v138, v16, 1);
    MachineFunction = (llvm *)sub_1CB9F9A80((uint64_t)&v135, v19, 1);
    unsigned int v21 = this[4];
    if (v21 != (llvm::Module *)(this + 3))
    {
      uint64_t v128 = (llvm::MachineModuleInfo *)(v12 + 32);
      while (1)
      {
        uint64_t v129 = v21;
        uint64_t v22 = v21 ? (const Function *)((char *)v21 - 56) : 0;
        MachineFunction = (llvm *)llvm::MachineModuleInfo::getMachineFunction(v128, v22);
        if (MachineFunction)
        {
          __int32 v23 = (void *)*((void *)MachineFunction + 41);
          uint64_t v130 = (void *)((char *)MachineFunction + 320);
          if (v23 != (void *)((char *)MachineFunction + 320)) {
            break;
          }
        }
LABEL_102:
        unsigned int v21 = (llvm::Module *)*((void *)v129 + 1);
        if (v21 == (llvm::Module *)(this + 3)) {
          goto LABEL_103;
        }
      }
      unsigned int v131 = (v22 >> 4) ^ (v22 >> 9);
      int v132 = v22;
LABEL_21:
      uint64_t v24 = v23 + 6;
      uint64_t v25 = v23[7];
      if ((void *)v25 == v23 + 6)
      {
LABEL_68:
        if ((void *)v25 == v24) {
          goto LABEL_101;
        }
        uint64_t v53 = v135;
        while (1)
        {
          int v54 = **(unsigned __int16 **)(v25 + 16);
          if ((v54 - 13) > 1) {
            goto LABEL_97;
          }
          uint64_t v55 = *(void *)(*(void *)(v25 + 32) + ((unint64_t)(v54 != 14) << 6) + 16);
          uint64_t v56 = *(void *)(v55 - 8 * *(unsigned int *)(v55 + 8) + 8);
          if (!v56 || (char v57 = *(void **)(v56 + 8), (v58 = *v57) == 0))
          {
            BOOL v65 = 1;
            int v66 = -1;
            goto LABEL_93;
          }
          unint64_t v59 = 0;
          BOOL v60 = (unsigned __int8 *)(v57 + 3);
          while (1)
          {
            int v61 = *v60;
            if ((v61 - 48) < 0xA)
            {
              int v62 = -48;
              goto LABEL_76;
            }
            if ((v61 - 97) >= 0x1A) {
              break;
            }
            int v62 = -87;
LABEL_84:
            uint64_t v22 = v132;
LABEL_76:
            unsigned int v63 = v62 + v61;
            if (v63 > 9)
            {
              unint64_t v64 = v59;
              goto LABEL_89;
            }
            unint64_t v64 = 10 * v59 + v63;
            if (v59 > v64 / 0xA)
            {
              BOOL v65 = 1;
              goto LABEL_90;
            }
            ++v60;
            unint64_t v59 = v64;
            if (!--v58) {
              goto LABEL_89;
            }
          }
          if ((v61 - 65) <= 0x19) {
            break;
          }
          unint64_t v64 = v59;
          uint64_t v22 = v132;
LABEL_89:
          BOOL v65 = v58 != 0;
LABEL_90:
          if (HIDWORD(v64)) {
            int v66 = -2;
          }
          else {
            int v66 = v64 - 1;
          }
LABEL_93:
          if (v65) {
            unsigned int v67 = -2;
          }
          else {
            unsigned int v67 = v66;
          }
          v53[v67 >> 6] &= ~(1 << v67);
LABEL_97:
          if ((*(unsigned char *)v25 & 4) == 0)
          {
            while ((*(_WORD *)(v25 + 44) & 8) != 0)
              uint64_t v25 = *(void *)(v25 + 8);
          }
          uint64_t v25 = *(void *)(v25 + 8);
          if ((void *)v25 == v24)
          {
LABEL_101:
            __int32 v23 = (void *)v23[1];
            if (v23 == v130) {
              goto LABEL_102;
            }
            goto LABEL_21;
          }
        }
        int v62 = -55;
        goto LABEL_84;
      }
      while (1)
      {
        if (**(unsigned __int16 **)(v25 + 16) - 13 >= 2)
        {
          uint64_t v50 = *(unsigned __int8 **)(v25 + 56);
          int v133 = v50;
          if (v50
            && (MachineFunction = (llvm *)llvm::MetadataTracking::track((uint64_t)&v133, v50, 2), (uint64_t v48 = v133) != 0))
          {
            int v51 = *((_DWORD *)v133 + 1);
            if (v51) {
              *((void *)v138[0] + ((v51 - 1) >> 6)) &= ~(1 << (v51 - 1));
            }
          }
          else
          {
            uint64_t v28 = (llvm::raw_ostream *)llvm::errs(MachineFunction);
            uint64_t v29 = (void *)*((void *)v28 + 4);
            if (*((void *)v28 + 3) - (void)v29 > 0x34uLL)
            {
              qmemcpy(v29, "WARNING: Instruction with empty DebugLoc in function ", 53);
              *((void *)v28 + 4) += 53;
            }
            else
            {
              uint64_t v28 = llvm::raw_ostream::write(v28, "WARNING: Instruction with empty DebugLoc in function ", 0x35uLL);
            }
            int v30 = llvm::errs(v28);
            int v31 = v30;
            if ((*((unsigned char *)v22 + 23) & 0x10) != 0)
            {
              uint64_t v32 = ***(void ***)v22;
              uint64_t v33 = *(void *)(v32 + 152);
              uint64_t v34 = *(unsigned int *)(v32 + 168);
              if (v34)
              {
                LODWORD(v35) = (v34 - 1) & v131;
                uint64_t v36 = (const Function **)(v33 + 16 * v35);
                unsigned int v37 = *v36;
                if (*v36 != v22)
                {
                  int v38 = 1;
                  do
                  {
                    if (v37 == (const Function *)-4096) {
                      goto LABEL_40;
                    }
                    int v39 = v35 + v38++;
                    uint64_t v35 = v39 & (v34 - 1);
                    unsigned int v37 = *(const Function **)(v33 + 16 * v35);
                  }
                  while (v37 != v22);
                  uint64_t v36 = (const Function **)(v33 + 16 * v35);
                }
              }
              else
              {
LABEL_40:
                uint64_t v36 = (const Function **)(v33 + 16 * v34);
              }
              uint64_t v40 = (size_t *)v36[1];
              size_t v43 = *v40;
              uint64_t v41 = v40 + 2;
              size_t v42 = v43;
              BOOL v44 = v30 + 3;
              uint64_t v46 = (llvm::raw_ostream **)(v30 + 4);
              unsigned int v45 = (llvm::raw_ostream *)v30[4];
              if (v43 <= v31[3] - (void)v45)
              {
                if (v42)
                {
                  memcpy(v45, v41, v42);
                  unsigned int v45 = (llvm::raw_ostream *)((char *)*v46 + v42);
                  *uint64_t v46 = v45;
                }
              }
              else
              {
                llvm::raw_ostream::write((llvm::raw_ostream *)v31, (const char *)v41, v42);
                unsigned int v45 = (llvm::raw_ostream *)v31[4];
              }
            }
            else
            {
              uint64_t v46 = (llvm::raw_ostream **)(v30 + 4);
              unsigned int v45 = (llvm::raw_ostream *)v30[4];
              BOOL v44 = v31 + 3;
            }
            if (*v44 - (void)v45 > 2uLL)
            {
              *((unsigned char *)v45 + 2) = 45;
              *(_WORD *)unsigned int v45 = 11552;
              *uint64_t v46 = (llvm::raw_ostream *)((char *)*v46 + 3);
            }
            else
            {
              unsigned int v45 = llvm::raw_ostream::write((llvm::raw_ostream *)v31, " --", 3uLL);
            }
            uint64_t v22 = v132;
            unsigned int v47 = (llvm::raw_ostream *)llvm::errs(v45);
            llvm::MachineInstr::print((llvm::MachineInstr *)v25, v47, (const llvm::TargetRegisterInfo *)1, 0, 0, 1, 0);
            uint64_t v48 = v133;
            if (!v133) {
              goto LABEL_63;
            }
          }
          int v52 = *v48;
          if ((v52 - 4) > 0x1E)
          {
            if ((v52 - 3) >= 0xFFFFFFFE) {
              BOOL v26 = v48;
            }
            else {
              BOOL v26 = 0;
            }
            if ((v52 - 3) < 0xFFFFFFFE)
            {
              if (v52 == 3) {
                *((void *)v48 + 1) = 0;
              }
              goto LABEL_63;
            }
            unint64_t v27 = (unint64_t)(v26 + 8);
          }
          else
          {
            if ((v48[1] & 0x7F) != 2 && !*((_DWORD *)v48 + 3)) {
              goto LABEL_63;
            }
            uint64_t v49 = *((void *)v48 + 2);
            if ((v49 & 4) == 0) {
              goto LABEL_63;
            }
            unint64_t v27 = v49 & 0xFFFFFFFFFFFFFFF8;
            if (!v27) {
              goto LABEL_63;
            }
          }
          uint64_t v134 = &v133;
          MachineFunction = (llvm *)sub_1CC5FA668(v27 + 16, &v134);
        }
LABEL_63:
        if ((*(unsigned char *)v25 & 4) == 0)
        {
          while ((*(_WORD *)(v25 + 44) & 8) != 0)
            uint64_t v25 = *(void *)(v25 + 8);
        }
        uint64_t v25 = *(void *)(v25 + 8);
        if ((void *)v25 == v24)
        {
          uint64_t v25 = v23[7];
          goto LABEL_68;
        }
      }
    }
    if (!v140) {
      goto LABEL_112;
    }
LABEL_103:
    uint64_t v68 = 0;
    uint64_t v69 = (uint64_t *)v138[0];
    uint64_t v70 = (v140 - 1) & 0xFFFFFFC0;
    while (1)
    {
      uint64_t v72 = *v69++;
      uint64_t v71 = v72;
      unint64_t v73 = v70 + v68 ? -1 : 0xFFFFFFFFFFFFFFFFLL >> -(char)v140;
      unint64_t v74 = v73 & v71;
      if (v74) {
        break;
      }
      v68 -= 64;
      if (v70 + v68 == -64) {
        goto LABEL_112;
      }
    }
    int v75 = __clz(__rbit64(v74));
    if (v75 + 1 != v68)
    {
      int v103 = v75 - v68;
      do
      {
        uint64_t v104 = (llvm::raw_ostream *)llvm::errs(MachineFunction);
        uint64_t v105 = v104;
        uint64_t v106 = (void *)*((void *)v104 + 4);
        if (*((void *)v104 + 3) - (void)v106 > 0x15uLL)
        {
          qmemcpy(v106, "WARNING: Missing line ", 22);
          *((void *)v104 + 4) += 22;
        }
        else
        {
          llvm::raw_ostream::write(v104, "WARNING: Missing line ", 0x16uLL);
        }
        unint64_t v107 = (v103 + 1);
        MachineFunction = sub_1CD098D14(v105, v107, 0, 0, 0);
        BOOL v108 = (unsigned char *)*((void *)v105 + 4);
        if (*((unsigned char **)v105 + 3) == v108)
        {
          MachineFunction = llvm::raw_ostream::write(v105, "\n", 1uLL);
        }
        else
        {
          *BOOL v108 = 10;
          ++*((void *)v105 + 4);
        }
        if (v107 == v140) {
          break;
        }
        unsigned int v109 = v107 >> 6;
        unsigned int v110 = v140 - 1;
        if (v107 >> 6 > (v140 - 1) >> 6) {
          break;
        }
        uint64_t v111 = 0;
        uint64_t v112 = v110 >> 6;
        unint64_t v113 = (v107 & 0x3F) != 0 ? ~(0xFFFFFFFFFFFFFFFFLL >> -(v107 & 0x3F)) : -1;
        unint64_t v114 = 0xFFFFFFFFFFFFFFFFLL >> ~(_BYTE)v110;
        unsigned int v115 = v109 << 6;
        uint64_t v116 = v112 - v109;
        unint64_t v117 = (char *)v138[0] + 8 * v109;
        while (1)
        {
          uint64_t v118 = v111 ? -1 : v113;
          unint64_t v119 = v116 == v111 ? v114 : -1;
          unint64_t v120 = v118 & v119 & *(void *)&v117[8 * v111];
          if (v120) {
            break;
          }
          v115 += 64;
          if (v116 + 1 == ++v111) {
            goto LABEL_185;
          }
        }
        int v103 = __clz(__rbit64(v120)) + v115;
      }
      while (v103 != -1);
LABEL_185:
      int v76 = 1;
    }
    else
    {
LABEL_112:
      int v76 = 0;
    }
    if (v137)
    {
      uint64_t v77 = 0;
      int v78 = (uint64_t *)v135;
      uint64_t v79 = (v137 - 1) & 0xFFFFFFC0;
      while (1)
      {
        uint64_t v81 = *v78++;
        uint64_t v80 = v81;
        unint64_t v82 = v79 + v77 ? -1 : 0xFFFFFFFFFFFFFFFFLL >> -(char)v137;
        unint64_t v83 = v82 & v80;
        if (v83) {
          break;
        }
        v77 -= 64;
        if (v79 + v77 == -64) {
          goto LABEL_171;
        }
      }
      int v84 = __clz(__rbit64(v83));
      if (v84 + 1 != v77)
      {
        int v85 = v84 - v77;
        do
        {
          unsigned int v86 = (llvm::raw_ostream *)llvm::errs(MachineFunction);
          uint64_t v87 = v86;
          uint64_t v88 = (void *)*((void *)v86 + 4);
          if (*((void *)v86 + 3) - (void)v88 > 0x19uLL)
          {
            qmemcpy(v88, "WARNING: Missing variable ", 26);
            *((void *)v86 + 4) += 26;
          }
          else
          {
            llvm::raw_ostream::write(v86, "WARNING: Missing variable ", 0x1AuLL);
          }
          unint64_t v89 = (v85 + 1);
          MachineFunction = sub_1CD098D14(v87, v89, 0, 0, 0);
          uint64_t v90 = (unsigned char *)*((void *)v87 + 4);
          if (*((unsigned char **)v87 + 3) == v90)
          {
            MachineFunction = llvm::raw_ostream::write(v87, "\n", 1uLL);
          }
          else
          {
            *uint64_t v90 = 10;
            ++*((void *)v87 + 4);
          }
          if (v89 == v137) {
            break;
          }
          unsigned int v91 = v89 >> 6;
          unsigned int v92 = v137 - 1;
          if (v89 >> 6 > (v137 - 1) >> 6) {
            break;
          }
          uint64_t v93 = 0;
          uint64_t v94 = v92 >> 6;
          unint64_t v95 = (v89 & 0x3F) != 0 ? ~(0xFFFFFFFFFFFFFFFFLL >> -(v89 & 0x3F)) : -1;
          unint64_t v96 = 0xFFFFFFFFFFFFFFFFLL >> ~(_BYTE)v92;
          unsigned int v97 = v91 << 6;
          uint64_t v98 = v94 - v91;
          uint64_t v99 = (char *)v135 + 8 * v91;
          while (1)
          {
            uint64_t v100 = v93 ? -1 : v95;
            unint64_t v101 = v98 == v93 ? v96 : -1;
            unint64_t v102 = v100 & v101 & *(void *)&v99[8 * v93];
            if (v102) {
              break;
            }
            v97 += 64;
            if (v98 + 1 == ++v93) {
              goto LABEL_170;
            }
          }
          int v85 = __clz(__rbit64(v102)) + v97;
        }
        while (v85 != -1);
LABEL_170:
        int v76 = 1;
      }
    }
LABEL_171:
    int v121 = (llvm::raw_ostream *)llvm::errs(MachineFunction);
    uint64_t v122 = (void *)*((void *)v121 + 4);
    if (*((void *)v121 + 3) - (void)v122 > 0x1CuLL)
    {
      qmemcpy(v122, "Machine IR debug info check: ", 29);
      *((void *)v121 + 4) += 29;
    }
    else
    {
      int v121 = llvm::raw_ostream::write(v121, "Machine IR debug info check: ", 0x1DuLL);
    }
    int v123 = (llvm::raw_ostream *)llvm::errs(v121);
    if (v76) {
      uint64_t v124 = "FAIL";
    }
    else {
      uint64_t v124 = "PASS";
    }
    uint64_t v125 = (_DWORD *)*((void *)v123 + 4);
    if (*((void *)v123 + 3) - (void)v125 > 3uLL)
    {
      *uint64_t v125 = *(_DWORD *)v124;
      uint64_t v126 = (unsigned char *)(*((void *)v123 + 4) + 4);
      *((void *)v123 + 4) = v126;
    }
    else
    {
      int v123 = llvm::raw_ostream::write(v123, v124, 4uLL);
      uint64_t v126 = (unsigned char *)*((void *)v123 + 4);
    }
    if (*((unsigned char **)v123 + 3) == v126)
    {
      llvm::raw_ostream::write(v123, "\n", 1uLL);
    }
    else
    {
      *uint64_t v126 = 10;
      ++*((void *)v123 + 4);
    }
    if (v135 != &v136) {
      free(v135);
    }
    if (v138[0] != v139) {
      free(v138[0]);
    }
  }
  else
  {
    uint64_t v10 = (llvm::raw_ostream *)llvm::errs(0);
    uint64_t v11 = (void *)*((void *)v10 + 4);
    if (*((void *)v10 + 3) - (void)v11 > 0x4EuLL)
    {
      qmemcpy(v11, "WARNING: Please run mir-debugify to generate llvm.mir.debugify metadata first.\n", 79);
      *((void *)v10 + 4) += 79;
    }
    else
    {
      llvm::raw_ostream::write(v10, "WARNING: Please run mir-debugify to generate llvm.mir.debugify metadata first.\n", 0x4FuLL);
    }
  }
  return 0;
}

void llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::MachineFunction>>::moveTopLevelCycleToNewParent(uint64_t a1, uint64_t a2, void *a3)
{
  if (*a3) {
    unint64_t v6 = (uint64_t **)(*a3 + 32);
  }
  else {
    unint64_t v6 = (uint64_t **)(a1 + 64);
  }
  uint64_t v8 = *v6;
  uint64_t v7 = v6[1];
  if (*v6 != v7)
  {
    while ((void *)*v8 != a3)
    {
      if (++v8 == v7)
      {
        uint64_t v8 = v6[1];
        break;
      }
    }
  }
  uint64_t v9 = *(uint64_t **)(a2 + 40);
  if ((unint64_t)v9 < *(void *)(a2 + 48))
  {
    uint64_t v55 = *v8;
    *uint64_t v8 = 0;
    *uint64_t v9 = v55;
    uint64_t v10 = (char *)(v9 + 1);
  }
  else
  {
    uint64_t v10 = sub_1CC33AA98((char **)(a2 + 32), v8);
  }
  *(void *)(a2 + 40) = v10;
  uint64_t v11 = v6[1];
  uint64_t v12 = *(v11 - 1);
  *(v11 - 1) = 0;
  uint64_t v13 = *v8;
  *uint64_t v8 = v12;
  if (v13)
  {
    uint64_t v56 = sub_1CC33AA34(v13);
    MEMORY[0x1D25D9CE0](v56, 0x10A0C40B2354FA7);
  }
  sub_1CC33A988((uint64_t)v6, v6[1] - 1);
  *a3 = a2;
  uint64_t v15 = (char *)a3[7];
  uint64_t v14 = (char *)a3[8];
  if (v14 - v15 >= 1)
  {
    uint64_t v16 = (v14 - v15) >> 3;
    uint64_t v18 = *(void *)(a2 + 56);
    uint64_t v17 = *(uint64_t **)(a2 + 64);
    uint64_t v19 = (uint64_t)v17 - v18;
    uint64_t v20 = (char *)(v18 + (((unint64_t)v17 - v18) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v21 = *(void *)(a2 + 72);
    if (v16 > (v21 - (uint64_t)v17) >> 3)
    {
      uint64_t v22 = v19 >> 3;
      unint64_t v23 = (v19 >> 3) + v16;
      if (v23 >> 61) {
        abort();
      }
      uint64_t v24 = v21 - v18;
      if (v24 >> 2 > v23) {
        unint64_t v23 = v24 >> 2;
      }
      if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v25 = v23;
      }
      if (v25)
      {
        if (v25 >> 61) {
          sub_1CB833614();
        }
        BOOL v26 = (char *)operator new(8 * v25);
        uint64_t v20 = (char *)(v18 + (((unint64_t)v17 - v18) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v22 = v19 >> 3;
      }
      else
      {
        BOOL v26 = 0;
      }
      unint64_t v27 = &v26[8 * v22];
      uint64_t v28 = &v27[8 * v16];
      uint64_t v29 = 8 * v16;
      int v30 = v27;
      do
      {
        uint64_t v31 = *(void *)v15;
        v15 += 8;
        *(void *)int v30 = v31;
        v30 += 8;
        v29 -= 8;
      }
      while (v29);
      if ((unint64_t)v19 >= 8)
      {
        uint64_t v32 = 8 * v22;
        do
        {
          *(void *)&v26[v32 - 8] = *(void *)(v18 - 8 + v32);
          v32 -= 8;
        }
        while (v32);
        uint64_t v17 = *(uint64_t **)(a2 + 64);
        unint64_t v27 = v26;
      }
      uint64_t v33 = &v26[8 * v25];
      uint64_t v34 = (char *)v17 - v20;
      if (v17 != (uint64_t *)v20)
      {
        size_t v35 = (char *)v17 - v20;
        uint64_t v36 = v28;
        memmove(v28, v20, v35);
        uint64_t v28 = v36;
      }
      unsigned int v37 = *(void **)(a2 + 56);
      *(void *)(a2 + 56) = v27;
      *(void *)(a2 + 64) = &v28[v34];
      *(void *)(a2 + 72) = v33;
      if (v37) {
        operator delete(v37);
      }
      goto LABEL_33;
    }
    uint64_t v45 = (char *)v17 - v20;
    uint64_t v46 = ((char *)v17 - v20) >> 3;
    if (v46 >= v16)
    {
      unsigned int v47 = &v15[8 * v16];
      uint64_t v49 = *(char **)(a2 + 64);
    }
    else
    {
      unsigned int v47 = &v15[8 * v46];
      int64_t v48 = v14 - v47;
      if (v14 != v47)
      {
        memmove(*(void **)(a2 + 64), &v15[8 * v46], v14 - v47);
        uint64_t v20 = (char *)(v18 + (((unint64_t)v17 - v18) & 0xFFFFFFFFFFFFFFF8));
      }
      uint64_t v49 = (char *)v17 + v48;
      *(void *)(a2 + 64) = (char *)v17 + v48;
      if (v45 < 1) {
        goto LABEL_33;
      }
    }
    uint64_t v50 = &v20[8 * v16];
    int v51 = (uint64_t *)&v49[-8 * v16];
    int v52 = v49;
    if (v51 < v17)
    {
      int v52 = v49;
      do
      {
        uint64_t v53 = *v51++;
        *(void *)int v52 = v53;
        v52 += 8;
      }
      while (v51 < v17);
    }
    *(void *)(a2 + 64) = v52;
    if (v49 != v50)
    {
      int v54 = v20;
      memmove(&v49[-8 * ((v49 - v50) >> 3)], v20, v49 - v50);
      uint64_t v20 = v54;
    }
    if (v47 != v15) {
      memmove(v20, v15, v47 - v15);
    }
  }
LABEL_33:
  uint64_t v38 = *(void *)(a1 + 40);
  uint64_t v39 = *(unsigned int *)(a1 + 56);
  uint64_t v40 = (void *)(v38 + 16 * v39);
  if (*(_DWORD *)(a1 + 48))
  {
    if (v39)
    {
      uint64_t v41 = 16 * v39;
      size_t v42 = *(void **)(a1 + 40);
      while (*v42 == -4096 || *v42 == -8192)
      {
        v42 += 2;
        v41 -= 16;
        if (!v41) {
          goto LABEL_69;
        }
      }
    }
    else
    {
      size_t v42 = *(void **)(a1 + 40);
    }
  }
  else
  {
LABEL_69:
    size_t v42 = (void *)(v38 + 16 * v39);
  }
  size_t v43 = (void *)(v38 + 16 * v39);
LABEL_41:
  while (v42 != v43)
  {
    if ((void *)v42[1] == a3) {
      v42[1] = a2;
    }
    BOOL v44 = v42 + 2;
    size_t v42 = v40;
    if (v44 != v40)
    {
      size_t v42 = v44;
      while (*v42 == -4096 || *v42 == -8192)
      {
        v42 += 2;
        if (v42 == v40)
        {
          size_t v42 = v40;
          goto LABEL_41;
        }
      }
    }
  }
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::block_begin(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::block_end(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

_DWORD *llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::MachineFunction>>::clear(uint64_t a1)
{
  uint64_t v1 = a1 + 64;
  sub_1CC33A988(a1 + 64, *(void **)(a1 + 64));
  sub_1CC338288((_DWORD *)(v1 - 48));

  return sub_1CC338288((_DWORD *)(v1 - 24));
}

_DWORD *sub_1CC338288(_DWORD *result)
{
  uint64_t v1 = result;
  int v2 = result[2];
  if (v2)
  {
    unsigned int v3 = result[4];
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      int v4 = 1 << (33 - __clz(v2 - 1));
      if (v4 <= 64) {
        int v5 = 64;
      }
      else {
        int v5 = v4;
      }
LABEL_9:
      if (v5 == v3)
      {
        *((void *)result + 1) = 0;
        uint64_t v12 = 16 * v3;
        uint64_t v13 = *(void **)result;
        do
        {
          *uint64_t v13 = -4096;
          v13 += 2;
          v12 -= 16;
        }
        while (v12);
      }
      else
      {
        int32x2_t result = (_DWORD *)MEMORY[0x1D25D9CD0](*(void *)result, 8);
        if (v5)
        {
          unint64_t v6 = (4 * v5 / 3u + 1) | ((unint64_t)(4 * v5 / 3u + 1) >> 1);
          unint64_t v7 = v6 | (v6 >> 2) | ((v6 | (v6 >> 2)) >> 4);
          LODWORD(v7) = (((v7 | (v7 >> 8)) >> 16) | v7 | (v7 >> 8)) + 1;
          v1[4] = v7;
          int32x2_t result = operator new(16 * v7, (std::align_val_t)8uLL);
          *(void *)uint64_t v1 = result;
          *((void *)v1 + 1) = 0;
          uint64_t v8 = v1[4];
          if (v8)
          {
            uint64_t v9 = 16 * v8;
            do
            {
              *(void *)int32x2_t result = -4096;
              result += 4;
              v9 -= 16;
            }
            while (v9);
          }
        }
        else
        {
          *(void *)uint64_t v1 = 0;
          *((void *)v1 + 1) = 0;
          v1[4] = 0;
        }
      }
      return result;
    }
  }
  else
  {
    if (!result[3]) {
      return result;
    }
    unsigned int v3 = result[4];
    if (v3 > 0x40)
    {
      int v5 = 0;
      goto LABEL_9;
    }
  }
  if (v3)
  {
    uint64_t v10 = *(void **)result;
    uint64_t v11 = 16 * v3;
    do
    {
      *uint64_t v10 = -4096;
      v10 += 2;
      v11 -= 16;
    }
    while (v11);
  }
  *((void *)result + 1) = 0;
  return result;
}

uint64_t llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::MachineFunction>>::compute(void *a1, uint64_t a2)
{
  int v2 = 0;
  v146[3] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t v116 = 0;
  uint64_t v117 = 0;
  unsigned int v115 = a1;
  unsigned int v118 = 0;
  unint64_t v119 = v121;
  uint64_t v120 = 0x800000000;
  a1[1] = a2;
  *a1 = *(void *)(a2 + 40);
  uint64_t v3 = *(void *)(a2 + 328);
  uint64_t v125 = &v127;
  uint64_t v126 = 0x800000000;
  int v133 = &v135;
  uint64_t v135 = v3;
  uint64_t v134 = (void *)0x800000001;
  unsigned int v4 = 1;
  do
  {
    int v5 = v133;
    uint64_t v6 = *((void *)v133 + v4 - 1);
    unsigned int v7 = v6 >> 4;
    if (!v118) {
      goto LABEL_17;
    }
    unsigned int v8 = v118 - 1;
    LODWORD(v9) = (v7 ^ (v6 >> 9)) & (v118 - 1);
    uint64_t v10 = (uint64_t *)(v116 + 16 * v9);
    uint64_t v11 = *v10;
    if (v6 != *v10)
    {
      int v13 = 1;
      uint64_t v14 = *v10;
      unsigned int v15 = (v7 ^ (v6 >> 9)) & v8;
      while (v14 != -4096)
      {
        unsigned int v16 = v15 + v13++;
        unsigned int v15 = v16 & v8;
        uint64_t v14 = *(void *)(v116 + 16 * v15);
        if (v6 == v14)
        {
          int v12 = v126;
          if (v4 != *((_DWORD *)v125 + v126 - 1)) {
            goto LABEL_6;
          }
          int v17 = 1;
          while (v11 != -4096)
          {
            int v18 = v9 + v17++;
            uint64_t v9 = v18 & v8;
            uint64_t v11 = *(void *)(v116 + 16 * v9);
            if (v6 == v11)
            {
              uint64_t v10 = (uint64_t *)(v116 + 16 * v9);
              goto LABEL_5;
            }
          }
          uint64_t v10 = (uint64_t *)(v116 + 16 * v118);
          goto LABEL_5;
        }
      }
LABEL_17:
      if (v126 >= HIDWORD(v126)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v125 + v126) = v4;
      LODWORD(v126) = v126 + 1;
      sub_1CC33AD70((uint64_t)&v133, (uint64_t)v5 + 8 * v134, *(char **)(v6 + 88), *(char **)(v6 + 96));
      ++v2;
      if (v118)
      {
        unsigned int v19 = (v118 - 1) & (v7 ^ (v6 >> 9));
        uint64_t v20 = (void *)(v116 + 16 * v19);
        uint64_t v21 = *v20;
        if (v6 == *v20)
        {
LABEL_39:
          if (v120 >= (unint64_t)HIDWORD(v120)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v119 + v120) = v6;
          LODWORD(v120) = v120 + 1;
          unsigned int v4 = v134;
          continue;
        }
        uint64_t v22 = 0;
        int v23 = 1;
        while (v21 != -4096)
        {
          if (v22) {
            BOOL v24 = 0;
          }
          else {
            BOOL v24 = v21 == -8192;
          }
          if (v24) {
            uint64_t v22 = v20;
          }
          unsigned int v25 = v19 + v23++;
          unsigned int v19 = v25 & (v118 - 1);
          uint64_t v20 = (void *)(v116 + 16 * v19);
          uint64_t v21 = *v20;
          if (v6 == *v20) {
            goto LABEL_39;
          }
        }
        if (v22) {
          BOOL v26 = v22;
        }
        else {
          BOOL v26 = v20;
        }
      }
      else
      {
        BOOL v26 = 0;
      }
      if (4 * (int)v117 + 4 >= 3 * v118)
      {
        sub_1CC33AF14((uint64_t)&v116, 2 * v118);
        unsigned int v28 = v118 - 1;
        unsigned int v29 = (v118 - 1) & (v7 ^ (v6 >> 9));
        BOOL v26 = (unsigned char *)(v116 + 16 * v29);
        uint64_t v30 = *(void *)v26;
        if (v6 == *(void *)v26)
        {
LABEL_196:
          uint64_t v27 = v6;
          goto LABEL_36;
        }
        uint64_t v31 = 0;
        int v32 = 1;
        while (v30 != -4096)
        {
          if (v31) {
            BOOL v33 = 0;
          }
          else {
            BOOL v33 = v30 == -8192;
          }
          if (v33) {
            uint64_t v31 = v26;
          }
          unsigned int v34 = v29 + v32++;
          unsigned int v29 = v34 & v28;
          BOOL v26 = (unsigned char *)(v116 + 16 * (v34 & v28));
          uint64_t v30 = *(void *)v26;
          if (v6 == *(void *)v26) {
            goto LABEL_196;
          }
        }
        if (v31) {
          BOOL v26 = v31;
        }
      }
      else if (v118 + ~v117 - HIDWORD(v117) <= v118 >> 3)
      {
        sub_1CC33AF14((uint64_t)&v116, v118);
        unint64_t v107 = 0;
        sub_1CC0B17CC(v116, v118, v6, &v107);
        BOOL v26 = v107;
      }
      uint64_t v27 = *(void *)v26;
LABEL_36:
      LODWORD(v117) = v117 + 1;
      if (v27 != -4096) {
        --HIDWORD(v117);
      }
      *(void *)BOOL v26 = v6;
      *((_DWORD *)v26 + 2) = v2;
      *((_DWORD *)v26 + 3) = 0;
      goto LABEL_39;
    }
    int v12 = v126;
    if (v4 == *((_DWORD *)v125 + v126 - 1))
    {
LABEL_5:
      *((_DWORD *)v10 + 3) = v2;
      LODWORD(v126) = v12 - 1;
    }
LABEL_6:
    LODWORD(v134) = --v4;
  }
  while (v4);
  if (v133 != &v135) {
    free(v133);
  }
  if (v125 != &v127) {
    free(v125);
  }
  uint64_t v122 = v124;
  uint64_t v123 = 0x800000000;
  if (v120)
  {
    size_t v35 = (char *)v119;
    uint64_t v36 = (char *)v119 + 8 * v120;
    while (1)
    {
      uint64_t v38 = *((void *)v36 - 1);
      v36 -= 8;
      uint64_t v37 = v38;
      unsigned int v39 = v38 >> 4;
      if (!v118) {
        goto LABEL_87;
      }
      uint64_t v40 = (v118 - 1) & (v39 ^ (v37 >> 9));
      uint64_t v41 = *(void *)(v116 + 16 * v40);
      if (v37 != v41) {
        break;
      }
LABEL_64:
      uint64_t v42 = *(void *)(v116 + 16 * v40 + 8);
LABEL_65:
      uint64_t v106 = v42;
      size_t v43 = *(uint64_t **)(v37 + 64);
      BOOL v44 = *(uint64_t **)(v37 + 72);
      while (v43 != v44)
      {
        uint64_t v45 = *v43;
        if (v118)
        {
          uint64_t v46 = ((v45 >> 4) ^ (v45 >> 9)) & (v118 - 1);
          uint64_t v47 = *(void *)(v116 + 16 * v46);
          if (v45 == v47)
          {
LABEL_69:
            uint64_t v48 = *(void *)(v116 + 16 * v46 + 8);
            goto LABEL_70;
          }
          int v50 = 1;
          while (v47 != -4096)
          {
            int v51 = v46 + v50++;
            uint64_t v46 = v51 & (v118 - 1);
            uint64_t v47 = *(void *)(v116 + 16 * v46);
            if (v45 == v47) {
              goto LABEL_69;
            }
          }
        }
        uint64_t v48 = 0;
LABEL_70:
        if (v106 <= v48 && HIDWORD(v106) >= HIDWORD(v48))
        {
          if (v123 >= (unint64_t)HIDWORD(v123)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v122 + v123) = v45;
          LODWORD(v123) = v123 + 1;
        }
        ++v43;
      }
      if (v123) {
        operator new();
      }
      if (v36 == v35) {
        goto LABEL_91;
      }
    }
    int v52 = 1;
    while (v41 != -4096)
    {
      int v53 = v40 + v52++;
      uint64_t v40 = v53 & (v118 - 1);
      uint64_t v41 = *(void *)(v116 + 16 * v40);
      if (v37 == v41) {
        goto LABEL_64;
      }
    }
LABEL_87:
    uint64_t v42 = 0;
    goto LABEL_65;
  }
LABEL_91:
  int v54 = (void *)v115[8];
  uint64_t v55 = (void *)v115[9];
  if (v54 != v55)
  {
    char v57 = &v137;
    uint64_t v58 = &v145;
    unint64_t v59 = v146;
    BOOL v60 = &v129;
    while (1)
    {
      int v61 = (void *)*v54;
      *(void *)*int v54 = 0;
      int v62 = operator new(0x18uLL);
      *int v62 = v61;
      *((unsigned char *)v62 + 8) = 0;
      *((unsigned char *)v62 + 16) = 0;
      int v133 = v57;
      uint64_t v134 = v57;
      uint64_t v135 = 0x100000008;
      LODWORD(v136) = 0;
      int v137 = v61;
      unint64_t v138 = v62;
      unsigned int v139 = v62 + 3;
      int v140 = v62 + 3;
      uint64_t v141 = v58;
      __n128 v142 = v58;
      uint64_t v143 = 8;
      int v144 = 0;
      v59[1] = 0;
      v59[2] = 0;
      *unint64_t v59 = 0;
      uint64_t v125 = v60;
      uint64_t v126 = (uint64_t)v60;
      uint64_t v129 = v61;
      uint64_t v127 = 0x100000008;
      int v128 = 0;
      unsigned int v63 = (char *)operator new(0x18uLL);
      unint64_t v64 = 0;
      BOOL v65 = 0;
      long long v66 = *(_OWORD *)v62;
      *((void *)v63 + 2) = v62[2];
      unsigned int v67 = v63 + 24;
      unsigned int v131 = v63 + 24;
      int v132 = v63 + 24;
      *(_OWORD *)unsigned int v63 = v66;
      __p = v63;
      unint64_t v107 = v111;
      BOOL v108 = v111;
      uint64_t v109 = 8;
      int v110 = 0;
      unint64_t v113 = 0;
      uint64_t v114 = 0;
      uint64_t v112 = 0;
      while (v67 - v63 != v64 - v65)
      {
LABEL_100:
        uint64_t v68 = (_DWORD *)*((void *)v67 - 3);
        if (*(void *)v68) {
          int v69 = *(_DWORD *)(*(void *)v68 + 80) + 1;
        }
        else {
          int v69 = 1;
        }
        v68[20] = v69;
        while (1)
        {
          uint64_t v70 = *((void *)v67 - 3);
          if (*(v67 - 8))
          {
            uint64_t v71 = (uint64_t *)*((void *)v67 - 2);
          }
          else
          {
            uint64_t v71 = *(uint64_t **)(v70 + 32);
            *((void *)v67 - 2) = v71;
            *(v67 - 8) = 1;
          }
          if (v71 != *(uint64_t **)(v70 + 40)) {
            break;
          }
LABEL_106:
          unsigned int v67 = v131 - 24;
          unsigned int v131 = v67;
          uint64_t v72 = v67;
          if (__p == v67) {
            goto LABEL_160;
          }
        }
        unint64_t v73 = (void *)v126;
        uint64_t v105 = v60;
        while (1)
        {
          *((void *)v67 - 2) = v71 + 1;
          uint64_t v74 = *v71;
          uint64_t v75 = HIDWORD(v127);
          if (v73 == v125)
          {
            if (HIDWORD(v127))
            {
              uint64_t v76 = 0;
              uint64_t v77 = 0;
              while (1)
              {
                uint64_t v78 = v73[v76];
                if (v78 == v74) {
                  goto LABEL_136;
                }
                if (v78 == -2) {
                  uint64_t v77 = &v73[v76];
                }
                if (HIDWORD(v127) == ++v76)
                {
                  if (!v77) {
                    break;
                  }
                  uint64_t v104 = v59;
                  uint64_t v88 = v58;
                  *uint64_t v77 = v74;
                  --v128;
                  goto LABEL_142;
                }
              }
            }
            unsigned int v79 = v127;
            if (HIDWORD(v127) < v127)
            {
              uint64_t v104 = v59;
              uint64_t v88 = v58;
              ++HIDWORD(v127);
              v73[v75] = v74;
              goto LABEL_142;
            }
          }
          else
          {
            unsigned int v79 = v127;
          }
          if (3 * v79 <= 4 * (HIDWORD(v127) - v128))
          {
            if (v79 >= 0x40) {
              v79 *= 2;
            }
            else {
              unsigned int v79 = 128;
            }
          }
          else if (v79 - HIDWORD(v127) >= v79 >> 3)
          {
            goto LABEL_123;
          }
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v125, v79);
          unsigned int v79 = v127;
          unint64_t v73 = (void *)v126;
LABEL_123:
          unsigned int v80 = v79 - 1;
          unsigned int v81 = (v79 - 1) & ((v74 >> 4) ^ (v74 >> 9));
          unint64_t v82 = &v73[v81];
          uint64_t v83 = *v82;
          if (*v82 == -1) {
            break;
          }
          int v84 = 0;
          int v85 = 1;
          while (v83 != v74)
          {
            if (v84) {
              BOOL v86 = 0;
            }
            else {
              BOOL v86 = v83 == -2;
            }
            if (v86) {
              int v84 = v82;
            }
            unsigned int v87 = v81 + v85++;
            unsigned int v81 = v87 & v80;
            unint64_t v82 = &v73[v87 & v80];
            uint64_t v83 = *v82;
            if (*v82 == -1) {
              goto LABEL_133;
            }
          }
LABEL_136:
          uint64_t v71 = (uint64_t *)*((void *)v67 - 2);
          BOOL v60 = v105;
          if (v71 == *(uint64_t **)(v70 + 40)) {
            goto LABEL_106;
          }
        }
        int v84 = 0;
LABEL_133:
        if (v84) {
          unint64_t v82 = v84;
        }
        if (*v82 == v74) {
          goto LABEL_136;
        }
        uint64_t v104 = v59;
        if (*v82 == -2) {
          --v128;
        }
        else {
          ++HIDWORD(v127);
        }
        uint64_t v88 = v58;
        *unint64_t v82 = v74;
LABEL_142:
        unint64_t v89 = v131;
        if (v131 < v132)
        {
          *(void *)unsigned int v131 = v74;
          v89[8] = 0;
          uint64_t v72 = v89 + 24;
          v89[16] = 0;
          BOOL v60 = v105;
        }
        else
        {
          uint64_t v90 = __p;
          unint64_t v91 = 0xAAAAAAAAAAAAAAABLL * ((v131 - (unsigned char *)__p) >> 3);
          unint64_t v92 = v91 + 1;
          if (v91 + 1 > 0xAAAAAAAAAAAAAAALL) {
            abort();
          }
          uint64_t v93 = v57;
          if (0x5555555555555556 * ((v132 - (unsigned char *)__p) >> 3) > v92) {
            unint64_t v92 = 0x5555555555555556 * ((v132 - (unsigned char *)__p) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((v132 - (unsigned char *)__p) >> 3) >= 0x555555555555555) {
            unint64_t v94 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v94 = v92;
          }
          if (v94)
          {
            if (v94 > 0xAAAAAAAAAAAAAAALL) {
              sub_1CB833614();
            }
            unint64_t v95 = (char *)operator new(24 * v94);
          }
          else
          {
            unint64_t v95 = 0;
          }
          unint64_t v96 = &v95[24 * v91];
          *(void *)unint64_t v96 = v74;
          v96[8] = 0;
          v96[16] = 0;
          unsigned int v97 = v96;
          if (v89 == v90)
          {
            BOOL v60 = v105;
          }
          else
          {
            BOOL v60 = v105;
            do
            {
              long long v98 = *(_OWORD *)(v89 - 24);
              *((void *)v97 - 1) = *((void *)v89 - 1);
              *(_OWORD *)(v97 - 24) = v98;
              v97 -= 24;
              v89 -= 24;
            }
            while (v89 != v90);
            unint64_t v89 = __p;
          }
          uint64_t v72 = v96 + 24;
          __p = v97;
          unsigned int v131 = v96 + 24;
          int v132 = &v95[24 * v94];
          if (v89) {
            operator delete(v89);
          }
          char v57 = v93;
        }
        unsigned int v131 = v72;
        unsigned int v67 = (char *)__p;
        uint64_t v58 = v88;
        unint64_t v59 = v104;
LABEL_160:
        BOOL v65 = v112;
        unint64_t v64 = v113;
        unsigned int v63 = v67;
        unsigned int v67 = v72;
      }
      if (v63 != v67) {
        break;
      }
LABEL_165:
      if (v65)
      {
        unint64_t v113 = v65;
        operator delete(v65);
      }
      if (v108 != v107) {
        free(v108);
      }
      if (__p)
      {
        unsigned int v131 = (char *)__p;
        operator delete(__p);
      }
      if ((void *)v126 != v125) {
        free((void *)v126);
      }
      if (v146[0])
      {
        v146[1] = v146[0];
        operator delete(v146[0]);
      }
      if (v142 != v141) {
        free(v142);
      }
      if (v138)
      {
        unsigned int v139 = v138;
        operator delete(v138);
      }
      if (v134 != v133) {
        free(v134);
      }
      if (++v54 == v55) {
        goto LABEL_92;
      }
    }
    uint64_t v99 = v65 + 8;
    uint64_t v100 = v63 + 8;
    while (1)
    {
      unint64_t v101 = v100 - 8;
      if (*((void *)v100 - 1) != *((void *)v99 - 1)) {
        goto LABEL_100;
      }
      int v102 = v99[8];
      if (v100[8]) {
        BOOL v103 = v102 == 0;
      }
      else {
        BOOL v103 = 1;
      }
      if (v103)
      {
        if ((v100[8] == 0) == (v102 != 0)) {
          goto LABEL_100;
        }
      }
      else if (*(void *)v100 != *(void *)v99)
      {
        goto LABEL_100;
      }
      v99 += 24;
      v100 += 24;
      if (v101 + 24 == v67) {
        goto LABEL_165;
      }
    }
  }
LABEL_92:
  if (v122 != v124) {
    free(v122);
  }
  if (v119 != v121) {
    free(v119);
  }
  return MEMORY[0x1D25D9CD0](v116, 8);
}

uint64_t llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::MachineFunction>>::getFunction(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::MachineFunction>>::getCycle(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(unsigned int *)(a1 + 32);
  if (v3)
  {
    LODWORD(v4) = (v3 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    int v5 = (uint64_t *)(v2 + 16 * v4);
    uint64_t v6 = *v5;
    if (*v5 == a2) {
      goto LABEL_8;
    }
    int v7 = 1;
    while (v6 != -4096)
    {
      int v8 = v4 + v7++;
      uint64_t v4 = v8 & (v3 - 1);
      uint64_t v6 = *(void *)(v2 + 16 * v4);
      if (v6 == a2)
      {
        int v5 = (uint64_t *)(v2 + 16 * v4);
        goto LABEL_8;
      }
    }
  }
  int v5 = (uint64_t *)(v2 + 16 * v3);
LABEL_8:
  if (v5 == (uint64_t *)(v2 + 16 * v3)) {
    return 0;
  }
  else {
    return v5[1];
  }
}

uint64_t llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::MachineFunction>>::getCycleDepth(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(unsigned int *)(a1 + 32);
  if (!v3)
  {
LABEL_7:
    int v5 = (uint64_t *)(v2 + 16 * v3);
    goto LABEL_8;
  }
  LODWORD(v4) = (v3 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  int v5 = (uint64_t *)(v2 + 16 * v4);
  uint64_t v6 = *v5;
  if (*v5 != a2)
  {
    int v7 = 1;
    while (v6 != -4096)
    {
      int v8 = v4 + v7++;
      uint64_t v4 = v8 & (v3 - 1);
      uint64_t v6 = *(void *)(v2 + 16 * v4);
      if (v6 == a2)
      {
        int v5 = (uint64_t *)(v2 + 16 * v4);
        goto LABEL_8;
      }
    }
    goto LABEL_7;
  }
LABEL_8:
  if (v5 == (uint64_t *)(v2 + 16 * v3)) {
    return 0;
  }
  uint64_t v10 = v5[1];
  if (!v10) {
    return 0;
  }
  else {
    return *(unsigned int *)(v10 + 80);
  }
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::getDepth(uint64_t a1)
{
  return *(unsigned int *)(a1 + 80);
}

uint64_t llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::MachineFunction>>::getTopLevelParentCycle(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = a2;
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(unsigned int *)(a1 + 56);
  unsigned int v4 = a2 >> 4;
  if (v3)
  {
    LODWORD(v5) = (v3 - 1) & (v4 ^ (a2 >> 9));
    uint64_t v6 = (uint64_t *)(v2 + 16 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a2) {
      goto LABEL_8;
    }
    int v8 = 1;
    while (v7 != -4096)
    {
      int v9 = v5 + v8++;
      uint64_t v5 = v9 & (v3 - 1);
      uint64_t v7 = *(void *)(v2 + 16 * v5);
      if (v7 == a2)
      {
        uint64_t v6 = (uint64_t *)(v2 + 16 * v5);
        goto LABEL_8;
      }
    }
  }
  uint64_t v6 = (uint64_t *)(v2 + 16 * v3);
LABEL_8:
  if (v6 != (uint64_t *)(v2 + 16 * v3)) {
    return v6[1];
  }
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = *(unsigned int *)(a1 + 32);
  if (v11)
  {
    LODWORD(v12) = (v11 - 1) & (v4 ^ (a2 >> 9));
    int v13 = (uint64_t *)(v10 + 16 * v12);
    uint64_t v14 = *v13;
    if (*v13 == a2) {
      goto LABEL_16;
    }
    int v15 = 1;
    while (v14 != -4096)
    {
      int v16 = v12 + v15++;
      uint64_t v12 = v16 & (v11 - 1);
      uint64_t v14 = *(void *)(v10 + 16 * v12);
      if (v14 == a2)
      {
        int v13 = (uint64_t *)(v10 + 16 * v12);
        goto LABEL_16;
      }
    }
  }
  int v13 = (uint64_t *)(v10 + 16 * v11);
LABEL_16:
  if (v13 == (uint64_t *)(v10 + 16 * v11)) {
    return 0;
  }
  unsigned int v19 = (void *)v13[1];
  do
  {
    uint64_t v17 = (uint64_t)v19;
    unsigned int v19 = (void *)*v19;
  }
  while (v19);
  uint64_t v21 = v17;
  sub_1CC339664((uint64_t)v20, a1 + 40, &v22, &v21);
  return v17;
}

uint64_t *sub_1CC339664(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  unsigned int v8 = *(_DWORD *)(a2 + 16);
  if (!v8)
  {
    int v18 = 0;
LABEL_15:
    int32x2_t result = sub_1CC2E10B8(a2, a3, v18);
    *int32x2_t result = *a3;
    result[1] = *a4;
    uint64_t v9 = *(void *)a2;
    unsigned int v8 = *(_DWORD *)(a2 + 16);
    char v17 = 1;
    goto LABEL_16;
  }
  uint64_t v9 = *(void *)a2;
  unsigned int v10 = ((*a3 >> 4) ^ (*a3 >> 9)) & (v8 - 1);
  int32x2_t result = (uint64_t *)(*(void *)a2 + 16 * v10);
  uint64_t v12 = *result;
  if (*a3 != *result)
  {
    int v13 = 0;
    int v14 = 1;
    while (v12 != -4096)
    {
      if (v13) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v12 == -8192;
      }
      if (v15) {
        int v13 = result;
      }
      unsigned int v16 = v10 + v14++;
      unsigned int v10 = v16 & (v8 - 1);
      int32x2_t result = (uint64_t *)(v9 + 16 * v10);
      uint64_t v12 = *result;
      if (*a3 == *result) {
        goto LABEL_11;
      }
    }
    if (v13) {
      int v18 = v13;
    }
    else {
      int v18 = result;
    }
    goto LABEL_15;
  }
LABEL_11:
  char v17 = 0;
LABEL_16:
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v9 + 16 * v8;
  *(unsigned char *)(a1 + 16) = v17;
  return result;
}

uint64_t llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::MachineFunction>>::validateTree(uint64_t a1)
{
  v111[0] = 0;
  v111[1] = 0;
  int v112 = 0;
  v109[0] = 0;
  v109[1] = 0;
  int v110 = 0;
  uint64_t v2 = *(uint64_t **)(a1 + 64);
  uint64_t v3 = *(uint64_t **)(a1 + 72);
  while (v2 != v3)
  {
    sub_1CD4C01BC(&v95, *v2);
    BOOL v86 = v91;
    unsigned int v4 = v96;
    if (v96 == v95)
    {
      unsigned int v87 = v91;
      uint64_t v5 = v91;
      uint64_t v6 = v96;
    }
    else
    {
      unsigned int v62 = v97;
      uint64_t v5 = malloc_type_malloc(8 * v97, 0x4065EBACuLL);
      if (!v5 && (v62 || (uint64_t v5 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
LABEL_134:
      }
        llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
      unsigned int v87 = v5;
      uint64_t v6 = v95;
      unsigned int v4 = v96;
    }
    unsigned int v7 = v98;
    unsigned int v88 = v97;
    if (v4 == v6) {
      unsigned int v8 = v98;
    }
    else {
      unsigned int v8 = v97;
    }
    if (v8)
    {
      memmove(v5, v4, 8 * v8);
      unsigned int v7 = v98;
    }
    unsigned int v89 = v7;
    int v90 = v99;
    uint64_t v93 = 0;
    uint64_t v94 = 0;
    unint64_t v92 = 0;
    sub_1CBF340A8(&v92, v100, v101, 0xAAAAAAAAAAAAAAABLL * ((v101 - (unsigned char *)v100) >> 3));
    uint64_t v77 = v82;
    uint64_t v9 = v103;
    if (v103 == v102)
    {
      uint64_t v78 = v82;
      unsigned int v10 = v82;
      uint64_t v11 = v103;
    }
    else
    {
      unsigned int v63 = v104;
      unsigned int v10 = malloc_type_malloc(8 * v104, 0x4065EBACuLL);
      if (!v10)
      {
        if (v63) {
          goto LABEL_134;
        }
        unsigned int v10 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
        if (!v10) {
          goto LABEL_134;
        }
      }
      uint64_t v78 = v10;
      uint64_t v11 = v102;
      uint64_t v9 = v103;
    }
    unsigned int v12 = v105;
    unsigned int v79 = v104;
    if (v9 == v11) {
      unsigned int v13 = v105;
    }
    else {
      unsigned int v13 = v104;
    }
    if (v13)
    {
      memmove(v10, v9, 8 * v13);
      unsigned int v12 = v105;
    }
    unsigned int v80 = v12;
    int v81 = v106;
    int v84 = 0;
    uint64_t v85 = 0;
    __p = 0;
    sub_1CBF340A8(&__p, v107, v108, 0xAAAAAAAAAAAAAAABLL * ((v108 - (unsigned char *)v107) >> 3));
    while (2)
    {
      if (v93 - (unsigned char *)v92 == v84 - (unsigned char *)__p)
      {
        if (v92 == v93)
        {
LABEL_98:
          char v59 = 1;
          goto LABEL_103;
        }
        int v14 = (char *)__p + 8;
        BOOL v15 = (char *)v92 + 8;
        while (1)
        {
          unsigned int v16 = v15 - 8;
          if (*((void *)v15 - 1) != *((void *)v14 - 1)) {
            break;
          }
          int v17 = v14[8];
          if (v15[8]) {
            BOOL v18 = v17 == 0;
          }
          else {
            BOOL v18 = 1;
          }
          if (v18)
          {
            if ((v15[8] == 0) == (v17 != 0)) {
              break;
            }
          }
          else if (*(void *)v15 != *(void *)v14)
          {
            break;
          }
          v14 += 24;
          v15 += 24;
          if (v16 + 24 == v93) {
            goto LABEL_98;
          }
        }
      }
      unsigned int v19 = (uint64_t *)*((void *)v93 - 3);
      uint64_t v20 = *v19;
      if (*v19)
      {
        uint64_t v21 = *(uint64_t ***)(v20 + 32);
        uint64_t v22 = *(uint64_t ***)(v20 + 40);
        while (v21 != v22)
        {
          if (*v21 == v19) {
            goto LABEL_36;
          }
          ++v21;
        }
        uint64_t v60 = 416;
        int v61 = "is_contained(Cycle->ParentCycle->children(), Cycle)";
      }
      else
      {
LABEL_36:
        int v23 = (uint64_t *)v19[7];
        BOOL v24 = (uint64_t *)v19[8];
        while (v23 != v24)
        {
          uint64_t v76 = 0;
          uint64_t v76 = *v23;
          v113[0] = 0;
          if (sub_1CBB8BDD4(*(void *)(a1 + 16), *(_DWORD *)(a1 + 32), v76, v113))
          {
            uint64_t v25 = v113[0];
            uint64_t v26 = *(void *)(a1 + 16);
            uint64_t v27 = *(unsigned int *)(a1 + 32);
          }
          else
          {
            uint64_t v26 = *(void *)(a1 + 16);
            uint64_t v27 = *(unsigned int *)(a1 + 32);
            uint64_t v25 = v26 + 16 * v27;
          }
          if (v25 == v26 + 16 * v27)
          {
            uint64_t v60 = 420;
            int v61 = "MapIt != BlockMap.end()";
            goto LABEL_102;
          }
          unsigned int v28 = *(uint64_t **)(v25 + 8);
          if (!v28) {
            goto LABEL_97;
          }
          unsigned int v29 = *((_DWORD *)v19 + 20);
          unsigned int v30 = *((_DWORD *)v28 + 20);
          if (v29 > v30) {
            goto LABEL_97;
          }
          if (v29 < v30)
          {
            do
              unsigned int v28 = (uint64_t *)*v28;
            while (v29 < *((_DWORD *)v28 + 20));
          }
          if (v28 != v19)
          {
LABEL_97:
            uint64_t v60 = 421;
            int v61 = "Cycle->contains(MapIt->second)";
            goto LABEL_102;
          }
          if (v112)
          {
            unsigned int v31 = ((v76 >> 4) ^ (v76 >> 9)) & (v112 - 1);
            int v32 = (void *)(v111[0] + 8 * v31);
            uint64_t v33 = *v32;
            if (v76 == *v32)
            {
LABEL_128:
              uint64_t v60 = 422;
              int v61 = "Blocks.insert(Block).second";
              goto LABEL_102;
            }
            unsigned int v34 = 0;
            int v35 = 1;
            while (v33 != -4096)
            {
              if (v34) {
                BOOL v36 = 0;
              }
              else {
                BOOL v36 = v33 == -8192;
              }
              if (v36) {
                unsigned int v34 = v32;
              }
              unsigned int v37 = v31 + v35++;
              unsigned int v31 = v37 & (v112 - 1);
              int v32 = (void *)(v111[0] + 8 * v31);
              uint64_t v33 = *v32;
              if (v76 == *v32) {
                goto LABEL_128;
              }
            }
            if (v34) {
              uint64_t v38 = v34;
            }
            else {
              uint64_t v38 = v32;
            }
          }
          else
          {
            uint64_t v38 = 0;
          }
          unsigned int v39 = sub_1CBB24DE0((uint64_t)v111, (uint64_t)&v76, &v76, v38);
          *unsigned int v39 = v76;
          ++v23;
        }
        sub_1CC33B0A0(v111);
        uint64_t v40 = *((unsigned int *)v19 + 4);
        if (v40)
        {
          uint64_t v41 = (uint64_t *)v19[1];
          uint64_t v42 = &v41[v40];
          do
          {
            v113[0] = 0;
            uint64_t v43 = *v41;
            v113[0] = *v41;
            if (v110)
            {
              unsigned int v44 = ((v43 >> 4) ^ (v43 >> 9)) & (v110 - 1);
              uint64_t v45 = (void *)(v109[0] + 8 * v44);
              uint64_t v46 = *v45;
              if (v43 == *v45)
              {
LABEL_127:
                uint64_t v60 = 428;
                int v61 = "Entries.insert(Entry).second";
                goto LABEL_102;
              }
              uint64_t v47 = 0;
              int v48 = 1;
              while (v46 != -4096)
              {
                if (v47) {
                  BOOL v49 = 0;
                }
                else {
                  BOOL v49 = v46 == -8192;
                }
                if (v49) {
                  uint64_t v47 = v45;
                }
                unsigned int v50 = v44 + v48++;
                unsigned int v44 = v50 & (v110 - 1);
                uint64_t v45 = (void *)(v109[0] + 8 * v44);
                uint64_t v46 = *v45;
                if (v43 == *v45) {
                  goto LABEL_127;
                }
              }
              if (v47) {
                int v51 = v47;
              }
              else {
                int v51 = v45;
              }
            }
            else
            {
              int v51 = 0;
            }
            int v52 = sub_1CBB24DE0((uint64_t)v109, (uint64_t)v113, v113, v51);
            *int v52 = v113[0];
            int v53 = (void *)v19[7];
            int v54 = (void *)v19[8];
            if (v53 != v54)
            {
              while (*v53 != v113[0])
              {
                if (++v53 == v54)
                {
                  int v53 = (void *)v19[8];
                  break;
                }
              }
            }
            if (v53 == v54)
            {
              uint64_t v60 = 429;
              int v61 = "is_contained(Cycle->Blocks, Entry)";
              goto LABEL_102;
            }
            ++v41;
          }
          while (v41 != v42);
          sub_1CC33B0A0(v109);
          uint64_t v55 = v19[4];
          uint64_t v56 = v19[5];
          if (v55 == v56)
          {
LABEL_95:
            sub_1CD47384C((char *)&v86);
            continue;
          }
          int v57 = 0;
          while (1)
          {
            unsigned int v58 = *(_DWORD *)(*(void *)v55 + 80);
            if (v58 <= *((_DWORD *)v19 + 20)) {
              break;
            }
            if (v57)
            {
              if (v57 != v58)
              {
                uint64_t v60 = 439;
                int v61 = "ChildDepth == Child->Depth";
                goto LABEL_102;
              }
            }
            else
            {
              int v57 = *(_DWORD *)(*(void *)v55 + 80);
            }
            v55 += 8;
            if (v55 == v56) {
              goto LABEL_95;
            }
          }
          uint64_t v60 = 435;
          int v61 = "Child->Depth > Cycle->Depth";
        }
        else
        {
          uint64_t v60 = 426;
          int v61 = "!Cycle->Entries.empty()";
        }
      }
      break;
    }
LABEL_102:
    sub_1CBFC83A4((llvm *)v60, v61);
    char v59 = 0;
LABEL_103:
    if (__p)
    {
      int v84 = __p;
      operator delete(__p);
    }
    if (v78 != v77) {
      free(v78);
    }
    if (v92)
    {
      uint64_t v93 = (char *)v92;
      operator delete(v92);
    }
    if (v87 != v86) {
      free(v87);
    }
    if (v107)
    {
      BOOL v108 = v107;
      operator delete(v107);
    }
    if (v103 != v102) {
      free(v103);
    }
    if (v100)
    {
      unint64_t v101 = v100;
      operator delete(v100);
    }
    if (v96 != v95) {
      free(v96);
    }
    if ((v59 & 1) == 0)
    {
LABEL_157:
      uint64_t v74 = 0;
      goto LABEL_159;
    }
    ++v2;
  }
  uint64_t v64 = *(void *)(a1 + 16);
  uint64_t v65 = *(unsigned int *)(a1 + 32);
  long long v66 = (void *)(v64 + 16 * v65);
  if (*(_DWORD *)(a1 + 24))
  {
    if (v65)
    {
      uint64_t v67 = 16 * v65;
      uint64_t v68 = *(void **)(a1 + 16);
      while ((*v68 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v68 += 2;
        v67 -= 16;
        if (!v67) {
          goto LABEL_140;
        }
      }
    }
    else
    {
      uint64_t v68 = *(void **)(a1 + 16);
    }
  }
  else
  {
LABEL_140:
    uint64_t v68 = (void *)(v64 + 16 * v65);
  }
  int v69 = (void *)(v64 + 16 * v65);
LABEL_143:
  while (v68 != v69)
  {
    uint64_t v70 = v68 + 1;
    while (1)
    {
      uint64_t v70 = (void *)*v70;
      if (!v70) {
        break;
      }
      uint64_t v71 = (void *)v70[7];
      uint64_t v72 = (void *)v70[8];
      if (v71 != v72)
      {
        while (*v71 != *v68)
        {
          if (++v71 == v72)
          {
            uint64_t v71 = (void *)v70[8];
            break;
          }
        }
      }
      if (v71 == v72)
      {
        sub_1CBFC83A4((llvm *)0x1C1, "is_contained(Cycle->Blocks, Block)");
        goto LABEL_157;
      }
    }
    unint64_t v73 = v68 + 2;
    uint64_t v68 = v66;
    if (v73 != v66)
    {
      while ((*v73 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v73 += 2;
        if (v73 == v66)
        {
          uint64_t v68 = v66;
          goto LABEL_143;
        }
      }
      uint64_t v68 = v73;
    }
  }
  uint64_t v74 = 1;
LABEL_159:
  MEMORY[0x1D25D9CD0](v109[0], 8);
  MEMORY[0x1D25D9CD0](v111[0], 8);
  return v74;
}

uint64_t llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::MachineFunction>>::toplevel_cycles(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::MachineFunction>>::const_toplevel_iterator::operator*(uint64_t a1)
{
  return **(void **)a1;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::children(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

BOOL llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::contains(uint64_t a1, uint64_t *a2)
{
  if (!a2) {
    return 0;
  }
  unsigned int v2 = *(_DWORD *)(a1 + 80);
  unsigned int v3 = *((_DWORD *)a2 + 20);
  if (v2 > v3) {
    return 0;
  }
  if (v2 < v3)
  {
    do
      a2 = (uint64_t *)*a2;
    while (v2 < *((_DWORD *)a2 + 20));
  }
  return a2 == (uint64_t *)a1;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::const_child_iterator::operator*(uint64_t a1)
{
  return **(void **)a1;
}

void llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::MachineFunction>>::dump(llvm *a1)
{
  llvm::dbgs(a1);

  llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::MachineFunction>>::print();
}

void *llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::MachineFunction>>::const_toplevel_iterator::const_toplevel_iterator(void *result, uint64_t a2)
{
  *int32x2_t result = a2;
  return result;
}

{
  *int32x2_t result = a2;
  return result;
}

uint64_t llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::MachineFunction>>::toplevel_begin(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::MachineFunction>>::toplevel_end(uint64_t a1)
{
  return *(void *)(a1 + 72);
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::clear(uint64_t a1)
{
  *(_DWORD *)(a1 + 16) = 0;
  uint64_t result = sub_1CC33A988(a1 + 32, *(void **)(a1 + 32));
  *(void *)(a1 + 64) = *(void *)(a1 + 56);
  *(_DWORD *)(a1 + 80) = 0;
  *(void *)a1 = 0;
  return result;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::appendEntry(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 16);
  if (v2 >= *(_DWORD *)(result + 20)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)(result + 8) + 8 * v2) = a2;
  ++*(_DWORD *)(result + 16);
  return result;
}

void llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::appendBlock(void *a1, uint64_t a2)
{
  uint64_t v5 = (void *)a1[8];
  unint64_t v4 = a1[9];
  if ((unint64_t)v5 >= v4)
  {
    unsigned int v7 = (void *)a1[7];
    uint64_t v8 = v5 - v7;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61) {
      abort();
    }
    uint64_t v10 = v4 - (void)v7;
    if (v10 >> 2 > v9) {
      unint64_t v9 = v10 >> 2;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 >> 61) {
        sub_1CB833614();
      }
      unsigned int v12 = (char *)operator new(8 * v11);
    }
    else
    {
      unsigned int v12 = 0;
    }
    unsigned int v13 = &v12[8 * v8];
    *(void *)unsigned int v13 = a2;
    uint64_t v6 = v13 + 8;
    if (v5 != v7)
    {
      do
      {
        uint64_t v14 = *--v5;
        *((void *)v13 - 1) = v14;
        v13 -= 8;
      }
      while (v5 != v7);
      uint64_t v5 = (void *)a1[7];
    }
    a1[7] = v13;
    a1[8] = v6;
    a1[9] = &v12[8 * v11];
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    *uint64_t v5 = a2;
    uint64_t v6 = v5 + 1;
  }
  a1[8] = v6;
}

BOOL llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::isReducible(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) == 1;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::getHeader(uint64_t a1)
{
  return **(void **)(a1 + 8);
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::getEntries(uint64_t a1)
{
  return a1 + 8;
}

BOOL llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::isEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if (v3)
  {
    uint64_t v4 = 8 * v3;
    uint64_t v5 = *(void **)(a1 + 8);
    while (*v5 != a2)
    {
      ++v5;
      v4 -= 8;
      if (!v4)
      {
        uint64_t v5 = (void *)(v2 + 8 * v3);
        return v3 != ((uint64_t)v5 - v2) >> 3;
      }
    }
  }
  else
  {
    uint64_t v5 = *(void **)(a1 + 8);
  }
  return v3 != ((uint64_t)v5 - v2) >> 3;
}

BOOL llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::contains(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 56);
  uint64_t v3 = *(void **)(a1 + 64);
  if (v2 != v3)
  {
    while (*v2 != a2)
    {
      if (++v2 == v3)
      {
        uint64_t v2 = *(void **)(a1 + 64);
        return v2 != v3;
      }
    }
  }
  return v2 != v3;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::getParentCycle(uint64_t a1)
{
  return *(void *)a1;
}

{
  return *(void *)a1;
}

void llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::getExitBlocks(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 8) = 0;
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v3 = *(void *)(a1 + 64);
  if (v2 != v3)
  {
    unint64_t v6 = 0;
    unint64_t v7 = 0;
    do
    {
      sub_1CC33AD70(a2, *(void *)a2 + 8 * v6, *(char **)(*(void *)v2 + 88), *(char **)(*(void *)v2 + 96));
      unint64_t v6 = *(unsigned int *)(a2 + 8);
      unint64_t v8 = v7;
      if (v7 < v6)
      {
        do
        {
          unint64_t v9 = *(void **)a2;
          uint64_t v10 = *(void *)(*(void *)a2 + 8 * v8);
          unint64_t v11 = *(void **)(a1 + 56);
          unsigned int v12 = *(void **)(a1 + 64);
          if (v11 != v12)
          {
            while (*v11 != v10)
            {
              if (++v11 == v12)
              {
                unint64_t v11 = *(void **)(a1 + 64);
                break;
              }
            }
          }
          if (v11 == v12)
          {
            unsigned int v13 = &v9[v7];
            if (v7)
            {
              uint64_t v14 = 8 * v7;
              BOOL v15 = *(void **)a2;
              while (*v15 != v10)
              {
                ++v15;
                v14 -= 8;
                if (!v14)
                {
                  BOOL v15 = &v9[v7];
                  break;
                }
              }
            }
            else
            {
              BOOL v15 = *(void **)a2;
            }
            if (v7 == v15 - v9)
            {
              ++v7;
              *unsigned int v13 = v10;
            }
          }
          ++v8;
        }
        while (v8 != v6);
      }
      if (v7 != v6)
      {
        if (v7 >= v6)
        {
          if (v7 > *(unsigned int *)(a2 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          if (v7 != v6) {
            bzero((void *)(*(void *)a2 + 8 * v6), 8 * (v7 - v6));
          }
        }
        unint64_t v6 = v7;
        *(_DWORD *)(a2 + 8) = v7;
      }
      v2 += 8;
    }
    while (v2 != v3);
  }
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::blocks(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

void *llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::const_child_iterator::const_child_iterator(void *result, uint64_t a2)
{
  *uint64_t result = a2;
  return result;
}

{
  *uint64_t result = a2;
  return result;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::child_begin(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::child_end(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::getNumChildren(uint64_t a1)
{
  return (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 3;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::getNumBlocks(uint64_t a1)
{
  return (uint64_t)(*(void *)(a1 + 64) - *(void *)(a1 + 56)) >> 3;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::getNumEntries(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::entries(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void sub_1CC33A3C4()
{
}

void llvm::MachineCycleInfoWrapperPass::runOnMachineFunction(llvm::MachineCycleInfoWrapperPass *this, llvm::MachineFunction *a2)
{
  *((void *)this + 31) = a2;
  llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::MachineFunction>>::compute();
}

_DWORD *llvm::MachineCycleInfoWrapperPass::releaseMemory(llvm::MachineCycleInfoWrapperPass *this)
{
  sub_1CC33A988((uint64_t)this + 320, *((void **)this + 40));
  sub_1CC338288((_DWORD *)this + 68);
  uint64_t result = sub_1CC338288((_DWORD *)this + 74);
  *((void *)this + 31) = 0;
  return result;
}

void sub_1CC33A508(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCE7C0, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CC33A3C4;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCCE7C0, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
  operator new();
}

uint64_t llvm::isCycleInvariant(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(*(void *)(a2 + 24) + 32);
  uint64_t v5 = *(void **)(v4 + 40);
  uint64_t v6 = *(void *)(v4 + 16);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 176))(v6);
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 104))(v6);
  uint64_t v9 = *(unsigned int *)(a2 + 40);
  if (!v9) {
    return 1;
  }
  uint64_t v10 = v8;
  unint64_t v11 = *(int **)(a2 + 32);
  unsigned int v12 = &v11[8 * v9];
  while (1)
  {
    int v13 = *v11;
    if (*v11) {
      goto LABEL_4;
    }
    uint64_t v14 = v11[1];
    if (!v14) {
      goto LABEL_4;
    }
    if (v14 >> 30) {
      break;
    }
    if ((v13 & 0x1000000) != 0)
    {
      if ((~v13 & 0x5000000) != 0) {
        return 0;
      }
      uint64_t v20 = *(unsigned int *)(a1 + 16);
      if (v20)
      {
        uint64_t v21 = *(void *)(a1 + 8);
        uint64_t v22 = v21 + 8 * v20;
        do
        {
          for (int i = *(unsigned __int16 **)(*(void *)v21 + 152);
                i != *(unsigned __int16 **)(*(void *)v21 + 160);
                i += 8)
          {
            if (*i == (unsigned __int16)v14)
            {
              if (*((void *)i + 1)) {
                return 0;
              }
              break;
            }
          }
          v21 += 8;
        }
        while (v21 != v22);
      }
    }
    else if ((llvm::MachineRegisterInfo::isConstantPhysReg(v5, v11[1]) & 1) == 0 {
           && ((*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v7 + 128))(v7, v14, *(void *)(*(void *)(a2 + 24) + 32)) & 1) == 0&& ((*(uint64_t (**)(uint64_t, int *))(*(void *)v10 + 24))(v10, v11) & 1) == 0)
    }
    {
      return 0;
    }
LABEL_4:
    v11 += 8;
    if (v11 == v12) {
      return 1;
    }
  }
  if ((v13 & 0x1000000) != 0) {
    goto LABEL_4;
  }
  if ((v14 & 0x80000000) != 0) {
    uint64_t v15 = v5[3] + 16 * (v14 & 0x7FFFFFFF) + 8;
  }
  else {
    uint64_t v15 = v5[34] + 8 * v14;
  }
  uint64_t v16 = *(void *)v15;
  if ((*(unsigned char *)(*(void *)v15 + 3) & 1) == 0) {
    uint64_t v16 = *(void *)(v16 + 24);
  }
  int v17 = *(void **)(a1 + 56);
  BOOL v18 = *(void **)(a1 + 64);
  if (v17 != v18)
  {
    uint64_t v19 = *(void *)(*(void *)(v16 + 8) + 24);
    while (*v17 != v19)
    {
      if (++v17 == v18)
      {
        int v17 = *(void **)(a1 + 64);
        break;
      }
    }
  }
  if (v17 == v18) {
    goto LABEL_4;
  }
  return 0;
}

uint64_t sub_1CC33A844(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 64);
  sub_1CC33A898(&v3);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 40), 8);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 16), 8);
  return a1;
}

void sub_1CC33A898(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = (void *)*--v4;
        uint64_t v6 = v7;
        *uint64_t v4 = 0;
        if (v7)
        {
          uint64_t v8 = (void *)v6[7];
          if (v8)
          {
            v6[8] = v8;
            operator delete(v8);
          }
          uint64_t v10 = v6 + 4;
          sub_1CC33A898(&v10);
          uint64_t v9 = (void *)v6[1];
          if (v9 != v6 + 3) {
            free(v9);
          }
          MEMORY[0x1D25D9CE0](v6, 0x10A0C40B2354FA7);
        }
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1CC33A988(uint64_t result, void *a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void **)(result + 8);
  while (v4 != a2)
  {
    uint64_t v6 = *--v4;
    uint64_t v5 = v6;
    *uint64_t v4 = 0;
    if (v6)
    {
      uint64_t v7 = *(void **)(v5 + 56);
      if (v7)
      {
        *(void *)(v5 + 64) = v7;
        operator delete(v7);
      }
      uint64_t v9 = (void **)(v5 + 32);
      sub_1CC33A898(&v9);
      uint64_t v8 = *(void **)(v5 + 8);
      if (v8 != (void *)(v5 + 24)) {
        free(v8);
      }
      uint64_t result = MEMORY[0x1D25D9CE0](v5, 0x10A0C40B2354FA7);
    }
  }
  *(void *)(v3 + 8) = a2;
  return result;
}

uint64_t sub_1CC33AA34(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 64) = v2;
    operator delete(v2);
  }
  uint64_t v5 = (void **)(a1 + 32);
  sub_1CC33A898(&v5);
  uint64_t v3 = *(void **)(a1 + 8);
  if (v3 != (void *)(a1 + 24)) {
    free(v3);
  }
  return a1;
}

char *sub_1CC33AA98(char **a1, uint64_t *a2)
{
  uint64_t v2 = (a1[1] - *a1) >> 3;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    abort();
  }
  uint64_t v6 = a1[2] - *a1;
  if (v6 >> 2 > v3) {
    unint64_t v3 = v6 >> 2;
  }
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v7 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v7 = v3;
  }
  if (v7)
  {
    if (v7 >> 61) {
      sub_1CB833614();
    }
    uint64_t v8 = (char *)operator new(8 * v7);
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = &v8[8 * v2];
  uint64_t v10 = &v8[8 * v7];
  uint64_t v11 = *a2;
  *a2 = 0;
  *(void *)uint64_t v9 = v11;
  unsigned int v12 = v9 + 8;
  int v13 = *a1;
  uint64_t v14 = a1[1];
  if (v14 == *a1)
  {
    *a1 = v9;
    a1[1] = v12;
    a1[2] = v10;
  }
  else
  {
    do
    {
      uint64_t v15 = *((void *)v14 - 1);
      v14 -= 8;
      *(void *)uint64_t v14 = 0;
      *((void *)v9 - 1) = v15;
      v9 -= 8;
    }
    while (v14 != v13);
    uint64_t v14 = *a1;
    uint64_t v16 = a1[1];
    *a1 = v9;
    a1[1] = v12;
    a1[2] = v10;
    while (v16 != v14)
    {
      uint64_t v18 = *((void *)v16 - 1);
      v16 -= 8;
      uint64_t v17 = v18;
      *(void *)uint64_t v16 = 0;
      if (v18)
      {
        uint64_t v19 = *(void **)(v17 + 56);
        if (v19)
        {
          *(void *)(v17 + 64) = v19;
          operator delete(v19);
        }
        uint64_t v22 = (void **)(v17 + 32);
        sub_1CC33A898(&v22);
        uint64_t v20 = *(void **)(v17 + 8);
        if (v20 != (void *)(v17 + 24)) {
          free(v20);
        }
        MEMORY[0x1D25D9CE0](v17, 0x10A0C40B2354FA7);
      }
    }
  }
  if (v14) {
    operator delete(v14);
  }
  return v12;
}

uint64_t *sub_1CC33ABF0(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(a2 + 64);
  unint64_t v3 = *(uint64_t **)(a2 + 72);
  if (v2 == v3) {
    return result;
  }
  char v4 = 0;
  uint64_t v5 = *result;
  do
  {
    uint64_t v6 = *v2;
    int v7 = *(_DWORD *)(v5 + 24);
    if (!v7) {
      goto LABEL_16;
    }
    uint64_t v8 = *(void *)(v5 + 8);
    unsigned int v9 = v7 - 1;
    uint64_t v10 = ((v6 >> 4) ^ (v6 >> 9)) & (v7 - 1);
    uint64_t v11 = *(void *)(v8 + 16 * v10);
    if (v6 != v11)
    {
      int v16 = 1;
      while (v11 != -4096)
      {
        int v17 = v10 + v16++;
        uint64_t v10 = v17 & v9;
        uint64_t v11 = *(void *)(v8 + 16 * v10);
        if (v6 == v11) {
          goto LABEL_5;
        }
      }
LABEL_16:
      uint64_t v12 = 0;
      goto LABEL_6;
    }
LABEL_5:
    uint64_t v12 = *(void *)(v8 + 16 * v10 + 8);
LABEL_6:
    int v13 = (_DWORD *)result[1];
    if (*v13 > v12 || v13[1] < HIDWORD(v12))
    {
      char v4 = 1;
    }
    else
    {
      uint64_t v14 = result[2];
      unint64_t v15 = *(unsigned int *)(v14 + 8);
      if (v15 >= *(unsigned int *)(v14 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)v14 + 8 * v15) = v6;
      ++*(_DWORD *)(v14 + 8);
    }
    ++v2;
  }
  while (v2 != v3);
  if (v4)
  {
    uint64_t v18 = *(void *)result[3];
    unsigned int v19 = *(_DWORD *)(v18 + 16);
    if (v19 >= *(_DWORD *)(v18 + 20)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(v18 + 8) + 8 * v19) = a2;
    ++*(_DWORD *)(v18 + 16);
  }
  return result;
}

unsigned char *sub_1CC33AD70(uint64_t a1, uint64_t a2, char *a3, char *a4)
{
  uint64_t v5 = a3;
  uint64_t v6 = *(void *)a1;
  uint64_t v7 = (a2 - *(void *)a1) >> 3;
  uint64_t v8 = *(unsigned int *)(a1 + 8);
  unint64_t v9 = *(unsigned int *)(a1 + 12);
  size_t v10 = a4 - a3;
  unint64_t v11 = v8 + ((a4 - a3) >> 3);
  if (*(void *)a1 + 8 * v8 == a2)
  {
    if (v11 > v9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    if (v5 != a4)
    {
      uint64_t v12 = (void *)(v6 + 8 * v8);
      do
      {
        uint64_t v13 = *(void *)v5;
        v5 += 8;
        *v12++ = v13;
      }
      while (v5 != a4);
      uint64_t v6 = *(void *)a1;
    }
    *(_DWORD *)(a1 + 8) = v8 + (v10 >> 3);
    return (unsigned char *)(v6 + 8 * v7);
  }
  else
  {
    unint64_t v16 = (uint64_t)v10 >> 3;
    if (v11 > v9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    int v17 = (char *)(v6 + 8 * v8);
    uint64_t __src = (unsigned char *)(v6 + 8 * v7);
    unint64_t v18 = (v17 - __src) >> 3;
    if (v18 >= v16)
    {
      sub_1CD4570C8(a1, &v17[-8 * v16], (char *)(v6 + 8 * v8));
      if (&v17[-8 * v16] != __src) {
        memmove(&__src[8 * v16], __src, &v17[-8 * v16] - __src);
      }
      if (a4 != v5)
      {
        uint64_t v14 = __src;
        memmove(__src, v5, v10);
        return v14;
      }
    }
    else
    {
      unsigned int v19 = v8 + (v10 >> 3);
      *(_DWORD *)(a1 + 8) = v19;
      if (v7 != v8)
      {
        uint64_t v20 = (void *)(v6 + 8 * v7);
        memcpy((void *)(v6 + 8 * v19 - 8 * v18), __src, v17 - __src);
        do
        {
          uint64_t v21 = *(void *)v5;
          v5 += 8;
          *v20++ = v21;
          --v18;
        }
        while (v18);
      }
      while (v5 != a4)
      {
        uint64_t v22 = *(void *)v5;
        v5 += 8;
        *(void *)int v17 = v22;
        v17 += 8;
      }
    }
    return __src;
  }
}

void *sub_1CC33AF14(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v12 = *(unsigned int *)(a1 + 16);
    if (v12)
    {
      uint64_t v13 = 16 * v12;
      do
      {
        *uint64_t result = -4096;
        result += 2;
        v13 -= 16;
      }
      while (v13);
    }
    if (v3)
    {
      uint64_t v14 = v4;
      do
      {
        uint64_t v15 = *v14;
        if ((*v14 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          int v16 = *(_DWORD *)(a1 + 16) - 1;
          unsigned int v17 = v16 & ((v15 >> 4) ^ (v15 >> 9));
          unint64_t v18 = (void *)(*(void *)a1 + 16 * v17);
          uint64_t v19 = *v18;
          if (v15 != *v18)
          {
            uint64_t v20 = 0;
            int v21 = 1;
            while (v19 != -4096)
            {
              if (v20) {
                BOOL v22 = 0;
              }
              else {
                BOOL v22 = v19 == -8192;
              }
              if (v22) {
                uint64_t v20 = v18;
              }
              unsigned int v23 = v17 + v21++;
              unsigned int v17 = v23 & v16;
              unint64_t v18 = (void *)(*(void *)a1 + 16 * (v23 & v16));
              uint64_t v19 = *v18;
              if (v15 == *v18) {
                goto LABEL_27;
              }
            }
            if (v20) {
              unint64_t v18 = v20;
            }
          }
LABEL_27:
          *unint64_t v18 = v15;
          v18[1] = v14[1];
          ++*(_DWORD *)(a1 + 8);
        }
        v14 += 2;
      }
      while (v14 != &v4[2 * v3]);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *uint64_t result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

_DWORD *sub_1CC33B0A0(_DWORD *result)
{
  uint64_t v1 = result;
  int v2 = result[2];
  if (v2)
  {
    unsigned int v3 = result[4];
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      int v4 = 1 << (33 - __clz(v2 - 1));
      if (v4 <= 64) {
        int v5 = 64;
      }
      else {
        int v5 = v4;
      }
LABEL_10:
      if (v5 == v3)
      {
        *((void *)result + 1) = 0;
        uint64_t v6 = 8 * v3;
        int v7 = *(void **)result;
        do
        {
          *v7++ = -4096;
          v6 -= 8;
        }
        while (v6);
      }
      else
      {
        uint64_t result = (_DWORD *)MEMORY[0x1D25D9CD0](*(void *)result, 8);
        if (v5)
        {
          unint64_t v10 = (4 * v5 / 3u + 1) | ((unint64_t)(4 * v5 / 3u + 1) >> 1);
          unint64_t v11 = v10 | (v10 >> 2) | ((v10 | (v10 >> 2)) >> 4);
          LODWORD(v11) = (((v11 | (v11 >> 8)) >> 16) | v11 | (v11 >> 8)) + 1;
          v1[4] = v11;
          uint64_t result = operator new(8 * v11, (std::align_val_t)8uLL);
          *(void *)uint64_t v1 = result;
          *((void *)v1 + 1) = 0;
          uint64_t v12 = v1[4];
          if (v12)
          {
            uint64_t v13 = 8 * v12;
            do
            {
              *(void *)uint64_t result = -4096;
              result += 2;
              v13 -= 8;
            }
            while (v13);
          }
        }
        else
        {
          *(void *)uint64_t v1 = 0;
          *((void *)v1 + 1) = 0;
          v1[4] = 0;
        }
      }
      return result;
    }
  }
  else
  {
    if (!result[3]) {
      return result;
    }
    unsigned int v3 = result[4];
    if (v3 > 0x40)
    {
      int v5 = 0;
      goto LABEL_10;
    }
  }
  if (v3)
  {
    unsigned int v8 = *(void **)result;
    uint64_t v9 = 8 * v3;
    do
    {
      *v8++ = -4096;
      v9 -= 8;
    }
    while (v9);
  }
  *((void *)result + 1) = 0;
  return result;
}

void sub_1CC33B1EC()
{
}

void sub_1CC33B288()
{
}

void sub_1CC33B2E8(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC33B320(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineModuleInfoWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::MachineModuleInfoWrapperPass::ID);
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v3);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);
}

BOOL sub_1CC33B3A4(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unsigned int v3 = *(uint64_t **)(a1 + 8);
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 == v5)
  {
LABEL_4:
    uint64_t v6 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v4 != &llvm::MachineModuleInfoWrapperPass::ID)
    {
      v4 += 16;
      if (v4 == v5) {
        goto LABEL_4;
      }
    }
    uint64_t v6 = *(void *)(v4 + 8);
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, &llvm::MachineModuleInfoWrapperPass::ID);
  uint64_t v8 = *(void *)(a2 + 32);
  v11[0] = &unk_1F260DE00;
  v11[1] = v7 + 32;
  uint64_t v12 = v11;
  BOOL v9 = llvm::applyDebugifyMetadata(a2, v8, a2 + 24, "ModuleDebugify: ", 0x10uLL, (uint64_t)v11);
  if (v12 == v11)
  {
    (*(void (**)(void *))(v11[0] + 32))(v11);
  }
  else if (v12)
  {
    (*(void (**)(void))(*v12 + 40))();
  }
  return v9;
}

void sub_1CC33B514()
{
}

void *sub_1CC33B528(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F260DE00;
  result[1] = v3;
  return result;
}

uint64_t sub_1CC33B570(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F260DE00;
  a2[1] = v2;
  return result;
}

BOOL sub_1CC33B59C(uint64_t a1, int a2, Function *a3)
{
  uint64_t v181 = *MEMORY[0x1E4F143B8];
  uint64_t MachineFunction = llvm::MachineModuleInfo::getMachineFunction(*(llvm::MachineModuleInfo **)(a1 + 8), a3);
  uint64_t v5 = MachineFunction;
  if (!MachineFunction) {
    return v5 != 0;
  }
  uint64_t v159 = (*(uint64_t (**)(void))(**(void **)(MachineFunction + 16) + 104))(*(void *)(MachineFunction + 16));
  uint64_t v6 = ***(void ***)a3;
  uint64_t v169 = a3;
  int v7 = *(_DWORD *)(v6 + 2496);
  if (v7)
  {
    uint64_t v8 = *(void *)(v6 + 2480);
    int v9 = v7 - 1;
    unsigned int v10 = v9 & ((a3 >> 4) ^ (a3 >> 9));
    unint64_t v11 = (Function **)(v8 + 40 * v10);
    uint64_t v12 = *v11;
    if (*v11 == a3) {
      goto LABEL_12;
    }
    uint64_t v13 = 0;
    int v14 = 1;
    while (v12 != (Function *)-4096)
    {
      if (v13) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v12 == (Function *)-8192;
      }
      if (v15) {
        uint64_t v13 = v11;
      }
      unsigned int v16 = v10 + v14++;
      unsigned int v10 = v16 & v9;
      unint64_t v11 = (Function **)(v8 + 40 * v10);
      uint64_t v12 = *v11;
      if (*v11 == a3) {
        goto LABEL_12;
      }
    }
    if (v13) {
      int v53 = v13;
    }
    else {
      int v53 = v11;
    }
  }
  else
  {
    int v53 = 0;
  }
  unint64_t v11 = (Function **)sub_1CC609054(v6 + 2480, (uint64_t)&v169, (uint64_t *)&v169, v53);
  uint64_t v54 = (uint64_t)v169;
  void v11[3] = 0;
  v11[4] = 0;
  *unint64_t v11 = (Function *)v54;
  v11[1] = (Function *)(v11 + 3);
  _OWORD v11[2] = (Function *)0x100000000;
LABEL_12:
  unsigned int v17 = v11[1];
  if (*(_DWORD *)v17)
  {
    uint64_t v18 = 16 * *((unsigned int *)v11 + 4) - 16;
    do
    {
      int v19 = *((_DWORD *)v17 + 4);
      unsigned int v17 = (Function *)((char *)v17 + 16);
      v18 -= 16;
    }
    while (v19);
  }
  uint64_t v20 = *((void *)v17 + 1);
  uint64_t v161 = v5;
  int v162 = a3;
  int v21 = (llvm::Module *)*((void *)a3 + 5);
  BOOL v22 = *(uint64_t **)v21;
  unsigned int v23 = *(_DWORD *)(v20 + 24);
  uint64_t v24 = v5 + 320;
  uint64_t v25 = *(void *)(v5 + 328);
  if (v25 == v24) {
    goto LABEL_61;
  }
  do
  {
    for (uint64_t i = *(void *)(v25 + 56); i != v25 + 48; uint64_t i = *(void *)(i + 8))
    {
      Impl = (unsigned __int8 *)llvm::DILocation::getImpl(v22, v23, 1u, v20, 0, 0, 0, 1);
      BOOL v177 = Impl;
      if (Impl) {
        llvm::MetadataTracking::track((uint64_t)&v177, Impl, 2);
      }
      unsigned int v28 = (unsigned __int8 **)(i + 56);
      if (&v177 != (unsigned __int8 **)(i + 56))
      {
        unsigned int v29 = *v28;
        if (*v28)
        {
          int v31 = *v29;
          if ((v31 - 4) > 0x1E)
          {
            if ((v31 - 3) >= 0xFFFFFFFE) {
              unsigned int v34 = *v28;
            }
            else {
              unsigned int v34 = 0;
            }
            if ((v31 - 3) < 0xFFFFFFFE)
            {
              if (v31 == 3) {
                *((void *)v29 + 1) = 0;
              }
              goto LABEL_22;
            }
            unint64_t v33 = (unint64_t)(v34 + 8);
          }
          else
          {
            if ((v29[1] & 0x7F) != 2 && !*((_DWORD *)v29 + 3)) {
              goto LABEL_22;
            }
            uint64_t v32 = *((void *)v29 + 2);
            if ((v32 & 4) == 0) {
              goto LABEL_22;
            }
            unint64_t v33 = v32 & 0xFFFFFFFFFFFFFFF8;
            if (!v33) {
              goto LABEL_22;
            }
          }
          uint64_t v169 = (Function *)(i + 56);
          sub_1CC5FA668(v33 + 16, &v169);
        }
LABEL_22:
        unsigned int v30 = v177;
        *unsigned int v28 = v177;
        if (v30)
        {
          llvm::MetadataTracking::retrack((uint64_t)&v177, v30, i + 56);
          BOOL v177 = 0;
        }
LABEL_24:
        if ((*(unsigned char *)i & 4) != 0) {
          goto LABEL_48;
        }
        goto LABEL_47;
      }
      if (v177)
      {
        int v35 = *v177;
        if ((v35 - 4) > 0x1E)
        {
          if ((v35 - 3) >= 0xFFFFFFFE) {
            BOOL v36 = v177;
          }
          else {
            BOOL v36 = 0;
          }
          if ((v35 - 3) >= 0xFFFFFFFE)
          {
            unint64_t v37 = (unint64_t)(v36 + 8);
LABEL_54:
            uint64_t v169 = (Function *)&v177;
            sub_1CC5FA668(v37 + 16, &v169);
            goto LABEL_44;
          }
          if (v35 == 3) {
            *((void *)v177 + 1) = 0;
          }
        }
        else if ((v177[1] & 0x7F) == 2 || *((_DWORD *)v177 + 3))
        {
          uint64_t v38 = *((void *)v177 + 2);
          if ((v38 & 4) != 0)
          {
            unint64_t v37 = v38 & 0xFFFFFFFFFFFFFFF8;
            if (v37) {
              goto LABEL_54;
            }
          }
        }
      }
LABEL_44:
      if (i) {
        goto LABEL_24;
      }
LABEL_47:
      while ((*(_WORD *)(i + 44) & 8) != 0)
        uint64_t i = *(void *)(i + 8);
LABEL_48:
      ++v23;
    }
    uint64_t v25 = *(void *)(v25 + 8);
  }
  while (v25 != v24);
LABEL_61:
  unsigned int v154 = v21;
  uint64_t v155 = v24;
  unsigned int v39 = (uint64_t *)*((void *)v21 + 14);
  unsigned int v40 = *((_DWORD *)v39 + 8);
  if (v40 <= 1) {
    uint64_t v41 = 1;
  }
  else {
    uint64_t v41 = v40;
  }
  if (v40 <= 0xD) {
    size_t v42 = v41;
  }
  else {
    size_t v42 = 14;
  }
  uint64_t v163 = *((unsigned int *)v39 + 2);
  uint64_t v165 = *((void *)v21 + 14);
  if (!v163) {
    goto LABEL_80;
  }
  uint64_t v43 = 0;
  int v44 = 0;
  do
    int v44 = 33 * v44 + aLlvmDbgValue[v43++];
  while (v42 != v43);
  uint64_t v45 = *v39;
  uint64_t v46 = *v39 + 8 * v163 + 8;
  int v47 = 1;
  int v48 = v44;
  while (1)
  {
    uint64_t v49 = v48 & (v163 - 1);
    unsigned int v50 = *(void **)(v45 + 8 * v49);
    if (v50 != (void *)-8)
    {
      if (!v50) {
        goto LABEL_80;
      }
      if (*(_DWORD *)(v46 + 4 * v49) == v44
        && v42 == *v50
        && !memcmp("llvm.dbg.value", (char *)v50 + *(unsigned int *)(v165 + 20), v42))
      {
        break;
      }
    }
    int v48 = v47 + v49;
    ++v47;
  }
  if (v49 == -1
    || (int)v49 == v163
    || (uint64_t v51 = *(void *)(*(void *)(v45 + 8 * (int)v49) + 8)) == 0
    || *(unsigned char *)(v51 + 16))
  {
LABEL_80:
    uint64_t v174 = 0;
    uint64_t v175 = 0;
    int v176 = 0;
    uint64_t v5 = v161;
  }
  else
  {
    uint64_t v174 = 0;
    uint64_t v175 = 0;
    int v176 = 0;
    uint64_t v55 = *(void *)(v51 + 8);
    uint64_t v5 = v161;
    uint64_t v56 = v24;
    if (v55)
    {
      uint64_t v57 = 0;
      uint64_t v58 = 0;
      do
      {
        uint64_t v59 = *(void *)(v55 + 24);
        BOOL v60 = sub_1CC27FAEC(v59);
        if (v59) {
          BOOL v61 = !v60;
        }
        else {
          BOOL v61 = 1;
        }
        if (!v61 && *(Function **)(*(void *)(v59 + 40) + 56) == v162)
        {
          unsigned int v62 = *(_DWORD *)(*(void *)(v59 + 48) + 4);
          LODWORD(v169) = v62;
          uint64_t v63 = v57;
          uint64_t v64 = *(void *)(*(void *)(v59 - 32 * (*(_DWORD *)(v59 + 20) & 0x7FFFFFF) + 32) + 24);
          *((void *)sub_1CD52C224((uint64_t)&v174, &v169) + 1) = v64;
          if (!v63 || (uint64_t v57 = v63, v62 < *(_DWORD *)(*(void *)(v63 + 48) + 4))) {
            uint64_t v57 = v59;
          }
          uint64_t v58 = *(void *)(*(void *)(v59 - 32 * (*(_DWORD *)(v59 + 20) & 0x7FFFFFF) + 64) + 24);
          uint64_t v56 = v155;
        }
        uint64_t v55 = *(void *)(v55 + 8);
      }
      while (v55);
      if (v175)
      {
        uint64_t v153 = v57;
        uint64_t v169 = (Function *)v173;
        uint64_t v170 = (Function *)v173;
        uint64_t v171 = 16;
        int v172 = 0;
        uint64_t v65 = *(void *)(v161 + 328);
        if (v65 != v56)
        {
          uint64_t v152 = 0;
          uint64_t v156 = *(void *)(v159 + 8) + 624;
          while (1)
          {
            uint64_t v66 = v65 + 48;
            uint64_t v67 = *(unint64_t **)(v65 + 56);
            if (v67 != (unint64_t *)(v65 + 48))
            {
              uint64_t v68 = *(void *)(v65 + 56);
              while (!**(_WORD **)(v68 + 16) || **(_WORD **)(v68 + 16) == 69)
              {
                uint64_t v68 = *(void *)(v68 + 8);
                if (v68 == v66)
                {
                  uint64_t v68 = v65 + 48;
                  break;
                }
              }
              uint64_t v157 = v65;
              uint64_t v158 = v68;
              uint64_t v160 = v65 + 48;
              if (v67 != (unint64_t *)v66) {
                break;
              }
            }
LABEL_196:
            uint64_t v65 = *(void *)(v65 + 8);
            if (v65 == v155) {
              goto LABEL_197;
            }
          }
          while (2)
          {
            if (!v67 || (int v69 = v67, (*(unsigned char *)v67 & 4) == 0))
            {
              int v69 = v67;
              if ((*((_WORD *)v67 + 22) & 8) != 0)
              {
                int v69 = v67;
                do
                  int v69 = (unint64_t *)v69[1];
                while ((*((_WORD *)v69 + 22) & 8) != 0);
              }
            }
            uint64_t v70 = (unint64_t *)v69[1];
            uint64_t v71 = (unsigned __int16 *)v67[2];
            int v72 = *v71;
            if ((v72 - 13) < 5) {
              goto LABEL_183;
            }
            uint64_t v73 = *((void *)v71 + 1);
            if ((*((_WORD *)v67 + 22) & 0xC) == 0 || (*((_WORD *)v67 + 22) & 4) != 0)
            {
              if ((v73 & 0x200) == 0) {
                goto LABEL_122;
              }
LABEL_183:
              uint64_t v67 = v70;
              if (v70 == (unint64_t *)v66) {
                goto LABEL_196;
              }
              continue;
            }
            break;
          }
          uint64_t v78 = v67;
          if ((v73 & 0x200) != 0) {
            goto LABEL_183;
          }
          while ((*((_WORD *)v78 + 22) & 8) != 0)
          {
            uint64_t v78 = (unint64_t *)v78[1];
            if ((*(unsigned char *)(v78[2] + 9) & 2) != 0) {
              goto LABEL_183;
            }
          }
LABEL_122:
          if (v72 == 69 || v72 == 0) {
            uint64_t v76 = (unint64_t *)v68;
          }
          else {
            uint64_t v76 = v70;
          }
          int v77 = *(_DWORD *)(v67[7] + 4);
          int v168 = v77;
          if (v176)
          {
            unsigned int v79 = (v176 - 1) & (37 * v77);
            int v80 = *(_DWORD *)(v174 + 16 * v79);
            if (v77 != v80)
            {
              int v108 = 1;
              while (v80 != -1)
              {
                unsigned int v109 = v79 + v108++;
                unsigned int v79 = v109 & (v176 - 1);
                int v80 = *(_DWORD *)(v174 + 16 * v79);
                if (v77 == v80) {
                  goto LABEL_135;
                }
              }
              goto LABEL_129;
            }
          }
          else
          {
LABEL_129:
            int v168 = *(_DWORD *)(*(void *)(v153 + 48) + 4);
          }
LABEL_135:
          uint64_t v164 = (unsigned __int8 **)(v67 + 7);
          uint64_t v166 = v76;
          uint64_t v81 = *((void *)sub_1CD52C224((uint64_t)&v174, &v168) + 1);
          unint64_t v82 = v170;
          uint64_t v83 = HIDWORD(v171);
          if (v170 == v169)
          {
            if (HIDWORD(v171))
            {
              int v84 = 0;
              uint64_t v85 = 8 * HIDWORD(v171);
              BOOL v86 = (uint64_t *)v170;
              while (*v86 != v81)
              {
                if (*v86 == -2) {
                  int v84 = v86;
                }
                ++v86;
                v85 -= 8;
                if (!v85)
                {
                  if (!v84) {
                    goto LABEL_143;
                  }
                  *int v84 = v81;
                  --v172;
                  goto LABEL_167;
                }
              }
              goto LABEL_167;
            }
LABEL_143:
            unsigned int v87 = v171;
            if (HIDWORD(v171) < v171)
            {
              ++HIDWORD(v171);
              *((void *)v170 + v83) = v81;
LABEL_167:
              int v178 = (char *)v180;
              uint64_t v179 = 0x400000000;
              uint64_t v97 = *((unsigned int *)v67 + 10);
              if (!v97) {
                goto LABEL_185;
              }
              uint64_t v98 = v58;
              unsigned int v99 = 0;
              unint64_t v100 = v67[4];
              uint64_t v101 = 32 * v97;
              int v102 = (_DWORD *)(v100 + 4);
              do
              {
                if ((*(v102 - 1) & 0x10000FF) == 0x1000000 && *v102)
                {
                  if (v99 >= HIDWORD(v179)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *(void *)&v178[8 * v99] = v100;
                  unsigned int v99 = v179 + 1;
                  LODWORD(v179) = v179 + 1;
                }
                v100 += 32;
                v102 += 8;
                v101 -= 32;
              }
              while (v101);
              uint64_t v58 = v98;
              uint64_t v65 = v157;
              if (!v99) {
                goto LABEL_185;
              }
              BOOL v103 = (const llvm::MachineOperand **)v178;
              uint64_t v104 = 8 * v99;
              do
              {
                unsigned int v105 = *v103++;
                uint64_t v106 = v81;
                llvm::BuildMI(v157, v166, v164, v156, 0, v105, v81, v58);
                uint64_t v81 = v106;
                v104 -= 8;
              }
              while (v104);
              if (!v179)
              {
LABEL_185:
                LODWORD(v167[0]) = 1;
                v167[1] = 0;
                v167[2] = v152;
                llvm::BuildMI(v65, v166, v164, v156, 0, (const llvm::MachineOperand *)v167, v81, v58);
                ++v152;
              }
              uint64_t v66 = v160;
              if (v178 != (char *)v180) {
                free(v178);
              }
              uint64_t v68 = v158;
              goto LABEL_183;
            }
          }
          else
          {
            unsigned int v87 = v171;
          }
          if (3 * v87 <= 4 * (HIDWORD(v171) - v172))
          {
            if (v87 >= 0x40) {
              v87 *= 2;
            }
            else {
              unsigned int v87 = 128;
            }
          }
          else if (v87 - HIDWORD(v171) >= v87 >> 3)
          {
            goto LABEL_148;
          }
          uint64_t v107 = v81;
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v169, v87);
          uint64_t v81 = v107;
          unsigned int v87 = v171;
          unint64_t v82 = v170;
LABEL_148:
          unsigned int v88 = v87 - 1;
          unsigned int v89 = (v87 - 1) & ((v81 >> 4) ^ (v81 >> 9));
          int v90 = (char *)v82 + 8 * v89;
          uint64_t v91 = *(void *)v90;
          if (*(void *)v90 == -1)
          {
            unint64_t v92 = 0;
LABEL_160:
            if (v92) {
              unint64_t v96 = v92;
            }
            else {
              unint64_t v96 = (uint64_t *)v90;
            }
            if (*v96 != v81)
            {
              if (*v96 == -2) {
                --v172;
              }
              else {
                ++HIDWORD(v171);
              }
              *unint64_t v96 = v81;
            }
          }
          else
          {
            unint64_t v92 = 0;
            int v93 = 1;
            while (v91 != v81)
            {
              if (v92) {
                BOOL v94 = 0;
              }
              else {
                BOOL v94 = v91 == -2;
              }
              if (v94) {
                unint64_t v92 = (uint64_t *)v90;
              }
              unsigned int v95 = v89 + v93++;
              unsigned int v89 = v95 & v88;
              int v90 = (char *)v82 + 8 * (v95 & v88);
              uint64_t v91 = *(void *)v90;
              if (*(void *)v90 == -1) {
                goto LABEL_160;
              }
            }
          }
          goto LABEL_167;
        }
LABEL_197:
        int v178 = "llvm.mir.debugify";
        v180[8] = 259;
        uint64_t NamedMetadata = llvm::Module::getNamedMetadata(v154, (const char **)&v178);
        uint64_t v112 = *v22;
        if (NamedMetadata)
        {
          uint64_t v113 = NamedMetadata;
          uint64_t v114 = v23 - 1;
          unsigned int v115 = *(llvm::ConstantInt **)(v112 + 1960);
          unsigned int v116 = *(_DWORD *)(v112 + 1968);
          LODWORD(v179) = v116 >> 8;
          if (v116 >> 8 > 0x40) {
            operator new[]();
          }
          if (v116 <= 0xFF) {
            unint64_t v117 = 0;
          }
          else {
            unint64_t v117 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v116) + 63);
          }
          int v178 = (char *)(v117 & v114);
          unint64_t v119 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v115, (llvm::LLVMContext *)&v178, v111);
          uint64_t v5 = v161;
          if (v179 >= 0x41 && v178) {
            MEMORY[0x1D25D9CB0](v178, 0x1000C8000313F17);
          }
          int v178 = (char *)llvm::ValueAsMetadata::get(v119, v118);
          uint64_t v120 = (unsigned __int8 *)llvm::MDTuple::getImpl((uint64_t)v22, &v178, 1, 0, 1);
          sub_1CC19E068(**(unsigned __int8 ****)(v113 + 48), v120);
          uint64_t v122 = *(llvm::ConstantInt **)(v112 + 1960);
          unsigned int v123 = *(_DWORD *)(v112 + 1968);
          LODWORD(v179) = v123 >> 8;
          if (v123 >> 8 > 0x40) {
            operator new[]();
          }
          if (v123 <= 0xFF) {
            LODWORD(v124) = 0;
          }
          else {
            unint64_t v124 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v123) + 63);
          }
          int v178 = (char *)(v124 & (HIDWORD(v171) - v172));
          uint64_t v126 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v122, (llvm::LLVMContext *)&v178, v121);
          if (v179 >= 0x41 && v178) {
            MEMORY[0x1D25D9CB0](v178, 0x1000C8000313F17);
          }
          int v178 = (char *)llvm::ValueAsMetadata::get(v126, v125);
          uint64_t v127 = (unsigned __int8 *)llvm::MDTuple::getImpl((uint64_t)v22, &v178, 1, 0, 1);
          sub_1CC19E068((unsigned __int8 **)(**(void **)(v113 + 48) + 8), v127);
        }
        else
        {
          uint64_t inserted = llvm::Module::getOrInsertNamedMetadata(v154, "llvm.mir.debugify", 0x11uLL);
          uint64_t v130 = v23 - 1;
          unsigned int v131 = *(llvm::ConstantInt **)(v112 + 1960);
          unsigned int v132 = *(_DWORD *)(v112 + 1968);
          LODWORD(v179) = v132 >> 8;
          if (v132 >> 8 > 0x40) {
            operator new[]();
          }
          if (v132 <= 0xFF) {
            unint64_t v133 = 0;
          }
          else {
            unint64_t v133 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v132) + 63);
          }
          int v178 = (char *)(v133 & v130);
          uint64_t v135 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v131, (llvm::LLVMContext *)&v178, v128);
          uint64_t v5 = v161;
          if (v179 >= 0x41 && v178) {
            MEMORY[0x1D25D9CB0](v178, 0x1000C8000313F17);
          }
          v167[0] = llvm::ValueAsMetadata::get(v135, v134);
          uint64_t v136 = (unsigned __int8 *)llvm::MDTuple::getImpl((uint64_t)v22, v167, 1, 0, 1);
          int v178 = (char *)v136;
          uint64_t v138 = *(void *)(inserted + 48);
          uint64_t v139 = *(unsigned int *)(v138 + 8);
          if (v139 >= *(_DWORD *)(v138 + 12))
          {
            sub_1CC608328(*(void *)(inserted + 48), (unsigned __int8 **)&v178);
          }
          else
          {
            int v140 = v136;
            uint64_t v141 = (unsigned __int8 **)(*(void *)v138 + 8 * v139);
            *uint64_t v141 = v140;
            if (v140)
            {
              llvm::MetadataTracking::track((uint64_t)v141, v140, 2);
              LODWORD(v139) = *(_DWORD *)(v138 + 8);
            }
            *(_DWORD *)(v138 + 8) = v139 + 1;
          }
          __n128 v142 = *(llvm::ConstantInt **)(v112 + 1960);
          unsigned int v143 = *(_DWORD *)(v112 + 1968);
          LODWORD(v179) = v143 >> 8;
          if (v143 >> 8 > 0x40) {
            operator new[]();
          }
          if (v143 <= 0xFF) {
            LODWORD(v144) = 0;
          }
          else {
            unint64_t v144 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v143) + 63);
          }
          int v178 = (char *)(v144 & (HIDWORD(v171) - v172));
          int v146 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v142, (llvm::LLVMContext *)&v178, v137);
          if (v179 >= 0x41 && v178) {
            MEMORY[0x1D25D9CB0](v178, 0x1000C8000313F17);
          }
          v167[0] = llvm::ValueAsMetadata::get(v146, v145);
          int v147 = (unsigned __int8 *)llvm::MDTuple::getImpl((uint64_t)v22, v167, 1, 0, 1);
          int v178 = (char *)v147;
          uint64_t v148 = *(void *)(inserted + 48);
          uint64_t v149 = *(unsigned int *)(v148 + 8);
          if (v149 >= *(_DWORD *)(v148 + 12))
          {
            sub_1CC608328(*(void *)(inserted + 48), (unsigned __int8 **)&v178);
          }
          else
          {
            int v150 = v147;
            uint64_t v151 = (unsigned __int8 **)(*(void *)v148 + 8 * v149);
            *uint64_t v151 = v150;
            if (v150)
            {
              llvm::MetadataTracking::track((uint64_t)v151, v150, 2);
              LODWORD(v149) = *(_DWORD *)(v148 + 8);
            }
            *(_DWORD *)(v148 + 8) = v149 + 1;
          }
        }
        if (v170 != v169) {
          free(v170);
        }
      }
    }
  }
  MEMORY[0x1D25D9CD0](v174, 8);
  return v5 != 0;
}

uint64_t llvm::DominanceFrontierBase<llvm::MachineBasicBlock,false>::getRoots(uint64_t a1)
{
  return a1 + 24;
}

uint64_t llvm::DominanceFrontierBase<llvm::MachineBasicBlock,false>::getRoot(uint64_t a1)
{
  return **(void **)(a1 + 24);
}

uint64_t llvm::DominanceFrontierBase<llvm::MachineBasicBlock,false>::isPostDominator()
{
  return 0;
}

void llvm::DominanceFrontierBase<llvm::MachineBasicBlock,false>::releaseMemory(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 8);
  sub_1CD486DF0(a1, *(void **)(a1 + 8));
  *(void *)a1 = v2;
  *(void *)(a1 + 16) = 0;
  *uint64_t v2 = 0;
}

uint64_t llvm::DominanceFrontierBase<llvm::MachineBasicBlock,false>::begin(uint64_t a1)
{
  return *(void *)a1;
}

{
  return *(void *)a1;
}

uint64_t llvm::DominanceFrontierBase<llvm::MachineBasicBlock,false>::end(uint64_t a1)
{
  return a1 + 8;
}

{
  return a1 + 8;
}

void *llvm::DominanceFrontierBase<llvm::MachineBasicBlock,false>::find(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void **)(a1 + 8);
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  uint64_t v5 = v2;
  do
  {
    unint64_t v6 = v3[4];
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      uint64_t v8 = v3;
    }
    else {
      uint64_t v8 = v3 + 1;
    }
    if (v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = (void *)*v8;
  }
  while (*v8);
  if (v5 == v2 || v5[4] > a2) {
    return v2;
  }
  return v5;
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  unint64_t v6;
  BOOL v7;
  void *v8;

  uint64_t v4 = *(void **)(a1 + 8);
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  uint64_t v5 = v2;
  do
  {
    unint64_t v6 = v3[4];
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      uint64_t v8 = v3;
    }
    else {
      uint64_t v8 = v3 + 1;
    }
    if (v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = (void *)*v8;
  }
  while (*v8);
  if (v5 == v2 || v5[4] > a2) {
    return v2;
  }
  return v5;
}

uint64_t **llvm::DominanceFrontierBase<llvm::MachineBasicBlock,false>::addBasicBlock(uint64_t **a1, unint64_t a2, void *a3)
{
  unint64_t v6 = a2;
  sub_1CC33D47C((uint64_t)v7, a3);
  uint64_t v4 = sub_1CBFF05F8(a1, v6, (uint64_t)&v6);
  sub_1CB833A08((uint64_t)v7, v7[1]);
  return v4;
}

void llvm::DominanceFrontierBase<llvm::MachineBasicBlock,false>::removeBlock(uint64_t **a1, unint64_t a2)
{
  uint64_t v4 = a1 + 1;
  uint64_t v5 = *a1;
  if (*a1 != (uint64_t *)(a1 + 1))
  {
    do
    {
      sub_1CBFF06F8((uint64_t **)v5 + 5, a2);
      unint64_t v6 = (uint64_t *)v5[1];
      if (v6)
      {
        do
        {
          BOOL v7 = v6;
          unint64_t v6 = (uint64_t *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          BOOL v7 = (uint64_t *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          uint64_t v5 = v7;
        }
        while (!v8);
      }
      uint64_t v5 = v7;
    }
    while (v7 != (uint64_t *)v4);
  }

  sub_1CBFF07C4(a1, a2);
}

uint64_t *llvm::DominanceFrontierBase<llvm::MachineBasicBlock,false>::addToFrontier(uint64_t a1, uint64_t a2, unint64_t a3)
{
  return sub_1CBFF06F8((uint64_t **)(a2 + 40), a3);
}

uint64_t *llvm::DominanceFrontierBase<llvm::MachineBasicBlock,false>::removeFromFrontier(uint64_t a1, uint64_t a2, unint64_t a3)
{
  return sub_1CBFF06F8((uint64_t **)(a2 + 40), a3);
}

BOOL llvm::DominanceFrontierBase<llvm::MachineBasicBlock,false>::compareDomSet(uint64_t a1, void *a2, void *a3)
{
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  int v19 = (uint64_t *)&v20;
  uint64_t v4 = a3 + 1;
  uint64_t v5 = (void *)*a3;
  if ((void *)*a3 != a3 + 1)
  {
    do
    {
      uint64_t v18 = (uint64_t *)v5[4];
      sub_1CD3CFB98(&v19, (unint64_t *)&v18, &v18);
      unint64_t v6 = (void *)v5[1];
      if (v6)
      {
        do
        {
          BOOL v7 = v6;
          unint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          BOOL v7 = (void *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          uint64_t v5 = v7;
        }
        while (!v8);
      }
      uint64_t v5 = v7;
    }
    while (v7 != v4);
  }
  unint64_t v11 = (void *)*a2;
  unsigned int v10 = a2 + 1;
  int v9 = v11;
  while (v9 != v10)
  {
    uint64_t v12 = (void *)v9[1];
    uint64_t v13 = v9;
    if (v12)
    {
      do
      {
        int v14 = v12;
        uint64_t v12 = (void *)*v12;
      }
      while (v12);
    }
    else
    {
      do
      {
        int v14 = (void *)v13[2];
        BOOL v8 = *v14 == (void)v13;
        uint64_t v13 = v14;
      }
      while (!v8);
    }
    BOOL v15 = sub_1CBFF06F8(&v19, v9[4]);
    int v9 = v14;
    if (!v15)
    {
      BOOL v16 = 1;
      goto LABEL_18;
    }
  }
  BOOL v16 = v21 != 0;
LABEL_18:
  sub_1CB833A08((uint64_t)&v19, v20);
  return v16;
}

BOOL llvm::DominanceFrontierBase<llvm::MachineBasicBlock,false>::compare(uint64_t a1, void *a2)
{
  int v19 = 0;
  uint64_t v20 = 0;
  uint64_t v18 = (uint64_t *)&v19;
  uint64_t v2 = a2 + 1;
  uint64_t v3 = (void *)*a2;
  if ((void *)*a2 == a2 + 1) {
    goto LABEL_9;
  }
  do
  {
    unint64_t v16 = v3[4];
    sub_1CC33D47C((uint64_t)v17, v3 + 5);
    sub_1CBFF05F8(&v18, v16, (uint64_t)&v16);
    sub_1CB833A08((uint64_t)v17, v17[1]);
    uint64_t v5 = (void *)v3[1];
    if (v5)
    {
      do
      {
        unint64_t v6 = v5;
        uint64_t v5 = (void *)*v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        unint64_t v6 = (void *)v3[2];
        BOOL v7 = *v6 == (void)v3;
        uint64_t v3 = v6;
      }
      while (!v7);
    }
    uint64_t v3 = v6;
  }
  while (v6 != v2);
  if (v18 == (uint64_t *)&v19)
  {
LABEL_9:
    BOOL v8 = v20 != 0;
  }
  else
  {
    int v9 = *(void **)(a1 + 8);
    if (v9)
    {
      unint64_t v10 = v18[4];
      unint64_t v11 = (void *)(a1 + 8);
      do
      {
        unint64_t v12 = v9[4];
        BOOL v13 = v12 >= v10;
        if (v12 >= v10) {
          int v14 = v9;
        }
        else {
          int v14 = v9 + 1;
        }
        if (v13) {
          unint64_t v11 = v9;
        }
        int v9 = (void *)*v14;
      }
      while (*v14);
      if (v11 != (void *)(a1 + 8) && v11[4] <= v10) {
        llvm::DominanceFrontierBase<llvm::MachineBasicBlock,false>::compareDomSet();
      }
    }
    BOOL v8 = 1;
  }
  sub_1CD486DF0((uint64_t)&v18, v19);
  return v8;
}

llvm::raw_ostream *llvm::DominanceFrontierBase<llvm::MachineBasicBlock,false>::print(llvm::raw_ostream *result, llvm::raw_ostream *this)
{
  uint64_t v2 = (void *)((char *)result + 8);
  uint64_t v3 = *(void **)result;
  if (*(llvm::raw_ostream **)result != (llvm::raw_ostream *)((char *)result + 8))
  {
    while (1)
    {
      uint64_t v5 = (void *)*((void *)this + 4);
      if (*((void *)this + 3) - (void)v5 > 0x14uLL)
      {
        qmemcpy(v5, "  DomFrontier for BB ", 21);
        *((void *)this + 4) += 21;
      }
      else
      {
        llvm::raw_ostream::write(this, "  DomFrontier for BB ", 0x15uLL);
      }
      uint64_t result = (llvm::raw_ostream *)v3[4];
      if (result)
      {
        uint64_t result = llvm::MachineBasicBlock::printAsOperand(result, this);
      }
      else
      {
        unint64_t v6 = (void *)*((void *)this + 4);
        if (*((void *)this + 3) - (void)v6 > 0xDuLL)
        {
          qmemcpy(v6, " <<exit node>>", 14);
          *((void *)this + 4) += 14;
        }
        else
        {
          uint64_t result = llvm::raw_ostream::write(this, " <<exit node>>", 0xEuLL);
        }
      }
      uint64_t v7 = *((void *)this + 4);
      if ((unint64_t)(*((void *)this + 3) - v7) > 4)
      {
        *(unsigned char *)(v7 + 4) = 9;
        *(_DWORD *)uint64_t v7 = 980642080;
        *((void *)this + 4) += 5;
      }
      else
      {
        uint64_t result = llvm::raw_ostream::write(this, " is:\t", 5uLL);
      }
      BOOL v8 = (void *)v3[5];
      if (v8 != v3 + 6) {
        break;
      }
LABEL_24:
      BOOL v15 = (unsigned char *)*((void *)this + 4);
      if ((unint64_t)v15 >= *((void *)this + 3))
      {
        uint64_t result = llvm::raw_ostream::write(this, 10);
      }
      else
      {
        *((void *)this + 4) = v15 + 1;
        unsigned char *v15 = 10;
      }
      unint64_t v16 = (void *)v3[1];
      if (v16)
      {
        do
        {
          unsigned int v17 = v16;
          unint64_t v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          unsigned int v17 = (void *)v3[2];
          BOOL v14 = *v17 == (void)v3;
          uint64_t v3 = v17;
        }
        while (!v14);
      }
      uint64_t v3 = v17;
      if (v17 == v2) {
        return result;
      }
    }
    while (1)
    {
      int v9 = (llvm::MachineBasicBlock *)v8[4];
      unint64_t v10 = (unsigned char *)*((void *)this + 4);
      if ((unint64_t)v10 >= *((void *)this + 3))
      {
        uint64_t result = llvm::raw_ostream::write(this, 32);
        if (v9)
        {
LABEL_12:
          uint64_t result = llvm::MachineBasicBlock::printAsOperand(v9, this);
          goto LABEL_16;
        }
      }
      else
      {
        *((void *)this + 4) = v10 + 1;
        *unint64_t v10 = 32;
        if (v9) {
          goto LABEL_12;
        }
      }
      unint64_t v11 = (void *)*((void *)this + 4);
      if (*((void *)this + 3) - (void)v11 > 0xCuLL)
      {
        qmemcpy(v11, "<<exit node>>", 13);
        *((void *)this + 4) += 13;
      }
      else
      {
        uint64_t result = llvm::raw_ostream::write(this, "<<exit node>>", 0xDuLL);
      }
LABEL_16:
      unint64_t v12 = (void *)v8[1];
      if (v12)
      {
        do
        {
          BOOL v13 = v12;
          unint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          BOOL v13 = (void *)v8[2];
          BOOL v14 = *v13 == (void)v8;
          BOOL v8 = v13;
        }
        while (!v14);
      }
      BOOL v8 = v13;
      if (v13 == v3 + 6) {
        goto LABEL_24;
      }
    }
  }
  return result;
}

void llvm::DominanceFrontierBase<llvm::MachineBasicBlock,false>::dump(llvm *a1)
{
  llvm::dbgs(a1);

  llvm::DominanceFrontierBase<llvm::MachineBasicBlock,false>::print();
}

uint64_t llvm::DominanceFrontierBase<llvm::MachineBasicBlock,true>::getRoots(uint64_t a1)
{
  return a1 + 24;
}

uint64_t llvm::DominanceFrontierBase<llvm::MachineBasicBlock,true>::getRoot(uint64_t a1)
{
  return **(void **)(a1 + 24);
}

uint64_t llvm::DominanceFrontierBase<llvm::MachineBasicBlock,true>::isPostDominator()
{
  return 1;
}

void llvm::DominanceFrontierBase<llvm::MachineBasicBlock,true>::releaseMemory(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 8);
  sub_1CD486DF0(a1, *(void **)(a1 + 8));
  *(void *)a1 = v2;
  *(void *)(a1 + 16) = 0;
  *uint64_t v2 = 0;
}

uint64_t llvm::DominanceFrontierBase<llvm::MachineBasicBlock,true>::begin(uint64_t a1)
{
  return *(void *)a1;
}

{
  return *(void *)a1;
}

uint64_t llvm::DominanceFrontierBase<llvm::MachineBasicBlock,true>::end(uint64_t a1)
{
  return a1 + 8;
}

{
  return a1 + 8;
}

void *llvm::DominanceFrontierBase<llvm::MachineBasicBlock,true>::find(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void **)(a1 + 8);
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  uint64_t v5 = v2;
  do
  {
    unint64_t v6 = v3[4];
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      BOOL v8 = v3;
    }
    else {
      BOOL v8 = v3 + 1;
    }
    if (v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = (void *)*v8;
  }
  while (*v8);
  if (v5 == v2 || v5[4] > a2) {
    return v2;
  }
  return v5;
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  unint64_t v6;
  BOOL v7;
  void *v8;

  uint64_t v4 = *(void **)(a1 + 8);
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  uint64_t v5 = v2;
  do
  {
    unint64_t v6 = v3[4];
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      BOOL v8 = v3;
    }
    else {
      BOOL v8 = v3 + 1;
    }
    if (v7) {
      uint64_t v5 = v3;
    }
    uint64_t v3 = (void *)*v8;
  }
  while (*v8);
  if (v5 == v2 || v5[4] > a2) {
    return v2;
  }
  return v5;
}

uint64_t **llvm::DominanceFrontierBase<llvm::MachineBasicBlock,true>::addBasicBlock(uint64_t **a1, unint64_t a2, void *a3)
{
  unint64_t v6 = a2;
  sub_1CC33D47C((uint64_t)v7, a3);
  uint64_t v4 = sub_1CBFF05F8(a1, v6, (uint64_t)&v6);
  sub_1CB833A08((uint64_t)v7, v7[1]);
  return v4;
}

void llvm::DominanceFrontierBase<llvm::MachineBasicBlock,true>::removeBlock(uint64_t **a1, unint64_t a2)
{
  uint64_t v4 = a1 + 1;
  uint64_t v5 = *a1;
  if (*a1 != (uint64_t *)(a1 + 1))
  {
    do
    {
      sub_1CBFF06F8((uint64_t **)v5 + 5, a2);
      unint64_t v6 = (uint64_t *)v5[1];
      if (v6)
      {
        do
        {
          BOOL v7 = v6;
          unint64_t v6 = (uint64_t *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          BOOL v7 = (uint64_t *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          uint64_t v5 = v7;
        }
        while (!v8);
      }
      uint64_t v5 = v7;
    }
    while (v7 != (uint64_t *)v4);
  }

  sub_1CBFF07C4(a1, a2);
}

uint64_t *llvm::DominanceFrontierBase<llvm::MachineBasicBlock,true>::addToFrontier(uint64_t a1, uint64_t a2, unint64_t a3)
{
  return sub_1CBFF06F8((uint64_t **)(a2 + 40), a3);
}

uint64_t *llvm::DominanceFrontierBase<llvm::MachineBasicBlock,true>::removeFromFrontier(uint64_t a1, uint64_t a2, unint64_t a3)
{
  return sub_1CBFF06F8((uint64_t **)(a2 + 40), a3);
}

BOOL llvm::DominanceFrontierBase<llvm::MachineBasicBlock,true>::compareDomSet(uint64_t a1, void *a2, void *a3)
{
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  int v19 = (uint64_t *)&v20;
  uint64_t v4 = a3 + 1;
  uint64_t v5 = (void *)*a3;
  if ((void *)*a3 != a3 + 1)
  {
    do
    {
      uint64_t v18 = (uint64_t *)v5[4];
      sub_1CD3CFB98(&v19, (unint64_t *)&v18, &v18);
      unint64_t v6 = (void *)v5[1];
      if (v6)
      {
        do
        {
          BOOL v7 = v6;
          unint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          BOOL v7 = (void *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          uint64_t v5 = v7;
        }
        while (!v8);
      }
      uint64_t v5 = v7;
    }
    while (v7 != v4);
  }
  unint64_t v11 = (void *)*a2;
  unint64_t v10 = a2 + 1;
  int v9 = v11;
  while (v9 != v10)
  {
    unint64_t v12 = (void *)v9[1];
    BOOL v13 = v9;
    if (v12)
    {
      do
      {
        BOOL v14 = v12;
        unint64_t v12 = (void *)*v12;
      }
      while (v12);
    }
    else
    {
      do
      {
        BOOL v14 = (void *)v13[2];
        BOOL v8 = *v14 == (void)v13;
        BOOL v13 = v14;
      }
      while (!v8);
    }
    BOOL v15 = sub_1CBFF06F8(&v19, v9[4]);
    int v9 = v14;
    if (!v15)
    {
      BOOL v16 = 1;
      goto LABEL_18;
    }
  }
  BOOL v16 = v21 != 0;
LABEL_18:
  sub_1CB833A08((uint64_t)&v19, v20);
  return v16;
}

BOOL llvm::DominanceFrontierBase<llvm::MachineBasicBlock,true>::compare(uint64_t a1, void *a2)
{
  int v19 = 0;
  uint64_t v20 = 0;
  uint64_t v18 = (uint64_t *)&v19;
  uint64_t v2 = a2 + 1;
  uint64_t v3 = (void *)*a2;
  if ((void *)*a2 == a2 + 1) {
    goto LABEL_9;
  }
  do
  {
    unint64_t v16 = v3[4];
    sub_1CC33D47C((uint64_t)v17, v3 + 5);
    sub_1CBFF05F8(&v18, v16, (uint64_t)&v16);
    sub_1CB833A08((uint64_t)v17, v17[1]);
    uint64_t v5 = (void *)v3[1];
    if (v5)
    {
      do
      {
        unint64_t v6 = v5;
        uint64_t v5 = (void *)*v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        unint64_t v6 = (void *)v3[2];
        BOOL v7 = *v6 == (void)v3;
        uint64_t v3 = v6;
      }
      while (!v7);
    }
    uint64_t v3 = v6;
  }
  while (v6 != v2);
  if (v18 == (uint64_t *)&v19)
  {
LABEL_9:
    BOOL v8 = v20 != 0;
  }
  else
  {
    int v9 = *(void **)(a1 + 8);
    if (v9)
    {
      unint64_t v10 = v18[4];
      unint64_t v11 = (void *)(a1 + 8);
      do
      {
        unint64_t v12 = v9[4];
        BOOL v13 = v12 >= v10;
        if (v12 >= v10) {
          BOOL v14 = v9;
        }
        else {
          BOOL v14 = v9 + 1;
        }
        if (v13) {
          unint64_t v11 = v9;
        }
        int v9 = (void *)*v14;
      }
      while (*v14);
      if (v11 != (void *)(a1 + 8) && v11[4] <= v10) {
        llvm::DominanceFrontierBase<llvm::MachineBasicBlock,true>::compareDomSet();
      }
    }
    BOOL v8 = 1;
  }
  sub_1CD486DF0((uint64_t)&v18, v19);
  return v8;
}

llvm::raw_ostream *llvm::DominanceFrontierBase<llvm::MachineBasicBlock,true>::print(llvm::raw_ostream *result, llvm::raw_ostream *this)
{
  uint64_t v2 = (void *)((char *)result + 8);
  uint64_t v3 = *(void **)result;
  if (*(llvm::raw_ostream **)result != (llvm::raw_ostream *)((char *)result + 8))
  {
    while (1)
    {
      uint64_t v5 = (void *)*((void *)this + 4);
      if (*((void *)this + 3) - (void)v5 > 0x14uLL)
      {
        qmemcpy(v5, "  DomFrontier for BB ", 21);
        *((void *)this + 4) += 21;
      }
      else
      {
        llvm::raw_ostream::write(this, "  DomFrontier for BB ", 0x15uLL);
      }
      uint64_t result = (llvm::raw_ostream *)v3[4];
      if (result)
      {
        uint64_t result = llvm::MachineBasicBlock::printAsOperand(result, this);
      }
      else
      {
        unint64_t v6 = (void *)*((void *)this + 4);
        if (*((void *)this + 3) - (void)v6 > 0xDuLL)
        {
          qmemcpy(v6, " <<exit node>>", 14);
          *((void *)this + 4) += 14;
        }
        else
        {
          uint64_t result = llvm::raw_ostream::write(this, " <<exit node>>", 0xEuLL);
        }
      }
      uint64_t v7 = *((void *)this + 4);
      if ((unint64_t)(*((void *)this + 3) - v7) > 4)
      {
        *(unsigned char *)(v7 + 4) = 9;
        *(_DWORD *)uint64_t v7 = 980642080;
        *((void *)this + 4) += 5;
      }
      else
      {
        uint64_t result = llvm::raw_ostream::write(this, " is:\t", 5uLL);
      }
      BOOL v8 = (void *)v3[5];
      if (v8 != v3 + 6) {
        break;
      }
LABEL_24:
      BOOL v15 = (unsigned char *)*((void *)this + 4);
      if ((unint64_t)v15 >= *((void *)this + 3))
      {
        uint64_t result = llvm::raw_ostream::write(this, 10);
      }
      else
      {
        *((void *)this + 4) = v15 + 1;
        unsigned char *v15 = 10;
      }
      unint64_t v16 = (void *)v3[1];
      if (v16)
      {
        do
        {
          unsigned int v17 = v16;
          unint64_t v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          unsigned int v17 = (void *)v3[2];
          BOOL v14 = *v17 == (void)v3;
          uint64_t v3 = v17;
        }
        while (!v14);
      }
      uint64_t v3 = v17;
      if (v17 == v2) {
        return result;
      }
    }
    while (1)
    {
      int v9 = (llvm::MachineBasicBlock *)v8[4];
      unint64_t v10 = (unsigned char *)*((void *)this + 4);
      if ((unint64_t)v10 >= *((void *)this + 3))
      {
        uint64_t result = llvm::raw_ostream::write(this, 32);
        if (v9)
        {
LABEL_12:
          uint64_t result = llvm::MachineBasicBlock::printAsOperand(v9, this);
          goto LABEL_16;
        }
      }
      else
      {
        *((void *)this + 4) = v10 + 1;
        *unint64_t v10 = 32;
        if (v9) {
          goto LABEL_12;
        }
      }
      unint64_t v11 = (void *)*((void *)this + 4);
      if (*((void *)this + 3) - (void)v11 > 0xCuLL)
      {
        qmemcpy(v11, "<<exit node>>", 13);
        *((void *)this + 4) += 13;
      }
      else
      {
        uint64_t result = llvm::raw_ostream::write(this, "<<exit node>>", 0xDuLL);
      }
LABEL_16:
      unint64_t v12 = (void *)v8[1];
      if (v12)
      {
        do
        {
          BOOL v13 = v12;
          unint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          BOOL v13 = (void *)v8[2];
          BOOL v14 = *v13 == (void)v8;
          BOOL v8 = v13;
        }
        while (!v14);
      }
      BOOL v8 = v13;
      if (v13 == v3 + 6) {
        goto LABEL_24;
      }
    }
  }
  return result;
}

void llvm::DominanceFrontierBase<llvm::MachineBasicBlock,true>::dump(llvm *a1)
{
  llvm::dbgs(a1);

  llvm::DominanceFrontierBase<llvm::MachineBasicBlock,true>::print();
}

void sub_1CC33D3D4(uint64_t a1)
{
}

uint64_t sub_1CC33D47C(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v3 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  uint64_t v4 = a2 + 1;
  uint64_t v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      sub_1CC33D514((void **)a1, v3, v5 + 4, v5 + 4);
      unint64_t v6 = (void *)v5[1];
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          unint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (void *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          uint64_t v5 = v7;
        }
        while (!v8);
      }
      uint64_t v5 = v7;
    }
    while (v7 != v4);
  }
  return a1;
}

uint64_t *sub_1CC33D514(void **a1, void *a2, unint64_t *a3, uint64_t *a4)
{
  unint64_t v6 = (uint64_t **)sub_1CC33D5C4(a1, a2, &v14, &v13, a3);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    BOOL v8 = v6;
    uint64_t v7 = (uint64_t *)operator new(0x28uLL);
    v7[4] = *a4;
    uint64_t v9 = v14;
    *uint64_t v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *BOOL v8 = v7;
    unint64_t v10 = (void *)**a1;
    unint64_t v11 = v7;
    if (v10)
    {
      *a1 = v10;
      unint64_t v11 = *v8;
    }
    sub_1CB8358B8(a1[1], v11);
    a1[2] = (void *)((char *)a1[2] + 1);
  }
  return v7;
}

void *sub_1CC33D5C4(void *a1, void *a2, void *a3, void *a4, unint64_t *a5)
{
  uint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, unint64_t v7 = a2[4], *a5 < v7))
  {
    uint64_t v8 = *a2;
    if ((void *)*a1 == a2)
    {
      unint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      uint64_t v9 = (void *)*a2;
      do
      {
        unint64_t v10 = v9;
        uint64_t v9 = (void *)v9[1];
      }
      while (v9);
    }
    else
    {
      uint64_t v13 = a2;
      do
      {
        unint64_t v10 = (void *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        uint64_t v13 = v10;
      }
      while (v14);
    }
    unint64_t v15 = *a5;
    if (v10[4] < *a5) {
      goto LABEL_17;
    }
    unint64_t v16 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          a4 = v16;
          unint64_t v17 = v16[4];
          if (v15 >= v17) {
            break;
          }
          unint64_t v16 = (void *)*a4;
          uint64_t v5 = a4;
          if (!*a4) {
            goto LABEL_34;
          }
        }
        if (v17 >= v15) {
          break;
        }
        uint64_t v5 = a4 + 1;
        unint64_t v16 = (void *)a4[1];
      }
      while (v16);
LABEL_25:
      *a3 = a4;
      return v5;
    }
    goto LABEL_42;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }
  uint64_t v11 = a2[1];
  if (v11)
  {
    unint64_t v12 = (void *)a2[1];
    do
    {
      a4 = v12;
      unint64_t v12 = (void *)*v12;
    }
    while (v12);
  }
  else
  {
    uint64_t v18 = a2;
    do
    {
      a4 = (void *)v18[2];
      BOOL v14 = *a4 == (void)v18;
      uint64_t v18 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= a4[4])
  {
    int v19 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          a4 = v19;
          unint64_t v20 = v19[4];
          if (v6 >= v20) {
            break;
          }
          int v19 = (void *)*a4;
          uint64_t v5 = a4;
          if (!*a4) {
            goto LABEL_34;
          }
        }
        if (v20 >= v6) {
          break;
        }
        uint64_t v5 = a4 + 1;
        int v19 = (void *)a4[1];
      }
      while (v19);
      goto LABEL_25;
    }
LABEL_42:
    *a3 = v5;
    return v5;
  }
  if (v11)
  {
LABEL_34:
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

double llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::DomTreeNodeBase(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  if (a3) {
    int v3 = *(_DWORD *)(a3 + 16) + 1;
  }
  else {
    int v3 = 0;
  }
  *(_DWORD *)(a1 + 16) = v3;
  *(void *)(a1 + 24) = a1 + 40;
  *(void *)(a1 + 32) = 0x400000000;
  double result = NAN;
  *(void *)(a1 + 72) = -1;
  return result;
}

{
  int v3;
  double result;

  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  if (a3) {
    int v3 = *(_DWORD *)(a3 + 16) + 1;
  }
  else {
    int v3 = 0;
  }
  *(_DWORD *)(a1 + 16) = v3;
  *(void *)(a1 + 24) = a1 + 40;
  *(void *)(a1 + 32) = 0x400000000;
  double result = NAN;
  *(void *)(a1 + 72) = -1;
  return result;
}

uint64_t llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::begin(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

{
  return *(void *)(a1 + 24);
}

uint64_t llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::end(uint64_t a1)
{
  return *(void *)(a1 + 24) + 8 * *(unsigned int *)(a1 + 32);
}

{
  return *(void *)(a1 + 24) + 8 * *(unsigned int *)(a1 + 32);
}

uint64_t llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::back(uint64_t a1)
{
  return *(void *)(a1 + 24) + 8 * *(unsigned int *)(a1 + 32) - 8;
}

{
  return *(void *)(a1 + 24) + 8 * *(unsigned int *)(a1 + 32) - 8;
}

uint64_t llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::children(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

{
  return *(void *)(a1 + 24);
}

uint64_t llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::getBlock(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::getIDom(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::getLevel(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::addChild@<X0>(uint64_t result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  unsigned int v4 = *(_DWORD *)(result + 32);
  if (v4 >= *(_DWORD *)(result + 36)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)(result + 24) + 8 * v4) = *a2;
  ++*(_DWORD *)(result + 32);
  uint64_t v5 = *a2;
  *a2 = 0;
  *a3 = v5;
  return result;
}

BOOL llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::isLeaf(uint64_t a1)
{
  return *(_DWORD *)(a1 + 32) == 0;
}

uint64_t llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::getNumChildren(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::clearAllChildren(uint64_t result)
{
  *(_DWORD *)(result + 32) = 0;
  return result;
}

uint64_t llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::compare(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 32);
  if (v2 != *(_DWORD *)(a2 + 32) || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16)) {
    return 1;
  }
  unsigned int v4 = v50;
  uint64_t v46 = v50;
  int v47 = v50;
  uint64_t v48 = 4;
  int v49 = 0;
  if (!v2) {
    return 0;
  }
  unsigned int v5 = 0;
  unint64_t v6 = *(uint64_t ***)(a2 + 24);
  unint64_t v7 = &v6[v2];
  unsigned int v8 = 4;
  uint64_t v9 = v50;
  do
  {
    uint64_t v10 = **v6;
    if (v9 != v4) {
      goto LABEL_15;
    }
    if (!v5)
    {
LABEL_13:
      if (v8 > v5)
      {
        HIDWORD(v48) = v5 + 1;
        *(void *)&v4[8 * v5] = v10;
        goto LABEL_35;
      }
LABEL_15:
      if (3 * v8 <= 4 * (v5 - v49))
      {
        if (v8 >= 0x40) {
          v8 *= 2;
        }
        else {
          unsigned int v8 = 128;
        }
      }
      else if (v8 - v5 >= v8 >> 3)
      {
        goto LABEL_17;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v46, v8);
      unsigned int v8 = v48;
      uint64_t v9 = v47;
LABEL_17:
      unsigned int v14 = v8 - 1;
      unsigned int v15 = (v8 - 1) & ((v10 >> 4) ^ (v10 >> 9));
      unint64_t v16 = &v9[8 * v15];
      uint64_t v17 = *v16;
      if (*v16 == -1)
      {
        uint64_t v18 = 0;
LABEL_29:
        if (v18) {
          unint64_t v16 = v18;
        }
        if (*v16 != v10)
        {
          if (*v16 == -2) {
            --v49;
          }
          else {
            ++HIDWORD(v48);
          }
          *unint64_t v16 = v10;
        }
      }
      else
      {
        uint64_t v18 = 0;
        int v19 = 1;
        while (v17 != v10)
        {
          if (v18) {
            BOOL v20 = 0;
          }
          else {
            BOOL v20 = v17 == -2;
          }
          if (v20) {
            uint64_t v18 = v16;
          }
          unsigned int v21 = v15 + v19++;
          unsigned int v15 = v21 & v14;
          unint64_t v16 = &v9[8 * (v21 & v14)];
          uint64_t v17 = *v16;
          if (*v16 == -1) {
            goto LABEL_29;
          }
        }
      }
      goto LABEL_35;
    }
    uint64_t v11 = 0;
    uint64_t v12 = 8 * v5;
    uint64_t v13 = v4;
    while (*v13 != v10)
    {
      if (*v13 == -2) {
        uint64_t v11 = v13;
      }
      ++v13;
      v12 -= 8;
      if (!v12)
      {
        if (!v11) {
          goto LABEL_13;
        }
        *uint64_t v11 = v10;
        --v49;
        break;
      }
    }
LABEL_35:
    unsigned int v4 = v46;
    uint64_t v9 = v47;
    unsigned int v8 = v48;
    unsigned int v5 = HIDWORD(v48);
    ++v6;
  }
  while (v6 != v7);
  uint64_t v24 = *(unsigned int *)(a1 + 32);
  if (v24)
  {
    uint64_t v25 = *(uint64_t ***)(a1 + 24);
    uint64_t v26 = &v25[v24];
    int v27 = v48 - 1;
    if (v47 == v46) {
      int v28 = HIDWORD(v48);
    }
    else {
      int v28 = v48;
    }
    unsigned int v29 = &v47[8 * v28];
    unsigned int v30 = HIDWORD(v48);
    int v31 = v47;
    do
    {
      uint64_t v32 = **v25;
      if (v31 == v46)
      {
        unint64_t v33 = &v46[8 * v30];
        if (v30)
        {
          uint64_t v34 = 0;
          while (*(void *)&v46[v34] != v32)
          {
            v34 += 8;
            if (8 * v30 == v34) {
              goto LABEL_69;
            }
          }
          unint64_t v33 = &v46[v34];
        }
LABEL_69:
        int v31 = v46;
      }
      else
      {
        unsigned int v35 = ((v32 >> 4) ^ (v32 >> 9)) & v27;
        BOOL v36 = &v47[8 * v35];
        uint64_t v37 = *v36;
        if (*v36 == -1)
        {
          uint64_t v38 = 0;
LABEL_71:
          if (v38) {
            BOOL v36 = v38;
          }
          uint64_t v42 = *v36;
        }
        else
        {
          uint64_t v38 = 0;
          int v39 = 1;
          while (v37 != v32)
          {
            if (v38) {
              BOOL v40 = 0;
            }
            else {
              BOOL v40 = v37 == -2;
            }
            if (v40) {
              uint64_t v38 = v36;
            }
            unsigned int v41 = v35 + v39++;
            unsigned int v35 = v41 & v27;
            BOOL v36 = &v47[8 * (v41 & v27)];
            uint64_t v37 = *v36;
            if (*v36 == -1) {
              goto LABEL_71;
            }
          }
          uint64_t v42 = **v25;
        }
        if (v42 == v32) {
          unint64_t v33 = v36;
        }
        else {
          unint64_t v33 = v29;
        }
        unsigned int v30 = HIDWORD(v48);
        int v31 = v47;
      }
      if (v31 == v46) {
        int v43 = v30;
      }
      else {
        int v43 = v48;
      }
      int v44 = &v31[8 * v43];
      BOOL v22 = v33 == v44;
      ++v25;
    }
    while (v33 != v44 && v25 != v26);
    uint64_t v9 = v31;
  }
  else
  {
    BOOL v22 = 0;
  }
  if (v9 != v46) {
    free(v9);
  }
  return v22;
}

uint64_t llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::getDFSNumIn(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

uint64_t llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::getDFSNumOut(uint64_t a1)
{
  return *(unsigned int *)(a1 + 76);
}

BOOL llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::DominatedBy(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 72) >= *(_DWORD *)(a2 + 72) && *(_DWORD *)(a1 + 76) <= *(_DWORD *)(a2 + 76);
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::DominatorTreeBase(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x100000000;
  if (a1 != a2)
  {
    unsigned int v4 = *(_DWORD *)(a2 + 8);
    if (v4)
    {
      unsigned int v5 = *(const void **)a2;
      if (*(void *)a2 == a2 + 16)
      {
        if (v4 >= 2) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        memcpy((void *)(a1 + 16), v5, 8uLL);
        *(_DWORD *)(a1 + 8) = v4;
      }
      else
      {
        *(void *)a1 = v5;
        int v11 = *(_DWORD *)(a2 + 12);
        *(_DWORD *)(a1 + 8) = v4;
        *(_DWORD *)(a1 + 12) = v11;
        *(void *)a2 = a2 + 16;
        *(_DWORD *)(a2 + 12) = 0;
      }
      *(_DWORD *)(a2 + 8) = 0;
    }
  }
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t v6 = a2 + 24;
  *(void *)(a1 + 24) = v7;
  *(void *)uint64_t v6 = 0;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(v6 + 8);
  *(_DWORD *)(v6 + 8) = 0;
  int v8 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(v6 + 12);
  *(_DWORD *)(v6 + 12) = v8;
  int v9 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(v6 + 16);
  *(_DWORD *)(v6 + 16) = v9;
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(v6 + 24);
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(v6 + 40);
  *(_DWORD *)(a1 + sub_1CC338288((_DWORD *)this + 68) = *(_DWORD *)(v6 + 44);
  sub_1CC0CEEC8((uint64_t *)v6);
  *(void *)(v6 + 24) = 0;
  *(void *)(v6 + 32) = 0;
  return a1;
}

uint64_t *llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::wipe(uint64_t *a1)
{
  double result = sub_1CC0CEEC8(a1 + 3);
  a1[6] = 0;
  a1[7] = 0;
  return result;
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unsigned int v4 = *(const void **)a2;
    if (*(void *)a2 == a2 + 16)
    {
      uint64_t v6 = (_DWORD *)(a2 + 8);
      uint64_t v5 = *(unsigned int *)(a2 + 8);
      uint64_t v7 = *(unsigned int *)(a1 + 8);
      if (v7 >= v5)
      {
        if (v5) {
          memmove(*(void **)a1, v4, 8 * v5);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v5)
        {
          *(_DWORD *)(a1 + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v7)
        {
          uint64_t v12 = *(unsigned int *)(a1 + 8);
          memmove(*(void **)a1, v4, 8 * v7);
          uint64_t v8 = v12;
        }
        else
        {
          uint64_t v8 = 0;
        }
        uint64_t v9 = *v6;
        if (v8 != v9) {
          memcpy((void *)(*(void *)a1 + 8 * v8), (const void *)(*(void *)a2 + 8 * v8), *(void *)a2 + 8 * v9 - (*(void *)a2 + 8 * v8));
        }
      }
      *(_DWORD *)(a1 + 8) = v5;
    }
    else
    {
      int v11 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v11);
        unsigned int v4 = *(const void **)a2;
      }
      *(void *)a1 = v4;
      uint64_t v6 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)a2 = a2 + 16;
      *(_DWORD *)(a2 + 12) = 0;
    }
    _DWORD *v6 = 0;
  }
  sub_1CC33DF3C((uint64_t *)(a1 + 24), (uint64_t *)(a2 + 24));
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
  *(_DWORD *)(a1 + sub_1CC338288((_DWORD *)this + 68) = *(_DWORD *)(a2 + 68);
  sub_1CC0CEEC8((uint64_t *)(a2 + 24));
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return a1;
}

uint64_t *sub_1CC33DF3C(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *((unsigned int *)a1 + 4);
  uint64_t v5 = *a1;
  if (v4)
  {
    uint64_t v6 = 16 * v4;
    uint64_t v7 = (uint64_t *)(v5 + 8);
    do
    {
      if ((*(v7 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        uint64_t v7 = sub_1CB9313C0(v7);
      }
      v7 += 2;
      v6 -= 16;
    }
    while (v6);
    uint64_t v5 = *a1;
  }
  MEMORY[0x1D25D9CD0](v5, 8);
  *a1 = 0;
  a1[1] = 0;
  *((_DWORD *)a1 + 4) = 0;
  *a1 = *a2;
  *a2 = 0;
  *((_DWORD *)a1 + 2) = *((_DWORD *)a2 + 2);
  *((_DWORD *)a2 + 2) = 0;
  int v8 = *((_DWORD *)a1 + 3);
  *((_DWORD *)a1 + 3) = *((_DWORD *)a2 + 3);
  *((_DWORD *)a2 + 3) = v8;
  int v9 = *((_DWORD *)a1 + 4);
  *((_DWORD *)a1 + 4) = *((_DWORD *)a2 + 4);
  *((_DWORD *)a2 + 4) = v9;
  return a1;
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::root_begin(uint64_t a1)
{
  return *(void *)a1;
}

{
  return *(void *)a1;
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::root_end(uint64_t a1)
{
  return *(void *)a1 + 8 * *(unsigned int *)(a1 + 8);
}

{
  return *(void *)a1 + 8 * *(unsigned int *)(a1 + 8);
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::root_size(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::roots(uint64_t a1)
{
  return *(void *)a1;
}

{
  return *(void *)a1;
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::isPostDominator()
{
  return 0;
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::getNode(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    LODWORD(v4) = (v3 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v5 = (uint64_t *)(v2 + 16 * v4);
    uint64_t v6 = *v5;
    if (*v5 == a2) {
      goto LABEL_8;
    }
    int v7 = 1;
    while (v6 != -4096)
    {
      int v8 = v4 + v7++;
      uint64_t v4 = v8 & (v3 - 1);
      uint64_t v6 = *(void *)(v2 + 16 * v4);
      if (v6 == a2)
      {
        uint64_t v5 = (uint64_t *)(v2 + 16 * v4);
        goto LABEL_8;
      }
    }
  }
  uint64_t v5 = (uint64_t *)(v2 + 16 * v3);
LABEL_8:
  if (v5 == (uint64_t *)(v2 + 16 * v3)) {
    return 0;
  }
  else {
    return v5[1];
  }
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::operator[](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    LODWORD(v4) = (v3 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v5 = (uint64_t *)(v2 + 16 * v4);
    uint64_t v6 = *v5;
    if (*v5 == a2) {
      goto LABEL_8;
    }
    int v7 = 1;
    while (v6 != -4096)
    {
      int v8 = v4 + v7++;
      uint64_t v4 = v8 & (v3 - 1);
      uint64_t v6 = *(void *)(v2 + 16 * v4);
      if (v6 == a2)
      {
        uint64_t v5 = (uint64_t *)(v2 + 16 * v4);
        goto LABEL_8;
      }
    }
  }
  uint64_t v5 = (uint64_t *)(v2 + 16 * v3);
LABEL_8:
  if (v5 == (uint64_t *)(v2 + 16 * v3)) {
    return 0;
  }
  else {
    return v5[1];
  }
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::getRootNode(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

{
  return *(void *)(a1 + 48);
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::properlyDominates(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = 0;
  if (a2 != a3)
  {
    if (a2)
    {
      uint64_t v5 = a3;
      if (a3)
      {
        if (*(void *)(a3 + 8) == a2)
        {
          return 1;
        }
        else
        {
          if (*(void *)(a2 + 8) == a3) {
            return 0;
          }
          unsigned int v6 = *(_DWORD *)(a2 + 16);
          if (v6 >= *(_DWORD *)(a3 + 16)) {
            return 0;
          }
          if (*(unsigned char *)(a1 + 64))
          {
            if (*(_DWORD *)(a3 + 72) >= *(_DWORD *)(a2 + 72)) {
              return *(_DWORD *)(a3 + 76) <= *(_DWORD *)(a2 + 76);
            }
            return 0;
          }
          unsigned int v7 = *(_DWORD *)(a1 + 68) + 1;
          *(_DWORD *)(a1 + sub_1CC338288((_DWORD *)this + 68) = v7;
          if (v7 > 0x20) {
            llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::updateDFSNumbers();
          }
          do
          {
            uint64_t v8 = v5;
            uint64_t v5 = *(void *)(v5 + 8);
          }
          while (v5 && *(_DWORD *)(v5 + 16) >= v6);
          return v8 == a2;
        }
      }
    }
  }
  return result;
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v10;
  uint64_t v12;
  void v13[7];

  if (a2 != a3)
  {
    v13[1] = v6;
    long long v13[2] = v5;
    v13[3] = v4;
    v13[4] = v3;
    v13[5] = v7;
    v13[6] = v8;
    uint64_t v10 = (uint64_t *)(a1 + 24);
    uint64_t v12 = 0;
    v13[0] = a2;
    sub_1CBFA3AF4((uint64_t *)(a1 + 24), v13, &v12);
    uint64_t v12 = 0;
    v13[0] = a3;
    sub_1CBFA3AF4(v10, v13, &v12);
    llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::dominates();
  }
  return 0;
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::dominates(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  BOOL v5 = a3 != a2 && a3 != 0;
  if (!v5 || a2 == 0)
  {
    if (v5)
    {
      if (!a2) {
        return 0;
      }
      if (*(void *)(a3 + 8) != a2)
      {
        if (*(void *)(a2 + 8) != a3)
        {
          unsigned int v11 = *(_DWORD *)(a2 + 16);
          if (v11 < *(_DWORD *)(a3 + 16))
          {
            if (*(unsigned char *)(a1 + 64))
            {
LABEL_15:
              if (*(_DWORD *)(a3 + 72) >= *(_DWORD *)(a2 + 72)) {
                return *(_DWORD *)(a3 + 76) <= *(_DWORD *)(a2 + 76);
              }
              return 0;
            }
            unsigned int v12 = *(_DWORD *)(a1 + 68) + 1;
            *(_DWORD *)(a1 + sub_1CC338288((_DWORD *)this + 68) = v12;
            if (v12 <= 0x20)
            {
              do
              {
                uint64_t v10 = v3;
                uint64_t v3 = *(void *)(v3 + 8);
              }
              while (v3 && *(_DWORD *)(v3 + 16) >= v11);
              return v10 == a2;
            }
LABEL_33:
            llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::updateDFSNumbers();
          }
        }
        return 0;
      }
    }
  }
  else if (*(void *)(a3 + 8) != a2)
  {
    if (*(void *)(a2 + 8) != a3)
    {
      unsigned int v7 = *(_DWORD *)(a2 + 16);
      if (v7 < *(_DWORD *)(a3 + 16))
      {
        if (*(unsigned char *)(a1 + 64)) {
          goto LABEL_15;
        }
        unsigned int v9 = *(_DWORD *)(a1 + 68) + 1;
        *(_DWORD *)(a1 + sub_1CC338288((_DWORD *)this + 68) = v9;
        if (v9 <= 0x20)
        {
          do
          {
            uint64_t v10 = v3;
            uint64_t v3 = *(void *)(v3 + 8);
          }
          while (v3 && *(_DWORD *)(v3 + 16) >= v7);
          return v10 == a2;
        }
        goto LABEL_33;
      }
    }
    return 0;
  }
  return 1;
}

BOOL llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::isReachableFromEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    LODWORD(v4) = (v3 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    BOOL v5 = (uint64_t *)(v2 + 16 * v4);
    uint64_t v6 = *v5;
    if (*v5 == a2) {
      return v5 != (uint64_t *)(v2 + 16 * v3) && v5[1] != 0;
    }
    int v7 = 1;
    while (v6 != -4096)
    {
      int v8 = v4 + v7++;
      uint64_t v4 = v8 & (v3 - 1);
      uint64_t v6 = *(void *)(v2 + 16 * v4);
      if (v6 == a2)
      {
        BOOL v5 = (uint64_t *)(v2 + 16 * v4);
        return v5 != (uint64_t *)(v2 + 16 * v3) && v5[1] != 0;
      }
    }
  }
  BOOL v5 = (uint64_t *)(v2 + 16 * v3);
  return v5 != (uint64_t *)(v2 + 16 * v3) && v5[1] != 0;
}

{
  return a2 != 0;
}

void llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::updateDFSNumbers(uint64_t a1)
{
  v18[64] = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 64))
  {
    *(_DWORD *)(a1 + sub_1CC338288((_DWORD *)this + 68) = 0;
  }
  else
  {
    unsigned int v15 = v18;
    unsigned int v17 = 32;
    uint64_t v2 = *(void *)(a1 + 48);
    if (v2)
    {
      uint64_t v3 = *(void *)(v2 + 24);
      v18[0] = *(void *)(a1 + 48);
      v18[1] = v3;
      int v4 = 1;
      int v16 = 1;
      *(_DWORD *)(v2 + 72) = 0;
      unsigned int v5 = 1;
      do
      {
        uint64_t v6 = (char *)v15;
        uint64_t v7 = v5;
        int v8 = (char *)v15 + 16 * v5;
        uint64_t v10 = *((void *)v8 - 2);
        unsigned int v9 = (uint64_t *)*((void *)v8 - 1);
        if (v9 == (uint64_t *)(*(void *)(v10 + 24) + 8 * *(unsigned int *)(v10 + 32)))
        {
          *(_DWORD *)(v10 + 76) = v4;
          unsigned int v5 = v7 - 1;
          int v16 = v7 - 1;
        }
        else
        {
          uint64_t v11 = *v9;
          *((void *)v8 - 1) = v9 + 1;
          uint64_t v12 = *(void *)(v11 + 24);
          if (v7 >= v17) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v13 = &v6[16 * v7];
          *(void *)uint64_t v13 = v11;
          *((void *)v13 + 1) = v12;
          unsigned int v5 = ++v16;
          *(_DWORD *)(v11 + 72) = v4;
        }
        ++v4;
      }
      while (v5);
      unsigned int v14 = v15;
      *(_DWORD *)(a1 + sub_1CC338288((_DWORD *)this + 68) = 0;
      *(unsigned char *)(a1 + 64) = 1;
      if (v14 != v18) {
        free(v14);
      }
    }
  }
}

BOOL llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::dominatedBySlowTreeWalk(uint64_t a1, uint64_t a2, uint64_t a3)
{
  do
  {
    uint64_t v3 = a3;
    a3 = *(void *)(a3 + 8);
  }
  while (a3 && *(_DWORD *)(a3 + 16) >= *(_DWORD *)(a2 + 16));
  return v3 == a2;
}

BOOL llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::dominates(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == a3) {
    return 1;
  }
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = *(unsigned int *)(a1 + 40);
  if (!v4) {
    goto LABEL_32;
  }
  LODWORD(v5) = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v6 = (uint64_t *)(v3 + 16 * v5);
  uint64_t v7 = *v6;
  if (*v6 != a2)
  {
    int v18 = 1;
    while (v7 != -4096)
    {
      int v19 = v5 + v18++;
      uint64_t v5 = v19 & (v4 - 1);
      uint64_t v7 = *(void *)(v3 + 16 * v5);
      if (v7 == a2)
      {
        uint64_t v6 = (uint64_t *)(v3 + 16 * v5);
        goto LABEL_4;
      }
    }
LABEL_32:
    uint64_t v6 = (uint64_t *)(v3 + 16 * v4);
  }
LABEL_4:
  int v8 = (uint64_t *)(v3 + 16 * v4);
  if (v6 == v8) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = v6[1];
  }
  if (!v4) {
    return 1;
  }
  unsigned int v10 = v4 - 1;
  LODWORD(v4) = (v4 - 1) & ((a3 >> 4) ^ (a3 >> 9));
  uint64_t v11 = (uint64_t *)(v3 + 16 * v4);
  uint64_t v12 = *v11;
  if (*v11 != a3)
  {
    int v20 = 1;
    do
    {
      if (v12 == -4096) {
        return 1;
      }
      int v21 = v4 + v20++;
      uint64_t v4 = v21 & v10;
      uint64_t v12 = *(void *)(v3 + 16 * v4);
    }
    while (v12 != a3);
    uint64_t v11 = (uint64_t *)(v3 + 16 * v4);
  }
  if (v11 == v8) {
    return 1;
  }
  uint64_t v13 = v11[1];
  BOOL v14 = v13 == v9 || v13 == 0;
  char v15 = !v14;
  if (!v14 && v9)
  {
    if (*(void *)(v13 + 8) != v9)
    {
      if (*(void *)(v9 + 8) != v13)
      {
        unsigned int v16 = *(_DWORD *)(v9 + 16);
        if (v16 < *(_DWORD *)(v13 + 16))
        {
          if (*(unsigned char *)(a1 + 64)) {
            goto LABEL_21;
          }
          unsigned int v22 = *(_DWORD *)(a1 + 68) + 1;
          *(_DWORD *)(a1 + sub_1CC338288((_DWORD *)this + 68) = v22;
          if (v22 <= 0x20)
          {
            do
            {
              uint64_t v23 = v13;
              uint64_t v13 = *(void *)(v13 + 8);
            }
            while (v13 && *(_DWORD *)(v13 + 16) >= v16);
            return v23 == v9;
          }
          goto LABEL_50;
        }
      }
      return 0;
    }
    return 1;
  }
  if ((v15 & 1) == 0) {
    return 1;
  }
  if (!v9) {
    return 0;
  }
  if (*(void *)(v13 + 8) == v9) {
    return 1;
  }
  if (*(void *)(v9 + 8) != v13)
  {
    unsigned int v24 = *(_DWORD *)(v9 + 16);
    if (v24 < *(_DWORD *)(v13 + 16))
    {
      if (*(unsigned char *)(a1 + 64))
      {
LABEL_21:
        if (*(_DWORD *)(v13 + 72) >= *(_DWORD *)(v9 + 72)) {
          return *(_DWORD *)(v13 + 76) <= *(_DWORD *)(v9 + 76);
        }
        return 0;
      }
      unsigned int v25 = *(_DWORD *)(a1 + 68) + 1;
      *(_DWORD *)(a1 + sub_1CC338288((_DWORD *)this + 68) = v25;
      if (v25 <= 0x20)
      {
        do
        {
          uint64_t v23 = v13;
          uint64_t v13 = *(void *)(v13 + 8);
        }
        while (v13 && *(_DWORD *)(v13 + 16) >= v24);
        return v23 == v9;
      }
LABEL_50:
      llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::updateDFSNumbers();
    }
  }
  return 0;
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::getRoot(uint64_t a1)
{
  return **(void **)a1;
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::findNearestCommonDominator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a2 + 32) + 328);
  if (v3 == a2 || v3 == a3) {
    return v3;
  }
  uint64_t v6 = *(void *)(a1 + 24);
  uint64_t v7 = *(unsigned int *)(a1 + 40);
  if (!v7) {
    goto LABEL_33;
  }
  LODWORD(v8) = (v7 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v9 = (uint64_t *)(v6 + 16 * v8);
  uint64_t v10 = *v9;
  if (*v9 != a2)
  {
    int v21 = 1;
    while (v10 != -4096)
    {
      int v22 = v8 + v21++;
      uint64_t v8 = v22 & (v7 - 1);
      uint64_t v10 = *(void *)(v6 + 16 * v8);
      if (v10 == a2)
      {
        uint64_t v9 = (uint64_t *)(v6 + 16 * v8);
        goto LABEL_9;
      }
    }
LABEL_33:
    uint64_t v9 = (uint64_t *)(v6 + 16 * v7);
  }
LABEL_9:
  uint64_t v11 = (uint64_t *)(v6 + 16 * v7);
  if (v9 == v11) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = (_DWORD *)v9[1];
  }
  if (!v7) {
    goto LABEL_32;
  }
  unsigned int v13 = v7 - 1;
  LODWORD(v7) = (v7 - 1) & ((a3 >> 4) ^ (a3 >> 9));
  BOOL v14 = (uint64_t *)(v6 + 16 * v7);
  uint64_t v15 = *v14;
  if (*v14 != a3)
  {
    int v23 = 1;
    while (v15 != -4096)
    {
      int v24 = v7 + v23++;
      uint64_t v7 = v24 & v13;
      uint64_t v15 = *(void *)(v6 + 16 * v7);
      if (v15 == a3)
      {
        BOOL v14 = (uint64_t *)(v6 + 16 * v7);
        goto LABEL_13;
      }
    }
    goto LABEL_32;
  }
LABEL_13:
  if (v14 == v11)
  {
LABEL_32:
    unsigned int v16 = 0;
    goto LABEL_15;
  }
  unsigned int v16 = (_DWORD *)v14[1];
LABEL_15:
  if (v12 == v16)
  {
    unsigned int v16 = v12;
  }
  else
  {
    do
    {
      unsigned int v17 = v12[4];
      unsigned int v18 = v16[4];
      BOOL v19 = v17 >= v18;
      if (v17 >= v18) {
        int v20 = v12;
      }
      else {
        int v20 = v16;
      }
      if (!v19) {
        unsigned int v16 = v12;
      }
      uint64_t v12 = (_DWORD *)*((void *)v20 + 1);
    }
    while (v12 != v16);
  }
  return *(void *)v16;
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::isVirtualRoot()
{
  return 0;
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::applyUpdates(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  v8[8] = *MEMORY[0x1E4F143B8];
  sub_1CC33FCD4((uint64_t)v5, a2, a3, 1u);
  sub_1CC34281C(a1, (uint64_t)v5, 0);
  if (v7 != v8) {
    free(v7);
  }
  sub_1CC33FBB0((uint64_t)&v6);
  return sub_1CC33FBB0((uint64_t)v5);
}

void llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::applyUpdates(uint64_t a1, unsigned char *a2, uint64_t a3, long long *a4, uint64_t a5)
{
  v18[8] = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    uint64_t v12 = v14;
    uint64_t v13 = 0x300000000;
    sub_1CD3D61B4((unsigned int *)&v12, a2, &a2[16 * a3]);
    sub_1CC346054((unsigned int *)&v12, (uint64_t)v12 + 16 * v13, a4, &a4[a5]);
    sub_1CC33FCD4((uint64_t)v15, (unint64_t *)v12, v13, 1u);
    sub_1CC33FCD4((uint64_t)v8, (unint64_t *)a4, a5, 0);
    sub_1CC34281C(a1, (uint64_t)v15, (uint64_t)v8);
    if (v10 != &v11) {
      free(v10);
    }
    sub_1CC33FBB0((uint64_t)&v9);
    sub_1CC33FBB0((uint64_t)v8);
    if (v17 != v18) {
      free(v17);
    }
    sub_1CC33FBB0((uint64_t)v16);
    sub_1CC33FBB0((uint64_t)v15);
    if (v12 != v14) {
      free(v12);
    }
  }
  else
  {
    sub_1CC33FCD4((uint64_t)v15, (unint64_t *)a4, a5, 0);
    sub_1CC34281C(a1, (uint64_t)v15, (uint64_t)v15);
    if (v17 != v18) {
      free(v17);
    }
    sub_1CC33FBB0((uint64_t)v16);
    sub_1CC33FBB0((uint64_t)v15);
  }
}

void llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::insertEdge(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::deleteEdge(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1CC343350(a1, 0, a2, a3);
}

void llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::createChild(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  operator new();
}

void llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::setNewRoot(uint64_t a1)
{
  *(unsigned char *)(a1 + 64) = 0;
  llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::createNode();
}

void llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::createNode(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  operator new();
}

void llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::changeImmediateDominator(uint64_t a1)
{
  *(unsigned char *)(a1 + 64) = 0;
  llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::setIDom();
}

void llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::changeImmediateDominator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = *(unsigned int *)(a1 + 40);
  if (v4)
  {
    LODWORD(v5) = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v6 = (uint64_t *)(v3 + 16 * v5);
    uint64_t v7 = *v6;
    if (*v6 != a2)
    {
      int v8 = 1;
      do
      {
        if (v7 == -4096) {
          goto LABEL_7;
        }
        int v9 = v5 + v8++;
        uint64_t v5 = v9 & (v4 - 1);
        uint64_t v7 = *(void *)(v3 + 16 * v5);
      }
      while (v7 != a2);
      uint64_t v6 = (uint64_t *)(v3 + 16 * v5);
    }
  }
  else
  {
LABEL_7:
    uint64_t v6 = (uint64_t *)(v3 + 16 * v4);
  }
  if (v6 == (uint64_t *)(v3 + 16 * v4))
  {
    if (!v4) {
      goto LABEL_16;
    }
  }
  else if (!v4)
  {
    goto LABEL_16;
  }
  int v10 = v4 - 1;
  unsigned int v11 = (v4 - 1) & ((a3 >> 4) ^ (a3 >> 9));
  uint64_t v12 = *(void *)(v3 + 16 * v11);
  if (v12 != a3)
  {
    int v13 = 1;
    do
    {
      if (v12 == -4096) {
        break;
      }
      unsigned int v14 = v11 + v13++;
      unsigned int v11 = v14 & v10;
      uint64_t v12 = *(void *)(v3 + 16 * v11);
    }
    while (v12 != a3);
  }
LABEL_16:
  *(unsigned char *)(a1 + 64) = 0;
  llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::setIDom();
}

void llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::splitBlock(uint64_t a1, uint64_t a2)
{
  v11[4] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = **(void **)(a2 + 88);
  uint64_t v3 = *(char **)(a2 + 64);
  uint64_t v4 = *(char **)(a2 + 72);
  unint64_t v5 = v4 - v3;
  if ((unint64_t)(v4 - v3) >= 0x21) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v3 != v4)
  {
    uint64_t v6 = v11;
    do
    {
      uint64_t v7 = *(void *)v3;
      v3 += 8;
      *v6++ = v7;
    }
    while (v3 != v4);
  }
  int v8 = v5 >> 3;
  int v9 = *(void **)(v2 + 64);
  int v10 = *(void **)(v2 + 72);
  if (v9 == v10)
  {
    if (v8) {
      goto LABEL_13;
    }
  }
  else
  {
    do
    {
      if (*v9 != a2) {
        llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::dominates();
      }
      ++v9;
    }
    while (v9 != v10);
    if (v8) {
LABEL_13:
    }
      llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::isReachableFromEntry();
  }
}

void llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::recalculate(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 56) = a2;
  sub_1CC2DC400(a1, 0);
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::recalculate(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  v14[8] = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 56) = a2;
  sub_1CC33FCD4((uint64_t)v10, a3, a4, 1u);
  v6[0] = 0;
  uint64_t v7 = v10;
  uint64_t v8 = 0;
  uint64_t v9 = v13;
  sub_1CC2DC400(a1, (uint64_t)v6);
  if (v12 != v14) {
    free(v12);
  }
  sub_1CC33FBB0((uint64_t)&v11);
  return sub_1CC33FBB0((uint64_t)v10);
}

uint64_t *llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::reset(uint64_t a1)
{
  uint64_t result = sub_1CC0CEEC8((uint64_t *)(a1 + 24));
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + sub_1CC338288((_DWORD *)this + 68) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(unsigned char *)(a1 + 64) = 0;
  return result;
}

void llvm::initializeMachineDominatorTreePass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCE8A0, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CC33F5E8;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCCE8A0, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC33F5E8()
{
}

void llvm::MachineDominatorTree::runOnMachineFunction(llvm::MachineDominatorTree *this, llvm::MachineFunction *a2)
{
  *((_DWORD *)this + 64) = 0;
  uint64_t v3 = (void *)*((void *)this + 130);
  if (v3 != *((void **)this + 129))
  {
    uint64_t v4 = *((unsigned int *)this + 262);
    if (v4 >= 0x21 && 4 * (*((_DWORD *)this + 263) - *((_DWORD *)this + 264)) < v4)
    {
      llvm::SmallPtrSetImplBase::shrink_and_clear((void **)this + 129);
LABEL_3:
      operator new();
    }
    memset(v3, 255, 8 * v4);
  }
  *(void *)((char *)this + 1052) = 0;
  goto LABEL_3;
}

void llvm::MachineDominatorTree::calculate(llvm::MachineDominatorTree *this, llvm::MachineFunction *a2)
{
  *((_DWORD *)this + 64) = 0;
  uint64_t v3 = (void *)*((void *)this + 130);
  if (v3 != *((void **)this + 129))
  {
    uint64_t v4 = *((unsigned int *)this + 262);
    if (v4 >= 0x21 && 4 * (*((_DWORD *)this + 263) - *((_DWORD *)this + 264)) < v4)
    {
      llvm::SmallPtrSetImplBase::shrink_and_clear((void **)this + 129);
LABEL_3:
      operator new();
    }
    memset(v3, 255, 8 * v4);
  }
  *(void *)((char *)this + 1052) = 0;
  goto LABEL_3;
}

void llvm::MachineDominatorTree::releaseMemory(llvm::MachineDominatorTree *this)
{
  *((_DWORD *)this + 64) = 0;
  uint64_t v1 = *((void *)this + 165);
  *((void *)this + 165) = 0;
  if (v1) {
    sub_1CBF8FF20((uint64_t)this + 1320, v1);
  }
}

void ***llvm::MachineDominatorTree::applySplitCriticalEdges(void ***this)
{
  unsigned int v1 = *((_DWORD *)this + 64);
  if (v1)
  {
    uint64_t v2 = (uint64_t)this;
    sub_1CBFDFD98((unint64_t *)&v16, v1, 1);
    uint64_t v3 = v2;
    unsigned int v4 = *(_DWORD *)(v2 + 256);
    if (v4)
    {
      uint64_t v5 = 0;
      uint64_t v6 = *(void *)(v2 + 248);
      uint64_t v15 = v6 + 24 * v4;
      do
      {
        uint64_t v7 = *(void *)(v6 + 8);
        uint64_t v8 = *(void *)(v3 + 1320);
        uint64_t v17 = 0;
        uint64_t v18 = v7;
        sub_1CBFA3AF4((uint64_t *)(v8 + 24), &v18, &v17);
        for (uint64_t i = *(uint64_t **)(v7 + 64); i != *(uint64_t **)(v7 + 72); ++i)
        {
          uint64_t v10 = *i;
          if (*i != *(void *)(v6 + 16))
          {
            uint64_t v11 = sub_1CB896AE8(v3 + 1032, *i);
            uint64_t v12 = *(void *)(v3 + 1040);
            uint64_t v13 = 1048;
            if (v12 == *(void *)(v3 + 1032)) {
              uint64_t v13 = 1052;
            }
            if (v11 != (void *)(v12 + 8 * *(unsigned int *)(v3 + v13))) {
              uint64_t v10 = **(void **)(v10 + 64);
            }
            uint64_t v14 = *(void *)(v3 + 1320);
            uint64_t v17 = 0;
            uint64_t v18 = v10;
            sub_1CBFA3AF4((uint64_t *)(v14 + 24), &v18, &v17);
            llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::dominates();
          }
        }
        ++v5;
        v6 += 24;
      }
      while (v6 != v15);
      if (*(_DWORD *)(v3 + 256)) {
        llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::addNewBlock();
      }
    }
    sub_1CBFF3560((llvm::SmallPtrSetImplBase *)(v3 + 1032));
    *(_DWORD *)(v3 + 256) = 0;
    return sub_1CB9F9ED4(&v16);
  }
  return this;
}

uint64_t sub_1CC33FBB0(uint64_t a1)
{
  if ((*(unsigned char *)a1 & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
  }
  return a1;
}

uint64_t sub_1CC33FBEC(char *a1, char *a2, void *a3)
{
  if (a1 == a2) {
    return 1;
  }
  uint64_t v3 = a2 - a1;
  while (*(void *)a1 == *a3)
  {
    a1 += 8;
    ++a3;
    v3 -= 8;
    if (a1 == a2) {
      return 1;
    }
  }
  if (v3 != 8)
  {
    if (a1 != a2)
    {
      uint64_t v5 = 0;
      uint64_t v6 = 8 * (v3 >> 3);
      uint64_t v7 = a1;
      while (1)
      {
        uint64_t v8 = *(void *)v7;
        if (a1 == v7)
        {
LABEL_14:
          unint64_t v10 = 0;
          uint64_t v11 = 0;
          do
          {
            if (v8 == a3[v10 / 8]) {
              ++v11;
            }
            v10 += 8;
          }
          while (v6 != v10);
          if (!v11) {
            return 0;
          }
          uint64_t v12 = v7 + 8;
          uint64_t v13 = 1;
          while (v12 != a2)
          {
            uint64_t v14 = *(void *)v12;
            v12 += 8;
            if (v8 == v14) {
              ++v13;
            }
          }
          if (v13 != v11) {
            return 0;
          }
        }
        else
        {
          uint64_t v9 = 0;
          while (*(void *)&a1[v9] != v8)
          {
            v9 += 8;
            if (v5 == v9) {
              goto LABEL_14;
            }
          }
        }
        v7 += 8;
        v5 += 8;
        if (v7 == a2) {
          return 1;
        }
      }
    }
    return 1;
  }
  return 0;
}

uint64_t sub_1CC33FCD4(uint64_t a1, unint64_t *a2, uint64_t a3, unsigned int a4)
{
  *(void *)a1 = 1;
  uint64_t v6 = (_DWORD *)(a1 + 296);
  for (uint64_t i = 8; i != 296; i += 72)
    *(void *)(a1 + i) = -4096;
  *(void *)(a1 + 296) = 1;
  for (uint64_t j = 304; j != 592; j += 72)
    *(void *)(a1 + j) = -4096;
  *(void *)(a1 + 600) = a1 + 616;
  *(void *)(a1 + 608) = 0x400000000;
  sub_1CC33FE78(a2, a3, a1 + 600, 0, 0);
  uint64_t v9 = *(unsigned int *)(a1 + 608);
  if (v9)
  {
    unint64_t v10 = *(unint64_t **)(a1 + 600);
    uint64_t v11 = &v10[2 * v9];
    do
    {
      unint64_t v12 = *v10;
      unint64_t v13 = v10[1];
      uint64_t v14 = ((v13 & 4) == 0) ^ a4;
      unint64_t v22 = *v10;
      sub_1CC3421B8((_DWORD *)a1, (uint64_t *)&v22);
      uint64_t v16 = v15 + 32 * v14;
      unint64_t v17 = *(unsigned int *)(v16 + 16);
      if (v17 >= *(unsigned int *)(v16 + 20)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v16 + 8) + 8 * v17) = v13 & 0xFFFFFFFFFFFFFFF8;
      ++*(_DWORD *)(v16 + 16);
      unint64_t v22 = v13 & 0xFFFFFFFFFFFFFFF8;
      sub_1CC3421B8(v6, (uint64_t *)&v22);
      uint64_t v19 = v18 + 32 * v14;
      unint64_t v20 = *(unsigned int *)(v19 + 16);
      if (v20 >= *(unsigned int *)(v19 + 20)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v19 + 8) + 8 * v20) = v12;
      ++*(_DWORD *)(v19 + 16);
      v10 += 2;
    }
    while (v10 != v11);
  }
  *(unsigned char *)(a1 + 592) = a4;
  return a1;
}

void sub_1CC33FE78(unint64_t *a1, uint64_t a2, uint64_t a3, int a4, char a5)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  char v45 = a5;
  uint64_t v48 = 1;
  uint64_t v9 = (uint64_t *)&v49;
  unint64_t v10 = &v51;
  uint64_t v11 = 8;
  int64x2_t v12 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  do
  {
    *(int64x2_t *)((char *)&v48 + v11) = v12;
    v11 += 24;
  }
  while (v11 != 104);
  sub_1CC3401C0((uint64_t)&v48, a2);
  if (a2)
  {
    unint64_t v13 = a1;
    do
    {
      unint64_t v14 = *v13;
      unint64_t v15 = v13[1];
      v13 += 2;
      if (a4) {
        unint64_t v16 = v14;
      }
      else {
        unint64_t v16 = v15 & 0xFFFFFFFFFFFFFFF8;
      }
      if (a4) {
        unint64_t v14 = v15 & 0xFFFFFFFFFFFFFFF8;
      }
      uint64_t v46 = (uint64_t *)v14;
      int v47 = (char *)v16;
      unint64_t v17 = sub_1CC3405D0(&v48, (uint64_t *)&v46);
      int v18 = *((_DWORD *)v17 + 4);
      if ((v15 & 4) != 0) {
        int v19 = v18 - 1;
      }
      else {
        int v19 = v18 + 1;
      }
      *((_DWORD *)v17 + 4) = v19;
    }
    while (v13 != &a1[2 * a2]);
  }
  *(_DWORD *)(a3 + 8) = 0;
  int v20 = v48;
  if (*(_DWORD *)(a3 + 12) < v48 >> 1) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v48 > 1)
  {
    if ((v48 & 1) == 0)
    {
      uint64_t v9 = v49;
      unsigned int v21 = v50;
      if (!v50)
      {
        int v20 = 0;
        int v24 = v49;
        unint64_t v10 = v49;
        goto LABEL_35;
      }
      unint64_t v10 = &v49[3 * v50];
    }
    int v20 = v48 & 1;
    int v24 = v9;
    while (1)
    {
      uint64_t v25 = v24[1];
      if ((*v24 != -4096 || v25 != -4096) && (*v24 != -8192 || v25 != -8192)) {
        break;
      }
      v24 += 3;
      if (v24 == v10)
      {
        int v24 = v10;
        break;
      }
    }
    uint64_t v9 = v49;
    unsigned int v21 = v50;
  }
  else
  {
    uint64_t v9 = v49;
    unsigned int v21 = v50;
    if (v48) {
      unint64_t v22 = &v49;
    }
    else {
      unint64_t v22 = v49;
    }
    if (v48) {
      unsigned int v23 = 4;
    }
    else {
      unsigned int v23 = v50;
    }
    int v24 = &v22[3 * v23];
    unint64_t v10 = v24;
  }
LABEL_35:
  BOOL v26 = v20 == 0;
  if (v20) {
    int v27 = (uint64_t *)&v49;
  }
  else {
    int v27 = v9;
  }
  if (!v26) {
    unsigned int v21 = 4;
  }
  int v28 = &v27[3 * v21];
  while (v24 != v28)
  {
    int v29 = *((_DWORD *)v24 + 4);
    if (v29)
    {
      BOOL v30 = v29 < 1;
      uint64_t v31 = v24[1];
      unint64_t v32 = *(unsigned int *)(a3 + 8);
      if (v32 >= *(unsigned int *)(a3 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      unint64_t v33 = (uint64_t *)(*(void *)a3 + 16 * v32);
      *unint64_t v33 = *v24;
      v33[1] = v31 & 0xFFFFFFFFFFFFFFFBLL | (4 * v30);
      ++*(_DWORD *)(a3 + 8);
    }
    uint64_t v34 = v24 + 3;
    int v24 = v10;
    if (v34 != v10)
    {
      int v24 = v34;
      while (1)
      {
        uint64_t v35 = v24[1];
        if ((*v24 != -4096 || v35 != -4096) && (*v24 != -8192 || v35 != -8192)) {
          break;
        }
        v24 += 3;
        if (v24 == v10)
        {
          int v24 = v10;
          break;
        }
      }
    }
  }
  if (a2)
  {
    uint64_t v36 = 0;
    uint64_t v37 = a1 + 1;
    do
    {
      if (a4)
      {
        unint64_t v38 = *(v37 - 1);
        unint64_t v39 = *v37 & 0xFFFFFFFFFFFFFFF8;
      }
      else
      {
        unint64_t v39 = *(v37 - 1);
        unint64_t v38 = *v37 & 0xFFFFFFFFFFFFFFF8;
      }
      uint64_t v46 = (uint64_t *)v39;
      int v47 = (char *)v38;
      *((_DWORD *)sub_1CC3405D0(&v48, (uint64_t *)&v46) + 4) = v36++;
      v37 += 2;
    }
    while (a2 != v36);
  }
  BOOL v40 = *(uint64_t **)a3;
  unint64_t v41 = *(unsigned int *)(a3 + 8);
  uint64_t v42 = (uint64_t *)(*(void *)a3 + 16 * v41);
  uint64_t v46 = &v48;
  int v47 = &v45;
  unint64_t v43 = 126 - 2 * __clz(v41);
  if (v41) {
    uint64_t v44 = v43;
  }
  else {
    uint64_t v44 = 0;
  }
  sub_1CC340708(v40, v42, (uint64_t)&v46, v44, 1);
  if ((v48 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v49, 8);
  }
}

uint64_t sub_1CC3401C0(uint64_t result, unsigned int a2)
{
  if (a2)
  {
    unint64_t v2 = (4 * a2 / 3 + 1) | ((unint64_t)(4 * a2 / 3 + 1) >> 1);
    unint64_t v3 = v2 | (v2 >> 2) | ((v2 | (v2 >> 2)) >> 4);
    a2 = (((v3 | (v3 >> 8)) >> 16) | v3 | (v3 >> 8)) + 1;
  }
  if (*(unsigned char *)result) {
    unsigned int v4 = 4;
  }
  else {
    unsigned int v4 = *(_DWORD *)(result + 16);
  }
  if (a2 > v4) {
    return sub_1CC34021C(result, a2);
  }
  return result;
}

uint64_t sub_1CC34021C(uint64_t a1, unsigned int a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    unsigned int v7 = *(_DWORD *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v14 = a2;
      *(void *)(a1 + 8) = operator new(24 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v14;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CC3403DC(a1, v6, v6 + 24 * v7);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = 0;
  uint64_t v9 = v15;
  do
  {
    uint64_t v11 = *(void *)(a1 + v8 + 8);
    uint64_t v10 = *(void *)(a1 + v8 + 16);
    if ((v11 != -4096 || v10 != -4096) && (v11 != -8192 || v10 != -8192))
    {
      *(_OWORD *)uint64_t v9 = *(_OWORD *)(a1 + v8 + 8);
      *((_DWORD *)v9 + 4) = *(_DWORD *)(a1 + v8 + 24);
      v9 += 24;
    }
    v8 += 24;
  }
  while (v8 != 96);
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v12 = a2;
    *(void *)(a1 + 8) = operator new(24 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v12;
  }
  return sub_1CC3403DC(a1, (uint64_t)v15, (uint64_t)v9);
}

uint64_t sub_1CC3403DC(uint64_t result, uint64_t a2, uint64_t a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (int64x2_t *)(result + 8);
    uint64_t v9 = (int64x2_t *)(result + 104);
  }
  else
  {
    unsigned int v7 = *(_DWORD *)(result + 16);
    if (!v7) {
      goto LABEL_14;
    }
    uint64_t v8 = *(int64x2_t **)(result + 8);
    uint64_t v9 = (int64x2_t *)((char *)v8 + 24 * v7);
  }
  int64x2_t v10 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  do
  {
    *uint64_t v8 = v10;
    uint64_t v8 = (int64x2_t *)((char *)v8 + 24);
  }
  while (v8 != v9);
LABEL_14:
  while (a2 != a3)
  {
    uint64_t v11 = *(void *)(a2 + 8);
    if ((*(void *)a2 != -4096 || v11 != -4096) && (*(void *)a2 != -8192 || v11 != -8192))
    {
      unint64_t v13 = 0;
      uint64_t result = sub_1CC3404C8((uint64_t)v5, (uint64_t *)a2, &v13);
      uint64_t v12 = v13;
      *unint64_t v13 = *(void *)a2;
      v12[1] = *(void *)(a2 + 8);
      *((_DWORD *)v12 + 4) = *(_DWORD *)(a2 + 16);
      *v5 += 2;
    }
    a2 += 24;
  }
  return result;
}

uint64_t sub_1CC3404C8(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      unint64_t v13 = 0;
      uint64_t result = 0;
      goto LABEL_11;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  unint64_t v7 = ((v6 >> 4) ^ (v6 >> 9) | ((unint64_t)((*a2 >> 4) ^ (*a2 >> 9)) << 32))
     + ~((unint64_t)((v6 >> 4) ^ (v6 >> 9)) << 32);
  unint64_t v8 = (v7 ^ (v7 >> 22)) + ~((v7 ^ (v7 >> 22)) << 13);
  unint64_t v9 = (9 * (v8 ^ (v8 >> 8))) ^ ((9 * (v8 ^ (v8 >> 8))) >> 15);
  int v10 = ((v9 + ~(v9 << 27)) >> 31) ^ (v9 + ~(v9 << 27));
  int v11 = v4 - 1;
  unsigned int v12 = (v4 - 1) & v10;
  unint64_t v13 = (void *)(v3 + 24 * v12);
  uint64_t v15 = *v13;
  uint64_t v14 = v13[1];
  if (v5 == *v13 && v6 == v14)
  {
    uint64_t result = 1;
  }
  else
  {
    unint64_t v17 = 0;
    int v18 = 1;
    uint64_t result = 1;
    while (v15 != -4096 || v14 != -4096)
    {
      if (v17) {
        BOOL v20 = 0;
      }
      else {
        BOOL v20 = v14 == -8192;
      }
      if (v20 && v15 == -8192) {
        unint64_t v17 = v13;
      }
      unsigned int v22 = v12 + v18++;
      unsigned int v12 = v22 & v11;
      unint64_t v13 = (void *)(v3 + 24 * (v22 & v11));
      uint64_t v15 = *v13;
      uint64_t v14 = v13[1];
      if (v5 == *v13 && v6 == v14) {
        goto LABEL_11;
      }
    }
    uint64_t result = 0;
    if (v17) {
      unint64_t v13 = v17;
    }
  }
LABEL_11:
  *a3 = v13;
  return result;
}

void *sub_1CC3405D0(_DWORD *a1, uint64_t *a2)
{
  unint64_t v7 = 0;
  char v4 = sub_1CC3404C8((uint64_t)a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CC34063C(a1, (uint64_t)a2, a2, v7);
    *uint64_t v5 = *a2;
    v5[1] = a2[1];
    *((_DWORD *)v5 + 4) = 0;
  }
  return v5;
}

void *sub_1CC34063C(_DWORD *a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *a1 >> 1;
  if (*a1) {
    unsigned int v7 = 4;
  }
  else {
    unsigned int v7 = a1[4];
  }
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_11;
  }
  if (v7 + ~v6 - a1[1] <= v7 >> 3)
  {
LABEL_11:
    sub_1CC34021C((uint64_t)a1, v7);
    unint64_t v9 = 0;
    sub_1CC3404C8((uint64_t)a1, a3, &v9);
    a4 = v9;
  }
  *a1 += 2;
  if (*a4 != -4096 || a4[1] != -4096) {
    --a1[1];
  }
  return a4;
}

void sub_1CC340708(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
uint64_t *sub_1CC340A80(uint64_t *result, uint64_t *a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v40 = v3;
    uint64_t v41 = v4;
    char v5 = a2;
    char v6 = result;
    unsigned int v7 = result + 2;
    if (result + 2 != a2)
    {
      uint64_t v9 = 0;
      int v10 = result;
      do
      {
        int v11 = v7;
        uint64_t v12 = *(_DWORD **)a3;
        unint64_t v13 = v10[3] & 0xFFFFFFFFFFFFFFF8;
        uint64_t v38 = v10[2];
        unint64_t v39 = v13;
        uint64_t v14 = sub_1CC3405D0(v12, &v38);
        unint64_t v15 = *(_DWORD **)a3;
        unint64_t v16 = v10[1] & 0xFFFFFFFFFFFFFFF8;
        uint64_t v38 = *v10;
        unint64_t v39 = v16;
        uint64_t result = sub_1CC3405D0(v15, &v38);
        int v17 = *((_DWORD *)v14 + 4);
        int v18 = *((_DWORD *)result + 4);
        BOOL v19 = v17 <= v18;
        BOOL v20 = v17 < v18;
        int v21 = !v19;
        if (**(unsigned char **)(a3 + 8)) {
          int v22 = v20;
        }
        else {
          int v22 = v21;
        }
        if (v22 == 1)
        {
          uint64_t v23 = *v11;
          uint64_t v24 = v10[3];
          uint64_t v25 = v9;
          while (1)
          {
            BOOL v26 = (char *)v6 + v25;
            *(_OWORD *)((char *)v6 + v25 + 16) = *(_OWORD *)((char *)v6 + v25);
            if (!v25) {
              break;
            }
            BOOL v27 = *(_DWORD **)a3;
            uint64_t v38 = v23;
            unint64_t v39 = v24 & 0xFFFFFFFFFFFFFFF8;
            char v28 = sub_1CC3405D0(v27, &v38);
            char v29 = *(_DWORD **)a3;
            unint64_t v30 = *((void *)v26 - 1) & 0xFFFFFFFFFFFFFFF8;
            uint64_t v38 = *((void *)v26 - 2);
            unint64_t v39 = v30;
            uint64_t result = sub_1CC3405D0(v29, &v38);
            int v31 = *((_DWORD *)v28 + 4);
            int v32 = *((_DWORD *)result + 4);
            BOOL v19 = v31 <= v32;
            BOOL v33 = v31 < v32;
            char v34 = !v19;
            if (**(unsigned char **)(a3 + 8)) {
              char v35 = v33;
            }
            else {
              char v35 = v34;
            }
            v25 -= 16;
            if ((v35 & 1) == 0)
            {
              uint64_t v36 = (uint64_t *)((char *)v6 + v25 + 16);
              goto LABEL_22;
            }
          }
          uint64_t v36 = v6;
LABEL_22:
          *uint64_t v36 = v23;
          v36[1] = v24;
          char v5 = a2;
        }
        unsigned int v7 = v11 + 2;
        v9 += 16;
        int v10 = v11;
      }
      while (v11 + 2 != v5);
    }
  }
  return result;
}

uint64_t *sub_1CC340BFC(uint64_t *result, uint64_t *a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v36 = v3;
    uint64_t v37 = v4;
    char v6 = result;
    unsigned int v7 = result + 2;
    if (result + 2 != a2)
    {
      do
      {
        uint64_t v9 = v7;
        int v10 = *(_DWORD **)a3;
        unint64_t v11 = v6[3] & 0xFFFFFFFFFFFFFFF8;
        uint64_t v34 = v6[2];
        unint64_t v35 = v11;
        uint64_t v12 = sub_1CC3405D0(v10, &v34);
        unint64_t v13 = *(_DWORD **)a3;
        unint64_t v14 = v6[1] & 0xFFFFFFFFFFFFFFF8;
        uint64_t v34 = *v6;
        unint64_t v35 = v14;
        uint64_t result = sub_1CC3405D0(v13, &v34);
        int v15 = *((_DWORD *)v12 + 4);
        int v16 = *((_DWORD *)result + 4);
        BOOL v17 = v15 <= v16;
        BOOL v18 = v15 < v16;
        int v19 = !v17;
        if (**(unsigned char **)(a3 + 8)) {
          int v20 = v18;
        }
        else {
          int v20 = v19;
        }
        if (v20 == 1)
        {
          uint64_t v21 = *v9;
          uint64_t v22 = v6[3];
          uint64_t v23 = v9;
          do
          {
            *(_OWORD *)uint64_t v23 = *((_OWORD *)v23 - 1);
            uint64_t v25 = *(_DWORD **)a3;
            uint64_t v34 = v21;
            unint64_t v35 = v22 & 0xFFFFFFFFFFFFFFF8;
            BOOL v26 = sub_1CC3405D0(v25, &v34);
            BOOL v27 = *(_DWORD **)a3;
            unint64_t v28 = *(v23 - 3) & 0xFFFFFFFFFFFFFFF8;
            uint64_t v34 = *(v23 - 4);
            unint64_t v35 = v28;
            uint64_t result = sub_1CC3405D0(v27, &v34);
            int v29 = *((_DWORD *)v26 + 4);
            int v30 = *((_DWORD *)result + 4);
            BOOL v17 = v29 <= v30;
            BOOL v31 = v29 < v30;
            char v32 = !v17;
            if (**(unsigned char **)(a3 + 8)) {
              char v33 = v31;
            }
            else {
              char v33 = v32;
            }
            uint64_t v24 = v23 - 2;
            v23 -= 2;
          }
          while ((v33 & 1) != 0);
          *uint64_t v24 = v21;
          v24[1] = v22;
        }
        unsigned int v7 = v9 + 2;
        char v6 = v9;
      }
      while (v9 + 2 != a2);
    }
  }
  return result;
}

uint64_t sub_1CC340D50(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  unint64_t v8 = *(_DWORD **)a4;
  unint64_t v9 = a2[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v67 = *a2;
  unint64_t v68 = v9;
  int v10 = sub_1CC3405D0(v8, &v67);
  unint64_t v11 = *(_DWORD **)a4;
  unint64_t v12 = a1[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v67 = *a1;
  unint64_t v68 = v12;
  unint64_t v13 = sub_1CC3405D0(v11, &v67);
  unint64_t v14 = *(_DWORD **)a4;
  int v15 = *((_DWORD *)v10 + 4);
  LODWORD(v13) = *((_DWORD *)v13 + 4);
  BOOL v16 = v15 <= (int)v13;
  BOOL v17 = v15 < (int)v13;
  char v18 = !v16;
  if (!**(unsigned char **)(a4 + 8)) {
    BOOL v17 = v18;
  }
  if (v17)
  {
    unint64_t v19 = a3[1] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v67 = *a3;
    unint64_t v68 = v19;
    int v20 = sub_1CC3405D0(v14, &v67);
    uint64_t v21 = *(_DWORD **)a4;
    unint64_t v22 = a2[1] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v67 = *a2;
    unint64_t v68 = v22;
    uint64_t v23 = sub_1CC3405D0(v21, &v67);
    int v24 = *((_DWORD *)v20 + 4);
    int v25 = *((_DWORD *)v23 + 4);
    BOOL v16 = v24 <= v25;
    BOOL v26 = v24 < v25;
    int v27 = !v16;
    if (**(unsigned char **)(a4 + 8)) {
      int v28 = v26;
    }
    else {
      int v28 = v27;
    }
    if (v28 == 1)
    {
      long long v29 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v29;
      return 1;
    }
    long long v53 = *(_OWORD *)a1;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)a2 = v53;
    uint64_t v54 = *(_DWORD **)a4;
    unint64_t v55 = a3[1] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v67 = *a3;
    unint64_t v68 = v55;
    uint64_t v56 = sub_1CC3405D0(v54, &v67);
    uint64_t v57 = *(_DWORD **)a4;
    unint64_t v58 = a2[1] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v67 = *a2;
    unint64_t v68 = v58;
    uint64_t v59 = sub_1CC3405D0(v57, &v67);
    int v60 = *((_DWORD *)v56 + 4);
    int v61 = *((_DWORD *)v59 + 4);
    BOOL v16 = v60 <= v61;
    BOOL v62 = v60 < v61;
    int v63 = !v16;
    if (**(unsigned char **)(a4 + 8)) {
      int v64 = v62;
    }
    else {
      int v64 = v63;
    }
    if (v64 != 1) {
      return 1;
    }
    long long v65 = *(_OWORD *)a2;
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_OWORD *)a3 = v65;
    return 2;
  }
  unint64_t v30 = a3[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v67 = *a3;
  unint64_t v68 = v30;
  BOOL v31 = sub_1CC3405D0(v14, &v67);
  char v32 = *(_DWORD **)a4;
  unint64_t v33 = a2[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v67 = *a2;
  unint64_t v68 = v33;
  uint64_t v34 = sub_1CC3405D0(v32, &v67);
  int v35 = *((_DWORD *)v31 + 4);
  int v36 = *((_DWORD *)v34 + 4);
  BOOL v16 = v35 <= v36;
  BOOL v37 = v35 < v36;
  int v38 = !v16;
  if (**(unsigned char **)(a4 + 8)) {
    int v39 = v37;
  }
  else {
    int v39 = v38;
  }
  if (v39 == 1)
  {
    long long v40 = *(_OWORD *)a2;
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_OWORD *)a3 = v40;
    uint64_t v41 = *(_DWORD **)a4;
    unint64_t v42 = a2[1] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v67 = *a2;
    unint64_t v68 = v42;
    BOOL v43 = sub_1CC3405D0(v41, &v67);
    int v44 = *(_DWORD **)a4;
    unint64_t v45 = a1[1] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v67 = *a1;
    unint64_t v68 = v45;
    long long v46 = sub_1CC3405D0(v44, &v67);
    int v47 = *((_DWORD *)v43 + 4);
    int v48 = *((_DWORD *)v46 + 4);
    BOOL v16 = v47 <= v48;
    BOOL v49 = v47 < v48;
    int v50 = !v16;
    if (**(unsigned char **)(a4 + 8)) {
      int v51 = v49;
    }
    else {
      int v51 = v50;
    }
    if (v51 != 1) {
      return 1;
    }
    long long v52 = *(_OWORD *)a1;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)a2 = v52;
    return 2;
  }
  return 0;
}

void *sub_1CC340FD8(void *a1, _OWORD *a2, uint64_t a3)
{
  uint64_t v6 = *a1;
  uint64_t v7 = a1[1];
  unint64_t v8 = *(_DWORD **)a3;
  *(void *)&long long v75 = v6;
  *((void *)&v75 + 1) = v7 & 0xFFFFFFFFFFFFFFF8;
  unint64_t v9 = sub_1CC3405D0(v8, (uint64_t *)&v75);
  int v10 = *(_DWORD **)a3;
  unint64_t v11 = *((void *)a2 - 1) & 0xFFFFFFFFFFFFFFF8;
  *(void *)&long long v75 = *((void *)a2 - 2);
  *((void *)&v75 + 1) = v11;
  unint64_t v12 = sub_1CC3405D0(v10, (uint64_t *)&v75);
  int v13 = *((_DWORD *)v9 + 4);
  int v14 = *((_DWORD *)v12 + 4);
  BOOL v15 = v13 <= v14;
  BOOL v16 = v13 < v14;
  char v17 = !v15;
  if (**(unsigned char **)(a3 + 8)) {
    char v18 = v16;
  }
  else {
    char v18 = v17;
  }
  if (v18)
  {
    unint64_t v19 = a1;
    do
    {
      int v20 = *(_DWORD **)a3;
      *(void *)&long long v75 = v6;
      *((void *)&v75 + 1) = v7 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v21 = sub_1CC3405D0(v20, (uint64_t *)&v75);
      unint64_t v22 = *(_DWORD **)a3;
      uint64_t v23 = v19[2];
      uint64_t v24 = v19[3];
      v19 += 2;
      *(void *)&long long v75 = v23;
      *((void *)&v75 + 1) = v24 & 0xFFFFFFFFFFFFFFF8;
      int v25 = sub_1CC3405D0(v22, (uint64_t *)&v75);
      int v26 = *((_DWORD *)v21 + 4);
      int v27 = *((_DWORD *)v25 + 4);
      BOOL v15 = v26 <= v27;
      BOOL v28 = v26 < v27;
      char v29 = !v15;
      if (**(unsigned char **)(a3 + 8)) {
        char v30 = v28;
      }
      else {
        char v30 = v29;
      }
    }
    while ((v30 & 1) == 0);
  }
  else
  {
    BOOL v31 = a1 + 2;
    do
    {
      unint64_t v19 = v31;
      if (v31 >= (void *)a2) {
        break;
      }
      char v32 = *(_DWORD **)a3;
      *(void *)&long long v75 = v6;
      *((void *)&v75 + 1) = v7 & 0xFFFFFFFFFFFFFFF8;
      unint64_t v33 = sub_1CC3405D0(v32, (uint64_t *)&v75);
      uint64_t v34 = *(_DWORD **)a3;
      unint64_t v35 = v19[1] & 0xFFFFFFFFFFFFFFF8;
      *(void *)&long long v75 = *v19;
      *((void *)&v75 + 1) = v35;
      int v36 = sub_1CC3405D0(v34, (uint64_t *)&v75);
      int v37 = *((_DWORD *)v33 + 4);
      int v38 = *((_DWORD *)v36 + 4);
      BOOL v15 = v37 <= v38;
      BOOL v39 = v37 < v38;
      int v40 = !v15;
      if (!**(unsigned char **)(a3 + 8)) {
        BOOL v39 = v40;
      }
      BOOL v31 = v19 + 2;
    }
    while (!v39);
  }
  if (v19 < (void *)a2)
  {
    do
    {
      uint64_t v41 = *(_DWORD **)a3;
      *(void *)&long long v75 = v6;
      *((void *)&v75 + 1) = v7 & 0xFFFFFFFFFFFFFFF8;
      unint64_t v42 = sub_1CC3405D0(v41, (uint64_t *)&v75);
      BOOL v43 = *(_DWORD **)a3;
      uint64_t v44 = *((void *)a2 - 2);
      uint64_t v45 = *((void *)a2-- - 1);
      *(void *)&long long v75 = v44;
      *((void *)&v75 + 1) = v45 & 0xFFFFFFFFFFFFFFF8;
      long long v46 = sub_1CC3405D0(v43, (uint64_t *)&v75);
      int v47 = *((_DWORD *)v42 + 4);
      int v48 = *((_DWORD *)v46 + 4);
      BOOL v15 = v47 <= v48;
      BOOL v49 = v47 < v48;
      char v50 = !v15;
      if (**(unsigned char **)(a3 + 8)) {
        char v51 = v49;
      }
      else {
        char v51 = v50;
      }
    }
    while ((v51 & 1) != 0);
  }
  while (v19 < (void *)a2)
  {
    long long v75 = *(_OWORD *)v19;
    *(_OWORD *)unint64_t v19 = *a2;
    *a2 = v75;
    do
    {
      long long v52 = *(_DWORD **)a3;
      *(void *)&long long v75 = v6;
      *((void *)&v75 + 1) = v7 & 0xFFFFFFFFFFFFFFF8;
      long long v53 = sub_1CC3405D0(v52, (uint64_t *)&v75);
      uint64_t v54 = *(_DWORD **)a3;
      uint64_t v55 = v19[2];
      uint64_t v56 = v19[3];
      v19 += 2;
      *(void *)&long long v75 = v55;
      *((void *)&v75 + 1) = v56 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v57 = sub_1CC3405D0(v54, (uint64_t *)&v75);
      int v58 = *((_DWORD *)v53 + 4);
      int v59 = *((_DWORD *)v57 + 4);
      BOOL v15 = v58 <= v59;
      BOOL v60 = v58 < v59;
      int v61 = !v15;
      if (**(unsigned char **)(a3 + 8)) {
        int v62 = v60;
      }
      else {
        int v62 = v61;
      }
    }
    while (v62 != 1);
    do
    {
      int v63 = *(_DWORD **)a3;
      *(void *)&long long v75 = v6;
      *((void *)&v75 + 1) = v7 & 0xFFFFFFFFFFFFFFF8;
      int v64 = sub_1CC3405D0(v63, (uint64_t *)&v75);
      long long v65 = *(_DWORD **)a3;
      uint64_t v66 = *((void *)a2 - 2);
      uint64_t v67 = *((void *)a2-- - 1);
      *(void *)&long long v75 = v66;
      *((void *)&v75 + 1) = v67 & 0xFFFFFFFFFFFFFFF8;
      unint64_t v68 = sub_1CC3405D0(v65, (uint64_t *)&v75);
      int v69 = *((_DWORD *)v64 + 4);
      int v70 = *((_DWORD *)v68 + 4);
      BOOL v15 = v69 <= v70;
      BOOL v71 = v69 < v70;
      char v72 = !v15;
      if (**(unsigned char **)(a3 + 8)) {
        char v73 = v71;
      }
      else {
        char v73 = v72;
      }
    }
    while ((v73 & 1) != 0);
  }
  if (v19 - 2 != a1) {
    *(_OWORD *)a1 = *((_OWORD *)v19 - 1);
  }
  *(v19 - 2) = v6;
  *(v19 - 1) = v7;
  return v19;
}

uint64_t *sub_1CC34128C(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = *a1;
  uint64_t v8 = a1[1];
  do
  {
    unint64_t v9 = *(_DWORD **)a3;
    unint64_t v10 = a1[v6 + 3] & 0xFFFFFFFFFFFFFFF8;
    *(void *)&long long v69 = a1[v6 + 2];
    *((void *)&v69 + 1) = v10;
    unint64_t v11 = sub_1CC3405D0(v9, (uint64_t *)&v69);
    unint64_t v12 = *(_DWORD **)a3;
    *(void *)&long long v69 = v7;
    *((void *)&v69 + 1) = v8 & 0xFFFFFFFFFFFFFFF8;
    int v13 = sub_1CC3405D0(v12, (uint64_t *)&v69);
    int v14 = *((_DWORD *)v11 + 4);
    int v15 = *((_DWORD *)v13 + 4);
    BOOL v16 = v14 <= v15;
    BOOL v17 = v14 < v15;
    char v18 = !v16;
    if (**(unsigned char **)(a3 + 8)) {
      char v19 = v17;
    }
    else {
      char v19 = v18;
    }
    v6 += 2;
  }
  while ((v19 & 1) != 0);
  int v20 = &a1[v6];
  if (v6 == 2)
  {
    do
    {
      if (v20 >= a2) {
        break;
      }
      char v32 = *(_DWORD **)a3;
      uint64_t v33 = *(a2 - 2);
      uint64_t v34 = *(a2 - 1);
      a2 -= 2;
      *(void *)&long long v69 = v33;
      *((void *)&v69 + 1) = v34 & 0xFFFFFFFFFFFFFFF8;
      unint64_t v35 = sub_1CC3405D0(v32, (uint64_t *)&v69);
      int v36 = *(_DWORD **)a3;
      *(void *)&long long v69 = v7;
      *((void *)&v69 + 1) = v8 & 0xFFFFFFFFFFFFFFF8;
      int v37 = sub_1CC3405D0(v36, (uint64_t *)&v69);
      int v38 = *((_DWORD *)v35 + 4);
      int v39 = *((_DWORD *)v37 + 4);
      BOOL v16 = v38 <= v39;
      BOOL v40 = v38 < v39;
      BOOL v41 = !v16;
    }
    while (!(**(unsigned char **)(a3 + 8) ? v40 : v41));
  }
  else
  {
    do
    {
      uint64_t v21 = *(_DWORD **)a3;
      uint64_t v22 = *(a2 - 2);
      uint64_t v23 = *(a2 - 1);
      a2 -= 2;
      *(void *)&long long v69 = v22;
      *((void *)&v69 + 1) = v23 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v24 = sub_1CC3405D0(v21, (uint64_t *)&v69);
      int v25 = *(_DWORD **)a3;
      *(void *)&long long v69 = v7;
      *((void *)&v69 + 1) = v8 & 0xFFFFFFFFFFFFFFF8;
      int v26 = sub_1CC3405D0(v25, (uint64_t *)&v69);
      int v27 = *((_DWORD *)v24 + 4);
      int v28 = *((_DWORD *)v26 + 4);
      BOOL v16 = v27 <= v28;
      BOOL v29 = v27 < v28;
      int v30 = !v16;
      if (**(unsigned char **)(a3 + 8)) {
        int v31 = v29;
      }
      else {
        int v31 = v30;
      }
    }
    while (v31 != 1);
  }
  BOOL v43 = &a1[v6];
  if (v20 < a2)
  {
    uint64_t v44 = a2;
    do
    {
      long long v69 = *(_OWORD *)v43;
      long long v45 = v69;
      *(_OWORD *)BOOL v43 = *(_OWORD *)v44;
      *(_OWORD *)uint64_t v44 = v45;
      do
      {
        long long v46 = *(_DWORD **)a3;
        uint64_t v47 = v43[2];
        uint64_t v48 = v43[3];
        v43 += 2;
        *(void *)&long long v69 = v47;
        *((void *)&v69 + 1) = v48 & 0xFFFFFFFFFFFFFFF8;
        BOOL v49 = sub_1CC3405D0(v46, (uint64_t *)&v69);
        char v50 = *(_DWORD **)a3;
        *(void *)&long long v69 = v7;
        *((void *)&v69 + 1) = v8 & 0xFFFFFFFFFFFFFFF8;
        char v51 = sub_1CC3405D0(v50, (uint64_t *)&v69);
        int v52 = *((_DWORD *)v49 + 4);
        int v53 = *((_DWORD *)v51 + 4);
        BOOL v16 = v52 <= v53;
        BOOL v54 = v52 < v53;
        char v55 = !v16;
        if (**(unsigned char **)(a3 + 8)) {
          char v56 = v54;
        }
        else {
          char v56 = v55;
        }
      }
      while ((v56 & 1) != 0);
      do
      {
        uint64_t v57 = *(_DWORD **)a3;
        uint64_t v58 = *(v44 - 2);
        uint64_t v59 = *(v44 - 1);
        v44 -= 2;
        *(void *)&long long v69 = v58;
        *((void *)&v69 + 1) = v59 & 0xFFFFFFFFFFFFFFF8;
        BOOL v60 = sub_1CC3405D0(v57, (uint64_t *)&v69);
        int v61 = *(_DWORD **)a3;
        *(void *)&long long v69 = v7;
        *((void *)&v69 + 1) = v8 & 0xFFFFFFFFFFFFFFF8;
        int v62 = sub_1CC3405D0(v61, (uint64_t *)&v69);
        int v63 = *((_DWORD *)v60 + 4);
        int v64 = *((_DWORD *)v62 + 4);
        BOOL v16 = v63 <= v64;
        BOOL v65 = v63 < v64;
        int v66 = !v16;
        if (**(unsigned char **)(a3 + 8)) {
          int v67 = v65;
        }
        else {
          int v67 = v66;
        }
      }
      while (v67 != 1);
    }
    while (v43 < v44);
  }
  uint64_t result = v43 - 2;
  if (v43 - 2 != a1) {
    *(_OWORD *)a1 = *(_OWORD *)result;
  }
  *(v43 - 2) = v7;
  *(v43 - 1) = v8;
  return result;
}

BOOL sub_1CC341500(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = a2;
  uint64_t v6 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v8 = *(_DWORD **)a3;
      uint64_t v9 = *(a2 - 1);
      unint64_t v10 = a2 - 2;
      uint64_t v53 = *(a2 - 2);
      unint64_t v54 = v9 & 0xFFFFFFFFFFFFFFF8;
      unint64_t v11 = sub_1CC3405D0(v8, &v53);
      unint64_t v12 = *(_DWORD **)a3;
      unint64_t v13 = a1[1] & 0xFFFFFFFFFFFFFFF8;
      uint64_t v53 = *a1;
      unint64_t v54 = v13;
      int v14 = sub_1CC3405D0(v12, &v53);
      int v15 = *((_DWORD *)v11 + 4);
      int v16 = *((_DWORD *)v14 + 4);
      BOOL v17 = v15 <= v16;
      BOOL v18 = v15 < v16;
      int v19 = !v17;
      if (**(unsigned char **)(a3 + 8)) {
        int v20 = v18;
      }
      else {
        int v20 = v19;
      }
      if (v20 == 1)
      {
        long long v21 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v10;
        *(_OWORD *)unint64_t v10 = v21;
      }
      return 1;
    case 3:
      sub_1CC340D50(a1, a1 + 2, a2 - 2, a3);
      return 1;
    case 4:
      sub_1CC3417C0(a1, a1 + 2, a1 + 4, a2 - 2, a3);
      return 1;
    case 5:
      sub_1CC341960(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2, a3);
      return 1;
    default:
      uint64_t v22 = a1 + 4;
      sub_1CC340D50(a1, a1 + 2, a1 + 4, a3);
      uint64_t v23 = a1 + 6;
      if (a1 + 6 == v4) {
        return 1;
      }
      uint64_t v24 = 0;
      int v25 = 0;
      char v51 = v4;
      break;
  }
  while (1)
  {
    int v26 = *(_DWORD **)a3;
    unint64_t v27 = v23[1] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v53 = *v23;
    unint64_t v54 = v27;
    int v28 = sub_1CC3405D0(v26, &v53);
    BOOL v29 = *(_DWORD **)a3;
    unint64_t v30 = v22[1] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v53 = *v22;
    unint64_t v54 = v30;
    int v31 = sub_1CC3405D0(v29, &v53);
    int v32 = *((_DWORD *)v28 + 4);
    int v33 = *((_DWORD *)v31 + 4);
    BOOL v17 = v32 <= v33;
    BOOL v34 = v32 < v33;
    BOOL v35 = !v17;
    if (**(unsigned char **)(a3 + 8) ? v34 : v35)
    {
      uint64_t v37 = *v23;
      uint64_t v52 = v23[1];
      uint64_t v38 = v24;
      while (1)
      {
        int v39 = (char *)a1 + v38;
        *(_OWORD *)((char *)a1 + v38 + 48) = *(_OWORD *)((char *)a1 + v38 + 32);
        if (v38 == -32) {
          break;
        }
        BOOL v40 = *(_DWORD **)a3;
        uint64_t v53 = v37;
        unint64_t v54 = v52 & 0xFFFFFFFFFFFFFFF8;
        BOOL v41 = sub_1CC3405D0(v40, &v53);
        unint64_t v42 = *(_DWORD **)a3;
        unint64_t v43 = *((void *)v39 + 3) & 0xFFFFFFFFFFFFFFF8;
        uint64_t v53 = *((void *)v39 + 2);
        unint64_t v54 = v43;
        uint64_t v44 = sub_1CC3405D0(v42, &v53);
        int v45 = *((_DWORD *)v41 + 4);
        int v46 = *((_DWORD *)v44 + 4);
        BOOL v17 = v45 <= v46;
        BOOL v47 = v45 < v46;
        char v48 = !v17;
        if (**(unsigned char **)(a3 + 8)) {
          char v49 = v47;
        }
        else {
          char v49 = v48;
        }
        v38 -= 16;
        if ((v49 & 1) == 0)
        {
          char v50 = (uint64_t *)((char *)a1 + v38 + 48);
          goto LABEL_30;
        }
      }
      char v50 = a1;
LABEL_30:
      uint64_t v4 = v51;
      *char v50 = v37;
      v50[1] = v52;
      if (++v25 == 8) {
        return v23 + 2 == v51;
      }
    }
    uint64_t v22 = v23;
    v24 += 16;
    v23 += 2;
    if (v23 == v4) {
      return 1;
    }
  }
}

__n128 sub_1CC3417C0(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  sub_1CC340D50(a1, a2, a3, a5);
  unint64_t v10 = *(_DWORD **)a5;
  unint64_t v11 = a4[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v47 = *a4;
  unint64_t v48 = v11;
  unint64_t v12 = sub_1CC3405D0(v10, &v47);
  unint64_t v13 = *(_DWORD **)a5;
  unint64_t v14 = a3[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v47 = *a3;
  unint64_t v48 = v14;
  int v15 = sub_1CC3405D0(v13, &v47);
  int v17 = *((_DWORD *)v12 + 4);
  int v18 = *((_DWORD *)v15 + 4);
  BOOL v19 = v17 <= v18;
  BOOL v20 = v17 < v18;
  int v21 = !v19;
  if (**(unsigned char **)(a5 + 8)) {
    int v22 = v20;
  }
  else {
    int v22 = v21;
  }
  if (v22 == 1)
  {
    long long v23 = *(_OWORD *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)a4 = v23;
    uint64_t v24 = *(_DWORD **)a5;
    unint64_t v25 = a3[1] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v47 = *a3;
    unint64_t v48 = v25;
    int v26 = sub_1CC3405D0(v24, &v47);
    unint64_t v27 = *(_DWORD **)a5;
    unint64_t v28 = a2[1] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v47 = *a2;
    unint64_t v48 = v28;
    BOOL v29 = sub_1CC3405D0(v27, &v47);
    int v30 = *((_DWORD *)v26 + 4);
    int v31 = *((_DWORD *)v29 + 4);
    BOOL v19 = v30 <= v31;
    BOOL v32 = v30 < v31;
    BOOL v33 = !v19;
    if (**(unsigned char **)(a5 + 8) ? v32 : v33)
    {
      long long v35 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v35;
      int v36 = *(_DWORD **)a5;
      unint64_t v37 = a2[1] & 0xFFFFFFFFFFFFFFF8;
      uint64_t v47 = *a2;
      unint64_t v48 = v37;
      uint64_t v38 = sub_1CC3405D0(v36, &v47);
      int v39 = *(_DWORD **)a5;
      unint64_t v40 = a1[1] & 0xFFFFFFFFFFFFFFF8;
      uint64_t v47 = *a1;
      unint64_t v48 = v40;
      BOOL v41 = sub_1CC3405D0(v39, &v47);
      int v42 = *((_DWORD *)v38 + 4);
      int v43 = *((_DWORD *)v41 + 4);
      BOOL v19 = v42 <= v43;
      BOOL v44 = v42 < v43;
      int v45 = !v19;
      if (**(unsigned char **)(a5 + 8)) {
        int v46 = v44;
      }
      else {
        int v46 = v45;
      }
      if (v46 == 1)
      {
        __n128 result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 sub_1CC341960(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  sub_1CC3417C0(a1, a2, a3, a4, a6);
  unint64_t v12 = *(_DWORD **)a6;
  unint64_t v13 = a5[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v61 = *a5;
  unint64_t v62 = v13;
  unint64_t v14 = sub_1CC3405D0(v12, &v61);
  int v15 = *(_DWORD **)a6;
  unint64_t v16 = a4[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v61 = *a4;
  unint64_t v62 = v16;
  int v17 = sub_1CC3405D0(v15, &v61);
  int v19 = *((_DWORD *)v14 + 4);
  int v20 = *((_DWORD *)v17 + 4);
  BOOL v21 = v19 <= v20;
  BOOL v22 = v19 < v20;
  int v23 = !v21;
  if (**(unsigned char **)(a6 + 8)) {
    int v24 = v22;
  }
  else {
    int v24 = v23;
  }
  if (v24 == 1)
  {
    long long v25 = *(_OWORD *)a4;
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(_OWORD *)a5 = v25;
    int v26 = *(_DWORD **)a6;
    unint64_t v27 = a4[1] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v61 = *a4;
    unint64_t v62 = v27;
    unint64_t v28 = sub_1CC3405D0(v26, &v61);
    BOOL v29 = *(_DWORD **)a6;
    unint64_t v30 = a3[1] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v61 = *a3;
    unint64_t v62 = v30;
    int v31 = sub_1CC3405D0(v29, &v61);
    int v32 = *((_DWORD *)v28 + 4);
    int v33 = *((_DWORD *)v31 + 4);
    BOOL v21 = v32 <= v33;
    BOOL v34 = v32 < v33;
    BOOL v35 = !v21;
    if (**(unsigned char **)(a6 + 8) ? v34 : v35)
    {
      long long v37 = *(_OWORD *)a3;
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_OWORD *)a4 = v37;
      uint64_t v38 = *(_DWORD **)a6;
      unint64_t v39 = a3[1] & 0xFFFFFFFFFFFFFFF8;
      uint64_t v61 = *a3;
      unint64_t v62 = v39;
      unint64_t v40 = sub_1CC3405D0(v38, &v61);
      BOOL v41 = *(_DWORD **)a6;
      unint64_t v42 = a2[1] & 0xFFFFFFFFFFFFFFF8;
      uint64_t v61 = *a2;
      unint64_t v62 = v42;
      int v43 = sub_1CC3405D0(v41, &v61);
      int v44 = *((_DWORD *)v40 + 4);
      int v45 = *((_DWORD *)v43 + 4);
      BOOL v21 = v44 <= v45;
      BOOL v46 = v44 < v45;
      BOOL v47 = !v21;
      if (**(unsigned char **)(a6 + 8) ? v46 : v47)
      {
        long long v49 = *(_OWORD *)a2;
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(_OWORD *)a3 = v49;
        char v50 = *(_DWORD **)a6;
        unint64_t v51 = a2[1] & 0xFFFFFFFFFFFFFFF8;
        uint64_t v61 = *a2;
        unint64_t v62 = v51;
        uint64_t v52 = sub_1CC3405D0(v50, &v61);
        uint64_t v53 = *(_DWORD **)a6;
        unint64_t v54 = a1[1] & 0xFFFFFFFFFFFFFFF8;
        uint64_t v61 = *a1;
        unint64_t v62 = v54;
        char v55 = sub_1CC3405D0(v53, &v61);
        int v56 = *((_DWORD *)v52 + 4);
        int v57 = *((_DWORD *)v55 + 4);
        BOOL v21 = v56 <= v57;
        BOOL v58 = v56 < v57;
        int v59 = !v21;
        if (**(unsigned char **)(a6 + 8)) {
          int v60 = v58;
        }
        else {
          int v60 = v59;
        }
        if (v60 == 1)
        {
          __n128 result = *(__n128 *)a1;
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

uint64_t *sub_1CC341B7C(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    uint64_t v6 = a2;
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = ((char *)a2 - (char *)a1) >> 4;
    if ((char *)a2 - (char *)a1 >= 17)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      unint64_t v12 = &a1[2 * v10];
      do
      {
        sub_1CC341DEC(a1, a4, v9, v12);
        v12 -= 2;
        --v11;
      }
      while (v11);
    }
    unint64_t v13 = v6;
    if (v6 != a3)
    {
      unint64_t v14 = v6;
      do
      {
        int v15 = *(_DWORD **)a4;
        unint64_t v16 = v14[1] & 0xFFFFFFFFFFFFFFF8;
        uint64_t v48 = *v14;
        unint64_t v49 = v16;
        int v17 = sub_1CC3405D0(v15, &v48);
        int v18 = *(_DWORD **)a4;
        unint64_t v19 = a1[1] & 0xFFFFFFFFFFFFFFF8;
        uint64_t v48 = *a1;
        unint64_t v49 = v19;
        int v20 = sub_1CC3405D0(v18, &v48);
        int v21 = *((_DWORD *)v17 + 4);
        int v22 = *((_DWORD *)v20 + 4);
        BOOL v23 = v21 <= v22;
        BOOL v24 = v21 < v22;
        int v25 = !v23;
        if (**(unsigned char **)(a4 + 8)) {
          int v26 = v24;
        }
        else {
          int v26 = v25;
        }
        if (v26 == 1)
        {
          long long v27 = *(_OWORD *)v14;
          *(_OWORD *)unint64_t v14 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v27;
          sub_1CC341DEC(a1, a4, v9, a1);
        }
        v14 += 2;
      }
      while (v14 != a3);
      unint64_t v13 = a3;
    }
    if (v8 < 17)
    {
      return v13;
    }
    else
    {
      int v45 = v13;
      do
      {
        BOOL v46 = v6;
        uint64_t v28 = 0;
        long long v47 = *(_OWORD *)a1;
        BOOL v29 = a1;
        do
        {
          unint64_t v30 = &v29[2 * v28 + 2];
          uint64_t v31 = (2 * v28) | 1;
          uint64_t v32 = 2 * v28 + 2;
          if (v32 < v9)
          {
            int v33 = *(_DWORD **)a4;
            unint64_t v34 = v30[1] & 0xFFFFFFFFFFFFFFF8;
            uint64_t v48 = *v30;
            unint64_t v49 = v34;
            BOOL v35 = sub_1CC3405D0(v33, &v48);
            int v36 = *(_DWORD **)a4;
            unint64_t v37 = v30[3] & 0xFFFFFFFFFFFFFFF8;
            uint64_t v48 = v30[2];
            unint64_t v49 = v37;
            uint64_t v38 = sub_1CC3405D0(v36, &v48);
            int v39 = *((_DWORD *)v35 + 4);
            int v40 = *((_DWORD *)v38 + 4);
            BOOL v23 = v39 <= v40;
            BOOL v41 = v39 < v40;
            BOOL v42 = !v23;
            if (**(unsigned char **)(a4 + 8) ? v41 : v42)
            {
              v30 += 2;
              uint64_t v31 = v32;
            }
          }
          *(_OWORD *)BOOL v29 = *(_OWORD *)v30;
          BOOL v29 = v30;
          uint64_t v28 = v31;
        }
        while (v31 <= (uint64_t)((unint64_t)(v9 - 2) >> 1));
        v6 -= 2;
        if (v30 == v46 - 2)
        {
          *(_OWORD *)unint64_t v30 = v47;
        }
        else
        {
          *(_OWORD *)unint64_t v30 = *(_OWORD *)v6;
          *(_OWORD *)uint64_t v6 = v47;
          sub_1CC342070(a1, (uint64_t)(v30 + 2), a4, ((char *)(v30 + 2) - (char *)a1) >> 4);
        }
        BOOL v23 = v9-- <= 2;
      }
      while (!v23);
      return v45;
    }
  }
  return a3;
}

void *sub_1CC341DEC(void *result, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6 = a3 - 2;
  if (a3 >= 2)
  {
    uint64_t v66 = v4;
    uint64_t v67 = v5;
    uint64_t v7 = a4;
    uint64_t v8 = result;
    int64_t v9 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) >= ((char *)a4 - (char *)result) >> 4)
    {
      uint64_t v10 = a3;
      uint64_t v12 = a4 - result;
      uint64_t v13 = v12 + 1;
      unint64_t v14 = &result[2 * v12 + 2];
      uint64_t v15 = v12 + 2;
      if (v12 + 2 < a3)
      {
        unint64_t v16 = *(_DWORD **)a2;
        unint64_t v17 = v14[1] & 0xFFFFFFFFFFFFFFF8;
        uint64_t v64 = *v14;
        unint64_t v65 = v17;
        int v18 = sub_1CC3405D0(v16, &v64);
        unint64_t v19 = *(_DWORD **)a2;
        unint64_t v20 = v14[3] & 0xFFFFFFFFFFFFFFF8;
        uint64_t v64 = v14[2];
        unint64_t v65 = v20;
        int v21 = sub_1CC3405D0(v19, &v64);
        int v22 = *((_DWORD *)v18 + 4);
        int v23 = *((_DWORD *)v21 + 4);
        BOOL v24 = v22 <= v23;
        BOOL v25 = v22 < v23;
        BOOL v26 = !v24;
        if (**(unsigned char **)(a2 + 8) ? v25 : v26)
        {
          v14 += 2;
          uint64_t v13 = v15;
        }
      }
      uint64_t v28 = *(_DWORD **)a2;
      unint64_t v29 = v14[1] & 0xFFFFFFFFFFFFFFF8;
      uint64_t v64 = *v14;
      unint64_t v65 = v29;
      unint64_t v30 = sub_1CC3405D0(v28, &v64);
      uint64_t v31 = *(_DWORD **)a2;
      unint64_t v32 = v7[1] & 0xFFFFFFFFFFFFFFF8;
      uint64_t v64 = *v7;
      unint64_t v65 = v32;
      __n128 result = sub_1CC3405D0(v31, &v64);
      int v33 = *((_DWORD *)v30 + 4);
      int v34 = *((_DWORD *)result + 4);
      BOOL v24 = v33 <= v34;
      BOOL v35 = v33 < v34;
      char v36 = !v24;
      if (**(unsigned char **)(a2 + 8)) {
        char v37 = v35;
      }
      else {
        char v37 = v36;
      }
      if ((v37 & 1) == 0)
      {
        uint64_t v38 = *v7;
        uint64_t v62 = v7[1];
        uint64_t v63 = v10;
        do
        {
          int v39 = v14;
          *(_OWORD *)uint64_t v7 = *(_OWORD *)v14;
          if (v9 < v13) {
            break;
          }
          uint64_t v40 = (2 * v13) | 1;
          unint64_t v14 = &v8[2 * v40];
          uint64_t v41 = 2 * v13 + 2;
          if (v41 < v10)
          {
            BOOL v42 = *(_DWORD **)a2;
            unint64_t v43 = v14[1] & 0xFFFFFFFFFFFFFFF8;
            uint64_t v64 = *v14;
            unint64_t v65 = v43;
            int v44 = sub_1CC3405D0(v42, &v64);
            int v45 = *(_DWORD **)a2;
            unint64_t v46 = v14[3] & 0xFFFFFFFFFFFFFFF8;
            uint64_t v64 = v14[2];
            unint64_t v65 = v46;
            long long v47 = sub_1CC3405D0(v45, &v64);
            int v48 = *((_DWORD *)v44 + 4);
            int v49 = *((_DWORD *)v47 + 4);
            BOOL v24 = v48 <= v49;
            BOOL v50 = v48 < v49;
            int v51 = !v24;
            if (**(unsigned char **)(a2 + 8)) {
              int v52 = v50;
            }
            else {
              int v52 = v51;
            }
            if (v52) {
              v14 += 2;
            }
            uint64_t v10 = v63;
            if (v52) {
              uint64_t v40 = v41;
            }
          }
          uint64_t v53 = *(_DWORD **)a2;
          unint64_t v54 = v14[1] & 0xFFFFFFFFFFFFFFF8;
          uint64_t v64 = *v14;
          unint64_t v65 = v54;
          char v55 = sub_1CC3405D0(v53, &v64);
          int v56 = *(_DWORD **)a2;
          uint64_t v64 = v38;
          unint64_t v65 = v62 & 0xFFFFFFFFFFFFFFF8;
          __n128 result = sub_1CC3405D0(v56, &v64);
          int v57 = *((_DWORD *)v55 + 4);
          int v58 = *((_DWORD *)result + 4);
          BOOL v24 = v57 <= v58;
          BOOL v59 = v57 < v58;
          BOOL v60 = !v24;
          BOOL v61 = **(unsigned char **)(a2 + 8) ? v59 : v60;
          uint64_t v7 = v39;
          uint64_t v13 = v40;
        }
        while (!v61);
        *int v39 = v38;
        v39[1] = v62;
      }
    }
  }
  return result;
}

void *sub_1CC342070(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6 = a4 - 2;
  if (a4 >= 2)
  {
    uint64_t v38 = v4;
    uint64_t v39 = v5;
    int64_t v9 = result;
    unint64_t v10 = v6 >> 1;
    unint64_t v11 = &result[2 * (v6 >> 1)];
    uint64_t v12 = *(_DWORD **)a3;
    unint64_t v13 = v11[1] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v36 = *v11;
    unint64_t v37 = v13;
    unint64_t v14 = sub_1CC3405D0(v12, &v36);
    uint64_t v15 = *(_DWORD **)a3;
    unint64_t v16 = (uint64_t *)(a2 - 16);
    unint64_t v17 = *(void *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
    uint64_t v36 = *(void *)(a2 - 16);
    unint64_t v37 = v17;
    __n128 result = sub_1CC3405D0(v15, &v36);
    int v18 = *((_DWORD *)v14 + 4);
    int v19 = *((_DWORD *)result + 4);
    BOOL v20 = v18 <= v19;
    BOOL v21 = v18 < v19;
    BOOL v22 = !v20;
    if (**(unsigned char **)(a3 + 8) ? v21 : v22)
    {
      uint64_t v24 = *(void *)(a2 - 16);
      uint64_t v25 = *(void *)(a2 - 8);
      do
      {
        BOOL v26 = v11;
        *(_OWORD *)unint64_t v16 = *(_OWORD *)v11;
        if (!v10) {
          break;
        }
        unint64_t v10 = (v10 - 1) >> 1;
        unint64_t v11 = &v9[2 * v10];
        long long v27 = *(_DWORD **)a3;
        unint64_t v28 = v11[1] & 0xFFFFFFFFFFFFFFF8;
        uint64_t v36 = *v11;
        unint64_t v37 = v28;
        unint64_t v29 = sub_1CC3405D0(v27, &v36);
        unint64_t v30 = *(_DWORD **)a3;
        uint64_t v36 = v24;
        unint64_t v37 = v25 & 0xFFFFFFFFFFFFFFF8;
        __n128 result = sub_1CC3405D0(v30, &v36);
        int v31 = *((_DWORD *)v29 + 4);
        int v32 = *((_DWORD *)result + 4);
        BOOL v20 = v31 <= v32;
        BOOL v33 = v31 < v32;
        BOOL v34 = !v20;
        BOOL v35 = **(unsigned char **)(a3 + 8) ? v33 : v34;
        unint64_t v16 = v26;
      }
      while (v35);
      *BOOL v26 = v24;
      v26[1] = v25;
    }
  }
  return result;
}

double sub_1CC3421B8(_DWORD *a1, uint64_t *a2)
{
  uint64_t v10 = 0;
  char v4 = sub_1CC3422C8((uint64_t)a1, *a2, &v10);
  uint64_t v6 = v10;
  if (v4) {
    return result;
  }
  int v7 = *a1 >> 1;
  if (*a1) {
    unsigned int v8 = 4;
  }
  else {
    unsigned int v8 = a1[4];
  }
  if (4 * v7 + 4 >= 3 * v8)
  {
    v8 *= 2;
    goto LABEL_12;
  }
  if (v8 + ~v7 - a1[1] <= v8 >> 3)
  {
LABEL_12:
    sub_1CC342378((uint64_t)a1, v8);
    uint64_t v10 = 0;
    sub_1CC3422C8((uint64_t)a1, *a2, &v10);
    uint64_t v6 = v10;
  }
  *a1 += 2;
  if (*(void *)v6 != -4096) {
    --a1[1];
  }
  uint64_t v9 = *a2;
  *(_OWORD *)(v6 + 56) = 0u;
  *(_OWORD *)(v6 + 40) = 0u;
  *(_OWORD *)(v6 + 24) = 0u;
  *(void *)uint64_t v6 = v9;
  *(void *)(v6 + 8) = v6 + 24;
  *(void *)&double result = 0x200000000;
  *(void *)(v6 + 16) = 0x200000000;
  *(void *)(v6 + 40) = v6 + 56;
  *(_DWORD *)(v6 + 52) = 2;
  return result;
}

uint64_t sub_1CC3422C8(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      int v7 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  int v7 = (void *)(v3 + 72 * v6);
  uint64_t v8 = *v7;
  if (*v7 == a2)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      int v7 = (void *)(v3 + 72 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    if (v10) {
      int v7 = v10;
    }
  }
LABEL_7:
  *a3 = v7;
  return result;
}

void sub_1CC342378(uint64_t a1, unsigned int a2)
{
  v27[36] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    unsigned int v6 = *(uint64_t **)(a1 + 8);
    unsigned int v7 = *(_DWORD *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v24 = a2;
      *(void *)(a1 + 8) = operator new(72 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v24;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CC342654(a1, v6, &v6[9 * v7]);
    JUMPOUT(0x1D25D9CD0);
  }
  unsigned int v25 = a2;
  uint64_t v8 = 0;
  uint64_t v9 = a1 + 8;
  uint64_t v10 = v27;
  uint64_t v11 = a1;
  BOOL v12 = (uint64_t *)(a1 + 8);
  do
  {
    if ((*v12 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      char v13 = 0;
      uint64_t v14 = 0;
      *uint64_t v10 = *v12;
      uint64_t v15 = v10 + 1;
      unint64_t v16 = v12 + 1;
      do
      {
        char v17 = v13;
        int v18 = &v15[4 * v14];
        *int v18 = (uint64_t)(v18 + 2);
        v18[1] = 0x200000000;
        if (v15 != v16)
        {
          int v19 = &v16[4 * v14];
          unint64_t v20 = *((unsigned int *)v19 + 2);
          if (*((_DWORD *)v19 + 2))
          {
            BOOL v21 = (const void *)*v19;
            if ((uint64_t *)*v19 == v19 + 2)
            {
              if (v20 >= 3) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              memcpy(v18 + 2, v21, 8 * *((unsigned int *)v19 + 2));
              *((_DWORD *)v18 + 2) = v20;
            }
            else
            {
              *int v18 = (uint64_t)v21;
              *((_DWORD *)v18 + 2) = v20;
              *((_DWORD *)v18 + 3) = *((_DWORD *)v19 + 3);
              *int v19 = (uint64_t)(v19 + 2);
              *((_DWORD *)v19 + 3) = 0;
            }
            *((_DWORD *)v19 + 2) = 0;
          }
        }
        char v13 = 1;
        uint64_t v14 = 1;
      }
      while ((v17 & 1) == 0);
      for (uint64_t i = 0; i != -64; i -= 32)
      {
        int v23 = *(void **)(v11 + i + 48);
        if ((void *)(v11 + i + 64) != v23) {
          free(v23);
        }
      }
      v10 += 9;
    }
    ++v8;
    BOOL v12 = (uint64_t *)(v9 + 72 * v8);
    v11 += 72;
  }
  while (v8 != 4);
  if (v25 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    *(void *)(a1 + 8) = operator new(72 * v25, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v25;
  }
  sub_1CC342654(a1, v27, v10);
}

void sub_1CC342654(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  unint64_t v4 = a2;
  int v6 = *(_DWORD *)a1;
  *(void *)a1 = *(_DWORD *)a1 & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(a1 + 8);
    uint64_t v9 = (void *)(a1 + 296);
  }
  else
  {
    unsigned int v7 = *(_DWORD *)(a1 + 16);
    if (!v7) {
      goto LABEL_6;
    }
    uint64_t v8 = *(void **)(a1 + 8);
    uint64_t v9 = &v8[9 * v7];
  }
  do
  {
    *uint64_t v8 = -4096;
    v8 += 9;
  }
  while (v8 != v9);
LABEL_6:
  if (a2 != a3)
  {
    do
    {
      uint64_t v10 = *v4;
      if ((*v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v24 = 0;
        sub_1CC3422C8(a1, v10, &v24);
        char v11 = 0;
        uint64_t v12 = 0;
        char v13 = v24;
        uint64_t v14 = v4 + 1;
        *uint64_t v24 = *v4;
        uint64_t v15 = v13 + 1;
        do
        {
          char v16 = v11;
          char v17 = &v15[4 * v12];
          uint64_t *v17 = (uint64_t)(v17 + 2);
          v17[1] = 0x200000000;
          if (v15 != v14)
          {
            int v18 = &v14[4 * v12];
            unint64_t v19 = *((unsigned int *)v18 + 2);
            if (*((_DWORD *)v18 + 2))
            {
              unint64_t v20 = (const void *)*v18;
              if ((uint64_t *)*v18 == v18 + 2)
              {
                if (v19 >= 3) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                memcpy(v17 + 2, v20, 8 * *((unsigned int *)v18 + 2));
                *((_DWORD *)v17 + 2) = v19;
              }
              else
              {
                uint64_t *v17 = (uint64_t)v20;
                int v21 = *((_DWORD *)v18 + 3);
                *((_DWORD *)v17 + 2) = v19;
                *((_DWORD *)v17 + 3) = v21;
                *int v18 = (uint64_t)(v18 + 2);
                *((_DWORD *)v18 + 3) = 0;
              }
              *((_DWORD *)v18 + 2) = 0;
            }
          }
          char v11 = 1;
          uint64_t v12 = 1;
        }
        while ((v16 & 1) == 0);
        uint64_t v22 = 0;
        *(_DWORD *)a1 += 2;
        do
        {
          int v23 = (uint64_t *)v4[v22 + 5];
          if (&v4[v22 + 7] != v23) {
            free(v23);
          }
          v22 -= 4;
        }
        while (v22 != -8);
      }
      v4 += 9;
    }
    while (v4 != a3);
  }
}

void sub_1CC34281C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(unsigned int *)(a2 + 608);
  if (!v3) {
    return;
  }
  if (v3 == 1)
  {
    uint64_t v7 = sub_1CC3429A8(a2);
    if (a3)
    {
      v18[0] = 0;
      uint64_t v19 = a3;
      uint64_t v20 = a3;
      unint64_t v21 = *(unsigned int *)(a3 + 608);
      unint64_t v8 = v6 & 0xFFFFFFFFFFFFFFF8;
      if ((v6 & 4) != 0) {
        sub_1CC343350(a1, (uint64_t)v18, v7, v8);
      }
      else {
        sub_1CC342AA0(a1, (uint64_t)v18, v7, v8);
      }
    }
    else
    {
      unint64_t v17 = v6 & 0xFFFFFFFFFFFFFFF8;
      if ((v6 & 4) != 0)
      {
        sub_1CC343350(a1, 0, v7, v17);
      }
      else
      {
        sub_1CC342AA0(a1, 0, v7, v17);
      }
    }
    return;
  }
  v18[0] = 0;
  uint64_t v19 = a2;
  uint64_t v20 = a3;
  unint64_t v21 = v3;
  unsigned int v9 = *(_DWORD *)(a1 + 32);
  if (v9 > 0x64)
  {
    if (v3 <= v9 / 0x28) {
      goto LABEL_8;
    }
LABEL_10:
    sub_1CC2DC400(a1, (uint64_t)v18);
    BOOL v10 = v18[0] == 0;
    if (!v21) {
      return;
    }
    goto LABEL_11;
  }
  if (v3 > v9) {
    goto LABEL_10;
  }
LABEL_8:
  BOOL v10 = 1;
LABEL_11:
  if (v10)
  {
    unint64_t v11 = 1;
    do
    {
      uint64_t v12 = sub_1CC3429A8(v19);
      unint64_t v14 = v13 & 0xFFFFFFFFFFFFFFF8;
      if ((v13 & 4) != 0) {
        sub_1CC343350(a1, (uint64_t)v18, v12, v14);
      }
      else {
        sub_1CC342AA0(a1, (uint64_t)v18, v12, v14);
      }
    }
    while (v11++ < v21 && v18[0] == 0);
  }
}

uint64_t sub_1CC3429A8(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 608);
  uint64_t v3 = *(void *)(a1 + 600) + 16 * v2;
  uint64_t v4 = *(void *)(v3 - 16);
  unint64_t v5 = *(void *)(v3 - 8);
  *(_DWORD *)(a1 + 608) = v2 - 1;
  unint64_t v6 = (v5 >> 2) & 1 ^ (*(unsigned char *)(a1 + 592) == 0);
  unint64_t v15 = v4;
  sub_1CC3421B8((_DWORD *)a1, (uint64_t *)&v15);
  uint64_t v8 = v7 + 8 + 32 * v6;
  int v9 = *(_DWORD *)(v8 + 8) - 1;
  *(_DWORD *)(v8 + 8) = v9;
  if (!v9 && !*(_DWORD *)(v7 + 8 + 32 * (v6 ^ 1) + 8)) {
    sub_1CC344FB8((_DWORD *)a1, v4);
  }
  BOOL v10 = (_DWORD *)(a1 + 296);
  unint64_t v15 = v5 & 0xFFFFFFFFFFFFFFF8;
  sub_1CC3421B8(v10, (uint64_t *)&v15);
  uint64_t v12 = v11 + 8 + 32 * v6;
  int v13 = *(_DWORD *)(v12 + 8) - 1;
  *(_DWORD *)(v12 + 8) = v13;
  if (!v13 && !*(_DWORD *)(v11 + 8 + 32 * (v6 ^ 1) + 8)) {
    sub_1CC344FB8(v10, v5 & 0xFFFFFFFFFFFFFFF8);
  }
  return v4;
}

void sub_1CC342AA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned char v118[64] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned int *)(a1 + 40);
  if (v4)
  {
    uint64_t v8 = *(void *)(a1 + 24);
    unsigned int v9 = v4 - 1;
    LODWORD(v10) = (v4 - 1) & ((a3 >> 4) ^ (a3 >> 9));
    uint64_t v11 = (uint64_t *)(v8 + 16 * v10);
    uint64_t v12 = *v11;
    if (*v11 != a3)
    {
      int v13 = 1;
      do
      {
        if (v12 == -4096) {
          return;
        }
        int v14 = v10 + v13++;
        uint64_t v10 = v14 & v9;
        uint64_t v12 = *(void *)(v8 + 16 * v10);
      }
      while (v12 != a3);
      uint64_t v11 = (uint64_t *)(v8 + 16 * v10);
    }
    unint64_t v15 = (uint64_t *)(v8 + 16 * v4);
    if (v11 != v15)
    {
      char v16 = (uint64_t *)v11[1];
      if (v16)
      {
        *(unsigned char *)(a1 + 64) = 0;
        LODWORD(v17) = v9 & ((a4 >> 4) ^ (a4 >> 9));
        int v18 = (uint64_t *)(v8 + 16 * v17);
        uint64_t v19 = *v18;
        if (*v18 != a4)
        {
          int v20 = 1;
          do
          {
            if (v19 == -4096) {
              goto LABEL_19;
            }
            int v21 = v17 + v20++;
            uint64_t v17 = v21 & v9;
            uint64_t v19 = *(void *)(v8 + 16 * v17);
          }
          while (v19 != a4);
          int v18 = (uint64_t *)(v8 + 16 * v17);
        }
        if (v18 != v15)
        {
          uint64_t v22 = v18[1];
          if (v22)
          {
            uint64_t v23 = *v16;
            sub_1CC34503C(a1, a2, v23, v22);
            return;
          }
        }
LABEL_19:
        unsigned int v99 = v16;
        unsigned int v109 = v111;
        uint64_t v110 = 0x800000000;
        uint64_t v24 = (char *)operator new(8uLL);
        int v25 = 0;
        __p = v24;
        *(void *)uint64_t v24 = 0;
        int v102 = v24 + 8;
        BOOL v103 = v24 + 8;
        v104[0] = 0;
        v104[1] = 0;
        unsigned int v105 = 0;
        uint64_t v100 = a2;
        uint64_t v106 = a2;
        unsigned int v26 = 1;
        unsigned int v117 = 64;
        v118[0] = a4;
        unsigned int v115 = v118;
        while (1)
        {
          uint64_t v108 = 0;
          uint64_t v27 = *((void *)v115 + v26 - 1);
          unsigned int v116 = v26 - 1;
          uint64_t v108 = v27;
          if (!v105) {
            break;
          }
          unsigned int v28 = (v105 - 1) & ((v27 >> 4) ^ (v27 >> 9));
          unint64_t v29 = (uint64_t *)(v104[0] + 72 * v28);
          uint64_t v30 = *v29;
          if (v27 != *v29)
          {
            int v31 = 0;
            int v32 = 1;
            while (v30 != -4096)
            {
              if (v31) {
                BOOL v33 = 0;
              }
              else {
                BOOL v33 = v30 == -8192;
              }
              if (v33) {
                int v31 = v29;
              }
              unsigned int v34 = v28 + v32++;
              unsigned int v28 = v34 & (v105 - 1);
              unint64_t v29 = (uint64_t *)(v104[0] + 72 * v28);
              uint64_t v30 = *v29;
              if (v27 == *v29) {
                goto LABEL_35;
              }
            }
            if (v31) {
              BOOL v35 = v31;
            }
            else {
              BOOL v35 = v29;
            }
            goto LABEL_34;
          }
LABEL_35:
          if (!*((_DWORD *)v29 + 2))
          {
            *((_DWORD *)v29 + 4) = ++v25;
            *((_DWORD *)v29 + 2) = v25;
            uint64_t v36 = v108;
            v29[3] = v108;
            unint64_t v37 = v102;
            if (v102 >= v103)
            {
              uint64_t v39 = (char *)__p;
              uint64_t v40 = (v102 - (unsigned char *)__p) >> 3;
              unint64_t v41 = v40 + 1;
              if ((unint64_t)(v40 + 1) >> 61) {
                abort();
              }
              uint64_t v42 = v103 - (unsigned char *)__p;
              if ((v103 - (unsigned char *)__p) >> 2 > v41) {
                unint64_t v41 = v42 >> 2;
              }
              if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v43 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v43 = v41;
              }
              if (v43)
              {
                if (v43 >> 61) {
                  sub_1CB833614();
                }
                int v44 = (char *)operator new(8 * v43);
              }
              else
              {
                int v44 = 0;
              }
              int v45 = (uint64_t *)&v44[8 * v40];
              *int v45 = v36;
              uint64_t v38 = (char *)(v45 + 1);
              if (v37 != v39)
              {
                do
                {
                  uint64_t v46 = *((void *)v37 - 1);
                  v37 -= 8;
                  *--int v45 = v46;
                }
                while (v37 != v39);
                unint64_t v37 = (char *)__p;
              }
              __p = v45;
              int v102 = v38;
              BOOL v103 = &v44[8 * v43];
              if (v37) {
                operator delete(v37);
              }
            }
            else
            {
              *(void *)int v102 = v36;
              uint64_t v38 = v37 + 8;
            }
            int v102 = v38;
            long long v47 = (uint64_t *)v114;
            if (v106)
            {
              sub_1CD517F18(*(void *)(v106 + 8), v108, (uint64_t)&v112);
              uint64_t v58 = v113;
              long long v47 = v112;
            }
            else
            {
              uint64_t v48 = *(void *)(v108 + 88);
              uint64_t v49 = *(void *)(v108 + 96);
              uint64_t v112 = (uint64_t *)v114;
              uint64_t v113 = 0x800000000;
              unint64_t v50 = v49 - v48;
              if ((unint64_t)(v49 - v48) >= 0x41) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              if (v49 != v48)
              {
                int v51 = v114;
                do
                {
                  uint64_t v52 = *(void *)(v49 - 8);
                  v49 -= 8;
                  *v51++ = v52;
                }
                while (v49 != v48);
                long long v47 = v112;
              }
              uint64_t v53 = v47;
              uint64_t v54 = (v50 >> 3);
              if (v54)
              {
                uint64_t v55 = 8 * v54;
                uint64_t v53 = v47;
                while (*v53)
                {
                  ++v53;
                  v55 -= 8;
                  if (!v55)
                  {
                    uint64_t v53 = &v47[v54];
                    break;
                  }
                }
              }
              uint64_t v56 = v53 - v47;
              if (v56 != v54)
              {
                int v84 = v53 + 1;
                if (v53 + 1 != &v47[v54])
                {
                  uint64_t v85 = 8 * v54 - 8 * v56 - 8;
                  do
                  {
                    if (*v84) {
                      *v53++ = *v84;
                    }
                    ++v84;
                    v85 -= 8;
                  }
                  while (v85);
                  long long v47 = v112;
                }
              }
              unint64_t v57 = (unint64_t)((char *)v53 - (char *)v47) >> 3;
              uint64_t v58 = v57;
              LODWORD(v113) = v57;
            }
            BOOL v59 = &v47[v58];
            if (v58)
            {
              while (1)
              {
                uint64_t v107 = 0;
                uint64_t v107 = *v47;
                BOOL v60 = sub_1CC2DD8D0(v104, v107);
                if ((uint64_t *)(v104[0] + 72 * v105) == v60 || !*((_DWORD *)v60 + 2)) {
                  break;
                }
                uint64_t v61 = v108;
                if (v107 != v108)
                {
                  uint64_t v63 = v60 + 6;
                  unint64_t v62 = *((unsigned int *)v60 + 12);
                  uint64_t v64 = v60 + 5;
                  goto LABEL_99;
                }
LABEL_102:
                if (++v47 == v59)
                {
                  long long v47 = v112;
                  goto LABEL_108;
                }
              }
              uint64_t v65 = v107;
              uint64_t v66 = *(void *)(a1 + 24);
              uint64_t v67 = *(unsigned int *)(a1 + 40);
              unsigned int v68 = v107 >> 4;
              if (v67)
              {
                LODWORD(v69) = (v68 ^ (v107 >> 9)) & (v67 - 1);
                int v70 = (uint64_t *)(v66 + 16 * v69);
                uint64_t v71 = *v70;
                if (*v70 != v107)
                {
                  int v72 = 1;
                  while (v71 != -4096)
                  {
                    int v73 = v69 + v72++;
                    uint64_t v69 = v73 & (v67 - 1);
                    uint64_t v71 = *(void *)(v66 + 16 * v69);
                    if (v71 == v107)
                    {
                      int v70 = (uint64_t *)(v66 + 16 * v69);
                      goto LABEL_78;
                    }
                  }
                  goto LABEL_77;
                }
              }
              else
              {
LABEL_77:
                int v70 = (uint64_t *)(v66 + 16 * v67);
              }
LABEL_78:
              if (v70 != (uint64_t *)(v66 + 16 * v67))
              {
                uint64_t v74 = v70[1];
                if (v74)
                {
                  if (v110 >= (unint64_t)HIDWORD(v110)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  long long v75 = (char *)v109 + 16 * v110;
                  *long long v75 = v108;
                  v75[1] = v74;
                  uint64_t v63 = &v110;
                  goto LABEL_101;
                }
              }
              if (v105)
              {
                unsigned int v76 = (v68 ^ (v107 >> 9)) & (v105 - 1);
                int v77 = (uint64_t *)(v104[0] + 72 * v76);
                uint64_t v78 = *v77;
                if (v107 != *v77)
                {
                  unsigned int v79 = 0;
                  int v80 = 1;
                  while (v78 != -4096)
                  {
                    if (v79) {
                      BOOL v81 = 0;
                    }
                    else {
                      BOOL v81 = v78 == -8192;
                    }
                    if (v81) {
                      unsigned int v79 = v77;
                    }
                    unsigned int v82 = v76 + v80++;
                    unsigned int v76 = v82 & (v105 - 1);
                    int v77 = (uint64_t *)(v104[0] + 72 * v76);
                    uint64_t v78 = *v77;
                    if (v107 == *v77) {
                      goto LABEL_97;
                    }
                  }
                  if (v79) {
                    uint64_t v83 = v79;
                  }
                  else {
                    uint64_t v83 = v77;
                  }
LABEL_96:
                  int v77 = sub_1CC2DD9E4((uint64_t)v104, (uint64_t)&v107, &v107, v83);
                  *int v77 = v107;
                  *(_OWORD *)(v77 + 5) = 0u;
                  *(_OWORD *)(v77 + 1) = 0u;
                  *(_OWORD *)(v77 + 3) = 0u;
                  *(_OWORD *)(v77 + 7) = 0u;
                  v77[5] = (uint64_t)(v77 + 7);
                  *((_DWORD *)v77 + 13) = 2;
                  uint64_t v65 = v107;
                }
LABEL_97:
                if (v116 >= (unint64_t)v117) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *((void *)v115 + v116) = v65;
                uint64_t v63 = v77 + 6;
                unint64_t v62 = *((unsigned int *)v77 + 12);
                ++v116;
                *((_DWORD *)v77 + 3) = v25;
                uint64_t v64 = v77 + 5;
                uint64_t v61 = v108;
LABEL_99:
                if (v62 >= *((unsigned int *)v63 + 1)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *(void *)(*v64 + 8 * v62) = v61;
LABEL_101:
                ++*(_DWORD *)v63;
                goto LABEL_102;
              }
              uint64_t v83 = 0;
              goto LABEL_96;
            }
LABEL_108:
            if (v47 != (uint64_t *)v114) {
              free(v47);
            }
          }
          unsigned int v26 = v116;
          if (!v116)
          {
            if (v115 != v118) {
              free(v115);
            }
            sub_1CC2DC6C4((uint64_t)&__p, a1, 0);
            sub_1CC2DCEC4((uint64_t)&__p, a1, v99);
            uint64_t v86 = v104[0];
            if (v105)
            {
              uint64_t v87 = v104[0] + 56;
              uint64_t v88 = 72 * v105;
              do
              {
                uint64_t v89 = *(void *)(v87 - 56);
                if (v89 != -4096 && v89 != -8192)
                {
                  int v90 = *(void **)(v87 - 16);
                  if ((void *)v87 != v90) {
                    free(v90);
                  }
                }
                v87 += 72;
                v88 -= 72;
              }
              while (v88);
              uint64_t v86 = v104[0];
            }
            MEMORY[0x1D25D9CD0](v86, 8);
            if (__p)
            {
              int v102 = (char *)__p;
              operator delete(__p);
            }
            uint64_t v91 = (char *)v109;
            if (v110)
            {
              unint64_t v92 = (char *)v109 + 16 * v110;
              do
              {
                uint64_t v93 = *(void *)(a1 + 24);
                int v94 = *(_DWORD *)(a1 + 40) - 1;
                LODWORD(v95) = ((*(void *)v91 >> 4) ^ (*(void *)v91 >> 9)) & v94;
                uint64_t v96 = v93 + 16 * v95;
                if (*(void *)v91 != *(void *)v96)
                {
                  int v97 = 1;
                  do
                  {
                    int v98 = v95 + v97++;
                    uint64_t v95 = v98 & v94;
                  }
                  while (*(void *)v91 != *(void *)(v93 + 16 * v95));
                  uint64_t v96 = v93 + 16 * v95;
                }
                sub_1CC34503C(a1, v100, **(void **)(v96 + 8), *((void *)v91 + 1));
                v91 += 16;
              }
              while (v91 != v92);
              uint64_t v91 = (char *)v109;
            }
            if (v91 != v111) {
              free(v91);
            }
            return;
          }
        }
        BOOL v35 = 0;
LABEL_34:
        unint64_t v29 = sub_1CC2DD9E4((uint64_t)v104, (uint64_t)&v108, &v108, v35);
        uint64_t *v29 = v108;
        *(_OWORD *)(v29 + 5) = 0u;
        *(_OWORD *)(v29 + 1) = 0u;
        *(_OWORD *)(v29 + 3) = 0u;
        *(_OWORD *)(v29 + 7) = 0u;
        v29[5] = (uint64_t)(v29 + 7);
        *((_DWORD *)v29 + 13) = 2;
        goto LABEL_35;
      }
    }
  }
}

uint64_t sub_1CC343350(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(result + 24);
  uint64_t v5 = *(unsigned int *)(result + 40);
  if (v5)
  {
    unsigned int v6 = v5 - 1;
    LODWORD(v7) = (v5 - 1) & ((a3 >> 4) ^ (a3 >> 9));
    uint64_t v8 = (uint64_t *)(v4 + 16 * v7);
    uint64_t v9 = *v8;
    if (*v8 == a3)
    {
LABEL_7:
      uint64_t v12 = (uint64_t *)(v4 + 16 * v5);
      if (v8 != v12 && v8[1])
      {
        LODWORD(v13) = v6 & ((a4 >> 4) ^ (a4 >> 9));
        int v14 = (uint64_t *)(v4 + 16 * v13);
        uint64_t v15 = *v14;
        if (*v14 == a4)
        {
LABEL_14:
          if (v14 != v12)
          {
            if (v14[1]) {
              llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::findNearestCommonDominator();
            }
          }
        }
        else
        {
          int v16 = 1;
          while (v15 != -4096)
          {
            int v17 = v13 + v16++;
            uint64_t v13 = v17 & v6;
            uint64_t v15 = *(void *)(v4 + 16 * v13);
            if (v15 == a4)
            {
              int v14 = (uint64_t *)(v4 + 16 * v13);
              goto LABEL_14;
            }
          }
        }
      }
    }
    else
    {
      int v10 = 1;
      while (v9 != -4096)
      {
        int v11 = v7 + v10++;
        uint64_t v7 = v11 & v6;
        uint64_t v9 = *(void *)(v4 + 16 * v7);
        if (v9 == a3)
        {
          uint64_t v8 = (uint64_t *)(v4 + 16 * v7);
          goto LABEL_7;
        }
      }
    }
  }
  return result;
}

void sub_1CC344FB8(_DWORD *a1, uint64_t a2)
{
  uint64_t v7 = 0;
  if (sub_1CC3422C8((uint64_t)a1, a2, &v7))
  {
    uint64_t v3 = 0;
    uint64_t v4 = v7;
    do
    {
      uint64_t v5 = (void *)v4[v3 + 5];
      if (&v4[v3 + 7] != v5) {
        free(v5);
      }
      v3 -= 4;
    }
    while (v3 != -8);
    *uint64_t v4 = -8192;
    int v6 = a1[1] + 1;
    *a1 -= 2;
    a1[1] = v6;
  }
}

void sub_1CC34503C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v96[8] = *MEMORY[0x1E4F143B8];
  uint64_t v75 = a4;
  if (a3 && *(void *)a4) {
    llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::findNearestCommonDominator();
  }
  uint64_t v6 = *(unsigned int *)(a1 + 40);
  if (!v6) {
    goto LABEL_12;
  }
  uint64_t v7 = *(void **)(a1 + 24);
  LODWORD(v8) = 0;
  uint64_t v9 = v7;
  uint64_t v10 = *v7;
  if (*v7)
  {
    int v11 = 1;
    while (v10 != -4096)
    {
      int v12 = v8 + v11++;
      uint64_t v8 = v12 & (v6 - 1);
      uint64_t v10 = v7[2 * v8];
      if (!v10)
      {
        uint64_t v9 = &v7[2 * v8];
        goto LABEL_10;
      }
    }
    goto LABEL_12;
  }
LABEL_10:
  if (v9 == &v7[2 * v6])
  {
LABEL_12:
    uint64_t v13 = 0;
    goto LABEL_13;
  }
  uint64_t v13 = v9[1];
LABEL_13:
  unsigned int v14 = *(_DWORD *)(v13 + 16) + 1;
  if (v14 >= *(_DWORD *)(a4 + 16)) {
    return;
  }
  uint64_t v83 = v85;
  uint64_t v84 = 0x800000001;
  uint64_t v86 = 1;
  int64x2_t v87 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  int64x2_t v88 = v87;
  int64x2_t v89 = v87;
  int64x2_t v90 = v87;
  uint64_t v91 = v93;
  uint64_t v92 = 0x800000000;
  int v94 = v96;
  uint64_t v95 = 0x800000000;
  int v80 = v82;
  uint64_t v81 = 0x800000000;
  v85[0] = a4;
  sub_1CC3458E8((uint64_t)&v86, &v75, (uint64_t)&v77);
  unsigned int v15 = v84;
  if (!v84) {
    goto LABEL_81;
  }
  do
  {
    int v16 = v83;
    uint64_t v17 = *(void *)v83;
    uint64_t v18 = v15;
    if (v15 != 1)
    {
      uint64_t v19 = 0;
      int v20 = (char *)v83 + 8 * v15;
      int64_t v21 = ((unint64_t)v15 - 2) >> 1;
      uint64_t v22 = v83;
      do
      {
        uint64_t v23 = &v22[v19];
        uint64_t v26 = v23[1];
        uint64_t v24 = (char *)(v23 + 1);
        uint64_t v25 = v26;
        uint64_t v27 = (2 * v19) | 1;
        uint64_t v28 = 2 * v19 + 2;
        if (v28 < v18 && *(_DWORD *)(v25 + 16) < *(_DWORD *)(*((void *)v24 + 1) + 16))
        {
          uint64_t v25 = *((void *)v24 + 1);
          v24 += 8;
          uint64_t v27 = v28;
        }
        *uint64_t v22 = v25;
        uint64_t v22 = v24;
        uint64_t v19 = v27;
      }
      while (v27 <= v21);
      unint64_t v29 = v20 - 8;
      if (v24 == v29)
      {
        *(void *)uint64_t v24 = v17;
      }
      else
      {
        *(void *)uint64_t v24 = *(void *)v29;
        *(void *)unint64_t v29 = v17;
        uint64_t v30 = v24 - v16 + 8;
        if (v30 >= 9)
        {
          unint64_t v31 = (((unint64_t)v30 >> 3) - 2) >> 1;
          int v32 = &v16[8 * v31];
          uint64_t v33 = *(void *)v32;
          uint64_t v34 = *(void *)v24;
          unsigned int v35 = *(_DWORD *)(*(void *)v24 + 16);
          if (*(_DWORD *)(*(void *)v32 + 16) < v35)
          {
            do
            {
              uint64_t v36 = v32;
              *(void *)uint64_t v24 = v33;
              if (!v31) {
                break;
              }
              unint64_t v31 = (v31 - 1) >> 1;
              int v32 = &v16[8 * v31];
              uint64_t v33 = *(void *)v32;
              uint64_t v24 = v36;
            }
            while (*(_DWORD *)(*(void *)v32 + 16) < v35);
            *(void *)uint64_t v36 = v34;
          }
        }
      }
    }
    LODWORD(v84) = v18 - 1;
    if (v92 >= (unint64_t)HIDWORD(v92)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v91 + v92) = v17;
    LODWORD(v92) = v92 + 1;
    unsigned int v37 = *(_DWORD *)(v17 + 16);
    while (2)
    {
      uint64_t v38 = *(void *)v17;
      if (a2)
      {
        sub_1CD517F18(*(void *)(a2 + 8), v38, (uint64_t)&v77);
        uint64_t v42 = v77;
        uint64_t v50 = v78;
      }
      else
      {
        uint64_t v40 = *(void *)(v38 + 88);
        uint64_t v39 = *(void *)(v38 + 96);
        int v77 = v79;
        uint64_t v78 = 0x800000000;
        unint64_t v41 = v39 - v40;
        if ((unint64_t)(v39 - v40) >= 0x41) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        uint64_t v42 = v79;
        if (v39 != v40)
        {
          unint64_t v43 = v79;
          do
          {
            uint64_t v44 = *(void *)(v39 - 8);
            v39 -= 8;
            *v43++ = v44;
          }
          while (v39 != v40);
          uint64_t v42 = v77;
        }
        int v45 = v42;
        uint64_t v46 = (v41 >> 3);
        if (v46)
        {
          uint64_t v47 = 8 * v46;
          int v45 = v42;
          while (*v45)
          {
            ++v45;
            v47 -= 8;
            if (!v47)
            {
              int v45 = &v42[v46];
              break;
            }
          }
        }
        uint64_t v48 = v45 - v42;
        if (v48 != v46)
        {
          int v72 = v45 + 1;
          if (v45 + 1 != &v42[v46])
          {
            uint64_t v73 = 8 * v46 - 8 * v48 - 8;
            do
            {
              if (*v72) {
                *v45++ = *v72;
              }
              ++v72;
              v73 -= 8;
            }
            while (v73);
            uint64_t v42 = v77;
          }
        }
        unint64_t v49 = (unint64_t)((char *)v45 - (char *)v42) >> 3;
        uint64_t v50 = v49;
        LODWORD(v78) = v49;
      }
      int v51 = &v42[v50];
      if (!v50) {
        goto LABEL_66;
      }
      do
      {
        uint64_t v52 = *v42;
        uint64_t v74 = 0;
        uint64_t v53 = *(void *)(a1 + 24);
        uint64_t v54 = *(unsigned int *)(a1 + 40);
        if (!v54) {
          goto LABEL_50;
        }
        LODWORD(v55) = (v54 - 1) & ((v52 >> 4) ^ (v52 >> 9));
        uint64_t v56 = (uint64_t *)(v53 + 16 * v55);
        uint64_t v57 = *v56;
        if (v52 != *v56)
        {
          int v58 = 1;
          while (v57 != -4096)
          {
            int v59 = v55 + v58++;
            uint64_t v55 = v59 & (v54 - 1);
            uint64_t v57 = *(void *)(v53 + 16 * v55);
            if (v52 == v57)
            {
              uint64_t v56 = (uint64_t *)(v53 + 16 * v55);
              goto LABEL_51;
            }
          }
LABEL_50:
          uint64_t v56 = (uint64_t *)(v53 + 16 * v54);
        }
LABEL_51:
        uint64_t v74 = v56[1];
        unsigned int v60 = *(_DWORD *)(v74 + 16);
        if (v60 > v14)
        {
          sub_1CC3458E8((uint64_t)&v86, &v74, (uint64_t)v76);
          if (v76[16])
          {
            if (v60 <= v37)
            {
              if (v84 >= (unint64_t)HIDWORD(v84)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v83 + v84) = v74;
              uint64_t v61 = (v84 + 1);
              LODWORD(v84) = v61;
              if (v61 >= 2)
              {
                unint64_t v62 = (char *)v83;
                uint64_t v63 = (char *)v83 + 8 * v61;
                unint64_t v64 = (unint64_t)(v61 - 2) >> 1;
                uint64_t v65 = (char *)v83 + 8 * v64;
                uint64_t v66 = *(void *)v65;
                uint64_t v69 = *((void *)v63 - 1);
                unsigned int v68 = v63 - 8;
                uint64_t v67 = v69;
                unsigned int v70 = *(_DWORD *)(v69 + 16);
                if (*(_DWORD *)(*(void *)v65 + 16) < v70)
                {
                  do
                  {
                    uint64_t v71 = v65;
                    *(void *)unsigned int v68 = v66;
                    if (!v64) {
                      break;
                    }
                    unint64_t v64 = (v64 - 1) >> 1;
                    uint64_t v65 = &v62[8 * v64];
                    uint64_t v66 = *(void *)v65;
                    unsigned int v68 = v71;
                  }
                  while (*(_DWORD *)(*(void *)v65 + 16) < v70);
                  *(void *)uint64_t v71 = v67;
                }
              }
            }
            else
            {
              if (v81 >= (unint64_t)HIDWORD(v81)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v80 + v81) = v74;
              LODWORD(v81) = v81 + 1;
            }
          }
        }
        ++v42;
      }
      while (v42 != v51);
      uint64_t v42 = v77;
LABEL_66:
      if (v42 != (void *)v79) {
        free(v42);
      }
      if (v81)
      {
        uint64_t v17 = *((void *)v80 + v81 - 1);
        LODWORD(v81) = v81 - 1;
        continue;
      }
      break;
    }
    unsigned int v15 = v84;
  }
  while (v84);
LABEL_81:
  if (v92) {
    llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::setIDom();
  }
  if (v80 != v82) {
    free(v80);
  }
  if (v94 != v96) {
    free(v94);
  }
  if (v91 != v93) {
    free(v91);
  }
  if ((v86 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v87.i64[0], 8);
  }
  if (v83 != v85) {
    free(v83);
  }
}

uint64_t sub_1CC34574C(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    uint64_t v6 = (void *)(a1 + 72 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v12 = 1;
    }
    else
    {
      uint64_t v8 = 0;
      int v9 = 1;
      while (v7 != -4096)
      {
        if (v8) {
          BOOL v10 = 0;
        }
        else {
          BOOL v10 = v7 == -8192;
        }
        if (v10) {
          uint64_t v8 = v6;
        }
        unsigned int v11 = v5 + v9++;
        unsigned int v5 = v11 & v4;
        uint64_t v6 = (void *)(a1 + 72 * (v11 & v4));
        uint64_t v7 = *v6;
        uint64_t v12 = 1;
        if (*v6 == a3) {
          goto LABEL_13;
        }
      }
      uint64_t v12 = 0;
      if (v8) {
        uint64_t v6 = v8;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v12 = 0;
  }
LABEL_13:
  *a4 = v6;
  return v12;
}

uint64_t sub_1CC3457E4(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 24);
  if (v2)
  {
    uint64_t v4 = 72 * v2;
    unsigned int v5 = (void *)(v3 + 56);
    do
    {
      uint64_t v6 = *(v5 - 7);
      if (v6 != -4096 && v6 != -8192)
      {
        uint64_t v7 = (void *)*(v5 - 2);
        if (v5 != v7) {
          free(v7);
        }
      }
      v5 += 9;
      v4 -= 72;
    }
    while (v4);
    uint64_t v3 = *(void *)(a1 + 24);
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  uint64_t v8 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v8;
    operator delete(v8);
  }
  return a1;
}

void sub_1CC34587C(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = 72 * v1;
    uint64_t v3 = *(void *)a1 + 56;
    do
    {
      uint64_t v4 = *(void *)(v3 - 56);
      if (v4 != -4096 && v4 != -8192)
      {
        unsigned int v5 = *(void **)(v3 - 16);
        if ((void *)v3 != v5) {
          free(v5);
        }
      }
      v3 += 72;
      v2 -= 72;
    }
    while (v2);
  }
}

void *sub_1CC3458E8@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v14 = 0;
  uint64_t result = (void *)sub_1CC3459A4(a1, a2, &v14);
  uint64_t v7 = v14;
  if (result)
  {
    uint64_t v8 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v9 = 8;
    }
    else
    {
      uint64_t v8 = *(void *)(a1 + 8);
      uint64_t v9 = *(unsigned int *)(a1 + 16);
    }
    char v12 = 0;
    uint64_t v13 = v8 + 8 * v9;
  }
  else
  {
    uint64_t result = sub_1CC345A54((_DWORD *)a1, (uint64_t)a2, a2, v14);
    uint64_t v7 = result;
    *uint64_t result = *a2;
    uint64_t v10 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v11 = 8;
    }
    else
    {
      uint64_t v10 = *(void *)(a1 + 8);
      uint64_t v11 = *(unsigned int *)(a1 + 16);
    }
    uint64_t v13 = v10 + 8 * v11;
    char v12 = 1;
  }
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v13;
  *(unsigned char *)(a3 + 16) = v12;
  return result;
}

uint64_t sub_1CC3459A4(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 8;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  uint64_t v7 = (void *)(v3 + 8 * v6);
  uint64_t v8 = *v7;
  if (*a2 == *v7)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 8 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    if (v10) {
      uint64_t v7 = v10;
    }
  }
LABEL_7:
  *a3 = v7;
  return result;
}

void *sub_1CC345A54(_DWORD *a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *a1 >> 1;
  if (*a1) {
    unsigned int v7 = 8;
  }
  else {
    unsigned int v7 = a1[4];
  }
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - a1[1] > v7 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CC345B14((uint64_t)a1, v7);
  uint64_t v9 = 0;
  sub_1CC3459A4((uint64_t)a1, a3, &v9);
  a4 = v9;
LABEL_6:
  *a1 += 2;
  if (*a4 != -4096) {
    --a1[1];
  }
  return a4;
}

uint64_t sub_1CC345B14(uint64_t a1, unsigned int a2)
{
  v14[8] = *MEMORY[0x1E4F143B8];
  if (a2 >= 9)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    int v6 = *(void **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 8)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CC345C90(a1, v6, &v6[v7]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = v14;
  for (uint64_t i = 8; i != 72; i += 8)
  {
    uint64_t v10 = *(void *)(a1 + i);
    if ((v10 | 0x1000) != 0xFFFFFFFFFFFFF000) {
      *v8++ = v10;
    }
  }
  if (a2 > 8)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CC345C90(a1, v14, v8);
}

uint64_t sub_1CC345C90(uint64_t result, void *a2, void *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 72);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[v7];
  }
  do
    *v8++ = -4096;
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v10 = 0;
      uint64_t result = sub_1CC3459A4((uint64_t)v5, a2, &v10);
      *uint64_t v10 = *a2;
      *v5 += 2;
    }
    ++a2;
  }
  return result;
}

uint64_t *sub_1CC345D50(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = (uint64_t)(a1 + 3);
  uint64_t v6 = a1[3];
  uint64_t v8 = *a1;
  uint64_t v9 = (uint64_t *)(*a1 + 8);
  int v10 = *((_DWORD *)a1 + 10);
  if (v10)
  {
    int v11 = v10 - 1;
    unsigned int v12 = ((*v9 >> 4) ^ (*v9 >> 9)) & v11;
    uint64_t result = (uint64_t *)(v6 + 72 * v12);
    uint64_t v14 = *result;
    if (*v9 == *result) {
      goto LABEL_16;
    }
    unsigned int v15 = 0;
    int v16 = 1;
    while (v14 != -4096)
    {
      if (v15) {
        BOOL v17 = 0;
      }
      else {
        BOOL v17 = v14 == -8192;
      }
      if (v17) {
        unsigned int v15 = result;
      }
      unsigned int v18 = v12 + v16++;
      unsigned int v12 = v18 & v11;
      uint64_t result = (uint64_t *)(v6 + 72 * v12);
      uint64_t v14 = *result;
      if (*v9 == *result) {
        goto LABEL_16;
      }
    }
    if (v15) {
      uint64_t v19 = v15;
    }
    else {
      uint64_t v19 = result;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  uint64_t result = sub_1CC2DD9E4(v7, (uint64_t)v9, v9, v19);
  *uint64_t result = *v9;
  *(_OWORD *)(result + 5) = 0u;
  *(_OWORD *)(result + 3) = 0u;
  *(_OWORD *)(result + 1) = 0u;
  *(_OWORD *)(result + 7) = 0u;
  result[5] = (uint64_t)(result + 7);
  *((_DWORD *)result + 13) = 2;
  uint64_t v8 = *a1;
LABEL_16:
  result[4] = a3;
  if (a1[1] - v8 != 8)
  {
    uint64_t v45 = 0;
    uint64_t v20 = *(void *)(*a1 + 8);
    uint64_t v45 = v20;
    uint64_t v21 = *(void *)(a2 + 24);
    int v22 = *(_DWORD *)(a2 + 40);
    unsigned int v23 = v20 >> 4;
    if (v22)
    {
      unsigned int v24 = (v23 ^ (v20 >> 9)) & (v22 - 1);
      uint64_t v25 = *(void *)(v21 + 16 * v24);
      if (v20 != v25)
      {
        int v26 = 1;
        do
        {
          if (v25 == -4096) {
            break;
          }
          unsigned int v27 = v24 + v26++;
          unsigned int v24 = v27 & (v22 - 1);
          uint64_t v25 = *(void *)(v21 + 16 * v24);
        }
        while (v20 != v25);
      }
    }
    int v28 = *((_DWORD *)a1 + 10);
    if (v28)
    {
      uint64_t v29 = a1[3];
      unsigned int v30 = v23 ^ (v20 >> 9);
      int v31 = v28 - 1;
      unsigned int v32 = (v28 - 1) & v30;
      uint64_t v33 = (uint64_t *)(v29 + 72 * v32);
      uint64_t v34 = *v33;
      if (v20 == *v33)
      {
LABEL_32:
        if (!v22) {
          goto LABEL_37;
        }
LABEL_33:
        uint64_t v39 = v33[4];
        unsigned int v40 = ((v39 >> 4) ^ (v39 >> 9)) & (v22 - 1);
        uint64_t v41 = *(void *)(v21 + 16 * v40);
        if (v39 != v41)
        {
          int v42 = 1;
          do
          {
            if (v41 == -4096) {
              break;
            }
            unsigned int v43 = v40 + v42++;
            unsigned int v40 = v43 & (v22 - 1);
            uint64_t v41 = *(void *)(v21 + 16 * v40);
          }
          while (v39 != v41);
        }
LABEL_37:
        llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::setIDom();
      }
      unsigned int v35 = 0;
      int v36 = 1;
      while (v34 != -4096)
      {
        if (v35) {
          BOOL v37 = 0;
        }
        else {
          BOOL v37 = v34 == -8192;
        }
        if (v37) {
          unsigned int v35 = v33;
        }
        unsigned int v38 = v32 + v36++;
        unsigned int v32 = v38 & v31;
        uint64_t v33 = (uint64_t *)(v29 + 72 * v32);
        uint64_t v34 = *v33;
        if (v20 == *v33) {
          goto LABEL_32;
        }
      }
      if (v35) {
        uint64_t v44 = v35;
      }
      else {
        uint64_t v44 = v33;
      }
    }
    else
    {
      uint64_t v44 = 0;
    }
    uint64_t v33 = sub_1CC2DD9E4(v7, (uint64_t)&v45, &v45, v44);
    *uint64_t v33 = v45;
    *(_OWORD *)(v33 + 5) = 0u;
    *(_OWORD *)(v33 + 1) = 0u;
    *(_OWORD *)(v33 + 3) = 0u;
    *(_OWORD *)(v33 + 7) = 0u;
    v33[5] = (uint64_t)(v33 + 7);
    *((_DWORD *)v33 + 13) = 2;
    uint64_t v21 = *(void *)(a2 + 24);
    int v22 = *(_DWORD *)(a2 + 40);
    if (!v22) {
      goto LABEL_37;
    }
    goto LABEL_33;
  }
  return result;
}

unsigned char *sub_1CC346054(unsigned int *a1, uint64_t a2, long long *__src, long long *a4)
{
  int v5 = __src;
  uint64_t v7 = *(void *)a1;
  uint64_t v8 = (a2 - *(void *)a1) >> 4;
  uint64_t v9 = a1[2];
  if (*(void *)a1 + 16 * v9 == a2)
  {
    sub_1CD3D61B4(a1, __src, a4);
    return (unsigned char *)(*(void *)a1 + 16 * v8);
  }
  else
  {
    unint64_t v10 = a4 - __src;
    if (v9 + v10 > a1[3]) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    int v11 = (unsigned char *)(v7 + 16 * v8);
    unsigned int v12 = (unsigned char *)(v7 + 16 * v9);
    unint64_t v13 = (v12 - v11) >> 4;
    if (v13 >= v10)
    {
      sub_1CD3E56A0((uint64_t)a1, &v12[-16 * v10], (char *)(v7 + 16 * v9));
      if (&v12[-16 * v10] != v11) {
        memmove(&v11[16 * v10], v11, &v12[-16 * v10] - v11);
      }
      if (v5 != a4) {
        memmove(v11, v5, (char *)a4 - (char *)v5);
      }
    }
    else
    {
      unsigned int v14 = v9 + ((unint64_t)((char *)a4 - (char *)__src) >> 4);
      a1[2] = v14;
      if (v8 != v9)
      {
        memcpy((void *)(v7 + 16 * v14 - 16 * v13), v11, v12 - v11);
        unsigned int v15 = v11;
        do
        {
          long long v16 = *v5++;
          *v15++ = v16;
          --v13;
        }
        while (v13);
      }
      if (v5 != a4) {
        memcpy(v12, v5, (char *)a4 - (char *)v5);
      }
    }
  }
  return v11;
}

void sub_1CC3461B4(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  v2[0] = v3;
  v2[1] = (void *)0x100000000;
  int v8 = 0;
  v3[1] = 0;
  void v3[2] = 0;
  int v4 = 0;
  char v7 = 0;
  uint64_t v1 = *(void *)(a1 + 56);
  uint64_t v5 = 0;
  uint64_t v6 = v1;
  sub_1CC2DC400((uint64_t)v2, 0);
  llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::compare();
}

uint64_t *sub_1CC3463C4(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *result;
  unsigned int v5 = *(_DWORD *)(*a2 + 72);
  unsigned int v6 = *(_DWORD *)(*result + 72);
  uint64_t v7 = *a3;
  unsigned int v8 = *(_DWORD *)(*a3 + 72);
  if (v5 >= v6)
  {
    if (v8 < v5)
    {
      *a2 = v7;
      *a3 = v3;
      uint64_t v9 = *result;
      if (*(_DWORD *)(*a2 + 72) < *(_DWORD *)(*result + 72))
      {
        *uint64_t result = *a2;
        *a2 = v9;
      }
    }
  }
  else
  {
    if (v8 >= v5)
    {
      *uint64_t result = v3;
      *a2 = v4;
      if (*(_DWORD *)(*a3 + 72) >= v6) {
        return result;
      }
      *a2 = *a3;
    }
    else
    {
      *uint64_t result = v7;
    }
    *a3 = v4;
  }
  return result;
}

uint64_t *sub_1CC34644C(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  unsigned int v3 = *(_DWORD *)(*a1 + 72);
  if (v3 >= *(_DWORD *)(*(a2 - 1) + 72))
  {
    unsigned int v6 = a1 + 1;
    do
    {
      uint64_t v4 = v6;
      if (v6 >= a2) {
        break;
      }
      ++v6;
    }
    while (v3 >= *(_DWORD *)(*v4 + 72));
  }
  else
  {
    uint64_t v4 = a1;
    do
    {
      uint64_t v5 = v4[1];
      ++v4;
    }
    while (v3 >= *(_DWORD *)(v5 + 72));
  }
  if (v4 < a2)
  {
    do
      uint64_t v7 = *--a2;
    while (v3 < *(_DWORD *)(v7 + 72));
  }
  if (v4 < a2)
  {
    uint64_t v8 = *v4;
    uint64_t v9 = *a2;
    do
    {
      *uint64_t v4 = v9;
      *a2 = v8;
      do
      {
        uint64_t v10 = v4[1];
        ++v4;
        uint64_t v8 = v10;
      }
      while (v3 >= *(_DWORD *)(v10 + 72));
      do
      {
        uint64_t v11 = *--a2;
        uint64_t v9 = v11;
      }
      while (v3 < *(_DWORD *)(v11 + 72));
    }
    while (v4 < a2);
  }
  if (v4 - 1 != a1) {
    *a1 = *(v4 - 1);
  }
  *(v4 - 1) = v2;
  return v4;
}

void *sub_1CC346518(void *a1, void *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = *a1;
  unsigned int v4 = *(_DWORD *)(*a1 + 72);
  do
    uint64_t v5 = a1[++v2];
  while (*(_DWORD *)(v5 + 72) < v4);
  unint64_t v6 = (unint64_t)&a1[v2];
  uint64_t v7 = &a1[v2 - 1];
  if (v2 == 1)
  {
    do
    {
      if (v6 >= (unint64_t)a2) {
        break;
      }
      uint64_t v9 = *--a2;
    }
    while (*(_DWORD *)(v9 + 72) >= v4);
  }
  else
  {
    do
      uint64_t v8 = *--a2;
    while (*(_DWORD *)(v8 + 72) >= v4);
  }
  if (v6 < (unint64_t)a2)
  {
    uint64_t v10 = *a2;
    uint64_t v11 = &a1[v2];
    unsigned int v12 = a2;
    do
    {
      *uint64_t v11 = v10;
      *unsigned int v12 = v5;
      do
      {
        uint64_t v13 = v11[1];
        ++v11;
        uint64_t v5 = v13;
      }
      while (*(_DWORD *)(v13 + 72) < v4);
      do
      {
        uint64_t v14 = *--v12;
        uint64_t v10 = v14;
      }
      while (*(_DWORD *)(v14 + 72) >= v4);
    }
    while (v11 < v12);
    uint64_t v7 = v11 - 1;
  }
  if (v7 != a1) {
    *a1 = *v7;
  }
  *uint64_t v7 = v3;
  return v7;
}

BOOL sub_1CC3465E4(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(a2 - 1);
      uint64_t v7 = *a1;
      if (*(_DWORD *)(v6 + 72) < *(_DWORD *)(*a1 + 72))
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      sub_1CC3463C4(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      sub_1CC346778(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      sub_1CC346810(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      uint64_t v8 = a1 + 2;
      sub_1CC3463C4(a1, a1 + 1, a1 + 2);
      uint64_t v9 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v10 = 0;
      uint64_t v11 = 24;
      break;
  }
  while (1)
  {
    uint64_t v12 = *v9;
    uint64_t v13 = *v8;
    unsigned int v14 = *(_DWORD *)(*v9 + 72);
    if (v14 < *(_DWORD *)(*v8 + 72))
    {
      uint64_t v15 = v11;
      while (1)
      {
        *(uint64_t *)((char *)a1 + v15) = v13;
        uint64_t v16 = v15 - 8;
        if (v15 == 8) {
          break;
        }
        uint64_t v13 = *(uint64_t *)((char *)a1 + v15 - 16);
        v15 -= 8;
        if (v14 >= *(_DWORD *)(v13 + 72))
        {
          BOOL v17 = (uint64_t *)((char *)a1 + v16);
          goto LABEL_12;
        }
      }
      BOOL v17 = a1;
LABEL_12:
      uint64_t *v17 = v12;
      if (++v10 == 8) {
        return v9 + 1 == a2;
      }
    }
    uint64_t v8 = v9;
    v11 += 8;
    if (++v9 == a2) {
      return 1;
    }
  }
}

uint64_t *sub_1CC346778(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  BOOL result = sub_1CC3463C4(a1, a2, a3);
  uint64_t v9 = *a3;
  if (*(_DWORD *)(*a4 + 72) < *(_DWORD *)(*a3 + 72))
  {
    *a3 = *a4;
    *a4 = v9;
    uint64_t v10 = *a2;
    if (*(_DWORD *)(*a3 + 72) < *(_DWORD *)(*a2 + 72))
    {
      *a2 = *a3;
      *a3 = v10;
      uint64_t v11 = *a1;
      if (*(_DWORD *)(*a2 + 72) < *(_DWORD *)(*a1 + 72))
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

uint64_t *sub_1CC346810(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  BOOL result = sub_1CC346778(a1, a2, a3, a4);
  uint64_t v11 = *a4;
  if (*(_DWORD *)(*a5 + 72) < *(_DWORD *)(*a4 + 72))
  {
    *a4 = *a5;
    *a5 = v11;
    uint64_t v12 = *a3;
    if (*(_DWORD *)(*a4 + 72) < *(_DWORD *)(*a3 + 72))
    {
      *a3 = *a4;
      *a4 = v12;
      uint64_t v13 = *a2;
      if (*(_DWORD *)(*a3 + 72) < *(_DWORD *)(*a2 + 72))
      {
        *a2 = *a3;
        *a3 = v13;
        uint64_t v14 = *a1;
        if (*(_DWORD *)(*a2 + 72) < *(_DWORD *)(*a1 + 72))
        {
          *a1 = *a2;
          *a2 = v14;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1CC3468D4(uint64_t result, void *a2, void *a3)
{
  if ((void *)result != a2)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (void *)result;
    uint64_t v6 = (uint64_t)a2 - result;
    uint64_t v7 = ((uint64_t)a2 - result) >> 3;
    if ((uint64_t)a2 - result >= 9)
    {
      unint64_t v8 = (unint64_t)(v7 - 2) >> 1;
      unint64_t v9 = v8 + 1;
      uint64_t v10 = (void *)(result + 8 * v8);
      do
      {
        BOOL result = sub_1CC346AAC((uint64_t)v5, v7, v10--);
        --v9;
      }
      while (v9);
    }
    if (v4 != a3)
    {
      uint64_t v11 = v4;
      do
      {
        uint64_t v12 = *v11;
        if (*(_DWORD *)(*v11 + 72) < *(_DWORD *)(*v5 + 72))
        {
          *uint64_t v11 = *v5;
          *uint64_t v5 = v12;
          BOOL result = sub_1CC346AAC((uint64_t)v5, v7, v5);
        }
        ++v11;
      }
      while (v11 != a3);
    }
    if (v6 >= 9)
    {
      do
      {
        uint64_t v13 = 0;
        uint64_t v14 = *v5;
        uint64_t v15 = v5;
        do
        {
          uint64_t v16 = &v15[v13];
          uint64_t v19 = v16[1];
          BOOL v17 = v16 + 1;
          uint64_t v18 = v19;
          uint64_t v20 = (2 * v13) | 1;
          uint64_t v21 = 2 * v13 + 2;
          if (v21 < v7)
          {
            BOOL result = *(unsigned int *)(v17[1] + 72);
            if (*(_DWORD *)(v18 + 72) < result)
            {
              uint64_t v18 = v17[1];
              ++v17;
              uint64_t v20 = v21;
            }
          }
          void *v15 = v18;
          uint64_t v15 = v17;
          uint64_t v13 = v20;
        }
        while (v20 <= (uint64_t)((unint64_t)(v7 - 2) >> 1));
        if (v17 == --v4)
        {
          void *v17 = v14;
        }
        else
        {
          void *v17 = *v4;
          *uint64_t v4 = v14;
          uint64_t v22 = (char *)v17 - (char *)v5 + 8;
          if (v22 >= 9)
          {
            unint64_t v23 = (((unint64_t)v22 >> 3) - 2) >> 1;
            unsigned int v24 = &v5[v23];
            uint64_t v25 = *v24;
            uint64_t v26 = *v17;
            unsigned int v27 = *(_DWORD *)(*v17 + 72);
            if (*(_DWORD *)(*v24 + 72) < v27)
            {
              do
              {
                int v28 = v24;
                void *v17 = v25;
                if (!v23) {
                  break;
                }
                unint64_t v23 = (v23 - 1) >> 1;
                unsigned int v24 = &v5[v23];
                uint64_t v25 = *v24;
                BOOL v17 = v28;
              }
              while (*(_DWORD *)(*v24 + 72) < v27);
              *int v28 = v26;
            }
          }
        }
      }
      while (v7-- > 2);
    }
  }
  return result;
}

uint64_t sub_1CC346AAC(uint64_t result, uint64_t a2, void *a3)
{
  if (a2 >= 2)
  {
    uint64_t v3 = (uint64_t)a3 - result;
    int64_t v4 = (unint64_t)(a2 - 2) >> 1;
    if (v4 >= ((uint64_t)a3 - result) >> 3)
    {
      uint64_t v5 = v3 >> 2;
      uint64_t v6 = (v3 >> 2) + 1;
      uint64_t v7 = (void *)(result + 8 * v6);
      uint64_t v8 = v5 + 2;
      uint64_t v9 = *v7;
      if (v8 < a2 && *(_DWORD *)(v9 + 72) < *(_DWORD *)(v7[1] + 72))
      {
        uint64_t v9 = v7[1];
        ++v7;
        uint64_t v6 = v8;
      }
      uint64_t v10 = *a3;
      unsigned int v11 = *(_DWORD *)(*a3 + 72);
      if (*(_DWORD *)(v9 + 72) >= v11)
      {
        do
        {
          uint64_t v12 = v7;
          *a3 = v9;
          if (v4 < v6) {
            break;
          }
          uint64_t v13 = (2 * v6) | 1;
          uint64_t v7 = (void *)(result + 8 * v13);
          uint64_t v14 = 2 * v6 + 2;
          uint64_t v9 = *v7;
          if (v14 < a2 && *(_DWORD *)(v9 + 72) < *(_DWORD *)(v7[1] + 72))
          {
            uint64_t v9 = v7[1];
            ++v7;
            uint64_t v13 = v14;
          }
          a3 = v12;
          uint64_t v6 = v13;
        }
        while (*(_DWORD *)(v9 + 72) >= v11);
        *uint64_t v12 = v10;
      }
    }
  }
  return result;
}

void sub_1CC346B80(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned char v91[64] = *MEMORY[0x1E4F143B8];
  uint64_t v85 = a2;
  int64x2_t v89 = v91;
  v91[0] = a2;
  uint64_t v90 = 0x4000000001;
  uint64_t v6 = (uint64_t *)(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 24);
  int v7 = *(_DWORD *)(a1 + 40);
  if (!v7) {
    goto LABEL_15;
  }
  int v8 = v7 - 1;
  unsigned int v9 = (v7 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v10 = (uint64_t *)(v5 + 72 * v9);
  uint64_t v11 = *v10;
  if (*v10 == a2)
  {
LABEL_14:
    *(_DWORD *)(v5 + 72 * v9 + 12) = 0;
LABEL_15:
    unsigned int v20 = 1;
LABEL_16:
    int v82 = 0;
    while (1)
    {
      uint64_t v84 = 0;
      uint64_t v21 = *((void *)v89 + v20 - 1);
      LODWORD(v90) = v20 - 1;
      uint64_t v84 = v21;
      int v22 = *(_DWORD *)(a1 + 40);
      if (v22)
      {
        uint64_t v23 = *(void *)(a1 + 24);
        int v24 = v22 - 1;
        unsigned int v25 = v24 & ((v21 >> 4) ^ (v21 >> 9));
        uint64_t v26 = (uint64_t *)(v23 + 72 * v25);
        uint64_t v27 = *v26;
        if (v21 == *v26) {
          goto LABEL_32;
        }
        int v28 = 0;
        int v29 = 1;
        while (v27 != -4096)
        {
          if (v28) {
            BOOL v30 = 0;
          }
          else {
            BOOL v30 = v27 == -8192;
          }
          if (v30) {
            int v28 = v26;
          }
          unsigned int v31 = v25 + v29++;
          unsigned int v25 = v31 & v24;
          uint64_t v26 = (uint64_t *)(v23 + 72 * v25);
          uint64_t v27 = *v26;
          if (v21 == *v26) {
            goto LABEL_32;
          }
        }
        if (v28) {
          unsigned int v32 = v28;
        }
        else {
          unsigned int v32 = v26;
        }
      }
      else
      {
        unsigned int v32 = 0;
      }
      uint64_t v26 = sub_1CC2DD9E4((uint64_t)v6, (uint64_t)&v84, &v84, v32);
      *uint64_t v26 = v84;
      *(_OWORD *)(v26 + 5) = 0u;
      *(_OWORD *)(v26 + 1) = 0u;
      *(_OWORD *)(v26 + 3) = 0u;
      *(_OWORD *)(v26 + 7) = 0u;
      v26[5] = (uint64_t)(v26 + 7);
      *((_DWORD *)v26 + 13) = 2;
LABEL_32:
      if (!*((_DWORD *)v26 + 2))
      {
        *((_DWORD *)v26 + 4) = ++v82;
        *((_DWORD *)v26 + 2) = v82;
        uint64_t v33 = v84;
        void v26[3] = v84;
        unsigned int v35 = *(uint64_t **)(a1 + 8);
        unint64_t v34 = *(void *)(a1 + 16);
        if ((unint64_t)v35 >= v34)
        {
          BOOL v37 = *(uint64_t **)a1;
          uint64_t v38 = ((uint64_t)v35 - *(void *)a1) >> 3;
          unint64_t v39 = v38 + 1;
          if ((unint64_t)(v38 + 1) >> 61) {
            abort();
          }
          uint64_t v40 = v34 - (void)v37;
          if (v40 >> 2 > v39) {
            unint64_t v39 = v40 >> 2;
          }
          if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v41 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v41 = v39;
          }
          if (v41)
          {
            if (v41 >> 61) {
              sub_1CB833614();
            }
            int v42 = (char *)operator new(8 * v41);
          }
          else
          {
            int v42 = 0;
          }
          unsigned int v43 = (uint64_t *)&v42[8 * v38];
          *unsigned int v43 = v33;
          int v36 = v43 + 1;
          if (v35 != v37)
          {
            do
            {
              uint64_t v44 = *--v35;
              *--unsigned int v43 = v44;
            }
            while (v35 != v37);
            unsigned int v35 = *(uint64_t **)a1;
          }
          *(void *)a1 = v43;
          *(void *)(a1 + 8) = v36;
          *(void *)(a1 + 16) = &v42[8 * v41];
          if (v35) {
            operator delete(v35);
          }
        }
        else
        {
          uint64_t *v35 = v33;
          int v36 = v35 + 1;
        }
        *(void *)(a1 + 8) = v36;
        uint64_t v45 = *(void *)(a1 + 48);
        if (v45)
        {
          sub_1CD517F18(*(void *)(v45 + 8), v84, (uint64_t)&v86);
          uint64_t v57 = v87;
          unint64_t v49 = v86;
        }
        else
        {
          uint64_t v46 = *(void *)(v84 + 88);
          uint64_t v47 = *(void *)(v84 + 96);
          uint64_t v86 = (uint64_t *)v88;
          uint64_t v87 = 0x800000000;
          unint64_t v48 = v47 - v46;
          if ((unint64_t)(v47 - v46) >= 0x41) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          unint64_t v49 = (uint64_t *)v88;
          if (v47 != v46)
          {
            uint64_t v50 = v88;
            do
            {
              uint64_t v51 = *(void *)(v47 - 8);
              v47 -= 8;
              *v50++ = v51;
            }
            while (v47 != v46);
            unint64_t v49 = v86;
          }
          uint64_t v52 = v49;
          uint64_t v53 = (v48 >> 3);
          if (v53)
          {
            uint64_t v54 = 8 * v53;
            uint64_t v52 = v49;
            while (*v52)
            {
              ++v52;
              v54 -= 8;
              if (!v54)
              {
                uint64_t v52 = &v49[v53];
                break;
              }
            }
          }
          uint64_t v55 = v52 - v49;
          if (v55 != v53)
          {
            uint64_t v78 = v52 + 1;
            if (v52 + 1 != &v49[v53])
            {
              uint64_t v79 = 8 * v53 - 8 * v55 - 8;
              do
              {
                if (*v78) {
                  *v52++ = *v78;
                }
                ++v78;
                v79 -= 8;
              }
              while (v79);
              unint64_t v49 = v86;
            }
          }
          unint64_t v56 = (unint64_t)((char *)v52 - (char *)v49) >> 3;
          uint64_t v57 = v56;
          LODWORD(v87) = v56;
        }
        int v58 = &v49[v57];
        if (v57)
        {
          while (1)
          {
            uint64_t v83 = 0;
            uint64_t v83 = *v49;
            int v59 = sub_1CC2DD8D0(v6, v83);
            uint64_t v60 = *(void *)(a1 + 24);
            unsigned int v61 = *(_DWORD *)(a1 + 40);
            if ((uint64_t *)(v60 + 72 * v61) == v59 || !*((_DWORD *)v59 + 2))
            {
              uint64_t v67 = v83;
              if (v84 != a3 && v83 != a3)
              {
                if (!v61)
                {
                  int v77 = 0;
                  goto LABEL_86;
                }
                unsigned int v69 = v61 - 1;
                unsigned int v70 = ((v83 >> 4) ^ (v83 >> 9)) & v69;
                uint64_t v71 = (uint64_t *)(v60 + 72 * v70);
                uint64_t v72 = *v71;
                if (v83 != *v71)
                {
                  uint64_t v73 = 0;
                  int v74 = 1;
                  while (v72 != -4096)
                  {
                    if (v73) {
                      BOOL v75 = 0;
                    }
                    else {
                      BOOL v75 = v72 == -8192;
                    }
                    if (v75) {
                      uint64_t v73 = v71;
                    }
                    unsigned int v76 = v70 + v74++;
                    unsigned int v70 = v76 & v69;
                    uint64_t v71 = (uint64_t *)(v60 + 72 * v70);
                    uint64_t v72 = *v71;
                    if (v83 == *v71) {
                      goto LABEL_87;
                    }
                  }
                  if (v73) {
                    int v77 = v73;
                  }
                  else {
                    int v77 = v71;
                  }
LABEL_86:
                  uint64_t v71 = sub_1CC2DD9E4((uint64_t)v6, (uint64_t)&v83, &v83, v77);
                  *uint64_t v71 = v83;
                  *(_OWORD *)(v71 + 5) = 0u;
                  *(_OWORD *)(v71 + 1) = 0u;
                  *(_OWORD *)(v71 + 3) = 0u;
                  *(_OWORD *)(v71 + 7) = 0u;
                  v71[5] = (uint64_t)(v71 + 7);
                  *((_DWORD *)v71 + 13) = 2;
                  uint64_t v67 = v83;
                }
LABEL_87:
                if (v90 >= (unint64_t)HIDWORD(v90)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *((void *)v89 + v90) = v67;
                uint64_t v65 = v71 + 6;
                unint64_t v64 = *((unsigned int *)v71 + 12);
                LODWORD(v90) = v90 + 1;
                *((_DWORD *)v71 + 3) = v82;
                uint64_t v63 = v71 + 5;
                uint64_t v62 = v84;
                unint64_t v66 = *((unsigned int *)v71 + 13);
LABEL_89:
                if (v64 >= v66) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *(void *)(*v63 + 8 * v64) = v62;
                ++*v65;
              }
            }
            else
            {
              uint64_t v62 = v84;
              if (v83 != v84)
              {
                uint64_t v63 = v59 + 5;
                uint64_t v65 = v59 + 6;
                unint64_t v64 = *((unsigned int *)v59 + 12);
                unint64_t v66 = *((unsigned int *)v59 + 13);
                goto LABEL_89;
              }
            }
            if (++v49 == v58)
            {
              unint64_t v49 = v86;
              break;
            }
          }
        }
        if (v49 != (uint64_t *)v88) {
          free(v49);
        }
      }
      unsigned int v20 = v90;
      if (!v90) {
        goto LABEL_113;
      }
    }
  }
  int v12 = 1;
  uint64_t v13 = *v10;
  unsigned int v14 = v8 & ((a2 >> 4) ^ (a2 >> 9));
  do
  {
    if (v13 == -4096) {
      goto LABEL_15;
    }
    unsigned int v15 = v14 + v12++;
    unsigned int v14 = v15 & v8;
    uint64_t v13 = *(void *)(v5 + 72 * v14);
  }
  while (v13 != a2);
  uint64_t v16 = 0;
  int v17 = 1;
  while (v11 != -4096)
  {
    if (v16) {
      BOOL v18 = 0;
    }
    else {
      BOOL v18 = v11 == -8192;
    }
    if (v18) {
      uint64_t v16 = v10;
    }
    unsigned int v19 = v9 + v17++;
    unsigned int v9 = v19 & v8;
    uint64_t v10 = (uint64_t *)(v5 + 72 * v9);
    uint64_t v11 = *v10;
    if (*v10 == a2) {
      goto LABEL_14;
    }
  }
  if (v16) {
    int v80 = v16;
  }
  else {
    int v80 = v10;
  }
  uint64_t v81 = sub_1CC2DD9E4(a1 + 24, (uint64_t)&v85, &v85, v80);
  *uint64_t v81 = v85;
  *(_OWORD *)(v81 + 5) = 0u;
  *(_OWORD *)(v81 + 3) = 0u;
  *(_OWORD *)(v81 + 1) = 0u;
  *(_OWORD *)(v81 + 7) = 0u;
  v81[5] = (uint64_t)(v81 + 7);
  *((_DWORD *)v81 + 13) = 2;
  unsigned int v20 = v90;
  if (v90) {
    goto LABEL_16;
  }
LABEL_113:
  if (v89 != v91) {
    free(v89);
  }
}

uint64_t sub_1CC347204()
{
  uint64_t v3 = &llvm::VerifyMachineDomInfo;
  int v2 = 1;
  v1.n128_u64[0] = (unint64_t)"Verify machine dominator info (time consuming)";
  v1.n128_u64[1] = 46;
  sub_1CD52D7AC(&v3, &v2, &v1);

  return __cxa_atexit((void (*)(void *))sub_1CC086C1C, &qword_1EBCCE7E0, &dword_1CB82C000);
}

uint64_t llvm::MachineFrameInfo::ensureMaxAlignment(uint64_t result, unsigned __int8 a2)
{
  if (*(unsigned __int8 *)(result + 60) < a2) {
    *(unsigned char *)(result + 60) = a2;
  }
  return result;
}

uint64_t llvm::MachineFrameInfo::CreateStackObject(unsigned __int8 *a1, uint64_t a2, unsigned __int8 a3, unsigned __int8 a4, uint64_t a5, int a6)
{
  if (a3 > *a1 && a1[1] == 0) {
    unsigned __int8 v12 = *a1;
  }
  else {
    unsigned __int8 v12 = a3;
  }
  char v13 = a4 ^ 1;
  unsigned int v15 = (void *)*((void *)a1 + 2);
  unint64_t v14 = *((void *)a1 + 3);
  if ((unint64_t)v15 >= v14)
  {
    unsigned int v20 = (void *)*((void *)a1 + 1);
    unint64_t v21 = 0xCCCCCCCCCCCCCCCDLL * (v15 - v20);
    unint64_t v22 = v21 + 1;
    if (v21 + 1 > 0x666666666666666) {
      abort();
    }
    unint64_t v23 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v14 - (void)v20) >> 3);
    if (2 * v23 > v22) {
      unint64_t v22 = 2 * v23;
    }
    if (v23 >= 0x333333333333333) {
      unint64_t v24 = 0x666666666666666;
    }
    else {
      unint64_t v24 = v22;
    }
    if (v24)
    {
      if (v24 > 0x666666666666666) {
        sub_1CB833614();
      }
      unsigned int v25 = (char *)operator new(40 * v24);
      unint64_t v21 = 0xCCCCCCCCCCCCCCCDLL * (v15 - v20);
    }
    else
    {
      unsigned int v25 = 0;
    }
    uint64_t v26 = &v25[40 * v21];
    *(void *)uint64_t v26 = 0;
    *((void *)v26 + 1) = a2;
    v26[16] = v12;
    v26[17] = 0;
    v26[18] = a4;
    v26[19] = 0;
    v26[20] = a6;
    *((void *)v26 + 3) = a5;
    v26[32] = 0;
    v26[33] = v13;
    *((_WORD *)v26 + 17) = 0;
    v26[36] = 0;
    uint64_t v16 = v26 + 40;
    if (v15 != v20)
    {
      do
      {
        long long v27 = *(_OWORD *)(v15 - 5);
        long long v28 = *(_OWORD *)(v15 - 3);
        *(void *)(v26 - 11) = *(void *)((char *)v15 - 11);
        *(_OWORD *)(v26 - 24) = v28;
        *(_OWORD *)(v26 - 40) = v27;
        v26 -= 40;
        v15 -= 5;
      }
      while (v15 != v20);
      unsigned int v15 = (void *)*((void *)a1 + 1);
    }
    *((void *)a1 + 1) = v26;
    *((void *)a1 + 2) = v16;
    *((void *)a1 + 3) = &v25[40 * v24];
    if (v15) {
      operator delete(v15);
    }
  }
  else
  {
    void *v15 = 0;
    v15[1] = a2;
    *((unsigned char *)v15 + 16) = v12;
    *((unsigned char *)v15 + 17) = 0;
    *((_WORD *)v15 + 9) = a4;
    *((unsigned char *)v15 + 20) = a6;
    v15[3] = a5;
    *((unsigned char *)v15 + 32) = 0;
    *((unsigned char *)v15 + 33) = v13;
    *((_WORD *)v15 + 17) = 0;
    uint64_t v16 = v15 + 5;
    *((unsigned char *)v15 + 36) = 0;
  }
  *((void *)a1 + 2) = v16;
  uint64_t v17 = *((void *)a1 + 1);
  int v18 = *((_DWORD *)a1 + 8);
  if (!a6 && a1[60] < v12) {
    a1[60] = v12;
  }
  return ~v18 - 858993459 * (((unint64_t)v16 - v17) >> 3);
}

uint64_t llvm::MachineFrameInfo::CreateSpillStackObject(unsigned __int8 *a1, uint64_t a2, unsigned __int8 a3)
{
  if (a3 > *a1 && a1[1] == 0) {
    unsigned __int8 v5 = *a1;
  }
  else {
    unsigned __int8 v5 = a3;
  }
  llvm::MachineFrameInfo::CreateStackObject(a1, a2, v5, 1u, 0, 0);
  uint64_t v7 = *((void *)a1 + 1);
  uint64_t v6 = *((void *)a1 + 2);
  int v8 = *((_DWORD *)a1 + 8);
  if (a1[60] < v5) {
    a1[60] = v5;
  }
  return ~v8 - 858993459 * ((unint64_t)(v6 - v7) >> 3);
}

uint64_t llvm::MachineFrameInfo::CreateFixedObject(llvm::MachineFrameInfo *this, uint64_t a2, uint64_t a3, char a4, char a5)
{
  unsigned int v6 = *(unsigned __int8 *)this;
  if (*((unsigned char *)this + 2)) {
    uint64_t v7 = 1;
  }
  else {
    uint64_t v7 = 1 << v6;
  }
  int v8 = *((unsigned __int8 *)this + 1);
  unint64_t v9 = 63 - __clz((v7 | a3) & -(v7 | a3));
  unsigned __int8 v12 = (char *)*((void *)this + 1);
  uint64_t v10 = (void *)((char *)this + 8);
  uint64_t v11 = v12;
  *(void *)&long long v16 = a3;
  *((void *)&v16 + 1) = a2;
  if (v9 <= v6 || v8 != 0) {
    LOBYTE(v6) = v9;
  }
  char v17 = v6;
  char v18 = a4;
  __int16 v19 = 0;
  char v20 = 0;
  uint64_t v21 = 0;
  char v22 = 0;
  char v23 = a5;
  __int16 v24 = 0;
  char v25 = 0;
  sub_1CC3475CC(v10, v11, &v16);
  int v14 = *((_DWORD *)this + 8);
  *((_DWORD *)this + 8) = v14 + 1;
  return ~v14;
}

char *sub_1CC3475CC(void *a1, char *__src, long long *a3)
{
  int64_t v4 = __src;
  unsigned int v6 = (char *)a1[1];
  unint64_t v7 = a1[2];
  if ((unint64_t)v6 >= v7)
  {
    int v8 = (char *)*a1;
    unint64_t v9 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v6[-*a1] >> 3) + 1;
    if (v9 > 0x666666666666666) {
      abort();
    }
    unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - (void)v8) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x333333333333333) {
      unint64_t v11 = 0x666666666666666;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 > 0x666666666666666) {
        goto LABEL_41;
      }
      unsigned __int8 v12 = (char *)operator new(40 * v11);
    }
    else
    {
      unsigned __int8 v12 = 0;
    }
    int64_t v13 = 0xCCCCCCCCCCCCCCCDLL * ((v4 - v8) >> 3);
    int v14 = &v12[8 * ((v4 - v8) >> 3)];
    unsigned int v15 = &v12[40 * v11];
    if (v13 != v11)
    {
LABEL_12:
      long long v16 = a3[1];
      *(_OWORD *)int v14 = *a3;
      *((_OWORD *)v14 + 1) = v16;
      *((void *)v14 + 4) = *((void *)a3 + 4);
      char v17 = v14;
      if (v4 != v8)
      {
        BOOL v30 = v4;
        unsigned int v31 = v14;
        do
        {
          long long v32 = *(_OWORD *)(v30 - 40);
          long long v33 = *(_OWORD *)(v30 - 24);
          char v17 = v31 - 40;
          *(void *)(v31 - 11) = *(void *)(v30 - 11);
          *(_OWORD *)(v31 - 24) = v33;
          *(_OWORD *)(v31 - 40) = v32;
          v30 -= 40;
          v31 -= 40;
        }
        while (v30 != v8);
      }
      char v18 = (char *)a1[1];
      int64_t v19 = v18 - v4;
      if (v18 != v4) {
        memmove(v14 + 40, v4, v19 - 3);
      }
      char v20 = (char *)*a1;
      *a1 = v17;
      a1[1] = &v14[v19 + 40];
      a1[2] = v15;
      if (v20) {
        operator delete(v20);
      }
      return v14;
    }
    __p = v12;
    if (v4 - v8 >= 1)
    {
      if (v13 >= -1) {
        uint64_t v29 = v13 + 1;
      }
      else {
        uint64_t v29 = v13 + 2;
      }
      v14 -= 40 * (v29 >> 1);
      goto LABEL_12;
    }
    unint64_t v34 = 0x999999999999999ALL * ((v4 - v8) >> 3);
    if (v8 == v4) {
      unint64_t v34 = 1;
    }
    if (v34 <= 0x666666666666666)
    {
      unint64_t v35 = v34 >> 2;
      uint64_t v36 = 5 * v34;
      BOOL v37 = (char *)operator new(40 * v34);
      int v14 = &v37[40 * v35];
      unsigned int v15 = &v37[8 * v36];
      if (__p)
      {
        operator delete(__p);
        int v8 = (char *)*a1;
      }
      goto LABEL_12;
    }
LABEL_41:
    sub_1CB833614();
  }
  if (__src == v6)
  {
    long long v38 = *a3;
    long long v39 = a3[1];
    *((void *)__src + 4) = *((void *)a3 + 4);
    *(_OWORD *)uint64_t __src = v38;
    *((_OWORD *)__src + 1) = v39;
    a1[1] = __src + 40;
  }
  else
  {
    char v22 = __src + 40;
    char v23 = v6 - 40;
    uint64_t v24 = a1[1];
    while (v23 < v6)
    {
      long long v25 = *(_OWORD *)v23;
      long long v26 = *((_OWORD *)v23 + 1);
      *(void *)(v24 + 32) = *((void *)v23 + 4);
      *(_OWORD *)uint64_t v24 = v25;
      *(_OWORD *)(v24 + 16) = v26;
      v23 += 40;
      v24 += 40;
    }
    a1[1] = v24;
    if (v6 != v22) {
      memmove(v22, __src, v6 - v22 - 3);
    }
    long long v27 = *a3;
    long long v28 = a3[1];
    *(void *)(v4 + 29) = *(void *)((char *)a3 + 29);
    *(_OWORD *)int64_t v4 = v27;
    *((_OWORD *)v4 + 1) = v28;
  }
  return v4;
}

uint64_t llvm::MachineFrameInfo::CreateFixedSpillStackObject(llvm::MachineFrameInfo *this, uint64_t a2, uint64_t a3, char a4)
{
  unsigned int v5 = *(unsigned __int8 *)this;
  if (*((unsigned char *)this + 2)) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = 1 << v5;
  }
  unint64_t v7 = 63 - __clz((v6 | a3) & -(v6 | a3));
  int v8 = *((unsigned __int8 *)this + 1);
  *(void *)&long long v15 = a3;
  *((void *)&v15 + 1) = a2;
  unint64_t v11 = (char *)*((void *)this + 1);
  unint64_t v9 = (void *)((char *)this + 8);
  unint64_t v10 = v11;
  if (v7 > v5 && v8 == 0) {
    LOBYTE(v7) = v5;
  }
  char v16 = v7;
  char v17 = a4;
  __int16 v18 = 1;
  char v19 = 0;
  v20[0] = 0;
  *(void *)((char *)v20 + 5) = 0;
  sub_1CC3475CC(v9, v10, &v15);
  int v13 = *((_DWORD *)this + 8);
  *((_DWORD *)this + 8) = v13 + 1;
  return ~v13;
}

uint64_t llvm::MachineFrameInfo::estimateStackSize(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 112))(*(void *)(a2 + 16));
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 176))(*(void *)(a2 + 16));
  unsigned __int8 v6 = *(unsigned char *)(a1 + 60);
  unsigned int v7 = *(_DWORD *)(a1 + 32);
  if (v7)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v10 = -v7 + 1;
    uint64_t v11 = v9;
    do
    {
      if (!*(unsigned char *)(v11 + 20) && v8 <= -*(void *)v11) {
        uint64_t v8 = -*(void *)v11;
      }
      int v12 = v10++;
      v11 += 40;
    }
    while (v12);
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t v9 = *(void *)(a1 + 8);
  }
  int v13 = -858993459 * ((unint64_t)(*(void *)(a1 + 16) - v9) >> 3);
  if (v7 != v13)
  {
    do
    {
      unsigned int v14 = v7;
      uint64_t v15 = *(void *)(v9 + 40 * v7 + 8);
      if (v15 != -1 && !*(unsigned char *)(v9 + 40 * v14 + 20))
      {
        unsigned int v16 = *(unsigned __int8 *)(v9 + 40 * v14 + 16);
        uint64_t v8 = (v8 + v15 + (1 << v16) - 1) & -(1 << v16);
        if (v16 > v6) {
          unsigned __int8 v6 = *(unsigned char *)(v9 + 40 * v14 + 16);
        }
      }
      unsigned int v7 = v14 + 1;
    }
    while (v13 != v14 + 1);
  }
  if (*(unsigned char *)(a1 + 61))
  {
    if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v4 + 208))(v4, a2))
    {
      LODWORD(v17) = *(_DWORD *)(a1 + 72);
      if (v17 == -1) {
        uint64_t v17 = 0;
      }
      else {
        uint64_t v17 = v17;
      }
      v8 += v17;
    }
    if (*(unsigned char *)(a1 + 61)) {
      goto LABEL_23;
    }
  }
  if (*(unsigned char *)(a1 + 36)
    || (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v5 + 440))(v5, a2)
    && (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v5 + 432))(v5, a2)
    && *(_DWORD *)(a1 + 32) != -858993459 * ((*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3))
  {
LABEL_23:
    __int16 v18 = (unsigned __int8 *)(v4 + 12);
  }
  else
  {
    __int16 v18 = (unsigned __int8 *)(v4 + 13);
  }
  unsigned int v19 = *v18;
  if (v19 <= v6) {
    LOBYTE(v19) = v6;
  }
  return (v8 + (1 << v19) - 1) & -(1 << v19);
}

uint64_t llvm::MachineFrameInfo::computeMaxCallFrameSize(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 104))(*(void *)(a2 + 16));
  int v5 = *(_DWORD *)(result + 64);
  int v6 = *(_DWORD *)(result + 68);
  *(_DWORD *)(a1 + 72) = 0;
  uint64_t v7 = *(void *)(a2 + 328);
  if (v7 != a2 + 320)
  {
    unsigned int v8 = 0;
    do
    {
      for (uint64_t i = *(void *)(v7 + 56); i != v7 + 48; uint64_t i = *(void *)(i + 8))
      {
        int v10 = **(unsigned __int16 **)(i + 16);
        if (v5 == v10 || v6 == v10)
        {
          if (v8 <= *(_DWORD *)(*(void *)(i + 32) + 16)) {
            unsigned int v8 = *(_DWORD *)(*(void *)(i + 32) + 16);
          }
          *(_DWORD *)(a1 + 72) = v8;
LABEL_15:
          *(unsigned char *)(a1 + 61) = 1;
          goto LABEL_16;
        }
        if ((v10 - 1) <= 1 && (*(unsigned char *)(*(void *)(i + 32) + 48) & 2) != 0) {
          goto LABEL_15;
        }
LABEL_16:
        if ((*(unsigned char *)i & 4) == 0)
        {
          while ((*(_WORD *)(i + 44) & 8) != 0)
            uint64_t i = *(void *)(i + 8);
        }
      }
      uint64_t v7 = *(void *)(v7 + 8);
    }
    while (v7 != a2 + 320);
  }
  return result;
}

char *sub_1CC347C74(void **a1, uint64_t a2)
{
  uint64_t v3 = (char *)*a1;
  int v2 = (char *)a1[1];
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((v2 - (unsigned char *)*a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x666666666666666) {
    abort();
  }
  if (0x999999999999999ALL * (((unsigned char *)a1[2] - v3) >> 3) > v5) {
    unint64_t v5 = 0x999999999999999ALL * (((unsigned char *)a1[2] - v3) >> 3);
  }
  if (0xCCCCCCCCCCCCCCCDLL * (((unsigned char *)a1[2] - v3) >> 3) >= 0x333333333333333) {
    unint64_t v8 = 0x666666666666666;
  }
  else {
    unint64_t v8 = v5;
  }
  if (v8)
  {
    if (v8 > 0x666666666666666) {
      sub_1CB833614();
    }
    uint64_t v9 = (char *)operator new(40 * v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  int v10 = &v9[40 * v4];
  long long v11 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)int v10 = *(_OWORD *)a2;
  *((_OWORD *)v10 + 1) = v11;
  *((void *)v10 + 4) = *(void *)(a2 + 32);
  int v12 = v10 + 40;
  if (v2 != v3)
  {
    do
    {
      long long v13 = *(_OWORD *)(v2 - 40);
      long long v14 = *(_OWORD *)(v2 - 24);
      *(void *)(v10 - 11) = *(void *)(v2 - 11);
      *(_OWORD *)(v10 - 24) = v14;
      *(_OWORD *)(v10 - 40) = v13;
      v10 -= 40;
      v2 -= 40;
    }
    while (v2 != v3);
    int v2 = (char *)*a1;
  }
  *a1 = v10;
  a1[1] = v12;
  a1[2] = &v9[40 * v8];
  if (v2) {
    operator delete(v2);
  }
  return v12;
}

uint64_t setUnsafeStackSize(uint64_t result, llvm::MachineFrameInfo *a2)
{
  uint64_t v2 = *(void *)(result + 112);
  if (v2)
  {
    if ((*(unsigned char *)(v2 + 18) & 2) != 0)
    {
      uint64_t result = llvm::Value::getMetadata((llvm::Value *)result, 30);
      if (result)
      {
        uint64_t v3 = result;
        if (*(unsigned char *)result == 4 && *(_DWORD *)(result + 8) == 2)
        {
          uint64_t result = *(void *)(result - 16);
          if (result)
          {
            uint64_t result = llvm::MDString::getString((llvm::MDString *)result);
            if (v4 == 17)
            {
              BOOL v5 = *(void *)result == 0x732D656661736E75 && *(void *)(result + 8) == 0x7A69732D6B636174;
              if (v5 && *(unsigned char *)(result + 16) == 101)
              {
                uint64_t v7 = *(void *)(v3 - 8 * *(unsigned int *)(v3 + 8) + 8);
                if (v7)
                {
                  uint64_t v8 = *(void *)(v7 + 128);
                  uint64_t v9 = (void *)(v8 + 24);
                  if (*(_DWORD *)(v8 + 32) >= 0x41u) {
                    uint64_t v9 = (void *)*v9;
                  }
                  *((void *)a2 + 84) = *v9;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void llvm::MachineFunctionInfo::~MachineFunctionInfo(llvm::MachineFunctionInfo *this)
{
}

void llvm::ilist_alloc_traits<llvm::MachineBasicBlock>::deleteNode(int a1, llvm::MachineBasicBlock *a2)
{
  uint64_t v3 = *((void *)a2 + 4);
  uint64_t v4 = *(llvm::MachineJumpTableInfo **)(v3 + 72);
  if (v4) {
    llvm::MachineJumpTableInfo::RemoveMBBFromJumpTables(v4, a2);
  }
  BOOL v5 = (void *)*((void *)a2 + 19);
  if (v5)
  {
    *((void *)a2 + 20) = v5;
    operator delete(v5);
  }
  int v6 = (void *)*((void *)a2 + 14);
  if (v6)
  {
    *((void *)a2 + 15) = v6;
    operator delete(v6);
  }
  uint64_t v7 = (void *)*((void *)a2 + 11);
  if (v7)
  {
    *((void *)a2 + 12) = v7;
    operator delete(v7);
  }
  uint64_t v8 = (void *)*((void *)a2 + 8);
  if (v8)
  {
    *((void *)a2 + 9) = v8;
    operator delete(v8);
  }
  for (uint64_t i = (llvm::MachineBasicBlock *)*((void *)a2 + 7);
        (llvm::MachineBasicBlock *)((char *)a2 + 48) != i;
  *(void *)a2 = *(void *)(v3 + 312);
  *(void *)(v3 + 312) = a2;
}

void llvm::MachineFunction::deleteMachineBasicBlock(llvm::MachineFunction *this, llvm::MachineBasicBlock **a2)
{
  uint64_t v4 = (llvm::MachineJumpTableInfo *)*((void *)this + 9);
  if (v4) {
    llvm::MachineJumpTableInfo::RemoveMBBFromJumpTables(v4, (llvm::MachineBasicBlock *)a2);
  }
  BOOL v5 = a2[19];
  if (v5)
  {
    a2[20] = v5;
    operator delete(v5);
  }
  int v6 = a2[14];
  if (v6)
  {
    a2[15] = v6;
    operator delete(v6);
  }
  uint64_t v7 = a2[11];
  if (v7)
  {
    a2[12] = v7;
    operator delete(v7);
  }
  uint64_t v8 = a2[8];
  if (v8)
  {
    a2[9] = v8;
    operator delete(v8);
  }
  for (uint64_t i = a2[7];
        a2 + 6 != (llvm::MachineBasicBlock **)i;
  *a2 = (llvm::MachineBasicBlock *)*((void *)this + 39);
  *((void *)this + 39) = a2;
}

void llvm::MachineFunction::MachineFunction(llvm::MachineFunction *this, llvm::Function *a2, const llvm::LLVMTargetMachine *a3, const llvm::TargetSubtargetInfo *a4, int a5, llvm::MachineModuleInfo *a6, llvm::FunctionGroup *a7)
{
  *(void *)this = a2;
  *((void *)this + 1) = a3;
  uint64_t v7 = (char *)*((void *)a6 + 257);
  if (!v7) {
    uint64_t v7 = (char *)a6 + 8;
  }
  *((void *)this + 2) = a4;
  *((void *)this + 3) = v7;
  *((void *)this + 4) = a6;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((void *)this + 18) = (char *)this + 160;
  *((void *)this + 19) = 0x400000000;
  *((void *)this + 24) = (char *)this + 208;
  *(_OWORD *)((char *)this + 200) = 0u;
  *((void *)this + 27) = 1;
  *((void *)this + 28) = 0;
  *((void *)this + 29) = (char *)this + 248;
  *((void *)this + 30) = 0x800000000;
  *((void *)this + 39) = 0;
  *((void *)this + 40) = (char *)this + 320;
  *((void *)this + 41) = (char *)this + 320;
  *((void *)this + 43) = a7;
  *((_DWORD *)this + 88) = 0;
  *((void *)this + 45) = (char *)this + 376;
  *((void *)this + 47) = 0;
  *((void *)this + 46) = 0x600000001;
  *((_DWORD *)this + 106) = 11;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 28) = 0u;
  *((_OWORD *)this + 29) = 0u;
  *((_OWORD *)this + 30) = 0u;
  *((_OWORD *)this + 31) = 0u;
  *((_OWORD *)this + 32) = 0u;
  *((_OWORD *)this + 33) = 0u;
  *(_OWORD *)((char *)this + 540) = 0u;
  *((_OWORD *)this + 35) = 0u;
  *((_DWORD *)this + 144) = 0;
  *((_DWORD *)this + 150) = 0;
  *(_OWORD *)((char *)this + 584) = 0u;
  *((void *)this + 78) = 0;
  *(void *)((char *)this + 629) = 0;
  *((_OWORD *)this + 38) = 0u;
  *((_DWORD *)this + 160) = 4;
  *(_OWORD *)((char *)this + 708) = 0u;
  *(_OWORD *)((char *)this + 680) = 0u;
  *(_OWORD *)((char *)this + 696) = 0u;
  *(_OWORD *)((char *)this + 648) = 0u;
  *(_OWORD *)((char *)this + 664) = 0u;
  *((_DWORD *)this + 190) = 0;
  *(_OWORD *)((char *)this + 728) = 0u;
  *(_OWORD *)((char *)this + 744) = 0u;
  *((void *)this + 96) = (char *)this + 784;
  *((void *)this + 97) = 0x400000000;
  *((_DWORD *)this + 228) = 0;
  *((void *)this + 115) = (char *)this + 936;
  *((void *)this + 116) = 0x800000000;
  *((_DWORD *)this + 278) = 0;
  *(_OWORD *)((char *)this + 1096) = 0u;
  *((_DWORD *)this + 84) = a5;
  llvm::MachineFunction::init(this);
}

void llvm::MachineFunction::init(llvm::MachineFunction *this)
{
  **((void **)this + 45) |= 5uLL;
  if ((*(uint64_t (**)(void))(**((void **)this + 2) + 176))(*((void *)this + 2)))
  {
    *((void *)this + 26) += 480;
    uint64_t v2 = *((void *)this + 16);
    if (((v2 + 7) & 0xFFFFFFFFFFFFFFF8) - v2 + 480 > *((void *)this + 17) - v2)
    {
      unsigned int v55 = *((_DWORD *)this + 38) >> 7;
      if (v55 >= 0x1E) {
        LOBYTE(v55) = 30;
      }
      uint64_t v56 = 4096 << v55;
      uint64_t v3 = (llvm::MachineRegisterInfo *)operator new(4096 << v55, (std::align_val_t)8uLL);
      unsigned int v57 = *((_DWORD *)this + 38);
      if (v57 >= *((_DWORD *)this + 39)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*((void *)this + 18) + 8 * v57) = v3;
      ++*((_DWORD *)this + 38);
      *((void *)this + 17) = (char *)v3 + v56;
    }
    else
    {
      uint64_t v3 = (llvm::MachineRegisterInfo *)((v2 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
    *((void *)this + 16) = (char *)v3 + 480;
    llvm::MachineRegisterInfo::MachineRegisterInfo(v3, this);
  }
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  if (*(unsigned char *)((*(uint64_t (**)(void))(**((void **)this + 2) + 112))(*((void *)this + 2)) + 20))
  {
    uint64_t v4 = *(void *)(*(void *)this + 112);
    if (v4)
    {
      if (*(_DWORD *)(v4 + 8))
      {
        uint64_t v5 = *(void *)(v4 + 40);
        if (v5)
        {
          int v6 = *(_DWORD *)(v5 + 40);
          if (v6)
          {
            uint64_t v7 = *(void *)(v5 + 24);
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EBCBE588))
            {
              unint64_t v61 = llvm::hashing::detail::fixed_seed_override;
              if (!llvm::hashing::detail::fixed_seed_override) {
                unint64_t v61 = 0xFF51AFD7ED558CCDLL;
              }
              qword_1EBCBE580 = v61;
              __cxa_guard_release(&qword_1EBCBE588);
            }
            unint64_t v8 = 0x9DDFEA08EB382D69
               * ((0x9DDFEA08EB382D69 * (qword_1EBCBE580 ^ 0x71B0A0613591C43)) ^ ((0x9DDFEA08EB382D69
                                                                                     * (qword_1EBCBE580 ^ 0x71B0A0613591C43)) >> 47) ^ 0x6E776B636174732DLL);
            unsigned int v9 = (-348639895 * ((v8 >> 47) ^ v8)) ^ 0x732D6E67;
            for (int i = 1; ; ++i)
            {
              unsigned int v11 = v9 & (v6 - 1);
              uint64_t v12 = v7 + 24 * v11;
              long long v13 = *(void **)v12;
              if (*(void *)v12 == -1)
              {
                if ("no-realign-stack" == (char *)-1) {
                  goto LABEL_25;
                }
              }
              else if (v13 == (void *)-2)
              {
                if ("no-realign-stack" == (char *)-2) {
                  goto LABEL_25;
                }
              }
              else if (*(void *)(v12 + 8) == 16 && *v13 == 0x696C6165722D6F6ELL && v13[1] == 0x6B636174732D6E67)
              {
                goto LABEL_25;
              }
              if (v13 == (void *)-1) {
                break;
              }
              unsigned int v9 = i + v11;
            }
          }
        }
      }
    }
    int v15 = 1;
  }
  else
  {
LABEL_25:
    int v15 = 0;
  }
  *((void *)this + 26) += 680;
  uint64_t v16 = *((void *)this + 16);
  if (((v16 + 7) & 0xFFFFFFFFFFFFFFF8) - v16 + 680 > *((void *)this + 17) - v16)
  {
    unsigned int v46 = *((_DWORD *)this + 38) >> 7;
    if (v46 >= 0x1E) {
      LOBYTE(v46) = 30;
    }
    uint64_t v47 = 4096 << v46;
    unint64_t v17 = (unint64_t)operator new(4096 << v46, (std::align_val_t)8uLL);
    unsigned int v48 = *((_DWORD *)this + 38);
    if (v48 >= *((_DWORD *)this + 39)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*((void *)this + 18) + 8 * v48) = v17;
    ++*((_DWORD *)this + 38);
    *((void *)this + 17) = v17 + v47;
  }
  else
  {
    unint64_t v17 = (v16 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *((void *)this + 16) = v17 + 680;
  FnStackunsigned int Alignment = llvm::AttributeList::getFnStackAlignment((llvm::AttributeList *)(*(void *)this + 112));
  if (FnStackAlignment > 0xFFu) {
    unint64_t v19 = FnStackAlignment;
  }
  else {
    unint64_t v19 = *(unsigned __int8 *)((*(uint64_t (**)(void))(**((void **)this + 2) + 112))(*((void *)this + 2))
  }
                             + 12);
  if (v15)
  {
    uint64_t v20 = *(void *)(*(void *)this + 112);
    if (v20) {
      LODWORD(v20) = (*(unsigned __int8 *)(v20 + 21) >> 6) & 1;
    }
  }
  else
  {
    LOBYTE(v20) = 0;
  }
  char v21 = 63 - __clz((1 << v19));
  if (v19 <= 0x1F) {
    char v22 = v21;
  }
  else {
    char v22 = 0;
  }
  *(unsigned char *)unint64_t v17 = v22;
  *(unsigned char *)(v17 + 1) = v15;
  *(unsigned char *)(v17 + 2) = v20;
  *(_OWORD *)(v17 + 8) = 0u;
  *(_OWORD *)(v17 + 24) = 0u;
  *(unsigned char *)(v17 + 40) = 0;
  *(void *)(v17 + 48) = 0;
  *(void *)(v17 + 55) = 0;
  *(void *)(v17 + 64) = -1;
  *(_DWORD *)(v17 + 72) = -1;
  *(void *)(v17 + 76) = 0;
  *(_OWORD *)(v17 + 84) = 0u;
  *(void *)(v17 + 97) = 0;
  *(void *)(v17 + 112) = v17 + 128;
  *(void *)(v17 + 120) = 0x2000000000;
  *(void *)(v17 + 640) = 0;
  *(void *)(v17 + 647) = 0;
  *(void *)(v17 + 672) = 0;
  *(_OWORD *)(v17 + 656) = 0u;
  *((void *)this + 7) = v17;
  setUnsafeStackSize(*(void *)this, (llvm::MachineFrameInfo *)v17);
  uint64_t v23 = *(void *)(*(void *)this + 112);
  if (v23)
  {
    if ((*(unsigned char *)(v23 + 21) & 0x40) != 0)
    {
      uint64_t v24 = *((void *)this + 7);
      unsigned __int8 v25 = llvm::AttributeList::getFnStackAlignment((llvm::AttributeList *)(*(void *)this + 112));
      if (*(unsigned __int8 *)(v24 + 60) < v25) {
        *(unsigned char *)(v24 + 60) = v25;
      }
    }
  }
  *((void *)this + 26) += 64;
  uint64_t v26 = *((void *)this + 16);
  if (((v26 + 7) & 0xFFFFFFFFFFFFFFF8) - v26 + 64 > *((void *)this + 17) - v26)
  {
    unsigned int v49 = *((_DWORD *)this + 38) >> 7;
    if (v49 >= 0x1E) {
      LOBYTE(v49) = 30;
    }
    uint64_t v50 = 4096 << v49;
    unint64_t v27 = (unint64_t)operator new(4096 << v49, (std::align_val_t)8uLL);
    unsigned int v51 = *((_DWORD *)this + 38);
    if (v51 >= *((_DWORD *)this + 39)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*((void *)this + 18) + 8 * v51) = v27;
    ++*((_DWORD *)this + 38);
    *((void *)this + 17) = v27 + v50;
  }
  else
  {
    unint64_t v27 = (v26 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *((void *)this + 16) = v27 + 64;
  uint64_t v28 = *(void *)(*(void *)this + 40) + 272;
  *(unsigned char *)unint64_t v27 = 0;
  *(_OWORD *)(v27 + 8) = 0u;
  *(_OWORD *)(v27 + 24) = 0u;
  *(_OWORD *)(v27 + 36) = 0u;
  *(void *)(v27 + 56) = v28;
  *((void *)this + 8) = v27;
  *((unsigned char *)this + 352) = *(unsigned char *)((*(uint64_t (**)(void))(**((void **)this + 2) + 120))(*((void *)this + 2))
                                    + 69);
  uint64_t v30 = *(void *)(*(void *)this + 112);
  if (!v30 || (*(unsigned char *)(v30 + 17) & 4) == 0)
  {
    unsigned int v31 = *(unsigned __int8 *)((*(uint64_t (**)(void))(**((void **)this + 2) + 120))(*((void *)this + 2))
                             + 70);
    if (*((unsigned __int8 *)this + 352) > v31) {
      LOBYTE(v31) = *((unsigned char *)this + 352);
    }
    *((unsigned char *)this + 352) = v31;
  }
  if (dword_1EBCCE928) {
    *((unsigned char *)this + 352) = __clz(1 << dword_1EBCCE928) ^ 0x3F;
  }
  long long v32 = 0;
  *((void *)this + 9) = 0;
  long long v33 = *(void **)this;
  if ((*(_WORD *)(*(void *)this + 18) & 8) != 0)
  {
    int v34 = *((_DWORD *)v33 + 5);
    if ((v34 & 0x40000000) != 0) {
      unint64_t v35 = (llvm::Value **)*(v33 - 1);
    }
    else {
      unint64_t v35 = (llvm::Value **)&v33[-4 * (v34 & 0x7FFFFFF)];
    }
    long long v32 = *v35;
  }
  if (llvm::classifyEHPersonality(v32, v29) - 7 <= 3)
  {
    *((void *)this + 26) += 696;
    uint64_t v44 = *((void *)this + 16);
    if (((v44 + 7) & 0xFFFFFFFFFFFFFFF8) - v44 + 696 > *((void *)this + 17) - v44)
    {
      unsigned int v58 = *((_DWORD *)this + 38) >> 7;
      if (v58 >= 0x1E) {
        LOBYTE(v58) = 30;
      }
      uint64_t v59 = 4096 << v58;
      uint64_t v45 = (__n128 *)operator new(4096 << v58, (std::align_val_t)8uLL);
      unsigned int v60 = *((_DWORD *)this + 38);
      if (v60 >= *((_DWORD *)this + 39)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*((void *)this + 18) + 8 * v60) = v45;
      ++*((_DWORD *)this + 38);
      *((void *)this + 17) = (char *)v45 + v59;
    }
    else
    {
      uint64_t v45 = (__n128 *)((v44 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
    *((void *)this + 16) = (char *)v45 + 696;
    llvm::WinEHFuncInfo::WinEHFuncInfo(v45);
    *((void *)this + 12) = v45;
  }
  BOOL v37 = *(void **)this;
  if ((*(_WORD *)(*(void *)this + 18) & 8) != 0)
  {
    int v39 = *((_DWORD *)v37 + 5);
    if ((v39 & 0x40000000) != 0) {
      uint64_t v40 = (llvm::Value **)*(v37 - 1);
    }
    else {
      uint64_t v40 = (llvm::Value **)&v37[-4 * (v39 & 0x7FFFFFF)];
    }
    long long v38 = *v40;
  }
  else
  {
    long long v38 = 0;
  }
  unsigned int v41 = llvm::classifyEHPersonality(v38, v36);
  if (v41 - 7 < 4 || v41 == 12)
  {
    *((void *)this + 26) += 48;
    uint64_t v42 = *((void *)this + 16);
    if (((v42 + 7) & 0xFFFFFFFFFFFFFFF8) - v42 + 48 > *((void *)this + 17) - v42)
    {
      unsigned int v52 = *((_DWORD *)this + 38) >> 7;
      if (v52 >= 0x1E) {
        LOBYTE(v52) = 30;
      }
      uint64_t v53 = 4096 << v52;
      unsigned int v43 = operator new(4096 << v52, (std::align_val_t)8uLL);
      unsigned int v54 = *((_DWORD *)this + 38);
      if (v54 >= *((_DWORD *)this + 39)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*((void *)this + 18) + 8 * v54) = v43;
      ++*((_DWORD *)this + 38);
      *((void *)this + 17) = (char *)v43 + v53;
    }
    else
    {
      unsigned int v43 = (_OWORD *)((v42 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
    *((void *)this + 16) = v43 + 3;
    v43[1] = 0u;
    v43[2] = 0u;
    *unsigned int v43 = 0u;
    *((void *)this + 11) = v43;
  }
  (*(void (**)(void))(**((void **)this + 2) + 104))(*((void *)this + 2));
  operator new();
}

uint64_t llvm::MachineFunction::handleInsertion(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 728);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t llvm::MachineFunction::handleRemoval(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 728);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 32))();
  }
  return result;
}

uint64_t llvm::MachineFunction::getDataLayout(llvm::MachineFunction *this)
{
  return *(void *)(*(void *)this + 40) + 272;
}

void llvm::MachineFunction::~MachineFunction(llvm::MachineFunction *this)
{
  llvm::MachineFunction::clear(this);
  MEMORY[0x1D25D9CD0](*((void *)this + 137), 8);
  uint64_t v2 = (char *)*((void *)this + 115);
  if (v2 != (char *)this + 936) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 96);
  if (v3 != (char *)this + 784) {
    free(v3);
  }
  uint64_t v4 = *((unsigned int *)this + 190);
  uint64_t v5 = *((void *)this + 93);
  if (v4)
  {
    long long v32 = (void *)(v5 + 24);
    uint64_t v33 = 32 * v4;
    do
    {
      if ((*(v32 - 3) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        int v34 = (void *)*(v32 - 2);
        if (v32 != v34) {
          free(v34);
        }
      }
      v32 += 4;
      v33 -= 32;
    }
    while (v33);
    uint64_t v5 = *((void *)this + 93);
  }
  MEMORY[0x1D25D9CD0](v5, 8);
  int v6 = (void *)*((void *)this + 87);
  if (v6)
  {
    *((void *)this + 88) = v6;
    operator delete(v6);
  }
  uint64_t v7 = (void *)*((void *)this + 84);
  if (v7)
  {
    *((void *)this + 85) = v7;
    operator delete(v7);
  }
  unint64_t v8 = (void *)*((void *)this + 81);
  if (v8)
  {
    *((void *)this + 82) = v8;
    operator delete(v8);
  }
  unsigned int v9 = (void *)*((void *)this + 76);
  if (v9)
  {
    *((void *)this + 77) = v9;
    operator delete(v9);
  }
  MEMORY[0x1D25D9CD0](*((void *)this + 73), 8);
  MEMORY[0x1D25D9CD0](*((void *)this + 70), 8);
  uint64_t v10 = *((unsigned int *)this + 138);
  uint64_t v11 = *((void *)this + 67);
  if (v10)
  {
    unint64_t v35 = (void *)(v11 + 24);
    uint64_t v36 = 40 * v10;
    do
    {
      if ((*(v35 - 3) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        BOOL v37 = (void *)*(v35 - 2);
        if (v35 != v37) {
          free(v37);
        }
      }
      v35 += 5;
      v36 -= 40;
    }
    while (v36);
    uint64_t v11 = *((void *)this + 67);
  }
  MEMORY[0x1D25D9CD0](v11, 8);
  uint64_t v12 = (void *)*((void *)this + 64);
  if (v12)
  {
    long long v13 = (void *)*((void *)this + 65);
    long long v14 = (void *)*((void *)this + 64);
    if (v13 != v12)
    {
      do
        long long v13 = sub_1CD531C78(v13 - 15);
      while (v13 != v12);
      long long v14 = (void *)*((void *)this + 64);
    }
    *((void *)this + 65) = v12;
    operator delete(v14);
  }
  int v15 = (void *)*((void *)this + 61);
  if (v15)
  {
    *((void *)this + 62) = v15;
    operator delete(v15);
  }
  uint64_t v16 = (void *)*((void *)this + 58);
  if (v16)
  {
    *((void *)this + 59) = v16;
    operator delete(v16);
  }
  long long v38 = (void **)((char *)this + 440);
  sub_1CC34C338(&v38);
  uint64_t v17 = *((void *)this + 54);
  *((void *)this + 54) = 0;
  if (v17)
  {
    uint64_t v18 = sub_1CC34BF28(v17);
    MEMORY[0x1D25D9CE0](v18, 0x10E2C4016F627CCLL);
  }
  unint64_t v19 = (char *)*((void *)this + 45);
  if (v19 != (char *)this + 376) {
    free(v19);
  }
  for (int i = (llvm::MachineBasicBlock *)*((void *)this + 41);
        (llvm::MachineFunction *)((char *)this + 320) != i;
  char v21 = (char *)*((void *)this + 29);
  if (v21 != (char *)this + 248) {
    free(v21);
  }
  uint64_t v22 = *((unsigned int *)this + 38);
  if (v22)
  {
    uint64_t v23 = (uint64_t *)*((void *)this + 18);
    uint64_t v24 = 8 * v22;
    do
    {
      uint64_t v25 = *v23++;
      MEMORY[0x1D25D9CD0](v25, 8);
      v24 -= 8;
    }
    while (v24);
  }
  uint64_t v26 = (uint64_t *)*((void *)this + 24);
  uint64_t v27 = *((unsigned int *)this + 50);
  if (v27)
  {
    uint64_t v30 = 16 * v27;
    do
    {
      uint64_t v31 = *v26;
      v26 += 2;
      MEMORY[0x1D25D9CD0](v31, 8);
      v30 -= 16;
    }
    while (v30);
    uint64_t v26 = (uint64_t *)*((void *)this + 24);
  }
  if (v26 != (uint64_t *)((char *)this + 208)) {
    free(v26);
  }
  uint64_t v28 = (char *)*((void *)this + 18);
  if (v28 != (char *)this + 160) {
    free(v28);
  }
  uint64_t v29 = (void *)*((void *)this + 13);
  if (v29)
  {
    *((void *)this + 14) = v29;
    operator delete(v29);
  }
}

uint64_t llvm::MachineFunction::clear(llvm::MachineFunction *this)
{
  uint64_t v2 = *((unsigned int *)this + 92);
  if (v2) {
    bzero(*((void **)this + 45), 8 * v2);
  }
  uint64_t v3 = (llvm::MachineFunction *)*((void *)this + 41);
  if (v3 != (llvm::MachineFunction *)((char *)this + 320))
  {
    do
    {
      uint64_t v4 = (char *)v3 + 48;
      *((void *)v3 + 6) = *((void *)v3 + 6) & 7 | ((unint64_t)v3 + 48);
      *((void *)v3 + 7) = (char *)v3 + 48;
      uint64_t v5 = (llvm::MachineFunction *)*((void *)v3 + 1);
      *(void *)(*(void *)(*((void *)v3 + 4) + 104) + 8 * *((unsigned int *)v3 + 6)) = 0;
      *((_DWORD *)v3 + 6) = -1;
      uint64_t v6 = *(void *)v3;
      uint64_t v7 = (void *)*((void *)v3 + 1);
      *uint64_t v7 = *(void *)v3;
      *(void *)(v6 + 8) = v7;
      *(void *)uint64_t v3 = 0;
      *((void *)v3 + 1) = 0;
      uint64_t v8 = *((void *)v3 + 4);
      unsigned int v9 = *(llvm::MachineJumpTableInfo **)(v8 + 72);
      if (v9) {
        llvm::MachineJumpTableInfo::RemoveMBBFromJumpTables(v9, v3);
      }
      uint64_t v10 = (void *)*((void *)v3 + 19);
      if (v10)
      {
        *((void *)v3 + 20) = v10;
        operator delete(v10);
      }
      uint64_t v11 = (void *)*((void *)v3 + 14);
      if (v11)
      {
        *((void *)v3 + 15) = v11;
        operator delete(v11);
      }
      uint64_t v12 = (void *)*((void *)v3 + 11);
      if (v12)
      {
        *((void *)v3 + 12) = v12;
        operator delete(v12);
      }
      long long v13 = (void *)*((void *)v3 + 8);
      if (v13)
      {
        *((void *)v3 + 9) = v13;
        operator delete(v13);
      }
      for (uint64_t i = *((void *)v3 + 7); v4 != (char *)i; uint64_t i = sub_1CC3195AC((uint64_t)v3 + 40, i))
        ;
      *(void *)uint64_t v3 = *(void *)(v8 + 312);
      *(void *)(v8 + 312) = v3;
      uint64_t v3 = v5;
    }
    while (v5 != (llvm::MachineFunction *)((char *)this + 320));
  }
  *((void *)this + 14) = *((void *)this + 13);
  *((void *)this + 28) = 0;
  *((_DWORD *)this + 60) = 0;
  *((void *)this + 39) = 0;
  *((void *)this + 77) = *((void *)this + 76);
  *((_DWORD *)this + 194) = 0;
  uint64_t v15 = *((void *)this + 5);
  if (v15)
  {
    uint64_t v16 = *(void **)(v15 + 456);
    if (v16)
    {
      *(void *)(v15 + 464) = v16;
      operator delete(v16);
    }
    uint64_t v17 = *(void **)(v15 + 424);
    if (v17 != (void *)(v15 + 440)) {
      free(v17);
    }
    uint64_t v18 = *(void **)(v15 + 352);
    if (v18 != (void *)(v15 + 368)) {
      free(v18);
    }
    unint64_t v19 = *(void **)(v15 + 280);
    if (v19 != (void *)(v15 + 296)) {
      free(v19);
    }
    uint64_t v20 = *(void *)(v15 + 272);
    *(void *)(v15 + 272) = 0;
    if (v20) {
      MEMORY[0x1D25D9CB0](v20, 0x20C8093837F09);
    }
    char v21 = *(void **)(v15 + 232);
    if (v21 != (void *)(v15 + 248)) {
      free(v21);
    }
    uint64_t v22 = *(char **)(v15 + 208);
    uint64_t v23 = *(unsigned int *)(v15 + 216);
    if (v23)
    {
      uint64_t v24 = 40 * v23;
      do
      {
        uint64_t v25 = *(char **)&v22[v24 - 32];
        if (&v22[v24 - 16] != v25) {
          free(v25);
        }
        v24 -= 40;
      }
      while (v24);
      uint64_t v22 = *(char **)(v15 + 208);
    }
    if (v22 != (char *)(v15 + 224)) {
      free(v22);
    }
    uint64_t v26 = *(void **)(v15 + 152);
    if (v26 != (void *)(v15 + 176)) {
      free(v26);
    }
    sub_1CC0D7CD8(v15 + 112);
    if (*(char *)(v15 + 103) < 0) {
      operator delete(*(void **)(v15 + 80));
    }
    uint64_t v27 = *(char **)(v15 + 64);
    uint64_t v28 = *(unsigned int *)(v15 + 72);
    if (v28)
    {
      uint64_t v38 = 24 * v28;
      do
      {
        if (v27[v38 - 1] < 0) {
          operator delete(*(void **)&v27[v38 - 24]);
        }
        v38 -= 24;
      }
      while (v38);
      uint64_t v27 = *(char **)(v15 + 64);
    }
    if (v27 != (char *)(v15 + 80)) {
      free(v27);
    }
    uint64_t v29 = *(void **)(v15 + 24);
    if (v29 != (void *)(v15 + 40)) {
      free(v29);
    }
  }
  uint64_t v30 = (void (***)(void))*((void *)this + 6);
  if (v30) {
    (**v30)(v30);
  }
  uint64_t v31 = (void *)*((void *)this + 7);
  long long v32 = (void *)v31[14];
  if (v32 != v31 + 16) {
    free(v32);
  }
  uint64_t v33 = (void *)v31[10];
  if (v33)
  {
    v31[11] = v33;
    operator delete(v33);
  }
  int v34 = (void *)v31[1];
  if (v34)
  {
    v31[2] = v34;
    operator delete(v34);
  }
  llvm::MachineConstantPool::~MachineConstantPool(*((llvm::MachineConstantPool **)this + 8));
  uint64_t v35 = *((void *)this + 9);
  if (v35)
  {
    int v39 = (void **)(v35 + 8);
    sub_1CBF7EDF0(&v39);
  }
  uint64_t v36 = *((void *)this + 12);
  if (v36) {
    sub_1CD531AC0(v36);
  }
  uint64_t result = *((void *)this + 11);
  if (result)
  {
    return sub_1CD531BCC(result);
  }
  return result;
}

uint64_t sub_1CC349148(llvm::MachineBasicBlock *this)
{
  uint64_t v2 = *((void *)this + 1);
  *(void *)(*(void *)(*((void *)this + 4) + 104) + 8 * *((unsigned int *)this + 6)) = 0;
  *((_DWORD *)this + 6) = -1;
  uint64_t v3 = *(void *)this;
  uint64_t v4 = (void *)*((void *)this + 1);
  *uint64_t v4 = *(void *)this;
  *(void *)(v3 + 8) = v4;
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  uint64_t v5 = *((void *)this + 4);
  uint64_t v6 = *(llvm::MachineJumpTableInfo **)(v5 + 72);
  if (v6) {
    llvm::MachineJumpTableInfo::RemoveMBBFromJumpTables(v6, this);
  }
  llvm::MachineBasicBlock::~MachineBasicBlock(this);
  *(void *)this = *(void *)(v5 + 312);
  *(void *)(v5 + 312) = this;
  return v2;
}

uint64_t llvm::MachineFunction::shouldSplitStack(llvm::MachineFunction *this)
{
  uint64_t v1 = *(void *)(*(void *)this + 112);
  if (!v1) {
    return 0;
  }
  if (!*(_DWORD *)(v1 + 8)) {
    return 0;
  }
  uint64_t v2 = *(void *)(v1 + 40);
  if (!v2) {
    return 0;
  }
  int v3 = *(_DWORD *)(v2 + 40);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(v2 + 24);
  uint64_t v5 = &unk_1EBCBE000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
  {
    uint64_t v18 = v4;
    int v17 = v3;
    int v15 = __cxa_guard_acquire(&qword_1EBCBE588);
    uint64_t v5 = &unk_1EBCBE000;
    int v3 = v17;
    uint64_t v4 = v18;
    if (v15)
    {
      unint64_t v16 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v16 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v16;
      __cxa_guard_release(&qword_1EBCBE588);
      uint64_t v5 = (void *)&unk_1EBCBE000;
      int v3 = v17;
      uint64_t v4 = v18;
    }
  }
  unint64_t v6 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v5[176] ^ 0xFAFE411847E215DDLL)) ^ ((0x9DDFEA08EB382D69
                                                                    * (v5[176] ^ 0xFAFE411847E215DDLL)) >> 47) ^ 0x8E8D6C6C2E8E65AELL);
  unsigned int v7 = (-348639895 * ((v6 >> 47) ^ v6)) ^ 0x732D7469;
  int v8 = v3 - 1;
  for (int i = 1; ; ++i)
  {
    unsigned int v10 = v7 & v8;
    uint64_t v11 = v4 + 24 * v10;
    uint64_t v12 = *(void **)v11;
    if (*(void *)v11 == -1)
    {
      if ("split-stack" == (char *)-1) {
        return 1;
      }
      goto LABEL_9;
    }
    if (v12 != (void *)-2) {
      break;
    }
    if ("split-stack" == (char *)-2) {
      return 1;
    }
LABEL_9:
    if (v12 == (void *)-1) {
      return 0;
    }
    unsigned int v7 = i + v10;
  }
  if (*(void *)(v11 + 8) != 11) {
    goto LABEL_9;
  }
  if (*v12 != 0x74732D74696C7073 || *(void *)((char *)v12 + 3) != 0x6B636174732D7469) {
    goto LABEL_9;
  }
  return 1;
}

void llvm::MachineFunction::RenumberBlocks(llvm::MachineFunction *this, llvm::MachineBasicBlock *a2)
{
  uint64_t v2 = (llvm::MachineFunction *)((char *)this + 320);
  if (*((llvm::MachineFunction **)this + 40) == (llvm::MachineFunction *)((char *)this + 320))
  {
    uint64_t v9 = *((void *)this + 13);
LABEL_16:
    *((void *)this + 14) = v9;
    return;
  }
  if (a2)
  {
    if (*((llvm::MachineBasicBlock **)this + 41) == a2) {
      unsigned int v3 = 0;
    }
    else {
      unsigned int v3 = *(_DWORD *)(*(void *)a2 + 24) + 1;
    }
  }
  else
  {
    unsigned int v3 = 0;
    a2 = (llvm::MachineBasicBlock *)*((void *)this + 41);
  }
  for (; a2 != v2; ++v3)
  {
    uint64_t v4 = *((int *)a2 + 6);
    if (v3 != v4)
    {
      if (v4 != -1) {
        *(void *)(*((void *)this + 13) + 8 * v4) = 0;
      }
      uint64_t v5 = *((void *)this + 13);
      uint64_t v6 = *(void *)(v5 + 8 * v3);
      if (v6) {
        *(_DWORD *)(v6 + 24) = -1;
      }
      *(void *)(v5 + 8 * v3) = a2;
      *((_DWORD *)a2 + 6) = v3;
    }
    a2 = (llvm::MachineBasicBlock *)*((void *)a2 + 1);
  }
  uint64_t v7 = *((void *)this + 13);
  unint64_t v8 = (*((void *)this + 14) - v7) >> 3;
  if (v3 <= v8)
  {
    if (v3 >= v8) {
      return;
    }
    uint64_t v9 = v7 + 8 * v3;
    goto LABEL_16;
  }
  sub_1CD4FEC18((char **)this + 13, v3 - v8);
}

llvm::MachineInstr *llvm::MachineFunction::CreateMachineInstr(llvm::MachineFunction *a1, uint64_t a2, unsigned __int8 **a3, char a4)
{
  unint64_t v8 = (llvm::MachineInstr *)*((void *)a1 + 28);
  if (v8)
  {
    *((void *)a1 + 28) = *(void *)v8;
  }
  else
  {
    *((void *)a1 + 26) += 72;
    uint64_t v11 = *((void *)a1 + 16);
    if (((v11 + 7) & 0xFFFFFFFFFFFFFFF8) - v11 + 72 > *((void *)a1 + 17) - v11)
    {
      unsigned int v12 = *((_DWORD *)a1 + 38) >> 7;
      if (v12 >= 0x1E) {
        LOBYTE(v12) = 30;
      }
      uint64_t v13 = 4096 << v12;
      unint64_t v8 = (llvm::MachineInstr *)operator new(4096 << v12, (std::align_val_t)8uLL);
      unsigned int v14 = *((_DWORD *)a1 + 38);
      if (v14 >= *((_DWORD *)a1 + 39)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*((void *)a1 + 18) + 8 * v14) = v8;
      ++*((_DWORD *)a1 + 38);
      *((void *)a1 + 16) = (char *)v8 + 72;
      *((void *)a1 + 17) = (char *)v8 + v13;
    }
    else
    {
      unint64_t v8 = (llvm::MachineInstr *)((v11 + 7) & 0xFFFFFFFFFFFFFFF8);
      *((void *)a1 + 16) = (char *)v8 + 72;
    }
  }
  uint64_t v9 = *a3;
  int v15 = v9;
  if (v9)
  {
    llvm::MetadataTracking::retrack((uint64_t)a3, v9, (uint64_t)&v15);
    *a3 = 0;
  }
  llvm::MachineInstr::MachineInstr(v8, a1, a2, &v15, a4);
  if (v15) {
    llvm::MetadataTracking::untrack((uint64_t)&v15, v15);
  }
  return v8;
}

unint64_t llvm::MachineFunction::CloneMachineInstr(llvm::MachineFunction *this, const llvm::MachineInstr *a2)
{
  unint64_t v4 = *((void *)this + 28);
  if (v4)
  {
    *((void *)this + 28) = *(void *)v4;
  }
  else
  {
    *((void *)this + 26) += 72;
    uint64_t v12 = *((void *)this + 16);
    if (((v12 + 7) & 0xFFFFFFFFFFFFFFF8) - v12 + 72 > *((void *)this + 17) - v12)
    {
      unsigned int v13 = *((_DWORD *)this + 38) >> 7;
      if (v13 >= 0x1E) {
        LOBYTE(v13) = 30;
      }
      uint64_t v14 = 4096 << v13;
      unint64_t v4 = (unint64_t)operator new(4096 << v13, (std::align_val_t)8uLL);
      unsigned int v15 = *((_DWORD *)this + 38);
      if (v15 >= *((_DWORD *)this + 39)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*((void *)this + 18) + 8 * v15) = v4;
      ++*((_DWORD *)this + 38);
      *((void *)this + 16) = v4 + 72;
      *((void *)this + 17) = v4 + v14;
    }
    else
    {
      unint64_t v4 = (v12 + 7) & 0xFFFFFFFFFFFFFFF8;
      *((void *)this + 16) = v4 + 72;
    }
  }
  *(void *)unint64_t v4 = 0;
  *(void *)(v4 + 8) = 0;
  *(void *)(v4 + 16) = *((void *)a2 + 2);
  *(void *)(v4 + 24) = 0;
  *(void *)(v4 + 32) = 0;
  *(void *)(v4 + 40) = 0;
  *(void *)(v4 + 48) = *((void *)a2 + 6);
  uint64_t v5 = (unsigned __int8 *)*((void *)a2 + 7);
  *(void *)(v4 + 56) = v5;
  if (v5) {
    llvm::MetadataTracking::track(v4 + 56, v5, 2);
  }
  *(_DWORD *)(v4 + 64) = 0;
  unsigned __int8 v6 = 64 - __clz(*((unsigned int *)a2 + 10) - 1);
  if (*((_DWORD *)a2 + 10)) {
    unsigned __int8 v7 = v6;
  }
  else {
    unsigned __int8 v7 = 0;
  }
  *(unsigned char *)(v4 + 47) = v7;
  *(void *)(v4 + 32) = sub_1CC357150((uint64_t *)this + 29, v7, (uint64_t *)this + 16);
  uint64_t v8 = *((unsigned int *)a2 + 10);
  if (v8)
  {
    uint64_t v9 = (const llvm::MachineOperand *)*((void *)a2 + 4);
    uint64_t v10 = 32 * v8;
    do
    {
      llvm::MachineInstr::addOperand((llvm::MachineInstr *)v4, this, v9);
      uint64_t v9 = (const llvm::MachineOperand *)((char *)v9 + 32);
      v10 -= 32;
    }
    while (v10);
  }
  *(_WORD *)(v4 + 44) = *(_WORD *)(v4 + 44) & 0xC | *((_WORD *)a2 + 22) & 0xFFF3;
  return v4;
}

const llvm::MachineInstr *llvm::MachineFunction::cloneMachineInstrBundle(uint64_t a1, uint64_t a2, uint64_t *a3, const llvm::MachineInstr *a4)
{
  uint64_t v8 = 0;
  uint64_t v9 = (uint64_t *)(a1 + 128);
  uint64_t v10 = (uint64_t *)(a1 + 232);
  uint64_t v11 = a4;
  for (i = (uint64_t *)(a1 + 232); ; uint64_t v10 = i)
  {
    uint64_t v12 = *(void *)(a1 + 224);
    if (v12)
    {
      *(void *)(a1 + 224) = *(void *)v12;
    }
    else
    {
      *(void *)(a1 + 208) += 72;
      uint64_t v33 = *(void *)(a1 + 128);
      if (((v33 + 7) & 0xFFFFFFFFFFFFFFF8) - v33 + 72 > *(void *)(a1 + 136) - v33)
      {
        uint64_t v35 = v10;
        unsigned int v36 = *(_DWORD *)(a1 + 152) >> 7;
        if (v36 >= 0x1E) {
          LOBYTE(v36) = 30;
        }
        uint64_t v37 = 4096 << v36;
        uint64_t v12 = (uint64_t)operator new(4096 << v36, (std::align_val_t)8uLL);
        unint64_t v38 = *(unsigned int *)(a1 + 152);
        if (v38 >= *(unsigned int *)(a1 + 156)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        uint64_t v10 = v35;
        *(void *)(*(void *)(a1 + 144) + 8 * v38) = v12;
        ++*(_DWORD *)(a1 + 152);
        *(void *)(a1 + 128) = v12 + 72;
        *(void *)(a1 + 136) = v12 + v37;
      }
      else
      {
        uint64_t v12 = (v33 + 7) & 0xFFFFFFFFFFFFFFF8;
        *uint64_t v9 = v12 + 72;
      }
    }
    *(void *)uint64_t v12 = 0;
    *(void *)(v12 + 8) = 0;
    *(void *)(v12 + 16) = *((void *)v11 + 2);
    *(void *)(v12 + 24) = 0;
    *(void *)(v12 + 32) = 0;
    *(void *)(v12 + 40) = 0;
    *(void *)(v12 + 48) = *((void *)v11 + 6);
    unsigned int v13 = (unsigned __int8 *)*((void *)v11 + 7);
    *(void *)(v12 + 56) = v13;
    if (v13)
    {
      int v34 = v10;
      llvm::MetadataTracking::track(v12 + 56, v13, 2);
      uint64_t v10 = v34;
    }
    *(_DWORD *)(v12 + 64) = 0;
    unsigned __int8 v14 = 64 - __clz(*((unsigned int *)v11 + 10) - 1);
    if (*((_DWORD *)v11 + 10)) {
      unsigned __int8 v15 = v14;
    }
    else {
      unsigned __int8 v15 = 0;
    }
    *(unsigned char *)(v12 + 47) = v15;
    unint64_t v16 = sub_1CC357150(v10, v15, v9);
    *(void *)(v12 + 32) = v16;
    uint64_t v17 = *((unsigned int *)v11 + 10);
    if (v17)
    {
      uint64_t v18 = a2;
      unint64_t v19 = (const llvm::MachineOperand *)*((void *)v11 + 4);
      uint64_t v20 = 32 * v17;
      do
      {
        llvm::MachineInstr::addOperand((llvm::MachineInstr *)v12, (llvm::MachineFunction *)a1, v19);
        unint64_t v19 = (const llvm::MachineOperand *)((char *)v19 + 32);
        v20 -= 32;
      }
      while (v20);
      unint64_t v16 = *(void **)(v12 + 32);
      a2 = v18;
    }
    *(_WORD *)(v12 + 44) = *(_WORD *)(v12 + 44) & 0xC | *((_WORD *)v11 + 22) & 0xFFF3;
    uint64_t v21 = *(void *)(a2 + 40);
    *(void *)(v12 + 24) = v21;
    uint64_t v22 = *(void *)(v21 + 32);
    uint64_t v23 = *(unsigned int *)(v12 + 40);
    if (v23)
    {
      uint64_t v27 = *(void *)(v22 + 40);
      uint64_t v28 = 32 * v23;
      do
      {
        if (!*(unsigned char *)v16)
        {
          uint64_t v29 = *((unsigned int *)v16 + 1);
          if ((int)v29 >= 0) {
            uint64_t v30 = (uint64_t *)(*(void *)(v27 + 272) + 8 * v29);
          }
          else {
            uint64_t v30 = (uint64_t *)(*(void *)(v27 + 24) + 16 * (v29 & 0x7FFFFFFF) + 8);
          }
          uint64_t v31 = *v30;
          if (*v30)
          {
            uint64_t v32 = *(void *)(v31 + 16);
            *(void *)(v31 + 16) = v16;
            long long v16[2] = v32;
            if (*((unsigned char *)v16 + 3))
            {
              void v16[3] = v31;
            }
            else
            {
              void v16[3] = 0;
              uint64_t v30 = (uint64_t *)(v32 + 24);
            }
          }
          else
          {
            long long v16[2] = v16;
            void v16[3] = 0;
          }
          *uint64_t v30 = (uint64_t)v16;
        }
        v16 += 4;
        v28 -= 32;
      }
      while (v28);
    }
    uint64_t v24 = *(void *)(v22 + 728);
    if (v24) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v24 + 24))(v24, v12);
    }
    unint64_t v25 = *a3 & 0xFFFFFFFFFFFFFFF8;
    *(void *)uint64_t v12 = v25 | *(void *)v12 & 7;
    *(void *)(v12 + 8) = a3;
    *(void *)(v25 + 8) = v12;
    *a3 = *a3 & 7 | v12;
    if (v8) {
      llvm::MachineInstr::bundleWithPred(v12);
    }
    else {
      uint64_t v8 = (const llvm::MachineInstr *)v12;
    }
    if ((*((_WORD *)v11 + 22) & 8) == 0) {
      break;
    }
    uint64_t v11 = (const llvm::MachineInstr *)*((void *)v11 + 1);
  }
  if (llvm::MachineInstr::shouldUpdateCallSiteInfo(a4)) {
    llvm::MachineFunction::copyCallSiteInfo((llvm::MachineFunction *)a1, a4, v8);
  }
  return v8;
}

void llvm::MachineFunction::deleteMachineInstr(llvm::MachineFunction *this, llvm::MachineInstr *a2)
{
  unint64_t v4 = (void *)*((void *)a2 + 4);
  if (v4)
  {
    uint64_t v5 = *((unsigned __int8 *)a2 + 47);
    unsigned __int8 v6 = (uint64_t *)((char *)this + 232);
    if (*((_DWORD *)this + 60) <= v5) {
      sub_1CC34BDE0((uint64_t)this + 232, v5 + 1);
    }
    uint64_t v7 = *v6;
    *unint64_t v4 = *(void *)(*v6 + 8 * v5);
    *(void *)(v7 + 8 * v5) = v4;
  }
  *(void *)a2 = *((void *)this + 28);
  *((void *)this + 28) = a2;
}

unint64_t llvm::MachineFunction::CreateMachineBasicBlock(llvm::MachineFunction *this, const llvm::BasicBlock *a2)
{
  unint64_t v4 = *((void *)this + 39);
  if (v4)
  {
    *((void *)this + 39) = *(void *)v4;
  }
  else
  {
    *((void *)this + 26) += 232;
    uint64_t v5 = *((void *)this + 16);
    if (((v5 + 7) & 0xFFFFFFFFFFFFFFF8) - v5 + 232 > *((void *)this + 17) - v5)
    {
      unsigned int v8 = *((_DWORD *)this + 38) >> 7;
      if (v8 >= 0x1E) {
        LOBYTE(v8) = 30;
      }
      uint64_t v9 = 4096 << v8;
      unint64_t v4 = (unint64_t)operator new(4096 << v8, (std::align_val_t)8uLL);
      unsigned int v10 = *((_DWORD *)this + 38);
      if (v10 >= *((_DWORD *)this + 39)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*((void *)this + 18) + 8 * v10) = v4;
      ++*((_DWORD *)this + 38);
      *((void *)this + 16) = v4 + 232;
      *((void *)this + 17) = v4 + v9;
    }
    else
    {
      unint64_t v4 = (v5 + 7) & 0xFFFFFFFFFFFFFFF8;
      *((void *)this + 16) = v4 + 232;
    }
  }
  *(void *)unint64_t v4 = 0;
  *(void *)(v4 + 8) = 0;
  *(void *)(v4 + 16) = a2;
  *(_DWORD *)(v4 + 24) = -1;
  *(void *)(v4 + 48) = (v4 + 48) | 4;
  *(void *)(v4 + 56) = v4 + 48;
  *(unsigned char *)(v4 + 144) = 0;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_OWORD *)(v4 + 80) = 0u;
  *(_OWORD *)(v4 + 96) = 0u;
  *(_OWORD *)(v4 + 112) = 0u;
  *(_OWORD *)(v4 + 121) = 0u;
  *(void *)(v4 + 160) = 0;
  *(void *)(v4 + 1sub_1CC338288((_DWORD *)this + 68) = 0;
  *(void *)(v4 + 152) = 0;
  *(unsigned char *)(v4 + 176) = 0;
  *(_DWORD *)(v4 + 187) = 0;
  *(void *)(v4 + 180) = 0;
  *(void *)(v4 + 192) = 0;
  *(_DWORD *)(v4 + 199) = 0;
  *(void *)(v4 + 216) = 0;
  *(void *)(v4 + 224) = 0;
  *(void *)(v4 + 208) = 0;
  *(void *)(v4 + 32) = this;
  *(void *)(v4 + 40) = v4;
  if (a2)
  {
    *(void *)(v4 + 136) = llvm::BasicBlock::getIrrLoopHeaderWeight(a2);
    *(void *)(v4 + 144) = v6;
  }
  return v4;
}

unint64_t llvm::MachineFunction::getMachineMemOperand(uint64_t a1, uint64_t a2, __int16 a3, uint64_t a4, char a5, long long *a6, uint64_t a7, __int16 a8, char a9, __int16 a10, __int16 a11)
{
  *(void *)(a1 + 208) += 80;
  uint64_t v18 = *(void *)(a1 + 128);
  if (((v18 + 7) & 0xFFFFFFFFFFFFFFF8) - v18 + 80 > *(void *)(a1 + 136) - v18)
  {
    unsigned int v24 = *(_DWORD *)(a1 + 152) >> 7;
    if (v24 >= 0x1E) {
      LOBYTE(v24) = 30;
    }
    uint64_t v26 = 4096 << v24;
    uint64_t v27 = a7;
    unint64_t v19 = (unint64_t)operator new(4096 << v24, (std::align_val_t)8uLL);
    unsigned int v25 = *(_DWORD *)(a1 + 152);
    if (v25 >= *(_DWORD *)(a1 + 156)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 144) + 8 * v25) = v19;
    ++*(_DWORD *)(a1 + 152);
    a7 = v27;
    *(void *)(a1 + 136) = v19 + v26;
  }
  else
  {
    unint64_t v19 = (v18 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *(void *)(a1 + 128) = v19 + 80;
  uint64_t v20 = ((unint64_t)(a4 & 0x1FFFFFFF) << 6) | 1;
  if (a4 == -1) {
    uint64_t v20 = 0;
  }
  uint64_t v21 = *(void *)(a2 + 16);
  *(_OWORD *)unint64_t v19 = *(_OWORD *)a2;
  *(void *)(v19 + 16) = v21;
  *(void *)(v19 + 24) = v20;
  *(_WORD *)(v19 + 32) = a3;
  *(unsigned char *)(v19 + 34) = a5;
  long long v22 = *a6;
  *(_OWORD *)(v19 + 56) = a6[1];
  *(_OWORD *)(v19 + 40) = v22;
  *(void *)(v19 + 72) = a7;
  *(_WORD *)(v19 + 36) = a8 & 0xF0FF | ((a9 & 0xF) << 8) | (a11 << 12);
  return v19;
}

{
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  long long v21;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;

  *(void *)(a1 + 208) += 80;
  uint64_t v18 = *(void *)(a1 + 128);
  if (((v18 + 7) & 0xFFFFFFFFFFFFFFF8) - v18 + 80 > *(void *)(a1 + 136) - v18)
  {
    uint64_t v23 = *(_DWORD *)(a1 + 152) >> 7;
    if (v23 >= 0x1E) {
      LOBYTE(v23) = 30;
    }
    unsigned int v25 = 4096 << v23;
    uint64_t v26 = a7;
    unint64_t v19 = (unint64_t)operator new(4096 << v23, (std::align_val_t)8uLL);
    unsigned int v24 = *(_DWORD *)(a1 + 152);
    if (v24 >= *(_DWORD *)(a1 + 156)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 144) + 8 * v24) = v19;
    ++*(_DWORD *)(a1 + 152);
    a7 = v26;
    *(void *)(a1 + 136) = v19 + v25;
  }
  else
  {
    unint64_t v19 = (v18 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *(void *)(a1 + 128) = v19 + 80;
  uint64_t v20 = *(void *)(a2 + 16);
  *(_OWORD *)unint64_t v19 = *(_OWORD *)a2;
  *(void *)(v19 + 16) = v20;
  *(void *)(v19 + 24) = a4;
  *(_WORD *)(v19 + 32) = a3;
  *(unsigned char *)(v19 + 34) = a5;
  uint64_t v21 = *a6;
  *(_OWORD *)(v19 + 56) = a6[1];
  *(_OWORD *)(v19 + 40) = v21;
  *(void *)(v19 + 72) = a7;
  *(_WORD *)(v19 + 36) = a8 & 0xF0FF | ((a9 & 0xF) << 8) | (a11 << 12);
  return v19;
}

unint64_t llvm::MachineFunction::getMachineMemOperand(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v8 = 63 - __clz(((1 << *(unsigned char *)(a2 + 34)) | a3) & -((1 << *(unsigned char *)(a2 + 34)) | a3));
  if (*(void *)a2 <= 7uLL) {
    char v9 = v8;
  }
  else {
    char v9 = *(unsigned char *)(a2 + 34);
  }
  *(void *)(a1 + 208) += 80;
  uint64_t v10 = *(void *)(a1 + 128);
  if (((v10 + 7) & 0xFFFFFFFFFFFFFFF8) - v10 + 80 > *(void *)(a1 + 136) - v10)
  {
    unsigned int v18 = *(_DWORD *)(a1 + 152) >> 7;
    if (v18 >= 0x1E) {
      LOBYTE(v18) = 30;
    }
    uint64_t v19 = 4096 << v18;
    unint64_t v11 = (unint64_t)operator new(4096 << v18, (std::align_val_t)8uLL);
    unsigned int v20 = *(_DWORD *)(a1 + 152);
    if (v20 >= *(_DWORD *)(a1 + 156)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 144) + 8 * v20) = v11;
    ++*(_DWORD *)(a1 + 152);
    *(void *)(a1 + 136) = v11 + v19;
  }
  else
  {
    unint64_t v11 = (v10 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *(void *)(a1 + 128) = v11 + 80;
  sub_1CB8F0264((uint64_t *)a2, a3, (uint64_t)&v21);
  __int16 v12 = *(_WORD *)(a2 + 32);
  long long v13 = *(_OWORD *)(a2 + 40);
  long long v14 = *(_OWORD *)(a2 + 56);
  __int16 v15 = *(_WORD *)(a2 + 36);
  uint64_t v16 = v22;
  *(_OWORD *)unint64_t v11 = v21;
  *(void *)(v11 + 16) = v16;
  *(void *)(v11 + 24) = a4;
  *(_WORD *)(v11 + 32) = v12;
  *(unsigned char *)(v11 + 34) = v9;
  *(_OWORD *)(v11 + 56) = v14;
  *(_OWORD *)(v11 + 40) = v13;
  *(void *)(v11 + 72) = 0;
  *(_WORD *)(v11 + 36) = v15;
  return v11;
}

unint64_t llvm::MachineFunction::getMachineMemOperand(uint64_t a1, uint64_t a2, long long *a3)
{
  unint64_t v6 = *(void *)a2 & 0xFFFFFFFFFFFFFFF8;
  if ((*(void *)a2 & 4) != 0 || !v6)
  {
    if ((*(void *)a2 & 4) != 0) {
      unint64_t v10 = *(void *)a2 & 0xFFFFFFFFFFFFFFF8;
    }
    else {
      unint64_t v10 = 0;
    }
    uint64_t v7 = *(void *)(a2 + 8);
    unint64_t v6 = v10 | 4;
    if (v10) {
      unsigned int v9 = *(_DWORD *)(v10 + 12);
    }
    else {
      unsigned int v9 = 0;
    }
  }
  else
  {
    uint64_t v7 = *(void *)(a2 + 8);
    unsigned int v8 = *(_DWORD *)(*(void *)v6 + 8);
    if ((v8 & 0xFE) == 0x12) {
      unsigned int v8 = *(_DWORD *)(**(void **)(*(void *)v6 + 16) + 8);
    }
    unsigned int v9 = v8 >> 8;
  }
  *(void *)(a1 + 208) += 80;
  uint64_t v11 = *(void *)(a1 + 128);
  if (((v11 + 7) & 0xFFFFFFFFFFFFFFF8) - v11 + 80 > *(void *)(a1 + 136) - v11)
  {
    unsigned int v22 = *(_DWORD *)(a1 + 152) >> 7;
    if (v22 >= 0x1E) {
      LOBYTE(v22) = 30;
    }
    uint64_t v23 = 4096 << v22;
    unint64_t v12 = (unint64_t)operator new(4096 << v22, (std::align_val_t)8uLL);
    unsigned int v24 = *(_DWORD *)(a1 + 152);
    if (v24 >= *(_DWORD *)(a1 + 156)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 144) + 8 * v24) = v12;
    ++*(_DWORD *)(a1 + 152);
    *(void *)(a1 + 136) = v12 + v23;
  }
  else
  {
    unint64_t v12 = (v11 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *(void *)(a1 + 128) = v12 + 80;
  __int16 v13 = *(_WORD *)(a2 + 32);
  if ((*(void *)(a2 + 24) & 0xFFFFFFFFFFFFFFF9) != 0)
  {
    unint64_t v15 = (unint64_t)(sub_1CB8F1DC4((unint64_t *)(a2 + 24)) + 7) >> 3;
    if (v14 == 1) {
  }
    }
  else
  {
    unint64_t v15 = -1;
  }
  char v16 = *(unsigned char *)(a2 + 34);
  uint64_t v17 = *(void *)(a2 + 72);
  __int16 v18 = *(_WORD *)(a2 + 36);
  uint64_t v19 = ((v15 & 0x1FFFFFFF) << 6) | 1;
  if (v15 == -1) {
    uint64_t v19 = 0;
  }
  *(void *)unint64_t v12 = v6;
  *(void *)(v12 + 8) = v7;
  *(_DWORD *)(v12 + 16) = v9;
  *(unsigned char *)(v12 + 20) = 0;
  *(void *)(v12 + 24) = v19;
  *(_WORD *)(v12 + 32) = v13;
  *(unsigned char *)(v12 + 34) = v16;
  long long v20 = *a3;
  *(_OWORD *)(v12 + 56) = a3[1];
  *(_OWORD *)(v12 + 40) = v20;
  *(void *)(v12 + 72) = v17;
  *(_WORD *)(v12 + 36) = v18;
  return v12;
}

unint64_t llvm::MachineFunction::getMachineMemOperand(uint64_t a1, long long *a2, __int16 a3)
{
  *(void *)(a1 + 208) += 80;
  uint64_t v6 = *(void *)(a1 + 128);
  if (((v6 + 7) & 0xFFFFFFFFFFFFFFF8) - v6 + 80 > *(void *)(a1 + 136) - v6)
  {
    unsigned int v17 = *(_DWORD *)(a1 + 152) >> 7;
    if (v17 >= 0x1E) {
      LOBYTE(v17) = 30;
    }
    uint64_t v18 = 4096 << v17;
    unint64_t v7 = (unint64_t)operator new(4096 << v17, (std::align_val_t)8uLL);
    unsigned int v19 = *(_DWORD *)(a1 + 152);
    if (v19 >= *(_DWORD *)(a1 + 156)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 144) + 8 * v19) = v7;
    ++*(_DWORD *)(a1 + 152);
    *(void *)(a1 + 136) = v7 + v18;
  }
  else
  {
    unint64_t v7 = (v6 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *(void *)(a1 + 128) = v7 + 80;
  long long v20 = *a2;
  uint64_t v21 = *((void *)a2 + 2);
  if ((*((void *)a2 + 3) & 0xFFFFFFFFFFFFFFF9) != 0)
  {
    unint64_t v9 = (unint64_t)(sub_1CB8F1DC4((unint64_t *)a2 + 3) + 7) >> 3;
    if (v8 == 1) {
  }
    }
  else
  {
    unint64_t v9 = -1;
  }
  char v10 = *((unsigned char *)a2 + 34);
  long long v11 = *(long long *)((char *)a2 + 40);
  long long v12 = *(long long *)((char *)a2 + 56);
  uint64_t v13 = *((void *)a2 + 9);
  __int16 v14 = *((_WORD *)a2 + 18);
  uint64_t v15 = ((v9 & 0x1FFFFFFF) << 6) | 1;
  if (v9 == -1) {
    uint64_t v15 = 0;
  }
  *(_OWORD *)unint64_t v7 = v20;
  *(void *)(v7 + 16) = v21;
  *(void *)(v7 + 24) = v15;
  *(_WORD *)(v7 + 32) = a3;
  *(unsigned char *)(v7 + 34) = v10;
  *(_OWORD *)(v7 + 56) = v12;
  *(_OWORD *)(v7 + 40) = v11;
  *(void *)(v7 + 72) = v13;
  *(_WORD *)(v7 + 36) = v14;
  return v7;
}

uint64_t llvm::MachineFunction::createMIExtraInfo(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return sub_1CC34A418((uint64_t *)(a1 + 128), a2, a3, a4, a5, a6);
}

uint64_t sub_1CC34A418(uint64_t *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v11 = a4 != 0;
  if (a4) {
    uint64_t v12 = a3 + 1;
  }
  else {
    uint64_t v12 = a3;
  }
  BOOL v13 = a5 != 0;
  if (a5) {
    ++v12;
  }
  BOOL v14 = a6 != 0;
  if (a6) {
    ++v12;
  }
  uint64_t v15 = sub_1CB906F34(a1, 8 * v12 + 8, 3);
  uint64_t v16 = v15;
  *(_DWORD *)uint64_t v15 = a3;
  *(unsigned char *)(v15 + 4) = v11;
  *(unsigned char *)(v15 + 5) = v13;
  *(unsigned char *)(v15 + 6) = v14;
  uint64_t v17 = v15 + 8;
  if (a3) {
    memmove((void *)(v15 + 8), a2, 8 * a3);
  }
  if (a4) {
    *(void *)(v17 + 8 * (int)a3) = a4;
  }
  if (a5) {
    *(void *)(v17 + 8 * (int)a3 + 8 * v11) = a5;
  }
  if (a6) {
    *(void *)(v17 + 8 * (int)a3 + 8 * (v13 + v11)) = a6;
  }
  return v16;
}

unsigned char *llvm::MachineFunction::createExternalSymbolName(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t v5 = (unsigned char *)sub_1CB906F34((uint64_t *)(a1 + 128), a3 + 1, 0);
  uint64_t v6 = v5;
  if (a3) {
    memmove(v5, a2, a3);
  }
  v6[a3] = 0;
  return v6;
}

void llvm::MachineFunction::allocateRegMask(llvm::MachineFunction *this)
{
  unsigned int v2 = *(_DWORD *)((*(uint64_t (**)(void))(**((void **)this + 2) + 176))(*((void *)this + 2)) + 16)
     + 31;
  unsigned int v3 = (uint64_t *)((char *)this + 128);
  size_t v4 = (v2 >> 3) & 0x1FFFFFFC;
  uint64_t v5 = (void *)sub_1CB906F34(v3, v4, 2);

  bzero(v5, v4);
}

void *llvm::MachineFunction::allocateShuffleMask(uint64_t a1, const void *a2, uint64_t a3)
{
  size_t v5 = 4 * a3;
  uint64_t v6 = (void *)sub_1CB906F34((uint64_t *)(a1 + 128), 4 * a3, 2);
  unint64_t v7 = v6;
  if (a3) {
    memmove(v6, a2, v5);
  }
  return v7;
}

uint64_t llvm::MachineFunction::needsFrameMovesForDebug(llvm::MachineFunction *this)
{
  if (*(unsigned char *)(*((void *)this + 4) + 2108)) {
    return 1;
  }
  else {
    return (*(unsigned __int16 *)(*((void *)this + 1) + 1064) >> 4) & 1;
  }
}

double llvm::MachineFunction::viewCFG(llvm::MachineFunction *this)
{
  uint64_t v1 = (llvm::raw_ostream *)llvm::errs(this);
  unsigned int v2 = (void *)*((void *)v1 + 4);
  if (*((void *)v1 + 3) - (void)v2 > 0x3DuLL)
  {
    qmemcpy(v2, "MachineFunction::viewCFG is only available in debug builds on ", 62);
    unsigned int v3 = (void *)(*((void *)v1 + 4) + 62);
    *((void *)v1 + 4) = v3;
  }
  else
  {
    uint64_t v1 = llvm::raw_ostream::write(v1, "MachineFunction::viewCFG is only available in debug builds on ", 0x3EuLL);
    unsigned int v3 = (void *)*((void *)v1 + 4);
  }
  if (*((void *)v1 + 3) - (void)v3 > 0x1CuLL)
  {
    qmemcpy(v3, "systems with Graphviz or gv!\n", 29);
    double result = *(double *)"Graphviz or gv!\n";
    *((void *)v1 + 4) += 29;
  }
  else
  {
    llvm::raw_ostream::write(v1, "systems with Graphviz or gv!\n", 0x1DuLL);
  }
  return result;
}

double llvm::MachineFunction::viewCFGOnly(llvm::MachineFunction *this)
{
  uint64_t v1 = (llvm::raw_ostream *)llvm::errs(this);
  unsigned int v2 = (void *)*((void *)v1 + 4);
  if (*((void *)v1 + 3) - (void)v2 > 0x41uLL)
  {
    qmemcpy(v2, "MachineFunction::viewCFGOnly is only available in debug builds on ", 66);
    unsigned int v3 = (void *)(*((void *)v1 + 4) + 66);
    *((void *)v1 + 4) = v3;
  }
  else
  {
    uint64_t v1 = llvm::raw_ostream::write(v1, "MachineFunction::viewCFGOnly is only available in debug builds on ", 0x42uLL);
    unsigned int v3 = (void *)*((void *)v1 + 4);
  }
  if (*((void *)v1 + 3) - (void)v3 > 0x1CuLL)
  {
    qmemcpy(v3, "systems with Graphviz or gv!\n", 29);
    double result = *(double *)"Graphviz or gv!\n";
    *((void *)v1 + 4) += 29;
  }
  else
  {
    llvm::raw_ostream::write(v1, "systems with Graphviz or gv!\n", 0x1DuLL);
  }
  return result;
}

uint64_t llvm::MachineFunction::addLiveIn(uint64_t a1, unsigned int a2, uint64_t a3)
{
  size_t v4 = *(void **)(a1 + 40);
  uint64_t v5 = v4[57];
  uint64_t v6 = v4[58] - v5;
  if (!v6) {
    goto LABEL_5;
  }
  unint64_t v7 = (unsigned int *)(v5 + 4);
  uint64_t v8 = 8 * (v6 >> 3);
  while (*(v7 - 1) != a2)
  {
    v7 += 2;
    v8 -= 8;
    if (!v8) {
      goto LABEL_5;
    }
  }
  uint64_t IncompleteVirtualRegister = *v7;
  if (!IncompleteVirtualRegister)
  {
LABEL_5:
    uint64_t v9 = a2;
    uint64_t IncompleteVirtualRegister = llvm::MachineRegisterInfo::createIncompleteVirtualRegister(*(void *)(a1 + 40), "", 0);
    *(void *)(v4[3] + 16 * (IncompleteVirtualRegister & 0x7FFFFFFF)) = a3 & 0xFFFFFFFFFFFFFFFBLL;
    uint64_t v11 = v4[1];
    if (v11) {
      (*(void (**)(uint64_t, void))(*(void *)v11 + 24))(v11, IncompleteVirtualRegister);
    }
    unint64_t v12 = v9 | ((unint64_t)IncompleteVirtualRegister << 32);
    BOOL v14 = (unint64_t *)v4[58];
    unint64_t v13 = v4[59];
    if ((unint64_t)v14 < v13)
    {
      *BOOL v14 = v12;
      unsigned int v22 = v14 + 1;
    }
    else
    {
      uint64_t v15 = (void *)v4[57];
      uint64_t v16 = v14 - v15;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 61) {
        abort();
      }
      uint64_t v18 = v13 - (void)v15;
      if (v18 >> 2 > v17) {
        unint64_t v17 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 61) {
          sub_1CB833614();
        }
        long long v20 = (char *)operator new(8 * v19);
      }
      else
      {
        long long v20 = 0;
      }
      uint64_t v21 = (unint64_t *)&v20[8 * v16];
      *uint64_t v21 = v12;
      unsigned int v22 = v21 + 1;
      if (v14 != v15)
      {
        do
        {
          unint64_t v23 = *--v14;
          *--uint64_t v21 = v23;
        }
        while (v14 != v15);
        BOOL v14 = (unint64_t *)v4[57];
      }
      v4[57] = v21;
      v4[58] = v22;
      v4[59] = &v20[8 * v19];
      if (v14) {
        operator delete(v14);
      }
    }
    v4[58] = v22;
  }
  return IncompleteVirtualRegister;
}

uint64_t llvm::MachineFunction::getPICBaseSymbol(llvm::MCContext **this)
{
  uint64_t v1 = *(int *)(*((void *)*this + 5) + 300);
  uint64_t v2 = qword_1CFAC7138[v1];
  unsigned int v3 = this[3];
  uint64_t v4 = *((unsigned int *)this + 84);
  v6[0] = *((void *)&off_1E682F670 + v1);
  v6[1] = v2;
  void v6[2] = v4;
  __int16 v7 = 2053;
  v8[0] = (unsigned __int8 **)v6;
  v8[2] = (unsigned __int8 **)"$pb";
  __int16 v9 = 770;
  return llvm::MCContext::getOrCreateSymbol(v3, v8);
}

llvm::MachineBasicBlock *llvm::MachineFunction::addLandingPad(llvm::MachineFunction *this, llvm::MachineBasicBlock *a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (llvm::MCContext *)*((void *)this + 3);
  int v34 = "tmp";
  v36[8] = 259;
  TempSymbol = (llvm::MachineBasicBlock *)llvm::MCContext::createTempSymbol(v4, (const llvm::Twine *)&v34, 1);
  llvm::MachineFunction::getOrCreateLandingPadInfo(this, a2)[11] = TempSymbol;
  uint64_t v6 = *((void *)a2 + 2);
  uint64_t v7 = v6 + 40;
  for (uint64_t i = *(void *)(v6 + 48); ; uint64_t i = *(void *)(i + 8))
  {
    if (i == v7) {
      return TempSymbol;
    }
    uint64_t v9 = i - 24;
    uint64_t v10 = i ? i - 24 : 0;
    if (*(unsigned char *)(v10 + 16) != 83) {
      break;
    }
  }
  int v11 = *(unsigned __int8 *)(i - 8);
  if (v11 == 80)
  {
    if ((*(_DWORD *)(i - 4) & 0x7FFFFFF) != 1)
    {
      unsigned int v15 = (*(_DWORD *)(i - 4) & 0x7FFFFFF) - 2;
      do
      {
        uint64_t v16 = v15;
        unint64_t v17 = llvm::Value::stripPointerCasts(*(llvm::Value **)(v9 - 32 * (*(_DWORD *)(i - 4) & 0x7FFFFFF) + 32 * v15));
        if (*((unsigned __int8 *)v17 + 16) >= 4u) {
          uint64_t v18 = 0;
        }
        else {
          uint64_t v18 = v17;
        }
        int v34 = v18;
        llvm::MachineFunction::addCatchTypeInfo(this, a2, (uint64_t)&v34, 1);
        --v15;
      }
      while (v16);
    }
  }
  else if (v11 == 94)
  {
    uint64_t v12 = *(void *)this;
    int v13 = *(_DWORD *)(*(void *)this + 20);
    if ((v13 & 0x40000000) != 0) {
      BOOL v14 = *(llvm::Value ***)(v12 - 8);
    }
    else {
      BOOL v14 = (llvm::Value **)(v12 - 32 * (v13 & 0x7FFFFFF));
    }
    unint64_t v19 = llvm::Value::stripPointerCasts(*v14);
    if (v19) {
      BOOL v20 = *((unsigned char *)v19 + 16) == 0;
    }
    else {
      BOOL v20 = 0;
    }
    if (v20) {
      llvm::MachineModuleInfo::addPersonality(*((llvm::MachineModuleInfo **)this + 4), (const Function *)v19);
    }
    if (*(_WORD *)(i - 6)) {
      llvm::MachineFunction::addCleanup(this, a2);
    }
    unsigned int v21 = *(_DWORD *)(i - 4) & 0x7FFFFFF;
    while (v21)
    {
      --v21;
      int v22 = *(_DWORD *)(i - 4);
      if ((v22 & 0x40000000) != 0) {
        uint64_t v23 = *(void *)(i - 32);
      }
      else {
        uint64_t v23 = v9 - 32 * (v22 & 0x7FFFFFF);
      }
      unsigned int v24 = *(llvm::Value **)(v23 + 32 * v21);
      if (*(unsigned char *)(*(void *)v24 + 8) != 17)
      {
        uint64_t v30 = llvm::Value::stripPointerCasts(v24);
        if (*((unsigned __int8 *)v30 + 16) >= 4u) {
          uint64_t v31 = 0;
        }
        else {
          uint64_t v31 = v30;
        }
        int v34 = v31;
        llvm::MachineFunction::addCatchTypeInfo(this, a2, (uint64_t)&v34, 1);
        continue;
      }
      int v34 = v36;
      uint64_t v35 = 0x400000000;
      int v25 = *((_DWORD *)v24 + 5);
      if ((v25 & 0x40000000) != 0)
      {
        uint64_t v27 = (llvm::Value **)*((void *)v24 - 1);
        uint64_t v26 = v25 & 0x7FFFFFF;
        if (v26)
        {
LABEL_35:
          uint64_t v28 = 32 * v26;
          do
          {
            uint64_t v29 = llvm::Value::stripPointerCasts(*v27);
            if (v35 >= (unint64_t)HIDWORD(v35)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v34 + v35) = v29;
            LODWORD(v26) = v35 + 1;
            LODWORD(v35) = v35 + 1;
            v27 += 4;
            v28 -= 32;
          }
          while (v28);
          uint64_t v32 = v34;
          goto LABEL_46;
        }
      }
      else
      {
        uint64_t v26 = v25 & 0x7FFFFFF;
        uint64_t v27 = (llvm::Value **)((char *)v24 - 32 * v26);
        if (v26) {
          goto LABEL_35;
        }
      }
      uint64_t v32 = v36;
LABEL_46:
      llvm::MachineFunction::addFilterTypeInfo(this, a2, (uint64_t)v32, v26);
      if (v34 != v36) {
        free(v34);
      }
    }
  }
  return TempSymbol;
}

void *sub_1CC34AD04(void *result, __n128 *a2)
{
  uint64_t v2 = a2;
  unsigned int v3 = result;
  uint64_t v4 = (__n128 *)result[1];
  if (&a2[7].n128_i8[8] != (__int8 *)v4)
  {
    do
    {
      uint64_t v5 = v2;
      uint64_t v2 = (__n128 *)((char *)v2 + 120);
      double result = sub_1CD532BC8(v5, v2);
    }
    while (result + 30 != (void *)v4);
    uint64_t v4 = (__n128 *)v3[1];
  }
  while (v4 != v2)
  {
    uint64_t v4 = (__n128 *)((char *)v4 - 120);
    double result = sub_1CD531C78(v4);
  }
  v3[1] = v2;
  return result;
}

llvm::MachineBasicBlock **llvm::MachineFunction::addSEHCatchHandler(llvm::MachineFunction *this, llvm::MachineBasicBlock *a2, const llvm::Function *a3, const llvm::BlockAddress *a4)
{
  double result = llvm::MachineFunction::getOrCreateLandingPadInfo(this, a2);
  unsigned int v7 = *((_DWORD *)result + 16);
  if (v7 >= *((_DWORD *)result + 17)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v8 = (void *)((char *)result[7] + 16 * v7);
  *uint64_t v8 = a3;
  v8[1] = a4;
  ++*((_DWORD *)result + 16);
  return result;
}

llvm::MachineBasicBlock **llvm::MachineFunction::addSEHCleanupHandler(llvm::MachineFunction *this, llvm::MachineBasicBlock *a2, const llvm::Function *a3)
{
  double result = llvm::MachineFunction::getOrCreateLandingPadInfo(this, a2);
  unsigned int v5 = *((_DWORD *)result + 16);
  if (v5 >= *((_DWORD *)result + 17)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v6 = (void *)((char *)result[7] + 16 * v5);
  void *v6 = a3;
  v6[1] = 0;
  ++*((_DWORD *)result + 16);
  return result;
}

void sub_1CC34AE58(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(unsigned char **)a1;
  if (a2 > (uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 2)
  {
    if (a2 >> 62) {
      abort();
    }
    unsigned int v5 = *(unsigned char **)(a1 + 8);
    uint64_t v6 = (char *)operator new(4 * a2);
    unsigned int v7 = &v6[(v5 - v2) & 0xFFFFFFFFFFFFFFFCLL];
    uint64_t v8 = v7;
    if (v5 != v2)
    {
      uint64_t v8 = &v6[(v5 - v2) & 0xFFFFFFFFFFFFFFFCLL];
      do
      {
        int v9 = *((_DWORD *)v5 - 1);
        v5 -= 4;
        *((_DWORD *)v8 - 1) = v9;
        v8 -= 4;
      }
      while (v5 != v2);
    }
    *(void *)a1 = v8;
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = &v6[4 * a2];
    if (v2)
    {
      operator delete(v2);
    }
  }
}

unint64_t sub_1CC34AF10(unint64_t result)
{
  if (**(_WORD **)(result + 16) == 20)
  {
    __int16 v1 = *(_WORD *)(result + 44);
    unint64_t v2 = result;
    if ((v1 & 4) != 0)
    {
      unint64_t v2 = result;
      do
        unint64_t v2 = *(void *)v2 & 0xFFFFFFFFFFFFFFF8;
      while ((*(_WORD *)(v2 + 44) & 4) != 0);
    }
    if ((v1 & 8) != 0)
    {
      do
        double result = *(void *)(result + 8);
      while ((*(_WORD *)(result + 44) & 8) != 0);
    }
    for (i = *(void *)(result + 8); v2 != i; unint64_t v2 = *(void *)(result + 8))
    {
      double result = v2;
      uint64_t v4 = *(unsigned __int16 **)(v2 + 16);
      if ((v4[4] & 0x80) != 0)
      {
        unsigned int v5 = *v4;
        BOOL v6 = v5 > 0x1F;
        unsigned int v7 = (1 << v5) & 0x8E000000;
        if (v6 || v7 == 0) {
          break;
        }
      }
    }
  }
  return result;
}

uint64_t llvm::MachineFunction::setDebugInstrNumberingCount(uint64_t this, int a2)
{
  *(_DWORD *)(this + 912) = a2;
  return this;
}

unint64_t llvm::MachineFunction::salvageCopySSA(llvm::MachineFunction *this, llvm::MachineInstr *a2)
{
  uint64_t v104[2] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = *((void *)this + 5);
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(*(void *)v4 + 16) + 176))(*(void *)(*(void *)v4 + 16));
  uint64_t v6 = (*(uint64_t (**)(void))(**((void **)this + 2) + 104))(*((void *)this + 2));
  uint64_t v7 = v6;
  int v8 = **((unsigned __int16 **)a2 + 2);
  if (v8 == 11)
  {
    uint64_t v12 = *((void *)a2 + 4);
    uint64_t v10 = (int *)(v12 + 68);
    int v13 = *(_DWORD *)(v12 + 112);
  }
  else
  {
    if (v8 == 19)
    {
      uint64_t v9 = *((void *)a2 + 4);
      uint64_t v10 = (int *)(v9 + 36);
      unsigned int v11 = *(_DWORD *)(v9 + 32);
    }
    else
    {
      (*(void (**)(unsigned __int8 ***__return_ptr, uint64_t, llvm::MachineInstr *))(*(void *)v6 + 416))(&v97, v6, a2);
      uint64_t v10 = (int *)(v98 + 4);
      unsigned int v11 = *(_DWORD *)v98;
    }
    int v13 = (v11 >> 8) & 0xFFF;
  }
  int v14 = *v10;
  int v102 = v104;
  uint64_t v103 = 0x400000000;
  if ((v14 & 0x80000000) == 0)
  {
LABEL_28:
    int v24 = **((unsigned __int16 **)a2 + 2);
    uint64_t v95 = this;
    if (v24 == 11)
    {
      int v25 = (unsigned int *)(*((void *)a2 + 4) + 68);
    }
    else if (v24 == 19)
    {
      int v25 = (unsigned int *)(*((void *)a2 + 4) + 36);
    }
    else
    {
      (*(void (**)(unsigned __int8 ***__return_ptr, uint64_t, llvm::MachineInstr *))(*(void *)v7 + 416))(&v97, v7, a2);
      int v25 = (unsigned int *)(v98 + 4);
    }
    uint64_t v26 = *v25;
    int v94 = (void *)*((void *)a2 + 3);
    uint64_t v27 = v94 + 6;
    if (a2 != (llvm::MachineInstr *)(v94 + 6))
    {
      unsigned int v28 = v26 - 1;
      uint64_t v96 = (void *)(v5 + 8);
      while (1)
      {
        uint64_t v29 = *((unsigned int *)a2 + 10);
        if (v29) {
          break;
        }
LABEL_43:
        a2 = (llvm::MachineInstr *)(*(void *)a2 & 0xFFFFFFFFFFFFFFF8);
        uint64_t v27 = v94 + 6;
        if (v94 + 6 == (void *)a2) {
          goto LABEL_44;
        }
      }
      uint64_t v30 = 0;
      uint64_t v31 = 32 * v29;
      uint64_t v32 = (unsigned int *)(*((void *)a2 + 4) + 4);
      while (1)
      {
        if ((*(v32 - 1) & 0x10000FF) == 0x1000000)
        {
          unsigned int v33 = *v32;
          if (*v32 == v26) {
            break;
          }
          if (v28 <= 0x3FFFFFFE && v33 - 1 <= 0x3FFFFFFE)
          {
            uint64_t v34 = v26;
            BOOL v35 = llvm::MCRegisterInfo::regsOverlap(v96, v26, v33);
            uint64_t v26 = v34;
            if (v35) {
              break;
            }
          }
        }
        v30 += 0x100000000;
        v32 += 8;
        v31 -= 32;
        if (!v31) {
          goto LABEL_43;
        }
      }
      unsigned int v56 = *((_DWORD *)a2 + 16);
      if (!v56)
      {
        uint64_t v57 = *(void *)(*((void *)a2 + 3) + 32);
        unsigned int v56 = *(_DWORD *)(v57 + 912) + 1;
        *(_DWORD *)(v57 + 912) = v56;
        *((_DWORD *)a2 + 16) = v56;
      }
      if (v103)
      {
        unsigned int v58 = v56 | v30;
        uint64_t v59 = 4 * v103;
        unsigned int v60 = (char *)v102 - 4;
        do
        {
          int v61 = *(_DWORD *)&v60[v59];
          unint64_t v4 = (*((_DWORD *)v95 + 228) + 1);
          *((_DWORD *)v95 + 228) = v4;
          int v97 = (unsigned __int8 **)v4;
          unint64_t v98 = v30 | v58;
          LODWORD(v99) = v61;
          unint64_t v62 = sub_1CD532FE4((uint64_t)v95 + 920, (unint64_t)&v97, 1);
          uint64_t v30 = 0;
          uint64_t v63 = *((void *)v95 + 115) + 20 * *((unsigned int *)v95 + 232);
          long long v64 = *(_OWORD *)v62;
          *(_DWORD *)(v63 + 16) = *(_DWORD *)(v62 + 16);
          *(_OWORD *)uint64_t v63 = v64;
          ++*((_DWORD *)v95 + 232);
          unsigned int v58 = v4;
          v59 -= 4;
        }
        while (v59);
      }
      else
      {
        unint64_t v4 = v30 | v56;
      }
      goto LABEL_66;
    }
LABEL_44:
    int v36 = v26;
    uint64_t v37 = v94;
    uint64_t v38 = v94[7];
    if ((unint64_t *)v38 == v27)
    {
      int v39 = v95;
      uint64_t v40 = v7;
    }
    else
    {
      int v39 = v95;
      uint64_t v40 = v7;
      while (!**(_WORD **)(v38 + 16) || **(_WORD **)(v38 + 16) == 69)
      {
        uint64_t v38 = *(void *)(v38 + 8);
        if ((unint64_t *)v38 == v27) {
          goto LABEL_51;
        }
      }
      uint64_t v27 = (unint64_t *)v38;
    }
LABEL_51:
    uint64_t v41 = *(void *)(v40 + 8) + 768;
    uint64_t v42 = (llvm::MachineFunction *)v94[4];
    uint64_t v101 = 0;
    unsigned int v43 = llvm::MachineFunction::CreateMachineInstr(v42, v41, &v101, 0);
    if (v101)
    {
      int v90 = *v101;
      if ((v90 - 4) > 0x1E)
      {
        if ((v90 - 3) >= 0xFFFFFFFE) {
          uint64_t v93 = v101;
        }
        else {
          uint64_t v93 = 0;
        }
        if ((v90 - 3) < 0xFFFFFFFE)
        {
          uint64_t v37 = v94;
          if (v90 == 3) {
            *((void *)v101 + 1) = 0;
          }
          goto LABEL_52;
        }
        unint64_t v92 = (unint64_t)(v93 + 8);
      }
      else
      {
        uint64_t v37 = v94;
        if ((v101[1] & 0x7F) != 2 && !*((_DWORD *)v101 + 3)) {
          goto LABEL_52;
        }
        uint64_t v91 = *((void *)v101 + 2);
        if ((v91 & 4) == 0) {
          goto LABEL_52;
        }
        unint64_t v92 = v91 & 0xFFFFFFFFFFFFFFF8;
        if (!v92) {
          goto LABEL_52;
        }
      }
      int v97 = &v101;
      sub_1CC5FA668(v92 + 16, &v97);
      uint64_t v37 = v94;
    }
LABEL_52:
    uint64_t v44 = v37[5];
    *((void *)v43 + 3) = v44;
    uint64_t v45 = *(void *)(v44 + 32);
    uint64_t v46 = *((unsigned int *)v43 + 10);
    if (v46)
    {
      uint64_t v72 = *((void *)v43 + 4);
      uint64_t v73 = *(void *)(v45 + 40);
      uint64_t v74 = 32 * v46;
      do
      {
        if (!*(unsigned char *)v72)
        {
          uint64_t v75 = *(unsigned int *)(v72 + 4);
          if ((int)v75 >= 0) {
            unsigned int v76 = (uint64_t *)(*(void *)(v73 + 272) + 8 * v75);
          }
          else {
            unsigned int v76 = (uint64_t *)(*(void *)(v73 + 24) + 16 * (v75 & 0x7FFFFFFF) + 8);
          }
          uint64_t v77 = *v76;
          if (*v76)
          {
            uint64_t v78 = *(void *)(v77 + 16);
            *(void *)(v77 + 16) = v72;
            *(void *)(v72 + 16) = v78;
            if (*(unsigned char *)(v72 + 3))
            {
              *(void *)(v72 + 24) = v77;
            }
            else
            {
              *(void *)(v72 + 24) = 0;
              unsigned int v76 = (uint64_t *)(v78 + 24);
            }
          }
          else
          {
            *(void *)(v72 + 16) = v72;
            *(void *)(v72 + 24) = 0;
          }
          *unsigned int v76 = v72;
        }
        v72 += 32;
        v74 -= 32;
      }
      while (v74);
    }
    uint64_t v47 = *(void *)(v45 + 728);
    if (v47) {
      (*(void (**)(uint64_t, llvm::MachineInstr *))(*(void *)v47 + 24))(v47, v43);
    }
    unint64_t v48 = *v27 & 0xFFFFFFFFFFFFFFF8;
    *(void *)unsigned int v43 = v48 | *(void *)v43 & 7;
    *((void *)v43 + 1) = v27;
    *(void *)(v48 + 8) = v43;
    *uint64_t v27 = *v27 & 7 | (unint64_t)v43;
    unint64_t v98 = 0;
    unint64_t v99 = 0;
    LODWORD(v97) = 0;
    HIDWORD(v97) = v36;
    uint64_t v100 = 0;
    llvm::MachineInstr::addOperand(v43, v42, (const llvm::MachineOperand *)&v97);
    unint64_t v4 = (*((_DWORD *)v39 + 228) + 1);
    *((_DWORD *)v39 + 228) = v4;
    LODWORD(v97) = 1;
    unint64_t v98 = 0;
    unint64_t v99 = v4;
    llvm::MachineInstr::addOperand(v43, v42, (const llvm::MachineOperand *)&v97);
    if (v103)
    {
      uint64_t v49 = 4 * v103;
      uint64_t v50 = (char *)v102 - 4;
      unsigned int v51 = v4;
      do
      {
        int v52 = *(_DWORD *)&v50[v49];
        unint64_t v4 = (*((_DWORD *)v39 + 228) + 1);
        *((_DWORD *)v39 + 228) = v4;
        int v97 = (unsigned __int8 **)v4;
        unint64_t v98 = v51;
        LODWORD(v99) = v52;
        unint64_t v53 = sub_1CD532FE4((uint64_t)v39 + 920, (unint64_t)&v97, 1);
        uint64_t v54 = *((void *)v39 + 115) + 20 * *((unsigned int *)v39 + 232);
        long long v55 = *(_OWORD *)v53;
        *(_DWORD *)(v54 + 16) = *(_DWORD *)(v53 + 16);
        *(_OWORD *)uint64_t v54 = v55;
        ++*((_DWORD *)v39 + 232);
        unsigned int v51 = v4;
        v49 -= 4;
      }
      while (v49);
    }
    goto LABEL_66;
  }
  while (1)
  {
    if (v13)
    {
      if (v103 >= (unint64_t)HIDWORD(v103)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v102 + v103) = v13;
      LODWORD(v103) = v103 + 1;
    }
    uint64_t v15 = v14 & 0x7FFFFFFF;
    uint64_t v16 = *(void *)(*(void *)(v4 + 24) + 16 * v15 + 8);
    if ((*(unsigned char *)(v16 + 3) & 1) == 0)
    {
      uint64_t v16 = *(void *)(v16 + 24);
      if ((*(unsigned char *)(v16 + 3) & 1) == 0) {
        uint64_t v16 = 0;
      }
    }
    a2 = *(llvm::MachineInstr **)(v16 + 8);
    int v17 = **((unsigned __int16 **)a2 + 2);
    if (v17 != 11 && v17 != 19)
    {
      (*(void (**)(unsigned __int8 ***__return_ptr, uint64_t, llvm::MachineInstr *))(*(void *)v7 + 416))(&v97, v7, a2);
      if (!(_BYTE)v99) {
        break;
      }
    }
    int v19 = **((unsigned __int16 **)a2 + 2);
    if (v19 == 11)
    {
      uint64_t v23 = *((void *)a2 + 4);
      unsigned int v21 = (int *)(v23 + 68);
      int v13 = *(_DWORD *)(v23 + 112);
    }
    else
    {
      if (v19 == 19)
      {
        uint64_t v20 = *((void *)a2 + 4);
        unsigned int v21 = (int *)(v20 + 36);
        unsigned int v22 = *(_DWORD *)(v20 + 32);
      }
      else
      {
        (*(void (**)(unsigned __int8 ***__return_ptr, uint64_t, llvm::MachineInstr *))(*(void *)v7 + 416))(&v97, v7, a2);
        unsigned int v21 = (int *)(v98 + 4);
        unsigned int v22 = *(_DWORD *)v98;
      }
      int v13 = (v22 >> 8) & 0xFFF;
    }
    int v14 = *v21;
    if ((*v21 & 0x80000000) == 0) {
      goto LABEL_28;
    }
  }
  uint64_t v66 = *(void *)(*(void *)(v4 + 24) + 16 * v15 + 8);
  if ((*(unsigned char *)(v66 + 3) & 1) == 0)
  {
    uint64_t v66 = *(void *)(v66 + 24);
    if ((*(unsigned char *)(v66 + 3) & 1) == 0) {
      uint64_t v66 = 0;
    }
  }
  uint64_t v67 = *(void *)(v66 + 8);
  uint64_t v68 = *(unsigned int *)(v67 + 40);
  if (v68)
  {
    uint64_t v69 = 0;
    uint64_t v70 = 32 * v68;
    uint64_t v71 = (_DWORD *)(*(void *)(v67 + 32) + 4);
    while ((*(v71 - 1) & 0x10000FF) != 0x1000000 || *v71 != v14)
    {
      v69 += 0x100000000;
      v71 += 8;
      v70 -= 32;
      if (!v70) {
        goto LABEL_66;
      }
    }
    int v79 = *(_DWORD *)(v67 + 64);
    if (!v79)
    {
      uint64_t v80 = *(void *)(*(void *)(v67 + 24) + 32);
      int v79 = *(_DWORD *)(v80 + 912) + 1;
      *(_DWORD *)(v80 + 912) = v79;
      *(_DWORD *)(v67 + 64) = v79;
    }
    unsigned int v81 = v69 | v79;
    if (v103)
    {
      uint64_t v82 = 4 * v103;
      uint64_t v83 = (char *)v102 - 4;
      uint64_t v84 = v69;
      do
      {
        int v85 = *(_DWORD *)&v83[v82];
        unint64_t v86 = (*((_DWORD *)this + 228) + 1);
        *((_DWORD *)this + 228) = v86;
        int v97 = (unsigned __int8 **)v86;
        unint64_t v98 = v84 | v81;
        LODWORD(v99) = v85;
        unint64_t v87 = sub_1CD532FE4((uint64_t)this + 920, (unint64_t)&v97, 1);
        uint64_t v84 = 0;
        uint64_t v69 = 0;
        uint64_t v88 = *((void *)this + 115) + 20 * *((unsigned int *)this + 232);
        long long v89 = *(_OWORD *)v87;
        *(_DWORD *)(v88 + 16) = *(_DWORD *)(v87 + 16);
        *(_OWORD *)uint64_t v88 = v89;
        ++*((_DWORD *)this + 232);
        unsigned int v81 = v86;
        v82 -= 4;
      }
      while (v82);
    }
    else
    {
      unint64_t v86 = v69 | v79;
    }
    unint64_t v4 = v69 | v86;
  }
LABEL_66:
  if (v102 != v104) {
    free(v102);
  }
  return v4;
}

BOOL llvm::MachineFunction::useDebugInstrRef(llvm::MachineFunction *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (!*(_DWORD *)(v1 + 552)) {
    return 0;
  }
  uint64_t v2 = *(void *)(*(void *)this + 112);
  if (v2)
  {
    if ((*(unsigned char *)(v2 + 17) & 8) != 0) {
      return 0;
    }
  }
  return *(_DWORD *)(v1 + 472) == 42 && dword_1EBD063C8 != 2 || dword_1EBD063C8 == 1;
}

void *sub_1CC34B910(void *result, uint64_t a2)
{
  unsigned int v3 = (char **)result;
  unint64_t v4 = result[2];
  uint64_t v5 = (void *)result[1];
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v5 - *result) >> 3);
    unint64_t v8 = v7 + 1;
    if (v7 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - *result) >> 3);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x555555555555555) {
      unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v10 = v8;
    }
    unsigned int v22 = result + 2;
    if (v10)
    {
      if (v10 > 0xAAAAAAAAAAAAAAALL) {
        sub_1CB833614();
      }
      unsigned int v11 = (char *)operator new(24 * v10);
    }
    else
    {
      unsigned int v11 = 0;
    }
    uint64_t v12 = &v11[24 * v7];
    int v13 = &v11[24 * v10];
    *(_OWORD *)uint64_t v12 = *(_OWORD *)a2;
    *((void *)v12 + 2) = *(void *)(a2 + 16);
    uint64_t v6 = v12 + 24;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    v20.i64[1] = (uint64_t)(v12 + 24);
    unsigned int v21 = v13;
    uint64_t v15 = *v3;
    int v14 = v3[1];
    if (v14 == *v3)
    {
      int64x2_t v16 = vdupq_n_s64((unint64_t)v14);
    }
    else
    {
      do
      {
        *((void *)v12 - 3) = 0;
        *((void *)v12 - 2) = 0;
        v12 -= 24;
        *((void *)v12 + 2) = 0;
        long long v17 = *(_OWORD *)(v14 - 24);
        v14 -= 24;
        *(_OWORD *)uint64_t v12 = v17;
        *((void *)v12 + 2) = *((void *)v14 + 2);
        *(void *)int v14 = 0;
        *((void *)v14 + 1) = 0;
        *((void *)v14 + 2) = 0;
      }
      while (v14 != v15);
      int64x2_t v16 = *(int64x2_t *)v3;
      uint64_t v6 = (char *)v20.i64[1];
      int v13 = v21;
    }
    void *v3 = v12;
    v3[1] = v6;
    int64x2_t v20 = v16;
    uint64_t v18 = v3[2];
    void v3[2] = v13;
    unsigned int v21 = v18;
    uint64_t v19 = v16.i64[0];
    double result = (void *)sub_1CD4CB4EC((uint64_t)&v19);
  }
  else
  {
    *uint64_t v5 = 0;
    v5[1] = 0;
    void v5[2] = 0;
    *(_OWORD *)uint64_t v5 = *(_OWORD *)a2;
    void v5[2] = *(void *)(a2 + 16);
    uint64_t v6 = (char *)(v5 + 3);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
  v3[1] = v6;
  return result;
}

uint64_t llvm::MachineJumpTableInfo::ReplaceMBBInJumpTable(llvm::MachineJumpTableInfo *this, unsigned int a2, llvm::MachineBasicBlock *a3, llvm::MachineBasicBlock *a4)
{
  uint64_t v4 = *((void *)this + 1) + 24 * a2;
  uint64_t v5 = *(llvm::MachineBasicBlock ***)v4;
  uint64_t v6 = *(llvm::MachineBasicBlock ***)(v4 + 8);
  if (v5 == v6)
  {
    char v7 = 0;
  }
  else
  {
    char v7 = 0;
    do
    {
      if (*v5 == a3)
      {
        *uint64_t v5 = a4;
        char v7 = 1;
      }
      ++v5;
    }
    while (v5 != v6);
  }
  return v7 & 1;
}

uint64_t llvm::printJumpTableEntryReference@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 24) = a2;
  *(void *)a2 = &unk_1F260E068;
  *(_DWORD *)(a2 + 8) = this;
  return this;
}

uint64_t llvm::MachineConstantPoolValue::getSizeInBytes(llvm::MachineConstantPoolValue *this, const llvm::DataLayout *a2)
{
  unsigned int v3 = (llvm::Type *)*((void *)this + 1);
  unint64_t v4 = (unint64_t)(sub_1CB83544C((uint64_t)a2, (uint64_t)v3) + 7) >> 3;
  BOOL v6 = v5 == 1;
  char Alignment = llvm::DataLayout::getAlignment(a2, v3, 1);
  if (v6)
  {
    char v10 = Alignment;
    char Alignment = v10;
  }
  return ((1 << Alignment) + v4 - 1) & -(1 << Alignment);
}

BOOL llvm::MachineConstantPoolEntry::needsRelocation(llvm::MachineConstantPoolEntry *this)
{
  return *((unsigned char *)this + 9) || llvm::Constant::getRelocationInfo(*(llvm::Constant **)this) == 2;
}

void llvm::MachineConstantPool::~MachineConstantPool(llvm::MachineConstantPool *this)
{
  v20[0] = 0;
  v20[1] = 0;
  int v21 = 0;
  uint64_t v2 = (void *)*((void *)this + 1);
  unsigned int v3 = (void *)*((void *)this + 2);
  while (v2 != v3)
  {
    char v10 = v2;
    if (*((unsigned char *)v2 + 9))
    {
      sub_1CD533060((uint64_t)v20, v2, (uint64_t)v22);
      if (*v10) {
        (*(void (**)(void))(*(void *)*v10 + 16))(*v10);
      }
    }
    uint64_t v2 = v10 + 2;
  }
  uint64_t v4 = *((void *)this + 4);
  uint64_t v5 = *((unsigned int *)this + 12);
  BOOL v6 = (void *)(v4 + 8 * v5);
  if (*((_DWORD *)this + 10))
  {
    if (v5)
    {
      uint64_t v11 = 8 * v5;
      uint64_t v12 = (void *)*((void *)this + 4);
      while ((*v12 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        ++v12;
        v11 -= 8;
        if (!v11) {
          goto LABEL_4;
        }
      }
      char v7 = v12;
    }
    else
    {
      char v7 = (void *)*((void *)this + 4);
    }
  }
  else
  {
LABEL_4:
    char v7 = (void *)(v4 + 8 * v5);
  }
  for (uint64_t i = (void *)(v4 + 8 * v5); v7 != i; uint64_t i = v19)
  {
    uint64_t v18 = v7;
    uint64_t v19 = i;
    uint64_t v13 = *v7;
    if (v21)
    {
      unsigned int v14 = ((v13 >> 4) ^ (v13 >> 9)) & (v21 - 1);
      uint64_t v15 = *(void *)(v20[0] + 8 * v14);
      if (v13 == v15) {
        goto LABEL_19;
      }
      int v16 = 1;
      while (v15 != -4096)
      {
        unsigned int v17 = v14 + v16++;
        unsigned int v14 = v17 & (v21 - 1);
        uint64_t v15 = *(void *)(v20[0] + 8 * v14);
        if (v13 == v15) {
          goto LABEL_19;
        }
      }
    }
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 16))(v13);
    }
LABEL_19:
    char v7 = v6;
    if (v18 + 1 != v6)
    {
      char v7 = v18 + 1;
      while ((*v7 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        if (++v7 == v6)
        {
          char v7 = v6;
          break;
        }
      }
    }
  }
  MEMORY[0x1D25D9CD0](v20[0], 8);
  MEMORY[0x1D25D9CD0](*((void *)this + 4), 8);
  unint64_t v9 = (void *)*((void *)this + 1);
  if (v9)
  {
    *((void *)this + 2) = v9;
    operator delete(v9);
  }
}

void sub_1CC34BDE0(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2 != a2)
  {
    int v3 = a2;
    if (v2 <= a2)
    {
      if (*(unsigned int *)(a1 + 12) < a2) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (a2 != v2) {
        bzero((void *)(*(void *)a1 + 8 * v2), 8 * (a2 - v2));
      }
    }
    *(_DWORD *)(a1 + 8) = v3;
  }
}

unint64_t sub_1CC34BE58(uint64_t a1, int a2)
{
  unint64_t result = *(void *)a1 & 0xFFFFFFFFFFFFFFF8;
  if (!result)
  {
    int v4 = *(_DWORD *)(a1 + 8);
    if ((v4 & 0x1C00) == 0x800)
    {
      if (a2 | ((v4 & 4) >> 2)) {
        int v5 = 4;
      }
      else {
        int v5 = 0;
      }
      *(_DWORD *)(a1 + 8) = v5 | v4 & 0xFFFFFFFB;
      unint64_t result = llvm::MCExpr::findAssociatedFragment(*(llvm::MCExpr **)(a1 + 24));
      *(void *)a1 = *(void *)a1 & 7 | result;
    }
  }
  return result;
}

uint64_t sub_1CC34BED0(uint64_t a1, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    unint64_t v2 = (uint64_t *)(*(void *)(a1 + 24) + 16 * (a2 & 0x7FFFFFFF) + 8);
  }
  else {
    unint64_t v2 = (uint64_t *)(*(void *)(a1 + 272) + 8 * a2);
  }
  uint64_t result = *v2;
  if (*v2 && (*(unsigned char *)(result + 3) & 1) == 0)
  {
    uint64_t v4 = *(void *)(result + 24);
    if (v4)
    {
      if (*(unsigned char *)(v4 + 3)) {
        return *(void *)(result + 24);
      }
      else {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1CC34BF28(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 176))
  {
    sub_1CC009394(a1 + 152);
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 152), 8);
    *(unsigned char *)(a1 + 176) = 0;
  }
  uint64_t v2 = *(unsigned int *)(a1 + 144);
  uint64_t v3 = *(void *)(a1 + 128);
  if (v2)
  {
    uint64_t v4 = v28;
    v28[0] = 2;
    v28[1] = 0;
    uint64_t v29 = -4096;
    uint64_t v30 = 0;
    uint64_t v26 = 0;
    uint64_t v27 = &unk_1F260E0B0;
    int v5 = v24;
    v24[0] = 2;
    v24[1] = 0;
    uint64_t v25 = -8192;
    BOOL v6 = (uint64_t *)(v3 + 40);
    uint64_t v7 = 48 * v2;
    do
    {
      uint64_t v8 = *(v6 - 2);
      if (v8 != v29 && v8 != v25)
      {
        uint64_t v11 = *v6;
        uint64_t *v6 = 0;
        if (v11)
        {
          unsigned int v22 = v4;
          uint64_t v12 = v5;
          (*(void (**)(uint64_t))(*(void *)v11 + 16))(v11);
          int v5 = v12;
          uint64_t v4 = v22;
          uint64_t v8 = *(v6 - 2);
        }
      }
      if (v8 != -4096 && v8 != -8192 && v8 != 0)
      {
        uint64_t v23 = v4;
        unsigned int v14 = v5;
        llvm::ValueHandleBase::RemoveFromUseList(v6 - 4);
        int v5 = v14;
        uint64_t v4 = v23;
      }
      v6 += 6;
      v7 -= 48;
    }
    while (v7);
    if (v25 != -8192 && v25 != -4096 && v25)
    {
      uint64_t v15 = v4;
      llvm::ValueHandleBase::RemoveFromUseList(v5);
      uint64_t v4 = v15;
    }
    if (v29 != -4096 && v29 != -8192 && v29) {
      llvm::ValueHandleBase::RemoveFromUseList(v4);
    }
    uint64_t v3 = *(void *)(a1 + 128);
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  if (*(_DWORD *)(a1 + 108))
  {
    uint64_t v16 = *(unsigned int *)(a1 + 104);
    if (v16)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 8 * v16;
      do
      {
        uint64_t v19 = *(void *)(*(void *)(a1 + 96) + v17);
        if (v19 != -8 && v19 != 0)
        {
          uint64_t v21 = *(void *)(v19 + 8);
          *(void *)(v19 + 8) = 0;
          if (v21) {
            (*(void (**)(uint64_t))(*(void *)v21 + 16))(v21);
          }
          MEMORY[0x1D25D9CD0](v19, 8);
        }
        v17 += 8;
      }
      while (v18 != v17);
    }
  }
  free(*(void **)(a1 + 96));
  sub_1CC34C2BC(*(void **)(a1 + 80));
  return a1;
}

void *sub_1CC34C188(void *result)
{
  result[1] = 0;
  v10[0] = 2;
  v10[1] = 0;
  uint64_t v11 = -4096;
  uint64_t v12 = 0;
  uint64_t v1 = *((unsigned int *)result + 4);
  if (v1)
  {
    uint64_t v2 = result;
    uint64_t result = v10;
    uint64_t v3 = *v2;
    uint64_t v4 = 48 * v1;
    int v5 = (void *)(*v2 + 16);
    do
    {
      uint64_t v6 = v10[0] & 6;
      *(v5 - 1) = v6;
      *int v5 = 0;
      uint64_t v7 = v11;
      v5[1] = v11;
      if (v7 != -4096 && v7 != -8192 && v7 != 0)
      {
        unint64_t v9 = v10[0] & 0xFFFFFFFFFFFFFFF8;
        *int v5 = *(void *)(v10[0] & 0xFFFFFFFFFFFFFFF8);
        *(void *)unint64_t v9 = v5 - 1;
        *(v5 - 1) = v9 | v6;
        if (*v5) {
          *(void *)*int v5 = *(void *)*v5 & 7 | (v3 + 16);
        }
      }
      *(v5 - 2) = &unk_1F260E0B0;
      void v5[2] = v12;
      v5 += 6;
      v3 += 48;
      v4 -= 48;
    }
    while (v4);
    if (v11 != -8192 && v11 != -4096)
    {
      if (v11) {
        return llvm::ValueHandleBase::RemoveFromUseList(v10);
      }
    }
  }
  return result;
}

void sub_1CC34C2BC(void *a1)
{
  if (a1)
  {
    sub_1CC34C2BC(*a1);
    sub_1CC34C2BC(a1[1]);
    uint64_t v3 = a1[5];
    a1[5] = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
    operator delete(a1);
  }
}

void sub_1CC34C338(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v3 = (void **)v1[1];
    uint64_t v4 = **a1;
    if (v3 != v2)
    {
      do
      {
        if (*((char *)v3 - 1) < 0)
        {
          uint64_t v12 = a1;
          uint64_t v6 = v2;
          uint64_t v8 = v1;
          char v10 = v3;
          operator delete(*(v3 - 3));
          uint64_t v1 = v8;
          uint64_t v3 = v10;
          uint64_t v2 = v6;
          a1 = v12;
        }
        int v5 = *(v3 - 6);
        if (v5)
        {
          *(v3 - 5) = v5;
          uint64_t v13 = a1;
          uint64_t v7 = v2;
          unint64_t v9 = v1;
          uint64_t v11 = v3;
          operator delete(v5);
          uint64_t v1 = v9;
          uint64_t v3 = v11;
          uint64_t v2 = v7;
          a1 = v13;
        }
        v3 -= 10;
      }
      while (v3 != v2);
      uint64_t v4 = **a1;
    }
    v1[1] = v2;
    operator delete(v4);
  }
}

uint64_t sub_1CC34C40C(uint64_t *a1, uint64_t a2)
{
  unint64_t v2 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 4);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x333333333333333) {
    abort();
  }
  if (0x999999999999999ALL * ((a1[2] - *a1) >> 4) > v3) {
    unint64_t v3 = 0x999999999999999ALL * ((a1[2] - *a1) >> 4);
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 4) >= 0x199999999999999) {
    unint64_t v6 = 0x333333333333333;
  }
  else {
    unint64_t v6 = v3;
  }
  uint64_t v19 = a1 + 2;
  if (v6)
  {
    if (v6 > 0x333333333333333) {
      sub_1CB833614();
    }
    uint64_t v7 = (char *)operator new(80 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = &v7[80 * v2];
  __p = v7;
  uint64_t v16 = v8;
  uint64_t v18 = &v7[80 * v6];
  *(_OWORD *)uint64_t v8 = *(_OWORD *)a2;
  *(_OWORD *)(v8 + 12) = *(_OWORD *)(a2 + 12);
  *((void *)v8 + 5) = 0;
  *((void *)v8 + 6) = 0;
  *((void *)v8 + 4) = 0;
  sub_1CC34C614((void *)v8 + 4, *(const void **)(a2 + 32), *(void *)(a2 + 40), *(void *)(a2 + 40) - *(void *)(a2 + 32));
  unint64_t v9 = v8 + 56;
  if (*(char *)(a2 + 79) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v9, *(const void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    *unint64_t v9 = *(_OWORD *)(a2 + 56);
    *((void *)v8 + 9) = *(void *)(a2 + 72);
  }
  uint64_t v17 = v8 + 80;
  sub_1CC34C694(a1, &__p);
  uint64_t v10 = a1[1];
  uint64_t v11 = v16;
  while (1)
  {
    uint64_t v12 = v17;
    if (v17 == v11) {
      break;
    }
    v17 -= 80;
    if (*(v12 - 1) < 0) {
      operator delete(*((void **)v12 - 3));
    }
    uint64_t v13 = (void *)*((void *)v12 - 6);
    if (v13)
    {
      *((void *)v12 - 5) = v13;
      operator delete(v13);
    }
  }
  if (__p) {
    operator delete(__p);
  }
  return v10;
}

uint64_t sub_1CC34C598(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  *(_OWORD *)(a1 + 12) = *(long long *)((char *)a2 + 12);
  *(_OWORD *)a1 = v4;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  sub_1CC34C614((void *)(a1 + 32), *((const void **)a2 + 4), *((void *)a2 + 5), *((void *)a2 + 5) - *((void *)a2 + 4));
  int v5 = (_OWORD *)(a1 + 56);
  if (*((char *)a2 + 79) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v5, *((const void **)a2 + 7), *((void *)a2 + 8));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 56);
    *(void *)(a1 + 72) = *((void *)a2 + 9);
    *int v5 = v6;
  }
  return a1;
}

void *sub_1CC34C614(void *result, const void *a2, uint64_t a3, size_t __sz)
{
  if (__sz)
  {
    if ((__sz & 0x8000000000000000) != 0) {
      abort();
    }
    uint64_t v7 = result;
    uint64_t result = operator new(__sz);
    uint64_t v8 = (char *)result;
    *uint64_t v7 = result;
    v7[1] = result;
    v7[2] = (char *)result + __sz;
    size_t v9 = a3 - (void)a2;
    if (v9) {
      uint64_t result = memcpy(result, a2, v9);
    }
    v7[1] = &v8[v9];
  }
  return result;
}

uint64_t *sub_1CC34C694(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  if (v3 == *result)
  {
    uint64_t v5 = a2[1];
  }
  else
  {
    do
    {
      uint64_t v5 = v4 - 80;
      long long v9 = *(_OWORD *)(v3 - 80);
      *(_OWORD *)(v4 - sub_1CC338288((_DWORD *)this + 68) = *(_OWORD *)(v3 - 68);
      *(_OWORD *)(v4 - 80) = v9;
      *(void *)(v4 - 40) = 0;
      *(void *)(v4 - 32) = 0;
      *(void *)(v4 - 48) = 0;
      *(_OWORD *)(v4 - 48) = *(_OWORD *)(v3 - 48);
      *(void *)(v4 - 32) = *(void *)(v3 - 32);
      *(void *)(v3 - 48) = 0;
      *(void *)(v3 - 40) = 0;
      *(void *)(v3 - 32) = 0;
      long long v10 = *(_OWORD *)(v3 - 24);
      *(void *)(v4 - 8) = *(void *)(v3 - 8);
      *(_OWORD *)(v4 - 24) = v10;
      *(void *)(v3 - 16) = 0;
      *(void *)(v3 - 8) = 0;
      *(void *)(v3 - 24) = 0;
      v3 -= 80;
      v4 -= 80;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  uint64_t v6 = *result;
  *uint64_t result = v5;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1CC34C748(void **a1, uint64_t a2)
{
  unint64_t v2 = 0xEEEEEEEEEEEEEEEFLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x222222222222222) {
    abort();
  }
  if (0xDDDDDDDDDDDDDDDELL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) > v3) {
    unint64_t v3 = 0xDDDDDDDDDDDDDDDELL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3);
  }
  if (0xEEEEEEEEEEEEEEEFLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) >= 0x111111111111111) {
    unint64_t v6 = 0x222222222222222;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0x222222222222222) {
      sub_1CB833614();
    }
    uint64_t v7 = operator new(120 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = (char *)&v7[15 * v6];
  long long v9 = sub_1CD532AFC(&v7[15 * v2], a2);
  long long v10 = v9 + 15;
  uint64_t v12 = (char *)*a1;
  uint64_t v11 = (char *)a1[1];
  if (v11 == *a1)
  {
    *a1 = v9;
    a1[1] = v10;
    a1[2] = v8;
  }
  else
  {
    do
    {
      v11 -= 120;
      long long v9 = sub_1CD532AFC(v9 - 15, (uint64_t)v11);
    }
    while (v11 != v12);
    uint64_t v11 = (char *)*a1;
    uint64_t v13 = (char *)a1[1];
    *a1 = v9;
    a1[1] = v10;
    a1[2] = v8;
    while (v13 != v11)
    {
      v13 -= 120;
      sub_1CD531C78(v13);
    }
  }
  if (v11) {
    operator delete(v11);
  }
  return v10;
}

void sub_1CC34C87C()
{
}

_DWORD *sub_1CC34C890(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  *(void *)uint64_t result = &unk_1F260E068;
  result[2] = *(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1CC34C8DC(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1F260E068;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(result + 8);
  return result;
}

llvm::raw_ostream *sub_1CC34C90C(uint64_t a1, llvm::raw_ostream *this)
{
  uint64_t v4 = *((void *)this + 4);
  if ((unint64_t)(*((void *)this + 3) - v4) > 0xB)
  {
    *(_DWORD *)(v4 + 8) = 778398818;
    *(void *)uint64_t v4 = *(void *)"%jump-table.";
    *((void *)this + 4) += 12;
  }
  else
  {
    llvm::raw_ostream::write(this, "%jump-table.", 0xCuLL);
  }
  unint64_t v5 = *(unsigned int *)(a1 + 8);

  return sub_1CD098D14(this, v5, 0, 0, 0);
}

char *sub_1CC34C9A4(char **a1, _OWORD *a2)
{
  unint64_t v3 = *a1;
  unint64_t v2 = a1[1];
  uint64_t v4 = (v2 - *a1) >> 4;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 60) {
    abort();
  }
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 3 > v5) {
    unint64_t v5 = v8 >> 3;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v9 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  if (v9)
  {
    if (v9 >> 60) {
      sub_1CB833614();
    }
    long long v10 = (char *)operator new(16 * v9);
  }
  else
  {
    long long v10 = 0;
  }
  uint64_t v11 = &v10[16 * v4];
  *(_OWORD *)uint64_t v11 = *a2;
  uint64_t v12 = v11 + 16;
  if (v2 != v3)
  {
    do
    {
      uint64_t v13 = *((void *)v2 - 2);
      v2 -= 16;
      __int16 v14 = *((_WORD *)v2 + 4);
      *((void *)v11 - 2) = v13;
      v11 -= 16;
      *((_WORD *)v11 + 4) = v14;
    }
    while (v2 != v3);
    unint64_t v2 = *a1;
  }
  *a1 = v11;
  a1[1] = v12;
  a1[2] = &v10[16 * v9];
  if (v2) {
    operator delete(v2);
  }
  return v12;
}

uint64_t sub_1CC34CA88()
{
  *(void *)&long long v4 = "Force the alignment of all functions in log2 format (e.g. 4 means align on 16B boundaries).";
  *((void *)&v4 + 1) = 91;
  unint64_t v3 = &v2;
  int v1 = 1;
  int v2 = 0;
  sub_1CD50BCD4((uint64_t)&unk_1EBCCE8A8, "align-all-functions", &v4, &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCCE8A8, &dword_1CB82C000);
}

uint64_t llvm::MachineFunctionPass::runOnFunction(llvm::MachineFunctionPass *this, llvm::Function *a2)
{
  uint64_t v116 = *MEMORY[0x1E4F143B8];
  if ((*((_DWORD *)a2 + 8) & 0xF) == 1) {
    return 0;
  }
  unint64_t v5 = (uint64_t *)*((void *)this + 1);
  uint64_t v6 = *v5;
  uint64_t v7 = v5[1];
  if (v6 == v7)
  {
LABEL_6:
    uint64_t v8 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v6 != &llvm::MachineModuleInfoWrapperPass::ID)
    {
      v6 += 16;
      if (v6 == v7) {
        goto LABEL_6;
      }
    }
    uint64_t v8 = *(void *)(v6 + 8);
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v8 + 96))(v8, &llvm::MachineModuleInfoWrapperPass::ID);
  uint64_t MachineFunction = (uint64_t ****)llvm::MachineModuleInfo::getOrCreateMachineFunction((llvm::MachineModuleInfo *)(v9 + 32), a2);
  uint64_t v11 = *(void *)(***((void ***)a2 + 5) + 72);
  int v12 = (*(uint64_t (**)(uint64_t, const char *, uint64_t))(*(void *)v11 + 24))(v11, "size-info", 9);
  if (!v12 || (uint64_t v13 = (uint64_t ****)MachineFunction[41], v13 == MachineFunction + 40))
  {
    unsigned int v14 = 0;
  }
  else
  {
    unsigned int v14 = 0;
    do
    {
      --v14;
      uint64_t v15 = v13 + 6;
      do
      {
        uint64_t v15 = (uint64_t ****)v15[1];
        ++v14;
      }
      while (v15 != v13 + 6);
      uint64_t v13 = (uint64_t ****)v13[1];
    }
    while (v13 != MachineFunction + 40);
  }
  uint64_t v2 = (*(uint64_t (**)(llvm::MachineFunctionPass *, uint64_t ****))(*(void *)this + 144))(this, MachineFunction);
  if (v12)
  {
    uint64_t v16 = (uint64_t ****)MachineFunction[41];
    if (v16 == MachineFunction + 40)
    {
      unsigned int v17 = 0;
    }
    else
    {
      unsigned int v17 = 0;
      do
      {
        --v17;
        uint64_t v18 = v16 + 6;
        do
        {
          uint64_t v18 = (uint64_t ****)v18[1];
          ++v17;
        }
        while (v18 != v16 + 6);
        uint64_t v16 = (uint64_t ****)v16[1];
      }
      while (v16 != MachineFunction + 40);
    }
    if (v14 != v17)
    {
      v81[0] = (uint64_t ***)MachineFunction;
      v81[1] = 0;
      uint64_t v19 = (uint64_t **)*MachineFunction;
      uint64_t v20 = ****MachineFunction;
      if (!*(void *)(v20 + 128))
      {
        if (!(*(unsigned int (**)(void))(**(void **)(v20 + 72) + 48))(*(void *)(v20 + 72))) {
          goto LABEL_27;
        }
        uint64_t v19 = (uint64_t **)*MachineFunction;
      }
      if ((*((unsigned char *)v19 + 23) & 0x20) == 0) {
        goto LABEL_65;
      }
      uint64_t v39 = *(void *)**v19;
      unint64_t v99 = v19;
      int v40 = *(_DWORD *)(v39 + 2496);
      if (v40)
      {
        uint64_t v41 = *(void *)(v39 + 2480);
        int v42 = v40 - 1;
        unsigned int v43 = v42 & ((v19 >> 4) ^ (v19 >> 9));
        uint64_t v44 = (uint64_t ***)(v41 + 40 * v43);
        uint64_t v45 = *v44;
        if (*v44 == v19) {
          goto LABEL_60;
        }
        uint64_t v46 = 0;
        int v47 = 1;
        while (v45 != (uint64_t **)-4096)
        {
          if (v46) {
            BOOL v48 = 0;
          }
          else {
            BOOL v48 = v45 == (uint64_t **)-8192;
          }
          if (v48) {
            uint64_t v46 = v44;
          }
          unsigned int v49 = v43 + v47++;
          unsigned int v43 = v49 & v42;
          uint64_t v44 = (uint64_t ***)(v41 + 40 * v43);
          uint64_t v45 = *v44;
          if (*v44 == v19) {
            goto LABEL_60;
          }
        }
        if (v46) {
          int v79 = v46;
        }
        else {
          int v79 = v44;
        }
      }
      else
      {
        int v79 = 0;
      }
      uint64_t v44 = (uint64_t ***)sub_1CC609054(v39 + 2480, (uint64_t)&v99, (uint64_t *)&v99, v79);
      uint64_t v80 = v99;
      void v44[3] = 0;
      v44[4] = 0;
      *uint64_t v44 = v80;
      v44[1] = (uint64_t **)(v44 + 3);
      v44[2] = (uint64_t **)0x100000000;
LABEL_60:
      uint64_t v50 = *((unsigned int *)v44 + 4);
      if (v50)
      {
        unsigned int v51 = v44[1] + 1;
        uint64_t v52 = 16 * v50;
        LODWORD(v53) = 0;
        while (*((_DWORD *)v51 - 2))
        {
          uint64_t v54 = 0;
          v51 += 2;
          v52 -= 16;
          if (!v52) {
            goto LABEL_67;
          }
        }
        uint64_t v53 = *v51;
        if (*v51)
        {
          uint64_t v54 = *v51;
          if (*(unsigned char *)v53 != 15) {
            uint64_t v54 = *(void *)(v53 - 8 * *(unsigned int *)(v53 + 8));
          }
          LODWORD(v53) = *(_DWORD *)(v53 + 28);
LABEL_67:
          long long v55 = MachineFunction[41];
          uint64_t v56 = (uint64_t)*v55[4];
          int v100 = 17;
          char v101 = 2;
          uint64_t v102 = v56;
          uint64_t v103 = v54;
          int v104 = v53;
          int v105 = 0;
          uint64_t v106 = "size-info";
          uint64_t v107 = "FunctionMISizeChange";
          uint64_t v108 = 20;
          char v109 = 0;
          char v110 = 0;
          uint64_t v111 = v113;
          uint64_t v112 = 0x400000000;
          v113[256] = 0;
          int v114 = -1;
          unsigned int v115 = v55;
          unint64_t v99 = (uint64_t **)&unk_1F260E0D8;
          uint64_t v57 = (void *)(*(uint64_t (**)(llvm::MachineFunctionPass *))(*(void *)this + 16))(this);
          llvm::DiagnosticInfoOptimizationBase::Argument::Argument(__dst, "Pass", 4uLL, v57, v58);
          uint64_t v59 = sub_1CC34D4D8((uint64_t)&v99, (uint64_t)__dst);
          v91[0] = ": Function: ";
          v91[1] = (void *)12;
          sub_1CC59ADEC((uint64_t *)(v59 + 80), (uint64_t)v91);
          if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
          {
            size_t v70 = 0;
            uint64_t v69 = &byte_1CFBCE98E;
            goto LABEL_76;
          }
          uint64_t v60 = ***(void ***)a2;
          uint64_t v61 = *(void *)(v60 + 152);
          uint64_t v62 = *(unsigned int *)(v60 + 168);
          if (v62)
          {
            LODWORD(v63) = (v62 - 1) & ((a2 >> 4) ^ (a2 >> 9));
            uint64_t v64 = v61 + 16 * v63;
            uint64_t v65 = *(llvm::Function **)v64;
            if (*(llvm::Function **)v64 == a2)
            {
LABEL_75:
              uint64_t v68 = *(void **)(v64 + 8);
              size_t v71 = *v68;
              uint64_t v69 = (char *)(v68 + 2);
              size_t v70 = v71;
LABEL_76:
              llvm::DiagnosticInfoOptimizationBase::Argument::Argument(v91, "Function", 8uLL, v69, v70);
              uint64_t v72 = sub_1CC34D4D8(v59, (uint64_t)v91);
              v88.__r_.__value_.__r.__words[0] = (std::string::size_type)": ";
              v88.__r_.__value_.__l.__size_ = 2;
              sub_1CC59ADEC((uint64_t *)(v72 + 80), (uint64_t)&v88);
              v88.__r_.__value_.__r.__words[0] = (std::string::size_type)"MI Instruction count changed from ";
              v88.__r_.__value_.__l.__size_ = 34;
              sub_1CC59ADEC((uint64_t *)(v72 + 80), (uint64_t)&v88);
              llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v88, "MIInstrsBefore", 0xEuLL, v14);
              uint64_t v73 = sub_1CC34D4D8(v72, (uint64_t)&v88);
              v85.__r_.__value_.__r.__words[0] = (std::string::size_type)" to ";
              v85.__r_.__value_.__l.__size_ = 4;
              sub_1CC59ADEC((uint64_t *)(v73 + 80), (uint64_t)&v85);
              llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v85, "MIInstrsAfter", 0xDuLL, v17);
              uint64_t v74 = sub_1CC34D4D8(v73, (uint64_t)&v85);
              v82.__r_.__value_.__r.__words[0] = (std::string::size_type)"; Delta: ";
              v82.__r_.__value_.__l.__size_ = 9;
              sub_1CC59ADEC((uint64_t *)(v74 + 80), (uint64_t)&v82);
              llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v82, "Delta", 5uLL, v17 - (unint64_t)v14);
              sub_1CC34D4D8(v74, (uint64_t)&v82);
              if (v84 < 0) {
                operator delete(__p);
              }
              if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v82.__r_.__value_.__l.__data_);
              }
              if (v87 < 0) {
                operator delete(v86);
              }
              if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v85.__r_.__value_.__l.__data_);
              }
              if (v90 < 0) {
                operator delete(v89);
              }
              if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v88.__r_.__value_.__l.__data_);
              }
              if (v94 < 0) {
                operator delete(v93);
              }
              if (v92 < 0) {
                operator delete(v91[0]);
              }
              if (v98 < 0) {
                operator delete(v97);
              }
              if (v96 < 0) {
                operator delete(__dst[0]);
              }
              llvm::MachineOptimizationRemarkEmitter::emit(v81, (llvm::DiagnosticInfoOptimizationBase *)&v99);
              unint64_t v99 = (uint64_t **)&unk_1F2616800;
              uint64_t v75 = (char *)v111;
              if (v112)
              {
                unint64_t v76 = (unint64_t)v112 << 6;
                do
                {
                  uint64_t v77 = (void **)&v75[v76];
                  if (v75[v76 - 17] < 0) {
                    operator delete(*(v77 - 5));
                  }
                  if (*((char *)v77 - 41) < 0) {
                    operator delete(*(v77 - 8));
                  }
                  v76 -= 64;
                }
                while (v76);
                uint64_t v75 = (char *)v111;
              }
              if (v75 != v113) {
                free(v75);
              }
              goto LABEL_27;
            }
            int v66 = 1;
            while (v65 != (llvm::Function *)-4096)
            {
              int v67 = v63 + v66++;
              uint64_t v63 = v67 & (v62 - 1);
              uint64_t v65 = *(llvm::Function **)(v61 + 16 * v63);
              if (v65 == a2)
              {
                uint64_t v64 = v61 + 16 * v63;
                goto LABEL_75;
              }
            }
          }
          uint64_t v64 = v61 + 16 * v62;
          goto LABEL_75;
        }
LABEL_66:
        uint64_t v54 = 0;
        goto LABEL_67;
      }
LABEL_65:
      LODWORD(v53) = 0;
      goto LABEL_66;
    }
  }
LABEL_27:
  uint64_t v21 = MachineFunction + 45;
  unsigned int v22 = *((_DWORD *)this + 42);
  if (*((_DWORD *)MachineFunction + 106) < v22)
  {
    int v33 = MachineFunction[53] & 0x3F;
    uint64_t v34 = *((unsigned int *)MachineFunction + 92);
    if (v33)
    {
      uint64_t v78 = (uint64_t)&MachineFunction[45][v34];
      *(void *)(v78 - 8) &= ~(-1 << v33);
    }
    unsigned int v35 = v34;
    *((_DWORD *)MachineFunction + 106) = v22;
    unsigned int v36 = v22 + 63;
    if (v34 != (v22 + 63) >> 6)
    {
      uint64_t v37 = v36 >> 6;
      if (v34 > v37)
      {
        *((_DWORD *)MachineFunction + 92) = v37;
        unsigned int v35 = v36 >> 6;
      }
      else
      {
        if (v37 > *((_DWORD *)MachineFunction + 93)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v37 != v34) {
          bzero((void *)(*v21 + 8 * v34), 8 * (v37 - v34));
        }
        unsigned int v35 = v37;
        *((_DWORD *)MachineFunction + 92) = v37;
        unsigned int v22 = *((_DWORD *)MachineFunction + 106);
      }
    }
    int v38 = v22 & 0x3F;
    if (v38) {
      *(void *)(*v21 + 8 * v35 - 8) &= ~(-1 << v38);
    }
  }
  uint64_t v23 = *((unsigned int *)this + 28);
  if (v23)
  {
    int v24 = (uint64_t *)*((void *)this + 13);
    uint64_t v25 = (void *)*v21;
    do
    {
      uint64_t v26 = *v24++;
      *v25++ |= v26;
      --v23;
    }
    while (v23);
  }
  LODWORD(v27) = *((_DWORD *)MachineFunction + 92);
  unsigned int v28 = *((_DWORD *)this + 46);
  if (v28 >= v27) {
    uint64_t v27 = v27;
  }
  else {
    uint64_t v27 = v28;
  }
  if (v27)
  {
    uint64_t v29 = (uint64_t *)*((void *)this + 22);
    uint64_t v30 = (void *)*v21;
    do
    {
      uint64_t v31 = *v29++;
      *v30++ &= ~v31;
      --v27;
    }
    while (v27);
  }
  return v2;
}

void llvm::MachineFunctionPass::getAnalysisUsage(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineModuleInfoWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::MachineModuleInfoWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::BasicAAWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::DominanceFrontierWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::AAResultsWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::IVUsersWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::MemoryDependenceWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::ScalarEvolutionWrapperPass::ID);

  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::SCEVAAWrapperPass::ID);
}

uint64_t sub_1CC34D4D8(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t v4 = a2;
    sub_1CB8BDF7C((uint64_t)v6, *(const void **)a2, *(void *)(a2 + 8));
    a2 = v4;
  }
  else
  {
    *(_OWORD *)uint64_t v6 = *(_OWORD *)a2;
    uint64_t v7 = *(void *)(a2 + 16);
  }
  if (*(char *)(a2 + 47) < 0)
  {
    uint64_t v5 = a2;
    sub_1CB8BDF7C((uint64_t)&__p, *(const void **)(a2 + 24), *(void *)(a2 + 32));
    a2 = v5;
  }
  else
  {
    long long __p = *(_OWORD *)(a2 + 24);
    uint64_t v9 = *(void *)(a2 + 40);
  }
  long long v10 = *(_OWORD *)(a2 + 48);
  sub_1CC59AF1C((unint64_t *)(a1 + 80), (long long *)v6);
  if (SHIBYTE(v9) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v7) < 0) {
    operator delete(v6[0]);
  }
  return a1;
}

uint64_t sub_1CC34D5B0(uint64_t a1)
{
  uint64_t v1 = *(void *)(****(void ****)(a1 + 16) + 72);
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2) {
    size_t v3 = strlen(*(const char **)(a1 + 40));
  }
  else {
    size_t v3 = 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t, size_t))(*(void *)v1 + 24);

  return v4(v1, v2, v3);
}

void sub_1CC34D634()
{
}

void sub_1CC34D6D0()
{
}

void sub_1CC34D790(void **this)
{
  *this = &unk_1F260E1D0;
  if (*((char *)this + 279) < 0) {
    operator delete(this[32]);
  }
  *this = &unk_1F260E110;
  uint64_t v2 = (void **)this[22];
  if (v2 != this + 24) {
    free(v2);
  }
  size_t v3 = (void **)this[13];
  if (v3 != this + 15) {
    free(v3);
  }
  uint64_t v4 = (void **)this[4];
  if (v4 != this + 6) {
    free(v4);
  }

  llvm::Pass::~Pass((llvm::Pass *)this);
}

void sub_1CC34D854(void **this)
{
  *this = &unk_1F260E1D0;
  if (*((char *)this + 279) < 0) {
    operator delete(this[32]);
  }
  *this = &unk_1F260E110;
  uint64_t v2 = (void **)this[22];
  if (v2 != this + 24) {
    free(v2);
  }
  size_t v3 = (void **)this[13];
  if (v3 != this + 15) {
    free(v3);
  }
  uint64_t v4 = (void **)this[4];
  if (v4 != this + 6) {
    free(v4);
  }
  llvm::Pass::~Pass((llvm::Pass *)this);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CC34D92C()
{
  return "MachineFunction Printer";
}

void sub_1CC34D93C(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  sub_1CB843600(a2, a2 + 144, (uint64_t)&llvm::SlotIndexes::ID);

  llvm::MachineFunctionPass::getAnalysisUsage(a1, a2);
}

uint64_t sub_1CC34D994(uint64_t a1, llvm::Value **a2)
{
  uint64_t Name = llvm::Value::getName(*a2);
  if (llvm::isFunctionInPrintList(Name, v5))
  {
    uint64_t v6 = *(llvm::raw_ostream **)(a1 + 248);
    uint64_t v7 = (_WORD *)*((void *)v6 + 4);
    if (*((void *)v6 + 3) - (void)v7 > 1uLL)
    {
      *uint64_t v7 = 8227;
      *((void *)v6 + 4) += 2;
    }
    else
    {
      uint64_t v6 = llvm::raw_ostream::write(v6, "# ", 2uLL);
    }
    char v8 = *(unsigned char *)(a1 + 279);
    if (v8 >= 0) {
      uint64_t v9 = (const char *)(a1 + 256);
    }
    else {
      uint64_t v9 = *(const char **)(a1 + 256);
    }
    if (v8 >= 0) {
      size_t v10 = v8 & 0x7F;
    }
    else {
      size_t v10 = *(void *)(a1 + 264);
    }
    uint64_t v11 = llvm::raw_ostream::write(v6, v9, v10);
    int v12 = (_WORD *)*((void *)v11 + 4);
    if (*((void *)v11 + 3) - (void)v12 > 1uLL)
    {
      *int v12 = 2618;
      *((void *)v11 + 4) += 2;
    }
    else
    {
      llvm::raw_ostream::write(v11, ":\n", 2uLL);
    }
    uint64_t v13 = *(llvm::raw_ostream **)(a1 + 248);
    uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*(void *)(a1 + 8) + 24), &llvm::SlotIndexes::ID, 1);
    if (AnalysisPass) {
      uint64_t v15 = (const llvm::SlotIndexes *)(*(uint64_t (**)(uint64_t, void *))(*(void *)AnalysisPass + 96))(AnalysisPass, &llvm::SlotIndexes::ID);
    }
    else {
      uint64_t v15 = 0;
    }
    llvm::MachineFunction::print(a2, v13, v15);
  }
  return 0;
}

void llvm::initializeMachineFunctionSplitterPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCE978, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CC34DB40;
    v3[1] = &v1;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCCE978, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC34DB40()
{
}

uint64_t sub_1CC34DBDC(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCCE970;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = a1 + 48;
  *(void *)(a1 + 40) = 0x600000001;
  *(_DWORD *)(a1 + 96) = 11;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 104) = a1 + 120;
  *(void *)(a1 + 112) = 0x600000001;
  *(_DWORD *)(a1 + 1sub_1CC338288((_DWORD *)this + 68) = 11;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 176) = a1 + 192;
  *(void *)(a1 + 184) = 0x600000001;
  *(_DWORD *)(a1 + 240) = 11;
  *(void *)a1 = &unk_1F260E290;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCE978, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC34DB40;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCCE978, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CC34DCD4()
{
}

void sub_1CC34DD10(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F260E110;
  uint64_t v1 = (void *)*((void *)a1 + 22);
  if (v1 != (void *)((char *)a1 + 192))
  {
    uint64_t v4 = a1;
    free(v1);
    a1 = v4;
  }
  uint64_t v2 = (void *)*((void *)a1 + 13);
  if (v2 != (void *)((char *)a1 + 120))
  {
    std::string::size_type v5 = a1;
    free(v2);
    a1 = v5;
  }
  size_t v3 = (void *)*((void *)a1 + 4);
  if (v3 != (void *)((char *)a1 + 48))
  {
    uint64_t v6 = a1;
    free(v3);
    a1 = v6;
  }

  llvm::Pass::~Pass(a1);
}

void sub_1CC34DDC4(llvm::Pass *this)
{
  *(void *)this = &unk_1F260E110;
  uint64_t v2 = (char *)*((void *)this + 22);
  if (v2 != (char *)this + 192) {
    free(v2);
  }
  size_t v3 = (char *)*((void *)this + 13);
  if (v3 != (char *)this + 120) {
    free(v3);
  }
  uint64_t v4 = (char *)*((void *)this + 4);
  if (v4 != (char *)this + 48) {
    free(v4);
  }
  llvm::Pass::~Pass(this);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CC34DE70()
{
  return "Machine Function Splitter Transformation";
}

void sub_1CC34DE80(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineModuleInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineBlockFrequencyInfo::ID);

  sub_1CB843600(a2, a2, (uint64_t)&llvm::ProfileSummaryInfoWrapperPass::ID);
}

uint64_t sub_1CC34DEE4(uint64_t a1, uint64_t a2)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  llvm::Function::getEntryCount(*(uint64_t ****)a2, 0, (uint64_t)&v45);
  if (!v47[0]) {
    return 0;
  }
  uint64_t v4 = *(uint64_t ****)a2;
  if ((*(unsigned char *)(*(void *)a2 + 34) & 0x40) != 0) {
    return 0;
  }
  std::string::size_type v5 = v4[14];
  if (v5)
  {
    if (*((_DWORD *)v5 + 2))
    {
      uint64_t v6 = v5[5];
      if (v6)
      {
        int v7 = *((_DWORD *)v6 + 10);
        if (v7)
        {
          uint64_t v8 = v6[3];
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EBCBE588))
          {
            unint64_t v43 = llvm::hashing::detail::fixed_seed_override;
            if (!llvm::hashing::detail::fixed_seed_override) {
              unint64_t v43 = 0xFF51AFD7ED558CCDLL;
            }
            qword_1EBCBE580 = v43;
            __cxa_guard_release(&qword_1EBCBE588);
          }
          uint64_t v9 = __ROR8__(qword_1EBCBE580 ^ 0xF54B982192FEA167, 30);
          unint64_t v10 = 0x9DDFEA08EB382D69
              * ((qword_1EBCBE580 + 0x18EB4DAABB32FA18) ^ ((0x9DDFEA08EB382D69
                                                            * ((v9 - 0x1A1B69534B932F1) ^ (qword_1EBCBE580
                                                                                           + 0x18EB4DAABB32FA18))) >> 47) ^ (0x9DDFEA08EB382D69 * ((v9 - 0x1A1B69534B932F1) ^ (qword_1EBCBE580 + 0x18EB4DAABB32FA18))));
          unsigned int v11 = -348639895 * ((v10 >> 47) ^ v10);
          for (int i = 1; ; ++i)
          {
            unsigned int v13 = v11 & (v7 - 1);
            uint64_t v14 = v8 + 24 * v13;
            uint64_t v15 = *(void **)v14;
            if (*(void *)v14 == -1)
            {
              if ("implicit-section-name" == (char *)-1) {
                return 0;
              }
            }
            else if (v15 == (void *)-2)
            {
              if ("implicit-section-name" == (char *)-2) {
                return 0;
              }
            }
            else if (*(void *)(v14 + 8) == 21)
            {
              BOOL v16 = *v15 == 0x746963696C706D69 && v15[1] == 0x6E6F69746365732DLL;
              if (v16 && *(void *)((char *)v15 + 13) == 0x656D616E2D6E6F69) {
                return 0;
              }
            }
            if (v15 == (void *)-1) {
              break;
            }
            unsigned int v11 = i + v13;
          }
          uint64_t v4 = *(uint64_t ****)a2;
        }
      }
    }
  }
  uint64_t Metadata = llvm::Value::getMetadata((llvm::Value *)v4, 20);
  if (!Metadata) {
    goto LABEL_31;
  }
  uint64_t v19 = *(void *)(*(void *)(Metadata - 8 * *(unsigned int *)(Metadata + 8) + 8) + 8);
  if (*(void *)v19 == 7)
  {
    int v40 = *(_DWORD *)(v19 + 24);
    int v41 = *(_DWORD *)(v19 + 27);
    if (v40 != 1852534389 || v41 != 1853321070) {
      goto LABEL_31;
    }
    return 0;
  }
  if (*(void *)v19 == 8 && *(void *)(v19 + 24) == 0x796C656B696C6E75) {
    return 0;
  }
LABEL_31:
  llvm::MachineFunction::RenumberBlocks((llvm::MachineFunction *)a2, 0);
  *(_DWORD *)(a2 + 640) = 3;
  uint64_t v20 = *(uint64_t **)(a1 + 8);
  uint64_t v21 = *v20;
  uint64_t v22 = v20[1];
  if (v21 == v22)
  {
LABEL_34:
    uint64_t v23 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v21 != &llvm::MachineBlockFrequencyInfo::ID)
    {
      v21 += 16;
      if (v21 == v22) {
        goto LABEL_34;
      }
    }
    uint64_t v23 = *(void *)(v21 + 8);
  }
  int v24 = (llvm::MachineBlockFrequencyInfo *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v23 + 96))(v23, &llvm::MachineBlockFrequencyInfo::ID);
  uint64_t v25 = *(uint64_t **)(a1 + 8);
  uint64_t v26 = *v25;
  uint64_t v27 = v25[1];
  if (v26 == v27)
  {
LABEL_39:
    uint64_t v28 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v26 != &llvm::ProfileSummaryInfoWrapperPass::ID)
    {
      v26 += 16;
      if (v26 == v27) {
        goto LABEL_39;
      }
    }
    uint64_t v28 = *(void *)(v26 + 8);
  }
  uint64_t v29 = *(llvm::ProfileSummaryInfo **)((*(uint64_t (**)(uint64_t, void *))(*(void *)v28 + 96))(v28, &llvm::ProfileSummaryInfoWrapperPass::ID)+ 32);
  uint64_t v45 = v47;
  uint64_t v46 = 0x200000000;
  uint64_t v30 = *(void *)(a2 + 328);
  if (v30 != a2 + 320)
  {
    do
    {
      if (*(void *)(*(void *)(v30 + 32) + 328) != v30)
      {
        if (*(unsigned char *)(v30 + 184))
        {
          if (v46 >= (unint64_t)HIDWORD(v46)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v45 + v46) = v30;
          LODWORD(v46) = v46 + 1;
        }
        else if (sub_1CC34E3CC((llvm::MachineBasicBlock *)v30, v24, v29))
        {
          *(void *)(v30 + 192) = llvm::MBBSectionID::ColdSectionID;
        }
      }
      uint64_t v30 = *(void *)(v30 + 8);
    }
    while (v30 != a2 + 320);
    if (v46)
    {
      int v31 = 0;
      uint64_t v32 = (llvm::MachineBasicBlock **)v45;
      uint64_t v33 = 8 * v46;
      do
      {
        uint64_t v34 = *v32++;
        v31 |= !sub_1CC34E3CC(v34, v24, v29);
        v33 -= 8;
      }
      while (v33);
      if ((v31 & 1) == 0 && v46)
      {
        unsigned int v35 = (uint64_t *)v45;
        uint64_t v36 = llvm::MBBSectionID::ColdSectionID;
        uint64_t v37 = 8 * v46;
        do
        {
          uint64_t v38 = *v35++;
          *(void *)(v38 + 192) = v36;
          v37 -= 8;
        }
        while (v37);
      }
    }
  }
  llvm::sortBasicBlocksAndUpdateBranches(a2, (uint64_t (*)(uint64_t, uint64_t *, uint64_t *))sub_1CC34E444, (uint64_t)&v44);
  if (v45 != v47) {
    free(v45);
  }
  return 1;
}

BOOL sub_1CC34E3CC(llvm::MachineBasicBlock *a1, llvm::MachineBlockFrequencyInfo *this, llvm::ProfileSummaryInfo *a3)
{
  unint64_t BlockProfileCount = llvm::MachineBlockFrequencyInfo::getBlockProfileCount(this, a1);
  if (!v5) {
    return 1;
  }
  unint64_t v6 = BlockProfileCount;
  if (!dword_1EBCCEA00) {
    return BlockProfileCount < dword_1EBCCEAC0;
  }
  unint64_t v8 = llvm::ProfileSummaryInfo::computeThreshold(a3, dword_1EBCCEA00);
  return v9 && v8 >= v6;
}

BOOL sub_1CC34E444(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(_DWORD *)(a2 + 192) < *(_DWORD *)(a3 + 192);
}

uint64_t sub_1CC34E458()
{
  *(void *)&long long v4 = "Percentile profile summary cutoff used to determine cold blocks. Unused if set to zero.";
  *((void *)&v4 + 1) = 87;
  size_t v3 = &v2;
  int v1 = 1;
  int v2 = 999950;
  sub_1CD50BCD4((uint64_t)&unk_1EBCCE980, "mfs-psi-cutoff", &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCCE980, &dword_1CB82C000);
  *(void *)&long long v4 = "Minimum number of times a block must be executed to be retained.";
  *((void *)&v4 + 1) = 64;
  int v1 = 1;
  int v2 = 1;
  size_t v3 = &v2;
  sub_1CD50BCD4((uint64_t)&unk_1EBCCEA40, "mfs-count-threshold", &v4, &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCCEA40, &dword_1CB82C000);
}

void sub_1CC34E548()
{
}

void llvm::createUnpackMachineBundles()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

uint64_t sub_1CC34E720(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCCEB00;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = a1 + 48;
  *(void *)(a1 + 40) = 0x600000001;
  *(_DWORD *)(a1 + 96) = 11;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 104) = a1 + 120;
  *(void *)(a1 + 112) = 0x600000001;
  *(_DWORD *)(a1 + 1sub_1CC338288((_DWORD *)this + 68) = 11;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 176) = a1 + 192;
  *(void *)(a1 + 184) = 0x600000001;
  *(_DWORD *)(a1 + 240) = 11;
  *(void *)a1 = &unk_1F260E350;
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 272) = a1 + 248;
      a1 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1 + 248);
    }
    else
    {
      *(void *)(a1 + 272) = v3;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    *(void *)(a1 + 272) = 0;
  }
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCEB08, memory_order_acquire) != -1)
  {
    v7[0] = sub_1CC34E548;
    v7[1] = &PassRegistry;
    unint64_t v6 = v7;
    std::__call_once(&qword_1EBCCEB08, &v6, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return v2;
}

void sub_1CC34E874()
{
}

llvm::MachineFunction *sub_1CC34E910(llvm::MachineFunction *a1, unsigned __int8 **a2, uint64_t a3)
{
  char v5 = *a2;
  int v7 = v5;
  if (v5) {
    llvm::MetadataTracking::track((uint64_t)&v7, v5, 2);
  }
  llvm::MachineFunction::CreateMachineInstr(a1, a3, &v7, 0);
  if (v7) {
    llvm::MetadataTracking::untrack((uint64_t)&v7, v7);
  }
  return a1;
}

uint64_t sub_1CC34E98C(uint64_t a1, unsigned int *a2)
{
  if (*(void *)(a1 + 160))
  {
    char v5 = (void *)(a1 + 152);
    uint64_t v4 = *(void *)(a1 + 152);
    unsigned int v6 = *a2;
    if (v4)
    {
      uint64_t result = 1;
      do
      {
        while (1)
        {
          unint64_t v8 = (void *)v4;
          unsigned int v9 = *(_DWORD *)(v4 + 28);
          if (v6 >= v9) {
            break;
          }
          uint64_t v4 = *v8;
          char v5 = v8;
          if (!*v8) {
            goto LABEL_9;
          }
        }
        if (v9 >= v6) {
          return result;
        }
        uint64_t v4 = v8[1];
      }
      while (v4);
      char v5 = v8 + 1;
    }
    else
    {
      unint64_t v8 = (void *)(a1 + 152);
    }
LABEL_9:
    unint64_t v10 = operator new(0x20uLL);
    v10[7] = v6;
    *(void *)unint64_t v10 = 0;
    *((void *)v10 + 1) = 0;
    *((void *)v10 + 2) = v8;
    *char v5 = v10;
    uint64_t v11 = **(void **)(a1 + 144);
    if (v11)
    {
      *(void *)(a1 + 144) = v11;
      unint64_t v10 = (_DWORD *)*v5;
    }
  }
  else
  {
    uint64_t v12 = *(unsigned int *)(a1 + 8);
    unsigned int v13 = *a2;
    if (!v12)
    {
LABEL_19:
      if (v12 >= *(_DWORD *)(a1 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a1 + 4 * v12) = v13;
      ++*(_DWORD *)(a1 + 8);
      return 0x100000001;
    }
    uint64_t v14 = 4 * v12;
    uint64_t v15 = *(_DWORD **)a1;
    while (*v15 != v13)
    {
      ++v15;
      v14 -= 4;
      if (!v14) {
        goto LABEL_18;
      }
    }
    if (v14) {
      return 1;
    }
LABEL_18:
    if (v12 <= 0x1F) {
      goto LABEL_19;
    }
    BOOL v16 = (void *)(a1 + 152);
    do
    {
      uint64_t v17 = *(void *)a1 + 4 * v12;
      uint64_t v18 = *(void *)(a1 + 152);
      uint64_t v19 = (void *)(a1 + 152);
      uint64_t v20 = (void *)(a1 + 152);
      if (v18)
      {
        unsigned int v21 = *(_DWORD *)(v17 - 4);
        do
        {
          while (1)
          {
            uint64_t v20 = (void *)v18;
            unsigned int v22 = *(_DWORD *)(v18 + 28);
            if (v21 >= v22) {
              break;
            }
            uint64_t v18 = *v20;
            uint64_t v19 = v20;
            if (!*v20) {
              goto LABEL_30;
            }
          }
          if (v22 >= v21) {
            goto LABEL_33;
          }
          uint64_t v18 = v20[1];
        }
        while (v18);
        uint64_t v19 = v20 + 1;
      }
LABEL_30:
      uint64_t v23 = operator new(0x20uLL);
      v23[7] = *(_DWORD *)(v17 - 4);
      *(void *)uint64_t v23 = 0;
      *((void *)v23 + 1) = 0;
      *((void *)v23 + 2) = v20;
      *uint64_t v19 = v23;
      uint64_t v24 = **(void **)(a1 + 144);
      if (v24)
      {
        *(void *)(a1 + 144) = v24;
        uint64_t v23 = (_DWORD *)*v19;
      }
      sub_1CB8358B8(*(uint64_t **)(a1 + 152), (uint64_t *)v23);
      ++*(void *)(a1 + 160);
      LODWORD(v12) = *(_DWORD *)(a1 + 8);
LABEL_33:
      LODWORD(v12) = v12 - 1;
      *(_DWORD *)(a1 + 8) = v12;
    }
    while (v12);
    uint64_t v25 = (_DWORD *)*v16;
    unsigned int v26 = *a2;
    uint64_t v27 = (void *)(a1 + 152);
    if (*v16)
    {
      do
      {
        while (1)
        {
          uint64_t v27 = v25;
          unsigned int v28 = v25[7];
          if (v26 >= v28) {
            break;
          }
          uint64_t v25 = (_DWORD *)*v27;
          BOOL v16 = v27;
          if (!*v27) {
            goto LABEL_43;
          }
        }
        if (v28 >= v26) {
          return 0x100000001;
        }
        uint64_t v25 = (_DWORD *)v27[1];
      }
      while (v25);
      BOOL v16 = v27 + 1;
    }
LABEL_43:
    unint64_t v10 = operator new(0x20uLL);
    v10[7] = v26;
    *(void *)unint64_t v10 = 0;
    *((void *)v10 + 1) = 0;
    *((void *)v10 + 2) = v27;
    *BOOL v16 = v10;
    uint64_t v29 = **(void **)(a1 + 144);
    if (v29)
    {
      *(void *)(a1 + 144) = v29;
      unint64_t v10 = (_DWORD *)*v16;
    }
  }
  sub_1CB8358B8(*(uint64_t **)(a1 + 152), (uint64_t *)v10);
  ++*(void *)(a1 + 160);
  return 0x100000001;
}

BOOL sub_1CC34EC20(uint64_t a1, unsigned int *a2)
{
  if (*(void *)(a1 + 96)) {
    return sub_1CD50BF28(a1 + 80, a2) != 0;
  }
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(int **)a1;
  size_t v5 = 4 * v3 - 4;
  unsigned int v6 = *(int **)a1;
  while (1)
  {
    int v7 = *v6++;
    if (v7 == *a2) {
      break;
    }
    v5 -= 4;
    uint64_t v4 = v6;
    if (v5 == -4) {
      return 0;
    }
  }
  if (v5)
  {
    memmove(v4, v4 + 1, v5);
    LODWORD(v3) = *(_DWORD *)(a1 + 8);
  }
  *(_DWORD *)(a1 + 8) = v3 - 1;
  return 1;
}

int **sub_1CC34ECB8(int **result, unsigned int *a2)
{
  uint64_t v2 = result;
  if (result[8])
  {
    uint64_t v7 = (uint64_t)(result + 6);
    return (int **)sub_1CD50BF28(v7, a2);
  }
  else
  {
    uint64_t v3 = *((unsigned int *)result + 2);
    if (v3)
    {
      uint64_t result = (int **)*result;
      size_t v4 = 4 * v3 - 4;
      size_t v5 = *v2;
      while (1)
      {
        int v6 = *v5++;
        if (v6 == *a2) {
          break;
        }
        v4 -= 4;
        uint64_t result = (int **)v5;
        if (v4 == -4) {
          return result;
        }
      }
      if (v4)
      {
        uint64_t result = (int **)memmove(result, (char *)result + 4, v4);
        LODWORD(v3) = *((_DWORD *)v2 + 2);
      }
      *((_DWORD *)v2 + 2) = v3 - 1;
    }
  }
  return result;
}

uint64_t llvm::finalizeBundle(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (v2 != a1 + 48)
  {
    while ((*(_WORD *)(v2 + 44) & 4) != 0)
    {
      uint64_t v2 = *(void *)(v2 + 8);
      if (v2 == a1 + 48)
      {
        uint64_t v2 = a1 + 48;
        break;
      }
    }
  }
  llvm::finalizeBundle(a1, a2, v2);
  return v2;
}

uint64_t llvm::AnalyzeVirtRegInBundle(unint64_t a1, int a2, uint64_t a3)
{
  unint64_t v3 = a1;
  if ((*(_WORD *)(a1 + 44) & 4) != 0)
  {
    unint64_t v3 = a1;
    do
      unint64_t v3 = *(void *)v3 & 0xFFFFFFFFFFFFFFF8;
    while ((*(_WORD *)(v3 + 44) & 4) != 0);
  }
  uint64_t v4 = *(void *)(a1 + 24) + 48;
  size_t v5 = *(int **)(v3 + 32);
  uint64_t v6 = *(unsigned int *)(v3 + 40);
  uint64_t v7 = &v5[8 * v6];
  if (!v6)
  {
    uint64_t v25 = *(void *)(v3 + 8);
    if (v25 == v4)
    {
      unint64_t v3 = *(void *)(a1 + 24) + 48;
    }
    else
    {
      unint64_t v3 = *(void *)(a1 + 24) + 48;
      if ((*(_WORD *)(v25 + 44) & 4) != 0)
      {
        while (1)
        {
          uint64_t v26 = v25;
          uint64_t v27 = *(unsigned int *)(v25 + 40);
          if (v27) {
            break;
          }
          uint64_t v25 = *(void *)(v25 + 8);
          if (v25 == v4 || (*(_WORD *)(v25 + 44) & 4) == 0)
          {
            uint64_t v25 = *(void *)(a1 + 24) + 48;
            break;
          }
        }
        size_t v5 = *(int **)(v26 + 32);
        uint64_t v7 = &v5[8 * v27];
        unint64_t v3 = v25;
      }
    }
  }
  if (v5 != v7)
  {
    unsigned __int8 v8 = 0;
    unsigned __int8 v9 = 0;
    int v10 = 0;
    while (1)
    {
      int v11 = *v5;
      if (!*v5 && v5[1] == a2)
      {
        if (a3)
        {
          uint64_t v12 = *(void *)(v3 + 32);
          unint64_t v13 = *(unsigned int *)(a3 + 8);
          if (v13 >= *(unsigned int *)(a3 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v14 = (void *)(*(void *)a3 + 16 * v13);
          *uint64_t v14 = *((void *)v5 + 1);
          v14[1] = (((unint64_t)v5 - v12) >> 5);
          ++*(_DWORD *)(a3 + 8);
          int v11 = *v5;
        }
        BOOL v15 = (v11 & 0x1000000) == 0;
        BOOL v16 = (v11 & 0x30000000) != 0 || (v11 & 0x10FFF00) == 0x1000000;
        int v17 = v16;
        if (v16) {
          BOOL v15 = 1;
        }
        if (v15) {
          int v18 = v10;
        }
        else {
          int v18 = 1;
        }
        if (!v17) {
          unsigned __int8 v8 = 1;
        }
        if ((v11 & 0x1000000) != 0)
        {
          unsigned __int8 v9 = 1;
          int v10 = v18;
        }
        else if ((v10 & 1) == 0)
        {
          int v19 = *(_DWORD *)(*(void *)(*((void *)v5 + 1) + 32)
                          + (((unint64_t)v5 - *(void *)(v3 + 32)) & 0x1FFFFFFFE0));
          if ((v19 & 0xF00000) != 0 && (v19 & 0x10000FF) == 0) {
            int v10 = 1;
          }
        }
      }
      v5 += 8;
      if (v5 == v7)
      {
        unint64_t v21 = *(void *)(v3 + 8);
        if (v21 == v4) {
          return (v10 << 16) | (v9 << 8) | v8;
        }
        size_t v5 = v7;
        unint64_t v3 = v4;
        if ((*(_WORD *)(v21 + 44) & 4) != 0)
        {
          while (1)
          {
            unint64_t v23 = v21;
            uint64_t v24 = *(unsigned int *)(v21 + 40);
            if (v24) {
              break;
            }
            unint64_t v21 = *(void *)(v21 + 8);
            if (v21 == v4 || (*(_WORD *)(v21 + 44) & 4) == 0)
            {
              unint64_t v3 = v4;
              goto LABEL_46;
            }
          }
          unint64_t v3 = v21;
LABEL_46:
          size_t v5 = *(int **)(v23 + 32);
          uint64_t v7 = &v5[8 * v24];
        }
      }
      if (v5 == v7) {
        return (v10 << 16) | (v9 << 8) | v8;
      }
    }
  }
  int v10 = 0;
  unsigned __int8 v9 = 0;
  unsigned __int8 v8 = 0;
  return (v10 << 16) | (v9 << 8) | v8;
}

unint64_t llvm::AnalyzePhysRegInBundle(unint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = a1;
  if ((*(_WORD *)(a1 + 44) & 4) != 0)
  {
    unint64_t v3 = a1;
    do
      unint64_t v3 = *(void *)v3 & 0xFFFFFFFFFFFFFFF8;
    while ((*(_WORD *)(v3 + 44) & 4) != 0);
  }
  uint64_t v4 = *(void *)(a1 + 24) + 48;
  size_t v5 = *(unsigned int **)(v3 + 32);
  uint64_t v6 = *(unsigned int *)(v3 + 40);
  uint64_t v7 = (int *)&v5[8 * v6];
  if (!v6)
  {
    unint64_t v42 = *(void *)(v3 + 8);
    if (v42 == v4)
    {
      unint64_t v3 = *(void *)(a1 + 24) + 48;
    }
    else
    {
      unint64_t v3 = *(void *)(a1 + 24) + 48;
      if ((*(_WORD *)(v42 + 44) & 4) != 0)
      {
        do
        {
          unint64_t v43 = v42;
          uint64_t v44 = *(unsigned int *)(v42 + 40);
          if (v44)
          {
            unint64_t v3 = v42;
            goto LABEL_79;
          }
          unint64_t v42 = *(void *)(v42 + 8);
        }
        while (v42 != v4 && (*(_WORD *)(v42 + 44) & 4) != 0);
        unint64_t v3 = *(void *)(a1 + 24) + 48;
LABEL_79:
        size_t v5 = *(unsigned int **)(v43 + 32);
        uint64_t v7 = (int *)&v5[8 * v44];
      }
    }
  }
  if (v5 == (unsigned int *)v7)
  {
    unsigned __int8 v8 = 0;
    LOBYTE(v9) = 0;
    LOBYTE(v10) = 0;
    LOBYTE(v11) = 0;
    LOBYTE(v12) = 0;
    uint64_t v13 = 0;
    goto LABEL_64;
  }
  unsigned __int8 v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  int v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = a2;
  unsigned int v15 = a2 - 1;
  BOOL v16 = (void *)(a3 + 8);
  uint64_t v17 = a2 >> 5;
  int v18 = 1 << a2;
  char v19 = 1;
  do
  {
    unsigned int v20 = *v5;
    if (*v5)
    {
      if (*v5 == 12 && (*(_DWORD *)(*((void *)v5 + 2) + 4 * v17) & v18) == 0) {
        unsigned __int8 v8 = 1;
      }
    }
    else
    {
      unsigned int v21 = v5[1];
      if (v21 - 1 > 0x3FFFFFFE) {
        goto LABEL_51;
      }
      if (v21 == a2)
      {
        BOOL v22 = (v20 & 0x30000000) != 0 || (v20 & 0x10FFF00) == 0x1000000;
        if (!v22) {
          goto LABEL_46;
        }
        BOOL v23 = 1;
      }
      else
      {
        if (v15 > 0x3FFFFFFE) {
          goto LABEL_51;
        }
        int v45 = v18;
        uint64_t v46 = v17;
        int v47 = v16;
        unsigned int v48 = v15;
        uint64_t v49 = v9;
        uint64_t v50 = v11;
        int v51 = v12;
        uint64_t v52 = v13;
        uint64_t v53 = v10;
        uint64_t v25 = a2;
        uint64_t v26 = a3;
        uint64_t v27 = v14;
        if (!llvm::MCRegisterInfo::regsOverlap(v16, v21, v14))
        {
          a3 = v26;
          a2 = v25;
          uint64_t v9 = v49;
          uint64_t v11 = v50;
          uint64_t v13 = v52;
          uint64_t v10 = v53;
          int v12 = v51;
          uint64_t v14 = v27;
          unsigned int v15 = v48;
          uint64_t v17 = v46;
          BOOL v16 = v47;
          int v18 = v45;
          goto LABEL_51;
        }
        a3 = v26;
        unsigned int v28 = (_WORD *)(*(void *)(v26 + 56)
                      + 2 * *(unsigned int *)(*(void *)(v26 + 8) + 24 * v27 + 8));
        int v29 = (unsigned __int16)*v28;
        a2 = v25;
        unsigned __int16 v30 = v29 + v25;
        BOOL v22 = v29 == 0;
        BOOL v23 = *v28 != 0;
        BOOL v31 = v22 || v21 == v30;
        uint64_t v9 = v49;
        uint64_t v11 = v50;
        uint64_t v10 = v53;
        int v12 = v51;
        uint64_t v14 = v27;
        uint64_t v17 = v46;
        BOOL v16 = v47;
        int v18 = v45;
        if (v31)
        {
          uint64_t v13 = v52;
          unsigned int v15 = v48;
        }
        else
        {
          uint64_t v32 = v28 + 1;
          unsigned int v15 = v48;
          do
          {
            int v34 = *v32++;
            int v33 = v34;
            v30 += v34;
            BOOL v23 = v34 != 0;
            if (!v34) {
              uint64_t v32 = 0;
            }
            if (v33) {
              BOOL v35 = v21 == v30;
            }
            else {
              BOOL v35 = 1;
            }
          }
          while (!v35);
          uint64_t v13 = v52;
        }
        if ((v20 & 0x30000000) == 0 && (v20 & 0x10FFF00) != 0x1000000)
        {
          if (v23)
          {
LABEL_46:
            if ((v20 >> 26) & ~HIBYTE(v20)) {
              uint64_t v13 = 1;
            }
            else {
              uint64_t v13 = v13;
            }
            int v12 = 1;
          }
          uint64_t v11 = 1;
          goto LABEL_51;
        }
      }
      if (v23) {
        unsigned int v24 = 1;
      }
      else {
        unsigned int v24 = v10;
      }
      if ((v20 & 0x1000000) != 0)
      {
        v19 &= (~v20 & 0x5000000) == 0;
        uint64_t v10 = v24;
      }
      else
      {
        uint64_t v10 = v10;
      }
      if ((v20 & 0x1000000) != 0) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = v9;
      }
    }
LABEL_51:
    v5 += 8;
    if (v5 == (unsigned int *)v7)
    {
      unint64_t v36 = *(void *)(v3 + 8);
      if (v36 == v4) {
        break;
      }
      size_t v5 = (unsigned int *)v7;
      unint64_t v3 = v4;
      if ((*(_WORD *)(v36 + 44) & 4) != 0)
      {
        while (1)
        {
          unint64_t v37 = v36;
          uint64_t v38 = *(unsigned int *)(v36 + 40);
          if (v38) {
            break;
          }
          unint64_t v36 = *(void *)(v36 + 8);
          if (v36 == v4 || (*(_WORD *)(v36 + 44) & 4) == 0)
          {
            unint64_t v3 = v4;
            goto LABEL_59;
          }
        }
        unint64_t v3 = v36;
LABEL_59:
        size_t v5 = *(unsigned int **)(v37 + 32);
        uint64_t v7 = (int *)&v5[8 * v38];
      }
    }
  }
  while (v5 != (unsigned int *)v7);
  if ((v19 & 1) == 0)
  {
    unint64_t v39 = 0;
    uint64_t v40 = 0;
    return ((unint64_t)v11 << 24) | ((unint64_t)v12 << 32) | ((unint64_t)v10 << 16) | v40 | v39 | (v13 << 56) | v8 | ((unint64_t)v9 << 8);
  }
LABEL_64:
  unint64_t v39 = (unint64_t)(v9 & 1) << 48;
  if ((v10 | v8))
  {
    unint64_t v39 = 0;
    uint64_t v40 = 0x10000000000;
  }
  else
  {
    uint64_t v40 = 0;
  }
  return ((unint64_t)v11 << 24) | ((unint64_t)v12 << 32) | ((unint64_t)v10 << 16) | v40 | v39 | (v13 << 56) | v8 | ((unint64_t)v9 << 8);
}

void sub_1CC34F414()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1CC34F4F4(llvm::Pass *this)
{
  *(void *)this = &unk_1F260E350;
  uint64_t v2 = (char *)this + 248;
  unint64_t v3 = (char *)*((void *)this + 34);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  *(void *)this = &unk_1F260E110;
  uint64_t v4 = (char *)*((void *)this + 22);
  if (v4 != (char *)this + 192) {
    free(v4);
  }
  size_t v5 = (char *)*((void *)this + 13);
  if (v5 != (char *)this + 120) {
    free(v5);
  }
  uint64_t v6 = (char *)*((void *)this + 4);
  if (v6 != (char *)this + 48) {
    free(v6);
  }

  llvm::Pass::~Pass(this);
}

void sub_1CC34F60C(llvm::Pass *this)
{
  *(void *)this = &unk_1F260E350;
  uint64_t v2 = (char *)this + 248;
  unint64_t v3 = (char *)*((void *)this + 34);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  *(void *)this = &unk_1F260E110;
  uint64_t v4 = (char *)*((void *)this + 22);
  if (v4 != (char *)this + 192) {
    free(v4);
  }
  size_t v5 = (char *)*((void *)this + 13);
  if (v5 != (char *)this + 120) {
    free(v5);
  }
  uint64_t v6 = (char *)*((void *)this + 4);
  if (v6 != (char *)this + 48) {
    free(v6);
  }
  llvm::Pass::~Pass(this);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC34F738(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 272);
  if (v3 && !(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, a2)
    || (uint64_t v4 = a2 + 320, v5 = *(void *)(a2 + 328), v5 == v4))
  {
    char v6 = 0;
  }
  else
  {
    char v6 = 0;
    do
    {
      uint64_t v7 = v5 + 48;
      uint64_t v8 = *(void *)(v5 + 56);
      if (v8 != v5 + 48)
      {
        do
        {
          uint64_t v9 = *(void *)(v8 + 8);
          if (**(_WORD **)(v8 + 16) == 20)
          {
            uint64_t v10 = v5 + 48;
            if (v9 != v7)
            {
              while (1)
              {
                __int16 v11 = *(_WORD *)(v9 + 44);
                if ((v11 & 4) == 0) {
                  break;
                }
                *(_WORD *)(v9 + 44) = v11 & 0xFFFB;
                *(_WORD *)((*(void *)v9 & 0xFFFFFFFFFFFFFFF8) + 44) &= ~8u;
                uint64_t v12 = *(unsigned int *)(v9 + 40);
                if (v12)
                {
                  uint64_t v13 = 0;
                  uint64_t v14 = 32 * v12;
                  do
                  {
                    uint64_t v15 = *(void *)(v9 + 32);
                    int v16 = *(_DWORD *)(v15 + v13);
                    if ((v16 & 0x200000FF) == 0x20000000) {
                      *(_DWORD *)(v15 + v13) = v16 & 0xDFFFFFFF;
                    }
                    v13 += 32;
                  }
                  while (v14 != v13);
                }
                uint64_t v9 = *(void *)(v9 + 8);
                if (v9 == v7)
                {
                  uint64_t v10 = v5 + 48;
                  goto LABEL_17;
                }
              }
              uint64_t v10 = v9;
            }
LABEL_17:
            llvm::MachineInstr::eraseFromParent((llvm::MachineInstr *)v8);
            char v6 = 1;
            uint64_t v9 = v10;
          }
          uint64_t v8 = v9;
        }
        while (v9 != v7);
      }
      uint64_t v5 = *(void *)(v5 + 8);
    }
    while (v5 != v4);
  }
  return v6 & 1;
}

void sub_1CC34F88C()
{
}

void sub_1CC34F99C(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F260E110;
  int v1 = (void *)*((void *)a1 + 22);
  if (v1 != (void *)((char *)a1 + 192))
  {
    uint64_t v4 = a1;
    free(v1);
    a1 = v4;
  }
  uint64_t v2 = (void *)*((void *)a1 + 13);
  if (v2 != (void *)((char *)a1 + 120))
  {
    uint64_t v5 = a1;
    free(v2);
    a1 = v5;
  }
  uint64_t v3 = (void *)*((void *)a1 + 4);
  if (v3 != (void *)((char *)a1 + 48))
  {
    char v6 = a1;
    free(v3);
    a1 = v6;
  }

  llvm::Pass::~Pass(a1);
}

void sub_1CC34FA50(llvm::Pass *this)
{
  *(void *)this = &unk_1F260E110;
  uint64_t v2 = (char *)*((void *)this + 22);
  if (v2 != (char *)this + 192) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 13);
  if (v3 != (char *)this + 120) {
    free(v3);
  }
  uint64_t v4 = (char *)*((void *)this + 4);
  if (v4 != (char *)this + 48) {
    free(v4);
  }
  llvm::Pass::~Pass(this);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC34FAFC(int a1, llvm *this)
{
  return llvm::finalizeBundles(this, this);
}

void llvm::MachineInstr::addImplicitDefUseOperands(llvm::MachineInstr *this, llvm::MachineFunction *a2)
{
  uint64_t v4 = *((void *)this + 2);
  uint64_t v5 = *(_WORD **)(v4 + 32);
  if (v5)
  {
    int v10 = (unsigned __int16)*v5;
    if (*v5)
    {
      __int16 v11 = v5 + 1;
      do
      {
        uint64_t v15 = 0;
        uint64_t v16 = 0;
        uint64_t v17 = 0;
        int v13 = 50331648;
        int v14 = v10;
        llvm::MachineInstr::addOperand(this, a2, (const llvm::MachineOperand *)&v13);
        int v12 = *v11++;
        int v10 = v12;
      }
      while (v12);
      uint64_t v4 = *((void *)this + 2);
    }
  }
  char v6 = *(_WORD **)(v4 + 24);
  if (v6)
  {
    int v7 = (unsigned __int16)*v6;
    if (*v6)
    {
      uint64_t v8 = v6 + 1;
      do
      {
        uint64_t v15 = 0;
        uint64_t v16 = 0;
        uint64_t v17 = 0;
        int v13 = 0x2000000;
        int v14 = v7;
        llvm::MachineInstr::addOperand(this, a2, (const llvm::MachineOperand *)&v13);
        int v9 = *v8++;
        int v7 = v9;
      }
      while (v9);
    }
  }
}

void llvm::MachineInstr::addOperand(llvm::MachineInstr *this, llvm::MachineFunction *a2, const llvm::MachineOperand *a3)
{
  char v6 = (const llvm::MachineOperand *)*((void *)this + 4);
  LODWORD(v7) = *((_DWORD *)this + 10);
  uint64_t v8 = v7;
  if (v6 <= a3 && (const llvm::MachineOperand *)((char *)v6 + 32 * v7) > a3)
  {
    long long v14 = *((_OWORD *)a3 + 1);
    v75[0] = *(_OWORD *)a3;
    v75[1] = v14;
    llvm::MachineInstr::addOperand(this, a2, (const llvm::MachineOperand *)v75);
    return;
  }
  int v10 = *(_DWORD *)a3 & 0x20000FF;
  if (v10 != 0x2000000 && **((unsigned __int16 **)this + 2) - 1 >= 2 && v7 != 0)
  {
    int v12 = (int *)((char *)v6 + 32 * v7 - 32);
    uint64_t v7 = *((unsigned int *)this + 10);
    do
    {
      int v13 = *v12;
      v12 -= 8;
      if ((v13 & 0x20000FF) != 0x2000000) {
        break;
      }
      --v7;
    }
    while (v7);
  }
  uint64_t v15 = *((void *)this + 3);
  if (v15) {
    uint64_t v16 = *(void *)(*(void *)(v15 + 32) + 40);
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v17 = *((unsigned __int8 *)this + 47);
  if (v6)
  {
    if (1 << v17 != v8)
    {
LABEL_40:
      int v31 = *((_DWORD *)this + 10);
      int v32 = v7 - v31;
      if (v7 == v31) {
        goto LABEL_63;
      }
      uint64_t v33 = *((void *)this + 4);
      int v34 = (char *)(v33 + 32 * v7 + 32);
      BOOL v35 = (char *)v6 + 32 * v7;
      uint64_t v36 = (v31 - v7);
      if (v16)
      {
        BOOL v37 = &v35[32 * v36] > v34;
        uint64_t v38 = (v36 - 1);
        uint64_t v39 = -32;
        if (v34 >= v35 && v37)
        {
          uint64_t v40 = v38;
        }
        else
        {
          uint64_t v39 = 32;
          uint64_t v40 = 0;
        }
        uint64_t v41 = 4 * v7;
        uint64_t v42 = v33 + 32 * v40 + 32;
        unint64_t v43 = (void *)((char *)v6 + 32 * v40);
        do
        {
          uint64_t v44 = (_OWORD *)(v42 + v41 * 8);
          int v45 = &v43[v41];
          long long v46 = *(_OWORD *)&v43[v41 + 2];
          *uint64_t v44 = *(_OWORD *)&v43[4 * v7];
          v44[1] = v46;
          if (!LOBYTE(v43[4 * v7]))
          {
            uint64_t v47 = *((unsigned int *)v45 + 1);
            if ((v47 & 0x80000000) != 0) {
              unsigned int v48 = (uint64_t *)(*(void *)(v16 + 24) + 16 * (v47 & 0x7FFFFFFF) + 8);
            }
            else {
              unsigned int v48 = (uint64_t *)(*(void *)(v16 + 272) + 8 * v47);
            }
            uint64_t v49 = v43[v41 + 3];
            if (v45 == (void *)*v48)
            {
              *unsigned int v48 = (uint64_t)v44;
              uint64_t v50 = v42 + v41 * 8;
            }
            else
            {
              *(void *)(v43[v41 + 2] + 24) = v44;
              uint64_t v50 = *v48;
            }
            if (v49) {
              uint64_t v50 = v49;
            }
            *(void *)(v50 + 16) = v44;
          }
          v42 += v39;
          unint64_t v43 = (void *)((char *)v43 + v39);
        }
        while (!__CFADD__(v32++, 1));
        goto LABEL_63;
      }
      unsigned int v52 = v36;
      goto LABEL_62;
    }
    unsigned __int8 v18 = v17 + 1;
  }
  else
  {
    unsigned __int8 v18 = 0;
  }
  *((unsigned char *)this + 47) = v18;
  char v19 = (char *)sub_1CC357150((uint64_t *)a2 + 29, v18, (uint64_t *)a2 + 16);
  *((void *)this + 4) = v19;
  if (!v7) {
    goto LABEL_40;
  }
  if (v16)
  {
    uint64_t v20 = -32;
    if (v19 >= (char *)v6 && (char *)v6 + 32 * v7 > v19)
    {
      uint64_t v21 = (v7 - 1);
    }
    else
    {
      uint64_t v20 = 32;
      uint64_t v21 = 0;
    }
    uint64_t v22 = 32 * v21;
    int v23 = v7;
    do
    {
      unsigned int v24 = &v19[v22];
      uint64_t v25 = (char *)v6 + v22;
      long long v26 = *(_OWORD *)((char *)v6 + v22 + 16);
      *(_OWORD *)unsigned int v24 = *(_OWORD *)((char *)v6 + v22);
      *((_OWORD *)v24 + 1) = v26;
      if (!*((unsigned char *)v6 + v22))
      {
        uint64_t v27 = *((unsigned int *)v25 + 1);
        if ((v27 & 0x80000000) != 0) {
          unsigned int v28 = (char **)(*(void *)(v16 + 24) + 16 * (v27 & 0x7FFFFFFF) + 8);
        }
        else {
          unsigned int v28 = (char **)(*(void *)(v16 + 272) + 8 * v27);
        }
        int v29 = *(char **)((char *)v6 + v22 + 24);
        if (v25 == *v28)
        {
          *unsigned int v28 = v24;
          unsigned __int16 v30 = &v19[v22];
        }
        else
        {
          *(void *)(*(void *)((char *)v6 + v22 + 16) + 24) = v24;
          unsigned __int16 v30 = *v28;
        }
        if (v29) {
          unsigned __int16 v30 = v29;
        }
        *((void *)v30 + 2) = v24;
      }
      v22 += v20;
      --v23;
    }
    while (v23);
    goto LABEL_40;
  }
  memmove(v19, v6, 32 * v7);
  unsigned int v52 = *((_DWORD *)this + 10) - v7;
  if (!v52) {
    goto LABEL_63;
  }
  int v34 = (char *)(*((void *)this + 4) + 32 * v7 + 32);
  BOOL v35 = (char *)v6 + 32 * v7;
LABEL_62:
  memmove(v34, v35, 32 * v52);
LABEL_63:
  ++*((_DWORD *)this + 10);
  uint64_t v53 = (const llvm::MachineOperand *)*((void *)this + 4);
  if (v6 && v6 != v53)
  {
    uint64_t v54 = (uint64_t *)((char *)a2 + 232);
    if (*((_DWORD *)a2 + 60) <= v17) {
      sub_1CC34BDE0((uint64_t)a2 + 232, v17 + 1);
    }
    uint64_t v55 = *v54;
    *(void *)char v6 = *(void *)(*v54 + 8 * v17);
    *(void *)(v55 + 8 * v17) = v6;
    uint64_t v53 = (const llvm::MachineOperand *)*((void *)this + 4);
  }
  uint64_t v56 = (void *)((char *)v53 + 32 * v7);
  long long v57 = *((_OWORD *)a3 + 1);
  *(_OWORD *)uint64_t v56 = *(_OWORD *)a3;
  *((_OWORD *)v56 + 1) = v57;
  v56[1] = this;
  int v58 = *(_DWORD *)v56;
  if (!*(_DWORD *)v56)
  {
    v56[2] = 0;
    uint64_t v59 = v56 + 2;
    unsigned int v60 = v58 & 0xFF0FFFFF;
    *(_DWORD *)uint64_t v56 = v60;
    if (v16)
    {
      uint64_t v61 = *((unsigned int *)v53 + 8 * v7 + 1);
      if ((v61 & 0x80000000) != 0) {
        uint64_t v62 = (uint64_t *)(*(void *)(v16 + 24) + 16 * (v61 & 0x7FFFFFFF) + 8);
      }
      else {
        uint64_t v62 = (uint64_t *)(*(void *)(v16 + 272) + 8 * v61);
      }
      uint64_t v63 = *v62;
      if (*v62)
      {
        uint64_t v64 = *(void *)(v63 + 16);
        *(void *)(v63 + 16) = v56;
        *uint64_t v59 = v64;
        uint64_t v65 = (void *)((char *)v53 + 32 * v7 + 24);
        if (*((unsigned char *)v56 + 3))
        {
          *uint64_t v65 = v63;
        }
        else
        {
          *uint64_t v65 = 0;
          uint64_t v62 = (uint64_t *)(v64 + 24);
        }
      }
      else
      {
        *uint64_t v59 = v56;
        *((void *)v53 + 4 * v7 + 3) = 0;
      }
      *uint64_t v62 = (uint64_t)v56;
      unsigned int v60 = *(_DWORD *)v56;
    }
    if (v10 != 0x2000000)
    {
      if ((v60 & 0x1000000) == 0)
      {
        uint64_t v66 = *((void *)this + 2);
        if (v7 < *(unsigned __int16 *)(v66 + 2))
        {
          __int16 v67 = *(_WORD *)(*(void *)(v66 + 40) + 6 * v7 + 4);
          if (v67)
          {
            uint64_t v68 = v67 >> 4;
            uint64_t v69 = *((void *)this + 4);
            size_t v70 = (unsigned int *)(v69 + 32 * v7);
            unsigned int v71 = *v70 & 0xFF0FFFFF | (((((v68 << 20) + 0x100000) >> 20) & 0xF) << 20);
            if (v68 == 15) {
              unsigned int v71 = *v70 | 0xF00000;
            }
            uint64_t v72 = 32 * v68;
            *size_t v70 = v71;
            if (v7 >= 0xE) {
              int v73 = 14;
            }
            else {
              int v73 = v7;
            }
            *(_DWORD *)(v69 + v72) = *(_DWORD *)(v69 + v72) & 0xFF0FFFFF | ((v73 << 20) + 0x100000);
          }
        }
      }
      uint64_t v74 = *((void *)this + 2);
      if (v7 >= *(unsigned __int16 *)(v74 + 2))
      {
        unsigned int v60 = *(_DWORD *)v56;
      }
      else
      {
        unsigned int v60 = *(_DWORD *)v56;
        if ((*(_WORD *)(*(void *)(v74 + 40) + 6 * v7 + 4) & 2) != 0)
        {
          v60 |= 0x40000000u;
          *(_DWORD *)uint64_t v56 = v60;
        }
      }
    }
    if ((v60 & 0x1000000) == 0 && **((unsigned __int16 **)this + 2) - 13 <= 4) {
      *(_DWORD *)uint64_t v56 = v60 | 0x80000000;
    }
  }
}

llvm::MachineInstr *llvm::MachineInstr::MachineInstr(llvm::MachineInstr *this, llvm::MachineFunction *a2, uint64_t a3, unsigned __int8 **a4, char a5)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((void *)this + 7) = *a4;
  *((void *)this + 2) = a3;
  if (*a4)
  {
    llvm::MetadataTracking::retrack((uint64_t)a4, *a4, (uint64_t)this + 56);
    *a4 = 0;
    a3 = *((void *)this + 2);
  }
  unsigned int v8 = 0;
  *((_DWORD *)this + 16) = 0;
  uint64_t v9 = *(void *)(a3 + 32);
  if (v9)
  {
    unsigned int v8 = -1;
    do
      ++v8;
    while (*(_WORD *)(v9 + 2 * v8));
  }
  unsigned int v10 = v8 + *(unsigned __int16 *)(a3 + 2);
  uint64_t v11 = *(void *)(a3 + 24);
  if (v11)
  {
    unsigned int v12 = -1;
    do
      ++v12;
    while (*(_WORD *)(v11 + 2 * v12));
  }
  else
  {
    unsigned int v12 = 0;
  }
  uint64_t v13 = v10 + v12;
  if (v13)
  {
    unsigned __int8 v14 = 64 - __clz(v13 - 1);
    *((unsigned char *)this + 47) = v14;
    *((void *)this + 4) = sub_1CC357150((uint64_t *)a2 + 29, v14, (uint64_t *)a2 + 16);
  }
  if ((a5 & 1) == 0)
  {
    uint64_t v15 = *((void *)this + 2);
    uint64_t v16 = *(_WORD **)(v15 + 32);
    if (v16)
    {
      int v23 = (unsigned __int16)*v16;
      if (*v16)
      {
        unsigned int v24 = v16 + 1;
        do
        {
          uint64_t v28 = 0;
          uint64_t v29 = 0;
          uint64_t v30 = 0;
          int v26 = 50331648;
          int v27 = v23;
          llvm::MachineInstr::addOperand(this, a2, (const llvm::MachineOperand *)&v26);
          int v25 = *v24++;
          int v23 = v25;
        }
        while (v25);
        uint64_t v15 = *((void *)this + 2);
      }
    }
    uint64_t v17 = *(_WORD **)(v15 + 24);
    if (v17)
    {
      int v20 = (unsigned __int16)*v17;
      if (*v17)
      {
        uint64_t v21 = v17 + 1;
        do
        {
          uint64_t v28 = 0;
          uint64_t v29 = 0;
          uint64_t v30 = 0;
          int v26 = 0x2000000;
          int v27 = v20;
          llvm::MachineInstr::addOperand(this, a2, (const llvm::MachineOperand *)&v26);
          int v22 = *v21++;
          int v20 = v22;
        }
        while (v22);
      }
    }
  }
  return this;
}

llvm::MachineInstr *llvm::MachineInstr::MachineInstr(llvm::MachineInstr *this, llvm::MachineFunction *a2, const llvm::MachineInstr *a3)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = *((void *)a3 + 2);
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = *((void *)a3 + 6);
  char v6 = (unsigned __int8 *)*((void *)a3 + 7);
  *((void *)this + 7) = v6;
  uint64_t v7 = (char *)this + 56;
  if (v6) {
    llvm::MetadataTracking::track((uint64_t)v7, v6, 2);
  }
  *((_DWORD *)this + 16) = 0;
  unsigned __int8 v8 = 64 - __clz(*((unsigned int *)a3 + 10) - 1);
  if (*((_DWORD *)a3 + 10)) {
    unsigned __int8 v9 = v8;
  }
  else {
    unsigned __int8 v9 = 0;
  }
  *((unsigned char *)this + 47) = v9;
  *((void *)this + 4) = sub_1CC357150((uint64_t *)a2 + 29, v9, (uint64_t *)a2 + 16);
  uint64_t v10 = *((unsigned int *)a3 + 10);
  if (v10)
  {
    uint64_t v11 = (const llvm::MachineOperand *)*((void *)a3 + 4);
    uint64_t v12 = 32 * v10;
    do
    {
      llvm::MachineInstr::addOperand(this, a2, v11);
      uint64_t v11 = (const llvm::MachineOperand *)((char *)v11 + 32);
      v12 -= 32;
    }
    while (v12);
  }
  *((_WORD *)this + 22) = *((_WORD *)this + 22) & 0xC | *((_WORD *)a3 + 22) & 0xFFF3;
  return this;
}

{
  unsigned __int8 *v6;
  char *v7;
  unsigned __int8 v8;
  unsigned __int8 v9;
  uint64_t v10;
  const llvm::MachineOperand *v11;
  uint64_t v12;

  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = *((void *)a3 + 2);
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = *((void *)a3 + 6);
  char v6 = (unsigned __int8 *)*((void *)a3 + 7);
  *((void *)this + 7) = v6;
  uint64_t v7 = (char *)this + 56;
  if (v6) {
    llvm::MetadataTracking::track((uint64_t)v7, v6, 2);
  }
  *((_DWORD *)this + 16) = 0;
  unsigned __int8 v8 = 64 - __clz(*((unsigned int *)a3 + 10) - 1);
  if (*((_DWORD *)a3 + 10)) {
    unsigned __int8 v9 = v8;
  }
  else {
    unsigned __int8 v9 = 0;
  }
  *((unsigned char *)this + 47) = v9;
  *((void *)this + 4) = sub_1CC357150((uint64_t *)a2 + 29, v9, (uint64_t *)a2 + 16);
  uint64_t v10 = *((unsigned int *)a3 + 10);
  if (v10)
  {
    uint64_t v11 = (const llvm::MachineOperand *)*((void *)a3 + 4);
    uint64_t v12 = 32 * v10;
    do
    {
      llvm::MachineInstr::addOperand(this, a2, v11);
      uint64_t v11 = (const llvm::MachineOperand *)((char *)v11 + 32);
      v12 -= 32;
    }
    while (v12);
  }
  *((_WORD *)this + 22) = *((_WORD *)this + 22) & 0xC | *((_WORD *)a3 + 22) & 0xFFF3;
  return this;
}

uint64_t llvm::MachineInstr::getRegInfo(llvm::MachineInstr *this)
{
  uint64_t v1 = *((void *)this + 3);
  if (v1) {
    return *(void *)(*(void *)(v1 + 32) + 40);
  }
  else {
    return 0;
  }
}

uint64_t llvm::MachineInstr::removeRegOperandsFromUseLists(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 40);
  if (v2)
  {
    uint64_t v3 = *(void *)(result + 32);
    uint64_t v4 = 32 * v2;
    do
    {
      if (!*(unsigned char *)v3)
      {
        uint64_t v5 = *(unsigned int *)(v3 + 4);
        if ((v5 & 0x80000000) != 0) {
          char v6 = (uint64_t *)(*(void *)(a2 + 24) + 16 * (v5 & 0x7FFFFFFF) + 8);
        }
        else {
          char v6 = (uint64_t *)(*(void *)(a2 + 272) + 8 * v5);
        }
        uint64_t v7 = *v6;
        uint64_t v9 = *(void *)(v3 + 16);
        uint64_t v8 = *(void *)(v3 + 24);
        if (v3 != *v6) {
          char v6 = (uint64_t *)(v9 + 24);
        }
        uint64_t *v6 = v8;
        if (v8) {
          uint64_t v10 = v8;
        }
        else {
          uint64_t v10 = v7;
        }
        *(void *)(v10 + 16) = v9;
        *(void *)(v3 + 16) = 0;
        *(void *)(v3 + 24) = 0;
      }
      v3 += 32;
      v4 -= 32;
    }
    while (v4);
  }
  return result;
}

uint64_t llvm::MachineInstr::addRegOperandsToUseLists(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 40);
  if (v2)
  {
    uint64_t v3 = *(void *)(result + 32);
    uint64_t v4 = 32 * v2;
    do
    {
      if (!*(unsigned char *)v3)
      {
        uint64_t v5 = *(unsigned int *)(v3 + 4);
        if ((int)v5 >= 0) {
          char v6 = (uint64_t *)(*(void *)(a2 + 272) + 8 * v5);
        }
        else {
          char v6 = (uint64_t *)(*(void *)(a2 + 24) + 16 * (v5 & 0x7FFFFFFF) + 8);
        }
        uint64_t v7 = *v6;
        if (*v6)
        {
          uint64_t v8 = *(void *)(v7 + 16);
          *(void *)(v7 + 16) = v3;
          *(void *)(v3 + 16) = v8;
          if (*(unsigned char *)(v3 + 3))
          {
            *(void *)(v3 + 24) = v7;
          }
          else
          {
            *(void *)(v3 + 24) = 0;
            char v6 = (uint64_t *)(v8 + 24);
          }
        }
        else
        {
          *(void *)(v3 + 16) = v3;
          *(void *)(v3 + 24) = 0;
        }
        uint64_t *v6 = v3;
      }
      v3 += 32;
      v4 -= 32;
    }
    while (v4);
  }
  return result;
}

void llvm::MachineInstr::addOperand(llvm::MachineInstr *this, const llvm::MachineOperand *a2)
{
}

char *llvm::MachineInstr::removeOperand(char *this, unsigned int a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = (_DWORD *)(*((void *)this + 4) + 32 * a2);
  if (*v3) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = (*v3 & 0xF00000) == 0;
  }
  if (!v4)
  {
    BOOL v37 = this;
    unsigned int v35 = a2;
    uint64_t v34 = a2;
    int v31 = (_DWORD *)(*((void *)this + 4) + 32 * a2);
    unsigned int TiedOperandIdx = llvm::MachineInstr::findTiedOperandIdx((llvm::MachineInstr *)this, a2);
    uint64_t v2 = v34;
    a2 = v35;
    unsigned int v33 = TiedOperandIdx;
    this = v37;
    *(_DWORD *)(*((void *)v37 + 4) + 32 * v33) &= 0xFF0FFFFF;
    *v31 &= 0xFF0FFFFF;
  }
  uint64_t v5 = *((void *)this + 3);
  if (v5 && (uint64_t v6 = *(void *)(*(void *)(v5 + 32) + 40)) != 0)
  {
    uint64_t v7 = *((void *)this + 4);
    uint64_t v8 = v7 + 32 * v2;
    if (!*(unsigned char *)v8)
    {
      uint64_t v11 = *(unsigned int *)(v8 + 4);
      if ((v11 & 0x80000000) != 0) {
        uint64_t v12 = (void *)(*(void *)(v6 + 24) + 16 * (v11 & 0x7FFFFFFF) + 8);
      }
      else {
        uint64_t v12 = (void *)(*(void *)(v6 + 272) + 8 * v11);
      }
      uint64_t v13 = *v12;
      uint64_t v14 = v7 + 32 * v2;
      uint64_t v16 = *(void *)(v14 + 16);
      uint64_t v15 = *(void *)(v14 + 24);
      if (*v12 == v8) {
        uint64_t v17 = v12;
      }
      else {
        uint64_t v17 = (void *)(v16 + 24);
      }
      void *v17 = v15;
      if (v15) {
        uint64_t v18 = v15;
      }
      else {
        uint64_t v18 = v13;
      }
      *(void *)(v18 + 16) = v16;
      *(void *)(v14 + 16) = 0;
      *(void *)(v14 + 24) = 0;
    }
    uint64_t v9 = this + 40;
    int v10 = *((_DWORD *)this + 10);
    if (v10 + ~a2)
    {
      int v19 = a2 - v10 + 1;
      uint64_t v20 = *((void *)this + 4) + 32 * v2 + 32;
      do
      {
        long long v21 = *(_OWORD *)(v20 + 16);
        *(_OWORD *)(v20 - 32) = *(_OWORD *)v20;
        *(_OWORD *)(v20 - 16) = v21;
        if (!*(unsigned char *)v20)
        {
          uint64_t v22 = *(unsigned int *)(v20 + 4);
          if ((v22 & 0x80000000) != 0) {
            int v23 = (uint64_t *)(*(void *)(v6 + 24) + 16 * (v22 & 0x7FFFFFFF) + 8);
          }
          else {
            int v23 = (uint64_t *)(*(void *)(v6 + 272) + 8 * v22);
          }
          uint64_t v24 = v20 - 32;
          uint64_t v25 = *(void *)(v20 + 24);
          if (v20 == *v23)
          {
            *int v23 = v24;
            uint64_t v26 = v20 - 32;
          }
          else
          {
            *(void *)(*(void *)(v20 + 16) + 24) = v24;
            uint64_t v26 = *v23;
          }
          if (v25) {
            uint64_t v26 = v25;
          }
          *(void *)(v26 + 16) = v24;
        }
        v20 += 32;
      }
      while (!__CFADD__(v19++, 1));
    }
  }
  else
  {
    uint64_t v28 = this;
    int v29 = *((_DWORD *)this + 10);
    this += 40;
    uint64_t v36 = this;
    unsigned int v30 = v29 + ~a2;
    if (v30) {
      this = (char *)memmove((void *)(v28[4] + 32 * v2), (const void *)(v28[4] + 32 * v2 + 32), 32 * v30);
    }
    uint64_t v9 = v36;
  }
  --*v9;
  return this;
}

uint64_t llvm::MachineInstr::setExtraInfo(uint64_t result, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = result;
  if (a5) {
    int v8 = a4 + 1;
  }
  else {
    int v8 = a4;
  }
  if (a6) {
    ++v8;
  }
  if (a7) {
    ++v8;
  }
  if (v8 <= 0)
  {
    *(void *)(result + 48) = 0;
  }
  else
  {
    if (a7 || v8 != 1)
    {
      uint64_t result = sub_1CC34A418((uint64_t *)(a2 + 128), a3, a4, a5, a6, a7);
      uint64_t v9 = result | 3;
    }
    else if (a5)
    {
      uint64_t v9 = a5 | 1;
    }
    else if (a6)
    {
      uint64_t v9 = a6 | 2;
    }
    else
    {
      uint64_t v9 = *a3;
    }
    *(void *)(v7 + 48) = v9;
  }
  return result;
}

uint64_t llvm::MachineInstr::dropMemRefs(uint64_t this, llvm::MachineFunction *a2)
{
  unint64_t v2 = *(void *)(this + 48);
  if (v2 < 8) {
    return this;
  }
  uint64_t v3 = this;
  if ((v2 & 7) != 0)
  {
    unint64_t v4 = v2 & 0xFFFFFFFFFFFFFFF8;
    BOOL v10 = (*(void *)(this + 48) & 7) != 3 || v4 == 0;
    if (v10 || !*(_DWORD *)v4) {
      return this;
    }
  }
  else
  {
    unint64_t v4 = v2 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(this + 48) = v2 & 0xFFFFFFFFFFFFFFF8;
    if ((v2 & 0xFFFFFFFFFFFFFFF8) == 0) {
      goto LABEL_24;
    }
    LOBYTE(v2) = v2 & 0xF8;
  }
  unint64_t v5 = v2 & 7;
  if (v5 != 1)
  {
    if (v5 == 3)
    {
      uint64_t v11 = *(unsigned __int8 *)(v4 + 4);
      if (*(unsigned char *)(v4 + 4)) {
        unint64_t v12 = *(void *)(v4 + 8 * *(int *)v4 + 8);
      }
      else {
        unint64_t v12 = 0;
      }
      if (*(unsigned char *)(v4 + 5)) {
        uint64_t v7 = *(void *)(v4 + 8 * *(int *)v4 + 8 * v11 + 8);
      }
      else {
        uint64_t v7 = 0;
      }
      if (*(unsigned char *)(v4 + 6)) {
        uint64_t v6 = *(void *)(v4 + 8 * *(int *)v4 + 8 * (*(unsigned __int8 *)(v4 + 5) + v11) + 8);
      }
      else {
        uint64_t v6 = 0;
      }
      unint64_t v4 = v12;
    }
    else
    {
      uint64_t v6 = 0;
      if (v5 == 2) {
        uint64_t v7 = v4;
      }
      else {
        uint64_t v7 = 0;
      }
      unint64_t v4 = 0;
    }
    goto LABEL_11;
  }
LABEL_24:
  uint64_t v7 = 0;
  uint64_t v6 = 0;
LABEL_11:
  int v8 = v7 != 0;
  if (v4) {
    ++v8;
  }
  if (v6) {
    ++v8;
  }
  if (v8)
  {
    if (v6 || v8 != 1)
    {
      this = sub_1CC34A418((uint64_t *)a2 + 16, 0, 0, v4, v7, v6);
      uint64_t v9 = this | 3;
    }
    else
    {
      uint64_t v9 = v7 | 2;
      if (v4) {
        uint64_t v9 = v4 | 1;
      }
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  *(void *)(v3 + 48) = v9;
  return this;
}

uint64_t llvm::MachineInstr::setMemRefs(uint64_t this, uint64_t *a2, void *a3, uint64_t a4)
{
  uint64_t v4 = this;
  if (a4)
  {
    unint64_t v5 = *(void *)(this + 48);
    if (v5 >= 8)
    {
      uint64_t v11 = *(void *)(this + 48) & 7;
      unint64_t v12 = (unsigned __int8 *)(v5 & 0xFFFFFFFFFFFFFFF8);
      if (v11 == 1 && v12 != 0)
      {
        uint64_t v6 = 0;
        uint64_t v8 = 0;
        unint64_t v7 = v5 & 0xFFFFFFFFFFFFFFF8;
        goto LABEL_5;
      }
      if (v11 != 3 || v12 == 0)
      {
        unint64_t v7 = 0;
        uint64_t v8 = 0;
        if (v12) {
          BOOL v15 = v11 == 2;
        }
        else {
          BOOL v15 = 0;
        }
        if (v15) {
          uint64_t v6 = (uint64_t)v12;
        }
        else {
          uint64_t v6 = 0;
        }
        goto LABEL_5;
      }
      uint64_t v16 = v12[4];
      if (v12[4]) {
        unint64_t v7 = *(void *)&v12[8 * *(int *)v12 + 8];
      }
      else {
        unint64_t v7 = 0;
      }
      if (v12[5]) {
        uint64_t v6 = *(void *)&v12[8 * *(int *)v12 + 8 + 8 * v16];
      }
      else {
        uint64_t v6 = 0;
      }
      if (v12[6])
      {
        uint64_t v8 = *(void *)&v12[8 * *(int *)v12 + 8 + 8 * v12[5] + 8 * v16];
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v6 = 0;
      unint64_t v7 = 0;
    }
    uint64_t v8 = 0;
LABEL_5:
    if (v6) {
      int v9 = a4 + 1;
    }
    else {
      int v9 = a4;
    }
    if (v7) {
      ++v9;
    }
    if (v8) {
      ++v9;
    }
    if (v9 <= 0)
    {
      *(void *)(this + 48) = 0;
    }
    else
    {
      if (v8 || v9 != 1)
      {
        this = sub_1CC34A418(a2 + 16, a3, a4, v7, v6, v8);
        uint64_t v10 = this | 3;
      }
      else if (v7)
      {
        uint64_t v10 = v7 | 1;
      }
      else if (v6)
      {
        uint64_t v10 = v6 | 2;
      }
      else
      {
        uint64_t v10 = *a3;
      }
      *(void *)(v4 + 48) = v10;
    }
    return this;
  }

  return llvm::MachineInstr::dropMemRefs(this, (llvm::MachineFunction *)a2);
}

void llvm::MachineInstr::addMemOperand(llvm::MachineInstr *this, llvm::MachineFunction *a2, llvm::MachineMemOperand *a3)
{
  unint64_t v17[2] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (unint64_t *)((char *)this + 48);
  unint64_t v4 = *((void *)this + 6);
  if (v4 >= 8)
  {
    if ((v4 & 7) != 0)
    {
      BOOL v9 = (v4 & 0xFFFFFFFFFFFFFFF8) != 0 && (*((void *)this + 6) & 7) == 3;
      unint64_t v5 = (char *)((v4 & 0xFFFFFFFFFFFFFFF8) + 8);
      if (!v9) {
        unint64_t v5 = 0;
      }
    }
    else
    {
      unint64_t v5 = (char *)this + 48;
      v4 &= 0xFFFFFFFFFFFFFFF8;
      unint64_t *v3 = v4;
      if (!v4)
      {
        unint64_t v5 = (char *)this + 48;
        uint64_t v3 = 0;
        goto LABEL_4;
      }
    }
    if ((v4 & 7) == 0)
    {
      unint64_t *v3 = v4 & 0xFFFFFFFFFFFFFFF8;
      unint64_t v4 = 1;
      goto LABEL_4;
    }
    uint64_t v10 = (int *)(v4 & 0xFFFFFFFFFFFFFFF8);
    if ((v4 & 7) == 3 && v10 != 0)
    {
      unint64_t v12 = *v10;
      uint64_t v3 = (unint64_t *)(v10 + 2);
      unint64_t v4 = v12;
      goto LABEL_4;
    }
  }
  else
  {
    unint64_t v5 = 0;
  }
  uint64_t v3 = 0;
  unint64_t v4 = 0;
LABEL_4:
  uint64_t v6 = (char *)&v3[v4];
  unint64_t v7 = v6 - v5;
  if ((unint64_t)(v6 - v5) > 0x10 || v6 != v5)
  {
    uint64_t v16 = a3;
    uint64_t v13 = this;
    uint64_t v14 = a2;
    size_t v15 = v6 - v5;
    if (v7 >= 0x11) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    if (v6 == v5)
    {
      unint64_t v7 = v6 - v5;
    }
    else
    {
      memcpy(v17, v5, v15);
      unint64_t v7 = v15;
      a2 = v14;
      this = v13;
      a3 = v16;
    }
  }
  unsigned int v8 = v7 >> 3;
  if (v8 >= 2) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  v17[v8] = a3;
  llvm::MachineInstr::setMemRefs((uint64_t)this, (uint64_t *)a2, v17, v8 + 1);
}

uint64_t llvm::MachineInstr::mergeFlagsWith(llvm::MachineInstr *this, const llvm::MachineInstr *a2)
{
  return *((unsigned __int16 *)a2 + 22) | *((unsigned __int16 *)this + 22);
}

uint64_t llvm::MachineInstr::copyFlagsFromInstruction(uint64_t a1)
{
  unsigned int v2 = *(unsigned __int8 *)(a1 + 16);
  HIDWORD(v4) = v2 - 41;
  LODWORD(v4) = v2 - 41;
  unsigned int v3 = v4 >> 1;
  BOOL v5 = v3 > 6;
  int v6 = (1 << v3) & 0x47;
  if (v5 || v6 == 0) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = (*(unsigned char *)(a1 + 17) & 6) << 10;
  }
  if (v2 <= 0x37 && ((1 << v2) & 0xC1800000000000) != 0) {
    uint64_t v10 = v10 & 0xFFFFDFFF | ((((*(unsigned char *)(a1 + 17) & 2) >> 1) & 1u) << 13);
  }
  if (sub_1CB845E74(a1))
  {
    int v8 = *(unsigned __int8 *)(a1 + 17) >> 1;
    if (v8 == 127) {
      int v8 = -1;
    }
    return (8 * v8) & 0x3F0 | ((v8 & 1) << 10) | v10;
  }
  return v10;
}

BOOL llvm::MachineInstr::copyIRFlags(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(unsigned __int8 *)(a2 + 16);
  HIDWORD(v6) = v4 - 41;
  LODWORD(v6) = v4 - 41;
  unsigned int v5 = v6 >> 1;
  BOOL v7 = v5 > 6;
  int v8 = (1 << v5) & 0x47;
  if (v7 || v8 == 0) {
    unsigned int v12 = 0;
  }
  else {
    unsigned int v12 = (*(unsigned char *)(a2 + 17) & 6) << 10;
  }
  if (v4 <= 0x37 && ((1 << v4) & 0xC1800000000000) != 0) {
    unsigned int v12 = v12 & 0xFFFFDFFF | ((((*(unsigned char *)(a2 + 17) & 2) >> 1) & 1) << 13);
  }
  BOOL result = sub_1CB845E74(a2);
  if (result)
  {
    int v11 = *(unsigned __int8 *)(a2 + 17) >> 1;
    if (v11 == 127) {
      LOWORD(v11) = -1;
    }
    LOWORD(v12) = (8 * v11) & 0x3F0 | ((v11 & 1) << 10) | v12;
  }
  *(_WORD *)(a1 + 44) = v12;
  return result;
}

BOOL llvm::MachineInstr::hasPropertyInBundle(uint64_t a1, uint64_t a2, int a3)
{
  BOOL result = a3 == 2;
  while (1)
  {
    uint64_t v5 = *(void *)(a1 + 16);
    if ((*(void *)(v5 + 8) & a2) == 0) {
      break;
    }
    if (a3 == 1) {
      return 1;
    }
LABEL_4:
    if ((*(_WORD *)(a1 + 44) & 8) == 0) {
      return result;
    }
    a1 = *(void *)(a1 + 8);
  }
  if (a3 != 2 || *(_WORD *)v5 == 20) {
    goto LABEL_4;
  }
  return 0;
}

BOOL llvm::MachineInstr::isIdenticalTo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = **(unsigned __int16 **)(a2 + 16);
  if (v3 == **(unsigned __int16 **)(a1 + 16))
  {
    unsigned int v6 = *(_DWORD *)(a2 + 40);
    if (v6 == *(_DWORD *)(a1 + 40))
    {
      if (v3 == 20)
      {
        uint64_t v8 = a2;
        uint64_t v9 = a1;
        while (1)
        {
          __int16 v10 = *(_WORD *)(v8 + 44);
          if ((*(_WORD *)(v9 + 44) & 8) == 0) {
            break;
          }
          if ((v10 & 8) != 0)
          {
            uint64_t v9 = *(void *)(v9 + 8);
            uint64_t v8 = *(void *)(v8 + 8);
            if (llvm::MachineInstr::isIdenticalTo(v9, v8, a3)) {
              continue;
            }
          }
          return 0;
        }
        if ((v10 & 8) != 0) {
          return 0;
        }
        unsigned int v6 = *(_DWORD *)(a1 + 40);
      }
      if (v6)
      {
        uint64_t v11 = 0;
        uint64_t v12 = 32 * v6;
        while (1)
        {
          uint64_t v13 = *(void *)(a1 + 32);
          uint64_t v14 = (llvm::MachineOperand *)(v13 + v11);
          uint64_t v15 = *(void *)(a2 + 32);
          uint64_t v16 = (const llvm::MachineOperand *)(v15 + v11);
          if (*(_DWORD *)(v13 + v11))
          {
LABEL_14:
            if (!llvm::MachineOperand::isIdenticalTo(v14, v16)) {
              return 0;
            }
            goto LABEL_15;
          }
          if ((*(_DWORD *)(v13 + v11) & 0x1000000) == 0) {
            break;
          }
          if (a3 == 2) {
            goto LABEL_15;
          }
          if (a3 != 3)
          {
            BOOL result = llvm::MachineOperand::isIdenticalTo((llvm::MachineOperand *)(v13 + v11), (const llvm::MachineOperand *)(v15 + v11));
            if (!result) {
              return result;
            }
            if (a3 != 1) {
              goto LABEL_15;
            }
            int v18 = (~*(_DWORD *)v14 & 0x5000000) == 0;
            int v19 = (~*(_DWORD *)v16 & 0x5000000) == 0;
            goto LABEL_29;
          }
          if ((*(_DWORD *)(v13 + v11 + 4) & 0x80000000) == 0 || (*(_DWORD *)(v15 + v11 + 4) & 0x80000000) == 0) {
            goto LABEL_14;
          }
LABEL_15:
          v11 += 32;
          if (v12 == v11) {
            goto LABEL_31;
          }
        }
        BOOL result = llvm::MachineOperand::isIdenticalTo((llvm::MachineOperand *)(v13 + v11), (const llvm::MachineOperand *)(v15 + v11));
        if (!result) {
          return result;
        }
        if (a3 != 1) {
          goto LABEL_15;
        }
        int v18 = (*(_DWORD *)v14 >> 26) & ~HIBYTE(*(_DWORD *)v14);
        int v19 = (*(_DWORD *)v16 >> 26) & ~HIBYTE(*(_DWORD *)v16);
LABEL_29:
        if ((v18 ^ v19)) {
          return 0;
        }
        goto LABEL_15;
      }
LABEL_31:
      if (**(unsigned __int16 **)(a1 + 16) - 13 > 4) {
        return 1;
      }
      uint64_t v20 = *(void *)(a1 + 56);
      if (!v20) {
        return 1;
      }
      uint64_t v21 = *(void *)(a2 + 56);
      if (!v21 || v20 == v21) {
        return 1;
      }
    }
  }
  return 0;
}

uint64_t llvm::MachineInstr::getMF(llvm::MachineInstr *this)
{
  return *(void *)(*((void *)this + 3) + 32);
}

llvm::MachineInstr *llvm::MachineInstr::removeFromParent(llvm::MachineInstr *this)
{
  uint64_t v2 = *(void *)(*((void *)this + 3) + 32);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 728);
    if (v3) {
      (*(void (**)(uint64_t, llvm::MachineInstr *))(*(void *)v3 + 32))(v3, this);
    }
    uint64_t v4 = *((unsigned int *)this + 10);
    if (v4)
    {
      uint64_t v5 = *((void *)this + 4);
      uint64_t v6 = *(void *)(v2 + 40);
      uint64_t v7 = 32 * v4;
      do
      {
        if (!*(unsigned char *)v5)
        {
          uint64_t v8 = *(unsigned int *)(v5 + 4);
          if ((v8 & 0x80000000) != 0) {
            uint64_t v9 = (uint64_t *)(*(void *)(v6 + 24) + 16 * (v8 & 0x7FFFFFFF) + 8);
          }
          else {
            uint64_t v9 = (uint64_t *)(*(void *)(v6 + 272) + 8 * v8);
          }
          uint64_t v10 = *v9;
          uint64_t v12 = *(void *)(v5 + 16);
          uint64_t v11 = *(void *)(v5 + 24);
          if (v5 != *v9) {
            uint64_t v9 = (uint64_t *)(v12 + 24);
          }
          *uint64_t v9 = v11;
          if (v11) {
            uint64_t v13 = v11;
          }
          else {
            uint64_t v13 = v10;
          }
          *(void *)(v13 + 16) = v12;
          *(void *)(v5 + 16) = 0;
          *(void *)(v5 + 24) = 0;
        }
        v5 += 32;
        v7 -= 32;
      }
      while (v7);
    }
  }
  *((void *)this + 3) = 0;
  uint64_t v14 = (unint64_t *)*((void *)this + 1);
  unint64_t v15 = *(void *)this & 0xFFFFFFFFFFFFFFF8;
  *uint64_t v14 = v15 | *v14 & 7;
  *(void *)(v15 + 8) = v14;
  *(void *)this &= 7uLL;
  *((void *)this + 1) = 0;
  return this;
}

void llvm::MachineInstr::eraseFromParent(llvm::MachineInstr *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this;
  if ((*(unsigned char *)this & 4) == 0)
  {
    uint64_t v2 = this;
    if ((*((_WORD *)this + 22) & 8) != 0)
    {
      uint64_t v2 = this;
      do
        uint64_t v2 = (llvm::MachineInstr *)*((void *)v2 + 1);
      while ((*((_WORD *)v2 + 22) & 8) != 0);
    }
  }
  uint64_t v3 = (llvm::MachineInstr *)*((void *)v2 + 1);
  if (v3 != this)
  {
    uint64_t v4 = *((void *)this + 3);
    do
    {
      uint64_t v5 = (llvm::MachineInstr *)*((void *)v1 + 1);
      uint64_t v6 = *(void *)(*((void *)v1 + 3) + 32);
      if (v6)
      {
        uint64_t v7 = *(void *)(v6 + 728);
        if (v7) {
          (*(void (**)(uint64_t, llvm::MachineInstr *))(*(void *)v7 + 32))(v7, v1);
        }
        uint64_t v8 = *((unsigned int *)v1 + 10);
        if (v8)
        {
          uint64_t v9 = *((void *)v1 + 4);
          uint64_t v10 = *(void *)(v6 + 40);
          uint64_t v11 = 32 * v8;
          do
          {
            if (!*(unsigned char *)v9)
            {
              uint64_t v12 = *(unsigned int *)(v9 + 4);
              if ((v12 & 0x80000000) != 0) {
                uint64_t v13 = (uint64_t *)(*(void *)(v10 + 24) + 16 * (v12 & 0x7FFFFFFF) + 8);
              }
              else {
                uint64_t v13 = (uint64_t *)(*(void *)(v10 + 272) + 8 * v12);
              }
              uint64_t v14 = *v13;
              uint64_t v16 = *(void *)(v9 + 16);
              uint64_t v15 = *(void *)(v9 + 24);
              if (v9 != *v13) {
                uint64_t v13 = (uint64_t *)(v16 + 24);
              }
              *uint64_t v13 = v15;
              if (v15) {
                uint64_t v17 = v15;
              }
              else {
                uint64_t v17 = v14;
              }
              *(void *)(v17 + 16) = v16;
              *(void *)(v9 + 16) = 0;
              *(void *)(v9 + 24) = 0;
            }
            v9 += 32;
            v11 -= 32;
          }
          while (v11);
        }
      }
      *((void *)v1 + 3) = 0;
      int v18 = (unint64_t *)*((void *)v1 + 1);
      unint64_t v19 = *(void *)v1 & 0xFFFFFFFFFFFFFFF8;
      *int v18 = v19 | *v18 & 7;
      *(void *)(v19 + 8) = v18;
      *(void *)v1 &= 7uLL;
      *((void *)v1 + 1) = 0;
      uint64_t v20 = *(void *)(*(void *)(v4 + 40) + 32);
      uint64_t v21 = (void *)*((void *)v1 + 4);
      if (v21)
      {
        uint64_t v22 = *((unsigned __int8 *)v1 + 47);
        int v23 = (uint64_t *)(v20 + 232);
        if (*(_DWORD *)(v20 + 240) <= v22) {
          sub_1CC34BDE0(v20 + 232, v22 + 1);
        }
        uint64_t v24 = *v23;
        *uint64_t v21 = *(void *)(*v23 + 8 * v22);
        *(void *)(v24 + 8 * v22) = v21;
      }
      *(void *)uint64_t v1 = *(void *)(v20 + 224);
      *(void *)(v20 + 224) = v1;
      uint64_t v1 = v5;
    }
    while (v5 != v3);
  }
}

uint64_t llvm::MachineInstr::eraseFromBundle(llvm::MachineInstr *this)
{
  uint64_t v2 = *((void *)this + 3);
  sub_1CC319554((uint64_t)this);

  return sub_1CC3195AC(v2 + 40, (uint64_t)this);
}

uint64_t llvm::MachineInstr::isCandidateForCallSiteEntry(uint64_t a1, int a2)
{
  if (!a2 || ((*(_WORD *)(a1 + 44) & 0xC) != 0 ? (BOOL v2 = (*(_WORD *)(a1 + 44) & 4) == 0) : (BOOL v2 = 0), !v2))
  {
    if ((*(unsigned char *)(*(void *)(a1 + 16) + 8) & 0x80) == 0) {
      return 0;
    }
LABEL_20:
    unsigned int v6 = **(unsigned __int16 **)(a1 + 16);
    if (v6 > 0x1F) {
      return 1;
    }
    else {
      return (0x71FFFFFFu >> v6) & 1;
    }
  }
  for (uint64_t i = a1; ; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v5 = *(void *)(i + 16);
    if ((*(unsigned char *)(v5 + 8) & 0x80) != 0) {
      break;
    }
    if (a2 == 2)
    {
      if (*(_WORD *)v5 != 20) {
        return 0;
      }
      if ((*(_WORD *)(i + 44) & 8) == 0) {
        goto LABEL_20;
      }
    }
    else if ((*(_WORD *)(i + 44) & 8) == 0)
    {
      return 0;
    }
LABEL_16:
    ;
  }
  if (a2 == 1) {
    goto LABEL_20;
  }
  if ((*(_WORD *)(i + 44) & 8) != 0) {
    goto LABEL_16;
  }
  if (a2 == 2) {
    goto LABEL_20;
  }
  return 0;
}

uint64_t llvm::MachineInstr::shouldUpdateCallSiteInfo(llvm::MachineInstr *this)
{
  uint64_t v1 = (unsigned __int16 *)*((void *)this + 2);
  unsigned int v2 = *v1;
  if (v2 == 20)
  {
    uint64_t v4 = *((void *)v1 + 1);
    if ((*((_WORD *)this + 22) & 0xC) != 0 && (*((_WORD *)this + 22) & 4) == 0)
    {
      if ((v4 & 0x80) == 0)
      {
        while ((*((_WORD *)this + 22) & 8) != 0)
        {
          this = (llvm::MachineInstr *)*((void *)this + 1);
          if ((*(unsigned char *)(*((void *)this + 2) + 8) & 0x80) != 0) {
            return 1;
          }
        }
        return 0;
      }
    }
    else if ((v4 & 0x80) == 0)
    {
      return 0;
    }
  }
  else
  {
    if ((v1[4] & 0x80) == 0) {
      return 0;
    }
    if (v2 <= 0x1F) {
      return (0x71FFFFFFu >> v2) & 1;
    }
  }
  return 1;
}

uint64_t llvm::MachineInstr::getNumExplicitOperands(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 16);
  unsigned int v2 = *(unsigned __int16 *)(v1 + 2);
  if ((*(unsigned char *)(v1 + 8) & 2) == 0) {
    return *(unsigned __int16 *)(v1 + 2);
  }
  int v3 = *(_DWORD *)(this + 40);
  if (v3 == v2) {
    return *(unsigned __int16 *)(v1 + 2);
  }
  uint64_t v4 = *(void *)(this + 32);
  int v5 = v3 - 1;
  LODWORD(this) = v2;
  do
  {
    int v6 = *(_DWORD *)(v4 + 32 * v2) & 0x20000FF;
    if (v6 == 0x2000000) {
      this = this;
    }
    else {
      this = (this + 1);
    }
    if (v5 == v2) {
      break;
    }
    ++v2;
  }
  while (v6 != 0x2000000);
  return this;
}

uint64_t llvm::MachineInstr::getNumExplicitDefs(llvm::MachineInstr *this)
{
  uint64_t v1 = *((void *)this + 2);
  uint64_t v2 = *(unsigned __int8 *)(v1 + 4);
  if ((*(unsigned char *)(v1 + 8) & 2) == 0) {
    return *(unsigned __int8 *)(v1 + 4);
  }
  int v4 = *((_DWORD *)this + 10);
  if (v4 == v2) {
    return *(unsigned __int8 *)(v1 + 4);
  }
  uint64_t v5 = *((void *)this + 4);
  int v6 = v4 - 1;
  uint64_t result = v2;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32 * v2);
    if ((v7 & 0x10000FF) != 0x1000000) {
      break;
    }
    uint64_t result = ((v7 & 0x2000000) == 0) + result;
    if (v6 == v2) {
      break;
    }
    LODWORD(v2) = v2 + 1;
  }
  while ((v7 & 0x2000000) == 0);
  return result;
}

uint64_t llvm::MachineInstr::bundleWithPred(uint64_t this)
{
  *(_WORD *)(this + 44) |= 4u;
  *(_WORD *)((*(void *)this & 0xFFFFFFFFFFFFFFF8) + 44) |= 8u;
  return this;
}

uint64_t llvm::MachineInstr::unbundleFromSucc(uint64_t this)
{
  *(_WORD *)(this + 44) &= ~8u;
  *(_WORD *)(*(void *)(this + 8) + 44) &= ~4u;
  return this;
}

BOOL llvm::MachineInstr::isStackAligningInlineAsm(llvm::MachineInstr *this)
{
  return **((unsigned __int16 **)this + 2) - 1 <= 1 && (*(unsigned char *)(*((void *)this + 4) + 48) & 2) != 0;
}

unint64_t llvm::MachineInstr::getDebugVariableOp(llvm::MachineInstr *this)
{
  return *((void *)this + 4) + ((unint64_t)(**((_WORD **)this + 2) != 14) << 6);
}

{
  return *((void *)this + 4) + ((unint64_t)(**((_WORD **)this + 2) != 14) << 6);
}

uint64_t llvm::MachineInstr::getDebugVariable(llvm::MachineInstr *this)
{
  return *(void *)(*((void *)this + 4) + ((unint64_t)(**((_WORD **)this + 2) != 14) << 6) + 16);
}

uint64_t llvm::MachineInstr::getDebugExpressionOp(llvm::MachineInstr *this)
{
  uint64_t v1 = 96;
  if (**((_WORD **)this + 2) == 14) {
    uint64_t v1 = 32;
  }
  return *((void *)this + 4) + v1;
}

{
  uint64_t v1;

  uint64_t v1 = 96;
  if (**((_WORD **)this + 2) == 14) {
    uint64_t v1 = 32;
  }
  return *((void *)this + 4) + v1;
}

uint64_t llvm::MachineInstr::getDebugExpression(llvm::MachineInstr *this)
{
  uint64_t v1 = 96;
  if (**((_WORD **)this + 2) == 14) {
    uint64_t v1 = 32;
  }
  return *(void *)(*((void *)this + 4) + v1 + 16);
}

BOOL llvm::MachineInstr::isDebugEntryValue(llvm::MachineInstr *this)
{
  int v1 = **((unsigned __int16 **)this + 2);
  if ((v1 - 13) > 1) {
    return 0;
  }
  BOOL v2 = v1 == 14;
  uint64_t v3 = 96;
  if (v2) {
    uint64_t v3 = 32;
  }
  uint64_t v5 = *(void *)(*((void *)this + 4) + v3 + 16) + 24;
  int v4 = *(void **)v5;
  return ((*(void *)(v5 + 8) - *(void *)v5) & 0x7FFFFFFF8) != 0 && *v4 == 4099;
}

uint64_t llvm::MachineInstr::getRegClassConstraint(llvm::MachineInstr *this, uint64_t a2, const llvm::TargetInstrInfo *a3, const llvm::TargetRegisterInfo *a4)
{
  unsigned int TiedOperandIdx = a2;
  uint64_t v6 = *(void *)(*((void *)this + 3) + 32);
  if (**((unsigned __int16 **)this + 2) - 1 >= 2)
  {
    uint64_t v17 = *(uint64_t (**)(const llvm::TargetInstrInfo *))(*(void *)a3 + 16);
    return v17(a3);
  }
  else
  {
    int v8 = *(_DWORD *)(*((void *)this + 4) + 32 * a2);
    if (!(_BYTE)v8)
    {
      if ((v8 & 0x1000000) == 0)
      {
        int v9 = v8 & 0x10000FF;
        int v10 = v8 & 0xF00000;
        if (!v9 && v10 != 0) {
          unsigned int TiedOperandIdx = llvm::MachineInstr::findTiedOperandIdx(this, a2);
        }
      }
      if (TiedOperandIdx >= 2)
      {
        unsigned int v12 = *((_DWORD *)this + 10);
        if (v12 >= 3)
        {
          uint64_t v13 = *((void *)this + 4);
          unsigned int v14 = 2;
          while (*(unsigned char *)(v13 + 32 * v14) == 1)
          {
            unsigned int v15 = v14;
            int v16 = *(_DWORD *)(v13 + 32 * v14 + 16);
            v14 += ((unsigned __int16)v16 >> 3) + 1;
            if (v14 > TiedOperandIdx)
            {
              if ((v15 & 0x80000000) != 0) {
                return 0;
              }
              if ((v16 & 7u) - 1 >= 3)
              {
                if ((v16 & 7) != 6) {
                  return 0;
                }
                unint64_t v19 = *(uint64_t (**)(const llvm::TargetRegisterInfo *, uint64_t, void))(*(void *)a4 + 240);
                return v19(a4, v6, 0);
              }
              else
              {
                if (v16 < 0x10000) {
                  return 0;
                }
                return *(void *)(*((void *)a4 + 30) + 8 * (HIWORD(v16) - 1));
              }
            }
            if (v14 >= v12) {
              return 0;
            }
          }
        }
      }
    }
    return 0;
  }
}

uint64_t llvm::MachineInstr::getRegClassConstraintEffectForVRegImpl(llvm::MachineInstr *a1, uint64_t a2, int a3, uint64_t a4, llvm::TargetInstrInfo *a5, llvm::TargetRegisterInfo *a6)
{
  uint64_t v6 = *((void *)a1 + 4);
  if (!*(unsigned char *)(v6 + 32 * a2) && *(_DWORD *)(v6 + 32 * a2 + 4) == a3) {
    return llvm::MachineInstr::getRegClassConstraintEffect(a1, a2, a4, a5, a6);
  }
  else {
    return a4;
  }
}

uint64_t llvm::MachineInstr::hasRegisterImplicitUseOperand(uint64_t a1, int a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 40);
  if (!v2) {
    return 0;
  }
  for (uint64_t i = (_DWORD *)(*(void *)(a1 + 32) + 4); (*(i - 1) & 0x30000FF) != 0x2000000 || *i != a2; i += 8)
  {
    if (!--v2) {
      return 0;
    }
  }
  return 1;
}

uint64_t llvm::MachineInstr::findRegisterUseOperandIdx(uint64_t a1, unsigned int a2, int a3, uint64_t a4)
{
  uint64_t v4 = *(unsigned int *)(a1 + 40);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = 0;
  unsigned int v8 = a2 - 1;
  if (a2) {
    BOOL v9 = a4 != 0;
  }
  else {
    BOOL v9 = 0;
  }
  int v10 = (void *)(a4 + 8);
  for (uint64_t i = (unsigned int *)(*(void *)(a1 + 32) + 4); ; i += 8)
  {
    unsigned int v12 = *(i - 1);
    if ((v12 & 0x10000FF) == 0)
    {
      unsigned int v13 = *i;
      if (*i)
      {
        if (v13 == a2
          || (v8 < 0x3FFFFFFF ? (BOOL v14 = v13 >> 30 == 0) : (BOOL v14 = 0),
              v14 ? (BOOL v15 = v9) : (BOOL v15 = 0),
              v15 && llvm::MCRegisterInfo::regsOverlap(v10, v13, a2)))
        {
          if (!a3 || ((v12 >> 26) & ~HIBYTE(v12) & 1) != 0) {
            break;
          }
        }
      }
    }
    if (v4 == ++v7) {
      return 0xFFFFFFFFLL;
    }
  }
  return v7;
}

uint64_t llvm::MachineInstr::readsWritesVirtualRegister(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (!v3)
  {
    unsigned __int8 v6 = 0;
    unsigned __int8 v8 = 0;
    goto LABEL_22;
  }
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  unsigned __int8 v6 = 0;
  char v7 = 0;
  unsigned __int8 v8 = 0;
  do
  {
    uint64_t v9 = *(void *)(a1 + 32);
    unsigned int v10 = *(_DWORD *)(v9 + v4);
    if (!(_BYTE)v10 && *(_DWORD *)(v9 + v4 + 4) == a2)
    {
      if (a3)
      {
        unint64_t v11 = *(unsigned int *)(a3 + 8);
        if (v11 >= *(unsigned int *)(a3 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(_DWORD *)(*(void *)a3 + 4 * v11) = v5;
        ++*(_DWORD *)(a3 + 8);
        unsigned int v10 = *(_DWORD *)(v9 + v4);
        if ((v10 & 0x1000000) == 0)
        {
LABEL_9:
          v7 |= (v10 & 0x10000000) == 0;
          goto LABEL_4;
        }
      }
      else if ((v10 & 0x1000000) == 0)
      {
        goto LABEL_9;
      }
      int v12 = (v10 >> 28) & 1;
      if ((v10 & 0xFFF00) == 0) {
        LOBYTE(v12) = 1;
      }
      v8 |= v12;
      v6 |= v12 ^ 1;
    }
LABEL_4:
    ++v5;
    v4 += 32;
  }
  while (v3 != v5);
  if (v7)
  {
    char v13 = 1;
    goto LABEL_17;
  }
LABEL_22:
  char v13 = v6 & (v8 ^ 1);
LABEL_17:
  if ((v6 | v8)) {
    int v14 = 256;
  }
  else {
    int v14 = 0;
  }
  return v14 & 0xFFFFFFFE | v13 & 1;
}

uint64_t llvm::MachineInstr::findRegisterDefOperandIdx(uint64_t a1, unsigned int a2, int a3, int a4, uint64_t a5)
{
  uint64_t v5 = *(unsigned int *)(a1 + 40);
  if (v5)
  {
    uint64_t v8 = 0;
    unsigned int v9 = a2 - 0x40000000;
    uint64_t v10 = a2 >> 5;
    int v11 = 1 << a2;
    uint64_t v30 = a5;
    int v31 = (void *)(a5 + 8);
    uint64_t v13 = *(void *)(a1 + 32);
    if (a2 - 0x40000000 > 0xC0000000) {
      int v14 = a4;
    }
    else {
      int v14 = 0;
    }
    int v32 = 1 << a2;
    int v33 = a3;
    while (1)
    {
      int v15 = *(_DWORD *)(v13 + 32 * v8);
      if (v15 == 12) {
        int v16 = v14;
      }
      else {
        int v16 = 0;
      }
      if (v16 == 1 && (*(_DWORD *)(*(void *)(v13 + 32 * v8 + 16) + 4 * v10) & v11) == 0) {
        return v8;
      }
      if ((v15 & 0x10000FF) == 0x1000000) {
        break;
      }
LABEL_34:
      if (++v8 == v5) {
        return 0xFFFFFFFFLL;
      }
    }
    unsigned int v17 = *(_DWORD *)(v13 + 32 * v8 + 4);
    BOOL v18 = v17 == a2;
    if (v9 >= 0xC0000001 && a5 && v17 != a2)
    {
      if (v17 - 1 > 0x3FFFFFFE) {
        goto LABEL_34;
      }
      if (a4)
      {
        uint64_t v19 = v10;
        BOOL v20 = llvm::MCRegisterInfo::regsOverlap(v31, v17, a2);
        int v11 = v32;
        a3 = v33;
        a5 = v30;
        uint64_t v10 = v19;
        if (!v20) {
          goto LABEL_34;
        }
LABEL_32:
        if (!a3 || (~v15 & 0x5000000) == 0) {
          return v8;
        }
        goto LABEL_34;
      }
      uint64_t v21 = (_WORD *)(*(void *)(a5 + 56) + 2 * *(unsigned int *)(*(void *)(a5 + 8) + 24 * a2 + 8));
      int v22 = (unsigned __int16)*v21;
      unsigned __int16 v23 = v22 + a2;
      BOOL v24 = v22 == 0;
      BOOL v18 = *v21 != 0;
      BOOL v24 = v24 || v17 == v23;
      if (!v24)
      {
        uint64_t v25 = v21 + 1;
        do
        {
          int v27 = *v25++;
          int v26 = v27;
          v23 += v27;
          BOOL v18 = v27 != 0;
          if (!v27) {
            uint64_t v25 = 0;
          }
          if (v26) {
            BOOL v28 = v17 == v23;
          }
          else {
            BOOL v28 = 1;
          }
        }
        while (!v28);
      }
    }
    if (!v18) {
      goto LABEL_34;
    }
    goto LABEL_32;
  }
  return 0xFFFFFFFFLL;
}

uint64_t llvm::MachineInstr::findTiedOperandIdx(llvm::MachineInstr *this, uint64_t a2)
{
  uint64_t v2 = a2;
  v48[4] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *((void *)this + 4);
  unsigned int v4 = *(_DWORD *)(v3 + 32 * a2);
  int v5 = (v4 >> 20) & 0xF;
  if (v5 != 15) {
    return (v5 - 1);
  }
  char v7 = (unsigned __int16 *)*((void *)this + 2);
  int v8 = *v7;
  if ((v8 - 1) >= 2)
  {
    if (v8 == 31)
    {
      long long v46 = this;
      unsigned int v27 = *((unsigned __int8 *)v7 + 4);
      uint64_t v28 = *((void *)v7 + 1);
      unsigned int v29 = v27;
      if ((v28 & 2) != 0)
      {
        int v39 = *((_DWORD *)this + 10);
        unsigned int v29 = *((unsigned __int8 *)v7 + 4);
        if (v39 != v27)
        {
          int v40 = v39 - 1;
          unsigned int v41 = *((unsigned __int8 *)v7 + 4);
          unsigned int v29 = v41;
          do
          {
            int v42 = *(_DWORD *)(v3 + 32 * v41);
            if ((v42 & 0x10000FF) != 0x1000000) {
              break;
            }
            v29 += (v42 & 0x2000000) == 0;
            if (v40 == v41) {
              break;
            }
            ++v41;
          }
          while ((v42 & 0x2000000) == 0);
        }
      }
      uint64_t v30 = *((void *)v7 + 4);
      if (v30)
      {
        unsigned int v31 = -1;
        do
          ++v31;
        while (*(_WORD *)(v30 + 2 * v31));
      }
      else
      {
        unsigned int v31 = 0;
      }
      LODWORD(v47) = v31 + v29;
      unsigned int NumGCPtrIdx = llvm::StatepointOpers::getNumGCPtrIdx((llvm::StatepointOpers *)&v46);
      if (*(_DWORD *)(v3 + 32 * NumGCPtrIdx + 16)) {
        uint64_t NextMetaArgIdx = NumGCPtrIdx + 1;
      }
      else {
        uint64_t NextMetaArgIdx = 0xFFFFFFFFLL;
      }
      if ((v28 & 2) == 0 || (int v43 = *((_DWORD *)this + 10), v43 == v27))
      {
        unsigned int v34 = v27;
      }
      else
      {
        int v44 = v43 - 1;
        unsigned int v34 = v27;
        do
        {
          int v45 = *(_DWORD *)(v3 + 32 * v27);
          if ((v45 & 0x10000FF) != 0x1000000) {
            break;
          }
          v34 += (v45 & 0x2000000) == 0;
          if (v44 == v27) {
            break;
          }
          ++v27;
        }
        while ((v45 & 0x2000000) == 0);
      }
      if (v30)
      {
        unsigned int v35 = -1;
        do
          ++v35;
        while (*(_WORD *)(v30 + 2 * v35));
      }
      else
      {
        unsigned int v35 = 0;
      }
      unsigned int v36 = v35 + v34;
      if (v35 + v34)
      {
        uint64_t v37 = 0;
        do
        {
          for (uint64_t i = 32 * NextMetaArgIdx; *(unsigned char *)(v3 + i); uint64_t i = 32 * NextMetaArgIdx)
            uint64_t NextMetaArgIdx = llvm::StackMaps::getNextMetaArgIdx(this, (const llvm::MachineInstr *)NextMetaArgIdx);
          if (v37 == v2) {
            break;
          }
          if (NextMetaArgIdx == v2) {
            return v37;
          }
          uint64_t NextMetaArgIdx = llvm::StackMaps::getNextMetaArgIdx(this, (const llvm::MachineInstr *)NextMetaArgIdx);
          uint64_t v37 = (v37 + 1);
        }
        while (v37 != v36);
      }
      return NextMetaArgIdx;
    }
    else if ((v4 & 0x1000000) != 0 && (int v21 = *((_DWORD *)this + 10), v21 != 14))
    {
      uint64_t v2 = 14;
      while (1)
      {
        unsigned int v23 = *(_DWORD *)(v3 + 32 * v2);
        int v24 = v23 & 0x10000FF;
        int v25 = (v23 >> 20) & 0xF;
        if (!v24 && v25 == a2 + 1) {
          break;
        }
        uint64_t v2 = (v2 + 1);
        if (v21 == v2) {
          return *((unsigned int *)this + 10);
        }
      }
    }
    else
    {
      return 14;
    }
  }
  else
  {
    unsigned int v9 = 0;
    long long v46 = v48;
    uint64_t v47 = 0x800000000;
    unsigned int v10 = *((_DWORD *)this + 10);
    int v11 = -1;
    unsigned int v12 = 2;
    while (1)
    {
      uint64_t v13 = *((void *)this + 4);
      if (v9 >= HIDWORD(v47)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v46 + v9) = v12;
      unsigned int v14 = v47 + 1;
      LODWORD(v47) = v47 + 1;
      unsigned int v15 = *(_DWORD *)(v13 + 32 * v12 + 16);
      unsigned int v16 = v12 + ((unsigned __int16)v15 >> 3) + 1;
      if (v16 > a2 && a2 > v12) {
        int v11 = v9;
      }
      if ((v15 & 0x80000000) != 0)
      {
        unsigned int v18 = HIWORD(v15) & 0x7FFF;
        uint64_t v19 = v46;
        int v20 = *((_DWORD *)v46 + v18);
        if (v11 == v9)
        {
          uint64_t v2 = a2 - v12 + v20;
          goto LABEL_23;
        }
        if (v11 == v18) {
          break;
        }
      }
      unsigned int v9 = v14;
      unsigned int v12 = v16;
      if (v16 >= v10)
      {
        uint64_t v19 = v46;
        goto LABEL_23;
      }
    }
    uint64_t v2 = v12 + a2 - v20;
LABEL_23:
    if (v19 != v48) {
      free(v19);
    }
  }
  return v2;
}

uint64_t llvm::MachineInstr::clearKillInfo(uint64_t this)
{
  uint64_t v1 = *(unsigned int *)(this + 40);
  if (v1)
  {
    uint64_t v2 = *(_DWORD **)(this + 32);
    uint64_t v3 = 32 * v1;
    do
    {
      if ((*v2 & 0x10000FF) == 0) {
        *v2 &= ~0x4000000u;
      }
      v2 += 8;
      v3 -= 32;
    }
    while (v3);
  }
  return this;
}

uint64_t llvm::MachineInstr::substituteRegister(uint64_t result, int a2, unsigned int a3, uint64_t a4, void *a5)
{
  uint64_t v8 = result;
  if (a3 - 1 <= 0x3FFFFFFE)
  {
    if (a4)
    {
      uint64_t result = llvm::MCRegisterInfo::getSubReg(a5 + 1, a3, a4);
      a3 = result;
    }
    uint64_t v14 = *(unsigned int *)(v8 + 40);
    if (v14)
    {
      unsigned int v15 = *(unsigned int **)(v8 + 32);
      uint64_t v16 = 32 * v14;
      unsigned int v17 = a3;
      do
      {
        if (!*(unsigned char *)v15 && v15[1] == a2) {
          uint64_t result = llvm::MachineOperand::substPhysReg(v15, v17, (uint64_t)a5);
        }
        v15 += 8;
        v16 -= 32;
      }
      while (v16);
    }
  }
  else
  {
    uint64_t v9 = *(unsigned int *)(result + 40);
    if (v9)
    {
      unsigned int v10 = *(unsigned int **)(result + 32);
      unsigned int v11 = a3;
      for (uint64_t i = 32 * v9; i; i -= 32)
      {
        if (*v10 || v10[1] != a2) {
          goto LABEL_5;
        }
        if (a4)
        {
          if (((*v10 >> 8) & 0xFFF) != 0)
          {
            int v13 = (*(uint64_t (**)(void *, uint64_t))(*a5 + 208))(a5, a4);
            uint64_t result = llvm::MachineOperand::setReg((uint64_t)v10, v11);
            if (!v13) {
              goto LABEL_5;
            }
          }
          else
          {
            uint64_t result = llvm::MachineOperand::setReg((uint64_t)v10, v11);
            LOWORD(v13) = a4;
          }
          *unsigned int v10 = *v10 & 0xFFF000FF | ((v13 & 0xFFF) << 8);
        }
        else
        {
          uint64_t result = llvm::MachineOperand::setReg((uint64_t)v10, v11);
        }
LABEL_5:
        v10 += 8;
      }
    }
  }
  return result;
}

BOOL llvm::MachineInstr::isSafeToMove(llvm::MachineInstr *this, llvm::AAResults *a2, BOOL *a3)
{
  unsigned __int8 v6 = (unsigned __int16 *)*((void *)this + 2);
  int v7 = *v6;
  if ((unsigned __int16)(v7 - 1) <= 1u && (*(unsigned char *)(*((void *)this + 4) + 48) & 0x10) != 0) {
    goto LABEL_68;
  }
  unsigned int v8 = *((unsigned __int16 *)this + 22);
  BOOL v14 = (v8 & 0xC) == 0;
  int v9 = (v8 >> 2) & 1;
  if (v14) {
    char v10 = 1;
  }
  else {
    char v10 = v9;
  }
  uint64_t v11 = *((void *)v6 + 1);
  if (v10)
  {
    if ((v11 & 0x100080) != 0) {
      goto LABEL_68;
    }
  }
  else
  {
    if ((v11 & 0x100000) != 0) {
      goto LABEL_68;
    }
    int v21 = this;
    while ((*((_WORD *)v21 + 22) & 8) != 0)
    {
      int v21 = (llvm::MachineInstr *)*((void *)v21 + 1);
      if ((*(unsigned char *)(*((void *)v21 + 2) + 10) & 0x10) != 0) {
        goto LABEL_68;
      }
    }
    if ((v11 & 0x80) != 0) {
      goto LABEL_68;
    }
    unsigned int v27 = this;
    while ((*((_WORD *)v27 + 22) & 8) != 0)
    {
      unsigned int v27 = (llvm::MachineInstr *)*((void *)v27 + 1);
      if ((*(unsigned char *)(*((void *)v27 + 2) + 8) & 0x80) != 0) {
        goto LABEL_68;
      }
    }
  }
  if (v7 == 69 || !*v6) {
    goto LABEL_68;
  }
  if ((unsigned __int16)(v7 - 1) > 1u || (*(unsigned char *)(*((void *)this + 4) + 48) & 8) == 0)
  {
    if (v10)
    {
      if ((v11 & 0x80000) != 0) {
        goto LABEL_42;
      }
    }
    else
    {
      if ((v11 & 0x80000) != 0) {
        goto LABEL_42;
      }
      int v22 = this;
      while ((*((_WORD *)v22 + 22) & 8) != 0)
      {
        int v22 = (llvm::MachineInstr *)*((void *)v22 + 1);
        if ((*(unsigned char *)(*((void *)v22 + 2) + 10) & 8) != 0) {
          goto LABEL_42;
        }
      }
    }
LABEL_12:
    unsigned int v12 = v7 - 3;
    if (v12 < 0xF && ((0x7C0Fu >> v12) & 1) != 0) {
      return 0;
    }
    uint64_t v13 = *((void *)v6 + 1);
    BOOL v14 = (*((_WORD *)this + 22) & 0xC) != 0 && (*((_WORD *)this + 22) & 4) == 0;
    if (v14)
    {
      if ((v13 & 0x200) != 0) {
        return 0;
      }
      unsigned int v23 = this;
      BOOL result = 0;
      while ((*((_WORD *)v23 + 22) & 8) != 0)
      {
        unsigned int v23 = (llvm::MachineInstr *)*((void *)v23 + 1);
        if ((*(unsigned char *)(*((void *)v23 + 2) + 9) & 2) != 0) {
          return result;
        }
      }
    }
    else if ((v13 & 0x200) != 0)
    {
      return 0;
    }
    if (!sub_1CC3526CC((uint64_t)this))
    {
      unsigned int v15 = *((unsigned __int16 *)this + 22);
      BOOL v14 = (v15 & 0xC) == 0;
      int v16 = (v15 >> 2) & 1;
      if (v14) {
        char v17 = 1;
      }
      else {
        char v17 = v16;
      }
      unsigned int v18 = (unsigned __int16 *)*((void *)this + 2);
      uint64_t v19 = *((void *)v18 + 1);
      if (v17)
      {
        if ((v19 & 0x1000000) != 0) {
          return 0;
        }
      }
      else
      {
        if ((v19 & 0x1000000) != 0) {
          return 0;
        }
        int v24 = this;
        BOOL result = 0;
        while ((*((_WORD *)v24 + 22) & 8) != 0)
        {
          int v24 = (llvm::MachineInstr *)*((void *)v24 + 1);
          if (*(unsigned char *)(*((void *)v24 + 2) + 11)) {
            return result;
          }
        }
      }
      if (*v18 - 1 > 1)
      {
LABEL_26:
        if (v17)
        {
          if ((v19 & 0x80000) == 0) {
            return 1;
          }
        }
        else if ((v19 & 0x80000) == 0)
        {
          int v26 = this;
          while ((*((_WORD *)v26 + 22) & 8) != 0)
          {
            int v26 = (llvm::MachineInstr *)*((void *)v26 + 1);
            if ((*(unsigned char *)(*((void *)v26 + 2) + 10) & 8) != 0) {
              goto LABEL_62;
            }
          }
          return 1;
        }
LABEL_62:
        if ((llvm::MachineInstr::isDereferenceableInvariantLoad(this, a2) & 1) == 0) {
          return !*a3;
        }
        return 1;
      }
      uint64_t v25 = *(void *)(*((void *)this + 4) + 48);
      if ((v25 & 1) == 0)
      {
        if ((v25 & 8) != 0) {
          goto LABEL_62;
        }
        goto LABEL_26;
      }
    }
    return 0;
  }
LABEL_42:
  if ((llvm::MachineInstr::hasOrderedMemoryRef(this) & 1) == 0)
  {
    unsigned __int8 v6 = (unsigned __int16 *)*((void *)this + 2);
    int v7 = *v6;
    goto LABEL_12;
  }
LABEL_68:
  BOOL result = 0;
  *a3 = 1;
  return result;
}

uint64_t llvm::MachineInstr::hasOrderedMemoryRef(llvm::MachineInstr *this)
{
  uint64_t v1 = (unsigned __int16 *)*((void *)this + 2);
  unsigned int v2 = *v1 - 1;
  if (v2 > 1 || (*(unsigned char *)(*((void *)this + 4) + 48) & 0x10) == 0)
  {
    unsigned int v3 = *((unsigned __int16 *)this + 22);
    BOOL v13 = (v3 & 0xC) == 0;
    int v4 = (v3 >> 2) & 1;
    if (v13) {
      LOBYTE(v4) = 1;
    }
    uint64_t v5 = *((void *)v1 + 1);
    if (v4)
    {
      if ((v5 & 0x100000) != 0) {
        goto LABEL_34;
      }
    }
    else
    {
      if ((v5 & 0x100000) != 0) {
        goto LABEL_34;
      }
      unsigned __int8 v6 = this;
      while ((*((_WORD *)v6 + 22) & 8) != 0)
      {
        unsigned __int8 v6 = (llvm::MachineInstr *)*((void *)v6 + 1);
        if ((*(unsigned char *)(*((void *)v6 + 2) + 10) & 0x10) != 0) {
          goto LABEL_34;
        }
      }
    }
    if (v2 > 1 || (*(unsigned char *)(*((void *)this + 4) + 48) & 8) == 0)
    {
      if (v4)
      {
        if ((v5 & 0x1080080) != 0) {
          goto LABEL_34;
        }
      }
      else
      {
        if ((v5 & 0x80000) != 0) {
          goto LABEL_34;
        }
        int v7 = this;
        while ((*((_WORD *)v7 + 22) & 8) != 0)
        {
          int v7 = (llvm::MachineInstr *)*((void *)v7 + 1);
          if ((*(unsigned char *)(*((void *)v7 + 2) + 10) & 8) != 0) {
            goto LABEL_34;
          }
        }
        if ((v5 & 0x80) != 0) {
          goto LABEL_34;
        }
        unsigned int v8 = this;
        while ((*((_WORD *)v8 + 22) & 8) != 0)
        {
          unsigned int v8 = (llvm::MachineInstr *)*((void *)v8 + 1);
          if ((*(unsigned char *)(*((void *)v8 + 2) + 8) & 0x80) != 0) {
            goto LABEL_34;
          }
        }
        if ((v5 & 0x1000000) != 0) {
          goto LABEL_34;
        }
        int v9 = this;
        while ((*((_WORD *)v9 + 22) & 8) != 0)
        {
          int v9 = (llvm::MachineInstr *)*((void *)v9 + 1);
          if (*(unsigned char *)(*((void *)v9 + 2) + 11)) {
            goto LABEL_34;
          }
        }
      }
      if (v2 > 1 || (*(unsigned char *)(*((void *)this + 4) + 48) & 1) == 0) {
        return 0;
      }
    }
  }
LABEL_34:
  char v10 = (char *)this + 48;
  unint64_t v11 = *((void *)this + 6);
  if (v11 < 8) {
    return 1;
  }
  if ((v11 & 7) != 0)
  {
    unsigned int v12 = (_DWORD *)(v11 & 0xFFFFFFFFFFFFFFF8);
    BOOL v13 = (*((void *)this + 6) & 7) != 3 || v12 == 0;
    if (v13 || !*v12) {
      return 1;
    }
  }
  else
  {
    v11 &= 0xFFFFFFFFFFFFFFF8;
    *(void *)char v10 = v11;
    if (!v11) {
      return 0;
    }
  }
  if ((v11 & 7) == 0)
  {
    *((void *)this + 6) = v11 & 0xFFFFFFFFFFFFFFF8;
    unsigned int v18 = (char *)this + 56;
    goto LABEL_50;
  }
  uint64_t result = 0;
  if ((v11 & 7) == 3)
  {
    unsigned int v15 = (int *)(v11 & 0xFFFFFFFFFFFFFFF8);
    if ((v11 & 0xFFFFFFFFFFFFFFF8) != 0)
    {
      uint64_t v17 = *v15;
      char v10 = (char *)(v15 + 2);
      uint64_t v16 = v17;
      if (v17)
      {
        unsigned int v18 = &v10[8 * v16];
LABEL_50:
        while ((*(_WORD *)(*(void *)v10 + 36) & 0xE00) == 0 && (*(_WORD *)(*(void *)v10 + 32) & 4) == 0)
        {
          v10 += 8;
          if (v10 == v18) {
            return 0;
          }
        }
        return 1;
      }
      return 0;
    }
  }
  return result;
}

BOOL sub_1CC3526CC(uint64_t a1)
{
  __int16 v1 = *(_WORD *)(a1 + 44);
  uint64_t v2 = *(void *)(*(void *)(a1 + 16) + 8);
  if ((v1 & 0xC) != 0 && (v1 & 4) == 0)
  {
    if ((v2 & 0x200000) == 0)
    {
      while ((*(_WORD *)(a1 + 44) & 8) != 0)
      {
        a1 = *(void *)(a1 + 8);
        if ((*(unsigned char *)(*(void *)(a1 + 16) + 10) & 0x20) != 0) {
          return (v1 & 0x4000) == 0;
        }
      }
      return 0;
    }
  }
  else if ((v2 & 0x200000) == 0)
  {
    return 0;
  }
  return (v1 & 0x4000) == 0;
}

BOOL llvm::MachineInstr::hasUnmodeledSideEffects(llvm::MachineInstr *this)
{
  __int16 v1 = (unsigned __int16 *)*((void *)this + 2);
  uint64_t v2 = *((void *)v1 + 1);
  if ((*((_WORD *)this + 22) & 0xC) == 0 || (*((_WORD *)this + 22) & 4) != 0)
  {
    if ((v2 & 0x1000000) == 0) {
      return *v1 - 1 <= 1 && (*(unsigned char *)(*((void *)this + 4) + 48) & 1) != 0;
    }
    return 1;
  }
  if ((v2 & 0x1000000) != 0) {
    return 1;
  }
  unsigned __int8 v6 = this;
  while ((*((_WORD *)v6 + 22) & 8) != 0)
  {
    unsigned __int8 v6 = (llvm::MachineInstr *)*((void *)v6 + 1);
    uint64_t v4 = 1;
    if (*(unsigned char *)(*((void *)v6 + 2) + 11)) {
      return v4;
    }
  }
  return *v1 - 1 <= 1 && (*(unsigned char *)(*((void *)this + 4) + 48) & 1) != 0;
}

uint64_t llvm::MachineInstr::isDereferenceableInvariantLoad(llvm::MachineInstr *this, llvm::AAResults *a2)
{
  unsigned int v3 = (unsigned __int16 *)*((void *)this + 2);
  if (*v3 - 1 > 1 || (*(unsigned char *)(*((void *)this + 4) + 48) & 8) == 0)
  {
    uint64_t v4 = *((void *)v3 + 1);
    if ((*((_WORD *)this + 22) & 0xC) != 0 && (*((_WORD *)this + 22) & 4) == 0)
    {
      if ((v4 & 0x80000) == 0)
      {
        int v26 = this;
        while ((*((_WORD *)v26 + 22) & 8) != 0)
        {
          int v26 = (llvm::MachineInstr *)*((void *)v26 + 1);
          if ((*(unsigned char *)(*((void *)v26 + 2) + 10) & 8) != 0) {
            goto LABEL_7;
          }
        }
        return 0;
      }
    }
    else if ((v4 & 0x80000) == 0)
    {
      return 0;
    }
  }
LABEL_7:
  int v7 = (char *)this + 48;
  unint64_t v6 = *((void *)this + 6);
  if (v6 < 8) {
    return 0;
  }
  if ((v6 & 7) == 0)
  {
    v6 &= 0xFFFFFFFFFFFFFFF8;
    *(void *)int v7 = v6;
    if (!v6) {
      return 1;
    }
    goto LABEL_10;
  }
  int v21 = (_DWORD *)(v6 & 0xFFFFFFFFFFFFFFF8);
  BOOL v22 = (*((void *)this + 6) & 7) != 3 || v21 == 0;
  if (v22 || !*v21) {
    return 0;
  }
LABEL_10:
  uint64_t v8 = *(void *)(*(void *)(*((void *)this + 3) + 32) + 56);
  if ((v6 & 7) == 0)
  {
    *((void *)this + 6) = v6 & 0xFFFFFFFFFFFFFFF8;
    int v9 = (char *)this + 56;
    while (1)
    {
LABEL_12:
      char v10 = *(uint64_t **)v7;
      if ((*(_WORD *)(*(void *)v7 + 36) & 0xE00) != 0) {
        return 0;
      }
      int v11 = *((unsigned __int16 *)v10 + 16);
      if ((v11 & 6) != 0) {
        return 0;
      }
      if ((~v11 & 0x30) != 0)
      {
        unint64_t v12 = *v10;
        unint64_t v13 = *v10 & 0xFFFFFFFFFFFFFFF8;
        if ((*v10 & 4) != 0 && v13)
        {
          if ((*(uint64_t (**)(unint64_t, uint64_t))(*(void *)v13 + 24))(*v10 & 0xFFFFFFFFFFFFFFF8, v8))goto LABEL_29; {
          unint64_t v12 = *v10;
          }
          unint64_t v13 = *v10 & 0xFFFFFFFFFFFFFFF8;
        }
        uint64_t v14 = v12 & 4;
        if (v13) {
          BOOL v15 = v14 == 0;
        }
        else {
          BOOL v15 = 0;
        }
        if (!v15 || !a2) {
          return 0;
        }
        if ((v10[3] & 0xFFFFFFFFFFFFFFF9) != 0)
        {
          unint64_t v18 = (unint64_t)(sub_1CB8F1DC4((unint64_t *)v10 + 3) + 7) >> 3;
          if (v17 == 1)
          {
            unint64_t v27 = v18;
            unint64_t v18 = v27;
          }
        }
        else
        {
          unint64_t v18 = -2;
        }
        v28[0] = v13;
        v28[1] = v18;
        long long v19 = *(_OWORD *)(v10 + 7);
        long long v29 = *(_OWORD *)(v10 + 5);
        long long v30 = v19;
        char v20 = llvm::AAResults::pointsToConstantMemory((uint64_t)a2, (uint64_t)v28, 0);
        uint64_t result = 0;
        if ((v20 & 1) == 0) {
          return result;
        }
      }
LABEL_29:
      v7 += 8;
      if (v7 == v9) {
        return 1;
      }
    }
  }
  uint64_t result = 1;
  if ((v6 & 7) == 3)
  {
    unsigned int v23 = (int *)(v6 & 0xFFFFFFFFFFFFFFF8);
    if ((v6 & 0xFFFFFFFFFFFFFFF8) != 0)
    {
      uint64_t v25 = *v23;
      int v7 = (char *)(v23 + 2);
      uint64_t v24 = v25;
      if (v25)
      {
        int v9 = &v7[8 * v24];
        goto LABEL_12;
      }
    }
  }
  return result;
}

uint64_t llvm::MachineInstr::mayAlias(llvm::MachineInstr *this, llvm::AAResults *a2, const llvm::MachineInstr *a3, int a4)
{
  uint64_t v8 = *(void *)(*((void *)this + 3) + 32);
  uint64_t v9 = (*(uint64_t (**)(void))(**(void **)(v8 + 16) + 104))(*(void *)(v8 + 16));
  uint64_t v10 = v9;
  uint64_t v11 = *(void *)(v8 + 56);
  unsigned int v12 = *((unsigned __int16 *)this + 22);
  BOOL v47 = (v12 & 0xC) == 0;
  int v13 = (v12 >> 2) & 1;
  if (v47) {
    char v14 = 1;
  }
  else {
    char v14 = v13;
  }
  BOOL v15 = (unsigned __int16 *)*((void *)this + 2);
  uint64_t v16 = *((void *)v15 + 1);
  if (v14)
  {
    if ((v16 & 0x80) != 0) {
      return 1;
    }
  }
  else
  {
    if ((v16 & 0x80) != 0) {
      return 1;
    }
    uint64_t v24 = this;
    while ((*((_WORD *)v24 + 22) & 8) != 0)
    {
      uint64_t v24 = (llvm::MachineInstr *)*((void *)v24 + 1);
      if ((*(unsigned char *)(*((void *)v24 + 2) + 8) & 0x80) != 0) {
        return 1;
      }
    }
  }
  unsigned int v17 = *((unsigned __int16 *)a3 + 22);
  BOOL v47 = (v17 & 0xC) == 0;
  int v18 = (v17 >> 2) & 1;
  if (v47) {
    char v19 = 1;
  }
  else {
    char v19 = v18;
  }
  char v20 = (unsigned __int16 *)*((void *)a3 + 2);
  uint64_t v21 = *((void *)v20 + 1);
  if (v19)
  {
    if ((v21 & 0x80) != 0) {
      return 1;
    }
  }
  else
  {
    if ((v21 & 0x80) != 0) {
      return 1;
    }
    uint64_t v25 = a3;
    while ((*((_WORD *)v25 + 22) & 8) != 0)
    {
      uint64_t v25 = (const llvm::MachineInstr *)*((void *)v25 + 1);
      if ((*(unsigned char *)(*((void *)v25 + 2) + 8) & 0x80) != 0) {
        return 1;
      }
    }
  }
  unsigned int v22 = *v15 - 1;
  if (v22 <= 1)
  {
    uint64_t v23 = *(void *)(*((void *)this + 4) + 48);
    if ((v23 & 0x10) != 0) {
      goto LABEL_52;
    }
  }
  if (v14)
  {
    if ((v16 & 0x100000) == 0) {
      goto LABEL_15;
    }
  }
  else if ((v16 & 0x100000) == 0)
  {
    int v26 = this;
    while ((*((_WORD *)v26 + 22) & 8) != 0)
    {
      int v26 = (llvm::MachineInstr *)*((void *)v26 + 1);
      if ((*(unsigned char *)(*((void *)v26 + 2) + 10) & 0x10) != 0) {
        goto LABEL_39;
      }
    }
LABEL_15:
    if (*v20 - 1 > 1 || (*(unsigned char *)(*((void *)a3 + 4) + 48) & 0x10) == 0)
    {
      if (v19)
      {
        if ((v21 & 0x100000) == 0) {
          return 0;
        }
      }
      else if ((v21 & 0x100000) == 0)
      {
        unint64_t v27 = a3;
        while ((*((_WORD *)v27 + 22) & 8) != 0)
        {
          unint64_t v27 = (const llvm::MachineInstr *)*((void *)v27 + 1);
          if ((*(unsigned char *)(*((void *)v27 + 2) + 10) & 0x10) != 0) {
            goto LABEL_39;
          }
        }
        return 0;
      }
    }
  }
LABEL_39:
  if (v22 > 1) {
    goto LABEL_40;
  }
  uint64_t v23 = *(void *)(*((void *)this + 4) + 48);
LABEL_52:
  if ((v23 & 8) != 0) {
    goto LABEL_53;
  }
LABEL_40:
  if (v14)
  {
    if ((v16 & 0x80000) != 0) {
      goto LABEL_53;
    }
  }
  else
  {
    if ((v16 & 0x80000) != 0) {
      goto LABEL_53;
    }
    uint64_t v28 = this;
    while ((*((_WORD *)v28 + 22) & 8) != 0)
    {
      uint64_t v28 = (llvm::MachineInstr *)*((void *)v28 + 1);
      if ((*(unsigned char *)(*((void *)v28 + 2) + 10) & 8) != 0) {
        goto LABEL_53;
      }
    }
  }
  if (v22 > 1 || (*(unsigned char *)(*((void *)this + 4) + 48) & 0x10) == 0)
  {
    if (v14)
    {
      if ((v16 & 0x100000) == 0) {
        return 0;
      }
    }
    else if ((v16 & 0x100000) == 0)
    {
      std::string v82 = this;
      while ((*((_WORD *)v82 + 22) & 8) != 0)
      {
        std::string v82 = (llvm::MachineInstr *)*((void *)v82 + 1);
        if ((*(unsigned char *)(*((void *)v82 + 2) + 10) & 0x10) != 0) {
          goto LABEL_53;
        }
      }
      return 0;
    }
  }
LABEL_53:
  unsigned int v29 = *v20 - 1;
  if (v29 > 1 || (*(unsigned char *)(*((void *)a3 + 4) + 48) & 8) == 0)
  {
    if (v19)
    {
      if ((v21 & 0x80000) != 0) {
        goto LABEL_59;
      }
    }
    else
    {
      if ((v21 & 0x80000) != 0) {
        goto LABEL_59;
      }
      uint64_t v83 = a3;
      while ((*((_WORD *)v83 + 22) & 8) != 0)
      {
        uint64_t v83 = (const llvm::MachineInstr *)*((void *)v83 + 1);
        if ((*(unsigned char *)(*((void *)v83 + 2) + 10) & 8) != 0) {
          goto LABEL_59;
        }
      }
    }
    if (v29 > 1 || (*(unsigned char *)(*((void *)a3 + 4) + 48) & 0x10) == 0)
    {
      if (v19)
      {
        if ((v21 & 0x100000) == 0) {
          return 0;
        }
      }
      else if ((v21 & 0x100000) == 0)
      {
        char v84 = a3;
        while ((*((_WORD *)v84 + 22) & 8) != 0)
        {
          char v84 = (const llvm::MachineInstr *)*((void *)v84 + 1);
          if ((*(unsigned char *)(*((void *)v84 + 2) + 10) & 0x10) != 0) {
            goto LABEL_59;
          }
        }
        return 0;
      }
    }
  }
LABEL_59:
  if ((*(uint64_t (**)(uint64_t, llvm::MachineInstr *, const llvm::MachineInstr *))(*(void *)v9 + 1064))(v9, this, a3))return 0; {
  int v32 = (unint64_t *)((char *)this + 48);
  }
  unint64_t v31 = *((void *)this + 6);
  if (v31 < 8) {
    return 1;
  }
  if ((v31 & 7) == 0)
  {
    v31 &= 0xFFFFFFFFFFFFFFF8;
    *int v32 = v31;
    goto LABEL_68;
  }
  uint64_t result = 1;
  if ((*((void *)this + 6) & 7) == 3
    && (v31 & 0xFFFFFFFFFFFFFFF8) != 0
    && *(_DWORD *)(v31 & 0xFFFFFFFFFFFFFFF8))
  {
LABEL_68:
    unsigned int v34 = (unint64_t *)((char *)a3 + 48);
    unint64_t v33 = *((void *)a3 + 6);
    if (v33 >= 8)
    {
      if ((v33 & 7) != 0)
      {
        uint64_t result = 1;
        if ((*((void *)a3 + 6) & 7) != 3
          || (v33 & 0xFFFFFFFFFFFFFFF8) == 0
          || !*(_DWORD *)(v33 & 0xFFFFFFFFFFFFFFF8))
        {
          return result;
        }
      }
      else
      {
        v33 &= 0xFFFFFFFFFFFFFFF8;
        *unsigned int v34 = v33;
        unint64_t v31 = *v32;
      }
      if (v31 < 8)
      {
        int v35 = 0;
      }
      else if ((v31 & 7) != 0)
      {
        int v35 = 0;
        if ((v31 & 7) == 3)
        {
          unsigned int v36 = (int *)(v31 & 0xFFFFFFFFFFFFFFF8);
          if (v36) {
            int v35 = *v36;
          }
        }
      }
      else
      {
        *int v32 = v31 & 0xFFFFFFFFFFFFFFF8;
        unint64_t v33 = *v34;
        int v35 = 1;
      }
      if (v33 < 8)
      {
        int v37 = 0;
      }
      else if ((v33 & 7) != 0)
      {
        int v37 = 0;
        if ((v33 & 7) == 3)
        {
          uint64_t v38 = (int *)(v33 & 0xFFFFFFFFFFFFFFF8);
          if (v38) {
            int v37 = *v38;
          }
        }
      }
      else
      {
        *unsigned int v34 = v33 & 0xFFFFFFFFFFFFFFF8;
        int v37 = 1;
      }
      if (v37 * v35 <= (*(unsigned int (**)(uint64_t))(*(void *)v10 + 1088))(v10))
      {
        unint64_t v39 = *v32;
        if (*v32 < 8) {
          return 0;
        }
        char v87 = (unint64_t *)((char *)a3 + 48);
        if ((v39 & 7) != 0)
        {
          uint64_t result = 0;
          if ((*v32 & 7) != 3) {
            return result;
          }
          int v40 = (int *)(v39 & 0xFFFFFFFFFFFFFFF8);
          if ((v39 & 0xFFFFFFFFFFFFFFF8) == 0) {
            return result;
          }
          uint64_t v42 = *v40;
          int v32 = (unint64_t *)(v40 + 2);
          uint64_t v41 = v42;
          if (!v42) {
            return 0;
          }
          int v43 = &v32[v41];
        }
        else
        {
          *((void *)this + 6) = v39 & 0xFFFFFFFFFFFFFFF8;
          int v43 = (unint64_t *)((char *)this + 56);
        }
        unint64_t v86 = v43;
        std::string v85 = (char *)a3 + 56;
        while (1)
        {
          unint64_t v44 = *v87;
          if (*v87 >= 8)
          {
            int v45 = (void *)*v32;
            if ((v44 & 7) == 0)
            {
              uint64_t v49 = (int *)v87;
              *char v87 = v44 & 0xFFFFFFFFFFFFFFF8;
              int v51 = (int *)v85;
LABEL_109:
              char v90 = v51;
              char v92 = v45 + 3;
              uint64_t v93 = v45;
              while (2)
              {
                unsigned int v52 = *(void **)v49;
                uint64_t v53 = *(void *)(*(void *)v49 + 8);
                int64_t v96 = v53;
                if (v53 >= v45[1]) {
                  uint64_t v53 = v45[1];
                }
                int64_t v94 = v45[1];
                uint64_t v95 = v53;
                if ((v45[3] & 0xFFFFFFFFFFFFFFF9) != 0)
                {
                  unint64_t v97 = (unint64_t)(sub_1CB8F1DC4(v92) + 7) >> 3;
                  if (v54 == 1) {
                }
                  }
                else
                {
                  unint64_t v97 = -1;
                }
                if ((v52[3] & 0xFFFFFFFFFFFFFFF9) != 0)
                {
                  unint64_t v56 = (unint64_t)(sub_1CB8F1DC4(v52 + 3) + 7) >> 3;
                  if (v55 == 1)
                  {
                    unint64_t v81 = v56;
                    unint64_t v56 = v81;
                  }
                }
                else
                {
                  unint64_t v56 = -1;
                }
                uint64_t v57 = *v45;
                unint64_t v58 = *v45 & 0xFFFFFFFFFFFFFFF8;
                if ((*v45 & 4) != 0) {
                  unint64_t v59 = 0;
                }
                else {
                  unint64_t v59 = *v45 & 0xFFFFFFFFFFFFFFF8;
                }
                uint64_t v91 = v52;
                uint64_t v60 = *v52;
                unint64_t v61 = *v52 & 0xFFFFFFFFFFFFFFF8;
                if ((*v52 & 4) != 0) {
                  unint64_t v62 = 0;
                }
                else {
                  unint64_t v62 = *v52 & 0xFFFFFFFFFFFFFFF8;
                }
                if (v59) {
                  BOOL v63 = v62 == 0;
                }
                else {
                  BOOL v63 = 1;
                }
                int v64 = !v63;
                if (v64 == 1 && v59 == v62) {
                  goto LABEL_146;
                }
                unint64_t v89 = v56;
                uint64_t v66 = v58 & (v57 << 61 >> 63);
                if (!v66
                  || !v62
                  || (uint64_t v88 = v58 & (v57 << 61 >> 63),
                      int v67 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v66 + 40))(v66, v11),
                      uint64_t v66 = v88,
                      v67))
                {
                  uint64_t v68 = v61 & (v60 << 61 >> 63);
                  if (!v59
                    || !v68
                    || (uint64_t v69 = v66,
                        int v70 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v68 + 40))(v68, v11),
                        uint64_t v66 = v69,
                        v70))
                  {
                    unint64_t v56 = v89;
                    if (!v66 || (v68 ? (BOOL v71 = v66 == v68) : (BOOL v71 = 0), !v71))
                    {
                      char v74 = v64 ^ 1;
                      if (!a2) {
                        char v74 = 1;
                      }
                      if (v74) {
                        return 1;
                      }
                      if (v97 == -1) {
                        unint64_t v75 = -1;
                      }
                      else {
                        unint64_t v75 = v94 - v95 + v97;
                      }
                      unint64_t v76 = v96 - v95 + v89;
                      if (v89 == -1) {
                        unint64_t v76 = -1;
                      }
                      if (v75 > 0x7FFFFFFFFFFFFFFBLL) {
                        unint64_t v75 = -2;
                      }
                      long long v77 = 0uLL;
                      long long v78 = 0uLL;
                      long long v79 = 0uLL;
                      if (a4)
                      {
                        long long v78 = *(_OWORD *)(v93 + 5);
                        long long v79 = *(_OWORD *)(v93 + 7);
                      }
                      v101[0] = v59;
                      v101[1] = v75;
                      long long v102 = v78;
                      long long v103 = v79;
                      if (v76 > 0x7FFFFFFFFFFFFFFBLL) {
                        unint64_t v76 = -2;
                      }
                      long long v80 = 0uLL;
                      if (a4)
                      {
                        long long v77 = *(_OWORD *)(v91 + 5);
                        long long v80 = *(_OWORD *)(v91 + 7);
                      }
                      v98[0] = v62;
                      v98[1] = v76;
                      long long v99 = v77;
                      long long v100 = v80;
                      if (llvm::AAResults::alias((uint64_t)a2, (uint64_t)v101, (uint64_t)v98)) {
                        return 1;
                      }
                      goto LABEL_152;
                    }
LABEL_146:
                    uint64_t result = 1;
                    if (v97 == -1 || v56 == -1) {
                      return result;
                    }
                    int64_t v72 = v96;
                    if (v94 <= v96)
                    {
                      unint64_t v73 = v97;
                    }
                    else
                    {
                      int64_t v72 = v94;
                      unint64_t v73 = v56;
                    }
                    if ((uint64_t)(v73 + v95) > v72) {
                      return result;
                    }
                  }
                }
LABEL_152:
                v49 += 2;
                int v45 = v93;
                if (v49 == v90) {
                  goto LABEL_174;
                }
                continue;
              }
            }
            long long v46 = (int *)(v44 & 0xFFFFFFFFFFFFFFF8);
            BOOL v47 = (*v87 & 7) != 3 || v46 == 0;
            if (!v47)
            {
              uint64_t v50 = *v46;
              uint64_t v49 = v46 + 2;
              uint64_t v48 = v50;
              if (v50)
              {
                int v51 = &v49[2 * v48];
                goto LABEL_109;
              }
            }
          }
LABEL_174:
          uint64_t result = 0;
          if (++v32 == v86) {
            return result;
          }
        }
      }
    }
    return 1;
  }
  return result;
}

BOOL llvm::MachineInstr::isLoadFoldBarrier(llvm::MachineInstr *this)
{
  __int16 v1 = (unsigned __int16 *)*((void *)this + 2);
  int v2 = *v1;
  if ((v2 - 1) <= 1 && (*(unsigned char *)(*((void *)this + 4) + 48) & 0x10) != 0) {
    return 1;
  }
  uint64_t v3 = *((void *)v1 + 1);
  if ((*((_WORD *)this + 22) & 0xC) != 0 && (*((_WORD *)this + 22) & 4) == 0)
  {
    if ((v3 & 0x100000) != 0) {
      return 1;
    }
    int v7 = this;
    while ((*((_WORD *)v7 + 22) & 8) != 0)
    {
      int v7 = (llvm::MachineInstr *)*((void *)v7 + 1);
      uint64_t v5 = 1;
      if ((*(unsigned char *)(*((void *)v7 + 2) + 10) & 0x10) != 0) {
        return v5;
      }
    }
    if ((v3 & 0x80) != 0) {
      return 1;
    }
    uint64_t v8 = this;
    while ((*((_WORD *)v8 + 22) & 8) != 0)
    {
      uint64_t v8 = (llvm::MachineInstr *)*((void *)v8 + 1);
      uint64_t v5 = 1;
      if ((*(unsigned char *)(*((void *)v8 + 2) + 8) & 0x80) != 0) {
        return v5;
      }
    }
    if ((v3 & 0x1000000) != 0) {
      return v2 != 23;
    }
    uint64_t v9 = this;
    while ((*((_WORD *)v9 + 22) & 8) != 0)
    {
      uint64_t v9 = (llvm::MachineInstr *)*((void *)v9 + 1);
      if (*(unsigned char *)(*((void *)v9 + 2) + 11)) {
        return v2 != 23;
      }
    }
  }
  else
  {
    if ((v3 & 0x100080) != 0) {
      return 1;
    }
    if ((v3 & 0x1000000) != 0) {
      return v2 != 23;
    }
  }
  if (v2 - 1) <= 1 && (*(unsigned char *)(*((void *)this + 4) + 48)) {
    return v2 != 23;
  }
  return 0;
}

BOOL llvm::MachineInstr::allDefsAreDead(llvm::MachineInstr *this)
{
  uint64_t v1 = *((unsigned int *)this + 10);
  if (!v1) {
    return 1;
  }
  int v2 = (_DWORD *)*((void *)this + 4);
  uint64_t v3 = 32 * v1;
  do
  {
    BOOL v4 = (~*v2 & 0x5000000) != 0 && (*v2 & 0x10000FF) == 0x1000000;
    BOOL result = !v4;
    if (v4) {
      break;
    }
    v2 += 8;
    v3 -= 32;
  }
  while (v3);
  return result;
}

void llvm::MachineInstr::copyImplicitOps(llvm::MachineInstr *this, llvm::MachineFunction *a2, const llvm::MachineInstr *a3)
{
  uint64_t v3 = *((unsigned int *)a3 + 10);
  uint64_t v4 = *(unsigned __int16 *)(*((void *)a3 + 2) + 2);
  if (v4 != v3)
  {
    int v7 = (const llvm::MachineOperand *)(*((void *)a3 + 4) + 32 * v4);
    uint64_t v8 = 32 * v3 - 32 * v4;
    do
    {
      if ((*(_DWORD *)v7 & 0x20000FF) == 0x2000000 || *(_DWORD *)v7 == 12) {
        llvm::MachineInstr::addOperand(this, a2, v7);
      }
      int v7 = (const llvm::MachineOperand *)((char *)v7 + 32);
      v8 -= 32;
    }
    while (v8);
  }
}

void llvm::MachineInstr::print(llvm::MachineInstr *this, llvm::raw_ostream *a2, llvm::ModuleSlotTracker *a3, const llvm::TargetRegisterInfo *a4, char a5, char a6, int a7, const llvm::TargetInstrInfo *a8)
{
  char v165 = (char)a4;
  unint64_t v167 = (const llvm::Function **)a3;
  uint64_t v14 = *((void *)this + 3);
  if (v14 && (uint64_t v15 = *(void *)(v14 + 32)) != 0)
  {
    unint64_t v164 = (*(uint64_t (**)(void))(**(void **)(v15 + 16) + 176))(*(void *)(v15 + 16));
    uint64_t v166 = *(void *)(v15 + 40);
    uint64_t v163 = (*(uint64_t (**)(void))(**(void **)(v15 + 8) + 56))(*(void *)(v15 + 8));
    a8 = (const llvm::TargetInstrInfo *)(*(uint64_t (**)(void))(**(void **)(v15 + 16) + 104))(*(void *)(v15 + 16));
  }
  else
  {
    uint64_t v163 = 0;
    unint64_t v164 = 0;
    uint64_t v166 = 0;
  }
  unint64_t v170 = 0x2000000000000001;
  int v159 = a7;
  char v161 = a5;
  if (v165) {
    int hasComplexRegisterTies = 1;
  }
  else {
    int hasComplexRegisterTies = llvm::MachineInstr::hasComplexRegisterTies(this);
  }
  uint64_t v16 = *((unsigned int *)this + 10);
  char v160 = a6;
  if (v16)
  {
    uint64_t v17 = 0;
    while (1)
    {
      int v18 = (llvm::raw_ostream *)(*((void *)this + 4) + 32 * v17);
      if ((*(_DWORD *)v18 & 0x30000FF) != 0x1000000) {
        break;
      }
      if (v17)
      {
        char v19 = (_WORD *)*((void *)a2 + 4);
        if (*((void *)a2 + 3) - (void)v19 > 1uLL)
        {
          *char v19 = 8236;
          *((void *)a2 + 4) += 2;
        }
        else
        {
          llvm::raw_ostream::write(a2, ", ", 2uLL);
        }
      }
      if (v166) {
        uint64_t TypeToPrint = llvm::MachineInstr::getTypeToPrint((uint64_t)this, v17, &v170, v166);
      }
      else {
        uint64_t TypeToPrint = 0;
      }
      if (!hasComplexRegisterTies
        || ((int v21 = *(_DWORD *)(*((void *)this + 4) + 32 * v17), (v21 & 0x10000FF) == 0)
          ? (BOOL v22 = (v21 & 0xF00000) == 0)
          : (BOOL v22 = 1),
            v22))
      {
        unsigned int TiedOperandIdx = 0;
      }
      else
      {
        unsigned int TiedOperandIdx = llvm::MachineInstr::findTiedOperandIdx(this, v17);
      }
      llvm::MachineOperand::print(v18, a2, v167, TypeToPrint, v17++, 0, v165, hasComplexRegisterTies, TiedOperandIdx, v164, v163);
      if (v17 == v16)
      {
        LODWORD(v17) = v16;
        break;
      }
    }
    if (v17)
    {
      uint64_t v24 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v24) > 2)
      {
        *(unsigned char *)(v24 + 2) = 32;
        *(_WORD *)uint64_t v24 = 15648;
        *((void *)a2 + 4) += 3;
      }
      else
      {
        llvm::raw_ostream::write(a2, " = ", 3uLL);
      }
    }
  }
  else
  {
    LODWORD(v17) = 0;
  }
  if (*((_WORD *)this + 22))
  {
    uint64_t v25 = *((void *)a2 + 4);
    if ((unint64_t)(*((void *)a2 + 3) - v25) > 0xB)
    {
      *(_DWORD *)(v25 + 8) = 544241012;
      *(void *)uint64_t v25 = *(void *)"frame-setup ";
      *((void *)a2 + 4) += 12;
    }
    else
    {
      llvm::raw_ostream::write(a2, "frame-setup ", 0xCuLL);
    }
  }
  if ((*((_WORD *)this + 22) & 2) != 0)
  {
    int v26 = (void *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v26 > 0xDuLL)
    {
      qmemcpy(v26, "frame-destroy ", 14);
      *((void *)a2 + 4) += 14;
    }
    else
    {
      llvm::raw_ostream::write(a2, "frame-destroy ", 0xEuLL);
    }
  }
  if ((*((_WORD *)this + 22) & 0x10) != 0)
  {
    uint64_t v27 = *((void *)a2 + 4);
    if ((unint64_t)(*((void *)a2 + 3) - v27) > 4)
    {
      *(unsigned char *)(v27 + 4) = 32;
      *(_DWORD *)uint64_t v27 = 1851879022;
      *((void *)a2 + 4) += 5;
    }
    else
    {
      llvm::raw_ostream::write(a2, "nnan ", 5uLL);
    }
  }
  if ((*((_WORD *)this + 22) & 0x20) != 0)
  {
    uint64_t v28 = *((void *)a2 + 4);
    if ((unint64_t)(*((void *)a2 + 3) - v28) > 4)
    {
      *(unsigned char *)(v28 + 4) = 32;
      *(_DWORD *)uint64_t v28 = 1718511982;
      *((void *)a2 + 4) += 5;
    }
    else
    {
      llvm::raw_ostream::write(a2, "ninf ", 5uLL);
    }
  }
  if ((*((_WORD *)this + 22) & 0x40) != 0)
  {
    unsigned int v29 = (_DWORD *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v29 > 3uLL)
    {
      _DWORD *v29 = 544895854;
      *((void *)a2 + 4) += 4;
    }
    else
    {
      llvm::raw_ostream::write(a2, "nsz ", 4uLL);
    }
  }
  if ((*((_WORD *)this + 22) & 0x80) != 0)
  {
    uint64_t v30 = *((void *)a2 + 4);
    if ((unint64_t)(*((void *)a2 + 3) - v30) > 4)
    {
      *(unsigned char *)(v30 + 4) = 32;
      *(_DWORD *)uint64_t v30 = 1885565537;
      *((void *)a2 + 4) += 5;
    }
    else
    {
      llvm::raw_ostream::write(a2, "arcp ", 5uLL);
    }
  }
  if ((*((_WORD *)this + 22) & 0x100) != 0)
  {
    uint64_t v31 = *((void *)a2 + 4);
    if ((unint64_t)(*((void *)a2 + 3) - v31) > 8)
    {
      *(unsigned char *)(v31 + 8) = 32;
      *(void *)uint64_t v31 = *(void *)"contract ";
      *((void *)a2 + 4) += 9;
    }
    else
    {
      llvm::raw_ostream::write(a2, "contract ", 9uLL);
    }
  }
  if ((*((_WORD *)this + 22) & 0x200) != 0)
  {
    int v32 = (_DWORD *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v32 > 3uLL)
    {
      *int v32 = 544106081;
      *((void *)a2 + 4) += 4;
    }
    else
    {
      llvm::raw_ostream::write(a2, "afn ", 4uLL);
    }
  }
  if ((*((_WORD *)this + 22) & 0x400) != 0)
  {
    unint64_t v33 = (void *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v33 > 7uLL)
    {
      *unint64_t v33 = 0x20636F7373616572;
      *((void *)a2 + 4) += 8;
    }
    else
    {
      llvm::raw_ostream::write(a2, "reassoc ", 8uLL);
    }
  }
  if ((*((_WORD *)this + 22) & 0x800) != 0)
  {
    unsigned int v34 = (_DWORD *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v34 > 3uLL)
    {
      *unsigned int v34 = 544699758;
      *((void *)a2 + 4) += 4;
    }
    else
    {
      llvm::raw_ostream::write(a2, "nuw ", 4uLL);
    }
  }
  if ((*((_WORD *)this + 22) & 0x1000) != 0)
  {
    int v35 = (_DWORD *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v35 > 3uLL)
    {
      _DWORD *v35 = 544699246;
      *((void *)a2 + 4) += 4;
    }
    else
    {
      llvm::raw_ostream::write(a2, "nsw ", 4uLL);
    }
  }
  if ((*((_WORD *)this + 22) & 0x2000) != 0)
  {
    uint64_t v36 = *((void *)a2 + 4);
    if ((unint64_t)(*((void *)a2 + 3) - v36) > 5)
    {
      *(_WORD *)(v36 + 4) = 8308;
      *(_DWORD *)uint64_t v36 = 1667332197;
      *((void *)a2 + 4) += 6;
    }
    else
    {
      llvm::raw_ostream::write(a2, "exact ", 6uLL);
    }
  }
  if ((*((_WORD *)this + 22) & 0x4000) != 0)
  {
    uint64_t v44 = *((void *)a2 + 4);
    if ((unint64_t)(*((void *)a2 + 3) - v44) > 0xA)
    {
      *(_DWORD *)(v44 + 7) = 544501861;
      *(void *)uint64_t v44 = *(void *)"nofpexcept ";
      *((void *)a2 + 4) += 11;
    }
    else
    {
      llvm::raw_ostream::write(a2, "nofpexcept ", 0xBuLL);
    }
    if ((*((_WORD *)this + 22) & 0x8000) == 0)
    {
LABEL_68:
      if (a8) {
        goto LABEL_69;
      }
LABEL_77:
      long long v46 = (_DWORD *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v46 <= 6uLL)
      {
        uint64_t v42 = "UNKNOWN";
        uint64_t v41 = a2;
        size_t v43 = 7;
        goto LABEL_79;
      }
      *(_DWORD *)((char *)v46 + 3) = 1314344782;
      *long long v46 = 1313558101;
      uint64_t v55 = *((void *)a2 + 4) + 7;
      goto LABEL_105;
    }
  }
  else if ((*((_WORD *)this + 22) & 0x8000) == 0)
  {
    goto LABEL_68;
  }
  int v45 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v45 > 7uLL)
  {
    *int v45 = 0x20656772656D6F6ELL;
    *((void *)a2 + 4) += 8;
    if (!a8) {
      goto LABEL_77;
    }
  }
  else
  {
    llvm::raw_ostream::write(a2, "nomerge ", 8uLL);
    if (!a8) {
      goto LABEL_77;
    }
  }
LABEL_69:
  uint64_t v37 = *((void *)a8 + 3);
  if (!v37) {
    goto LABEL_80;
  }
  uint64_t v38 = (const char *)(v37 + *(unsigned int *)(*((void *)a8 + 2) + 4 * **((unsigned __int16 **)this + 2)));
  size_t v39 = strlen(v38);
  int v40 = (void *)*((void *)a2 + 4);
  if (v39 > *((void *)a2 + 3) - (void)v40)
  {
    uint64_t v41 = a2;
    uint64_t v42 = v38;
    size_t v43 = v39;
LABEL_79:
    llvm::raw_ostream::write(v41, v42, v43);
    goto LABEL_80;
  }
  if (v39)
  {
    memcpy(v40, v38, v39);
    uint64_t v55 = *((void *)a2 + 4) + v39;
LABEL_105:
    *((void *)a2 + 4) = v55;
  }
LABEL_80:
  if (v161) {
    goto LABEL_341;
  }
  BOOL v47 = v16 >= 2 && **((unsigned __int16 **)this + 2) - 3 >= 0xFFFFFFFE;
  char v48 = !v47;
  if (!v47)
  {
    int v49 = -1;
    goto LABEL_123;
  }
  uint64_t v50 = (unsigned char *)*((void *)a2 + 4);
  if (*((unsigned char **)a2 + 3) == v50)
  {
    llvm::raw_ostream::write(a2, " ", 1uLL);
  }
  else
  {
    *uint64_t v50 = 32;
    ++*((void *)a2 + 4);
  }
  if (v166) {
    uint64_t v51 = llvm::MachineInstr::getTypeToPrint((uint64_t)this, 0, &v170, v166);
  }
  else {
    uint64_t v51 = 0;
  }
  unsigned int v52 = (llvm::raw_ostream *)*((void *)this + 4);
  unsigned int v53 = hasComplexRegisterTies;
  if (hasComplexRegisterTies)
  {
    unsigned int v53 = 0;
    if ((*(_DWORD *)v52 & 0x10000FF) == 0 && (*(_DWORD *)v52 & 0xF00000) != 0)
    {
      unsigned int v53 = llvm::MachineInstr::findTiedOperandIdx(this, 0);
      unsigned int v52 = (llvm::raw_ostream *)*((void *)this + 4);
    }
  }
  llvm::MachineOperand::print(v52, a2, v167, v51, 0, 1, v165, hasComplexRegisterTies, v53, v164, v163);
  int v54 = *(_DWORD *)(*((void *)this + 4) + 48);
  if (v54)
  {
    unint64_t v56 = (void *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v56 > 0xCuLL)
    {
      qmemcpy(v56, " [sideeffect]", 13);
      *((void *)a2 + 4) += 13;
      if ((v54 & 8) != 0) {
        goto LABEL_108;
      }
    }
    else
    {
      llvm::raw_ostream::write(a2, " [sideeffect]", 0xDuLL);
      if ((v54 & 8) != 0) {
        goto LABEL_108;
      }
    }
LABEL_99:
    if ((v54 & 0x10) == 0) {
      goto LABEL_100;
    }
LABEL_110:
    uint64_t v58 = *((void *)a2 + 4);
    if ((unint64_t)(*((void *)a2 + 3) - v58) > 0xA)
    {
      *(_DWORD *)(v58 + 7) = 1566929519;
      *(void *)uint64_t v58 = *(void *)" [maystore]";
      *((void *)a2 + 4) += 11;
      if ((v54 & 0x20) != 0) {
        goto LABEL_112;
      }
    }
    else
    {
      llvm::raw_ostream::write(a2, " [maystore]", 0xBuLL);
      if ((v54 & 0x20) != 0) {
        goto LABEL_112;
      }
    }
LABEL_101:
    if ((v54 & 2) == 0) {
      goto LABEL_116;
    }
LABEL_114:
    uint64_t v60 = (void *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v60 > 0xCuLL)
    {
      qmemcpy(v60, " [alignstack]", 13);
      *((void *)a2 + 4) += 13;
    }
    else
    {
      llvm::raw_ostream::write(a2, " [alignstack]", 0xDuLL);
    }
    goto LABEL_116;
  }
  if ((v54 & 8) == 0) {
    goto LABEL_99;
  }
LABEL_108:
  uint64_t v57 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v57) > 9)
  {
    *(_WORD *)(v57 + 8) = 23908;
    *(void *)uint64_t v57 = *(void *)" [mayload]";
    *((void *)a2 + 4) += 10;
    if ((v54 & 0x10) != 0) {
      goto LABEL_110;
    }
  }
  else
  {
    llvm::raw_ostream::write(a2, " [mayload]", 0xAuLL);
    if ((v54 & 0x10) != 0) {
      goto LABEL_110;
    }
  }
LABEL_100:
  if ((v54 & 0x20) == 0) {
    goto LABEL_101;
  }
LABEL_112:
  unint64_t v59 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v59 > 0xEuLL)
  {
    qmemcpy(v59, " [isconvergent]", 15);
    *((void *)a2 + 4) += 15;
    if ((v54 & 2) == 0) {
      goto LABEL_116;
    }
    goto LABEL_114;
  }
  llvm::raw_ostream::write(a2, " [isconvergent]", 0xFuLL);
  if ((v54 & 2) != 0) {
    goto LABEL_114;
  }
LABEL_116:
  if ((*(unsigned char *)(*((void *)this + 4) + 48) & 4) == 0)
  {
    unint64_t v61 = (void *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v61 > 0xCuLL)
    {
      qmemcpy(v61, " [attdialect]", 13);
      *((void *)a2 + 4) += 13;
    }
    else
    {
      llvm::raw_ostream::write(a2, " [attdialect]", 0xDuLL);
    }
  }
  if ((*(unsigned char *)(*((void *)this + 4) + 48) & 4) != 0)
  {
    unint64_t v62 = (void *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v62 > 0xEuLL)
    {
      qmemcpy(v62, " [inteldialect]", 15);
      *((void *)a2 + 4) += 15;
    }
    else
    {
      llvm::raw_ostream::write(a2, " [inteldialect]", 0xFuLL);
    }
  }
  LODWORD(v17) = 2;
  int v49 = 2;
LABEL_123:
  int v63 = *((_DWORD *)this + 10);
  if (v17 != v63)
  {
    unsigned int v162 = 0;
    while (1)
    {
      uint64_t v73 = *((void *)this + 4);
      char v74 = (unsigned char *)*((void *)a2 + 4);
      if ((v48 & 1) == 0)
      {
        if (*((unsigned char **)a2 + 3) == v74)
        {
          llvm::raw_ostream::write(a2, ",", 1uLL);
          char v74 = (unsigned char *)*((void *)a2 + 4);
        }
        else
        {
          *char v74 = 44;
          char v74 = (unsigned char *)(*((void *)a2 + 4) + 1);
          *((void *)a2 + 4) = v74;
        }
      }
      if (*((unsigned char **)a2 + 3) == v74)
      {
        llvm::raw_ostream::write(a2, " ", 1uLL);
      }
      else
      {
        *char v74 = 32;
        ++*((void *)a2 + 4);
      }
      unint64_t v75 = (unsigned char *)(v73 + 32 * v17);
      int v76 = **((unsigned __int16 **)this + 2);
      if ((v76 - 13) > 1)
      {
        if (v76 == 17 && *v75 == 14)
        {
          uint64_t v77 = *(void *)(v73 + 32 * v17 + 16);
          if (*(unsigned char *)v77 == 26)
          {
            uint64_t v83 = *(void *)(v77 - 8 * *(unsigned int *)(v77 + 8) + 8);
            if (v83)
            {
              if (**(void **)(v83 + 8))
              {
                char v84 = (unsigned char *)*((void *)a2 + 4);
                if (*((unsigned char **)a2 + 3) == v84)
                {
                  long long v80 = a2;
                  unint64_t v81 = "\"";
                  size_t v82 = 1;
LABEL_165:
                  llvm::raw_ostream::write(v80, v81, v82);
                  std::string v85 = (unsigned char *)*((void *)a2 + 4);
LABEL_166:
                  uint64_t v86 = *(void *)(v77 - 8 * *(unsigned int *)(v77 + 8) + 8);
                  if (v86)
                  {
                    char v87 = *(size_t **)(v86 + 8);
                    size_t v90 = *v87;
                    uint64_t v88 = v87 + 3;
                    size_t v89 = v90;
                    if (v90 <= *((void *)a2 + 3) - (void)v85)
                    {
                      if (v89)
                      {
                        memcpy(v85, v88, v89);
                        std::string v85 = (unsigned char *)(*((void *)a2 + 4) + v89);
                        *((void *)a2 + 4) = v85;
                      }
                    }
                    else
                    {
                      llvm::raw_ostream::write(a2, (const char *)v88, v89);
                      std::string v85 = (unsigned char *)*((void *)a2 + 4);
                    }
                  }
                  if ((unint64_t)v85 >= *((void *)a2 + 3))
                  {
                    llvm::raw_ostream::write(a2, 34);
                  }
                  else
                  {
                    *((void *)a2 + 4) = v85 + 1;
                    *std::string v85 = 34;
                  }
                  goto LABEL_215;
                }
                *char v84 = 34;
                std::string v85 = (unsigned char *)(*((void *)a2 + 4) + 1);
LABEL_266:
                *((void *)a2 + 4) = v85;
                goto LABEL_166;
              }
            }
          }
          if (v166) {
            uint64_t v92 = llvm::MachineInstr::getTypeToPrint((uint64_t)this, v17, &v170, v166);
          }
          else {
            uint64_t v92 = 0;
          }
          if (hasComplexRegisterTies)
          {
            unsigned int v97 = 0;
            int v102 = *(_DWORD *)(*((void *)this + 4) + 32 * v17);
            if ((v102 & 0x10000FF) == 0 && (v102 & 0xF00000) != 0) {
              goto LABEL_212;
            }
LABEL_214:
            llvm::MachineOperand::print((llvm::raw_ostream *)(v73 + 32 * v17), a2, v167, v92, v17, 1, v165, hasComplexRegisterTies, v97, v164, v163);
            goto LABEL_215;
          }
LABEL_213:
          unsigned int v97 = 0;
          goto LABEL_214;
        }
      }
      else if (*v75 == 14)
      {
        uint64_t v77 = *(void *)(v73 + 32 * v17 + 16);
        if (*(unsigned char *)v77 == 25)
        {
          uint64_t v78 = *(void *)(v77 - 8 * *(unsigned int *)(v77 + 8) + 8);
          if (v78)
          {
            if (**(void **)(v78 + 8))
            {
              long long v79 = (_WORD *)*((void *)a2 + 4);
              if (*((void *)a2 + 3) - (void)v79 <= 1uLL)
              {
                long long v80 = a2;
                unint64_t v81 = "!\"";
                size_t v82 = 2;
                goto LABEL_165;
              }
              *long long v79 = 8737;
              std::string v85 = (unsigned char *)(*((void *)a2 + 4) + 2);
              goto LABEL_266;
            }
          }
        }
        if (v166) {
          uint64_t v92 = llvm::MachineInstr::getTypeToPrint((uint64_t)this, v17, &v170, v166);
        }
        else {
          uint64_t v92 = 0;
        }
        if (hasComplexRegisterTies)
        {
          int v95 = *(_DWORD *)(*((void *)this + 4) + 32 * v17);
          if ((v95 & 0x10000FF) == 0 && (v95 & 0xF00000) != 0)
          {
LABEL_212:
            unsigned int v97 = llvm::MachineInstr::findTiedOperandIdx(this, v17);
            goto LABEL_214;
          }
        }
        goto LABEL_213;
      }
      if (v17 == v49 && *v75 == 1)
      {
        uint64_t v91 = (unsigned char *)*((void *)a2 + 4);
        if ((unint64_t)v91 >= *((void *)a2 + 3))
        {
          llvm::raw_ostream::write(a2, 36);
        }
        else
        {
          *((void *)a2 + 4) = v91 + 1;
          *uint64_t v91 = 36;
        }
        sub_1CD098D14(a2, v162, 0, 0, 0);
        unint64_t v103 = *(void *)(v73 + 32 * v17 + 16);
        int v104 = (_WORD *)*((void *)a2 + 4);
        if (*((void *)a2 + 3) - (void)v104 > 1uLL)
        {
          *int v104 = 23354;
          *((void *)a2 + 4) += 2;
        }
        else
        {
          llvm::raw_ostream::write(a2, ":[", 2uLL);
        }
        uint64_t v105 = v103 & 7;
        uint64_t v106 = 8 * v105 - 8;
        size_t v107 = *(void *)((char *)&unk_1CFAC7198 + v106);
        uint64_t v108 = *(char **)((char *)off_1E682F6C8 + v106);
        char v109 = (void *)*((void *)a2 + 4);
        if (v107 <= *((void *)a2 + 3) - (void)v109)
        {
          memcpy(v109, v108, v107);
          *((void *)a2 + 4) += v107;
        }
        else
        {
          llvm::raw_ostream::write(a2, (const char *)v108, v107);
        }
        if (v105 != 5)
        {
          if (v105 != 6)
          {
            if ((v103 & 0x80000000) == 0)
            {
              if (v103 >= 0x10000)
              {
                if (v164)
                {
                  char v110 = (unsigned char *)*((void *)a2 + 4);
                  if ((unint64_t)v110 >= *((void *)a2 + 3))
                  {
                    llvm::raw_ostream::write(a2, 58);
                  }
                  else
                  {
                    *((void *)a2 + 4) = v110 + 1;
                    *char v110 = 58;
                  }
                  uint64_t v114 = *(void *)(v164 + 80);
                  if (v114)
                  {
                    unsigned int v115 = (const char *)(v114
                                        + *(unsigned int *)(**(void **)(*(void *)(v164 + 240)
                                                                        + 8 * (WORD1(v103) - 1))
                                                          + 16));
                    size_t v116 = strlen(v115);
                    unsigned int v117 = (void *)*((void *)a2 + 4);
                    if (v116 <= *((void *)a2 + 3) - (void)v117)
                    {
                      if (v116)
                      {
                        memcpy(v117, v115, v116);
                        *((void *)a2 + 4) += v116;
                      }
                    }
                    else
                    {
                      llvm::raw_ostream::write(a2, v115, v116);
                    }
                  }
                  goto LABEL_259;
                }
                uint64_t v111 = *((void *)a2 + 4);
                if ((unint64_t)(*((void *)a2 + 3) - v111) > 2)
                {
                  *(unsigned char *)(v111 + 2) = 67;
                  *(_WORD *)uint64_t v111 = 21050;
                  *((void *)a2 + 4) += 3;
                }
                else
                {
                  llvm::raw_ostream::write(a2, ":RC", 3uLL);
                }
                uint64_t v112 = a2;
                unint64_t v113 = WORD1(v103) - 1;
LABEL_258:
                sub_1CD098D14(v112, v113, 0, 0, 0);
              }
LABEL_259:
              unsigned int v123 = (unsigned char *)*((void *)a2 + 4);
              if ((unint64_t)v123 >= *((void *)a2 + 3))
              {
                llvm::raw_ostream::write(a2, 93);
              }
              else
              {
                *((void *)a2 + 4) = v123 + 1;
                unsigned char *v123 = 93;
              }
              ++v162;
              v49 += ((unsigned __int16)v103 >> 3) + 1;
              goto LABEL_215;
            }
LABEL_255:
            uint64_t v122 = *((void *)a2 + 4);
            if ((unint64_t)(*((void *)a2 + 3) - v122) > 8)
            {
              *(unsigned char *)(v122 + 8) = 36;
              *(void *)uint64_t v122 = *(void *)" tiedto:$";
              *((void *)a2 + 4) += 9;
            }
            else
            {
              llvm::raw_ostream::write(a2, " tiedto:$", 9uLL);
            }
            unint64_t v113 = (v103 >> 16) & 0x7FFF;
            uint64_t v112 = a2;
            goto LABEL_258;
          }
          unsigned int v118 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v118)
          {
            llvm::raw_ostream::write(a2, ":", 1uLL);
          }
          else
          {
            *unsigned int v118 = 58;
            ++*((void *)a2 + 4);
          }
          a3 = (llvm::ModuleSlotTracker *)sub_1CD535588(WORD1(v103) & 0x7FFF);
          size_t v120 = v119;
          int v121 = (void *)*((void *)a2 + 4);
          if (v119 <= *((void *)a2 + 3) - (void)v121)
          {
            if (v119)
            {
              memcpy(v121, a3, v119);
              *((void *)a2 + 4) += v120;
            }
          }
          else
          {
            llvm::raw_ostream::write(a2, (const char *)a3, v119);
          }
        }
        if ((v103 & 0x80000000) == 0) {
          goto LABEL_259;
        }
        goto LABEL_255;
      }
      if (v166) {
        uint64_t v92 = llvm::MachineInstr::getTypeToPrint((uint64_t)this, v17, &v170, v166);
      }
      else {
        uint64_t v92 = 0;
      }
      if (!hasComplexRegisterTies
        || ((int v93 = *(_DWORD *)(*((void *)this + 4) + 32 * v17), (v93 & 0x10000FF) == 0)
          ? (BOOL v94 = (v93 & 0xF00000) == 0)
          : (BOOL v94 = 1),
            v94))
      {
        unsigned int v97 = 0;
      }
      else
      {
        unsigned int v97 = llvm::MachineInstr::findTiedOperandIdx(this, v17);
      }
      if (*v75 != 1) {
        goto LABEL_214;
      }
      int v98 = **((unsigned __int16 **)this + 2);
      if ((v17 != 2 || v98 != 8) && (v17 != 3 || v98 != 9))
      {
        BOOL v99 = (v17 & 1) == 0;
        if (v17 <= 1 || v98 != 18) {
          BOOL v99 = 0;
        }
        BOOL v101 = v98 == 11 && v17 == 3;
        if (!v101 && !v99) {
          goto LABEL_214;
        }
      }
      llvm::MachineOperand::printSubRegIdx(a2, *(llvm::raw_ostream **)(v73 + 32 * v17 + 16), v164, a4);
LABEL_215:
      char v64 = 0;
      char v48 = 0;
      LODWORD(v17) = v17 + 1;
      if (v63 == v17) {
        goto LABEL_125;
      }
    }
  }
  char v64 = v48;
LABEL_125:
  uint64_t v65 = a8;
  int v67 = (unint64_t *)((char *)this + 48);
  unint64_t v66 = *((void *)this + 6);
  char v68 = v160;
  if (v66 < 8) {
    goto LABEL_277;
  }
  uint64_t v69 = (llvm::raw_ostream *)(v66 & 0xFFFFFFFFFFFFFFF8);
  if ((*((void *)this + 6) & 7) == 1 && v69) {
    goto LABEL_370;
  }
  if ((*((void *)this + 6) & 7) == 3 && v69 && *((unsigned char *)v69 + 4) && *((void *)v69 + *(int *)v69 + 1))
  {
    uint64_t v69 = (llvm::raw_ostream *)*((void *)v69 + *(int *)v69 + 1);
LABEL_370:
    if ((v64 & 1) == 0)
    {
      uint64_t v155 = (unsigned char *)*((void *)a2 + 4);
      if ((unint64_t)v155 >= *((void *)a2 + 3))
      {
        llvm::raw_ostream::write(a2, 44);
      }
      else
      {
        *((void *)a2 + 4) = v155 + 1;
        *uint64_t v155 = 44;
      }
    }
    uint64_t v156 = *((void *)a2 + 4);
    if ((unint64_t)(*((void *)a2 + 3) - v156) > 0x11)
    {
      *(_WORD *)(v156 + 16) = 8300;
      *(_OWORD *)uint64_t v156 = *(_OWORD *)" pre-instr-symbol ";
      *((void *)a2 + 4) += 18;
    }
    else
    {
      llvm::raw_ostream::write(a2, " pre-instr-symbol ", 0x12uLL);
    }
    llvm::MachineOperand::printSymbol(a2, v69, a3);
    unint64_t v66 = *v67;
    if (*v67 < 8) {
      goto LABEL_277;
    }
    uint64_t v69 = (llvm::raw_ostream *)(v66 & 0xFFFFFFFFFFFFFFF8);
  }
  if ((v66 & 7) != 2 || !v69)
  {
    if ((v66 & 7) != 3
      || !v69
      || !*((unsigned char *)v69 + 5)
      || (uint64_t v70 = *((unsigned __int8 *)v69 + 4), !*((void *)v69 + *(int *)v69 + v70 + 1)))
    {
LABEL_138:
      if ((v66 & 7) == 3)
      {
        if (v69)
        {
          if (*((unsigned char *)v69 + 6))
          {
            uint64_t v71 = *((void *)v69 + *(int *)v69 + (*((unsigned char *)v69 + 5) + *((unsigned char *)v69 + 4)) + 1);
            if (v71)
            {
              if ((v64 & 1) == 0)
              {
                int64_t v72 = (unsigned char *)*((void *)a2 + 4);
                if ((unint64_t)v72 >= *((void *)a2 + 3))
                {
                  llvm::raw_ostream::write(a2, 44);
                }
                else
                {
                  *((void *)a2 + 4) = v72 + 1;
                  *int64_t v72 = 44;
                }
              }
              uint64_t v124 = *((void *)a2 + 4);
              if ((unint64_t)(*((void *)a2 + 3) - v124) > 0x12)
              {
                *(_DWORD *)(v124 + 15) = 544367979;
                *(_OWORD *)uint64_t v124 = *(_OWORD *)" heap-alloc-marker ";
                *((void *)a2 + 4) += 19;
              }
              else
              {
                llvm::raw_ostream::write(a2, " heap-alloc-marker ", 0x13uLL);
              }
              sub_1CC4F9EAC((uint64_t)a2, v71, (llvm::ModuleSlotTracker *)v167, 0, 1, 0);
            }
          }
        }
      }
      goto LABEL_277;
    }
    uint64_t v69 = (llvm::raw_ostream *)*((void *)v69 + *(int *)v69 + v70 + 1);
  }
  if ((v64 & 1) == 0)
  {
    uint64_t v157 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v157 >= *((void *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, 44);
    }
    else
    {
      *((void *)a2 + 4) = v157 + 1;
      *uint64_t v157 = 44;
    }
  }
  uint64_t v158 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v158) > 0x12)
  {
    *(_DWORD *)(v158 + 15) = 543977314;
    *(_OWORD *)uint64_t v158 = *(_OWORD *)" post-instr-symbol ";
    *((void *)a2 + 4) += 19;
  }
  else
  {
    llvm::raw_ostream::write(a2, " post-instr-symbol ", 0x13uLL);
  }
  llvm::MachineOperand::printSymbol(a2, v69, a3);
  unint64_t v66 = *v67;
  if (*v67 >= 8)
  {
    uint64_t v69 = (llvm::raw_ostream *)(v66 & 0xFFFFFFFFFFFFFFF8);
    goto LABEL_138;
  }
LABEL_277:
  if (*((_DWORD *)this + 16))
  {
    if ((v64 & 1) == 0)
    {
      uint64_t v125 = (unsigned char *)*((void *)a2 + 4);
      if (*((unsigned char **)a2 + 3) == v125)
      {
        llvm::raw_ostream::write(a2, ",", 1uLL);
      }
      else
      {
        *uint64_t v125 = 44;
        ++*((void *)a2 + 4);
      }
    }
    uint64_t v126 = *((void *)a2 + 4);
    if ((unint64_t)(*((void *)a2 + 3) - v126) > 0x13)
    {
      *(_DWORD *)(v126 + 16) = 544367970;
      *(_OWORD *)uint64_t v126 = *(_OWORD *)" debug-instr-number ";
      *((void *)a2 + 4) += 20;
    }
    else
    {
      llvm::raw_ostream::write(a2, " debug-instr-number ", 0x14uLL);
    }
    sub_1CD098D14(a2, *((unsigned int *)this + 16), 0, 0, 0);
  }
  if ((v160 & 1) == 0 && *((void *)this + 7))
  {
    if ((v64 & 1) == 0)
    {
      uint64_t v127 = (unsigned char *)*((void *)a2 + 4);
      if ((unint64_t)v127 >= *((void *)a2 + 3))
      {
        llvm::raw_ostream::write(a2, 44);
      }
      else
      {
        *((void *)a2 + 4) = v127 + 1;
        *uint64_t v127 = 44;
      }
    }
    int v128 = (_OWORD *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v128 > 0xFuLL)
    {
      _OWORD *v128 = *(_OWORD *)" debug-location ";
      *((void *)a2 + 4) += 16;
    }
    else
    {
      llvm::raw_ostream::write(a2, " debug-location ", 0x10uLL);
    }
    sub_1CC4F9EAC((uint64_t)a2, *((void *)this + 7), (llvm::ModuleSlotTracker *)v167, 0, 1, 0);
  }
  unint64_t v129 = *v67;
  if (*v67 >= 8)
  {
    if ((v129 & 7) != 0)
    {
      if ((*v67 & 7) != 3) {
        goto LABEL_323;
      }
      uint64_t v130 = (_DWORD *)(v129 & 0xFFFFFFFFFFFFFFF8);
      if (!v130 || !*v130) {
        goto LABEL_323;
      }
    }
    else
    {
      *int v67 = v129 & 0xFFFFFFFFFFFFFFF8;
    }
    v169[0] = &v170;
    v169[1] = 0;
    uint64_t v131 = *((void *)this + 3);
    if (!v131 || (uint64_t v132 = *(void *)(v131 + 32)) == 0) {
      operator new();
    }
    unint64_t v133 = *(void **)(v132 + 56);
    uint64_t v134 = ***(uint64_t ****)v132;
    uint64_t v135 = (_DWORD *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v135 > 3uLL)
    {
      _DWORD *v135 = 540686880;
      *((void *)a2 + 4) += 4;
    }
    else
    {
      llvm::raw_ostream::write(a2, " :: ", 4uLL);
    }
    unint64_t v136 = *v67;
    if (*v67 < 8) {
      goto LABEL_320;
    }
    if ((v136 & 7) != 0)
    {
      if ((*v67 & 7) != 3
        || (int v137 = (int *)(v136 & 0xFFFFFFFFFFFFFFF8), (v136 & 0xFFFFFFFFFFFFFFF8) == 0)
        || (v139 = *v137, int v67 = (unint64_t *)(v137 + 2), v138 = v139, !v139))
      {
LABEL_320:
        if (v169[0] != &v170) {
          free(v169[0]);
        }
        char v68 = v160;
        goto LABEL_323;
      }
      int v140 = &v67[v138];
    }
    else
    {
      *((void *)this + 6) = v136 & 0xFFFFFFFFFFFFFFF8;
      int v140 = (unint64_t *)((char *)this + 56);
    }
    char v141 = 0;
    do
    {
      __n128 v142 = (uint64_t *)*v67;
      if (v141)
      {
        unsigned int v143 = (_WORD *)*((void *)a2 + 4);
        if (*((void *)a2 + 3) - (void)v143 > 1uLL)
        {
          *unsigned int v143 = 8236;
          *((void *)a2 + 4) += 2;
        }
        else
        {
          llvm::raw_ostream::write(a2, ", ", 2uLL);
        }
      }
      llvm::MachineMemOperand::print(v142, a2, (llvm::ModuleSlotTracker *)v167, (uint64_t)v169, v134, v133, (uint64_t)v65);
      ++v67;
      char v141 = 1;
    }
    while (v67 != v140);
    goto LABEL_320;
  }
LABEL_323:
  if (v68) {
    goto LABEL_341;
  }
  uint64_t v144 = *((void *)this + 7);
  if (v144)
  {
    uint64_t v153 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v153 >= *((void *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, 59);
    }
    else
    {
      *((void *)a2 + 4) = v153 + 1;
      unsigned char *v153 = 59;
    }
    unsigned int v154 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v154 >= *((void *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, 32);
    }
    else
    {
      *((void *)a2 + 4) = v154 + 1;
      *unsigned int v154 = 32;
    }
    llvm::DebugLoc::print((uint64_t)this + 56, a2);
  }
  int v145 = **((unsigned __int16 **)this + 2);
  if ((v145 - 13) > 1 || *(unsigned char *)(*((void *)this + 4) + ((unint64_t)(v145 != 14) << 6)) != 14) {
    goto LABEL_337;
  }
  if (!v144)
  {
    int v146 = (unsigned char *)*((void *)a2 + 4);
    if (*((unsigned char **)a2 + 3) == v146)
    {
      llvm::raw_ostream::write(a2, ";", 1uLL);
    }
    else
    {
      *int v146 = 59;
      ++*((void *)a2 + 4);
    }
  }
  uint64_t v147 = *(void *)(*((void *)this + 4) + ((unint64_t)(**((_WORD **)this + 2) != 14) << 6) + 16);
  uint64_t v148 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v148) > 8)
  {
    *(unsigned char *)(v148 + 8) = 58;
    *(void *)uint64_t v148 = *(void *)" line no:";
    *((void *)a2 + 4) += 9;
  }
  else
  {
    llvm::raw_ostream::write(a2, " line no:", 9uLL);
  }
  sub_1CD098D14(a2, *(unsigned int *)(v147 + 24), 0, 0, 0);
  if (**((_WORD **)this + 2) != 13) {
    goto LABEL_337;
  }
  uint64_t v149 = (unsigned char *)*((void *)this + 4);
  if (v149[32] != 1 || *v149) {
    goto LABEL_337;
  }
  uint64_t v150 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v150) <= 8)
  {
    llvm::raw_ostream::write(a2, " indirect", 9uLL);
LABEL_337:
    if (!v159) {
      goto LABEL_341;
    }
    goto LABEL_338;
  }
  *(unsigned char *)(v150 + 8) = 116;
  *(void *)uint64_t v150 = *(void *)" indirect";
  *((void *)a2 + 4) += 9;
  if (!v159) {
    goto LABEL_341;
  }
LABEL_338:
  uint64_t v151 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)v151 >= *((void *)a2 + 3))
  {
    llvm::raw_ostream::write(a2, 10);
  }
  else
  {
    *((void *)a2 + 4) = v151 + 1;
    *uint64_t v151 = 10;
  }
LABEL_341:
  unint64_t v152 = v170;
  if ((v170 & 1) == 0 && v170)
  {
    if (*(void *)v170 != v170 + 16) {
      free(*(void **)v170);
    }
    MEMORY[0x1D25D9CE0](v152, 0x1080C40EF38A13ELL);
  }
}

uint64_t llvm::MachineInstr::addRegisterKilled(llvm::MachineInstr *this, unsigned int a2, uint64_t a3, int a4)
{
  v66[2] = *MEMORY[0x1E4F143B8];
  unsigned int v7 = a2 - 1;
  if (a2 - 1 > 0x3FFFFFFE)
  {
    int v21 = 0;
  }
  else
  {
    uint64_t v8 = (uint64_t *)(a3 + 8);
    if (!a3) {
      uint64_t v8 = 0;
    }
    uint64_t v9 = *v8;
    unint64_t v10 = *(unsigned int *)(*v8 + 24 * a2 + 16);
    __int16 v11 = v10 & 0xF;
    uint64_t v12 = (v10 >> 3) & 0x1FFFFFFE;
    uint64_t v14 = v8[5];
    uint64_t v13 = v8[6];
    uint64_t v15 = (_WORD *)(v13 + v12);
    unsigned __int16 v16 = *v15 + v11 * a2;
    while (1)
    {
      unsigned __int16 v17 = *(_WORD *)(v14 + 4 * v16);
      if (v17) {
        break;
      }
LABEL_13:
      int v21 = 0;
      int v22 = (unsigned __int16)v15[1];
      ++v15;
      v16 += v22;
      if (!v22) {
        goto LABEL_17;
      }
    }
    unsigned __int16 v18 = *(_WORD *)(v14 + 4 * v16 + 2);
    while (!v13)
    {
LABEL_11:
      unsigned __int16 v17 = v18;
      BOOL v30 = v18 == 0;
      unsigned __int16 v18 = 0;
      if (v30) {
        goto LABEL_13;
      }
    }
    char v19 = (unsigned __int16 *)(v13 + 2 * *(unsigned int *)(v9 + 24 * v17 + 8));
    while (a2 == v17)
    {
      int v20 = *v19++;
      v17 += v20;
      if (!v20) {
        goto LABEL_11;
      }
    }
    int v21 = 1;
  }
LABEL_17:
  char v64 = v66;
  uint64_t v65 = 0x400000000;
  uint64_t v23 = *((unsigned int *)this + 10);
  if (!v23)
  {
    char v25 = 0;
LABEL_86:
    if (a4)
    {
      uint64_t v61 = 0;
      uint64_t v62 = 0;
      uint64_t v63 = 0;
      v60[0] = 100663296;
      v60[1] = a2;
      llvm::MachineInstr::addOperand(this, *(llvm::MachineFunction **)(*((void *)this + 3) + 32), (const llvm::MachineOperand *)v60);
LABEL_88:
      char v25 = 1;
    }
    goto LABEL_89;
  }
  uint64_t v24 = 0;
  char v25 = 0;
  do
  {
    uint64_t v27 = (int *)(*((void *)this + 4) + 32 * v24);
    unsigned int v28 = *v27;
    if ((*v27 & 0x910000FF) == 0)
    {
      unsigned int v29 = v27[1];
      if (v29)
      {
        if (v29 == a2)
        {
          if ((v25 & 1) == 0)
          {
            if ((v28 >> 26) & ~HIBYTE(v28)) {
              goto LABEL_88;
            }
            if (v7 <= 0x3FFFFFFE)
            {
              BOOL v30 = (v28 & 0x10000FF) != 0 || (v28 & 0xF00000) == 0;
              if (!v30) {
                goto LABEL_88;
              }
            }
            *uint64_t v27 = v28 | 0x4000000;
          }
          char v25 = 1;
        }
        else if (v21 && ((v28 >> 26) & ~HIBYTE(v28) & 1) != 0 && !(v29 >> 30))
        {
          uint64_t v31 = *(void *)(a3 + 56);
          uint64_t v32 = *(void *)(a3 + 8);
          unint64_t v33 = (_WORD *)(v31 + 2 * *(unsigned int *)(v32 + 24 * a2 + 8));
          int v34 = (unsigned __int16)*v33;
          unsigned __int16 v35 = v34 + a2;
          BOOL v30 = v34 == 0;
          BOOL v36 = *v33 == 0;
          if (!v30 && v29 != v35)
          {
            uint64_t v38 = v33 + 1;
            do
            {
              int v40 = *v38++;
              int v39 = v40;
              v35 += v40;
              BOOL v36 = v40 == 0;
              if (!v40) {
                uint64_t v38 = 0;
              }
              if (v39) {
                BOOL v41 = v29 == v35;
              }
              else {
                BOOL v41 = 1;
              }
            }
            while (!v41);
          }
          if (!v36) {
            goto LABEL_88;
          }
          uint64_t v42 = (_WORD *)(v31 + 2 * *(unsigned int *)(v32 + 24 * v29 + 8));
          int v43 = (unsigned __int16)*v42;
          unsigned __int16 v44 = v43 + v29;
          BOOL v30 = v43 == 0;
          BOOL v45 = *v42 != 0;
          if (!v30 && v44 != a2)
          {
            BOOL v47 = v42 + 1;
            do
            {
              int v49 = *v47++;
              int v48 = v49;
              v44 += v49;
              BOOL v45 = v49 != 0;
              if (!v49) {
                BOOL v47 = 0;
              }
              if (v48) {
                BOOL v50 = v44 == a2;
              }
              else {
                BOOL v50 = 1;
              }
            }
            while (!v50);
          }
          if (v45)
          {
            if (v65 >= (unint64_t)HIDWORD(v65)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((_DWORD *)v64 + v65) = v24;
            LODWORD(v65) = v65 + 1;
          }
        }
      }
    }
    ++v24;
  }
  while (v24 != v23);
  for (unsigned int i = v65; v65; LODWORD(v65) = v65 - 1)
  {
    uint64_t v52 = *((unsigned int *)v64 + i - 1);
    uint64_t v53 = *((void *)this + 4);
    int v54 = (_DWORD *)(v53 + 32 * v52);
    if ((*v54 & 0x2000000) != 0)
    {
      if (v52 >= 2 && **((unsigned __int16 **)this + 2) - 3 >= 0xFFFFFFFE)
      {
        unsigned int v56 = *((_DWORD *)this + 10);
        if (v56 >= 3)
        {
          unsigned int v57 = 2;
          while (*(unsigned char *)(v53 + 32 * v57) == 1)
          {
            unsigned int v58 = v57;
            v57 += ((unsigned __int16)*(_DWORD *)(v53 + 32 * v57 + 16) >> 3) + 1;
            if (v57 > v52)
            {
              if ((v58 & 0x80000000) == 0) {
                goto LABEL_68;
              }
              break;
            }
            if (v57 >= v56) {
              break;
            }
          }
        }
      }
      llvm::MachineInstr::removeOperand((char *)this, v52);
    }
    else
    {
LABEL_68:
      *v54 &= ~0x4000000u;
    }
    unsigned int i = v65 - 1;
  }
  if ((v25 & 1) == 0) {
    goto LABEL_86;
  }
LABEL_89:
  if (v64 != v66) {
    free(v64);
  }
  return v25 & 1;
}

uint64_t llvm::MachineInstr::clearRegisterKills(uint64_t result, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(result + 40);
  if (v3)
  {
    unsigned int v5 = a2 - 1;
    unint64_t v6 = *(unsigned int **)(result + 32);
    if (a2 - 1 >= 0x3FFFFFFF) {
      a3 = 0;
    }
    uint64_t v9 = 32 * v3;
    while (1)
    {
      unsigned int v10 = *v6;
      if ((*v6 & 0x10000FF) != 0 || ((v10 >> 26) & ~HIBYTE(v10) & 1) == 0) {
        goto LABEL_16;
      }
      unsigned int v11 = v6[1];
      if (a3)
      {
        if (v11 == a2) {
          goto LABEL_15;
        }
        if (v5 <= 0x3FFFFFFE && v11 - 1 <= 0x3FFFFFFE) {
          break;
        }
      }
      if (v11 == a2) {
        goto LABEL_15;
      }
LABEL_16:
      v6 += 8;
      v9 -= 32;
      if (!v9) {
        return result;
      }
    }
    BOOL result = llvm::MCRegisterInfo::regsOverlap((void *)(a3 + 8), a2, v11);
    if ((result & 1) == 0) {
      goto LABEL_16;
    }
LABEL_15:
    unsigned int *v6 = v10 & 0xFBFFFFFF;
    goto LABEL_16;
  }
  return result;
}

uint64_t llvm::MachineInstr::addRegisterDead(llvm::MachineInstr *this, unsigned int a2, uint64_t a3, int a4)
{
  int v4 = a4;
  v65[2] = *MEMORY[0x1E4F143B8];
  if (a2 - 1 > 0x3FFFFFFE)
  {
    int v21 = 0;
  }
  else
  {
    if (a3) {
      unsigned int v7 = (uint64_t *)(a3 + 8);
    }
    else {
      unsigned int v7 = 0;
    }
    uint64_t v8 = *v7;
    unint64_t v9 = *(unsigned int *)(*v7 + 24 * a2 + 16);
    __int16 v10 = v9 & 0xF;
    uint64_t v11 = (v9 >> 3) & 0x1FFFFFFE;
    uint64_t v14 = v7 + 5;
    uint64_t v13 = v7[5];
    uint64_t v12 = v14[1];
    uint64_t v15 = (_WORD *)(v12 + v11);
    unsigned __int16 v16 = *v15 + v10 * a2;
    while (1)
    {
      unsigned __int16 v17 = *(_WORD *)(v13 + 4 * v16);
      if (v17) {
        break;
      }
LABEL_14:
      int v21 = 0;
      int v22 = (unsigned __int16)v15[1];
      ++v15;
      v16 += v22;
      if (!v22) {
        goto LABEL_18;
      }
    }
    unsigned __int16 v18 = *(_WORD *)(v13 + 4 * v16 + 2);
    while (!v12)
    {
LABEL_12:
      unsigned __int16 v17 = v18;
      BOOL v29 = v18 == 0;
      unsigned __int16 v18 = 0;
      if (v29) {
        goto LABEL_14;
      }
    }
    char v19 = (unsigned __int16 *)(v12 + 2 * *(unsigned int *)(v8 + 24 * v17 + 8));
    while (a2 == v17)
    {
      int v20 = *v19++;
      v17 += v20;
      if (!v20) {
        goto LABEL_12;
      }
    }
    int v21 = 1;
  }
LABEL_18:
  uint64_t v63 = v65;
  uint64_t v64 = 0x400000000;
  uint64_t v23 = *((unsigned int *)this + 10);
  if (v23)
  {
    uint64_t v24 = 0;
    char v25 = 0;
    do
    {
      int v26 = (int *)(*((void *)this + 4) + 32 * v24);
      int v27 = *v26;
      if ((*v26 & 0x10000FF) == 0x1000000)
      {
        unsigned int v28 = v26[1];
        if (v28)
        {
          if (v28 == a2)
          {
            *int v26 = v27 | 0x4000000;
            char v25 = 1;
          }
          else if (v21)
          {
            BOOL v29 = (~v27 & 0x5000000) == 0 && v28 >> 30 == 0;
            if (v29)
            {
              uint64_t v30 = *(void *)(a3 + 56);
              uint64_t v31 = *(void *)(a3 + 8);
              uint64_t v32 = (_WORD *)(v30 + 2 * *(unsigned int *)(v31 + 24 * a2 + 8));
              int v33 = (unsigned __int16)*v32;
              unsigned __int16 v34 = v33 + a2;
              BOOL v29 = v33 == 0;
              BOOL v35 = *v32 == 0;
              if (!v29 && v28 != v34)
              {
                uint64_t v37 = v32 + 1;
                do
                {
                  int v39 = *v37++;
                  int v38 = v39;
                  v34 += v39;
                  BOOL v35 = v39 == 0;
                  if (!v39) {
                    uint64_t v37 = 0;
                  }
                  if (v38) {
                    BOOL v40 = v28 == v34;
                  }
                  else {
                    BOOL v40 = 1;
                  }
                }
                while (!v40);
              }
              if (!v35) {
                goto LABEL_84;
              }
              BOOL v41 = (_WORD *)(v30 + 2 * *(unsigned int *)(v31 + 24 * v28 + 8));
              int v42 = (unsigned __int16)*v41;
              unsigned __int16 v43 = v42 + v28;
              BOOL v29 = v42 == 0;
              BOOL v44 = *v41 != 0;
              if (!v29 && v43 != a2)
              {
                long long v46 = v41 + 1;
                do
                {
                  int v48 = *v46++;
                  int v47 = v48;
                  v43 += v48;
                  BOOL v44 = v48 != 0;
                  if (!v48) {
                    long long v46 = 0;
                  }
                  if (v47) {
                    BOOL v49 = v43 == a2;
                  }
                  else {
                    BOOL v49 = 1;
                  }
                }
                while (!v49);
              }
              if (v44)
              {
                if (v64 >= (unint64_t)HIDWORD(v64)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *((_DWORD *)v63 + v64) = v24;
                LODWORD(v64) = v64 + 1;
              }
            }
          }
        }
      }
      ++v24;
    }
    while (v24 != v23);
    unsigned int v50 = v64;
    if (!v64)
    {
      int v4 = a4;
      if (v25) {
        goto LABEL_85;
      }
      goto LABEL_82;
    }
    int v4 = a4;
    do
    {
      uint64_t v51 = *((unsigned int *)v63 + v50 - 1);
      uint64_t v52 = *((void *)this + 4);
      uint64_t v53 = (_DWORD *)(v52 + 32 * v51);
      if ((*v53 & 0x2000000) != 0)
      {
        if (v51 >= 2 && **((unsigned __int16 **)this + 2) - 3 >= 0xFFFFFFFE)
        {
          unsigned int v55 = *((_DWORD *)this + 10);
          if (v55 >= 3)
          {
            unsigned int v56 = 2;
            while (*(unsigned char *)(v52 + 32 * v56) == 1)
            {
              unsigned int v57 = v56;
              v56 += ((unsigned __int16)*(_DWORD *)(v52 + 32 * v56 + 16) >> 3) + 1;
              if (v56 > v51)
              {
                if ((v57 & 0x80000000) == 0) {
                  goto LABEL_64;
                }
                break;
              }
              if (v56 >= v55) {
                break;
              }
            }
          }
        }
        llvm::MachineInstr::removeOperand((char *)this, v51);
      }
      else
      {
LABEL_64:
        *v53 &= ~0x4000000u;
      }
      unsigned int v50 = v64 - 1;
      LODWORD(v64) = v64 - 1;
    }
    while (v64);
  }
  else
  {
    char v25 = 0;
  }
  if (v25) {
    goto LABEL_85;
  }
LABEL_82:
  if (v4)
  {
    uint64_t v60 = 0;
    uint64_t v61 = 0;
    uint64_t v62 = 0;
    v59[0] = 117440512;
    v59[1] = a2;
    llvm::MachineInstr::addOperand(this, *(llvm::MachineFunction **)(*((void *)this + 3) + 32), (const llvm::MachineOperand *)v59);
LABEL_84:
    char v25 = 1;
  }
LABEL_85:
  if (v63 != v65) {
    free(v63);
  }
  return v25 & 1;
}

uint64_t llvm::MachineInstr::clearRegisterDeads(uint64_t result, int a2)
{
  uint64_t v2 = *(unsigned int *)(result + 40);
  if (v2)
  {
    uint64_t v3 = *(_DWORD **)(result + 32);
    uint64_t v4 = 32 * v2;
    do
    {
      if ((*v3 & 0x10000FF) == 0x1000000 && v3[1] == a2) {
        *v3 &= ~0x4000000u;
      }
      v3 += 8;
      v4 -= 32;
    }
    while (v4);
  }
  return result;
}

uint64_t llvm::MachineInstr::setRegisterDefReadUndef(uint64_t result, int a2, int a3)
{
  uint64_t v3 = *(unsigned int *)(result + 40);
  if (v3)
  {
    uint64_t v4 = *(unsigned int **)(result + 32);
    uint64_t v5 = 32 * v3;
    do
    {
      unsigned int v6 = *v4;
      if ((*v4 & 0x10000FF) == 0x1000000 && (v6 & 0xFFF00) != 0 && v4[1] == a2)
      {
        if (a3) {
          int v8 = 0x10000000;
        }
        else {
          int v8 = 0;
        }
        *uint64_t v4 = v6 & 0xEFFFFFFF | v8;
      }
      v4 += 8;
      v5 -= 32;
    }
    while (v5);
  }
  return result;
}

void llvm::MachineInstr::addRegisterDefined(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (a2 - 1 > 0x3FFFFFFE)
  {
    uint64_t v5 = *(unsigned int *)(a1 + 40);
    if (!v5)
    {
LABEL_13:
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      v9[0] = 50331648;
      v9[1] = a2;
      llvm::MachineInstr::addOperand((llvm::MachineInstr *)a1, *(llvm::MachineFunction **)(*(void *)(a1 + 24) + 32), (const llvm::MachineOperand *)v9);
      return;
    }
    uint64_t v6 = 32 * v5;
    unsigned int v7 = (_DWORD *)(*(void *)(a1 + 32) + 4);
    while (*(v7 - 1) || (*(v7 - 1) & 0x10FFF00) != 0x1000000 || *v7 != a2)
    {
      v7 += 8;
      v6 -= 32;
      if (!v6) {
        goto LABEL_13;
      }
    }
  }
  else if (llvm::MachineInstr::findRegisterDefOperandIdx(a1, a2, 0, 0, a3) == -1 || !*(void *)(a1 + 32))
  {
    goto LABEL_13;
  }
}

void llvm::MachineInstr::setPhysRegsDeadExcept(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(unsigned int *)(a1 + 40);
  if (v4)
  {
    unsigned int v7 = *(int **)(a1 + 32);
    int v8 = &v7[8 * v4];
    unint64_t v9 = (void *)(a4 + 8);
    uint64_t v22 = 4 * a3;
    char v10 = 1;
LABEL_3:
    char v21 = v10;
    do
    {
      int v11 = *v7;
      if (*v7)
      {
        if (*v7 == 12)
        {
          char v10 = 0;
          v7 += 8;
          if (v7 != v8) {
            goto LABEL_3;
          }
          uint64_t v16 = a4;
          uint64_t v17 = a3;
          if (a3) {
            goto LABEL_22;
          }
          return;
        }
      }
      else if ((v11 & 0x1000000) != 0)
      {
        unsigned int v12 = v7[1];
        if (v12 - 1 <= 0x3FFFFFFE)
        {
          if (a3)
          {
            uint64_t v13 = v22;
            uint64_t v14 = a2;
            while (1)
            {
              unsigned int v15 = *v14;
              if (v12 == *v14 || v15 - 1 <= 0x3FFFFFFE && llvm::MCRegisterInfo::regsOverlap(v9, v15, v12)) {
                break;
              }
              ++v14;
              v13 -= 4;
              if (!v13) {
                goto LABEL_15;
              }
            }
          }
          else
          {
LABEL_15:
            *unsigned int v7 = v11 | 0x4000000;
          }
        }
      }
      v7 += 8;
    }
    while (v7 != v8);
    uint64_t v17 = a3;
    uint64_t v16 = a4;
    if (!(v21 & 1 | (a3 == 0)))
    {
LABEL_22:
      uint64_t v18 = 4 * v17;
      do
      {
        unsigned int v19 = *a2++;
        llvm::MachineInstr::addRegisterDefined(a1, v19, v16);
        v18 -= 4;
      }
      while (v18);
    }
  }
}

unint64_t llvm::MachineInstrExpressionTrait::getHashValue(llvm::MachineInstrExpressionTrait *this, const llvm::MachineInstr *const *a2)
{
  v9[16] = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)(*(void *)this + 40) + 1) > 0x10) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  v9[0] = **(unsigned __int16 **)(*(void *)this + 16);
  int v2 = 1;
  unsigned int v8 = 1;
  uint64_t v3 = *(unsigned int *)(*(void *)this + 40);
  if (v3)
  {
    uint64_t v4 = *(llvm **)(*(void *)this + 32);
    uint64_t v5 = 32 * v3;
    do
    {
      if ((*(_DWORD *)v4 & 0x10000FF) != 0x1000000 || (*((_DWORD *)v4 + 1) & 0x80000000) == 0)
      {
        uint64_t v6 = llvm::hash_value(v4, (const llvm::MachineOperand *)a2);
        if (v8 >= 0x10uLL) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        v9[v8] = v6;
        int v2 = ++v8;
      }
      uint64_t v4 = (llvm *)((char *)v4 + 32);
      v5 -= 32;
    }
    while (v5);
  }
  return sub_1CC13A6B8(v9, (uint64_t)&v9[v2]);
}

llvm::MachineFunction *llvm::BuildMI(llvm::MachineFunction *a1, unsigned __int8 **a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13 = *a2;
  *(void *)&long long v16 = v13;
  if (v13) {
    llvm::MetadataTracking::track((uint64_t)&v16, v13, 2);
  }
  MachineInstr = llvm::MachineFunction::CreateMachineInstr(a1, a3, (unsigned __int8 **)&v16, 0);
  if ((void)v16) {
    llvm::MetadataTracking::untrack((uint64_t)&v16, (unsigned __int8 *)v16);
  }
  *((void *)&v16 + 1) = 0;
  long long v17 = 0uLL;
  LODWORD(v16) = 0;
  DWORD1(v16) = a5;
  llvm::MachineInstr::addOperand(MachineInstr, a1, (const llvm::MachineOperand *)&v16);
  if (a4)
  {
    LODWORD(v16) = 1;
    *((void *)&v16 + 1) = 0;
    *(void *)&long long v17 = 0;
  }
  else
  {
    long long v16 = 0u;
    long long v17 = 0u;
  }
  llvm::MachineInstr::addOperand(MachineInstr, a1, (const llvm::MachineOperand *)&v16);
  LODWORD(v16) = 14;
  *((void *)&v16 + 1) = 0;
  *(void *)&long long v17 = a6;
  llvm::MachineInstr::addOperand(MachineInstr, a1, (const llvm::MachineOperand *)&v16);
  LODWORD(v16) = 14;
  *((void *)&v16 + 1) = 0;
  *(void *)&long long v17 = a7;
  llvm::MachineInstr::addOperand(MachineInstr, a1, (const llvm::MachineOperand *)&v16);
  return a1;
}

llvm::MachineFunction *llvm::BuildMI(llvm::MachineFunction *a1, unsigned __int8 **a2, uint64_t a3, int a4, const llvm::MachineOperand *a5, uint64_t a6, uint64_t a7)
{
  if (*(unsigned char *)a5)
  {
    unsigned int v15 = *a2;
    *(void *)&long long v17 = v15;
    if (v15) {
      llvm::MetadataTracking::track((uint64_t)&v17, v15, 2);
    }
    MachineInstr = llvm::MachineFunction::CreateMachineInstr(a1, a3, (unsigned __int8 **)&v17, 0);
    if ((void)v17) {
      llvm::MetadataTracking::untrack((uint64_t)&v17, (unsigned __int8 *)v17);
    }
    llvm::MachineInstr::addOperand(MachineInstr, a1, a5);
    if (a4)
    {
      LODWORD(v17) = 1;
      *((void *)&v17 + 1) = 0;
      *(void *)&long long v18 = 0;
    }
    else
    {
      long long v17 = 0u;
      long long v18 = 0u;
    }
    llvm::MachineInstr::addOperand(MachineInstr, a1, (const llvm::MachineOperand *)&v17);
    LODWORD(v17) = 14;
    *((void *)&v17 + 1) = 0;
    *(void *)&long long v18 = a6;
    llvm::MachineInstr::addOperand(MachineInstr, a1, (const llvm::MachineOperand *)&v17);
    LODWORD(v17) = 14;
    *((void *)&v17 + 1) = 0;
    *(void *)&long long v18 = a7;
    llvm::MachineInstr::addOperand(MachineInstr, a1, (const llvm::MachineOperand *)&v17);
    return a1;
  }
  else
  {
    int v13 = *((_DWORD *)a5 + 1);
    return llvm::BuildMI(a1, a2, a3, a4, v13, a6, a7);
  }
}

llvm::MachineFunction *llvm::BuildMI(llvm::MachineFunction *a1, unsigned __int8 **a2, _WORD *a3, int a4, const llvm::MachineOperand *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a3 == 13)
  {
    return llvm::BuildMI(a1, a2, (uint64_t)a3, a4, a5, a7, a8);
  }
  else
  {
    int v20 = a5;
    unsigned int v12 = sub_1CC34E910(a1, a2, (uint64_t)a3);
    uint64_t v14 = v13;
    v21[0] = 14;
    uint64_t v22 = 0;
    uint64_t v23 = a7;
    llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)v21);
    v21[0] = 14;
    uint64_t v22 = 0;
    uint64_t v23 = a8;
    llvm::MachineInstr::addOperand(v14, v12, (const llvm::MachineOperand *)v21);
    if (a6)
    {
      uint64_t v15 = 32 * a6;
      do
      {
        if (*(unsigned char *)v20)
        {
          long long v16 = v14;
          long long v17 = v12;
          long long v18 = v20;
        }
        else
        {
          int v19 = *((_DWORD *)v20 + 1);
          uint64_t v22 = 0;
          v21[0] = 0;
          v21[1] = v19;
          uint64_t v23 = 0;
          uint64_t v24 = 0;
          long long v18 = (const llvm::MachineOperand *)v21;
          long long v16 = v14;
          long long v17 = v12;
        }
        llvm::MachineInstr::addOperand(v16, v17, v18);
        int v20 = (llvm::MachineOperand *)((char *)v20 + 32);
        v15 -= 32;
      }
      while (v15);
    }
    return v12;
  }
}

llvm::MachineFunction *llvm::BuildMI(uint64_t a1, unint64_t *a2, unsigned __int8 **a3, _WORD *a4, int a5, const llvm::MachineOperand *a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v11 = *(llvm::MachineFunction **)(a1 + 32);
  llvm::BuildMI(v11, a3, a4, a5, a6, a7, a8, a9);
  int v13 = (unint64_t *)v12;
  uint64_t v14 = *(void *)(a1 + 40);
  *(void *)(v12 + 24) = v14;
  uint64_t v15 = *(void *)(v14 + 32);
  uint64_t v16 = *(unsigned int *)(v12 + 40);
  if (v16)
  {
    uint64_t v20 = *(void *)(v12 + 32);
    uint64_t v21 = *(void *)(v15 + 40);
    uint64_t v22 = 32 * v16;
    do
    {
      if (!*(unsigned char *)v20)
      {
        uint64_t v23 = *(unsigned int *)(v20 + 4);
        if ((int)v23 >= 0) {
          uint64_t v24 = (uint64_t *)(*(void *)(v21 + 272) + 8 * v23);
        }
        else {
          uint64_t v24 = (uint64_t *)(*(void *)(v21 + 24) + 16 * (v23 & 0x7FFFFFFF) + 8);
        }
        uint64_t v25 = *v24;
        if (*v24)
        {
          uint64_t v26 = *(void *)(v25 + 16);
          *(void *)(v25 + 16) = v20;
          *(void *)(v20 + 16) = v26;
          if (*(unsigned char *)(v20 + 3))
          {
            *(void *)(v20 + 24) = v25;
          }
          else
          {
            *(void *)(v20 + 24) = 0;
            uint64_t v24 = (uint64_t *)(v26 + 24);
          }
        }
        else
        {
          *(void *)(v20 + 16) = v20;
          *(void *)(v20 + 24) = 0;
        }
        *uint64_t v24 = v20;
      }
      v20 += 32;
      v22 -= 32;
    }
    while (v22);
  }
  uint64_t v17 = *(void *)(v15 + 728);
  if (v17) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 24))(v17, v12);
  }
  unint64_t v18 = *a2 & 0xFFFFFFFFFFFFFFF8;
  *int v13 = v18 | *v13 & 7;
  v13[1] = (unint64_t)a2;
  *(void *)(v18 + 8) = v13;
  *a2 = *a2 & 7 | (unint64_t)v13;
  return v11;
}

llvm::DIExpression *sub_1CC3560C4(uint64_t a1, int a2)
{
  void v21[6] = *MEMORY[0x1E4F143B8];
  int v19 = v21;
  uint64_t v20 = 0x600000000;
  sub_1CD535D4C(v13, a1, a2);
  uint64_t v9 = v13[0];
  uint64_t v10 = v13[1];
  if (v15)
  {
    if (v15 == &v14)
    {
      uint64_t v12 = v11;
      (*(void (**)(void))(*v15 + 24))();
    }
    else
    {
      uint64_t v12 = (void *)(*(uint64_t (**)(void))(*v15 + 16))();
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  uint64_t v6 = v16;
  if (v18)
  {
    if (v18 == &v17)
    {
      unsigned int v8 = v7;
      (*(void (**)(void))(*v18 + 24))();
    }
    else
    {
      unsigned int v8 = (void *)(*(uint64_t (**)(void))(*v18 + 16))();
    }
  }
  else
  {
    unsigned int v8 = 0;
  }
LABEL_11:
  uint64_t v3 = v9;
  while (v3 != v6)
  {
    if (v20 >= (unint64_t)HIDWORD(v20)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    v19[v20] = v3;
    LODWORD(v20) = v20 + 1;
    while (1)
    {
      uint64_t v3 = v9 + 32;
      uint64_t v9 = v3;
      if (v3 == v10) {
        break;
      }
      if (!v12) {
        sub_1CB920400();
      }
      if ((*(unsigned int (**)(void *, uint64_t))(*v12 + 48))(v12, v3)) {
        goto LABEL_11;
      }
    }
  }
  if (v8 == v7)
  {
    (*(void (**)(void *))(v7[0] + 32))(v7);
  }
  else if (v8)
  {
    (*(void (**)(void))(*v8 + 40))();
  }
  if (v12 == v11)
  {
    (*(void (**)(void *))(v11[0] + 32))(v11);
  }
  else if (v12)
  {
    (*(void (**)(void))(*v12 + 40))();
  }
  sub_1CD5363F0(v13);
  uint64_t v4 = sub_1CC3563EC(a1, v19, v20);
  if (v19 != v21) {
    free(v19);
  }
  return v4;
}

llvm::DIExpression *sub_1CC3563EC(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  int v4 = **(unsigned __int16 **)(a1 + 16);
  uint64_t v5 = *(unsigned char **)(a1 + 32);
  uint64_t v6 = 96;
  if (v4 == 14) {
    uint64_t v6 = 32;
  }
  BOOL result = *(llvm::DIExpression **)&v5[v6 + 16];
  if (v4 == 13)
  {
    if (v5[32] == 1 && !*v5)
    {
      return llvm::DIExpression::prepend(result, (const llvm::DIExpression *)1, 0);
    }
  }
  else if (v4 == 14)
  {
    uint64_t v11 = 6;
    if (a3)
    {
      uint64_t v9 = 8 * a3;
      do
      {
        uint64_t v10 = *a2++;
        BOOL result = llvm::DIExpression::appendOpsToArg(result, &v11, 1, (v10 - (*(void *)(a1 + 32) + ((unint64_t)(**(_WORD **)(a1 + 16) == 14) << 6))) >> 5, 0);
        v9 -= 8;
      }
      while (v9);
    }
  }
  return result;
}

void *llvm::updateDbgValueForSpill(uint64_t a1, int a2, int a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = sub_1CC3560C4(a1, a3);
  if (**(_WORD **)(a1 + 16) == 13) {
    llvm::MachineOperand::ChangeToImmediate((unsigned int *)(*(void *)(a1 + 32) + 32), 0, 0);
  }
  sub_1CD5364DC(a1, a3, v18);
  uint64_t v14 = (llvm::MachineOperand *)v18[0];
  uint64_t v15 = (llvm::MachineOperand *)v18[1];
  if (v20)
  {
    if (v20 == &v19)
    {
      uint64_t v17 = v16;
      (*(void (**)(void))(*v20 + 24))();
    }
    else
    {
      uint64_t v17 = (void *)(*(uint64_t (**)(void))(*v20 + 16))();
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  uint64_t v11 = v21;
  if (v23)
  {
    if (v23 == &v22)
    {
      int v13 = v12;
      (*(void (**)(void))(*v23 + 24))();
    }
    else
    {
      int v13 = (void *)(*(uint64_t (**)(void))(*v23 + 16))();
    }
  }
  else
  {
    int v13 = 0;
  }
  unsigned int v7 = v14;
  while (v7 != v11)
  {
    llvm::MachineOperand::removeRegFromUses(v7);
    int v8 = *(_DWORD *)v7;
    *((_DWORD *)v7 + 4) = a2;
    *(_DWORD *)unsigned int v7 = v8 & 0xFFF00000 | 5;
    while (1)
    {
      unsigned int v7 = (llvm::MachineOperand *)((char *)v14 + 32);
      uint64_t v14 = v7;
      if (v7 == v15) {
        break;
      }
      if (!v17) {
        sub_1CB920400();
      }
      if ((*(unsigned int (**)(void *, llvm::MachineOperand *))(*v17 + 48))(v17, v7))
      {
        unsigned int v7 = v14;
        break;
      }
    }
  }
  if (v13 == v12)
  {
    (*(void (**)(void *))(v12[0] + 32))(v12);
  }
  else if (v13)
  {
    (*(void (**)(void))(*v13 + 40))();
  }
  if (v17 == v16)
  {
    (*(void (**)(void *))(v16[0] + 32))(v16);
  }
  else if (v17)
  {
    (*(void (**)(void))(*v17 + 40))();
  }
  BOOL result = sub_1CD536B84(v18);
  uint64_t v10 = 96;
  if (**(_WORD **)(a1 + 16) == 14) {
    uint64_t v10 = 32;
  }
  *(void *)(*(void *)(a1 + 32) + v10 + 16) = v6;
  return result;
}

uint64_t llvm::MachineInstr::collectDebugValues(uint64_t result, uint64_t a2)
{
  if (!**(unsigned char **)(result + 32))
  {
    uint64_t v2 = result;
    if ((*(unsigned char *)result & 4) == 0)
    {
      uint64_t v2 = result;
      if ((*(_WORD *)(result + 44) & 8) != 0)
      {
        uint64_t v2 = result;
        do
          uint64_t v2 = *(void *)(v2 + 8);
        while ((*(_WORD *)(v2 + 44) & 8) != 0);
      }
    }
    uint64_t v3 = *(void *)(v2 + 8);
    for (i = *(void *)(result + 24) + 48; v3 != i; uint64_t v3 = *(void *)(v3 + 8))
    {
      int v5 = **(unsigned __int16 **)(v3 + 16);
      if ((v5 - 13) > 1) {
        break;
      }
      uint64_t v6 = *(void *)(v3 + 32);
      if (v5 != 14)
      {
        uint64_t v8 = v6 + 32;
        goto LABEL_13;
      }
      uint64_t v7 = *(unsigned int *)(v3 + 40);
      if (v7 != 2)
      {
        uint64_t v8 = v6 + 32 * v7;
        v6 += 64;
LABEL_13:
        while (*(unsigned char *)v6 || *(_DWORD *)(v6 + 4) != *(_DWORD *)(*(void *)(result + 32) + 4))
        {
          v6 += 32;
          if (v6 == v8)
          {
            if (v3) {
              goto LABEL_20;
            }
            goto LABEL_23;
          }
        }
        unint64_t v9 = *(unsigned int *)(a2 + 8);
        if (v9 >= *(unsigned int *)(a2 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a2 + 8 * v9) = v3;
        ++*(_DWORD *)(a2 + 8);
        if (!v3) {
          goto LABEL_23;
        }
      }
LABEL_20:
      if ((*(unsigned char *)v3 & 4) == 0)
      {
LABEL_23:
        while ((*(_WORD *)(v3 + 44) & 8) != 0)
          uint64_t v3 = *(void *)(v3 + 8);
      }
    }
  }
  return result;
}

void llvm::MachineInstr::changeDebugValuesDefReg(uint64_t a1, unsigned int a2)
{
  v32[2] = *MEMORY[0x1E4F143B8];
  uint64_t v30 = v32;
  uint64_t v31 = 0x200000000;
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)v2)
  {
    uint64_t v3 = *(unsigned int *)(v2 + 4);
    int v4 = *(void **)(a1 + 24);
    if (v4) {
      int v4 = *(void **)(v4[4] + 40);
    }
    if ((v3 & 0x80000000) != 0) {
      int v5 = (uint64_t *)(v4[3] + 16 * (v3 & 0x7FFFFFFF) + 8);
    }
    else {
LABEL_59:
    }
      int v5 = (uint64_t *)(v4[34] + 8 * v3);
    uint64_t v6 = *v5;
    if (*v5)
    {
      while ((*(unsigned char *)(v6 + 3) & 1) != 0)
      {
        uint64_t v6 = *(void *)(v6 + 24);
        if (!v6) {
          return;
        }
      }
      unsigned int v7 = 0;
LABEL_11:
      uint64_t v8 = *(void *)(v6 + 8);
      int v9 = **(unsigned __int16 **)(v8 + 16);
      if ((v9 - 13) > 1) {
        goto LABEL_22;
      }
      uint64_t v10 = *(void *)(v8 + 32);
      if (v9 == 14)
      {
        uint64_t v11 = *(unsigned int *)(v8 + 40);
        if (v11 == 2) {
          goto LABEL_22;
        }
        uint64_t v12 = v10 + 32 * v11;
        v10 += 64;
      }
      else
      {
        uint64_t v12 = v10 + 32;
      }
      while (*(unsigned char *)v10 || *(_DWORD *)(v10 + 4) != v3)
      {
        v10 += 32;
        if (v10 == v12) {
          goto LABEL_22;
        }
      }
      if (v7 >= HIDWORD(v31)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v30[v7] = v8;
      unsigned int v7 = v31 + 1;
      LODWORD(v31) = v31 + 1;
LABEL_22:
      while (1)
      {
        uint64_t v6 = *(void *)(v6 + 24);
        if (!v6) {
          break;
        }
        if ((*(unsigned char *)(v6 + 3) & 1) == 0) {
          goto LABEL_11;
        }
      }
      int v13 = v30;
      if (v7)
      {
        unsigned int v14 = a2;
        uint64_t v15 = &v30[v7];
        do
        {
          sub_1CD5364DC(*v13, v3, v24);
          uint64_t v20 = v24[0];
          uint64_t v21 = v24[1];
          if (v26)
          {
            if (v26 == v25)
            {
              uint64_t v23 = v22;
              (*(void (**)(void *, void *))(v25[0] + 24))(v25, v22);
            }
            else
            {
              uint64_t v23 = (void *)(*(uint64_t (**)(void))(*v26 + 16))();
            }
          }
          else
          {
            uint64_t v23 = 0;
          }
          uint64_t v17 = v27;
          if (v29)
          {
            if (v29 == v28)
            {
              uint64_t v19 = v18;
              (*(void (**)(void *, void *))(v28[0] + 24))(v28, v18);
            }
            else
            {
              uint64_t v19 = (void *)(*(uint64_t (**)(void))(*v29 + 16))();
            }
          }
          else
          {
            uint64_t v19 = 0;
          }
LABEL_38:
          uint64_t v16 = v20;
          while (v16 != v17)
          {
            llvm::MachineOperand::setReg(v16, v14);
            while (1)
            {
              uint64_t v16 = v20 + 32;
              uint64_t v20 = v16;
              if (v16 == v21) {
                break;
              }
              if (!v23)
              {
                sub_1CB920400();
                goto LABEL_59;
              }
              if ((*(unsigned int (**)(void *))(*v23 + 48))(v23)) {
                goto LABEL_38;
              }
            }
          }
          if (v19 == v18)
          {
            (*(void (**)(void *))(v18[0] + 32))(v18);
          }
          else if (v19)
          {
            (*(void (**)(void))(*v19 + 40))();
          }
          if (v23 == v22)
          {
            (*(void (**)(void *))(v22[0] + 32))(v22);
          }
          else if (v23)
          {
            (*(void (**)(void))(*v23 + 40))();
          }
          sub_1CD536B84(v24);
          ++v13;
        }
        while (v13 != v15);
        int v13 = v30;
      }
      if (v13 != v32) {
        free(v13);
      }
    }
  }
}

uint64_t llvm::MachineInstr::getSpillSize(llvm::MachineInstr *this, const llvm::TargetInstrInfo *a2)
{
  int v11 = 0;
  if ((*(unsigned int (**)(const llvm::TargetInstrInfo *, llvm::MachineInstr *, int *))(*(void *)a2 + 112))(a2, this, &v11)&& (uint64_t v7 = *(void *)(*(void *)(*((void *)this + 3) + 32) + 56), *(unsigned char *)(*(void *)(v7 + 8) + 40 * (*(_DWORD *)(v7 + 32) + v11) + 18)))
  {
    uint64_t v8 = *((void *)this + 6);
    if ((v8 & 7) != 0)
    {
      unint64_t v9 = *(void *)((v8 & 0xFFFFFFFFFFFFFFF8) + 8);
    }
    else
    {
      unint64_t v9 = v8 & 0xFFFFFFFFFFFFFFF8;
      *((void *)this + 6) = v8 & 0xFFFFFFFFFFFFFFF8;
    }
    int v10 = sub_1CB8F20C0(v9);
    uint64_t v5 = v10 & 0xFFFFFF00;
    uint64_t v3 = v10;
    uint64_t v4 = 0x100000000;
  }
  else
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    uint64_t v5 = 0;
  }
  return v4 | v3 | v5;
}

uint64_t llvm::MachineInstr::getFoldedSpillSize(llvm::MachineInstr *this, const llvm::TargetInstrInfo *a2)
{
  _OWORD v11[2] = *MEMORY[0x1E4F143B8];
  v10[0] = v11;
  v10[1] = (void *)0x200000000;
  if ((*(unsigned int (**)(const llvm::TargetInstrInfo *, llvm::MachineInstr *, void **))(*(void *)a2 + 120))(a2, this, v10))
  {
    int v7 = sub_1CC356F78((uint64_t)v10, *(void *)(*(void *)(*((void *)this + 3) + 32) + 56));
    unsigned int v5 = v7 & 0xFFFFFF00;
    int v3 = v7;
    uint64_t v4 = 0x100000000;
  }
  else
  {
    int v3 = 0;
    uint64_t v4 = 0;
    unsigned int v5 = 0;
  }
  if (v10[0] != v11)
  {
    uint64_t v9 = v4;
    unsigned int v8 = v5;
    free(v10[0]);
    unsigned int v5 = v8;
    uint64_t v4 = v9;
  }
  return v4 | v5 | v3;
}

uint64_t sub_1CC356F78(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v4 = 0;
  unsigned int v5 = *(void **)a1;
  uint64_t v6 = 8 * v2;
  do
  {
    int v7 = (void *)*v5;
    if (*(unsigned char *)(*(void *)(a2 + 8)
                  + 40
                  * (*(_DWORD *)(a2 + 32)
                                 + *(_DWORD *)((*(void *)*v5 & ((uint64_t)(*(void *)*v5 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8)
                                             + 0x10))
                  + 18))
    {
      uint64_t v9 = v7[3];
      unsigned int v8 = v7 + 3;
      if ((v9 & 0xFFFFFFFFFFFFFFF9) != 0)
      {
        unint64_t v11 = (unint64_t)(sub_1CB8F1DC4(v8) + 7) >> 3;
        if (v10 == 1)
        {
          int v13 = v11;
          LODWORD(v11) = v13;
        }
      }
      else
      {
        LODWORD(v11) = -1;
      }
      uint64_t v4 = (v4 + v11);
    }
    ++v5;
    v6 -= 8;
  }
  while (v6);
  return v4;
}

uint64_t llvm::MachineInstr::getRestoreSize(llvm::MachineInstr *this, const llvm::TargetInstrInfo *a2)
{
  int v11 = 0;
  if ((*(unsigned int (**)(const llvm::TargetInstrInfo *, llvm::MachineInstr *, int *))(*(void *)a2 + 80))(a2, this, &v11)&& (uint64_t v7 = *(void *)(*(void *)(*((void *)this + 3) + 32) + 56), *(unsigned char *)(*(void *)(v7 + 8) + 40 * (*(_DWORD *)(v7 + 32) + v11) + 18)))
  {
    uint64_t v8 = *((void *)this + 6);
    if ((v8 & 7) != 0)
    {
      unint64_t v9 = *(void *)((v8 & 0xFFFFFFFFFFFFFFF8) + 8);
    }
    else
    {
      unint64_t v9 = v8 & 0xFFFFFFFFFFFFFFF8;
      *((void *)this + 6) = v8 & 0xFFFFFFFFFFFFFFF8;
    }
    int v10 = sub_1CB8F20C0(v9);
    uint64_t v5 = v10 & 0xFFFFFF00;
    uint64_t v3 = v10;
    uint64_t v4 = 0x100000000;
  }
  else
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    uint64_t v5 = 0;
  }
  return v4 | v3 | v5;
}

uint64_t llvm::MachineInstr::getDebugInstrNum(llvm::MachineInstr *this, llvm::MachineFunction *a2)
{
  uint64_t result = *((unsigned int *)this + 16);
  if (!result)
  {
    uint64_t result = (*((_DWORD *)a2 + 228) + 1);
    *((_DWORD *)a2 + 228) = result;
    *((_DWORD *)this + 16) = result;
  }
  return result;
}

void *sub_1CC357150(uint64_t *a1, unsigned __int8 a2, uint64_t *__sz)
{
  if (*((_DWORD *)a1 + 2) <= a2) {
    return (void *)sub_1CB906F34(__sz, 32 << a2, 3);
  }
  uint64_t v3 = *a1;
  uint64_t result = *(void **)(*a1 + 8 * a2);
  if (!result) {
    return (void *)sub_1CB906F34(__sz, 32 << a2, 3);
  }
  *(void *)(v3 + 8 * a2) = *result;
  return result;
}

uint64_t sub_1CC35718C(void *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  sub_1CC300F30((uint64_t)v15, a3);
  sub_1CD536290(v17, v6, v7, (uint64_t)v15);
  uint64_t v8 = a2[1];
  sub_1CC300F30((uint64_t)v10, a3);
  sub_1CD536290(v12, v8, v8, (uint64_t)v10);
  sub_1CD535F9C(a1, v17, v12);
  if (v14 == v13)
  {
    (*(void (**)(void *))(v13[0] + 32))(v13);
  }
  else if (v14)
  {
    (*(void (**)(void))(*v14 + 40))();
  }
  if (v11 == v10)
  {
    (*(void (**)(void *))(v10[0] + 32))(v10);
  }
  else if (v11)
  {
    (*(void (**)(void))(*v11 + 40))();
  }
  if (v19 == v18)
  {
    (*(void (**)(void *))(v18[0] + 32))(v18);
  }
  else if (v19)
  {
    (*(void (**)(void *))(*v19 + 40))(v19);
  }
  uint64_t result = (uint64_t)v16;
  if (v16 == v15) {
    return (*(uint64_t (**)(void *))(v15[0] + 32))(v15);
  }
  if (v16) {
    return (*(uint64_t (**)(void))(*v16 + 40))();
  }
  return result;
}

uint64_t sub_1CC3573E8(uint64_t result)
{
  if (*(void *)result != *(void *)(result + 8))
  {
    uint64_t v1 = (void *)result;
    while (1)
    {
      uint64_t v2 = v1[5];
      if (!v2) {
        break;
      }
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 48))(v2);
      if ((result & 1) == 0)
      {
        uint64_t v3 = v1[1];
        uint64_t v4 = *v1 + 32;
        *uint64_t v1 = v4;
        if (v4 != v3) {
          continue;
        }
      }
      return result;
    }
    sub_1CB920400();
    return sub_1CC35745C();
  }
  return result;
}

uint64_t sub_1CC35745C@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a1;
  uint64_t v7 = a1[1];
  sub_1CC357728((uint64_t)v15, a2);
  sub_1CD536A24(v17, v6, v7, (uint64_t)v15);
  uint64_t v8 = a1[1];
  sub_1CC357728((uint64_t)v10, a2);
  sub_1CD536A24(v12, v8, v8, (uint64_t)v10);
  sub_1CD53672C(v17, v12, a3);
  if (v14 == v13)
  {
    (*(void (**)(void *))(v13[0] + 32))(v13);
  }
  else if (v14)
  {
    (*(void (**)(void))(*v14 + 40))();
  }
  if (v11 == v10)
  {
    (*(void (**)(void *))(v10[0] + 32))(v10);
  }
  else if (v11)
  {
    (*(void (**)(void))(*v11 + 40))();
  }
  if (v19 == v18)
  {
    (*(void (**)(void *))(v18[0] + 32))(v18);
  }
  else if (v19)
  {
    (*(void (**)(void *))(*v19 + 40))(v19);
  }
  uint64_t result = (uint64_t)v16;
  if (v16 == v15) {
    return (*(uint64_t (**)(void *))(v15[0] + 32))(v15);
  }
  if (v16) {
    return (*(uint64_t (**)(void))(*v16 + 40))();
  }
  return result;
}

uint64_t sub_1CC3576B4(uint64_t result)
{
  if (*(void *)result != *(void *)(result + 8))
  {
    uint64_t v1 = (void *)result;
    while (1)
    {
      uint64_t v2 = v1[5];
      if (!v2) {
        break;
      }
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 48))(v2);
      if ((result & 1) == 0)
      {
        uint64_t v3 = v1[1];
        uint64_t v4 = *v1 + 32;
        *uint64_t v1 = v4;
        if (v4 != v3) {
          continue;
        }
      }
      return result;
    }
    sub_1CB920400();
    return sub_1CC357728(v5, v6);
  }
  return result;
}

uint64_t sub_1CC357728(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_1CC3577C0(llvm *a1)
{
  llvm::initializeMachineLoopInfoPass((uint64_t)a1);
  llvm::initializeMachineBlockFrequencyInfoPass(a1, v2);
  llvm::initializeMachineDominatorTreePass((uint64_t)a1);
  llvm::initializeAAResultsWrapperPassPass(a1, v3);
  operator new();
}

void sub_1CC357878(llvm *a1)
{
  llvm::initializeMachineLoopInfoPass((uint64_t)a1);
  llvm::initializeMachineBlockFrequencyInfoPass(a1, v2);
  llvm::initializeMachineDominatorTreePass((uint64_t)a1);
  llvm::initializeAAResultsWrapperPassPass(a1, v3);
  operator new();
}

void sub_1CC357930()
{
}

double sub_1CC3579F8(uint64_t a1, uint64_t a2, char a3)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = a1 + 48;
  *(void *)(a1 + 40) = 0x600000001;
  *(_DWORD *)(a1 + 96) = 11;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 104) = a1 + 120;
  *(void *)(a1 + 112) = 0x600000001;
  *(_DWORD *)(a1 + 1sub_1CC338288((_DWORD *)this + 68) = 11;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 176) = a1 + 192;
  *(void *)(a1 + 184) = 0x600000001;
  *(_DWORD *)(a1 + 240) = 11;
  *(void *)a1 = &unk_1F260E718;
  *(void *)(a1 + 352) = 0;
  *(_OWORD *)(a1 + 320) = xmmword_1CFB28DF0;
  *(_OWORD *)(a1 + 336) = unk_1CFB28E00;
  *(_OWORD *)(a1 + 288) = llvm::MCSchedModel::Default;
  *(_OWORD *)(a1 + 304) = unk_1CFB28DE0;
  *(_OWORD *)(a1 + 360) = llvm::MCSchedModel::Default;
  *(void *)(a1 + 424) = 0;
  *(_OWORD *)(a1 + 408) = unk_1CFB28E00;
  *(_OWORD *)(a1 + 392) = xmmword_1CFB28DF0;
  *(_OWORD *)(a1 + 376) = unk_1CFB28DE0;
  double result = 0.0;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(void *)(a1 + 480) = a1 + 496;
  *(void *)(a1 + 488) = 0x1000000000;
  *(void *)(a1 + 560) = 0;
  *(unsigned char *)(a1 + 5sub_1CC338288((_DWORD *)this + 68) = a3;
  *(void *)(a1 + 632) = a1 + 648;
  *(void *)(a1 + 640) = 0x800000000;
  *(void *)(a1 + 712) = a1 + 728;
  *(void *)(a1 + 720) = 0x2000000000;
  *(_OWORD *)(a1 + 864) = 0u;
  *(void *)(a1 + 856) = a1 + 864;
  *(void *)(a1 + 880) = a1 + 896;
  *(void *)(a1 + 888) = 0x800000000;
  *(void *)(a1 + 928) = a1 + 944;
  *(void *)(a1 + 936) = 0x800000000;
  *(void *)(a1 + 976) = a1 + 992;
  *(void *)(a1 + 984) = 0x1000000000;
  *(_DWORD *)(a1 + 1776) = 0;
  *(_OWORD *)(a1 + 1760) = 0u;
  return result;
}

void sub_1CC357B30(uint64_t a1)
{
  sub_1CC35A924(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC357B68(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineLoopInfo::ID);
  if (dword_1EBCCEEA8) {
    sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineBlockFrequencyInfo::ID);
  }
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineDominatorTree::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::AAResultsWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::MachineLoopInfo::ID);

  llvm::MachineFunctionPass::getAnalysisUsage(a1, a2);
}

void sub_1CC357C10(uint64_t a1)
{
  *(_DWORD *)(a1 + 720) = 0;
  sub_1CB833A08(a1 + 856, *(void **)(a1 + 864));
  *(void *)(a1 + 856) = a1 + 864;
  *(void *)(a1 + 872) = 0;
  *(void *)(a1 + 864) = 0;
  *(_DWORD *)(a1 + 888) = 0;
  *(_DWORD *)(a1 + 936) = 0;
  uint64_t v2 = *(unsigned int *)(a1 + 984);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 976);
    uint64_t v4 = 48 * v2;
    do
    {
      uint64_t v5 = *(void **)(v3 + v4 - 48);
      if ((void *)(v3 + v4 - 32) != v5) {
        free(v5);
      }
      v4 -= 48;
    }
    while (v4);
  }
  *(_DWORD *)(a1 + 984) = 0;

  sub_1CD53711C((unsigned int *)(a1 + 1760));
}

BOOL sub_1CC357CAC(uint64_t a1, uint64_t a2)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (llvm::FunctionPass::skipFunction((llvm::FunctionPass *)a1, *(llvm::LLVMContextImpl *****)a2)) {
    return 0;
  }
  uint64_t v4 = *(llvm::Module **)(*(void *)a2 + 40);
  BOOL v41 = "agx.reduce.reg.pressure";
  __int16 v43 = 259;
  uint64_t NamedMetadata = llvm::Module::getNamedMetadata(v4, (const char **)&v41);
  if (!NamedMetadata) {
    goto LABEL_7;
  }
  uint64_t v6 = *(void *)(*(void *)(***(void ***)(NamedMetadata + 48)
                             - 8 * *(unsigned int *)(***(void ***)(NamedMetadata + 48) + 8))
                 + 128);
  uint64_t v7 = (void *)(v6 + 24);
  if (*(_DWORD *)(v6 + 32) >= 0x41u) {
    uint64_t v7 = (void *)*v7;
  }
  if (*v7) {
    return 0;
  }
LABEL_7:
  *(_WORD *)(a1 + 608) = 0;
  unint64_t v9 = *(const llvm::TargetSubtargetInfo **)(a2 + 16);
  *(void *)(a1 + 248) = (*(uint64_t (**)(const llvm::TargetSubtargetInfo *))(*(void *)v9 + 104))(v9);
  *(void *)(a1 + 256) = (*(uint64_t (**)(const llvm::TargetSubtargetInfo *))(*(void *)v9 + 120))(v9);
  *(void *)(a1 + 264) = (*(uint64_t (**)(const llvm::TargetSubtargetInfo *))(*(void *)v9 + 176))(v9);
  *(void *)(a1 + 272) = *(void *)(a2 + 56);
  *(void *)(a1 + 280) = *(void *)(a2 + 40);
  llvm::TargetSchedModel::init((llvm::TargetSchedModel *)(a1 + 288), v9);
  *(unsigned char *)(a1 + 5sub_1CC338288((_DWORD *)this + 68) = **(unsigned char **)(**(void **)(a1 + 280) + 360) & 1;
  llvm::Function::getEntryCount(*(uint64_t ****)a2, 0, (uint64_t)&v41);
  *(unsigned char *)(a1 + 569) = v42;
  if (*(unsigned char *)(a1 + 568))
  {
    unsigned int v10 = (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 296))(*(void *)(a1 + 264));
    unsigned int v11 = v10;
    uint64_t v12 = (void **)(a1 + 880);
    uint64_t v13 = v10;
    unsigned int v14 = *(_DWORD *)(a1 + 888);
    if (v14 != v10)
    {
      if (v14 <= v10)
      {
        if (*(_DWORD *)(a1 + 892) < v10) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v14 != v10) {
          bzero((char *)*v12 + 4 * v14, 4 * (v10 - (unint64_t)v14));
        }
      }
      *(_DWORD *)(a1 + 888) = v11;
    }
    if (v11) {
      bzero(*v12, 4 * v13);
    }
    unsigned int v15 = *(_DWORD *)(a1 + 936);
    if (v15 != v11)
    {
      if (v15 <= v11)
      {
        if (*(_DWORD *)(a1 + 940) < v11) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v15 != v11) {
          bzero((void *)(*(void *)(a1 + 928) + 4 * v15), 4 * (v13 - v15));
        }
      }
      *(_DWORD *)(a1 + 936) = v11;
    }
    if (v11)
    {
      uint64_t v16 = 0;
      do
      {
        *(_DWORD *)(*(void *)(a1 + 928) + 4 * v16) = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 264) + 312))(*(void *)(a1 + 264), a2, v16);
        ++v16;
      }
      while (v13 != v16);
    }
  }
  if (dword_1EBCCEEA8)
  {
    uint64_t v17 = *(uint64_t **)(a1 + 8);
    uint64_t v18 = *v17;
    uint64_t v19 = v17[1];
    if (v18 == v19)
    {
LABEL_29:
      uint64_t v20 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v18 != &llvm::MachineBlockFrequencyInfo::ID)
      {
        v18 += 16;
        if (v18 == v19) {
          goto LABEL_29;
        }
      }
      uint64_t v20 = *(void *)(v18 + 8);
    }
    *(void *)(a1 + 584) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v20 + 96))(v20, &llvm::MachineBlockFrequencyInfo::ID);
  }
  uint64_t v21 = *(uint64_t **)(a1 + 8);
  uint64_t v22 = *v21;
  uint64_t v23 = v21[1];
  if (v22 == v23)
  {
LABEL_35:
    uint64_t v24 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v22 != &llvm::MachineLoopInfo::ID)
    {
      v22 += 16;
      if (v22 == v23) {
        goto LABEL_35;
      }
    }
    uint64_t v24 = *(void *)(v22 + 8);
  }
  *(void *)(a1 + 592) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v24 + 96))(v24, &llvm::MachineLoopInfo::ID);
  uint64_t v25 = *(uint64_t **)(a1 + 8);
  uint64_t v26 = *v25;
  uint64_t v27 = v25[1];
  if (v26 == v27)
  {
LABEL_40:
    uint64_t v28 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v26 != &llvm::MachineDominatorTree::ID)
    {
      v26 += 16;
      if (v26 == v27) {
        goto LABEL_40;
      }
    }
    uint64_t v28 = *(void *)(v26 + 8);
  }
  *(void *)(a1 + 600) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v28 + 96))(v28, &llvm::MachineDominatorTree::ID);
  BOOL v29 = *(uint64_t **)(a1 + 8);
  uint64_t v30 = *v29;
  uint64_t v31 = v29[1];
  if (v30 == v31)
  {
LABEL_45:
    uint64_t v32 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v30 != &llvm::AAResultsWrapperPass::ID)
    {
      v30 += 16;
      if (v30 == v31) {
        goto LABEL_45;
      }
    }
    uint64_t v32 = *(void *)(v30 + 8);
  }
  *(void *)(a1 + 576) = *(void *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v32 + 96))(v32, &llvm::AAResultsWrapperPass::ID)+ 32);
  uint64_t v33 = *(void *)(a1 + 592);
  unsigned __int16 v34 = *(char **)(v33 + 272);
  BOOL v35 = *(char **)(v33 + 280);
  int v38 = v40;
  uint64_t v39 = 0x800000000;
  sub_1CBAACC38((uint64_t)&v38, v34, v35);
  if (v39)
  {
    uint64_t v36 = *((void *)v38 + v39 - 1);
    LODWORD(v39) = v39 - 1;
    *(void *)(a1 + 616) = v36;
    *(void *)(a1 + 624) = 0;
    *(_DWORD *)(a1 + 640) = 0;
    if (*(unsigned char *)(a1 + 568)) {
      llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getLoopPredecessor();
    }
    llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getExitBlocks();
  }
  BOOL v8 = *(unsigned char *)(a1 + 608) != 0;
  if (v38 != v40) {
    free(v38);
  }
  return v8;
}

void sub_1CC35A8EC(uint64_t a1)
{
  sub_1CC35A924(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC35A924(uint64_t a1)
{
  *(void *)a1 = &unk_1F260E718;
  sub_1CD529648((unsigned int *)(a1 + 1760));
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 1760), 8);
  sub_1CD48219C((char **)(a1 + 976));
  uint64_t v2 = *(void **)(a1 + 928);
  if (v2 != (void *)(a1 + 944)) {
    free(v2);
  }
  uint64_t v3 = *(void **)(a1 + 880);
  if (v3 != (void *)(a1 + 896)) {
    free(v3);
  }
  sub_1CB833A08(a1 + 856, *(void **)(a1 + 864));
  uint64_t v4 = *(void **)(a1 + 712);
  if (v4 != (void *)(a1 + 728)) {
    free(v4);
  }
  uint64_t v5 = *(void **)(a1 + 632);
  if (v5 != (void *)(a1 + 648)) {
    free(v5);
  }
  uint64_t v6 = *(void **)(a1 + 480);
  if (v6 != (void *)(a1 + 496)) {
    free(v6);
  }
  *(void *)a1 = &unk_1F260E110;
  uint64_t v7 = *(void **)(a1 + 176);
  if (v7 != (void *)(a1 + 192)) {
    free(v7);
  }
  BOOL v8 = *(void **)(a1 + 104);
  if (v8 != (void *)(a1 + 120)) {
    free(v8);
  }
  unint64_t v9 = *(void **)(a1 + 32);
  if (v9 != (void *)(a1 + 48)) {
    free(v9);
  }

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

uint64_t sub_1CC35AA64(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 624);
  if (result == -1) {
    return 0;
  }
  if (!result) {
    llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getLoopPreheader();
  }
  return result;
}

uint64_t sub_1CC35AAE4(uint64_t a1, llvm::MachineInstr *this)
{
  BOOL v22 = 1;
  if (!llvm::MachineInstr::isSafeToMove(this, *(llvm::AAResults **)(a1 + 576), &v22))
  {
    if (!byte_1EBCCED28) {
      return 0;
    }
    uint64_t result = sub_1CC35AD0C((uint64_t)this, *(void *)(a1 + 264));
    if (!result) {
      return result;
    }
  }
  uint64_t v5 = (unsigned __int16 *)*((void *)this + 2);
  if (*v5 - 1 > 1 || (*(unsigned char *)(*((void *)this + 4) + 48) & 8) == 0)
  {
    uint64_t v6 = *((void *)v5 + 1);
    if ((*((_WORD *)this + 22) & 0xC) != 0 && (*((_WORD *)this + 22) & 4) == 0)
    {
      if ((v6 & 0x80000) == 0)
      {
        uint64_t v20 = this;
        while ((*((_WORD *)v20 + 22) & 8) != 0)
        {
          uint64_t v20 = (llvm::MachineInstr *)*((void *)v20 + 1);
          if ((*(unsigned char *)(*((void *)v20 + 2) + 10) & 8) != 0) {
            goto LABEL_10;
          }
        }
        goto LABEL_31;
      }
    }
    else if ((v6 & 0x80000) == 0)
    {
      goto LABEL_31;
    }
  }
LABEL_10:
  BOOL v8 = (unint64_t *)((char *)this + 48);
  unint64_t v9 = *((void *)this + 6);
  if (v9 < 8) {
    goto LABEL_31;
  }
  if ((v9 & 7) != 0)
  {
    unsigned int v10 = (_DWORD *)(v9 & 0xFFFFFFFFFFFFFFF8);
    BOOL v11 = (*((void *)this + 6) & 7) != 3 || v10 == 0;
    if (v11 || !*v10) {
      goto LABEL_31;
    }
LABEL_19:
    if ((v9 & 7) == 0)
    {
      *((void *)this + 6) = v9 & 0xFFFFFFFFFFFFFFF8;
      unsigned int v15 = (unint64_t *)((char *)this + 56);
      goto LABEL_25;
    }
    if ((v9 & 7) == 3)
    {
      uint64_t v12 = (int *)(v9 & 0xFFFFFFFFFFFFFFF8);
      if ((v9 & 0xFFFFFFFFFFFFFFF8) != 0)
      {
        uint64_t v14 = *v12;
        BOOL v8 = (unint64_t *)(v12 + 2);
        uint64_t v13 = v14;
        if (v14)
        {
          unsigned int v15 = &v8[v13];
LABEL_25:
          while (1)
          {
            uint64_t v16 = *(void *)*v8;
            if ((v16 & 4) != 0)
            {
              unint64_t v17 = v16 & 0xFFFFFFFFFFFFFFF8;
              if (v17)
              {
                if ((*(_DWORD *)(v17 + 8) | 2) == 3) {
                  goto LABEL_31;
                }
              }
            }
            if (++v8 == v15) {
              goto LABEL_29;
            }
          }
        }
      }
    }
    goto LABEL_29;
  }
  v9 &= 0xFFFFFFFFFFFFFFF8;
  *BOOL v8 = v9;
  if (v9) {
    goto LABEL_19;
  }
LABEL_29:
  uint64_t result = sub_1CC35AEBC(a1, *((void *)this + 3));
  if (!result) {
    return result;
  }
  uint64_t v5 = (unsigned __int16 *)*((void *)this + 2);
LABEL_31:
  if (*v5 - 1 <= 1 && (*(unsigned char *)(*((void *)this + 4) + 48) & 0x20) != 0) {
    return 0;
  }
  uint64_t v18 = *((void *)v5 + 1);
  if ((*((_WORD *)this + 22) & 0xC) != 0 && (*((_WORD *)this + 22) & 4) == 0)
  {
    if ((v18 & 0x1000000000) == 0)
    {
      uint64_t v21 = this;
      uint64_t result = 0;
      while ((*((_WORD *)v21 + 22) & 8) != 0)
      {
        uint64_t v21 = (llvm::MachineInstr *)*((void *)v21 + 1);
        if ((*(unsigned char *)(*((void *)v21 + 2) + 12) & 0x10) != 0) {
          return result;
        }
      }
      return (*(uint64_t (**)(void, llvm::MachineInstr *, void))(**(void **)(a1 + 248) + 168))(*(void *)(a1 + 248), this, *(void *)(a1 + 616));
    }
  }
  else if ((v18 & 0x1000000000) == 0)
  {
    return (*(uint64_t (**)(void, llvm::MachineInstr *, void))(**(void **)(a1 + 248) + 168))(*(void *)(a1 + 248), this, *(void *)(a1 + 616));
  }
  return 0;
}

uint64_t sub_1CC35AD0C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned __int16 **)(a1 + 16);
  unsigned int v5 = *v4 - 1;
  if (v5 <= 1 && (*(unsigned char *)(*(void *)(a1 + 32) + 48) & 0x10) != 0)
  {
    __int16 v6 = *(_WORD *)(a1 + 44);
    uint64_t v8 = *((void *)v4 + 1);
    int v7 = v6 & 0xC;
  }
  else
  {
    __int16 v6 = *(_WORD *)(a1 + 44);
    int v7 = v6 & 0xC;
    uint64_t v8 = *((void *)v4 + 1);
    if ((v6 & 0xC) != 0 && (v6 & 4) == 0)
    {
      if ((v8 & 0x100000) == 0)
      {
        uint64_t v16 = a1;
        while ((*(_WORD *)(v16 + 44) & 8) != 0)
        {
          uint64_t v16 = *(void *)(v16 + 8);
          if ((*(unsigned char *)(*(void *)(v16 + 16) + 10) & 0x10) != 0) {
            goto LABEL_7;
          }
        }
        goto LABEL_36;
      }
    }
    else if ((v8 & 0x100000) == 0)
    {
      goto LABEL_36;
    }
  }
LABEL_7:
  if (v7 && (v6 & 4) == 0)
  {
    if ((v8 & 0x1000000) == 0)
    {
      uint64_t v17 = a1;
      while ((*(_WORD *)(v17 + 44) & 8) != 0)
      {
        char v11 = 0;
        uint64_t v17 = *(void *)(v17 + 8);
        if (*(unsigned char *)(*(void *)(v17 + 16) + 11)) {
          return v11 & 1;
        }
      }
      goto LABEL_10;
    }
  }
  else if ((v8 & 0x1000000) == 0)
  {
LABEL_10:
    if (v5 > 1 || (*(unsigned char *)(*(void *)(a1 + 32) + 48) & 1) == 0)
    {
      uint64_t v10 = *(unsigned int *)(a1 + 40);
      if (v10)
      {
        char v11 = 0;
        uint64_t v12 = 32 * v10;
        for (uint64_t i = (_DWORD *)(*(void *)(a1 + 32) + 4); ; i += 8)
        {
          if (*((unsigned char *)i - 4) != 1)
          {
            if (*((unsigned char *)i - 4)) {
              break;
            }
            unsigned int v14 = *i;
            if ((*i & 0x80000000) != 0)
            {
              unsigned int v15 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
              if ((v15 & 0x80000000) != 0) {
                break;
              }
              unsigned int v14 = v15;
            }
            if (!(*(unsigned int (**)(uint64_t, void, void))(*(void *)a2 + 128))(a2, v14, *(void *)(*(void *)(a1 + 24) + 32)))break; {
            char v11 = 1;
            }
          }
          v12 -= 32;
          if (!v12) {
            return v11 & 1;
          }
        }
      }
    }
  }
LABEL_36:
  char v11 = 0;
  return v11 & 1;
}

BOOL sub_1CC35AEBC(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 1784);
  if (v2 != 2) {
    return v2 == 0;
  }
  if (**(void **)(*(void *)(a1 + 616) + 32) != a2) {
    llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getExitingBlocks();
  }
  *(_DWORD *)(a1 + 1784) = 0;
  return 1;
}

void sub_1CC35AFF0(uint64_t a1, uint64_t a2)
{
  v11[16] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned int *)(a1 + 888);
  if (v4) {
    bzero(*(void **)(a1 + 880), 4 * v4);
  }
  if (((*(void *)(a2 + 72) - *(void *)(a2 + 64)) & 0x7FFFFFFF8) == 8)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    unint64_t v9 = v11;
    uint64_t v10 = 0x400000000;
    if (((*(uint64_t (**)(void, uint64_t, uint64_t *, uint64_t *, void **, void))(**(void **)(a1 + 248)
                                                                                            + 248))(*(void *)(a1 + 248), a2, &v8, &v7, &v9, 0) & 1) == 0&& !v10)
    {
      sub_1CC35AFF0(a1, **(void **)(a2 + 64));
    }
    if (v9 != v11) {
      free(v9);
    }
  }
  uint64_t v5 = a2 + 48;
  for (uint64_t i = *(void *)(a2 + 56); i != v5; uint64_t i = *(void *)(i + 8))
  {
    sub_1CC35B140(a1, i, 1);
    if (!i || (*(unsigned char *)i & 4) == 0)
    {
      while ((*(_WORD *)(i + 44) & 8) != 0)
        uint64_t i = *(void *)(i + 8);
    }
  }
}

void sub_1CC35B140(uint64_t a1, uint64_t a2, int a3)
{
  sub_1CC35BE50(&v16, a1, a2, 1, a3);
  uint64_t v4 = &v16[2 * v18];
  if (v17)
  {
    if (v18)
    {
      uint64_t v5 = 8 * v18;
      __int16 v6 = v16;
      while (*v6 >= 0xFFFFFFFE)
      {
        v6 += 2;
        v5 -= 8;
        if (!v5) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      __int16 v6 = v16;
    }
  }
  else
  {
LABEL_6:
    __int16 v6 = &v16[2 * v18];
  }
  uint64_t v7 = &v16[2 * v18];
  if (v6 != v7)
  {
    uint64_t v8 = *(void *)(a1 + 880);
    do
    {
      uint64_t v10 = *v6;
      unsigned int v11 = v6[1];
      unint64_t v9 = v6 + 2;
      int v12 = *(_DWORD *)(v8 + 4 * v10);
      int v13 = -v11;
      unsigned int v14 = v11 + v12;
      if (v12 < v13) {
        unsigned int v14 = 0;
      }
      *(_DWORD *)(v8 + 4 * v10) = v14;
      while (v9 != v4)
      {
        unsigned int v15 = *v9;
        v9 += 2;
        if (v15 <= 0xFFFFFFFD)
        {
          __int16 v6 = v9 - 2;
          goto LABEL_17;
        }
      }
      __int16 v6 = v4;
LABEL_17:
      ;
    }
    while (v6 != v7);
  }

  JUMPOUT(0x1D25D9CD0);
}

uint64_t sub_1CC35B22C(uint64_t a1, uint64_t a2)
{
  v146[8] = *MEMORY[0x1E4F143B8];
  int v2 = **(unsigned __int16 **)(a2 + 16);
  if (v2 == 10) {
    return 1;
  }
  if (byte_1EBCCED28)
  {
    if (v2 == 19 && (*(_DWORD *)(*(void *)(a2 + 32) + 36) & 0x80000000) == 0)
    {
      uint64_t v6 = *(void *)(a1 + 280);
      uint64_t v7 = *(void *)(a1 + 264);
      if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 128))(v7))
      {
        uint64_t v8 = *(unsigned int *)(*(void *)(a2 + 32) + 4);
        unint64_t v9 = (uint64_t *)((v8 & 0x80000000) != 0
                       ? *(void *)(v6 + 24) + 16 * (v8 & 0x7FFFFFFF) + 8
                       : *(void *)(v6 + 272) + 8 * v8);
        uint64_t v10 = *v9;
        if (*v9)
        {
          while ((*(unsigned char *)(v10 + 3) & 1) != 0)
          {
            uint64_t v10 = *(void *)(v10 + 24);
            if (!v10) {
              goto LABEL_12;
            }
          }
          uint64_t v108 = *(void *)(v10 + 8);
LABEL_193:
          char v109 = *(unsigned __int16 **)(v108 + 16);
          if (*v109 - 1 > 1 || (*(unsigned char *)(*(void *)(v108 + 32) + 48) & 0x10) == 0)
          {
            uint64_t v110 = *((void *)v109 + 1);
            if ((*(_WORD *)(v108 + 44) & 0xC) != 0 && (*(_WORD *)(v108 + 44) & 4) == 0)
            {
              uint64_t v112 = v108;
              if ((v110 & 0x100000) == 0)
              {
                do
                {
                  if ((*(_WORD *)(v112 + 44) & 8) == 0) {
                    goto LABEL_201;
                  }
                  uint64_t v112 = *(void *)(v112 + 8);
                }
                while ((*(unsigned char *)(*(void *)(v112 + 16) + 10) & 0x10) == 0);
              }
            }
            else if ((v110 & 0x100000) == 0)
            {
              goto LABEL_201;
            }
          }
          if (sub_1CC35AD0C(v108, v7)) {
            return 1;
          }
          uint64_t v108 = *(void *)(v10 + 8);
LABEL_201:
          while (1)
          {
            uint64_t v10 = *(void *)(v10 + 24);
            if (!v10) {
              break;
            }
            if ((*(unsigned char *)(v10 + 3) & 1) == 0 && *(void *)(v10 + 8) != v108)
            {
              uint64_t v108 = *(void *)(v10 + 8);
              goto LABEL_193;
            }
          }
        }
      }
    }
  }
LABEL_12:
  if (((*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 248) + 152))(*(void *)(a1 + 248), a2) & 1) != 0
    || ((unsigned int v11 = *(unsigned __int16 **)(a2 + 16), v12 = *v11, v12 != 11) ? (v13 = v12 == 19) : (v13 = 1), v13))
  {
    int v142 = 1;
  }
  else
  {
    int v105 = *((unsigned __int8 *)v11 + 4);
    uint64_t v106 = *(unsigned int *)(a2 + 40);
    if (v105) {
      BOOL v107 = v106 == 0;
    }
    else {
      BOOL v107 = 1;
    }
    if (v107)
    {
LABEL_191:
      int v142 = 0;
    }
    else
    {
      uint64_t v126 = 0;
      uint64_t v127 = 0;
      int v142 = 0;
      uint64_t v128 = v106 - 1;
      do
      {
        uint64_t v129 = *(void *)(a2 + 32);
        if ((*(_DWORD *)(v129 + v126) & 0x10000FF) == 0x1000000)
        {
          --v105;
          if ((*(_DWORD *)(v129 + v126 + 4) - 1) >= 0x3FFFFFFF)
          {
            if (!(*(unsigned int (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 248) + 1000))(*(void *)(a1 + 248), a1 + 288, a2, v127))goto LABEL_191; {
            int v142 = 1;
            }
          }
        }
        if (!v105) {
          break;
        }
        v126 += 32;
        BOOL v13 = v128 == v127++;
      }
      while (!v13);
    }
  }
  unsigned int v143 = v146;
  unsigned int v14 = 1;
  unsigned int v145 = 8;
  v146[0] = a2;
  while (1)
  {
    uint64_t v15 = *((void *)v143 + --v14);
    unsigned int v144 = v14;
    uint64_t v16 = *(unsigned int *)(v15 + 40);
    if (v16) {
      break;
    }
LABEL_105:
    if (!v14)
    {
      int v61 = 0;
      goto LABEL_108;
    }
  }
  int v17 = *(_DWORD **)(v15 + 32);
  unsigned int v18 = &v17[8 * v16];
  while (1)
  {
    if ((*v17 & 0x10000FF) == 0x1000000)
    {
      int v19 = v17[1];
      if (v19 < 0)
      {
        uint64_t v20 = *(void *)(*(void *)(*(void *)(a1 + 280) + 24) + 16 * (v19 & 0x7FFFFFFF) + 8);
        if (v20) {
          break;
        }
      }
    }
LABEL_24:
    v17 += 8;
    if (v17 == v18) {
      goto LABEL_105;
    }
  }
  while ((*(unsigned char *)(v20 + 3) & 1) != 0)
  {
    uint64_t v20 = *(void *)(v20 + 24);
    if (!v20) {
      goto LABEL_24;
    }
  }
  uint64_t v21 = *(void *)(v20 + 8);
LABEL_31:
  int v22 = **(unsigned __int16 **)(v21 + 16);
  if (v22 == 69) {
    goto LABEL_34;
  }
  if (v22 == 19)
  {
    uint64_t v31 = *(void *)(a1 + 616);
    uint64_t v32 = *(void *)(v21 + 24);
    uint64_t v34 = *(void *)(v31 + 56);
    uint64_t v33 = *(void *)(v31 + 64);
    if (v33 == v34)
    {
      uint64_t v35 = *(unsigned int *)(v31 + 76);
      uint64_t v36 = (void *)(v33 + 8 * v35);
      if (v35)
      {
        uint64_t v37 = 0;
        uint64_t v38 = 8 * v35;
        while (*(void *)(v33 + v37) != v32)
        {
          v37 += 8;
          if (v38 == v37) {
            goto LABEL_83;
          }
        }
        uint64_t v36 = (void *)(v33 + v37);
      }
LABEL_83:
      uint64_t v34 = *(void *)(v31 + 64);
    }
    else
    {
      uint64_t v52 = *(unsigned int *)(v31 + 72);
      int v53 = v52 - 1;
      unsigned int v54 = (v52 - 1) & ((v32 >> 4) ^ (v32 >> 9));
      uint64_t v36 = (void *)(v33 + 8 * v54);
      uint64_t v55 = *v36;
      if (*v36 == -1)
      {
        unsigned int v56 = 0;
LABEL_100:
        if (v56) {
          uint64_t v36 = v56;
        }
        if (*v36 != v32) {
          uint64_t v36 = (void *)(v33 + 8 * v52);
        }
      }
      else
      {
        unsigned int v56 = 0;
        int v57 = 1;
        while (v55 != v32)
        {
          if (v56) {
            BOOL v58 = 0;
          }
          else {
            BOOL v58 = v55 == -2;
          }
          if (v58) {
            unsigned int v56 = v36;
          }
          unsigned int v59 = v54 + v57++;
          unsigned int v54 = v59 & v53;
          uint64_t v36 = (void *)(v33 + 8 * (v59 & v53));
          uint64_t v55 = *v36;
          if (*v36 == -1) {
            goto LABEL_100;
          }
        }
      }
    }
    if (v33 == v34) {
      uint64_t v60 = 76;
    }
    else {
      uint64_t v60 = 72;
    }
    if (v36 != (void *)(v33 + 8 * *(unsigned int *)(v31 + v60)))
    {
      if (v14 >= v145) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v143 + v14) = v21;
      unsigned int v14 = ++v144;
      uint64_t v21 = *(void *)(v20 + 8);
    }
LABEL_90:
    while (1)
    {
      uint64_t v20 = *(void *)(v20 + 24);
      if (!v20) {
        goto LABEL_24;
      }
      if ((*(unsigned char *)(v20 + 3) & 1) == 0 && *(void *)(v20 + 8) != v21)
      {
        uint64_t v21 = *(void *)(v20 + 8);
        goto LABEL_31;
      }
    }
  }
  if (**(_WORD **)(v21 + 16)) {
    goto LABEL_90;
  }
LABEL_34:
  uint64_t v23 = *(void *)(a1 + 616);
  uint64_t v24 = *(void *)(v21 + 24);
  uint64_t v26 = *(void *)(v23 + 56);
  uint64_t v25 = *(void *)(v23 + 64);
  if (v25 == v26)
  {
    uint64_t v27 = *(unsigned int *)(v23 + 76);
    uint64_t v28 = (void *)(v25 + 8 * v27);
    if (v27)
    {
      uint64_t v29 = 0;
      uint64_t v30 = 8 * v27;
      while (*(void *)(v25 + v29) != v24)
      {
        v29 += 8;
        if (v30 == v29) {
          goto LABEL_58;
        }
      }
      uint64_t v28 = (void *)(v25 + v29);
    }
LABEL_58:
    uint64_t v26 = *(void *)(v23 + 64);
  }
  else
  {
    uint64_t v39 = *(unsigned int *)(v23 + 72);
    int v40 = v39 - 1;
    unsigned int v41 = (v39 - 1) & ((v24 >> 4) ^ (v24 >> 9));
    uint64_t v28 = (void *)(v25 + 8 * v41);
    uint64_t v42 = *v28;
    if (*v28 == -1)
    {
      __int16 v43 = 0;
LABEL_95:
      if (v43) {
        uint64_t v28 = v43;
      }
      if (*v28 != v24) {
        uint64_t v28 = (void *)(v25 + 8 * v39);
      }
    }
    else
    {
      __int16 v43 = 0;
      int v44 = 1;
      while (v42 != v24)
      {
        if (v43) {
          BOOL v45 = 0;
        }
        else {
          BOOL v45 = v42 == -2;
        }
        if (v45) {
          __int16 v43 = v28;
        }
        unsigned int v46 = v41 + v44++;
        unsigned int v41 = v46 & v40;
        uint64_t v28 = (void *)(v25 + 8 * (v46 & v40));
        uint64_t v42 = *v28;
        if (*v28 == -1) {
          goto LABEL_95;
        }
      }
    }
  }
  if (v25 == v26) {
    uint64_t v47 = 76;
  }
  else {
    uint64_t v47 = 72;
  }
  if (v28 == (void *)(v25 + 8 * *(unsigned int *)(v23 + v47)))
  {
    uint64_t v48 = *(void *)(a1 + 632);
    uint64_t v49 = *(unsigned int *)(a1 + 640);
    if (v49)
    {
      uint64_t v50 = 8 * v49;
      uint64_t v51 = *(void **)(a1 + 632);
      while (*v51 != v24)
      {
        ++v51;
        v50 -= 8;
        if (!v50)
        {
          uint64_t v51 = (void *)(v48 + 8 * v49);
          break;
        }
      }
    }
    else
    {
      uint64_t v51 = *(void **)(a1 + 632);
    }
    if (v49 == ((uint64_t)v51 - v48) >> 3) {
      goto LABEL_90;
    }
  }
  int v61 = 1;
LABEL_108:
  if (v143 != v146) {
    free(v143);
  }
  if (v142 & v61) {
    return 0;
  }
  char v141 = v61;
  uint64_t v62 = *(void *)(a2 + 16);
  if (*(_WORD *)v62 == 10
    || (*(unsigned char *)(v62 + 11) & 0x20) != 0
    && ((uint64_t v63 = *(llvm::AAResults **)(a1 + 576),
         uint64_t v64 = *(llvm::TargetInstrInfo **)(a1 + 248),
         ((*(uint64_t (**)(llvm::TargetInstrInfo *, uint64_t, llvm::AAResults *))(*(void *)v64 + 32))(v64, a2, v63) & 1) != 0)|| llvm::TargetInstrInfo::isReallyTriviallyReMaterializableGeneric(v64, (const llvm::MachineInstr *)a2, v63)))
  {
    uint64_t v65 = *(unsigned int *)(a2 + 40);
    if (!v65) {
      return 1;
    }
    uint64_t v66 = 32 * v65;
    for (uint64_t i = (_DWORD *)(*(void *)(a2 + 32) + 4); (*(i - 1) & 0x10000FF) != 0 || (*i & 0x80000000) == 0; i += 8)
    {
      v66 -= 32;
      if (!v66) {
        return 1;
      }
    }
  }
  uint64_t v68 = *(void *)(a2 + 16);
  uint64_t v69 = *(unsigned __int16 *)(v68 + 2);
  if (!*(_WORD *)(v68 + 2))
  {
LABEL_180:
    sub_1CC35BE50(&v143, a1, a2, 0, 0);
    int v102 = v143;
    if (v144)
    {
      if (LODWORD(v146[0]))
      {
        uint64_t v103 = 8 * LODWORD(v146[0]);
        int v104 = (unsigned int *)v143;
        while (*v104 >= 0xFFFFFFFE)
        {
          v104 += 2;
          v103 -= 8;
          if (!v103) {
            goto LABEL_185;
          }
        }
      }
      else
      {
        int v104 = (unsigned int *)v143;
      }
    }
    else
    {
LABEL_185:
      int v104 = (unsigned int *)((char *)v143 + 8 * LODWORD(v146[0]));
    }
    unint64_t v113 = (char *)v143 + 8 * LODWORD(v146[0]);
    if (v104 == (unsigned int *)v113) {
      goto LABEL_248;
    }
    while (1)
    {
      int v114 = v104[1];
      if (v114 > 0)
      {
        if ((v142 & (byte_1EBCCEC68 == 0)) != 0) {
          goto LABEL_226;
        }
        uint64_t v115 = *(unsigned int *)(a1 + 984);
        if (v115) {
          break;
        }
      }
LABEL_219:
      unsigned int v118 = v104 + 2;
      while (v118 != (unsigned int *)((char *)v143 + 8 * LODWORD(v146[0])))
      {
        unsigned int v119 = *v118;
        v118 += 2;
        if (v119 <= 0xFFFFFFFD)
        {
          int v104 = v118 - 2;
          goto LABEL_224;
        }
      }
      int v104 = (unsigned int *)((char *)v143 + 8 * LODWORD(v146[0]));
LABEL_224:
      if (v104 == (unsigned int *)v113) {
        goto LABEL_248;
      }
    }
    size_t v116 = *(void **)(a1 + 976);
    uint64_t v117 = 48 * v115;
    while (*(_DWORD *)(*v116 + 4 * *v104) + v114 < *(_DWORD *)(*(void *)(a1 + 928) + 4 * *v104))
    {
      v116 += 6;
      v117 -= 48;
      if (!v117) {
        goto LABEL_219;
      }
    }
LABEL_226:
    if ((v141 & 1) == 0)
    {
      if (byte_1EBCCEBA8 && !sub_1CC35AEBC(a1, *(void *)(a2 + 24)))
      {
        int v130 = **(unsigned __int16 **)(a2 + 16);
        uint64_t v131 = *(void *)(a1 + 1760);
        uint64_t v132 = *(unsigned int *)(a1 + 1776);
        unint64_t v133 = sub_1CD489BC0(v131, *(_DWORD *)(a1 + 1776), v130);
        if ((int *)(v131 + 32 * v132) == v133 || v130 == 10) {
          goto LABEL_260;
        }
        uint64_t v135 = (uint64_t *)*((void *)v133 + 1);
        unint64_t v136 = (uint64_t *)*((void *)v133 + 2);
        if (v135 == v136) {
          goto LABEL_260;
        }
        while (1)
        {
          uint64_t v137 = *(unsigned char *)(a1 + 568) ? *(void *)(a1 + 280) : 0;
          uint64_t v3 = *v135;
          if ((*(unsigned int (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 248) + 216))(*(void *)(a1 + 248), a2, *v135, v137))
          {
            break;
          }
          uint64_t v3 = 0;
          if (++v135 == v136) {
            goto LABEL_261;
          }
        }
        if (!v3) {
          goto LABEL_261;
        }
      }
      uint64_t v120 = *(void *)(a2 + 16);
      if (*(_WORD *)v120 == 10
        || (*(unsigned char *)(v120 + 11) & 0x20) != 0
        && ((int v121 = *(llvm::AAResults **)(a1 + 576),
             uint64_t v122 = *(llvm::TargetInstrInfo **)(a1 + 248),
             ((*(uint64_t (**)(llvm::TargetInstrInfo *, uint64_t, llvm::AAResults *))(*(void *)v122 + 32))(v122, a2, v121) & 1) != 0)|| llvm::TargetInstrInfo::isReallyTriviallyReMaterializableGeneric(v122, (const llvm::MachineInstr *)a2, v121)))
      {
        uint64_t v123 = *(unsigned int *)(a2 + 40);
        if (!v123)
        {
LABEL_248:
          uint64_t v3 = 1;
LABEL_261:
          MEMORY[0x1D25D9CD0](v102, 4);
          return v3;
        }
        uint64_t v124 = 32 * v123;
        uint64_t v125 = (_DWORD *)(*(void *)(a2 + 32) + 4);
        while ((*(v125 - 1) & 0x10000FF) != 0 || (*v125 & 0x80000000) == 0)
        {
          v125 += 8;
          v124 -= 32;
          if (!v124) {
            goto LABEL_248;
          }
        }
      }
      if (llvm::MachineInstr::isDereferenceableInvariantLoad((llvm::MachineInstr *)a2, *(llvm::AAResults **)(a1 + 576)))goto LABEL_248; {
    }
      }
LABEL_260:
    uint64_t v3 = 0;
    goto LABEL_261;
  }
  uint64_t v70 = 0;
  uint64_t v71 = a1 + 288;
  while (1)
  {
    uint64_t v72 = *(void *)(a2 + 32);
    int v73 = *(_DWORD *)(v72 + 32 * v70);
    if ((v73 & 0x20000FF) == 0 && (v73 & 0x1000000) != 0)
    {
      int v74 = *(_DWORD *)(v72 + 32 * v70 + 4);
      if (v74 < 0)
      {
        uint64_t v75 = *(void *)(*(void *)(*(void *)(a1 + 280) + 24) + 16 * (v74 & 0x7FFFFFFF) + 8);
        if (v75)
        {
          if ((*(_DWORD *)v75 & 0x81000000) != 0)
          {
            uint64_t v76 = *(void *)(*(void *)(*(void *)(a1 + 280) + 24) + 16 * (v74 & 0x7FFFFFFF) + 8);
            while (1)
            {
              uint64_t v76 = *(void *)(v76 + 24);
              if (!v76) {
                goto LABEL_125;
              }
              if ((*(_DWORD *)v76 & 0x81000000) == 0)
              {
                while (1)
                {
                  uint64_t v75 = *(void *)(v75 + 24);
                  if (!v75) {
                    goto LABEL_125;
                  }
                  if ((*(_DWORD *)v75 & 0x81000000) == 0) {
                    goto LABEL_136;
                  }
                }
              }
            }
          }
LABEL_136:
          uint64_t v77 = *(void *)(v75 + 8);
LABEL_137:
          int v78 = **(unsigned __int16 **)(v77 + 16);
          if (v78 == 11 || v78 == 19)
          {
LABEL_164:
            while (1)
            {
              uint64_t v75 = *(void *)(v75 + 24);
              if (!v75) {
                goto LABEL_125;
              }
              if ((*(_DWORD *)v75 & 0x81000000) == 0 && *(void *)(v75 + 8) != v77)
              {
                uint64_t v77 = *(void *)(v75 + 8);
                goto LABEL_137;
              }
            }
          }
          uint64_t v80 = *(void *)(a1 + 616);
          uint64_t v81 = *(void *)(v77 + 24);
          uint64_t v83 = *(void *)(v80 + 56);
          uint64_t v82 = *(void *)(v80 + 64);
          if (v82 == v83)
          {
            uint64_t v84 = *(unsigned int *)(v80 + 76);
            std::string v85 = (void *)(v82 + 8 * v84);
            if (v84)
            {
              uint64_t v86 = 0;
              uint64_t v87 = 8 * v84;
              while (*(void *)(v82 + v86) != v81)
              {
                v86 += 8;
                if (v87 == v86) {
                  goto LABEL_159;
                }
              }
              std::string v85 = (void *)(v82 + v86);
            }
LABEL_159:
            uint64_t v83 = *(void *)(v80 + 64);
          }
          else
          {
            uint64_t v88 = *(unsigned int *)(v80 + 72);
            int v89 = v88 - 1;
            unsigned int v90 = (v88 - 1) & ((v81 >> 4) ^ (v81 >> 9));
            std::string v85 = (void *)(v82 + 8 * v90);
            uint64_t v91 = *v85;
            if (*v85 == -1)
            {
              uint64_t v92 = 0;
LABEL_169:
              if (v92) {
                std::string v85 = v92;
              }
              if (*v85 != v81) {
                std::string v85 = (void *)(v82 + 8 * v88);
              }
            }
            else
            {
              uint64_t v92 = 0;
              int v93 = 1;
              while (v91 != v81)
              {
                if (v92) {
                  BOOL v94 = 0;
                }
                else {
                  BOOL v94 = v91 == -2;
                }
                if (v94) {
                  uint64_t v92 = v85;
                }
                unsigned int v95 = v90 + v93++;
                unsigned int v90 = v95 & v89;
                std::string v85 = (void *)(v82 + 8 * (v95 & v89));
                uint64_t v91 = *v85;
                if (*v85 == -1) {
                  goto LABEL_169;
                }
              }
            }
          }
          if (v82 == v83) {
            uint64_t v96 = 76;
          }
          else {
            uint64_t v96 = 72;
          }
          if (v85 == (void *)(v82 + 8 * *(unsigned int *)(v80 + v96))) {
            goto LABEL_164;
          }
          uint64_t v97 = *(unsigned int *)(v77 + 40);
          if (v97) {
            break;
          }
        }
      }
    }
LABEL_125:
    if (++v70 == v69) {
      goto LABEL_180;
    }
  }
  uint64_t v98 = 0;
  uint64_t v99 = 0;
  uint64_t v139 = *(unsigned int *)(v77 + 40);
  uint64_t v140 = v71;
  while (1)
  {
    uint64_t v100 = *(void *)(v77 + 32);
    if ((*(_DWORD *)(v100 + v98) & 0x10000FF) == 0 && *(_DWORD *)(v100 + v98 + 4) == v74)
    {
      char v101 = (*(uint64_t (**)(void, uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 248) + 992))(*(void *)(a1 + 248), v71, *(void *)(a1 + 280), a2, v70, v77, v99);
      uint64_t v97 = v139;
      uint64_t v71 = v140;
      if (v101) {
        return 1;
      }
    }
    ++v99;
    v98 += 32;
    if (v97 == v99) {
      goto LABEL_125;
    }
  }
}

_DWORD *sub_1CC35BE50(_DWORD *result, uint64_t a2, uint64_t a3, int a4, int a5)
{
  *(void *)uint64_t result = 0;
  *((void *)result + 1) = 0;
  result[4] = 0;
  uint64_t v5 = *(_WORD **)(a3 + 16);
  if (*v5 != 10)
  {
    uint64_t v6 = (unsigned __int16)v5[1];
    if (v5[1])
    {
      uint64_t v8 = (uint64_t)result;
      uint64_t v9 = 0;
      uint64_t v24 = a2 + 712;
      do
      {
        uint64_t v10 = (_DWORD *)(*(void *)(a3 + 32) + 32 * v9);
        if ((*v10 & 0x20000FF) == 0)
        {
          unsigned int v11 = v10[1];
          unsigned int v30 = v11;
          if ((v11 & 0x80000000) != 0)
          {
            if (a4)
            {
              unint64_t v12 = ((unint64_t)sub_1CC34E98C(v24, &v30) >> 32) & 1;
              unsigned int v11 = v30;
            }
            else
            {
              LODWORD(v12) = 0;
            }
            unint64_t v13 = *(void *)(*(void *)(*(void *)(a2 + 280) + 24) + 16 * (v11 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8;
            uint64_t result = (_DWORD *)(*(uint64_t (**)(void, unint64_t))(**(void **)(a2 + 264) + 280))(*(void *)(a2 + 264), v13);
            int v14 = *result;
            if ((*v10 & 0x1000000) != 0) {
              goto LABEL_26;
            }
            if (((*v10 >> 26) & ~HIBYTE(*v10) & 1) == 0)
            {
              uint64_t v15 = *(void *)(a2 + 280);
              uint64_t v16 = v10[1];
              if ((v16 & 0x80000000) != 0) {
                int v17 = (uint64_t *)(*(void *)(v15 + 24) + 16 * (v16 & 0x7FFFFFFF) + 8);
              }
              else {
                int v17 = (uint64_t *)(*(void *)(v15 + 272) + 8 * v16);
              }
              uint64_t v18 = *v17;
              if (v18)
              {
                if ((*(unsigned char *)(v18 + 3) & 0x81) == 0) {
                  goto LABEL_21;
                }
                while (1)
                {
                  uint64_t v18 = *(void *)(v18 + 24);
                  if (!v18) {
                    break;
                  }
                  if ((*(_DWORD *)v18 & 0x81000000) == 0)
                  {
LABEL_21:
                    while (1)
                    {
                      uint64_t v18 = *(void *)(v18 + 24);
                      if (!v18) {
                        goto LABEL_13;
                      }
                      if ((*(_DWORD *)v18 & 0x81000000) == 0) {
                        goto LABEL_23;
                      }
                    }
                  }
                }
              }
LABEL_23:
              if ((v12 & a5) == 0) {
                int v14 = 0;
              }
              if ((v12 & 1) == 0) {
                goto LABEL_6;
              }
              goto LABEL_26;
            }
LABEL_13:
            if ((v12 & 1) == 0)
            {
              int v14 = -v14;
LABEL_26:
              if (v14)
              {
                uint64_t result = (_DWORD *)(*(uint64_t (**)(void, unint64_t))(**(void **)(a2 + 264) + 320))(*(void *)(a2 + 264), v13);
                int v19 = *result;
                if (*result != -1)
                {
                  uint64_t v20 = result + 1;
                  do
                  {
                    uint64_t v21 = *(void *)v8;
                    uint64_t v22 = *(unsigned int *)(v8 + 16);
                    if ((int *)(v21 + 8 * v22) == sub_1CBA86078(*(void *)v8, *(_DWORD *)(v8 + 16), v19))
                    {
                      int v29 = v19;
                      uint64_t result = sub_1CD537474(v8, &v29);
                      result[1] = v14;
                    }
                    else
                    {
                      int v28 = v19;
                      uint64_t result = sub_1CD537474(v8, &v28);
                      result[1] += v14;
                    }
                    int v23 = *v20++;
                    int v19 = v23;
                  }
                  while (v23 != -1);
                }
              }
            }
          }
        }
LABEL_6:
        ++v9;
      }
      while (v9 != v6);
    }
  }
  return result;
}

void sub_1CC35C0DC()
{
}

void sub_1CC35C1A8(uint64_t a1)
{
  sub_1CC35A924(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC35C1E0()
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  v5.n128_u64[0] = (unint64_t)"MachineLICM should avoid speculation";
  v5.n128_u64[1] = 36;
  LOBYTE(v2) = 1;
  *(void *)&long long v4 = &v2;
  LODWORD(v3) = 1;
  sub_1CD4130FC((llvm::cl::Option *)&unk_1EBCCEB28, "avoid-speculation", &v5, (unsigned char **)&v4, &v3);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCCEB28, &dword_1CB82C000);
  v5.n128_u64[0] = (unint64_t)"MachineLICM should hoist even cheap instructions";
  v5.n128_u64[1] = 48;
  LOBYTE(v2) = 0;
  *(void *)&long long v4 = &v2;
  LODWORD(v3) = 1;
  sub_1CD4130FC((llvm::cl::Option *)&unk_1EBCCEBE8, "hoist-cheap-insts", &v5, (unsigned char **)&v4, &v3);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCCEBE8, &dword_1CB82C000);
  v5.n128_u64[0] = (unint64_t)"Hoist invariant stores";
  v5.n128_u64[1] = 22;
  LOBYTE(v2) = 1;
  *(void *)&long long v4 = &v2;
  LODWORD(v3) = 1;
  sub_1CD4130FC((llvm::cl::Option *)&unk_1EBCCECA8, "hoist-const-stores", &v5, (unsigned char **)&v4, &v3);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCCECA8, &dword_1CB82C000);
  v5.n128_u64[0] = (unint64_t)"Do not hoist instructions if targetblock is N times hotter than the source.";
  v5.n128_u64[1] = 75;
  int v2 = 1;
  LODWORD(v3) = 100;
  *(void *)&long long v4 = &v3;
  sub_1CD50BCD4((uint64_t)&unk_1EBCCED68, "block-freq-ratio-threshold", &v5, (int **)&v4, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCCED68, &dword_1CB82C000);
  *(void *)&long long v4 = "Disable hoisting instructions to hotter blocks";
  *((void *)&v4 + 1) = 46;
  int v1 = 1;
  int v2 = 1;
  uint64_t v3 = &v2;
  v5.n128_u64[0] = (unint64_t)v6;
  v6[0] = "none";
  v6[1] = 4;
  int v7 = 0;
  uint64_t v8 = "disable the feature";
  uint64_t v9 = 19;
  uint64_t v10 = "pgo";
  uint64_t v11 = 3;
  int v12 = 1;
  unint64_t v13 = "enable the feature when using profile data";
  uint64_t v14 = 42;
  uint64_t v15 = "all";
  uint64_t v16 = 3;
  int v17 = 2;
  uint64_t v18 = "enable the feature with/wo profile data";
  uint64_t v19 = 39;
  v5.n128_u64[1] = 0x400000003;
  sub_1CD537904(&v4, &v3, &v1, (uint64_t)&v5);
  if ((void *)v5.n128_u64[0] != v6) {
    free((void *)v5.n128_u64[0]);
  }
  return __cxa_atexit((void (*)(void *))sub_1CD536C70, &qword_1EBCCEE28, &dword_1CB82C000);
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getLoopDepth(void *a1)
{
  LODWORD(v1) = 0;
  do
  {
    a1 = (void *)*a1;
    uint64_t v1 = (v1 + 1);
  }
  while (a1);
  return v1;
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getHeader(uint64_t a1)
{
  return **(void **)(a1 + 32);
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getBlocks(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getParentLoop(uint64_t a1)
{
  return *(void *)a1;
}

void *llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::setParentLoop(void *result, uint64_t a2)
{
  *uint64_t result = a2;
  return result;
}

BOOL llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::contains(void *a1, void *a2)
{
  if (a2 == a1) {
    return 1;
  }
  do
  {
    BOOL result = a2 != 0;
    if (!a2) {
      break;
    }
    a2 = (void *)*a2;
  }
  while (a2 != a1);
  return result;
}

BOOL llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::contains(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 56);
  uint64_t v2 = *(void *)(a1 + 64);
  if (v2 == v3)
  {
    uint64_t v4 = *(unsigned int *)(a1 + 76);
    __n128 v5 = (void *)(v2 + 8 * v4);
    if (v4)
    {
      uint64_t v6 = 0;
      uint64_t v7 = 8 * v4;
      while (*(void *)(v2 + v6) != a2)
      {
        v6 += 8;
        if (v7 == v6) {
          goto LABEL_19;
        }
      }
      __n128 v5 = (void *)(v2 + v6);
    }
LABEL_19:
    uint64_t v3 = *(void *)(a1 + 64);
  }
  else
  {
    uint64_t v8 = *(unsigned int *)(a1 + 72);
    int v9 = v8 - 1;
    unsigned int v10 = (v8 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    __n128 v5 = (void *)(v2 + 8 * v10);
    uint64_t v11 = *v5;
    if (*v5 == -1)
    {
      int v12 = 0;
LABEL_24:
      if (v12) {
        __n128 v5 = v12;
      }
      if (*v5 != a2) {
        __n128 v5 = (void *)(v2 + 8 * v8);
      }
    }
    else
    {
      int v12 = 0;
      int v13 = 1;
      while (v11 != a2)
      {
        if (v12) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v11 == -2;
        }
        if (v14) {
          int v12 = v5;
        }
        unsigned int v15 = v10 + v13++;
        unsigned int v10 = v15 & v9;
        __n128 v5 = (void *)(v2 + 8 * (v15 & v9));
        uint64_t v11 = *v5;
        if (*v5 == -1) {
          goto LABEL_24;
        }
      }
    }
  }
  BOOL v14 = v2 == v3;
  uint64_t v16 = 72;
  if (v14) {
    uint64_t v16 = 76;
  }
  return v5 != (void *)(v2 + 8 * *(unsigned int *)(a1 + v16));
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getSubLoops(uint64_t a1)
{
  return a1 + 8;
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getSubLoopsVector(uint64_t a1)
{
  return a1 + 8;
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::begin(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::end(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::rbegin(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::rend(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

BOOL llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::isInnermost(uint64_t a1)
{
  return *(void *)(a1 + 8) == *(void *)(a1 + 16);
}

BOOL llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::isOutermost(void *a1)
{
  return *a1 == 0;
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::block_begin(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::block_end(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::blocks(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getNumBlocks(uint64_t a1)
{
  return (*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 3;
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getBlocksVector(uint64_t a1)
{
  return a1 + 32;
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getBlocksSet(uint64_t a1)
{
  return a1 + 56;
}

{
  return a1 + 56;
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::isInvalid()
{
  return 0;
}

BOOL llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::isLoopExiting(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(a2 + 88);
  uint64_t v3 = *(uint64_t **)(a2 + 96);
  if (v2 == v3) {
    return 0;
  }
  uint64_t v4 = (unsigned int *)(a1 + 76);
  __n128 v5 = (unsigned int *)(a1 + 72);
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v6 = *(void *)(a1 + 64);
  if (v6 == v7) {
    uint64_t v8 = (unsigned int *)(a1 + 76);
  }
  else {
    uint64_t v8 = (unsigned int *)(a1 + 72);
  }
  uint64_t v9 = *(void *)(a1 + 64);
  do
  {
    uint64_t v10 = *v2;
    if (v9 == v7)
    {
      uint64_t v11 = *v4;
      int v12 = (void *)(v7 + 8 * v11);
      if (v11)
      {
        uint64_t v13 = 0;
        uint64_t v14 = 8 * v11;
        while (*(void *)(v7 + v13) != v10)
        {
          v13 += 8;
          if (v14 == v13) {
            goto LABEL_24;
          }
        }
        int v12 = (void *)(v7 + v13);
      }
LABEL_24:
      uint64_t v9 = v7;
    }
    else
    {
      int v15 = *v5 - 1;
      unsigned int v16 = v15 & ((v10 >> 4) ^ (v10 >> 9));
      int v12 = (void *)(v6 + 8 * v16);
      uint64_t v17 = *v12;
      if (*v12 == -1)
      {
        uint64_t v18 = 0;
LABEL_26:
        if (v18) {
          int v12 = v18;
        }
        if (*v12 != v10) {
          int v12 = (void *)(v6 + 8 * *v8);
        }
      }
      else
      {
        uint64_t v18 = 0;
        int v19 = 1;
        while (v17 != v10)
        {
          if (v18) {
            BOOL v20 = 0;
          }
          else {
            BOOL v20 = v17 == -2;
          }
          if (v20) {
            uint64_t v18 = v12;
          }
          unsigned int v21 = v16 + v19++;
          unsigned int v16 = v21 & v15;
          int v12 = (void *)(v6 + 8 * (v21 & v15));
          uint64_t v17 = *v12;
          if (*v12 == -1) {
            goto LABEL_26;
          }
        }
      }
      uint64_t v9 = v6;
    }
    if (v9 == v7) {
      uint64_t v22 = v4;
    }
    else {
      uint64_t v22 = v5;
    }
    int v23 = (void *)(v9 + 8 * *v22);
    BOOL result = v12 == v23;
    ++v2;
  }
  while (v12 != v23 && v2 != v3);
  return result;
}

BOOL llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::isLoopLatch(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = **(void **)(a1 + 32);
  uint64_t v3 = *(void **)(v2 + 64);
  uint64_t v4 = *(void **)(v2 + 72);
  if (v3 != v4)
  {
    while (*v3 != a2)
    {
      if (++v3 == v4)
      {
        uint64_t v3 = v4;
        return v3 != v4;
      }
    }
  }
  return v3 != v4;
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getNumBackEdges(uint64_t result)
{
  uint64_t v1 = **(void **)(result + 32);
  uint64_t v2 = *(uint64_t **)(v1 + 64);
  uint64_t v3 = *(uint64_t **)(v1 + 72);
  if (v2 == v3) {
    return 0;
  }
  uint64_t v4 = result;
  LODWORD(result) = 0;
  __n128 v5 = (unsigned int *)(v4 + 76);
  uint64_t v6 = (unsigned int *)(v4 + 72);
  uint64_t v9 = v4 + 56;
  uint64_t v7 = *(void *)(v4 + 56);
  uint64_t v8 = *(void *)(v9 + 8);
  if (v8 == v7) {
    uint64_t v10 = v5;
  }
  else {
    uint64_t v10 = v6;
  }
  uint64_t v11 = v8;
  do
  {
    uint64_t v12 = *v2;
    if (v11 == v7)
    {
      uint64_t v13 = *v5;
      uint64_t v14 = (void *)(v7 + 8 * v13);
      if (v13)
      {
        uint64_t v15 = 0;
        uint64_t v16 = 8 * v13;
        while (*(void *)(v7 + v15) != v12)
        {
          v15 += 8;
          if (v16 == v15) {
            goto LABEL_24;
          }
        }
        uint64_t v14 = (void *)(v7 + v15);
      }
LABEL_24:
      uint64_t v11 = v7;
    }
    else
    {
      int v17 = *v6 - 1;
      unsigned int v18 = v17 & ((v12 >> 4) ^ (v12 >> 9));
      uint64_t v14 = (void *)(v8 + 8 * v18);
      uint64_t v19 = *v14;
      if (*v14 == -1)
      {
        BOOL v20 = 0;
LABEL_26:
        if (v20) {
          uint64_t v14 = v20;
        }
        if (*v14 != v12) {
          uint64_t v14 = (void *)(v8 + 8 * *v10);
        }
      }
      else
      {
        BOOL v20 = 0;
        int v21 = 1;
        while (v19 != v12)
        {
          if (v20) {
            BOOL v22 = 0;
          }
          else {
            BOOL v22 = v19 == -2;
          }
          if (v22) {
            BOOL v20 = v14;
          }
          unsigned int v23 = v18 + v21++;
          unsigned int v18 = v23 & v17;
          uint64_t v14 = (void *)(v8 + 8 * (v23 & v17));
          uint64_t v19 = *v14;
          if (*v14 == -1) {
            goto LABEL_26;
          }
        }
      }
      uint64_t v11 = v8;
    }
    if (v11 == v7) {
      uint64_t v24 = v5;
    }
    else {
      uint64_t v24 = v6;
    }
    if (v14 == (void *)(v11 + 8 * *v24)) {
      BOOL result = result;
    }
    else {
      BOOL result = (result + 1);
    }
    ++v2;
  }
  while (v2 != v3);
  return result;
}

void llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getExitingBlock()
{
}

{
  while (1)
    ;
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getExitBlocks(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 32);
  for (uint64_t i = *(void *)(result + 40); v2 != i; v2 += 8)
  {
    uint64_t v4 = *(uint64_t **)(*(void *)v2 + 88);
    __n128 v5 = *(uint64_t **)(*(void *)v2 + 96);
    while (v4 != v5)
    {
      uint64_t v6 = *v4;
      uint64_t v8 = *(void *)(result + 56);
      uint64_t v7 = *(void *)(result + 64);
      if (v7 == v8)
      {
        uint64_t v9 = *(unsigned int *)(result + 76);
        uint64_t v10 = (void *)(v7 + 8 * v9);
        if (v9)
        {
          uint64_t v11 = 0;
          uint64_t v12 = 8 * v9;
          while (*(void *)(v7 + v11) != v6)
          {
            v11 += 8;
            if (v12 == v11) {
              goto LABEL_9;
            }
          }
          uint64_t v10 = (void *)(v7 + v11);
        }
LABEL_9:
        uint64_t v8 = *(void *)(result + 64);
      }
      else
      {
        uint64_t v14 = *(unsigned int *)(result + 72);
        int v15 = v14 - 1;
        unsigned int v16 = (v14 - 1) & ((v6 >> 4) ^ (v6 >> 9));
        uint64_t v10 = (void *)(v7 + 8 * v16);
        uint64_t v17 = *v10;
        if (*v10 == -1)
        {
          unsigned int v18 = 0;
LABEL_25:
          if (v18) {
            uint64_t v10 = v18;
          }
          if (*v10 != v6) {
            uint64_t v10 = (void *)(v7 + 8 * v14);
          }
        }
        else
        {
          unsigned int v18 = 0;
          int v19 = 1;
          while (v17 != v6)
          {
            if (v18) {
              BOOL v20 = 0;
            }
            else {
              BOOL v20 = v17 == -2;
            }
            if (v20) {
              unsigned int v18 = v10;
            }
            unsigned int v21 = v16 + v19++;
            unsigned int v16 = v21 & v15;
            uint64_t v10 = (void *)(v7 + 8 * (v21 & v15));
            uint64_t v17 = *v10;
            if (*v10 == -1) {
              goto LABEL_25;
            }
          }
        }
      }
      if (v7 == v8) {
        uint64_t v13 = (unsigned int *)(result + 76);
      }
      else {
        uint64_t v13 = (unsigned int *)(result + 72);
      }
      if (v10 == (void *)(v7 + 8 * *v13))
      {
        unint64_t v22 = *(unsigned int *)(a2 + 8);
        if (v22 >= *(unsigned int *)(a2 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a2 + 8 * v22) = v6;
        ++*(_DWORD *)(a2 + 8);
      }
      ++v4;
    }
  }
  return result;
}

void llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getExitBlock()
{
}

{
  while (1)
    ;
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::hasDedicatedExits(uint64_t a1)
{
  v26[4] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = v26;
  uint64_t v25 = 0x400000000;
  sub_1CC35CDE0((void *)a1, (uint64_t)&v24);
  if (v25)
  {
    uint64_t v2 = (char *)v24;
    while (1)
    {
      uint64_t v3 = *(uint64_t **)(*(void *)v2 + 64);
      uint64_t v4 = *(uint64_t **)(*(void *)v2 + 72);
      if (v3 != v4) {
        break;
      }
LABEL_38:
      v2 += 8;
      if (v2 == (char *)v24 + 8 * v25) {
        goto LABEL_39;
      }
    }
    uint64_t v6 = *(void *)(a1 + 56);
    uint64_t v5 = *(void *)(a1 + 64);
    if (v5 == v6) {
      uint64_t v7 = (unsigned int *)(a1 + 76);
    }
    else {
      uint64_t v7 = (unsigned int *)(a1 + 72);
    }
    uint64_t v8 = *(void *)(a1 + 64);
    while (1)
    {
      uint64_t v9 = *v3;
      if (v8 == v6)
      {
        uint64_t v10 = *(unsigned int *)(a1 + 76);
        uint64_t v11 = (void *)(v6 + 8 * v10);
        if (v10)
        {
          uint64_t v12 = 0;
          uint64_t v13 = 8 * v10;
          while (*(void *)(v6 + v12) != v9)
          {
            v12 += 8;
            if (v13 == v12) {
              goto LABEL_26;
            }
          }
          uint64_t v11 = (void *)(v6 + v12);
        }
LABEL_26:
        uint64_t v8 = *(void *)(a1 + 56);
      }
      else
      {
        int v14 = *(_DWORD *)(a1 + 72) - 1;
        unsigned int v15 = v14 & ((v9 >> 4) ^ (v9 >> 9));
        uint64_t v11 = (void *)(v5 + 8 * v15);
        uint64_t v16 = *v11;
        if (*v11 == -1)
        {
          uint64_t v17 = 0;
LABEL_28:
          if (v17) {
            uint64_t v11 = v17;
          }
          if (*v11 != v9) {
            uint64_t v11 = (void *)(v5 + 8 * *v7);
          }
        }
        else
        {
          uint64_t v17 = 0;
          int v18 = 1;
          while (v16 != v9)
          {
            if (v17) {
              BOOL v19 = 0;
            }
            else {
              BOOL v19 = v16 == -2;
            }
            if (v19) {
              uint64_t v17 = v11;
            }
            unsigned int v20 = v15 + v18++;
            unsigned int v15 = v20 & v14;
            uint64_t v11 = (void *)(v5 + 8 * (v20 & v14));
            uint64_t v16 = *v11;
            if (*v11 == -1) {
              goto LABEL_28;
            }
          }
        }
        uint64_t v8 = *(void *)(a1 + 64);
      }
      unsigned int v21 = (unsigned int *)(v8 == v6 ? a1 + 76 : a1 + 72);
      if (v11 == (void *)(v8 + 8 * *v21)) {
        break;
      }
      if (++v3 == v4) {
        goto LABEL_38;
      }
    }
    uint64_t v22 = 0;
  }
  else
  {
LABEL_39:
    uint64_t v22 = 1;
  }
  if (v24 != v26) {
    free(v24);
  }
  return v22;
}

void sub_1CC35CDE0(void *a1, uint64_t a2)
{
  uint64_t v42 = v46;
  __int16 v43 = v46;
  uint64_t v44 = 32;
  int v45 = 0;
  uint64_t v2 = a1[4];
  uint64_t v3 = a1[5];
  if (v3 == v2) {
    return;
  }
  uint64_t v6 = (unsigned int *)a1 + 19;
  uint64_t v7 = (unsigned int *)(a1 + 9);
  do
  {
    uint64_t v9 = *(uint64_t **)(*(void *)v2 + 88);
    uint64_t v8 = *(uint64_t **)(*(void *)v2 + 96);
    while (v9 != v8)
    {
      uint64_t v10 = *v9;
      uint64_t v12 = a1[7];
      uint64_t v11 = a1[8];
      if (v11 == v12)
      {
        uint64_t v13 = *v6;
        int v14 = (void *)(v11 + 8 * v13);
        if (v13)
        {
          uint64_t v15 = 0;
          uint64_t v16 = 8 * v13;
          while (*(void *)(v11 + v15) != v10)
          {
            v15 += 8;
            if (v16 == v15) {
              goto LABEL_23;
            }
          }
          int v14 = (void *)(v11 + v15);
        }
LABEL_23:
        uint64_t v12 = a1[8];
      }
      else
      {
        uint64_t v17 = *v7;
        int v18 = v17 - 1;
        unsigned int v19 = (v17 - 1) & ((v10 >> 4) ^ (v10 >> 9));
        int v14 = (void *)(v11 + 8 * v19);
        uint64_t v20 = *v14;
        if (*v14 == -1)
        {
          unsigned int v21 = 0;
LABEL_53:
          if (v21) {
            int v14 = v21;
          }
          if (*v14 != v10) {
            int v14 = (void *)(v11 + 8 * v17);
          }
        }
        else
        {
          unsigned int v21 = 0;
          int v22 = 1;
          while (v20 != v10)
          {
            if (v21) {
              BOOL v23 = 0;
            }
            else {
              BOOL v23 = v20 == -2;
            }
            if (v23) {
              unsigned int v21 = v14;
            }
            unsigned int v24 = v19 + v22++;
            unsigned int v19 = v24 & v18;
            int v14 = (void *)(v11 + 8 * (v24 & v18));
            uint64_t v20 = *v14;
            if (*v14 == -1) {
              goto LABEL_53;
            }
          }
        }
      }
      if (v11 == v12) {
        uint64_t v25 = v6;
      }
      else {
        uint64_t v25 = v7;
      }
      if (v14 != (void *)(v11 + 8 * *v25)) {
        goto LABEL_67;
      }
      uint64_t v26 = v43;
      uint64_t v27 = HIDWORD(v44);
      if (v43 == v42)
      {
        if (HIDWORD(v44))
        {
          int v28 = 0;
          uint64_t v29 = 8 * HIDWORD(v44);
          unsigned int v30 = v43;
          while (*(void *)v30 != v10)
          {
            if (*(void *)v30 == -2) {
              int v28 = v30;
            }
            v30 += 8;
            v29 -= 8;
            if (!v29)
            {
              if (!v28) {
                goto LABEL_36;
              }
              *(void *)int v28 = v10;
              --v45;
              goto LABEL_65;
            }
          }
          goto LABEL_67;
        }
LABEL_36:
        unsigned int v31 = v44;
        if (HIDWORD(v44) < v44)
        {
          ++HIDWORD(v44);
          *(void *)&v43[8 * v27] = v10;
LABEL_65:
          unint64_t v41 = *(unsigned int *)(a2 + 8);
          if (v41 >= *(unsigned int *)(a2 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)a2 + 8 * v41) = v10;
          ++*(_DWORD *)(a2 + 8);
          goto LABEL_67;
        }
      }
      else
      {
        unsigned int v31 = v44;
      }
      if (3 * v31 <= 4 * (HIDWORD(v44) - v45))
      {
        if (v31 >= 0x40) {
          v31 *= 2;
        }
        else {
          unsigned int v31 = 128;
        }
      }
      else if (v31 - HIDWORD(v44) >= v31 >> 3)
      {
        goto LABEL_41;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v42, v31);
      unsigned int v31 = v44;
      uint64_t v26 = v43;
LABEL_41:
      unsigned int v32 = v31 - 1;
      unsigned int v33 = (v31 - 1) & ((v10 >> 4) ^ (v10 >> 9));
      uint64_t v34 = &v26[8 * v33];
      uint64_t v35 = *(void *)v34;
      if (*(void *)v34 == -1)
      {
        uint64_t v36 = 0;
LABEL_58:
        if (v36) {
          int v40 = v36;
        }
        else {
          int v40 = v34;
        }
        if (*(void *)v40 != v10)
        {
          if (*(void *)v40 == -2) {
            --v45;
          }
          else {
            ++HIDWORD(v44);
          }
          *(void *)int v40 = v10;
          goto LABEL_65;
        }
      }
      else
      {
        uint64_t v36 = 0;
        int v37 = 1;
        while (v35 != v10)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            uint64_t v36 = v34;
          }
          unsigned int v39 = v33 + v37++;
          unsigned int v33 = v39 & v32;
          uint64_t v34 = &v26[8 * (v39 & v32)];
          uint64_t v35 = *(void *)v34;
          if (*(void *)v34 == -1) {
            goto LABEL_58;
          }
        }
      }
LABEL_67:
      ++v9;
    }
    v2 += 8;
  }
  while (v2 != v3);
  if (v43 != v42) {
    free(v43);
  }
}

void llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getUniqueNonLatchExitBlocks()
{
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getLoopLatch(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 32);
  uint64_t v2 = *(uint64_t **)(v1 + 64);
  uint64_t v3 = *(uint64_t **)(v1 + 72);
  if (v2 == v3) {
    return 0;
  }
  uint64_t v4 = 0;
  uint64_t v5 = (unsigned int *)(a1 + 76);
  uint64_t v6 = (unsigned int *)(a1 + 72);
  uint64_t v8 = *(void *)(a1 + 56);
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v9 = v7;
  do
  {
    uint64_t result = *v2;
    if (v9 == v8)
    {
      uint64_t v11 = *v5;
      uint64_t v12 = (void *)(v8 + 8 * v11);
      if (v11)
      {
        uint64_t v13 = 0;
        uint64_t v14 = 8 * v11;
        while (*(void *)(v8 + v13) != result)
        {
          v13 += 8;
          if (v14 == v13) {
            goto LABEL_8;
          }
        }
        uint64_t v12 = (void *)(v8 + v13);
      }
LABEL_8:
      uint64_t v9 = v8;
    }
    else
    {
      int v16 = *v6 - 1;
      unsigned int v17 = v16 & ((result >> 4) ^ (result >> 9));
      uint64_t v12 = (void *)(v7 + 8 * v17);
      uint64_t v18 = *v12;
      if (*v12 == -1)
      {
        unsigned int v19 = 0;
LABEL_30:
        if (v19) {
          uint64_t v12 = v19;
        }
        if (*v12 != result)
        {
          if (v7 == v8) {
            BOOL v23 = v5;
          }
          else {
            BOOL v23 = v6;
          }
          uint64_t v12 = (void *)(v7 + 8 * *v23);
        }
      }
      else
      {
        unsigned int v19 = 0;
        int v20 = 1;
        while (v18 != result)
        {
          if (v19) {
            BOOL v21 = 0;
          }
          else {
            BOOL v21 = v18 == -2;
          }
          if (v21) {
            unsigned int v19 = v12;
          }
          unsigned int v22 = v17 + v20++;
          unsigned int v17 = v22 & v16;
          uint64_t v12 = (void *)(v7 + 8 * (v22 & v16));
          uint64_t v18 = *v12;
          if (*v12 == -1) {
            goto LABEL_30;
          }
        }
      }
      uint64_t v9 = v7;
    }
    if (v9 == v8) {
      uint64_t v15 = v5;
    }
    else {
      uint64_t v15 = v6;
    }
    if (v12 == (void *)(v9 + 8 * *v15))
    {
      uint64_t result = v4;
    }
    else if (v4)
    {
      return 0;
    }
    ++v2;
    uint64_t v4 = result;
  }
  while (v2 != v3);
  return result;
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getUniqueExitBlock(void *a1)
{
  v5[8] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = v5;
  uint64_t v4 = 0x800000000;
  sub_1CC35CDE0(a1, (uint64_t)&v3);
  if (v4 == 1) {
    uint64_t v1 = *(void *)v3;
  }
  else {
    uint64_t v1 = 0;
  }
  if (v3 != v5) {
    free(v3);
  }
  return v1;
}

void llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::hasNoExitBlocks()
{
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getExitEdges(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(uint64_t **)(result + 32);
  for (uint64_t i = *(uint64_t **)(result + 40); v3 != i; ++v3)
  {
    uint64_t v4 = *v3;
    uint64_t v6 = *(uint64_t **)(*v3 + 88);
    uint64_t v5 = *(uint64_t **)(*v3 + 96);
    while (v6 != v5)
    {
      uint64_t v7 = *v6;
      uint64_t v9 = *(void *)(result + 56);
      uint64_t v8 = *(void *)(result + 64);
      if (v8 == v9)
      {
        uint64_t v10 = *(unsigned int *)(result + 76);
        uint64_t v11 = (void *)(v8 + 8 * v10);
        if (v10)
        {
          uint64_t v12 = 0;
          uint64_t v13 = 8 * v10;
          while (*(void *)(v8 + v12) != v7)
          {
            v12 += 8;
            if (v13 == v12) {
              goto LABEL_22;
            }
          }
          uint64_t v11 = (void *)(v8 + v12);
        }
LABEL_22:
        uint64_t v9 = *(void *)(result + 64);
      }
      else
      {
        uint64_t v14 = *(unsigned int *)(result + 72);
        int v15 = v14 - 1;
        unsigned int v16 = (v14 - 1) & ((v7 >> 4) ^ (v7 >> 9));
        uint64_t v11 = (void *)(v8 + 8 * v16);
        uint64_t v17 = *v11;
        if (*v11 == -1)
        {
          uint64_t v18 = 0;
LABEL_31:
          if (v18) {
            uint64_t v11 = v18;
          }
          if (*v11 != v7) {
            uint64_t v11 = (void *)(v8 + 8 * v14);
          }
        }
        else
        {
          uint64_t v18 = 0;
          int v19 = 1;
          while (v17 != v7)
          {
            if (v18) {
              BOOL v20 = 0;
            }
            else {
              BOOL v20 = v17 == -2;
            }
            if (v20) {
              uint64_t v18 = v11;
            }
            unsigned int v21 = v16 + v19++;
            unsigned int v16 = v21 & v15;
            uint64_t v11 = (void *)(v8 + 8 * (v21 & v15));
            uint64_t v17 = *v11;
            if (*v11 == -1) {
              goto LABEL_31;
            }
          }
        }
      }
      if (v8 == v9) {
        unsigned int v22 = (unsigned int *)(result + 76);
      }
      else {
        unsigned int v22 = (unsigned int *)(result + 72);
      }
      if (v11 == (void *)(v8 + 8 * *v22))
      {
        uint64_t v23 = *(unsigned int *)(a2 + 8);
        if (v23 >= *(_DWORD *)(a2 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        unsigned int v24 = (void *)(*(void *)a2 + 16 * v23);
        *unsigned int v24 = v4;
        v24[1] = v7;
        *(_DWORD *)(a2 + 8) = v23 + 1;
      }
      ++v6;
    }
  }
  return result;
}

void llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getLoopPreheader()
{
}

{
  while (1)
    ;
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getLoopPredecessor(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 32);
  uint64_t v2 = *(uint64_t **)(v1 + 64);
  uint64_t v3 = *(uint64_t **)(v1 + 72);
  if (v2 != v3)
  {
    uint64_t v4 = 0;
    uint64_t v5 = (unsigned int *)(a1 + 76);
    uint64_t v6 = (unsigned int *)(a1 + 72);
    uint64_t v8 = *(void *)(a1 + 56);
    uint64_t v7 = *(void *)(a1 + 64);
    uint64_t v9 = v7;
    while (1)
    {
      uint64_t result = *v2;
      if (v9 == v8)
      {
        uint64_t v11 = *v5;
        uint64_t v12 = (void *)(v8 + 8 * v11);
        if (v11)
        {
          uint64_t v13 = 0;
          uint64_t v14 = 8 * v11;
          while (*(void *)(v8 + v13) != result)
          {
            v13 += 8;
            if (v14 == v13) {
              goto LABEL_8;
            }
          }
          uint64_t v12 = (void *)(v8 + v13);
        }
LABEL_8:
        uint64_t v9 = v8;
      }
      else
      {
        int v16 = *v6 - 1;
        unsigned int v17 = v16 & ((result >> 4) ^ (result >> 9));
        uint64_t v12 = (void *)(v7 + 8 * v17);
        uint64_t v18 = *v12;
        if (*v12 == -1)
        {
          int v19 = 0;
LABEL_32:
          if (v19) {
            uint64_t v12 = v19;
          }
          if (*v12 != result)
          {
            if (v7 == v8) {
              uint64_t v23 = v5;
            }
            else {
              uint64_t v23 = v6;
            }
            uint64_t v12 = (void *)(v7 + 8 * *v23);
          }
        }
        else
        {
          int v19 = 0;
          int v20 = 1;
          while (v18 != result)
          {
            if (v19) {
              BOOL v21 = 0;
            }
            else {
              BOOL v21 = v18 == -2;
            }
            if (v21) {
              int v19 = v12;
            }
            unsigned int v22 = v17 + v20++;
            unsigned int v17 = v22 & v16;
            uint64_t v12 = (void *)(v7 + 8 * (v22 & v16));
            uint64_t v18 = *v12;
            if (*v12 == -1) {
              goto LABEL_32;
            }
          }
        }
        uint64_t v9 = v7;
      }
      if (v9 == v8) {
        int v15 = v5;
      }
      else {
        int v15 = v6;
      }
      if (v12 == (void *)(v9 + 8 * *v15))
      {
        if (v4 && v4 != result) {
          return 0;
        }
      }
      else
      {
        uint64_t result = v4;
      }
      ++v2;
      uint64_t v4 = result;
      if (v2 == v3) {
        return result;
      }
    }
  }
  return 0;
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getLoopLatches(uint64_t result, uint64_t a2)
{
  uint64_t v2 = **(void **)(result + 32);
  uint64_t v3 = *(uint64_t **)(v2 + 64);
  for (uint64_t i = *(uint64_t **)(v2 + 72); v3 != i; ++v3)
  {
    uint64_t v5 = *v3;
    uint64_t v7 = *(void *)(result + 56);
    uint64_t v6 = *(void *)(result + 64);
    if (v6 == v7)
    {
      uint64_t v8 = *(unsigned int *)(result + 76);
      uint64_t v9 = (void *)(v6 + 8 * v8);
      if (v8)
      {
        uint64_t v10 = 0;
        uint64_t v11 = 8 * v8;
        while (*(void *)(v6 + v10) != v5)
        {
          v10 += 8;
          if (v11 == v10) {
            goto LABEL_7;
          }
        }
        uint64_t v9 = (void *)(v6 + v10);
      }
LABEL_7:
      uint64_t v7 = *(void *)(result + 64);
    }
    else
    {
      uint64_t v14 = *(unsigned int *)(result + 72);
      int v15 = v14 - 1;
      unsigned int v16 = (v14 - 1) & ((v5 >> 4) ^ (v5 >> 9));
      uint64_t v9 = (void *)(v6 + 8 * v16);
      uint64_t v17 = *v9;
      if (*v9 == -1)
      {
        uint64_t v18 = 0;
LABEL_29:
        if (v18) {
          uint64_t v9 = v18;
        }
        if (*v9 != v5) {
          uint64_t v9 = (void *)(v6 + 8 * v14);
        }
      }
      else
      {
        uint64_t v18 = 0;
        int v19 = 1;
        while (v17 != v5)
        {
          if (v18) {
            BOOL v20 = 0;
          }
          else {
            BOOL v20 = v17 == -2;
          }
          if (v20) {
            uint64_t v18 = v9;
          }
          unsigned int v21 = v16 + v19++;
          unsigned int v16 = v21 & v15;
          uint64_t v9 = (void *)(v6 + 8 * (v21 & v15));
          uint64_t v17 = *v9;
          if (*v9 == -1) {
            goto LABEL_29;
          }
        }
      }
    }
    if (v6 == v7) {
      uint64_t v12 = (unsigned int *)(result + 76);
    }
    else {
      uint64_t v12 = (unsigned int *)(result + 72);
    }
    if (v9 != (void *)(v6 + 8 * *v12))
    {
      unint64_t v13 = *(unsigned int *)(a2 + 8);
      if (v13 >= *(unsigned int *)(a2 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a2 + 8 * v13) = v5;
      ++*(_DWORD *)(a2 + 8);
    }
  }
  return result;
}

void llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getLoopsInPreorder(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  *(void *)(a2 + 16) = a1;
  *(void *)a2 = a2 + 16;
  *(void *)(a2 + 8) = 0x400000001;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v7 = v9;
  uint64_t v8 = 0x400000000;
  sub_1CD475C08((uint64_t)&v7, v3, v3, v4, v4);
  while (v8)
  {
    uint64_t v5 = *((void *)v7 + v8 - 1);
    LODWORD(v8) = v8 - 1;
    sub_1CD475C08((uint64_t)&v7, *(void *)(v5 + 16), *(void *)(v5 + 16), *(void *)(v5 + 8), *(void *)(v5 + 8));
    unint64_t v6 = *(unsigned int *)(a2 + 8);
    if (v6 >= *(unsigned int *)(a2 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)a2 + 8 * v6) = v5;
    ++*(_DWORD *)(a2 + 8);
  }
  if (v7 != v9) {
    free(v7);
  }
}

void llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getLoopsInPreorder(uint64_t a1@<X0>, void *a2@<X8>)
{
  a2[2] = a1;
  *a2 = a2 + 2;
  a2[1] = 0x400000001;
  sub_1CC35DD44(*(void *)(a1 + 8), *(void *)(a1 + 16), (uint64_t)a2);
}

void sub_1CC35DD44(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = v9;
  uint64_t v8 = 0x400000000;
  sub_1CD475C08((uint64_t)&v7, a2, a2, a1, a1);
  for (unsigned int i = v8; v8; unsigned int i = v8)
  {
    uint64_t v5 = *((void *)v7 + i - 1);
    LODWORD(v8) = i - 1;
    sub_1CD475C08((uint64_t)&v7, *(void *)(v5 + 16), *(void *)(v5 + 16), *(void *)(v5 + 8), *(void *)(v5 + 8));
    unint64_t v6 = *(unsigned int *)(a3 + 8);
    if (v6 >= *(unsigned int *)(a3 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)a3 + 8 * v6) = v5;
    ++*(_DWORD *)(a3 + 8);
  }
  if (v7 != v9) {
    free(v7);
  }
}

void llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::addBlockEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = a2;
  uint64_t v3 = *(void **)(a1 + 40);
  if ((unint64_t)v3 >= *(void *)(a1 + 48))
  {
    uint64_t v5 = sub_1CBC13470((void **)(a1 + 32), &v22);
    uint64_t v4 = v22;
  }
  else
  {
    uint64_t v4 = a2;
    void *v3 = a2;
    uint64_t v5 = v3 + 1;
  }
  uint64_t v6 = *(void *)(a1 + 56);
  *(void *)(a1 + 40) = v5;
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v8 = *(unsigned int *)(a1 + 76);
  if (v7 != v6)
  {
    unsigned int v12 = *(_DWORD *)(a1 + 72);
    goto LABEL_15;
  }
  if (!v8)
  {
LABEL_11:
    unsigned int v12 = *(_DWORD *)(a1 + 72);
    if (v8 < v12)
    {
      *(_DWORD *)(a1 + 76) = v8 + 1;
      *(void *)(v7 + 8 * v8) = v4;
      return;
    }
LABEL_15:
    if (3 * v12 <= 4 * ((int)v8 - *(_DWORD *)(a1 + 80)))
    {
      if (v12 >= 0x40) {
        v12 *= 2;
      }
      else {
        unsigned int v12 = 128;
      }
    }
    else if (v12 - v8 >= v12 >> 3)
    {
      goto LABEL_17;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(a1 + 56), v12);
    unsigned int v12 = *(_DWORD *)(a1 + 72);
    uint64_t v7 = *(void *)(a1 + 64);
LABEL_17:
    unsigned int v13 = v12 - 1;
    unsigned int v14 = (v12 - 1) & ((v4 >> 4) ^ (v4 >> 9));
    int v15 = (void *)(v7 + 8 * v14);
    uint64_t v16 = *v15;
    if (*v15 == -1)
    {
      uint64_t v17 = 0;
LABEL_29:
      if (v17) {
        unsigned int v21 = v17;
      }
      else {
        unsigned int v21 = v15;
      }
      if (*v21 != v4)
      {
        if (*v21 == -2) {
          --*(_DWORD *)(a1 + 80);
        }
        else {
          ++*(_DWORD *)(a1 + 76);
        }
        *unsigned int v21 = v4;
      }
    }
    else
    {
      uint64_t v17 = 0;
      int v18 = 1;
      while (v16 != v4)
      {
        if (v17) {
          BOOL v19 = 0;
        }
        else {
          BOOL v19 = v16 == -2;
        }
        if (v19) {
          uint64_t v17 = v15;
        }
        unsigned int v20 = v14 + v18++;
        unsigned int v14 = v20 & v13;
        int v15 = (void *)(v7 + 8 * (v20 & v13));
        uint64_t v16 = *v15;
        if (*v15 == -1) {
          goto LABEL_29;
        }
      }
    }
    return;
  }
  uint64_t v9 = 0;
  uint64_t v10 = 8 * v8;
  uint64_t v11 = *(void **)(a1 + 64);
  while (*v11 != v4)
  {
    if (*v11 == -2) {
      uint64_t v9 = v11;
    }
    ++v11;
    v10 -= 8;
    if (!v10)
    {
      if (!v9) {
        goto LABEL_11;
      }
      *uint64_t v9 = v4;
      --*(_DWORD *)(a1 + 80);
      return;
    }
  }
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::replaceChildLoopWith(uint64_t result, void *a2, void *a3)
{
  uint64_t v3 = *(void **)(result + 8);
  uint64_t v4 = *(void **)(result + 16);
  if (v3 != v4)
  {
    while ((void *)*v3 != a2)
    {
      if (++v3 == v4)
      {
        uint64_t v3 = *(void **)(result + 16);
        break;
      }
    }
  }
  void *v3 = a3;
  *a2 = 0;
  *a3 = result;
  return result;
}

void llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::addChildLoop(void *a1, void *a2)
{
  *a2 = a1;
  uint64_t v5 = (void *)a1[2];
  unint64_t v4 = a1[3];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = (void *)a1[1];
    uint64_t v8 = v5 - v7;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61) {
      abort();
    }
    uint64_t v10 = v4 - (void)v7;
    if (v10 >> 2 > v9) {
      unint64_t v9 = v10 >> 2;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 >> 61) {
        sub_1CB833614();
      }
      unsigned int v12 = (char *)operator new(8 * v11);
    }
    else
    {
      unsigned int v12 = 0;
    }
    unsigned int v13 = &v12[8 * v8];
    *(void *)unsigned int v13 = a2;
    uint64_t v6 = v13 + 8;
    if (v5 != v7)
    {
      do
      {
        uint64_t v14 = *--v5;
        *((void *)v13 - 1) = v14;
        v13 -= 8;
      }
      while (v5 != v7);
      uint64_t v5 = (void *)a1[1];
    }
    a1[1] = v13;
    a1[2] = v6;
    a1[3] = &v12[8 * v11];
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    *uint64_t v5 = a2;
    uint64_t v6 = v5 + 1;
  }
  a1[2] = v6;
}

void *llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::removeChildLoop(uint64_t a1, char *__dst)
{
  uint64_t v6 = *(void **)__dst;
  unint64_t v4 = __dst + 8;
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(a1 + 16);
  int64_t v8 = v7 - v4;
  if (v7 != v4) {
    memmove(__dst, v4, v7 - v4);
  }
  *(void *)(a1 + 16) = &__dst[v8];
  *uint64_t v5 = 0;
  return v5;
}

void *llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::removeChildLoop(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void **)(a1 + 8);
  uint64_t v3 = *(char **)(a1 + 16);
  if (v4 != (void *)v3)
  {
    while (*v4 != a2)
    {
      if (++v4 == (void *)v3)
      {
        unint64_t v4 = *(void **)(a1 + 16);
        break;
      }
    }
  }
  uint64_t v5 = (void *)*v4;
  int64_t v6 = v3 - (char *)(v4 + 1);
  if (v3 != (char *)(v4 + 1)) {
    memmove(v4, v4 + 1, v3 - (char *)(v4 + 1));
  }
  *(void *)(a1 + 16) = (char *)v4 + v6;
  *uint64_t v5 = 0;
  return v5;
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::reverseBlock(uint64_t result, unsigned int a2)
{
  uint64_t v2 = *(void *)(result + 32);
  uint64_t v3 = *(void *)(result + 40);
  unint64_t v4 = v2 + 8 * a2;
  uint64_t v5 = (void *)(v3 - 8);
  BOOL v6 = v4 == v3 || v4 >= (unint64_t)v5;
  if (!v6)
  {
    unint64_t v7 = v2 + 8 * a2 + 8;
    do
    {
      uint64_t v8 = *(void *)(v7 - 8);
      *(void *)(v7 - 8) = *v5;
      *v5-- = v8;
      BOOL v6 = v7 >= (unint64_t)v5;
      v7 += 8;
    }
    while (!v6);
  }
  return result;
}

void llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::reserveBlocks(uint64_t a1, unsigned int a2)
{
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::moveToHeader(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void **)(result + 32);
  if (*v2 != a2)
  {
    int v3 = 0;
    do
    {
      int v4 = v3;
      uint64_t v5 = v2[v3++];
    }
    while (v5 != a2);
    v2[v4] = *v2;
    **(void **)(result + 32) = a2;
  }
  return result;
}

void *llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::removeBlockFromLoop(void *result, uint64_t a2)
{
  int v3 = result;
  uint64_t v5 = (char *)result[4];
  int v4 = (char *)result[5];
  if (v5 != v4)
  {
    while (*(void *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        uint64_t v5 = (char *)result[5];
        break;
      }
    }
  }
  int64_t v6 = v4 - (v5 + 8);
  if (v4 != v5 + 8) {
    uint64_t result = memmove(v5, v5 + 8, v4 - (v5 + 8));
  }
  v3[5] = &v5[v6];
  uint64_t v8 = v3[7];
  uint64_t v7 = v3[8];
  if (v7 == v8)
  {
    uint64_t v9 = *((unsigned int *)v3 + 19);
    uint64_t v10 = (void *)(v7 + 8 * v9);
    if (v9)
    {
      uint64_t v11 = 0;
      uint64_t v12 = 8 * v9;
      while (*(void *)(v7 + v11) != a2)
      {
        v11 += 8;
        if (v12 == v11) {
          goto LABEL_12;
        }
      }
      uint64_t v10 = (void *)(v7 + v11);
    }
LABEL_12:
    uint64_t v8 = v3[8];
  }
  else
  {
    uint64_t v14 = *((unsigned int *)v3 + 18);
    int v15 = v14 - 1;
    unsigned int v16 = (v14 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v10 = (void *)(v7 + 8 * v16);
    uint64_t v17 = *v10;
    if (*v10 == -1)
    {
      int v18 = 0;
LABEL_31:
      if (v18) {
        uint64_t v10 = v18;
      }
      if (*v10 != a2) {
        uint64_t v10 = (void *)(v7 + 8 * v14);
      }
    }
    else
    {
      int v18 = 0;
      int v19 = 1;
      while (v17 != a2)
      {
        if (v18) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v17 == -2;
        }
        if (v20) {
          int v18 = v10;
        }
        unsigned int v21 = v16 + v19++;
        unsigned int v16 = v21 & v15;
        uint64_t v10 = (void *)(v7 + 8 * (v21 & v15));
        uint64_t v17 = *v10;
        if (*v10 == -1) {
          goto LABEL_31;
        }
      }
    }
  }
  BOOL v20 = v7 == v8;
  uint64_t v13 = 72;
  if (v20) {
    uint64_t v13 = 76;
  }
  if (v10 != (void *)(v7 + 8 * *(unsigned int *)((char *)v3 + v13)))
  {
    *uint64_t v10 = -2;
    ++*((_DWORD *)v3 + 20);
  }
  return result;
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::verifyLoopNest(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = 0;
  uint64_t result = sub_1CC091A20(*(void *)a2, *(_DWORD *)(a2 + 16), a1, &v11);
  if (result) {
    goto LABEL_7;
  }
  unsigned int v5 = *(_DWORD *)(a2 + 16);
  int v6 = *(_DWORD *)(a2 + 8);
  if (4 * v6 + 4 >= 3 * v5)
  {
    v5 *= 2;
    goto LABEL_12;
  }
  if (v5 + ~v6 - *(_DWORD *)(a2 + 12) <= v5 >> 3)
  {
LABEL_12:
    sub_1CC091AB4(a2, v5);
    uint64_t v11 = 0;
    uint64_t result = sub_1CC091A20(*(void *)a2, *(_DWORD *)(a2 + 16), a1, &v11);
  }
  uint64_t v7 = v11;
  ++*(_DWORD *)(a2 + 8);
  if (*v7 != -4096) {
    --*(_DWORD *)(a2 + 12);
  }
  *uint64_t v7 = a1;
LABEL_7:
  uint64_t v9 = *(uint64_t **)(a1 + 8);
  uint64_t v8 = *(uint64_t **)(a1 + 16);
  while (v9 != v8)
  {
    uint64_t v10 = *v9++;
    uint64_t result = llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::verifyLoopNest(v10, a2);
  }
  return result;
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::isAnnotatedParallel()
{
  return 0;
}

void llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::print(uint64_t a1, llvm::raw_ostream *a2, int a3, char a4, int a5)
{
  llvm::raw_ostream::indent(a2, 2 * a5);
  uint64_t v8 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v8 > 0xDuLL)
  {
    qmemcpy(v8, "Loop at depth ", 14);
    *((void *)a2 + 4) += 14;
  }
  else
  {
    llvm::raw_ostream::write(a2, "Loop at depth ", 0xEuLL);
  }
  LODWORD(v9) = 0;
  uint64_t v10 = (void *)a1;
  do
  {
    uint64_t v10 = (void *)*v10;
    unint64_t v9 = (v9 + 1);
  }
  while (v10);
  sub_1CD098D14(a2, v9, 0, 0, 0);
  uint64_t v11 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v11 > 0xCuLL)
  {
    qmemcpy(v11, " containing: ", 13);
    *((void *)a2 + 4) += 13;
  }
  else
  {
    llvm::raw_ostream::write(a2, " containing: ", 0xDuLL);
  }
  uint64_t v12 = *(llvm::MachineBasicBlock ***)(a1 + 32);
  if (*(llvm::MachineBasicBlock ***)(a1 + 40) != v12)
  {
    uint64_t v13 = 0;
    unsigned int v14 = 0;
    int v15 = *v12;
    while (1)
    {
      unsigned int v16 = v12[v13];
      if (a3)
      {
        uint64_t v17 = (unsigned char *)*((void *)a2 + 4);
        if (*((unsigned char **)a2 + 3) == v17)
        {
          llvm::raw_ostream::write(a2, "\n", 1uLL);
        }
        else
        {
          unsigned char *v17 = 10;
          ++*((void *)a2 + 4);
        }
      }
      else
      {
        if (v14)
        {
          __int16 v43 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v43)
          {
            llvm::raw_ostream::write(a2, ",", 1uLL);
          }
          else
          {
            *__int16 v43 = 44;
            ++*((void *)a2 + 4);
          }
        }
        llvm::MachineBasicBlock::printAsOperand(v16, a2);
      }
      if (v16 == v15)
      {
        int v18 = (void *)*((void *)a2 + 4);
        if (*((void *)a2 + 3) - (void)v18 > 7uLL)
        {
          *int v18 = 0x3E7265646165683CLL;
          *((void *)a2 + 4) += 8;
        }
        else
        {
          llvm::raw_ostream::write(a2, "<header>", 8uLL);
        }
      }
      uint64_t v19 = **(void **)(a1 + 32);
      BOOL v20 = *(llvm::MachineBasicBlock ***)(v19 + 64);
      unsigned int v21 = *(llvm::MachineBasicBlock ***)(v19 + 72);
      if (v20 != v21)
      {
        while (*v20 != v16)
        {
          if (++v20 == v21)
          {
            BOOL v20 = v21;
            break;
          }
        }
      }
      if (v20 != v21)
      {
        uint64_t v22 = (_DWORD *)*((void *)a2 + 4);
        if (*((void *)a2 + 3) - (void)v22 > 6uLL)
        {
          *(_DWORD *)((char *)v22 + 3) = 1047028596;
          *uint64_t v22 = 1952541756;
          *((void *)a2 + 4) += 7;
        }
        else
        {
          llvm::raw_ostream::write(a2, "<latch>", 7uLL);
        }
      }
      uint64_t v23 = (uint64_t *)*((void *)v16 + 11);
      unsigned int v24 = (uint64_t *)*((void *)v16 + 12);
      if (v23 == v24) {
        goto LABEL_60;
      }
      uint64_t v26 = *(void *)(a1 + 56);
      uint64_t v25 = *(void *)(a1 + 64);
      uint64_t v27 = (unsigned int *)(v25 == v26 ? a1 + 76 : a1 + 72);
      uint64_t v28 = *(void *)(a1 + 64);
      while (1)
      {
        uint64_t v29 = *v23;
        if (v28 == v26)
        {
          uint64_t v30 = *(unsigned int *)(a1 + 76);
          unsigned int v31 = (void *)(v26 + 8 * v30);
          if (v30)
          {
            uint64_t v32 = 0;
            uint64_t v33 = 8 * v30;
            while (*(void *)(v26 + v32) != v29)
            {
              v32 += 8;
              if (v33 == v32) {
                goto LABEL_45;
              }
            }
            unsigned int v31 = (void *)(v26 + v32);
          }
LABEL_45:
          uint64_t v28 = *(void *)(a1 + 56);
        }
        else
        {
          int v34 = *(_DWORD *)(a1 + 72) - 1;
          unsigned int v35 = v34 & ((v29 >> 4) ^ (v29 >> 9));
          unsigned int v31 = (void *)(v25 + 8 * v35);
          uint64_t v36 = *v31;
          if (*v31 == -1)
          {
            int v37 = 0;
LABEL_47:
            if (v37) {
              unsigned int v31 = v37;
            }
            if (*v31 != v29) {
              unsigned int v31 = (void *)(v25 + 8 * *v27);
            }
          }
          else
          {
            int v37 = 0;
            int v38 = 1;
            while (v36 != v29)
            {
              if (v37) {
                BOOL v39 = 0;
              }
              else {
                BOOL v39 = v36 == -2;
              }
              if (v39) {
                int v37 = v31;
              }
              unsigned int v40 = v35 + v38++;
              unsigned int v35 = v40 & v34;
              unsigned int v31 = (void *)(v25 + 8 * (v40 & v34));
              uint64_t v36 = *v31;
              if (*v31 == -1) {
                goto LABEL_47;
              }
            }
          }
          uint64_t v28 = *(void *)(a1 + 64);
        }
        unint64_t v41 = (unsigned int *)(v28 == v26 ? a1 + 76 : a1 + 72);
        if (v31 == (void *)(v28 + 8 * *v41)) {
          break;
        }
        if (++v23 == v24) {
          goto LABEL_60;
        }
      }
      uint64_t v42 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v42) <= 8) {
        break;
      }
      *(unsigned char *)(v42 + 8) = 62;
      *(void *)uint64_t v42 = *(void *)"<exiting>";
      *((void *)a2 + 4) += 9;
      if (a3) {
LABEL_71:
      }
        llvm::MachineBasicBlock::print(v16, a2, 0, (const llvm::TargetRegisterInfo *)1);
LABEL_61:
      uint64_t v12 = *(llvm::MachineBasicBlock ***)(a1 + 32);
      uint64_t v13 = ++v14;
      if (v14 >= (unint64_t)((uint64_t)(*(void *)(a1 + 40) - (void)v12) >> 3)) {
        goto LABEL_73;
      }
    }
    llvm::raw_ostream::write(a2, "<exiting>", 9uLL);
LABEL_60:
    if (a3) {
      goto LABEL_71;
    }
    goto LABEL_61;
  }
LABEL_73:
  if (a4)
  {
    uint64_t v44 = (unsigned char *)*((void *)a2 + 4);
    if (*((unsigned char **)a2 + 3) == v44)
    {
      llvm::raw_ostream::write(a2, "\n", 1uLL);
    }
    else
    {
      *uint64_t v44 = 10;
      ++*((void *)a2 + 4);
    }
    unsigned int v46 = *(uint64_t **)(a1 + 8);
    int v45 = *(uint64_t **)(a1 + 16);
    while (v46 != v45)
    {
      uint64_t v47 = *v46++;
      llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::print(v47, a2, 0, 1, (a5 + 2));
    }
  }
}

double llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::LoopBase(uint64_t a1)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = a1 + 88;
  *(void *)(a1 + 64) = a1 + 88;
  *(void *)&double result = 8;
  *(void *)(a1 + 72) = 8;
  *(_DWORD *)(a1 + 80) = 0;
  return result;
}

{
  double result;

  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = a1 + 88;
  *(void *)(a1 + 64) = a1 + 88;
  *(void *)&double result = 8;
  *(void *)(a1 + 72) = 8;
  *(_DWORD *)(a1 + 80) = 0;
  return result;
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::LoopBase(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 56) = a1 + 88;
  *(void *)(a1 + 64) = a1 + 88;
  *(_DWORD *)(a1 + 80) = 0;
  int v4 = operator new(8uLL);
  *(void *)(a1 + 32) = v4;
  *v4++ = a2;
  *(void *)(a1 + 40) = v4;
  *(void *)(a1 + 48) = v4;
  *(void *)(a1 + 72) = 0x100000008;
  *(void *)(a1 + 88) = a2;
  return a1;
}

{
  void *v4;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 56) = a1 + 88;
  *(void *)(a1 + 64) = a1 + 88;
  *(_DWORD *)(a1 + 80) = 0;
  int v4 = operator new(8uLL);
  *(void *)(a1 + 32) = v4;
  *v4++ = a2;
  *(void *)(a1 + 40) = v4;
  *(void *)(a1 + 48) = v4;
  *(void *)(a1 + 72) = 0x100000008;
  *(void *)(a1 + 88) = a2;
  return a1;
}

uint64_t llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::~LoopBase(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 8);
  int v3 = *(uint64_t **)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v9 = *v2++;
      llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::~LoopBase(v9);
    }
    while (v2 != v3);
    uint64_t v2 = *(uint64_t **)(a1 + 8);
  }
  uint64_t v4 = *(void *)(a1 + 56);
  *(void *)(a1 + 16) = v2;
  *(void *)(a1 + 40) = *(void *)(a1 + 32);
  if (*(void *)(a1 + 64) == v4) {
    goto LABEL_3;
  }
  uint64_t v10 = *(unsigned int *)(a1 + 72);
  if (v10 < 0x21 || 4 * (*(_DWORD *)(a1 + 76) - *(_DWORD *)(a1 + 80)) >= v10)
  {
    memset(*(void **)(a1 + 64), 255, 8 * v10);
LABEL_3:
    *(_DWORD *)(a1 + 76) = 0;
    *(_DWORD *)(a1 + 80) = 0;
    goto LABEL_4;
  }
  llvm::SmallPtrSetImplBase::shrink_and_clear((void **)(a1 + 56));
LABEL_4:
  *(void *)a1 = 0;
  unsigned int v5 = *(void **)(a1 + 64);
  if (v5 != *(void **)(a1 + 56)) {
    free(v5);
  }
  int v6 = *(void **)(a1 + 32);
  if (v6)
  {
    *(void *)(a1 + 40) = v6;
    operator delete(v6);
  }
  uint64_t v7 = *(void **)(a1 + 8);
  if (v7)
  {
    *(void *)(a1 + 16) = v7;
    operator delete(v7);
  }
  return a1;
}

void llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::~LoopInfoBase()
{
}

{
  while (1)
    ;
}

_DWORD *llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::releaseMemory(_DWORD *result)
{
  uint64_t v1 = result;
  int v2 = result[2];
  if (v2 || result[3])
  {
    uint64_t v11 = result[4];
    if (v11 <= 4 * v2 || v11 < 0x41)
    {
      if (v11)
      {
        uint64_t v12 = *(void **)result;
        uint64_t v13 = 16 * v11;
        do
        {
          *uint64_t v12 = -4096;
          v12 += 2;
          v13 -= 16;
        }
        while (v13);
      }
      *((void *)result + 1) = 0;
    }
    else
    {
      double result = sub_1CBA7B248(result);
    }
  }
  uint64_t v3 = *((void *)v1 + 3);
  if (v3 != *((void *)v1 + 4)) {
    llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::~LoopBase();
  }
  *((void *)v1 + 4) = v3;
  uint64_t v4 = v1[30];
  if (v4)
  {
    unsigned int v14 = (uint64_t *)*((void *)v1 + 14);
    uint64_t v15 = 16 * v4;
    do
    {
      uint64_t v16 = *v14;
      v14 += 2;
      double result = (_DWORD *)MEMORY[0x1D25D9CD0](v16, 8);
      v15 -= 16;
    }
    while (v15);
  }
  v1[30] = 0;
  uint64_t v5 = v1[18];
  if (v5)
  {
    *((void *)v1 + 16) = 0;
    int v6 = (void *)*((void *)v1 + 8);
    uint64_t v7 = *v6 + 4096;
    *((void *)v1 + 6) = *v6;
    *((void *)v1 + 7) = v7;
    if (v5 != 1)
    {
      uint64_t v8 = v6 + 1;
      uint64_t v9 = 8 * v5 - 8;
      do
      {
        uint64_t v10 = *v8++;
        double result = (_DWORD *)MEMORY[0x1D25D9CD0](v10, 8);
        v9 -= 8;
      }
      while (v9);
    }
    v1[18] = 1;
  }
  return result;
}

uint64_t llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::LoopInfoBase(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)a1 = *(void *)a2;
  *(void *)a2 = 0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = 0;
  int v4 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = v4;
  int v5 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v5;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  sub_1CC056A04(a1 + 48, a2 + 48);
  *(void *)(a2 + 32) = *(void *)(a2 + 24);
  return a1;
}

uint64_t llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::operator=(uint64_t a1, uint64_t a2)
{
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)a1 = *(void *)a2;
  *(void *)a2 = 0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = 0;
  int v4 = *(void **)(a1 + 24);
  int v5 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = v5;
  int v6 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v6;
  if (v4 != *(void **)(a1 + 32)) {
    llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::~LoopBase();
  }
  if (v4)
  {
    *(void *)(a1 + 32) = v4;
    operator delete(v4);
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
  }
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  sub_1CD49A7EC(a1 + 48, a2 + 48);
  *(void *)(a2 + 32) = *(void *)(a2 + 24);
  return a1;
}

uint64_t llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::begin(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::end(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::rbegin(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::rend(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

BOOL llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::empty(uint64_t a1)
{
  return *(void *)(a1 + 24) == *(void *)(a1 + 32);
}

void llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getLoopsInPreorder(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v13[4] = *MEMORY[0x1E4F143B8];
  *(void *)a2 = a2 + 16;
  *(void *)(a2 + 8) = 0x400000000;
  uint64_t v11 = v13;
  uint64_t v12 = 0x400000000;
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3 != v4)
  {
    do
    {
      uint64_t v5 = *(void *)(v3 - 8);
      v3 -= 8;
      uint64_t __src = v10;
      v10[0] = v5;
      uint64_t v9 = 0x400000001;
      sub_1CC35DD44(*(void *)(v5 + 8), *(void *)(v5 + 16), (uint64_t)&__src);
      int v6 = v9;
      uint64_t v7 = *(unsigned int *)(a2 + 8);
      if (v7 + (unint64_t)v9 > *(unsigned int *)(a2 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v9)
      {
        memcpy((void *)(*(void *)a2 + 8 * v7), __src, 8 * v9);
        LODWORD(v7) = *(_DWORD *)(a2 + 8);
      }
      *(_DWORD *)(a2 + 8) = v7 + v6;
      if (__src != v10) {
        free(__src);
      }
    }
    while (v3 != v4);
    if (v11 != v13) {
      free(v11);
    }
  }
}

void llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getLoopsInReverseSiblingPreorder(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  void v10[4] = *MEMORY[0x1E4F143B8];
  *(void *)a2 = a2 + 16;
  *(void *)(a2 + 8) = 0x400000000;
  uint64_t v8 = v10;
  uint64_t v9 = 0x400000000;
  uint64_t v3 = *(void **)(a1 + 24);
  uint64_t v4 = *(void **)(a1 + 32);
  if (v3 != v4)
  {
    do
    {
      if (!HIDWORD(v9)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)uint64_t v8 = *v3;
      unsigned int v5 = v9 + 1;
      do
      {
        uint64_t v6 = *((void *)v8 + v5 - 1);
        LODWORD(v9) = v5 - 1;
        sub_1CBAACC38((uint64_t)&v8, *(char **)(v6 + 8), *(char **)(v6 + 16));
        unint64_t v7 = *(unsigned int *)(a2 + 8);
        if (v7 >= *(unsigned int *)(a2 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a2 + 8 * v7) = v6;
        ++*(_DWORD *)(a2 + 8);
        unsigned int v5 = v9;
      }
      while (v9);
      ++v3;
    }
    while (v3 != v4);
    if (v8 != v10) {
      free(v8);
    }
  }
}

uint64_t llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getLoopFor(uint64_t *a1, uint64_t a2)
{
  int v2 = *((_DWORD *)a1 + 4);
  if (v2)
  {
    uint64_t v3 = *a1;
    unsigned int v4 = v2 - 1;
    uint64_t v5 = (v2 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v6 = *(void *)(*a1 + 16 * v5);
    if (v6 == a2) {
      return *(void *)(v3 + 16 * v5 + 8);
    }
    int v7 = 1;
    while (v6 != -4096)
    {
      int v8 = v5 + v7++;
      uint64_t v5 = v8 & v4;
      uint64_t v6 = *(void *)(v3 + 16 * v5);
      if (v6 == a2) {
        return *(void *)(v3 + 16 * v5 + 8);
      }
    }
  }
  return 0;
}

uint64_t llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::operator[](uint64_t *a1, uint64_t a2)
{
  int v2 = *((_DWORD *)a1 + 4);
  if (v2)
  {
    uint64_t v3 = *a1;
    unsigned int v4 = v2 - 1;
    uint64_t v5 = (v2 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v6 = *(void *)(*a1 + 16 * v5);
    if (v6 == a2) {
      return *(void *)(v3 + 16 * v5 + 8);
    }
    int v7 = 1;
    while (v6 != -4096)
    {
      int v8 = v5 + v7++;
      uint64_t v5 = v8 & v4;
      uint64_t v6 = *(void *)(v3 + 16 * v5);
      if (v6 == a2) {
        return *(void *)(v3 + 16 * v5 + 8);
      }
    }
  }
  return 0;
}

uint64_t llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getLoopDepth(uint64_t *a1, uint64_t a2)
{
  int v2 = *((_DWORD *)a1 + 4);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *a1;
  unsigned int v4 = v2 - 1;
  uint64_t v5 = (v2 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v6 = *(void *)(*a1 + 16 * v5);
  if (v6 != a2)
  {
    int v7 = 1;
    while (v6 != -4096)
    {
      int v8 = v5 + v7++;
      uint64_t v5 = v8 & v4;
      uint64_t v6 = *(void *)(v3 + 16 * v5);
      if (v6 == a2) {
        goto LABEL_6;
      }
    }
    return 0;
  }
LABEL_6:
  uint64_t v9 = *(void **)(v3 + 16 * v5 + 8);
  if (!v9) {
    return 0;
  }
  LODWORD(result) = 0;
  do
  {
    uint64_t v9 = (void *)*v9;
    uint64_t result = (result + 1);
  }
  while (v9);
  return result;
}

BOOL llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::isLoopHeader(uint64_t *a1, uint64_t a2)
{
  int v2 = *((_DWORD *)a1 + 4);
  if (v2)
  {
    uint64_t v3 = *a1;
    unsigned int v4 = v2 - 1;
    uint64_t v5 = (v2 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v6 = *(void *)(*a1 + 16 * v5);
    if (v6 == a2)
    {
LABEL_6:
      uint64_t v9 = *(void *)(v3 + 16 * v5 + 8);
      if (v9) {
        return **(void **)(v9 + 32) == a2;
      }
    }
    else
    {
      int v7 = 1;
      while (v6 != -4096)
      {
        int v8 = v5 + v7++;
        uint64_t v5 = v8 & v4;
        uint64_t v6 = *(void *)(v3 + 16 * v5);
        if (v6 == a2) {
          goto LABEL_6;
        }
      }
    }
  }
  return 0;
}

uint64_t llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getTopLevelLoops(uint64_t a1)
{
  return a1 + 24;
}

uint64_t llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getTopLevelLoopsVector(uint64_t a1)
{
  return a1 + 24;
}

uint64_t llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::removeLoop(uint64_t a1, char *__dst)
{
  uint64_t v6 = *(void *)__dst;
  unsigned int v4 = __dst + 8;
  uint64_t v5 = v6;
  int v7 = *(char **)(a1 + 32);
  int64_t v8 = v7 - v4;
  if (v7 != v4) {
    memmove(__dst, v4, v7 - v4);
  }
  *(void *)(a1 + 32) = &__dst[v8];
  return v5;
}

int32x2_t llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::changeLoopFor(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v16 = a2;
  if (a3)
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (v4)
    {
      int v5 = v4 - 1;
      unsigned int v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      int v7 = (void *)(*(void *)a1 + 16 * v6);
      uint64_t v8 = *v7;
      if (*v7 == a2)
      {
LABEL_17:
        v7[1] = a3;
        return result;
      }
      uint64_t v9 = 0;
      int v10 = 1;
      while (v8 != -4096)
      {
        if (v9) {
          BOOL v11 = 0;
        }
        else {
          BOOL v11 = v8 == -8192;
        }
        if (v11) {
          uint64_t v9 = v7;
        }
        unsigned int v12 = v6 + v10++;
        unsigned int v6 = v12 & v5;
        int v7 = (void *)(*(void *)a1 + 16 * (v12 & v5));
        uint64_t v8 = *v7;
        if (*v7 == a2) {
          goto LABEL_17;
        }
      }
      if (v9) {
        uint64_t v13 = v9;
      }
      else {
        uint64_t v13 = v7;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    int v7 = sub_1CC361B00(a1, &v16, v13);
    *int v7 = v16;
    v7[1] = 0;
    goto LABEL_17;
  }
  uint64_t v17 = 0;
  if (sub_1CB834D78((uint64_t *)a1, &v16, &v17))
  {
    void *v17 = -8192;
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + 8) = result;
  }
  return result;
}

uint64_t llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::changeTopLevelLoop(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(result + 24);
  int v4 = *(void **)(result + 32);
  if (v3 != v4)
  {
    while (*v3 != a2)
    {
      if (++v3 == v4)
      {
        uint64_t v3 = *(void **)(result + 32);
        break;
      }
    }
  }
  void *v3 = a3;
  return result;
}

void llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::addTopLevelLoop(void *a1, uint64_t a2)
{
  int v5 = (void *)a1[4];
  unint64_t v4 = a1[5];
  if ((unint64_t)v5 >= v4)
  {
    int v7 = (void *)a1[3];
    uint64_t v8 = v5 - v7;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61) {
      abort();
    }
    uint64_t v10 = v4 - (void)v7;
    if (v10 >> 2 > v9) {
      unint64_t v9 = v10 >> 2;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 >> 61) {
        sub_1CB833614();
      }
      unsigned int v12 = (char *)operator new(8 * v11);
    }
    else
    {
      unsigned int v12 = 0;
    }
    uint64_t v13 = &v12[8 * v8];
    *(void *)uint64_t v13 = a2;
    unsigned int v6 = v13 + 8;
    if (v5 != v7)
    {
      do
      {
        uint64_t v14 = *--v5;
        *((void *)v13 - 1) = v14;
        v13 -= 8;
      }
      while (v5 != v7);
      int v5 = (void *)a1[3];
    }
    a1[3] = v13;
    a1[4] = v6;
    a1[5] = &v12[8 * v11];
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    *int v5 = a2;
    unsigned int v6 = v5 + 1;
  }
  a1[4] = v6;
}

int32x2_t llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::removeBlock(int32x2_t *a1, uint64_t a2)
{
  int32x2_t v2 = *a1;
  uint64_t v3 = a1[2].u32[0];
  if (v3)
  {
    LODWORD(v4) = (v3 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    int v5 = (uint64_t *)(*(void *)&v2 + 16 * v4);
    uint64_t v6 = *v5;
    if (*v5 == a2) {
      goto LABEL_8;
    }
    int v7 = 1;
    while (v6 != -4096)
    {
      int v8 = v4 + v7++;
      uint64_t v4 = v8 & (v3 - 1);
      uint64_t v6 = *(void *)(*(void *)&v2 + 16 * v4);
      if (v6 == a2)
      {
        int v5 = (uint64_t *)(*(void *)&v2 + 16 * v4);
        goto LABEL_8;
      }
    }
  }
  int v5 = (uint64_t *)(*(void *)&v2 + 16 * v3);
LABEL_8:
  if (v5 != (uint64_t *)(*(void *)&v2 + 16 * v3))
  {
    if (v5[1]) {
      llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::removeBlockFromLoop();
    }
    *int v5 = -8192;
    int32x2_t result = vadd_s32(a1[1], (int32x2_t)0x1FFFFFFFFLL);
    a1[1] = result;
  }
  return result;
}

BOOL llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::isNotAlreadyContainedIn(void *a1, void *a2)
{
  if (!a1) {
    return 1;
  }
  int32x2_t v2 = a1;
  do
  {
    BOOL result = v2 != a2;
    if (v2 == a2) {
      break;
    }
    int32x2_t v2 = (void *)*v2;
  }
  while (v2);
  return result;
}

void llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::analyze(void *a1, uint64_t a2)
{
  v203[16] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void **)(a2 + 48);
  uint64_t v179 = v183;
  uint64_t __src = v183;
  int v182 = 0;
  uint64_t v181 = 0x100000008;
  uint64_t v184 = &v186;
  v183[0] = v3;
  uint64_t v4 = v3[3];
  uint64_t v134 = v3;
  uint64_t v186 = v3;
  uint64_t v187 = v4;
  uint64_t v185 = 0x800000001;
  sub_1CC08C4B4((llvm::SmallPtrSetImplBase *)&v179);
  uint64_t v168 = 0;
  long long v170 = 0u;
  uint64_t v178 = 0;
  long long v177 = 0u;
  long long v176 = 0u;
  long long v175 = 0u;
  long long v174 = 0u;
  long long v173 = 0u;
  long long v172 = 0u;
  long long v171 = 0u;
  long long v167 = 0u;
  long long v166 = 0u;
  long long v165 = 0u;
  long long v164 = 0u;
  char v161 = (char *)&v164 + 8;
  unsigned int v162 = (char *)&v164 + 8;
  uint64_t v163 = 8;
  uint64_t v169 = (char *)&v170 + 8;
  DWORD1(v170) = 8;
  uint64_t v196 = v200;
  if (__src == v179)
  {
    unint64_t v197 = v200;
    unsigned int v5 = HIDWORD(v181);
    if (HIDWORD(v181)) {
      memmove(v200, __src, 8 * HIDWORD(v181));
    }
  }
  else
  {
    unint64_t v197 = __src;
    uint64_t __src = v179;
    unsigned int v5 = HIDWORD(v181);
  }
  unint64_t v198 = __PAIR64__(v5, v181);
  int v199 = v182;
  uint64_t v181 = 8;
  int v182 = 0;
  uint64_t v201 = v203;
  uint64_t v202 = 0x800000000;
  int v6 = v185;
  if (v185)
  {
    if (v184 == &v186)
    {
      if (v185 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v203, &v186, 16 * v185);
      LODWORD(v202) = v6;
      LODWORD(v185) = 0;
      int v188 = v192;
      unsigned int v7 = HIDWORD(v163);
      if (v162 == v161)
      {
        uint64_t v189 = v192;
      }
      else
      {
        uint64_t v189 = v162;
        unsigned int v162 = v161;
      }
      goto LABEL_10;
    }
    uint64_t v201 = v184;
    uint64_t v202 = v185;
    uint64_t v184 = &v186;
    uint64_t v185 = 0;
  }
  unsigned int v7 = 0;
  int v188 = v192;
  uint64_t v189 = v192;
LABEL_10:
  unint64_t v190 = __PAIR64__(v7, v163);
  int v191 = v164;
  uint64_t v163 = 8;
  LODWORD(v164) = 0;
  uint64_t v193 = v195;
  uint64_t v194 = 0x800000000;
  int v8 = v170;
  if (v170)
  {
    if (v169 == (char *)&v170 + 8)
    {
      if (v170 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v195, (char *)&v170 + 8, 16 * v170);
      LODWORD(v194) = v8;
    }
    else
    {
      uint64_t v193 = v169;
      uint64_t v194 = v170;
      uint64_t v169 = (char *)&v170 + 8;
      DWORD1(v170) = 0;
    }
    LODWORD(v170) = 0;
  }
  if (v197 == v196)
  {
    uint64_t v140 = v148;
    unsigned int v9 = HIDWORD(v198);
    if (HIDWORD(v198)) {
      memmove(v148, v197, 8 * HIDWORD(v198));
    }
  }
  else
  {
    uint64_t v140 = v197;
    unint64_t v197 = v196;
    unsigned int v9 = HIDWORD(v198);
  }
  unsigned int v142 = v198;
  unsigned int v144 = v9;
  int v146 = v199;
  unint64_t v198 = 8;
  int v199 = 0;
  uint64_t v149 = v151;
  uint64_t v150 = 0x800000000;
  int v10 = v202;
  if (v202)
  {
    if (v201 == v203)
    {
      if (v202 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v151, v203, 16 * v202);
      LODWORD(v150) = v10;
    }
    else
    {
      uint64_t v149 = v201;
      uint64_t v150 = v202;
      uint64_t v201 = v203;
      HIDWORD(v202) = 0;
    }
    LODWORD(v202) = 0;
  }
  unint64_t v152 = v157;
  if (v189 == v188)
  {
    uint64_t v153 = v157;
    unsigned int v11 = HIDWORD(v190);
    if (HIDWORD(v190)) {
      memmove(v157, v189, 8 * HIDWORD(v190));
    }
  }
  else
  {
    uint64_t v153 = v189;
    uint64_t v189 = v188;
    unsigned int v11 = HIDWORD(v190);
  }
  unsigned int v154 = v190;
  unsigned int v155 = v11;
  int v156 = v191;
  unint64_t v190 = 8;
  int v191 = 0;
  uint64_t v158 = v160;
  uint64_t v159 = 0x800000000;
  int v12 = v194;
  uint64_t v13 = v193;
  if (v194)
  {
    if (v193 == v195)
    {
      if (v194 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v160, v195, 16 * v194);
      LODWORD(v159) = v12;
      uint64_t v13 = v193;
    }
    else
    {
      uint64_t v158 = v193;
      uint64_t v159 = v194;
      uint64_t v193 = v195;
      HIDWORD(v194) = 0;
      uint64_t v13 = v195;
    }
    LODWORD(v194) = 0;
  }
  if (v13 != v195) {
    free(v13);
  }
  if (v189 != v188) {
    free(v189);
  }
  if (v201 != v203) {
    free(v201);
  }
  if (v197 != v196) {
    free(v197);
  }
  if (v169 != (char *)&v170 + 8) {
    free(v169);
  }
  if (v162 != v161) {
    free(v162);
  }
  if (v184 != &v186) {
    free(v184);
  }
  if (__src != v179) {
    free(__src);
  }
  uint64_t v14 = v200;
  uint64_t v196 = v200;
  uint64_t v15 = v140;
  uint64_t v139 = a1;
  if (v140 == v148)
  {
    unint64_t v197 = v200;
    uint64_t v16 = v140;
  }
  else
  {
    uint64_t v14 = malloc_type_malloc(8 * v142, 0x4065EBACuLL);
    if (!v14)
    {
      if (v142) {
        goto LABEL_360;
      }
      uint64_t v14 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v14) {
        goto LABEL_360;
      }
    }
    unint64_t v197 = v14;
    uint64_t v16 = v148;
    uint64_t v15 = v140;
  }
  unsigned int v17 = v144;
  LODWORD(v198) = v142;
  if (v15 == v16) {
    unsigned int v18 = v144;
  }
  else {
    unsigned int v18 = v142;
  }
  if (v18)
  {
    memmove(v14, v15, 8 * v18);
    unsigned int v17 = v144;
  }
  HIDWORD(v198) = v17;
  int v199 = v146;
  uint64_t v201 = v203;
  uint64_t v202 = 0x800000000;
  if (v150) {
    sub_1CC361C34((uint64_t)&v201, (uint64_t)&v149);
  }
  uint64_t v19 = v192;
  int v188 = v192;
  BOOL v20 = v153;
  if (v153 == v152)
  {
    uint64_t v189 = v192;
    unsigned int v21 = v153;
  }
  else
  {
    unsigned int v132 = v154;
    uint64_t v19 = malloc_type_malloc(8 * v154, 0x4065EBACuLL);
    if (!v19)
    {
      if (v132) {
        goto LABEL_360;
      }
      uint64_t v19 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v19) {
        goto LABEL_360;
      }
    }
    uint64_t v189 = v19;
    unsigned int v21 = v152;
    BOOL v20 = v153;
  }
  LODWORD(v190) = v154;
  unsigned int v22 = v155;
  if (v20 == v21) {
    unsigned int v23 = v155;
  }
  else {
    unsigned int v23 = v154;
  }
  if (v23)
  {
    memmove(v19, v20, 8 * v23);
    unsigned int v22 = v155;
  }
  HIDWORD(v190) = v22;
  int v191 = v156;
  uint64_t v193 = v195;
  uint64_t v194 = 0x800000000;
  if (v159) {
    sub_1CC361C34((uint64_t)&v193, (uint64_t)&v158);
  }
  while (1)
  {
    if (v202 != v194) {
      goto LABEL_75;
    }
    if (!v202) {
      break;
    }
    unsigned int v24 = v193;
    uint64_t v25 = v201;
    while (*v25 == *v24 && v25[1] == v24[1])
    {
      v25 += 2;
      v24 += 2;
      if (v25 == (void *)((char *)v201 + 16 * v202)) {
        goto LABEL_81;
      }
    }
LABEL_75:
    uint64_t v27 = **((void **)v201 + 2 * v202 - 2);
    uint64_t v179 = &v181;
    uint64_t __src = (void *)0x400000000;
    if (*(void *)(v27 + 64) != *(void *)(v27 + 72)) {
      llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::dominates();
    }
    if (v179 != &v181) {
      free(v179);
    }
    LODWORD(v202) = v202 - 1;
    if (v202) {
      sub_1CC08C4B4((llvm::SmallPtrSetImplBase *)&v196);
    }
  }
LABEL_81:
  if (v193 != v195) {
    free(v193);
  }
  if (v189 != v188) {
    free(v189);
  }
  if (v201 != v203) {
    free(v201);
  }
  if (v197 != v196) {
    free(v197);
  }
  if (v158 != v160) {
    free(v158);
  }
  if (v153 != v152) {
    free(v153);
  }
  if (v149 != v151) {
    free(v149);
  }
  if (v140 != v148) {
    free(v140);
  }
  uint64_t v28 = (void *)*v134;
  uint64_t v179 = v183;
  uint64_t __src = v183;
  int v182 = 0;
  uint64_t v181 = 0x100000008;
  uint64_t v184 = &v186;
  v183[0] = v28;
  uint64_t v29 = v28[11];
  uint64_t v186 = v28;
  uint64_t v187 = v29;
  uint64_t v185 = 0x800000001;
  sub_1CB93B280((llvm::SmallPtrSetImplBase *)&v179);
  uint64_t v168 = 0;
  long long v170 = 0u;
  uint64_t v178 = 0;
  long long v177 = 0u;
  long long v176 = 0u;
  long long v175 = 0u;
  long long v174 = 0u;
  long long v173 = 0u;
  long long v172 = 0u;
  long long v171 = 0u;
  long long v167 = 0u;
  long long v166 = 0u;
  long long v165 = 0u;
  long long v164 = 0u;
  char v161 = (char *)&v164 + 8;
  unsigned int v162 = (char *)&v164 + 8;
  uint64_t v163 = 8;
  uint64_t v169 = (char *)&v170 + 8;
  DWORD1(v170) = 8;
  uint64_t v196 = v200;
  if (__src == v179)
  {
    unint64_t v197 = v200;
    unsigned int v30 = HIDWORD(v181);
    if (HIDWORD(v181)) {
      memmove(v200, __src, 8 * HIDWORD(v181));
    }
  }
  else
  {
    unint64_t v197 = __src;
    uint64_t __src = v179;
    unsigned int v30 = HIDWORD(v181);
  }
  unint64_t v198 = __PAIR64__(v30, v181);
  int v199 = v182;
  uint64_t v181 = 8;
  int v182 = 0;
  uint64_t v201 = v203;
  uint64_t v202 = 0x800000000;
  int v31 = v185;
  if (v185)
  {
    if (v184 != &v186)
    {
      uint64_t v201 = v184;
      uint64_t v202 = v185;
      uint64_t v184 = &v186;
      uint64_t v185 = 0;
      goto LABEL_101;
    }
    if (v185 >= 9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy(v203, &v186, 16 * v185);
    LODWORD(v202) = v31;
    LODWORD(v185) = 0;
    int v188 = v192;
    unsigned int v32 = HIDWORD(v163);
    if (v162 == v161)
    {
      uint64_t v189 = v192;
      if (HIDWORD(v163)) {
        memmove(v192, v162, 8 * HIDWORD(v163));
      }
    }
    else
    {
      uint64_t v189 = v162;
      unsigned int v162 = v161;
    }
  }
  else
  {
LABEL_101:
    unsigned int v32 = 0;
    int v188 = v192;
    uint64_t v189 = v192;
  }
  unint64_t v190 = __PAIR64__(v32, v163);
  int v191 = v164;
  uint64_t v163 = 8;
  LODWORD(v164) = 0;
  uint64_t v193 = v195;
  uint64_t v194 = 0x800000000;
  int v33 = v170;
  if (v170)
  {
    if (v169 == (char *)&v170 + 8)
    {
      if (v170 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v195, (char *)&v170 + 8, 16 * v170);
      LODWORD(v194) = v33;
    }
    else
    {
      uint64_t v193 = v169;
      uint64_t v194 = v170;
      uint64_t v169 = (char *)&v170 + 8;
      DWORD1(v170) = 0;
    }
    LODWORD(v170) = 0;
  }
  if (v197 == v196)
  {
    char v141 = v148;
    unsigned int v34 = HIDWORD(v198);
    if (HIDWORD(v198)) {
      memmove(v148, v197, 8 * HIDWORD(v198));
    }
  }
  else
  {
    char v141 = v197;
    unint64_t v197 = v196;
    unsigned int v34 = HIDWORD(v198);
  }
  unsigned int v143 = v198;
  unsigned int v145 = v34;
  int v147 = v199;
  unint64_t v198 = 8;
  int v199 = 0;
  uint64_t v149 = v151;
  uint64_t v150 = 0x800000000;
  int v35 = v202;
  if (v202)
  {
    if (v201 == v203)
    {
      if (v202 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v151, v203, 16 * v202);
      LODWORD(v150) = v35;
    }
    else
    {
      uint64_t v149 = v201;
      uint64_t v150 = v202;
      uint64_t v201 = v203;
      HIDWORD(v202) = 0;
    }
    LODWORD(v202) = 0;
  }
  unint64_t v152 = v157;
  if (v189 == v188)
  {
    uint64_t v153 = v157;
    unsigned int v36 = HIDWORD(v190);
    int v37 = v139;
    if (HIDWORD(v190)) {
      memmove(v157, v189, 8 * HIDWORD(v190));
    }
  }
  else
  {
    uint64_t v153 = v189;
    uint64_t v189 = v188;
    unsigned int v36 = HIDWORD(v190);
    int v37 = v139;
  }
  unsigned int v154 = v190;
  unsigned int v155 = v36;
  int v156 = v191;
  unint64_t v190 = 8;
  int v191 = 0;
  int v38 = v160;
  uint64_t v158 = v160;
  uint64_t v159 = 0x800000000;
  int v39 = v194;
  unsigned int v40 = v193;
  if (v194)
  {
    if (v193 == v195)
    {
      if (v194 >= 9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v160, v195, 16 * v194);
      LODWORD(v159) = v39;
      unsigned int v40 = v193;
    }
    else
    {
      uint64_t v158 = v193;
      uint64_t v159 = v194;
      uint64_t v193 = v195;
      HIDWORD(v194) = 0;
      unsigned int v40 = v195;
    }
    LODWORD(v194) = 0;
  }
  if (v40 != v195) {
    free(v40);
  }
  if (v189 != v188) {
    free(v189);
  }
  if (v201 != v203) {
    free(v201);
  }
  if (v197 != v196) {
    free(v197);
  }
  if (v169 != (char *)&v170 + 8) {
    free(v169);
  }
  if (v162 != v161) {
    free(v162);
  }
  if (v184 != &v186) {
    free(v184);
  }
  if (__src != v179) {
    free(__src);
  }
  unint64_t v41 = v200;
  uint64_t v196 = v200;
  uint64_t v42 = v141;
  if (v141 == v148)
  {
    unint64_t v197 = v200;
    __int16 v43 = v141;
    goto LABEL_146;
  }
  unint64_t v41 = malloc_type_malloc(8 * v143, 0x4065EBACuLL);
  if (!v41)
  {
    if (v143 || (v41 = malloc_type_malloc(1uLL, 0x4065EBACuLL), int v37 = v139, !v41)) {
LABEL_360:
    }
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  unint64_t v197 = v41;
  __int16 v43 = v148;
  uint64_t v42 = v141;
LABEL_146:
  unsigned int v44 = v145;
  LODWORD(v198) = v143;
  if (v42 == v43) {
    unsigned int v45 = v145;
  }
  else {
    unsigned int v45 = v143;
  }
  if (v45)
  {
    memmove(v41, v42, 8 * v45);
    unsigned int v44 = v145;
  }
  int v46 = v150;
  HIDWORD(v198) = v44;
  int v199 = v147;
  uint64_t v201 = v203;
  uint64_t v202 = 0x800000000;
  if (v150)
  {
    if (v150 >= 9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy(v203, v149, 16 * v150);
    LODWORD(v202) = v46;
  }
  uint64_t v47 = v192;
  int v188 = v192;
  uint64_t v48 = v153;
  if (v153 == v152)
  {
    uint64_t v189 = v192;
    uint64_t v49 = v153;
  }
  else
  {
    unsigned int v133 = v154;
    uint64_t v47 = malloc_type_malloc(8 * v154, 0x4065EBACuLL);
    if (!v47)
    {
      if (v133) {
        goto LABEL_360;
      }
      uint64_t v47 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      int v37 = v139;
      if (!v47) {
        goto LABEL_360;
      }
    }
    uint64_t v189 = v47;
    uint64_t v49 = v152;
    uint64_t v48 = v153;
  }
  LODWORD(v190) = v154;
  unsigned int v50 = v155;
  if (v48 == v49) {
    unsigned int v51 = v155;
  }
  else {
    unsigned int v51 = v154;
  }
  if (v51)
  {
    memmove(v47, v48, 8 * v51);
    unsigned int v50 = v155;
  }
  HIDWORD(v190) = v50;
  int v191 = v156;
  uint64_t v52 = v195;
  uint64_t v193 = v195;
  uint64_t v194 = 0x800000000;
  uint64_t v53 = v159;
  if (v159)
  {
    if (v159 >= 9uLL) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy(v195, v158, 16 * v159);
    LODWORD(v194) = v53;
  }
  while (2)
  {
    if (v202 != v53)
    {
LABEL_165:
      int v54 = *((_DWORD *)v37 + 4);
      if (!v54) {
        goto LABEL_263;
      }
      uint64_t v55 = *((void *)v201 + 2 * v202 - 2);
      uint64_t v56 = *v37;
      unsigned int v57 = (v55 >> 4) ^ (v55 >> 9);
      unsigned int v58 = v54 - 1;
      uint64_t v59 = v57 & v58;
      uint64_t v60 = *(void *)(*v37 + 16 * v59);
      if (v60 != v55)
      {
        int v61 = 1;
        while (v60 != -4096)
        {
          int v62 = v59 + v61++;
          uint64_t v59 = v62 & v58;
          uint64_t v60 = *(void *)(v56 + 16 * v59);
          if (v60 == v55) {
            goto LABEL_170;
          }
        }
        goto LABEL_263;
      }
LABEL_170:
      uint64_t v63 = *(void **)(v56 + 16 * v59 + 8);
      if (!v63)
      {
LABEL_263:
        LODWORD(v202) = v202 - 1;
        if (v202) {
          sub_1CB93B280((llvm::SmallPtrSetImplBase *)&v196);
        }
        uint64_t v53 = v194;
        continue;
      }
      if (*(void *)v63[4] == v55)
      {
        uint64_t v64 = (void *)*v63;
        if (*v63)
        {
          uint64_t v66 = (void *)v64[2];
          unint64_t v65 = v64[3];
          if ((unint64_t)v66 < v65)
          {
            *uint64_t v66 = v63;
            int v67 = v66 + 1;
            goto LABEL_211;
          }
          int v74 = v52;
          unint64_t v136 = v38;
          uint64_t v75 = (void *)v64[1];
          uint64_t v76 = v66 - v75;
          unint64_t v77 = v76 + 1;
          if (!((unint64_t)(v76 + 1) >> 61))
          {
            uint64_t v78 = v65 - (void)v75;
            if (v78 >> 2 > v77) {
              unint64_t v77 = v78 >> 2;
            }
            if ((unint64_t)v78 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v77 = 0x1FFFFFFFFFFFFFFFLL;
            }
            unint64_t v135 = v77;
            if (v77)
            {
              if (!(v77 >> 61))
              {
                long long v79 = (char *)operator new(8 * v77);
                goto LABEL_204;
              }
LABEL_340:
              sub_1CB833614();
            }
            long long v79 = 0;
LABEL_204:
            uint64_t v87 = &v79[8 * v76];
            *(void *)uint64_t v87 = v63;
            int v67 = v87 + 8;
            uint64_t v52 = v74;
            if (v66 == v75)
            {
              unint64_t v88 = v135;
            }
            else
            {
              unint64_t v88 = v135;
              do
              {
                uint64_t v89 = *--v66;
                *((void *)v87 - 1) = v89;
                v87 -= 8;
              }
              while (v66 != v75);
              uint64_t v66 = (void *)v64[1];
            }
            v64[1] = v87;
            v64[2] = v67;
            v64[3] = &v79[8 * v88];
            int v38 = v136;
            if (v66) {
              operator delete(v66);
            }
LABEL_211:
            v64[2] = v67;
            int v37 = v139;
LABEL_222:
            uint64_t v92 = v63[4];
            uint64_t v93 = v63[5];
            BOOL v94 = (void *)(v93 - 8);
            BOOL v95 = v92 + 8 == v93 || v92 + 8 >= (unint64_t)v94;
            if (!v95)
            {
              unint64_t v96 = v92 + 16;
              do
              {
                uint64_t v97 = *(void *)(v96 - 8);
                *(void *)(v96 - 8) = *v94;
                *v94-- = v97;
                BOOL v95 = v96 >= (unint64_t)v94;
                v96 += 8;
              }
              while (!v95);
            }
            unint64_t v98 = v63[1];
            uint64_t v99 = v63[2];
            uint64_t v100 = (void *)(v99 - 8);
            if (v98 != v99 && v98 < (unint64_t)v100)
            {
              unint64_t v102 = v98 + 8;
              do
              {
                uint64_t v103 = *(void *)(v102 - 8);
                *(void *)(v102 - 8) = *v100;
                *v100-- = v103;
                BOOL v95 = v102 >= (unint64_t)v100;
                v102 += 8;
              }
              while (!v95);
            }
            goto LABEL_236;
          }
LABEL_339:
          abort();
        }
        int v37 = v139;
        uint64_t v72 = (void *)v139[4];
        unint64_t v71 = v139[5];
        if ((unint64_t)v72 >= v71)
        {
          uint64_t v80 = v52;
          uint64_t v137 = v38;
          uint64_t v81 = (void *)v139[3];
          uint64_t v82 = v72 - v81;
          unint64_t v83 = v82 + 1;
          if ((unint64_t)(v82 + 1) >> 61) {
            goto LABEL_339;
          }
          uint64_t v84 = v71 - (void)v81;
          if (v84 >> 2 > v83) {
            unint64_t v83 = v84 >> 2;
          }
          if ((unint64_t)v84 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v85 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v85 = v83;
          }
          if (v85)
          {
            if (v85 >> 61) {
              goto LABEL_340;
            }
            uint64_t v86 = (char *)operator new(8 * v85);
          }
          else
          {
            uint64_t v86 = 0;
          }
          unsigned int v90 = &v86[8 * v82];
          *(void *)unsigned int v90 = v63;
          int v73 = v90 + 8;
          if (v72 == v81)
          {
            int v37 = v139;
            uint64_t v52 = v80;
          }
          else
          {
            uint64_t v52 = v80;
            do
            {
              uint64_t v91 = *--v72;
              *((void *)v90 - 1) = v91;
              v90 -= 8;
            }
            while (v72 != v81);
            int v37 = v139;
            uint64_t v72 = (void *)v139[3];
          }
          void v37[3] = v90;
          void v37[4] = v73;
          v37[5] = &v86[8 * v85];
          if (v72) {
            operator delete(v72);
          }
          int v38 = v137;
        }
        else
        {
          *uint64_t v72 = v63;
          int v73 = v72 + 1;
        }
        void v37[4] = v73;
        goto LABEL_222;
      }
      while (2)
      {
        int v105 = (void *)v63[5];
        unint64_t v104 = v63[6];
        if ((unint64_t)v105 >= v104)
        {
          uint64_t v138 = v52;
          uint64_t v123 = (void *)v63[4];
          uint64_t v124 = v105 - v123;
          unint64_t v125 = v124 + 1;
          if ((unint64_t)(v124 + 1) >> 61) {
            goto LABEL_339;
          }
          uint64_t v126 = v38;
          uint64_t v127 = v104 - (void)v123;
          if (v127 >> 2 > v125) {
            unint64_t v125 = v127 >> 2;
          }
          if ((unint64_t)v127 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v128 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v128 = v125;
          }
          if (v128)
          {
            if (v128 >> 61) {
              goto LABEL_340;
            }
            uint64_t v129 = (char *)operator new(8 * v128);
          }
          else
          {
            uint64_t v129 = 0;
          }
          int v130 = &v129[8 * v124];
          *(void *)int v130 = v55;
          uint64_t v106 = v130 + 8;
          if (v105 != v123)
          {
            do
            {
              uint64_t v131 = *--v105;
              *((void *)v130 - 1) = v131;
              v130 -= 8;
            }
            while (v105 != v123);
            int v105 = (void *)v63[4];
          }
          v63[4] = v130;
          void v63[5] = v106;
          v63[6] = &v129[8 * v128];
          if (v105) {
            operator delete(v105);
          }
          int v37 = v139;
          int v38 = v126;
          uint64_t v52 = v138;
        }
        else
        {
          *int v105 = v55;
          uint64_t v106 = v105 + 1;
        }
        uint64_t v107 = v63[7];
        void v63[5] = v106;
        uint64_t v108 = v63[8];
        uint64_t v109 = *((unsigned int *)v63 + 19);
        if (v108 == v107)
        {
          if (v109)
          {
            uint64_t v110 = 0;
            uint64_t v111 = 8 * v109;
            uint64_t v112 = (void *)v63[8];
            while (*v112 != v55)
            {
              if (*v112 == -2) {
                uint64_t v110 = v112;
              }
              ++v112;
              v111 -= 8;
              if (!v111)
              {
                if (!v110) {
                  goto LABEL_247;
                }
                *uint64_t v110 = v55;
                --*((_DWORD *)v63 + 20);
                break;
              }
            }
LABEL_236:
            uint64_t v63 = (void *)*v63;
            if (!v63) {
              goto LABEL_263;
            }
            continue;
          }
LABEL_247:
          unsigned int v113 = *((_DWORD *)v63 + 18);
          if (v109 < v113)
          {
            *((_DWORD *)v63 + 19) = v109 + 1;
            *(void *)(v108 + 8 * v109) = v55;
            goto LABEL_236;
          }
        }
        else
        {
          unsigned int v113 = *((_DWORD *)v63 + 18);
        }
        break;
      }
      if (3 * v113 <= 4 * ((int)v109 - *((_DWORD *)v63 + 20)))
      {
        if (v113 >= 0x40) {
          v113 *= 2;
        }
        else {
          unsigned int v113 = 128;
        }
      }
      else if (v113 - v109 >= v113 >> 3)
      {
        goto LABEL_252;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(v63 + 7), v113);
      unsigned int v113 = *((_DWORD *)v63 + 18);
      uint64_t v108 = v63[8];
LABEL_252:
      unsigned int v114 = v113 - 1;
      unsigned int v115 = (v113 - 1) & v57;
      size_t v116 = (void *)(v108 + 8 * v115);
      uint64_t v117 = *v116;
      if (*v116 == -1)
      {
        unsigned int v118 = 0;
LABEL_267:
        if (v118) {
          uint64_t v122 = v118;
        }
        else {
          uint64_t v122 = v116;
        }
        if (*v122 != v55)
        {
          if (*v122 == -2) {
            --*((_DWORD *)v63 + 20);
          }
          else {
            ++*((_DWORD *)v63 + 19);
          }
          void *v122 = v55;
        }
      }
      else
      {
        unsigned int v118 = 0;
        int v119 = 1;
        while (v117 != v55)
        {
          if (v118) {
            BOOL v120 = 0;
          }
          else {
            BOOL v120 = v117 == -2;
          }
          if (v120) {
            unsigned int v118 = v116;
          }
          unsigned int v121 = v115 + v119++;
          unsigned int v115 = v121 & v114;
          size_t v116 = (void *)(v108 + 8 * (v121 & v114));
          uint64_t v117 = *v116;
          if (*v116 == -1) {
            goto LABEL_267;
          }
        }
      }
      goto LABEL_236;
    }
    break;
  }
  if (v53)
  {
    uint64_t v68 = v193;
    uint64_t v69 = v201;
    while (*v69 == *v68 && v69[1] == v68[1])
    {
      v69 += 2;
      v68 += 2;
      if (v69 == (void *)((char *)v201 + 16 * v53)) {
        goto LABEL_296;
      }
    }
    goto LABEL_165;
  }
LABEL_296:
  if (v193 != v52) {
    free(v193);
  }
  if (v189 != v188) {
    free(v189);
  }
  if (v201 != v203) {
    free(v201);
  }
  if (v197 != v196) {
    free(v197);
  }
  if (v158 != v38) {
    free(v158);
  }
  if (v153 != v152) {
    free(v153);
  }
  if (v149 != v151) {
    free(v149);
  }
  if (v141 != v148) {
    free(v141);
  }
}

uint64_t llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::print(uint64_t result)
{
  if (*(void *)(result + 32) != *(void *)(result + 24)) {
    llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::print();
  }
  return result;
}

uint64_t llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::verify(uint64_t a1)
{
  if (*(void *)(a1 + 24) != *(void *)(a1 + 32)) {
    llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::verifyLoopNest();
  }
  return MEMORY[0x1D25D9CD0](0, 8);
}

void llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::destroy()
{
}

void llvm::initializeMachineLoopInfoPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCF080, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CC361480;
    v3[1] = &v1;
    int32x2_t v2 = v3;
    std::__call_once(&qword_1EBCCF080, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC361480(uint64_t a1)
{
}

void llvm::MachineLoopInfo::runOnMachineFunction(llvm::MachineLoopInfo *this, llvm::MachineFunction *a2)
{
  uint64_t v3 = (uint64_t *)*((void *)this + 1);
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 == v5)
  {
LABEL_7:
    uint64_t v6 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v4 != &llvm::MachineDominatorTree::ID)
    {
      v4 += 16;
      if (v4 == v5) {
        goto LABEL_7;
      }
    }
    uint64_t v6 = *(void *)(v4 + 8);
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, &llvm::MachineDominatorTree::ID);
  (*(void (**)(llvm::MachineLoopInfo *))(*(void *)this + 88))(this);
  if (*(void *)(v7 + 1320))
  {
    llvm::MachineDominatorTree::applySplitCriticalEdges((void ***)v7);
    llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::analyze();
  }
  operator new();
}

void llvm::MachineLoopInfo::calculate(llvm::MachineLoopInfo *this, void ***a2)
{
  (*(void (**)(llvm::MachineLoopInfo *))(*(void *)this + 88))(this);
  if (a2[165])
  {
    llvm::MachineDominatorTree::applySplitCriticalEdges(a2);
    llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::analyze();
  }
  operator new();
}

void llvm::MachineLoop::findLoopControlBlock(llvm::MachineLoop *this)
{
}

void llvm::MachineLoopInfo::findLoopPreheader(llvm::MachineLoopInfo *this, llvm::MachineLoop *a2)
{
}

void sub_1CC361A40()
{
}

void *sub_1CC361A48(uint64_t a1, uint64_t *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    int v12 = 0;
LABEL_15:
    uint64_t v6 = sub_1CC361B00(a1, a2, v12);
    void *v6 = *a2;
    v6[1] = 0;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
  uint64_t v6 = (void *)(*(void *)a1 + 16 * v5);
  uint64_t v7 = *v6;
  if (*a2 != *v6)
  {
    int v8 = 0;
    int v9 = 1;
    while (v7 != -4096)
    {
      if (v8) {
        BOOL v10 = 0;
      }
      else {
        BOOL v10 = v7 == -8192;
      }
      if (v10) {
        int v8 = v6;
      }
      unsigned int v11 = v5 + v9++;
      unsigned int v5 = v11 & v4;
      uint64_t v6 = (void *)(*(void *)a1 + 16 * (v11 & v4));
      uint64_t v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v8) {
      int v12 = v8;
    }
    else {
      int v12 = v6;
    }
    goto LABEL_15;
  }
  return v6;
}

void *sub_1CC361B00(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) <= v6 >> 3)
    {
      sub_1CC2E11F0(a1, v6);
      uint64_t v16 = 0;
      sub_1CB834D78((uint64_t *)a1, a2, &v16);
      a3 = v16;
    }
LABEL_4:
    uint64_t v7 = *a3;
    goto LABEL_5;
  }
  sub_1CC2E11F0(a1, 2 * v6);
  uint64_t v7 = *a2;
  int v9 = *(_DWORD *)(a1 + 16) - 1;
  unsigned int v10 = ((*a2 >> 4) ^ (*a2 >> 9)) & v9;
  a3 = (void *)(*(void *)a1 + 16 * v10);
  uint64_t v11 = *a3;
  if (*a2 != *a3)
  {
    int v12 = 0;
    int v13 = 1;
    while (v11 != -4096)
    {
      if (v12) {
        BOOL v14 = 0;
      }
      else {
        BOOL v14 = v11 == -8192;
      }
      if (v14) {
        int v12 = a3;
      }
      unsigned int v15 = v10 + v13++;
      unsigned int v10 = v15 & v9;
      a3 = (void *)(*(void *)a1 + 16 * v10);
      uint64_t v11 = *a3;
      if (v7 == *a3) {
        goto LABEL_5;
      }
    }
    if (v12) {
      a3 = v12;
    }
    goto LABEL_4;
  }
LABEL_5:
  ++*(_DWORD *)(a1 + 8);
  if (v7 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

uint64_t sub_1CC361C34(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v3 = *(unsigned int *)(a2 + 8);
    uint64_t v4 = *(unsigned int *)(a1 + 8);
    if (v4 >= v3)
    {
      if (v3)
      {
        unsigned int v6 = *(long long **)a2;
        uint64_t v7 = *(_OWORD **)a1;
        uint64_t v8 = 16 * v3;
        do
        {
          long long v9 = *v6++;
          *v7++ = v9;
          v8 -= 16;
        }
        while (v8);
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 12) < v3)
      {
        *(_DWORD *)(a1 + 8) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v4)
      {
        unsigned int v10 = *(long long **)a2;
        uint64_t v11 = *(_OWORD **)a1;
        uint64_t v12 = 16 * v4;
        do
        {
          long long v13 = *v10++;
          *v11++ = v13;
          v12 -= 16;
        }
        while (v12);
      }
      else
      {
        uint64_t v4 = 0;
      }
      if (v4 != v3) {
        memcpy((void *)(*(void *)a1 + 16 * v4), (const void *)(*(void *)a2 + 16 * v4), *(void *)a2 + 16 * v3 - (*(void *)a2 + 16 * v4));
      }
    }
    *(_DWORD *)(a1 + 8) = v3;
  }
  return a1;
}

void llvm::MachineModuleInfoImpl::~MachineModuleInfoImpl(llvm::MachineModuleInfoImpl *this)
{
}

uint64_t llvm::MachineModuleInfo::initialize(uint64_t this)
{
  *(void *)(this + 2072) = 0;
  *(_DWORD *)(this + 2104) = 0;
  *(_DWORD *)(this + 2136) = 0;
  *(_WORD *)(this + 2108) = 0;
  return this;
}

uint64_t llvm::MachineModuleInfo::finalize(llvm::MachineModuleInfo *this)
{
  *((void *)this + 261) = *((void *)this + 260);
  llvm::MCContext::reset((llvm::MachineModuleInfo *)((char *)this + 8));
  uint64_t result = *((void *)this + 259);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  *((void *)this + 259) = 0;
  return result;
}

uint64_t llvm::MachineModuleInfo::MachineModuleInfo(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  llvm::MCContext::MCContext(a1 + 8, (long long *)(*(void *)a2 + 448), *(void *)(*(void *)a2 + 560), *(void *)(*(void *)a2 + 568), *(void *)(*(void *)a2 + 584), 0, *(void *)a2 + 1128, 0, 0, 0);
  *(void *)(a1 + 2056) = 0;
  *(void *)(a1 + 2080) = 0;
  *(_OWORD *)(a1 + 2088) = 0u;
  *(_DWORD *)(a1 + 2128) = 0;
  *(_OWORD *)(a1 + 2112) = 0u;
  *(void *)(a1 + 2112) = *(void *)(a2 + 2112);
  *(void *)(a2 + 2112) = 0;
  *(_DWORD *)(a1 + 2120) = *(_DWORD *)(a2 + 2120);
  *(_DWORD *)(a2 + 2120) = 0;
  int v4 = *(_DWORD *)(a1 + 2124);
  *(_DWORD *)(a1 + 2124) = *(_DWORD *)(a2 + 2124);
  *(_DWORD *)(a2 + 2124) = v4;
  int v5 = *(_DWORD *)(a1 + 2128);
  *(_DWORD *)(a1 + 2128) = *(_DWORD *)(a2 + 2128);
  *(_DWORD *)(a2 + 2128) = v5;
  *(_DWORD *)(a1 + 2136) = 0;
  *(void *)(a1 + 2192) = 0;
  *(void *)(a1 + 2144) = 0;
  *(void *)(a1 + 2160) = 0;
  *(void *)(a1 + 2152) = 0;
  *(void *)(a1 + 176) = (*(uint64_t (**)(void))(**(void **)a2 + 24))();
  *(_DWORD *)(a1 + 2104) = *(_DWORD *)(a2 + 2104);
  *(void *)(a1 + 2056) = *(void *)(a2 + 2056);
  *(_OWORD *)(a1 + 2064) = *(_OWORD *)(a2 + 2064);
  return a1;
}

llvm::MachineModuleInfo *llvm::MachineModuleInfo::MachineModuleInfo(llvm::MachineModuleInfo *this, const llvm::LLVMTargetMachine *a2, llvm::MCContext *a3)
{
  *(void *)this = a2;
  llvm::MCContext::MCContext((uint64_t)this + 8, (long long *)a2 + 28, *((void *)a2 + 70), *((void *)a2 + 71), *((void *)a2 + 73), 0, (uint64_t)a2 + 1128, 0, 0, 0);
  *((void *)this + 257) = a3;
  *((_DWORD *)this + 534) = 0;
  *((void *)this + 2sub_1CC338288((_DWORD *)this + 74) = 0;
  *((void *)this + 260) = 0;
  *(_OWORD *)((char *)this + 2088) = 0u;
  *((_OWORD *)this + 132) = 0u;
  *((_DWORD *)this + 532) = 0;
  *((void *)this + 2sub_1CC338288((_DWORD *)this + 68) = 0;
  *((void *)this + 270) = 0;
  *((void *)this + 269) = 0;
  *((void *)this + 22) = (*(uint64_t (**)(const llvm::LLVMTargetMachine *))(*(void *)a2 + 24))(a2);
  *((void *)this + 259) = 0;
  *((_DWORD *)this + 526) = 0;
  *((_DWORD *)this + 534) = 0;
  *((_WORD *)this + 1054) = 0;
  return this;
}

void llvm::MachineModuleInfo::~MachineModuleInfo(llvm::MachineModuleInfo *this)
{
  llvm::MachineModuleInfo::finalize(this);
  int32x2_t v2 = (llvm::MachineModuleInfo *)*((void *)this + 274);
  if (v2 == (llvm::MachineModuleInfo *)((char *)this + 2168))
  {
    (*(void (**)(char *))(*((void *)this + 271) + 32))((char *)this + 2168);
  }
  else if (v2)
  {
    (*(void (**)(llvm::MachineModuleInfo *))(*(void *)v2 + 40))(v2);
  }
  uint64_t v3 = *((void *)this + 270);
  *((void *)this + 270) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  sub_1CC362EB0((unsigned int *)this + 528);
  MEMORY[0x1D25D9CD0](*((void *)this + 264), 8);
  int v4 = (void *)*((void *)this + 260);
  if (v4)
  {
    *((void *)this + 261) = v4;
    operator delete(v4);
  }
  llvm::MCContext::~MCContext((llvm::MachineModuleInfo *)((char *)this + 8));
}

void llvm::MachineModuleInfo::addPersonality(llvm::MachineModuleInfo *this, const Function *a2)
{
  int v4 = (const Function **)*((void *)this + 260);
  int v5 = (const Function **)*((void *)this + 261);
  unsigned int v6 = v4;
  if (v4 != v5)
  {
    unsigned int v6 = (const Function **)*((void *)this + 260);
    while (*v6 != a2)
    {
      if (++v6 == v5)
      {
        unsigned int v6 = (const Function **)*((void *)this + 261);
        break;
      }
    }
  }
  if (v6 == v5)
  {
    unint64_t v7 = *((void *)this + 262);
    if ((unint64_t)v5 >= v7)
    {
      uint64_t v9 = v5 - v4;
      unint64_t v10 = v9 + 1;
      if ((unint64_t)(v9 + 1) >> 61) {
        abort();
      }
      uint64_t v11 = v7 - (void)v4;
      if (v11 >> 2 > v10) {
        unint64_t v10 = v11 >> 2;
      }
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v12 = v10;
      }
      if (v12)
      {
        if (v12 >> 61) {
          sub_1CB833614();
        }
        long long v13 = (char *)operator new(8 * v12);
      }
      else
      {
        long long v13 = 0;
      }
      BOOL v14 = &v13[8 * v9];
      *(void *)BOOL v14 = a2;
      uint64_t v8 = v14 + 8;
      if (v4 != v5)
      {
        do
        {
          uint64_t v15 = (uint64_t)*--v5;
          *((void *)v14 - 1) = v15;
          v14 -= 8;
        }
        while (v5 != v4);
        int v4 = (const Function **)*((void *)this + 260);
      }
      *((void *)this + 260) = v14;
      *((void *)this + 261) = v8;
      *((void *)this + 262) = &v13[8 * v12];
      if (v4) {
        operator delete(v4);
      }
    }
    else
    {
      *int v5 = a2;
      uint64_t v8 = v5 + 1;
    }
    *((void *)this + 261) = v8;
  }
}

uint64_t llvm::MachineModuleInfo::getMachineFunction(llvm::MachineModuleInfo *this, const Function *a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = a2;
  if (sub_1CBFFBC50((uint64_t *)this + 264, &v8, &v7))
  {
    uint64_t v3 = v7;
    uint64_t v4 = *((void *)this + 264);
    uint64_t v5 = *((unsigned int *)this + 532);
  }
  else
  {
    uint64_t v4 = *((void *)this + 264);
    uint64_t v5 = *((unsigned int *)this + 532);
    uint64_t v3 = v4 + 16 * v5;
  }
  if (v3 == v4 + 16 * v5) {
    return 0;
  }
  else {
    return *(void *)(v3 + 8);
  }
}

uint64_t llvm::MachineModuleInfo::getOrCreateMachineFunction(llvm::MachineModuleInfo *this, llvm::Function *a2)
{
  if (*((llvm::Function **)this + 268) == a2) {
    return *((void *)this + 269);
  }
  uint64_t v7 = a2;
  uint64_t v8 = 0;
  sub_1CC362F2C((uint64_t)this + 2112, &v7, (uint64_t *)&v8, (uint64_t)&v9);
  uint64_t v4 = v8;
  uint64_t v8 = 0;
  if (v4)
  {
    llvm::MachineFunction::~MachineFunction(v4);
    MEMORY[0x1D25D9CE0]();
  }
  if (v10)
  {
    (*(void (**)(void, llvm::Function *))(**(void **)this + 16))(*(void *)this, a2);
    operator new();
  }
  uint64_t v5 = *(void *)(v9 + 8);
  *((void *)this + 2sub_1CC338288((_DWORD *)this + 68) = a2;
  *((void *)this + 269) = v5;
  return v5;
}

uint64_t sub_1CC362388(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 2192);
  if (v2)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 48))(v2);
  }
  else
  {
    uint64_t result = *(void *)(a1 + 2160);
    if (!result) {
      return result;
    }
  }
  uint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 24);

  return v4();
}

double llvm::MachineModuleInfo::deleteMachineFunctionFor(llvm::MachineModuleInfo *this, llvm::Function *a2)
{
  uint64_t v4 = a2;
  sub_1CC362464((uint64_t)this + 2112, &v4);
  double result = 0.0;
  *((_OWORD *)this + 134) = 0u;
  return result;
}

int32x2_t sub_1CC362464(uint64_t a1, void *a2)
{
  uint64_t v6 = 0;
  if (sub_1CBFFBC50((uint64_t *)a1, a2, &v6))
  {
    uint64_t v4 = (void *)v6;
    uint64_t v5 = *(llvm::MachineFunction **)(v6 + 8);
    *(void *)(v6 + 8) = 0;
    if (v5)
    {
      llvm::MachineFunction::~MachineFunction(v5);
      MEMORY[0x1D25D9CE0]();
    }
    *uint64_t v4 = -8192;
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + 8) = result;
  }
  return result;
}

BOOL sub_1CC3624E0(uint64_t a1)
{
  if (*(char *)(a1 + 471) < 0)
  {
    sub_1CB8BDF7C((uint64_t)__p, *(const void **)(a1 + 448), *(void *)(a1 + 456));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)(a1 + 448);
    uint64_t v5 = *(void *)(a1 + 464);
  }
  long long v6 = *(_OWORD *)(a1 + 472);
  uint64_t v7 = *(void *)(a1 + 488);
  int v2 = v6;
  if (SHIBYTE(v5) < 0) {
    operator delete(__p[0]);
  }
  return (v2 - 27) < 3;
}

llvm::MachineModuleInfoWrapperPass *llvm::MachineModuleInfoWrapperPass::MachineModuleInfoWrapperPass(llvm::MachineModuleInfoWrapperPass *this, const llvm::LLVMTargetMachine *a2, llvm::MCContext *a3)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::MachineModuleInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(void *)this = &unk_1F260E9A0;
  uint64_t v4 = llvm::MachineModuleInfo::MachineModuleInfo((llvm::MachineModuleInfoWrapperPass *)((char *)this + 32), a2, a3);
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v4);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCF148, memory_order_acquire) != -1)
  {
    v8[0] = sub_1CC362624;
    v8[1] = &PassRegistry;
    uint64_t v7 = v8;
    std::__call_once(&qword_1EBCCF148, &v7, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void sub_1CC362624(uint64_t a1)
{
}

uint64_t llvm::MachineModuleInfoWrapperPass::doInitialization(llvm::MachineModuleInfoWrapperPass *this, llvm::Module *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  *((void *)this + 263) = 0;
  *((_DWORD *)this + 534) = 0;
  *((_DWORD *)this + 542) = 0;
  *((_WORD *)this + 1070) = 0;
  *((void *)this + 262) = a2;
  uint64_t v4 = *(void *)a2;
  uint64_t v5 = (char *)*((void *)this + 261);
  if (!v5) {
    uint64_t v5 = (char *)this + 40;
  }
  v11[0] = &unk_1F260EB50;
  v11[1] = v4;
  _OWORD v11[2] = a2;
  unint64_t v12 = v11;
  sub_1CBF42504((void *)v5 + 14, (uint64_t)v11);
  if (v12 == v11)
  {
    (*(void (**)(void *))(v11[0] + 32))(v11);
  }
  else if (v12)
  {
    (*(void (**)(void))(*v12 + 40))();
  }
  if (byte_1EBCCF108)
  {
    BOOL v6 = 0;
  }
  else
  {
    sub_1CC362814(a2, &v8);
    BOOL v6 = v9 != v10;
  }
  *((unsigned char *)this + 2140) = v6;
  return 0;
}

uint64_t sub_1CC362814@<X0>(llvm::Module *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v8 = "llvm.dbg.cu";
  __int16 v9 = 259;
  uint64_t result = llvm::Module::getNamedMetadata(a1, &v8);
  if (result && (v6 = *(uint64_t **)(result + 48), uint64_t v5 = *((unsigned int *)v6 + 2), v5))
  {
    uint64_t v4 = 0;
    uint64_t v7 = *v6;
    while (!*(_DWORD *)(*(void *)(v7 + 8 * v4) + 36))
    {
      if (v5 == ++v4)
      {
        LODWORD(v4) = v5;
        break;
      }
    }
  }
  else
  {
    LODWORD(v4) = 0;
    uint64_t v5 = 0;
  }
  *a2 = result;
  a2[1] = v4;
  a2[2] = result;
  a2[3] = v5;
  return result;
}

uint64_t llvm::MachineModuleInfoWrapperPass::doFinalization(llvm::MachineModuleInfoWrapperPass *this, llvm::Module *a2)
{
  return 0;
}

uint64_t llvm::MachineModuleAnalysis::run@<X0>(const llvm::LLVMTargetMachine **a1@<X0>, llvm::Module *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  llvm::MachineModuleInfo::MachineModuleInfo((llvm::MachineModuleInfo *)a4, *a1);
  *(void *)(a4 + 2064) = a2;
  if (byte_1EBCCF108)
  {
    BOOL v8 = 0;
  }
  else
  {
    sub_1CC362814(a2, &v10);
    BOOL v8 = v11 != v12;
  }
  *(unsigned char *)(a4 + 2108) = v8;
  uint64_t result = sub_1CC3624E0((uint64_t)*a1);
  if (result)
  {
    v13[0] = &unk_1F260EB98;
    v13[1] = a2;
    void v13[2] = a3;
    BOOL v14 = v13;
    sub_1CC362B58((void *)(a4 + 2168), v13);
    uint64_t result = (uint64_t)v14;
    if (v14 == v13)
    {
      return (*(uint64_t (**)(void *))(v13[0] + 32))(v13);
    }
    else if (v14)
    {
      return (*(uint64_t (**)(void))(*v14 + 40))();
    }
  }
  return result;
}

void sub_1CC362A10(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CC362A48()
{
  return "Free MachineFunction";
}

void sub_1CC362A58(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineModuleInfoWrapperPass::ID);

  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::MachineModuleInfoWrapperPass::ID);
}

uint64_t sub_1CC362AA8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 == v5)
  {
LABEL_4:
    uint64_t v6 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v4 != &llvm::MachineModuleInfoWrapperPass::ID)
    {
      v4 += 16;
      if (v4 == v5) {
        goto LABEL_4;
      }
    }
    uint64_t v6 = *(void *)(v4 + 8);
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, &llvm::MachineModuleInfoWrapperPass::ID);
  uint64_t v9 = a2;
  sub_1CC362464(v7 + 2144, &v9);
  *(_OWORD *)(v7 + 2176) = 0u;
  return 1;
}

void *sub_1CC362B58(void *a1, void *a2)
{
  void v9[3] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (void *)a2[3];
  if (v3)
  {
    if (v3 == a2)
    {
      BOOL v8 = v7;
      (*(void (**)(void *, void *))(*a2 + 24))(a2, v7);
    }
    else
    {
      BOOL v8 = (void *)(*(uint64_t (**)(void *))(*v3 + 16))(v3);
    }
  }
  else
  {
    BOOL v8 = 0;
  }
  if (v7 != a1)
  {
    uint64_t v4 = v8;
    uint64_t v5 = (void *)a1[3];
    if (v8 == v7)
    {
      if (v5 == a1)
      {
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, v9);
        (*(void (**)(void *))(*v8 + 32))(v8);
        BOOL v8 = 0;
        (*(void (**)(void, void *))(*(void *)a1[3] + 24))(a1[3], v7);
        (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
        a1[3] = 0;
        BOOL v8 = v7;
        (*(void (**)(void *, void *))(v9[0] + 24))(v9, a1);
        (*(void (**)(void *))(v9[0] + 32))(v9);
      }
      else
      {
        (*(void (**)(void *, void *))(v7[0] + 24))(v7, a1);
        (*(void (**)(void *))(*v8 + 32))(v8);
        BOOL v8 = (void *)a1[3];
      }
      a1[3] = a1;
    }
    else if (v5 == a1)
    {
      (*(void (**)(void *, void *))(*a1 + 24))(a1, v7);
      (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
      a1[3] = v8;
      BOOL v8 = v7;
    }
    else
    {
      BOOL v8 = (void *)a1[3];
      a1[3] = v4;
    }
  }
  if (v8 == v7)
  {
    (*(void (**)(void *))(v7[0] + 32))(v7);
  }
  else if (v8)
  {
    (*(void (**)(void))(*v8 + 40))();
  }
  return a1;
}

unsigned int *sub_1CC362EB0(unsigned int *result)
{
  uint64_t v1 = result[4];
  if (v1)
  {
    uint64_t v2 = 16 * v1;
    uint64_t v3 = (unsigned int **)(*(void *)result + 8);
    do
    {
      if (((unint64_t)*(v3 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t result = *v3;
        void *v3 = 0;
        if (result)
        {
          uint64_t v4 = v3;
          uint64_t v5 = v2;
          llvm::MachineFunction::~MachineFunction((llvm::MachineFunction *)result);
          uint64_t result = (unsigned int *)MEMORY[0x1D25D9CE0]();
          uint64_t v3 = v4;
          uint64_t v2 = v5;
        }
      }
      v3 += 2;
      v2 -= 16;
    }
    while (v2);
  }
  return result;
}

uint64_t sub_1CC362F2C@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v13 = 0;
  uint64_t result = sub_1CBFFBC50((uint64_t *)a1, a2, &v13);
  uint64_t v9 = v13;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CC362FC4(a1, (uint64_t)a2, a2, v13);
    uint64_t v9 = (void *)result;
    *(void *)uint64_t result = *a2;
    uint64_t v11 = *a3;
    *a3 = 0;
    *(void *)(result + 8) = v11;
    char v10 = 1;
  }
  uint64_t v12 = *(void *)a1 + 16 * *(unsigned int *)(a1 + 16);
  *(void *)a4 = v9;
  *(void *)(a4 + 8) = v12;
  *(unsigned char *)(a4 + 16) = v10;
  return result;
}

void *sub_1CC362FC4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CC363074(a1, v7);
  uint64_t v9 = 0;
  sub_1CBFFBC50((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CC363074(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      uint64_t v11 = 16 * v10;
      do
      {
        *uint64_t result = -4096;
        result += 2;
        v11 -= 16;
      }
      while (v11);
    }
    if (v3)
    {
      uint64_t v12 = 16 * v3;
      uint64_t v13 = (void *)v4;
      do
      {
        if (*v13 != -8192 && *v13 != -4096)
        {
          uint64_t v19 = 0;
          sub_1CBFFBC50((uint64_t *)a1, v13, &v19);
          BOOL v14 = v19;
          *uint64_t v19 = *v13;
          uint64_t v15 = v13[1];
          v13[1] = 0;
          v14[1] = v15;
          ++*(_DWORD *)(a1 + 8);
          uint64_t v16 = (llvm::MachineFunction *)v13[1];
          v13[1] = 0;
          if (v16)
          {
            llvm::MachineFunction::~MachineFunction(v16);
            MEMORY[0x1D25D9CE0]();
          }
        }
        v13 += 2;
        v12 -= 16;
      }
      while (v12);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v17 = *(unsigned int *)(a1 + 16);
  if (v17)
  {
    uint64_t v18 = 16 * v17;
    do
    {
      *uint64_t result = -4096;
      result += 2;
      v18 -= 16;
    }
    while (v18);
  }
  return result;
}

void sub_1CC3631F0()
{
}

void *sub_1CC363204(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F260EB08;
  result[1] = v3;
  return result;
}

uint64_t sub_1CC36324C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F260EB08;
  a2[1] = v2;
  return result;
}

uint64_t sub_1CC363278(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v2 = *v1;
  uint64_t v3 = v1[1];
  if (v2 == v3)
  {
LABEL_4:
    uint64_t v4 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v2 != &llvm::FunctionGroupInfoWrapperPass::ID)
    {
      v2 += 16;
      if (v2 == v3) {
        goto LABEL_4;
      }
    }
    uint64_t v4 = *(void *)(v2 + 8);
  }
  return *(void *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 96))(v4, &llvm::FunctionGroupInfoWrapperPass::ID)+ 32);
}

void sub_1CC363300()
{
}

__n128 sub_1CC363314(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F260EB50;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1CC363360(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F260EB50;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1CC363390(uint64_t a1, uint64_t a2, char *a3, uint64_t *a4, void *a5)
{
  char v7 = *a3;
  if (!*a3) {
    goto LABEL_2;
  }
  unsigned int BufferContainingLoc = llvm::SourceMgr::FindBufferContainingLoc(a4, *(void *)(a2 + 8));
  if (!BufferContainingLoc) {
    goto LABEL_2;
  }
  if (BufferContainingLoc > (unint64_t)((uint64_t)(a5[1] - *a5) >> 3)) {
    goto LABEL_2;
  }
  uint64_t v21 = *(void *)(*a5 + 8 * (BufferContainingLoc - 1));
  if (!v21) {
    goto LABEL_2;
  }
  uint64_t v22 = *(unsigned int *)(v21 + 8);
  if (!v22) {
    goto LABEL_2;
  }
  int v8 = 0;
  unsigned int v23 = *(_DWORD *)(a2 + 40) - 1;
  if (v23 >= v22) {
    unsigned int v23 = 0;
  }
  uint64_t v24 = *(void *)(v21 - 8 * v22 + 8 * v23);
  if (*(unsigned char *)v24 == 1)
  {
    uint64_t v25 = *(void *)(v24 + 128);
    if (*(unsigned char *)(v25 + 16) == 16)
    {
      uint64_t v26 = (void *)(v25 + 24);
      if (*(_DWORD *)(v25 + 32) >= 0x41u) {
        uint64_t v26 = (void *)*v26;
      }
      int v8 = *(_DWORD *)v26;
      goto LABEL_3;
    }
LABEL_2:
    int v8 = 0;
  }
LABEL_3:
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v13 = *(void *)(v10 + 168);
  uint64_t v11 = v10 + 168;
  uint64_t v12 = v13;
  char v14 = *(unsigned char *)(v11 + 23);
  uint64_t v15 = *(void *)(v11 + 8);
  int v16 = *(_DWORD *)(a2 + 48);
  if (v14 < 0) {
    uint64_t v11 = v12;
  }
  uint64_t v17 = v14 & 0x7F;
  if (v14 < 0) {
    uint64_t v17 = v15;
  }
  int v28 = 23;
  char v29 = v16;
  uint64_t v27 = &unk_1F2616970;
  uint64_t v30 = a2;
  uint64_t v31 = v11;
  uint64_t v32 = v17;
  char v33 = v7;
  int v34 = v8;
  return llvm::LLVMContext::diagnose(v9, (const llvm::DiagnosticInfo *)&v27);
}

void sub_1CC3634D0()
{
}

__n128 sub_1CC3634E4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F260EB98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1CC363530(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F260EB98;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1CC363560()
{
}

uint64_t sub_1CC36358C()
{
  int v2 = 1;
  *(void *)&long long v1 = "Disable debug info printing";
  *((void *)&v1 + 1) = 27;
  sub_1CD4C1500((uint64_t)&unk_1EBCCF088, "disable-debug-info-print", &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCCF088, &dword_1CB82C000);
}

uint64_t sub_1CC36360C(void *a1, void *a2)
{
  if ((*(unsigned char *)*a1 & 4) != 0)
  {
    uint64_t v4 = *(size_t **)(*a1 - 8);
    size_t v5 = *v4;
    int v2 = v4 + 2;
    size_t v3 = v5;
  }
  else
  {
    int v2 = 0;
    size_t v3 = 0;
  }
  if ((*(unsigned char *)*a2 & 4) != 0)
  {
    int v8 = *(size_t **)(*a2 - 8);
    size_t v9 = *v8;
    unint64_t v6 = v8 + 2;
    size_t v7 = v9;
  }
  else
  {
    unint64_t v6 = 0;
    size_t v7 = 0;
  }
  if (v7 >= v3) {
    size_t v10 = v3;
  }
  else {
    size_t v10 = v7;
  }
  if (v10)
  {
    int v11 = memcmp(v2, v6, v10);
    if (v11) {
      return (v11 >> 31) | 1u;
    }
  }
  if (v3 < v7) {
    unsigned int v13 = -1;
  }
  else {
    unsigned int v13 = 1;
  }
  if (v3 == v7) {
    return 0;
  }
  else {
    return v13;
  }
}

uint64_t llvm::MachineModuleInfoMachO::getAuthGVStubList@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = this;
  uint64_t v4 = this + 56;
  int v5 = *(_DWORD *)(this + 64);
  if (v5)
  {
    uint64_t v6 = *(unsigned int *)(this + 72);
    if (v6)
    {
      uint64_t v7 = 16 * v6;
      int v8 = *(void **)(this + 56);
      while ((*v8 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v8 += 2;
        v7 -= 16;
        if (!v7) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      int v8 = *(void **)(this + 56);
    }
    uint64_t v16 = *(void *)(this + 56) + 16 * v6;
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    if (v8 != (void *)v16)
    {
      unint64_t v17 = 0;
      uint64_t v18 = v8;
LABEL_28:
      unint64_t v19 = v17++;
      while (1)
      {
        v18 += 2;
        if (v18 == (void *)v16) {
          break;
        }
        if ((*v18 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          if (v18 != (void *)v16) {
            goto LABEL_28;
          }
          break;
        }
      }
      if (v19 >= 0xFFFFFFFFFFFFFFFLL) {
        abort();
      }
      this = (uint64_t)operator new(16 * v17);
      *a2 = this;
      a2[1] = this;
      a2[2] = this + 16 * v17;
      BOOL v20 = (uint64_t **)this;
      while (2)
      {
        *(_OWORD *)BOOL v20 = *(_OWORD *)v8;
        do
        {
          v8 += 2;
          if (v8 == (void *)v16)
          {
            v20 += 2;
            goto LABEL_40;
          }
        }
        while ((*v8 | 0x1000) == 0xFFFFFFFFFFFFF000);
        v20 += 2;
        if (v8 != (void *)v16) {
          continue;
        }
        break;
      }
LABEL_40:
      a2[1] = v20;
      if (v20 != (uint64_t **)this)
      {
        this = sub_1CC363A64(this, v20, 126 - 2 * __clz(((uint64_t)v20 - this) >> 4), 1);
        int v5 = *(_DWORD *)(v2 + 64);
      }
    }
  }
  else
  {
LABEL_6:
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  if (v5)
  {
    unsigned int v9 = *(_DWORD *)(v2 + 72);
    if (v9 > 4 * v5 && v9 >= 0x41)
    {
      int v10 = 1 << (33 - __clz(v5 - 1));
      if (v10 <= 64) {
        int v11 = 64;
      }
      else {
        int v11 = v10;
      }
LABEL_16:
      if (v11 == v9)
      {
        *(void *)(v2 + 64) = 0;
        uint64_t v12 = 16 * v9;
        unsigned int v13 = *(void **)(v2 + 56);
        do
        {
          *unsigned int v13 = -4096;
          v13 += 2;
          v12 -= 16;
        }
        while (v12);
      }
      else
      {
        this = MEMORY[0x1D25D9CD0](*(void *)v4, 8);
        if (v11)
        {
          unint64_t v21 = (4 * v11 / 3u + 1) | ((unint64_t)(4 * v11 / 3u + 1) >> 1);
          unint64_t v22 = v21 | (v21 >> 2) | ((v21 | (v21 >> 2)) >> 4);
          LODWORD(v22) = (((v22 | (v22 >> 8)) >> 16) | v22 | (v22 >> 8)) + 1;
          *(_DWORD *)(v2 + 72) = v22;
          this = (uint64_t)operator new(16 * v22, (std::align_val_t)8uLL);
          *(void *)(v2 + 56) = this;
          *(void *)(v2 + 64) = 0;
          uint64_t v23 = *(unsigned int *)(v2 + 72);
          if (v23)
          {
            uint64_t v24 = 16 * v23;
            do
            {
              *(void *)this = -4096;
              this += 16;
              v24 -= 16;
            }
            while (v24);
          }
        }
        else
        {
          *(void *)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
          *(_DWORD *)(v4 + 16) = 0;
        }
      }
      return this;
    }
  }
  else
  {
    if (!*(_DWORD *)(v2 + 68)) {
      return this;
    }
    unsigned int v9 = *(_DWORD *)(v2 + 72);
    if (v9 > 0x40)
    {
      int v11 = 0;
      goto LABEL_16;
    }
  }
  if (v9)
  {
    char v14 = *(void **)v4;
    uint64_t v15 = 16 * v9;
    do
    {
      *char v14 = -4096;
      v14 += 2;
      v15 -= 16;
    }
    while (v15);
  }
  *(void *)(v2 + 64) = 0;
  return this;
}

void *sub_1CC363918(void *a1)
{
  *a1 = &unk_1F260EC58;
  sub_1CC0D7CD8((uint64_t)(a1 + 1));
  return a1;
}

void sub_1CC36395C(void *a1)
{
  *a1 = &unk_1F260EC58;
  sub_1CC0D7CD8((uint64_t)(a1 + 1));

  JUMPOUT(0x1D25D9CE0);
}

_OWORD *sub_1CC3639C0(_OWORD *result, _OWORD *a2, _OWORD *a3, _OWORD *a4, uint64_t a5, unint64_t a6)
{
  if (a6)
  {
    if (a6 >> 60) {
      abort();
    }
    int v10 = result;
    __n128 result = operator new(16 * a6);
    *int v10 = result;
    v10[1] = result;
    void v10[2] = &result[a6];
    while (a2 != a4)
    {
      *__n128 result = *a2;
      while (++a2 != a3)
      {
        if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000) {
          goto LABEL_10;
        }
      }
      a2 = a3;
LABEL_10:
      ++result;
    }
    v10[1] = result;
  }
  return result;
}

uint64_t sub_1CC363A64(uint64_t result, uint64_t **a2, uint64_t a3, char a4)
{
  uint64_t v7 = result;
LABEL_2:
  v330 = a2 - 2;
  int v8 = (uint64_t **)v7;
  while (1)
  {
    unint64_t v9 = (unint64_t)v8;
    uint64_t v10 = (char *)a2 - (char *)v8;
    uint64_t v11 = ((char *)a2 - (char *)v8) >> 4;
    if (v5 || !v4)
    {
      switch(v11)
      {
        case 0:
        case 1:
          return result;
        case 2:
          unsigned int v162 = *(a2 - 2);
          if ((*v162 & 4) != 0)
          {
            uint64_t v288 = (size_t *)*((void *)v162 - 1);
            size_t v289 = *v288;
            __n128 result = (uint64_t)(v288 + 2);
            size_t v163 = v289;
          }
          else
          {
            __n128 result = 0;
            size_t v163 = 0;
          }
          v290 = *(uint64_t **)v9;
          if ((**(unsigned char **)v9 & 4) != 0)
          {
            unint64_t v293 = (size_t *)*(v290 - 1);
            size_t v294 = *v293;
            v291 = v293 + 2;
            size_t v292 = v294;
          }
          else
          {
            v291 = 0;
            size_t v292 = 0;
          }
          if (v292 >= v163) {
            size_t v295 = v163;
          }
          else {
            size_t v295 = v292;
          }
          if (v295 && (__n128 result = memcmp((const void *)result, v291, v295), result))
          {
            if ((result & 0x80000000) == 0) {
              return result;
            }
          }
          else if (v163 >= v292)
          {
            return result;
          }
          *(void *)unint64_t v9 = v162;
          *(a2 - 2) = v290;
          v296 = *(uint64_t **)(v9 + 8);
          *(void *)(v9 + 8) = *(a2 - 1);
          *(a2 - 1) = v296;
          break;
        case 3:
          return (uint64_t)sub_1CC364DF8((uint64_t **)v9, (uint64_t **)(v9 + 16), v330);
        case 4:
          return (uint64_t)sub_1CC365384((uint64_t **)v9, (uint64_t **)(v9 + 16), (uint64_t **)(v9 + 32), v330);
        case 5:
          return (uint64_t)sub_1CC364BB4((uint64_t **)v9, (uint64_t **)(v9 + 16), (uint64_t **)(v9 + 32), (uint64_t **)(v9 + 48), v330);
        default:
          JUMPOUT(0);
      }
      return result;
    }
    v336 = (uint64_t **)v9;
    if (v10 <= 383) {
      break;
    }
    if (!a3)
    {
      if ((uint64_t **)v9 == a2) {
        return result;
      }
      int64_t v195 = (unint64_t)(v11 - 2) >> 1;
      int64_t v196 = v195;
      while (1)
      {
        int64_t v197 = v196;
        if (v195 < v196) {
          goto LABEL_367;
        }
        uint64_t v198 = (2 * v196) | 1;
        int v199 = &v336[2 * v198];
        uint64_t v200 = 2 * v196 + 2;
        int64_t v328 = v196;
        if (v200 < v11)
        {
          uint64_t v201 = v199 + 2;
          if ((*(unsigned char *)*v199 & 4) != 0)
          {
            unint64_t v204 = (size_t *)*(*v199 - 1);
            size_t v205 = *v204;
            uint64_t v202 = v204 + 2;
            size_t v203 = v205;
          }
          else
          {
            uint64_t v202 = 0;
            size_t v203 = 0;
          }
          if ((*(unsigned char *)*v201 & 4) != 0)
          {
            uint64_t v208 = *(size_t **)(*v201 - 8);
            size_t v209 = *v208;
            int v206 = v208 + 2;
            size_t v207 = v209;
          }
          else
          {
            int v206 = 0;
            size_t v207 = 0;
          }
          if (v207 >= v203) {
            size_t v210 = v203;
          }
          else {
            size_t v210 = v207;
          }
          if (v210 && (int v211 = memcmp(v202, v206, v210)) != 0)
          {
            int v212 = (v211 >> 31) | 1;
          }
          else
          {
            if (v203 < v207) {
              int v212 = -1;
            }
            else {
              int v212 = 1;
            }
            if (v203 == v207) {
              int v212 = 0;
            }
          }
          if (v212 == -1)
          {
            v199 += 2;
            uint64_t v198 = v200;
          }
        }
        unint64_t v213 = *v199;
        if ((*(unsigned char *)*v199 & 4) != 0)
        {
          int v215 = (unint64_t *)*(v213 - 1);
          unint64_t v216 = *v215;
          __n128 result = (uint64_t)(v215 + 2);
          unint64_t v214 = v216;
        }
        else
        {
          __n128 result = 0;
          unint64_t v214 = 0;
        }
        BOOL v217 = &v336[2 * v328];
        uint64_t v218 = **v217;
        v331 = *v217;
        if ((v218 & 4) != 0)
        {
          unsigned int v221 = (unint64_t *)*(*v217 - 1);
          unint64_t v222 = *v221;
          unint64_t v219 = v221 + 2;
          unint64_t v220 = v222;
        }
        else
        {
          unint64_t v219 = 0;
          unint64_t v220 = 0;
        }
        size_t v223 = v220 >= v214 ? v214 : v220;
        if (!v223) {
          break;
        }
        __n128 result = memcmp((const void *)result, v219, v223);
        if (!result) {
          break;
        }
        int64_t v197 = v328;
        if ((result & 0x80000000) == 0) {
          goto LABEL_326;
        }
LABEL_367:
        int64_t v196 = v197 - 1;
        if (!v197)
        {
          unint64_t v248 = v336;
          while (1)
          {
            uint64_t v249 = 0;
            uint64_t v329 = v248[1];
            v332 = *v248;
            do
            {
              uint64_t v250 = (uint64_t)&v248[2 * v249 + 2];
              uint64_t v251 = (2 * v249) | 1;
              uint64_t v252 = 2 * v249 + 2;
              if (v252 < v11)
              {
                unint64_t v253 = &v248[2 * v249 + 4];
                if ((**(unsigned char **)v250 & 4) != 0)
                {
                  v255 = *(size_t **)(*(void *)v250 - 8);
                  size_t v256 = *v255;
                  __n128 result = (uint64_t)(v255 + 2);
                  size_t v254 = v256;
                }
                else
                {
                  __n128 result = 0;
                  size_t v254 = 0;
                }
                if ((*(unsigned char *)*v253 & 4) != 0)
                {
                  uint64_t v259 = (size_t *)*(*v253 - 1);
                  size_t v260 = *v259;
                  unint64_t v257 = v259 + 2;
                  size_t v258 = v260;
                }
                else
                {
                  unint64_t v257 = 0;
                  size_t v258 = 0;
                }
                if (v258 >= v254) {
                  size_t v261 = v254;
                }
                else {
                  size_t v261 = v258;
                }
                if (v261 && (__n128 result = memcmp((const void *)result, v257, v261), result))
                {
                  int v262 = ((int)result >> 31) | 1;
                }
                else
                {
                  if (v254 < v258) {
                    int v262 = -1;
                  }
                  else {
                    int v262 = 1;
                  }
                  if (v254 == v258) {
                    int v262 = 0;
                  }
                }
                if (v262 == -1)
                {
                  v250 += 16;
                  uint64_t v251 = v252;
                }
              }
              *unint64_t v248 = *(uint64_t **)v250;
              v248[1] = *(uint64_t **)(v250 + 8);
              unint64_t v248 = (uint64_t **)v250;
              uint64_t v249 = v251;
            }
            while (v251 <= (uint64_t)((unint64_t)(v11 - 2) >> 1));
            uint64_t v263 = a2 - 2;
            if ((uint64_t **)v250 == a2 - 2)
            {
              *(void *)uint64_t v250 = v332;
              *(void *)(v250 + 8) = v329;
              goto LABEL_425;
            }
            *(void *)uint64_t v250 = *(a2 - 2);
            *(void *)(v250 + 8) = *(a2 - 1);
            *(a2 - 2) = v332;
            *(a2 - 1) = v329;
            unint64_t v248 = v336;
            uint64_t v264 = v250 - (void)v336 + 16;
            if (v264 >= 17) {
              break;
            }
LABEL_426:
            a2 = v263;
            if (v11-- <= 2) {
              return result;
            }
          }
          unint64_t v265 = (((unint64_t)v264 >> 4) - 2) >> 1;
          v266 = &v336[2 * v265];
          uint64_t v267 = *v266;
          if ((*(unsigned char *)*v266 & 4) != 0)
          {
            uint64_t v269 = (size_t *)*(v267 - 1);
            size_t v270 = *v269;
            __n128 result = (uint64_t)(v269 + 2);
            size_t v268 = v270;
          }
          else
          {
            __n128 result = 0;
            size_t v268 = 0;
          }
          uint64_t v271 = **(void **)v250;
          v335 = *(uint64_t **)v250;
          if ((v271 & 4) != 0)
          {
            v274 = *(size_t **)(*(void *)v250 - 8);
            size_t v275 = *v274;
            uint64_t v272 = v274 + 2;
            size_t v273 = v275;
          }
          else
          {
            uint64_t v272 = 0;
            size_t v273 = 0;
          }
          if (v273 >= v268) {
            size_t v276 = v268;
          }
          else {
            size_t v276 = v273;
          }
          if (v276 && (__n128 result = memcmp((const void *)result, v272, v276), result))
          {
            unint64_t v248 = v336;
            if ((result & 0x80000000) == 0) {
              goto LABEL_426;
            }
          }
          else
          {
            BOOL v4 = v268 >= v273;
            unint64_t v248 = v336;
            if (v4) {
              goto LABEL_426;
            }
          }
          unint64_t v333 = *(uint64_t **)(v250 + 8);
          while (2)
          {
            int v277 = v266;
            *(void *)uint64_t v250 = v267;
            *(void *)(v250 + 8) = v266[1];
            if (!v265)
            {
LABEL_424:
              *int v277 = v335;
              v277[1] = v333;
LABEL_425:
              unint64_t v248 = v336;
              goto LABEL_426;
            }
            unint64_t v265 = (v265 - 1) >> 1;
            v266 = &v336[2 * v265];
            uint64_t v267 = *v266;
            if ((*(unsigned char *)*v266 & 4) != 0)
            {
              v283 = (size_t *)*(v267 - 1);
              size_t v284 = *v283;
              __n128 result = (uint64_t)(v283 + 2);
              size_t v278 = v284;
              if ((v271 & 4) == 0) {
                goto LABEL_414;
              }
LABEL_412:
              v279 = (size_t *)*(v335 - 1);
              size_t v282 = *v279;
              uint64_t v280 = v279 + 2;
              size_t v281 = v282;
            }
            else
            {
              __n128 result = 0;
              size_t v278 = 0;
              if ((v271 & 4) != 0) {
                goto LABEL_412;
              }
LABEL_414:
              uint64_t v280 = 0;
              size_t v281 = 0;
            }
            if (v281 >= v278) {
              size_t v285 = v278;
            }
            else {
              size_t v285 = v281;
            }
            if (v285 && (__n128 result = memcmp((const void *)result, v280, v285), result))
            {
              int v286 = ((int)result >> 31) | 1;
            }
            else
            {
              if (v278 >= v281) {
                goto LABEL_424;
              }
              int v286 = -1;
            }
            uint64_t v250 = (uint64_t)v277;
            if (v286 != -1) {
              goto LABEL_424;
            }
            continue;
          }
        }
      }
      int64_t v197 = v328;
      if (v214 < v220) {
        goto LABEL_367;
      }
LABEL_326:
      int v326 = v217[1];
      uint64_t v224 = v331;
      while (1)
      {
        uint64_t v225 = v199;
        void *v217 = v213;
        v217[1] = v199[1];
        if (v195 < v198)
        {
LABEL_366:
          int64_t v197 = v328;
          *uint64_t v225 = v224;
          v225[1] = v326;
          goto LABEL_367;
        }
        uint64_t v226 = (2 * v198) | 1;
        int v199 = &v336[2 * v226];
        uint64_t v198 = 2 * v198 + 2;
        if (v198 < v11)
        {
          unsigned int v227 = v199 + 2;
          if ((*(unsigned char *)*v199 & 4) != 0)
          {
            uint64_t v230 = (size_t *)*(*v199 - 1);
            size_t v231 = *v230;
            unint64_t v228 = v230 + 2;
            size_t v229 = v231;
          }
          else
          {
            unint64_t v228 = 0;
            size_t v229 = 0;
          }
          if ((*(unsigned char *)*v227 & 4) != 0)
          {
            uint64_t v234 = *(size_t **)(*v227 - 8);
            size_t v235 = *v234;
            uint64_t v232 = v234 + 2;
            size_t v233 = v235;
          }
          else
          {
            uint64_t v232 = 0;
            size_t v233 = 0;
          }
          if (v233 >= v229) {
            size_t v236 = v229;
          }
          else {
            size_t v236 = v233;
          }
          if (v236 && (int v237 = memcmp(v228, v232, v236)) != 0)
          {
            int v238 = (v237 >> 31) | 1;
          }
          else
          {
            if (v229 < v233) {
              int v238 = -1;
            }
            else {
              int v238 = 1;
            }
            if (v229 == v233) {
              int v238 = 0;
            }
          }
          uint64_t v224 = v331;
          if (v238 == -1) {
            v199 += 2;
          }
          else {
            uint64_t v198 = v226;
          }
        }
        else
        {
          uint64_t v198 = v226;
        }
        unint64_t v213 = *v199;
        if ((*(unsigned char *)*v199 & 4) != 0)
        {
          v244 = (size_t *)*(v213 - 1);
          size_t v245 = *v244;
          __n128 result = (uint64_t)(v244 + 2);
          size_t v239 = v245;
          if ((v218 & 4) == 0)
          {
LABEL_354:
            int v241 = 0;
            size_t v242 = 0;
            goto LABEL_355;
          }
        }
        else
        {
          __n128 result = 0;
          size_t v239 = 0;
          if ((v218 & 4) == 0) {
            goto LABEL_354;
          }
        }
        uint64_t v240 = (size_t *)*(v224 - 1);
        size_t v243 = *v240;
        int v241 = v240 + 2;
        size_t v242 = v243;
LABEL_355:
        if (v242 >= v239) {
          size_t v246 = v239;
        }
        else {
          size_t v246 = v242;
        }
        if (v246 && (__n128 result = memcmp((const void *)result, v241, v246), result))
        {
          int v247 = ((int)result >> 31) | 1;
        }
        else if (v239 == v242)
        {
          int v247 = 0;
        }
        else
        {
          if (v239 < v242) {
            goto LABEL_366;
          }
          int v247 = 1;
        }
        BOOL v217 = v225;
        if (v247 == -1) {
          goto LABEL_366;
        }
      }
    }
    unint64_t v12 = (unint64_t)v11 >> 1;
    unint64_t v13 = v9 + 16 * ((unint64_t)v11 >> 1);
    if ((unint64_t)v10 < 0x801)
    {
      sub_1CC364DF8((uint64_t **)v13, (uint64_t **)v9, v330);
    }
    else
    {
      sub_1CC364DF8((uint64_t **)v9, (uint64_t **)v13, v330);
      sub_1CC364DF8((uint64_t **)(v9 + 16), (uint64_t **)(v13 - 16), a2 - 4);
      sub_1CC364DF8((uint64_t **)(v9 + 32), (uint64_t **)(v9 + 16 + 16 * v12), a2 - 6);
      sub_1CC364DF8((uint64_t **)(v13 - 16), (uint64_t **)v13, (uint64_t **)(v9 + 16 + 16 * v12));
      uint64_t v14 = *(void *)(v13 + 8);
      long long v15 = *(_OWORD *)v9;
      *(void *)unint64_t v9 = *(void *)v13;
      *(void *)(v9 + 8) = v14;
      *(_OWORD *)unint64_t v13 = v15;
    }
    uint64_t v327 = a3 - 1;
    if (a4)
    {
      uint64_t v16 = *(uint64_t **)v9;
      uint64_t v17 = **(void **)v9 & 4;
LABEL_27:
      unint64_t v325 = *(uint64_t **)(v9 + 8);
      uint64_t v30 = 16;
      do
      {
        uint64_t v31 = v30;
        uint64_t v32 = *(uint64_t **)(v9 + v30);
        if ((*(unsigned char *)v32 & 4) != 0)
        {
          int v39 = (size_t *)*(v32 - 1);
          size_t v40 = *v39;
          char v33 = v39 + 2;
          size_t v34 = v40;
          if (v17)
          {
LABEL_30:
            int v35 = (size_t *)*(v16 - 1);
            size_t v38 = *v35;
            unsigned int v36 = v35 + 2;
            size_t v37 = v38;
            goto LABEL_33;
          }
        }
        else
        {
          char v33 = 0;
          size_t v34 = 0;
          if (v17) {
            goto LABEL_30;
          }
        }
        unsigned int v36 = 0;
        size_t v37 = 0;
LABEL_33:
        if (v37 >= v34) {
          size_t v41 = v34;
        }
        else {
          size_t v41 = v37;
        }
        if (v41 && (int v42 = memcmp(v33, v36, v41)) != 0)
        {
          int v43 = (v42 >> 31) | 1;
        }
        else
        {
          if (v34 >= v37) {
            break;
          }
          int v43 = -1;
        }
        uint64_t v30 = v31 + 16;
      }
      while (v43 == -1);
      unint64_t v44 = v9 + v31;
      unsigned int v45 = a2 - 2;
      if (v31 != 16)
      {
        while (1)
        {
          int v46 = v45;
          if ((*(unsigned char *)*v45 & 4) != 0)
          {
            uint64_t v53 = (size_t *)*(*v45 - 1);
            size_t v54 = *v53;
            uint64_t v47 = v53 + 2;
            size_t v48 = v54;
            if (!v17)
            {
LABEL_47:
              unsigned int v50 = 0;
              size_t v51 = 0;
              goto LABEL_48;
            }
          }
          else
          {
            uint64_t v47 = 0;
            size_t v48 = 0;
            if (!v17) {
              goto LABEL_47;
            }
          }
          uint64_t v49 = (size_t *)*(v16 - 1);
          size_t v52 = *v49;
          unsigned int v50 = v49 + 2;
          size_t v51 = v52;
LABEL_48:
          if (v51 >= v48) {
            size_t v55 = v48;
          }
          else {
            size_t v55 = v51;
          }
          if (v55 && (int v56 = memcmp(v47, v50, v55)) != 0)
          {
            int v57 = (v56 >> 31) | 1;
          }
          else if (v48 == v51)
          {
            int v57 = 0;
          }
          else
          {
            if (v48 < v51) {
              goto LABEL_80;
            }
            int v57 = 1;
          }
          unsigned int v45 = v46 - 2;
          if (v57 == -1) {
            goto LABEL_80;
          }
        }
      }
      unsigned int v58 = a2 - 2;
      while (2)
      {
        if (v44 < (unint64_t)(v58 + 2))
        {
          int v46 = v58;
          if ((*(unsigned char *)*v58 & 4) != 0)
          {
            unint64_t v65 = (size_t *)*(*v58 - 1);
            size_t v66 = *v65;
            uint64_t v59 = v65 + 2;
            size_t v60 = v66;
            if (!v17) {
              goto LABEL_66;
            }
LABEL_64:
            int v61 = (size_t *)*(v16 - 1);
            size_t v64 = *v61;
            int v62 = v61 + 2;
            size_t v63 = v64;
          }
          else
          {
            uint64_t v59 = 0;
            size_t v60 = 0;
            if (v17) {
              goto LABEL_64;
            }
LABEL_66:
            int v62 = 0;
            size_t v63 = 0;
          }
          if (v63 >= v60) {
            size_t v67 = v60;
          }
          else {
            size_t v67 = v63;
          }
          if (v67 && (int v68 = memcmp(v59, v62, v67)) != 0)
          {
            int v69 = (v68 >> 31) | 1;
          }
          else if (v60 == v63)
          {
            int v69 = 0;
          }
          else
          {
            if (v60 < v63) {
              goto LABEL_80;
            }
            int v69 = 1;
          }
          unsigned int v58 = v46 - 2;
          if (v69 == -1) {
            goto LABEL_80;
          }
          continue;
        }
        break;
      }
      int v46 = v58 + 2;
LABEL_80:
      if (v44 >= (unint64_t)v46)
      {
        int v8 = (uint64_t **)v44;
        goto LABEL_117;
      }
      uint64_t v70 = *v46;
      int v8 = (uint64_t **)v44;
      unint64_t v71 = v46;
      while (2)
      {
        *int v8 = v70;
        *unint64_t v71 = v32;
        uint64_t v72 = v8[1];
        v8[1] = v71[1];
        v71[1] = v72;
        int v73 = v8 + 2;
        while (2)
        {
          int v8 = v73;
          uint64_t v32 = *v73;
          if ((*(unsigned char *)*v73 & 4) != 0)
          {
            uint64_t v80 = (size_t *)*(v32 - 1);
            size_t v81 = *v80;
            int v74 = v80 + 2;
            size_t v75 = v81;
            if (!v17) {
              goto LABEL_87;
            }
LABEL_85:
            uint64_t v76 = (size_t *)*(v16 - 1);
            size_t v79 = *v76;
            unint64_t v77 = v76 + 2;
            size_t v78 = v79;
          }
          else
          {
            int v74 = 0;
            size_t v75 = 0;
            if (v17) {
              goto LABEL_85;
            }
LABEL_87:
            unint64_t v77 = 0;
            size_t v78 = 0;
          }
          if (v78 >= v75) {
            size_t v82 = v75;
          }
          else {
            size_t v82 = v78;
          }
          if (v82 && (int v83 = memcmp(v74, v77, v82)) != 0)
          {
            int v84 = (v83 >> 31) | 1;
          }
          else
          {
            if (v75 >= v78) {
              break;
            }
            int v84 = -1;
          }
          int v73 = v8 + 2;
          if (v84 == -1) {
            continue;
          }
          break;
        }
        unint64_t v85 = v71 - 2;
        while (2)
        {
          unint64_t v71 = v85;
          uint64_t v70 = *v85;
          if ((*(unsigned char *)*v85 & 4) != 0)
          {
            uint64_t v92 = (size_t *)*(v70 - 1);
            size_t v93 = *v92;
            uint64_t v86 = v92 + 2;
            size_t v87 = v93;
            if (!v17) {
              goto LABEL_102;
            }
LABEL_100:
            unint64_t v88 = (size_t *)*(v16 - 1);
            size_t v91 = *v88;
            uint64_t v89 = v88 + 2;
            size_t v90 = v91;
          }
          else
          {
            uint64_t v86 = 0;
            size_t v87 = 0;
            if (v17) {
              goto LABEL_100;
            }
LABEL_102:
            uint64_t v89 = 0;
            size_t v90 = 0;
          }
          if (v90 >= v87) {
            size_t v94 = v87;
          }
          else {
            size_t v94 = v90;
          }
          if (v94 && (int v95 = memcmp(v86, v89, v94)) != 0)
          {
            int v96 = (v95 >> 31) | 1;
          }
          else if (v87 == v90)
          {
            int v96 = 0;
          }
          else
          {
            if (v87 < v90) {
              break;
            }
            int v96 = 1;
          }
          unint64_t v85 = v71 - 2;
          if (v96 != -1) {
            continue;
          }
          break;
        }
        if (v8 < v71) {
          continue;
        }
        break;
      }
LABEL_117:
      uint64_t v7 = (uint64_t)v336;
      if (v8 - 2 != v336)
      {
        void *v336 = *(v8 - 2);
        v336[1] = *(v8 - 1);
      }
      a3 = v327;
      *(v8 - 2) = v16;
      *(v8 - 1) = v325;
      if (v44 < (unint64_t)v46)
      {
LABEL_122:
        __n128 result = sub_1CC363A64(v336, v8 - 2, v327, a4 & 1);
        a4 = 0;
      }
      else
      {
        BOOL v97 = sub_1CC365084(v336, v8 - 2);
        __n128 result = sub_1CC365084(v8, a2);
        if (result)
        {
          a2 = v8 - 2;
          if (v97) {
            return result;
          }
          goto LABEL_2;
        }
        if (!v97) {
          goto LABEL_122;
        }
      }
    }
    else
    {
      uint64_t v18 = *(unsigned char **)(v9 - 16);
      if ((*v18 & 4) != 0)
      {
        unint64_t v21 = (size_t *)*((void *)v18 - 1);
        size_t v22 = *v21;
        unint64_t v19 = v21 + 2;
        size_t v20 = v22;
      }
      else
      {
        unint64_t v19 = 0;
        size_t v20 = 0;
      }
      uint64_t v16 = *(uint64_t **)v9;
      if ((**(void **)v9 & 4) != 0)
      {
        uint64_t v25 = (size_t *)*(v16 - 1);
        size_t v26 = *v25;
        uint64_t v23 = v25 + 2;
        size_t v24 = v26;
      }
      else
      {
        uint64_t v23 = 0;
        size_t v24 = 0;
      }
      uint64_t v17 = **(void **)v9 & 4;
      if (v24 >= v20) {
        size_t v27 = v20;
      }
      else {
        size_t v27 = v24;
      }
      if (v27 && (int v28 = memcmp(v19, v23, v27)) != 0)
      {
        if (v28 < 0) {
          goto LABEL_27;
        }
      }
      else if (v20 < v24)
      {
        goto LABEL_27;
      }
      if (v17)
      {
        unint64_t v98 = (size_t *)*(v16 - 1);
        size_t v99 = *v98;
        __n128 result = (uint64_t)(v98 + 2);
        size_t v29 = v99;
      }
      else
      {
        __n128 result = 0;
        size_t v29 = 0;
      }
      if ((*(unsigned char *)*v330 & 4) != 0)
      {
        unint64_t v102 = (size_t *)*(*v330 - 1);
        size_t v103 = *v102;
        uint64_t v100 = v102 + 2;
        size_t v101 = v103;
      }
      else
      {
        uint64_t v100 = 0;
        size_t v101 = 0;
      }
      unint64_t v104 = *(uint64_t **)(v9 + 8);
      if (v101 >= v29) {
        size_t v105 = v29;
      }
      else {
        size_t v105 = v101;
      }
      if (v105 && (__n128 result = memcmp((const void *)result, v100, v105), result))
      {
        if ((result & 0x80000000) == 0) {
          goto LABEL_133;
        }
      }
      else if (v29 >= v101)
      {
LABEL_133:
        uint64_t v106 = (uint64_t **)(v9 + 16);
        do
        {
          int v8 = v106;
          if (v106 >= a2) {
            break;
          }
          if (v17)
          {
            uint64_t v108 = (unint64_t *)*(v16 - 1);
            unint64_t v109 = *v108;
            __n128 result = (uint64_t)(v108 + 2);
            unint64_t v107 = v109;
          }
          else
          {
            __n128 result = 0;
            unint64_t v107 = 0;
          }
          if ((*(unsigned char *)*v106 & 4) != 0)
          {
            uint64_t v112 = (unint64_t *)*(*v106 - 1);
            unint64_t v113 = *v112;
            uint64_t v110 = v112 + 2;
            unint64_t v111 = v113;
          }
          else
          {
            uint64_t v110 = 0;
            unint64_t v111 = 0;
          }
          size_t v114 = v111 >= v107 ? v107 : v111;
          if (v114 && (__n128 result = memcmp((const void *)result, v110, v114), result))
          {
            int v115 = ((int)result >> 31) | 1;
          }
          else if (v107 == v111)
          {
            int v115 = 0;
          }
          else
          {
            if (v107 < v111) {
              goto LABEL_172;
            }
            int v115 = 1;
          }
          uint64_t v106 = v8 + 2;
        }
        while (v115 != -1);
        goto LABEL_172;
      }
      size_t v116 = (uint64_t **)(v9 + 16);
      do
      {
        int v8 = v116;
        if (v17)
        {
          unsigned int v118 = (size_t *)*(v16 - 1);
          size_t v119 = *v118;
          __n128 result = (uint64_t)(v118 + 2);
          size_t v117 = v119;
        }
        else
        {
          __n128 result = 0;
          size_t v117 = 0;
        }
        if ((*(unsigned char *)*v116 & 4) != 0)
        {
          uint64_t v122 = (size_t *)*(*v116 - 1);
          size_t v123 = *v122;
          BOOL v120 = v122 + 2;
          size_t v121 = v123;
        }
        else
        {
          BOOL v120 = 0;
          size_t v121 = 0;
        }
        if (v121 >= v117) {
          size_t v124 = v117;
        }
        else {
          size_t v124 = v121;
        }
        if (v124 && (__n128 result = memcmp((const void *)result, v120, v124), result))
        {
          int v125 = ((int)result >> 31) | 1;
        }
        else if (v117 == v121)
        {
          int v125 = 0;
        }
        else
        {
          if (v117 < v121) {
            break;
          }
          int v125 = 1;
        }
        size_t v116 = v8 + 2;
      }
      while (v125 != -1);
LABEL_172:
      uint64_t v126 = a2;
      if (v8 < a2)
      {
        uint64_t v127 = a2 - 2;
        do
        {
          uint64_t v126 = v127;
          if (v17)
          {
            uint64_t v129 = (size_t *)*(v16 - 1);
            size_t v130 = *v129;
            __n128 result = (uint64_t)(v129 + 2);
            size_t v128 = v130;
          }
          else
          {
            __n128 result = 0;
            size_t v128 = 0;
          }
          if ((*(unsigned char *)*v127 & 4) != 0)
          {
            unsigned int v133 = (size_t *)*(*v127 - 1);
            size_t v134 = *v133;
            uint64_t v131 = v133 + 2;
            size_t v132 = v134;
          }
          else
          {
            uint64_t v131 = 0;
            size_t v132 = 0;
          }
          if (v132 >= v128) {
            size_t v135 = v128;
          }
          else {
            size_t v135 = v132;
          }
          if (v135 && (__n128 result = memcmp((const void *)result, v131, v135), result))
          {
            int v136 = ((int)result >> 31) | 1;
          }
          else
          {
            if (v128 >= v132) {
              break;
            }
            int v136 = -1;
          }
          uint64_t v127 = v126 - 2;
        }
        while (v136 == -1);
      }
      if (v8 < v126)
      {
        uint64_t v137 = *v8;
        uint64_t v138 = *v126;
        do
        {
          *int v8 = v138;
          *uint64_t v126 = v137;
          uint64_t v139 = v8[1];
          v8[1] = v126[1];
          v126[1] = v139;
          uint64_t v140 = v8 + 2;
          do
          {
            int v8 = v140;
            if (v17)
            {
              unsigned int v143 = (size_t *)*(v16 - 1);
              size_t v144 = *v143;
              char v141 = v143 + 2;
              size_t v142 = v144;
            }
            else
            {
              char v141 = 0;
              size_t v142 = 0;
            }
            uint64_t v137 = *v140;
            if ((*(unsigned char *)*v140 & 4) != 0)
            {
              int v147 = (size_t *)*(v137 - 1);
              size_t v148 = *v147;
              unsigned int v145 = v147 + 2;
              size_t v146 = v148;
            }
            else
            {
              unsigned int v145 = 0;
              size_t v146 = 0;
            }
            if (v146 >= v142) {
              size_t v149 = v142;
            }
            else {
              size_t v149 = v146;
            }
            if (v149 && (int v150 = memcmp(v141, v145, v149)) != 0)
            {
              int v151 = (v150 >> 31) | 1;
            }
            else if (v142 == v146)
            {
              int v151 = 0;
            }
            else
            {
              if (v142 < v146) {
                break;
              }
              int v151 = 1;
            }
            uint64_t v140 = v8 + 2;
          }
          while (v151 != -1);
          unint64_t v152 = v126 - 2;
          do
          {
            uint64_t v126 = v152;
            if (v17)
            {
              unsigned int v154 = (size_t *)*(v16 - 1);
              size_t v155 = *v154;
              __n128 result = (uint64_t)(v154 + 2);
              size_t v153 = v155;
            }
            else
            {
              __n128 result = 0;
              size_t v153 = 0;
            }
            uint64_t v138 = *v152;
            if ((*(unsigned char *)*v152 & 4) != 0)
            {
              uint64_t v158 = (size_t *)*(v138 - 1);
              size_t v159 = *v158;
              int v156 = v158 + 2;
              size_t v157 = v159;
            }
            else
            {
              int v156 = 0;
              size_t v157 = 0;
            }
            if (v157 >= v153) {
              size_t v160 = v153;
            }
            else {
              size_t v160 = v157;
            }
            if (v160 && (__n128 result = memcmp((const void *)result, v156, v160), result))
            {
              int v161 = ((int)result >> 31) | 1;
            }
            else
            {
              if (v153 >= v157) {
                break;
              }
              int v161 = -1;
            }
            unint64_t v152 = v126 - 2;
          }
          while (v161 == -1);
        }
        while (v8 < v126);
      }
      BOOL v4 = (unint64_t)(v8 - 2) >= v9;
      BOOL v5 = v8 - 2 == (uint64_t **)v9;
      if (v8 - 2 != (uint64_t **)v9)
      {
        *(void *)unint64_t v9 = *(v8 - 2);
        *(void *)(v9 + 8) = *(v8 - 1);
      }
      a4 = 0;
      *(v8 - 2) = v16;
      *(v8 - 1) = v104;
      a3 = v327;
    }
  }
  long long v164 = (uint64_t **)(v9 + 16);
  BOOL v166 = (uint64_t **)v9 == a2 || v164 == a2;
  if ((a4 & 1) == 0)
  {
    if (v166) {
      return result;
    }
    for (unsigned int i = (void *)(v9 + 8); ; i += 2)
    {
      unint64_t v298 = v9;
      v299 = *(uint64_t **)(v9 + 16);
      uint64_t v300 = *v299;
      if ((*v299 & 4) != 0)
      {
        int v302 = (size_t *)*(v299 - 1);
        size_t v303 = *v302;
        __n128 result = (uint64_t)(v302 + 2);
        size_t v301 = v303;
      }
      else
      {
        __n128 result = 0;
        size_t v301 = 0;
      }
      unint64_t v304 = (unint64_t)v164;
      uint64_t v305 = *(uint64_t **)v9;
      if ((**(unsigned char **)v9 & 4) != 0)
      {
        v308 = (size_t *)*(v305 - 1);
        size_t v309 = *v308;
        v306 = v308 + 2;
        size_t v307 = v309;
      }
      else
      {
        v306 = 0;
        size_t v307 = 0;
      }
      if (v307 >= v301) {
        size_t v310 = v301;
      }
      else {
        size_t v310 = v307;
      }
      if (v310 && (__n128 result = memcmp((const void *)result, v306, v310), result))
      {
        unint64_t v9 = v304;
        if ((result & 0x80000000) == 0) {
          goto LABEL_475;
        }
      }
      else
      {
        BOOL v4 = v301 >= v307;
        unint64_t v9 = v304;
        if (v4) {
          goto LABEL_475;
        }
      }
      uint64_t v311 = *(void *)(v298 + 24);
      v312 = i;
      do
      {
        uint64_t v313 = v312;
        uint64_t v314 = *v312;
        v313[1] = v305;
        v313[2] = v314;
        if ((v300 & 4) != 0)
        {
          v316 = (size_t *)*(v299 - 1);
          size_t v317 = *v316;
          __n128 result = (uint64_t)(v316 + 2);
          size_t v315 = v317;
        }
        else
        {
          __n128 result = 0;
          size_t v315 = 0;
        }
        uint64_t v305 = (uint64_t *)*(v313 - 3);
        if ((*(unsigned char *)v305 & 4) != 0)
        {
          v320 = (size_t *)*(v305 - 1);
          size_t v321 = *v320;
          int v318 = v320 + 2;
          size_t v319 = v321;
        }
        else
        {
          int v318 = 0;
          size_t v319 = 0;
        }
        if (v319 >= v315) {
          size_t v322 = v315;
        }
        else {
          size_t v322 = v319;
        }
        if (v322 && (__n128 result = memcmp((const void *)result, v318, v322), result))
        {
          int v323 = ((int)result >> 31) | 1;
          unint64_t v9 = v304;
        }
        else
        {
          BOOL v4 = v315 >= v319;
          unint64_t v9 = v304;
          if (v4) {
            break;
          }
          int v323 = -1;
        }
        v312 = v313 - 2;
      }
      while (v323 == -1);
      *(v313 - 1) = v299;
      *uint64_t v313 = v311;
LABEL_475:
      long long v164 = (uint64_t **)(v9 + 16);
      if ((uint64_t **)(v9 + 16) == a2) {
        return result;
      }
    }
  }
  if (v166) {
    return result;
  }
  uint64_t v167 = 0;
  unint64_t v168 = v9;
  while (2)
  {
    uint64_t v169 = (uint64_t **)v168;
    unint64_t v168 = (unint64_t)v164;
    long long v170 = v169[2];
    uint64_t v171 = *v170;
    if ((*v170 & 4) != 0)
    {
      long long v173 = (size_t *)*(v170 - 1);
      size_t v174 = *v173;
      __n128 result = (uint64_t)(v173 + 2);
      size_t v172 = v174;
    }
    else
    {
      __n128 result = 0;
      size_t v172 = 0;
    }
    long long v175 = *v169;
    if ((*(unsigned char *)*v169 & 4) != 0)
    {
      uint64_t v178 = (size_t *)*(v175 - 1);
      size_t v179 = *v178;
      long long v176 = v178 + 2;
      size_t v177 = v179;
    }
    else
    {
      long long v176 = 0;
      size_t v177 = 0;
    }
    if (v177 >= v172) {
      size_t v180 = v172;
    }
    else {
      size_t v180 = v177;
    }
    if (v180 && (__n128 result = memcmp((const void *)result, v176, v180), result))
    {
      if ((result & 0x80000000) == 0) {
        goto LABEL_287;
      }
    }
    else if (v172 >= v177)
    {
      goto LABEL_287;
    }
    uint64_t v181 = v169[3];
    uint64_t v182 = v167;
    while (2)
    {
      unint64_t v183 = (char *)v336 + v182;
      uint64_t v184 = *(uint64_t *)((char *)v336 + v182 + 8);
      *((void *)v183 + 2) = v175;
      *((void *)v183 + 3) = v184;
      if (!v182)
      {
        uint64_t v185 = v336;
        goto LABEL_286;
      }
      uint64_t v185 = v169;
      if ((v171 & 4) != 0)
      {
        uint64_t v187 = (size_t *)*(v170 - 1);
        size_t v188 = *v187;
        __n128 result = (uint64_t)(v187 + 2);
        size_t v186 = v188;
      }
      else
      {
        __n128 result = 0;
        size_t v186 = 0;
      }
      long long v175 = (uint64_t *)*((void *)v183 - 2);
      if ((*(unsigned char *)v175 & 4) != 0)
      {
        int v191 = (size_t *)*(v175 - 1);
        size_t v192 = *v191;
        uint64_t v189 = v191 + 2;
        size_t v190 = v192;
      }
      else
      {
        uint64_t v189 = 0;
        size_t v190 = 0;
      }
      if (v190 >= v186) {
        size_t v193 = v186;
      }
      else {
        size_t v193 = v190;
      }
      if (v193)
      {
        __n128 result = memcmp((const void *)result, v189, v193);
        if (result)
        {
          int v194 = ((int)result >> 31) | 1;
          goto LABEL_282;
        }
      }
      if (v186 < v190)
      {
        int v194 = -1;
LABEL_282:
        uint64_t v169 = v185 - 2;
        v182 -= 16;
        if (v194 != -1) {
          goto LABEL_286;
        }
        continue;
      }
      break;
    }
    uint64_t v185 = (uint64_t **)((char *)v336 + v182);
LABEL_286:
    *uint64_t v185 = v170;
    v185[1] = v181;
LABEL_287:
    long long v164 = (uint64_t **)(v168 + 16);
    v167 += 16;
    if ((uint64_t **)(v168 + 16) != a2) {
      continue;
    }
    return result;
  }
}

void *sub_1CC364BB4(uint64_t **a1, uint64_t **a2, uint64_t **a3, uint64_t **a4, uint64_t **a5)
{
  sub_1CC365384((uint64_t **)a1, a2, a3, a4);
  uint64_t v10 = *a5;
  if ((*(unsigned char *)*a5 & 4) != 0)
  {
    unint64_t v13 = (size_t *)*(v10 - 1);
    size_t v14 = *v13;
    __n128 result = v13 + 2;
    size_t v12 = v14;
  }
  else
  {
    __n128 result = 0;
    size_t v12 = 0;
  }
  long long v15 = *a4;
  if ((*(unsigned char *)*a4 & 4) != 0)
  {
    uint64_t v18 = (size_t *)*(v15 - 1);
    size_t v19 = *v18;
    uint64_t v16 = v18 + 2;
    size_t v17 = v19;
  }
  else
  {
    uint64_t v16 = 0;
    size_t v17 = 0;
  }
  if (v17 >= v12) {
    size_t v20 = v12;
  }
  else {
    size_t v20 = v17;
  }
  if (v20 && (__n128 result = (void *)memcmp(result, v16, v20), result))
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v12 >= v17)
  {
    return result;
  }
  *a4 = v10;
  *a5 = v15;
  unint64_t v21 = a4[1];
  a4[1] = a5[1];
  a5[1] = v21;
  size_t v22 = *a4;
  if ((*(unsigned char *)*a4 & 4) != 0)
  {
    size_t v24 = (size_t *)*(v22 - 1);
    size_t v25 = *v24;
    __n128 result = v24 + 2;
    size_t v23 = v25;
  }
  else
  {
    __n128 result = 0;
    size_t v23 = 0;
  }
  size_t v26 = *a3;
  if ((*(unsigned char *)*a3 & 4) != 0)
  {
    size_t v29 = (size_t *)*(v26 - 1);
    size_t v30 = *v29;
    size_t v27 = v29 + 2;
    size_t v28 = v30;
  }
  else
  {
    size_t v27 = 0;
    size_t v28 = 0;
  }
  if (v28 >= v23) {
    size_t v31 = v23;
  }
  else {
    size_t v31 = v28;
  }
  if (v31 && (__n128 result = (void *)memcmp(result, v27, v31), result))
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v23 >= v28)
  {
    return result;
  }
  *a3 = v22;
  *a4 = v26;
  uint64_t v32 = a3[1];
  a3[1] = a4[1];
  a4[1] = v32;
  char v33 = *a3;
  if ((*(unsigned char *)*a3 & 4) != 0)
  {
    int v35 = (size_t *)*(v33 - 1);
    size_t v36 = *v35;
    __n128 result = v35 + 2;
    size_t v34 = v36;
  }
  else
  {
    __n128 result = 0;
    size_t v34 = 0;
  }
  size_t v37 = *a2;
  if ((*(unsigned char *)*a2 & 4) != 0)
  {
    size_t v40 = (size_t *)*(v37 - 1);
    size_t v41 = *v40;
    size_t v38 = v40 + 2;
    size_t v39 = v41;
  }
  else
  {
    size_t v38 = 0;
    size_t v39 = 0;
  }
  if (v39 >= v34) {
    size_t v42 = v34;
  }
  else {
    size_t v42 = v39;
  }
  if (v42 && (__n128 result = (void *)memcmp(result, v38, v42), result))
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v34 >= v39)
  {
    return result;
  }
  *a2 = v33;
  *a3 = v37;
  int v43 = a2[1];
  a2[1] = a3[1];
  a3[1] = v43;
  unint64_t v44 = *a2;
  if ((*(unsigned char *)*a2 & 4) != 0)
  {
    int v46 = (size_t *)*(v44 - 1);
    size_t v47 = *v46;
    __n128 result = v46 + 2;
    size_t v45 = v47;
  }
  else
  {
    __n128 result = 0;
    size_t v45 = 0;
  }
  size_t v48 = *(uint64_t **)a1;
  if ((**(unsigned char **)a1 & 4) != 0)
  {
    size_t v51 = (size_t *)*(v48 - 1);
    size_t v52 = *v51;
    uint64_t v49 = v51 + 2;
    size_t v50 = v52;
  }
  else
  {
    uint64_t v49 = 0;
    size_t v50 = 0;
  }
  if (v50 >= v45) {
    size_t v53 = v45;
  }
  else {
    size_t v53 = v50;
  }
  if (v53 && (__n128 result = (void *)memcmp(result, v49, v53), result))
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v45 >= v50)
  {
    return result;
  }
  *(void *)a1 = v44;
  *a2 = v48;
  size_t v54 = *(uint64_t **)(a1 + 8);
  *(void *)(a1 + 8) = a2[1];
  a2[1] = v54;
  return result;
}

void *sub_1CC364DF8(uint64_t **a1, uint64_t **a2, uint64_t **a3)
{
  uint64_t v6 = *a2;
  uint64_t v7 = **a2;
  if ((v7 & 4) != 0)
  {
    uint64_t v10 = (size_t *)*(v6 - 1);
    size_t v11 = *v10;
    int v8 = v10 + 2;
    size_t v9 = v11;
  }
  else
  {
    int v8 = 0;
    size_t v9 = 0;
  }
  size_t v12 = *a1;
  if ((*(unsigned char *)*a1 & 4) != 0)
  {
    long long v15 = (size_t *)*(v12 - 1);
    size_t v16 = *v15;
    unint64_t v13 = v15 + 2;
    size_t v14 = v16;
  }
  else
  {
    unint64_t v13 = 0;
    size_t v14 = 0;
  }
  if (v14 >= v9) {
    size_t v17 = v9;
  }
  else {
    size_t v17 = v14;
  }
  if (v17 && (int v18 = memcmp(v8, v13, v17)) != 0)
  {
    if ((v18 & 0x80000000) == 0) {
      goto LABEL_13;
    }
  }
  else if (v9 >= v14)
  {
LABEL_13:
    size_t v19 = *a3;
    if ((*(unsigned char *)*a3 & 4) != 0)
    {
      uint64_t v32 = (size_t *)*(v19 - 1);
      size_t v33 = *v32;
      __n128 result = v32 + 2;
      size_t v21 = v33;
      if ((v7 & 4) != 0) {
        goto LABEL_15;
      }
    }
    else
    {
      __n128 result = 0;
      size_t v21 = 0;
      if ((v7 & 4) != 0)
      {
LABEL_15:
        size_t v22 = (size_t *)*(v6 - 1);
        size_t v25 = *v22;
        size_t v23 = v22 + 2;
        size_t v24 = v25;
LABEL_22:
        if (v24 >= v21) {
          size_t v34 = v21;
        }
        else {
          size_t v34 = v24;
        }
        if (v34 && (__n128 result = (void *)memcmp(result, v23, v34), result))
        {
          if ((result & 0x80000000) == 0) {
            return result;
          }
        }
        else if (v21 >= v24)
        {
          return result;
        }
        *a2 = v19;
        *a3 = v6;
        size_t v36 = (uint64_t *)(a2 + 1);
        int v35 = a2[1];
        a2[1] = a3[1];
        a3[1] = v35;
        size_t v37 = *a2;
        if ((*(unsigned char *)*a2 & 4) != 0)
        {
          size_t v48 = (size_t *)*(v37 - 1);
          size_t v49 = *v48;
          __n128 result = v48 + 2;
          size_t v38 = v49;
        }
        else
        {
          __n128 result = 0;
          size_t v38 = 0;
        }
        size_t v50 = *a1;
        if ((*(unsigned char *)*a1 & 4) != 0)
        {
          unsigned int v58 = (size_t *)*(v50 - 1);
          size_t v59 = *v58;
          size_t v51 = v58 + 2;
          size_t v52 = v59;
        }
        else
        {
          size_t v51 = 0;
          size_t v52 = 0;
        }
        if (v52 >= v38) {
          size_t v60 = v38;
        }
        else {
          size_t v60 = v52;
        }
        if (v60 && (__n128 result = (void *)memcmp(result, v51, v60), result))
        {
          if ((result & 0x80000000) == 0) {
            return result;
          }
        }
        else if (v38 >= v52)
        {
          return result;
        }
        *a1 = v37;
        int v46 = (uint64_t *)(a1 + 1);
        *a2 = v50;
        goto LABEL_71;
      }
    }
    size_t v23 = 0;
    size_t v24 = 0;
    goto LABEL_22;
  }
  size_t v26 = *a3;
  if ((*(unsigned char *)*a3 & 4) != 0)
  {
    size_t v39 = (size_t *)*(v26 - 1);
    size_t v40 = *v39;
    __n128 result = v39 + 2;
    size_t v27 = v40;
    if ((v7 & 4) != 0) {
      goto LABEL_19;
    }
  }
  else
  {
    __n128 result = 0;
    size_t v27 = 0;
    if ((v7 & 4) != 0)
    {
LABEL_19:
      size_t v28 = (size_t *)*(v6 - 1);
      size_t v31 = *v28;
      size_t v29 = v28 + 2;
      size_t v30 = v31;
      goto LABEL_34;
    }
  }
  size_t v29 = 0;
  size_t v30 = 0;
LABEL_34:
  if (v30 >= v27) {
    size_t v41 = v27;
  }
  else {
    size_t v41 = v30;
  }
  if (v41 && (__n128 result = (void *)memcmp(result, v29, v41), result))
  {
    if ((result & 0x80000000) == 0)
    {
LABEL_40:
      *a1 = v6;
      size_t v42 = a2[1];
      *a2 = v12;
      int v43 = a1[1];
      a1[1] = v42;
      a2[1] = v43;
      unint64_t v44 = *a3;
      if ((*(unsigned char *)*a3 & 4) != 0)
      {
        size_t v53 = (size_t *)*(v44 - 1);
        size_t v54 = *v53;
        __n128 result = v53 + 2;
        size_t v45 = v54;
      }
      else
      {
        __n128 result = 0;
        size_t v45 = 0;
      }
      size_t v55 = *a2;
      if ((*(unsigned char *)*a2 & 4) != 0)
      {
        int v61 = (size_t *)*(v55 - 1);
        size_t v62 = *v61;
        int v56 = v61 + 2;
        size_t v57 = v62;
      }
      else
      {
        int v56 = 0;
        size_t v57 = 0;
      }
      if (v57 >= v45) {
        size_t v63 = v45;
      }
      else {
        size_t v63 = v57;
      }
      if (v63 && (__n128 result = (void *)memcmp(result, v56, v63), result))
      {
        if ((result & 0x80000000) == 0) {
          return result;
        }
      }
      else if (v45 >= v57)
      {
        return result;
      }
      *a2 = v44;
      *a3 = v55;
      size_t v47 = (uint64_t *)(a3 + 1);
      int v46 = (uint64_t *)(a2 + 1);
      goto LABEL_70;
    }
  }
  else if (v27 >= v30)
  {
    goto LABEL_40;
  }
  *a1 = v26;
  int v46 = (uint64_t *)(a1 + 1);
  *a3 = v12;
  size_t v47 = (uint64_t *)(a3 + 1);
LABEL_70:
  size_t v36 = v47;
LABEL_71:
  uint64_t v64 = *v46;
  *int v46 = *v36;
  *size_t v36 = v64;
  return result;
}

BOOL sub_1CC365084(uint64_t **a1, uint64_t **a2)
{
  uint64_t v3 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v3)
  {
    case 0:
    case 1:
      return result;
    case 2:
      BOOL v5 = *(a2 - 2);
      if ((*v5 & 4) != 0)
      {
        size_t v39 = (size_t *)*((void *)v5 - 1);
        size_t v40 = *v39;
        uint64_t v6 = v39 + 2;
        size_t v7 = v40;
      }
      else
      {
        uint64_t v6 = 0;
        size_t v7 = 0;
      }
      size_t v41 = *a1;
      if ((*(unsigned char *)*a1 & 4) != 0)
      {
        unint64_t v44 = (size_t *)*(v41 - 1);
        size_t v45 = *v44;
        size_t v42 = v44 + 2;
        size_t v43 = v45;
      }
      else
      {
        size_t v42 = 0;
        size_t v43 = 0;
      }
      if (v43 >= v7) {
        size_t v46 = v7;
      }
      else {
        size_t v46 = v43;
      }
      if (v46 && (int v47 = memcmp(v6, v42, v46)) != 0)
      {
        if ((v47 & 0x80000000) == 0) {
          return 1;
        }
      }
      else if (v7 >= v43)
      {
        return 1;
      }
      *a1 = (uint64_t *)v5;
      *(a2 - 2) = v41;
      size_t v48 = a1[1];
      a1[1] = *(a2 - 1);
      *(a2 - 1) = v48;
      return 1;
    case 3:
      sub_1CC364DF8(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      sub_1CC365384(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      sub_1CC364BB4(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      int v8 = a1 + 4;
      sub_1CC364DF8(a1, a1 + 2, a1 + 4);
      size_t v9 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v50 = 0;
      break;
  }
  while (2)
  {
    size_t v11 = *v9;
    uint64_t v12 = **v9;
    if ((v12 & 4) != 0)
    {
      long long v15 = (size_t *)*(v11 - 1);
      size_t v16 = *v15;
      unint64_t v13 = v15 + 2;
      size_t v14 = v16;
    }
    else
    {
      unint64_t v13 = 0;
      size_t v14 = 0;
    }
    size_t v17 = *v8;
    if ((*(unsigned char *)*v8 & 4) != 0)
    {
      size_t v20 = (size_t *)*(v17 - 1);
      size_t v21 = *v20;
      int v18 = v20 + 2;
      size_t v19 = v21;
    }
    else
    {
      int v18 = 0;
      size_t v19 = 0;
    }
    if (v19 >= v14) {
      size_t v22 = v14;
    }
    else {
      size_t v22 = v19;
    }
    if (v22 && (int v23 = memcmp(v13, v18, v22)) != 0)
    {
      if ((v23 & 0x80000000) == 0) {
        goto LABEL_41;
      }
    }
    else if (v14 >= v19)
    {
      goto LABEL_41;
    }
    size_t v49 = v9[1];
    uint64_t v24 = v10;
    while (1)
    {
      size_t v25 = (uint64_t **)((char *)a1 + v24);
      uint64_t v26 = *(uint64_t *)((char *)a1 + v24 + 40);
      v25[6] = v17;
      v25[7] = v26;
      if (v24 == -32)
      {
        size_t v27 = a1;
        goto LABEL_40;
      }
      size_t v27 = v8;
      if ((v12 & 4) != 0)
      {
        size_t v30 = (unint64_t *)*(v11 - 1);
        unint64_t v31 = *v30;
        size_t v28 = v30 + 2;
        unint64_t v29 = v31;
      }
      else
      {
        size_t v28 = 0;
        unint64_t v29 = 0;
      }
      size_t v17 = (uint64_t *)v25[2];
      if ((*(unsigned char *)v17 & 4) != 0)
      {
        size_t v34 = (unint64_t *)*(v17 - 1);
        unint64_t v35 = *v34;
        uint64_t v32 = v34 + 2;
        unint64_t v33 = v35;
      }
      else
      {
        uint64_t v32 = 0;
        unint64_t v33 = 0;
      }
      size_t v36 = v33 >= v29 ? v29 : v33;
      if (!v36) {
        break;
      }
      int v37 = memcmp(v28, v32, v36);
      if (!v37) {
        break;
      }
      int v38 = (v37 >> 31) | 1;
LABEL_36:
      int v8 = v27 - 2;
      v24 -= 16;
      if (v38 != -1) {
        goto LABEL_40;
      }
    }
    if (v29 < v33)
    {
      int v38 = -1;
      goto LABEL_36;
    }
    size_t v27 = (uint64_t **)((char *)a1 + v24 + 32);
LABEL_40:
    *size_t v27 = v11;
    v27[1] = v49;
    if (++v50 != 8)
    {
LABEL_41:
      int v8 = v9;
      v10 += 16;
      v9 += 2;
      if (v9 == a2) {
        return 1;
      }
      continue;
    }
    return v9 + 2 == a2;
  }
}

void *sub_1CC365384(uint64_t **a1, uint64_t **a2, uint64_t **a3, uint64_t **a4)
{
  sub_1CC364DF8(a1, a2, a3);
  int v8 = *a4;
  if ((*(unsigned char *)*a4 & 4) != 0)
  {
    size_t v11 = (size_t *)*(v8 - 1);
    size_t v12 = *v11;
    BOOL result = v11 + 2;
    size_t v10 = v12;
  }
  else
  {
    BOOL result = 0;
    size_t v10 = 0;
  }
  unint64_t v13 = *a3;
  if ((*(unsigned char *)*a3 & 4) != 0)
  {
    size_t v16 = (size_t *)*(v13 - 1);
    size_t v17 = *v16;
    size_t v14 = v16 + 2;
    size_t v15 = v17;
  }
  else
  {
    size_t v14 = 0;
    size_t v15 = 0;
  }
  if (v15 >= v10) {
    size_t v18 = v10;
  }
  else {
    size_t v18 = v15;
  }
  if (v18 && (BOOL result = (void *)memcmp(result, v14, v18), result))
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v10 >= v15)
  {
    return result;
  }
  *a3 = v8;
  *a4 = v13;
  size_t v19 = a3[1];
  a3[1] = a4[1];
  a4[1] = v19;
  size_t v20 = *a3;
  if ((*(unsigned char *)*a3 & 4) != 0)
  {
    size_t v22 = (size_t *)*(v20 - 1);
    size_t v23 = *v22;
    BOOL result = v22 + 2;
    size_t v21 = v23;
  }
  else
  {
    BOOL result = 0;
    size_t v21 = 0;
  }
  uint64_t v24 = *a2;
  if ((*(unsigned char *)*a2 & 4) != 0)
  {
    size_t v27 = (size_t *)*(v24 - 1);
    size_t v28 = *v27;
    size_t v25 = v27 + 2;
    size_t v26 = v28;
  }
  else
  {
    size_t v25 = 0;
    size_t v26 = 0;
  }
  if (v26 >= v21) {
    size_t v29 = v21;
  }
  else {
    size_t v29 = v26;
  }
  if (v29 && (BOOL result = (void *)memcmp(result, v25, v29), result))
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v21 >= v26)
  {
    return result;
  }
  *a2 = v20;
  *a3 = v24;
  size_t v30 = a2[1];
  a2[1] = a3[1];
  a3[1] = v30;
  unint64_t v31 = *a2;
  if ((*(unsigned char *)*a2 & 4) != 0)
  {
    unint64_t v33 = (size_t *)*(v31 - 1);
    size_t v34 = *v33;
    BOOL result = v33 + 2;
    size_t v32 = v34;
  }
  else
  {
    BOOL result = 0;
    size_t v32 = 0;
  }
  unint64_t v35 = *a1;
  if ((*(unsigned char *)*a1 & 4) != 0)
  {
    int v38 = (size_t *)*(v35 - 1);
    size_t v39 = *v38;
    size_t v36 = v38 + 2;
    size_t v37 = v39;
  }
  else
  {
    size_t v36 = 0;
    size_t v37 = 0;
  }
  if (v37 >= v32) {
    size_t v40 = v32;
  }
  else {
    size_t v40 = v37;
  }
  if (v40 && (BOOL result = (void *)memcmp(result, v36, v40), result))
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v32 >= v37)
  {
    return result;
  }
  *a1 = v31;
  *a2 = v35;
  size_t v41 = a1[1];
  a1[1] = a2[1];
  a2[1] = v41;
  return result;
}

void sub_1CC365548()
{
}

void *sub_1CC36555C(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1F260ECA0;
  result[1] = v3;
  return result;
}

uint64_t sub_1CC3655A4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F260ECA0;
  a2[1] = v2;
  return result;
}

uint64_t sub_1CC3655D0(uint64_t a1, llvm::AbstractSlotTrackerStorage **a2, const llvm::Module **a3, unsigned __int8 *a4)
{
  return llvm::MachineModuleSlotTracker::processMachineModule(*(void *)(a1 + 8), *a2, *a3, *a4);
}

void sub_1CC3655E8()
{
}

void *sub_1CC3655FC(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1F260ECE8;
  result[1] = v3;
  return result;
}

uint64_t sub_1CC365644(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F260ECE8;
  a2[1] = v2;
  return result;
}

uint64_t sub_1CC365670(uint64_t a1, llvm::AbstractSlotTrackerStorage **a2, const Function **a3, char *a4)
{
  return llvm::MachineModuleSlotTracker::processMachineFunction(*(void *)(a1 + 8), *a2, *a3, *a4);
}

uint64_t llvm::MachineOperand::setReg(uint64_t result, unsigned int a2)
{
  uint64_t v2 = *(unsigned int *)(result + 4);
  if (v2 != a2)
  {
    *(_DWORD *)result &= ~0x8000000u;
    uint64_t v3 = *(void *)(result + 8);
    if (v3 && (uint64_t v4 = *(void *)(v3 + 24)) != 0 && (v5 = *(void *)(v4 + 32)) != 0)
    {
      uint64_t v6 = *(void *)(v5 + 40);
      if ((v2 & 0x80000000) != 0) {
        size_t v7 = (uint64_t *)(*(void *)(v6 + 24) + 16 * (v2 & 0x7FFFFFFF) + 8);
      }
      else {
        size_t v7 = (uint64_t *)(*(void *)(v6 + 272) + 8 * v2);
      }
      uint64_t v8 = *v7;
      uint64_t v10 = *(void *)(result + 16);
      uint64_t v9 = *(void *)(result + 24);
      if (*v7 != result) {
        size_t v7 = (uint64_t *)(v10 + 24);
      }
      *size_t v7 = v9;
      if (v9) {
        uint64_t v11 = v9;
      }
      else {
        uint64_t v11 = v8;
      }
      *(void *)(v11 + 16) = v10;
      *(void *)(result + 16) = 0;
      *(void *)(result + 24) = 0;
      *(_DWORD *)(result + 4) = a2;
      if ((a2 & 0x80000000) != 0) {
        size_t v12 = (uint64_t *)(*(void *)(v6 + 24) + 16 * (a2 & 0x7FFFFFFF) + 8);
      }
      else {
        size_t v12 = (uint64_t *)(*(void *)(v6 + 272) + 8 * a2);
      }
      uint64_t v13 = *v12;
      if (*v12)
      {
        uint64_t v14 = *(void *)(v13 + 16);
        *(void *)(v13 + 16) = result;
        *(void *)(result + 16) = v14;
        if (*(unsigned char *)(result + 3))
        {
          *(void *)(result + 24) = v13;
        }
        else
        {
          *(void *)(result + 24) = 0;
          size_t v12 = (uint64_t *)(v14 + 24);
        }
      }
      else
      {
        *(void *)(result + 16) = result;
        *(void *)(result + 24) = 0;
      }
      *size_t v12 = result;
    }
    else
    {
      *(_DWORD *)(result + 4) = a2;
    }
  }
  return result;
}

uint64_t llvm::MachineOperand::substVirtReg(unsigned int *a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    LOWORD(v7) = a3;
    if (((*a1 >> 8) & 0xFFF) != 0)
    {
      int v7 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a4 + 208))(a4, a3);
      uint64_t result = llvm::MachineOperand::setReg((uint64_t)a1, a2);
      if (!v7) {
        return result;
      }
    }
    else
    {
      uint64_t result = llvm::MachineOperand::setReg((uint64_t)a1, a2);
    }
    *a1 = *a1 & 0xFFF000FF | ((v7 & 0xFFF) << 8);
    return result;
  }

  return llvm::MachineOperand::setReg((uint64_t)a1, a2);
}

uint64_t llvm::MachineOperand::substPhysReg(unsigned int *a1, unsigned int SubReg, uint64_t a3)
{
  int v4 = (*a1 >> 8) & 0xFFF;
  if (v4)
  {
    SubReg = llvm::MCRegisterInfo::getSubReg((void *)(a3 + 8), SubReg, v4);
    unsigned int v6 = *a1;
    *a1 &= 0xFFF000FF;
    if ((v6 & 0x1000000) != 0) {
      *a1 = v6 & 0xEFF000FF;
    }
  }

  return llvm::MachineOperand::setReg((uint64_t)a1, SubReg);
}

uint64_t llvm::MachineOperand::setIsDef(uint64_t this, int a2)
{
  if (((((*(_DWORD *)this & 0x1000000) == 0) ^ a2) & 1) == 0)
  {
    uint64_t v2 = *(void *)(this + 8);
    if (v2 && (v3 = *(void *)(v2 + 24)) != 0 && (uint64_t v4 = *(void *)(v3 + 32)) != 0)
    {
      uint64_t v5 = *(void *)(v4 + 40);
      uint64_t v6 = *(unsigned int *)(this + 4);
      if ((v6 & 0x80000000) != 0) {
        int v7 = (uint64_t *)(*(void *)(v5 + 24) + 16 * (v6 & 0x7FFFFFFF) + 8);
      }
      else {
        int v7 = (uint64_t *)(*(void *)(v5 + 272) + 8 * v6);
      }
      uint64_t v8 = *v7;
      uint64_t v10 = *(void *)(this + 16);
      uint64_t v9 = *(void *)(this + 24);
      if (*v7 != this) {
        int v7 = (uint64_t *)(v10 + 24);
      }
      *int v7 = v9;
      if (v9) {
        uint64_t v11 = v9;
      }
      else {
        uint64_t v11 = v8;
      }
      *(void *)(v11 + 16) = v10;
      *(void *)(this + 16) = 0;
      *(void *)(this + 24) = 0;
      if (a2) {
        int v12 = 0x1000000;
      }
      else {
        int v12 = 0;
      }
      uint64_t v13 = *(unsigned int *)(this + 4);
      *(_DWORD *)this = *(_DWORD *)this & 0xFEFFFFFF | v12;
      if ((v13 & 0x80000000) != 0) {
        uint64_t v14 = (uint64_t *)(*(void *)(v5 + 24) + 16 * (v13 & 0x7FFFFFFF) + 8);
      }
      else {
        uint64_t v14 = (uint64_t *)(*(void *)(v5 + 272) + 8 * v13);
      }
      uint64_t v15 = *v14;
      if (*v14)
      {
        uint64_t v16 = *(void *)(v15 + 16);
        *(void *)(v15 + 16) = this;
        *(void *)(this + 16) = v16;
        if (*(unsigned char *)(this + 3))
        {
          *(void *)(this + 24) = v15;
        }
        else
        {
          *(void *)(this + 24) = 0;
          uint64_t v14 = (uint64_t *)(v16 + 24);
        }
      }
      else
      {
        *(void *)(this + 16) = this;
        *(void *)(this + 24) = 0;
      }
      *uint64_t v14 = this;
    }
    else
    {
      if (a2) {
        int v17 = 0x1000000;
      }
      else {
        int v17 = 0;
      }
      *(_DWORD *)this = *(_DWORD *)this & 0xFEFFFFFF | v17;
    }
  }
  return this;
}

BOOL llvm::MachineOperand::isRenamable(llvm::MachineOperand *this)
{
  if ((*(_DWORD *)this & 0x8000000) == 0) {
    return 0;
  }
  uint64_t v1 = *((void *)this + 1);
  if (!v1) {
    return 1;
  }
  uint64_t v2 = *(void *)(*(void *)(v1 + 16) + 8);
  if ((*(_DWORD *)this & 0x1000000) != 0) {
    return (v2 & 0x100000000) == 0;
  }
  else {
    return (int)v2 >= 0;
  }
}

unsigned int *llvm::MachineOperand::setIsRenamable(unsigned int *this, int a2)
{
  if (a2) {
    int v2 = 0x8000000;
  }
  else {
    int v2 = 0;
  }
  *this = *this & 0xF7FFFFFF | v2;
  return this;
}

llvm::MachineOperand *llvm::MachineOperand::removeRegFromUses(llvm::MachineOperand *this)
{
  if (!*(unsigned char *)this)
  {
    if (*((void *)this + 2))
    {
      uint64_t v1 = *((void *)this + 1);
      if (v1)
      {
        uint64_t v2 = *(void *)(v1 + 24);
        if (v2)
        {
          uint64_t v3 = *(void *)(v2 + 32);
          if (v3) {
            return (llvm::MachineOperand *)llvm::MachineRegisterInfo::removeRegOperandFromUseList(*(void *)(v3 + 40), this);
          }
        }
      }
    }
  }
  return this;
}

unsigned int *llvm::MachineOperand::ChangeToImmediate(unsigned int *this, uint64_t a2, __int16 a3)
{
  unsigned int v3 = *this;
  if (!*this)
  {
    uint64_t v4 = *((void *)this + 2);
    if (v4)
    {
      uint64_t v5 = *((void *)this + 1);
      if (v5)
      {
        uint64_t v6 = *(void *)(v5 + 24);
        if (v6)
        {
          uint64_t v7 = *(void *)(v6 + 32);
          if (v7)
          {
            uint64_t v8 = *(void *)(v7 + 40);
            uint64_t v9 = this[1];
            if ((v9 & 0x80000000) != 0) {
              uint64_t v10 = (uint64_t *)(*(void *)(v8 + 24) + 16 * (v9 & 0x7FFFFFFF) + 8);
            }
            else {
              uint64_t v10 = (uint64_t *)(*(void *)(v8 + 272) + 8 * v9);
            }
            uint64_t v11 = (int *)*v10;
            int v12 = (int *)*((void *)this + 3);
            if ((unsigned int *)*v10 != this) {
              uint64_t v10 = (uint64_t *)(v4 + 24);
            }
            *uint64_t v10 = (uint64_t)v12;
            if (v12) {
              uint64_t v13 = v12;
            }
            else {
              uint64_t v13 = v11;
            }
            *((void *)v13 + 2) = v4;
            *((void *)this + 3) = 0;
            unsigned int v3 = *this;
          }
        }
      }
    }
  }
  *((void *)this + 2) = a2;
  *this = v3 & 0xFFF00000 | ((a3 & 0xFFF) << 8) | 1;
  return this;
}

unsigned int *llvm::MachineOperand::ChangeToFPImmediate(unsigned int *result, uint64_t a2, __int16 a3)
{
  unsigned int v3 = *result;
  if (!*result)
  {
    uint64_t v4 = *((void *)result + 2);
    if (v4)
    {
      uint64_t v5 = *((void *)result + 1);
      if (v5)
      {
        uint64_t v6 = *(void *)(v5 + 24);
        if (v6)
        {
          uint64_t v7 = *(void *)(v6 + 32);
          if (v7)
          {
            uint64_t v8 = *(void *)(v7 + 40);
            uint64_t v9 = result[1];
            if ((v9 & 0x80000000) != 0) {
              uint64_t v10 = (uint64_t *)(*(void *)(v8 + 24) + 16 * (v9 & 0x7FFFFFFF) + 8);
            }
            else {
              uint64_t v10 = (uint64_t *)(*(void *)(v8 + 272) + 8 * v9);
            }
            uint64_t v11 = (int *)*v10;
            int v12 = (int *)*((void *)result + 3);
            if ((unsigned int *)*v10 != result) {
              uint64_t v10 = (uint64_t *)(v4 + 24);
            }
            *uint64_t v10 = (uint64_t)v12;
            if (v12) {
              uint64_t v13 = v12;
            }
            else {
              uint64_t v13 = v11;
            }
            *((void *)v13 + 2) = v4;
            *((void *)result + 3) = 0;
            unsigned int v3 = *result;
          }
        }
      }
    }
  }
  *((void *)result + 2) = a2;
  *uint64_t result = v3 & 0xFFF00000 | ((a3 & 0xFFF) << 8) | 3;
  return result;
}

int *llvm::MachineOperand::ChangeToES(int *this, const char *a2, __int16 a3)
{
  int v3 = *this;
  if (!*this)
  {
    uint64_t v4 = *((void *)this + 2);
    if (v4)
    {
      uint64_t v5 = *((void *)this + 1);
      if (v5)
      {
        uint64_t v6 = *(void *)(v5 + 24);
        if (v6)
        {
          uint64_t v7 = *(void *)(v6 + 32);
          if (v7)
          {
            uint64_t v8 = *(void *)(v7 + 40);
            uint64_t v9 = this[1];
            if ((v9 & 0x80000000) != 0) {
              uint64_t v10 = (uint64_t *)(*(void *)(v8 + 24) + 16 * (v9 & 0x7FFFFFFF) + 8);
            }
            else {
              uint64_t v10 = (uint64_t *)(*(void *)(v8 + 272) + 8 * v9);
            }
            uint64_t v11 = (int *)*v10;
            int v12 = (int *)*((void *)this + 3);
            if ((int *)*v10 != this) {
              uint64_t v10 = (uint64_t *)(v4 + 24);
            }
            *uint64_t v10 = (uint64_t)v12;
            if (v12) {
              uint64_t v13 = v12;
            }
            else {
              uint64_t v13 = v11;
            }
            *((void *)v13 + 2) = v4;
            *((void *)this + 3) = 0;
            int v3 = *this;
          }
        }
      }
    }
  }
  *((void *)this + 2) = a2;
  this[6] = 0;
  *(void *)this = v3 & 0xFFF00000 | ((a3 & 0xFFF) << 8) | 9;
  return this;
}